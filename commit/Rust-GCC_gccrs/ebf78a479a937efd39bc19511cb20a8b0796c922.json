{"sha": "ebf78a479a937efd39bc19511cb20a8b0796c922", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJmNzhhNDc5YTkzN2VmZDM5YmMxOTUxMWNiMjBhOGIwNzk2YzkyMg==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2006-03-28T04:19:26Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2006-03-28T04:19:26Z"}, "message": "tree-loop-linear.c: Don't include varray.h.\n\n\t* tree-loop-linear.c: Don't include varray.h.\n\t(gather_interchange_stats, try_interchange_loops,\n\tlinear_transform_loops): Use VEC instead of VARRAY.\n\t* lambda-mat.c: Don't include varray.h.\n\t* tree-chrec.c: Same.\n\t* lambda-trans.c: Same.\n\t* tree-vectorizer.c (new_loop_vec_info, destroy_loop_vec_info): Use\n\tVEC instead of VARRAY.\n\t* tree-vectorizer.h: Idem.\n\t* tree-data-ref.c (dump_data_references,\n\tdump_data_dependence_relations, dump_dist_dir_vectors, dump_ddrs,\n\tinitialize_data_dependence_relation, finalize_ddr_dependent,\n\tcompute_all_dependences, find_data_references_in_loop,\n\tcompute_data_dependences_for_loop, analyze_all_data_dependences,\n\tfree_dependence_relation, free_dependence_relations,\n\tfree_data_refs): Idem.\n\t* tree-data-ref.h (data_reference_p, subscript_p): New.\n\t(data_dependence_relation, DDR_SUBSCRIPT, DDR_NUM_SUBSCRIPTS): Use\n\tVEC instead of VARRAY.\n\t(DDR_SUBSCRIPTS_VECTOR_INIT): Removed.\n\t(find_data_references_in_loop, compute_data_dependences_for_loop,\n\tdump_ddrs, dump_dist_dir_vectors, dump_data_references,\n\tdump_data_dependence_relations, free_dependence_relations,\n\tfree_data_refs): Adjust declaration.\n\t(lambda_transform_legal_p): Move declaration here...\n\t* tree-vect-analyze.c (vect_analyze_data_ref_dependences,\n\tvect_compute_data_refs_alignment, vect_verify_datarefs_alignment,\n\tvect_enhance_data_refs_alignment, vect_analyze_data_ref_accesses,\n\tvect_analyze_data_refs): Use VEC instead of VARRAY.\n\t* lambda.h (lambda_transform_legal_p): ...from here.\n\t* lambda-code.c (lambda_transform_legal_p): Use VEC instead of VARRAY.\n\t* tree-vect-transform.c (vect_update_inits_of_drs): Idem.\n\t* Makefile.in (tree-loop-linear.o, lambda-mat.o, lambda-trans.o,\n\ttree-chrec.o): Don't depend on VARRAY_H.\n\nFrom-SVN: r112437", "tree": {"sha": "29bb0dc8b58695cd2522e866ebb0a5c9b775a9e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29bb0dc8b58695cd2522e866ebb0a5c9b775a9e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebf78a479a937efd39bc19511cb20a8b0796c922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf78a479a937efd39bc19511cb20a8b0796c922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf78a479a937efd39bc19511cb20a8b0796c922", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf78a479a937efd39bc19511cb20a8b0796c922/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d73a40911175532999ff6fdaf7a5223871aefb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d73a40911175532999ff6fdaf7a5223871aefb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d73a40911175532999ff6fdaf7a5223871aefb0"}], "stats": {"total": 540, "additions": 254, "deletions": 286}, "files": [{"sha": "b8a8a7d59fab11bd7518d41ec20bc905e62d4d19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -1,3 +1,40 @@\n+2006-03-27  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-loop-linear.c: Don't include varray.h.\n+\t(gather_interchange_stats, try_interchange_loops,\n+\tlinear_transform_loops): Use VEC instead of VARRAY.\n+\t* lambda-mat.c: Don't include varray.h.\n+\t* tree-chrec.c: Same.\n+\t* lambda-trans.c: Same.\n+\t* tree-vectorizer.c (new_loop_vec_info, destroy_loop_vec_info): Use\n+\tVEC instead of VARRAY.\n+\t* tree-vectorizer.h: Idem.\n+\t* tree-data-ref.c (dump_data_references,\n+\tdump_data_dependence_relations, dump_dist_dir_vectors, dump_ddrs,\n+\tinitialize_data_dependence_relation, finalize_ddr_dependent,\n+\tcompute_all_dependences, find_data_references_in_loop,\n+\tcompute_data_dependences_for_loop, analyze_all_data_dependences,\n+\tfree_dependence_relation, free_dependence_relations,\n+\tfree_data_refs): Idem.\n+\t* tree-data-ref.h (data_reference_p, subscript_p): New.\n+\t(data_dependence_relation, DDR_SUBSCRIPT, DDR_NUM_SUBSCRIPTS): Use\n+\tVEC instead of VARRAY.\n+\t(DDR_SUBSCRIPTS_VECTOR_INIT): Removed.\n+\t(find_data_references_in_loop, compute_data_dependences_for_loop,\n+\tdump_ddrs, dump_dist_dir_vectors, dump_data_references,\n+\tdump_data_dependence_relations, free_dependence_relations,\n+\tfree_data_refs): Adjust declaration.\n+\t(lambda_transform_legal_p): Move declaration here...\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_dependences,\n+\tvect_compute_data_refs_alignment, vect_verify_datarefs_alignment,\n+\tvect_enhance_data_refs_alignment, vect_analyze_data_ref_accesses,\n+\tvect_analyze_data_refs): Use VEC instead of VARRAY.\n+\t* lambda.h (lambda_transform_legal_p): ...from here.\n+\t* lambda-code.c (lambda_transform_legal_p): Use VEC instead of VARRAY.\n+\t* tree-vect-transform.c (vect_update_inits_of_drs): Idem.\n+\t* Makefile.in (tree-loop-linear.o, lambda-mat.o, lambda-trans.o,\n+\ttree-chrec.o): Don't depend on VARRAY_H.\n+\n 2006-03-27  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \t* rtl.def (Copyright): Update date."}, {"sha": "234247ba6a3c443183caecfaf3d6cbd7d0cf02bd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -2046,7 +2046,7 @@ tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TM_H) coretypes.h\n tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(REAL_H) $(SCEV_H) tree-pass.h $(PARAMS_H) \\\n-   $(DIAGNOSTIC_H) $(VARRAY_H) $(CFGLOOP_H) $(TREE_FLOW_H)\n+   $(DIAGNOSTIC_H) $(CFGLOOP_H) $(TREE_FLOW_H)\n tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(REAL_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n@@ -2078,7 +2078,7 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) $(LAMBDA_H) \\\n-   $(TARGET_H) tree-chrec.h $(VARRAY_H)\n+   $(TARGET_H) tree-chrec.h\n tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FUNCTION_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \\\n    tree-stdarg.h $(TARGET_H) langhooks.h\n@@ -2582,9 +2582,9 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) \\\n    $(REAL_H) $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h timevar.h tree-pass.h\n lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n-   $(TM_H) coretypes.h $(TREE_H) $(VARRAY_H)\n+   $(TM_H) coretypes.h $(TREE_H)\n lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n-   $(TM_H) coretypes.h $(TARGET_H) $(TREE_H) $(VARRAY_H)\n+   $(TM_H) coretypes.h $(TARGET_H) $(TREE_H)\n lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n    $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\"}, {"sha": "8c8b1e5f342e4510dcf47853d0caba9bea03fbdc", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -2578,7 +2578,7 @@ perfect_nestify (struct loops *loops,\n bool\n lambda_transform_legal_p (lambda_trans_matrix trans, \n \t\t\t  int nb_loops,\n-\t\t\t  varray_type dependence_relations)\n+\t\t\t  VEC (ddr_p, heap) *dependence_relations)\n {\n   unsigned int i, j;\n   lambda_vector distres;\n@@ -2589,8 +2589,7 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n \n   /* When there is an unknown relation in the dependence_relations, we\n      know that it is no worth looking at this loop nest: give up.  */\n-  ddr = (struct data_dependence_relation *) \n-    VARRAY_GENERIC_PTR (dependence_relations, 0);\n+  ddr = VEC_index (ddr_p, dependence_relations, 0);\n   if (ddr == NULL)\n     return true;\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n@@ -2599,11 +2598,8 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n   distres = lambda_vector_new (nb_loops);\n \n   /* For each distance vector in the dependence graph.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n     {\n-      ddr = (struct data_dependence_relation *) \n-\tVARRAY_GENERIC_PTR (dependence_relations, i);     \n-\n       /* Don't care about relations for which we know that there is no\n \t dependence, nor about read-read (aka. output-dependences):\n \t these data accesses can happen in any order.  */"}, {"sha": "39b75e66f7300c2158d299013919ce54c0542029", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -23,7 +23,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n-#include \"varray.h\"\n #include \"tree.h\"\n #include \"lambda.h\"\n "}, {"sha": "aff2f1df0408ef1ce7e18c9abcd425321c777e96", "filename": "gcc/lambda-trans.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -26,7 +26,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"tree.h\"\n #include \"target.h\"\n-#include \"varray.h\"\n #include \"lambda.h\"\n \n /* Allocate a new transformation matrix.  */"}, {"sha": "fc5679a57634194e7b6b888cc3938257f8156a2e", "filename": "gcc/lambda.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -143,7 +143,6 @@ lambda_loopnest lambda_loopnest_transform (lambda_loopnest, lambda_trans_matrix)\n struct loop;\n struct loops;\n bool perfect_nest_p (struct loop *);\n-bool lambda_transform_legal_p (lambda_trans_matrix, int, varray_type);\n void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n \n #define lambda_loop_new() (lambda_loop) ggc_alloc_cleared (sizeof (struct lambda_loop_s))"}, {"sha": "3863e0870292792db76326d6b149190287a0dc30", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -32,7 +32,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree.h\"\n #include \"real.h\"\n #include \"diagnostic.h\"\n-#include \"varray.h\"\n #include \"cfgloop.h\"\n #include \"tree-flow.h\"\n #include \"tree-chrec.h\""}, {"sha": "7f9dc3274a053add925448a1c9e23118a744b237", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 109, "deletions": 151, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -526,25 +526,26 @@ int_divides_p (int a, int b)\n /* Dump into FILE all the data references from DATAREFS.  */ \n \n void \n-dump_data_references (FILE *file, \n-\t\t      varray_type datarefs)\n+dump_data_references (FILE *file, VEC (data_reference_p, heap) *datarefs)\n {\n   unsigned int i;\n-  \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-    dump_data_reference (file, VARRAY_GENERIC_PTR (datarefs, i));\n+  struct data_reference *dr;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    dump_data_reference (file, dr);\n }\n \n-/* Dump into FILE all the dependence relations from DDR.  */ \n+/* Dump into FILE all the dependence relations from DDRS.  */ \n \n void \n dump_data_dependence_relations (FILE *file, \n-\t\t\t\tvarray_type ddr)\n+\t\t\t\tVEC (ddr_p, heap) *ddrs)\n {\n   unsigned int i;\n-  \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddr); i++)\n-    dump_data_dependence_relation (file, VARRAY_GENERIC_PTR (ddr, i));\n+  struct data_dependence_relation *ddr;\n+\n+  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+    dump_data_dependence_relation (file, ddr);\n }\n \n /* Dump function for a DATA_REFERENCE structure.  */\n@@ -790,52 +791,44 @@ dump_data_dependence_direction (FILE *file,\n    considered nest.  */\n \n void \n-dump_dist_dir_vectors (FILE *file, varray_type ddrs)\n+dump_dist_dir_vectors (FILE *file, VEC (ddr_p, heap) *ddrs)\n {\n   unsigned int i, j;\n+  struct data_dependence_relation *ddr;\n+  lambda_vector v;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n-    {\n-      struct data_dependence_relation *ddr = \n-\t(struct data_dependence_relation *) \n-\tVARRAY_GENERIC_PTR (ddrs, i);\n-      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n-\t  && DDR_AFFINE_P (ddr))\n-\t{\n-\t  for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n-\t    {\n-\t      fprintf (file, \"DISTANCE_V (\");\n-\t      print_lambda_vector (file, DDR_DIST_VECT (ddr, j),\n-\t\t\t\t   DDR_NB_LOOPS (ddr));\n-\t      fprintf (file, \")\\n\");\n-\t    }\n+  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+    if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE && DDR_AFFINE_P (ddr))\n+      {\n+\tfor (j = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), j, v); j++)\n+\t  {\n+\t    fprintf (file, \"DISTANCE_V (\");\n+\t    print_lambda_vector (file, v, DDR_NB_LOOPS (ddr));\n+\t    fprintf (file, \")\\n\");\n+\t  }\n+\n+\tfor (j = 0; VEC_iterate (lambda_vector, DDR_DIR_VECTS (ddr), j, v); j++)\n+\t  {\n+\t    fprintf (file, \"DIRECTION_V (\");\n+\t    print_direction_vector (file, v, DDR_NB_LOOPS (ddr));\n+\t    fprintf (file, \")\\n\");\n+\t  }\n+      }\n \n-\t  for (j = 0; j < DDR_NUM_DIR_VECTS (ddr); j++)\n-\t    {\n-\t      fprintf (file, \"DIRECTION_V (\");\n-\t      print_direction_vector (file, DDR_DIR_VECT (ddr, j),\n-\t\t\t\t      DDR_NB_LOOPS (ddr));\n-\t      fprintf (file, \")\\n\");\n-\t    }\n-\t}\n-    }\n   fprintf (file, \"\\n\\n\");\n }\n \n /* Dumps the data dependence relations DDRS in FILE.  */\n \n void \n-dump_ddrs (FILE *file, varray_type ddrs)\n+dump_ddrs (FILE *file, VEC (ddr_p, heap) *ddrs)\n {\n   unsigned int i;\n+  struct data_dependence_relation *ddr;\n+\n+  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+    dump_data_dependence_relation (file, ddr);\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n-    {\n-      struct data_dependence_relation *ddr = \n-\t(struct data_dependence_relation *) \n-\tVARRAY_GENERIC_PTR (ddrs, i);\n-      dump_data_dependence_relation (file, ddr);\n-    }\n   fprintf (file, \"\\n\\n\");\n }\n \n@@ -2135,7 +2128,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n     \n   DDR_AFFINE_P (res) = true;\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n-  DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n+  DDR_SUBSCRIPTS (res) = VEC_alloc (subscript_p, heap, DR_NUM_DIMENSIONS (a));\n   DDR_LOOP_NEST (res) = loop_nest;\n   DDR_DIR_VECTS (res) = NULL;\n   DDR_DIST_VECTS (res) = NULL;\n@@ -2149,9 +2142,9 @@ initialize_data_dependence_relation (struct data_reference *a,\n       SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n       SUB_DISTANCE (subscript) = chrec_dont_know;\n-      VARRAY_PUSH_GENERIC_PTR (DDR_SUBSCRIPTS (res), subscript);\n+      VEC_safe_push (subscript_p, heap, DDR_SUBSCRIPTS (res), subscript);\n     }\n-  \n+\n   return res;\n }\n \n@@ -2170,7 +2163,7 @@ finalize_ddr_dependent (struct data_dependence_relation *ddr,\n     }\n \n   DDR_ARE_DEPENDENT (ddr) = chrec;  \n-  varray_clear (DDR_SUBSCRIPTS (ddr));\n+  VEC_free (subscript_p, heap, DDR_SUBSCRIPTS (ddr));\n }\n \n /* The dependence relation DDR cannot be represented by a distance\n@@ -3776,33 +3769,34 @@ subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n {\n   unsigned int i;\n   tree last_conflicts;\n+  struct subscript *subscript;\n \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+  for (i = 0; VEC_iterate (subscript_p, DDR_SUBSCRIPTS (ddr), i, subscript);\n+       i++)\n     {\n       tree overlaps_a, overlaps_b;\n-      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n-      \n+\n       analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n \t\t\t\t      DR_ACCESS_FN (drb, i),\n \t\t\t\t      &overlaps_a, &overlaps_b, \n \t\t\t\t      &last_conflicts);\n-      \n+\n       if (chrec_contains_undetermined (overlaps_a)\n  \t  || chrec_contains_undetermined (overlaps_b))\n  \t{\n  \t  finalize_ddr_dependent (ddr, chrec_dont_know);\n \t  dependence_stats.num_dependence_undetermined++;\n \t  return false;\n  \t}\n-      \n+\n       else if (overlaps_a == chrec_known\n  \t       || overlaps_b == chrec_known)\n  \t{\n  \t  finalize_ddr_dependent (ddr, chrec_known);\n \t  dependence_stats.num_dependence_independent++;\n \t  return false;\n  \t}\n-      \n+\n       else\n  \t{\n  \t  SUB_CONFLICTS_IN_A (subscript) = overlaps_a;\n@@ -3916,11 +3910,11 @@ static void\n compute_self_dependence (struct data_dependence_relation *ddr)\n {\n   unsigned int i;\n+  struct subscript *subscript;\n \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+  for (i = 0; VEC_iterate (subscript_p, DDR_SUBSCRIPTS (ddr), i, subscript);\n+       i++)\n     {\n-      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n-      \n       /* The accessed index overlaps for each iteration.  */\n       SUB_CONFLICTS_IN_A (subscript) = integer_zero_node;\n       SUB_CONFLICTS_IN_B (subscript) = integer_zero_node;\n@@ -3934,53 +3928,35 @@ compute_self_dependence (struct data_dependence_relation *ddr)\n \n /* Compute in DEPENDENCE_RELATIONS the data dependence graph for all\n    the data references in DATAREFS, in the LOOP_NEST.  When\n-   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is FALSE, don't compute\n-   read-read and self relations.  */\n+   COMPUTE_SELF_AND_RR is FALSE, don't compute read-read and self\n+   relations.  */\n \n static void \n-compute_all_dependences (varray_type datarefs,\n-\t\t\t VEC(ddr_p,heap) **dependence_relations,\n+compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n+\t\t\t VEC (ddr_p, heap) *dependence_relations,\n \t\t\t VEC (loop_p, heap) *loop_nest,\n-\t\t\t bool compute_self_and_read_read_dependences)\n+\t\t\t bool compute_self_and_rr)\n {\n-  unsigned int i, j, N = VARRAY_ACTIVE_SIZE (datarefs);\n+  struct data_dependence_relation *ddr;\n+  struct data_reference *a, *b;\n+  unsigned int i, j;\n \n-  /* Note that we specifically skip i == j because it's a self dependence, and\n-     use compute_self_dependence below.  */\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, a); i++)\n+    for (j = i + 1; VEC_iterate (data_reference_p, datarefs, j, b); j++)\n+      if (!DR_IS_READ (a) || !DR_IS_READ (b) || compute_self_and_rr)\n+\t{\n+\t  ddr = initialize_data_dependence_relation (a, b, loop_nest);\n+\t  VEC_safe_push (ddr_p, heap, dependence_relations, ddr);\n+\t  compute_affine_dependence (ddr);\n+\t}\n \n-  for (i = 0; i < N; i++)\n-    for (j = i + 1; j < N; j++)\n+  if (compute_self_and_rr)\n+    for (i = 0; VEC_iterate (data_reference_p, datarefs, i, a); i++)\n       {\n-\tstruct data_reference *a, *b;\n-\tstruct data_dependence_relation *ddr;\n-\n-\ta = VARRAY_GENERIC_PTR (datarefs, i);\n-\tb = VARRAY_GENERIC_PTR (datarefs, j);\n-\n-\tif (DR_IS_READ (a) && DR_IS_READ (b)\n-            && !compute_self_and_read_read_dependences)\n-\t  continue;\n-\n-\tddr = initialize_data_dependence_relation (a, b, loop_nest);\n-\tVEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-\tcompute_affine_dependence (ddr);\n+\tddr = initialize_data_dependence_relation (a, a, loop_nest);\n+\tVEC_safe_push (ddr_p, heap, dependence_relations, ddr);\n+\tcompute_self_dependence (ddr);\n       }\n-\n-  if (!compute_self_and_read_read_dependences)\n-    return;\n-\n-  /* Compute self dependence relation of each dataref to itself.  */\n-  for (i = 0; i < N; i++)\n-    {\n-      struct data_reference *a, *b;\n-      struct data_dependence_relation *ddr;\n-\n-      a = VARRAY_GENERIC_PTR (datarefs, i);\n-      b = VARRAY_GENERIC_PTR (datarefs, i);\n-      ddr = initialize_data_dependence_relation (a, b, loop_nest);\n-      VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-      compute_self_dependence (ddr);\n-    }\n }\n \n /* Search the data references in LOOP, and record the information into\n@@ -3991,7 +3967,8 @@ compute_all_dependences (varray_type datarefs,\n    arithmetic as if they were array accesses, etc.  */\n \n tree \n-find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n+find_data_references_in_loop (struct loop *loop,\n+\t\t\t      VEC (data_reference_p, heap) *datarefs)\n {\n   basic_block bb, *bbs;\n   unsigned int i;\n@@ -4035,7 +4012,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t    dr = create_data_ref (opnd0, stmt, false);\n \t\t    if (dr) \n \t\t      {\n-\t\t\tVARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n+\t\t\tVEC_safe_push (data_reference_p, heap, datarefs, dr);\n \t\t\tone_inserted = true;\n \t\t      }\n \t\t  }\n@@ -4047,7 +4024,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t    dr = create_data_ref (opnd1, stmt, true);\n \t\t    if (dr) \n \t\t      {\n-\t\t\tVARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n+\t\t\tVEC_safe_push (data_reference_p, heap, datarefs, dr);\n \t\t\tone_inserted = true;\n \t\t      }\n \t\t  }\n@@ -4072,7 +4049,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t      dr = create_data_ref (TREE_VALUE (args), stmt, true);\n \t\t      if (dr)\n \t\t\t{\n-\t\t\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n+\t\t\t  VEC_safe_push (data_reference_p, heap, datarefs, dr);\n \t\t\t  one_inserted = true;\n \t\t\t}\n \t\t    }\n@@ -4103,7 +4080,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n \t\t  DR_MEMTAG (res) = NULL_TREE;\n \t\t  DR_PTR_INFO (res) = NULL;\n-\t\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, res);\n+\t\t  VEC_safe_push (data_reference_p, heap, datarefs, res);\n \n \t\t  free (bbs);\n \t\t  return chrec_dont_know;\n@@ -4164,20 +4141,17 @@ find_loop_nest (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n }\n \n /* Given a loop nest LOOP, the following vectors are returned:\n-   *DATAREFS is initialized to all the array elements contained in this loop, \n-   *DEPENDENCE_RELATIONS contains the relations between the data references.  \n+   DATAREFS is initialized to all the array elements contained in this loop, \n+   DEPENDENCE_RELATIONS contains the relations between the data references.  \n    Compute read-read and self relations if \n    COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */\n \n void\n compute_data_dependences_for_loop (struct loop *loop, \n \t\t\t\t   bool compute_self_and_read_read_dependences,\n-\t\t\t\t   varray_type *datarefs,\n-\t\t\t\t   varray_type *dependence_relations)\n+\t\t\t\t   VEC (data_reference_p, heap) *datarefs,\n+\t\t\t\t   VEC (ddr_p, heap) *dependence_relations)\n {\n-  unsigned int i;\n-  VEC(ddr_p,heap) *allrelations;\n-  struct data_dependence_relation *ddr;\n   struct loop *loop_nest = loop;\n   VEC (loop_p, heap) *vloops = VEC_alloc (loop_p, heap, 3);\n \n@@ -4195,20 +4169,11 @@ compute_data_dependences_for_loop (struct loop *loop,\n       /* Insert a single relation into dependence_relations:\n \t chrec_dont_know.  */\n       ddr = initialize_data_dependence_relation (NULL, NULL, vloops);\n-      VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+      VEC_safe_push (ddr_p, heap, dependence_relations, ddr);\n     }\n   else\n-    {\n-      allrelations = NULL;\n-      compute_all_dependences (*datarefs, &allrelations, vloops,\n-\t\t\t       compute_self_and_read_read_dependences);\n-\t\t\t       \n-\n-      /* FIXME: We copy the contents of allrelations back to a VARRAY\n-\t because the vectorizer has not yet been converted to use VECs.  */\n-      for (i = 0; VEC_iterate (ddr_p, allrelations, i, ddr); i++)\n-\tVARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-    }\n+    compute_all_dependences (datarefs, dependence_relations, vloops,\n+\t\t\t     compute_self_and_read_read_dependences);\n \n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n@@ -4285,18 +4250,15 @@ static void\n analyze_all_data_dependences (struct loops *loops)\n {\n   unsigned int i;\n-  varray_type datarefs;\n-  varray_type dependence_relations;\n   int nb_data_refs = 10;\n-\n-  VARRAY_GENERIC_PTR_INIT (datarefs, nb_data_refs, \"datarefs\");\n-  VARRAY_GENERIC_PTR_INIT (dependence_relations, \n-\t\t\t   nb_data_refs * nb_data_refs,\n-\t\t\t   \"dependence_relations\");\n+  VEC (data_reference_p, heap) *datarefs = \n+    VEC_alloc (data_reference_p, heap, nb_data_refs);\n+  VEC (ddr_p, heap) *dependence_relations = \n+    VEC_alloc (ddr_p, heap, nb_data_refs * nb_data_refs);\n \n   /* Compute DDs on the whole function.  */\n   compute_data_dependences_for_loop (loops->parray[0], false,\n-\t\t\t\t     &datarefs, &dependence_relations);\n+\t\t\t\t     datarefs, dependence_relations);\n \n   if (dump_file)\n     {\n@@ -4312,12 +4274,10 @@ analyze_all_data_dependences (struct loops *loops)\n \t  unsigned nb_bot_relations = 0;\n \t  unsigned nb_basename_differ = 0;\n \t  unsigned nb_chrec_relations = 0;\n+\t  struct data_dependence_relation *ddr;\n \n-\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+\t  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n \t    {\n-\t      struct data_dependence_relation *ddr;\n-\t      ddr = VARRAY_GENERIC_PTR (dependence_relations, i);\n-\t  \n \t      if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n \t\tnb_top_relations++;\n \t  \n@@ -4358,45 +4318,43 @@ free_dependence_relation (struct data_dependence_relation *ddr)\n     return;\n \n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE && DDR_SUBSCRIPTS (ddr))\n-    varray_clear (DDR_SUBSCRIPTS (ddr));\n+    VEC_free (subscript_p, heap, DDR_SUBSCRIPTS (ddr));\n+\n   free (ddr);\n }\n \n /* Free the memory used by the data dependence relations from\n    DEPENDENCE_RELATIONS.  */\n \n void \n-free_dependence_relations (varray_type dependence_relations)\n+free_dependence_relations (VEC (ddr_p, heap) *dependence_relations)\n {\n   unsigned int i;\n-  if (dependence_relations == NULL)\n-    return;\n+  struct data_dependence_relation *ddr;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n-    free_dependence_relation (VARRAY_GENERIC_PTR (dependence_relations, i));\n-  varray_clear (dependence_relations);\n+  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+    free_dependence_relation (ddr);\n+\n+  VEC_free (ddr_p, heap, dependence_relations);\n }\n \n /* Free the memory used by the data references from DATAREFS.  */\n \n void\n-free_data_refs (varray_type datarefs)\n+free_data_refs (VEC (data_reference_p, heap) *datarefs)\n {\n   unsigned int i;\n-  \n-  if (datarefs == NULL)\n-    return;\n+  struct data_reference *dr;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n-      struct data_reference *dr = (struct data_reference *) \n-\tVARRAY_GENERIC_PTR (datarefs, i);\n-      if (dr)\n-\t{\n-\t  DR_FREE_ACCESS_FNS (dr);\n-\t  free (dr);\n-\t}\n+      if (DR_TYPE(dr) == ARRAY_REF_TYPE)\n+\tVEC_free (tree, heap, (dr)->object_info.access_fns);\n+      else\n+\tVEC_free (tree, heap, (dr)->first_location.access_fns);\n+\n+      free (dr);\n     }\n-  varray_clear (datarefs);\n+  VEC_free (data_reference_p, heap, datarefs);\n }\n "}, {"sha": "c5976f982dc0d24888d816b0258f3e42bd5613b9", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -107,6 +107,10 @@ struct data_reference\n   enum data_ref_type type;\n };\n \n+typedef struct data_reference *data_reference_p;\n+DEF_VEC_P(data_reference_p);\n+DEF_VEC_ALLOC_P (data_reference_p, heap);\n+\n #define DR_STMT(DR)                (DR)->stmt\n #define DR_REF(DR)                 (DR)->ref\n #define DR_BASE_OBJECT(DR)         (DR)->object_info.base_object\n@@ -181,6 +185,10 @@ struct subscript\n   tree distance;\n };\n \n+typedef struct subscript *subscript_p;\n+DEF_VEC_P(subscript_p);\n+DEF_VEC_ALLOC_P (subscript_p, heap);\n+\n #define SUB_CONFLICTS_IN_A(SUB) SUB->conflicting_iterations_in_a\n #define SUB_CONFLICTS_IN_B(SUB) SUB->conflicting_iterations_in_b\n #define SUB_LAST_CONFLICT(SUB) SUB->last_conflict\n@@ -219,16 +227,16 @@ struct data_dependence_relation\n   /* For each subscript in the dependence test, there is an element in\n      this array.  This is the attribute that labels the edge A->B of\n      the data_dependence_relation.  */\n-  varray_type subscripts;\n+  VEC (subscript_p, heap) *subscripts;\n \n   /* The analyzed loop nest.  */\n   VEC (loop_p, heap) *loop_nest;\n \n   /* The classic direction vector.  */\n-  VEC(lambda_vector,heap) *dir_vects;\n+  VEC (lambda_vector, heap) *dir_vects;\n \n   /* The classic distance vector.  */\n-  VEC(lambda_vector,heap) *dist_vects;\n+  VEC (lambda_vector, heap) *dist_vects;\n };\n \n typedef struct data_dependence_relation *ddr_p;\n@@ -240,10 +248,8 @@ DEF_VEC_ALLOC_P(ddr_p,heap);\n #define DDR_AFFINE_P(DDR) DDR->affine_p\n #define DDR_ARE_DEPENDENT(DDR) DDR->are_dependent\n #define DDR_SUBSCRIPTS(DDR) DDR->subscripts\n-#define DDR_SUBSCRIPTS_VECTOR_INIT(DDR, N) \\\n-  VARRAY_GENERIC_PTR_INIT (DDR_SUBSCRIPTS (DDR), N, \"subscripts_vector\");\n-#define DDR_SUBSCRIPT(DDR, I) VARRAY_GENERIC_PTR (DDR_SUBSCRIPTS (DDR), I)\n-#define DDR_NUM_SUBSCRIPTS(DDR) VARRAY_ACTIVE_SIZE (DDR_SUBSCRIPTS (DDR))\n+#define DDR_SUBSCRIPT(DDR, I) VEC_index (subscript_p, DDR_SUBSCRIPTS (DDR), I)\n+#define DDR_NUM_SUBSCRIPTS(DDR) VEC_length (subscript_p, DDR_SUBSCRIPTS (DDR))\n \n #define DDR_LOOP_NEST(DDR) DDR->loop_nest\n /* The size of the direction/distance vectors: the number of loops in\n@@ -263,29 +269,32 @@ DEF_VEC_ALLOC_P(ddr_p,heap);\n \n \f\n \n-extern tree find_data_references_in_loop (struct loop *, varray_type *);\n+extern tree find_data_references_in_loop (struct loop *,\n+\t\t\t\t\t  VEC (data_reference_p, heap) *);\n extern void compute_data_dependences_for_loop (struct loop *, bool,\n-\t\t\t\t\t       varray_type *, varray_type *);\n+\t\t\t\t\t       VEC (data_reference_p, heap) *,\n+\t\t\t\t\t       VEC (ddr_p, heap) *);\n extern void print_direction_vector (FILE *, lambda_vector, int);\n extern void print_dir_vectors (FILE *, VEC (lambda_vector, heap) *, int);\n extern void print_dist_vectors (FILE *, VEC (lambda_vector, heap) *, int);\n extern void dump_subscript (FILE *, struct subscript *);\n-extern void dump_ddrs (FILE *, varray_type);\n-extern void dump_dist_dir_vectors (FILE *, varray_type);\n+extern void dump_ddrs (FILE *, VEC (ddr_p, heap) *);\n+extern void dump_dist_dir_vectors (FILE *, VEC (ddr_p, heap) *);\n extern void dump_data_reference (FILE *, struct data_reference *);\n-extern void dump_data_references (FILE *, varray_type);\n+extern void dump_data_references (FILE *, VEC (data_reference_p, heap) *);\n extern void debug_data_dependence_relation (struct data_dependence_relation *);\n extern void dump_data_dependence_relation (FILE *, \n \t\t\t\t\t   struct data_dependence_relation *);\n-extern void dump_data_dependence_relations (FILE *, varray_type);\n+extern void dump_data_dependence_relations (FILE *, VEC (ddr_p, heap) *);\n extern void dump_data_dependence_direction (FILE *, \n \t\t\t\t\t    enum data_dependence_direction);\n extern void free_dependence_relation (struct data_dependence_relation *);\n-extern void free_dependence_relations (varray_type);\n-extern void free_data_refs (varray_type);\n+extern void free_dependence_relations (VEC (ddr_p, heap) *);\n+extern void free_data_refs (VEC (data_reference_p, heap) *);\n extern struct data_reference *analyze_array (tree, tree, bool);\n extern void estimate_iters_using_array (tree, tree);\n \n+\n /* Return the index of the variable VAR in the LOOP_NEST array.  */\n \n static inline int\n@@ -302,6 +311,7 @@ index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n   return var_index;\n }\n \n-\f\n+/* In lambda-code.c  */\n+bool lambda_transform_legal_p (lambda_trans_matrix, int, VEC (ddr_p, heap) *);\n \n #endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "a47981c94d02cc932848d4727d58ed1e4f0a3a2c", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -41,7 +41,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n-#include \"varray.h\"\n #include \"lambda.h\"\n \n /* Linear loop transforms include any composition of interchange,\n@@ -90,26 +89,24 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n */\n \n static void\n-gather_interchange_stats (varray_type dependence_relations, \n-\t\t\t  varray_type datarefs,\n+gather_interchange_stats (VEC (ddr_p, heap) *dependence_relations,\n+\t\t\t  VEC (data_reference_p, heap) *datarefs,\n \t\t\t  struct loop *loop,\n \t\t\t  struct loop *first_loop,\n \t\t\t  unsigned int *dependence_steps, \n \t\t\t  unsigned int *nb_deps_not_carried_by_loop, \n \t\t\t  unsigned int *access_strides)\n {\n   unsigned int i, j;\n+  struct data_dependence_relation *ddr;\n+  struct data_reference *dr;\n \n   *dependence_steps = 0;\n   *nb_deps_not_carried_by_loop = 0;\n   *access_strides = 0;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n     {\n-      struct data_dependence_relation *ddr = \n-\t(struct data_dependence_relation *) \n-\tVARRAY_GENERIC_PTR (dependence_relations, i);\n-\n       /* If we don't know anything about this dependence, or the distance\n \t vector is NULL, or there is no dependence, then there is no reuse of\n \t data.  */\n@@ -134,10 +131,9 @@ gather_interchange_stats (varray_type dependence_relations,\n     }\n \n   /* Compute the access strides.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n       unsigned int it;\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       tree stmt = DR_STMT (dr);\n       struct loop *stmt_loop = loop_containing_stmt (stmt);\n       struct loop *inner_loop = first_loop->inner;\n@@ -171,8 +167,8 @@ gather_interchange_stats (varray_type dependence_relations,\n static lambda_trans_matrix\n try_interchange_loops (lambda_trans_matrix trans, \n \t\t       unsigned int depth,\t\t       \n-\t\t       varray_type dependence_relations,\n-\t\t       varray_type datarefs, \n+\t\t       VEC (ddr_p, heap) *dependence_relations,\n+\t\t       VEC (data_reference_p, heap) *datarefs,\n \t\t       struct loop *first_loop)\n {\n   struct loop *loop_i;\n@@ -184,8 +180,7 @@ try_interchange_loops (lambda_trans_matrix trans,\n \n   /* When there is an unknown relation in the dependence_relations, we\n      know that it is no worth looking at this loop nest: give up.  */\n-  ddr = (struct data_dependence_relation *) \n-    VARRAY_GENERIC_PTR (dependence_relations, 0);\n+  ddr = VEC_index (ddr_p, dependence_relations, 0);\n   if (ddr == NULL || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     return trans;\n   \n@@ -250,8 +245,8 @@ linear_transform_loops (struct loops *loops)\n   for (i = 1; i < loops->num; i++)\n     {\n       unsigned int depth = 0;\n-      varray_type datarefs;\n-      varray_type dependence_relations;\n+      VEC (ddr_p, heap) *dependence_relations;\n+      VEC (data_reference_p, heap) *datarefs;\n       struct loop *loop_nest = loops->parray[i];\n       struct loop *temp;\n       lambda_loopnest before, after;\n@@ -292,31 +287,17 @@ linear_transform_loops (struct loops *loops)\n \n       /* Analyze data references and dependence relations using scev.  */      \n  \n-      VARRAY_GENERIC_PTR_INIT (datarefs, 10, \"datarefs\");\n-      VARRAY_GENERIC_PTR_INIT (dependence_relations, 10,\n-\t\t\t       \"dependence_relations\");\n-      \n-  \n-      compute_data_dependences_for_loop (loop_nest, true,\n-\t\t\t\t\t &datarefs, &dependence_relations);\n+      datarefs = VEC_alloc (data_reference_p, heap, 10);\n+      dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);\n+      compute_data_dependences_for_loop (loop_nest, true, datarefs,\n+\t\t\t\t\t dependence_relations);\n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  unsigned int j;\n-\t  for (j = 0; j < VARRAY_ACTIVE_SIZE (dependence_relations); j++)\n-\t    {\n-\t      struct data_dependence_relation *ddr = \n-\t\t(struct data_dependence_relation *) \n-\t\tVARRAY_GENERIC_PTR (dependence_relations, j);\n+\tdump_ddrs (dump_file, dependence_relations);\n \n-\t      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-\t\tdump_data_dependence_relation (dump_file, ddr);\n-\t    }\n-\t  fprintf (dump_file, \"\\n\\n\");\n-\t}\n       /* Build the transformation matrix.  */\n       trans = lambda_trans_matrix_new (depth, depth);\n       lambda_matrix_id (LTM_MATRIX (trans), depth);\n-\n       trans = try_interchange_loops (trans, depth, dependence_relations,\n \t\t\t\t     datarefs, loop_nest);\n \n@@ -334,8 +315,10 @@ linear_transform_loops (struct loops *loops)\n \t    fprintf (dump_file, \"Can't transform loop, transform is illegal:\\n\");\n \t  continue;\n \t}\n+\n       if (!perfect_nest_p (loop_nest))\n \tneed_perfect_nest = true;\n+\n       before = gcc_loopnest_to_lambda_loopnest (loops,\n \t\t\t\t\t\tloop_nest, &oldivs, \n \t\t\t\t\t\t&invariants,\n@@ -350,18 +333,23 @@ linear_transform_loops (struct loops *loops)\n \t}\n   \n       after = lambda_loopnest_transform (before, trans);\n+\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"After:\\n\");\n \t  print_lambda_loopnest (dump_file, after, 'u');\n \t}\n+\n       lambda_loopnest_to_gcc_loopnest (loop_nest, oldivs, invariants,\n \t\t\t\t       after, trans);\n+\n       if (dump_file)\n \tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n+\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }\n+\n   VEC_free (tree, heap, oldivs);\n   VEC_free (tree, heap, invariants);\n   scev_reset ();"}, {"sha": "f6319428552f1ee928640d4d1c85326ad5134268", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 41, "deletions": 56, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -679,18 +679,15 @@ static bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n {\n   unsigned int i;\n-  varray_type ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+  VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+  struct data_dependence_relation *ddr;\n \n   if (vect_print_dump_info (REPORT_DETAILS)) \n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n      \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n-    {\n-      struct data_dependence_relation *ddr = VARRAY_GENERIC_PTR (ddrs, i);\n-     \n-      if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n-        return false;\n-    }\n+  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n+      return false;\n \n   return true;\n }\n@@ -812,15 +809,13 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n static bool\n vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  struct data_reference *dr;\n   unsigned int i;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n-      if (!vect_compute_data_ref_alignment (dr))\n-\treturn false;\n-    }\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    if (!vect_compute_data_ref_alignment (dr))\n+      return false;\n \n   return true;\n }\n@@ -884,13 +879,13 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n static bool\n vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  struct data_reference *dr;\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n         {\n@@ -1007,7 +1002,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n static bool\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n   struct data_reference *dr0 = NULL;\n   struct data_reference *dr;\n@@ -1055,16 +1050,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n      TODO: Use a cost model.  */\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-    {\n-      dr = VARRAY_GENERIC_PTR (datarefs, i);\n-      if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n-        {\n-          dr0 = dr;\n-          do_peeling = true;\n-          break;\n-        }\n-    }\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n+      {\n+\tdr0 = dr;\n+\tdo_peeling = true;\n+\tbreak;\n+      }\n \n   /* Often peeling for alignment will require peeling for loop-bound, which in \n      turn requires that we know how to adjust the loop ivs after the loop.  */\n@@ -1088,13 +1080,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         }\n \n       /* Ensure that all data refs can be vectorized after the peel.  */\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+      for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n         {\n           int save_misalignment;\n \n-\t  dr = VARRAY_GENERIC_PTR (datarefs, i);\n \t  if (dr == dr0)\n \t    continue;\n+\n \t  save_misalignment = DR_MISALIGNMENT (dr);\n \t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n \t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n@@ -1116,13 +1108,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n              by the peeling factor times the element size of DR_i (MOD the\n              vectorization factor times the size).  Otherwise, the\n              misalignment of DR_i must be set to unknown.  */\n-\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-\t    {\n-\t      dr = VARRAY_GENERIC_PTR (datarefs, i);\n-\t      if (dr == dr0)\n-\t        continue;\n+\t  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+\t    if (dr != dr0)\n \t      vect_update_misalignment_for_peel (dr, dr0, npeel);\n-\t    }\n \n           LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n           LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n@@ -1154,10 +1142,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (do_versioning)\n     {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+      for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n         {\n-          dr = VARRAY_GENERIC_PTR (datarefs, i);\n-\n           if (aligned_access_p (dr))\n             continue;\n \n@@ -1303,21 +1289,19 @@ static bool\n vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n {\n   unsigned int i;\n-  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  struct data_reference *dr;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_ref_accesses ===\");\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n-      if (!vect_analyze_data_ref_access (dr))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n-\t  return false;\n-\t}\n-    }\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    if (!vect_analyze_data_ref_access (dr))\n+      {\n+\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t  fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n+\treturn false;\n+      }\n \n   return true;\n }\n@@ -1342,22 +1326,23 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned int i;\n-  varray_type datarefs;\n+  VEC (data_reference_p, heap) *datarefs;\n+  struct data_reference *dr;\n   tree scalar_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs ===\");\n \n   compute_data_dependences_for_loop (loop, false,\n-                                     &(LOOP_VINFO_DATAREFS (loop_vinfo)),\n-                                     &(LOOP_VINFO_DDRS (loop_vinfo)));\n+                                     LOOP_VINFO_DATAREFS (loop_vinfo),\n+                                     LOOP_VINFO_DDRS (loop_vinfo));\n \n   /* Go through the data-refs, check that the analysis succeeded. Update pointer\n      from stmt_vec_info struct to DR and vectype.  */\n   datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       tree stmt;\n       stmt_vec_info stmt_info;\n    "}, {"sha": "1d23f14d1ff35e5b5456e8a08289305ece89ee28", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -2769,16 +2769,14 @@ static void\n vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n {\n   unsigned int i;\n-  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  struct data_reference *dr;\n \n   if (vect_dump && (dump_flags & TDF_DETAILS))\n     fprintf (vect_dump, \"=== vect_update_inits_of_dr ===\");\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n-      vect_update_init_of_dr (dr, niters);\n-    }\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    vect_update_init_of_dr (dr, niters);\n }\n \n "}, {"sha": "b6538a4b46dd86f53e3aca0c6ae7385d2e64288a", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -1420,8 +1420,8 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n-  VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREFS (res), 20, \"loop_datarefs\");\n-  VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DDRS (res), 20, \"loop_ddrs\");\n+  LOOP_VINFO_DATAREFS (res) = VEC_alloc (data_reference_p, heap, 10);\n+  LOOP_VINFO_DDRS (res) = VEC_alloc (ddr_p, heap, 10 * 10);\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n   LOOP_VINFO_MAY_MISALIGN_STMTS (res)\n     = VEC_alloc (tree, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_CHECKS));\n@@ -1483,8 +1483,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n     }\n \n   free (LOOP_VINFO_BBS (loop_vinfo));\n-  varray_clear (LOOP_VINFO_DATAREFS (loop_vinfo));\n-  varray_clear (LOOP_VINFO_DDRS (loop_vinfo));\n+  free_data_refs (LOOP_VINFO_DATAREFS (loop_vinfo));\n+  free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n   VEC_free (tree, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n \n   free (loop_vinfo);"}, {"sha": "3b7ca1b911ae559f7519bbf64aa6315ab1538d36", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf78a479a937efd39bc19511cb20a8b0796c922/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ebf78a479a937efd39bc19511cb20a8b0796c922", "patch": "@@ -122,10 +122,10 @@ typedef struct _loop_vec_info {\n   int ptr_mask;\n \n   /* All data references in the loop.  */\n-  varray_type datarefs;\n+  VEC (data_reference_p, heap) *datarefs;\n \n   /* All data dependences in the loop.  */\n-  varray_type ddrs;\n+  VEC (ddr_p, heap) *ddrs;\n \n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */"}]}