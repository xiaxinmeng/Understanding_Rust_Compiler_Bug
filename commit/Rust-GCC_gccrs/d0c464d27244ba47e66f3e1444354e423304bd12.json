{"sha": "d0c464d27244ba47e66f3e1444354e423304bd12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjNDY0ZDI3MjQ0YmE0N2U2NmYzZTE0NDQzNTRlNDIzMzA0YmQxMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-02T09:02:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-02T09:02:21Z"}, "message": "gimplify.h (omp_construct_selector_matches): Change return type to int, add a new SCORES argument.\n\n\t* gimplify.h (omp_construct_selector_matches): Change return\n\ttype to int, add a new SCORES argument.\n\t* gimplify.c (omp_construct_selector_matches): Likewise.  If\n\tSCORES is non-NULL, compute scores of each construct.\n\t* omp-general.h (omp_get_context_selector): Declare.\n\t* omp-general.c (omp_maybe_offloaded, omp_context_selector_matches):\n\tAdjust omp_construct_selector_matches callers.\n\t(omp_get_context_selector): New function, moved from c-family/c-omp.c.\n\t(omp_context_compute_score): New function.\n\t(omp_resolve_declare_variant): Compute scores and decide based on\n\tthat.\nc-family/\n\t* c-common.h (c_omp_get_context_selector): Remove.\n\t* c-omp.c (c_omp_get_context_selector): Moved to omp-general.c\n\tand renamed to omp_get_context_selector.\nc/\n\t* c-parser.c (c_finish_omp_declare_variant): Use\n\tomp_get_context_selector instead of c_omp_get_context_selector.\ncp/\n\t* decl.c (omp_declare_variant_finalize_one): Use\n\tomp_get_context_selector instead of c_omp_get_context_selector.\ntestsuite/\n\t* c-c++-common/gomp/declare-variant-12.c: New test.\n\nFrom-SVN: r277742", "tree": {"sha": "bf2a4b0ab2cb56537d82c7caa73be8a0c0ed6173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf2a4b0ab2cb56537d82c7caa73be8a0c0ed6173"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c464d27244ba47e66f3e1444354e423304bd12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c464d27244ba47e66f3e1444354e423304bd12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c464d27244ba47e66f3e1444354e423304bd12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c464d27244ba47e66f3e1444354e423304bd12/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "628be4ef7078d5fcbd0096f7b11fb9a24e4da08a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628be4ef7078d5fcbd0096f7b11fb9a24e4da08a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628be4ef7078d5fcbd0096f7b11fb9a24e4da08a"}], "stats": {"total": 385, "additions": 323, "deletions": 62}, "files": [{"sha": "a1282f3fcd8b48e910750fbe94b2fce60e026127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -1,5 +1,17 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gimplify.h (omp_construct_selector_matches): Change return\n+\ttype to int, add a new SCORES argument.\n+\t* gimplify.c (omp_construct_selector_matches): Likewise.  If\n+\tSCORES is non-NULL, compute scores of each construct.\n+\t* omp-general.h (omp_get_context_selector): Declare.\n+\t* omp-general.c (omp_maybe_offloaded, omp_context_selector_matches):\n+\tAdjust omp_construct_selector_matches callers.\n+\t(omp_get_context_selector): New function, moved from c-family/c-omp.c.\n+\t(omp_context_compute_score): New function.\n+\t(omp_resolve_declare_variant): Compute scores and decide based on\n+\tthat.\n+\n \tPR bootstrap/92314\n \t* configure.ac: Don't look for omp-device-properties files from\n \tinstalled offloading compilers.  Instead add tmake_file snippets"}, {"sha": "9e93911fab22f0f250ec3af5a5706ea57609c197", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -1,5 +1,9 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-common.h (c_omp_get_context_selector): Remove.\n+\t* c-omp.c (c_omp_get_context_selector): Moved to omp-general.c\n+\tand renamed to omp_get_context_selector.\n+\n \t* c-omp.c (c_omp_mark_declare_variant): Use\n \tomp_context_selector_set_compare.\n "}, {"sha": "bae7644caab7b03f1fbc1e0658ea7565ff73cd8b", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -1193,7 +1193,6 @@ extern void c_omp_declare_simd_clauses_to_decls (tree, tree);\n extern bool c_omp_predefined_variable (tree);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n extern tree c_omp_check_context_selector (location_t, tree);\n-extern tree c_omp_get_context_selector (tree, const char *, const char *);\n extern void c_omp_mark_declare_variant (location_t, tree, tree);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */"}, {"sha": "e53461dacf9d61fa0c0f0710f61e6fa850b49a53", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -2237,27 +2237,6 @@ c_omp_check_context_selector (location_t loc, tree ctx)\n   return ctx;\n }\n \n-/* From context selector CTX, return trait-selector with name SEL in\n-   trait-selector-set with name SET if any, or NULL_TREE if not found.\n-   If SEL is NULL, return the list of trait-selectors in SET.  */\n-\n-tree\n-c_omp_get_context_selector (tree ctx, const char *set, const char *sel)\n-{\n-  tree setid = get_identifier (set);\n-  tree selid = sel ? get_identifier (sel) : NULL_TREE;\n-  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n-    if (TREE_PURPOSE (t1) == setid)\n-      {\n-\tif (sel == NULL)\n-\t  return TREE_VALUE (t1);\n-\tfor (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n-\t  if (TREE_PURPOSE (t2) == selid)\n-\t    return t2;\n-      }\n-  return NULL_TREE;\n-}\n-\n /* Register VARIANT as variant of some base function marked with\n    #pragma omp declare variant.  CONSTRUCT is corresponding construct\n    selector set.  */"}, {"sha": "59e53cf129f1e012dce39fd7f254fa002ec9e6fe", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -1,3 +1,8 @@\n+2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c (c_finish_omp_declare_variant): Use\n+\tomp_get_context_selector instead of c_omp_get_context_selector.\n+\n 2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* c-tree.h (c_simulate_enum_decl): Declare."}, {"sha": "6a43419637ff93834d2f0be990382df1ed514eb0", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -19465,8 +19465,7 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \t  error_at (token->location, \"variant %qD is not a function\", variant);\n \t  variant = error_mark_node;\n \t}\n-      else if (c_omp_get_context_selector (ctx, \"construct\", \"simd\")\n-\t       == NULL_TREE\n+      else if (omp_get_context_selector (ctx, \"construct\", \"simd\") == NULL_TREE\n \t       && !comptypes (TREE_TYPE (fndecl), TREE_TYPE (variant)))\n \t{\n \t  error_at (token->location, \"variant %qD and base %qD have \"\n@@ -19487,7 +19486,7 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n       if (variant != error_mark_node)\n \t{\n \t  C_DECL_USED (variant) = 1;\n-\t  tree construct = c_omp_get_context_selector (ctx, \"construct\", NULL);\n+\t  tree construct = omp_get_context_selector (ctx, \"construct\", NULL);\n \t  c_omp_mark_declare_variant (match_loc, variant, construct);\n \t  if (omp_context_selector_matches (ctx))\n \t    {"}, {"sha": "7b178e5cef852dd9dccb00207707b72f1c5786ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -1,5 +1,8 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* decl.c (omp_declare_variant_finalize_one): Use\n+\tomp_get_context_selector instead of c_omp_get_context_selector.\n+\n \tPR c++/89640\n \t* parser.c (cp_parser_decl_specifier_seq): Don't parse attributes\n \tif CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR."}, {"sha": "6057fbcd718c2e9f44f008dad61229bb423c87d4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -7103,7 +7103,7 @@ omp_declare_variant_finalize_one (tree decl, tree attr)\n \t       DECL_ARGUMENTS (decl), NULL);\n \n   tree ctx = TREE_VALUE (TREE_VALUE (attr));\n-  tree simd = c_omp_get_context_selector (ctx, \"construct\", \"simd\");\n+  tree simd = omp_get_context_selector (ctx, \"construct\", \"simd\");\n   if (simd)\n     {\n       TREE_VALUE (simd)\n@@ -7202,7 +7202,7 @@ omp_declare_variant_finalize_one (tree decl, tree attr)\n \t}\n       else\n \t{\n-\t  tree construct = c_omp_get_context_selector (ctx, \"construct\", NULL);\n+\t  tree construct = omp_get_context_selector (ctx, \"construct\", NULL);\n \t  c_omp_mark_declare_variant (match_loc, variant, construct);\n \t  if (!omp_context_selector_matches (ctx))\n \t    return true;"}, {"sha": "d06b3ce570982008f1eb4c98376637961a4e402c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 73, "deletions": 24, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -10381,14 +10381,24 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \n /* Return 0 if CONSTRUCTS selectors don't match the OpenMP context,\n    -1 if unknown yet (simd is involved, won't be known until vectorization)\n-   and positive number if they do, the number is then the number of constructs\n-   in the OpenMP context.  */\n-\n-HOST_WIDE_INT\n-omp_construct_selector_matches (enum tree_code *constructs, int nconstructs)\n+   and 1 if they do.  If SCORES is non-NULL, it should point to an array\n+   of at least 2*NCONSTRUCTS+2 ints, and will be filled with the positions\n+   of the CONSTRUCTS (position -1 if it will never match) followed by\n+   number of constructs in the OpenMP context construct trait.  If the\n+   score depends on whether it will be in a declare simd clone or not,\n+   the function returns 2 and there will be two sets of the scores, the first\n+   one for the case that it is not in a declare simd clone, the other\n+   that it is in a declare simd clone.  */\n+\n+int\n+omp_construct_selector_matches (enum tree_code *constructs, int nconstructs,\n+\t\t\t\tint *scores)\n {\n   int matched = 0, cnt = 0;\n   bool simd_seen = false;\n+  bool target_seen = false;\n+  int declare_simd_cnt = -1;\n+  auto_vec<enum tree_code, 16> codes;\n   for (struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp; ctx;)\n     {\n       if (((ctx->region_type & ORT_PARALLEL) && ctx->code == OMP_PARALLEL)\n@@ -10401,7 +10411,9 @@ omp_construct_selector_matches (enum tree_code *constructs, int nconstructs)\n \t      && !omp_find_clause (ctx->clauses, OMP_CLAUSE_BIND)))\n \t{\n \t  ++cnt;\n-\t  if (matched < nconstructs && ctx->code == constructs[matched])\n+\t  if (scores)\n+\t    codes.safe_push (ctx->code);\n+\t  else if (matched < nconstructs && ctx->code == constructs[matched])\n \t    {\n \t      if (ctx->code == OMP_SIMD)\n \t\t{\n@@ -10412,7 +10424,12 @@ omp_construct_selector_matches (enum tree_code *constructs, int nconstructs)\n \t      ++matched;\n \t    }\n \t  if (ctx->code == OMP_TARGET)\n-\t    return matched < nconstructs ? 0 : simd_seen ? -1 : cnt;\n+\t    {\n+\t      if (scores == NULL)\n+\t\treturn matched < nconstructs ? 0 : simd_seen ? -1 : 1;\n+\t      target_seen = true;\n+\t      break;\n+\t    }\n \t}\n       else if (ctx->region_type == ORT_WORKSHARE\n \t       && ctx->code == OMP_LOOP\n@@ -10424,31 +10441,40 @@ omp_construct_selector_matches (enum tree_code *constructs, int nconstructs)\n \tctx = ctx->outer_context->outer_context;\n       ctx = ctx->outer_context;\n     }\n-  if (cnt == 0\n-      && constructs[0] == OMP_SIMD\n+  if (!target_seen\n       && lookup_attribute (\"omp declare simd\",\n \t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n     {\n       /* Declare simd is a maybe case, it is supposed to be added only to the\n \t omp-simd-clone.c added clones and not to the base function.  */\n-      gcc_assert (matched == 0);\n-      ++cnt;\n-      simd_seen = true;\n-      if (++matched == nconstructs)\n-\treturn -1;\n+      declare_simd_cnt = cnt++;\n+      if (scores)\n+\tcodes.safe_push (OMP_SIMD);\n+      else if (cnt == 0\n+\t       && constructs[0] == OMP_SIMD)\n+\t{\n+\t  gcc_assert (matched == 0);\n+\t  simd_seen = true;\n+\t  if (++matched == nconstructs)\n+\t    return -1;\n+\t}\n     }\n   if (tree attr = lookup_attribute (\"omp declare variant variant\",\n \t\t\t\t    DECL_ATTRIBUTES (current_function_decl)))\n     {\n       enum tree_code variant_constructs[5];\n-      int variant_nconstructs\n-\t= omp_constructor_traits_to_codes (TREE_VALUE (attr),\n-\t\t\t\t\t   variant_constructs);\n+      int variant_nconstructs = 0;\n+      if (!target_seen)\n+\tvariant_nconstructs\n+\t  = omp_constructor_traits_to_codes (TREE_VALUE (attr),\n+\t\t\t\t\t     variant_constructs);\n       for (int i = 0; i < variant_nconstructs; i++)\n \t{\n \t  ++cnt;\n-\t  if (matched < nconstructs\n-\t      && variant_constructs[i] == constructs[matched])\n+\t  if (scores)\n+\t    codes.safe_push (variant_constructs[i]);\n+\t  else if (matched < nconstructs\n+\t\t   && variant_constructs[i] == constructs[matched])\n \t    {\n \t      if (variant_constructs[i] == OMP_SIMD)\n \t\t{\n@@ -10460,15 +10486,38 @@ omp_construct_selector_matches (enum tree_code *constructs, int nconstructs)\n \t    }\n \t}\n     }\n-  if (lookup_attribute (\"omp declare target block\",\n-\t\t\tDECL_ATTRIBUTES (current_function_decl)))\n+  if (!target_seen\n+      && lookup_attribute (\"omp declare target block\",\n+\t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n     {\n-      ++cnt;\n-      if (matched < nconstructs && constructs[matched] == OMP_TARGET)\n+      if (scores)\n+\tcodes.safe_push (OMP_TARGET);\n+      else if (matched < nconstructs && constructs[matched] == OMP_TARGET)\n \t++matched;\n     }\n+  if (scores)\n+    {\n+      for (int pass = 0; pass < (declare_simd_cnt == -1 ? 1 : 2); pass++)\n+\t{\n+\t  int j = codes.length () - 1;\n+\t  for (int i = nconstructs - 1; i >= 0; i--)\n+\t    {\n+\t      while (j >= 0\n+\t\t     && (pass != 0 || declare_simd_cnt != j)\n+\t\t     && constructs[i] != codes[j])\n+\t\t--j;\n+\t      if (pass == 0 && declare_simd_cnt != -1 && j > declare_simd_cnt)\n+\t\t*scores++ = j - 1;\n+\t      else\n+\t\t*scores++ = j;\n+\t    }\n+\t  *scores++ = ((pass == 0 && declare_simd_cnt != -1)\n+\t\t       ? codes.length () - 1 : codes.length ());\n+\t}\n+      return declare_simd_cnt == -1 ? 1 : 2;\n+    }\n   if (matched == nconstructs)\n-    return simd_seen ? -1 : cnt;\n+    return simd_seen ? -1 : 1;\n   return 0;\n }\n "}, {"sha": "ea69d282cf81fe2cbeba6d5944a1a9e83b73ae36", "filename": "gcc/gimplify.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -75,7 +75,7 @@ extern void omp_firstprivatize_variable (struct gimplify_omp_ctx *, tree);\n extern enum gimplify_status gimplify_expr (tree *, gimple_seq *, gimple_seq *,\n \t\t\t\t\t   bool (*) (tree), fallback_t);\n \n-HOST_WIDE_INT omp_construct_selector_matches (enum tree_code *, int);\n+int omp_construct_selector_matches (enum tree_code *, int, int *);\n \n extern void gimplify_type_sizes (tree, gimple_seq *);\n extern void gimplify_one_sizepos (tree *, gimple_seq *);"}, {"sha": "7f8d7a84dcc14936c78e5ab5cbb723ac9db90be6", "filename": "gcc/omp-general.c", "status": "modified", "additions": 130, "deletions": 10, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -639,7 +639,7 @@ omp_maybe_offloaded (void)\n   if (cfun && (cfun->curr_properties & PROP_gimple_any) == 0)\n     {\n       enum tree_code construct = OMP_TARGET;\n-      if (omp_construct_selector_matches (&construct, 1))\n+      if (omp_construct_selector_matches (&construct, 1, NULL))\n \treturn true;\n     }\n   return false;\n@@ -677,8 +677,8 @@ omp_context_selector_matches (tree ctx)\n \t  enum tree_code constructs[5];\n \t  int nconstructs\n \t    = omp_constructor_traits_to_codes (TREE_VALUE (t1), constructs);\n-\t  HOST_WIDE_INT r\n-\t    = omp_construct_selector_matches (constructs, nconstructs);\n+\t  int r = omp_construct_selector_matches (constructs, nconstructs,\n+\t\t\t\t\t\t  NULL);\n \t  if (r == 0)\n \t    return 0;\n \t  if (r == -1)\n@@ -1261,13 +1261,93 @@ omp_context_selector_compare (tree ctx1, tree ctx2)\n   return swapped ? -ret : ret;\n }\n \n+/* From context selector CTX, return trait-selector with name SEL in\n+   trait-selector-set with name SET if any, or NULL_TREE if not found.\n+   If SEL is NULL, return the list of trait-selectors in SET.  */\n+\n+tree\n+omp_get_context_selector (tree ctx, const char *set, const char *sel)\n+{\n+  tree setid = get_identifier (set);\n+  tree selid = sel ? get_identifier (sel) : NULL_TREE;\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    if (TREE_PURPOSE (t1) == setid)\n+      {\n+\tif (sel == NULL)\n+\t  return TREE_VALUE (t1);\n+\tfor (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\t  if (TREE_PURPOSE (t2) == selid)\n+\t    return t2;\n+      }\n+  return NULL_TREE;\n+}\n+\n+/* Compute *SCORE for context selector CTX.  Return true if the score\n+   would be different depending on whether it is a declare simd clone or\n+   not.  DECLARE_SIMD should be true for the case when it would be\n+   a declare simd clone.  */\n+\n+static bool\n+omp_context_compute_score (tree ctx, widest_int *score, bool declare_simd)\n+{\n+  tree construct = omp_get_context_selector (ctx, \"construct\", NULL);\n+  bool has_kind = omp_get_context_selector (ctx, \"device\", \"kind\");\n+  bool has_arch = omp_get_context_selector (ctx, \"device\", \"arch\");\n+  bool has_isa = omp_get_context_selector (ctx, \"device\", \"isa\");\n+  bool ret = false;\n+  *score = 1;\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+      if (tree t3 = TREE_VALUE (t2))\n+\tif (TREE_PURPOSE (t3)\n+\t    && strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t3)), \" score\") == 0\n+\t    && TREE_CODE (TREE_VALUE (t3)) == INTEGER_CST)\n+\t  *score += wi::to_widest (TREE_VALUE (t3));\n+  if (construct || has_kind || has_arch || has_isa)\n+    {\n+      int scores[12];\n+      enum tree_code constructs[5];\n+      int nconstructs = 0;\n+      if (construct)\n+\tnconstructs = omp_constructor_traits_to_codes (construct, constructs);\n+      if (omp_construct_selector_matches (constructs, nconstructs, scores)\n+\t  == 2)\n+\tret = true;\n+      int b = declare_simd ? nconstructs + 1 : 0;\n+      if (scores[b + nconstructs] + 4U < score->get_precision ())\n+\t{\n+\t  for (int n = 0; n < nconstructs; ++n)\n+\t    {\n+\t      if (scores[b + n] < 0)\n+\t\t{\n+\t\t  *score = 0;\n+\t\t  return ret;\n+\t\t}\n+\t      *score += wi::shifted_mask <widest_int> (scores[b + n], 1, false);\n+\t    }\n+\t  if (has_kind)\n+\t    *score += wi::shifted_mask <widest_int> (scores[b + nconstructs],\n+\t\t\t\t\t\t     1, false);\n+\t  if (has_arch)\n+\t    *score += wi::shifted_mask <widest_int> (scores[b + nconstructs] + 1,\n+\t\t\t\t\t\t     1, false);\n+\t  if (has_isa)\n+\t    *score += wi::shifted_mask <widest_int> (scores[b + nconstructs] + 2,\n+\t\t\t\t\t\t     1, false);\n+\t}\n+      else /* FIXME: Implement this.  */\n+\tgcc_unreachable ();\n+    }\n+  return ret;\n+}\n+\n /* Try to resolve declare variant, return the variant decl if it should\n    be used instead of base, or base otherwise.  */\n \n tree\n omp_resolve_declare_variant (tree base)\n {\n-  tree variant = NULL_TREE;\n+  tree variant1 = NULL_TREE, variant2 = NULL_TREE;\n   auto_vec <tree, 16> variants;\n   for (tree attr = DECL_ATTRIBUTES (base); attr; attr = TREE_CHAIN (attr))\n     {\n@@ -1319,16 +1399,56 @@ omp_resolve_declare_variant (tree base)\n \t\tvariants[j] = NULL_TREE;\n \t    }\n       }\n-  /* FIXME: Scoring not implemented yet, so just resolve it\n-     if there is a single variant left.  */\n+  widest_int max_score1 = 0;\n+  widest_int max_score2 = 0;\n+  bool first = true;\n   FOR_EACH_VEC_ELT (variants, i, attr1)\n     if (attr1)\n       {\n-\tif (variant)\n-\t  return base;\n-\tvariant = TREE_PURPOSE (TREE_VALUE (attr1));\n+\tif (variant1)\n+\t  {\n+\t    widest_int score1;\n+\t    widest_int score2;\n+\t    bool need_two;\n+\t    tree ctx;\n+\t    if (first)\n+\t      {\n+\t\tfirst = false;\n+\t\tctx = TREE_VALUE (TREE_VALUE (variant1));\n+\t\tneed_two = omp_context_compute_score (ctx, &max_score1, false);\n+\t\tif (need_two)\n+\t\t  omp_context_compute_score (ctx, &max_score2, true);\n+\t\telse\n+\t\t  max_score2 = max_score1;\n+\t      }\n+\t    ctx = TREE_VALUE (TREE_VALUE (attr1));\n+\t    need_two = omp_context_compute_score (ctx, &score1, false);\n+\t    if (need_two)\n+\t      omp_context_compute_score (ctx, &score2, true);\n+\t    else\n+\t      score2 = score1;\n+\t    if (score1 > max_score1)\n+\t      {\n+\t\tmax_score1 = score1;\n+\t\tvariant1 = attr1;\n+\t      }\n+\t    if (score2 > max_score2)\n+\t      {\n+\t\tmax_score2 = score2;\n+\t\tvariant2 = attr1;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    variant1 = attr1;\n+\t    variant2 = attr1;\n+\t  }\n       }\n-  return variant ? variant : base;\n+  /* If there is a disagreement on which variant has the highest score\n+     depending on whether it will be in a declare simd clone or not,\n+     punt for now and defer until after IPA where we will know that.  */\n+  return ((variant1 && variant1 == variant2)\n+\t  ? TREE_PURPOSE (TREE_VALUE (variant1)) : base);\n }\n \n "}, {"sha": "fe5c25b08abd5cb2a1215eed0b838af76b01fa12", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -87,6 +87,7 @@ extern int omp_max_simt_vf (void);\n extern int omp_constructor_traits_to_codes (tree, enum tree_code *);\n extern int omp_context_selector_matches (tree);\n extern int omp_context_selector_set_compare (const char *, tree, tree);\n+extern tree omp_get_context_selector (tree, const char *, const char *);\n extern tree omp_resolve_declare_variant (tree);\n extern tree oacc_launch_pack (unsigned code, tree device, unsigned op);\n extern tree oacc_replace_fn_attrib_attr (tree attribs, tree dims);"}, {"sha": "57b5d34e55ad914c276e508124750e4d2f6d14d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -1,5 +1,7 @@\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/declare-variant-12.c: New test.\n+\n \tPR c++/89640\n \t* g++.dg/cpp1z/attr-lambda1.C: New test.\n \t* g++.dg/ext/attr-lambda2.C: New test."}, {"sha": "f01c757c08d523c7bbedd60c95e4e824c13f9e7c", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-12.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c464d27244ba47e66f3e1444354e423304bd12/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-12.c?ref=d0c464d27244ba47e66f3e1444354e423304bd12", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-foffload=disable -fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-mavx512bw -mavx512vl\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#pragma omp requires atomic_default_mem_order(seq_cst)\n+void f01 (void);\n+void f02 (void);\n+void f03 (void);\n+#pragma omp declare variant (f01) match (device={isa(avx512f,avx512vl)}) /* 16 */\n+#pragma omp declare variant (f02) match (implementation={vendor(score(15):gnu)})\n+#pragma omp declare variant (f03) match (user={condition(score(11):1)})\n+void f04 (void);\n+void f05 (void);\n+void f06 (void);\n+void f07 (void);\n+#pragma omp declare variant (f05) match (device={isa(avx512f,avx512vl)}) /* 16 */\n+#pragma omp declare variant (f06) match (implementation={vendor(score(15):gnu)})\n+#pragma omp declare variant (f07) match (user={condition(score(17):1)})\n+void f08 (void);\n+void f09 (void);\n+void f10 (void);\n+void f11 (void);\n+void f12 (void);\n+#pragma omp declare variant (f09) match (device={arch(x86_64)},user={condition(score(65):1)}) /* 64+65 */\n+#pragma omp declare variant (f10) match (implementation={vendor(score(127):gnu)})\n+#pragma omp declare variant (f11) match (device={isa(ssse3)}) /* 128 */\n+#pragma omp declare variant (f12) match (implementation={atomic_default_mem_order(score(126):seq_cst)})\n+void f13 (void);\n+void f14 (void);\n+void f15 (void);\n+void f16 (void);\n+#pragma omp declare variant (f14) match (construct={teams,parallel,for}) /* 16+8+4 */\n+#pragma omp declare variant (f15) match (construct={parallel},user={condition(score(19):1)}) /* 8+19 */\n+#pragma omp declare variant (f16) match (implementation={atomic_default_mem_order(score(27):seq_cst)})\n+void f17 (void);\n+void f18 (void);\n+void f19 (void);\n+void f20 (void);\n+#pragma omp declare variant (f18) match (construct={teams,parallel,for}) /* 16+8+4 */\n+#pragma omp declare variant (f19) match (construct={for},user={condition(score(25):1)}) /* 4+25 */\n+#pragma omp declare variant (f20) match (implementation={atomic_default_mem_order(score(28):seq_cst)})\n+void f21 (void);\n+void f22 (void);\n+void f23 (void);\n+void f24 (void);\n+#pragma omp declare variant (f22) match (construct={parallel,for}) /* 2+1 */\n+#pragma omp declare variant (f23) match (construct={for}) /* 0 */\n+#pragma omp declare variant (f24) match (implementation={atomic_default_mem_order(score(2):seq_cst)})\n+void f25 (void);\n+void f26 (void);\n+void f27 (void);\n+void f28 (void);\n+#pragma omp declare variant (f26) match (construct={parallel,for}) /* 2+1 */\n+#pragma omp declare variant (f27) match (construct={for},user={condition(1)}) /* 4 */\n+#pragma omp declare variant (f28) match (implementation={atomic_default_mem_order(score(3):seq_cst)})\n+void f29 (void);\n+\n+void\n+test1 (void)\n+{\n+  int i, j;\n+  #pragma omp parallel for\t/* 2 constructs in OpenMP context, isa has score 2^4.  */\n+  for (i = 0; i < 1; i++)\n+    f04 ();\t/* { dg-final { scan-tree-dump-times \"f01 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+  #pragma omp target teams\t/* 2 constructs in OpenMP context, isa has score 2^4.  */\n+  f08 ();\t/* { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  #pragma omp teams\n+  #pragma omp parallel for\n+  for (i = 0; i < 1; i++)\n+    #pragma omp parallel for\t/* 5 constructs in OpenMP context, arch is 2^6, isa 2^7.  */\n+    for (j = 0; j < 1; j++)\n+      {\n+\tf13 ();\t/* { dg-final { scan-tree-dump-times \"f09 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f10 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+\tf17 ();\t/* { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+\tf21 ();\t/* { dg-final { scan-tree-dump-times \"f19 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+      }\n+  #pragma omp for\n+  for (i = 0; i < 1; i++)\n+    #pragma omp parallel for\n+    for (j = 0; j < 1; j++)\n+      {\n+\tf25 ();\t/* { dg-final { scan-tree-dump-times \"f22 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+\tf29 ();\t/* { dg-final { scan-tree-dump-times \"f27 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+      }\n+}"}]}