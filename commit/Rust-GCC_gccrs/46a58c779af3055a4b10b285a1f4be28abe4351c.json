{"sha": "46a58c779af3055a4b10b285a1f4be28abe4351c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZhNThjNzc5YWYzMDU1YTRiMTBiMjg1YTFmNGJlMjhhYmU0MzUxYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-04T12:35:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-04T13:42:43Z"}, "message": "tree-optimization/96920 - another ICE when vectorizing nested cycles\n\nThis refines the previous fix for PR96698 by re-doing how and where\nwe arrange for setting vectorized cycle PHI backedge values.\n\n2020-09-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/96698\n\tPR tree-optimization/96920\n\t* tree-vectorizer.h (loop_vec_info::reduc_latch_defs): Remove.\n\t(loop_vec_info::reduc_latch_slp_defs): Likewise.\n\t* tree-vect-stmts.c (vect_transform_stmt): Remove vectorized\n\tcycle PHI latch code.\n\t* tree-vect-loop.c (maybe_set_vectorized_backedge_value): New\n\thelper to set vectorized cycle PHI latch values.\n\t(vect_transform_loop): Walk over all PHIs again after\n\tvectorizing them, calling maybe_set_vectorized_backedge_value.\n\tCall maybe_set_vectorized_backedge_value for each vectorized\n\tstmt.  Remove delayed update code.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Initialize\n\tSLP instance reduc_phis member.\n\t(vect_schedule_slp): Set vectorized cycle PHI latch values.\n\n\t* gfortran.dg/vect/pr96920.f90: New testcase.\n\t* gcc.dg/vect/pr96920.c: Likewise.", "tree": {"sha": "baefb67199cad573cf5461dbfc4c9f8be57a2001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baefb67199cad573cf5461dbfc4c9f8be57a2001"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46a58c779af3055a4b10b285a1f4be28abe4351c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a58c779af3055a4b10b285a1f4be28abe4351c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a58c779af3055a4b10b285a1f4be28abe4351c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a58c779af3055a4b10b285a1f4be28abe4351c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09fa6acd8d96013cf97046b273642fdefeef7559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09fa6acd8d96013cf97046b273642fdefeef7559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09fa6acd8d96013cf97046b273642fdefeef7559"}], "stats": {"total": 211, "additions": 144, "deletions": 67}, "files": [{"sha": "af5da4ae52e93f7d3195e45b39eb819b261c4891", "filename": "gcc/testsuite/gcc.dg/vect/pr96920.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr96920.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr96920.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr96920.c?ref=46a58c779af3055a4b10b285a1f4be28abe4351c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+int a[1024];\n+int b[2048];\n+\n+void foo (int x, int y)\n+{\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      int tem0 = b[2*i];\n+      int tem1 = b[2*i+1];\n+      for (int j = 0; j < 32; ++j)\n+\t{\n+\t  int tem = tem0;\n+\t  tem0 = tem1;\n+\t  tem1 = tem;\n+\t  a[i] += tem0;\n+\t}\n+    }\n+}"}, {"sha": "e1dc0adac9c136c83d668ece1c39259077058840", "filename": "gcc/testsuite/gfortran.dg/vect/pr96920.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr96920.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr96920.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr96920.f90?ref=46a58c779af3055a4b10b285a1f4be28abe4351c", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+      subroutine ice(npoint, nterm, x, g)\n+      implicit none\n+      integer    norder\n+      parameter (norder=10)\n+      integer j\n+      integer k\n+      integer ii\n+      integer nterm\n+      integer npoint\n+      real b(norder)\n+      real c(norder)\n+      real d(norder)\n+      real x(npoint)\n+      real g(npoint)\n+      real gg\n+      real prev\n+      real prev2\n+\n+          j = 1\n+    100   continue\n+          j = j+1\n+          if (nterm == j)  then\n+             do ii=1,npoint\n+                k = nterm\n+                gg= d(k)\n+                prev= 0.0\n+                do k=k-1,1,-1\n+                   prev2= prev\n+                   prev= gg\n+                   gg = d(k)+(x(ii)-b(k))*prev-c(k+1)*prev2\n+                enddo\n+                g(ii) = gg\n+             enddo\n+          endif\n+          go to 100\n+      end"}, {"sha": "9799b3d718899abc069b7186e0f64abdac1997f4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=46a58c779af3055a4b10b285a1f4be28abe4351c", "patch": "@@ -8555,6 +8555,42 @@ scale_profile_for_vect_loop (class loop *loop, unsigned vf)\n     scale_bbs_frequencies (&loop->latch, 1, exit_l->probability / prob);\n }\n \n+/* For a vectorized stmt DEF_STMT_INFO adjust all vectorized PHI\n+   latch edge values originally defined by it.  */\n+\n+static void\n+maybe_set_vectorized_backedge_value (loop_vec_info loop_vinfo,\n+\t\t\t\t     stmt_vec_info def_stmt_info)\n+{\n+  tree def = gimple_get_lhs (vect_orig_stmt (def_stmt_info)->stmt);\n+  if (!def || TREE_CODE (def) != SSA_NAME)\n+    return;\n+  stmt_vec_info phi_info;\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, def)\n+    if (gphi *phi = dyn_cast <gphi *> (USE_STMT (use_p)))\n+      if (gimple_bb (phi)->loop_father->header == gimple_bb (phi)\n+\t  && (phi_info = loop_vinfo->lookup_stmt (phi))\n+\t  && VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (phi_info))\n+\t  && STMT_VINFO_REDUC_TYPE (phi_info) != FOLD_LEFT_REDUCTION\n+\t  && STMT_VINFO_REDUC_TYPE (phi_info) != EXTRACT_LAST_REDUCTION)\n+\t{\n+\t  loop_p loop = gimple_bb (phi)->loop_father;\n+\t  edge e = loop_latch_edge (loop);\n+\t  if (PHI_ARG_DEF_FROM_EDGE (phi, e) == def)\n+\t    {\n+\t      vec<gimple *> &phi_defs = STMT_VINFO_VEC_STMTS (phi_info);\n+\t      vec<gimple *> &latch_defs = STMT_VINFO_VEC_STMTS (def_stmt_info);\n+\t      gcc_assert (phi_defs.length () == latch_defs.length ());\n+\t      for (unsigned i = 0; i < phi_defs.length (); ++i)\n+\t\tadd_phi_arg (as_a <gphi *> (phi_defs[i]),\n+\t\t\t     gimple_get_lhs (latch_defs[i]), e,\n+\t\t\t     gimple_phi_arg_location (phi, e->dest_idx));\n+\t    }\n+\t}\n+}\n+\n /* Vectorize STMT_INFO if relevant, inserting any new instructions before GSI.\n    When vectorizing STMT_INFO as a store, set *SEEN_STORE to its\n    stmt_vec_info.  */\n@@ -8933,7 +8969,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \n       for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n-        {\n+\t{\n \t  gphi *phi = si.phi ();\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -8968,6 +9004,27 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t    }\n \t}\n \n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  gphi *phi = si.phi ();\n+\t  stmt_info = loop_vinfo->lookup_stmt (phi);\n+\t  if (!stmt_info)\n+\t    continue;\n+\n+\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t      && !STMT_VINFO_LIVE_P (stmt_info))\n+\t    continue;\n+\n+\t  if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def)\n+\t      && ! PURE_SLP_STMT (stmt_info))\n+\t    maybe_set_vectorized_backedge_value (loop_vinfo, stmt_info);\n+\t}\n+\n       for (gimple_stmt_iterator si = gsi_start_bb (bb);\n \t   !gsi_end_p (si);)\n \t{\n@@ -9005,9 +9062,16 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t\t\t= STMT_VINFO_RELATED_STMT (stmt_info);\n \t\t      vect_transform_loop_stmt (loop_vinfo, pat_stmt_info, &si,\n \t\t\t\t\t\t&seen_store);\n+\t\t      maybe_set_vectorized_backedge_value (loop_vinfo,\n+\t\t\t\t\t\t\t   pat_stmt_info);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      vect_transform_loop_stmt (loop_vinfo, stmt_info, &si,\n+\t\t\t\t\t\t&seen_store);\n+\t\t      maybe_set_vectorized_backedge_value (loop_vinfo,\n+\t\t\t\t\t\t\t   stmt_info);\n \t\t    }\n-\t\t  vect_transform_loop_stmt (loop_vinfo, stmt_info, &si,\n-\t\t\t\t\t    &seen_store);\n \t\t}\n \t      gsi_next (&si);\n \t      if (seen_store)\n@@ -9025,38 +9089,6 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t    }\n \t}\n \n-      /* Fill in backedge defs of reductions.  */\n-      for (unsigned i = 0; i < loop_vinfo->reduc_latch_defs.length (); ++i)\n-\t{\n-\t  stmt_vec_info stmt_info = loop_vinfo->reduc_latch_defs[i];\n-\t  stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n-\t  vec<gimple *> &phi_info\n-\t    = STMT_VINFO_VEC_STMTS (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n-\t  vec<gimple *> &vec_stmt\n-\t    = STMT_VINFO_VEC_STMTS (stmt_info);\n-\t  gcc_assert (phi_info.length () == vec_stmt.length ());\n-\t  gphi *phi\n-\t    = dyn_cast <gphi *> (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt);\n-\t  edge e = loop_latch_edge (gimple_bb (phi_info[0])->loop_father);\n-\t  for (unsigned j = 0; j < phi_info.length (); ++j)\n-\t    add_phi_arg (as_a <gphi *> (phi_info[j]),\n-\t\t\t gimple_get_lhs (vec_stmt[j]), e,\n-\t\t\t gimple_phi_arg_location (phi, e->dest_idx));\n-\t}\n-      for (unsigned i = 0; i < loop_vinfo->reduc_latch_slp_defs.length (); ++i)\n-\t{\n-\t  slp_tree slp_node = loop_vinfo->reduc_latch_slp_defs[i].first;\n-\t  slp_tree phi_node = loop_vinfo->reduc_latch_slp_defs[i].second;\n-\t  gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n-\t  e = loop_latch_edge (gimple_bb (phi)->loop_father);\n-\t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n-\t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n-\t  for (unsigned j = 0; j < SLP_TREE_VEC_STMTS (phi_node).length (); ++j)\n-\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[j]),\n-\t\t\t vect_get_slp_vect_def (slp_node, j),\n-\t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n-\t}\n-\n       /* Stub out scalar statements that must not survive vectorization.\n \t Doing this here helps with grouped statements, or statements that\n \t are involved in patterns.  */"}, {"sha": "811d1b29fc053fc1bf46746de9eeec0a8543a530", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=46a58c779af3055a4b10b285a1f4be28abe4351c", "patch": "@@ -2244,6 +2244,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n \t  SLP_INSTANCE_LOADS (new_instance) = vNULL;\n \t  SLP_INSTANCE_ROOT_STMT (new_instance) = constructor ? stmt_info : NULL;\n+\t  new_instance->reduc_phis = NULL;\n \n \t  vect_gather_slp_loads (new_instance, node);\n \t  if (dump_enabled_p ())\n@@ -4565,6 +4566,25 @@ vect_schedule_slp (vec_info *vinfo)\n       stmt_vec_info store_info;\n       unsigned int j;\n \n+      /* For reductions set the latch values of the vectorized PHIs.  */\n+      if (instance->reduc_phis\n+\t  && STMT_VINFO_REDUC_TYPE (SLP_TREE_REPRESENTATIVE\n+\t\t\t(instance->reduc_phis)) != FOLD_LEFT_REDUCTION\n+\t  && STMT_VINFO_REDUC_TYPE (SLP_TREE_REPRESENTATIVE\n+\t\t\t(instance->reduc_phis)) != EXTRACT_LAST_REDUCTION)\n+\t{\n+\t  slp_tree slp_node = root;\n+\t  slp_tree phi_node = instance->reduc_phis;\n+\t  gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n+\t  edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n+\t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n+\t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n+\t  for (unsigned j = 0; j < SLP_TREE_VEC_STMTS (phi_node).length (); ++j)\n+\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[j]),\n+\t\t\t vect_get_slp_vect_def (slp_node, j),\n+\t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n+\t}\n+\n       /* Remove scalar call stmts.  Do not do this for basic-block\n \t vectorization as not all uses may be vectorized.\n \t ???  Why should this be necessary?  DCE should be able to"}, {"sha": "c7339679b322398d2f4698347589112f920b26e3", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=46a58c779af3055a4b10b285a1f4be28abe4351c", "patch": "@@ -10921,33 +10921,6 @@ vect_transform_stmt (vec_info *vinfo,\n   if (STMT_VINFO_TYPE (stmt_info) == store_vec_info_type)\n     return is_store;\n \n-  /* If this stmt defines a value used on a backedge, record it so\n-     we can update the vectorized PHIs later.  */\n-  stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n-  stmt_vec_info reduc_info;\n-  if (STMT_VINFO_REDUC_DEF (orig_stmt_info)\n-      && vect_stmt_to_vectorize (orig_stmt_info) == stmt_info\n-      && (reduc_info = info_for_reduction (vinfo, orig_stmt_info))\n-      && STMT_VINFO_REDUC_TYPE (reduc_info) != FOLD_LEFT_REDUCTION\n-      && STMT_VINFO_REDUC_TYPE (reduc_info) != EXTRACT_LAST_REDUCTION)\n-    {\n-      gphi *phi;\n-      edge e;\n-      if (!slp_node\n-\t  && (phi = dyn_cast <gphi *>\n-\t\t      (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt))\n-\t  && dominated_by_p (CDI_DOMINATORS,\n-\t\t\t     gimple_bb (orig_stmt_info->stmt), gimple_bb (phi))\n-\t  && (e = loop_latch_edge (gimple_bb (phi)->loop_father))\n-\t  && (PHI_ARG_DEF_FROM_EDGE (phi, e)\n-\t      == gimple_get_lhs (orig_stmt_info->stmt)))\n-\tas_a <loop_vec_info> (vinfo)->reduc_latch_defs.safe_push (stmt_info);\n-      else if (slp_node\n-\t       && slp_node != slp_node_instance->reduc_phis)\n-\tas_a <loop_vec_info> (vinfo)->reduc_latch_slp_defs.safe_push\n-\t    (std::make_pair (slp_node, slp_node_instance->reduc_phis));\n-    }\n-\n   /* Handle stmts whose DEF is used outside the loop-nest that is\n      being vectorized.  */\n   if (is_a <loop_vec_info> (vinfo))"}, {"sha": "8551b6866132f2a479d7625736d47e8ba898f5cd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a58c779af3055a4b10b285a1f4be28abe4351c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=46a58c779af3055a4b10b285a1f4be28abe4351c", "patch": "@@ -627,11 +627,6 @@ typedef class _loop_vec_info : public vec_info {\n      stmt in the chain.  */\n   auto_vec<stmt_vec_info> reduction_chains;\n \n-  /* The vectorized stmts defining the latch values of the reduction\n-     they are involved with.  */\n-  auto_vec<stmt_vec_info> reduc_latch_defs;\n-  auto_vec<std::pair<slp_tree, slp_tree> > reduc_latch_slp_defs;\n-\n   /* Cost vector for a single scalar iteration.  */\n   auto_vec<stmt_info_for_cost> scalar_cost_vec;\n "}]}