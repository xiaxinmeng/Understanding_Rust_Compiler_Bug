{"sha": "a6b46ba2c84f81e70811e13581c99350cdc76400", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZiNDZiYTJjODRmODFlNzA4MTFlMTM1ODFjOTkzNTBjZGM3NjQwMA==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2005-06-21T09:02:00Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-06-21T09:02:00Z"}, "message": "genopinit.c (vec_shl_optab, [...]): Initialize new optabs.\n\n        * genopinit.c (vec_shl_optab, vec_shr_optab): Initialize new optabs.\n        (reduc_plus_optab): Removed.  Replcaed with...\n        (reduc_splus_optab, reduc_uplus_optab): Initialize new optabs.\n        * optabs.c (optab_for_tree_code): Return reduc_splus_optab or\n        reduc_uplus_optab instead of reduc_plus_optab.\n        (expand_vec_shift_expr): New function.\n        (init_optabs): Initialize new optabs. Remove initialization of\n        reduc_plus_optab.\n        (optab_for_tree_code): Return vec_shl_optab/vec_shr_optab\n        for VEC_LSHIFT_EXPR/VEC_RSHIFT_EXPR.\n        * optabs.h (OTI_reduc_plus): Removed. Replaced with...\n        (OTI_reduc_splus, OTI_reduc_uplus): New.\n        (reduc_plus_optab): Removed.  Replcaed with...\n        (reduc_splus_optab, reduc_uplus_optab): New optabs.\n        (vec_shl_optab, vec_shr_optab): New optabs.\n        (expand_vec_shift_expr): New function declaration.\n\n        * tree.def (VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR): New tree-codes.\n        * tree-inline.c (estimate_num_insns_1): Handle new tree-codes.\n        * expr.c (expand_expr_real_1): Handle new tree-codes.\n        * tree-pretty-print.c (dump_generic_node, op_symbol, op_prio): Likewise.\n        * tree-vect-generic.c (expand_vector_operations_1): Add assert.\n\n        * tree-vect-transform.c (vect_create_epilog_for_reduction): Add two\n        alternatives for generating reduction epilog code.\n        (vectorizable_reduction): Don't fail of direct reduction support is\n        not available.\n        (vectorizable_target_reduction_pattern): Likewise.\n\n        * config/rs6000/altivec.md (reduc_smax_v4si, reduc_smax_v4sf,\n        reduc_umax_v4si, reduc_smin_v4si, reduc_smin_v4sf, reduc_umin_v4si,\n        reduc_plus_v4si, reduc_plus_v4sf): Removed.\n        (vec_shl_<mode>, vec_shr_<mode>, altivec_vsumsws_nomode,\n        reduc_splus_<mode>, reduc_uplus_v16qi): New.\n\nFrom-SVN: r101231", "tree": {"sha": "9b2edf4d87ca9a2741f8f8a846bf5e277d74ab28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2edf4d87ca9a2741f8f8a846bf5e277d74ab28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6b46ba2c84f81e70811e13581c99350cdc76400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b46ba2c84f81e70811e13581c99350cdc76400", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b46ba2c84f81e70811e13581c99350cdc76400", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b46ba2c84f81e70811e13581c99350cdc76400/comments", "author": null, "committer": null, "parents": [{"sha": "a3a2067ac5b2a5ce0b8439d42167df5694d2bb5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a2067ac5b2a5ce0b8439d42167df5694d2bb5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a2067ac5b2a5ce0b8439d42167df5694d2bb5b"}], "stats": {"total": 1097, "additions": 882, "deletions": 215}, "files": [{"sha": "0cc4cf9170e0ad5e43758f016107ce4ca614de68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -1,3 +1,40 @@\n+2005-06-21  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* genopinit.c (vec_shl_optab, vec_shr_optab): Initialize new optabs.\n+\t(reduc_plus_optab): Removed.  Replcaed with...\n+\t(reduc_splus_optab, reduc_uplus_optab): Initialize new optabs.\n+\t* optabs.c (optab_for_tree_code): Return reduc_splus_optab or\n+\treduc_uplus_optab instead of reduc_plus_optab.\n+\t(expand_vec_shift_expr): New function.\n+\t(init_optabs): Initialize new optabs. Remove initialization of\n+\treduc_plus_optab.\n+\t(optab_for_tree_code): Return vec_shl_optab/vec_shr_optab\n+\tfor VEC_LSHIFT_EXPR/VEC_RSHIFT_EXPR.\n+\t* optabs.h (OTI_reduc_plus): Removed. Replaced with...\n+\t(OTI_reduc_splus, OTI_reduc_uplus): New.\n+\t(reduc_plus_optab): Removed.  Replcaed with...\n+\t(reduc_splus_optab, reduc_uplus_optab): New optabs.\n+\t(vec_shl_optab, vec_shr_optab): New optabs.\n+\t(expand_vec_shift_expr): New function declaration.\n+\n+\t* tree.def (VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR): New tree-codes.\n+\t* tree-inline.c (estimate_num_insns_1): Handle new tree-codes.\n+\t* expr.c (expand_expr_real_1): Handle new tree-codes.\n+\t* tree-pretty-print.c (dump_generic_node, op_symbol, op_prio): Likewise.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Add assert.\n+\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Add two\n+\talternatives for generating reduction epilog code.\n+\t(vectorizable_reduction): Don't fail of direct reduction support is\n+\tnot available.\n+\t(vectorizable_target_reduction_pattern): Likewise.\n+\n+\t* config/rs6000/altivec.md (reduc_smax_v4si, reduc_smax_v4sf,\n+\treduc_umax_v4si, reduc_smin_v4si, reduc_smin_v4sf, reduc_umin_v4si,\n+\treduc_plus_v4si, reduc_plus_v4sf): Removed.\n+\t(vec_shl_<mode>, vec_shr_<mode>, altivec_vsumsws_nomode,\n+\treduc_splus_<mode>, reduc_uplus_v16qi): New.\n+\n 2005-06-20  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* c-typeck.c (build_function_call): Set fundecl = function again."}, {"sha": "7bfd5d9ed71853318ea3041ac391e07912869df1", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 69, "deletions": 126, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -1825,157 +1825,100 @@\n   operands[3] = gen_reg_rtx (GET_MODE (operands[0]));\n })\n \n-;; Reduction\n-\n-(define_expand \"reduc_smax_v4si\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+;; Vector shift left in bits. Currently supported ony for shift\n+;; amounts that can be expressed as byte shifts (divisible by 8).\n+;; General shift amounts can be supported using vslo + vsl. We're\n+;; not expecting to see these yet (the vectorizer currently\n+;; generates only shifts divisible by byte_size).\n+(define_expand \"vec_shl_<mode>\"\n+  [(set (match_operand:V 0 \"register_operand\" \"=v\")\n+        (unspec:V [(match_operand:V 1 \"register_operand\" \"v\")\n+                   (match_operand:QI 2 \"reg_or_short_operand\" \"\")] 219 ))]\n   \"TARGET_ALTIVEC\"\n   \"\n-{  \n-  rtx vtmp1 = gen_reg_rtx (V4SImode);\n-  rtx vtmp2 = gen_reg_rtx (V4SImode);\n-  rtx vtmp3 = gen_reg_rtx (V4SImode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_smaxv4si3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_smaxv4si3 (operands[0], vtmp2, vtmp3));\n+{\n+  rtx bitshift = operands[2];\n+  rtx byteshift = gen_reg_rtx (QImode);\n+  HOST_WIDE_INT bitshift_val;\n+  HOST_WIDE_INT byteshift_val;\n+\n+  if (! CONSTANT_P (bitshift))\n+    FAIL;\n+  bitshift_val = INTVAL (bitshift);\n+  if (bitshift_val & 0x7)\n+    FAIL;\n+  byteshift_val = bitshift_val >> 3;\n+  byteshift = gen_rtx_CONST_INT (QImode, byteshift_val);\n+  emit_insn (gen_altivec_vsldoi_<mode> (operands[0], operands[1], operands[1],\n+                                        byteshift));\n   DONE;\n }\")\n \n-(define_expand \"reduc_smax_v4sf\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n-        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")] 217))]\n+;; Vector shift left in bits. Currently supported ony for shift\n+;; amounts that can be expressed as byte shifts (divisible by 8).\n+;; General shift amounts can be supported using vsro + vsr. We're\n+;; not expecting to see these yet (the vectorizer currently\n+;; generates only shifts divisible by byte_size).\n+(define_expand \"vec_shr_<mode>\"\n+  [(set (match_operand:V 0 \"register_operand\" \"=v\")\n+        (unspec:V [(match_operand:V 1 \"register_operand\" \"v\")\n+                   (match_operand:QI 2 \"reg_or_short_operand\" \"\")] 219 ))]\n   \"TARGET_ALTIVEC\"\n   \"\n-{ \n-  rtx vtmp1 = gen_reg_rtx (V4SFmode);\n-  rtx vtmp2 = gen_reg_rtx (V4SFmode);\n-  rtx vtmp3 = gen_reg_rtx (V4SFmode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4sf (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_smaxv4sf3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4sf (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_smaxv4sf3 (operands[0], vtmp2, vtmp3));\n+{\n+  rtx bitshift = operands[2];\n+  rtx byteshift = gen_reg_rtx (QImode);\n+  HOST_WIDE_INT bitshift_val;\n+  HOST_WIDE_INT byteshift_val;\n+ \n+  if (! CONSTANT_P (bitshift))\n+    FAIL;\n+  bitshift_val = INTVAL (bitshift);\n+  if (bitshift_val & 0x7)\n+    FAIL;\n+  byteshift_val = 16 - (bitshift_val >> 3);\n+  byteshift = gen_rtx_CONST_INT (QImode, byteshift_val);\n+  emit_insn (gen_altivec_vsldoi_<mode> (operands[0], operands[1], operands[1],\n+                                        byteshift));\n   DONE;\n }\")\n \n-(define_expand \"reduc_umax_v4si\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+(define_insn \"altivec_vsumsws_nomode\"\n+  [(set (match_operand 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+                      (match_operand:V4SI 2 \"register_operand\" \"v\")] 135))\n+   (set (reg:SI 110) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))]\n   \"TARGET_ALTIVEC\"\n-  \"\n-{ \n-  rtx vtmp1 = gen_reg_rtx (V4SImode);\n-  rtx vtmp2 = gen_reg_rtx (V4SImode);\n-  rtx vtmp3 = gen_reg_rtx (V4SImode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_umaxv4si3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_umaxv4si3 (operands[0], vtmp2, vtmp3));\n-  DONE;\n-}\")\n+  \"vsumsws %0,%1,%2\"\n+  [(set_attr \"type\" \"veccomplex\")])\n \n-(define_expand \"reduc_smin_v4si\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+(define_expand \"reduc_splus_<mode>\"\n+  [(set (match_operand:VIshort 0 \"register_operand\" \"=v\")\n+        (unspec:VIshort [(match_operand:VIshort 1 \"register_operand\" \"v\")] 217))]\n   \"TARGET_ALTIVEC\"\n   \"\n { \n+  rtx vzero = gen_reg_rtx (V4SImode);\n   rtx vtmp1 = gen_reg_rtx (V4SImode);\n-  rtx vtmp2 = gen_reg_rtx (V4SImode);\n-  rtx vtmp3 = gen_reg_rtx (V4SImode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_sminv4si3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_sminv4si3 (operands[0], vtmp2, vtmp3));\n-  DONE;\n-}\")\n \n-(define_expand \"reduc_smin_v4sf\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n-        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")] 217))]\n-  \"TARGET_ALTIVEC\"\n-  \"\n-{\n-  rtx vtmp1 = gen_reg_rtx (V4SFmode);\n-  rtx vtmp2 = gen_reg_rtx (V4SFmode);\n-  rtx vtmp3 = gen_reg_rtx (V4SFmode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4sf (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_sminv4sf3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4sf (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_sminv4sf3 (operands[0], vtmp2, vtmp3));\n+  emit_insn (gen_altivec_vspltisw (vzero, const0_rtx));\n+  emit_insn (gen_altivec_vsum4s<VI_char>s (vtmp1, operands[1], vzero));\n+  emit_insn (gen_altivec_vsumsws_nomode (operands[0], vtmp1, vzero));\n   DONE;\n }\")\n \n-(define_expand \"reduc_umin_v4si\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n+(define_expand \"reduc_uplus_v16qi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+        (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")] 217))]\n   \"TARGET_ALTIVEC\"\n   \"\n {\n+  rtx vzero = gen_reg_rtx (V4SImode);\n   rtx vtmp1 = gen_reg_rtx (V4SImode);\n-  rtx vtmp2 = gen_reg_rtx (V4SImode);\n-  rtx vtmp3 = gen_reg_rtx (V4SImode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_uminv4si3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_uminv4si3 (operands[0], vtmp2, vtmp3));\n-  DONE;\n-}\")\n \n-(define_expand \"reduc_plus_v4si\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")] 217))]\n-  \"TARGET_ALTIVEC\"\n-  \"\n-{ \n-  rtx vtmp1 = gen_reg_rtx (V4SImode);\n-  rtx vtmp2 = gen_reg_rtx (V4SImode);\n-  rtx vtmp3 = gen_reg_rtx (V4SImode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_addv4si3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4si (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_addv4si3 (operands[0], vtmp2, vtmp3));\n-  DONE;\n-}\")\n-  \n-(define_expand \"reduc_plus_v4sf\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n-        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")] 217))]\n-  \"TARGET_ALTIVEC\"\n-  \"\n-{ \n-  rtx vtmp1 = gen_reg_rtx (V4SFmode);\n-  rtx vtmp2 = gen_reg_rtx (V4SFmode);\n-  rtx vtmp3 = gen_reg_rtx (V4SFmode);\n-\n-  emit_insn (gen_altivec_vsldoi_v4sf (vtmp1, operands[1], operands[1], \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 8)));\n-  emit_insn (gen_addv4sf3 (vtmp2, operands[1], vtmp1));\n-  emit_insn (gen_altivec_vsldoi_v4sf (vtmp3, vtmp2, vtmp2, \n-\t\t\t\t      gen_rtx_CONST_INT (SImode, 4)));\n-  emit_insn (gen_addv4sf3 (operands[0], vtmp2, vtmp3));\n+  emit_insn (gen_altivec_vspltisw (vzero, const0_rtx));\n+  emit_insn (gen_altivec_vsum4ubs (vtmp1, operands[1], vzero));\n+  emit_insn (gen_altivec_vsumsws_nomode (operands[0], vtmp1, vzero));\n   DONE;\n }\")\n "}, {"sha": "573ec5edabb24571d43fbd5865b521131ef4ffb7", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -8367,6 +8367,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         return temp;\n       }\n \n+    case VEC_LSHIFT_EXPR:\n+    case VEC_RSHIFT_EXPR:\n+      {\n+\ttarget = expand_vec_shift_expr (exp, target);\n+\treturn target;\n+      }\n+\n     default:\n       return lang_hooks.expand_expr (exp, original_target, tmode,\n \t\t\t\t     modifier, alt_rtl);"}, {"sha": "19a7f7c817664ca0b7a668cae80303b9998f0387", "filename": "gcc/genopinit.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -196,14 +196,17 @@ static const char * const optabs[] =\n   \"vec_set_optab->handlers[$A].insn_code = CODE_FOR_$(vec_set$a$)\",\n   \"vec_extract_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract$a$)\",\n   \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\",\n+  \"vec_shl_optab->handlers[$A].insn_code = CODE_FOR_$(vec_shl_$a$)\",\n+  \"vec_shr_optab->handlers[$A].insn_code = CODE_FOR_$(vec_shr_$a$)\",\n   \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\",\n   \"vcond_gen_code[$A] = CODE_FOR_$(vcond$a$)\",\n   \"vcondu_gen_code[$A] = CODE_FOR_$(vcondu$a$)\",\n   \"reduc_smax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smax_$a$)\",\n   \"reduc_umax_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umax_$a$)\",\n   \"reduc_smin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_smin_$a$)\",\n   \"reduc_umin_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_umin_$a$)\",\n-  \"reduc_plus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_plus_$a$)\" \n+  \"reduc_splus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_splus_$a$)\" ,\n+  \"reduc_uplus_optab->handlers[$A].insn_code = CODE_FOR_$(reduc_uplus_$a$)\" \n };\n \n static void gen_insn (rtx);"}, {"sha": "22027271716b7180fcc85e5748cfd27f918f5798", "filename": "gcc/optabs.c", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -301,7 +301,13 @@ optab_for_tree_code (enum tree_code code, tree type)\n       return TYPE_UNSIGNED (type) ? reduc_umin_optab : reduc_smin_optab;\n \n     case REDUC_PLUS_EXPR:\n-      return reduc_plus_optab;\n+      return TYPE_UNSIGNED (type) ? reduc_uplus_optab : reduc_splus_optab;\n+\n+    case VEC_LSHIFT_EXPR:\n+      return vec_shl_optab;\n+\n+    case VEC_RSHIFT_EXPR:\n+      return vec_shr_optab;\n \n     default:\n       break;\n@@ -443,6 +449,61 @@ force_expand_binop (enum machine_mode mode, optab binoptab,\n   return true;\n }\n \n+/* Generate insns for VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR.  */\n+\n+rtx\n+expand_vec_shift_expr (tree vec_shift_expr, rtx target)\n+{\n+  enum insn_code icode;\n+  rtx rtx_op1, rtx_op2;\n+  enum machine_mode mode1;\n+  enum machine_mode mode2;\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (vec_shift_expr));\n+  tree vec_oprnd = TREE_OPERAND (vec_shift_expr, 0);\n+  tree shift_oprnd = TREE_OPERAND (vec_shift_expr, 1);\n+  optab shift_optab;\n+  rtx pat;\n+\n+  switch (TREE_CODE (vec_shift_expr))\n+    {\n+      case VEC_RSHIFT_EXPR:\n+\tshift_optab = vec_shr_optab;\n+\tbreak;\n+      case VEC_LSHIFT_EXPR:\n+\tshift_optab = vec_shl_optab;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  icode = (int) shift_optab->handlers[(int) mode].insn_code;\n+  gcc_assert (icode != CODE_FOR_nothing);\n+\n+  mode1 = insn_data[icode].operand[1].mode;\n+  mode2 = insn_data[icode].operand[2].mode;\n+\n+  rtx_op1 = expand_expr (vec_oprnd, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  if (!(*insn_data[icode].operand[1].predicate) (rtx_op1, mode1)\n+      && mode1 != VOIDmode)\n+    rtx_op1 = force_reg (mode1, rtx_op1);\n+\n+  rtx_op2 = expand_expr (shift_oprnd, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  if (!(*insn_data[icode].operand[2].predicate) (rtx_op2, mode2)\n+      && mode2 != VOIDmode)\n+    rtx_op2 = force_reg (mode2, rtx_op2);\n+\n+  if (!target\n+      || ! (*insn_data[icode].operand[0].predicate) (target, mode))\n+    target = gen_reg_rtx (mode);\n+\n+  /* Emit instruction */\n+  pat = GEN_FCN (icode) (target, rtx_op1, rtx_op2);\n+  gcc_assert (pat);\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\n /* This subroutine of expand_doubleword_shift handles the cases in which\n    the effective shift value is >= BITS_PER_WORD.  The arguments and return\n    value are the same as for the parent routine, except that SUPERWORD_OP1\n@@ -5074,11 +5135,14 @@ init_optabs (void)\n   reduc_umax_optab = init_optab (UNKNOWN);\n   reduc_smin_optab = init_optab (UNKNOWN);\n   reduc_umin_optab = init_optab (UNKNOWN);\n-  reduc_plus_optab = init_optab (UNKNOWN);\n+  reduc_splus_optab = init_optab (UNKNOWN);\n+  reduc_uplus_optab = init_optab (UNKNOWN);\n \n   vec_extract_optab = init_optab (UNKNOWN);\n   vec_set_optab = init_optab (UNKNOWN);\n   vec_init_optab = init_optab (UNKNOWN);\n+  vec_shl_optab = init_optab (UNKNOWN);\n+  vec_shr_optab = init_optab (UNKNOWN);\n   vec_realign_load_optab = init_optab (UNKNOWN);\n   movmisalign_optab = init_optab (UNKNOWN);\n "}, {"sha": "91afce35a9670e5d65c8a28e83a5bea7a3cf4576", "filename": "gcc/optabs.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -236,14 +236,18 @@ enum optab_index\n   OTI_reduc_umax,\n   OTI_reduc_smin,\n   OTI_reduc_umin,\n-  OTI_reduc_plus,\n+  OTI_reduc_splus,\n+  OTI_reduc_uplus,\n \n   /* Set specified field of vector operand.  */\n   OTI_vec_set,\n   /* Extract specified field of vector operand.  */\n   OTI_vec_extract,\n   /* Initialize vector operand.  */\n   OTI_vec_init,\n+  /* Whole vector shift. The shift amount is in bits.  */\n+  OTI_vec_shl,\n+  OTI_vec_shr,\n   /* Extract specified elements from vectors, for vector load.  */\n   OTI_vec_realign_load,\n \n@@ -358,11 +362,14 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define reduc_umax_optab (optab_table[OTI_reduc_umax])\n #define reduc_smin_optab (optab_table[OTI_reduc_smin])\n #define reduc_umin_optab (optab_table[OTI_reduc_umin])\n-#define reduc_plus_optab (optab_table[OTI_reduc_plus])\n+#define reduc_splus_optab (optab_table[OTI_reduc_splus])\n+#define reduc_uplus_optab (optab_table[OTI_reduc_uplus])\n \n #define vec_set_optab (optab_table[OTI_vec_set])\n #define vec_extract_optab (optab_table[OTI_vec_extract])\n #define vec_init_optab (optab_table[OTI_vec_init])\n+#define vec_shl_optab (optab_table[OTI_vec_shl])\n+#define vec_shr_optab (optab_table[OTI_vec_shr])\n #define vec_realign_load_optab (optab_table[OTI_vec_realign_load])\n \n #define powi_optab (optab_table[OTI_powi])\n@@ -575,4 +582,7 @@ bool expand_vec_cond_expr_p (tree, enum machine_mode);\n /* Generate code for VEC_COND_EXPR.  */\n extern rtx expand_vec_cond_expr (tree, rtx);\n \n+/* Generate code for VEC_LSHIFT_EXPR and VEC_RSHIFT_EXPR.  */\n+extern rtx expand_vec_shift_expr (tree, rtx);\n+\n #endif /* GCC_OPTABS_H */"}, {"sha": "a526fb121b46f6bdb93a67916b003ccf5839a357", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -1,3 +1,21 @@\n+2005-06-21  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_reduction): \n+\tRemove.\n+\t* gcc.dg/vect/vect.exp: Run tests with additional flags separately.\n+\t* gcc.dg/vect/vect-reduc-1.c: Vectorizable on all relevant platforms -\n+\tremove vect_reduction target keyword. Also avoid two returns in main.\n+\t* gcc.dg/vect/vect-reduc-3.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-2.c: Likewise. Also initialize diff to 0.\n+\t* gcc.dg/vect/vect-reduc-1short.c: New test.\n+\t* gcc.dg/vect/vect-reduc-1char.c: New test.\n+\t* gcc.dg/vect/vect-reduc-2short.c: New test.\n+\t* gcc.dg/vect/vect-reduc-2char.c: New test.\n+\t* gcc.dg/vect/vect-reduc-6.c: New test.\n+\t* gcc.dg/vect/trapv-vect-reduc-4.c: New test.\n+\t* gcc.dg/vect/fast-math-vect-reduc-5.c: New test.\n+\t* gcc.dg/vect/fast-math-vect-reduc-7.c: New test\n+\n 2005-06-21  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \tPaul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "dd84f5c2e7b2db5c9b6b80fdfd075c241620a7c8", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-reduc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-reduc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-reduc-5.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+/* need -funsafe-math-optimizations to vectorize the summation.\n+   also need -ffinite-math-only to create the min/max expr.  */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (float x, float max_result)\n+{\n+  int i;\n+  float b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  float diff = 2;\n+  float max = x;\n+  float min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */"}, {"sha": "797b1a78d3a6a35e6489094408cce2c6806c9d89", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-vect-reduc-7.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-reduc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-reduc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-reduc-7.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+/* need -funsafe-math-optimizations to vectorize the summation.\n+   also need -ffinite-math-only to create the min/max expr.  */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (double x, double max_result)\n+{\n+  int i;\n+  double b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  double c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  double diff = 2;\n+  double max = x;\n+  double min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */"}, {"sha": "21297178a002901649e1b3a9b7db9e054eb63729", "filename": "gcc/testsuite/gcc.dg/vect/trapv-vect-reduc-4.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftrapv-vect-reduc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftrapv-vect-reduc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftrapv-vect-reduc-4.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-do compile } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (int x, int max_result)\n+{\n+  int i;\n+  int b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  int c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  int diff = 2;\n+  int max = x;\n+  int min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */"}, {"sha": "bc87a5c62c861b0b2795211d19987bf3bac1b353", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -47,9 +47,9 @@ int main (void)\n { \n   check_vect ();\n   \n-  return main1 (100, 100);\n-  return main1 (0, 15);\n+  main1 (100, 100);\n+  main1 (0, 15);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail {! vect_reduction} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e85fa4a20c0c44925bc901aa62cdde7d73c31446", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-1char.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1char.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (unsigned char x, unsigned char max_result)\n+{\n+  int i;\n+  unsigned char ub[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char uc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned char udiff = 2;\n+  unsigned char umax = x;\n+  unsigned char umin = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    udiff += (unsigned char)(ub[i] - uc[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umax = umax < uc[i] ? uc[i] : umax;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umin = umin > uc[i] ? uc[i] : umin;\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+  if (umax != max_result)\n+    abort ();\n+  if (umin != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "bd116befd93897ea4605b27ea79a77609e7bd3aa", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-1short.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-1short.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (unsigned short x, unsigned short max_result)\n+{\n+  int i;\n+  unsigned short ub[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned short uc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned short  udiff = 2;\n+  unsigned short umax = x;\n+  unsigned short umin = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    udiff += (unsigned short)(ub[i] - uc[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umax = umax < uc[i] ? uc[i] : umax;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umin = umin > uc[i] ? uc[i] : umin;\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+  if (umax != max_result)\n+    abort ();\n+  if (umin != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ca1a3da07e3660f2721e2ea3a791953e98d373ac", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -1,11 +1,10 @@\n-\n /* { dg-require-effective-target vect_int } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n #define N 16\n-#define DIFF 242\n+#define DIFF 240\n \n /* Test vectorization of reduction of signed-int.  */\n \n@@ -14,7 +13,7 @@ int main1 (int x, int max_result)\n   int i;\n   int b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n   int c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n-  int diff = 2;\n+  int diff = 0;\n   int max = x;\n   int min = 10;\n \n@@ -45,9 +44,10 @@ int main (void)\n { \n   check_vect ();\n   \n-  return main1 (100, 100);\n-  return main1 (0, 15);\n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail {! vect_reduction} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "eddc2cf0247977eabc3d398acb61406f60eaca91", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-2char.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2char.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 121\n+\n+int main1 (char x, char max_result)\n+{\n+  int i;\n+  char b[N] = {0,2,3,6,8,10,12,14,16,18,20,22,24,26,28,30};\n+  char c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  signed char diff = 2;\n+  char max = x;\n+  char min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0 ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f0880aab12af9187c3c8479b43b3a723656abaa9", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-2short.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-2short.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (short x, short max_result)\n+{\n+  int i;\n+  short b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  short c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  short diff = 2;\n+  short max = x;\n+  short min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "001183721aa6ee67aa102e14a2ce4e1275b2f2a7", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-3.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -4,12 +4,11 @@\n #include \"tree-vect.h\"\n \n #define N 16\n-#define DIFF 240\n \n /* Test vectorization of reduction of unsigned-int in the presence\n    of unknown-loop-bound.  */\n \n-int main1 (int n)\n+int main1 (int n, int res)\n {\n   int i;\n   unsigned int ub[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n@@ -22,7 +21,7 @@ int main1 (int n)\n   }\n \n   /* check results:  */\n-  if (udiff != DIFF)\n+  if (udiff != res)\n     abort ();\n \n   return 0;\n@@ -32,9 +31,10 @@ int main (void)\n { \n   check_vect ();\n   \n-  return main1 (N);\n-  return main1 (N-1);\n+  main1 (N, 240);\n+  main1 (N-1, 210);\n+  return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail {! vect_reduction} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4e4f15590c638690482038e762754d55076ba2dc", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-6.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-6.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+int main1 (float x, float max_result)\n+{\n+  int i;\n+  float b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  float diff = 2;\n+  float max = x;\n+  float min = 10;\n+\n+  for (i = 0; i < N; i++) {\n+    diff += (b[i] - c[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    max = max < c[i] ? c[i] : max;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    min = min > c[i] ? c[i] : min;\n+  }\n+\n+  /* check results:  */\n+  if (diff != DIFF)\n+    abort ();\n+  if (max != max_result)\n+    abort ();\n+  if (min != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100 ,100);\n+  main1 (0, 15);\n+  return 0;\n+}\n+\n+/* need -ffast-math to vectorizer these loops.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */"}, {"sha": "6ab7e3d5f5e3521815e142ed743bfecb5866db30", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -76,7 +76,25 @@ if [istarget \"powerpc*-*-*\"] {\n dg-init\n \n # Main loop.\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]]  \\\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+\n+# -ffast-math tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-vect*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+# -ftrapv tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ftrapv\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/trapv-vect*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # Clean up."}, {"sha": "0378169977565ddc156079a2b8ddba6b2a1994e5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -988,23 +988,6 @@ proc check_effective_target_vect_int_mult { } {\n     return $et_vect_int_mult_saved\n }\n \n-# Return 1 if the target supports vector reduction\n-\n-proc check_effective_target_vect_reduction { } {\n-    global et_vect_reduction_saved\n-\n-    if [info exists et_vect_reduction_saved] { \n-        verbose \"check_effective_target_vect_reduction: using cached result\" 2\n-    } else {\n-        set et_vect_reduction_saved 0\n-        if { [istarget powerpc*-*-*] } {\n-            set et_vect_reduction_saved 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_reduction: returning $et_vect_reduction_saved\" 2\n-    return $et_vect_reduction_saved\n-}   \n-\n # Return 1 if the target supports atomic operations on \"int\" and \"long\".\n \n proc check_effective_target_sync_int_long { } {"}, {"sha": "ee30ccc92b089598cbc83373f7520a8ab0eaee30", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -1692,6 +1692,8 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n+    case VEC_LSHIFT_EXPR:\n+    case VEC_RSHIFT_EXPR:\n \n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:"}, {"sha": "04cc8fac187f4611942a2132c9ac44a2b13569ef", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -1043,6 +1043,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n+    case VEC_LSHIFT_EXPR:\n+    case VEC_RSHIFT_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n     case BIT_AND_EXPR:\n@@ -1838,6 +1840,8 @@ op_prio (tree op)\n     case REDUC_MAX_EXPR:\n     case REDUC_MIN_EXPR:\n     case REDUC_PLUS_EXPR:\n+    case VEC_LSHIFT_EXPR:\n+    case VEC_RSHIFT_EXPR:\n       return 16;\n \n     case SAVE_EXPR:\n@@ -1925,6 +1929,12 @@ op_symbol (tree op)\n     case RSHIFT_EXPR:\n       return \">>\";\n \n+    case VEC_LSHIFT_EXPR:\n+      return \"v<<\";\n+\n+    case VEC_RSHIFT_EXPR:\n+      return \"v>>\";\n+ \n     case PLUS_EXPR:\n       return \"+\";\n "}, {"sha": "fc75222d8924fa7113e9a4b42162ff95e5ffb8da", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -448,6 +448,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n \tcompute_type = TREE_TYPE (type);\n     }\n \n+  gcc_assert (code != VEC_LSHIFT_EXPR && code != VEC_RSHIFT_EXPR);\n   rhs = expand_vector_operation (bsi, type, compute_type, rhs, code);\n   if (lang_hooks.types_compatible_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n     *p_rhs = rhs;"}, {"sha": "a4417d4d6731d822966fbabd28b0cd2253839c07", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 206, "deletions": 51, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -834,6 +834,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  enum machine_mode mode = TYPE_MODE (vectype);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block exit_bb;\n@@ -843,15 +844,18 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   block_stmt_iterator exit_bsi;\n   tree vec_dest;\n   tree new_temp;\n+  tree new_name;\n   tree epilog_stmt;\n   tree new_scalar_dest, exit_phi;\n-  tree bitsize, bitpos; \n+  tree bitsize, bitpos, bytesize; \n   enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1));\n   tree scalar_initial_def;\n   tree vec_initial_def;\n   tree orig_name;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n+  bool extract_scalar_result;\n+  bool adjust_in_epilog;\n   \n   /*** 1. Create the reduction def-use cycle  ***/\n   \n@@ -888,63 +892,214 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   exit_bsi = bsi_start (exit_bb);\n \n \n-  /* 2.2 Create:\n-        v_out2 = reduc_expr <v_out1>\n-        s_out3 = extract_field <v_out2, 0>  */\n+  new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n+  bitsize = TYPE_SIZE (scalar_type);\n+  bytesize = TYPE_SIZE_UNIT (scalar_type);\n \n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-  epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n-                         build1 (reduc_code, vectype, PHI_RESULT (new_phi)));\n-  new_temp = make_ssa_name (vec_dest, epilog_stmt);\n-  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n-  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+  /* 2.2 Create the reduction code.  */\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+  if (reduc_code < NUM_TREE_CODES)\n     {\n-      fprintf (vect_dump, \"transform reduction: created epilog code:\");\n-      print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n-    }\n+      /*** Case 1:  Create:\n+\t   v_out2 = reduc_expr <v_out1>  */\n \n-  new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n-  bitsize = TYPE_SIZE (scalar_type);\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"Reduce using direct vector reduction.\");\n \n-  /* The result is in the low order bits.  */\n-  if (BITS_BIG_ENDIAN)\n-    bitpos = size_binop (MULT_EXPR,\n-                       bitsize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1),\n-                       TYPE_SIZE (scalar_type));\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+\t\t\tbuild1 (reduc_code, vectype,  PHI_RESULT (new_phi)));\n+      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n+      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\n+      extract_scalar_result = true;\n+      adjust_in_epilog = true;\n+    }\n   else\n-    bitpos = bitsize_zero_node;\n+    {\n+      enum tree_code shift_code;\n+      bool have_whole_vector_shift = true;\n+      enum tree_code code = TREE_CODE (TREE_OPERAND (stmt, 1)); /* CHECKME */\n+      int bit_offset;\n+      int element_bitsize = tree_low_cst (bitsize, 1);\n+      int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n+      tree vec_temp;\n+\n+      /* The result of the reduction is expected to be at the LSB bits\n+\t of the vector. For big-endian targets this means at the right\n+\t end of the vector. For little-edian targets this means at the\n+\t left end of the vector.  */\n+\n+      if (BITS_BIG_ENDIAN\n+\t  && vec_shr_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+\tshift_code = VEC_RSHIFT_EXPR;\n+      else if (!BITS_BIG_ENDIAN\n+\t       && vec_shl_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+\tshift_code = VEC_LSHIFT_EXPR;\n+      else\n+\thave_whole_vector_shift = false;\n+\n+      if (have_whole_vector_shift)\n+        {\n+\t  /*** Case 2:\n+\t     for (offset = VS/2; offset >= element_size; offset/=2)\n+\t        {\n+\t          Create:  va' = vec_shift <va, offset>\n+\t          Create:  va = vop <va, va'>\n+\t        }  */\n+\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"Reduce using vector shifts\");\n+\n+\t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t  new_temp = PHI_RESULT (new_phi);\n+\n+\t  for (bit_offset = vec_size_in_bits/2;\n+\t       bit_offset >= element_bitsize;\n+\t       bit_offset /= 2)\n+\t    {\n+\t      tree bitpos = size_int (bit_offset);\n+\n+\t      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+\t      build2 (shift_code, vectype, new_temp, bitpos));\n+\t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n+\t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n+\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\n+\n+\t      epilog_stmt = build2 (MODIFY_EXPR, vectype, vec_dest,\n+\t      build2 (code, vectype, new_name, new_temp));\n+\t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n+\t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\t    }\n+\n+\t  extract_scalar_result = true;\n+\t  adjust_in_epilog = true;\n+\t}\n+      else\n+        {\n+\t  /*** Case 3:\n+\t     Create:  s = init; \n+\t     for (offset=0; offset<vector_size; offset+=element_size;)\n+\t       {\n+\t         Create:  s' = extract_field <v_out2, offset>\n+\t         Create:  s = op <s, s'>\n+\t       }  */\n+\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"Reduce using scalar code. \");\n+\n+\t  vec_temp = PHI_RESULT (new_phi);\n+\t  vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n+\n+\t  /* first iteration is peeled out when possible to minimize\n+\t     the number of operations we generate:  */\n+\t  if (code == PLUS_EXPR \n+\t     && (integer_zerop (scalar_initial_def) \n+\t\t || real_zerop (scalar_initial_def)))\n+\t    {\n+\t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+                                build3 (BIT_FIELD_REF, scalar_type,\n+                                \tvec_temp, bitsize, bitsize_zero_node));\n+              new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+              TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+              bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+                print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\t      \n+\t      bit_offset = element_bitsize;\n+\t    }\n+\t  else\n+\t    {\n+\t      new_temp = scalar_initial_def;\n+\t      bit_offset = 0;\n+\t    }\n \n-  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n-                 build3 (BIT_FIELD_REF, scalar_type,\n-                         new_temp, bitsize, bitpos));\n-  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n-  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t  for (;\n+\t       bit_offset < vec_size_in_bits;\n+\t       bit_offset += element_bitsize)\n+\t    { \n+\t      tree bitpos = bitsize_int (bit_offset);\n+\n+\t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+\t\t\t\tbuild3 (BIT_FIELD_REF, scalar_type,\n+\t\t\t\t\tvec_temp, bitsize, bitpos));\n+\t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n+\t      TREE_OPERAND (epilog_stmt, 0) = new_name;\n+\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\n+\n+\t      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+\t\t\t\tbuild2 (code, scalar_type, new_name, new_temp));\n+\t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+\t      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+\t    }\n+\n+\t  extract_scalar_result = false;\n+\t  adjust_in_epilog = false;\n+\t}\n+    }\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC)) \n-    print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n \n+  /* 2.3  Extract the final scalar result.  Create:\n+         s_out3 = extract_field <v_out2, bitpos>  */\n   \n-  /* 2.3 Adjust the final result by the initial value of the reduction\n-         variable. (when such adjustment is not needed, then\n-         'scalar_initial_def' is zero).\n+  if (extract_scalar_result)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"extract scalar result\");\n \n-         Create:\n-         s_out = scalar_expr <s_out, scalar_initial_def>  */\n+      /* The result is in the low order bits.  */\n+      if (BITS_BIG_ENDIAN)\n+\tbitpos = size_binop (MULT_EXPR,\n+\t\t       bitsize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1),\n+\t\t       TYPE_SIZE (scalar_type));\n+      else\n+\tbitpos = bitsize_zero_node;\n+\n+      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+\t\t     build3 (BIT_FIELD_REF, scalar_type,\n+\t\t\t     new_temp, bitsize, bitpos));\n+      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+      TREE_OPERAND (epilog_stmt, 0) = new_temp; \n+      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tprint_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+    }\n \n-  epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n-                  build2 (code, scalar_type, new_temp, scalar_initial_def));\n-  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-  TREE_OPERAND (epilog_stmt, 0) = new_temp;\n-  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n \n-  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+  /* 2.4 Adjust the final result by the initial value of the reduction\n+\t variable. (when such adjustment is not needed, then\n+\t 'scalar_initial_def' is zero).\n \n-    \n-  /* 2.4 Replace uses of s_out0 with uses of s_out3  */ \n+\t Create: \n+\t s_out = scalar_expr <s_out, scalar_initial_def>  */\n+  \n+  if (adjust_in_epilog)\n+    {\n+      epilog_stmt = build2 (MODIFY_EXPR, scalar_type, new_scalar_dest,\n+                      build2 (code, scalar_type, new_temp, scalar_initial_def));\n+      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+      TREE_OPERAND (epilog_stmt, 0) = new_temp;\n+      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        print_generic_expr (vect_dump, epilog_stmt, TDF_SLIM);\n+    }\n+\n+\n+  /* 2.5 Replace uses of s_out0 with uses of s_out3  */\n \n   /* Find the loop-closed-use at the loop exit of the original\n      scalar result.  (The reduction result is expected to have\n@@ -954,10 +1109,10 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n     {\n       if (!flow_bb_inside_loop_p (loop, bb_for_stmt (USE_STMT (use_p))))\n-        {\n-          exit_phi = USE_STMT (use_p);\n-          break;\n-        }\n+\t{\n+\t  exit_phi = USE_STMT (use_p);\n+\t  break;\n+\t}\n     }\n \n   orig_name = PHI_RESULT (exit_phi);\n@@ -1067,13 +1222,13 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"no optab for reduction.\");\n-      return false;\n+      reduc_code = NUM_TREE_CODES;\n     }\n   if (reduc_optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-        fprintf (vect_dump, \"op not supported by target.\");\n-      return false;\n+        fprintf (vect_dump, \"reduc op not supported by target.\");\n+      reduc_code = NUM_TREE_CODES;\n     }\n  \n   if (!vec_stmt) /* transformation not required.  */"}, {"sha": "26a8703b6db92f0f1f8a1de1cfdf06b8df2f8618", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b46ba2c84f81e70811e13581c99350cdc76400/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=a6b46ba2c84f81e70811e13581c99350cdc76400", "patch": "@@ -957,6 +957,12 @@ DEFTREECODE (REDUC_MAX_EXPR, \"reduc_max_expr\", tcc_unary, 1)\n DEFTREECODE (REDUC_MIN_EXPR, \"reduc_min_expr\", tcc_unary, 1)\n DEFTREECODE (REDUC_PLUS_EXPR, \"reduc_plus_expr\", tcc_unary, 1)\n \n+/* Whole vector lesft/right shift in bytes.\n+   Operand 0 is a vector to be shifted.\n+   Operand 1 is an integer shift amount in bits.  */\n+DEFTREECODE (VEC_LSHIFT_EXPR, \"vec_lshift_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_RSHIFT_EXPR, \"vec_rshift_expr\", tcc_binary, 2)\n+\n /*\n Local variables:\n mode:c"}]}