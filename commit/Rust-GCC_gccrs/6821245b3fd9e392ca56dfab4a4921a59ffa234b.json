{"sha": "6821245b3fd9e392ca56dfab4a4921a59ffa234b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyMTI0NWIzZmQ5ZTM5MmNhNTZkZmFiNGE0OTIxYTU5ZmZhMjM0Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-27T03:14:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-27T03:14:33Z"}, "message": "Remember the location of a variable template-id.\n\nI noticed that tsubst of a TEMPLATE_ID_EXPR was losing the location\ninformation from its EXPR_LOCATION.  Then I noticed that\ncxx_eval_constant_expression was also throwing away location information for\nvariable references.\n\n\t* pt.c (tsubst_copy_and_build) [TEMPLATE_ID_EXPR]: Remember the\n\tlocation of a variable template-id.\n\t* constexpr.c (cxx_eval_constant_expression): Get expr location\n\tbefore stripping location wrappers.\n\t(non_const_var_error): Take location argument.\n\nFrom-SVN: r278755", "tree": {"sha": "fbf6664ddf8b75e5751be33ff9a1987da6c3854e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbf6664ddf8b75e5751be33ff9a1987da6c3854e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6821245b3fd9e392ca56dfab4a4921a59ffa234b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6821245b3fd9e392ca56dfab4a4921a59ffa234b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6821245b3fd9e392ca56dfab4a4921a59ffa234b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6821245b3fd9e392ca56dfab4a4921a59ffa234b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88b34a4811a0a5237138bbd6700202c2f3569c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b34a4811a0a5237138bbd6700202c2f3569c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b34a4811a0a5237138bbd6700202c2f3569c7d"}], "stats": {"total": 75, "additions": 49, "deletions": 26}, "files": [{"sha": "6cf8579377d9c33fd7288ecc6413f7b5655865e2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6821245b3fd9e392ca56dfab4a4921a59ffa234b", "patch": "@@ -1,3 +1,11 @@\n+2019-11-26  Jason Merrill  <jason@redhat.com>\n+\n+\t* pt.c (tsubst_copy_and_build) [TEMPLATE_ID_EXPR]: Remember the\n+\tlocation of a variable template-id.\n+\t* constexpr.c (cxx_eval_constant_expression): Get expr location\n+\tbefore stripping location wrappers.\n+\t(non_const_var_error): Take location argument.\n+\n 2019-11-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* typeck.c (cp_build_unary_op): Consistently use the accurate"}, {"sha": "f648b1d8e4c255a41eb8181a707cd7a07da45508", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=6821245b3fd9e392ca56dfab4a4921a59ffa234b", "patch": "@@ -3786,27 +3786,27 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n    cxx_eval_constant_expression.  */\n \n static void\n-non_const_var_error (tree r)\n+non_const_var_error (location_t loc, tree r)\n {\n   auto_diagnostic_group d;\n   tree type = TREE_TYPE (r);\n   if (DECL_NAME (r) == heap_uninit_identifier\n       || DECL_NAME (r) == heap_identifier)\n     {\n-      error (\"the content of uninitialized storage is not usable \"\n-\t     \"in a constant expression\");\n+      error_at (loc, \"the content of uninitialized storage is not usable \"\n+\t\t\"in a constant expression\");\n       inform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n       return;\n     }\n   if (DECL_NAME (r) == heap_deleted_identifier)\n     {\n-      error (\"use of allocated storage after deallocation in a \"\n-\t     \"constant expression\");\n+      error_at (loc, \"use of allocated storage after deallocation in a \"\n+\t\t\"constant expression\");\n       inform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n       return;\n     }\n-  error (\"the value of %qD is not usable in a constant \"\n-\t \"expression\", r);\n+  error_at (loc, \"the value of %qD is not usable in a constant \"\n+\t    \"expression\", r);\n   /* Avoid error cascade.  */\n   if (DECL_INITIAL (r) == error_mark_node)\n     return;\n@@ -4765,6 +4765,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return t;\n     }\n \n+  location_t loc = cp_expr_loc_or_input_loc (t);\n+\n   STRIP_ANY_LOCATION_WRAPPER (t);\n \n   if (CONSTANT_CLASS_P (t))\n@@ -4794,7 +4796,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n   if (++ctx->global->constexpr_ops_count >= constexpr_ops_limit)\n     {\n       if (!ctx->quiet)\n-\terror_at (cp_expr_loc_or_input_loc (t),\n+\terror_at (loc,\n \t\t  \"%<constexpr%> evaluation operation count exceeds limit of \"\n \t\t  \"%wd (use %<-fconstexpr-ops-limit=%> to increase the limit)\",\n \t\t  constexpr_ops_limit);\n@@ -4877,7 +4879,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (DECL_P (r))\n \t{\n \t  if (!ctx->quiet)\n-\t    non_const_var_error (r);\n+\t    non_const_var_error (loc, r);\n \t  *non_constant_p = true;\n \t}\n       break;\n@@ -5086,9 +5088,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t  jump_target);\n \tif (!CLEANUP_EH_ONLY (t) && !*non_constant_p)\n \t  {\n-\t    location_t loc = input_location;\n-\t    if (EXPR_HAS_LOCATION (t))\n-\t      input_location = EXPR_LOCATION (t);\n+\t    iloc_sentinel ils (loc);\n \t    /* Also evaluate the cleanup.  If we weren't skipping at the\n \t       start of the CLEANUP_BODY, change jump_target temporarily\n \t       to &initial_jump_target, so that even a return or break or\n@@ -5097,7 +5097,6 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t  non_constant_p, overflow_p,\n \t\t\t\t\t  jump_target ? &initial_jump_target\n \t\t\t\t\t  : NULL);\n-\t    input_location = loc;\n \t  }\n       }\n       break;\n@@ -5365,7 +5364,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (REINTERPRET_CAST_P (t))\n \t{\n \t  if (!ctx->quiet)\n-\t    error_at (cp_expr_loc_or_input_loc (t),\n+\t    error_at (loc,\n \t\t      \"%<reinterpret_cast%> is not a constant expression\");\n \t  *non_constant_p = true;\n \t  return t;\n@@ -5405,7 +5404,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\tif (TYPE_REF_P (type))\n \t\t  {\n \t\t    if (!ctx->quiet)\n-\t\t      error_at (cp_expr_loc_or_input_loc (t),\n+\t\t      error_at (loc,\n \t\t\t\t\"dereferencing a null pointer\");\n \t\t    *non_constant_p = true;\n \t\t    return t;\n@@ -5417,7 +5416,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t    if (!can_convert (type, from, tf_none))\n \t\t      {\n \t\t\tif (!ctx->quiet)\n-\t\t\t  error_at (cp_expr_loc_or_input_loc (t),\n+\t\t\t  error_at (loc,\n \t\t\t\t    \"conversion of %qT null pointer to %qT \"\n \t\t\t\t    \"is not a constant expression\",\n \t\t\t\t    from, type);\n@@ -5432,8 +5431,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t     reinterpret_cast<void*>(sizeof 0)\n \t\t*/\n \t\tif (!ctx->quiet)\n-\t\t  error_at (cp_expr_loc_or_input_loc (t),\n-\t\t\t    \"%<reinterpret_cast<%T>(%E)%> is not \"\n+\t\t  error_at (loc, \"%<reinterpret_cast<%T>(%E)%> is not \"\n \t\t\t    \"a constant expression\",\n \t\t\t    type, op);\n \t\t*non_constant_p = true;\n@@ -5534,8 +5532,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case BASELINK:\n     case OFFSET_REF:\n       if (!ctx->quiet)\n-        error_at (cp_expr_loc_or_input_loc (t),\n-\t\t  \"expression %qE is not a constant expression\", t);\n+\terror_at (loc, \"expression %qE is not a constant expression\", t);\n       *non_constant_p = true;\n       break;\n \n@@ -5552,8 +5549,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    || !DECL_P (get_base_address (TREE_OPERAND (obj, 0))))\n \t  {\n \t    if (!ctx->quiet)\n-\t      error_at (cp_expr_loc_or_input_loc (t),\n-\t\t\t\"expression %qE is not a constant expression\", t);\n+\t      error_at (loc, \"expression %qE is not a constant expression\", t);\n \t    *non_constant_p = true;\n \t    return t;\n \t  }\n@@ -5661,7 +5657,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case ASM_EXPR:\n       if (!ctx->quiet)\n-\tinline_asm_in_constexpr_error (cp_expr_loc_or_input_loc (t));\n+\tinline_asm_in_constexpr_error (loc);\n       *non_constant_p = true;\n       return t;\n \n@@ -6724,7 +6720,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  && !is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/false))\n         {\n           if (flags & tf_error)\n-            non_const_var_error (t);\n+\t    non_const_var_error (loc, t);\n           return false;\n         }\n       return true;"}, {"sha": "a11718ed41e7441234e8d9451bc1d9d7651695b3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6821245b3fd9e392ca56dfab4a4921a59ffa234b", "patch": "@@ -18870,7 +18870,12 @@ tsubst_copy_and_build (tree t,\n \t  }\n \n \tif (variable_template_p (templ))\n-\t  RETURN (lookup_and_finish_template_variable (templ, targs, complain));\n+\t  {\n+\t    tree r = lookup_and_finish_template_variable (templ, targs,\n+\t\t\t\t\t\t\t  complain);\n+\t    r = maybe_wrap_with_location (r, EXPR_LOCATION (t));\n+\t    RETURN (r);\n+\t  }\n \n \tif (TREE_CODE (templ) == COMPONENT_REF)\n \t  {"}, {"sha": "029ec7a1186b48bd3e4ef97a81e692909b71295c", "filename": "gcc/testsuite/g++.dg/concepts/pr67595.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67595.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67595.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr67595.C?ref=6821245b3fd9e392ca56dfab4a4921a59ffa234b", "patch": "@@ -9,6 +9,6 @@ template <class X> bool input_iterator{weak_input_iterator<X>}; // { dg-warning\n template <class X> bool forward_iterator{input_iterator<X>};\n template <class X> bool bidirectional_iterator{forward_iterator<X>};\n template <class X>\n-concept bool random_access_iterator{bidirectional_iterator<X>};\n+concept bool random_access_iterator{bidirectional_iterator<X>}; // { dg-error \"constant\" }\n void fn1(random_access_iterator);\n int main() { fn1(0); }  // { dg-error \"\" }"}, {"sha": "4e2b43b1d07d24cbb801633ec9e822467a8cf002", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ64.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ64.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6821245b3fd9e392ca56dfab4a4921a59ffa234b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ64.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ64.C?ref=6821245b3fd9e392ca56dfab4a4921a59ffa234b", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++14 } }\n+\n+template <class T> T var = T();\n+\n+template <class T>\n+void f()\n+{\n+  constexpr T i = var<T>;\t// { dg-error \"19:var\" }\n+}\n+\n+int main()\n+{\n+  f<int>();\n+}"}]}