{"sha": "914ec131d6bc1b87347a5a03de96bd69b942e4f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE0ZWMxMzFkNmJjMWI4NzM0N2E1YTAzZGU5NmJkNjliOTQyZTRmNw==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@dg-rtp.dg.com", "date": "1997-09-05T05:14:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-05T05:14:46Z"}, "message": "reg-stack.c (subst_stack_regs): Pop the stack register for a computed goto which sets the same stack register.\n\n        * reg-stack.c (subst_stack_regs): Pop the stack register for a\n        computed goto which sets the same stack register.\n\n        * reg-stack.c (compare_for_stack_reg): Swap only if the source and\n        destination are both on the regstack.\n        (subst_stack_regs_pat): Put the destination at the top of the regstack.\nBring over regstack bugfixes from the FSF.\n\nFrom-SVN: r15096", "tree": {"sha": "e53b9cd27e7f6e24f25c038463c220de666545a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e53b9cd27e7f6e24f25c038463c220de666545a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/914ec131d6bc1b87347a5a03de96bd69b942e4f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/914ec131d6bc1b87347a5a03de96bd69b942e4f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/914ec131d6bc1b87347a5a03de96bd69b942e4f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/914ec131d6bc1b87347a5a03de96bd69b942e4f7/comments", "author": null, "committer": null, "parents": [{"sha": "d5d1738a3a56748bc7c8c9f591d18d6bae469b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d1738a3a56748bc7c8c9f591d18d6bae469b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d1738a3a56748bc7c8c9f591d18d6bae469b6c"}], "stats": {"total": 68, "additions": 59, "deletions": 9}, "files": [{"sha": "8c48d61f4677b81c4a91c2ad74701bb4177196c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/914ec131d6bc1b87347a5a03de96bd69b942e4f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/914ec131d6bc1b87347a5a03de96bd69b942e4f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=914ec131d6bc1b87347a5a03de96bd69b942e4f7", "patch": "@@ -1,3 +1,12 @@\n+Thu Sep  4 23:14:27 1997  Stan Cox  (coxs@dg-rtp.dg.com)\n+\n+\t* reg-stack.c (subst_stack_regs): Pop the stack register for a\n+\tcomputed goto which sets the same stack register.\n+\n+\t* reg-stack.c (compare_for_stack_reg): Swap only if the source and\n+\tdestination are both on the regstack.\n+\t(subst_stack_regs_pat): Put the destination at the top of the regstack.\n+\n Thu Sep  4 15:02:27 1997  Jim Wilson  <wilson@cygnus.com>\n \n \t* mips.md (nonlocal_goto_receiver): Define."}, {"sha": "881d94ffaa0b471a28468fd8468dcd838ca2ae16", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/914ec131d6bc1b87347a5a03de96bd69b942e4f7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/914ec131d6bc1b87347a5a03de96bd69b942e4f7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=914ec131d6bc1b87347a5a03de96bd69b942e4f7", "patch": "@@ -1,5 +1,5 @@\n /* Register to Stack convert for GNU compiler.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -2018,6 +2018,7 @@ compare_for_stack_reg (insn, regstack, pat)\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n   rtx cc0_user;\n+  int have_cmove; \n \n   src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n   src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n@@ -2032,11 +2033,16 @@ compare_for_stack_reg (insn, regstack, pat)\n       rtx *dest, src_note;\n       \n       dest = get_true_reg (&SET_DEST (PATTERN (cc0_user)));\n-      if (REGNO (*dest) != regstack->reg[regstack->top])\n+\n+      have_cmove = 1;\n+      if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG\n+\t  && REGNO (*dest) != regstack->reg[regstack->top])\n \t{\n \t  emit_swap_insn (insn, regstack, *dest);\t\n \t}\n     }\n+  else\n+    have_cmove = 0;\n \n   /* ??? If fxch turns out to be cheaper than fstp, give priority to\n      registers that die in this insn - move those to stack top first.  */\n@@ -2071,7 +2077,8 @@ compare_for_stack_reg (insn, regstack, pat)\n   else\n     src2_note = NULL_RTX;\n \n-  emit_swap_insn (insn, regstack, *src1);\n+  if (! have_cmove)\n+     emit_swap_insn (insn, regstack, *src1);\n \n   replace_reg (src1, FIRST_STACK_REG);\n \n@@ -2378,8 +2385,6 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t  for (i = 1; i <= 2; i++)\n \t    if (src_note [i])\n \t      {\n-\t\tint regno = get_hard_regnum (regstack, XEXP (src_note [i], 0));\n-\n \t\t/* If the register that dies is not at the top of stack, then\n \t\t   move the top of stack to the dead reg */\n \t\tif (REGNO (XEXP (src_note[i], 0))\n@@ -2397,13 +2402,15 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\t    replace_reg (&XEXP (src_note[i], 0), FIRST_STACK_REG);\n \t\t    regstack->top--;\n \t\t  }\n-\t\t\n \t      }\n-\n-\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t  replace_reg (dest, FIRST_STACK_REG);\n \t}\n \n+\t/* Make dest the top of stack.  Add dest to regstack if not present. */\n+\tif (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n+\t  regstack->reg[++regstack->top] = REGNO (*dest);\t\n+\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\treplace_reg (dest, FIRST_STACK_REG);\n+\n \tbreak;\n \n       default:\n@@ -2719,6 +2726,7 @@ subst_stack_regs (insn, regstack)\n {\n   register rtx *note_link, note;\n   register int i;\n+  rtx head, jump, pat, cipat;\n   int n_operands;\n \n   if (GET_CODE (insn) == CALL_INSN)\n@@ -2790,6 +2798,39 @@ subst_stack_regs (insn, regstack)\n   if (GET_CODE (insn) == NOTE)\n     return;\n \n+  /* If we are reached by a computed goto which sets this same stack register,\n+     then pop this stack register, but maintain regstack. */\n+\n+  pat = single_set (insn);\n+  if (pat != 0\n+      && INSN_UID (insn) <= max_uid\n+      && GET_CODE (block_begin[BLOCK_NUM(insn)]) == CODE_LABEL\n+      && GET_CODE (pat) == SET && STACK_REG_P (SET_DEST (pat)))\n+    for (head = block_begin[BLOCK_NUM(insn)], jump = LABEL_REFS (head);\n+\t jump != head;\n+\t jump = LABEL_NEXTREF (jump))\n+      {\n+\tcipat = single_set (CONTAINING_INSN (jump));\n+\tif (cipat != 0\n+\t    && GET_CODE (cipat) == SET\n+\t    && SET_DEST (cipat) == pc_rtx\n+\t    && uses_reg_or_mem (SET_SRC (cipat))\n+\t    && INSN_UID (CONTAINING_INSN (jump)) <= max_uid)\n+\t  {\n+\t    int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n+\t    if (TEST_HARD_REG_BIT (block_out_reg_set[from_block],\n+\t\t\t\t   REGNO (SET_DEST (pat))))\n+\t      {\n+\t\tstruct stack_def old;\n+\t\tbcopy (regstack->reg, old.reg, sizeof (old.reg));\n+\t\temit_pop_insn (insn, regstack, SET_DEST (pat), emit_insn_before);\n+\t\tregstack->top += 1;\n+\t\tbcopy (old.reg, regstack->reg, sizeof (old.reg));\n+\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (SET_DEST (pat)));\n+\t      }\n+\t  }\n+      }\n+\n   /* If there is a REG_UNUSED note on a stack register on this insn,\n      the indicated reg must be popped.  The REG_UNUSED note is removed,\n      since the form of the newly emitted pop insn references the reg,"}]}