{"sha": "e4689f195c69060c720c10c35188573750c193a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ2ODlmMTk1YzY5MDYwYzcyMGMxMGMzNTE4ODU3Mzc1MGMxOTNhNQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-02T10:29:02Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-02T10:29:02Z"}, "message": "(blockage insn): Renamed from profiler.\n\n\t(epilogue insn): Don't provide this if a return insn will suffice.\n\t(m88k_end_epilogue): If the last insn isn't a barrier, print a return.\n(compare word insns): New insns and define_split\n\tpatterns to take advantage of recent fold_truthop change.\n\t(superoptimizer sequences): New define_split patterns.\n\t(add/sub with carry): New insns.\n\t(add/sub DImode, ffssi2): Clobber the condition code register.\n\nFrom-SVN: r1383", "tree": {"sha": "b1523ad2158fe81aca86260e750301e10a40aa51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1523ad2158fe81aca86260e750301e10a40aa51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4689f195c69060c720c10c35188573750c193a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4689f195c69060c720c10c35188573750c193a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4689f195c69060c720c10c35188573750c193a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4689f195c69060c720c10c35188573750c193a5/comments", "author": null, "committer": null, "parents": [{"sha": "c8b9d354bb53ad02a47ad700400006211acf1743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b9d354bb53ad02a47ad700400006211acf1743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8b9d354bb53ad02a47ad700400006211acf1743"}], "stats": {"total": 502, "additions": 492, "deletions": 10}, "files": [{"sha": "2efc2f9c045b5df9cba8ecb3b88d77405d408e97", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 492, "deletions": 10, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4689f195c69060c720c10c35188573750c193a5/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4689f195c69060c720c10c35188573750c193a5/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=e4689f195c69060c720c10c35188573750c193a5", "patch": "@@ -28,7 +28,7 @@\n (define_expand \"m88k_sccs_id\"\n   [(match_operand:SI 0 \"\" \"\")]\n   \"\"\n-  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.2.3.13 29 Jun 1992 16:41:06\\\";\n+  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.2.6.5 01 Jul 1992 18:47:08\\\";\n      FAIL; }\")\n \f\n ;; Attribute specifications\n@@ -210,6 +210,129 @@\n ;(define_function_unit \"writeback\" 1 1 (eq_attr \"type\" \"store\") 0 1)\n ;(define_function_unit \"memory\" 1 3 (eq_attr \"type\" \"store\") 1 2)\n \f\n+;; Superoptimizer sequences\n+\n+;; geu+: { r = ((unsigned_word) v0 >= (unsigned_word) v1) + v2; }\n+;;      subu.co r5,r2,r3\n+;;      addu.cio r6,r4,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (geu:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 3 \"register_operand\" \"r\"))))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_dup 2) (match_dup 3)] 1))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 1)\n+\t\t (unspec:SI [(const_int 0)\n+\t\t\t     (reg:CC 0)] 0)))]\n+  \"\")\n+\n+;; leu+: { r = ((unsigned_word) v0 <= (unsigned_word) v1) + v2; }\n+;;      subu.co r5,r3,r2\n+;;      addu.cio r6,r4,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (leu:SI (match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_dup 2) (match_dup 3)] 1))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 1)\n+\t\t (unspec:SI [(const_int 0)\n+\t\t\t     (reg:CC 0)] 0)))]\n+  \"\")\n+\n+;; eq0+: { r = (v0 == 0) + v1; }\n+;;      subu.co r4,r0,r2\n+;;      addu.cio r5,r3,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (eq:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t (const_int 0))))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(const_int 0) (match_dup 2)] 1))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 1)\n+\t\t (unspec:SI [(const_int 0)\n+\t\t\t     (reg:CC 0)] 0)))]\n+  \"\")\n+\n+;; ltu-:  { r = v2 - ((unsigned_word) v0 < (unsigned_word) v1); }\n+;;      subu.co r5,r2,r3\n+;;      subu.cio r6,r4,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (ltu:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"r\"))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_dup 2) (match_dup 3)] 1))\n+   (set (match_dup 0)\n+\t(minus:SI (match_dup 1)\n+\t\t  (unspec:SI [(const_int 0)\n+\t\t\t      (reg:CC 0)] 1)))]\n+  \"\")\n+\n+;; gtu-: { r = v2 - ((unsigned_word) v0 > (unsigned_word) v1); }\n+;;      subu.co r5,r3,r2\n+;;      subu.cio r6,r4,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (gtu:SI (match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_dup 2) (match_dup 3)] 1))\n+   (set (match_dup 0)\n+\t(minus:SI (match_dup 1)\n+\t\t (unspec:SI [(const_int 0)\n+\t\t\t     (reg:CC 0)] 1)))]\n+  \"\")\n+\n+;; ne0-: { r = v1 - (v0 != 0); }\n+;;      subu.co r4,r0,r2\n+;;      subu.cio r5,r3,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (ne:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t(const_int 0))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(const_int 0) (match_dup 2)] 1))\n+   (set (match_dup 0)\n+\t(minus:SI (match_dup 1)\n+\t\t  (unspec:SI [(const_int 0)\n+\t\t\t      (reg:CC 0)] 1)))]\n+  \"\")\n+\n+;; ges0-: { r = v1 - ((signed_word) v0 >= 0); }\n+;;\taddu.co\tr4,r2,r2\n+;;\tsubu.cio r5,r3,r0\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (xor:SI (lshiftrt:SI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t   (const_int 31))\n+\t\t\t  (const_int 1))))]\n+  \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_dup 2) (match_dup 2)] 0))\n+   (set (match_dup 0)\n+\t(minus:SI (match_dup 1)\n+\t\t  (unspec:SI [(const_int 0)\n+\t\t\t      (reg:CC 0)] 1)))]\n+  \"\")\n+\f\n ;; This rich set of complex patterns are mostly due to Torbjorn Granlund\n ;; (tege@sics.se).  They've changed since then, so don't complain to him\n ;; if they don't work right.\n@@ -313,6 +436,277 @@\n }\"\n   [(set_attr \"type\" \"marith\")]) ; arith,bit,marith.  length is 1 or 2.\n \f\n+;; Improve logical operations on compare words\n+;;\n+;; We define all logical operations on CCmode values to preserve the pairwise\n+;; relationship of the compare bits.  This allows a future branch prediction\n+;; pass the degree of freedom needed to change and/bb0-le into or/bb1-gt.\n+;;\n+;; Opportunities arise when conditional expressions using && and || are made\n+;; unconditional.  When these are used to branch, the sequence is\n+;; cmp/cmp/extu/extu/{and,or}/bcnd-{eq0,ne0}.  When these are used to create\n+;; a value, the sequence is cmp/cmp/extu/extu/{and,or} for 1 or 0 or\n+;; cmp/cmp/ext/ext/{and,or} for -1 or 0.\n+;;\n+;; When the extracted conditions are the same, the define_split patterns\n+;; below change extu/extu/{and,or} into {and,or}/extu.  If the reversed\n+;; conditions match, one compare word can be complimented, resulting in\n+;; {and.c,or.c}/extu.  These changes are done for ext/ext/{and,or} as well.\n+;; If the conditions don't line up, one can be rotated.  To keep the pairwise\n+;; relationship, it may be necessary to both rotate and compliment.  Rotating\n+;; makes branching cheaper, but doesn't help (or hurt) creating a value, so\n+;; we don't do this for ext/ext/{and,or}.\n+;;\n+;; These changes result in the sequence extu/bcnd-{eq0,ne0} which is combined\n+;; into an alternate form of bb0 and bb1.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (neg:SI \n+\t\t (match_operator 1 \"relop\"\n+\t\t\t\t [(match_operand:CC 2 \"register_operand\" \"%r\")\n+\t\t\t\t  (const_int 0)]))\n+\t\t(neg:SI\n+\t\t (match_operator 3 \"relop\"\n+\t\t\t\t [(match_operand:CC 4 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 0)]))))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))]\n+  \"\"\n+  [(set (match_dup 5)\n+\t(ior:CC (match_dup 4)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(neg:SI (match_op_dup 1 [(match_dup 5) (const_int 0)])))]\n+  \"operands[5] = gen_rtx (SUBREG, CCmode, operands[5], 0);\n+   if (GET_CODE (operands[1]) == GET_CODE (operands[3]))\n+     ; /* The conditions match.  */\n+   else if (GET_CODE (operands[1])\n+\t    == reverse_condition (GET_CODE (operands[3])))\n+     /* Reverse the condition by complimenting the compare word.  */\n+     operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+   else\n+     {\n+       /* Make the condition pairs line up by rotating the compare word.  */\n+       int cv1 = condition_value (operands[1]);\n+       int cv2 = condition_value (operands[3]);\n+\n+       operands[4] = gen_rtx (ROTATE, CCmode, operands[4],\n+\t\t\t      gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t       ((cv2 & ~1) - (cv1 & ~1)) & 0x1f));\n+       /* Reverse the condition if needed.  */\n+       if ((cv1 & 1) != (cv2 & 1))\n+\t operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+     }\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operator 1 \"relop\"\n+\t\t\t\t[(match_operand:CC 2 \"register_operand\" \"%r\")\n+\t\t\t\t (const_int 0)])\n+\t\t(match_operator 3 \"relop\"\n+\t\t\t\t[(match_operand:CC 4 \"register_operand\" \"r\")\n+\t\t\t\t (const_int 0)])))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))]\n+  \"GET_CODE (operands[1]) == GET_CODE (operands[3])\n+   || GET_CODE (operands[1]) == reverse_condition (GET_CODE (operands[3]))\"\n+  [(set (match_dup 5)\n+\t(ior:CC (match_dup 4)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n+  \"operands[5] = gen_rtx (SUBREG, CCmode, operands[5], 0);\n+   /* Reverse the condition by  complimenting the compare word.  */\n+   if (GET_CODE (operands[1]) != GET_CODE (operands[3]))\n+      operands[4] = gen_rtx (NOT, CCmode, operands[4]);\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (neg:SI \n+\t\t (match_operator 1 \"relop\"\n+\t\t\t\t [(match_operand:CC 2 \"register_operand\" \"%r\")\n+\t\t\t\t  (const_int 0)]))\n+\t\t(neg:SI\n+\t\t (match_operator 3 \"relop\"\n+\t\t\t\t [(match_operand:CC 4 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 0)]))))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))]\n+  \"\"\n+  [(set (match_dup 5)\n+\t(and:CC (match_dup 4)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(neg:SI (match_op_dup 1 [(match_dup 5) (const_int 0)])))]\n+  \"operands[5] = gen_rtx (SUBREG, CCmode, operands[5], 0);\n+   if (GET_CODE (operands[1]) == GET_CODE (operands[3]))\n+     ; /* The conditions match.  */\n+   else if (GET_CODE (operands[1])\n+\t    == reverse_condition (GET_CODE (operands[3])))\n+     /* Reverse the condition by complimenting the compare word.  */\n+     operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+   else\n+     {\n+       /* Make the condition pairs line up by rotating the compare word.  */\n+       int cv1 = condition_value (operands[1]);\n+       int cv2 = condition_value (operands[3]);\n+\n+       operands[4] = gen_rtx (ROTATE, CCmode, operands[4],\n+\t\t\t      gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t       ((cv2 & ~1) - (cv1 & ~1)) & 0x1f));\n+       /* Reverse the condition if needed.  */\n+       if ((cv1 & 1) != (cv2 & 1))\n+\t operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+     }\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operator 1 \"relop\"\n+\t\t\t\t[(match_operand:CC 2 \"register_operand\" \"%r\")\n+\t\t\t\t (const_int 0)])\n+\t\t(match_operator 3 \"relop\"\n+\t\t\t\t[(match_operand:CC 4 \"register_operand\" \"r\")\n+\t\t\t\t (const_int 0)])))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))]\n+  \"GET_CODE (operands[1]) == GET_CODE (operands[3])\n+   || GET_CODE (operands[1]) == reverse_condition (GET_CODE (operands[3]))\"\n+  [(set (match_dup 5)\n+\t(and:CC (match_dup 4)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n+  \"operands[5] = gen_rtx (SUBREG, CCmode, operands[5], 0);\n+   /* Reverse the condition by  complimenting the compare word.  */\n+   if (GET_CODE (operands[1]) != GET_CODE (operands[3]))\n+      operands[4] = gen_rtx (NOT, CCmode, operands[4]);\")\n+\f\n+;; Logical operations on compare words.\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(and:CC (not:CC (match_operand:CC 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:CC 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and.c %0,%2,%1\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(and:CC (match_operand:CC 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:CC 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(ior:CC (not:CC (match_operand:CC 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:CC 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or.c %0,%2,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(ior:CC (match_operand:CC 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:CC 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:CC 2 \"int5_operand\" \"\")))]\n+  \"\"\n+  \"rot %0,%1,%2\"\n+  [(set_attr \"type\" \"bit\")])\n+\n+;; rotate/and[.c] and rotate/ior[.c]\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(ior:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\"))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:CC 4 \"=r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(ior:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\"))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_operand:CC 4 \"register_operand\" \"=r\"))]\n+  \"\"\n+  [(set (match_dup 4)\n+\t(rotate:CC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ior:CC (match_dup 4) (match_dup 3)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(ior:CC (not:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\")))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:CC 4 \"=r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(ior:CC (not:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\")))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_operand:CC 4 \"register_operand\" \"=r\"))]\n+  \"\"\n+  [(set (match_dup 4)\n+\t(rotate:CC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ior:CC (not:CC (match_dup 4)) (match_dup 3)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(and:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\"))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:CC 4 \"=r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(and:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\"))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_operand:CC 4 \"register_operand\" \"=r\"))]\n+  \"\"\n+  [(set (match_dup 4)\n+\t(rotate:CC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ior:CC (match_dup 4) (match_dup 3)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(and:CC (not:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\")))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:CC 4 \"=r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(and:CC (not:CC (rotate:CC (match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:CC 2 \"int5_operand\" \"\")))\n+\t\t(match_operand:CC 3 \"register_operand\" \"r\")))\n+   (clobber (match_operand:CC 4 \"register_operand\" \"=r\"))]\n+  \"\"\n+  [(set (match_dup 4)\n+\t(rotate:CC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(and:CC (not:CC (match_dup 4)) (match_dup 3)))]\n+  \"\")\n+\f\n ;; Recognize bcnd instructions for integer values.  This is distinguished\n ;; from a conditional branch instruction (below) with SImode instead of\n ;; CCmode.\n@@ -1008,6 +1402,35 @@\n     return \\\"bb1%. %R3%C0,%1,%P2%P3\\\";\n }\"\n   [(set_attr \"type\" \"branch\")])\n+\n+;; Branch conditional on scc values.  These arise from manipulations on\n+;; compare words above.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operator 0 \"relop\"\n+\t\t\t     [(match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t      (const_int 0)])\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb1%. %R3%C0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (match_operator 0 \"relop\"\n+\t\t\t     [(match_operand:CC 1 \"register_operand\" \"r\")\n+\t\t\t      (const_int 0)])\n+\t     (const_int 0))\n+\t (match_operand 2 \"pc_or_label_ref\" \"\")\n+\t (match_operand 3 \"pc_or_label_ref\" \"\")))]\n+  \"\"\n+  \"bb0%. %R3%C0,%1,%P2%P3\"\n+  [(set_attr \"type\" \"branch\")])\n \f\n (define_insn \"locate1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"r\")\n@@ -1713,7 +2136,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t (zero_extend:DI\n-\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:CC 0))]\n   \"\"\n   \"addu.co %d0,%d1,%2\\;addu.ci %0,%1,%#r0\"\n   [(set_attr \"type\" \"marith\")])\n@@ -1722,18 +2146,46 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (zero_extend:DI\n \t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 0))]\n   \"\"\n   \"addu.co %d0,%1,%d2\\;addu.ci %0,%#r0,%2\"\n   [(set_attr \"type\" \"marith\")])\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 0))]\n   \"\"\n   \"addu.co %d0,%d1,%d2\\;addu.ci %0,%1,%2\"\n   [(set_attr \"type\" \"marith\")])\n+\n+;; Add with carry insns.\n+\n+(define_insn \"\"\n+  [(parallel [(set (match_operand:SI 0 \"reg_or_0_operand\" \"r\")\n+\t\t   (plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t    (match_operand:SI 2 \"reg_or_0_operand\" \"rO\")))\n+\t      (set (reg:CC 0)\n+\t\t   (unspec:CC [(match_dup 1) (match_dup 2)] 0))])]\n+  \"\"\n+  \"addu.co %r0,%r1,%r2\")\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_operand:SI 0 \"reg_or_0_operand\" \"rO\")\n+\t\t\t       (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")]\n+\t\t\t      0))]\n+  \"\"\n+  \"addu.co %#r0,%r0,%r1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"reg_or_0_operand\" \"r\")\n+\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t (unspec:SI [(match_operand:SI 2 \"reg_or_0_operand\" \"rO\")\n+\t\t\t     (reg:CC 0)] 0)))]\n+  \"\"\n+  \"addu.ci %r0,%r1,%r2\")\n \f\n ;;- subtract instructions\n \n@@ -1804,7 +2256,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t  (zero_extend:DI\n-\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:CC 0))]\n   \"\"\n   \"subu.co %d0,%d1,%2\\;subu.ci %0,%1,%#r0\"\n   [(set_attr \"type\" \"marith\")])\n@@ -1813,18 +2266,46 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (zero_extend:DI\n \t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 0))]\n   \"\"\n   \"subu.co %d0,%1,%d2\\;subu.ci %0,%#r0,%2\"\n   [(set_attr \"type\" \"marith\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 0))]\n   \"\"\n   \"subu.co %d0,%d1,%d2\\;subu.ci %0,%1,%2\"\n   [(set_attr \"type\" \"marith\")])\n+\n+;; Subtract with carry insns.\n+\n+(define_insn \"\"\n+  [(parallel [(set (match_operand:SI 0 \"reg_or_0_operand\" \"r\")\n+\t\t   (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t     (match_operand:SI 2 \"reg_or_0_operand\" \"rO\")))\n+\t      (set (reg:CC 0)\n+\t\t   (unspec:CC [(match_dup 1) (match_dup 2)] 1))])]\n+  \"\"\n+  \"subu.co %r0,%r1,%r2\")\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0) (unspec:CC [(match_operand:SI 0 \"reg_or_0_operand\" \"rO\")\n+\t\t\t       (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")]\n+\t\t\t      1))]\n+  \"\"\n+  \"subu.co %#r0,%r0,%r1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"reg_or_0_operand\" \"r\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t  (unspec:SI [(match_operand:SI 2 \"reg_or_0_operand\" \"rO\")\n+\t\t\t      (reg:CC 0)] 1)))]\n+  \"\"\n+  \"subu.ci %r0,%r1,%r2\")\n \f\n ;;- multiply instructions\n ;;\n@@ -2790,6 +3271,7 @@\n (define_insn \"ffssi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,&r\")\n \t(ffs:SI (match_operand:SI 1 \"register_operand\" \"0,r\")))\n+   (clobber (reg:CC 0))\n    (clobber (match_scratch:SI 2 \"=r,X\"))]\n   \"\"\n   \"@\n@@ -3087,7 +3569,7 @@\n \n (define_insn \"return\"\n   [(return)]\n-  \"null_epilogue ()\"\n+  \"null_prologue ()\"\n   \"jmp%. %#r1\"\n   [(set_attr \"type\" \"jump\")])\n \n@@ -3098,10 +3580,10 @@\n \n (define_expand \"epilogue\"\n   [(set (pc) (reg:SI 1))]\n-  \"\"\n+  \"! null_prologue ()\"\n   \"m88k_expand_epilogue ();\")\n \n-(define_insn \"profiler\"\n+(define_insn \"blockage\"\n   [(unspec_volatile [(const_int 0)] 0)]\n   \"\"\n   \"\""}]}