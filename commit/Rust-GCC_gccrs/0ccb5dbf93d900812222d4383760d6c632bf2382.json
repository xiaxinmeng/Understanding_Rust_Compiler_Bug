{"sha": "0ccb5dbf93d900812222d4383760d6c632bf2382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNjYjVkYmY5M2Q5MDA4MTIyMjJkNDM4Mzc2MGQ2YzYzMmJmMjM4Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-09-30T15:00:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-09-30T15:00:12Z"}, "message": "re PR tree-optimization/46309 (optimization a==3||a==1)\n\n\tPR tree-optimization/46309\n\t* fold-const.c (make_range, merge_ranges): Remove prototypes.\n\t(make_range_step): New function.\n\t(make_range): Use it.\n\t* tree.h (make_range_step): New prototypes.\n\t* Makefile.in (tree-ssa-reassoc.o): Depend on $(DIAGNOSTIC_CORE_H).\n\t* tree-ssa-reassoc.c: Include diagnostic-core.h.\n\t(struct range_entry): New type.\n\t(init_range_entry, range_entry_cmp, update_range_test,\n\toptimize_range_tests): New functions.\n\t(reassociate_bb): Call optimize_range_tests.\n\n\t* gcc.dg/pr46309.c: New test.\n\nFrom-SVN: r179388", "tree": {"sha": "573817e015f2034176cc6127bcda920e8e5f7953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/573817e015f2034176cc6127bcda920e8e5f7953"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ccb5dbf93d900812222d4383760d6c632bf2382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ccb5dbf93d900812222d4383760d6c632bf2382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ccb5dbf93d900812222d4383760d6c632bf2382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ccb5dbf93d900812222d4383760d6c632bf2382/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "915afed63edcfbc614b3357d0862a4124a156d3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915afed63edcfbc614b3357d0862a4124a156d3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915afed63edcfbc614b3357d0862a4124a156d3a"}], "stats": {"total": 1047, "additions": 803, "deletions": 244}, "files": [{"sha": "5195d04073fd79d9a9df9b5fa7ecce938050e073", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -1,3 +1,17 @@\n+2011-09-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/46309\n+\t* fold-const.c (make_range, merge_ranges): Remove prototypes.\n+\t(make_range_step): New function.\n+\t(make_range): Use it.\n+\t* tree.h (make_range_step): New prototypes.\n+\t* Makefile.in (tree-ssa-reassoc.o): Depend on $(DIAGNOSTIC_CORE_H).\n+\t* tree-ssa-reassoc.c: Include diagnostic-core.h.\n+\t(struct range_entry): New type.\n+\t(init_range_entry, range_entry_cmp, update_range_test,\n+\toptimize_range_tests): New functions.\n+\t(reassociate_bb): Call optimize_range_tests.\n+\n 2011-09-30  Jakub Jelinek  <jakub@redhat.com>\n \t    Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "cca9c4b120422419946c30f77871febcfabada2f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -2650,7 +2650,7 @@ tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) \\\n    tree-iterator.h $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_INLINE_H) \\\n    $(VEC_H) langhooks.h alloc-pool.h pointer-set.h $(CFGLOOP_H) \\\n-   tree-pretty-print.h gimple-pretty-print.h\n+   tree-pretty-print.h gimple-pretty-print.h $(DIAGNOSTIC_CORE_H)\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_P_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) $(BASIC_BLOCK_H) $(FLAGS_H) $(TIMEVAR_H) $(TM_H) \\"}, {"sha": "79ebd8b5701841eff8944b7d7a74f968d001a22d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 260, "deletions": 243, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -115,9 +115,6 @@ static int simple_operand_p (const_tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n static tree range_successor (tree);\n-extern tree make_range (tree, int *, tree *, tree *, bool *);\n-extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n-\t\t\t  tree, tree);\n static tree fold_range_test (location_t, enum tree_code, tree, tree, tree);\n static tree fold_cond_expr_with_comparison (location_t, tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n@@ -3790,288 +3787,308 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n   return constant_boolean_node (result, type);\n }\n \f\n-/* Given EXP, a logical expression, set the range it is testing into\n-   variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression\n-   actually being tested.  *PLOW and *PHIGH will be made of the same\n-   type as the returned expression.  If EXP is not a comparison, we\n-   will most likely not be returning a useful value and range.  Set\n-   *STRICT_OVERFLOW_P to true if the return value is only valid\n-   because signed overflow is undefined; otherwise, do not change\n-   *STRICT_OVERFLOW_P.  */\n+/* Helper routine for make_range.  Perform one step for it, return\n+   new expression if the loop should continue or NULL_TREE if it should\n+   stop.  */\n \n tree\n-make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n-\t    bool *strict_overflow_p)\n+make_range_step (location_t loc, enum tree_code code, tree arg0, tree arg1,\n+\t\t tree exp_type, tree *p_low, tree *p_high, int *p_in_p,\n+\t\t bool *strict_overflow_p)\n {\n-  enum tree_code code;\n-  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n-  tree exp_type = NULL_TREE, arg0_type = NULL_TREE;\n-  int in_p, n_in_p;\n-  tree low, high, n_low, n_high;\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  /* Start with simply saying \"EXP != 0\" and then look at the code of EXP\n-     and see if we can refine the range.  Some of the cases below may not\n-     happen, but it doesn't seem worth worrying about this.  We \"continue\"\n-     the outer loop when we've changed something; otherwise we \"break\"\n-     the switch, which will \"break\" the while.  */\n-\n-  in_p = 0;\n-  low = high = build_int_cst (TREE_TYPE (exp), 0);\n+  tree arg0_type = TREE_TYPE (arg0);\n+  tree n_low, n_high, low = *p_low, high = *p_high;\n+  int in_p = *p_in_p, n_in_p;\n \n-  while (1)\n+  switch (code)\n     {\n-      code = TREE_CODE (exp);\n-      exp_type = TREE_TYPE (exp);\n+    case TRUTH_NOT_EXPR:\n+      *p_in_p = ! in_p;\n+      return arg0;\n+\n+    case EQ_EXPR: case NE_EXPR:\n+    case LT_EXPR: case LE_EXPR: case GE_EXPR: case GT_EXPR:\n+      /* We can only do something if the range is testing for zero\n+\t and if the second operand is an integer constant.  Note that\n+\t saying something is \"in\" the range we make is done by\n+\t complementing IN_P since it will set in the initial case of\n+\t being not equal to zero; \"out\" is leaving it alone.  */\n+      if (low == NULL_TREE || high == NULL_TREE\n+\t  || ! integer_zerop (low) || ! integer_zerop (high)\n+\t  || TREE_CODE (arg1) != INTEGER_CST)\n+\treturn NULL_TREE;\n \n-      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+      switch (code)\n \t{\n-\t  if (TREE_OPERAND_LENGTH (exp) > 0)\n-\t    arg0 = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE_CLASS (code) == tcc_comparison\n-\t      || TREE_CODE_CLASS (code) == tcc_unary\n-\t      || TREE_CODE_CLASS (code) == tcc_binary)\n-\t    arg0_type = TREE_TYPE (arg0);\n-\t  if (TREE_CODE_CLASS (code) == tcc_binary\n-\t      || TREE_CODE_CLASS (code) == tcc_comparison\n-\t      || (TREE_CODE_CLASS (code) == tcc_expression\n-\t\t  && TREE_OPERAND_LENGTH (exp) > 1))\n-\t    arg1 = TREE_OPERAND (exp, 1);\n+\tcase NE_EXPR:  /* - [c, c]  */\n+\t  low = high = arg1;\n+\t  break;\n+\tcase EQ_EXPR:  /* + [c, c]  */\n+\t  in_p = ! in_p, low = high = arg1;\n+\t  break;\n+\tcase GT_EXPR:  /* - [-, c] */\n+\t  low = 0, high = arg1;\n+\t  break;\n+\tcase GE_EXPR:  /* + [c, -] */\n+\t  in_p = ! in_p, low = arg1, high = 0;\n+\t  break;\n+\tcase LT_EXPR:  /* - [c, -] */\n+\t  low = arg1, high = 0;\n+\t  break;\n+\tcase LE_EXPR:  /* + [-, c] */\n+\t  in_p = ! in_p, low = 0, high = arg1;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n \n-      switch (code)\n+      /* If this is an unsigned comparison, we also know that EXP is\n+\t greater than or equal to zero.  We base the range tests we make\n+\t on that fact, so we record it here so we can parse existing\n+\t range tests.  We test arg0_type since often the return type\n+\t of, e.g. EQ_EXPR, is boolean.  */\n+      if (TYPE_UNSIGNED (arg0_type) && (low == 0 || high == 0))\n \t{\n-\tcase TRUTH_NOT_EXPR:\n-\t  in_p = ! in_p, exp = arg0;\n-\t  continue;\n-\n-\tcase EQ_EXPR: case NE_EXPR:\n-\tcase LT_EXPR: case LE_EXPR: case GE_EXPR: case GT_EXPR:\n-\t  /* We can only do something if the range is testing for zero\n-\t     and if the second operand is an integer constant.  Note that\n-\t     saying something is \"in\" the range we make is done by\n-\t     complementing IN_P since it will set in the initial case of\n-\t     being not equal to zero; \"out\" is leaving it alone.  */\n-\t  if (low == 0 || high == 0\n-\t      || ! integer_zerop (low) || ! integer_zerop (high)\n-\t      || TREE_CODE (arg1) != INTEGER_CST)\n-\t    break;\n+\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n+\t\t\t      in_p, low, high, 1,\n+\t\t\t      build_int_cst (arg0_type, 0),\n+\t\t\t      NULL_TREE))\n+\t    return NULL_TREE;\n \n-\t  switch (code)\n-\t    {\n-\t    case NE_EXPR:  /* - [c, c]  */\n-\t      low = high = arg1;\n-\t      break;\n-\t    case EQ_EXPR:  /* + [c, c]  */\n-\t      in_p = ! in_p, low = high = arg1;\n-\t      break;\n-\t    case GT_EXPR:  /* - [-, c] */\n-\t      low = 0, high = arg1;\n-\t      break;\n-\t    case GE_EXPR:  /* + [c, -] */\n-\t      in_p = ! in_p, low = arg1, high = 0;\n-\t      break;\n-\t    case LT_EXPR:  /* - [c, -] */\n-\t      low = arg1, high = 0;\n-\t      break;\n-\t    case LE_EXPR:  /* + [-, c] */\n-\t      in_p = ! in_p, low = 0, high = arg1;\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n+\t  in_p = n_in_p, low = n_low, high = n_high;\n \n-\t  /* If this is an unsigned comparison, we also know that EXP is\n-\t     greater than or equal to zero.  We base the range tests we make\n-\t     on that fact, so we record it here so we can parse existing\n-\t     range tests.  We test arg0_type since often the return type\n-\t     of, e.g. EQ_EXPR, is boolean.  */\n-\t  if (TYPE_UNSIGNED (arg0_type) && (low == 0 || high == 0))\n+\t  /* If the high bound is missing, but we have a nonzero low\n+\t     bound, reverse the range so it goes from zero to the low bound\n+\t     minus 1.  */\n+\t  if (high == 0 && low && ! integer_zerop (low))\n \t    {\n-\t      if (! merge_ranges (&n_in_p, &n_low, &n_high,\n-\t\t\t\t  in_p, low, high, 1,\n-\t\t\t\t  build_int_cst (arg0_type, 0),\n-\t\t\t\t  NULL_TREE))\n-\t\tbreak;\n-\n-\t      in_p = n_in_p, low = n_low, high = n_high;\n-\n-\t      /* If the high bound is missing, but we have a nonzero low\n-\t\t bound, reverse the range so it goes from zero to the low bound\n-\t\t minus 1.  */\n-\t      if (high == 0 && low && ! integer_zerop (low))\n-\t\t{\n-\t\t  in_p = ! in_p;\n-\t\t  high = range_binop (MINUS_EXPR, NULL_TREE, low, 0,\n-\t\t\t\t      integer_one_node, 0);\n-\t\t  low = build_int_cst (arg0_type, 0);\n-\t\t}\n+\t      in_p = ! in_p;\n+\t      high = range_binop (MINUS_EXPR, NULL_TREE, low, 0,\n+\t\t\t\t  integer_one_node, 0);\n+\t      low = build_int_cst (arg0_type, 0);\n \t    }\n+\t}\n \n-\t  exp = arg0;\n-\t  continue;\n-\n-\tcase NEGATE_EXPR:\n-\t  /* (-x) IN [a,b] -> x in [-b, -a]  */\n-\t  n_low = range_binop (MINUS_EXPR, exp_type,\n-\t\t\t       build_int_cst (exp_type, 0),\n-\t\t\t       0, high, 1);\n-\t  n_high = range_binop (MINUS_EXPR, exp_type,\n-\t\t\t\tbuild_int_cst (exp_type, 0),\n-\t\t\t\t0, low, 0);\n-\t  if (n_high != 0 && TREE_OVERFLOW (n_high))\n-\t    break;\n-\t  goto normalize;\n+      *p_low = low;\n+      *p_high = high;\n+      *p_in_p = in_p;\n+      return arg0;\n \n-\tcase BIT_NOT_EXPR:\n-\t  /* ~ X -> -X - 1  */\n-\t  exp = build2_loc (loc, MINUS_EXPR, exp_type, negate_expr (arg0),\n-\t\t\t    build_int_cst (exp_type, 1));\n-\t  continue;\n+    case NEGATE_EXPR:\n+      /* (-x) IN [a,b] -> x in [-b, -a]  */\n+      n_low = range_binop (MINUS_EXPR, exp_type,\n+\t\t\t   build_int_cst (exp_type, 0),\n+\t\t\t   0, high, 1);\n+      n_high = range_binop (MINUS_EXPR, exp_type,\n+\t\t\t    build_int_cst (exp_type, 0),\n+\t\t\t    0, low, 0);\n+      if (n_high != 0 && TREE_OVERFLOW (n_high))\n+\treturn NULL_TREE;\n+      goto normalize;\n \n-\tcase PLUS_EXPR:  case MINUS_EXPR:\n-\t  if (TREE_CODE (arg1) != INTEGER_CST)\n-\t    break;\n+    case BIT_NOT_EXPR:\n+      /* ~ X -> -X - 1  */\n+      return build2_loc (loc, MINUS_EXPR, exp_type, negate_expr (arg0),\n+\t\t\t build_int_cst (exp_type, 1));\n \n-\t  /* If flag_wrapv and ARG0_TYPE is signed, then we cannot\n-\t     move a constant to the other side.  */\n-\t  if (!TYPE_UNSIGNED (arg0_type)\n-\t      && !TYPE_OVERFLOW_UNDEFINED (arg0_type))\n-\t    break;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      if (TREE_CODE (arg1) != INTEGER_CST)\n+\treturn NULL_TREE;\n \n-\t  /* If EXP is signed, any overflow in the computation is undefined,\n-\t     so we don't worry about it so long as our computations on\n-\t     the bounds don't overflow.  For unsigned, overflow is defined\n-\t     and this is exactly the right thing.  */\n-\t  n_low = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t       arg0_type, low, 0, arg1, 0);\n-\t  n_high = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t\targ0_type, high, 1, arg1, 0);\n-\t  if ((n_low != 0 && TREE_OVERFLOW (n_low))\n-\t      || (n_high != 0 && TREE_OVERFLOW (n_high)))\n-\t    break;\n+      /* If flag_wrapv and ARG0_TYPE is signed, then we cannot\n+\t move a constant to the other side.  */\n+      if (!TYPE_UNSIGNED (arg0_type)\n+\t  && !TYPE_OVERFLOW_UNDEFINED (arg0_type))\n+\treturn NULL_TREE;\n \n-\t  if (TYPE_OVERFLOW_UNDEFINED (arg0_type))\n-\t    *strict_overflow_p = true;\n+      /* If EXP is signed, any overflow in the computation is undefined,\n+\t so we don't worry about it so long as our computations on\n+\t the bounds don't overflow.  For unsigned, overflow is defined\n+\t and this is exactly the right thing.  */\n+      n_low = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t   arg0_type, low, 0, arg1, 0);\n+      n_high = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t    arg0_type, high, 1, arg1, 0);\n+      if ((n_low != 0 && TREE_OVERFLOW (n_low))\n+\t  || (n_high != 0 && TREE_OVERFLOW (n_high)))\n+\treturn NULL_TREE;\n \n-\tnormalize:\n-\t  /* Check for an unsigned range which has wrapped around the maximum\n-\t     value thus making n_high < n_low, and normalize it.  */\n-\t  if (n_low && n_high && tree_int_cst_lt (n_high, n_low))\n-\t    {\n-\t      low = range_binop (PLUS_EXPR, arg0_type, n_high, 0,\n-\t\t\t\t integer_one_node, 0);\n-\t      high = range_binop (MINUS_EXPR, arg0_type, n_low, 0,\n-\t\t\t\t  integer_one_node, 0);\n+      if (TYPE_OVERFLOW_UNDEFINED (arg0_type))\n+\t*strict_overflow_p = true;\n \n-\t      /* If the range is of the form +/- [ x+1, x ], we won't\n-\t\t be able to normalize it.  But then, it represents the\n-\t\t whole range or the empty set, so make it\n-\t\t +/- [ -, - ].  */\n-\t      if (tree_int_cst_equal (n_low, low)\n-\t\t  && tree_int_cst_equal (n_high, high))\n-\t\tlow = high = 0;\n-\t      else\n-\t\tin_p = ! in_p;\n-\t    }\n-\t  else\n-\t    low = n_low, high = n_high;\n-\n-\t  exp = arg0;\n-\t  continue;\n+      normalize:\n+\t/* Check for an unsigned range which has wrapped around the maximum\n+\t   value thus making n_high < n_low, and normalize it.  */\n+\tif (n_low && n_high && tree_int_cst_lt (n_high, n_low))\n+\t  {\n+\t    low = range_binop (PLUS_EXPR, arg0_type, n_high, 0,\n+\t\t\t       integer_one_node, 0);\n+\t    high = range_binop (MINUS_EXPR, arg0_type, n_low, 0,\n+\t\t\t\tinteger_one_node, 0);\n+\n+\t    /* If the range is of the form +/- [ x+1, x ], we won't\n+\t       be able to normalize it.  But then, it represents the\n+\t       whole range or the empty set, so make it\n+\t       +/- [ -, - ].  */\n+\t    if (tree_int_cst_equal (n_low, low)\n+\t\t&& tree_int_cst_equal (n_high, high))\n+\t      low = high = 0;\n+\t    else\n+\t      in_p = ! in_p;\n+\t  }\n+\telse\n+\t  low = n_low, high = n_high;\n \n-\tCASE_CONVERT: case NON_LVALUE_EXPR:\n-\t  if (TYPE_PRECISION (arg0_type) > TYPE_PRECISION (exp_type))\n-\t    break;\n+\t*p_low = low;\n+\t*p_high = high;\n+\t*p_in_p = in_p;\n+\treturn arg0;\n \n-\t  if (! INTEGRAL_TYPE_P (arg0_type)\n-\t      || (low != 0 && ! int_fits_type_p (low, arg0_type))\n-\t      || (high != 0 && ! int_fits_type_p (high, arg0_type)))\n-\t    break;\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n+      if (TYPE_PRECISION (arg0_type) > TYPE_PRECISION (exp_type))\n+\treturn NULL_TREE;\n \n-\t  n_low = low, n_high = high;\n+      if (! INTEGRAL_TYPE_P (arg0_type)\n+\t  || (low != 0 && ! int_fits_type_p (low, arg0_type))\n+\t  || (high != 0 && ! int_fits_type_p (high, arg0_type)))\n+\treturn NULL_TREE;\n \n-\t  if (n_low != 0)\n-\t    n_low = fold_convert_loc (loc, arg0_type, n_low);\n+      n_low = low, n_high = high;\n \n-\t  if (n_high != 0)\n-\t    n_high = fold_convert_loc (loc, arg0_type, n_high);\n+      if (n_low != 0)\n+\tn_low = fold_convert_loc (loc, arg0_type, n_low);\n \n+      if (n_high != 0)\n+\tn_high = fold_convert_loc (loc, arg0_type, n_high);\n \n-\t  /* If we're converting arg0 from an unsigned type, to exp,\n-\t     a signed type,  we will be doing the comparison as unsigned.\n-\t     The tests above have already verified that LOW and HIGH\n-\t     are both positive.\n+      /* If we're converting arg0 from an unsigned type, to exp,\n+\t a signed type,  we will be doing the comparison as unsigned.\n+\t The tests above have already verified that LOW and HIGH\n+\t are both positive.\n \n-\t     So we have to ensure that we will handle large unsigned\n-\t     values the same way that the current signed bounds treat\n-\t     negative values.  */\n+\t So we have to ensure that we will handle large unsigned\n+\t values the same way that the current signed bounds treat\n+\t negative values.  */\n \n-\t  if (!TYPE_UNSIGNED (exp_type) && TYPE_UNSIGNED (arg0_type))\n-\t    {\n-\t      tree high_positive;\n-\t      tree equiv_type;\n-\t      /* For fixed-point modes, we need to pass the saturating flag\n-\t\t as the 2nd parameter.  */\n-\t      if (ALL_FIXED_POINT_MODE_P (TYPE_MODE (arg0_type)))\n-\t\tequiv_type = lang_hooks.types.type_for_mode\n-\t\t\t     (TYPE_MODE (arg0_type),\n-\t\t\t      TYPE_SATURATING (arg0_type));\n-\t      else\n-\t\tequiv_type = lang_hooks.types.type_for_mode\n-\t\t\t     (TYPE_MODE (arg0_type), 1);\n-\n-\t      /* A range without an upper bound is, naturally, unbounded.\n-\t\t Since convert would have cropped a very large value, use\n-\t\t the max value for the destination type.  */\n-\t      high_positive\n-\t\t= TYPE_MAX_VALUE (equiv_type) ? TYPE_MAX_VALUE (equiv_type)\n-\t\t: TYPE_MAX_VALUE (arg0_type);\n-\n-\t      if (TYPE_PRECISION (exp_type) == TYPE_PRECISION (arg0_type))\n-\t\thigh_positive = fold_build2_loc (loc, RSHIFT_EXPR, arg0_type,\n+      if (!TYPE_UNSIGNED (exp_type) && TYPE_UNSIGNED (arg0_type))\n+\t{\n+\t  tree high_positive;\n+\t  tree equiv_type;\n+\t  /* For fixed-point modes, we need to pass the saturating flag\n+\t     as the 2nd parameter.  */\n+\t  if (ALL_FIXED_POINT_MODE_P (TYPE_MODE (arg0_type)))\n+\t    equiv_type\n+\t      = lang_hooks.types.type_for_mode (TYPE_MODE (arg0_type),\n+\t\t\t\t\t\tTYPE_SATURATING (arg0_type));\n+\t  else\n+\t    equiv_type\n+\t      = lang_hooks.types.type_for_mode (TYPE_MODE (arg0_type), 1);\n+\n+\t  /* A range without an upper bound is, naturally, unbounded.\n+\t     Since convert would have cropped a very large value, use\n+\t     the max value for the destination type.  */\n+\t  high_positive\n+\t    = TYPE_MAX_VALUE (equiv_type) ? TYPE_MAX_VALUE (equiv_type)\n+\t      : TYPE_MAX_VALUE (arg0_type);\n+\n+\t  if (TYPE_PRECISION (exp_type) == TYPE_PRECISION (arg0_type))\n+\t    high_positive = fold_build2_loc (loc, RSHIFT_EXPR, arg0_type,\n \t\t\t\t\t     fold_convert_loc (loc, arg0_type,\n \t\t\t\t\t\t\t       high_positive),\n \t\t\t\t\t     build_int_cst (arg0_type, 1));\n \n-\t      /* If the low bound is specified, \"and\" the range with the\n-\t\t range for which the original unsigned value will be\n-\t\t positive.  */\n-\t      if (low != 0)\n-\t\t{\n-\t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n-\t\t\t\t      1, n_low, n_high, 1,\n-\t\t\t\t      fold_convert_loc (loc, arg0_type,\n-\t\t\t\t\t\t\tinteger_zero_node),\n-\t\t\t\t      high_positive))\n-\t\t    break;\n+\t  /* If the low bound is specified, \"and\" the range with the\n+\t     range for which the original unsigned value will be\n+\t     positive.  */\n+\t  if (low != 0)\n+\t    {\n+\t      if (! merge_ranges (&n_in_p, &n_low, &n_high, 1, n_low, n_high,\n+\t\t\t\t  1, fold_convert_loc (loc, arg0_type,\n+\t\t\t\t\t\t       integer_zero_node),\n+\t\t\t\t  high_positive))\n+\t\treturn NULL_TREE;\n \n-\t\t  in_p = (n_in_p == in_p);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Otherwise, \"or\" the range with the range of the input\n-\t\t     that will be interpreted as negative.  */\n-\t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n-\t\t\t\t      0, n_low, n_high, 1,\n-\t\t\t\t      fold_convert_loc (loc, arg0_type,\n-\t\t\t\t\t\t\tinteger_zero_node),\n-\t\t\t\t      high_positive))\n-\t\t    break;\n+\t      in_p = (n_in_p == in_p);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, \"or\" the range with the range of the input\n+\t\t that will be interpreted as negative.  */\n+\t      if (! merge_ranges (&n_in_p, &n_low, &n_high, 0, n_low, n_high,\n+\t\t\t\t  1, fold_convert_loc (loc, arg0_type,\n+\t\t\t\t\t\t       integer_zero_node),\n+\t\t\t\t  high_positive))\n+\t\treturn NULL_TREE;\n \n-\t\t  in_p = (in_p != n_in_p);\n-\t\t}\n+\t      in_p = (in_p != n_in_p);\n \t    }\n+\t}\n \n-\t  exp = arg0;\n-\t  low = n_low, high = n_high;\n-\t  continue;\n+      *p_low = n_low;\n+      *p_high = n_high;\n+      *p_in_p = in_p;\n+      return arg0;\n \n-\tdefault:\n-\t  break;\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Given EXP, a logical expression, set the range it is testing into\n+   variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression\n+   actually being tested.  *PLOW and *PHIGH will be made of the same\n+   type as the returned expression.  If EXP is not a comparison, we\n+   will most likely not be returning a useful value and range.  Set\n+   *STRICT_OVERFLOW_P to true if the return value is only valid\n+   because signed overflow is undefined; otherwise, do not change\n+   *STRICT_OVERFLOW_P.  */\n+\n+tree\n+make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n+\t    bool *strict_overflow_p)\n+{\n+  enum tree_code code;\n+  tree arg0, arg1 = NULL_TREE;\n+  tree exp_type, nexp;\n+  int in_p;\n+  tree low, high;\n+  location_t loc = EXPR_LOCATION (exp);\n+\n+  /* Start with simply saying \"EXP != 0\" and then look at the code of EXP\n+     and see if we can refine the range.  Some of the cases below may not\n+     happen, but it doesn't seem worth worrying about this.  We \"continue\"\n+     the outer loop when we've changed something; otherwise we \"break\"\n+     the switch, which will \"break\" the while.  */\n+\n+  in_p = 0;\n+  low = high = build_int_cst (TREE_TYPE (exp), 0);\n+\n+  while (1)\n+    {\n+      code = TREE_CODE (exp);\n+      exp_type = TREE_TYPE (exp);\n+      arg0 = NULL_TREE;\n+\n+      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+\t{\n+\t  if (TREE_OPERAND_LENGTH (exp) > 0)\n+\t    arg0 = TREE_OPERAND (exp, 0);\n+\t  if (TREE_CODE_CLASS (code) == tcc_binary\n+\t      || TREE_CODE_CLASS (code) == tcc_comparison\n+\t      || (TREE_CODE_CLASS (code) == tcc_expression\n+\t\t  && TREE_OPERAND_LENGTH (exp) > 1))\n+\t    arg1 = TREE_OPERAND (exp, 1);\n \t}\n+      if (arg0 == NULL_TREE)\n+\tbreak;\n \n-      break;\n+      nexp = make_range_step (loc, code, arg0, arg1, exp_type, &low,\n+\t\t\t      &high, &in_p, strict_overflow_p);\n+      if (nexp == NULL_TREE)\n+\tbreak;\n+      exp = nexp;\n     }\n \n   /* If EXP is a constant, we can evaluate whether this is true or false.  */"}, {"sha": "59cae6b900d4e9f12ed16f2b8f69f7f729cb3627", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -1,3 +1,8 @@\n+2011-09-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/46309\n+\t* gcc.dg/pr46309.c: New test.\n+\n 2011-09-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/strlenopt-21.c: New test."}, {"sha": "2629a3cef37ce194a4c402194bf5b0dc7b5c3524", "filename": "gcc/testsuite/gcc.dg/pr46309.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309.c?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -0,0 +1,66 @@\n+/* PR tree-optimization/46309 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc-details\" } */\n+\n+int\n+f1 (int a)\n+{\n+  int v1 = (a == 3);\n+  int v2 = (a == 1);\n+  int v3 = (a == 4);\n+  int v4 = (a == 2);\n+  return v1 || v2 || v3 || v4;\n+}\n+\n+int\n+f2 (int a)\n+{\n+  int v1 = (a == 1);\n+  int v2 = (a == 2);\n+  int v3 = (a == 3);\n+  int v4 = (a == 4);\n+  return v1 || v2 || v3 || v4;\n+}\n+\n+int\n+f3 (int a)\n+{\n+  int v1 = (a == 3);\n+  int v2 = (a == 1);\n+  return v1 || v2;\n+}\n+\n+int\n+f4 (int a)\n+{\n+  int v1 = (a == 1);\n+  int v2 = (a == 2);\n+  return v1 || v2;\n+}\n+\n+int\n+f5 (unsigned int a)\n+{\n+  int v1 = (a <= 31);\n+  int v2 = (a >= 64 && a <= 95);\n+  return v1 || v2;\n+}\n+\n+int\n+f6 (unsigned int a)\n+{\n+  int v1 = (a <= 31);\n+  int v2 = (a >= 64 && a <= 95);\n+  int v3 = (a >= 128 && a <= 159);\n+  int v4 = (a >= 192 && a <= 223);\n+  return v1 || v2 || v3 || v4;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.1, 1. and -.2, 2. and -.3, 3. and -.4, 4.\\[\\n\\r\\]* into\" 2 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.1, 1. and -.3, 3.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.1, 1. and -.2, 2.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.0, 31. and -.64, 95.\\[\\n\\r\\]* into\" 2 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.128, 159. and -.192, 223.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests D.\\[0-9\\]*_\\[0-9\\]* -.0, 31. and -.128, 159.\\[\\n\\r\\]* into\" 1 \"reassoc2\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc2\" } } */"}, {"sha": "f7c21e70eb86ff7e8fea64b7ec49dea3d4795b75", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"target.h\"\n #include \"params.h\"\n+#include \"diagnostic-core.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less\n@@ -1568,6 +1569,457 @@ optimize_ops_list (enum tree_code opcode,\n     optimize_ops_list (opcode, ops);\n }\n \n+/* The following functions are subroutines to optimize_range_tests and allow\n+   it to try to change a logical combination of comparisons into a range\n+   test.\n+\n+   For example, both\n+\tX == 2 || X == 5 || X == 3 || X == 4\n+   and\n+\tX >= 2 && X <= 5\n+   are converted to\n+\t(unsigned) (X - 2) <= 3\n+\n+   For more information see comments above fold_test_range in fold-const.c,\n+   this implementation is for GIMPLE.  */\n+\n+struct range_entry\n+{\n+  tree exp;\n+  tree low;\n+  tree high;\n+  bool in_p;\n+  bool strict_overflow_p;\n+  unsigned int idx, next;\n+};\n+\n+/* This is similar to make_range in fold-const.c, but on top of\n+   GIMPLE instead of trees.  */\n+\n+static void\n+init_range_entry (struct range_entry *r, tree exp)\n+{\n+  int in_p;\n+  tree low, high;\n+  bool is_bool, strict_overflow_p;\n+\n+  r->exp = NULL_TREE;\n+  r->in_p = false;\n+  r->strict_overflow_p = false;\n+  r->low = NULL_TREE;\n+  r->high = NULL_TREE;\n+  if (TREE_CODE (exp) != SSA_NAME || !INTEGRAL_TYPE_P (TREE_TYPE (exp)))\n+    return;\n+\n+  /* Start with simply saying \"EXP != 0\" and then look at the code of EXP\n+     and see if we can refine the range.  Some of the cases below may not\n+     happen, but it doesn't seem worth worrying about this.  We \"continue\"\n+     the outer loop when we've changed something; otherwise we \"break\"\n+     the switch, which will \"break\" the while.  */\n+  low = build_int_cst (TREE_TYPE (exp), 0);\n+  high = low;\n+  in_p = 0;\n+  strict_overflow_p = false;\n+  is_bool = false;\n+  if (TYPE_PRECISION (TREE_TYPE (exp)) == 1)\n+    {\n+      if (TYPE_UNSIGNED (TREE_TYPE (exp)))\n+\tis_bool = true;\n+      else\n+\treturn;\n+    }\n+  else if (TREE_CODE (TREE_TYPE (exp)) == BOOLEAN_TYPE)\n+    is_bool = true;\n+\n+  while (1)\n+    {\n+      gimple stmt;\n+      enum tree_code code;\n+      tree arg0, arg1, exp_type;\n+      tree nexp;\n+      location_t loc;\n+\n+      if (TREE_CODE (exp) != SSA_NAME)\n+\tbreak;\n+\n+      stmt = SSA_NAME_DEF_STMT (exp);\n+      if (!is_gimple_assign (stmt))\n+\tbreak;\n+\n+      code = gimple_assign_rhs_code (stmt);\n+      arg0 = gimple_assign_rhs1 (stmt);\n+      arg1 = gimple_assign_rhs2 (stmt);\n+      exp_type = TREE_TYPE (exp);\n+      loc = gimple_location (stmt);\n+      switch (code)\n+\t{\n+\tcase BIT_NOT_EXPR:\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == BOOLEAN_TYPE)\n+\t    {\n+\t      in_p = !in_p;\n+\t      exp = arg0;\n+\t      continue;\n+\t    }\n+\t  break;\n+\tcase SSA_NAME:\n+\t  exp = arg0;\n+\t  continue;\n+\tCASE_CONVERT:\n+\t  if (is_bool)\n+\t    goto do_default;\n+\t  if (TYPE_PRECISION (TREE_TYPE (arg0)) == 1)\n+\t    {\n+\t      if (TYPE_UNSIGNED (TREE_TYPE (arg0)))\n+\t\tis_bool = true;\n+\t      else\n+\t\treturn;\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (arg0)) == BOOLEAN_TYPE)\n+\t    is_bool = true;\n+\t  goto do_default;\n+\tcase EQ_EXPR:\n+\tcase NE_EXPR:\n+\tcase LT_EXPR:\n+\tcase LE_EXPR:\n+\tcase GE_EXPR:\n+\tcase GT_EXPR:\n+\t  is_bool = true;\n+\t  /* FALLTHRU */\n+\tdefault:\n+\t  if (!is_bool)\n+\t    return;\n+\tdo_default:\n+\t  nexp = make_range_step (loc, code, arg0, arg1, exp_type,\n+\t\t\t\t  &low, &high, &in_p,\n+\t\t\t\t  &strict_overflow_p);\n+\t  if (nexp != NULL_TREE)\n+\t    {\n+\t      exp = nexp;\n+\t      gcc_assert (TREE_CODE (exp) == SSA_NAME);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+      break;\n+    }\n+  if (is_bool)\n+    {\n+      r->exp = exp;\n+      r->in_p = in_p;\n+      r->low = low;\n+      r->high = high;\n+      r->strict_overflow_p = strict_overflow_p;\n+    }\n+}\n+\n+/* Comparison function for qsort.  Sort entries\n+   without SSA_NAME exp first, then with SSA_NAMEs sorted\n+   by increasing SSA_NAME_VERSION, and for the same SSA_NAMEs\n+   by increasing ->low and if ->low is the same, by increasing\n+   ->high.  ->low == NULL_TREE means minimum, ->high == NULL_TREE\n+   maximum.  */\n+\n+static int\n+range_entry_cmp (const void *a, const void *b)\n+{\n+  const struct range_entry *p = (const struct range_entry *) a;\n+  const struct range_entry *q = (const struct range_entry *) b;\n+\n+  if (p->exp != NULL_TREE && TREE_CODE (p->exp) == SSA_NAME)\n+    {\n+      if (q->exp != NULL_TREE && TREE_CODE (q->exp) == SSA_NAME)\n+\t{\n+\t  /* Group range_entries for the same SSA_NAME together.  */\n+\t  if (SSA_NAME_VERSION (p->exp) < SSA_NAME_VERSION (q->exp))\n+\t    return -1;\n+\t  else if (SSA_NAME_VERSION (p->exp) > SSA_NAME_VERSION (q->exp))\n+\t    return 1;\n+\t  /* If ->low is different, NULL low goes first, then by\n+\t     ascending low.  */\n+\t  if (p->low != NULL_TREE)\n+\t    {\n+\t      if (q->low != NULL_TREE)\n+\t\t{\n+\t\t  tree tem = fold_binary (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t  p->low, q->low);\n+\t\t  if (tem && integer_onep (tem))\n+\t\t    return -1;\n+\t\t  tem = fold_binary (GT_EXPR, boolean_type_node,\n+\t\t\t\t     p->low, q->low);\n+\t\t  if (tem && integer_onep (tem))\n+\t\t    return 1;\n+\t\t}\n+\t      else\n+\t\treturn 1;\n+\t    }\n+\t  else if (q->low != NULL_TREE)\n+\t    return -1;\n+\t  /* If ->high is different, NULL high goes last, before that by\n+\t     ascending high.  */\n+\t  if (p->high != NULL_TREE)\n+\t    {\n+\t      if (q->high != NULL_TREE)\n+\t\t{\n+\t\t  tree tem = fold_binary (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t  p->high, q->high);\n+\t\t  if (tem && integer_onep (tem))\n+\t\t    return -1;\n+\t\t  tem = fold_binary (GT_EXPR, boolean_type_node,\n+\t\t\t\t     p->high, q->high);\n+\t\t  if (tem && integer_onep (tem))\n+\t\t    return 1;\n+\t\t}\n+\t      else\n+\t\treturn -1;\n+\t    }\n+\t  else if (p->high != NULL_TREE)\n+\t    return 1;\n+\t  /* If both ranges are the same, sort below by ascending idx.  */\n+\t}\n+      else\n+\treturn 1;\n+    }\n+  else if (q->exp != NULL_TREE && TREE_CODE (q->exp) == SSA_NAME)\n+    return -1;\n+\n+  if (p->idx < q->idx)\n+    return -1;\n+  else\n+    {\n+      gcc_checking_assert (p->idx > q->idx);\n+      return 1;\n+    }\n+}\n+\n+/* Helper routine of optimize_range_test.\n+   [EXP, IN_P, LOW, HIGH, STRICT_OVERFLOW_P] is a merged range for\n+   RANGE and OTHERRANGE through OTHERRANGE + COUNT - 1 ranges,\n+   OPCODE and OPS are arguments of optimize_range_tests.  Return\n+   true if the range merge has been successful.  */\n+\n+static bool\n+update_range_test (struct range_entry *range, struct range_entry *otherrange,\n+\t\t   unsigned int count, enum tree_code opcode,\n+\t\t   VEC (operand_entry_t, heap) **ops, tree exp, bool in_p,\n+\t\t   tree low, tree high, bool strict_overflow_p)\n+{\n+  tree op = VEC_index (operand_entry_t, *ops, range->idx)->op;\n+  location_t loc = gimple_location (SSA_NAME_DEF_STMT (op));\n+  tree tem = build_range_check (loc, TREE_TYPE (op), exp, in_p, low, high);\n+  enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;\n+  gimple_stmt_iterator gsi;\n+\n+  if (tem == NULL_TREE)\n+    return false;\n+\n+  if (strict_overflow_p && issue_strict_overflow_warning (wc))\n+    warning_at (loc, OPT_Wstrict_overflow,\n+\t\t\"assuming signed overflow does not occur \"\n+\t\t\"when simplifying range test\");\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      struct range_entry *r;\n+      fprintf (dump_file, \"Optimizing range tests \");\n+      print_generic_expr (dump_file, range->exp, 0);\n+      fprintf (dump_file, \" %c[\", range->in_p ? '+' : '-');\n+      print_generic_expr (dump_file, range->low, 0);\n+      fprintf (dump_file, \", \");\n+      print_generic_expr (dump_file, range->high, 0);\n+      fprintf (dump_file, \"]\");\n+      for (r = otherrange; r < otherrange + count; r++)\n+\t{\n+\t  fprintf (dump_file, \" and %c[\", r->in_p ? '+' : '-');\n+\t  print_generic_expr (dump_file, r->low, 0);\n+\t  fprintf (dump_file, \", \");\n+\t  print_generic_expr (dump_file, r->high, 0);\n+\t  fprintf (dump_file, \"]\");\n+\t}\n+      fprintf (dump_file, \"\\n into \");\n+      print_generic_expr (dump_file, tem, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (opcode == BIT_IOR_EXPR)\n+    tem = invert_truthvalue_loc (loc, tem);\n+\n+  tem = fold_convert_loc (loc, TREE_TYPE (op), tem);\n+  gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (op));\n+  tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE, true,\n+\t\t\t\t  GSI_SAME_STMT);\n+\n+  VEC_index (operand_entry_t, *ops, range->idx)->op = tem;\n+  range->exp = exp;\n+  range->low = low;\n+  range->high = high;\n+  range->in_p = in_p;\n+  range->strict_overflow_p = false;\n+\n+  for (range = otherrange; range < otherrange + count; range++)\n+    {\n+      VEC_index (operand_entry_t, *ops, range->idx)->op = error_mark_node;\n+      range->exp = NULL_TREE;\n+    }\n+  return true;\n+}\n+\n+/* Optimize range tests, similarly how fold_range_test optimizes\n+   it on trees.  The tree code for the binary\n+   operation between all the operands is OPCODE.  */\n+\n+static void\n+optimize_range_tests (enum tree_code opcode,\n+\t\t      VEC (operand_entry_t, heap) **ops)\n+{\n+  unsigned int length = VEC_length (operand_entry_t, *ops), i, j, first;\n+  operand_entry_t oe;\n+  struct range_entry *ranges;\n+  bool any_changes = false;\n+\n+  if (length == 1)\n+    return;\n+\n+  ranges = XNEWVEC (struct range_entry, length);\n+  for (i = 0; i < length; i++)\n+    {\n+      ranges[i].idx = i;\n+      init_range_entry (ranges + i, VEC_index (operand_entry_t, *ops, i)->op);\n+      /* For | invert it now, we will invert it again before emitting\n+\t the optimized expression.  */\n+      if (opcode == BIT_IOR_EXPR)\n+\tranges[i].in_p = !ranges[i].in_p;\n+    }\n+\n+  qsort (ranges, length, sizeof (*ranges), range_entry_cmp);\n+  for (i = 0; i < length; i++)\n+    if (ranges[i].exp != NULL_TREE && TREE_CODE (ranges[i].exp) == SSA_NAME)\n+      break;\n+\n+  /* Try to merge ranges.  */\n+  for (first = i; i < length; i++)\n+    {\n+      tree low = ranges[i].low;\n+      tree high = ranges[i].high;\n+      int in_p = ranges[i].in_p;\n+      bool strict_overflow_p = ranges[i].strict_overflow_p;\n+      int update_fail_count = 0;\n+\n+      for (j = i + 1; j < length; j++)\n+\t{\n+\t  if (ranges[i].exp != ranges[j].exp)\n+\t    break;\n+\t  if (!merge_ranges (&in_p, &low, &high, in_p, low, high,\n+\t\t\t     ranges[j].in_p, ranges[j].low, ranges[j].high))\n+\t    break;\n+\t  strict_overflow_p |= ranges[j].strict_overflow_p;\n+\t}\n+\n+      if (j == i + 1)\n+\tcontinue;\n+\n+      if (update_range_test (ranges + i, ranges + i + 1, j - i - 1, opcode,\n+\t\t\t     ops, ranges[i].exp, in_p, low, high,\n+\t\t\t     strict_overflow_p))\n+\t{\n+\t  i = j - 1;\n+\t  any_changes = true;\n+\t}\n+      /* Avoid quadratic complexity if all merge_ranges calls would succeed,\n+\t while update_range_test would fail.  */\n+      else if (update_fail_count == 64)\n+\ti = j - 1;\n+      else\n+\t++update_fail_count;\n+    }\n+\n+  /* Optimize X == CST1 || X == CST2\n+     if popcount (CST1 ^ CST2) == 1 into\n+     (X & ~(CST1 ^ CST2)) == (CST1 & ~(CST1 ^ CST2)).\n+     Similarly for ranges.  E.g.\n+     X != 2 && X != 3 && X != 10 && X != 11\n+     will be transformed by the above loop into\n+     (X - 2U) <= 1U && (X - 10U) <= 1U\n+     and this loop can transform that into\n+     ((X & ~8) - 2U) <= 1U.  */\n+  for (i = first; i < length; i++)\n+    {\n+      tree lowi, highi, lowj, highj, type, lowxor, highxor, tem, exp;\n+\n+      if (ranges[i].exp == NULL_TREE || ranges[i].in_p)\n+\tcontinue;\n+      type = TREE_TYPE (ranges[i].exp);\n+      if (!INTEGRAL_TYPE_P (type))\n+\tcontinue;\n+      lowi = ranges[i].low;\n+      if (lowi == NULL_TREE)\n+\tlowi = TYPE_MIN_VALUE (type);\n+      highi = ranges[i].high;\n+      if (highi == NULL_TREE)\n+\tcontinue;\n+      for (j = i + 1; j < length && j < i + 64; j++)\n+\t{\n+\t  if (ranges[j].exp == NULL_TREE)\n+\t    continue;\n+\t  if (ranges[i].exp != ranges[j].exp)\n+\t    break;\n+\t  if (ranges[j].in_p)\n+\t    continue;\n+\t  lowj = ranges[j].low;\n+\t  if (lowj == NULL_TREE)\n+\t    continue;\n+\t  highj = ranges[j].high;\n+\t  if (highj == NULL_TREE)\n+\t    highj = TYPE_MAX_VALUE (type);\n+\t  tem = fold_binary (GT_EXPR, boolean_type_node,\n+\t\t\t     lowj, highi);\n+\t  if (tem == NULL_TREE || !integer_onep (tem))\n+\t    continue;\n+\t  lowxor = fold_binary (BIT_XOR_EXPR, type, lowi, lowj);\n+\t  if (lowxor == NULL_TREE || TREE_CODE (lowxor) != INTEGER_CST)\n+\t    continue;\n+\t  gcc_checking_assert (!integer_zerop (lowxor));\n+\t  tem = fold_binary (MINUS_EXPR, type, lowxor,\n+\t\t\t     build_int_cst (type, 1));\n+\t  if (tem == NULL_TREE)\n+\t    continue;\n+\t  tem = fold_binary (BIT_AND_EXPR, type, lowxor, tem);\n+\t  if (tem == NULL_TREE || !integer_zerop (tem))\n+\t    continue;\n+\t  highxor = fold_binary (BIT_XOR_EXPR, type, highi, highj);\n+\t  if (!tree_int_cst_equal (lowxor, highxor))\n+\t    continue;\n+\t  tem = fold_build1 (BIT_NOT_EXPR, type, lowxor);\n+\t  exp = fold_build2 (BIT_AND_EXPR, type, ranges[i].exp, tem);\n+\t  lowj = fold_build2 (BIT_AND_EXPR, type, lowi, tem);\n+\t  highj = fold_build2 (BIT_AND_EXPR, type, highi, tem);\n+\t  if (update_range_test (ranges + i, ranges + j, 1, opcode, ops, exp,\n+\t\t\t\t ranges[i].in_p, lowj, highj,\n+\t\t\t\t ranges[i].strict_overflow_p\n+\t\t\t\t || ranges[j].strict_overflow_p))\n+\t    {\n+\t      any_changes = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (any_changes)\n+    {\n+      j = 0;\n+      FOR_EACH_VEC_ELT (operand_entry_t, *ops, i, oe)\n+\t{\n+\t  if (oe->op == error_mark_node)\n+\t    continue;\n+\t  else if (i != j)\n+\t    VEC_replace (operand_entry_t, *ops, j, oe);\n+\t  j++;\n+\t}\n+      VEC_truncate (operand_entry_t, *ops, j);\n+    }\n+\n+  XDELETEVEC (ranges);\n+}\n+\n /* Return true if OPERAND is defined by a PHI node which uses the LHS\n    of STMT in it's operands.  This is also known as a \"destructive\n    update\" operation.  */\n@@ -2447,6 +2899,9 @@ reassociate_bb (basic_block bb)\n \t\t  optimize_ops_list (rhs_code, &ops);\n \t\t}\n \n+\t      if (rhs_code == BIT_IOR_EXPR || rhs_code == BIT_AND_EXPR)\n+\t\toptimize_range_tests (rhs_code, &ops);\n+\n \t      if (VEC_length (operand_entry_t, ops) == 1)\n \t\t{\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "f064bbe30f5a94d0cdcb22da99bd20d1e043d4db", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ccb5dbf93d900812222d4383760d6c632bf2382/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0ccb5dbf93d900812222d4383760d6c632bf2382", "patch": "@@ -5384,6 +5384,8 @@ extern unsigned int get_pointer_alignment (tree);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);\n extern tree make_range (tree, int *, tree *, tree *, bool *);\n+extern tree make_range_step (location_t, enum tree_code, tree, tree, tree,\n+\t\t\t     tree *, tree *, int *, bool *);\n extern tree build_range_check (location_t, tree, tree, int, tree, tree);\n extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n \t\t\t  tree, tree);"}]}