{"sha": "a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlMGI2YzY1OWZkNzg3MTlhZDIxYjVlZTRjODk2YWMxMWIxZDM4Yw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-12-15T15:42:43Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-12-15T15:42:43Z"}, "message": "[arm] Use arm_active_target for architecture and tune\n\nWe now start to make more use of the new data structure.  This allows\nus to eliminate two of the existing static variables,\narm_selected_arch and arm_selected tune.\n\n\t* arm.c (arm_selected_tune): Delete static variable.\n\t(arm_selected_arch): Likewise.\n\t(arm_configure_build_target): Declare local versions of arm_selected\n\ttarget and arm_selected_arch.  Initialize more fields in target\n\tdata structure.\n\t(arm_option_override): Use arm_active_target instead of\n\tarm_selected_tune and arm_selected_arch.\n\t(asm_file_start): Use arm_active_target.\n\nFrom-SVN: r243699", "tree": {"sha": "847db18870172b16145dade870bb6599a0bcc60b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/847db18870172b16145dade870bb6599a0bcc60b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c/comments", "author": null, "committer": null, "parents": [{"sha": "8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8341f8c4a5ff74c482ceed872fe2e0d92a335f41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8341f8c4a5ff74c482ceed872fe2e0d92a335f41"}], "stats": {"total": 69, "additions": 52, "deletions": 17}, "files": [{"sha": "004d26842f93775cdf40e3211011fc213caf00f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c", "patch": "@@ -1,3 +1,14 @@\n+2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_selected_tune): Delete static variable.\n+\t(arm_selected_arch): Likewise.\n+\t(arm_configure_build_target): Declare local versions of arm_selected\n+\ttarget and arm_selected_arch.  Initialize more fields in target\n+\tdata structure.\n+\t(arm_option_override): Use arm_active_target instead of\n+\tarm_selected_tune and arm_selected_arch.\n+\t(asm_file_start): Use arm_active_target.\n+\n 2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm-protos.h (arm_build_target): New structure."}, {"sha": "a4d370c735d19ba57a3f45c15b53306ab8f992b1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a8e0b6c659fd78719ad21b5ee4c896ac11b1d38c", "patch": "@@ -2319,9 +2319,7 @@ static const struct processors all_architectures[] =\n \n /* These are populated as commandline arguments are processed, or NULL\n    if not specified.  */\n-static const struct processors *arm_selected_arch;\n static const struct processors *arm_selected_cpu;\n-static const struct processors *arm_selected_tune;\n \n /* The name of the preprocessor macro to define for this architecture.  PROFILE\n    is replaced by the architecture name (eg. 8A) in arm_option_override () and\n@@ -3068,9 +3066,10 @@ arm_configure_build_target (struct arm_build_target *target,\n \t\t\t    struct gcc_options *opts_set,\n \t\t\t    bool warn_compatible)\n {\n-  arm_selected_arch = NULL;\n+  const struct processors *arm_selected_tune = NULL;\n+  const struct processors *arm_selected_arch = NULL;\n+\n   arm_selected_cpu = NULL;\n-  arm_selected_tune = NULL;\n \n   bitmap_clear (target->isa);\n   target->core_name = NULL;\n@@ -3119,17 +3118,24 @@ arm_configure_build_target (struct arm_build_target *target,\n \t\t Prefer the CPU setting.  */\n \t      arm_selected_arch = NULL;\n \t    }\n+\n+\t  target->core_name = arm_selected_cpu->name;\n \t}\n       else\n \t{\n \t  /* Pick a CPU based on the architecture.  */\n \t  arm_selected_cpu = arm_selected_arch;\n \t  target->arch_name = arm_selected_arch->name;\n+\t  /* Note: target->core_name is left unset in this path.  */\n \t}\n     }\n-\n+  else if (arm_selected_cpu)\n+    {\n+      target->core_name = arm_selected_cpu->name;\n+      arm_initialize_isa (target->isa, arm_selected_cpu->isa_bits);\n+    }\n   /* If the user did not specify a processor, choose one for them.  */\n-  if (!arm_selected_cpu)\n+  else\n     {\n       const struct processors * sel;\n       auto_sbitmap sought_isa (isa_num_bits);\n@@ -3229,16 +3235,27 @@ arm_configure_build_target (struct arm_build_target *target,\n \t    }\n \t  arm_selected_cpu = sel;\n \t}\n+\n+      /* Now we know the CPU, we can finally initialize the target\n+\t structure.  */\n+      target->core_name = arm_selected_cpu->name;\n+      arm_initialize_isa (target->isa, arm_selected_cpu->isa_bits);\n     }\n \n   gcc_assert (arm_selected_cpu);\n+\n   /* The selected cpu may be an architecture, so lookup tuning by core ID.  */\n   if (!arm_selected_tune)\n     arm_selected_tune = &all_cores[arm_selected_cpu->core];\n \n+  /* Finish initializing the target structure.  */\n   target->arch_pp_name = arm_selected_cpu->arch;\n+  target->base_arch = arm_selected_cpu->base_arch;\n+  target->arch_core = arm_selected_cpu->core;\n+\n   target->tune_flags = arm_selected_tune->tune_flags;\n   target->tune = arm_selected_tune->tune;\n+  target->tune_core = arm_selected_tune->core;\n }\n \n /* Fix up any incompatible options that the user has specified.  */\n@@ -3263,9 +3280,9 @@ arm_option_override (void)\n   insn_flags = arm_selected_cpu->flags;\n   arm_base_arch = arm_selected_cpu->base_arch;\n \n-  arm_tune = arm_selected_tune->core;\n-  tune_flags = arm_selected_tune->tune_flags;\n-  current_tune = arm_selected_tune->tune;\n+  arm_tune = arm_active_target.tune_core;\n+  tune_flags = arm_active_target.tune_flags;\n+  current_tune = arm_active_target.tune;\n \n   /* TBD: Dwarf info for apcs frame is not handled yet.  */\n   if (TARGET_APCS_FRAME)\n@@ -25957,10 +25974,16 @@ arm_file_start (void)\n \n   if (TARGET_BPABI)\n     {\n-      if (arm_selected_arch)\n+      /* We don't have a specified CPU.  Use the architecture to\n+\t generate the tags.\n+\n+\t Note: it might be better to do this unconditionally, then the\n+\t assembler would not need to know about all new CPU names as\n+\t they are added.  */\n+      if (!arm_active_target.core_name)\n         {\n \t  /* armv7ve doesn't support any extensions.  */\n-\t  if (strcmp (arm_selected_arch->name, \"armv7ve\") == 0)\n+\t  if (strcmp (arm_active_target.arch_name, \"armv7ve\") == 0)\n \t    {\n \t      /* Keep backward compatability for assemblers\n \t\t which don't support armv7ve.  */\n@@ -25972,20 +25995,21 @@ arm_file_start (void)\n \t    }\n \t  else\n \t    {\n-\t      const char* pos = strchr (arm_selected_arch->name, '+');\n+\t      const char* pos = strchr (arm_active_target.arch_name, '+');\n \t      if (pos)\n \t\t{\n \t\t  char buf[32];\n-\t\t  gcc_assert (strlen (arm_selected_arch->name)\n+\t\t  gcc_assert (strlen (arm_active_target.arch_name)\n \t\t\t      <= sizeof (buf) / sizeof (*pos));\n-\t\t  strncpy (buf, arm_selected_arch->name,\n-\t\t\t\t(pos - arm_selected_arch->name) * sizeof (*pos));\n-\t\t  buf[pos - arm_selected_arch->name] = '\\0';\n+\t\t  strncpy (buf, arm_active_target.arch_name,\n+\t\t\t   (pos - arm_active_target.arch_name) * sizeof (*pos));\n+\t\t  buf[pos - arm_active_target.arch_name] = '\\0';\n \t\t  asm_fprintf (asm_out_file, \"\\t.arch %s\\n\", buf);\n \t\t  asm_fprintf (asm_out_file, \"\\t.arch_extension %s\\n\", pos + 1);\n \t\t}\n \t      else\n-\t\tasm_fprintf (asm_out_file, \"\\t.arch %s\\n\", arm_selected_arch->name);\n+\t\tasm_fprintf (asm_out_file, \"\\t.arch %s\\n\",\n+\t\t\t     arm_active_target.arch_name);\n \t    }\n         }\n       else if (strncmp (arm_selected_cpu->name, \"generic\", 7) == 0)"}]}