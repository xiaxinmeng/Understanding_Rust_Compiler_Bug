{"sha": "ff439b5feee1968f82bd45ae2da87afee820ddf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY0MzliNWZlZWUxOTY4ZjgyYmQ0NWFlMmRhODdhZmVlODIwZGRmOA==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gnu.org", "date": "1998-06-04T00:30:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-04T00:30:40Z"}, "message": "expr.c (safe_from_p): Avoid combinatorial explosion over duplicate SAVE_EXPRs by ensuring we never...\n\n        * expr.c (safe_from_p): Avoid combinatorial explosion\n        over duplicate SAVE_EXPRs by ensuring we never recurse\n        on one that has already been visited.\n\nFrom-SVN: r20214", "tree": {"sha": "9c0b386ecc35abd07f7e78ecf16fb27dde9a3117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0b386ecc35abd07f7e78ecf16fb27dde9a3117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff439b5feee1968f82bd45ae2da87afee820ddf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff439b5feee1968f82bd45ae2da87afee820ddf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff439b5feee1968f82bd45ae2da87afee820ddf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff439b5feee1968f82bd45ae2da87afee820ddf8/comments", "author": null, "committer": null, "parents": [{"sha": "7d2a46a8c754157a835273f0d97561dd6e499cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2a46a8c754157a835273f0d97561dd6e499cd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2a46a8c754157a835273f0d97561dd6e499cd0"}], "stats": {"total": 69, "additions": 67, "deletions": 2}, "files": [{"sha": "06e47f7b3f6112a7c42d858108892cf94afaecf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff439b5feee1968f82bd45ae2da87afee820ddf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff439b5feee1968f82bd45ae2da87afee820ddf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff439b5feee1968f82bd45ae2da87afee820ddf8", "patch": "@@ -1,3 +1,9 @@\n+Thu Jun  4 01:26:57 1998  Craig Burley  <burley@gnu.org>\n+\n+\t* expr.c (safe_from_p): Avoid combinatorial explosion\n+\tover duplicate SAVE_EXPRs by ensuring we never recurse\n+\ton one that has already been visited.\n+\n Thu Jun  4 00:54:21 1998  Graham  <grahams@rcp.co.uk>\n \n \t* loop.c (check_dbra_loop): Initialise final_value before"}, {"sha": "9f59dd5e6fbec2bd9e6e3734c256319f207b1d3c", "filename": "gcc/expr.c", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff439b5feee1968f82bd45ae2da87afee820ddf8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff439b5feee1968f82bd45ae2da87afee820ddf8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ff439b5feee1968f82bd45ae2da87afee820ddf8", "patch": "@@ -4644,7 +4644,10 @@ init_noncopied_parts (lhs, list)\n /* Subroutine of expand_expr: return nonzero iff there is no way that\n    EXP can reference X, which is being modified.  TOP_P is nonzero if this\n    call is going to be used to determine whether we need a temporary\n-   for EXP, as opposed to a recursive call to this function.  */\n+   for EXP, as opposed to a recursive call to this function.\n+\n+   It is always safe for this routine to return zero since it merely\n+   searches for optimization opportunities.  */\n \n static int\n safe_from_p (x, exp, top_p)\n@@ -4654,6 +4657,10 @@ safe_from_p (x, exp, top_p)\n {\n   rtx exp_rtl = 0;\n   int i, nops;\n+  static int save_expr_count;\n+  static int save_expr_size = 0;\n+  static tree *save_expr_rewritten;\n+  static tree save_expr_trees[256];\n \n   if (x == 0\n       /* If EXP has varying size, we MUST use a target since we currently\n@@ -4671,6 +4678,28 @@ safe_from_p (x, exp, top_p)\n \t  && GET_MODE (x) == BLKmode))\n     return 1;\n \n+  if (top_p && save_expr_size == 0)\n+    {\n+      int rtn;\n+\n+      save_expr_count = 0;\n+      save_expr_size = sizeof (save_expr_trees) / sizeof (save_expr_trees[0]);\n+      save_expr_rewritten = &save_expr_trees[0];\n+\n+      rtn = safe_from_p (x, exp, 1);\n+\n+      for (i = 0; i < save_expr_count; ++i)\n+\t{\n+\t  if (TREE_CODE (save_expr_trees[i]) != ERROR_MARK)\n+\t    abort ();\n+\t  TREE_SET_CODE (save_expr_trees[i], SAVE_EXPR);\n+\t}\n+\n+      save_expr_size = 0;\n+\n+      return rtn;\n+    }\n+\n   /* If this is a subreg of a hard register, declare it unsafe, otherwise,\n      find the underlying pseudo.  */\n   if (GET_CODE (x) == SUBREG)\n@@ -4702,6 +4731,8 @@ safe_from_p (x, exp, top_p)\n \t\t || safe_from_p (x, TREE_VALUE (exp), 0))\n \t\t&& (TREE_CHAIN (exp) == 0\n \t\t    || safe_from_p (x, TREE_CHAIN (exp), 0)));\n+      else if (TREE_CODE (exp) == ERROR_MARK)\n+\treturn 1;\t/* An already-visited SAVE_EXPR? */\n       else\n \treturn 0;\n \n@@ -4764,7 +4795,35 @@ safe_from_p (x, exp, top_p)\n \n \tcase SAVE_EXPR:\n \t  exp_rtl = SAVE_EXPR_RTL (exp);\n-\t  break;\n+\t  if (exp_rtl)\n+\t    break;\n+\n+\t  /* This SAVE_EXPR might appear many times in the top-level\n+\t     safe_from_p() expression, and if it has a complex\n+\t     subexpression, examining it multiple times could result\n+\t     in a combinatorial explosion.  E.g. on an Alpha\n+\t     running at least 200MHz, a Fortran test case compiled with\n+\t     optimization took about 28 minutes to compile -- even though\n+\t     it was only a few lines long, and the complicated line causing\n+\t     so much time to be spent in the earlier version of safe_from_p()\n+\t     had only 293 or so unique nodes.\n+\n+\t     So, turn this SAVE_EXPR into an ERROR_MARK for now, but remember\n+\t     where it is so we can turn it back in the top-level safe_from_p()\n+\t     when we're done.  */\n+\n+\t  /* For now, don't bother re-sizing the array. */\n+\t  if (save_expr_count >= save_expr_size)\n+\t    return 0;\n+\t  save_expr_rewritten[save_expr_count++] = exp;\n+\t  TREE_SET_CODE (exp, ERROR_MARK);\n+\n+\t  nops = tree_code_length[(int) SAVE_EXPR];\n+\t  for (i = 0; i < nops; i++)\n+\t    if (TREE_OPERAND (exp, i) != 0\n+\t\t&& ! safe_from_p (x, TREE_OPERAND (exp, i), 0))\n+\t      return 0;\n+\t  return 1;\n \n \tcase BIND_EXPR:\n \t  /* The only operand we look at is operand 1.  The rest aren't"}]}