{"sha": "5d64469294e1b8c364e55a6b285f4282c9523d0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ2NDQ2OTI5NGUxYjhjMzY0ZTU1YTZiMjg1ZjQyODJjOTUyM2QwZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-01-16T23:12:53Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-01-16T23:12:53Z"}, "message": "cplus-dem.c: Fix indenting; note that this file also lives in libiberty.\n\n        * cplus-dem.c: Fix indenting; note that this file also lives in\n        libiberty.\n        (do_type, case 'M'): Check for a template as well as a class.\n\nFrom-SVN: r13503", "tree": {"sha": "86b99c5947da3fe787c98489aa4b365dcd37afb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86b99c5947da3fe787c98489aa4b365dcd37afb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d64469294e1b8c364e55a6b285f4282c9523d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d64469294e1b8c364e55a6b285f4282c9523d0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d64469294e1b8c364e55a6b285f4282c9523d0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d64469294e1b8c364e55a6b285f4282c9523d0d/comments", "author": null, "committer": null, "parents": [{"sha": "79aff5ac0d3a0862fd126b36038c553597368644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79aff5ac0d3a0862fd126b36038c553597368644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79aff5ac0d3a0862fd126b36038c553597368644"}], "stats": {"total": 932, "additions": 476, "deletions": 456}, "files": [{"sha": "5028df1d10e4cdf2c5d9dafebf55f65975340eb7", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 476, "deletions": 456, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d64469294e1b8c364e55a6b285f4282c9523d0d/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d64469294e1b8c364e55a6b285f4282c9523d0d/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=5d64469294e1b8c364e55a6b285f4282c9523d0d", "patch": "@@ -25,6 +25,9 @@ Boston, MA 02111-1307, USA.  */\n    realloc except that they generate a fatal error if there is no\n    available memory.  */\n \n+/* This file lives in both GCC and libiberty.  When making changes, please\n+   try not to break either.  */\n+\n #include <ctype.h>\n #include <string.h>\n #include <stdio.h>\n@@ -38,7 +41,7 @@ extern char *xrealloc PARAMS((char *, unsigned));\n \n char *\n mystrstr (s1, s2)\n-  char *s1, *s2;\n+     char *s1, *s2;\n {\n   register char *p = s1;\n   register int len = strlen (s2);\n@@ -81,7 +84,7 @@ void\n set_cplus_marker_for_demangling (ch)\n      int ch;\n {\n-    cplus_markers[0] = ch;\n+  cplus_markers[0] = ch;\n }\n \n /* Stuff that is shared between sub-routines.\n@@ -198,9 +201,9 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n \n #define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n #define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n-\t\t\t\t   string_prepend(str, \" \");}\n+    string_prepend(str, \" \");}\n #define APPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n-\t\t\t\t   string_append(str, \" \");}\n+    string_append(str, \" \");}\n \n #define ARM_VTABLE_STRING \"__vtbl__\"\t/* Lucid/ARM virtual table prefix */\n #define ARM_VTABLE_STRLEN 8\t\t/* strlen (ARM_VTABLE_STRING) */\n@@ -308,17 +311,17 @@ string_prepends PARAMS ((string *, string *));\n \n static int\n consume_count (type)\n-    const char **type;\n+     const char **type;\n {\n-    int count = 0;\n+  int count = 0;\n \n-    while (isdigit (**type))\n-      {\n-\tcount *= 10;\n-\tcount += **type - '0';\n-\t(*type)++;\n-      }\n-    return (count);\n+  while (isdigit (**type))\n+    {\n+      count *= 10;\n+      count += **type - '0';\n+      (*type)++;\n+    }\n+  return (count);\n }\n \n int\n@@ -338,7 +341,7 @@ cplus_demangle_opname (opname, result, options)\n   work->options = options;\n   \n   if (opname[0] == '_' && opname[1] == '_'\n-\t  && opname[2] == 'o' && opname[3] == 'p')\n+      && opname[2] == 'o' && opname[3] == 'p')\n     {\n       /* ANSI.  */\n       /* type conversion operator.  */\n@@ -390,9 +393,9 @@ cplus_demangle_opname (opname, result, options)\n \t}\n     }\n   else if (len >= 3 \n-      && opname[0] == 'o'\n-      && opname[1] == 'p'\n-      && strchr (cplus_markers, opname[2]) != NULL)\n+\t   && opname[0] == 'o'\n+\t   && opname[1] == 'p'\n+\t   && strchr (cplus_markers, opname[2]) != NULL)\n     {\n       /* see if it's an assignment expression */\n       if (len >= 10 /* op$assign_ */\n@@ -643,150 +646,150 @@ demangle_signature (work, mangled, declp)\n     {\n       switch (**mangled)\n \t{\n-\t  case 'Q':\n-\t    oldmangled = *mangled;\n-\t    success = demangle_qualified (work, mangled, declp, 1, 0);\n-\t    if (success)\n-\t      {\n-\t\tremember_type (work, oldmangled, *mangled - oldmangled);\n-\t      }\n-\t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n-\t      {\n-\t\texpect_func = 1;\n-\t      }\n-\t    oldmangled = NULL;\n-\t    break;\n+\tcase 'Q':\n+\t  oldmangled = *mangled;\n+\t  success = demangle_qualified (work, mangled, declp, 1, 0);\n+\t  if (success)\n+\t    {\n+\t      remember_type (work, oldmangled, *mangled - oldmangled);\n+\t    }\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t    {\n+\t      expect_func = 1;\n+\t    }\n+\t  oldmangled = NULL;\n+\t  break;\n \t  \n-\t  case 'S':\n-\t    /* Static member function */\n-\t    if (oldmangled == NULL)\n-\t      {\n-\t\toldmangled = *mangled;\n-\t      }\n-\t    (*mangled)++;\n-\t    work -> static_type = 1;\n-\t    break;\n+\tcase 'S':\n+\t  /* Static member function */\n+\t  if (oldmangled == NULL)\n+\t    {\n+\t      oldmangled = *mangled;\n+\t    }\n+\t  (*mangled)++;\n+\t  work -> static_type = 1;\n+\t  break;\n \n-\t  case 'C':\n-\t    /* a const member function */\n-\t    if (oldmangled == NULL)\n-\t      {\n-\t\toldmangled = *mangled;\n-\t      }\n-\t    (*mangled)++;\n-\t    work -> const_type = 1;\n-\t    break;\n+\tcase 'C':\n+\t  /* a const member function */\n+\t  if (oldmangled == NULL)\n+\t    {\n+\t      oldmangled = *mangled;\n+\t    }\n+\t  (*mangled)++;\n+\t  work -> const_type = 1;\n+\t  break;\n \t  \n-\t  case '0': case '1': case '2': case '3': case '4':\n-\t  case '5': case '6': case '7': case '8': case '9':\n-\t    if (oldmangled == NULL)\n-\t      {\n-\t\toldmangled = *mangled;\n-\t      }\n-\t    success = demangle_class (work, mangled, declp);\n-\t    if (success)\n-\t      {\n-\t\tremember_type (work, oldmangled, *mangled - oldmangled);\n-\t      }\n-\t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n-\t      {\n-\t\texpect_func = 1;\n-\t      }\n-\t    oldmangled = NULL;\n-\t    break;\n+\tcase '0': case '1': case '2': case '3': case '4':\n+\tcase '5': case '6': case '7': case '8': case '9':\n+\t  if (oldmangled == NULL)\n+\t    {\n+\t      oldmangled = *mangled;\n+\t    }\n+\t  success = demangle_class (work, mangled, declp);\n+\t  if (success)\n+\t    {\n+\t      remember_type (work, oldmangled, *mangled - oldmangled);\n+\t    }\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t    {\n+\t      expect_func = 1;\n+\t    }\n+\t  oldmangled = NULL;\n+\t  break;\n \t  \n-\t  case 'F':\n-\t    /* Function */\n-\t    /* ARM style demangling includes a specific 'F' character after\n+\tcase 'F':\n+\t  /* Function */\n+\t  /* ARM style demangling includes a specific 'F' character after\n \t     the class name.  For GNU style, it is just implied.  So we can\n \t     safely just consume any 'F' at this point and be compatible\n \t     with either style.  */\n \n-\t    oldmangled = NULL;\n-\t    func_done = 1;\n-\t    (*mangled)++;\n+\t  oldmangled = NULL;\n+\t  func_done = 1;\n+\t  (*mangled)++;\n \n-\t    /* For lucid/ARM style we have to forget any types we might\n-\t       have remembered up to this point, since they were not argument\n-\t       types.  GNU style considers all types seen as available for\n-\t       back references.  See comment in demangle_args() */\n+\t  /* For lucid/ARM style we have to forget any types we might\n+\t     have remembered up to this point, since they were not argument\n+\t     types.  GNU style considers all types seen as available for\n+\t     back references.  See comment in demangle_args() */\n \n-\t    if (LUCID_DEMANGLING || ARM_DEMANGLING)\n-\t      {\n-\t\tforget_types (work);\n-\t      }\n-\t    success = demangle_args (work, mangled, declp);\n-\t    break;\n+\t  if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+\t    {\n+\t      forget_types (work);\n+\t    }\n+\t  success = demangle_args (work, mangled, declp);\n+\t  break;\n \t  \n-\t  case 't':\n-\t    /* G++ Template */\n-\t    string_init(&trawname); \n-\t    string_init(&tname);\n-            if (oldmangled == NULL)\n-              {\n-                oldmangled = *mangled;\n-              }\n-\t    success = demangle_template (work, mangled, &tname, &trawname);\n-            if (success)\n-              {\n-                remember_type (work, oldmangled, *mangled - oldmangled);\n-              }\n-\t    string_append(&tname, \"::\");\n-\t    string_prepends(declp, &tname);\n-  \t    if (work -> destructor & 1)\n-    \t      {\n-      \t\tstring_prepend (&trawname, \"~\");\n-      \t\tstring_appends (declp, &trawname);\n-\t\twork->destructor -= 1;\n-    \t      }\n-  \t    if ((work->constructor & 1) || (work->destructor & 1))\n-    \t      {\n-      \t\tstring_appends (declp, &trawname);\n-\t\twork->constructor -= 1;\n-              }\n-\t    string_delete(&trawname);\n-\t    string_delete(&tname);\n-\t    oldmangled = NULL;\n-\t    expect_func = 1;\n-\t    break;\n+\tcase 't':\n+\t  /* G++ Template */\n+\t  string_init(&trawname); \n+\t  string_init(&tname);\n+\t  if (oldmangled == NULL)\n+\t    {\n+\t      oldmangled = *mangled;\n+\t    }\n+\t  success = demangle_template (work, mangled, &tname, &trawname);\n+\t  if (success)\n+\t    {\n+\t      remember_type (work, oldmangled, *mangled - oldmangled);\n+\t    }\n+\t  string_append(&tname, \"::\");\n+\t  string_prepends(declp, &tname);\n+\t  if (work -> destructor & 1)\n+\t    {\n+\t      string_prepend (&trawname, \"~\");\n+\t      string_appends (declp, &trawname);\n+\t      work->destructor -= 1;\n+\t    }\n+\t  if ((work->constructor & 1) || (work->destructor & 1))\n+\t    {\n+\t      string_appends (declp, &trawname);\n+\t      work->constructor -= 1;\n+\t    }\n+\t  string_delete(&trawname);\n+\t  string_delete(&tname);\n+\t  oldmangled = NULL;\n+\t  expect_func = 1;\n+\t  break;\n \n-\t  case '_':\n-\t    /* At the outermost level, we cannot have a return type specified,\n-\t       so if we run into another '_' at this point we are dealing with\n-\t       a mangled name that is either bogus, or has been mangled by\n-\t       some algorithm we don't know how to deal with.  So just\n-\t       reject the entire demangling.  */\n-\t    success = 0;\n-\t    break;\n+\tcase '_':\n+\t  /* At the outermost level, we cannot have a return type specified,\n+\t     so if we run into another '_' at this point we are dealing with\n+\t     a mangled name that is either bogus, or has been mangled by\n+\t     some algorithm we don't know how to deal with.  So just\n+\t     reject the entire demangling.  */\n+\t  success = 0;\n+\t  break;\n \n-\t  default:\n-\t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n-\t      {\n-\t\t/* Assume we have stumbled onto the first outermost function\n-\t\t   argument token, and start processing args.  */\n-\t\tfunc_done = 1;\n-\t\tsuccess = demangle_args (work, mangled, declp);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Non-GNU demanglers use a specific token to mark the start\n-\t\t   of the outermost function argument tokens.  Typically 'F',\n-\t\t   for ARM-demangling, for example.  So if we find something\n-\t\t   we are not prepared for, it must be an error.  */\n-\t\tsuccess = 0;\n-\t      }\n-\t    break;\n-\t}\n-/*\n-      if (AUTO_DEMANGLING || GNU_DEMANGLING)\n-*/\n-\t{\n-\t  if (success && expect_func)\n+\tdefault:\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n \t    {\n+\t      /* Assume we have stumbled onto the first outermost function\n+\t\t argument token, and start processing args.  */\n \t      func_done = 1;\n \t      success = demangle_args (work, mangled, declp);\n \t    }\n+\t  else\n+\t    {\n+\t      /* Non-GNU demanglers use a specific token to mark the start\n+\t\t of the outermost function argument tokens.  Typically 'F',\n+\t\t for ARM-demangling, for example.  So if we find something\n+\t\t we are not prepared for, it must be an error.  */\n+\t      success = 0;\n+\t    }\n+\t  break;\n \t}\n+      /*\n+\tif (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t*/\n+      {\n+\tif (success && expect_func)\n+\t  {\n+\t    func_done = 1;\n+\t    success = demangle_args (work, mangled, declp);\n+\t  }\n+      }\n     }\n   if (success && !func_done)\n     {\n@@ -910,70 +913,70 @@ demangle_template (work, mangled, tname, trawname)\n \t  done = 0;\n \t  /* temp is initialized in do_type */\n \t  success = do_type (work, mangled, &temp);\n-/*\n-\t  if (success)\n+\t  /*\n+\t    if (success)\n \t    {\n-\t      string_appends (tname, &temp);\n+\t    string_appends (tname, &temp);\n \t    }\n-*/\n+\t    */\n \t  string_delete(&temp);\n \t  if (!success)\n \t    {\n \t      break;\n \t    }\n-/*\n-\t  string_append (tname, \"=\");\n-*/\n+\t  /*\n+\t    string_append (tname, \"=\");\n+\t    */\n \t  while (*old_p && !done)\n \t    {\t\n \t      switch (*old_p)\n \t\t{\n-\t\t  case 'P':\n-\t\t  case 'p':\n-\t\t  case 'R':\n-\t\t    done = is_pointer = 1;\n-\t\t    break;\n-\t\t  case 'C':\t/* const */\n-\t\t  case 'S':\t/* explicitly signed [char] */\n-\t\t  case 'U':\t/* unsigned */\n-\t\t  case 'V':\t/* volatile */\n-\t\t  case 'F':\t/* function */\n-\t\t  case 'M':\t/* member function */\n-\t\t  case 'O':\t/* ??? */\n-\t\t    old_p++;\n-\t\t    continue;\n-\t\t  case 'Q':\t/* qualified name */\n-                    done = is_integral = 1;\n-                    break;\n-\t\t  case 'T':\t/* remembered type */\n-\t\t    abort ();\n-\t\t    break;\n-\t\t  case 'v':\t/* void */\n-\t\t    abort ();\n-\t\t    break;\n-\t\t  case 'x':\t/* long long */\n-\t\t  case 'l':\t/* long */\n-\t\t  case 'i':\t/* int */\n-\t\t  case 's':\t/* short */\n-\t\t  case 'w':\t/* wchar_t */\n-\t\t    done = is_integral = 1;\n-\t\t    break;\n-\t\t  case 'b':\t/* bool */\n-\t\t    done = is_bool = 1;\n-\t\t    break;\n-\t\t  case 'c':\t/* char */\n-\t\t    done = is_char = 1;\n-\t\t    break;\n-\t\t  case 'r':\t/* long double */\n-\t\t  case 'd':\t/* double */\n-\t\t  case 'f':\t/* float */\n-\t\t    done = is_real = 1;\n-\t\t    break;\n-\t\t  default:\n-\t\t    /* it's probably user defined type, let's assume\n-\t\t       it's integral, it seems hard to figure out\n-\t\t       what it really is */\n-\t\t    done = is_integral = 1;\n+\t\tcase 'P':\n+\t\tcase 'p':\n+\t\tcase 'R':\n+\t\t  done = is_pointer = 1;\n+\t\t  break;\n+\t\tcase 'C':\t/* const */\n+\t\tcase 'S':\t/* explicitly signed [char] */\n+\t\tcase 'U':\t/* unsigned */\n+\t\tcase 'V':\t/* volatile */\n+\t\tcase 'F':\t/* function */\n+\t\tcase 'M':\t/* member function */\n+\t\tcase 'O':\t/* ??? */\n+\t\t  old_p++;\n+\t\t  continue;\n+\t\tcase 'Q':\t/* qualified name */\n+\t\t  done = is_integral = 1;\n+\t\t  break;\n+\t\tcase 'T':\t/* remembered type */\n+\t\t  abort ();\n+\t\t  break;\n+\t\tcase 'v':\t/* void */\n+\t\t  abort ();\n+\t\t  break;\n+\t\tcase 'x':\t/* long long */\n+\t\tcase 'l':\t/* long */\n+\t\tcase 'i':\t/* int */\n+\t\tcase 's':\t/* short */\n+\t\tcase 'w':\t/* wchar_t */\n+\t\t  done = is_integral = 1;\n+\t\t  break;\n+\t\tcase 'b':\t/* bool */\n+\t\t  done = is_bool = 1;\n+\t\t  break;\n+\t\tcase 'c':\t/* char */\n+\t\t  done = is_char = 1;\n+\t\t  break;\n+\t\tcase 'r':\t/* long double */\n+\t\tcase 'd':\t/* double */\n+\t\tcase 'f':\t/* float */\n+\t\t  done = is_real = 1;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  /* it's probably user defined type, let's assume\n+\t\t     it's integral, it seems hard to figure out\n+\t\t     what it really is */\n+\t\t  done = is_integral = 1;\n \t\t}\n \t    }\n \t  if (is_integral)\n@@ -991,8 +994,8 @@ demangle_template (work, mangled, tname, trawname)\n \t    }\n \t  else if (is_char)\n \t    {\n-            char tmp[2];\n-            int val;\n+\t      char tmp[2];\n+\t      int val;\n               if (**mangled == 'm')\n                 {\n                   string_appendn (tname, \"-\", 1);\n@@ -1088,19 +1091,19 @@ demangle_template (work, mangled, tname, trawname)\n     string_append (tname, \" \");\n   string_append (tname, \">\");\n   \n-/*\n-      if (work -> static_type)\n-\t{\n-\t  string_append (declp, *mangled + 1);\n-\t  *mangled += strlen (*mangled);\n-\t  success = 1;\n-\t}\n-      else\n-\t{\n-\t  success = demangle_args (work, mangled, declp);\n-\t}\n+  /*\n+    if (work -> static_type)\n+    {\n+    string_append (declp, *mangled + 1);\n+    *mangled += strlen (*mangled);\n+    success = 1;\n     }\n-*/\n+    else\n+    {\n+    success = demangle_args (work, mangled, declp);\n+    }\n+    }\n+    */\n   return (success);\n }\n \n@@ -1114,14 +1117,14 @@ arm_pt (work, mangled, n, anchor, args)\n   /* ARM template? */\n   if (ARM_DEMANGLING && (*anchor = mystrstr (mangled, \"__pt__\")))\n     {\n-\tint len;\n-        *args = *anchor + 6;\n-\tlen = consume_count (args);\n-        if (*args + len == mangled + n && **args == '_')\n-\t  {\n-\t    ++*args;\n-\t    return 1;\n-\t  }\n+      int len;\n+      *args = *anchor + 6;\n+      len = consume_count (args);\n+      if (*args + len == mangled + n && **args == '_')\n+\t{\n+\t  ++*args;\n+\t  return 1;\n+\t}\n     }\n   return 0;\n }\n@@ -1139,26 +1142,26 @@ demangle_arm_pt (work, mangled, n, declp)\n \n   /* ARM template? */\n   if (arm_pt (work, *mangled, n, &p, &args))\n-  {\n-    string arg;\n-    string_init (&arg);\n-    string_appendn (declp, *mangled, p - *mangled);\n-    string_append (declp, \"<\");\n-    /* should do error checking here */\n-    while (args < e) {\n-      string_clear (&arg);\n-      do_type (work, &args, &arg);\n-      string_appends (declp, &arg);\n-      string_append (declp, \",\");\n-    }\n-    string_delete (&arg);\n-    --declp->p;\n-    string_append (declp, \">\");\n-  }\n+    {\n+      string arg;\n+      string_init (&arg);\n+      string_appendn (declp, *mangled, p - *mangled);\n+      string_append (declp, \"<\");\n+      /* should do error checking here */\n+      while (args < e) {\n+\tstring_clear (&arg);\n+\tdo_type (work, &args, &arg);\n+\tstring_appends (declp, &arg);\n+\tstring_append (declp, \",\");\n+      }\n+      string_delete (&arg);\n+      --declp->p;\n+      string_append (declp, \">\");\n+    }\n   else\n-  {\n-    string_appendn (declp, *mangled, n);\n-  }\n+    {\n+      string_appendn (declp, *mangled, n);\n+    }\n   *mangled += n;\n }\n \n@@ -1173,10 +1176,10 @@ demangle_class_name (work, mangled, declp)\n \n   n = consume_count (mangled);\n   if (strlen (*mangled) >= n)\n-  {\n-    demangle_arm_pt (work, mangled, n, declp);\n-    success = 1;\n-  }\n+    {\n+      demangle_arm_pt (work, mangled, n, declp);\n+      success = 1;\n+    }\n \n   return (success);\n }\n@@ -1326,9 +1329,9 @@ demangle_prefix (work, mangled, declp)\n       work->constructor = 2;\n     }\n \n-/*  This block of code is a reduction in strength time optimization\n-    of:\n-    \tscan = mystrstr (*mangled, \"__\"); */\n+  /*  This block of code is a reduction in strength time optimization\n+      of:\n+      scan = mystrstr (*mangled, \"__\"); */\n \n   {\n     scan = *mangled;\n@@ -1491,9 +1494,9 @@ gnu_special (work, mangled, declp)\n \t\t&& (*mangled)[2] == 'v'\n \t\t&& (*mangled)[3] == 't'\n \t\t&& (*mangled)[4] == '_')\n-\t     || ((*mangled)[1] == 'v'\n-\t\t && (*mangled)[2] == 't'\n-\t\t && strchr (cplus_markers, (*mangled)[3]) != NULL)))\n+\t       || ((*mangled)[1] == 'v'\n+\t\t   && (*mangled)[2] == 't'\n+\t\t   && strchr (cplus_markers, (*mangled)[3]) != NULL)))\n     {\n       /* Found a GNU style virtual table, get past \"_vt<CPLUS_MARKER>\"\n          and create the decl.  Note that we consume the entire mangled\n@@ -1552,16 +1555,16 @@ gnu_special (work, mangled, declp)\n       (*mangled)++;\n       switch (**mangled)\n \t{\n-\t  case 'Q':\n-\t    success = demangle_qualified (work, mangled, declp, 0, 1);\n-\t    break;\n-\t  case 't':\n-\t    success = demangle_template (work, mangled, declp, 0);\n-\t    break;\n-\t  default:\n-\t    n = consume_count (mangled);\n-\t    string_appendn (declp, *mangled, n);\n-\t    (*mangled) += n;\n+\tcase 'Q':\n+\t  success = demangle_qualified (work, mangled, declp, 0, 1);\n+\t  break;\n+\tcase 't':\n+\t  success = demangle_template (work, mangled, declp, 0);\n+\t  break;\n+\tdefault:\n+\t  n = consume_count (mangled);\n+\t  string_appendn (declp, *mangled, n);\n+\t  (*mangled) += n;\n \t}\n       if (success && (p == *mangled))\n \t{\n@@ -1604,16 +1607,16 @@ gnu_special (work, mangled, declp)\n       (*mangled) += 4;\n       switch (**mangled)\n \t{\n-\t  case 'Q':\n-\t    success = demangle_qualified (work, mangled, declp, 0, 1);\n-\t    break;\n-\t  case 't':\n-\t    success = demangle_template (work, mangled, declp, 0);\n-\t    break;\n-\t  default:\n-\t    n = consume_count (mangled);\n-\t    string_appendn (declp, *mangled, n);\n-\t    (*mangled) += n;\n+\tcase 'Q':\n+\t  success = demangle_qualified (work, mangled, declp, 0, 1);\n+\t  break;\n+\tcase 't':\n+\t  success = demangle_template (work, mangled, declp, 0);\n+\t  break;\n+\tdefault:\n+\t  n = consume_count (mangled);\n+\t  string_appendn (declp, *mangled, n);\n+\t  (*mangled) += n;\n \t}\n       if (success && **mangled != '\\0')\n \tsuccess = 0;\n@@ -1819,9 +1822,9 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \t  namelength = consume_count (mangled);\n       \t  if (strlen (*mangled) < namelength)\n \t    {\n-\t    /* Simple sanity check failed */\n-\t       success = 0;\n-\t       break;\n+\t      /* Simple sanity check failed */\n+\t      success = 0;\n+\t      break;\n \t    }\n       \t  string_appendn (&temp, *mangled, namelength);\n       \t  *mangled += namelength;\n@@ -1947,20 +1950,20 @@ do_type (work, mangled, result)\n       switch (**mangled)\n \t{\n \n-\t/* A pointer type */\n+\t  /* A pointer type */\n \tcase 'P':\n \tcase 'p':\n \t  (*mangled)++;\n \t  string_prepend (&decl, \"*\");\n \t  break;\n \n-\t/* A reference type */\n+\t  /* A reference type */\n \tcase 'R':\n \t  (*mangled)++;\n \t  string_prepend (&decl, \"&\");\n \t  break;\n \n-\t/* An array */\n+\t  /* An array */\n \tcase 'A':\n \t  {\n \t    const char *p = ++(*mangled);\n@@ -1996,7 +1999,7 @@ do_type (work, mangled, result)\n \t    }\n \t  break;\n \n-\t/* A function */\n+\t  /* A function */\n \tcase 'F':\n \t  (*mangled)++;\n \t  if (!STRING_EMPTY (&decl) && decl.b[0] == '*')\n@@ -2026,22 +2029,39 @@ do_type (work, mangled, result)\n \n \t    member = **mangled == 'M';\n \t    (*mangled)++;\n-\t    if (!isdigit (**mangled))\n-\t      {\n-\t\tsuccess = 0;\n-\t\tbreak;\n-\t      }\n-\t    n = consume_count (mangled);\n-\t    if (strlen (*mangled) < n)\n+\t    if (!isdigit (**mangled) && **mangled != 't')\n \t      {\n \t\tsuccess = 0;\n \t\tbreak;\n \t      }\n+\n \t    string_append (&decl, \")\");\n \t    string_prepend (&decl, \"::\");\n-\t    string_prependn (&decl, *mangled, n);\n+\t    if (isdigit (**mangled)) \n+\t      {\n+\t\tn = consume_count (mangled);\n+\t\tif (strlen (*mangled) < n)\n+\t\t  {\n+\t\t    success = 0;\n+\t\t    break;\n+\t\t  }\n+\t\tstring_prependn (&decl, *mangled, n);\n+\t\t*mangled += n;\n+\t      }\n+\t    else\n+\t      {\n+\t\tstring temp;\n+\t\tstring_init (&temp);\n+\t\tsuccess = demangle_template (work, mangled, &temp, NULL);\n+\t\tif (success)\n+\t\t  {\n+\t\t    string_prependn (&decl, temp.b, temp.p - temp.b);\n+\t\t    string_clear (&temp);\n+\t\t  }\n+\t\telse\n+\t\t  break;\n+\t      }\n \t    string_prepend (&decl, \"(\");\n-\t    *mangled += n;\n \t    if (member)\n \t      {\n \t\tif (**mangled == 'C')\n@@ -2084,27 +2104,27 @@ do_type (work, mangled, result)\n \t    break;\n \t  }\n         case 'G':\n-\t    (*mangled)++;\n-\t    break;\n+\t  (*mangled)++;\n+\t  break;\n \n \tcase 'C':\n \t  (*mangled)++;\n-/*\n-\t  if ((*mangled)[1] == 'P')\n+\t  /*\n+\t    if ((*mangled)[1] == 'P')\n \t    {\n-*/\n-\t      if (PRINT_ANSI_QUALIFIERS)\n+\t    */\n+\t  if (PRINT_ANSI_QUALIFIERS)\n+\t    {\n+\t      if (!STRING_EMPTY (&decl))\n \t\t{\n-\t\t  if (!STRING_EMPTY (&decl))\n-\t\t    {\n-\t\t      string_prepend (&decl, \" \");\n-\t\t    }\n-\t\t  string_prepend (&decl, \"const\");\n+\t\t  string_prepend (&decl, \" \");\n \t\t}\n-\t      break;\n-/*\n+\t      string_prepend (&decl, \"const\");\n \t    }\n-*/\n+\t  break;\n+\t  /*\n+\t    }\n+\t    */\n \n \t  /* fall through */\n \tdefault:\n@@ -2116,13 +2136,13 @@ do_type (work, mangled, result)\n   switch (**mangled)\n     {\n       /* A qualified name, such as \"Outer::Inner\".  */\n-      case 'Q':\n-        success = demangle_qualified (work, mangled, result, 0, 1);\n-\tbreak;\n+    case 'Q':\n+      success = demangle_qualified (work, mangled, result, 0, 1);\n+      break;\n \n-      default:\n-\tsuccess = demangle_fund_type (work, mangled, result);\n-\tbreak;\n+    default:\n+      success = demangle_fund_type (work, mangled, result);\n+      break;\n     }\n \n   if (success)\n@@ -2169,132 +2189,132 @@ demangle_fund_type (work, mangled, result)\n     {\n       switch (**mangled)\n \t{\n-\t  case 'C':\n-\t    (*mangled)++;\n-\t    if (PRINT_ANSI_QUALIFIERS)\n-\t      {\n-\t\tAPPEND_BLANK (result);\n-\t\tstring_append (result, \"const\");\n-\t      }\n-\t    break;\n-\t  case 'U':\n-\t    (*mangled)++;\n-\t    APPEND_BLANK (result);\n-\t    string_append (result, \"unsigned\");\n-\t    break;\n-\t  case 'S': /* signed char only */\n-\t    (*mangled)++;\n-\t    APPEND_BLANK (result);\n-\t    string_append (result, \"signed\");\n-\t    break;\n-\t  case 'V':\n-\t    (*mangled)++;\n-\t    if (PRINT_ANSI_QUALIFIERS)\n-\t      {\n-\t\tAPPEND_BLANK (result);\n-\t\tstring_append (result, \"volatile\");\n-\t      }\n-\t    break;\n-\t  default:\n-\t    done = 1;\n-\t    break;\n+\tcase 'C':\n+\t  (*mangled)++;\n+\t  if (PRINT_ANSI_QUALIFIERS)\n+\t    {\n+\t      APPEND_BLANK (result);\n+\t      string_append (result, \"const\");\n+\t    }\n+\t  break;\n+\tcase 'U':\n+\t  (*mangled)++;\n+\t  APPEND_BLANK (result);\n+\t  string_append (result, \"unsigned\");\n+\t  break;\n+\tcase 'S': /* signed char only */\n+\t  (*mangled)++;\n+\t  APPEND_BLANK (result);\n+\t  string_append (result, \"signed\");\n+\t  break;\n+\tcase 'V':\n+\t  (*mangled)++;\n+\t  if (PRINT_ANSI_QUALIFIERS)\n+\t    {\n+\t      APPEND_BLANK (result);\n+\t      string_append (result, \"volatile\");\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  done = 1;\n+\t  break;\n \t}\n     }\n \n   /* Now pick off the fundamental type.  There can be only one.  */\n \n   switch (**mangled)\n     {\n-      case '\\0':\n-      case '_':\n-\tbreak;\n-      case 'v':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"void\");\n-\tbreak;\n-      case 'x':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"long long\");\n-\tbreak;\n-      case 'l':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"long\");\n-\tbreak;\n-      case 'i':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"int\");\n-\tbreak;\n-      case 's':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"short\");\n-\tbreak;\n-      case 'b':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"bool\");\n-\tbreak;\n-      case 'c':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"char\");\n-\tbreak;\n-      case 'w':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"wchar_t\");\n-\tbreak;\n-      case 'r':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"long double\");\n-\tbreak;\n-      case 'd':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"double\");\n-\tbreak;\n-      case 'f':\n-\t(*mangled)++;\n-\tAPPEND_BLANK (result);\n-\tstring_append (result, \"float\");\n-\tbreak;\n-      case 'G':\n-\t(*mangled)++;\n-\tif (!isdigit (**mangled))\n-\t  {\n-\t    success = 0;\n-\t    break;\n-\t  }\n-\t/* fall through */\n-      /* An explicit type, such as \"6mytype\" or \"7integer\" */\n-      case '0':\n-      case '1':\n-      case '2':\n-      case '3':\n-      case '4':\n-      case '5':\n-      case '6':\n-      case '7':\n-      case '8':\n-      case '9':\n-\tAPPEND_BLANK (result);\n-\tif (!demangle_class_name (work, mangled, result)) {\n-\t  --result->p;\n+    case '\\0':\n+    case '_':\n+      break;\n+    case 'v':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"void\");\n+      break;\n+    case 'x':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"long long\");\n+      break;\n+    case 'l':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"long\");\n+      break;\n+    case 'i':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"int\");\n+      break;\n+    case 's':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"short\");\n+      break;\n+    case 'b':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"bool\");\n+      break;\n+    case 'c':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"char\");\n+      break;\n+    case 'w':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"wchar_t\");\n+      break;\n+    case 'r':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"long double\");\n+      break;\n+    case 'd':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"double\");\n+      break;\n+    case 'f':\n+      (*mangled)++;\n+      APPEND_BLANK (result);\n+      string_append (result, \"float\");\n+      break;\n+    case 'G':\n+      (*mangled)++;\n+      if (!isdigit (**mangled))\n+\t{\n \t  success = 0;\n+\t  break;\n \t}\n-\tbreak;\n-      case 't':\n-        success = demangle_template(work,mangled, result, 0);\n-        break;\n-      default:\n+      /* fall through */\n+      /* An explicit type, such as \"6mytype\" or \"7integer\" */\n+    case '0':\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+    case '5':\n+    case '6':\n+    case '7':\n+    case '8':\n+    case '9':\n+      APPEND_BLANK (result);\n+      if (!demangle_class_name (work, mangled, result)) {\n+\t--result->p;\n \tsuccess = 0;\n-\tbreak;\n       }\n+      break;\n+    case 't':\n+      success = demangle_template(work,mangled, result, 0);\n+      break;\n+    default:\n+      success = 0;\n+      break;\n+    }\n \n   return (success);\n }\n@@ -2635,7 +2655,7 @@ demangle_function_name (work, mangled, declp, scan)\n \t}\n     }\n   else if (declp->b[0] == '_' && declp->b[1] == '_'\n-\t  && declp->b[2] == 'o' && declp->b[3] == 'p')\n+\t   && declp->b[2] == 'o' && declp->b[3] == 'p')\n     {\n       /* ANSI.  */\n       /* type conversion operator.  */\n@@ -2846,7 +2866,7 @@ string_prependn (p, s, n)\n \n static void\n demangle_it (mangled_name)\n-  char *mangled_name;\n+     char *mangled_name;\n {\n   char *result;\n \n@@ -2874,8 +2894,8 @@ usage (stream, status)\n {    \n   fprintf (stream, \"\\\n Usage: %s [-_] [-n] [-s {gnu,lucid,arm}] [--strip-underscores]\\n\\\n-       [--no-strip-underscores] [--format={gnu,lucid,arm}]\\n\\\n-       [--help] [--version] [arg...]\\n\",\n+      [--no-strip-underscores] [--format={gnu,lucid,arm}]\\n\\\n+      [--help] [--version] [arg...]\\n\",\n \t   program_name);\n   exit (status);\n }\n@@ -2913,40 +2933,40 @@ main (argc, argv)\n     {\n       switch (c)\n \t{\n-\t  case '?':\n-\t    usage (stderr, 1);\n-\t    break;\n-\t  case 'h':\n-\t    usage (stdout, 0);\n-\t  case 'n':\n-\t    strip_underscore = 0;\n-\t    break;\n-\t  case 'v':\n-\t    printf (\"GNU %s version %s\\n\", program_name, program_version);\n-\t    exit (0);\n-\t  case '_':\n-\t    strip_underscore = 1;\n-\t    break;\n-\t  case 's':\n-\t    if (strcmp (optarg, \"gnu\") == 0)\n-\t      {\n-\t\tcurrent_demangling_style = gnu_demangling;\n-\t      }\n-\t    else if (strcmp (optarg, \"lucid\") == 0)\n-\t      {\n-\t\tcurrent_demangling_style = lucid_demangling;\n-\t      }\n-\t    else if (strcmp (optarg, \"arm\") == 0)\n-\t      {\n-\t\tcurrent_demangling_style = arm_demangling;\n-\t      }\n-\t    else\n-\t      {\n-\t\tfprintf (stderr, \"%s: unknown demangling style `%s'\\n\",\n-\t\t\t program_name, optarg);\n-\t\texit (1);\n-\t      }\n-\t    break;\n+\tcase '?':\n+\t  usage (stderr, 1);\n+\t  break;\n+\tcase 'h':\n+\t  usage (stdout, 0);\n+\tcase 'n':\n+\t  strip_underscore = 0;\n+\t  break;\n+\tcase 'v':\n+\t  printf (\"GNU %s version %s\\n\", program_name, program_version);\n+\t  exit (0);\n+\tcase '_':\n+\t  strip_underscore = 1;\n+\t  break;\n+\tcase 's':\n+\t  if (strcmp (optarg, \"gnu\") == 0)\n+\t    {\n+\t      current_demangling_style = gnu_demangling;\n+\t    }\n+\t  else if (strcmp (optarg, \"lucid\") == 0)\n+\t    {\n+\t      current_demangling_style = lucid_demangling;\n+\t    }\n+\t  else if (strcmp (optarg, \"arm\") == 0)\n+\t    {\n+\t      current_demangling_style = arm_demangling;\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (stderr, \"%s: unknown demangling style `%s'\\n\",\n+\t\t       program_name, optarg);\n+\t      exit (1);\n+\t    }\n+\t  break;\n \t}\n     }\n "}]}