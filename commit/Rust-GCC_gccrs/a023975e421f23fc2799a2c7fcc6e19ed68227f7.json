{"sha": "a023975e421f23fc2799a2c7fcc6e19ed68227f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyMzk3NWU0MjFmMjNmYzI3OTlhMmM3ZmNjNmUxOWVkNjgyMjdmNw==", "commit": {"author": {"name": "Olga Golovanevsky", "email": "olga@il.ibm.com", "date": "2004-10-14T17:21:35Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-10-14T17:21:35Z"}, "message": "2004-10-14  Olga Golovanevsky  <olga@il.ibm.com>\n\n        * tree-vectorizer.c (vect_generate_tmps_on_preheader):\n        (vect_update_ivs_after_vectorizer):\n        (vect_transform_for_unknown_loop_bound):\n        (tree_duplicate_loop_to_edge):\n        (allocate_new_names):\n        (rename_use_op):\n        (rename_def_op):\n        (rename_variables_in_bb):\n        (free_new_names):\n        (rename_variables_in_loop):\n        (copy_phi_nodes):\n        (update_phis_for_duplicate_loop):\n        (update_phi_nodes_for_guard):\n        (make_loop_iterate_ntimes):\n        (tree_duplicate_loop_to_edge_cfg):\n        (add_loop_guard):\n        (vect_analyze_loop_with_symbolic_num_of_iters):\n        (verify_loop_for_duplication):\n        (vect_gen_niters_for_prolog_loop):\n        (vect_update_niters_after_peeling):\n        (vect_update_inits_of_dr):\n        (vect_update_inits_of_drs):\n        (vect_build_loop_niters):\n        (vect_do_peeling_for_alignment): New functions.\n        (vect_transform_loop): Add unknown and known but indivisible loop\n        bound support; add peeling for unalignment support.\n        (vect_analyze_loop_form): Support symbolic number of iterations.\n        (vect_transform_loop_bound): New input parameter.\n        (vect_get_loop_niters): Change input parameter type.\n        (new_loop_vec_info): LOOP_VINFO_NITERS is tree now.\n        (vectorizable_store): Allow unaligned access.\n        (vectorize_loops): Add rewrite_into_loop_closed_ssa.\n        (vect_analyze_data_refs_alignment): Allowed one unaligned\n        store.\n        * tree-vectorizer.h (LOOP_VINFO_NITERS_KNOWN_P): Redefined\n        to use tree.\n        (LOOP_VINFO_INT_NITERS): New macro.\n        (MAX_NUMBER_OF_UNALIGNED_DATA_REFS): New define.\n        (do_peeling_for_alignment):\n        (unaligned_drs): New members of _loop_vec_info.\n        (LOOP_DO_PEELING_FOR_ALIGNMENT): New macro.\n\nFrom-SVN: r89040", "tree": {"sha": "cf7a81b91a03469d3f5d1f4413db635fb27b33e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf7a81b91a03469d3f5d1f4413db635fb27b33e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a023975e421f23fc2799a2c7fcc6e19ed68227f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a023975e421f23fc2799a2c7fcc6e19ed68227f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a023975e421f23fc2799a2c7fcc6e19ed68227f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a023975e421f23fc2799a2c7fcc6e19ed68227f7/comments", "author": null, "committer": null, "parents": [{"sha": "7238c5ec254957652393d695e309be7ad8985451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7238c5ec254957652393d695e309be7ad8985451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7238c5ec254957652393d695e309be7ad8985451"}], "stats": {"total": 1930, "additions": 1755, "deletions": 175}, "files": [{"sha": "13d6db424d790c3d6a43b638354a6f57556f4ca6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -1,3 +1,47 @@\n+2004-10-14  Olga Golovanevsky  <olga@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_generate_tmps_on_preheader):\n+\t(vect_update_ivs_after_vectorizer):\n+\t(vect_transform_for_unknown_loop_bound):\n+\t(tree_duplicate_loop_to_edge):\n+\t(allocate_new_names):\n+\t(rename_use_op):\n+\t(rename_def_op):\n+\t(rename_variables_in_bb):\n+\t(free_new_names):\n+\t(rename_variables_in_loop):\n+\t(copy_phi_nodes):\n+\t(update_phis_for_duplicate_loop):\n+\t(update_phi_nodes_for_guard):\n+\t(make_loop_iterate_ntimes):\n+\t(tree_duplicate_loop_to_edge_cfg):\n+\t(add_loop_guard):\n+\t(vect_analyze_loop_with_symbolic_num_of_iters):\n+\t(verify_loop_for_duplication): \n+\t(vect_gen_niters_for_prolog_loop):\n+\t(vect_update_niters_after_peeling):\n+\t(vect_update_inits_of_dr):\n+\t(vect_update_inits_of_drs):\n+\t(vect_build_loop_niters):\n+\t(vect_do_peeling_for_alignment): New functions.\n+\t(vect_transform_loop): Add unknown and known but indivisible loop\n+\tbound support; add peeling for unalignment support. \n+\t(vect_analyze_loop_form): Support symbolic number of iterations.\n+\t(vect_transform_loop_bound): New input parameter.\n+\t(vect_get_loop_niters): Change input parameter type.\n+\t(new_loop_vec_info): LOOP_VINFO_NITERS is tree now.\n+\t(vectorizable_store): Allow unaligned access.\n+\t(vectorize_loops): Add rewrite_into_loop_closed_ssa.\n+\t(vect_analyze_data_refs_alignment): Allowed one unaligned\n+\tstore.\n+\t* tree-vectorizer.h (LOOP_VINFO_NITERS_KNOWN_P): Redefined \n+\tto use tree.\n+\t(LOOP_VINFO_INT_NITERS): New macro.\n+\t(MAX_NUMBER_OF_UNALIGNED_DATA_REFS): New define.\n+\t(do_peeling_for_alignment):\n+\t(unaligned_drs): New members of _loop_vec_info.\n+\t(LOOP_DO_PEELING_FOR_ALIGNMENT): New macro.\n+\n 2004-10-14  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* tree.h (TREE_STRING_POINTER): Wrap in \"const char *\"."}, {"sha": "2919fb34b0794592eaa11be6305b709c43495f79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -1,3 +1,24 @@\n+2004-10-14  Olga GOlovanevsky  <olga@il.ibm.com>\n+\n+\t* testsuite/gcc.dg/vect/vect-28.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-30.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-31.c : Vectorize 4 loops instead of 2.\n+\t* testsuite/gcc.dg/vect/vect-33.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-44.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-46.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-50.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-52.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-54.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-58.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-60.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-64.c : Vectorize 3 loops instead of 1.\n+\t* testsuite/gcc.dg/vect/vect-66.c : Vectorize 3 loops instead of 2.\n+\t* testsuite/gcc.dg/vect/vect-68.c : Vectorize 4 loops instead of 2.\n+\t* testsuite/gcc.dg/vect/vect-69.c : Vectorize 4 loops instead of 2.\n+\t* testsuite/gcc.dg/vect/vect-8.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-80.c : Remove xfail.\n+\t* testsuite/gcc.dg/vect/vect-none.c : Vectorize 1 loops instead of 0.\n+\n 2004-10-14  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect/vect-82.c: New testcase.\t"}, {"sha": "cebfc5a24f5a3ab680eaef7a25ccf9cce976d1a0", "filename": "gcc/testsuite/gcc.dg/vect/vect-26.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -37,5 +37,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n "}, {"sha": "26ebfc1a6e5c1d6d5aa2ea74dc3dccc10362ad4e", "filename": "gcc/testsuite/gcc.dg/vect/vect-28.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -40,5 +40,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n "}, {"sha": "b2c18ef81a3b33949c03b400221dfb37ee5cf823", "filename": "gcc/testsuite/gcc.dg/vect/vect-30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-30.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -64,4 +64,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\"  } } */"}, {"sha": "b15f1569ef407bccccd9686188ed842b8e7c1f68", "filename": "gcc/testsuite/gcc.dg/vect/vect-31.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-31.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -88,4 +88,4 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */"}, {"sha": "8742ef5d2433bc517c39876fb37581b3528266b5", "filename": "gcc/testsuite/gcc.dg/vect/vect-33.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -38,4 +38,4 @@ int main (void)\n } \n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "3549faf11ebb004a90afccc528317a3b43a685b2", "filename": "gcc/testsuite/gcc.dg/vect/vect-44.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -59,4 +59,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "d28c0151ce9a3f311dc499ea64eac0d3ad891ca6", "filename": "gcc/testsuite/gcc.dg/vect/vect-46.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -55,4 +55,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "1104b3fa0c1fc99fda4f8b4e24f03214ffa07541", "filename": "gcc/testsuite/gcc.dg/vect/vect-50.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -54,4 +54,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "f62042969354c38c6900b5d541106e4a55db9617", "filename": "gcc/testsuite/gcc.dg/vect/vect-52.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -56,4 +56,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "cd322d1063d16dc7cc046e0c8f63e9345a3fe5cf", "filename": "gcc/testsuite/gcc.dg/vect/vect-54.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -55,4 +55,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "06a9fd29dcb9d307ccb823e971388fc12e95bd28", "filename": "gcc/testsuite/gcc.dg/vect/vect-58.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -56,4 +56,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "71d6083950548f26557bc2505ace162deb2691e0", "filename": "gcc/testsuite/gcc.dg/vect/vect-60.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -57,4 +57,4 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "67a659cfec56845e17c38efbf72d22339d1e24dd", "filename": "gcc/testsuite/gcc.dg/vect/vect-64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-64.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -83,4 +83,4 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */"}, {"sha": "593a12bbd598ee4ec66c788947adb5324e98d415", "filename": "gcc/testsuite/gcc.dg/vect/vect-66.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-66.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -79,4 +79,4 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */"}, {"sha": "0237e2b78c26854d401f1d6d96b98799dc832227", "filename": "gcc/testsuite/gcc.dg/vect/vect-68.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-68.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -87,4 +87,4 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */"}, {"sha": "753371fd5638f928722b5286bb2c54069289380f", "filename": "gcc/testsuite/gcc.dg/vect/vect-69.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-69.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -114,4 +114,4 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */"}, {"sha": "d3513f76ba8be67472fbe2afa7f5741182673a4c", "filename": "gcc/testsuite/gcc.dg/vect/vect-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-8.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -39,4 +39,4 @@ int main (void)\n   return main1 (N);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "39981be4d09b06b6d7359da2c171c756152c485c", "filename": "gcc/testsuite/gcc.dg/vect/vect-80.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-80.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -47,4 +47,4 @@ int main (void)\n   return 0;\t\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */"}, {"sha": "a9d44759d1d79dd9741d1058cd0430593bc88415", "filename": "gcc/testsuite/gcc.dg/vect/vect-none.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-none.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -189,5 +189,5 @@ foo (int n)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized \" 3 \"vect\"} } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 3 \"vect\"} } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\"} } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "d12d140307abd2f19a9958967aa2e98d1c4c2905", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1652, "deletions": 151, "changes": 1803, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -139,6 +139,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n+#include \"toplev.h\"\n #include \"tree-chrec.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n@@ -158,7 +159,7 @@ static bool vect_analyze_operations (loop_vec_info);\n \n /* Main code transformation functions.  */\n static void vect_transform_loop (loop_vec_info, struct loops *);\n-static void vect_transform_loop_bound (loop_vec_info);\n+static void vect_transform_loop_bound (loop_vec_info, tree niters);\n static bool vect_transform_stmt (tree, block_stmt_iterator *);\n static bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n static bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n@@ -173,14 +174,16 @@ static bool exist_non_indexing_operands_for_use_p (tree, tree);\n static bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *, bool);\n static void vect_mark_relevant (varray_type, tree);\n static bool vect_stmt_relevant_p (tree, loop_vec_info);\n-static tree vect_get_loop_niters (struct loop *, HOST_WIDE_INT *);\n+static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_compute_data_ref_alignment \n   (struct data_reference *, loop_vec_info);\n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_get_first_index (tree, tree *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n   (tree, tree, bool);\n+static bool vect_analyze_loop_with_symbolic_num_of_iters (tree niters, \n+ \t\t\t\t\t\t\t  struct loop *loop);\n static tree vect_get_base_and_bit_offset\n   (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n static struct data_reference * vect_analyze_pointer_ref_access\n@@ -203,17 +206,847 @@ static tree get_vectype_for_scalar_type (tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree);\n static tree vect_init_vector (tree, tree);\n+static tree vect_build_symbol_bound (tree, int, struct loop *);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n \n+static void vect_generate_tmps_on_preheader (loop_vec_info, \n+\t\t\t\t\t     tree *, tree *, \n+\t\t\t\t\t     tree *);\n+static tree vect_build_loop_niters (loop_vec_info);\n+static void vect_update_ivs_after_vectorizer (struct loop *, tree); \n+\n+/* Loop transformations prior to vectorizeration.  */\n+\n+/* Loop transformations entry point function. \n+   It can be used outside of the vectorizer \n+   in case the loop to be manipulated answers conditions specified\n+   in function documentation.  */\n+struct loop *tree_duplicate_loop_to_edge (struct loop *, \n+\t\t\t\t\t  struct loops *, edge, \n+\t\t\t\t\t  tree, tree, bool);\n+\n+static void allocate_new_names (bitmap);\n+static void rename_use_op (use_operand_p);\n+static void rename_def_op (def_operand_p, tree);\n+static void rename_variables_in_bb (basic_block);\n+static void free_new_names (bitmap);\n+static void rename_variables_in_loop (struct loop *);\n+static void copy_phi_nodes (struct loop *, struct loop *, bool);\n+static void update_phis_for_duplicate_loop (struct loop *,\n+\t\t\t\t\t    struct loop *, \n+\t\t\t\t\t    bool after);\n+static void update_phi_nodes_for_guard (edge, struct loop *);  \n+static void make_loop_iterate_ntimes (struct loop *, tree, tree, tree);\n+static struct loop *tree_duplicate_loop_to_edge_cfg (struct loop *, \n+\t\t\t\t\t\t     struct loops *, \n+\t\t\t\t\t\t     edge);\n+static edge add_loop_guard (basic_block, tree, basic_block);\n+static bool verify_loop_for_duplication (struct loop *, bool, edge);\n+\n+/* Utilities dealing with loop peeling (not peeling itself).  */\n+static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n+static void vect_update_niters_after_peeling (loop_vec_info, tree);\n+static void vect_update_inits_of_dr (struct data_reference *, struct loop *, \n+\t\t\t\t     tree niters);\n+static void vect_update_inits_of_drs (loop_vec_info, tree);\n+static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n+\n /* Utilities for creation and deletion of vec_info structs.  */\n loop_vec_info new_loop_vec_info (struct loop *loop);\n void destroy_loop_vec_info (loop_vec_info);\n stmt_vec_info new_stmt_vec_info (tree stmt, struct loop *loop);\n \n-static bool vect_debug_stats (struct loop *loop);\n-static bool vect_debug_details (struct loop *loop);\n+static bool vect_debug_stats (struct loop *loop);\n+static bool vect_debug_details (struct loop *loop);\n+\n+\f\n+/* Utilities to support loop peeling for vectorization purposes.  */\n+\n+\n+/* For each definition in DEFINITIONS this function allocates \n+   new ssa name.  */\n+\n+static void\n+allocate_new_names (bitmap definitions)\n+{\n+  unsigned ver;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n+    {\n+      tree def = ssa_name (ver);\n+      tree *new_name_ptr = xmalloc (sizeof (tree));\n+\n+      bool abnormal = SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def);\n+\n+      *new_name_ptr = duplicate_ssa_name (def, SSA_NAME_DEF_STMT (def));\n+      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (*new_name_ptr) = abnormal;\n+\n+      SSA_NAME_AUX (def) = new_name_ptr;\n+    }\n+}\n+\n+\n+/* Renames the use *OP_P.  */\n+\n+static void\n+rename_use_op (use_operand_p op_p)\n+{\n+  tree *new_name_ptr;\n+\n+  if (TREE_CODE (USE_FROM_PTR (op_p)) != SSA_NAME)\n+    return;\n+\n+  new_name_ptr = SSA_NAME_AUX (USE_FROM_PTR (op_p));\n+\n+  /* Something defined outside of the loop.  */\n+  if (!new_name_ptr)\n+    return;\n+\n+  /* An ordinary ssa name defined in the loop.  */\n+\n+  SET_USE (op_p, *new_name_ptr);\n+}\n+\n+\n+/* Renames the def *OP_P in statement STMT.  */\n+\n+static void\n+rename_def_op (def_operand_p op_p, tree stmt)\n+{\n+  tree *new_name_ptr;\n+\n+  if (TREE_CODE (DEF_FROM_PTR (op_p)) != SSA_NAME)\n+    return;\n+\n+  new_name_ptr = SSA_NAME_AUX (DEF_FROM_PTR (op_p));\n+\n+  /* Something defined outside of the loop.  */\n+  if (!new_name_ptr)\n+    return;\n+\n+  /* An ordinary ssa name defined in the loop.  */\n+\n+  SET_DEF (op_p, *new_name_ptr);\n+  SSA_NAME_DEF_STMT (DEF_FROM_PTR (op_p)) = stmt;\n+}\n+\n+\n+/* Renames the variables in basic block BB.  */\n+\n+static void\n+rename_variables_in_bb (basic_block bb)\n+{\n+  tree phi;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+  stmt_ann_t ann;\n+  use_optype uses;\n+  vuse_optype vuses;\n+  def_optype defs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  unsigned i;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+    rename_def_op (PHI_RESULT_PTR (phi), phi);\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+      get_stmt_operands (stmt);\n+      ann = stmt_ann (stmt);\n+\n+      uses = USE_OPS (ann);\n+      for (i = 0; i < NUM_USES (uses); i++)\n+\trename_use_op (USE_OP_PTR (uses, i));\n+\n+      defs = DEF_OPS (ann);\n+      for (i = 0; i < NUM_DEFS (defs); i++)\n+\trename_def_op (DEF_OP_PTR (defs, i), stmt);\n+\n+      vuses = VUSE_OPS (ann);\n+      for (i = 0; i < NUM_VUSES (vuses); i++)\n+\trename_use_op (VUSE_OP_PTR (vuses, i));\n+\n+      v_may_defs = V_MAY_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t{\n+\t  rename_use_op (V_MAY_DEF_OP_PTR (v_may_defs, i));\n+\t  rename_def_op (V_MAY_DEF_RESULT_PTR (v_may_defs, i), stmt);\n+\t}\n+\n+      v_must_defs = V_MUST_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\trename_def_op (V_MUST_DEF_OP_PTR (v_must_defs, i), stmt);\n+    }\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n+      rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e));\n+}\n+\n+\n+/* Releases the structures holding the new ssa names.  */\n+\n+static void\n+free_new_names (bitmap definitions)\n+{\n+  unsigned ver;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n+    {\n+      tree def = ssa_name (ver);\n+\n+      if (SSA_NAME_AUX (def))\n+\t{\n+\t  free (SSA_NAME_AUX (def));\n+\t  SSA_NAME_AUX (def) = NULL;\n+\t}\n+    }\n+}\n+\n+\n+/* Renames variables in new generated LOOP.  */\n+\n+static void\n+rename_variables_in_loop (struct loop *loop)\n+{\n+  unsigned i;\n+  basic_block *bbs;\n+\n+  bbs = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    rename_variables_in_bb (bbs[i]);\n+\n+  free (bbs);\n+}\n+\n+\n+/* This function copies phis from LOOP header to\n+   NEW_LOOP header. AFTER is as\n+   in update_phis_for_duplicate_loop function.  */\n+\n+static void\n+copy_phi_nodes (struct loop *loop, struct loop *new_loop,\n+\t\t      bool after)\n+{\n+  tree phi, new_phi, def;\n+  edge new_e;\n+  edge e = (after ? loop_latch_edge (loop) : loop_preheader_edge (loop));\n+\n+  /* Second add arguments to newly created phi nodes.  */\n+  for (phi = phi_nodes (loop->header),\n+\t new_phi = phi_nodes (new_loop->header);\n+       phi;\n+       phi = TREE_CHAIN (phi),\n+\t new_phi = TREE_CHAIN (new_phi))\n+    {\n+      new_e = loop_preheader_edge (new_loop);\n+      def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      add_phi_arg (&new_phi, def, new_e);\n+    }\n+}\n+\n+\n+/* Update the PHI nodes of the NEW_LOOP. AFTER is true if the NEW_LOOP\n+   executes after LOOP, and false if it executes before it.  */\n+\n+static void\n+update_phis_for_duplicate_loop (struct loop *loop,\n+                                struct loop *new_loop, bool after)\n+{\n+  edge old_latch;\n+  tree *new_name_ptr, new_ssa_name;\n+  tree phi_new, phi_old, def;\n+  edge orig_entry_e = loop_preheader_edge (loop);\n+\n+  /* Copy phis from loop->header to new_loop->header.  */\n+  copy_phi_nodes (loop, new_loop, after);\n+\n+  old_latch = loop_latch_edge (loop);\n+\n+  /* Update PHI args for the new loop latch edge, and\n+     the old loop preheader edge, we know that the PHI nodes\n+     are ordered appropriately in copy_phi_nodes.  */\n+  for (phi_new = phi_nodes (new_loop->header),\n+       phi_old = phi_nodes (loop->header);\n+       phi_new && phi_old;\n+       phi_new = TREE_CHAIN (phi_new), phi_old = TREE_CHAIN (phi_old))\n+    {\n+      def = PHI_ARG_DEF_FROM_EDGE (phi_old, old_latch);\n+\n+      if (TREE_CODE (def) != SSA_NAME)\n+\tcontinue;\n+\n+      new_name_ptr = SSA_NAME_AUX (def);\n+\n+      /* Something defined outside of the loop.  */\n+      if (!new_name_ptr)\n+\tcontinue;\n+\n+      /* An ordinary ssa name defined in the loop.  */\n+      new_ssa_name = *new_name_ptr;\n+\n+      add_phi_arg (&phi_new, new_ssa_name, loop_latch_edge(new_loop));\n+\n+      /* Update PHI args for the original loop pre-header edge.  */\n+      if (! after)\n+        SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi_old, orig_entry_e),\n+\t         new_ssa_name);\n+    }\n+}\n+\n+\n+/* Update PHI nodes for a guard of the LOOP.\n+\n+   LOOP is supposed to have a preheader bb at which a guard condition is \n+   located.  The true edge of this condition skips the LOOP and ends\n+   at the destination of the (unique) LOOP exit.  The loop exit bb is supposed \n+   to be an empty bb (created by this transformation) with one successor.\n+\n+   This function creates phi nodes at the LOOP exit bb.  These phis need to be\n+   created as a result of adding true edge coming from guard.\n+\n+   FORNOW: Only phis which have corresponding phi nodes at the header of the\n+   LOOP are created.  Here we use the assumption that after the LOOP there\n+   are no uses of defs generated in LOOP.\n+\n+   After the phis creation, the function updates the values of phi nodes at\n+   the LOOP exit successor bb:\n+\n+   Original loop:\n+\n+   bb0: loop preheader\n+        goto bb1\n+   bb1: loop header\n+        if (exit_cond) goto bb3 else goto bb2\n+   bb2: loop latch\n+        goto bb1\n+   bb3:\n+\n+\n+   After guard creation (the loop before this function):\n+\n+   bb0: loop preheader\n+        if (guard_condition) goto bb4 else goto bb1\n+   bb1: loop header\n+        if (exit_cond) goto bb4 else goto bb2\n+   bb2: loop latch\n+        goto bb1\n+   bb4: loop exit       \n+        (new empty bb)\n+        goto bb3\n+   bb3:\n+\n+   This function updates the phi nodes in bb4 and in bb3, to account for the \n+   new edge from bb0 to bb4.  */\n+\n+static void\n+update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n+{\n+  tree phi, phi1;\n+\n+  for (phi = phi_nodes (loop->header); phi; phi = TREE_CHAIN (phi))\n+      {\n+\ttree new_phi;\n+\ttree phi_arg;\n+\n+\t/* Generate new phi node.  */\n+\tnew_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (phi)),\n+\t\t\t           loop->exit_edges[0]->dest);\n+\n+\t/* Add argument coming from guard true edge.  */\n+\tphi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->entry_edges[0]);\n+\tadd_phi_arg (&new_phi, phi_arg, guard_true_edge);\n+\n+\t/* Add argument coming from loop exit edge.  */\n+\tphi_arg = PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0));\t\t\t           \n+\tadd_phi_arg (&new_phi, phi_arg, loop->exit_edges[0]);\n+      \n+\t/* Update all phi nodes at the loop exit successor.  */\n+\tfor (phi1 = phi_nodes (EDGE_SUCC (loop->exit_edges[0]->dest, 0)->dest); \n+\t     phi1; \n+\t     phi1 = TREE_CHAIN (phi1))\n+\t  {\n+\t    tree old_arg = PHI_ARG_DEF_FROM_EDGE (phi1, \n+\t\t\t\t  EDGE_SUCC (loop->exit_edges[0]->dest, 0));\n+\t    if (old_arg == phi_arg)\n+\t      {\t\n+\t\tedge e = EDGE_SUCC (loop->exit_edges[0]->dest, 0);\n+\n+\t\tSET_PHI_ARG_DEF (phi1, \n+\t\t\t\t phi_arg_from_edge (phi1, e),\n+\t\t\t\t PHI_RESULT (new_phi)); \n+\t      }\n+\t  }\n+      }       \n+}\n+\n+\n+/* Make the LOOP iterate NITERS times. This is done by adding a new IV\n+   that starts at zero, increases by one and its limit is NITERS.  */\n+\n+static void\n+make_loop_iterate_ntimes (struct loop *loop, tree niters,\n+\t\t\t  tree begin_label, tree exit_label)\n+{\n+  tree indx_before_incr, indx_after_incr, cond_stmt, cond;\n+  tree orig_cond;\n+  edge exit_edge = loop->exit_edges[0];\n+  block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n+\n+  /* Flow loop scan does not update loop->single_exit field.  */\n+  loop->single_exit = loop->exit_edges[0];\n+  orig_cond = get_loop_exit_condition (loop);\n+  gcc_assert (orig_cond);\n+  create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop,\n+             &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n+  \n+  /* CREATE_IV uses BSI_INSERT with TSI_NEW_STMT, so we want to get\n+     back to the exit condition statement.  */\n+  bsi_next (&loop_exit_bsi);\n+  gcc_assert (bsi_stmt (loop_exit_bsi) == orig_cond);\n+\n+\n+  if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n+    cond = build2 (GE_EXPR, boolean_type_node, indx_after_incr, niters);\n+  else /* 'then' edge loops back.   */\n+    cond = build2 (LT_EXPR, boolean_type_node, indx_after_incr, niters);\n+\n+  begin_label = build1 (GOTO_EXPR, void_type_node, begin_label);\n+  exit_label = build1 (GOTO_EXPR, void_type_node, exit_label);\n+  cond_stmt = build (COND_EXPR, TREE_TYPE (orig_cond), cond,\n+\t\t     begin_label, exit_label);\n+  bsi_insert_before (&loop_exit_bsi, cond_stmt, BSI_SAME_STMT);\n+\n+  /* Remove old loop exit test:  */\n+  bsi_remove (&loop_exit_bsi);\n+\n+  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+    print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n+}\n+\n+\n+/* Given LOOP this function generates a new copy of it and puts it \n+   on E which is either the entry or exit of LOOP.  */\n+\n+static struct loop *\n+tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops, \n+\t\t\t\t edge e)\n+{\n+  struct loop *new_loop;\n+  basic_block *new_bbs, *bbs;\n+  bool at_exit;\n+  bool was_imm_dom;\n+  basic_block exit_dest; \n+  tree phi, phi_arg;\n+\n+  at_exit = (e == loop->exit_edges[0]); \n+  if (!at_exit && e != loop_preheader_edge (loop))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file,\n+\t\t   \"Edge is not an entry nor an exit edge.\\n\");\n+      return NULL;\n+    }\n+\n+  bbs = get_loop_body (loop);\n+\n+  /* Check whether duplication is possible.  */\n+  if (!can_copy_bbs_p (bbs, loop->num_nodes))\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t  fprintf (dump_file,\n+\t\t   \"Cannot copy basic blocks.\\n\");\n+      free (bbs);\n+      return NULL;\n+    }\n+\n+  /* Generate new loop structure.  */\n+  new_loop = duplicate_loop (loops, loop, loop->outer);\n+  if (!new_loop)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t  fprintf (dump_file,\n+\t\t   \"The duplicate_loop returns NULL.\\n\");\n+      free (bbs);\n+      return NULL;\n+    }\n+\n+  exit_dest = loop->exit_edges[0]->dest;\n+  was_imm_dom = (get_immediate_dominator (CDI_DOMINATORS, \n+\t\t\t\t\t  exit_dest) == loop->header ? \n+\t\t true : false);\n+\n+  new_bbs = xmalloc (sizeof (basic_block) * loop->num_nodes);\n+\n+  copy_bbs (bbs, loop->num_nodes, new_bbs, NULL, 0, NULL, NULL);\n+\n+  /* Duplicating phi args at exit bbs as coming \n+     also from exit of duplicated loop.  */\n+  for (phi = phi_nodes (exit_dest); phi; phi = TREE_CHAIN (phi))\n+    {\n+      phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->exit_edges[0]);\n+      if (phi_arg)\n+\t{\n+\t  edge new_loop_exit_edge;\n+\n+\t  if (EDGE_SUCC (new_loop->header, 0)->dest == new_loop->latch)\n+\t    new_loop_exit_edge = EDGE_SUCC (new_loop->header, 1);\n+\t  else\n+\t    new_loop_exit_edge = EDGE_SUCC (new_loop->header, 0);\n+  \n+\t  add_phi_arg (&phi, phi_arg, new_loop_exit_edge);\t\n+\t}\n+    }    \n+   \n+  if (at_exit) /* Add the loop copy at exit.  */\n+    {\n+      redirect_edge_and_branch_force (e, new_loop->header);\n+      set_immediate_dominator (CDI_DOMINATORS, new_loop->header, e->src);\n+      if (was_imm_dom)\n+\tset_immediate_dominator (CDI_DOMINATORS, exit_dest, new_loop->header);\n+    }\n+  else /* Add the copy at entry.  */\n+    {\n+      edge new_exit_e;\n+      edge entry_e = loop_preheader_edge (loop);\n+      basic_block preheader = entry_e->src;\n+           \n+      if (!flow_bb_inside_loop_p (new_loop, \n+\t\t\t\t  EDGE_SUCC (new_loop->header, 0)->dest))\n+        new_exit_e = EDGE_SUCC (new_loop->header, 0);\n+      else\n+\tnew_exit_e = EDGE_SUCC (new_loop->header, 1); \n+\n+      redirect_edge_and_branch_force (new_exit_e, loop->header);\n+      set_immediate_dominator (CDI_DOMINATORS, loop->header,\n+\t\t\t       new_exit_e->src);\n+\n+      /* We have to add phi args to the loop->header here as coming \n+\t from new_exit_e edge.  */\n+      for (phi = phi_nodes (loop->header); phi; phi = TREE_CHAIN (phi))\n+\t{\n+\t  phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, entry_e);\n+\t  if (phi_arg)\n+\t    add_phi_arg (&phi, phi_arg, new_exit_e);\t\n+\t}    \n+\n+      redirect_edge_and_branch_force (entry_e, new_loop->header);\n+      set_immediate_dominator (CDI_DOMINATORS, new_loop->header, preheader);\n+    }\n+\n+  flow_loop_scan (new_loop, LOOP_ALL);\n+  flow_loop_scan (loop, LOOP_ALL);  \n+  free (new_bbs);\n+  free (bbs);\n+\n+  return new_loop;\n+}\n+\n+\n+/* Given the condition statement COND, put it as the last statement\n+   of GUARD_BB; EXIT_BB is the basic block to skip the loop;\n+   Assumes that this is the single exit of the guarded loop.  \n+   Returns the skip edge.  */\n+\n+static edge\n+add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n+{\n+  block_stmt_iterator bsi;\n+  edge new_e, enter_e;\n+  tree cond_stmt, then_label, else_label;\n+\n+  enter_e = EDGE_SUCC (guard_bb, 0);\n+  enter_e->flags &= ~EDGE_FALLTHRU;\n+  enter_e->flags |= EDGE_FALSE_VALUE;\n+  bsi = bsi_last (guard_bb);\n+\n+  then_label = build1 (GOTO_EXPR, void_type_node,\n+                       tree_block_label (exit_bb));\n+  else_label = build1 (GOTO_EXPR, void_type_node,\n+                       tree_block_label (enter_e->dest));\n+  cond_stmt = build (COND_EXPR, void_type_node, cond,\n+   \t\t     then_label, else_label);\n+  bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n+  /* Add new edge to connect entry block to the second loop.  */\n+  new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);\n+  set_immediate_dominator (CDI_DOMINATORS, exit_bb, guard_bb);\n+  return new_e;\n+}\n+\n+\n+/* This function verifies that certain restrictions apply to LOOP.  */\n+\n+static bool\n+verify_loop_for_duplication (struct loop *loop,\n+\t\t\t     bool update_first_loop_count, edge e)\n+{\n+  edge exit_e = loop->exit_edges [0];\n+  edge entry_e = loop_preheader_edge (loop);\n+\n+  /* We duplicate only innermost loops.  */\n+  if (loop->inner)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t  fprintf (dump_file,\n+\t\t   \"Loop duplication failed. Loop is not innermost.\\n\");\n+      return false;\n+    }\n+\n+  /* Only loops with 1 exit. */\n+  if (loop->num_exits != 1)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t  fprintf (dump_file,\n+\t\t   \"More than one exit from loop.\\n\");\n+      return false;\n+    }\n+\n+  /* Only loops with 1 entry. */\n+  if (loop->num_entries != 1)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t  fprintf (dump_file,\n+\t\t   \"More than one exit from loop.\\n\");\n+      return false;\n+    }\n+\n+  /* All loops has outers, the only case loop->outer is NULL is for\n+     the function itself.  */\n+  if (!loop->outer)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t  fprintf (dump_file,\n+\t\t   \"Loop is outer-most loop.\\n\");\n+      return false;\n+    }\n+  \n+  /* Verify that new IV can be created and loop condition \n+     can be changed to make first loop iterate first_niters times.  */\n+  if (!update_first_loop_count)\n+    {\n+      tree orig_cond = get_loop_exit_condition (loop);\n+      block_stmt_iterator loop_exit_bsi = bsi_last (exit_e->src);\n+      \n+      if (!orig_cond)\n+\t{\n+\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t    fprintf (dump_file,\n+\t\t     \"Loop has no exit condition.\\n\");\n+\t  return false;\n+\t}\n+      if (orig_cond != bsi_stmt (loop_exit_bsi))\n+\t{\n+\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\t    fprintf (dump_file,\n+\t\t     \"Loop exit condition is not loop header last stmt.\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Make sure E is either an entry or an exit edge.  */\n+  if (e != exit_e && e != entry_e)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\tfprintf (dump_file,\n+\t\t \"E is not loop entry or exit edge.\\n\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Given LOOP this function duplicates it to the edge E. \n+\n+   This transformation takes place before the loop is vectorized. \n+   For now, there are two main cases when it's used \n+   by the vectorizer: to support loops with unknown loop bounds \n+   (or loop bounds indivisible by vectorization factor) and to force the \n+   alignment of data references in the loop. In the first case, LOOP is \n+   duplicated to the exit edge, producing epilog loop. In the second case, LOOP \n+   is duplicated to the preheader edge thus generating prolog loop. In both \n+   cases, the original loop will be vectorized after the transformation. \n+\n+   The edge E is supposed to be either preheader edge of the LOOP or  \n+   its exit edge. If preheader edge is specified, the LOOP copy \n+   will precede the original one. Otherwise the copy will be located \n+   at the exit of the LOOP.\n+   \n+   FIRST_NITERS (SSA_NAME) parameter specifies how many times to iterate \n+   the first loop. If UPDATE_FIRST_LOOP_COUNT parameter is false, the first \n+   loop will be iterated FIRST_NITERS times by introducing additional \n+   induction variable and replacing loop exit condition. If \n+   UPDATE_FIRST_LOOP_COUNT is true no change to the first loop is made and \n+   the caller to tree_duplicate_loop_to_edge is responsible for updating \n+   the first loop count.\n+   \n+   NITERS (also SSA_NAME) parameter defines the number of iteration the\n+   original loop iterated. The function generates two if-then guards: \n+   one prior to the first loop and the other prior to the second loop. \n+   The first guard will be:\n+\n+   if (FIRST_NITERS == 0) then skip the first loop\n+   \n+   The second guard will be:\n+\n+   if (FIRST_NITERS == NITERS) then skip the second loop\n+\n+   Thus the equivalence to the original code is guaranteed by correct values \n+   of NITERS and FIRST_NITERS and generation of if-then loop guards.\n+\n+   For now this function supports only loop forms that are candidate for \n+   vectorization. Such types are the following: \n+\n+   (1) only innermost loops \n+   (2) loops built from 2 basic blocks \n+   (3) loops with one entry and one exit\n+   (4) loops without function calls\n+   (5) loops without defs that are used after the loop \n+\n+   (1), (3) are checked in this function; (2) - in function \n+   vect_analyze_loop_form; (4) - in function vect_analyze_data_refs;\n+   (5) is checked as part of the function vect_mark_stmts_to_be_vectorized, \n+   when excluding induction/reduction support.   \n+\n+   The function returns NULL in case one of these checks or \n+   transformations failed.  */\n+   \n+struct loop*\n+tree_duplicate_loop_to_edge (struct loop *loop, struct loops *loops, \n+\t\t\t     edge e, tree first_niters, \n+\t\t\t     tree niters, bool update_first_loop_count)\n+{\n+  struct loop *new_loop = NULL, *first_loop, *second_loop;\n+  edge skip_e;\n+  tree pre_condition;\n+  bitmap definitions;\n+  basic_block first_exit_bb, second_exit_bb;\n+  basic_block pre_header_bb;\n+  edge exit_e = loop->exit_edges [0];\n+\n+  gcc_assert (!any_marked_for_rewrite_p ());\n+\n+  if (!verify_loop_for_duplication (loop, update_first_loop_count, e))\n+      return NULL;\n+\n+  /* We have to initialize cfg_hooks. Then, when calling \n+   cfg_hooks->split_edge, the function tree_split_edge \n+   is actually called and, when calling cfg_hooks->duplicate_block, \n+   the function tree_duplicate_bb is called.  */\n+  tree_register_cfg_hooks ();\n+\n+  /* 1. Generate a copy of LOOP and put it on E (entry or exit).  */\n+  if (!(new_loop = tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n+\tfprintf (dump_file,\n+\t\t \"The tree_duplicate_loop_to_edge_cfg failed.\\n\");\n+      return NULL;\n+    }\n+\n+  definitions = marked_ssa_names ();\n+  allocate_new_names (definitions);\n+  update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n+  /* Here, using assumption (5), we do not propagate new names futher \n+     than on phis of the exit from the second loop.  */\n+  rename_variables_in_loop (new_loop);\n+  free_new_names (definitions);\n+\n+  if (e == exit_e)\n+    {\n+      first_loop = loop;\n+      second_loop = new_loop;\n+    }\n+  else \n+    {\n+      first_loop = new_loop;\n+      second_loop = loop;\n+    }\n+\n+  /* 2. Generate bb between the loops.  */\n+  first_exit_bb = split_edge (first_loop->exit_edges[0]);\n+  add_bb_to_loop (first_exit_bb, first_loop->outer);\n+\n+  /* We need to update here first loop exit edge \n+     and second loop preheader edge.  */\n+  flow_loop_scan (first_loop, LOOP_ALL);\n+  flow_loop_scan (second_loop, LOOP_ALL);  \n+\n+  /* 3. Make first loop iterate FIRST_NITERS times, if needed.  */\n+  if (!update_first_loop_count)\n+    {\n+      tree first_loop_latch_lbl = tree_block_label (first_loop->latch);\n+      tree first_loop_exit_lbl = tree_block_label (first_exit_bb);\n+\n+      make_loop_iterate_ntimes (first_loop, first_niters,\n+\t\t\t\tfirst_loop_latch_lbl,\n+\t\t\t\tfirst_loop_exit_lbl);\n+    }\n+  \n+  /* 4. Add the guard before first loop:\n+\n+     if FIRST_NITERS == 0 \n+       skip first loop\n+     else \n+       enter first loop  */\n+\n+  /* 4a. Generate bb before first loop.  */\n+  pre_header_bb = split_edge (loop_preheader_edge (first_loop));\n+  add_bb_to_loop (pre_header_bb, first_loop->outer);\n+\n+  /* First loop preheader edge is changed.  */\n+  flow_loop_scan (first_loop, LOOP_ALL);\n \n+  /* 4b. Generate guard condition.  */\n+  pre_condition = build (LE_EXPR, boolean_type_node,\n+\t\t\t   first_niters, integer_zero_node);\n+\n+  /* 4c. Add condition at the end of preheader bb.  */\n+  skip_e = add_loop_guard (pre_header_bb, pre_condition, first_exit_bb);\n+\n+  /* 4d. Updtae phis at first loop exit and propagate changes \n+     to the phis of second loop.  */\n+  update_phi_nodes_for_guard (skip_e, first_loop);\n+\n+  /* 5. Add the guard before second loop:\n+\n+     if FIRST_NITERS == NITERS SKIP\n+       skip second loop\n+     else \n+       enter second loop  */\n+\n+  /* 5a. Generate empty bb at the exit from the second loop.  */\n+  second_exit_bb = split_edge (second_loop->exit_edges[0]);\n+  add_bb_to_loop (second_exit_bb, second_loop->outer);\n+\n+  /* Second loop preheader edge is changed.  */\n+  flow_loop_scan (second_loop, LOOP_ALL);\n+\n+  /* 5b. Generate guard condition.  */\n+  pre_condition = build (EQ_EXPR, boolean_type_node,\n+\t\t\t   first_niters, niters);\n+\n+  /* 5c. Add condition at the end of preheader bb.  */\n+  skip_e = add_loop_guard (first_exit_bb, pre_condition, second_exit_bb);\n+  update_phi_nodes_for_guard (skip_e, second_loop);\n+\n+  BITMAP_XFREE (definitions);\n+  unmark_all_for_rewrite ();\n+  \n+  return new_loop;\n+}\n+\n+\n+\f\n+/* Here the proper Vectorizer starts.  */\n \n /* Function new_stmt_vec_info.\n \n@@ -274,13 +1107,17 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_LOOP (res) = loop;\n   LOOP_VINFO_BBS (res) = bbs;\n   LOOP_VINFO_EXIT_COND (res) = NULL;\n-  LOOP_VINFO_NITERS (res) = -1;\n+  LOOP_VINFO_NITERS (res) = NULL;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n+  LOOP_DO_PEELING_FOR_ALIGNMENT (res) = false;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_WRITES (res), 20,\n \t\t\t   \"loop_write_datarefs\");\n   VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_READS (res), 20,\n \t\t\t   \"loop_read_datarefs\");\n+\n+  for (i=0; i<MAX_NUMBER_OF_UNALIGNED_DATA_REFS; i++)\n+    LOOP_UNALIGNED_DR (res, i) = NULL;\n   return res;\n }\n \n@@ -595,7 +1432,6 @@ vect_get_base_and_bit_offset (struct data_reference *dr,\n }\n \n \n-\n /* Function vect_force_dr_alignment_p.\n \n    Returns whether the alignment of a DECL can be forced to be aligned\n@@ -709,8 +1545,8 @@ vect_create_index_for_vector_ref (struct loop *loop, block_stmt_iterator *bsi)\n    OFFSET: Optional. If supplied, it is be added to the initial address.\n \n    Output:\n-   1. Return an SSA_NAME whose value is the address of the memory location of the\n-      first vector of the data reference.\n+   1. Return an SSA_NAME whose value is the address of the memory location of \n+      the first vector of the data reference.\n    2. If new_stmt_list is not NULL_TREE after return then the caller must insert\n       these statement(s) which define the returned SSA_NAME.\n \n@@ -744,7 +1580,8 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   /* Only the access function of the last index is relevant (i_n in\n      a[i_1][i_2]...[i_n]), the others correspond to loop invariants. */\n   access_fn = DR_ACCESS_FN (dr, 0);\n-  ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_oval, &step, true);\n+  ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_oval, &step, \n+\t\t\t\t    true);\n   if (!ok)\n     init_oval = integer_zero_node;\n \n@@ -1519,8 +2356,6 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  if (!aligned_access_p (STMT_VINFO_DATA_REF (stmt_info)))\n-    return false;\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -1613,7 +2448,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \tsoftware_pipeline_loads_p = true;\n       else if (!targetm.vectorize.misaligned_mem_ok (mode))\n \t{\n-\t  /* Possibly unaligned access, and can't software pipeline the loads  */\n+\t  /* Possibly unaligned access, and can't software pipeline the loads.\n+\t   */\n \t  if (vect_debug_details (loop))\n \t    fprintf (dump_file, \"Arbitrary load not supported.\");\n \t  return false;\n@@ -1731,7 +2567,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t}\n       else\n \t{\n-\t  /* Use current address instead of init_addr for reduced reg pressure.  */\n+\t  /* Use current address instead of init_addr for reduced reg pressure.\n+\t   */\n \t  magic = dataref_ptr;\n \t}\n \n@@ -1745,124 +2582,612 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       add_phi_arg (&phi_stmt, lsq, loop_latch_edge (loop));\n \n \n-      /* <5> Create <vec_dest = realign_load (msq, lsq, magic)> in loop  */\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      new_stmt = build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, magic);\n-      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n-      new_temp = make_ssa_name (vec_dest, new_stmt); \n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-    }\n+      /* <5> Create <vec_dest = realign_load (msq, lsq, magic)> in loop  */\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      new_stmt = build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, magic);\n+      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n+      new_temp = make_ssa_name (vec_dest, new_stmt); \n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+    }\n+\n+  *vec_stmt = new_stmt;\n+  return true;\n+}\n+\n+\n+/* Function vect_transform_stmt.\n+\n+   Create a vectorized stmt to replace STMT, and insert it at BSI.  */\n+\n+static bool\n+vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n+{\n+  bool is_store = false;\n+  tree vec_stmt = NULL_TREE;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  bool done;\n+\n+  switch (STMT_VINFO_TYPE (stmt_info))\n+    {\n+    case op_vec_info_type:\n+      done = vectorizable_operation (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case assignment_vec_info_type:\n+      done = vectorizable_assignment (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case load_vec_info_type:\n+      done = vectorizable_load (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n+    case store_vec_info_type:\n+      done = vectorizable_store (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      is_store = true;\n+      break;\n+    default:\n+      if (vect_debug_details (NULL))\n+        fprintf (dump_file, \"stmt not supported.\");\n+      gcc_unreachable ();\n+    }\n+\n+  STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+\n+  return is_store;\n+}\n+\n+\n+/* This function builds ni_name = number of iterations loop executes\n+   on the loop preheader.  */\n+\n+static tree\n+vect_build_loop_niters (loop_vec_info loop_vinfo)\n+{\n+  tree ni_name, stmt, var;\n+  edge pe;\n+  basic_block new_bb;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree ni = unshare_expr (LOOP_VINFO_NITERS(loop_vinfo));\n+\n+  var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n+  add_referenced_tmp_var (var);\n+  if (TREE_CODE (ni) == INTEGER_CST)\n+    {\n+      /* This case is generated when treating a known loop bound \n+\t indivisible by VF. Here we cannot use force_gimple_operand.  */\n+      stmt = build (MODIFY_EXPR, void_type_node, var, ni);\n+      ni_name = make_ssa_name (var, stmt);\n+      TREE_OPERAND (stmt, 0) = ni_name;\n+    }\n+  else\n+    ni_name = force_gimple_operand (ni, &stmt, false, var);\n+\n+  pe = loop_preheader_edge (loop);\n+  new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+  if (new_bb)\n+    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+      \n+  return ni_name;\n+}\n+\n+\n+/* This function generates the following statements:\n+\n+ ni_name = number of iterations loop executes\n+ ratio = ni_name / vf\n+ ratio_mult_vf_name = ratio * vf\n+\n+ and places them at the loop preheader edge.  */\n+\n+static void \n+vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo, tree *ni_name_p,\n+\t\t\t\t tree *ratio_mult_vf_name_p, tree *ratio_p)\n+{\n+\n+  edge pe;\n+  basic_block new_bb;\n+  tree stmt, ni_name;\n+  tree ratio;\n+  tree ratio_mult_vf_name, ratio_mult_vf;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree ni = LOOP_VINFO_NITERS(loop_vinfo);\n+  \n+  int vf, i;\n+\n+  /* Generate temporary variable that contains \n+     number of iterations loop executes.  */\n+\n+  ni_name = vect_build_loop_niters (loop_vinfo);\n+\n+  /* ratio = ni / vf.\n+     vf is power of 2; then if ratio =  = n >> log2 (vf).   */\n+  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  ratio = vect_build_symbol_bound (ni_name, vf, loop);\n+       \n+  /* Update initial conditions of loop copy.  */\n+       \n+  /* ratio_mult_vf = ratio * vf;  \n+     then if ratio_mult_vf = ratio << log2 (vf).  */\n+\n+  i = exact_log2 (vf);\n+  ratio_mult_vf = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n+  add_referenced_tmp_var (ratio_mult_vf);\n+\n+  ratio_mult_vf_name = make_ssa_name (ratio_mult_vf, NULL_TREE);\n+\n+  stmt = build2 (MODIFY_EXPR, void_type_node, ratio_mult_vf_name,\n+\t\tbuild2 (LSHIFT_EXPR, TREE_TYPE (ratio),\n+\t\t       ratio, build_int_cst (unsigned_type_node,\n+\t\t\t\t\t     i)));\n+\n+  SSA_NAME_DEF_STMT (ratio_mult_vf_name) = stmt;\n+\n+  pe = loop_preheader_edge (loop);\n+  new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+  if (new_bb)\n+    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+\n+  *ni_name_p = ni_name;\n+  *ratio_mult_vf_name_p = ratio_mult_vf_name;\n+  *ratio_p = ratio;\n+    \n+  return;  \n+}\n+\n+\n+/* This function generates stmt \n+   \n+   tmp = n / vf;\n+\n+   and attaches it to preheader of LOOP.  */\n+\n+static tree \n+vect_build_symbol_bound (tree n, int vf, struct loop * loop)\n+{\n+  tree var, stmt, var_name;\n+  edge pe;\n+  basic_block new_bb;\n+  int i;\n+\n+  /* create temporary variable */\n+  var = create_tmp_var (TREE_TYPE (n), \"bnd\");\n+  add_referenced_tmp_var (var);\n+\n+  var_name = make_ssa_name (var, NULL_TREE);\n+\n+  /* vf is power of 2; then n/vf = n >> log2 (vf).   */\n+\n+  i = exact_log2 (vf);\n+  stmt = build2 (MODIFY_EXPR, void_type_node, var_name,\n+\t\tbuild2 (RSHIFT_EXPR, TREE_TYPE (n),\n+\t\t       n, build_int_cst (unsigned_type_node,i)));\n+\n+  SSA_NAME_DEF_STMT (var_name) = stmt;\n+\n+  pe = loop_preheader_edge (loop);\n+  new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+  if (new_bb)\n+    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+  else\t\n+    if (vect_debug_details (NULL))\n+      fprintf (dump_file, \"New bb on preheader edge was not generated.\");\n+\n+  return var_name;\n+}\n+\n+\n+/* Function vect_transform_loop_bound.\n+\n+   Create a new exit condition for the loop.  */\n+\n+static void\n+vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  edge exit_edge = loop->single_exit;\n+  block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n+  tree indx_before_incr, indx_after_incr;\n+  tree orig_cond_expr;\n+  HOST_WIDE_INT old_N = 0;\n+  int vf;\n+  tree cond_stmt;\n+  tree new_loop_bound;\n+  bool symbol_niters;\n+  tree cond;\n+  tree lb_type;\n+\n+  symbol_niters = !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo);\n+\n+  if (!symbol_niters)\n+    old_N = LOOP_VINFO_INT_NITERS (loop_vinfo);\n+\n+  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+  orig_cond_expr = LOOP_VINFO_EXIT_COND (loop_vinfo);\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (orig_cond_expr);\n+#endif\n+  gcc_assert (orig_cond_expr == bsi_stmt (loop_exit_bsi));\n+\n+  create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop, \n+\t     &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n+\n+  /* bsi_insert is using BSI_NEW_STMT. We need to bump it back \n+     to point to the exit condition.  */\n+  bsi_next (&loop_exit_bsi);\n+  gcc_assert (bsi_stmt (loop_exit_bsi) == orig_cond_expr);\n+\n+  /* new loop exit test:  */\n+  lb_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (orig_cond_expr, 0), 1));\n+  if (!symbol_niters)\n+    new_loop_bound = fold_convert (lb_type, \n+\t\t\t\t   build_int_cst (unsigned_type_node, \n+\t\t\t\t\t\t  old_N/vf));\n+  else\n+    new_loop_bound = niters;\n+\n+  if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n+    cond = build2 (GE_EXPR, boolean_type_node, \n+\t\t   indx_after_incr, new_loop_bound);\n+  else /* 'then' edge loops back.   */\n+    cond = build2 (LT_EXPR, boolean_type_node, \n+\t\t   indx_after_incr, new_loop_bound);\n+\n+  cond_stmt = build3 (COND_EXPR, TREE_TYPE (orig_cond_expr), cond,\n+\tTREE_OPERAND (orig_cond_expr, 1), TREE_OPERAND (orig_cond_expr, 2));\n+\n+  bsi_insert_before (&loop_exit_bsi, cond_stmt, BSI_SAME_STMT);   \n+\n+  /* remove old loop exit test:  */\n+  bsi_remove (&loop_exit_bsi);\n+\n+  if (vect_debug_details (NULL))\n+    print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n+}\n+\n+\n+/*   Advance IVs of the loop (to be vectorized later) to correct position.\n+\n+     When loop is vectorized, its IVs are not always advanced\n+     correctly since vectorization changes the loop count. It's ok\n+     in case epilog loop was not produced after original one before \n+     vectorization process (the vectorizer checks that there is no uses \n+     of IVs after the loop). However, in case the epilog loop was peeled, \n+     IVs from original loop are used in epilog loop and should be \n+     advanced correctly.\n+\n+     Here we use access functions of IVs and number of\n+     iteration loop executes in order to bring IVs to correct position.\n+\n+     Function also update phis of basic block at the exit\n+     from the loop.  */\n+\n+static void\n+vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n+{\n+  edge exit = loop->exit_edges[0];\n+  tree phi;\n+  edge latch = loop_latch_edge (loop);\n+\n+  /* Generate basic block at the exit from the loop.  */\n+  basic_block new_bb = split_edge (exit);\n+  add_bb_to_loop (new_bb, EDGE_SUCC (new_bb, 0)->dest->loop_father);\n+  \n+  loop->exit_edges[0] = EDGE_PRED (new_bb, 0);\n+  \n+  for (phi = phi_nodes (loop->header); phi; phi = TREE_CHAIN (phi))\n+    {\n+      tree access_fn = NULL;\n+      tree evolution_part;\n+      tree init_expr;\n+      tree step_expr;\n+      tree var, stmt, ni, ni_name;\n+      int i, j, num_elem1, num_elem2;\n+      tree phi1;\n+      block_stmt_iterator last_bsi;\n+\n+      /* Skip virtual phi's. The data dependences that are associated with\n+         virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n+\n+      if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n+\t{\n+\t  if (vect_debug_details (NULL))\n+\t    fprintf (dump_file, \"virtual phi. skip.\");\n+\t  continue;\n+\t}\n+\n+      access_fn = analyze_scalar_evolution (loop, PHI_RESULT (phi)); \n+\n+      evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n+      \n+      /* FORNOW: We do not transform initial conditions of IVs \n+\t which evolution functions are a polynomial of degree >= 2 or\n+\t exponential.  */\n+\n+      step_expr = evolution_part;\n+      init_expr = initial_condition (access_fn);\n+\n+      ni = build2 (PLUS_EXPR, TREE_TYPE (init_expr),\n+\t\t  build2 (MULT_EXPR, TREE_TYPE (niters),\n+\t\t       niters, step_expr), init_expr);\n+\n+      var = create_tmp_var (TREE_TYPE (init_expr), \"tmp\");\n+      add_referenced_tmp_var (var);\n+\n+      ni_name = force_gimple_operand (ni, &stmt, false, var);\n+      \n+      /* Insert stmt into new_bb.  */\n+      last_bsi = bsi_last (new_bb);\n+      bsi_insert_after (&last_bsi, stmt, BSI_NEW_STMT);   \n+\n+      /* Fix phi expressions in duplicated loop.  */\n+      num_elem1 = PHI_NUM_ARGS (phi);\n+      for (i = 0; i < num_elem1; i++)\n+\tif (PHI_ARG_EDGE (phi, i) == latch)\n+\t  {\n+\t    tree def = PHI_ARG_DEF (phi, i);\n+\n+\t    for (phi1 = phi_nodes (EDGE_SUCC (new_bb, 0)->dest); phi1; \n+\t\t phi1 = TREE_CHAIN (phi1))\n+\t      {\n+\t\tnum_elem2 = PHI_NUM_ARGS (phi1);\n+\t\tfor (j = 0; j < num_elem2; j++)\n+\t\t  if (PHI_ARG_DEF (phi1, j) == def)\n+\t\t    {\n+\t\t      SET_PHI_ARG_DEF (phi1, j, ni_name);\n+\t\t      PHI_ARG_EDGE (phi1, j) = EDGE_SUCC (new_bb, 0);\t\t      \n+\t\t      break;\n+ \t\t    }\t\t    \n+\t      }\n+\t    break;\n+\t  }\n+    }\n+        \n+}\n+\n+\n+/* This function is the main driver of tranformation \n+   to be done for loop before vectorizing it in case of \n+   unknown loop bound.  */\n+\n+static void \n+vect_transform_for_unknown_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n+\t\t\t\t       struct loops *loops)\n+{\n+\n+  tree ni_name, ratio_mult_vf_name;\n+#ifdef ENABLE_CHECKING\n+  int loop_num;\n+#endif\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *new_loop;\n+\n+  if (vect_debug_details (NULL))\n+    fprintf (dump_file, \"\\n<<vect_transtorm_for_unknown_loop_bound>>\\n\");\n+\n+  /* Generate the following variables on the preheader of original loop:\n+\t \n+     ni_name = number of iteration the original loop executes\n+     ratio = ni_name / vf\n+     ratio_mult_vf_name = ratio * vf  */\n+  vect_generate_tmps_on_preheader (loop_vinfo, &ni_name,\n+\t\t\t\t   &ratio_mult_vf_name, ratio);\n+\n+  /* Update loop info.  */\n+  loop->pre_header = loop_preheader_edge (loop)->src;\n+  loop->pre_header_edges[0] = loop_preheader_edge (loop);\n+\n+#ifdef ENABLE_CHECKING\n+  loop_num  = loop->num; \n+#endif\n+  new_loop = tree_duplicate_loop_to_edge (loop, loops, loop->exit_edges[0],\n+\t\t\t\t\t  ratio_mult_vf_name, ni_name, true); \n+#ifdef ENABLE_CHECKING\n+  gcc_assert (new_loop);\n+  gcc_assert (loop_num == loop->num);\n+#endif\n+\n+  /* Update IVs of original loop as if they were advanced \n+     by ratio_mult_vf_name steps.  */\n+\n+#ifdef ENABLE_CHECKING\n+  /* Check existence of intermediate bb.  */\n+  gcc_assert (loop->exit_edges[0]->dest == new_loop->pre_header);\n+#endif\n+  vect_update_ivs_after_vectorizer (loop, ratio_mult_vf_name); \n+\n+  return;\n \n-  *vec_stmt = new_stmt;\n-  return true;\n }\n \n \n-/* Function vect_transform_stmt.\n+/* Function vect_gen_niters_for_prolog_loop\n \n-   Create a vectorized stmt to replace STMT, and insert it at BSI.  */\n+   Set the number of iterations for the loop represented by LOOP_VINFO\n+   to the minimum between NITERS (the original iteration count of the loop)\n+   and the misalignment DR  - the first data reference in the list\n+   LOOP_UNALIGNED_DR (LOOP_VINFO). As a result, after the execution of this\n+   loop, the data reference DR will refer to an aligned location.  */\n \n-static bool\n-vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n+static tree \n+vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree niters)\n {\n-  bool is_store = false;\n-  tree vec_stmt = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  bool done;\n+  struct data_reference *dr = LOOP_UNALIGNED_DR (loop_vinfo, 0);\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree var, stmt;\n+  tree iters, iters_name;\n+  edge pe;\n+  basic_block new_bb;\n+  tree dr_stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n+  tree start_addr, byte_miss_align, elem_miss_align;\n+  int vec_type_align = \n+    GET_MODE_ALIGNMENT (TYPE_MODE (STMT_VINFO_VECTYPE (stmt_info))) \n+\t\t\t\t\t\t\t/ BITS_PER_UNIT;\n+  tree tmp1, tmp2;\n+  tree new_stmt_list = NULL_TREE;\n \n-  switch (STMT_VINFO_TYPE (stmt_info))\n-    {\n-    case op_vec_info_type:\n-      done = vectorizable_operation (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      break;\n+  start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n+\t\t\t\t\t\t     &new_stmt_list, NULL_TREE);\n+\n+  pe = loop_preheader_edge (loop); \n+  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt_list); \n+  if (new_bb)\n+    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n+\n+  byte_miss_align = \n+\tbuild (BIT_AND_EXPR, integer_type_node, start_addr, \n+\t\t  build (MINUS_EXPR, integer_type_node, \n+\t\t\t build_int_cst (unsigned_type_node,\n+\t\t\t\t\tvec_type_align), integer_one_node));\n+  tmp1 = build_int_cst (unsigned_type_node, vec_type_align/vf);\n+  elem_miss_align = build (FLOOR_DIV_EXPR, integer_type_node, \n+\t\t\t   byte_miss_align, tmp1); \n+  \n+  tmp2 = \n+\tbuild (BIT_AND_EXPR, integer_type_node,\n+\t  build (MINUS_EXPR, integer_type_node, \n+\t\tbuild_int_cst (unsigned_type_node, vf), elem_miss_align),\n+\t  build (MINUS_EXPR, integer_type_node, \n+\t\tbuild_int_cst (unsigned_type_node, vf), integer_one_node)); \n+\n+  iters = build2 (MIN_EXPR, TREE_TYPE (tmp2), tmp2, niters);\n+  var = create_tmp_var (TREE_TYPE (iters), \"iters\");\n+  add_referenced_tmp_var (var);\n+  iters_name = force_gimple_operand (iters, &stmt, false, var);\n+\n+  /* Insert stmt on loop preheader edge.  */\n+  pe = loop_preheader_edge (loop);\n+  new_bb = bsi_insert_on_edge_immediate (pe, stmt);\n+  if (new_bb)\n+    add_bb_to_loop (new_bb, EDGE_PRED (new_bb, 0)->src->loop_father);\n \n-    case assignment_vec_info_type:\n-      done = vectorizable_assignment (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      break;\n+  return iters_name; \n+}\n \n-    case load_vec_info_type:\n-      done = vectorizable_load (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      break;\n \n-    case store_vec_info_type:\n-      done = vectorizable_store (stmt, bsi, &vec_stmt);\n-      gcc_assert (done);\n-      is_store = true;\n-      break;\n-    default:\n-      if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"stmt not supported.\");\n-      gcc_unreachable ();\n-    }\n+/* Function vect_update_niters_after_peeling\n \n-  STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+   NITERS iterations were peeled from the loop represented by LOOP_VINFO. \n+   The new number of iterations is therefore original_niters - NITERS.\n+   Record the new number of iterations in LOOP_VINFO.  */\n \n-  return is_store;\n+static void\n+vect_update_niters_after_peeling (loop_vec_info loop_vinfo, tree niters)\n+{\n+  tree n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n+  LOOP_VINFO_NITERS (loop_vinfo) = \n+    build (MINUS_EXPR, integer_type_node, n_iters, niters);      \n }\n \n \n-/* Function vect_transform_loop_bound.\n+/* Function vect_update_inits_of_dr\n \n-   Create a new exit condition for the loop.  */\n+   NITERS iterations were peeled from LOOP.  DR represents a data reference\n+   in LOOP.  This function updates the information recorded in DR to\n+   account for the fact that the first NITERS iterations had already been \n+   executed.  Specifically, it updates the initial_condition of the \n+   access_function of DR.  */\n \n static void\n-vect_transform_loop_bound (loop_vec_info loop_vinfo)\n+vect_update_inits_of_dr (struct data_reference *dr, struct loop *loop, \n+\t\t\t tree niters)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  edge exit_edge = loop->single_exit;\n-  block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n-  tree indx_before_incr, indx_after_incr;\n-  tree orig_cond_expr;\n-  HOST_WIDE_INT old_N = 0;\n-  int vf;\n-  tree cond_stmt;\n-  tree new_loop_bound;\n-  tree cond;\n-  tree lb_type;\n+  tree access_fn = DR_ACCESS_FN (dr, 0);\n+  tree init, init_new, step;\n+      \n+  step = evolution_part_in_loop_num (access_fn, loop->num);\n+  init = initial_condition (access_fn);\n+      \n+  init_new = build (PLUS_EXPR, TREE_TYPE (init),\n+\t\t  build (MULT_EXPR, TREE_TYPE (niters),\n+\t\t\t niters, step), init);\n+  DR_ACCESS_FN (dr, 0) = chrec_replace_initial_condition (access_fn, init_new);\n+  \n+  return;\n+}\n \n-  gcc_assert (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo));\n-  old_N = LOOP_VINFO_NITERS (loop_vinfo);\n-  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-  /* FORNOW: \n-     assuming number-of-iterations divides by the vectorization factor.  */\n-  gcc_assert (!(old_N % vf));\n+/* Function vect_update_inits_of_drs\n \n-  orig_cond_expr = LOOP_VINFO_EXIT_COND (loop_vinfo);\n-  gcc_assert (orig_cond_expr);\n-  gcc_assert (orig_cond_expr == bsi_stmt (loop_exit_bsi));\n+   NITERS iterations were peeled from the loop represented by LOOP_VINFO.  \n+   This function updates the information recorded for the data references in \n+   the loop to account for the fact that the first NITERS iterations had \n+   already been executed.  Specifically, it updates the initial_condition of the\n+   access_function of all the data_references in the loop.  */\n \n-  create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop, \n-\t     &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n+static void\n+vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n+{\n+  unsigned int i;\n+  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n+  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-  /* bsi_insert is using BSI_NEW_STMT. We need to bump it back \n-     to point to the exit condition.  */\n-  bsi_next (&loop_exit_bsi);\n-  gcc_assert (bsi_stmt (loop_exit_bsi) == orig_cond_expr);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n<<vect_update_inits_of_dr>>\\n\");\n \n-  /* new loop exit test:  */\n-  lb_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (orig_cond_expr, 0), 1));\n-  new_loop_bound = build_int_cst (lb_type, old_N/vf);\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n+      vect_update_inits_of_dr (dr, loop, niters);\n+    }\n \n-  if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n-    cond = build2 (GE_EXPR, boolean_type_node, indx_after_incr, new_loop_bound);\n-  else /* 'then' edge loops back.   */\n-    cond = build2 (LT_EXPR, boolean_type_node, indx_after_incr, new_loop_bound);\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n+      vect_update_inits_of_dr (dr, loop, niters);\n+      DR_MISALIGNMENT (dr) = -1; \n+    }\n+}\n \n-  cond_stmt = build3 (COND_EXPR, TREE_TYPE (orig_cond_expr), cond,\n-\tTREE_OPERAND (orig_cond_expr, 1), TREE_OPERAND (orig_cond_expr, 2));\n \n-  bsi_insert_before (&loop_exit_bsi, cond_stmt, BSI_SAME_STMT);   \n+/* Function vect_do_peeling_for_alignment\n \n-  /* remove old loop exit test:  */\n-  bsi_remove (&loop_exit_bsi);\n+   Peel the first 'niters' iterations of the loop represented by LOOP_VINFO.\n+   'niters' is set to the misalignment of one of the data references in the\n+   loop, thereby forcing it to refer to an aligned location at the beginning\n+   of the execution of this loop.  The data reference for which we are\n+   peeling is chosen from LOOP_UNALIGNED_DR.  */\n+\n+static void\n+vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree niters_of_prolog_loop, ni_name;\n+  struct data_reference *dr = LOOP_UNALIGNED_DR (loop_vinfo, 0);\n \n   if (vect_debug_details (NULL))\n-    print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n+    fprintf (dump_file, \"\\n<<vect_do_peeling_for_alignment>>\\n\");\n+\n+  ni_name = vect_build_loop_niters (loop_vinfo);\n+  niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name);\n+  \n+\n+  /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n+  tree_duplicate_loop_to_edge (loop, loops, loop_preheader_edge(loop), \n+\t\t\t\t  niters_of_prolog_loop, ni_name, false); \n+\n+\n+  /* Update stmt info of dr according to which we peeled.  */\n+  DR_MISALIGNMENT (dr) = 0; \n+  \n+  /* Update number of times loop executes.  */\n+  vect_update_niters_after_peeling (loop_vinfo, niters_of_prolog_loop);\n+\n+  /* Update all inits of access functions of all data refs.  */\n+  vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);\n+\n+  /* After peeling we have to reset scalar evolution analyzer.  */\n+  scev_reset ();\n+\n+  return;\n }\n \n \n@@ -1881,13 +3206,45 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   int nbbs = loop->num_nodes;\n   block_stmt_iterator si;\n   int i;\n+  tree ratio = NULL;\n #ifdef ENABLE_CHECKING\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n #endif\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vec_transform_loop>>\\n\");\n \n+  \n+  /* Peel the loop if there are data refs with unknown alignment.\n+     Only one data ref with unknown store is allowed.  */\n+\n+  \n+  if (LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+    vect_do_peeling_for_alignment (loop_vinfo, loops);\n+  \n+  /* If the loop has a symbolic number of iterations 'n' \n+     (i.e. it's not a compile time constant), \n+     then an epilog loop needs to be created. We therefore duplicate \n+     the initial loop. The original loop will be vectorized, and will compute\n+     the first (n/VF) iterations. The second copy of the loop will remain \n+     serial and will compute the remaining (n%VF) iterations.\n+     (VF is the vectorization factor).  */\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    vect_transform_for_unknown_loop_bound (loop_vinfo, &ratio, loops);\n+\n+  /* FORNOW: we'll treat the case where niters is constant and \n+     \n+                        niters % vf != 0\n+\n+     in the way similar to one with symbolic niters. \n+     For this we'll generate variable which value is equal to niters.  */\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) \n+      && (LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0))\n+    vect_transform_for_unknown_loop_bound (loop_vinfo, &ratio, loops);\n+\n+\n   /* 1) Make sure the loop header has exactly two entries\n      2) Make sure we have a preheader basic block.  */\n \n@@ -1948,7 +3305,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */\n \n-  vect_transform_loop_bound (loop_vinfo);\n+  vect_transform_loop_bound (loop_vinfo, ratio);\n \n   if (vect_debug_details (loop))\n     fprintf (dump_file,\"Success! loop vectorized.\");\n@@ -2174,30 +3531,27 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n \n-  /* FORNOW: handle only cases where the loop bound divides by the\n-     vectorization factor.  */\n-\n-  if (vect_debug_details (NULL))\n+  \n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) \n+      && vect_debug_details (NULL))\n     fprintf (dump_file, \n \t\"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n-\tvectorization_factor, LOOP_VINFO_NITERS (loop_vinfo));\n-\n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)) \n-    {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\tfprintf (dump_file, \"not vectorized: Unknown loop bound.\");\n-      return false;\n-    }\n+\tvectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) \n-      && LOOP_VINFO_NITERS (loop_vinfo) % vectorization_factor != 0)\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-        fprintf (dump_file, \"not vectorized: loop bound doesn't divided by %d.\",\n-\t\t vectorization_factor);\n-      return false;\n+      /* In this case we have to generate epilog loop, that \n+\t can be done only for loops with one entry edge.  */\n+      if (LOOP_VINFO_LOOP (loop_vinfo)->num_entries != 1\n+\t  || !(LOOP_VINFO_LOOP (loop_vinfo)->pre_header))\n+\t{\n+\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t    fprintf (dump_file, \"not vectorized: more than one entry.\");\n+\t  return false;\n+\t}\n     }\n-\n+  \n   return true;\n }\n \n@@ -2272,7 +3626,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n     return false;\n   \n   step_expr = evolution_part;\n-  init_expr = initial_condition (access_fn);\n+  init_expr = unshare_expr (initial_condition (access_fn));\n \n   if (vect_debug_details (NULL))\n     {\n@@ -2832,11 +4186,12 @@ vect_compute_array_ref_alignment (struct data_reference *dr,\n   tree nbits;\n \n   if (TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n-      /* The reference is an array without its last index. */\n-      next_ref = vect_compute_array_base_alignment (ref, vectype, &dims, &misalign);\n+    /* The reference is an array without its last index. */\n+    next_ref = vect_compute_array_base_alignment (ref, vectype, &dims, \n+\t\t\t\t\t\t  &misalign);\n   else\n-      next_ref = \n-\tvect_compute_array_base_alignment (oprnd0, vectype, &dims, &misalign);\n+    next_ref = vect_compute_array_base_alignment (oprnd0, vectype, &dims, \n+\t\t\t\t\t\t  &misalign);\n   if (!vectype)\n     /* Alignment is not requested. Just return the base.  */\n     return next_ref;\n@@ -3037,9 +4392,11 @@ static bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   /*varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);*/\n \n   unsigned int i;\n+  unsigned int decide_peeling_count = 0;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_analyze_data_refs_alignment>>\\n\");\n@@ -3062,19 +4419,33 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n \n \n   /* Finally, check that loop can be vectorized. \n-     FOR NOW: Until support for misaligned accesses is in place, only if all\n-     accesses are aligned can the loop be vectorized. This restriction will be \n-     relaxed.  */\n+     FOR NOW: Until support for misaligned stores is in place, only if all\n+     stores are aligned can the loop be vectorized.  This restriction will be \n+     relaxed.  In the meantime, we can force the alignment of on of the\n+     data-references in the loop using peeling.  We currently use a heuristic \n+     that peels the first misaligned store, but we plan to develop a \n+     better cost model to guide the decision on which data-access to peel for.\n+   */\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n       if (!aligned_access_p (dr))\n \t{\n-\t  if (vect_debug_stats (LOOP_VINFO_LOOP (loop_vinfo))\n-\t      || vect_debug_details (LOOP_VINFO_LOOP (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: unaligned store.\");\n-\t  return false;\n+\t  /* Decide here whether we need peeling for alignment.  */\n+\t  decide_peeling_count++;\n+\t  if (decide_peeling_count > MAX_NUMBER_OF_UNALIGNED_DATA_REFS)\n+\t    {\n+\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t\tfprintf (dump_file, \n+\t\t\t \"not vectorized: multiple misaligned stores.\");\n+\t      return false;\n+\t    }\n+\t  else\n+\t    {\n+\t      LOOP_UNALIGNED_DR (loop_vinfo, decide_peeling_count - 1) = dr;\n+\t      LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo) = true;\n+\t    }\n \t}\n     }\n \n@@ -3125,12 +4496,12 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       if (evolution_part_in_loop_num (access_fn, \n \t\t\t\t      loop_containing_stmt (DR_STMT (dr))->num))\n \t{\n-\t  /* Evolution part is not NULL in this loop (it is neither constant nor \n-\t     invariant). */\n+\t  /* Evolution part is not NULL in this loop (it is neither constant \n+\t     nor invariant). */\n \t  if (vect_debug_details (NULL))\n \t    {\n \t      fprintf (dump_file, \n-\t\t       \"not vectorized: complicated multidimensional array access.\");\n+\t\t       \"not vectorized: complicated multidim. array access.\");\n \t      print_generic_expr (dump_file, access_fn, TDF_SLIM);\n \t    }\n \t  return false;\n@@ -3144,7 +4515,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n     {\n       if (vect_debug_details (NULL))\n \t{\n-\t  fprintf (dump_file, \"not vectorized: too complicated access function.\");\n+\t  fprintf (dump_file, \"not vectorized: complicated access function.\");\n \t  print_generic_expr (dump_file, access_fn, TDF_SLIM);\n \t}\n       return false;\n@@ -3521,7 +4892,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  /* Analyze MEMREF. If it is of a supported form, build data_reference\n \t     struct for it (DR) and find the relevant symbol for aliasing \n \t     purposes.  */\n-\t  symbl = vect_get_symbl_and_dr (memref, stmt, is_read, loop_vinfo, &dr);\n+\t  symbl = vect_get_symbl_and_dr (memref, stmt, is_read, loop_vinfo, \n+\t\t\t\t\t &dr);\n \t  if (!symbl)\n \t    {\n \t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n@@ -3563,7 +4935,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      switch (TREE_CODE (address_base))\n \t\t{\n \t\tcase ARRAY_REF:\n-\t\t  dr = analyze_array (stmt, TREE_OPERAND (symbl, 0), DR_IS_READ(dr));\n+\t\t  dr = analyze_array (stmt, TREE_OPERAND (symbl, 0), \n+\t\t\t\t      DR_IS_READ(dr));\n \t\t  STMT_VINFO_MEMTAG (stmt_info) = \n \t\t     vect_get_base_and_bit_offset (dr, DR_BASE_NAME (dr), NULL_TREE,\n \t\t\t\t\t\t   loop_vinfo, &offset, \n@@ -3577,7 +4950,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\tdefault:\n \t\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n \t\t    {\n-\t\t      fprintf (dump_file, \"not vectorized: unhandled address expression: \");\n+\t\t      fprintf (dump_file, \n+\t\t\t       \"not vectorized: unhandled address expr: \");\n \t\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n \t\t    }\n \t\t  return false;\n@@ -3851,12 +5225,109 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vect_analyze_loop_with_symbolic_num_of_iters.\n+\n+   In case the number of iterations that LOOP iterates in unknown at compile \n+   time, an epilog loop will be generated, and the loop induction variables \n+   (IVs) will be \"advanced\" to the value they are supposed to take just before \n+   the epilog loop. Here we check that the access function of the loop IVs\n+   and the expression that represents the loop bound are simple enough.\n+   These restrictions will be relaxed in the future.  */\n+\n+static bool \n+vect_analyze_loop_with_symbolic_num_of_iters (tree niters, \n+\t\t\t\t\t      struct loop *loop)\n+{\n+  basic_block bb = loop->header;\n+  tree phi;\n+\n+  if (vect_debug_details (NULL))\n+    fprintf (dump_file, \n+\t     \"\\n<<vect_analyze_loop_with_symbolic_num_of_iters>>\\n\");\n+  \n+  if (chrec_contains_undetermined (niters))\n+    {\n+      if (vect_debug_details (NULL))\n+        fprintf (dump_file, \"Infinite number of iterations.\");\n+      return false;\n+    }\n+\n+  if (!niters)\n+    {\n+      if (vect_debug_details (NULL))\n+        fprintf (dump_file, \"niters is NULL pointer.\");\n+      return false;\n+    }\n+\n+  if (vect_debug_details (NULL))\n+    {\n+      fprintf (dump_file, \"Symbolic number of iterations is \");\n+      print_generic_expr (dump_file, niters, TDF_DETAILS);\n+    }\n+   \n+  /* Analyze phi functions of the loop header.  */\n+\n+  for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+    {\n+      tree access_fn = NULL;\n+      tree evolution_part;\n+\n+      if (vect_debug_details (NULL))\n+\t{\n+          fprintf (dump_file, \"Analyze phi: \");\n+          print_generic_expr (dump_file, phi, TDF_SLIM);\n+\t}\n+\n+      /* Skip virtual phi's. The data dependences that are associated with\n+         virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n+\n+      if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n+\t{\n+\t  if (vect_debug_details (NULL))\n+\t    fprintf (dump_file, \"virtual phi. skip.\");\n+\t  continue;\n+\t}\n+\n+      /* Analyze the evolution function.  */\n+\n+      access_fn = instantiate_parameters\n+\t(loop, analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n+\n+      if (!access_fn)\n+\t{\n+\t  if (vect_debug_details (NULL))\n+\t    fprintf (dump_file, \"No Access function.\");\n+\t  return false;\n+\t}\n+\n+      if (vect_debug_details (NULL))\n+        {\n+\t  fprintf (dump_file, \"Access function of PHI: \");\n+\t  print_generic_expr (dump_file, access_fn, TDF_SLIM);\n+        }\n+\n+      evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n+      \n+      if (evolution_part == NULL_TREE)\n+\treturn false;\n+  \n+      /* FORNOW: We do not transform initial conditions of IVs \n+\t which evolution functions are a polynomial of degree >= 2.  */\n+\n+      if (tree_is_chrec (evolution_part))\n+\treturn false;  \n+    }\n+\n+  return  true;\n+}\n+\n+\n /* Function vect_get_loop_niters.\n \n    Determine how many iterations the loop is executed.  */\n \n static tree\n-vect_get_loop_niters (struct loop *loop, HOST_WIDE_INT *number_of_iterations)\n+vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n {\n   tree niters;\n \n@@ -3866,14 +5337,15 @@ vect_get_loop_niters (struct loop *loop, HOST_WIDE_INT *number_of_iterations)\n   niters = number_of_iterations_in_loop (loop);\n \n   if (niters != NULL_TREE\n-      && niters != chrec_dont_know\n-      && host_integerp (niters,0))\n+      && niters != chrec_dont_know)\n     {\n-      *number_of_iterations = TREE_INT_CST_LOW (niters);\n+      *number_of_iterations = niters;\n \n       if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"==> get_loop_niters:\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t\t *number_of_iterations);\n+\t{\n+\t  fprintf (dump_file, \"==> get_loop_niters:\" );\n+\t  print_generic_expr (dump_file, *number_of_iterations, TDF_SLIM);\n+\t}\n     }\n \n   return get_loop_exit_condition (loop);\n@@ -3895,7 +5367,7 @@ vect_analyze_loop_form (struct loop *loop)\n {\n   loop_vec_info loop_vinfo;\n   tree loop_cond;\n-  HOST_WIDE_INT number_of_iterations = -1;\n+  tree number_of_iterations = NULL;\n \n   if (vect_debug_details (loop))\n     fprintf (dump_file, \"\\n<<vect_analyze_loop_form>>\\n\");\n@@ -3943,24 +5415,52 @@ vect_analyze_loop_form (struct loop *loop)\n \tfprintf (dump_file, \"not vectorized: complicated exit condition.\");\n       return NULL;\n     }\n-\n-  if (number_of_iterations < 0)\n+  \n+  if (!number_of_iterations) \n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\n-        fprintf (dump_file, \"not vectorized: unknown loop bound.\");\n+\tfprintf (dump_file, \n+\t\t \"not vectorized: number of iterations cannot be computed.\");\n       return NULL;\n     }\n \n-  if (number_of_iterations == 0) /* CHECKME: can this happen? */\n+  loop_vinfo = new_loop_vec_info (loop);\n+  LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\tfprintf (dump_file, \"loop bound unknown.\");\n+\n+      /* Unknown loop bound.  */\n+      if (!vect_analyze_loop_with_symbolic_num_of_iters \n+\t\t\t\t\t(number_of_iterations, loop))\n+\t{\n+          if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t    fprintf (dump_file, \n+\t\t     \"not vectorized: can't determine loop bound.\");\n+\t  return NULL;\n+\t}\n+      else\n+\t{\n+\t  /* We need only one loop entry for unknown loop bound support.  */\n+\t  if (loop->num_entries != 1 || !loop->pre_header)\n+\t    {\t      \n+\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+\t\tfprintf (dump_file, \n+\t\t\t \"not vectorized: more than one loop entry.\");\n+\t      return NULL;\n+\t    }\n+\t}\n+    }\n+  else\n+  if (LOOP_VINFO_INT_NITERS (loop_vinfo) == 0)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\n \tfprintf (dump_file, \"not vectorized: number of iterations = 0.\");\n       return NULL;\n     }\n \n-  loop_vinfo = new_loop_vec_info (loop);\n   LOOP_VINFO_EXIT_COND (loop_vinfo) = loop_cond;\n-  LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n \n   return loop_vinfo;\n }\n@@ -4170,5 +5670,6 @@ vectorize_loops (struct loops *loops)\n          Information in virtual phi nodes is sufficient for it.  */\n       rewrite_into_loop_closed_ssa (); \n     }\n+  rewrite_into_loop_closed_ssa (); \n   bitmap_clear (vars_to_rename);\n }"}, {"sha": "8ec9576544a5298be37c0e006636095d24d48cfd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a023975e421f23fc2799a2c7fcc6e19ed68227f7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a023975e421f23fc2799a2c7fcc6e19ed68227f7", "patch": "@@ -121,6 +121,7 @@ vinfo_for_stmt (tree stmt)\n \n /* The misalignment of the memory access in bytes.  */\n #define DR_MISALIGNMENT(DR)   (DR)->aux\n+#define MAX_NUMBER_OF_UNALIGNED_DATA_REFS 1\n \n static inline bool\n aligned_access_p (struct data_reference *data_ref_info)\n@@ -152,15 +153,22 @@ typedef struct _loop_vec_info {\n   /* The loop exit_condition.  */\n   tree exit_cond;\n \n-  /* Number of iterations. -1 if unknown.  */\n-  HOST_WIDE_INT num_iters;\n+  /* Number of iterations.  */\n+  tree num_iters;\n \n   /* Is the loop vectorizable? */\n   bool vectorizable;\n \n   /* Unrolling factor  */\n   int vectorization_factor;\n \n+  /* Unknown DRs according to which loop was peeled.  */\n+  struct data_reference *unaligned_drs [MAX_NUMBER_OF_UNALIGNED_DATA_REFS];\n+\n+  /* If true, loop is peeled.\n+   unaligned_drs show in this case DRs used for peeling.  */\n+  bool do_peeling_for_alignment;\n+\n   /* All data references in the loop that are being written to.  */\n   varray_type data_ref_writes;\n \n@@ -177,8 +185,14 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_VECT_FACTOR(L)    (L)->vectorization_factor\n #define LOOP_VINFO_DATAREF_WRITES(L) (L)->data_ref_writes\n #define LOOP_VINFO_DATAREF_READS(L)  (L)->data_ref_reads\n-\n-#define LOOP_VINFO_NITERS_KNOWN_P(L) ((L)->num_iters > 0)\n+#define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))       \n+#define LOOP_DO_PEELING_FOR_ALIGNMENT(L) (L)->do_peeling_for_alignment\n+#define LOOP_UNALIGNED_DR(L, I)      (L)->unaligned_drs[(I)] \n+  \n+\n+#define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\\n+(host_integerp ((L)->num_iters,0)                        \\\n+&& TREE_INT_CST_LOW ((L)->num_iters) > 0)      \n \n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */"}]}