{"sha": "96d8c147aacf4b423e072c5da510ac12b0d4b507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZkOGMxNDdhYWNmNGI0MjNlMDcyYzVkYTUxMGFjMTJiMGQ0YjUwNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-01-16T23:38:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-01-16T23:38:48Z"}, "message": "locale_conv.h (wstring_convert, [...]): New.\n\n\t* include/bits/locale_conv.h (wstring_convert, wbuffer_convert): New.\n\t* include/std/locale: Include new header.\n\t* include/Makefile.am: Add it.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/22_locale/conversions/buffer/requirements/typedefs.cc: New.\n\t* testsuite/22_locale/conversions/string/1.cc: New.\n\t* testsuite/22_locale/conversions/string/2.cc: New.\n\t* testsuite/22_locale/conversions/string/requirements/typedefs.cc: New.\n\t* testsuite/22_locale/conversions/string/requirements/typedefs-2.cc:\n\tNew.\n\nFrom-SVN: r219780", "tree": {"sha": "9fa678ce08c8d04a8f9eec47fe99c7d7753d6f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa678ce08c8d04a8f9eec47fe99c7d7753d6f94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96d8c147aacf4b423e072c5da510ac12b0d4b507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d8c147aacf4b423e072c5da510ac12b0d4b507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d8c147aacf4b423e072c5da510ac12b0d4b507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d8c147aacf4b423e072c5da510ac12b0d4b507/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28af1fb39dfbf903ccafeafda927d280fd8768d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28af1fb39dfbf903ccafeafda927d280fd8768d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28af1fb39dfbf903ccafeafda927d280fd8768d8"}], "stats": {"total": 727, "additions": 727, "deletions": 0}, "files": [{"sha": "cf4033c0891bc5687e69aa288aa339713c630ac0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -1,3 +1,16 @@\n+2015-01-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/locale_conv.h (wstring_convert, wbuffer_convert): New.\n+\t* include/std/locale: Include new header.\n+\t* include/Makefile.am: Add it.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/22_locale/conversions/buffer/requirements/typedefs.cc: New.\n+\t* testsuite/22_locale/conversions/string/1.cc: New.\n+\t* testsuite/22_locale/conversions/string/2.cc: New.\n+\t* testsuite/22_locale/conversions/string/requirements/typedefs.cc: New.\n+\t* testsuite/22_locale/conversions/string/requirements/typedefs-2.cc:\n+\tNew.\n+\n 2015-01-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* config/abi/pre/gnu.ver: Export new symbols."}, {"sha": "267713224953a55a224d7d74a724f5affa2f53e5", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -113,6 +113,7 @@ bits_headers = \\\n \t${bits_srcdir}/list.tcc \\\n \t${bits_srcdir}/locale_classes.h \\\n \t${bits_srcdir}/locale_classes.tcc \\\n+\t${bits_srcdir}/locale_conv.h \\\n \t${bits_srcdir}/locale_facets.h \\\n \t${bits_srcdir}/locale_facets.tcc \\\n \t${bits_srcdir}/locale_facets_nonio.h \\"}, {"sha": "9c423cb4341861be95f8a45c8e094655b004eb4a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -381,6 +381,7 @@ bits_headers = \\\n \t${bits_srcdir}/list.tcc \\\n \t${bits_srcdir}/locale_classes.h \\\n \t${bits_srcdir}/locale_classes.tcc \\\n+\t${bits_srcdir}/locale_conv.h \\\n \t${bits_srcdir}/locale_facets.h \\\n \t${bits_srcdir}/locale_facets.tcc \\\n \t${bits_srcdir}/locale_facets_nonio.h \\"}, {"sha": "c8a44f42421b29ae7a6f1517ff5d97bb5905cd82", "filename": "libstdc++-v3/include/bits/locale_conv.h", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -0,0 +1,464 @@\n+// wstring_convert implementation -*- C++ -*-\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/locale_conv.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{locale}\n+ */\n+\n+#ifndef _LOCALE_CONV_H\n+#define _LOCALE_CONV_H 1\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <streambuf>\n+#include \"stringfwd.h\"\n+#include \"allocator.h\"\n+#include \"codecvt.h\"\n+#include \"unique_ptr.h\"\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+\n+  /**\n+   * @addtogroup locales\n+   * @{\n+   */\n+\n+  /// String conversions\n+  template<typename _Codecvt, typename _Elem = wchar_t,\n+\t   typename _Wide_alloc = allocator<_Elem>,\n+\t   typename _Byte_alloc = allocator<char>>\n+    class wstring_convert\n+    {\n+    public:\n+      typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n+      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n+      typedef typename _Codecvt::state_type \t\t\t   state_type;\n+      typedef typename wide_string::traits_type::int_type\t   int_type;\n+\n+      /** Default constructor.\n+       *\n+       * @param  __pcvt The facet to use for conversions.\n+       *\n+       * Takes ownership of @p __pcvt and will delete it in the destructor.\n+       */\n+      explicit\n+      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)\n+      {\n+\tif (!_M_cvt)\n+\t  __throw_logic_error(\"wstring_convert\");\n+      }\n+\n+      /** Construct with an initial converstion state.\n+       *\n+       * @param  __pcvt The facet to use for conversions.\n+       * @param  __state Initial conversion state.\n+       *\n+       * Takes ownership of @p __pcvt and will delete it in the destructor.\n+       * The object's conversion state will persist between conversions.\n+       */\n+      wstring_convert(_Codecvt* __pcvt, state_type __state)\n+      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)\n+      {\n+\tif (!_M_cvt)\n+\t  __throw_logic_error(\"wstring_convert\");\n+      }\n+\n+      /** Construct with error strings.\n+       *\n+       * @param  __byte_err A string to return on failed conversions.\n+       * @param  __wide_err A wide string to return on failed conversions.\n+       */\n+      explicit\n+      wstring_convert(const byte_string& __byte_err,\n+\t\t      const wide_string& __wide_err = wide_string())\n+      : _M_cvt(new _Codecvt),\n+\t_M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),\n+\t_M_with_strings(true)\n+      {\n+\tif (!_M_cvt)\n+\t  __throw_logic_error(\"wstring_convert\");\n+      }\n+\n+      ~wstring_convert() = default;\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2176. Special members for wstring_convert and wbuffer_convert\n+      wstring_convert(const wstring_convert&) = delete;\n+      wstring_convert& operator=(const wstring_convert&) = delete;\n+\n+      /// @{ Convert from bytes.\n+      wide_string\n+      from_bytes(char __byte)\n+      {\n+\tchar __bytes[2] = { __byte };\n+\treturn from_bytes(__bytes, __bytes+1);\n+      }\n+\n+      wide_string\n+      from_bytes(const char* __ptr)\n+      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }\n+\n+      wide_string\n+      from_bytes(const byte_string& __str)\n+      {\n+\tauto __ptr = __str.data();\n+\treturn from_bytes(__ptr, __ptr + __str.size());\n+      }\n+\n+      wide_string\n+      from_bytes(const char* __first, const char* __last)\n+      {\n+\tauto __errstr = _M_with_strings ? &_M_wide_err_string : nullptr;\n+\t_ConvFn<char, _Elem> __fn = &_Codecvt::in;\n+\treturn _M_conv(__first, __last, __errstr, __fn);\n+      }\n+      /// @}\n+\n+      /// @{ Convert to bytes.\n+      byte_string\n+      to_bytes(_Elem __wchar)\n+      {\n+\t_Elem __wchars[2] = { __wchar };\n+\treturn to_bytes(__wchars, __wchars+1);\n+      }\n+\n+      byte_string\n+      to_bytes(const _Elem* __ptr)\n+      {\n+\treturn to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));\n+      }\n+\n+      byte_string\n+      to_bytes(const wide_string& __wstr)\n+      {\n+\tauto __ptr = __wstr.data();\n+\treturn to_bytes(__ptr, __ptr + __wstr.size());\n+      }\n+\n+      byte_string\n+      to_bytes(const _Elem* __first, const _Elem* __last)\n+      {\n+\tauto __errstr = _M_with_strings ? &_M_byte_err_string : nullptr;\n+\t_ConvFn<_Elem, char> __fn = &_Codecvt::out;\n+\treturn _M_conv(__first, __last, __errstr, __fn);\n+      }\n+      /// @}\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2174. wstring_convert::converted() should be noexcept\n+      /// The number of elements successfully converted in the last conversion.\n+      size_t converted() const noexcept { return _M_count; }\n+\n+      /// The final conversion state of the last conversion.\n+      state_type state() const { return _M_state; }\n+\n+    private:\n+      template<typename _InC, typename _OutC>\n+\tusing _ConvFn\n+\t  = codecvt_base::result\n+\t    (_Codecvt::*)(state_type&, const _InC*, const _InC*, const _InC*&,\n+\t\t\t  _OutC*, _OutC*, _OutC*&) const;\n+\n+      template<typename _InChar, typename _OutStr, typename _MemFn>\n+\t_OutStr\n+\t_M_conv(const _InChar* __first, const _InChar* __last,\n+\t\tconst _OutStr* __err, _MemFn __memfn)\n+\t{\n+\t  if (!_M_with_cvtstate)\n+\t    _M_state = state_type();\n+\n+\t  auto __outstr = __err ? _OutStr(__err->get_allocator()) : _OutStr();\n+\t  size_t __outchars = 0;\n+\t  auto __next = __first;\n+\n+\t  codecvt_base::result __result;\n+\t  do\n+\t    {\n+\t      __outstr.resize(__outstr.size() + (__last - __next));\n+\t      auto __outnext = &__outstr.front() + __outchars;\n+\t      auto const __outlast = &__outstr.back() + 1;\n+\t      __result = ((*_M_cvt).*__memfn)(_M_state, __next, __last, __next,\n+\t\t\t\t\t    __outnext, __outlast, __outnext);\n+\t      __outchars = __outnext - &__outstr.front();\n+\t    }\n+\t  while (__result == codecvt_base::partial && __next != __last);\n+\n+\t  __outstr.resize(__outchars);\n+\t  _M_count = __next - __first;\n+\n+\t  if (__result != codecvt_base::error)\n+\t    return __outstr;\n+\t  else if (__err)\n+\t    return *__err;\n+\t  else\n+\t    __throw_range_error(\"wstring_convert\");\n+\t}\n+\n+      unique_ptr<_Codecvt>\t_M_cvt;\n+      byte_string\t\t_M_byte_err_string;\n+      wide_string\t\t_M_wide_err_string;\n+      state_type\t\t_M_state = state_type();\n+      size_t\t\t\t_M_count = 0;\n+      bool\t\t\t_M_with_cvtstate = false;\n+      bool\t\t\t_M_with_strings = false;\n+    };\n+\n+  /// Buffer conversions\n+  template<typename _Codecvt, typename _Elem = wchar_t,\n+\t   typename _Tr = char_traits<_Elem>>\n+    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>\n+    {\n+      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;\n+\n+    public:\n+      typedef typename _Codecvt::state_type state_type;\n+\n+      /** Default constructor.\n+       *\n+       * @param  __bytebuf The underlying byte stream buffer.\n+       * @param  __pcvt    The facet to use for conversions.\n+       * @param  __state   Initial conversion state.\n+       *\n+       * Takes ownership of @p __pcvt and will delete it in the destructor.\n+       */\n+      explicit\n+      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,\n+\t\t      state_type __state = state_type())\n+      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)\n+      {\n+\tif (!_M_cvt)\n+\t  __throw_logic_error(\"wstring_convert\");\n+\n+\t_M_always_noconv = _M_cvt->always_noconv();\n+\n+\tif (_M_buf)\n+\t  {\n+\t    this->setp(_M_put_area, _M_put_area + _S_buffer_length);\n+\t    this->setg(_M_get_area + _S_putback_length,\n+\t\t       _M_get_area + _S_putback_length,\n+\t\t       _M_get_area + _S_putback_length);\n+\t  }\n+      }\n+\n+      ~wbuffer_convert() = default;\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2176. Special members for wstring_convert and wbuffer_convert\n+      wbuffer_convert(const wbuffer_convert&) = delete;\n+      wbuffer_convert& operator=(const wbuffer_convert&) = delete;\n+\n+      streambuf* rdbuf() const noexcept { return _M_buf; }\n+\n+      streambuf*\n+      rdbuf(streambuf *__bytebuf) noexcept\n+      {\n+\tauto __prev = _M_buf;\n+\t_M_buf = __bytebuf;\n+\treturn __prev;\n+      }\n+\n+      /// The conversion state following the last conversion.\n+      state_type state() const noexcept { return _M_state; }\n+\n+    protected:\n+      int\n+      sync()\n+      { return _M_buf && _M_conv_put() && _M_buf->pubsync() ? 0 : -1; }\n+\n+      typename _Wide_streambuf::int_type\n+      overflow(typename _Wide_streambuf::int_type __out)\n+      {\n+\tif (!_M_buf || !_M_conv_put())\n+\t  return _Tr::eof();\n+\telse if (!_Tr::eq_int_type(__out, _Tr::eof()))\n+\t  return this->sputc(__out);\n+\treturn _Tr::not_eof(__out);\n+      }\n+\n+      typename _Wide_streambuf::int_type\n+      underflow()\n+      {\n+\tif (!_M_buf)\n+\t  return _Tr::eof();\n+\n+\tif (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))\n+\t  return _Tr::to_int_type(*this->gptr());\n+\telse\n+\t  return _Tr::eof();\n+      }\n+\n+      streamsize\n+      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)\n+      {\n+\tif (!_M_buf || __n == 0)\n+\t  return 0;\n+\tstreamsize __done = 0;\n+\tdo\n+\t{\n+\t  auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),\n+\t\t\t\t\t   __n - __done);\n+\t  _Tr::copy(this->pptr(), __s + __done, __nn);\n+\t  this->pbump(__nn);\n+\t  __done += __nn;\n+\t} while (__done < __n && _M_conv_put());\n+\treturn __done;\n+      }\n+\n+    private:\n+      // fill the get area from converted contents of the byte stream buffer\n+      bool\n+      _M_conv_get()\n+      {\n+\tconst streamsize __pb1 = this->gptr() - this->eback();\n+\tconst streamsize __pb2 = _S_putback_length;\n+\tconst streamsize __npb = std::min(__pb1, __pb2);\n+\n+\t_Tr::move(_M_get_area + _S_putback_length - __npb,\n+\t\t  this->gptr() - __npb, __npb);\n+\n+\tstreamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;\n+\t__nbytes = std::min(__nbytes, _M_buf->in_avail());\n+\tif (__nbytes < 1)\n+\t  __nbytes == 1;\n+\t__nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);\n+\tif (__nbytes < 1)\n+\t  return false;\n+\t__nbytes += _M_unconv;\n+\n+\t// convert _M_get_buf into _M_get_area\n+\n+\t_Elem* __outbuf = _M_get_area + _S_putback_length;\n+\t_Elem* __outnext = __outbuf;\n+\tconst char* __bnext = _M_get_buf;\n+\n+\tcodecvt_base::result __result;\n+\tif (_M_always_noconv)\n+\t  __result = codecvt_base::noconv;\n+\telse\n+\t  {\n+\t    _Elem* __outend = _M_get_area + _S_buffer_length;\n+\n+\t    __result = _M_cvt->in(_M_state,\n+\t\t\t\t  __bnext, __bnext + __nbytes, __bnext,\n+\t\t\t\t  __outbuf, __outend, __outnext);\n+\t  }\n+\n+\tif (__result == codecvt_base::noconv)\n+\t  {\n+\t    // cast is safe because noconv means _Elem is same type as char\n+\t    auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);\n+\t    _Tr::copy(__outbuf, __get_buf, __nbytes);\n+\t    _M_unconv = 0;\n+\t    return true;\n+\t  }\n+\n+\tif ((_M_unconv = _M_get_buf + __nbytes - __bnext))\n+\t  char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);\n+\n+\tthis->setg(__outbuf, __outbuf, __outnext);\n+\n+\treturn __result != codecvt_base::error;\n+      }\n+\n+      // unused\n+      bool\n+      _M_put(...)\n+      { return false; }\n+\n+      bool\n+      _M_put(const char* __p, streamsize __n)\n+      {\n+\tif (_M_buf->sputn(__p, __n) < __n)\n+\t  return false;\n+      }\n+\n+      // convert the put area and write to the byte stream buffer\n+      bool\n+      _M_conv_put()\n+      {\n+\t_Elem* const __first = this->pbase();\n+\tconst _Elem* const __last = this->pptr();\n+\tconst streamsize __pending = __last - __first;\n+\n+\tif (_M_always_noconv)\n+\t  return _M_put(__first, __pending);\n+\n+\tchar __outbuf[2 * _S_buffer_length];\n+\n+\tconst _Elem* __next = __first;\n+\tconst _Elem* __start;\n+\tdo\n+\t  {\n+\t    __start = __next;\n+\t    char* __outnext = __outbuf;\n+\t    char* const __outlast = __outbuf + sizeof(__outbuf);\n+\t    auto __result = _M_cvt->out(_M_state, __next, __last, __next,\n+\t\t\t\t\t__outnext, __outlast, __outnext);\n+\t    if (__result == codecvt_base::error)\n+\t      return false;\n+\t    else if (__result == codecvt_base::noconv)\n+\t      return _M_put(__next, __pending);\n+\n+\t    if (!_M_put(__outbuf, __outnext - __outbuf))\n+\t\treturn false;\n+\t  }\n+\twhile (__next != __last && __next != __start);\n+\n+\tif (__next != __last)\n+\t  _Tr::move(__first, __next, __last - __next);\n+\n+\tthis->pbump(__first - __next);\n+\treturn __next != __first;\n+      }\n+\n+      streambuf*\t\t_M_buf;\n+      unique_ptr<_Codecvt>\t_M_cvt;\n+      state_type\t\t_M_state;\n+\n+      static const streamsize\t_S_buffer_length = 32;\n+      static const streamsize\t_S_putback_length = 3;\n+      _Elem                     _M_put_area[_S_buffer_length];\n+      _Elem                     _M_get_area[_S_buffer_length];\n+      streamsize\t\t_M_unconv = 0;\n+      char\t\t\t_M_get_buf[_S_buffer_length-_S_putback_length];\n+      bool\t\t\t_M_always_noconv;\n+    };\n+\n+  /// @} group locales\n+\n+#endif  // _GLIBCXX_USE_WCHAR_T\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif // __cplusplus\n+\n+#endif /* _LOCALE_CONV_H */"}, {"sha": "102004fc3de346b179ca9de1d98f198e33627b5c", "filename": "libstdc++-v3/include/std/locale", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -39,5 +39,8 @@\n #include <bits/locale_classes.h>\n #include <bits/locale_facets.h>\n #include <bits/locale_facets_nonio.h>\n+#if __cplusplus >= 201103L\n+#  include <bits/locale_conv.h>\n+#endif\n \n #endif /* _GLIBCXX_LOCALE */"}, {"sha": "c59c6d62f3413e373be8cf9a4b61d1d499427430", "filename": "libstdc++-v3/testsuite/22_locale/conversions/buffer/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fbuffer%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fbuffer%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fbuffer%2Frequirements%2Ftypedefs.cc?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 22.3.3.2.3  Buffer conversions\n+\n+#include <locale>\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  struct cvt_type : std::codecvt<wchar_t, char, mbstate_t> { };\n+  typedef std::char_traits<wchar_t> traits_type;\n+  typedef std::wbuffer_convert<cvt_type, wchar_t, traits_type> test_type;\n+  typedef test_type::state_type state_type;\n+\n+  static_assert( std::is_same<cvt_type::state_type, state_type>::value,\n+\t\t \"state type\" );\n+}"}, {"sha": "c2ab6e743e41c5a4d4027bbcee0567cb267ee708", "filename": "libstdc++-v3/testsuite/22_locale/conversions/string/1.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2F1.cc?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 22.3.3.2.2  String conversions\n+\n+#include <locale>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+template<typename Elem>\n+struct cvt : std::codecvt<Elem, char, std::mbstate_t> { };\n+\n+template<typename Elem>\n+using str_conv = std::wstring_convert<cvt<Elem>, Elem>;\n+\n+using std::string;\n+using std::wstring;\n+\n+void test01()\n+{\n+  typedef str_conv<char> sc;  // noconv\n+  sc c;\n+  string input = \"King for a day...\";\n+  string output = c.from_bytes(input);\n+  VERIFY( input == output );\n+  VERIFY( c.converted() == output.length() );\n+  string roundtrip = c.to_bytes(output);\n+  VERIFY( input == roundtrip );\n+  VERIFY( c.converted() == roundtrip.length() );\n+}\n+\n+void test02()\n+{\n+  typedef str_conv<wchar_t> wsc;\n+  wsc c;\n+  string input = \"Fool for a lifetime\";\n+  wstring output = c.from_bytes(input);\n+  VERIFY( c.converted() == output.length() );\n+  VERIFY( L\"Fool for a lifetime\" == output );\n+  string roundtrip = c.to_bytes(output);\n+  VERIFY( input == roundtrip );\n+  VERIFY( c.converted() == roundtrip.length() );\n+\n+  VERIFY( c.from_bytes(input[0]) == output.substr(0, 1) );\n+  VERIFY( c.from_bytes(input.c_str()) == output );\n+  VERIFY( c.from_bytes(input.data(), input.data()+input.size()) == output );\n+\n+  VERIFY( c.to_bytes(output[0]) == input.substr(0, 1) );\n+  VERIFY( c.to_bytes(output.c_str()) == input );\n+  VERIFY( c.to_bytes(output.data(), output.data()+output.size()) == input );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "94eb75f9b00b303ae741476ddd879f3cd0df13a6", "filename": "libstdc++-v3/testsuite/22_locale/conversions/string/2.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2F2.cc?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 22.3.3.2.2  String conversions\n+\n+#include <locale>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+template<typename Elem>\n+struct cvt : std::codecvt<Elem, char, std::mbstate_t> { };\n+\n+template<typename Elem>\n+using str_conv = std::wstring_convert<cvt<Elem>, Elem>;\n+\n+using std::string;\n+using std::wstring;\n+\n+// test conversion errors, with and without error strings\n+\n+void test01()\n+{\n+  typedef str_conv<wchar_t> sc;\n+\n+  const sc::byte_string berr = \"invalid wide string\";\n+  const sc::wide_string werr = L\"invalid byte string\";\n+\n+  sc c(berr, werr);\n+  string input = \"Stop\";\n+  input += char(0xff);\n+  input += char(0xff);\n+  wstring woutput = c.from_bytes(input);\n+  VERIFY( werr == woutput );\n+  wstring winput = L\"Stop\";\n+  winput += wchar_t(0xff);\n+  winput += wchar_t(0xff);\n+  string output = c.to_bytes(winput);\n+  VERIFY( berr == output );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "65a14584fba0cb3b88a19fef9b893242cb29cdbf", "filename": "libstdc++-v3/testsuite/22_locale/conversions/string/requirements/typedefs-2.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2Frequirements%2Ftypedefs-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2Frequirements%2Ftypedefs-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2Frequirements%2Ftypedefs-2.cc?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 22.3.3.2.2  String conversions\n+\n+#include <locale>\n+#include <string>\n+#include <type_traits>\n+#include <testsuite_allocator.h>\n+\n+template<typename T>\n+  using alloc = __gnu_test::uneq_allocator<T>;\n+\n+template<typename C>\n+  using Str = std::basic_string<C, std::char_traits<C>, alloc<C>>;\n+\n+struct cvt : std::codecvt<wchar_t, char, std::mbstate_t> { };\n+\n+using wconv = std::wstring_convert<cvt, wchar_t, alloc<wchar_t>, alloc<char>>;\n+\n+static_assert( std::is_same<wconv::byte_string, Str<char>>::value,\n+\t       \"byte string is std::string\" );\n+static_assert( std::is_same<wconv::wide_string, Str<wchar_t>>::value,\n+\t       \"wide string is std::wstring\" );"}, {"sha": "baed16e964d325a7618765a3cf920ebd8f3c65fb", "filename": "libstdc++-v3/testsuite/22_locale/conversions/string/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d8c147aacf4b423e072c5da510ac12b0d4b507/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fconversions%2Fstring%2Frequirements%2Ftypedefs.cc?ref=96d8c147aacf4b423e072c5da510ac12b0d4b507", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 22.3.3.2.2  String conversions\n+\n+#include <locale>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::codecvt<wchar_t, char, mbstate_t> codecvt_type;\n+  typedef std::wstring_convert<codecvt_type> test_type;\n+  typedef test_type::byte_string byte_string;\n+  typedef test_type::wide_string wide_string;\n+  typedef test_type::state_type state_type;\n+  typedef test_type::int_type int_type;\n+}"}]}