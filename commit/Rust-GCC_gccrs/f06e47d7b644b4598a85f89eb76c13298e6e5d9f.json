{"sha": "f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA2ZTQ3ZDdiNjQ0YjQ1OThhODVmODllYjc2YzEzMjk4ZTZlNWQ5Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-11-29T14:32:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-11-29T14:32:00Z"}, "message": "re PR target/88152 (optimize SSE & AVX char compares with subsequent movmskb)\n\n\tPR target/88152\n\t* tree.h (build_uniform_cst, uniform_integer_cst_p): Declare.\n\t* tree.c (build_uniform_cst, uniform_integer_cst_p): New functions.\n\t* match.pd (define_predicates): Add uniform_integer_cst_p.\n\t(cmp @0 INTEGER_CST@1, cmp (convert?@2 @0) INTEGER_CST@1): Adjust\n\tso that it works also for vector comparisons with uniform constants\n\twith INTEGER_CST element.\n\n\t* g++.dg/tree-ssa/pr88152-1.C: New test.\n\t* g++.dg/tree-ssa/pr88152-2.C: New test.\n\nFrom-SVN: r266620", "tree": {"sha": "154376b661fe1d100a310785cbfa7be99e6c267e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/154376b661fe1d100a310785cbfa7be99e6c267e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b076fecbc240380b25bb25c65aae85c4b5ea9ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b076fecbc240380b25bb25c65aae85c4b5ea9ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b076fecbc240380b25bb25c65aae85c4b5ea9ce5"}], "stats": {"total": 265, "additions": 242, "deletions": 23}, "files": [{"sha": "fcf4cf7a19c22682a06c1e762159ba5316d878fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -1,5 +1,13 @@\n 2018-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/88152\n+\t* tree.h (build_uniform_cst, uniform_integer_cst_p): Declare.\n+\t* tree.c (build_uniform_cst, uniform_integer_cst_p): New functions.\n+\t* match.pd (define_predicates): Add uniform_integer_cst_p.\n+\t(cmp @0 INTEGER_CST@1, cmp (convert?@2 @0) INTEGER_CST@1): Adjust\n+\tso that it works also for vector comparisons with uniform constants\n+\twith INTEGER_CST element.\n+\n \tPR target/88234\n \t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): For\n \tvec_add and vec_sub builtins, perform PLUS_EXPR or MINUS_EXPR"}, {"sha": "6c267510adff3c582949611c5490470a8cf4c99c", "filename": "gcc/match.pd", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n    tree_expr_nonzero_p\n    integer_valued_real_p\n    integer_pow2p\n+   uniform_integer_cst_p\n    HONOR_NANS)\n \n /* Operator lists.  */\n@@ -3107,16 +3108,22 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (for cmp  (le gt)\n      acmp (lt ge)\n  (simplify\n-  (cmp @0 INTEGER_CST@1)\n-  (if (tree_int_cst_sgn (@1) == -1)\n-   (acmp @0 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) + 1); }))))\n+  (cmp @0 uniform_integer_cst_p@1)\n+  (with { tree cst = uniform_integer_cst_p (@1); }\n+   (if (tree_int_cst_sgn (cst) == -1)\n+     (acmp @0 { build_uniform_cst (TREE_TYPE (@1),\n+\t\t\t\t   wide_int_to_tree (TREE_TYPE (cst),\n+\t\t\t\t\t\t     wi::to_wide (cst)\n+\t\t\t\t\t\t     + 1)); })))))\n (for cmp  (ge lt)\n      acmp (gt le)\n  (simplify\n-  (cmp @0 INTEGER_CST@1)\n-  (if (tree_int_cst_sgn (@1) == 1)\n-   (acmp @0 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) - 1); }))))\n-\n+  (cmp @0 uniform_integer_cst_p@1)\n+  (with { tree cst = uniform_integer_cst_p (@1); }\n+   (if (tree_int_cst_sgn (cst) == 1)\n+    (acmp @0 { build_uniform_cst (TREE_TYPE (@1),\n+\t\t\t\t  wide_int_to_tree (TREE_TYPE (cst),\n+\t\t\t\t  wi::to_wide (cst) - 1)); })))))\n \n /* We can simplify a logical negation of a comparison to the\n    inverted comparison.  As we cannot compute an expression\n@@ -3934,19 +3941,22 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  /* Comparisons with the highest or lowest possible integer of\n     the specified precision will have known values.  */\n  (simplify\n-  (cmp (convert?@2 @0) INTEGER_CST@1)\n-  (if ((INTEGRAL_TYPE_P (TREE_TYPE (@1)) || POINTER_TYPE_P (TREE_TYPE (@1)))\n+  (cmp (convert?@2 @0) uniform_integer_cst_p@1)\n+  (if ((INTEGRAL_TYPE_P (TREE_TYPE (@1))\n+\t|| POINTER_TYPE_P (TREE_TYPE (@1))\n+\t|| VECTOR_INTEGER_TYPE_P (TREE_TYPE (@1)))\n        && tree_nop_conversion_p (TREE_TYPE (@2), TREE_TYPE (@0)))\n    (with\n     {\n-      tree arg1_type = TREE_TYPE (@1);\n+      tree cst = uniform_integer_cst_p (@1);\n+      tree arg1_type = TREE_TYPE (cst);\n       unsigned int prec = TYPE_PRECISION (arg1_type);\n       wide_int max = wi::max_value (arg1_type);\n       wide_int signed_max = wi::max_value (prec, SIGNED);\n       wide_int min = wi::min_value (arg1_type);\n     }\n     (switch\n-     (if (wi::to_wide (@1) == max)\n+     (if (wi::to_wide (cst) == max)\n       (switch\n        (if (cmp == GT_EXPR)\n \t{ constant_boolean_node (false, type); })\n@@ -3956,7 +3966,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t{ constant_boolean_node (true, type); })\n        (if (cmp == LT_EXPR)\n \t(ne @2 @1))))\n-     (if (wi::to_wide (@1) == min)\n+     (if (wi::to_wide (cst) == min)\n       (switch\n        (if (cmp == LT_EXPR)\n         { constant_boolean_node (false, type); })\n@@ -3966,19 +3976,31 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n         { constant_boolean_node (true, type); })\n        (if (cmp == GT_EXPR)\n         (ne @2 @1))))\n-     (if (wi::to_wide (@1) == max - 1)\n+     (if (wi::to_wide (cst) == max - 1)\n       (switch\n        (if (cmp == GT_EXPR)\n-\t(eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) + 1); }))\n+\t(eq @2 { build_uniform_cst (TREE_TYPE (@1),\n+\t\t\t\t    wide_int_to_tree (TREE_TYPE (cst),\n+\t\t\t\t\t\t      wi::to_wide (cst)\n+\t\t\t\t\t\t      + 1)); }))\n        (if (cmp == LE_EXPR)\n-\t(ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) + 1); }))))\n-     (if (wi::to_wide (@1) == min + 1)\n+\t(ne @2 { build_uniform_cst (TREE_TYPE (@1),\n+\t\t\t\t    wide_int_to_tree (TREE_TYPE (cst),\n+\t\t\t\t\t\t      wi::to_wide (cst)\n+\t\t\t\t\t\t      + 1)); }))))\n+     (if (wi::to_wide (cst) == min + 1)\n       (switch\n        (if (cmp == GE_EXPR)\n-        (ne @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) - 1); }))\n+        (ne @2 { build_uniform_cst (TREE_TYPE (@1),\n+\t\t\t\t    wide_int_to_tree (TREE_TYPE (cst),\n+\t\t\t\t\t\t      wi::to_wide (cst)\n+\t\t\t\t\t\t      - 1)); }))\n        (if (cmp == LT_EXPR)\n-        (eq @2 { wide_int_to_tree (TREE_TYPE (@1), wi::to_wide (@1) - 1); }))))\n-     (if (wi::to_wide (@1) == signed_max\n+        (eq @2 { build_uniform_cst (TREE_TYPE (@1),\n+\t\t\t\t    wide_int_to_tree (TREE_TYPE (cst),\n+\t\t\t\t\t\t      wi::to_wide (cst)\n+\t\t\t\t\t\t      - 1)); }))))\n+     (if (wi::to_wide (cst) == signed_max\n \t  && TYPE_UNSIGNED (arg1_type)\n \t  /* We will flip the signedness of the comparison operator\n \t     associated with the mode of @1, so the sign bit is\n@@ -3990,10 +4012,16 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       /* The following case also applies to X < signed_max+1\n \t and X >= signed_max+1 because previous transformations.  */\n       (if (cmp == LE_EXPR || cmp == GT_EXPR)\n-       (with { tree st = signed_type_for (arg1_type); }\n-        (if (cmp == LE_EXPR)\n-\t (ge (convert:st @0) { build_zero_cst (st); })\n-\t (lt (convert:st @0) { build_zero_cst (st); }))))))))))\n+       (with { tree st = signed_type_for (TREE_TYPE (@1)); }\n+       \t(switch\n+\t (if (cst == @1 && cmp == LE_EXPR)\n+\t  (ge (convert:st @0) { build_zero_cst (st); }))\n+\t (if (cst == @1 && cmp == GT_EXPR)\n+\t  (lt (convert:st @0) { build_zero_cst (st); }))\n+\t (if (cmp == LE_EXPR)\n+\t  (ge (view_convert:st @0) { build_zero_cst (st); }))\n+\t (if (cmp == GT_EXPR)\n+\t  (lt (view_convert:st @0) { build_zero_cst (st); })))))))))))\n \n (for cmp (unordered ordered unlt unle ungt unge uneq ltgt)\n  /* If the second operand is NaN, the result is constant.  */"}, {"sha": "b75b80d9c82d76faf681114b1fd9d4681e52b640", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -1,5 +1,9 @@\n 2018-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/88152\n+\t* g++.dg/tree-ssa/pr88152-1.C: New test.\n+\t* g++.dg/tree-ssa/pr88152-2.C: New test.\n+\n \tPR target/88234\n \t* gcc.dg/ubsan/pr88234.c: New test.\n "}, {"sha": "423ec897c1da7b1ddf60b5278782348538888f18", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr88152-1.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr88152-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr88152-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr88152-1.C?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -0,0 +1,55 @@\n+// PR target/88152\n+// { dg-do compile }\n+// { dg-options \"-O2 -std=c++14 -fdump-tree-forwprop1\" }\n+// { dg-final { scan-tree-dump-times \" (?:<|>=) \\{ 0\\[, ]\" 120 \"forwprop1\" } }\n+\n+template <typename T, int N>\n+using V [[gnu::vector_size (sizeof (T) * N)]] = T;\n+\n+void *foo ();\n+\n+template <typename T, int N, T max, T maxp1>\n+__attribute__((noipa)) void\n+test_uns ()\n+{\n+  V<T, N> *x = (V<T, N> *) foo ();\n+  x[1] = x[0] > max;\n+  x[3] = x[2] >= maxp1;\n+  x[5] = x[4] <= max;\n+  x[7] = x[6] < maxp1;\n+}\n+\n+template <typename T, int N>\n+__attribute__((noipa)) void\n+test ()\n+{\n+  V<T, N> *x = (V<T, N> *) foo ();\n+  x[1] = x[0] >= 0;\n+  x[3] = x[2] > -1;\n+  x[5] = x[4] < 0;\n+  x[7] = x[6] <= -1;\n+}\n+\n+template <int N>\n+__attribute__((noipa)) void\n+tests ()\n+{\n+  test_uns<unsigned char, N, __SCHAR_MAX__, 1U + __SCHAR_MAX__> ();\n+  test<signed char, N> ();\n+  test_uns<unsigned short int, N, __SHRT_MAX__, 1U + __SHRT_MAX__> ();\n+  test<short int, N> ();\n+  test_uns<unsigned int, N, __INT_MAX__, 1U + __INT_MAX__> ();\n+  test<int, N> ();\n+  test_uns<unsigned long int, N, __LONG_MAX__, 1UL + __LONG_MAX__> ();\n+  test<long int, N> ();\n+  test_uns<unsigned long long int, N, __LONG_LONG_MAX__, 1ULL + __LONG_LONG_MAX__> ();\n+  test<long long int, N> ();\n+}\n+\n+void\n+all_tests ()\n+{\n+  tests<1> ();\n+  tests<2> ();\n+  tests<8> ();\n+}"}, {"sha": "69118b4ea360a2096e9191ffe41877b33ca8c97e", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr88152-2.C", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr88152-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr88152-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr88152-2.C?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -0,0 +1,85 @@\n+// PR target/88152\n+// { dg-do compile { target int32 } }\n+// { dg-options \"-O2 -Wno-psabi -fdump-tree-forwprop1\" }\n+// { dg-final { scan-tree-dump-not \" (?:>|>=|<|<=) \\{ 214748364\\[67]\" \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-not \" (?:>|>=|<|<=) \\{ -214748364\\[78]\" \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-times \"(?:return| =) \\{ 0, 0, 0, 0 \\}\" 2 \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-times \"(?:return| =) \\{ -1, -1, -1, -1 \\}\" 2 \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-times \" == \\{ 2147483647, 2147483647, 2147483647, 2147483647 \\}\" 2 \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-times \" != \\{ 2147483647, 2147483647, 2147483647, 2147483647 \\}\" 2 \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-times \" == \\{ -2147483648, -2147483648, -2147483648, -2147483648 \\}\" 2 \"forwprop1\" } }\n+// { dg-final { scan-tree-dump-times \" != \\{ -2147483648, -2147483648, -2147483648, -2147483648 \\}\" 2 \"forwprop1\" } }\n+\n+typedef int V __attribute__((vector_size (16)));\n+\n+V\n+f1 (V a)\n+{\n+  return a > __INT_MAX__;\n+}\n+\n+V\n+f2 (V a)\n+{\n+  return a >= __INT_MAX__;\n+}\n+\n+V\n+f3 (V a)\n+{\n+  return a < __INT_MAX__;\n+}\n+\n+V\n+f4 (V a)\n+{\n+  return a <= __INT_MAX__;\n+}\n+\n+V\n+f5 (V a)\n+{\n+  return a > -__INT_MAX__ - 1;\n+}\n+\n+V\n+f6 (V a)\n+{\n+  return a >= -__INT_MAX__ - 1;\n+}\n+\n+V\n+f7 (V a)\n+{\n+  return a < -__INT_MAX__ - 1;\n+}\n+\n+V\n+f8 (V a)\n+{\n+  return a <= -__INT_MAX__ - 1;\n+}\n+\n+V\n+f9 (V a)\n+{\n+  return a > __INT_MAX__ - 1;\n+}\n+\n+V\n+f10 (V a)\n+{\n+  return a <= __INT_MAX__ - 1;\n+}\n+\n+V\n+f11 (V a)\n+{\n+  return a >= -__INT_MAX__;\n+}\n+\n+V\n+f12 (V a)\n+{\n+  return a < -__INT_MAX__;\n+}"}, {"sha": "170ef1300ed240fb6a4bd51bdaf94991e46f1f55", "filename": "gcc/tree.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -1906,6 +1906,18 @@ build_vector_from_val (tree vectype, tree sc)\n     }\n }\n \n+/* If TYPE is not a vector type, just return SC, otherwise return\n+   build_vector_from_val (TYPE, SC).  */\n+\n+tree\n+build_uniform_cst (tree type, tree sc)\n+{\n+  if (!VECTOR_TYPE_P (type))\n+    return sc;\n+\n+  return build_vector_from_val (type, sc);\n+}\n+\n /* Build a vector series of type TYPE in which element I has the value\n    BASE + I * STEP.  The result is a constant if BASE and STEP are constant\n    and a VEC_SERIES_EXPR otherwise.  */\n@@ -11212,6 +11224,26 @@ uniform_vector_p (const_tree vec)\n   return NULL_TREE;\n }\n \n+/* If the argument is INTEGER_CST, return it.  If the argument is vector\n+   with all elements the same INTEGER_CST, return that INTEGER_CST.  Otherwise\n+   return NULL_TREE.  */\n+\n+tree\n+uniform_integer_cst_p (tree t)\n+{\n+  if (TREE_CODE (t) == INTEGER_CST)\n+    return t;\n+\n+  if (VECTOR_TYPE_P (TREE_TYPE (t)))\n+    {\n+      t = uniform_vector_p (t);\n+      if (t && TREE_CODE (t) == INTEGER_CST)\n+\treturn t;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Build an empty statement at location LOC.  */\n \n tree"}, {"sha": "960526d48a8dbea38dc74bfc171162ccdf238d90", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06e47d7b644b4598a85f89eb76c13298e6e5d9f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f06e47d7b644b4598a85f89eb76c13298e6e5d9f", "patch": "@@ -4182,6 +4182,7 @@ extern tree build_int_cst_type (tree, poly_int64);\n extern tree make_vector (unsigned, unsigned CXX_MEM_STAT_INFO);\n extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);\n extern tree build_vector_from_val (tree, tree);\n+extern tree build_uniform_cst (tree, tree);\n extern tree build_vec_series (tree, tree, tree);\n extern tree build_index_vector (tree, poly_uint64, poly_uint64);\n extern void recompute_constructor_flags (tree);\n@@ -4492,6 +4493,12 @@ extern tree vector_cst_elt (const_tree, unsigned int);\n \n extern tree uniform_vector_p (const_tree);\n \n+/* If the argument is INTEGER_CST, return it.  If the argument is vector\n+   with all elements the same INTEGER_CST, return that INTEGER_CST.  Otherwise\n+   return NULL_TREE.  */\n+\n+extern tree uniform_integer_cst_p (tree);\n+\n /* Given a CONSTRUCTOR CTOR, return the element values as a vector.  */\n \n extern vec<tree, va_gc> *ctor_to_vec (tree);"}]}