{"sha": "c4501e6230543baaf5ad4ff87c0e24498bcb351b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1MDFlNjIzMDU0M2JhYWY1YWQ0ZmY4N2MwZTI0NDk4YmNiMzUxYg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2003-05-12T22:30:31Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2003-05-12T22:30:31Z"}, "message": "configure.in (HAVE_AS_TLS): Add powerpc and powerpc64 tests.\n\n2003-05-12  Janis Johnson  <janis187@us.ibm.com>\n\t    Alan Modra  <amodra@bigpond.net.au>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\t* configure.in (HAVE_AS_TLS): Add powerpc and powerpc64 tests.\n\t* configure: Rebuild.\n\t* config/rs6000/rs6000-protos.h: Update.\n\t* config/rs6000/rs6000.c (rs6000_tls_size): New.\n\t(rs6000_tls_size_string): New.\n\t(rs6000_parse_tls_size_option): New.\n\t(rs6000_legitimize_tls_address): New.\n\t(rs6000_tls_get_addr): New.\n\t(rs6000_got_sym): New.\n\t(rs6000_tls_symbol_ref): New.\n\t(rs6000_tls_symbol_ref_1): New.\n\t(rs6000_get_some_local_dynamic_name): New.\n\t(rs6000_get_some_local_dynamic_name_1): New.\n\t(TARGET_HAVE_TLS): New.\n\t(TARGET_CANNOT_FORCE_CONST_MEM): New.\n\t(rs6000_override_options): Handle -mtls-size option.\n\t(constant_pool_expr_1): Handle TLS symbols.\n\t(rs6000_legitimize_address): Handle TLS symbols.\n\t(rs6000_tls_referenced_p): New.\n\t(rs6000_legitimate_address): Handle TLS symbols.\n\t(rs6000_emit_move): Handle TLS symbols.\n\t(print_operand): Handle TLS symbols.\n\t(uses_TOC): Handle TLS symbols.\n\t(rs6000_emit_prologue): Use symbol for unspec constant.\n\t* config/rs6000/rs6000.h (HAVE_AS_TLS): New.\n\t(some_ld_name): New.\n\t(LEGITIMATE_CONSTANT_P): Handle TLS symbols.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Handle TLS symbols.\n\t(PREDICATE_CODES): Add rs6000_tls_symbol_ref.\n\t* config/rs6000/rs6000.md (load_toc_v4_PIC_1, load_toc_v4_PIC_1b):\n\tSupport TLS.\n\t(tls_gd_32, tls_gd_64, tls_ld_32, tls_ld_64, tls_dtprel_32,\n\ttls_dtprel_64, tls_dtprel_ha_32, tls_dtprel_ha_64, tls_dtprel_lo_32,\n\ttls_dtprel_lo_64, tls_got_dtprel_32, tls_got_dtprel_64, tls_tprel_32,\n\ttls_tprel_64, tls_tprel_ha_32, tls_tprel_ha_64, tls_tprel_lo_32,\n\ttls_tprel_lo_64, tls_got_tprel_32, tls_got_tprel_64, tls_tls_32,\n\ttls_tls_64): New.\n\t* config/rs6000/sysv4.h (SUBTARGET_OPTIONS): Add tls_size.\n\nCo-Authored-By: Alan Modra <amodra@bigpond.net.au>\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r66742", "tree": {"sha": "b3e5af61ecf33cf727a33cc4a9e164384031ece4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3e5af61ecf33cf727a33cc4a9e164384031ece4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4501e6230543baaf5ad4ff87c0e24498bcb351b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4501e6230543baaf5ad4ff87c0e24498bcb351b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4501e6230543baaf5ad4ff87c0e24498bcb351b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4501e6230543baaf5ad4ff87c0e24498bcb351b/comments", "author": null, "committer": null, "parents": [{"sha": "6cfae22a6b3f271c7d588ea56c08bb9930684169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cfae22a6b3f271c7d588ea56c08bb9930684169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cfae22a6b3f271c7d588ea56c08bb9930684169"}], "stats": {"total": 818, "additions": 766, "deletions": 52}, "files": [{"sha": "68ed27979ccf92a786e2c47aeac30e469d2f177b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -1,3 +1,46 @@\n+2003-05-12  Janis Johnson  <janis187@us.ibm.com>\n+\t    Alan Modra  <amodra@bigpond.net.au>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* configure.in (HAVE_AS_TLS): Add powerpc and powerpc64 tests.\n+\t* configure: Rebuild.\n+\t* config/rs6000/rs6000-protos.h: Update.\n+\t* config/rs6000/rs6000.c (rs6000_tls_size): New.\n+\t(rs6000_tls_size_string): New.\n+\t(rs6000_parse_tls_size_option): New.\n+\t(rs6000_legitimize_tls_address): New.\n+\t(rs6000_tls_get_addr): New.\n+\t(rs6000_got_sym): New.\n+\t(rs6000_tls_symbol_ref): New.\n+\t(rs6000_tls_symbol_ref_1): New.\n+\t(rs6000_get_some_local_dynamic_name): New.\n+\t(rs6000_get_some_local_dynamic_name_1): New.\n+\t(TARGET_HAVE_TLS): New.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): New.\n+\t(rs6000_override_options): Handle -mtls-size option.\n+\t(constant_pool_expr_1): Handle TLS symbols.\n+\t(rs6000_legitimize_address): Handle TLS symbols.\n+\t(rs6000_tls_referenced_p): New.\n+\t(rs6000_legitimate_address): Handle TLS symbols.\n+\t(rs6000_emit_move): Handle TLS symbols.\n+\t(print_operand): Handle TLS symbols.\n+\t(uses_TOC): Handle TLS symbols.\n+\t(rs6000_emit_prologue): Use symbol for unspec constant.\n+\t* config/rs6000/rs6000.h (HAVE_AS_TLS): New.\n+\t(some_ld_name): New.\n+\t(LEGITIMATE_CONSTANT_P): Handle TLS symbols.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Handle TLS symbols.\n+\t(PREDICATE_CODES): Add rs6000_tls_symbol_ref.\n+\t* config/rs6000/rs6000.md (load_toc_v4_PIC_1, load_toc_v4_PIC_1b):\n+\tSupport TLS.\n+\t(tls_gd_32, tls_gd_64, tls_ld_32, tls_ld_64, tls_dtprel_32,\n+\ttls_dtprel_64, tls_dtprel_ha_32, tls_dtprel_ha_64, tls_dtprel_lo_32,\n+\ttls_dtprel_lo_64, tls_got_dtprel_32, tls_got_dtprel_64, tls_tprel_32,\n+\ttls_tprel_64, tls_tprel_ha_32, tls_tprel_ha_64, tls_tprel_lo_32,\n+\ttls_tprel_lo_64, tls_got_tprel_32, tls_got_tprel_64, tls_tls_32,\n+\ttls_tls_64): New.\n+\t* config/rs6000/sysv4.h (SUBTARGET_OPTIONS): Add tls_size.\n+\n 2003-05-12  Neil Booth  <neil@cat.daikokuya.co.uk>\n \n \t* Makefile.in (stage2_build, stage3_build, stage4_build):"}, {"sha": "8ee39e21bc330373d2b03986274d6c216d653f44", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -195,6 +195,8 @@ extern int rs6000_register_move_cost PARAMS ((enum machine_mode,\n \t\t\t\t\t      enum reg_class, enum reg_class));\n extern int rs6000_memory_move_cost PARAMS ((enum machine_mode,\n \t\t\t\t\t    enum reg_class, int));\n+extern bool rs6000_tls_referenced_p PARAMS ((rtx));\n+extern int rs6000_tls_symbol_ref PARAMS ((rtx, enum machine_mode));\n \n /* Declare functions in rs6000-c.c */\n "}, {"sha": "965c3e1ad1ad89807b30202d258ce38dfcd759ae", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 387, "deletions": 26, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -136,6 +136,10 @@ const char *rs6000_sdata_name = (char *)0;\n int fixuplabelno = 0;\n #endif\n \n+/* Bit size of immediate TLS offsets and string from which it is decoded.  */\n+int rs6000_tls_size = 32;\n+const char *rs6000_tls_size_string;\n+\n /* ABI enumeration available for subtarget to use.  */\n enum rs6000_abi rs6000_current_abi;\n \n@@ -286,6 +290,7 @@ static rtx altivec_expand_abs_builtin PARAMS ((enum insn_code, tree, rtx));\n static rtx altivec_expand_predicate_builtin PARAMS ((enum insn_code, const char *, tree, rtx));\n static rtx altivec_expand_stv_builtin PARAMS ((enum insn_code, tree));\n static void rs6000_parse_abi_options PARAMS ((void));\n+static void rs6000_parse_tls_size_option PARAMS ((void));\n static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n static int first_altivec_reg_to_save PARAMS ((void));\n static unsigned int compute_vrsave_mask PARAMS ((void));\n@@ -295,6 +300,12 @@ int easy_vector_constant PARAMS ((rtx, enum machine_mode));\n static int easy_vector_same PARAMS ((rtx, enum machine_mode));\n static bool is_ev64_opaque_type PARAMS ((tree));\n static rtx rs6000_dwarf_register_span PARAMS ((rtx));\n+static rtx rs6000_legitimize_tls_address PARAMS ((rtx, enum tls_model));\n+static rtx rs6000_tls_get_addr PARAMS ((void));\n+static rtx rs6000_got_sym PARAMS ((void));\n+static inline int rs6000_tls_symbol_ref_1 PARAMS ((rtx *, void *));\n+static const char *rs6000_get_some_local_dynamic_name PARAMS ((void));\n+static int rs6000_get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -367,6 +378,10 @@ static const char alt_reg_names[][8] =\n \n /* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */\n #define ALTIVEC_REG_BIT(REGNO) (0x80000000 >> ((REGNO) - FIRST_ALTIVEC_REGNO))\n+\n+/* Return 1 for a symbol ref for a thread-local storage symbol.  */\n+#define RS6000_SYMBOL_REF_TLS_P(RTX) \\\n+  (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -408,6 +423,12 @@ static const char alt_reg_names[][8] =\n #define TARGET_ASM_ASSEMBLE_VISIBILITY rs6000_assemble_visibility\n #endif\n \n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS HAVE_AS_TLS\n+\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM rs6000_tls_referenced_p\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE rs6000_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n@@ -727,6 +748,9 @@ rs6000_override_options (default_cpu)\n   rs6000_parse_yes_no_option (\"float-gprs\", rs6000_float_gprs_string,\n \t\t\t      &rs6000_float_gprs);\n \n+  /* Handle -mtls-size option.  */\n+  rs6000_parse_tls_size_option ();\n+\n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n@@ -864,6 +888,23 @@ rs6000_parse_abi_options ()\n     error (\"unknown ABI specified: '%s'\", rs6000_abi_string);\n }\n \n+/* Validate and record the size specified with the -mtls-size option.  */\n+\n+static void\n+rs6000_parse_tls_size_option ()\n+{\n+  if (rs6000_tls_size_string == 0)\n+    return;\n+  else if (strcmp (rs6000_tls_size_string, \"16\") == 0)\n+    rs6000_tls_size = 16;\n+  else if (strcmp (rs6000_tls_size_string, \"32\") == 0)\n+    rs6000_tls_size = 32;\n+  else if (strcmp (rs6000_tls_size_string, \"64\") == 0)\n+    rs6000_tls_size = 64;\n+  else\n+    error (\"bad value `%s' for -mtls-size switch\", rs6000_tls_size_string);\n+}\n+\n void\n optimization_options (level, size)\n      int level ATTRIBUTE_UNUSED;\n@@ -2236,7 +2277,9 @@ constant_pool_expr_1 (op, have_sym, have_toc)\n   switch (GET_CODE(op)) \n     {\n     case SYMBOL_REF:\n-      if (CONSTANT_POOL_ADDRESS_P (op))\n+      if (RS6000_SYMBOL_REF_TLS_P (op))\n+\treturn 0;\n+      else if (CONSTANT_POOL_ADDRESS_P (op))\n \t{\n \t  if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (op), Pmode))\n \t    {\n@@ -2462,6 +2505,13 @@ rs6000_legitimize_address (x, oldx, mode)\n      rtx oldx ATTRIBUTE_UNUSED;\n      enum machine_mode mode;\n {\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      enum tls_model model = SYMBOL_REF_TLS_MODEL (x);\n+      if (model != 0)\n+\treturn rs6000_legitimize_tls_address (x, model);\n+    }\n+\n   if (GET_CODE (x) == PLUS \n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n@@ -2562,6 +2612,253 @@ rs6000_legitimize_address (x, oldx, mode)\n     return NULL_RTX;\n }\n \n+/* Construct the SYMBOL_REF for the tls_get_addr function.  */\n+\n+static GTY(()) rtx rs6000_tls_symbol;\n+static rtx\n+rs6000_tls_get_addr ()\n+{\n+  if (!rs6000_tls_symbol)\n+    rs6000_tls_symbol = init_one_libfunc (\"__tls_get_addr\");\n+\n+  return rs6000_tls_symbol;\n+}\n+\n+/* Construct the SYMBOL_REF for TLS GOT references.  */\n+\n+static GTY(()) rtx rs6000_got_symbol;\n+static rtx\n+rs6000_got_sym ()\n+{\n+  if (!rs6000_got_symbol)\n+    {\n+      rs6000_got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+      SYMBOL_REF_FLAGS (rs6000_got_symbol) |= SYMBOL_FLAG_LOCAL;\n+      SYMBOL_REF_FLAGS (rs6000_got_symbol) |= SYMBOL_FLAG_EXTERNAL;\n+    }     \n+\n+  return rs6000_got_symbol;\n+}\n+\n+/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n+   this (thread-local) address.  */\n+\n+static rtx\n+rs6000_legitimize_tls_address (addr, model)\n+     rtx addr;\n+     enum tls_model model;\n+{\n+  rtx dest, insn;\n+\n+  dest = gen_reg_rtx (Pmode);\n+  if (model == TLS_MODEL_LOCAL_EXEC && rs6000_tls_size == 16)\n+    {\n+      rtx tlsreg;\n+\n+      if (TARGET_64BIT)\n+\t{\n+\t  tlsreg = gen_rtx_REG (Pmode, 13);\n+\t  insn = gen_tls_tprel_64 (dest, tlsreg, addr);\n+\t}\n+      else\n+\t{\n+\t  tlsreg = gen_rtx_REG (Pmode, 2);\n+\t  insn = gen_tls_tprel_32 (dest, tlsreg, addr);\n+\t}\n+      emit_insn (insn);\n+    }\n+  else if (model == TLS_MODEL_LOCAL_EXEC && rs6000_tls_size == 32)\n+    {\n+      rtx tlsreg, tmp;\n+\n+      tmp = gen_reg_rtx (Pmode);\n+      if (TARGET_64BIT)\n+\t{\n+\t  tlsreg = gen_rtx_REG (Pmode, 13);\n+\t  insn = gen_tls_tprel_ha_64 (tmp, tlsreg, addr);\n+\t}\n+      else\n+\t{\n+\t  tlsreg = gen_rtx_REG (Pmode, 2);\n+\t  insn = gen_tls_tprel_ha_32 (tmp, tlsreg, addr);\n+\t}\n+      emit_insn (insn);\n+      if (TARGET_64BIT)\n+\tinsn = gen_tls_tprel_lo_64 (dest, tmp, addr);\n+      else\n+\tinsn = gen_tls_tprel_lo_32 (dest, tmp, addr);\n+      emit_insn (insn);\n+    }\n+  else\n+    {\n+      rtx r3, got, tga, tmp1, tmp2, eqv;\n+\n+      if (TARGET_64BIT)\n+\tgot = gen_rtx_REG (Pmode, TOC_REGISTER);\n+      else\n+\t{\n+\t  if (flag_pic == 1)\n+\t    got = gen_rtx_REG (Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n+\t  else\n+\t    {\n+\t      rtx gsym = rs6000_got_sym ();\n+\t      got = gen_reg_rtx (Pmode);\n+\t      if (flag_pic == 0)\n+\t\trs6000_emit_move (got, gsym, Pmode);\n+\t      else\n+\t\t{\n+\t\t  char buf[30];\n+\t\t  static int tls_got_labelno = 0;\n+\t\t  rtx tempLR, lab, tmp3, mem;\n+\t\t  rtx first, last;\n+\n+\t\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LTLS\", tls_got_labelno++);\n+\t\t  lab = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n+\t\t  tempLR = gen_reg_rtx (Pmode);\n+\t\t  tmp1 = gen_reg_rtx (Pmode);\n+\t\t  tmp2 = gen_reg_rtx (Pmode);\n+\t\t  tmp3 = gen_reg_rtx (Pmode);\n+\t\t  mem = gen_rtx_MEM (Pmode, tmp1);\n+\t\t  RTX_UNCHANGING_P (mem) = 1;\n+\n+\t\t  first = emit_insn (gen_load_toc_v4_PIC_1b (tempLR, lab,\n+\t\t\t\t\t\t\t     gsym));\n+\t\t  emit_move_insn (tmp1, tempLR);\n+\t\t  emit_move_insn (tmp2, mem);\n+\t\t  emit_insn (gen_addsi3 (tmp3, tmp1, tmp2));\n+\t\t  last = emit_move_insn (got, tmp3);\n+\t\t  REG_NOTES (last) = gen_rtx_EXPR_LIST (REG_EQUAL, gsym,\n+\t\t\t\t\t\t\tREG_NOTES (last));\n+\t\t  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n+\t\t\t\t\t\t\t REG_NOTES (first));\n+\t\t  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,\n+\t\t\t\t\t\t\tREG_NOTES (last));\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (model == TLS_MODEL_GLOBAL_DYNAMIC)\n+\t{\n+\t  r3 = gen_rtx_REG (Pmode, 3);\n+\t  if (TARGET_64BIT)\n+\t    insn = gen_tls_gd_64 (r3, got, addr);\n+\t  else\n+\t    insn = gen_tls_gd_32 (r3, got, addr);\n+\t  start_sequence ();\n+\t  emit_insn (insn);\n+\t  tga = gen_rtx_MEM (Pmode, rs6000_tls_get_addr ());\n+\t  insn = gen_call_value (r3, tga, const0_rtx, const0_rtx);\n+\t  insn = emit_call_insn (insn);\n+\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r3);\n+\t  insn = get_insns ();\n+\t  end_sequence ();\n+\t  emit_libcall_block (insn, dest, r3, addr);\n+\t}\n+      else if (model == TLS_MODEL_LOCAL_DYNAMIC)\n+\t{\n+\t  r3 = gen_rtx_REG (Pmode, 3);\n+\t  if (TARGET_64BIT)\n+\t    insn = gen_tls_ld_64 (r3, got);\n+\t  else\n+\t    insn = gen_tls_ld_32 (r3, got);\n+\t  start_sequence ();\n+\t  emit_insn (insn);\n+\t  tga = gen_rtx_MEM (Pmode, rs6000_tls_get_addr ());\n+\t  insn = gen_call_value (r3, tga, const0_rtx, const0_rtx);\n+\t  insn = emit_call_insn (insn);\n+\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r3);\n+\t  insn = get_insns ();\n+\t  end_sequence ();\n+\t  tmp1 = gen_reg_rtx (Pmode);\n+\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\tUNSPEC_TLSLD);\n+\t  emit_libcall_block (insn, tmp1, r3, eqv);\n+\t  if (rs6000_tls_size == 16)\n+\t    {\n+\t      if (TARGET_64BIT)\n+\t\tinsn = gen_tls_dtprel_64 (dest, tmp1, addr);\n+\t      else\n+\t\tinsn = gen_tls_dtprel_32 (dest, tmp1, addr);\n+\t    }\n+\t  else if (rs6000_tls_size == 32)\n+\t    {\n+\t      tmp2 = gen_reg_rtx (Pmode);\n+\t      if (TARGET_64BIT)\n+\t\tinsn = gen_tls_dtprel_ha_64 (tmp2, tmp1, addr);\n+\t      else\n+\t\tinsn = gen_tls_dtprel_ha_32 (tmp2, tmp1, addr);\n+\t      emit_insn (insn);\n+\t      if (TARGET_64BIT)\n+\t\tinsn = gen_tls_dtprel_lo_64 (dest, tmp2, addr);\n+\t      else\n+\t\tinsn = gen_tls_dtprel_lo_32 (dest, tmp2, addr);\n+\t    }\n+\t  else\n+\t    {\n+\t      tmp2 = gen_reg_rtx (Pmode);\n+\t      if (TARGET_64BIT)\n+\t\tinsn = gen_tls_got_dtprel_64 (tmp2, got, addr);\n+\t      else\n+\t\tinsn = gen_tls_got_dtprel_32 (tmp2, got, addr);\n+\t      emit_insn (insn);\n+\t      insn = gen_rtx_SET (Pmode, dest,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, tmp2, tmp1));\n+\t    }\n+\t  emit_insn (insn);\n+\t}\n+      else\n+\t{\n+\t  /* IE, or 64 bit offset LE.  */\n+\t  tmp2 = gen_reg_rtx (Pmode);\n+\t  if (TARGET_64BIT)\n+\t    insn = gen_tls_got_tprel_64 (tmp2, got, addr);\n+\t  else\n+\t    insn = gen_tls_got_tprel_32 (tmp2, got, addr);\n+\t  emit_insn (insn);\n+\t  if (TARGET_64BIT)\n+\t    insn = gen_tls_tls_64 (dest, tmp2, addr);\n+\t  else\n+\t    insn = gen_tls_tls_32 (dest, tmp2, addr);\n+\t  emit_insn (insn);\n+\t}\n+    }\n+\n+  return dest;\n+}\n+\n+/* Return 1 if X is a SYMBOL_REF for a TLS symbol.  This is used in\n+   instruction definitions.  */\n+\n+int\n+rs6000_tls_symbol_ref (x, mode)\n+     rtx x;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return RS6000_SYMBOL_REF_TLS_P (x);\n+}\n+\n+/* Return 1 if X contains a thread-local symbol.  */\n+\n+bool\n+rs6000_tls_referenced_p (x)\n+     rtx x;\n+{\n+  return for_each_rtx (&x, &rs6000_tls_symbol_ref_1, 0);\n+}\n+\n+/* Return 1 if *X is a thread-local symbol.  This is the same as\n+   rs6000_tls_symbol_ref except for the type of the unused argument.  */\n+\n+static inline int\n+rs6000_tls_symbol_ref_1 (x, data)\n+     rtx *x;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return RS6000_SYMBOL_REF_TLS_P (*x);\n+}\n+\n /* The convention appears to be to define this wherever it is used.\n    With legitimize_reload_address now defined here, REG_MODE_OK_FOR_BASE_P\n    is now used here.  */\n@@ -2730,6 +3027,8 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n     rtx x;\n     int reg_ok_strict;\n {\n+  if (RS6000_SYMBOL_REF_TLS_P (x))\n+    return 0;\n   if (legitimate_indirect_address_p (x, reg_ok_strict))\n     return 1;\n   if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n@@ -3051,6 +3350,15 @@ rs6000_emit_move (dest, source, mode)\n \t}\n     }\n \n+  /* Recognize the case where operand[1] is a reference to thread-local\n+     data and load its address to a register.  */\n+  if (GET_CODE (operands[1]) == SYMBOL_REF)\n+    {\n+      enum tls_model model = SYMBOL_REF_TLS_MODEL (operands[1]);\n+      if (model != 0)\n+\toperands[1] = rs6000_legitimize_tls_address (operands[1], model);\n+    }\n+\n   /* Handle the case where reload calls us with an invalid address.  */\n   if (reload_in_progress && mode == Pmode\n       && (! general_operand (operands[1], mode)\n@@ -7822,6 +8130,48 @@ extract_ME (op)\n   return i;\n }\n \n+/* Locate some local-dynamic symbol still in use by this function\n+   so that we can print its name in some tls_ld pattern.  */\n+\n+static const char *\n+rs6000_get_some_local_dynamic_name ()\n+{\n+  rtx insn;\n+\n+  if (cfun->machine->some_ld_name)\n+    return cfun->machine->some_ld_name;\n+\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn)\n+\t&& for_each_rtx (&PATTERN (insn),\n+\t\t\t rs6000_get_some_local_dynamic_name_1, 0))\n+      return cfun->machine->some_ld_name;\n+\n+  abort ();\n+}\n+\n+/* Helper function for rs6000_get_some_local_dynamic_name.  */\n+\n+static int\n+rs6000_get_some_local_dynamic_name_1 (px, data)\n+     rtx *px;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      const char *str = XSTR (x, 0);\n+      if (SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n+\t{\n+\t  cfun->machine->some_ld_name = str;\n+\t  return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Print an operand.  Recognize special options, documented below.  */\n \n #if TARGET_ELF\n@@ -8436,6 +8786,10 @@ print_operand (file, x, code)\n \toutput_addr_const (file, x);\n       return;\n \n+    case '&':\n+      assemble_name (file, rs6000_get_some_local_dynamic_name ());\n+      return;\n+\n     default:\n       output_operand_lossage (\"invalid %%xn code\");\n     }\n@@ -10204,27 +10558,35 @@ get_TOC_alias_set ()\n }   \n \n /* This retuns nonzero if the current function uses the TOC.  This is\n-   determined by the presence of (unspec ... UNSPEC_TOC), which is\n-   generated by the various load_toc_* patterns.  */\n+   determined by the presence of (unspec ... UNSPEC_TOC) or\n+   use (unspec ... UNSPEC_TOC), which are generated by the various\n+   load_toc_* patterns.  */\n \n int\n uses_TOC () \n {\n-    rtx insn;\n+  rtx insn;\n \n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (INSN_P (insn))\n-\t{\n-\t  rtx pat = PATTERN (insn);\n-\t  int i;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\trtx pat = PATTERN (insn);\n+\tint i;\n \n-\t  if (GET_CODE (pat) == PARALLEL) \n-\t    for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n-\t      if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == UNSPEC \n-\t\t && XINT (XVECEXP (PATTERN (insn), 0, i), 1) == UNSPEC_TOC)\n-\t\t  return 1;\n-\t}\n-    return 0;\n+\tif (GET_CODE (pat) == PARALLEL) \n+\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t    {\n+\t      rtx sub = XVECEXP (pat, 0, i);\n+\t      if (GET_CODE (sub) == USE)\n+\t\t{\n+\t\t  sub = XEXP (sub, 0);\n+\t\t  if (GET_CODE (sub) == UNSPEC\n+\t\t      && XINT (sub, 1) == UNSPEC_TOC)\n+\t\t    return 1;\n+\t\t}\n+\t    }\n+      }\n+  return 0;\n }\n \n rtx\n@@ -11090,7 +11452,7 @@ rs6000_emit_prologue ()\n \t  && regs_ever_live[RS6000_PIC_OFFSET_TABLE_REGNUM]))\n   {\n     /* If emit_load_toc_table will use the link register, we need to save\n-       it.  We use R11 for this purpose because emit_load_toc_table\n+       it.  We use R12 for this purpose because emit_load_toc_table\n        can use register 0.  This allows us to use a plain 'blr' to return\n        from the procedure more often.  */\n     int save_LR_around_toc_setup = (TARGET_ELF\n@@ -11099,14 +11461,14 @@ rs6000_emit_prologue ()\n \t\t\t\t    && ! info->lr_save_p\n \t\t\t\t    && EXIT_BLOCK_PTR->pred != NULL);\n     if (save_LR_around_toc_setup)\n-      emit_move_insn (gen_rtx_REG (Pmode, 11), \n-\t\t      gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n-    \n-    rs6000_emit_load_toc_table (TRUE);\n-\n-    if (save_LR_around_toc_setup)\n-      emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM), \n-\t\t      gen_rtx_REG (Pmode, 11));\n+      {\n+\trtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+\trs6000_maybe_dead (emit_move_insn (frame_ptr_rtx, lr));\n+\trs6000_emit_load_toc_table (TRUE);\n+\trs6000_maybe_dead (emit_move_insn (lr, frame_ptr_rtx));\n+      }\n+    else\n+      rs6000_emit_load_toc_table (TRUE);\n   }\n \n #if TARGET_MACHO\n@@ -13033,7 +13395,6 @@ rs6000_longcall_ref (call_ref)\n \n   return force_reg (Pmode, call_ref);\n }\n-\n \f\n #ifdef USING_ELFOS_H\n "}, {"sha": "589963be6d3beff7d52f9b49269d7670668bab59", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -211,6 +211,10 @@ extern int target_flags;\n #define TARGET_UPDATE\t\t(! TARGET_NO_UPDATE)\n #define TARGET_FUSED_MADD\t(! TARGET_NO_FUSED_MADD)\n \n+#ifndef HAVE_AS_TLS\n+#define HAVE_AS_TLS 0\n+#endif\n+\n #ifdef IN_LIBGCC2\n /* For libgcc2 we make sure this is a compile time constant */\n #if defined (__64BIT__) || defined (__powerpc64__)\n@@ -1675,6 +1679,8 @@ typedef struct machine_function GTY(())\n   int sysv_varargs_p;\n   /* Flags if __builtin_return_address (n) with n >= 1 was used.  */\n   int ra_needs_full_frame;\n+  /* Some local-dynamic symbol.  */\n+  const char *some_ld_name;\n   /* Whether the instruction chain has been scanned already.  */\n   int insn_chain_scanned_p;\n } machine_function;\n@@ -2012,9 +2018,10 @@ typedef struct rs6000_args\n    acceptable.  */\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n-  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode\t\\\n-   || (TARGET_POWERPC64 && GET_MODE (X) == DImode)\t\t\\\n-   || easy_fp_constant (X, GET_MODE (X)))\n+  ((GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode\t\\\n+    || (TARGET_POWERPC64 && GET_MODE (X) == DImode)\t\t\\\n+    || easy_fp_constant (X, GET_MODE (X)))\t\t\t\\\n+   && !rs6000_tls_referenced_p (X))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -2643,7 +2650,7 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n /* Define which CODE values are valid.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)  \\\n-  ((CODE) == '.')\n+  ((CODE) == '.' || (CODE) == '&')\n \n /* Print a memory address as an operand to reference that memory location.  */\n \n@@ -2674,6 +2681,7 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"reg_or_logical_cint_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}}, \\\n   {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t   \\\n   {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\t   \\\n+  {\"rs6000_tls_symbol_ref\", {SYMBOL_REF}},\t\t\t\t   \\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n   {\"easy_vector_constant\", {CONST_VECTOR}},\t\t\t\t   \\\n   {\"easy_vector_constant_add_self\", {CONST_VECTOR}},\t\t\t   \\\n@@ -2697,6 +2705,7 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"count_register_operand\", {REG}},\t\t\t\t\t   \\\n   {\"xer_operand\", {REG}},\t\t\t\t\t\t   \\\n   {\"symbol_ref_operand\", {SYMBOL_REF}},\t\t\t\t\t   \\\n+  {\"rs6000_tls_symbol_ref\", {SYMBOL_REF}},\t\t\t\t   \\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\t   \\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t   \\\n   {\"input_operand\", {SUBREG, MEM, REG, CONST_INT,\t\t\t   \\"}, {"sha": "d2149d7a222ff76f5a10eba30c7275c90014e0b2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 184, "deletions": 4, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -9718,6 +9718,186 @@\n    && addrs_ok_for_quad_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n   \"stfq%U0%X0 %1,%0\")\n \f\n+;; TLS support.\n+\n+;; \"b\" output constraint here and on tls_ld to support tls linker optimization.\n+(define_insn \"tls_gd_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSGD))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addi %0,%1,%2@got@tlsgd\")\n+\n+(define_insn \"tls_gd_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSGD))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addi %0,%1,%2@got@tlsgd\")\n+\n+(define_insn \"tls_ld_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")]\n+\t\t   UNSPEC_TLSLD))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addi %0,%1,%&@got@tlsld\")\n+\n+(define_insn \"tls_ld_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")]\n+\t\t   UNSPEC_TLSLD))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addi %0,%1,%&@got@tlsld\")\n+\n+(define_insn \"tls_dtprel_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSDTPREL))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addi %0,%1,%2@dtprel\")\n+\n+(define_insn \"tls_dtprel_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSDTPREL))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addi %0,%1,%2@dtprel\")\n+\n+(define_insn \"tls_dtprel_ha_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSDTPRELHA))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addis %0,%1,%2@dtprel@ha\")\n+\n+(define_insn \"tls_dtprel_ha_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSDTPRELHA))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addis %0,%1,%2@dtprel@ha\")\n+\n+(define_insn \"tls_dtprel_lo_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSDTPRELLO))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addi %0,%1,%2@dtprel@l\")\n+\n+(define_insn \"tls_dtprel_lo_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSDTPRELLO))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addi %0,%1,%2@dtprel@l\")\n+\n+(define_insn \"tls_got_dtprel_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSGOTDTPREL))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"lwz %0,%2@got@dtprel(%1)\")\n+\n+(define_insn \"tls_got_dtprel_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSGOTDTPREL))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"ld %0,%2@got@dtprel(%1)\")\n+\n+(define_insn \"tls_tprel_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTPREL))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addi %0,%1,%2@tprel\")\n+\n+(define_insn \"tls_tprel_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTPREL))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addi %0,%1,%2@tprel\")\n+\n+(define_insn \"tls_tprel_ha_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTPRELHA))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addis %0,%1,%2@tprel@ha\")\n+\n+(define_insn \"tls_tprel_ha_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTPRELHA))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addis %0,%1,%2@tprel@ha\")\n+\n+(define_insn \"tls_tprel_lo_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTPRELLO))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"addi %0,%1,%2@tprel@l\")\n+\n+(define_insn \"tls_tprel_lo_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTPRELLO))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"addi %0,%1,%2@tprel@l\")\n+\n+;; \"b\" output contraint here and on tls_tls input to support linker tls\n+;; optimization.  The linker may edit the instructions emitted by a\n+;; tls_got_tprel/tls_tls pair to addis,addi.\n+(define_insn \"tls_got_tprel_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSGOTTPREL))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"lwz %0,%2@got@tprel(%1)\")\n+\n+(define_insn \"tls_got_tprel_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSGOTTPREL))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"ld %0,%2@got@tprel(%1)\")\n+\n+(define_insn \"tls_tls_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTLS))]\n+  \"HAVE_AS_TLS && !TARGET_64BIT\"\n+  \"add %0,%1,%2@tls\")\n+\n+(define_insn \"tls_tls_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:DI 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t   UNSPEC_TLSTLS))]\n+  \"HAVE_AS_TLS && TARGET_64BIT\"\n+  \"add %0,%1,%2@tls\")\n+\f\n ;; Next come insns related to the calling sequence.\n ;;\n ;; First, an insn to allocate new stack space for dynamic use (e.g., alloca).\n@@ -9895,7 +10075,7 @@\n (define_insn \"load_toc_v4_PIC_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(match_operand:SI 1 \"immediate_operand\" \"s\"))\n-   (unspec [(match_dup 1)] UNSPEC_TOC)]\n+   (use (unspec [(match_dup 1)] UNSPEC_TOC))]\n   \"TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2\"\n   \"bcl 20,31,%1\\\\n%1:\"\n   [(set_attr \"type\" \"branch\")\n@@ -9904,10 +10084,10 @@\n (define_insn \"load_toc_v4_PIC_1b\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(match_operand:SI 1 \"immediate_operand\" \"s\"))\n-   (unspec [(match_dup 1) (match_operand 2 \"immediate_operand\" \"s\")]\n-   \t   UNSPEC_TOCPTR)]\n+   (use (unspec [(match_dup 1) (match_operand 2 \"immediate_operand\" \"s\")]\n+\t\tUNSPEC_TOCPTR))]\n   \"TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2\"\n-  \"bcl 20,31,%1\\\\n\\\\t.long %2-%1+4\\\\n%1:\"\n+  \"bcl 20,31,%1+4\\\\n%1:\\\\n\\\\t.long %2-%1\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n "}, {"sha": "d6b0f31088d23b612cfcff08a2b88cc4e09a73c6", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -79,12 +79,15 @@ extern enum rs6000_sdata_type rs6000_sdata;\n /* Strings provided by SUBTARGET_OPTIONS */\n extern const char *rs6000_abi_name;\n extern const char *rs6000_sdata_name;\n+extern const char *rs6000_tls_size_string; /* For -mtls-size= */\n \n /* Override rs6000.h definition.  */\n #undef\tSUBTARGET_OPTIONS\n #define\tSUBTARGET_OPTIONS\t\t\t\t\t\t\t\\\n   { \"call-\",  &rs6000_abi_name, N_(\"Select ABI calling convention\"), 0},\t\\\n-  { \"sdata=\", &rs6000_sdata_name, N_(\"Select method for sdata handling\"), 0}\n+  { \"sdata=\", &rs6000_sdata_name, N_(\"Select method for sdata handling\"), 0},\t\\\n+  { \"tls-size=\", &rs6000_tls_size_string,\t\t\t\t\t\\\n+   N_(\"Specify bit size of immediate TLS offsets\"), 0 }\n \n /* Max # of bytes for variables to automatically be put into the .sdata\n    or .sdata2 sections.  */"}, {"sha": "fe5e6b39f7a0dc285a2a7667e278de5203537de7", "filename": "gcc/configure", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -8196,6 +8196,64 @@ foo:\tdata8\t25\n \ttls_first_major=2\n \ttls_first_minor=13\n \t;;\n+  powerpc-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+\t.align 2\n+ld0:\t.space 4\n+ld1:\t.space 4\n+x1:\t.space 4\n+x2:\t.space 4\n+x3:\t.space 4\n+\t.text\n+\taddi 3,31,ld0@got@tlsgd\n+\tbl __tls_get_addr\n+\taddi 3,31,x1@got@tlsld\n+\tbl __tls_get_addr\n+\taddi 9,3,x1@dtprel\n+\taddis 9,3,x2@dtprel@ha\n+\taddi 9,9,x2@dtprel@l\n+\tlwz 9,x3@got@tprel(31)\n+\tadd 9,9,x@tls\n+\taddi 9,2,x1@tprel\n+\taddis 9,2,x2@tprel@ha\n+\taddi 9,9,x2@tprel@l'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n+  powerpc64-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+\t.align 3\n+ld0:\t.space 8\n+ld1:\t.space 8\n+x1:\t.space 8\n+x2:\t.space 8\n+x3:\t.space 8\n+\t.text\n+\taddi 3,2,ld0@got@tlsgd\n+\tbl .__tls_get_addr\n+\tnop\n+\taddi 3,2,ld1@toc\n+\tbl .__tls_get_addr\n+\tnop\n+\taddi 3,2,x1@got@tlsld\n+\tbl .__tls_get_addr\n+\tnop\n+\taddi 9,3,x1@dtprel\n+\tbl .__tls_get_addr\n+\tnop\n+\taddis 9,3,x2@dtprel@ha\n+\taddi 9,9,x2@dtprel@l\n+\tbl .__tls_get_addr\n+\tnop\n+\tld 9,x3@got@dtprel(2)\n+\tadd 9,9,3\n+\tbl .__tls_get_addr\n+\tnop'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n   s390-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -8265,7 +8323,7 @@ case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler supports explicit relocations\"\"... $ac_c\" 1>&6\n-echo \"configure:8269: checking assembler supports explicit relocations\" >&5\n+echo \"configure:8327: checking assembler supports explicit relocations\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8318,7 +8376,7 @@ EOF\n     ;;\n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:8322: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:8380: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8346,7 +8404,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler supports -relax\"\"... $ac_c\" 1>&6\n-echo \"configure:8350: checking assembler supports -relax\" >&5\n+echo \"configure:8408: checking assembler supports -relax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_relax_opt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8374,7 +8432,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:8378: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:8436: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8401,7 +8459,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:8405: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:8463: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8441,7 +8499,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:8445: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:8503: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8480,7 +8538,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:8484: checking assembler instructions\" >&5\n+echo \"configure:8542: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test $in_tree_gas = yes ; then \n        if test $gcc_cv_gas_major_version -eq 2 \\\n@@ -8514,7 +8572,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:8518: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:8576: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test $in_tree_gas = yes ; then\n        if test $gcc_cv_gas_major_version -eq 2 \\\n@@ -8548,7 +8606,7 @@ EOF\n \n   ia64*-*-*)\n     echo $ac_n \"checking assembler supports ltoffx and ldxmov\"\"... $ac_c\" 1>&6\n-echo \"configure:8552: checking assembler supports ltoffx and ldxmov\" >&5\n+echo \"configure:8610: checking assembler supports ltoffx and ldxmov\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_ltoffx_ldxmov_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8593,7 +8651,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:8597: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:8655: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -8655,7 +8713,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:8659: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:8717: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test $in_tree_gas = yes ; then\n    if test $gcc_cv_gas_major_version -eq 2 \\\n@@ -8689,7 +8747,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:8693: checking assembler --gstabs support\" >&5\n+echo \"configure:8751: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test $in_tree_gas = yes ; then\n    if test $gcc_cv_gas_major_version -eq 2 \\\n@@ -8722,7 +8780,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker read-only and read-write section mixing\"\"... $ac_c\" 1>&6\n-echo \"configure:8726: checking linker read-only and read-write section mixing\" >&5\n+echo \"configure:8784: checking linker read-only and read-write section mixing\" >&5\n gcc_cv_ld_ro_rw_mix=unknown\n if test $in_tree_ld = yes ; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 10 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -8760,7 +8818,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_ld_ro_rw_mix\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:8764: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:8822: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test $in_tree_ld = yes ; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -8784,7 +8842,7 @@ echo \"$ac_t\"\"$gcc_cv_ld_eh_frame_hdr\" 1>&6\n case \"$target\" in\n   mips*-*-*)\n     echo $ac_n \"checking whether libgloss uses STARTUP directives consistently\"\"... $ac_c\" 1>&6\n-echo \"configure:8788: checking whether libgloss uses STARTUP directives consistently\" >&5\n+echo \"configure:8846: checking whether libgloss uses STARTUP directives consistently\" >&5\n     gcc_cv_mips_libgloss_startup=no\n     gcc_cv_libgloss_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/libgloss\n     if test \"x$exec_prefix\" = xNONE; then\n@@ -8812,7 +8870,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_mips_libgloss_startup\" 1>&6\n \n     echo $ac_n \"checking whether the assembler has explicit relocation support\"\"... $ac_c\" 1>&6\n-echo \"configure:8816: checking whether the assembler has explicit relocation support\" >&5\n+echo \"configure:8874: checking whether the assembler has explicit relocation support\" >&5\n     if test x$gcc_cv_mips_explicit_relocs = x; then\n       gcc_cv_mips_explicit_relocs=no\n       if test x$gcc_cv_as != x; then\n@@ -9007,7 +9065,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:9011: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:9069: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "f0e5d752474595dd57aef73dcf7a9117f121b9d7", "filename": "gcc/configure.in", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4501e6230543baaf5ad4ff87c0e24498bcb351b/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=c4501e6230543baaf5ad4ff87c0e24498bcb351b", "patch": "@@ -2123,6 +2123,64 @@ foo:\tdata8\t25\n \ttls_first_major=2\n \ttls_first_minor=13\n \t;;\n+  powerpc-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+\t.align 2\n+ld0:\t.space 4\n+ld1:\t.space 4\n+x1:\t.space 4\n+x2:\t.space 4\n+x3:\t.space 4\n+\t.text\n+\taddi 3,31,ld0@got@tlsgd\n+\tbl __tls_get_addr\n+\taddi 3,31,x1@got@tlsld\n+\tbl __tls_get_addr\n+\taddi 9,3,x1@dtprel\n+\taddis 9,3,x2@dtprel@ha\n+\taddi 9,9,x2@dtprel@l\n+\tlwz 9,x3@got@tprel(31)\n+\tadd 9,9,x@tls\n+\taddi 9,2,x1@tprel\n+\taddis 9,2,x2@tprel@ha\n+\taddi 9,9,x2@tprel@l'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n+  powerpc64-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+\t.align 3\n+ld0:\t.space 8\n+ld1:\t.space 8\n+x1:\t.space 8\n+x2:\t.space 8\n+x3:\t.space 8\n+\t.text\n+\taddi 3,2,ld0@got@tlsgd\n+\tbl .__tls_get_addr\n+\tnop\n+\taddi 3,2,ld1@toc\n+\tbl .__tls_get_addr\n+\tnop\n+\taddi 3,2,x1@got@tlsld\n+\tbl .__tls_get_addr\n+\tnop\n+\taddi 9,3,x1@dtprel\n+\tbl .__tls_get_addr\n+\tnop\n+\taddis 9,3,x2@dtprel@ha\n+\taddi 9,9,x2@dtprel@l\n+\tbl .__tls_get_addr\n+\tnop\n+\tld 9,x3@got@dtprel(2)\n+\tadd 9,9,3\n+\tbl .__tls_get_addr\n+\tnop'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\t;;\n   s390-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}]}