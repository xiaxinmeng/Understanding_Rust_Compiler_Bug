{"sha": "85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "node_id": "C_kwDOANBUbNoAKDg1YWMyZmU0NGZkNGFjZjgzNTBkZDc0Y2NiMDAzYTIwNTBiYWFkMmE", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:05Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:05Z"}, "message": "aarch64: Add more vec_combine patterns\n\nvec_combine is really one instruction on aarch64, provided that\nthe lowpart element is in the same register as the destination\nvector.  This patch adds patterns for that.\n\nThe patch fixes a regression from GCC 8.  Before the patch:\n\nint64x2_t s64q_1(int64_t a0, int64_t a1) {\n  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n    return (int64x2_t) { a1, a0 };\n  else\n    return (int64x2_t) { a0, a1 };\n}\n\ngenerated:\n\n        fmov    d0, x0\n        ins     v0.d[1], x1\n        ins     v0.d[1], x1\n        ret\n\nwhereas GCC 8 generated the more respectable:\n\n        dup     v0.2d, x0\n        ins     v0.d[1], x1\n        ret\n\ngcc/\n\t* config/aarch64/predicates.md (aarch64_reg_or_mem_pair_operand):\n\tNew predicate.\n\t* config/aarch64/aarch64-simd.md (*aarch64_combine_internal<mode>)\n\t(*aarch64_combine_internal_be<mode>): New patterns.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/vec-init-9.c: New test.\n\t* gcc.target/aarch64/vec-init-10.c: Likewise.\n\t* gcc.target/aarch64/vec-init-11.c: Likewise.", "tree": {"sha": "bb28b1b1f8c19ae2ca9f34d26630784e34d122b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb28b1b1f8c19ae2ca9f34d26630784e34d122b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeef5c57f161ad0258c5ab066ade2274bef3271a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeef5c57f161ad0258c5ab066ade2274bef3271a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeef5c57f161ad0258c5ab066ade2274bef3271a"}], "stats": {"total": 360, "additions": 360, "deletions": 0}, "files": [{"sha": "ead80396e70474999ddd2be9cfd30d4960e88b44", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "patch": "@@ -4326,6 +4326,25 @@\n   [(set_attr \"type\" \"neon_load1_1reg_q\")]\n )\n \n+;; This STP pattern is a partial duplicate of the general vec_concat patterns\n+;; below.  The reason for having both of them is that the alternatives of\n+;; the later patterns do not have consistent register preferences: the STP\n+;; alternatives have no preference between GPRs and FPRs (and if anything,\n+;; the GPR form is more natural for scalar integers) whereas the other\n+;; alternatives *require* an FPR for operand 1 and prefer one for operand 2.\n+;;\n+;; Using \"*\" to hide the STP alternatives from the RA penalizes cases in\n+;; which the destination was always memory.  On the other hand, expressing\n+;; the true preferences makes GPRs seem more palatable than they really are\n+;; for register destinations.\n+;;\n+;; Despite that, we do still want the general form to have STP alternatives,\n+;; in order to handle cases where a register destination is spilled.\n+;;\n+;; The best compromise therefore seemed to be to have a dedicated STP\n+;; pattern to catch cases in which the destination was always memory.\n+;; This dedicated pattern must come first.\n+\n (define_insn \"store_pair_lanes<mode>\"\n   [(set (match_operand:<VDBL> 0 \"aarch64_mem_pair_lanes_operand\" \"=Umn, Umn\")\n \t(vec_concat:<VDBL>\n@@ -4338,6 +4357,49 @@\n   [(set_attr \"type\" \"neon_stp, store_16\")]\n )\n \n+;; Form a vector whose least significant half comes from operand 1 and whose\n+;; most significant half comes from operand 2.  The register alternatives\n+;; tie the least significant half to the same register as the destination,\n+;; so that only the other half needs to be handled explicitly.  For the\n+;; reasons given above, the STP alternatives use ? for constraints that\n+;; the register alternatives either don't accept or themselves disparage.\n+\n+(define_insn \"*aarch64_combine_internal<mode>\"\n+  [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, Umn, Umn\")\n+\t(vec_concat:<VDBL>\n+\t  (match_operand:VDC 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")\n+\t  (match_operand:VDC 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, w, ?r\")))]\n+  \"TARGET_SIMD\n+   && !BYTES_BIG_ENDIAN\n+   && (register_operand (operands[0], <VDBL>mode)\n+       || register_operand (operands[2], <MODE>mode))\"\n+  \"@\n+   ins\\t%0.d[1], %2.d[0]\n+   ins\\t%0.d[1], %2\n+   ld1\\t{%0.d}[1], %2\n+   stp\\t%d1, %d2, %y0\n+   stp\\t%x1, %x2, %y0\"\n+  [(set_attr \"type\" \"neon_ins_q, neon_from_gp_q, neon_load1_one_lane_q, neon_stp, store_16\")]\n+)\n+\n+(define_insn \"*aarch64_combine_internal_be<mode>\"\n+  [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, Umn, Umn\")\n+\t(vec_concat:<VDBL>\n+\t  (match_operand:VDC 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, ?w, ?r\")\n+\t  (match_operand:VDC 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")))]\n+  \"TARGET_SIMD\n+   && BYTES_BIG_ENDIAN\n+   && (register_operand (operands[0], <VDBL>mode)\n+       || register_operand (operands[2], <MODE>mode))\"\n+  \"@\n+   ins\\t%0.d[1], %2.d[0]\n+   ins\\t%0.d[1], %2\n+   ld1\\t{%0.d}[1], %2\n+   stp\\t%d2, %d1, %y0\n+   stp\\t%x2, %x1, %y0\"\n+  [(set_attr \"type\" \"neon_ins_q, neon_from_gp_q, neon_load1_one_lane_q, neon_stp, store_16\")]\n+)\n+\n ;; In this insn, operand 1 should be low, and operand 2 the high part of the\n ;; dest vector.\n "}, {"sha": "c308015ac2c13d24cd6bcec71247ec45df8cf5e6", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "patch": "@@ -254,6 +254,10 @@\n \t\t\t\t\t\t  false,\n \t\t\t\t\t\t  ADDR_QUERY_LDP_STP_N)\")))\n \n+(define_predicate \"aarch64_reg_or_mem_pair_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_mem_pair_lanes_operand\")))\n+\n (define_predicate \"aarch64_prefetch_operand\"\n   (match_test \"aarch64_address_valid_for_prefetch_p (op, false)\"))\n "}, {"sha": "f5dd83b94b5bf475a6c2929fa054af0a5338bd9b", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-10.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-10.c?ref=85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#include <arm_neon.h>\n+\n+int64x2_t f1(int64_t *x, int c) {\n+  return c ? (int64x2_t) { x[0], x[2] } : (int64x2_t) { 0, 0 };\n+}\n+\n+int64x2_t f2(int64_t *x, int i0, int i1, int c) {\n+  return c ? (int64x2_t) { x[i0], x[i1] } : (int64x2_t) { 0, 0 };\n+}\n+\n+/* { dg-final { scan-assembler-times {\\t(?:ldr\\td[0-9]+|ld1\\t)} 4 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tx} } } */"}, {"sha": "df242702c0ca618eb10d44f89db4cdb5f7632080", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-11.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-11.c?ref=85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#include <arm_neon.h>\n+\n+void f1(int64x2_t *res, int64_t *x, int c0, int c1) {\n+  res[0] = (int64x2_t) { c0 ? x[0] : 0, c1 ? x[2] : 0 };\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tldr\\tx[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler {\\tstp\\tx[0-9]+, x[0-9]+} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\td} } } */"}, {"sha": "8f68e06a55925b973a87723c7b5924264382e4b0", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-9.c", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ac2fe44fd4acf8350dd74ccb003a2050baad2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-9.c?ref=85ac2fe44fd4acf8350dd74ccb003a2050baad2a", "patch": "@@ -0,0 +1,267 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include <arm_neon.h>\n+\n+void ext();\n+\n+/*\n+** s64q_1:\n+**\tfmov\td0, x0\n+**\tins\tv0\\.d\\[1\\], x1\n+**\tret\n+*/\n+int64x2_t s64q_1(int64_t a0, int64_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int64x2_t) { a1, a0 };\n+  else\n+    return (int64x2_t) { a0, a1 };\n+}\n+/*\n+** s64q_2:\n+**\tfmov\td0, x0\n+**\tld1\t{v0\\.d}\\[1\\], \\[x1\\]\n+**\tret\n+*/\n+int64x2_t s64q_2(int64_t a0, int64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int64x2_t) { ptr[0], a0 };\n+  else\n+    return (int64x2_t) { a0, ptr[0] };\n+}\n+/*\n+** s64q_3:\n+**\tldr\td0, \\[x0\\]\n+**\tins\tv0\\.d\\[1\\], x1\n+**\tret\n+*/\n+int64x2_t s64q_3(int64_t *ptr, int64_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int64x2_t) { a1, ptr[0] };\n+  else\n+    return (int64x2_t) { ptr[0], a1 };\n+}\n+/*\n+** s64q_4:\n+**\tstp\tx1, x2, \\[x0\\]\n+**\tret\n+*/\n+void s64q_4(int64x2_t *res, int64_t a0, int64_t a1) {\n+  res[0] = (int64x2_t) { a0, a1 };\n+}\n+/*\n+** s64q_5:\n+**\tstp\tx1, x2, \\[x0, #?8\\]\n+**\tret\n+*/\n+void s64q_5(uintptr_t res, int64_t a0, int64_t a1) {\n+  *(int64x2_t *)(res + 8) = (int64x2_t) { a0, a1 };\n+}\n+/*\n+** s64q_6:\n+**\t...\n+**\tstp\tx0, x1, .*\n+**\t...\n+**\tldr\tq0, .*\n+**\t...\n+**\tret\n+*/\n+int64x2_t s64q_6(int64_t a0, int64_t a1) {\n+  int64x2_t res = { a0, a1 };\n+  ext ();\n+  return res;\n+}\n+\n+/*\n+** f64q_1:\n+**\tins\tv0\\.d\\[1\\], v1\\.d\\[0\\]\n+**\tret\n+*/\n+float64x2_t f64q_1(float64_t a0, float64_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float64x2_t) { a1, a0 };\n+  else\n+    return (float64x2_t) { a0, a1 };\n+}\n+/*\n+** f64q_2:\n+**\tld1\t{v0\\.d}\\[1\\], \\[x0\\]\n+**\tret\n+*/\n+float64x2_t f64q_2(float64_t a0, float64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float64x2_t) { ptr[0], a0 };\n+  else\n+    return (float64x2_t) { a0, ptr[0] };\n+}\n+/*\n+** f64q_3:\n+**\tldr\td0, \\[x0\\]\n+**\tins\tv0\\.d\\[1\\], v1\\.d\\[0\\]\n+**\tret\n+*/\n+float64x2_t f64q_3(float64_t a0, float64_t a1, float64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float64x2_t) { a1, ptr[0] };\n+  else\n+    return (float64x2_t) { ptr[0], a1 };\n+}\n+/*\n+** f64q_4:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tret\n+*/\n+void f64q_4(float64x2_t *res, float64_t a0, float64_t a1) {\n+  res[0] = (float64x2_t) { a0, a1 };\n+}\n+/*\n+** f64q_5:\n+**\tstp\td0, d1, \\[x0, #?8\\]\n+**\tret\n+*/\n+void f64q_5(uintptr_t res, float64_t a0, float64_t a1) {\n+  *(float64x2_t *)(res + 8) = (float64x2_t) { a0, a1 };\n+}\n+/*\n+** f64q_6:\n+**\t...\n+**\tstp\td0, d1, .*\n+**\t...\n+**\tldr\tq0, .*\n+**\t...\n+**\tret\n+*/\n+float64x2_t f64q_6(float64_t a0, float64_t a1) {\n+  float64x2_t res = { a0, a1 };\n+  ext ();\n+  return res;\n+}\n+\n+/*\n+** s32q_1:\n+**\tins\tv0\\.d\\[1\\], v1\\.d\\[0\\]\n+**\tret\n+*/\n+int32x4_t s32q_1(int32x2_t a0, int32x2_t a1) {\n+  return vcombine_s32 (a0, a1);\n+}\n+/*\n+** s32q_2:\n+**\tld1\t{v0\\.d}\\[1\\], \\[x0\\]\n+**\tret\n+*/\n+int32x4_t s32q_2(int32x2_t a0, int32x2_t *ptr) {\n+  return vcombine_s32 (a0, ptr[0]);\n+}\n+/*\n+** s32q_3:\n+**\tldr\td0, \\[x0\\]\n+**\tins\tv0\\.d\\[1\\], v1\\.d\\[0\\]\n+**\tret\n+*/\n+int32x4_t s32q_3(int32x2_t a0, int32x2_t a1, int32x2_t *ptr) {\n+  return vcombine_s32 (ptr[0], a1);\n+}\n+/*\n+** s32q_4:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tret\n+*/\n+void s32q_4(int32x4_t *res, int32x2_t a0, int32x2_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    res[0] = vcombine_s32 (a1, a0);\n+  else\n+    res[0] = vcombine_s32 (a0, a1);\n+}\n+/*\n+** s32q_5:\n+**\tstp\td0, d1, \\[x0, #?8\\]\n+**\tret\n+*/\n+void s32q_5(uintptr_t res, int32x2_t a0, int32x2_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    *(int32x4_t *)(res + 8) = vcombine_s32 (a1, a0);\n+  else\n+    *(int32x4_t *)(res + 8) = vcombine_s32 (a0, a1);\n+}\n+/*\n+** s32q_6:\n+**\t...\n+**\tstp\td0, d1, .*\n+**\t...\n+**\tldr\tq0, .*\n+**\t...\n+**\tret\n+*/\n+int32x4_t s32q_6(int32x2_t a0, int32x2_t a1) {\n+  int32x4_t res = (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\t\t   ? vcombine_s32 (a1, a0)\n+\t\t   : vcombine_s32 (a0, a1));\n+  ext ();\n+  return res;\n+}\n+\n+/*\n+** f32q_1:\n+**\tins\tv0\\.d\\[1\\], v1\\.d\\[0\\]\n+**\tret\n+*/\n+float32x4_t f32q_1(float32x2_t a0, float32x2_t a1) {\n+  return vcombine_f32 (a0, a1);\n+}\n+/*\n+** f32q_2:\n+**\tld1\t{v0\\.d}\\[1\\], \\[x0\\]\n+**\tret\n+*/\n+float32x4_t f32q_2(float32x2_t a0, float32x2_t *ptr) {\n+  return vcombine_f32 (a0, ptr[0]);\n+}\n+/*\n+** f32q_3:\n+**\tldr\td0, \\[x0\\]\n+**\tins\tv0\\.d\\[1\\], v1\\.d\\[0\\]\n+**\tret\n+*/\n+float32x4_t f32q_3(float32x2_t a0, float32x2_t a1, float32x2_t *ptr) {\n+  return vcombine_f32 (ptr[0], a1);\n+}\n+/*\n+** f32q_4:\n+**\tstp\td0, d1, \\[x0\\]\n+**\tret\n+*/\n+void f32q_4(float32x4_t *res, float32x2_t a0, float32x2_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    res[0] = vcombine_f32 (a1, a0);\n+  else\n+    res[0] = vcombine_f32 (a0, a1);\n+}\n+/*\n+** f32q_5:\n+**\tstp\td0, d1, \\[x0, #?8\\]\n+**\tret\n+*/\n+void f32q_5(uintptr_t res, float32x2_t a0, float32x2_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    *(float32x4_t *)(res + 8) = vcombine_f32 (a1, a0);\n+  else\n+    *(float32x4_t *)(res + 8) = vcombine_f32 (a0, a1);\n+}\n+/*\n+** f32q_6:\n+**\t...\n+**\tstp\td0, d1, .*\n+**\t...\n+**\tldr\tq0, .*\n+**\t...\n+**\tret\n+*/\n+float32x4_t f32q_6(float32x2_t a0, float32x2_t a1) {\n+  float32x4_t res = (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\t\t     ? vcombine_f32 (a1, a0)\n+\t\t     : vcombine_f32 (a0, a1));\n+  ext ();\n+  return res;\n+}"}]}