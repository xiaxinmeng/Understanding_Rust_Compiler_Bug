{"sha": "0f9926f36760320180ae46f7e2c332750ebfbd9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5OTI2ZjM2NzYwMzIwMTgwYWU0NmY3ZTJjMzMyNzUwZWJmYmQ5ZA==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-06-18T17:38:21Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-06-18T17:38:21Z"}, "message": "Helper function for epilogue expansion.\n\nHelper function for epilogue expansion. Emit RTL for APCS frame epilogue\n(when -mapcs-frame command line option is specified). \nThis function is used by a later patch.\n\ngcc/\n\n2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n            Sameera Deshpande  <sameera.deshpande@arm.com>\n            Greta Yorsh  <greta.yorsh@arm.com>\n\n        * config/arm/arm.c (arm_expand_epilogue_apcs_frame): New function.\n        * config/arm/arm.md (arm_addsi3) Add an alternative.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r188741", "tree": {"sha": "fad5e8692a1b8bbd2327fe4c16d1cd33a20076a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fad5e8692a1b8bbd2327fe4c16d1cd33a20076a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f9926f36760320180ae46f7e2c332750ebfbd9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9926f36760320180ae46f7e2c332750ebfbd9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f9926f36760320180ae46f7e2c332750ebfbd9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9926f36760320180ae46f7e2c332750ebfbd9d/comments", "author": null, "committer": null, "parents": [{"sha": "4b2678f8864154a2339001a0ad588c7f611437c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2678f8864154a2339001a0ad588c7f611437c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b2678f8864154a2339001a0ad588c7f611437c7"}], "stats": {"total": 171, "additions": 166, "deletions": 5}, "files": [{"sha": "3171ed0e1cf90e00bd3fe4c846b11575c59289e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9926f36760320180ae46f7e2c332750ebfbd9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9926f36760320180ae46f7e2c332750ebfbd9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f9926f36760320180ae46f7e2c332750ebfbd9d", "patch": "@@ -1,3 +1,10 @@\n+2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n+            Sameera Deshpande  <sameera.deshpande@arm.com>\n+            Greta Yorsh  <greta.yorsh@arm.com>\n+\n+        * config/arm/arm.c (arm_expand_epilogue_apcs_frame): New function.\n+        * config/arm/arm.md (arm_addsi3) Add an alternative.\n+\n 2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n             Sameera Deshpande  <sameera.deshpande@arm.com>\n             Greta Yorsh  <greta.yorsh@arm.com>"}, {"sha": "64404f3f788ab27ad557b426b83d745162d059f6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9926f36760320180ae46f7e2c332750ebfbd9d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9926f36760320180ae46f7e2c332750ebfbd9d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0f9926f36760320180ae46f7e2c332750ebfbd9d", "patch": "@@ -23320,6 +23320,159 @@ thumb1_expand_epilogue (void)\n     emit_use (gen_rtx_REG (SImode, LR_REGNUM));\n }\n \n+/* Epilogue code for APCS frame.  */\n+static void\n+arm_expand_epilogue_apcs_frame (bool really_return)\n+{\n+  unsigned long func_type;\n+  unsigned long saved_regs_mask;\n+  int num_regs = 0;\n+  int i;\n+  int floats_from_frame = 0;\n+  arm_stack_offsets *offsets;\n+\n+  gcc_assert (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM);\n+  func_type = arm_current_func_type ();\n+\n+  /* Get frame offsets for ARM.  */\n+  offsets = arm_get_frame_offsets ();\n+  saved_regs_mask = offsets->saved_regs_mask;\n+\n+  /* Find the offset of the floating-point save area in the frame.  */\n+  floats_from_frame = offsets->saved_args - offsets->frame;\n+\n+  /* Compute how many core registers saved and how far away the floats are.  */\n+  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+    if (saved_regs_mask & (1 << i))\n+      {\n+        num_regs++;\n+        floats_from_frame += 4;\n+      }\n+\n+  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+    {\n+      int start_reg;\n+\n+      /* The offset is from IP_REGNUM.  */\n+      int saved_size = arm_get_vfp_saved_size ();\n+      if (saved_size > 0)\n+        {\n+          floats_from_frame += saved_size;\n+          emit_insn (gen_addsi3 (gen_rtx_REG (SImode, IP_REGNUM),\n+                                 hard_frame_pointer_rtx,\n+                                 GEN_INT (-floats_from_frame)));\n+        }\n+\n+      /* Generate VFP register multi-pop.  */\n+      start_reg = FIRST_VFP_REGNUM;\n+\n+      for (i = FIRST_VFP_REGNUM; i < LAST_VFP_REGNUM; i += 2)\n+        /* Look for a case where a reg does not need restoring.  */\n+        if ((!df_regs_ever_live_p (i) || call_used_regs[i])\n+            && (!df_regs_ever_live_p (i + 1)\n+                || call_used_regs[i + 1]))\n+          {\n+            if (start_reg != i)\n+              arm_emit_vfp_multi_reg_pop (start_reg,\n+                                          (i - start_reg) / 2,\n+                                          gen_rtx_REG (SImode,\n+                                                       IP_REGNUM));\n+            start_reg = i + 2;\n+          }\n+\n+      /* Restore the remaining regs that we have discovered (or possibly\n+         even all of them, if the conditional in the for loop never\n+         fired).  */\n+      if (start_reg != i)\n+        arm_emit_vfp_multi_reg_pop (start_reg,\n+                                    (i - start_reg) / 2,\n+                                    gen_rtx_REG (SImode, IP_REGNUM));\n+    }\n+\n+  if (TARGET_IWMMXT)\n+    {\n+      /* The frame pointer is guaranteed to be non-double-word aligned, as\n+         it is set to double-word-aligned old_stack_pointer - 4.  */\n+      rtx insn;\n+      int lrm_count = (num_regs % 2) ? (num_regs + 2) : (num_regs + 1);\n+\n+      for (i = LAST_IWMMXT_REGNUM; i >= FIRST_IWMMXT_REGNUM; i--)\n+        if (df_regs_ever_live_p (i) && !call_used_regs[i])\n+          {\n+            rtx addr = gen_frame_mem (V2SImode,\n+                                 plus_constant (Pmode, hard_frame_pointer_rtx,\n+                                                - lrm_count * 4));\n+            insn = emit_insn (gen_movsi (gen_rtx_REG (V2SImode, i), addr));\n+            REG_NOTES (insn) = alloc_reg_note (REG_CFA_RESTORE,\n+                                               gen_rtx_REG (V2SImode, i),\n+                                               NULL_RTX);\n+            lrm_count += 2;\n+          }\n+    }\n+\n+  /* saved_regs_mask should contain IP which contains old stack pointer\n+     at the time of activation creation.  Since SP and IP are adjacent registers,\n+     we can restore the value directly into SP.  */\n+  gcc_assert (saved_regs_mask & (1 << IP_REGNUM));\n+  saved_regs_mask &= ~(1 << IP_REGNUM);\n+  saved_regs_mask |= (1 << SP_REGNUM);\n+\n+  /* There are two registers left in saved_regs_mask - LR and PC.  We\n+     only need to restore LR (the return address), but to\n+     save time we can load it directly into PC, unless we need a\n+     special function exit sequence, or we are not really returning.  */\n+  if (really_return\n+      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n+      && !crtl->calls_eh_return)\n+    /* Delete LR from the register mask, so that LR on\n+       the stack is loaded into the PC in the register mask.  */\n+    saved_regs_mask &= ~(1 << LR_REGNUM);\n+  else\n+    saved_regs_mask &= ~(1 << PC_REGNUM);\n+\n+  num_regs = bit_count (saved_regs_mask);\n+  if ((offsets->outgoing_args != (1 + num_regs)) || cfun->calls_alloca)\n+    {\n+      /* Unwind the stack to just below the saved registers.  */\n+      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+                             hard_frame_pointer_rtx,\n+                             GEN_INT (- 4 * num_regs)));\n+    }\n+\n+  arm_emit_multi_reg_pop (saved_regs_mask);\n+\n+  if (IS_INTERRUPT (func_type))\n+    {\n+      /* Interrupt handlers will have pushed the\n+         IP onto the stack, so restore it now.  */\n+      rtx insn;\n+      rtx addr = gen_rtx_MEM (SImode,\n+                              gen_rtx_POST_INC (SImode,\n+                              stack_pointer_rtx));\n+      set_mem_alias_set (addr, get_frame_alias_set ());\n+      insn = emit_insn (gen_movsi (gen_rtx_REG (SImode, IP_REGNUM), addr));\n+      REG_NOTES (insn) = alloc_reg_note (REG_CFA_RESTORE,\n+                                         gen_rtx_REG (SImode, IP_REGNUM),\n+                                         NULL_RTX);\n+    }\n+\n+  if (!really_return || (saved_regs_mask & (1 << PC_REGNUM)))\n+    return;\n+\n+  if (crtl->calls_eh_return)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+               stack_pointer_rtx,\n+               GEN_INT (ARM_EH_STACKADJ_REGNUM)));\n+\n+  if (IS_STACKALIGN (func_type))\n+    /* Restore the original stack pointer.  Before prologue, the stack was\n+       realigned and the original stack pointer saved in r0.  For details,\n+       see comment in arm_expand_prologue.  */\n+    emit_insn (gen_movsi (stack_pointer_rtx, gen_rtx_REG (SImode, 0)));\n+\n+  emit_jump_insn (simple_return_rtx);\n+}\n+\n /* Implementation of insn prologue_thumb1_interwork.  This is the first\n    \"instruction\" of a function called in ARM mode.  Swap to thumb mode.  */\n "}, {"sha": "6d2f4abfb4cc18497510044e5ec09623857c3263", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9926f36760320180ae46f7e2c332750ebfbd9d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9926f36760320180ae46f7e2c332750ebfbd9d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0f9926f36760320180ae46f7e2c332750ebfbd9d", "patch": "@@ -724,9 +724,9 @@\n ;;  (plus (reg rN) (reg sp)) into (reg rN).  In this case reload will\n ;; put the duplicated register first, and not try the commutative version.\n (define_insn_and_split \"*arm_addsi3\"\n-  [(set (match_operand:SI          0 \"s_register_operand\" \"=r, k,r,r, k, r, k,r, k, r\")\n-\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%rk,k,r,rk,k, rk,k,rk,k, rk\")\n-\t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI,rI,k,Pj,Pj,L, L,PJ,PJ,?n\")))]\n+  [(set (match_operand:SI          0 \"s_register_operand\" \"=r, k,r,r, k, r, k,k,r, k, r\")\n+\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%rk,k,r,rk,k, rk,k,r,rk,k, rk\")\n+\t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI,rI,k,Pj,Pj,L, L,L,PJ,PJ,?n\")))]\n   \"TARGET_32BIT\"\n   \"@\n    add%?\\\\t%0, %1, %2\n@@ -736,6 +736,7 @@\n    addw%?\\\\t%0, %1, %2\n    sub%?\\\\t%0, %1, #%n2\n    sub%?\\\\t%0, %1, #%n2\n+   sub%?\\\\t%0, %1, #%n2\n    subw%?\\\\t%0, %1, #%n2\n    subw%?\\\\t%0, %1, #%n2\n    #\"\n@@ -750,9 +751,9 @@\n \t\t      operands[1], 0);\n   DONE;\n   \"\n-  [(set_attr \"length\" \"4,4,4,4,4,4,4,4,4,16\")\n+  [(set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,16\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"arch\" \"*,*,*,t2,t2,*,*,t2,t2,*\")]\n+   (set_attr \"arch\" \"*,*,*,t2,t2,*,*,a,t2,t2,*\")]\n )\n \n (define_insn_and_split \"*thumb1_addsi3\""}]}