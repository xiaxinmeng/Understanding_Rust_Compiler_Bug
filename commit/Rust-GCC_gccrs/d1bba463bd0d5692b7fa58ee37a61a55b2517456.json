{"sha": "d1bba463bd0d5692b7fa58ee37a61a55b2517456", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFiYmE0NjNiZDBkNTY5MmI3ZmE1OGVlMzdhNjFhNTViMjUxNzQ1Ng==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-06T22:09:07Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-06T22:09:07Z"}, "message": "c++: Fix constexpr evaluation of pre-increment when !lval [PR99287]\n\nHere, during cxx_eval_increment_expression (with lval=false) of\n++__first where __first is &\"mystr\"[0], we correctly update __first\nto &\"mystr\"[1] but we end up returning &\"mystr\"[0] + 1 instead of\n&\"mystr\"[1].  This unreduced return value inhibits other pointer\narithmetic folding during later constexpr evaluation, which ultimately\ncauses the constexpr evaluation to fail.\n\nIt turns out the simplification of &\"mystr\"[0] + 1 to &\"mystr\"[1]\nis performed by cxx_fold_pointer_plus_expression, not by fold_build2.\nSo we perform this simplification during constexpr evaluation of\nthe temporary MODIFY_EXPR (during which we assign to __first the\nsimplified value), but then we return 'mod' which has only been folded\nvia fold_build2 and hasn't gone through cxx_fold_pointer_plus_expression.\n\nThis patch fixes this by updating 'mod' with the result of the\nMODIFY_EXPR evaluation appropriately, so that it captures any additional\nfolding of the expression when !lval.  We now need to be wary of this\nevaluation failing and returning e.g. the MODIFY_EXPR or NULL_TREE; it\nseems checking *non_constant_p should cover our bases here and is\ngenerally prudent.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/99287\n\t* constexpr.c (cxx_eval_increment_expression): Pass lval when\n\tevaluating the MODIFY_EXPR, and update 'mod' with the result of\n\tthis evaluation.  Check *non_constant_p afterwards.  For prefix\n\tops, just return 'mod'.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/99287\n\t* g++.dg/cpp2a/constexpr-99287.C: New test.\n\nCo-authored-by: Jakub Jelinek <jakub@redhat.com>", "tree": {"sha": "be0148634d2c34eef8a04b6d29afa943ea11844e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be0148634d2c34eef8a04b6d29afa943ea11844e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1bba463bd0d5692b7fa58ee37a61a55b2517456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1bba463bd0d5692b7fa58ee37a61a55b2517456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1bba463bd0d5692b7fa58ee37a61a55b2517456", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1bba463bd0d5692b7fa58ee37a61a55b2517456/comments", "author": null, "committer": null, "parents": [{"sha": "0cc54a68e309df89fb47bc1fa6c23662c45eeacc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cc54a68e309df89fb47bc1fa6c23662c45eeacc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cc54a68e309df89fb47bc1fa6c23662c45eeacc"}], "stats": {"total": 78, "additions": 68, "deletions": 10}, "files": [{"sha": "c94674471b7bac5a71dccc16b0dc015082d9c711", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1bba463bd0d5692b7fa58ee37a61a55b2517456/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1bba463bd0d5692b7fa58ee37a61a55b2517456/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=d1bba463bd0d5692b7fa58ee37a61a55b2517456", "patch": "@@ -5582,20 +5582,17 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n   /* Storing the modified value.  */\n   tree store = build2_loc (cp_expr_loc_or_loc (t, input_location),\n \t\t\t   MODIFY_EXPR, type, op, mod);\n-  cxx_eval_constant_expression (ctx, store,\n-\t\t\t\ttrue, non_constant_p, overflow_p);\n+  mod = cxx_eval_constant_expression (ctx, store, lval,\n+\t\t\t\t      non_constant_p, overflow_p);\n   ggc_free (store);\n+  if (*non_constant_p)\n+    return t;\n \n   /* And the value of the expression.  */\n   if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n-    {\n-      /* Prefix ops are lvalues.  */\n-      if (lval)\n-\treturn op;\n-      else\n-\t/* But we optimize when the caller wants an rvalue.  */\n-\treturn mod;\n-    }\n+    /* Prefix ops are lvalues, but the caller might want an rvalue;\n+       lval has already been taken into account in the store above.  */\n+    return mod;\n   else\n     /* Postfix ops are rvalues.  */\n     return val;"}, {"sha": "c9c2ac2f7c256270e2748cab94a5f8f5109611e5", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-99287.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1bba463bd0d5692b7fa58ee37a61a55b2517456/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-99287.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1bba463bd0d5692b7fa58ee37a61a55b2517456/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-99287.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-99287.C?ref=d1bba463bd0d5692b7fa58ee37a61a55b2517456", "patch": "@@ -0,0 +1,61 @@\n+// PR c++/99287\n+// { dg-do compile { target c++20 } }\n+\n+namespace std {\n+struct source_location {\n+  static consteval source_location\n+  current(const void *__p = __builtin_source_location()) {\n+    source_location __ret;\n+    __ret._M_impl = static_cast<const __impl *>(__p);\n+    return __ret;\n+  }\n+  constexpr const char *function_name() {\n+    return _M_impl ? _M_impl->_M_function_name : \"\";\n+  }\n+  struct __impl {\n+    const char *_M_file_name;\n+    const char *_M_function_name;\n+    unsigned _M_line;\n+    unsigned _M_column;\n+  } const *_M_impl;\n+};\n+struct char_traits {\n+  static constexpr long length(const char *__s) {\n+    return __builtin_strlen(__s);\n+  }\n+};\n+template <typename _CharT, typename _Traits = char_traits>\n+class basic_string_view {\n+public:\n+  using traits_type = _Traits;\n+  using size_type = unsigned long;\n+  constexpr basic_string_view(const _CharT *__str)\n+      : _M_len{traits_type::length(__str)}, _M_str{__str} {}\n+  constexpr size_type find(const _CharT *, size_type, size_type) const noexcept;\n+  constexpr size_type find(_CharT *__str) {\n+    long __trans_tmp_1 = traits_type::length(__str);\n+    return find(__str, 0, __trans_tmp_1);\n+  }\n+  long _M_len;\n+  const _CharT *_M_str;\n+};\n+using string_view = basic_string_view<const char>;\n+template <typename _CharT, typename _Traits>\n+constexpr unsigned long\n+basic_string_view<_CharT, _Traits>::find(const _CharT *__str, size_type,\n+                                         size_type __n) const noexcept {\n+  int __trans_tmp_2;\n+  const _CharT *__first = _M_str;\n+  size_type __len = _M_len;\n+  while (__len >= __n) {\n+    __trans_tmp_2 = __builtin_memcmp(__first, __str, __n);\n+    if (__trans_tmp_2 == 0)\n+      return __first - _M_str;\n+    __len = _M_str - ++__first;\n+  }\n+}\n+} // namespace std\n+template <typename> consteval auto f() {\n+  return std::string_view{std::source_location::current().function_name()};\n+}\n+int main() { constexpr auto s = f<int>().find(\"int\"); }"}]}