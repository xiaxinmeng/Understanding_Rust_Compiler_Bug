{"sha": "c9632a3b4362ac9edba382b0f57d7dbd040819d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk2MzJhM2I0MzYyYWM5ZWRiYTM4MmIwZjU3ZDdkYmQwNDA4MTlkMA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T20:10:47Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T20:10:47Z"}, "message": "Initial revision\n\nFrom-SVN: r12270", "tree": {"sha": "634ecd0fae9fa0672f0cb7204f5b1a9f328acec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/634ecd0fae9fa0672f0cb7204f5b1a9f328acec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9632a3b4362ac9edba382b0f57d7dbd040819d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9632a3b4362ac9edba382b0f57d7dbd040819d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9632a3b4362ac9edba382b0f57d7dbd040819d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9632a3b4362ac9edba382b0f57d7dbd040819d0/comments", "author": null, "committer": null, "parents": [{"sha": "c10d53dd60b1aa82fa460b70f16b791b54f7d116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10d53dd60b1aa82fa460b70f16b791b54f7d116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c10d53dd60b1aa82fa460b70f16b791b54f7d116"}], "stats": {"total": 441, "additions": 441, "deletions": 0}, "files": [{"sha": "ac4b0f029329769cb1563093552bdc498c9f369c", "filename": "gcc/pexecute.c", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9632a3b4362ac9edba382b0f57d7dbd040819d0/gcc%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9632a3b4362ac9edba382b0f57d7dbd040819d0/gcc%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpexecute.c?ref=c9632a3b4362ac9edba382b0f57d7dbd040819d0", "patch": "@@ -0,0 +1,441 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* This file exports two functions: pexecute and pwait.  */\n+\n+/* This file lives in at least two places: libiberty and gcc.\n+   Don't change one without the other.  */\n+\n+/* ??? The usage of execv/spawnv vs execvp/spawnvp seems backwards.  */\n+\n+#include <stdio.h>\n+#include <errno.h>\n+\n+#ifdef IN_GCC\n+#include \"config.h\"\n+#include \"gansidecl.h\"\n+/* ??? Need to find a suitable header file.  */\n+#define PEXECUTE_FIRST  1\n+#define PEXECUTE_LAST   2\n+#define PEXECUTE_ONE    (PEXECUTE_FIRST + PEXECUTE_LAST)\n+#define PEXECUTE_SEARCH 4\n+#else\n+#include \"libiberty.h\"\n+#endif\n+\n+/* stdin file number.  */\n+#define STDIN_FILE_NO 0\n+\n+/* stdout file number.  */\n+#define STDOUT_FILE_NO 1\n+\n+/* value of `pipe': port index for reading.  */\n+#define READ_PORT 0\n+\n+/* value of `pipe': port index for writing.  */\n+#define WRITE_PORT 1\n+\n+static char *install_error_msg = \"installation problem, cannot exec `%s'\";\n+\n+/* pexecute: execute a program.\n+\n+   PROGRAM and ARGV are the arguments to execv/execvp.\n+\n+   THIS_PNAME is name of the calling program (i.e. argv[0]).\n+\n+   TEMP_BASE is the path name, sans suffix, of a temporary file to use\n+   if needed.  This is currently only needed for MSDOS ports that don't use\n+   GO32 (do any still exist?).  Ports that don't need it can pass NULL.\n+\n+   (FLAGS & PEXECUTE_SEARCH) is non-zero if $PATH should be searched\n+   (??? It's not clear that GCC passes this flag correctly).\n+   (FLAGS & PEXECUTE_FIRST) is nonzero for the first process in chain.\n+   (FLAGS & PEXECUTE_FIRST) is nonzero for the last process in chain.\n+   FIRST_LAST could be simplified to only mark the last of a chain of processes\n+   but that requires the caller to always mark the last one (and not give up\n+   early if some error occurs).  It's more robust to require the caller to\n+   mark both ends of the chain.\n+\n+   The result is the pid on systems like Unix where we fork/exec and on systems\n+   like WIN32 and OS2 where we use spawn.  It is up to the caller to wait for\n+   the child.\n+\n+   The result is the WEXITSTATUS on systems like MSDOS where we spawn and wait\n+   for the child here.\n+\n+   Upon failure, ERRMSG_FMT and ERRMSG_ARG are set to the text of the error\n+   message with an optional argument (if not needed, ERRMSG_ARG is set to\n+   NULL), and -1 is returned.  `errno' is available to the caller to use.\n+\n+   pwait: cover function for wait.\n+\n+   PID is the process id of the task to wait for.\n+   STATUS is the `status' argument to wait.\n+   FLAGS is currently unused (allows future enhancement without breaking\n+   upward compatibility).  Pass 0 for now.\n+\n+   The result is the pid of the child reaped,\n+   or -1 for failure (errno says why).\n+\n+   On systems that don't support waiting for a particular child, PID is\n+   ignored.  On systems like MSDOS that don't really multitask pwait\n+   is just a mechanism to provide a consistent interface for the caller.\n+*/\n+\n+#ifdef __MSDOS__\n+\n+/* MSDOS doesn't multitask, but for the sake of a consistent interface\n+   the code behaves like it does.  pexecute runs the program, tucks the\n+   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n+   exit code.  */\n+\n+#include <process.h>\n+\n+/* For communicating information from pexecute to pwait.  */\n+static int last_pid = 0;\n+static int last_status = 0;\n+static int last_reaped = 0;\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int rc;\n+\n+  last_pid++;\n+  if (last_pid < 0)\n+    last_pid = 1;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+\n+#ifdef __GO32__\n+  /* ??? What are the possible return values from spawnv?  */\n+  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);\n+#else\n+  char *scmd, *rf;\n+  FILE *argfile;\n+  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;\n+\n+  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);\n+  rf = scmd + strlen(program) + 2 + el;\n+  sprintf (scmd, \"%s%s @%s.gp\", program,\n+\t   (flags & PEXECUTE_SEARCH ? \".exe\" : \"\"), temp_base);\n+  argfile = fopen (rf, \"w\");\n+  if (argfile == 0)\n+    {\n+      int errno_save = errno;\n+      free (scmd);\n+      errno = errno_save;\n+      *errmsg_fmt = \"cannot open `%s.gp'\";\n+      *errmsg_arg = temp_base;\n+      return -1;\n+    }\n+\n+  for (i=1; argv[i]; i++)\n+    {\n+      char *cp;\n+      for (cp = argv[i]; *cp; cp++)\n+\t{\n+\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || isspace (*cp))\n+\t    fputc ('\\\\', argfile);\n+\t  fputc (*cp, argfile);\n+\t}\n+      fputc ('\\n', argfile);\n+    }\n+  fclose (argfile);\n+\n+  rc = system (scmd);\n+\n+  {\n+    int errno_save = errno;\n+    remove (rf);\n+    free (scmd);\n+    errno = errno_save;\n+  }\n+#endif\n+\n+  if (rc == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+\n+  /* Tuck the status away for pwait, and return a \"pid\".  */\n+  last_status = rc << 8;\n+  return last_pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* On MSDOS each pexecute must be followed by it's associated pwait.  */\n+  if (pid != last_pid\n+      /* Called twice for the same child?  */\n+      || pid == last_reaped)\n+    {\n+      /* ??? ECHILD would be a better choice.  Can we use it here?  */\n+      errno = EINVAL;\n+      return -1;\n+    }\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  *status = last_status;\n+  last_reaped = last_pid;\n+  return last_pid;\n+}\n+\n+#endif /* MSDOS */\n+\n+#ifdef _WIN32\n+\n+#include <process.h>\n+/* ??? Why are these __spawnv{,p} and not _spawnv{,p}?  */\n+extern int __spawnv ();\n+extern int __spawnvp ();\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int pid;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+  pid = (flags & PEXECUTE_SEARCH ? __spawnvp : __spawnv) (_P_NOWAIT, program, argv);\n+  if (pid == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+  return pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  int pid = cwait (status, pid, WAIT_CHILD);\n+  return pid;\n+}\n+\n+#endif /* WIN32 */\n+\n+#ifdef OS2\n+\n+/* ??? Does OS2 have process.h?  */\n+extern int spawnv ();\n+extern int spawnvp ();\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int pid;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+  /* ??? Presumably 1 == _P_NOWAIT.  */\n+  pid = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);\n+  if (pid == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+  return pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  int pid = wait (status);\n+  return pid;\n+}\n+\n+#endif /* OS2 */\n+\n+#if ! defined (__MSDOS__) && ! defined (_WIN32) && ! defined (OS2)\n+\n+#ifdef USG\n+#define vfork fork\n+#endif\n+\n+extern int execv ();\n+extern int execvp ();\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);\n+  int pid;\n+  int pdes[2];\n+  int input_desc, output_desc;\n+  int retries, sleep_interval;\n+  /* Pipe waiting from last process, to be used as input for the next one.\n+     Value is STDIN_FILE_NO if no pipe is waiting\n+     (i.e. the next command is the first of a group).  */\n+  static int last_pipe_input;\n+\n+  /* If this is the first process, initialize.  */\n+  if (flags & PEXECUTE_FIRST)\n+    last_pipe_input = STDIN_FILE_NO;\n+\n+  input_desc = last_pipe_input;\n+\n+  /* If this isn't the last process, make a pipe for its output,\n+     and record it as waiting to be the input to the next process.  */\n+  if (! (flags & PEXECUTE_LAST))\n+    {\n+      if (pipe (pdes) < 0)\n+\t{\n+\t  *errmsg_fmt = \"pipe\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+      output_desc = pdes[WRITE_PORT];\n+      last_pipe_input = pdes[READ_PORT];\n+    }\n+  else\n+    {\n+      /* Last process.  */\n+      output_desc = STDOUT_FILE_NO;\n+      last_pipe_input = STDIN_FILE_NO;\n+    }\n+\n+  /* Fork a subprocess; wait and retry if it fails.  */\n+  sleep_interval = 1;\n+  for (retries = 0; retries < 4; retries++)\n+    {\n+      pid = vfork ();\n+      if (pid >= 0)\n+\tbreak;\n+      sleep (sleep_interval);\n+      sleep_interval *= 2;\n+    }\n+\n+  switch (pid)\n+    {\n+    case -1:\n+      {\n+#ifdef vfork\n+\t*errmsg_fmt = \"fork\";\n+#else\n+\t*errmsg_fmt = \"vfork\";\n+#endif\n+\t*errmsg_arg = NULL;\n+\treturn -1;\n+      }\n+\n+    case 0: /* child */\n+      /* Move the input and output pipes into place, if necessary.  */\n+      if (input_desc != STDIN_FILE_NO)\n+\t{\n+\t  close (STDIN_FILE_NO);\n+\t  dup (input_desc);\n+\t  close (input_desc);\n+\t}\n+      if (output_desc != STDOUT_FILE_NO)\n+\t{\n+\t  close (STDOUT_FILE_NO);\n+\t  dup (output_desc);\n+\t  close (output_desc);\n+\t}\n+\n+      /* Close the parent's descs that aren't wanted here.  */\n+      if (last_pipe_input != STDIN_FILE_NO)\n+\tclose (last_pipe_input);\n+\n+      /* Exec the program.  */\n+      (*func) (program, argv);\n+\n+      /* Note: Calling fprintf and exit here doesn't seem right for vfork.  */\n+      fprintf (stderr, \"%s: \", this_pname);\n+      fprintf (stderr, install_error_msg, program);\n+#ifdef IN_GCC\n+      fprintf (stderr, \": %s\\n\", my_strerror (errno));\n+#else\n+      fprintf (stderr, \": %s\\n\", xstrerror (errno));\n+#endif\n+      exit (-1);\n+      /* NOTREACHED */\n+      return 0;\n+\n+    default:\n+      /* In the parent, after forking.\n+\t Close the descriptors that we made for this child.  */\n+      if (input_desc != STDIN_FILE_NO)\n+\tclose (input_desc);\n+      if (output_desc != STDOUT_FILE_NO)\n+\tclose (output_desc);\n+\n+      /* Return child's process number.  */\n+      return pid;\n+    }\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  pid = wait (status);\n+  return pid;\n+}\n+\n+#endif /* !MSDOS && !WIN32 && !OS2 */"}]}