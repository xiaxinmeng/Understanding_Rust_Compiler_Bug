{"sha": "f35be1268c996d993ab0b4ff329734d467474445", "node_id": "C_kwDOANBUbNoAKGYzNWJlMTI2OGM5OTZkOTkzYWIwYjRmZjMyOTczNGQ0Njc0NzQ0NDU", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-09-21T23:26:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-09-22T13:28:19Z"}, "message": "cmd/cgo: add and use runtime/cgo.Incomplete instead of //go:notinheap\n\nThis ports https://go.dev/cl/421879 to libgo. This is a quick port to\nupdate gofrontend to work with the version of cgo in gc mainline.\nA more complete port will follow, changing the gc version of cmd/cgo to\nchoose an approach based on feature testing the gccgo in use.\n\nUpdates golang/go#46731\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/432338", "tree": {"sha": "0c12b075c51c0d5097f26953835ae540d9f2f501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c12b075c51c0d5097f26953835ae540d9f2f501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35be1268c996d993ab0b4ff329734d467474445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35be1268c996d993ab0b4ff329734d467474445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35be1268c996d993ab0b4ff329734d467474445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35be1268c996d993ab0b4ff329734d467474445/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44dba051d72587828882cbb31118934a4fb06c1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44dba051d72587828882cbb31118934a4fb06c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44dba051d72587828882cbb31118934a4fb06c1a"}], "stats": {"total": 119, "additions": 67, "deletions": 52}, "files": [{"sha": "f7a7985287da779f04a9204862d6ea802021790b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35be1268c996d993ab0b4ff329734d467474445/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35be1268c996d993ab0b4ff329734d467474445/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f35be1268c996d993ab0b4ff329734d467474445", "patch": "@@ -1,4 +1,4 @@\n-6543b7fc6da533eb976b37649a925e7fd5a521fa\n+42efec8c126cf3787bc7c89d9c7f224eff7c5a21\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e786aeaafa9d9cff9d719c673e68a11abcf3f762", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=f35be1268c996d993ab0b4ff329734d467474445", "patch": "@@ -132,12 +132,11 @@ func (p *Package) addToFlag(flag string, args []string) {\n //\n // For example, the following string:\n //\n-//     `a b:\"c d\" 'e''f'  \"g\\\"\"`\n+//\t`a b:\"c d\" 'e''f'  \"g\\\"\"`\n //\n // Would be parsed as:\n //\n-//     []string{\"a\", \"b:c d\", \"ef\", `g\"`}\n-//\n+//\t[]string{\"a\", \"b:c d\", \"ef\", `g\"`}\n func splitQuoted(s string) (r []string, err error) {\n \tvar args []string\n \targ := make([]rune, len(s))\n@@ -1156,13 +1155,19 @@ func (p *Package) mangle(f *File, arg *ast.Expr, addPosition bool) (ast.Expr, bo\n \n // checkIndex checks whether arg has the form &a[i], possibly inside\n // type conversions. If so, then in the general case it writes\n-//    _cgoIndexNN := a\n-//    _cgoNN := &cgoIndexNN[i] // with type conversions, if any\n+//\n+//\t_cgoIndexNN := a\n+//\t_cgoNN := &cgoIndexNN[i] // with type conversions, if any\n+//\n // to sb, and writes\n-//    _cgoCheckPointer(_cgoNN, _cgoIndexNN)\n+//\n+//\t_cgoCheckPointer(_cgoNN, _cgoIndexNN)\n+//\n // to sbCheck, and returns true. If a is a simple variable or field reference,\n // it writes\n-//    _cgoIndexNN := &a\n+//\n+//\t_cgoIndexNN := &a\n+//\n // and dereferences the uses of _cgoIndexNN. Taking the address avoids\n // making a copy of an array.\n //\n@@ -1210,10 +1215,14 @@ func (p *Package) checkIndex(sb, sbCheck *bytes.Buffer, arg ast.Expr, i int) boo\n \n // checkAddr checks whether arg has the form &x, possibly inside type\n // conversions. If so, it writes\n-//    _cgoBaseNN := &x\n-//    _cgoNN := _cgoBaseNN // with type conversions, if any\n+//\n+//\t_cgoBaseNN := &x\n+//\t_cgoNN := _cgoBaseNN // with type conversions, if any\n+//\n // to sb, and writes\n-//    _cgoCheckPointer(_cgoBaseNN, true)\n+//\n+//\t_cgoCheckPointer(_cgoBaseNN, true)\n+//\n // to sbCheck, and returns true. This tells _cgoCheckPointer to check\n // just the contents of the pointer being passed, not any other part\n // of the memory allocation. This is run after checkIndex, which looks\n@@ -2131,8 +2140,8 @@ type typeConv struct {\n \t// Type names X for which there exists an XGetTypeID function with type func() CFTypeID.\n \tgetTypeIDs map[string]bool\n \n-\t// badStructs contains C structs that should be marked NotInHeap.\n-\tnotInHeapStructs map[string]bool\n+\t// incompleteStructs contains C structs that should be marked Incomplete.\n+\tincompleteStructs map[string]bool\n \n \t// Predeclared types.\n \tbool                                   ast.Expr\n@@ -2145,7 +2154,6 @@ type typeConv struct {\n \tstring                                 ast.Expr\n \tgoVoid                                 ast.Expr // _Ctype_void, denotes C's void\n \tgoVoidPtr                              ast.Expr // unsafe.Pointer or *byte\n-\tgoVoidPtrNoHeap                        ast.Expr // *_Ctype_void_notinheap, like goVoidPtr but marked NotInHeap\n \n \tptrSize int64\n \tintSize int64\n@@ -2169,7 +2177,7 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.m = make(map[string]*Type)\n \tc.ptrs = make(map[string][]*Type)\n \tc.getTypeIDs = make(map[string]bool)\n-\tc.notInHeapStructs = make(map[string]bool)\n+\tc.incompleteStructs = make(map[string]bool)\n \tc.bool = c.Ident(\"bool\")\n \tc.byte = c.Ident(\"byte\")\n \tc.int8 = c.Ident(\"int8\")\n@@ -2188,7 +2196,6 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.void = c.Ident(\"void\")\n \tc.string = c.Ident(\"string\")\n \tc.goVoid = c.Ident(\"_Ctype_void\")\n-\tc.goVoidPtrNoHeap = c.Ident(\"*_Ctype_void_notinheap\")\n \n \t// Normally cgo translates void* to unsafe.Pointer,\n \t// but for historical reasons -godefs uses *byte instead.\n@@ -2531,19 +2538,13 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\t// other than try to determine a Go representation.\n \t\t\ttt := *t\n \t\t\ttt.C = &TypeRepr{\"%s %s\", []interface{}{dt.Kind, tag}}\n-\t\t\ttt.Go = c.Ident(\"struct{}\")\n-\t\t\tif dt.Kind == \"struct\" {\n-\t\t\t\t// We don't know what the representation of this struct is, so don't let\n-\t\t\t\t// anyone allocate one on the Go side. As a side effect of this annotation,\n-\t\t\t\t// pointers to this type will not be considered pointers in Go. They won't\n-\t\t\t\t// get writebarrier-ed or adjusted during a stack copy. This should handle\n-\t\t\t\t// all the cases badPointerTypedef used to handle, but hopefully will\n-\t\t\t\t// continue to work going forward without any more need for cgo changes.\n-\t\t\t\ttt.NotInHeap = true\n-\t\t\t\t// TODO: we should probably do the same for unions. Unions can't live\n-\t\t\t\t// on the Go heap, right? It currently doesn't work for unions because\n-\t\t\t\t// they are defined as a type alias for struct{}, not a defined type.\n-\t\t\t}\n+\t\t\t// We don't know what the representation of this struct is, so don't let\n+\t\t\t// anyone allocate one on the Go side. As a side effect of this annotation,\n+\t\t\t// pointers to this type will not be considered pointers in Go. They won't\n+\t\t\t// get writebarrier-ed or adjusted during a stack copy. This should handle\n+\t\t\t// all the cases badPointerTypedef used to handle, but hopefully will\n+\t\t\t// continue to work going forward without any more need for cgo changes.\n+\t\t\ttt.Go = c.Ident(\"_cgopackage.Incomplete\")\n \t\t\ttypedef[name.Name] = &tt\n \t\t\tbreak\n \t\t}\n@@ -2569,7 +2570,9 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\t\ttt.C = &TypeRepr{\"struct %s\", []interface{}{tag}}\n \t\t\t}\n \t\t\ttt.Go = g\n-\t\t\ttt.NotInHeap = c.notInHeapStructs[tag]\n+\t\t\tif c.incompleteStructs[tag] {\n+\t\t\t\ttt.Go = c.Ident(\"_cgopackage.Incomplete\")\n+\t\t\t}\n \t\t\ttypedef[name.Name] = &tt\n \t\t}\n \n@@ -2614,32 +2617,31 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\t}\n \t\t}\n \t\tif c.badVoidPointerTypedef(dt) {\n-\t\t\t// Treat this typedef as a pointer to a NotInHeap void.\n+\t\t\t// Treat this typedef as a pointer to a _cgopackage.Incomplete.\n \t\t\ts := *sub\n-\t\t\ts.Go = c.goVoidPtrNoHeap\n+\t\t\ts.Go = c.Ident(\"*_cgopackage.Incomplete\")\n \t\t\tsub = &s\n \t\t\t// Make sure we update any previously computed type.\n \t\t\tif oldType := typedef[name.Name]; oldType != nil {\n \t\t\t\toldType.Go = sub.Go\n \t\t\t}\n \t\t}\n \t\t// Check for non-pointer \"struct <tag>{...}; typedef struct <tag> *<name>\"\n-\t\t// typedefs that should be marked NotInHeap.\n+\t\t// typedefs that should be marked Incomplete.\n \t\tif ptr, ok := dt.Type.(*dwarf.PtrType); ok {\n \t\t\tif strct, ok := ptr.Type.(*dwarf.StructType); ok {\n \t\t\t\tif c.badStructPointerTypedef(dt.Name, strct) {\n-\t\t\t\t\tc.notInHeapStructs[strct.StructName] = true\n+\t\t\t\t\tc.incompleteStructs[strct.StructName] = true\n \t\t\t\t\t// Make sure we update any previously computed type.\n \t\t\t\t\tname := \"_Ctype_struct_\" + strct.StructName\n \t\t\t\t\tif oldType := typedef[name]; oldType != nil {\n-\t\t\t\t\t\toldType.NotInHeap = true\n+\t\t\t\t\t\toldType.Go = c.Ident(\"_cgopackage.Incomplete\")\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tt.Go = name\n \t\tt.BadPointer = sub.BadPointer\n-\t\tt.NotInHeap = sub.NotInHeap\n \t\tif unionWithPointer[sub.Go] {\n \t\t\tunionWithPointer[t.Go] = true\n \t\t}\n@@ -2650,7 +2652,6 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\ttt := *t\n \t\t\ttt.Go = sub.Go\n \t\t\ttt.BadPointer = sub.BadPointer\n-\t\t\ttt.NotInHeap = sub.NotInHeap\n \t\t\ttypedef[name.Name] = &tt\n \t\t}\n \n@@ -3174,7 +3175,7 @@ func (c *typeConv) anonymousStructTypedef(dt *dwarf.TypedefType) bool {\n // non-pointers in this type.\n // TODO: Currently our best solution is to find these manually and list them as\n // they come up. A better solution is desired.\n-// Note: DEPRECATED. There is now a better solution. Search for NotInHeap in this file.\n+// Note: DEPRECATED. There is now a better solution. Search for _cgopackage.Incomplete in this file.\n func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \tif c.badCFType(dt) {\n \t\treturn true\n@@ -3188,7 +3189,7 @@ func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool {\n \treturn false\n }\n \n-// badVoidPointerTypedef is like badPointerTypeDef, but for \"void *\" typedefs that should be NotInHeap.\n+// badVoidPointerTypedef is like badPointerTypeDef, but for \"void *\" typedefs that should be _cgopackage.Incomplete.\n func (c *typeConv) badVoidPointerTypedef(dt *dwarf.TypedefType) bool {\n \t// Match the Windows HANDLE type (#42018).\n \tif goos != \"windows\" || dt.Name != \"HANDLE\" {"}, {"sha": "186aef06c0801628e19e69a00277aa4d284261ae", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=f35be1268c996d993ab0b4ff329734d467474445", "patch": "@@ -153,7 +153,6 @@ type Type struct {\n \tEnumValues map[string]int64\n \tTypedef    string\n \tBadPointer bool // this pointer type should be represented as a uintptr (deprecated)\n-\tNotInHeap  bool // this type should have a go:notinheap annotation\n }\n \n // A FuncType collects information about a function type in both the C and Go worlds."}, {"sha": "9ed88b84974c1aa80f707b3eb50a94dd2706eab0", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=f35be1268c996d993ab0b4ff329734d467474445", "patch": "@@ -85,11 +85,14 @@ func (p *Package) writeDefs() {\n \tfmt.Fprintf(fgo2, \"// Code generated by cmd/cgo; DO NOT EDIT.\\n\\n\")\n \tfmt.Fprintf(fgo2, \"package %s\\n\\n\", p.PackageName)\n \tfmt.Fprintf(fgo2, \"import \\\"unsafe\\\"\\n\\n\")\n-\tif !*gccgo && *importRuntimeCgo {\n-\t\tfmt.Fprintf(fgo2, \"import _ \\\"runtime/cgo\\\"\\n\\n\")\n-\t}\n \tif *importSyscall {\n \t\tfmt.Fprintf(fgo2, \"import \\\"syscall\\\"\\n\\n\")\n+\t}\n+\tif *importRuntimeCgo {\n+\t\tfmt.Fprintf(fgo2, \"import _cgopackage \\\"runtime/cgo\\\"\\n\\n\")\n+\t\tfmt.Fprintf(fgo2, \"type _ _cgopackage.Incomplete\\n\") // prevent import-not-used error\n+\t}\n+\tif *importSyscall {\n \t\tfmt.Fprintf(fgo2, \"var _ syscall.Errno\\n\")\n \t}\n \tfmt.Fprintf(fgo2, \"func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }\\n\\n\")\n@@ -113,9 +116,6 @@ func (p *Package) writeDefs() {\n \tsort.Strings(typedefNames)\n \tfor _, name := range typedefNames {\n \t\tdef := typedef[name]\n-\t\tif def.NotInHeap {\n-\t\t\tfmt.Fprintf(fgo2, \"//go:notinheap\\n\")\n-\t\t}\n \t\tfmt.Fprintf(fgo2, \"type %s \", name)\n \t\t// We don't have source info for these types, so write them out without source info.\n \t\t// Otherwise types would look like:\n@@ -140,7 +140,6 @@ func (p *Package) writeDefs() {\n \t\tfmt.Fprintf(fgo2, \"%s\", buf.Bytes())\n \t\tfmt.Fprintf(fgo2, \"\\n\\n\")\n \t}\n-\tfmt.Fprintf(fgo2, \"//go:notinheap\\ntype _Ctype_void_notinheap struct{}\\n\\n\")\n \tif *gccgo {\n \t\tfmt.Fprintf(fgo2, \"type _Ctype_void byte\\n\")\n \t} else {"}, {"sha": "9c5c0a1ce261cf109e9f50f7c7a95aa584f8b34b", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=f35be1268c996d993ab0b4ff329734d467474445", "patch": "@@ -1818,7 +1818,7 @@ func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *\n \t\tif p.UsesCgo() {\n \t\t\taddImport(\"unsafe\", true)\n \t\t}\n-\t\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) && cfg.BuildContext.Compiler != \"gccgo\" {\n+\t\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) {\n \t\t\taddImport(\"runtime/cgo\", true)\n \t\t}\n \t\tif p.UsesCgo() && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n@@ -1828,9 +1828,7 @@ func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *\n \t\t// SWIG adds imports of some standard packages.\n \t\tif p.UsesSwig() {\n \t\t\taddImport(\"unsafe\", true)\n-\t\t\tif cfg.BuildContext.Compiler != \"gccgo\" {\n-\t\t\t\taddImport(\"runtime/cgo\", true)\n-\t\t\t}\n+\t\t\taddImport(\"runtime/cgo\", true)\n \t\t\taddImport(\"syscall\", true)\n \t\t\taddImport(\"sync\", true)\n \n@@ -2455,7 +2453,7 @@ func LinkerDeps(p *Package) []string {\n \tdeps := []string{\"runtime\"}\n \n \t// External linking mode forces an import of runtime/cgo.\n-\tif externalLinkingForced(p) && cfg.BuildContext.Compiler != \"gccgo\" {\n+\tif externalLinkingForced(p) {\n \t\tdeps = append(deps, \"runtime/cgo\")\n \t}\n \t// On ARM with GOARM=5, it forces an import of math, for soft floating point."}, {"sha": "5921435696bc6a8885429c088453bf676e21d107", "filename": "libgo/go/runtime/cgo/cgo.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fruntime%2Fcgo%2Fcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35be1268c996d993ab0b4ff329734d467474445/libgo%2Fgo%2Fruntime%2Fcgo%2Fcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo%2Fcgo.go?ref=f35be1268c996d993ab0b4ff329734d467474445", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Package cgo contains runtime support for code generated\n+by the cgo tool.  See the documentation for the cgo command\n+for details on using cgo.\n+*/\n+package cgo\n+\n+// Incomplete is used specifically for the semantics of incomplete C types.\n+//\n+//go:notinheap\n+type Incomplete struct {\n+\t//\t_ sys.NotInHeap\n+\t_ struct{ _ struct{} }\n+}"}]}