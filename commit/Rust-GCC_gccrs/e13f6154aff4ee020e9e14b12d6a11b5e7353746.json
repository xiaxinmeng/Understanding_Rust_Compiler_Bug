{"sha": "e13f6154aff4ee020e9e14b12d6a11b5e7353746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzZjYxNTRhZmY0ZWUwMjBlOWUxNGIxMmQ2YTExYjVlNzM1Mzc0Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-17T00:52:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-17T00:52:30Z"}, "message": "i370.c (mvs_add_label): Change spacing for coding conventions.\n\n        * i370.c (mvs_add_label): Change spacing for coding conventions.\n        * i370.h (ASM_OUTPUT_CASE_LABEL): Change to the data CSECT for the\n        outputing case vectors.\n        (ASM_OUTPUT_CASE_END): New, put assembler back into code CSECT.\n        (ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Remove page check,\n        since vector in in the data CSECT.\n        (ASM_OUTPUT_REG_POP, ASM_OUTPUT_REG_PUSH): Restore to correct operation.        * i370.md (Many patterns): Put the length in the XL directives.\n        (movdi): Put back STM and MVC in definition.\n        (floatsidf2): Correct TARGET_ELF_ABI pattern and add back the LE370\n        pattern using the TCA.\n        * oe.h (CPP_SPEC): Added to allow trigraphs.\n        * xm-oe.h (HOST_BITS_PER_LONGLONG): Change to 32. IBM's compiler does\n        not support the \"long long\" type.\n\nFrom-SVN: r33191", "tree": {"sha": "d3181b3fc2c2a72427c62c0cf2e6c8052d12b23f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3181b3fc2c2a72427c62c0cf2e6c8052d12b23f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e13f6154aff4ee020e9e14b12d6a11b5e7353746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e13f6154aff4ee020e9e14b12d6a11b5e7353746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e13f6154aff4ee020e9e14b12d6a11b5e7353746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e13f6154aff4ee020e9e14b12d6a11b5e7353746/comments", "author": null, "committer": null, "parents": [{"sha": "954869eb3bd32ca1230512deab5a76c826324b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954869eb3bd32ca1230512deab5a76c826324b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954869eb3bd32ca1230512deab5a76c826324b73"}], "stats": {"total": 97, "additions": 49, "deletions": 48}, "files": [{"sha": "8d00f7330c50aeadc8b545a42903fcb1fb7c41eb", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=e13f6154aff4ee020e9e14b12d6a11b5e7353746", "patch": "@@ -645,7 +645,7 @@ mvs_add_label (id)\n \n   fwd_distance = lp->label_last_ref - lp->label_addr;\n \n-  if (mvs_page_code + 2*fwd_distance + mvs_page_lit < 4060) return;\n+  if (mvs_page_code + 2 * fwd_distance + mvs_page_lit < 4060) return;\n \n   mvs_need_base_reload ++;\n }"}, {"sha": "88f5dd1264b21cb2136bd7f155a114ff019fad8b", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=e13f6154aff4ee020e9e14b12d6a11b5e7353746", "patch": "@@ -1160,23 +1160,29 @@ enum reg_class\n   fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM);\t\t\t\\\n }\n \n-/* Generate case label.  */\n-/* hack alert -- I don't get it ... what if its a really big case label?\n- * wouldn't we have to say label_emitted also ?? */\n+/* Generate case label.  For HLASM we can change to the data CSECT\n+   and put the vectors out of the code body. The assembler just\n+   concatenates CSECTs with the same name. */\n \n #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n-   fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n+  fprintf (FILE,\"\\tCSECT\\n\");                                           \\\n+  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n+\n+/* Put the CSECT back to the code body */\n+\n+#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n+  assemble_name (FILE, mvs_function_name);                              \\\n+  fputs (\"\\tCSECT\\n\", FILE);\n \n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n-  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tA(L%d)\\n\", VALUE)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n \n /* This is how to output an insn to push a register on the stack.\n@@ -1188,21 +1194,17 @@ enum reg_class\n \n #define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n   mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tSXXX\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n+  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n      reg_names[REGNO], STACK_POINTER_OFFSET)\n \n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n #define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n   mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLAXXX\\t13,4(13)\\n\",\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n      reg_names[REGNO], STACK_POINTER_OFFSET)\n \n-/* TBD: hack alert XXX  these two float point macros print horribly\n-   incorrect things when run in cross-compiler mode. Thats's because\n-   in cross-compiler mode, the VALUE is not really a double.  See below,\n-   in the ELF section, for the correct implementation.  */\n /* This is how to output an assembler line defining a `double' constant.  */\n #define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tD'%.18G'\\n\", (VALUE))"}, {"sha": "97081957f9fe1b529d3bc7eaa9d7a675e053a23f", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=e13f6154aff4ee020e9e14b12d6a11b5e7353746", "patch": "@@ -170,7 +170,7 @@\n     {\n       /* an unsigned compare to zero is always zero/not-zero... */\n       mvs_check_page (0, 4, 4);\n-      return \\\"N\t%0,=X'000000FF'\\\";\n+      return \\\"N\t%0,=XL4'000000FF'\\\";\n     }\n   mvs_check_page (0, 4, 0);\n   return \\\"CLI\t%0,0\\\";\n@@ -189,7 +189,7 @@\n     {\n       /* an unsigned compare to zero is always zero/not-zero... */\n       mvs_check_page (0, 4, 4);\n-      return \\\"N\t%0,=X'000000FF'\\\";\n+      return \\\"N\t%0,=XL4'000000FF'\\\";\n     }\n   mvs_check_page (0, 8, 0);\n   return \\\"SLL\t%0,24\\;SRA\t%0,24\\\";\n@@ -348,7 +348,7 @@\n       if (GET_CODE (operands[1]) == CONST_INT)\n \t{\n \t  mvs_check_page (0, 4, 1);\n-          return \\\"CLM\t%0,1,=X'%X1'\\\";\n+          return \\\"CLM\t%0,1,=XL1'%X1'\\\";\n         }\n       mvs_check_page (0, 4, 0);\n       return \\\"CLM\t%0,1,%1\\\";\n@@ -359,7 +359,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  mvs_check_page (0, 4, 1);\n-          return \\\"CLM\t%1,1,=X'%X0'\\\";\n+          return \\\"CLM\t%1,1,=XL1'%X0'\\\";\n         }\n       mvs_check_page (0, 4, 0);\n       return \\\"CLI\t%1,%B0\\\";\n@@ -394,7 +394,7 @@\n       if (GET_CODE (operands[1]) == CONST_INT)\n \t{\n \t  mvs_check_page (0, 4, 1);\n-          return \\\"CLM\t%0,1,=X'%X1'\\\";\n+          return \\\"CLM\t%0,1,=XL1'%X1'\\\";\n         }\n       if (!(REG_P (operands[1])))\n \t{\n@@ -648,9 +648,7 @@ check_label_emit ();\n   else if (REG_P (operands[1]))\n     {\n       mvs_check_page (0, 4, 0);\n-      /* can't use stm otherwise stm r6,r7,0(r10,r13) can happen */\n       return \\\"STM\t%1,%N1,%0\\\"; \n-      /* return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\"; */\n     }\n   mvs_check_page (0, 6, 0);\n   return \\\"MVC\t%O0(8,%R0),%W1\\\";\n@@ -706,17 +704,8 @@ check_label_emit ();\n       mvs_check_page (0, 4, 0);\n       return \\\"STD\t%1,%0\\\";\n     }\n-  else if (REG_P (operands[1]))\n-    {\n-      /* hack alert -- for some reason, %N0 doesn't work \n-       * when the mem ref is e.g. 168(r13,r1) ...  \n-       * add 4 and pray for the best .. */\n-      mvs_check_page (0, 8, 0);\n-      return \\\"ST\t%1,%0\\;ST\t%N1,4+%N0\\\";\n-    }\n-  /* this is almost certainly not what is desired, let it break ... */\n-  mvs_check_page (0, 8, 0);\n-  return \\\"xxxST\t%1,%0\\;ST\t%N1,%N0\\\";\n+  mvs_check_page (0, 4, 0);\n+  return \\\"STM\t%1,%N1,%0\\\";\n }\"\n    [(set_attr \"length\" \"8\")]\n )\n@@ -740,16 +729,15 @@ check_label_emit ();\n   if (REG_P (operands[0]))\n     {\n       mvs_check_page (0, 8, 0);\n-      return \\\"L\t%0,%1\\;L\t%N0,4+%N1\\\";\n+      return \\\"LM\t%0,%N0,%1\\\";\n     }\n   else if (REG_P (operands[1]))\n     {\n       mvs_check_page (0, 8, 0);\n-      return \\\"ST\t%1,%0\\;ST\t%N1,4+%N0\\\";\n+      return \\\"STM\t%1,%N1,%0\\\";\n     }\n   mvs_check_page (0, 6, 0);\n-  /* should never get here ... */\n-  return \\\"xxxxxxMVC\t%O0(8,%R0),%W1\\\";\n+  return \\\"MVC\t%O0(8,%R0),%1\\\";\n }\"\n    [(set_attr \"length\" \"8\")]\n )\n@@ -1200,7 +1188,7 @@ check_label_emit ();\n       return \\\"STM\t%1,%N1,%0\\\";\n     }\n   mvs_check_page (0, 6, 0);\n-  return \\\"MVC\t%O0(8,%R0),%W1\\\";\n+  return \\\"MVC\t%O0(8,%R0),%1\\\";\n }\"\n    [(set_attr \"length\" \"12\")]\n )\n@@ -1715,7 +1703,7 @@ check_label_emit ();\n   /* AND only sets zero/not-zero bits not the arithmetic bits ... */\n   CC_STATUS_INIT;\n   mvs_check_page (0, 4, 4);\n-  return \\\"N\t%1,=X'0000FFFF'\\\";\n+  return \\\"N\t%1,=XL4'0000FFFF'\\\";\n }\"\n    [(set_attr \"length\" \"4\")]\n )\n@@ -1736,7 +1724,7 @@ check_label_emit ();\n       /* AND only sets zero/not-zero bits not the arithmetic bits ... */\n       CC_STATUS_INIT;\n       mvs_check_page (0, 4, 4);\n-      return \\\"N\t%0,=X'000000FF'\\\";\n+      return \\\"N\t%0,=XL4'000000FF'\\\";\n     }\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n@@ -1766,7 +1754,7 @@ check_label_emit ();\n       /* AND only sets zero/not-zero bits not the arithmetic bits ... */\n       CC_STATUS_INIT;\n       mvs_check_page (0, 4, 4);\n-      return \\\"N\t%0,=X'000000FF'\\\";\n+      return \\\"N\t%0,=XL4'000000FF'\\\";\n     }\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n@@ -1830,6 +1818,8 @@ check_label_emit ();\n ;\n ; floatsidf2 instruction pattern(s).\n ;\n+; LE/370 mode uses the float field of the TCA.\n+;\n \n (define_insn \"floatsidf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n@@ -1839,10 +1829,15 @@ check_label_emit ();\n {\n   check_label_emit ();\n   CC_STATUS_INIT;\n+#ifdef TARGET_ELF_ABI\n+  mvs_check_page (0, 22, 12);\n+  return \\\"MVC  140(4,13),=XL4'4E000000'\\;ST\t%1,144(,13)\\;XI\t144(13),128\\;LD\t%0,140(,13)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n+#else\n   mvs_check_page (0, 16, 8);\n-  return \\\"ST\t%1,144(,13)\\;XI\t144(13),128\\;LD\t%0,140(,13)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n+  return \\\"ST\t%1,508(,12)\\;XI\t508(12),128\\;LD\t%0,504(,12)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n+#endif\n }\"\n-   [(set_attr \"length\" \"16\")]\n+   [(set_attr \"length\" \"22\")]\n )\n \n ;\n@@ -2419,7 +2414,7 @@ check_label_emit ();\n \n       /* XXX trouble.  Below we generate some rtx's that model what\n        * is really supposed to happen with multiply on the 370/390\n-       * hardware, and that is all well & god.  However, during optimization\n+       * hardware, and that is all well & good.  However, during optimization\n        * it can happen that the two operands are exchanged (after all, \n        * multiplication is commutitive), in which case the doubleword\n        * ends up in memory and everything is hosed.  The gen_reg_rtx\n@@ -3579,7 +3574,7 @@ check_label_emit ();\n       return \\\"X\t%0,=F'-1'\\\";\n     }\n   mvs_check_page (0, 6, 4);\n-  return \\\"XC\t%O0(2,%R0),=X'FFFF'\\\";\n+  return \\\"XC\t%O0(2,%R0),=XL4'FFFF'\\\";\n }\"\n   [(set_attr \"length\" \"6\")]\n )\n@@ -3867,10 +3862,10 @@ check_label_emit ();\n   if (REG_P (operands[2]))\n     {\n       mvs_check_page (0, 8, 4);\n-      return \\\"N\t%0,=X'0000FFFF'\\;SRL\t%0,0(%2)\\\";\n+      return \\\"N\t%0,=XL4'0000FFFF'\\;SRL\t%0,0(%2)\\\";\n     }\n   mvs_check_page (0, 8, 4);\n-  return \\\"N\t%0,=X'0000FFFF'\\;SRL\t%0,%c2\\\";\n+  return \\\"N\t%0,=XL4'0000FFFF'\\;SRL\t%0,%c2\\\";\n }\"\n   [(set_attr \"length\" \"8\")]\n )\n@@ -3890,8 +3885,8 @@ check_label_emit ();\n   CC_STATUS_INIT; /* AND sets the CC but not how we want it */\n   mvs_check_page (0, 8, 4);\n   if (REG_P (operands[2])) \n-    return \\\"N\t%0,=X'000000FF'\\;SRL\t%0,0(%2)\\\";\n-  return \\\"N\t%0,=X'000000FF'\\;SRL\t%0,%c2\\\";\n+    return \\\"N\t%0,=XL4'000000FF'\\;SRL\t%0,0(%2)\\\";\n+  return \\\"N\t%0,=XL4'000000FF'\\;SRL\t%0,%c2\\\";\n }\"\n   [(set_attr \"length\" \"8\")]\n )"}, {"sha": "634252ee65bd6a744314abb9c336d289516c3460", "filename": "gcc/config/i370/oe.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Foe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Foe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Foe.h?ref=e13f6154aff4ee020e9e14b12d6a11b5e7353746", "patch": "@@ -29,6 +29,10 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_EBCDIC 1\n #define TARGET_HLASM 1\n \n+/* Options for the preprocessor for this target machine.  */\n+\n+#define CPP_SPEC \"-trigraphs\"\n+\n /* Options for this target machine.  */\n \n #define LIB_SPEC \"\""}, {"sha": "a930a2bae61e5bc6af73735acba86321fe018f3e", "filename": "gcc/config/i370/xm-oe.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fxm-oe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f6154aff4ee020e9e14b12d6a11b5e7353746/gcc%2Fconfig%2Fi370%2Fxm-oe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fxm-oe.h?ref=e13f6154aff4ee020e9e14b12d6a11b5e7353746", "patch": "@@ -34,7 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #define HOST_BITS_PER_SHORT\t16\n #define HOST_BITS_PER_INT\t32\n #define HOST_BITS_PER_LONG\t32\n-#define HOST_BITS_PER_LONGLONG\t64\n+#define HOST_BITS_PER_LONGLONG\t32\n #define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n #define HOST_EBCDIC\t\t1\n "}]}