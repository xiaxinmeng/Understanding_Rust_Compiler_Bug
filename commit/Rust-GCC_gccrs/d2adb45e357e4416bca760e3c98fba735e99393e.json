{"sha": "d2adb45e357e4416bca760e3c98fba735e99393e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJhZGI0NWUzNTdlNDQxNmJjYTc2MGUzYzk4ZmJhNzM1ZTk5MzkzZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-13T10:23:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-06-13T10:23:05Z"}, "message": "[multiple changes]\n\n2014-06-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* errout.adb (SPARK_Msg_N): New routine.\n\t(SPARK_Msg_NE): New routine.\n\t* errout.ads Add a section on SPARK-related error routines.\n\t(SPARK_Msg_N): New routine.\n\t(SPARK_Msg_NE): New routine.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Ensure that\n\tpragma Abstract_State is always inserted after SPARK_Mode.\n\t(Insert_After_SPARK_Mode): New routine.\n\t* sem_prag.adb (Analyze_Abstract_State,\n\tAnalyze_Constituent, Analyze_External_Property,\n\tAnalyze_External_Property_In_Decl_Part, Analyze_Global_Item,\n\tAnalyze_Global_List, Analyze_Initialization_Item,\n\tAnalyze_Initialization_Item_With_Inputs, Analyze_Input_Item,\n\tAnalyze_Input_List, Analyze_Input_Output, Analyze_Part_Of,\n\tAnalyze_Pragma, Analyze_Refined_Depends_In_Decl_Part,\n\tAnalyze_Refined_Global_In_Decl_Part,\n\tAnalyze_Refined_State_In_Decl_Part, Analyze_Refinement_Clause,\n\tCheck_Aspect_Specification_Order, Check_Constituent_Usage,\n\tCheck_Declaration_Order, Check_Dependency_Clause,\n\tCheck_Duplicate_Mode, Check_Duplicate_Option,\n\tCheck_Duplicate_Property, Check_External_Properties,\n\tCheck_External_Property, Check_Function_Return,\n\tCheck_Matching_Constituent, Check_Matching_State,\n\tCheck_Mode_Restriction_In_Enclosing_Context,\n\tCheck_Mode_Restriction_In_Function, Check_Refined_Global_Item,\n\tCheck_State_And_Constituent_Use, Create_Or_Modify_Clause,\n\tHas_Extra_Parentheses, Inconsistent_Mode_Error,\n\tMatch_Error, Propagate_Part_Of, Report_Extra_Clauses,\n\tReport_Extra_Constituents_In_List, Report_Extra_Inputs,\n\tReport_Unrefined_States, Report_Unused_Constituents,\n\tReport_Unused_States, Role_Error, Usage_Error):\n\tConvert Error_Msg_XXX calls to SPARK_Msg_XXX calls\n\tto report semantic errors only when SPARK_Mode is on.\n\t(Analyze_Depends_In_Decl_Part): Do not check the syntax of\n\tpragma Depends explicitly, this is now done by the analysis.\n\t(Analyze_Global_In_Decl_List): Do not check the syntax of\n\tpragma Global explicitly, this is now done by the analysis.\n\t(Analyze_Initializes_In_Decl_Part): Do not check the syntax of\n\tpragma Initializes explicitly, this is now done by the analysis.\n\t(Analyze_Part_Of): Do not check the syntax of the encapsulating\n\tstate, this is now done by the analysis.\n\t(Analyze_Pragma): Do\n\tnot check the syntax of a state declaration, this is now done\n\tby the analysis.\n\t(Analyze_Refined_Depends_In_Decl_Part): Do not\n\tcheck the syntax of pragma Refined_Depends explicitly, this is now\n\tdone by the analysis.\n\t(Analyze_Refined_Global_In_Decl_Part): Do\n\tnot check the syntax of pragma Refined_Global explicitly, this is\n\tnow done by the analysis.\n\t(Analyze_Refined_State_In_Decl_Part):\n\tDo not check the syntax of pragma Refined_State explicitly, this\n\tis now done by the analysis.\n\t(Check_Dependence_List_Syntax): Removed.\n\t(Check_Global_List_Syntax): Removed.\n\t(Check_Initialization_List_Syntax): Removed.\n\t(Check_Item_Syntax): Removed.\n\t(Check_Missing_Part_Of): Do not consider items from an instance.\n\t(Check_Refinement_List_Syntax): Removed.\n\t(Check_State_Declaration_Syntax): Removed.\n\t(Collect_Global_List): Do not raise Program_Error when the input is\n\tmalformed.\n\t(Process_Global_List): Do not raise Program_Error when the input\n\tis malformed.\n\t* sem_ch13.adb: Minor reformatting.\n2014-06-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Find_Type_Name): Diagnose a private type completion\n\tthat is an interface definition with an interface list.\n\t(Process_Full_View): Move error message on missmatched interfaces\n\tbetween views to the declaration of full view, for clarity.\n\t* sem_ch9.adb (Check_Interfaces): Move error message to full view,\n\tfor clarity.\n\nFrom-SVN: r211626", "tree": {"sha": "93f40ade93fdafebba80ead301dbccf38c7846cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93f40ade93fdafebba80ead301dbccf38c7846cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2adb45e357e4416bca760e3c98fba735e99393e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2adb45e357e4416bca760e3c98fba735e99393e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2adb45e357e4416bca760e3c98fba735e99393e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2adb45e357e4416bca760e3c98fba735e99393e/comments", "author": null, "committer": null, "parents": [{"sha": "6aa4c5b68dbf3723a24d831f1340c91327211e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa4c5b68dbf3723a24d831f1340c91327211e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa4c5b68dbf3723a24d831f1340c91327211e5f"}], "stats": {"total": 992, "additions": 377, "deletions": 615}, "files": [{"sha": "1760db5d39f72634687dbf724c80732d5c932e8c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -1,3 +1,79 @@\n+2014-06-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* errout.adb (SPARK_Msg_N): New routine.\n+\t(SPARK_Msg_NE): New routine.\n+\t* errout.ads Add a section on SPARK-related error routines.\n+\t(SPARK_Msg_N): New routine.\n+\t(SPARK_Msg_NE): New routine.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Ensure that\n+\tpragma Abstract_State is always inserted after SPARK_Mode.\n+\t(Insert_After_SPARK_Mode): New routine.\n+\t* sem_prag.adb (Analyze_Abstract_State,\n+\tAnalyze_Constituent, Analyze_External_Property,\n+\tAnalyze_External_Property_In_Decl_Part, Analyze_Global_Item,\n+\tAnalyze_Global_List, Analyze_Initialization_Item,\n+\tAnalyze_Initialization_Item_With_Inputs, Analyze_Input_Item,\n+\tAnalyze_Input_List, Analyze_Input_Output, Analyze_Part_Of,\n+\tAnalyze_Pragma, Analyze_Refined_Depends_In_Decl_Part,\n+\tAnalyze_Refined_Global_In_Decl_Part,\n+\tAnalyze_Refined_State_In_Decl_Part, Analyze_Refinement_Clause,\n+\tCheck_Aspect_Specification_Order, Check_Constituent_Usage,\n+\tCheck_Declaration_Order, Check_Dependency_Clause,\n+\tCheck_Duplicate_Mode, Check_Duplicate_Option,\n+\tCheck_Duplicate_Property, Check_External_Properties,\n+\tCheck_External_Property, Check_Function_Return,\n+\tCheck_Matching_Constituent, Check_Matching_State,\n+\tCheck_Mode_Restriction_In_Enclosing_Context,\n+\tCheck_Mode_Restriction_In_Function, Check_Refined_Global_Item,\n+\tCheck_State_And_Constituent_Use, Create_Or_Modify_Clause,\n+\tHas_Extra_Parentheses, Inconsistent_Mode_Error,\n+\tMatch_Error, Propagate_Part_Of, Report_Extra_Clauses,\n+\tReport_Extra_Constituents_In_List, Report_Extra_Inputs,\n+\tReport_Unrefined_States, Report_Unused_Constituents,\n+\tReport_Unused_States, Role_Error, Usage_Error):\n+\tConvert Error_Msg_XXX calls to SPARK_Msg_XXX calls\n+\tto report semantic errors only when SPARK_Mode is on.\n+\t(Analyze_Depends_In_Decl_Part): Do not check the syntax of\n+\tpragma Depends explicitly, this is now done by the analysis.\n+\t(Analyze_Global_In_Decl_List): Do not check the syntax of\n+\tpragma Global explicitly, this is now done by the analysis.\n+\t(Analyze_Initializes_In_Decl_Part): Do not check the syntax of\n+\tpragma Initializes explicitly, this is now done by the analysis.\n+\t(Analyze_Part_Of): Do not check the syntax of the encapsulating\n+\tstate, this is now done by the analysis.\n+\t(Analyze_Pragma): Do\n+\tnot check the syntax of a state declaration, this is now done\n+\tby the analysis.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Do not\n+\tcheck the syntax of pragma Refined_Depends explicitly, this is now\n+\tdone by the analysis.\n+\t(Analyze_Refined_Global_In_Decl_Part): Do\n+\tnot check the syntax of pragma Refined_Global explicitly, this is\n+\tnow done by the analysis.\n+\t(Analyze_Refined_State_In_Decl_Part):\n+\tDo not check the syntax of pragma Refined_State explicitly, this\n+\tis now done by the analysis.\n+\t(Check_Dependence_List_Syntax): Removed.\n+\t(Check_Global_List_Syntax): Removed.\n+\t(Check_Initialization_List_Syntax): Removed.\n+\t(Check_Item_Syntax): Removed.\n+\t(Check_Missing_Part_Of): Do not consider items from an instance.\n+\t(Check_Refinement_List_Syntax): Removed.\n+\t(Check_State_Declaration_Syntax): Removed.\n+\t(Collect_Global_List): Do not raise Program_Error when the input is\n+\tmalformed.\n+\t(Process_Global_List): Do not raise Program_Error when the input\n+\tis malformed.\n+\t* sem_ch13.adb: Minor reformatting.\n+2014-06-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Find_Type_Name): Diagnose a private type completion\n+\tthat is an interface definition with an interface list.\n+\t(Process_Full_View): Move error message on missmatched interfaces\n+\tbetween views to the declaration of full view, for clarity.\n+\t* sem_ch9.adb (Check_Interfaces): Move error message to full view,\n+\tfor clarity.\n+\n 2014-06-13  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_attr.adb (Expand_N_Attribute_Reference, case Pred/Succ): Change"}, {"sha": "3a037a40cb94eaae7cb230c2e8eaa951cc7de5b1", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -3065,6 +3065,32 @@ package body Errout is\n       return False;\n    end Special_Msg_Delete;\n \n+   -----------------\n+   -- SPARK_Msg_N --\n+   -----------------\n+\n+   procedure SPARK_Msg_N (Msg : String; N : Node_Or_Entity_Id) is\n+   begin\n+      if SPARK_Mode = On then\n+         Error_Msg_N (Msg, N);\n+      end if;\n+   end SPARK_Msg_N;\n+\n+   ------------------\n+   -- SPARK_Msg_NE --\n+   ------------------\n+\n+   procedure SPARK_Msg_NE\n+     (Msg : String;\n+      N   : Node_Or_Entity_Id;\n+      E   : Node_Or_Entity_Id)\n+   is\n+   begin\n+      if SPARK_Mode = On then\n+         Error_Msg_NE (Msg, N, E);\n+      end if;\n+   end SPARK_Msg_NE;\n+\n    --------------------------\n    -- Unwind_Internal_Type --\n    --------------------------"}, {"sha": "a6b7a2bcbddc4b6d934d89c7d3d631fc71983fa1", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -908,6 +908,29 @@ package Errout is\n    procedure dmsg (Id : Error_Msg_Id) renames Erroutc.dmsg;\n    --  Debugging routine to dump an error message\n \n+   ------------------------------------\n+   -- SPARK Error Output Subprograms --\n+   ------------------------------------\n+\n+   --  The following routines are intended to report semantic errors in SPARK\n+   --  constructs subject to aspect/pragma SPARK_Mode. Note that syntax errors\n+   --  must be reported using the Error_Msg_XXX routines. This allows for the\n+   --  partial analysis of SPARK features when they are disabled via SPARK_Mode\n+   --  set to \"off\".\n+\n+   procedure SPARK_Msg_N (Msg : String; N : Node_Or_Entity_Id);\n+   pragma Inline (SPARK_Msg_N);\n+   --  Same as Error_Msg_N, but the error is reported only when SPARK_Mode is\n+   --  \"on\". The routine is inlined because it acts as a simple wrapper.\n+\n+   procedure SPARK_Msg_NE\n+     (Msg : String;\n+      N   : Node_Or_Entity_Id;\n+      E   : Node_Or_Entity_Id);\n+   pragma Inline (SPARK_Msg_NE);\n+   --  Same as Error_Msg_NE, but the error is reported only when SPARK_Mode is\n+   --  \"on\". The routine is inlined because it acts as a simple wrapper.\n+\n    ------------------------------------\n    -- Utility Interface for Back End --\n    ------------------------------------"}, {"sha": "149826f2519e33e80e37eecb88e26a63b51135d9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -2007,10 +2007,51 @@ package body Sem_Ch13 is\n                --  immediately.\n \n                when Aspect_Abstract_State => Abstract_State : declare\n+                  procedure Insert_After_SPARK_Mode\n+                    (Ins_Nod : Node_Id;\n+                     Decls   : List_Id);\n+                  --  Insert Aitem before node Ins_Nod. If Ins_Nod denotes\n+                  --  pragma SPARK_Mode, then SPARK_Mode is skipped. Decls is\n+                  --  the associated declarative list where Aitem is to reside.\n+\n+                  -----------------------------\n+                  -- Insert_After_SPARK_Mode --\n+                  -----------------------------\n+\n+                  procedure Insert_After_SPARK_Mode\n+                    (Ins_Nod : Node_Id;\n+                     Decls   : List_Id)\n+                  is\n+                     Decl : Node_Id := Ins_Nod;\n+\n+                  begin\n+                     --  Skip SPARK_Mode\n+\n+                     if Present (Decl)\n+                       and then Nkind (Decl) = N_Pragma\n+                       and then Pragma_Name (Decl) = Name_SPARK_Mode\n+                     then\n+                        Decl := Next (Decl);\n+                     end if;\n+\n+                     if Present (Decl) then\n+                        Insert_Before (Decl, Aitem);\n+\n+                     --  Aitem acts as the last declaration\n+\n+                     else\n+                        Append_To (Decls, Aitem);\n+                     end if;\n+                  end Insert_After_SPARK_Mode;\n+\n+                  --  Local variables\n+\n                   Context : Node_Id := N;\n                   Decl    : Node_Id;\n                   Decls   : List_Id;\n \n+               --  Start of processing for Abstract_State\n+\n                begin\n                   --  When aspect Abstract_State appears on a generic package,\n                   --  it is propageted to the package instance. The context in\n@@ -2061,17 +2102,20 @@ package body Sem_Ch13 is\n                               Decl := Next (Decl);\n                            end loop;\n \n-                           if Present (Decl) then\n-                              Insert_Before (Decl, Aitem);\n-                           else\n-                              Append_To (Decls, Aitem);\n-                           end if;\n+                           --  Pragma Abstract_State must be inserted after\n+                           --  pragma SPARK_Mode in the tree. This ensures that\n+                           --  any error messages dependent on SPARK_Mode will\n+                           --  be properly enabled/suppressed.\n+\n+                           Insert_After_SPARK_Mode (Decl, Decls);\n \n                         --  The related package is not a generic instance, the\n-                        --  corresponding pragma must be the first declaration.\n+                        --  corresponding pragma must be the first declaration\n+                        --  except when SPARK_Mode is already in the list. In\n+                        --  that case pragma Abstract_State is placed second.\n \n                         else\n-                           Prepend_To (Decls, Aitem);\n+                           Insert_After_SPARK_Mode (First (Decls), Decls);\n                         end if;\n \n                      --  Otherwise the pragma forms a new declarative list"}, {"sha": "b899e0116bc76bec2ff6b67e82aa4704b8d1cf7c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -15599,8 +15599,10 @@ package body Sem_Ch3 is\n \n                elsif Nkind (N) = N_Full_Type_Declaration\n                  and then\n-                   Nkind (Type_Definition (N)) = N_Record_Definition\n-                 and then Interface_Present (Type_Definition (N))\n+                   (Nkind (Type_Definition (N)) = N_Record_Definition\n+                     or else Nkind (Type_Definition (N))\n+                                 = N_Derived_Type_Definition)\n+                      and then Interface_Present (Type_Definition (N))\n                then\n                   Error_Msg_N\n                     (\"completion of private type cannot be an interface\", N);\n@@ -18307,8 +18309,8 @@ package body Sem_Ch3 is\n \n             if Present (Iface) then\n                Error_Msg_NE\n-                 (\"interface & not implemented by full type \" &\n-                  \"(RM-2005 7.3 (7.3/2))\", Priv_T, Iface);\n+                 (\"interface in partial view& not implemented by full type \" &\n+                  \"(RM-2005 7.3 (7.3/2))\", Full_T, Iface);\n             end if;\n \n             Iface := Find_Hidden_Interface (Full_T_Ifaces, Priv_T_Ifaces);"}, {"sha": "be4642788390e60dba33e815a9c73272854e0ae7", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -3327,8 +3327,8 @@ package body Sem_Ch9 is\n \n                if Present (Iface) then\n                   Error_Msg_NE\n-                    (\"interface & not implemented by full type \" &\n-                     \"(RM-2005 7.3 (7.3/2))\", Priv_T, Iface);\n+                    (\"interface in partial view& not implemented by full \"\n+                      & \"type (RM-2005 7.3 (7.3/2))\", T, Iface);\n                end if;\n \n                Iface := Find_Hidden_Interface (Full_T_Ifaces, Priv_T_Ifaces);"}, {"sha": "8aad039df813b016def3187d4aec321443ae385b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 193, "deletions": 602, "changes": 795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2adb45e357e4416bca760e3c98fba735e99393e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d2adb45e357e4416bca760e3c98fba735e99393e", "patch": "@@ -184,19 +184,6 @@ package body Sem_Prag is\n    --  whether a particular item appears in a mixed list of nodes and entities.\n    --  It is assumed that all nodes in the list have entities.\n \n-   procedure Check_Dependence_List_Syntax (List : Node_Id);\n-   --  Subsidiary to the analysis of pragmas Depends and Refined_Depends.\n-   --  Verify the syntax of dependence relation List.\n-\n-   procedure Check_Global_List_Syntax (List : Node_Id);\n-   --  Subsidiary to the analysis of pragmas Global and Refined_Global. Verify\n-   --  the syntax of global list List.\n-\n-   procedure Check_Item_Syntax (Item : Node_Id);\n-   --  Subsidiary to the analysis of pragmas Depends, Global, Initializes,\n-   --  Part_Of, Refined_Depends, Refined_Depends and Refined_State. Verify the\n-   --  syntax of a SPARK annotation item.\n-\n    function Check_Kind (Nam : Name_Id) return Name_Id;\n    --  This function is used in connection with pragmas Assert, Check,\n    --  and assertion aspects and pragmas, to determine if Check pragmas\n@@ -674,7 +661,7 @@ package body Sem_Prag is\n \n             if Nkind (Inputs) = N_Aggregate then\n                if Present (Component_Associations (Inputs)) then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"nested dependency relations not allowed\", Inputs);\n \n                elsif Present (Expressions (Inputs)) then\n@@ -692,6 +679,8 @@ package body Sem_Prag is\n                      Next (Input);\n                   end loop;\n \n+               --  Syntax error, always report\n+\n                else\n                   Error_Msg_N (\"malformed input dependency list\", Inputs);\n                end if;\n@@ -714,7 +703,7 @@ package body Sem_Prag is\n             --    (null =>[+] null)\n \n             if Null_Output_Seen and then Null_Input_Seen then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"null dependency clause cannot have a null input list\",\n                   Inputs);\n             end if;\n@@ -742,10 +731,10 @@ package body Sem_Prag is\n \n             if Nkind (Item) = N_Aggregate then\n                if not Top_Level then\n-                  Error_Msg_N (\"nested grouping of items not allowed\", Item);\n+                  SPARK_Msg_N (\"nested grouping of items not allowed\", Item);\n \n                elsif Present (Component_Associations (Item)) then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"nested dependency relations not allowed\", Item);\n \n                --  Recursively analyze the grouped items\n@@ -765,6 +754,8 @@ package body Sem_Prag is\n                      Next (Grouped);\n                   end loop;\n \n+               --  Syntax error, always report\n+\n                else\n                   Error_Msg_N (\"malformed dependency list\", Item);\n                end if;\n@@ -787,18 +778,18 @@ package body Sem_Prag is\n                  or else Entity (Prefix (Item)) /= Spec_Id\n                then\n                   Error_Msg_Name_1 := Name_Result;\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"prefix of attribute % must denote the enclosing \"\n                      & \"function\", Item);\n \n                --  Function'Result is allowed to appear on the output side of a\n                --  dependency clause (SPARK RM 6.1.5(6)).\n \n                elsif Is_Input then\n-                  Error_Msg_N (\"function result cannot act as input\", Item);\n+                  SPARK_Msg_N (\"function result cannot act as input\", Item);\n \n                elsif Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix null and non-null dependency items\", Item);\n \n                else\n@@ -811,27 +802,27 @@ package body Sem_Prag is\n \n             elsif Nkind (Item) = N_Null then\n                if Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"multiple null dependency relations not allowed\", Item);\n \n                elsif Non_Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix null and non-null dependency items\", Item);\n \n                else\n                   Null_Seen := True;\n \n                   if Is_Output then\n                      if not Is_Last then\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"null output list must be the last clause in a \"\n                            & \"dependency relation\", Item);\n \n                      --  Catch a useless dependence of the form:\n                      --    null =>+ ...\n \n                      elsif Self_Ref then\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"useless dependence, null depends on itself\", Item);\n                      end if;\n                   end if;\n@@ -843,7 +834,7 @@ package body Sem_Prag is\n                Non_Null_Seen := True;\n \n                if Null_Seen then\n-                  Error_Msg_N (\"cannot mix null and non-null items\", Item);\n+                  SPARK_Msg_N (\"cannot mix null and non-null items\", Item);\n                end if;\n \n                Analyze       (Item);\n@@ -873,7 +864,7 @@ package body Sem_Prag is\n                      --  item to the list of processed relations.\n \n                      if Contains (Seen, Item_Id) then\n-                        Error_Msg_NE\n+                        SPARK_Msg_NE\n                           (\"duplicate use of item &\", Item, Item_Id);\n                      else\n                         Add_Item (Item_Id, Seen);\n@@ -887,7 +878,7 @@ package body Sem_Prag is\n                        and then Null_Output_Seen\n                        and then Contains (All_Inputs_Seen, Item_Id)\n                      then\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"input of a null output list cannot appear in \"\n                            & \"multiple input lists\", Item);\n                      end if;\n@@ -903,10 +894,10 @@ package body Sem_Prag is\n \n                      if Ekind (Item_Id) = E_Abstract_State then\n                         if Has_Visible_Refinement (Item_Id) then\n-                           Error_Msg_NE\n+                           SPARK_Msg_NE\n                              (\"cannot mention state & in global refinement\",\n                               Item, Item_Id);\n-                           Error_Msg_N\n+                           SPARK_Msg_N\n                              (\"\\use its constituents instead\", Item);\n                            return;\n \n@@ -948,18 +939,17 @@ package body Sem_Prag is\n                   --  (SPARK RM 6.1.5(1)).\n \n                   else\n-                     Error_Msg_N\n+                     SPARK_Msg_N\n                        (\"item must denote parameter, variable, or state\",\n                         Item);\n                   end if;\n \n                --  All other input/output items are illegal\n-               --  (SPARK RM 6.1.5(1))\n+               --  (SPARK RM 6.1.5(1)). This is a syntax error, always report.\n \n                else\n                   Error_Msg_N\n-                    (\"item must denote parameter, variable, or state\",\n-                     Item);\n+                    (\"item must denote parameter, variable, or state\", Item);\n                end if;\n             end if;\n          end Analyze_Input_Output;\n@@ -1015,7 +1005,7 @@ package body Sem_Prag is\n       procedure Check_Function_Return is\n       begin\n          if Ekind (Spec_Id) = E_Function and then not Result_Seen then\n-            Error_Msg_NE\n+            SPARK_Msg_NE\n               (\"result of & must appear in exactly one output list\",\n                N, Spec_Id);\n          end if;\n@@ -1164,10 +1154,10 @@ package body Sem_Prag is\n                  (\" & cannot appear in dependence relation\");\n \n                Error_Msg := Name_Find;\n-               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n+               SPARK_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n \n                Error_Msg_Name_1 := Chars (Subp_Id);\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"\\& is not part of the input or output set of subprogram %\",\n                   Item, Item_Id);\n \n@@ -1194,7 +1184,7 @@ package body Sem_Prag is\n \n                Add_Str_To_Name_Buffer (\" in dependence relation\");\n                Error_Msg := Name_Find;\n-               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n+               SPARK_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n             end if;\n          end Role_Error;\n \n@@ -1266,7 +1256,7 @@ package body Sem_Prag is\n                     (\" & must appear in at least one input dependence list\");\n \n                   Error_Msg := Name_Find;\n-                  Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n+                  SPARK_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n                end if;\n \n             --  Output case (SPARK RM 6.1.5(10))\n@@ -1279,7 +1269,7 @@ package body Sem_Prag is\n                  (\" & must appear in exactly one output dependence list\");\n \n                Error_Msg := Name_Find;\n-               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n+               SPARK_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n             end if;\n          end Usage_Error;\n \n@@ -1486,7 +1476,7 @@ package body Sem_Prag is\n             --  appear in the input list of a relation (SPARK RM 6.1.5(10)).\n \n             elsif Is_Attribute_Result (Output) then\n-               Error_Msg_N (\"function result cannot depend on itself\", Output);\n+               SPARK_Msg_N (\"function result cannot depend on itself\", Output);\n                return;\n             end if;\n \n@@ -1683,14 +1673,6 @@ package body Sem_Prag is\n    begin\n       Set_Analyzed (N);\n \n-      --  Verify the syntax of pragma Depends when SPARK checks are suppressed.\n-      --  Semantic analysis and normalization are disabled in this mode.\n-\n-      if SPARK_Mode = Off then\n-         Check_Dependence_List_Syntax (Deps);\n-         return;\n-      end if;\n-\n       Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n       Subp_Id   := Defining_Entity (Subp_Decl);\n \n@@ -1809,14 +1791,16 @@ package body Sem_Prag is\n             Check_Usage (Subp_Outputs, All_Outputs_Seen, False);\n             Check_Function_Return;\n \n-         --  The dependency list is malformed\n+         --  The dependency list is malformed. This is a syntax error, always\n+         --  report.\n \n          else\n             Error_Msg_N (\"malformed dependency relation\", Deps);\n             return;\n          end if;\n \n-      --  The top level dependency relation is malformed\n+      --  The top level dependency relation is malformed. This is a syntax\n+      --  error, always report.\n \n       else\n          Error_Msg_N (\"malformed dependency relation\", Deps);\n@@ -1855,10 +1839,10 @@ package body Sem_Prag is\n            and then Present (Entity (Obj))\n            and then Is_Formal (Entity (Obj))\n          then\n-            Error_Msg_N (\"external property % cannot apply to parameter\", N);\n+            SPARK_Msg_N (\"external property % cannot apply to parameter\", N);\n          end if;\n       else\n-         Error_Msg_N\n+         SPARK_Msg_N\n            (\"external property % must apply to a volatile object\", N);\n       end if;\n \n@@ -1874,7 +1858,7 @@ package body Sem_Prag is\n             Expr_Val := Is_True (Expr_Value (Expr));\n          else\n             Error_Msg_Name_1 := Pragma_Name (N);\n-            Error_Msg_N (\"expression of % must be static\", Expr);\n+            SPARK_Msg_N (\"expression of % must be static\", Expr);\n          end if;\n       end if;\n    end Analyze_External_Property_In_Decl_Part;\n@@ -1969,7 +1953,7 @@ package body Sem_Prag is\n             --    with Global => (Name, null)\n \n             if Nkind (Item) = N_Null then\n-               Error_Msg_N (\"cannot mix null and non-null global items\", Item);\n+               SPARK_Msg_N (\"cannot mix null and non-null global items\", Item);\n                return;\n             end if;\n \n@@ -1990,7 +1974,7 @@ package body Sem_Prag is\n \n                if Is_Formal (Item_Id) then\n                   if Scope (Item_Id) = Spec_Id then\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"global item cannot reference parameter of subprogram\",\n                         Item, Spec_Id);\n                      return;\n@@ -2000,13 +1984,13 @@ package body Sem_Prag is\n                --  Do this check first to provide a better error diagnostic.\n \n                elsif Ekind (Item_Id) = E_Constant then\n-                  Error_Msg_N (\"global item cannot denote a constant\", Item);\n+                  SPARK_Msg_N (\"global item cannot denote a constant\", Item);\n \n                --  The only legal references are those to abstract states and\n                --  variables (SPARK RM 6.1.4(4)).\n \n                elsif not Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"global item must denote variable or state\", Item);\n                   return;\n                end if;\n@@ -2020,10 +2004,10 @@ package body Sem_Prag is\n                   --  some of its constituents (SPARK RM 6.1.4(8)).\n \n                   if Has_Visible_Refinement (Item_Id) then\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"cannot mention state & in global refinement\",\n                         Item, Item_Id);\n-                     Error_Msg_N (\"\\use its constituents instead\", Item);\n+                     SPARK_Msg_N (\"\\use its constituents instead\", Item);\n                      return;\n \n                   --  If the reference to the abstract state appears in an\n@@ -2093,7 +2077,7 @@ package body Sem_Prag is\n             --  (SPARK RM 6.1.4(11)).\n \n             if Contains (Seen, Item_Id) then\n-               Error_Msg_N (\"duplicate global item\", Item);\n+               SPARK_Msg_N (\"duplicate global item\", Item);\n \n             --  Add the entity of the current item to the list of processed\n             --  items.\n@@ -2123,7 +2107,7 @@ package body Sem_Prag is\n          is\n          begin\n             if Status then\n-               Error_Msg_N (\"duplicate global mode\", Mode);\n+               SPARK_Msg_N (\"duplicate global mode\", Mode);\n             end if;\n \n             Status := True;\n@@ -2166,10 +2150,10 @@ package body Sem_Prag is\n                   if Appears_In (Inputs, Item_Id)\n                     and then not Appears_In (Outputs, Item_Id)\n                   then\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"global item & cannot have mode In_Out or Output\",\n                         Item, Item_Id);\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"\\item already appears as input of subprogram &\",\n                         Item, Context);\n \n@@ -2190,7 +2174,7 @@ package body Sem_Prag is\n          procedure Check_Mode_Restriction_In_Function (Mode : Node_Id) is\n          begin\n             if Ekind (Spec_Id) = E_Function then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"global mode & is not applicable to functions\", Mode);\n             end if;\n          end Check_Mode_Restriction_In_Function;\n@@ -2225,7 +2209,7 @@ package body Sem_Prag is\n \n             if Present (Expressions (List)) then\n                if Present (Component_Associations (List)) then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix moded and non-moded global lists\", List);\n                end if;\n \n@@ -2242,7 +2226,7 @@ package body Sem_Prag is\n \n             elsif Present (Component_Associations (List)) then\n                if Present (Expressions (List)) then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix moded and non-moded global lists\", List);\n                end if;\n \n@@ -2266,11 +2250,11 @@ package body Sem_Prag is\n                         Check_Duplicate_Mode (Mode, Proof_Seen);\n \n                      else\n-                        Error_Msg_N (\"invalid mode selector\", Mode);\n+                        SPARK_Msg_N (\"invalid mode selector\", Mode);\n                      end if;\n \n                   else\n-                     Error_Msg_N (\"invalid mode selector\", Mode);\n+                     SPARK_Msg_N (\"invalid mode selector\", Mode);\n                   end if;\n \n                   --  Items in a moded list appear as a collection of\n@@ -2290,7 +2274,8 @@ package body Sem_Prag is\n                raise Program_Error;\n             end if;\n \n-         --  Any other attempt to declare a global item is illegal\n+         --  Any other attempt to declare a global item is illegal. This is a\n+         --  syntax error, always report.\n \n          else\n             Error_Msg_N (\"malformed global list\", List);\n@@ -2312,14 +2297,6 @@ package body Sem_Prag is\n       Set_Analyzed (N);\n       Check_SPARK_Aspect_For_ASIS (N);\n \n-      --  Verify the syntax of pragma Global when SPARK checks are suppressed.\n-      --  Semantic analysis is disabled in this mode.\n-\n-      if SPARK_Mode = Off then\n-         Check_Global_List_Syntax (Items);\n-         return;\n-      end if;\n-\n       Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n       Subp_Id   := Defining_Entity (Subp_Decl);\n \n@@ -2434,9 +2411,6 @@ package body Sem_Prag is\n       --  Verify the legality of a single initialization item followed by a\n       --  list of input items.\n \n-      procedure Check_Initialization_List_Syntax (List : Node_Id);\n-      --  Verify the syntax of initialization list List\n-\n       procedure Collect_States_And_Variables;\n       --  Inspect the visible declarations of the related package and gather\n       --  the entities of all abstract states and variables in States_And_Vars.\n@@ -2453,10 +2427,10 @@ package body Sem_Prag is\n \n          if Nkind (Item) = N_Null then\n             if Null_Seen then\n-               Error_Msg_N (\"multiple null initializations not allowed\", Item);\n+               SPARK_Msg_N (\"multiple null initializations not allowed\", Item);\n \n             elsif Non_Null_Seen then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"cannot mix null and non-null initialization items\", Item);\n             else\n                Null_Seen := True;\n@@ -2468,7 +2442,7 @@ package body Sem_Prag is\n             Non_Null_Seen := True;\n \n             if Null_Seen then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"cannot mix null and non-null initialization items\", Item);\n             end if;\n \n@@ -2485,15 +2459,15 @@ package body Sem_Prag is\n \n                   if not Contains (States_And_Vars, Item_Id) then\n                      Error_Msg_Name_1 := Chars (Pack_Id);\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"initialization item & must appear in the visible \"\n                         & \"declarations of package %\", Item, Item_Id);\n \n                   --  Detect a duplicate use of the same initialization item\n                   --  (SPARK RM 7.1.5(5)).\n \n                   elsif Contains (Items_Seen, Item_Id) then\n-                     Error_Msg_N (\"duplicate initialization item\", Item);\n+                     SPARK_Msg_N (\"duplicate initialization item\", Item);\n \n                   --  The item is legal, add it to the list of processed states\n                   --  and variables.\n@@ -2514,13 +2488,13 @@ package body Sem_Prag is\n                --  variable (SPARK RM 7.1.5(3)).\n \n                else\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"initialization item must denote variable or state\",\n                      Item);\n                end if;\n \n             --  Some form of illegal construct masquerading as a name\n-            --  (SPARK RM 7.1.5(3)).\n+            --  (SPARK RM 7.1.5(3)). This is a syntax error, always report.\n \n             else\n                Error_Msg_N\n@@ -2557,11 +2531,11 @@ package body Sem_Prag is\n \n             if Nkind (Input) = N_Null then\n                if Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"multiple null initializations not allowed\", Item);\n \n                elsif Non_Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix null and non-null initialization item\", Item);\n                else\n                   Null_Seen := True;\n@@ -2573,7 +2547,7 @@ package body Sem_Prag is\n                Non_Null_Seen := True;\n \n                if Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix null and non-null initialization item\", Item);\n                end if;\n \n@@ -2594,7 +2568,7 @@ package body Sem_Prag is\n \n                      if Within_Scope (Input_Id, Current_Scope) then\n                         Error_Msg_Name_1 := Chars (Pack_Id);\n-                        Error_Msg_NE\n+                        SPARK_Msg_NE\n                           (\"input item & cannot denote a visible variable or \"\n                            & \"state of package % (SPARK RM 7.1.5(4))\",\n                            Input, Input_Id);\n@@ -2603,7 +2577,7 @@ package body Sem_Prag is\n                      --  (SPARK RM 7.1.5(5)).\n \n                      elsif Contains (Inputs_Seen, Input_Id) then\n-                        Error_Msg_N (\"duplicate input item\", Input);\n+                        SPARK_Msg_N (\"duplicate input item\", Input);\n \n                      --  Input is legal, add it to the list of processed inputs\n \n@@ -2625,15 +2599,15 @@ package body Sem_Prag is\n                   --  variable (SPARK RM 7.1.5(3)).\n \n                   else\n-                     Error_Msg_N\n+                     SPARK_Msg_N\n                        (\"input item must denote variable or state\", Input);\n                   end if;\n \n                --  Some form of illegal construct masquerading as a name\n                --  (SPARK RM 7.1.5(3)).\n \n                else\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"input item must denote variable or state\", Input);\n                end if;\n             end if;\n@@ -2656,7 +2630,7 @@ package body Sem_Prag is\n          Elmt := First (Choices (Item));\n          while Present (Elmt) loop\n             if Name_Seen then\n-               Error_Msg_N (\"only one item allowed in initialization\", Elmt);\n+               SPARK_Msg_N (\"only one item allowed in initialization\", Elmt);\n             else\n                Name_Seen := True;\n                Analyze_Initialization_Item (Elmt);\n@@ -2677,7 +2651,7 @@ package body Sem_Prag is\n             end if;\n \n             if Present (Component_Associations (Inputs)) then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"inputs must appear in named association form\", Inputs);\n             end if;\n \n@@ -2688,61 +2662,6 @@ package body Sem_Prag is\n          end if;\n       end Analyze_Initialization_Item_With_Inputs;\n \n-      --------------------------------------\n-      -- Check_Initialization_List_Syntax --\n-      --------------------------------------\n-\n-      procedure Check_Initialization_List_Syntax (List : Node_Id) is\n-         Init  : Node_Id;\n-         Input : Node_Id;\n-\n-      begin\n-         --  Null initialization list\n-\n-         if Nkind (List) = N_Null then\n-            null;\n-\n-         elsif Nkind (List) = N_Aggregate then\n-\n-            --  Simple initialization items\n-\n-            if Present (Expressions (List)) then\n-               Init := First (Expressions (List));\n-               while Present (Init) loop\n-                  Check_Item_Syntax (Init);\n-                  Next (Init);\n-               end loop;\n-            end if;\n-\n-            --  Initialization items with a input lists\n-\n-            if Present (Component_Associations (List)) then\n-               Init := First (Component_Associations (List));\n-               while Present (Init) loop\n-                  Check_Item_Syntax (First (Choices (Init)));\n-\n-                  if Nkind (Expression (Init)) = N_Aggregate\n-                    and then Present (Expressions (Expression (Init)))\n-                  then\n-                     Input := First (Expressions (Expression (Init)));\n-                     while Present (Input) loop\n-                        Check_Item_Syntax (Input);\n-                        Next (Input);\n-                     end loop;\n-\n-                  else\n-                     Error_Msg_N (\"malformed initialization item\", Init);\n-                  end if;\n-\n-                  Next (Init);\n-               end loop;\n-            end if;\n-\n-         else\n-            Error_Msg_N (\"malformed initialization list\", List);\n-         end if;\n-      end Check_Initialization_List_Syntax;\n-\n       ----------------------------------\n       -- Collect_States_And_Variables --\n       ----------------------------------\n@@ -2792,13 +2711,6 @@ package body Sem_Prag is\n \n       if Nkind (Inits) = N_Null then\n          return;\n-\n-      --  Verify the syntax of pragma Initializes when SPARK checks are\n-      --  suppressed. Semantic analysis is disabled in this mode.\n-\n-      elsif SPARK_Mode = Off then\n-         Check_Initialization_List_Syntax (Inits);\n-         return;\n       end if;\n \n       --  Single and multiple initialization clauses appear as an aggregate. If\n@@ -2840,10 +2752,6 @@ package body Sem_Prag is\n    -- Analyze_Pragma --\n    --------------------\n \n-   --------------------\n-   -- Analyze_Pragma --\n-   --------------------\n-\n    procedure Analyze_Pragma (N : Node_Id) is\n       Loc     : constant Source_Ptr := Sloc (N);\n       Prag_Id : Pragma_Id;\n@@ -3478,21 +3386,25 @@ package body Sem_Prag is\n \n          Legal := False;\n \n-         --  Verify the syntax of the encapsulating state when SPARK check are\n-         --  suppressed. Semantic analysis is disabled in this mode.\n+         if Nkind_In (State, N_Expanded_Name,\n+                             N_Identifier,\n+                             N_Selected_Component)\n+         then\n+            Analyze       (State);\n+            Resolve_State (State);\n \n-         if SPARK_Mode = Off then\n-            Check_Item_Syntax (State);\n-            return;\n-         end if;\n+            if Is_Entity_Name (State)\n+              and then Ekind (Entity (State)) = E_Abstract_State\n+            then\n+               State_Id := Entity (State);\n \n-         Analyze       (State);\n-         Resolve_State (State);\n+            else\n+               SPARK_Msg_N\n+                 (\"indicator Part_Of must denote an abstract state\", State);\n+               return;\n+            end if;\n \n-         if Is_Entity_Name (State)\n-           and then Ekind (Entity (State)) = E_Abstract_State\n-         then\n-            State_Id := Entity (State);\n+         --  This is a syntax error, always report\n \n          else\n             Error_Msg_N\n@@ -3516,11 +3428,11 @@ package body Sem_Prag is\n          --  visible.\n \n          if Placement = Not_In_Package then\n-            Error_Msg_N\n+            SPARK_Msg_N\n               (\"indicator Part_Of cannot appear in this context \"\n                & \"(SPARK RM 7.2.6(5))\", Indic);\n             Error_Msg_Name_1 := Chars (Scope (State_Id));\n-            Error_Msg_NE\n+            SPARK_Msg_NE\n               (\"\\& is not part of the hidden state of package %\",\n                Indic, Item_Id);\n \n@@ -3554,7 +3466,7 @@ package body Sem_Prag is\n                Parent_Unit := Scope (Parent_Unit);\n \n                if not Is_Child_Or_Sibling (Pack_Id, Scope (State_Id)) then\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"indicator Part_Of must denote an abstract state of& \"\n                      & \"or public descendant (SPARK RM 7.2.6(3))\",\n                        Indic, Parent_Unit);\n@@ -3567,7 +3479,7 @@ package body Sem_Prag is\n                   null;\n \n                else\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"indicator Part_Of must denote an abstract state of& \"\n                      & \"or public descendant (SPARK RM 7.2.6(3))\",\n                        Indic, Parent_Unit);\n@@ -3577,11 +3489,11 @@ package body Sem_Prag is\n             --  a private child unit or a public descendant thereof.\n \n             else\n-               Error_Msg_N\n-                 (\"indicator Part_Of cannot appear in this context (SPARK \"\n-                  & \"RM 7.2.6(5))\", Indic);\n+               SPARK_Msg_N\n+                 (\"indicator Part_Of cannot appear in this context \"\n+                  & \"(SPARK RM 7.2.6(5))\", Indic);\n                Error_Msg_Name_1 := Chars (Pack_Id);\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"\\& is declared in the visible part of package %\",\n                   Indic, Item_Id);\n             end if;\n@@ -3591,11 +3503,11 @@ package body Sem_Prag is\n \n          elsif Placement = Private_State_Space then\n             if Scope (State_Id) /= Pack_Id then\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"indicator Part_Of must designate an abstract state of \"\n                   & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n                Error_Msg_Name_1 := Chars (Pack_Id);\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"\\& is declared in the private part of package %\",\n                   Indic, Item_Id);\n             end if;\n@@ -3604,13 +3516,13 @@ package body Sem_Prag is\n          --  Part_Of indicators as the refinement has already been seen.\n \n          else\n-            Error_Msg_N\n+            SPARK_Msg_N\n               (\"indicator Part_Of cannot appear in this context \"\n                & \"(SPARK RM 7.2.6(5))\", Indic);\n \n             if Scope (State_Id) = Pack_Id then\n                Error_Msg_Name_1 := Chars (Pack_Id);\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"\\& is declared in the body of package %\", Indic, Item_Id);\n             end if;\n          end if;\n@@ -4227,7 +4139,7 @@ package body Sem_Prag is\n \n             --  If we get here, then the aspects are out of order\n \n-            Error_Msg_N (\"aspect % cannot come after aspect %\", First);\n+            SPARK_Msg_N (\"aspect % cannot come after aspect %\", First);\n          end Check_Aspect_Specification_Order;\n \n          --  Local variables\n@@ -4262,7 +4174,7 @@ package body Sem_Prag is\n \n          else\n             if From_Aspect_Specification (Second) then\n-               Error_Msg_N (\"pragma % cannot come after aspect %\", First);\n+               SPARK_Msg_N (\"pragma % cannot come after aspect %\", First);\n \n             --  Both pragmas are source constructs. Try to reach First from\n             --  Second by traversing the declarations backwards.\n@@ -4282,7 +4194,7 @@ package body Sem_Prag is\n \n                --  If we get here, then the pragmas are out of order\n \n-               Error_Msg_N (\"pragma % cannot come after pragma %\", First);\n+               SPARK_Msg_N (\"pragma % cannot come after pragma %\", First);\n             end if;\n          end if;\n       end Check_Declaration_Order;\n@@ -10235,9 +10147,6 @@ package body Sem_Prag is\n             --  decorate a state abstraction entity and introduce it into the\n             --  visibility chain.\n \n-            procedure Check_State_Declaration_Syntax (State : Node_Id);\n-            --  Verify the syntex of state declaration State\n-\n             ----------------------------\n             -- Analyze_Abstract_State --\n             ----------------------------\n@@ -10392,15 +10301,15 @@ package body Sem_Prag is\n \n                   if Nkind (Prop) = N_Others_Choice then\n                      if Others_Seen then\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"only one others choice allowed in option External\",\n                            Prop);\n                      else\n                         Others_Seen := True;\n                      end if;\n \n                   elsif Others_Seen then\n-                     Error_Msg_N\n+                     SPARK_Msg_N\n                        (\"others must be the last property in option External\",\n                         Prop);\n \n@@ -10418,7 +10327,7 @@ package body Sem_Prag is\n                   --  Otherwise the construct is not a valid property\n \n                   else\n-                     Error_Msg_N (\"invalid external state property\", Prop);\n+                     SPARK_Msg_N (\"invalid external state property\", Prop);\n                      return;\n                   end if;\n \n@@ -10431,7 +10340,7 @@ package body Sem_Prag is\n                      if Is_Static_Expression (Expr) then\n                         Expr_Val := Is_True (Expr_Value (Expr));\n                      else\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"expression of external state property must be \"\n                            & \"static\", Expr);\n                      end if;\n@@ -10525,7 +10434,7 @@ package body Sem_Prag is\n                is\n                begin\n                   if Status then\n-                     Error_Msg_N (\"duplicate state option\", Opt);\n+                     SPARK_Msg_N (\"duplicate state option\", Opt);\n                   end if;\n \n                   Status := True;\n@@ -10541,7 +10450,7 @@ package body Sem_Prag is\n                is\n                begin\n                   if Status then\n-                     Error_Msg_N (\"duplicate external property\", Prop);\n+                     SPARK_Msg_N (\"duplicate external property\", Prop);\n                   end if;\n \n                   Status := True;\n@@ -10605,7 +10514,7 @@ package body Sem_Prag is\n                --  declare additional states.\n \n                if Null_Seen then\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"package & has null abstract state\", State, Pack_Id);\n \n                --  Null states appear as internally generated entities\n@@ -10622,7 +10531,7 @@ package body Sem_Prag is\n                   --  non-null states.\n \n                   if Non_Null_Seen then\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"package & has non-null abstract state\",\n                         State, Pack_Id);\n                   end if;\n@@ -10649,7 +10558,7 @@ package body Sem_Prag is\n                         Is_Null => False);\n                      Non_Null_Seen := True;\n                   else\n-                     Error_Msg_N\n+                     SPARK_Msg_N\n                        (\"state name must be an identifier\",\n                         Ancestor_Part (State));\n                   end if;\n@@ -10671,12 +10580,12 @@ package body Sem_Prag is\n                      --  (SPARK RM 7.1.4(9)).\n \n                      elsif Chars (Opt) = Name_Part_Of then\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"indicator Part_Of must denote an abstract state\",\n                            Opt);\n \n                      else\n-                        Error_Msg_N\n+                        SPARK_Msg_N\n                           (\"simple option not allowed in state declaration\",\n                            Opt);\n                      end if;\n@@ -10699,19 +10608,21 @@ package body Sem_Prag is\n                            Analyze_Part_Of_Option (Opt);\n \n                         else\n-                           Error_Msg_N (\"invalid state option\", Opt);\n+                           SPARK_Msg_N (\"invalid state option\", Opt);\n                         end if;\n                      else\n-                        Error_Msg_N (\"invalid state option\", Opt);\n+                        SPARK_Msg_N (\"invalid state option\", Opt);\n                      end if;\n \n                      Next (Opt);\n                   end loop;\n \n-               --  Any other attempt to declare a state is illegal\n+               --  Any other attempt to declare a state is illegal. This is a\n+               --  syntax error, always report.\n \n                else\n                   Error_Msg_N (\"malformed abstract state declaration\", State);\n+                  return;\n                end if;\n \n                --  Guard against a junk state. In such cases no entity is\n@@ -10743,49 +10654,6 @@ package body Sem_Prag is\n                end if;\n             end Analyze_Abstract_State;\n \n-            ------------------------------------\n-            -- Check_State_Declaration_Syntax --\n-            ------------------------------------\n-\n-            procedure Check_State_Declaration_Syntax (State : Node_Id) is\n-               Decl : Node_Id;\n-\n-            begin\n-               --  Null abstract state\n-\n-               if Nkind (State) = N_Null then\n-                  null;\n-\n-               --  Single state\n-\n-               elsif Nkind (State) = N_Identifier then\n-                  null;\n-\n-               --  State with various options\n-\n-               elsif Nkind (State) = N_Extension_Aggregate then\n-                  if Nkind (Ancestor_Part (State)) /= N_Identifier then\n-                     Error_Msg_N\n-                       (\"state name must be an identifier\",\n-                        Ancestor_Part (State));\n-                  end if;\n-\n-               --  Multiple states\n-\n-               elsif Nkind (State) = N_Aggregate\n-                 and then Present (Expressions (State))\n-               then\n-                  Decl := First (Expressions (State));\n-                  while Present (Decl) loop\n-                     Check_State_Declaration_Syntax (Decl);\n-                     Next (Decl);\n-                  end loop;\n-\n-               else\n-                  Error_Msg_N (\"malformed abstract state\", State);\n-               end if;\n-            end Check_State_Declaration_Syntax;\n-\n             --  Local variables\n \n             Context : constant Node_Id := Parent (Parent (N));\n@@ -10808,16 +10676,7 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            State := Expression (Arg1);\n-\n-            --  Verify the syntax of pragma Abstract_State when SPARK checks\n-            --  are suppressed. Semantic analysis is disabled in this mode.\n-\n-            if SPARK_Mode = Off then\n-               Check_State_Declaration_Syntax (State);\n-               return;\n-            end if;\n-\n+            State   := Expression (Arg1);\n             Pack_Id := Defining_Entity (Context);\n \n             --  Multiple non-null abstract states appear as an aggregate\n@@ -17699,7 +17558,7 @@ package body Sem_Prag is\n                --  indicator, but has no visible state.\n \n                if not Has_Item then\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"package instantiation & has Part_Of indicator but \"\n                      & \"lacks visible state\", Instance, Pack_Id);\n                end if;\n@@ -17765,7 +17624,7 @@ package body Sem_Prag is\n             if Nkind (Stmt) = N_Object_Declaration\n               and then Ekind (Defining_Entity (Stmt)) /= E_Variable\n             then\n-               Error_Msg_N (\"indicator Part_Of must apply to a variable\", N);\n+               SPARK_Msg_N (\"indicator Part_Of must apply to a variable\", N);\n                return;\n             end if;\n \n@@ -22135,12 +21994,12 @@ package body Sem_Prag is\n          --  a matching clause, emit an error.\n \n          else\n-            Error_Msg_NE\n+            SPARK_Msg_NE\n               (\"dependence clause of subprogram & has no matching refinement \"\n                & \"in body\", Ref_Clause, Spec_Id);\n \n             if Has_Refined_State then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"\\check the use of constituents in dependence refinement\",\n                   Ref_Clause);\n             end if;\n@@ -22166,7 +22025,7 @@ package body Sem_Prag is\n          procedure Match_Error (Msg : String; N : Node_Id) is\n          begin\n             if Post_Errors then\n-               Error_Msg_N (Msg, N);\n+               SPARK_Msg_N (Msg, N);\n             end if;\n          end Match_Error;\n \n@@ -22400,7 +22259,7 @@ package body Sem_Prag is\n             if Present (Ref_Inputs) and then Post_Errors then\n                Input := First (Ref_Inputs);\n                while Present (Input) loop\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"unmatched or extra input in refinement clause\", Input);\n \n                   Next (Input);\n@@ -22575,7 +22434,7 @@ package body Sem_Prag is\n                if Nkind (Clause) /= N_Component_Association\n                  or else Nkind (Expression (Clause)) /= N_Null\n                then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"unmatched or extra clause in dependence refinement\",\n                      Clause);\n                end if;\n@@ -22597,14 +22456,6 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n    begin\n-      --  Verify the syntax of pragma Refined_Depends when SPARK checks are\n-      --  suppressed. Semantic analysis is disabled in this mode.\n-\n-      if SPARK_Mode = Off then\n-         Check_Dependence_List_Syntax (Refs);\n-         return;\n-      end if;\n-\n       if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n          Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n       else\n@@ -22617,7 +22468,7 @@ package body Sem_Prag is\n       --  rendered useless as there is nothing to refine (SPARK RM 7.2.5(2)).\n \n       if No (Depends) then\n-         Error_Msg_NE\n+         SPARK_Msg_NE\n            (\"useless refinement, declaration of subprogram & lacks aspect or \"\n             & \"pragma Depends\", N, Spec_Id);\n          return;\n@@ -22631,7 +22482,7 @@ package body Sem_Prag is\n       --  (SPARK RM 7.2.5(2)).\n \n       if Nkind (Deps) = N_Null then\n-         Error_Msg_NE\n+         SPARK_Msg_NE\n            (\"useless refinement, subprogram & does not depend on abstract \"\n             & \"state with visible refinement\",\n             N, Spec_Id);\n@@ -22821,7 +22672,7 @@ package body Sem_Prag is\n \n                elsif Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n                   Error_Msg_Name_1 := Chars (State_Id);\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"constituent & of state % must have mode Input, In_Out \"\n                      & \"or Output in global refinement\",\n                      N, Constit_Id);\n@@ -22851,7 +22702,7 @@ package body Sem_Prag is\n                null;\n \n             else\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"global refinement of state & redefines the mode of its \"\n                   & \"constituents\", N, State_Id);\n             end if;\n@@ -22924,7 +22775,7 @@ package body Sem_Prag is\n                  or else Present_Then_Remove (Proof_In_Constits, Constit_Id)\n                then\n                   Error_Msg_Name_1 := Chars (State_Id);\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"constituent & of state % must have mode Input in global \"\n                      & \"refinement\", N, Constit_Id);\n                end if;\n@@ -22935,7 +22786,7 @@ package body Sem_Prag is\n             --  Not one of the constituents appeared as Input\n \n             if not In_Seen then\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"global refinement of state & must include at least one \"\n                   & \"constituent of mode Input\", N, State_Id);\n             end if;\n@@ -23006,7 +22857,7 @@ package body Sem_Prag is\n                  or else Present_Then_Remove (Proof_In_Constits, Constit_Id)\n                then\n                   Error_Msg_Name_1 := Chars (State_Id);\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"constituent & of state % must have mode Output in \"\n                      & \"global refinement\", N, Constit_Id);\n \n@@ -23015,12 +22866,12 @@ package body Sem_Prag is\n                else\n                   if not Posted then\n                      Posted := True;\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"output state & must be replaced by all its \"\n                         & \"constituents in global refinement\", N, State_Id);\n                   end if;\n \n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"\\constituent & is missing in output list\",\n                      N, Constit_Id);\n                end if;\n@@ -23096,7 +22947,7 @@ package body Sem_Prag is\n                  or else Present_Then_Remove (Out_Constits, Constit_Id)\n                then\n                   Error_Msg_Name_1 := Chars (State_Id);\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"constituent & of state % must have mode Proof_In in \"\n                      & \"global refinement\", N, Constit_Id);\n                end if;\n@@ -23107,7 +22958,7 @@ package body Sem_Prag is\n             --  Not one of the constituents appeared as Proof_In\n \n             if not Proof_In_Seen then\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"global refinement of state & must include at least one \"\n                   & \"constituent of mode Proof_In\", N, State_Id);\n             end if;\n@@ -23177,12 +23028,12 @@ package body Sem_Prag is\n \n             procedure Inconsistent_Mode_Error (Expect : Name_Id) is\n             begin\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"global item & has inconsistent modes\", Item, Item_Id);\n \n                Error_Msg_Name_1 := Global_Mode;\n                Error_Msg_Name_2 := Expect;\n-               Error_Msg_N (\"\\expected mode %, found mode %\", Item);\n+               SPARK_Msg_N (\"\\expected mode %, found mode %\", Item);\n             end Inconsistent_Mode_Error;\n \n          --  Start of processing for Check_Refined_Global_Item\n@@ -23233,7 +23084,7 @@ package body Sem_Prag is\n             --  it must be an extra (SPARK RM 7.2.4(3)).\n \n             else\n-               Error_Msg_NE (\"extra global item &\", Item, Item_Id);\n+               SPARK_Msg_NE (\"extra global item &\", Item, Item_Id);\n             end if;\n          end Check_Refined_Global_Item;\n \n@@ -23342,7 +23193,7 @@ package body Sem_Prag is\n             if Present (List) then\n                Constit_Elmt := First_Elmt (List);\n                while Present (Constit_Elmt) loop\n-                  Error_Msg_NE (\"extra constituent &\", N, Node (Constit_Elmt));\n+                  SPARK_Msg_NE (\"extra constituent &\", N, Node (Constit_Elmt));\n                   Next_Elmt (Constit_Elmt);\n                end loop;\n             end if;\n@@ -23368,14 +23219,6 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Refined_Global_In_Decl_Part\n \n    begin\n-      --  Verify the syntax of pragma Refined_Global when SPARK checks are\n-      --  suppressed. Semantic analysis is disabled in this mode.\n-\n-      if SPARK_Mode = Off then\n-         Check_Global_List_Syntax (Items);\n-         return;\n-      end if;\n-\n       if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n          Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n       else\n@@ -23388,7 +23231,7 @@ package body Sem_Prag is\n       --  Refined_Global useless as there is nothing to refine.\n \n       if No (Global) then\n-         Error_Msg_NE\n+         SPARK_Msg_NE\n            (\"useless refinement, declaration of subprogram & lacks aspect or \"\n             & \"pragma Global\", N, Spec_Id);\n          return;\n@@ -23418,7 +23261,7 @@ package body Sem_Prag is\n         and then not Has_Proof_In_State\n         and then not Has_Null_State\n       then\n-         Error_Msg_NE\n+         SPARK_Msg_NE\n            (\"useless refinement, subprogram & does not depend on abstract \"\n             & \"state with visible refinement\", N, Spec_Id);\n          return;\n@@ -23436,7 +23279,7 @@ package body Sem_Prag is\n             or else Present (Proof_In_Items))\n         and then not Has_Null_State\n       then\n-         Error_Msg_NE\n+         SPARK_Msg_NE\n            (\"refinement cannot be null, subprogram & has global items\",\n             N, Spec_Id);\n          return;\n@@ -23522,9 +23365,6 @@ package body Sem_Prag is\n       procedure Analyze_Refinement_Clause (Clause : Node_Id);\n       --  Perform full analysis of a single refinement clause\n \n-      procedure Check_Refinement_List_Syntax (List : Node_Id);\n-      --  Verify the syntax of refinement clause list List\n-\n       function Collect_Body_States (Pack_Id : Entity_Id) return Elist_Id;\n       --  Gather the entities of all abstract states and variables declared in\n       --  the body state space of package Pack_Id.\n@@ -23664,7 +23504,7 @@ package body Sem_Prag is\n                --  Detect a duplicate use of a constituent\n \n                if Contains (Constituents_Seen, Constit_Id) then\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"duplicate use of constituent &\", Constit, Constit_Id);\n                   return;\n                end if;\n@@ -23681,10 +23521,10 @@ package body Sem_Prag is\n \n                   else\n                      Error_Msg_Name_1 := Chars (State_Id);\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"& cannot act as constituent of state %\",\n                         Constit, Constit_Id);\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"\\Part_Of indicator specifies & as encapsulating \"\n                         & \"state\", Constit, Encapsulating_State (Constit_Id));\n                   end if;\n@@ -23715,7 +23555,7 @@ package body Sem_Prag is\n                   --  refinement (SPARK RM 7.2.2(9)).\n \n                   Error_Msg_Name_1 := Chars (Spec_Id);\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"cannot use & in refinement, constituent is not a hidden \"\n                      & \"state of package %\", Constit, Constit_Id);\n                end if;\n@@ -23733,11 +23573,11 @@ package body Sem_Prag is\n \n             if Nkind (Constit) = N_Null then\n                if Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"multiple null constituents not allowed\", Constit);\n \n                elsif Non_Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix null and non-null constituents\", Constit);\n \n                else\n@@ -23760,7 +23600,7 @@ package body Sem_Prag is\n                Non_Null_Seen := True;\n \n                if Null_Seen then\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"cannot mix null and non-null constituents\", Constit);\n                end if;\n \n@@ -23777,15 +23617,15 @@ package body Sem_Prag is\n                      Check_Matching_Constituent (Constit_Id);\n \n                   else\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"constituent & must denote a variable or state (SPARK \"\n                         & \"RM 7.2.2(5))\", Constit, Constit_Id);\n                   end if;\n \n                --  The constituent is illegal\n \n                else\n-                  Error_Msg_N (\"malformed constituent\", Constit);\n+                  SPARK_Msg_N (\"malformed constituent\", Constit);\n                end if;\n             end if;\n          end Analyze_Constituent;\n@@ -23807,7 +23647,7 @@ package body Sem_Prag is\n \n             if Enabled then\n                if No (Constit) then\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"external state & requires at least one constituent with \"\n                      & \"property %\", State, State_Id);\n                end if;\n@@ -23818,7 +23658,7 @@ package body Sem_Prag is\n \n             elsif Present (Constit) then\n                Error_Msg_Name_2 := Chars (Constit);\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"external state & lacks property % set by constituent %\",\n                   State, State_Id);\n             end if;\n@@ -23835,7 +23675,7 @@ package body Sem_Prag is\n             --  Detect a duplicate refinement of a state (SPARK RM 7.2.2(8))\n \n             if Contains (Refined_States_Seen, State_Id) then\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"duplicate refinement of state &\", State, State_Id);\n                return;\n             end if;\n@@ -23865,7 +23705,7 @@ package body Sem_Prag is\n             --  the package declaration.\n \n             Error_Msg_Name_1 := Chars (Spec_Id);\n-            Error_Msg_NE\n+            SPARK_Msg_NE\n               (\"cannot refine state, & is not defined in package %\",\n                State, State_Id);\n          end Check_Matching_State;\n@@ -23893,18 +23733,18 @@ package body Sem_Prag is\n \n                   if not Posted then\n                      Posted := True;\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"state & has unused Part_Of constituents\",\n                         State, State_Id);\n                   end if;\n \n                   Error_Msg_Sloc := Sloc (Constit_Id);\n \n                   if Ekind (Constit_Id) = E_Abstract_State then\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"\\abstract state & defined #\", State, Constit_Id);\n                   else\n-                     Error_Msg_NE\n+                     SPARK_Msg_NE\n                        (\"\\variable & defined #\", State, Constit_Id);\n                   end if;\n \n@@ -23925,6 +23765,7 @@ package body Sem_Prag is\n       begin\n          --  A refinement clause appears as a component association where the\n          --  sole choice is the state and the expressions are the constituents.\n+         --  This is a syntax error, always report.\n \n          if Nkind (Clause) /= N_Component_Association then\n             Error_Msg_N (\"malformed state refinement clause\", Clause);\n@@ -23950,7 +23791,7 @@ package body Sem_Prag is\n             if Ekind (State_Id) = E_Abstract_State then\n                Check_Matching_State;\n             else\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"& must denote an abstract state\", State, State_Id);\n                return;\n             end if;\n@@ -23967,15 +23808,15 @@ package body Sem_Prag is\n                while Present (Body_Ref_Elmt) loop\n                   Body_Ref := Node (Body_Ref_Elmt);\n \n-                  Error_Msg_N (\"reference to & not allowed\", Body_Ref);\n+                  SPARK_Msg_N (\"reference to & not allowed\", Body_Ref);\n                   Error_Msg_Sloc := Sloc (State);\n-                  Error_Msg_N (\"\\refinement of & is visible#\", Body_Ref);\n+                  SPARK_Msg_N (\"\\refinement of & is visible#\", Body_Ref);\n \n                   Next_Elmt (Body_Ref_Elmt);\n                end loop;\n             end if;\n \n-         --  The state name is illegal\n+         --  The state name is illegal. This is a syntax error, always report.\n \n          else\n             Error_Msg_N (\"malformed state name in refinement clause\", State);\n@@ -23987,7 +23828,7 @@ package body Sem_Prag is\n          Extra_State := Next (State);\n \n          if Present (Extra_State) then\n-            Error_Msg_N\n+            SPARK_Msg_N\n               (\"refinement clause cannot cover multiple states\", Extra_State);\n          end if;\n \n@@ -24003,7 +23844,7 @@ package body Sem_Prag is\n \n          if Nkind (Constit) = N_Aggregate then\n             if Present (Component_Associations (Constit)) then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"constituents of refinement clause must appear in \"\n                   & \"positional form\", Constit);\n \n@@ -24062,7 +23903,7 @@ package body Sem_Prag is\n             --  external (SPARK RM 7.2.8(2)).\n \n             else\n-               Error_Msg_NE\n+               SPARK_Msg_NE\n                  (\"external state & requires at least one external \"\n                   & \"constituent or null refinement\", State, State_Id);\n             end if;\n@@ -24071,7 +23912,7 @@ package body Sem_Prag is\n          --  constituents (SPARK RM 7.2.8(1)).\n \n          elsif External_Constit_Seen then\n-            Error_Msg_NE\n+            SPARK_Msg_NE\n               (\"non-external state & cannot contain external constituents in \"\n                & \"refinement\", State, State_Id);\n          end if;\n@@ -24082,70 +23923,6 @@ package body Sem_Prag is\n          Report_Unused_Constituents (Part_Of_Constits);\n       end Analyze_Refinement_Clause;\n \n-      ----------------------------------\n-      -- Check_Refinement_List_Syntax --\n-      ----------------------------------\n-\n-      procedure Check_Refinement_List_Syntax (List : Node_Id) is\n-         procedure Check_Clause_Syntax (Clause : Node_Id);\n-         --  Verify the syntax of state refinement clause Clause\n-\n-         -------------------------\n-         -- Check_Clause_Syntax --\n-         -------------------------\n-\n-         procedure Check_Clause_Syntax (Clause : Node_Id) is\n-            Constits : constant Node_Id := Expression (Clause);\n-            Constit  : Node_Id;\n-\n-         begin\n-            --  State to be refined\n-\n-            Check_Item_Syntax (First (Choices (Clause)));\n-\n-            --  Multiple constituents\n-\n-            if Nkind (Constits) = N_Aggregate\n-              and then Present (Expressions (Constits))\n-            then\n-               Constit := First (Expressions (Constits));\n-               while Present (Constit) loop\n-                  Check_Item_Syntax (Constit);\n-                  Next (Constit);\n-               end loop;\n-\n-            --  Single constituent\n-\n-            else\n-               Check_Item_Syntax (Constits);\n-            end if;\n-         end Check_Clause_Syntax;\n-\n-         --  Local variables\n-\n-         Clause : Node_Id;\n-\n-      --  Start of processing for Check_Refinement_List_Syntax\n-\n-      begin\n-         --  Multiple state refinement clauses\n-\n-         if Nkind (List) = N_Aggregate\n-           and then Present (Component_Associations (List))\n-         then\n-            Clause := First (Component_Associations (List));\n-            while Present (Clause) loop\n-               Check_Clause_Syntax (Clause);\n-               Next (Clause);\n-            end loop;\n-\n-         --  Single state refinement clause\n-\n-         else\n-            Check_Clause_Syntax (List);\n-         end if;\n-      end Check_Refinement_List_Syntax;\n-\n       -------------------------\n       -- Collect_Body_States --\n       -------------------------\n@@ -24246,7 +24023,7 @@ package body Sem_Prag is\n          if Present (States) then\n             State_Elmt := First_Elmt (States);\n             while Present (State_Elmt) loop\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"abstract state & must be refined\", Node (State_Elmt));\n \n                Next_Elmt (State_Elmt);\n@@ -24277,17 +24054,17 @@ package body Sem_Prag is\n \n                if not Posted then\n                   Posted := True;\n-                  Error_Msg_N\n+                  SPARK_Msg_N\n                     (\"body of package & has unused hidden states\", Body_Id);\n                end if;\n \n                Error_Msg_Sloc := Sloc (State_Id);\n \n                if Ekind (State_Id) = E_Abstract_State then\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"\\abstract state & defined #\", Body_Id, State_Id);\n                else\n-                  Error_Msg_NE\n+                  SPARK_Msg_NE\n                     (\"\\variable & defined #\", Body_Id, State_Id);\n                end if;\n \n@@ -24308,14 +24085,6 @@ package body Sem_Prag is\n    begin\n       Set_Analyzed (N);\n \n-      --  Verify the syntax of pragma Refined_State when SPARK checks are\n-      --  suppressed. Semantic analysis is disabled in this mode.\n-\n-      if SPARK_Mode = Off then\n-         Check_Refinement_List_Syntax (Clauses);\n-         return;\n-      end if;\n-\n       Body_Id := Defining_Entity (Body_Decl);\n       Spec_Id := Corresponding_Spec (Body_Decl);\n \n@@ -24334,7 +24103,7 @@ package body Sem_Prag is\n \n       if Nkind (Clauses) = N_Aggregate then\n          if Present (Expressions (Clauses)) then\n-            Error_Msg_N\n+            SPARK_Msg_N\n               (\"state refinements must appear as component associations\",\n                Clauses);\n \n@@ -24500,110 +24269,6 @@ package body Sem_Prag is\n       end if;\n    end Check_Applicable_Policy;\n \n-   ----------------------------------\n-   -- Check_Dependence_List_Syntax --\n-   ----------------------------------\n-\n-   procedure Check_Dependence_List_Syntax (List : Node_Id) is\n-      procedure Check_Clause_Syntax (Clause : Node_Id);\n-      --  Verify the syntax of a dependency clause Clause\n-\n-      -------------------------\n-      -- Check_Clause_Syntax --\n-      -------------------------\n-\n-      procedure Check_Clause_Syntax (Clause : Node_Id) is\n-         Input   : Node_Id;\n-         Inputs  : Node_Id;\n-         Output  : Node_Id;\n-         Outputs : Node_Id;\n-\n-      begin\n-         --  Output items\n-\n-         Outputs := First (Choices (Clause));\n-         while Present (Outputs) loop\n-\n-            --  Multiple output items\n-\n-            if Nkind (Outputs) = N_Aggregate then\n-               Output := First (Expressions (Outputs));\n-               while Present (Output) loop\n-                  Check_Item_Syntax (Output);\n-                  Next (Output);\n-               end loop;\n-\n-            --  Single output item\n-\n-            else\n-               Check_Item_Syntax (Outputs);\n-            end if;\n-\n-            Next (Outputs);\n-         end loop;\n-\n-         Inputs := Expression (Clause);\n-\n-         --  A self-dependency appears as operator \"+\"\n-\n-         if Nkind (Inputs) = N_Op_Plus then\n-            Inputs := Right_Opnd (Inputs);\n-         end if;\n-\n-         --  Input items\n-\n-         if Nkind (Inputs) = N_Aggregate then\n-            if Present (Expressions (Inputs)) then\n-               Input := First (Expressions (Inputs));\n-               while Present (Input) loop\n-                  Check_Item_Syntax (Input);\n-                  Next (Input);\n-               end loop;\n-\n-            else\n-               Error_Msg_N (\"malformed input dependency list\", Inputs);\n-            end if;\n-\n-         --  Single input item\n-\n-         else\n-            Check_Item_Syntax (Inputs);\n-         end if;\n-      end Check_Clause_Syntax;\n-\n-      --  Local variables\n-\n-      Clause : Node_Id;\n-\n-   --  Start of processing for Check_Dependence_List_Syntax\n-\n-   begin\n-      --  Null dependency relation\n-\n-      if Nkind (List) = N_Null then\n-         null;\n-\n-      --  Verify the syntax of a single or multiple dependency clauses\n-\n-      elsif Nkind (List) = N_Aggregate\n-        and then Present (Component_Associations (List))\n-      then\n-         Clause := First (Component_Associations (List));\n-         while Present (Clause) loop\n-            if Has_Extra_Parentheses (Clause) then\n-               null;\n-            else\n-               Check_Clause_Syntax (Clause);\n-            end if;\n-\n-            Next (Clause);\n-         end loop;\n-\n-      else\n-         Error_Msg_N (\"malformed dependency relation\", List);\n-      end if;\n-   end Check_Dependence_List_Syntax;\n-\n    -------------------------------\n    -- Check_External_Properties --\n    -------------------------------\n@@ -24649,97 +24314,12 @@ package body Sem_Prag is\n          null;\n \n       else\n-         Error_Msg_N\n+         SPARK_Msg_N\n            (\"illegal combination of external properties (SPARK RM 7.1.2(6))\",\n             Item);\n       end if;\n    end Check_External_Properties;\n \n-   ------------------------------\n-   -- Check_Global_List_Syntax --\n-   ------------------------------\n-\n-   procedure Check_Global_List_Syntax (List : Node_Id) is\n-      Assoc : Node_Id;\n-      Item  : Node_Id;\n-\n-   begin\n-      --  Null global list\n-\n-      if Nkind (List) = N_Null then\n-         null;\n-\n-      --  Single global item\n-\n-      elsif Nkind_In (List, N_Expanded_Name,\n-                            N_Identifier,\n-                            N_Selected_Component)\n-      then\n-         null;\n-\n-      elsif Nkind (List) = N_Aggregate then\n-\n-         --  Items in a simple global list\n-\n-         if Present (Expressions (List)) then\n-            Item := First (Expressions (List));\n-            while Present (Item) loop\n-               Check_Item_Syntax (Item);\n-               Next (Item);\n-            end loop;\n-\n-         --  Items in a moded global list\n-\n-         elsif Present (Component_Associations (List)) then\n-            Assoc := First (Component_Associations (List));\n-            while Present (Assoc) loop\n-               Check_Item_Syntax (First (Choices (Assoc)));\n-               Check_Global_List_Syntax (Expression (Assoc));\n-\n-               Next (Assoc);\n-            end loop;\n-         end if;\n-\n-      --  Anything else is an error\n-\n-      else\n-         Error_Msg_N (\"malformed global list\", List);\n-      end if;\n-   end Check_Global_List_Syntax;\n-\n-   -----------------------\n-   -- Check_Item_Syntax --\n-   -----------------------\n-\n-   procedure Check_Item_Syntax (Item : Node_Id) is\n-   begin\n-      --  Null can appear in various annotation lists to denote a missing or\n-      --  optional relation.\n-\n-      if Nkind (Item) = N_Null then\n-         null;\n-\n-      --  Formal parameter, state or variable nodes\n-\n-      elsif Nkind_In (Item, N_Expanded_Name,\n-                            N_Identifier,\n-                            N_Selected_Component)\n-      then\n-         null;\n-\n-      --  Attribute 'Result can appear in annotations to denote the outcome of\n-      --  a function call.\n-\n-      elsif Is_Attribute_Result (Item) then\n-         null;\n-\n-      --  Any other node cannot possibly denote a legal SPARK item\n-\n-      else\n-         Error_Msg_N (\"malformed item\", Item);\n-      end if;\n-   end Check_Item_Syntax;\n-\n    ----------------\n    -- Check_Kind --\n    ----------------\n@@ -24853,10 +24433,17 @@ package body Sem_Prag is\n    --  Start of processing for Check_Missing_Part_Of\n \n    begin\n+      --  Do not consider abstract states, variables or package instantiations\n+      --  coming from an instance as those always inherit the Part_Of indicator\n+      --  of the instance itself.\n+\n+      if In_Instance then\n+         return;\n+\n       --  Do not consider internally generated entities as these can never\n       --  have a Part_Of indicator.\n \n-      if not Comes_From_Source (Item_Id) then\n+      elsif not Comes_From_Source (Item_Id) then\n          return;\n \n       --  Perform these checks only when SPARK_Mode is enabled as they will\n@@ -25059,7 +24646,7 @@ package body Sem_Prag is\n \n          if Present (State_Id) then\n             Error_Msg_Name_1 := Chars (Constit_Id);\n-            Error_Msg_NE\n+            SPARK_Msg_NE\n               (\"cannot mention state & and its constituent % in the same \"\n                & \"context\", Context, State_Id);\n             exit;\n@@ -25199,10 +24786,12 @@ package body Sem_Prag is\n                raise Program_Error;\n             end if;\n \n-         --  Invalid list\n+         --  To accomodate partial decoration of disabled SPARK features, this\n+         --  routine may be called with illegal input. If this is the case, do\n+         --  not raise Program_Error.\n \n          else\n-            raise Program_Error;\n+            null;\n          end if;\n       end Process_Global_List;\n \n@@ -25305,10 +24894,12 @@ package body Sem_Prag is\n                end loop;\n             end if;\n \n-         --  Invalid list\n+         --  To accomodate partial decoration of disabled SPARK features, this\n+         --  routine may be called with illegal input. If this is the case, do\n+         --  not raise Program_Error.\n \n          else\n-            raise Program_Error;\n+            null;\n          end if;\n       end Collect_Global_List;\n \n@@ -25616,13 +25207,13 @@ package body Sem_Prag is\n             if Nkind (Expr) = N_Aggregate\n               and then Present (Component_Associations (Expr))\n             then\n-               Error_Msg_N\n+               SPARK_Msg_N\n                  (\"dependency clause contains extra parentheses\", Expr);\n \n             --  Otherwise the expression is a malformed construct\n \n             else\n-               Error_Msg_N (\"malformed dependency clause\", Expr);\n+               SPARK_Msg_N (\"malformed dependency clause\", Expr);\n             end if;\n \n             Next (Expr);"}]}