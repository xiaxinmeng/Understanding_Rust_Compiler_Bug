{"sha": "cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmNDRjMTBhZTFmNGQzZGM3M2FiZWQ4NWRmYTc4NWI3MGE1NTNlMQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2017-09-12T07:24:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2017-09-12T07:24:32Z"}, "message": "tree-ssa-threadbackward.c (fsm_find_thread_path): Make GC vectors heap vectors.\n\n\t* tree-ssa-threadbackward.c (fsm_find_thread_path): Make GC\n\tvectors heap vectors.  Clean up comments.\n\tMake visited_bbs a reference.\n\t(profitable_jump_thread_path): Make GC\n\tvectors heap vectors.  Clean up comments.\n\tMisc cleanups.\n\t(convert_and_register_jump_thread_path): Make GC vectors heap\n\tvectors.\n\t(check_subpath_and_update_thread_path): Same.  Clean up comments.\n\tMake visited_bbs a reference.\n\t(handle_phi): Abstract common code to to\n\tregister_jump_thread_path_if_profitable.\n\tRename VAR_BB to DEF_BB.\n\tUpdate comments.\n\tMake GC vectors heap vectors.\n\tMake visited_bbs a reference.\n\t(handle_assignment): Same.\n\t(register_jump_thread_path_if_profitable): New.\n\t(fsm_find_control_statement_thread_paths): Rename VAR_BB to\n\tDEF_BB.\n\tMake GC\tvectors heap vectors.  Clean up comments.\n\tMake visited_bbs a reference.\n\t(find_jump_threads_backwards): Make visited_bbs live in the stack.\n\t* tree-ssa-threadupdate.c (delete_jump_thread_path): Fix typo in\n\tcomment.\n\nFrom-SVN: r251998", "tree": {"sha": "4e0a7a26649e757b926dfff57e4c91b6717ba8f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e0a7a26649e757b926dfff57e4c91b6717ba8f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "072f1e63ad57fdcabb2ce52eaa7e57410bf442cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/072f1e63ad57fdcabb2ce52eaa7e57410bf442cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/072f1e63ad57fdcabb2ce52eaa7e57410bf442cb"}], "stats": {"total": 310, "additions": 166, "deletions": 144}, "files": [{"sha": "68a4b3ebec6034d60e9c429edff42da8fa07f40c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "patch": "@@ -1,3 +1,31 @@\n+2017-09-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-ssa-threadbackward.c (fsm_find_thread_path): Make GC\n+\tvectors heap vectors.  Clean up comments.\n+\tMake visited_bbs a reference.\n+\t(profitable_jump_thread_path): Make GC\n+\tvectors heap vectors.  Clean up comments.\n+\tMisc cleanups.\n+\t(convert_and_register_jump_thread_path): Make GC vectors heap\n+\tvectors.\n+\t(check_subpath_and_update_thread_path): Same.  Clean up comments.\n+\tMake visited_bbs a reference.\n+\t(handle_phi): Abstract common code to to\n+\tregister_jump_thread_path_if_profitable.\n+\tRename VAR_BB to DEF_BB.\n+\tUpdate comments.\n+\tMake GC vectors heap vectors.\n+\tMake visited_bbs a reference.\n+\t(handle_assignment): Same.\n+\t(register_jump_thread_path_if_profitable): New.\n+\t(fsm_find_control_statement_thread_paths): Rename VAR_BB to\n+\tDEF_BB.\n+\tMake GC\tvectors heap vectors.  Clean up comments.\n+\tMake visited_bbs a reference.\n+\t(find_jump_threads_backwards): Make visited_bbs live in the stack.\n+\t* tree-ssa-threadupdate.c (delete_jump_thread_path): Fix typo in\n+\tcomment.\n+\n 2017-09-11  Max Filippov  <jcmvbkbc@gmail.com>\n \n \tPR target/82181"}, {"sha": "12bc80350f584314eeca29883e628d958d7b241d", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 137, "deletions": 143, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "patch": "@@ -59,33 +59,34 @@ get_gimple_control_stmt (basic_block bb)\n   return NULL;\n }\n \n-/* Return true if the CFG contains at least one path from START_BB to END_BB.\n-   When a path is found, record in PATH the blocks from END_BB to START_BB.\n-   VISITED_BBS is used to make sure we don't fall into an infinite loop.  Bound\n-   the recursion to basic blocks belonging to LOOP.  */\n+/* Return true if the CFG contains at least one path from START_BB to\n+   END_BB.  When a path is found, record in PATH the blocks from\n+   END_BB to START_BB.  VISITED_BBS is used to make sure we don't fall\n+   into an infinite loop.  Bound the recursion to basic blocks\n+   belonging to LOOP.  */\n \n static bool\n fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n-\t\t      vec<basic_block, va_gc> *&path,\n-\t\t      hash_set<basic_block> *visited_bbs, loop_p loop)\n+\t\t      vec<basic_block> &path,\n+\t\t      hash_set<basic_block> &visited_bbs, loop_p loop)\n {\n   if (loop != start_bb->loop_father)\n     return false;\n \n   if (start_bb == end_bb)\n     {\n-      vec_safe_push (path, start_bb);\n+      path.safe_push (start_bb);\n       return true;\n     }\n \n-  if (!visited_bbs->add (start_bb))\n+  if (!visited_bbs.add (start_bb))\n     {\n       edge e;\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, start_bb->succs)\n \tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop))\n \t  {\n-\t    vec_safe_push (path, start_bb);\n+\t    path.safe_push (start_bb);\n \t    return true;\n \t  }\n     }\n@@ -99,21 +100,21 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n    final taken edge from the path, NULL otherwise.\n \n    NAME is the SSA_NAME of the variable we found to have a constant\n-   value on PATH.  ARG is the value of that SSA_NAME.\n+   value on PATH.  ARG is the constant value of NAME on that path.\n \n    BBI will be appended to PATH when we have a profitable jump threading\n    path.  Callers are responsible for removing BBI from PATH in that case.\n \n-   SPEED_P indicate that we could increase code size to improve the code path */\n+   SPEED_P indicate that we could increase code size to improve the\n+   code path.  */\n \n static edge\n-profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n-\t\t\t     basic_block bbi, tree name, tree arg, bool speed_p,\n-\t\t\t     bool *creates_irreducible_loop)\n+profitable_jump_thread_path (vec<basic_block> &path,\n+\t\t\t     basic_block bbi, tree name, tree arg,\n+\t\t\t     bool speed_p, bool *creates_irreducible_loop)\n {\n   /* Note BBI is not in the path yet, hence the +1 in the test below\n      to make sure BBI is accounted for in the path length test.  */\n-  int path_length = path->length ();\n \n   /* We can get a length of 0 here when the statement that\n      makes a conditional generate a compile-time constant\n@@ -124,10 +125,10 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n      wanted by wiring up all the incoming edges.  If we run this\n      early in IPA, that might be worth doing.   For now we just\n      reject that case.  */\n-  if (path_length == 0)\n+  if (path.is_empty ())\n       return NULL;\n \n-  if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+  if (path.length () + 1 > (unsigned) PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n@@ -148,13 +149,11 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n   /* Add BBI to the path.\n      From this point onward, if we decide we the path is not profitable\n      to thread, we must remove BBI from the path.  */\n-  vec_safe_push (path, bbi);\n-  ++path_length;\n+  path.safe_push (bbi);\n \n   int n_insns = 0;\n   gimple_stmt_iterator gsi;\n-  int j;\n-  loop_p loop = (*path)[0]->loop_father;\n+  loop_p loop = path[0]->loop_father;\n   bool path_crosses_loops = false;\n   bool threaded_through_latch = false;\n   bool multiway_branch_in_path = false;\n@@ -168,9 +167,9 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n      will have to be duplicated, we will not record the path if there\n      are too many instructions on the path.  Also check that all the\n      blocks in the path belong to a single loop.  */\n-  for (j = 0; j < path_length; j++)\n+  for (unsigned j = 0; j < path.length (); j++)\n     {\n-      basic_block bb = (*path)[j];\n+      basic_block bb = path[j];\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \" bb:%i\", bb->index);\n@@ -181,7 +180,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \t loop father, nor how many statements are in that block because\n \t it will not be copied or whether or not it ends in a multiway\n \t branch.  */\n-      if (j < path_length - 1)\n+      if (j < path.length () - 1)\n \t{\n \t  int orig_n_insns = n_insns;\n \t  if (bb->loop_father != loop)\n@@ -268,7 +267,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \tthreaded_through_latch = true;\n     }\n \n-  gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n+  gimple *stmt = get_gimple_control_stmt (path[0]);\n   gcc_assert (stmt);\n \n   /* We are going to remove the control statement at the end of the\n@@ -301,14 +300,14 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n      latch, then this thread would create an irreducible loop.\n \n      We have to know the outgoing edge to figure this out.  */\n-  edge taken_edge = find_taken_edge ((*path)[0], arg);\n+  edge taken_edge = find_taken_edge (path[0], arg);\n \n   /* There are cases where we may not be able to extract the\n      taken edge.  For example, a computed goto to an absolute\n      address.  Handle those cases gracefully.  */\n   if (taken_edge == NULL)\n     {\n-      path->pop ();\n+      path.pop ();\n       return NULL;\n     }\n \n@@ -324,7 +323,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n \t\t \"the path crosses loops.\\n\");\n-      path->pop ();\n+      path.pop ();\n       return NULL;\n     }\n \n@@ -340,7 +339,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n \t\t     \"the number of instructions on the path \"\n \t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n-\t  path->pop ();\n+\t  path.pop ();\n \t  return NULL;\n \t}\n     }\n@@ -350,7 +349,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n \t\t \"duplication of %i insns is needed and optimizing for size.\\n\",\n \t\t n_insns);\n-      path->pop ();\n+      path.pop ();\n       return NULL;\n     }\n \n@@ -364,15 +363,16 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n      optimizer would have done anyway, so an irreducible loop is not\n      so bad.  */\n   if (!threaded_multiway_branch && *creates_irreducible_loop\n-      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n-\t  > path_length * PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS)))\n+      && (n_insns * (unsigned) PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n+\t  > (path.length () *\n+\t     (unsigned) PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS))))\n \n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"FSM would create irreducible loop without threading \"\n \t\t \"multiway branch.\\n\");\n-      path->pop ();\n+      path.pop ();\n       return NULL;\n     }\n \n@@ -392,7 +392,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \tfprintf (dump_file,\n \t\t \"FSM did not thread around loop and would copy too \"\n \t\t \"many statements.\\n\");\n-      path->pop ();\n+      path.pop ();\n       return NULL;\n     }\n \n@@ -406,7 +406,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \tfprintf (dump_file,\n \t\t \"FSM Thread through multiway branch without threading \"\n \t\t \"a multiway branch.\\n\");\n-      path->pop ();\n+      path.pop ();\n       return NULL;\n     }\n   return taken_edge;\n@@ -419,16 +419,15 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n    register the path.   */\n \n static void\n-convert_and_register_jump_thread_path (vec<basic_block, va_gc> *path,\n-\t\t\t\t       edge taken_edge)\n+convert_and_register_jump_thread_path (vec<basic_block> &path, edge taken_edge)\n {\n   vec<jump_thread_edge *> *jump_thread_path = new vec<jump_thread_edge *> ();\n \n   /* Record the edges between the blocks in PATH.  */\n-  for (unsigned int j = 0; j < path->length () - 1; j++)\n+  for (unsigned int j = 0; j + 1 < path.length (); j++)\n     {\n-      basic_block bb1 = (*path)[path->length () - j - 1];\n-      basic_block bb2 = (*path)[path->length () - j - 2];\n+      basic_block bb1 = path[path.length () - j - 1];\n+      basic_block bb2 = path[path.length () - j - 2];\n \n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n@@ -445,82 +444,104 @@ convert_and_register_jump_thread_path (vec<basic_block, va_gc> *path,\n   --max_threaded_paths;\n }\n \n-/* While following a chain of SSA_NAME definitions, we jumped from a definition\n-   in LAST_BB to a definition in VAR_BB (walking backwards).\n+/* While following a chain of SSA_NAME definitions, we jumped from a\n+   definition in LAST_BB to a definition in NEW_BB (walking\n+   backwards).\n \n-   Verify there is a single path between the blocks and none of the blocks\n-   in the path is already in VISITED_BBS.  If so, then update VISISTED_BBS,\n-   add the new blocks to PATH and return TRUE.  Otherwise return FALSE.\n+   Verify there is a single path between the blocks and none of the\n+   blocks in the path is already in VISITED_BBS.  If so, then update\n+   VISISTED_BBS, add the new blocks to PATH and return TRUE.\n+   Otherwise return FALSE.\n \n    Store the length of the subpath in NEXT_PATH_LENGTH.  */\n \n static bool\n check_subpath_and_update_thread_path (basic_block last_bb, basic_block new_bb,\n-\t\t\t\t      hash_set<basic_block> *visited_bbs,\n-\t\t\t\t      vec<basic_block, va_gc> *&path,\n+\t\t\t\t      hash_set<basic_block> &visited_bbs,\n+\t\t\t\t      vec<basic_block> &path,\n \t\t\t\t      int *next_path_length)\n {\n   edge e;\n   int e_count = 0;\n   edge_iterator ei;\n-  vec<basic_block, va_gc> *next_path;\n-  vec_alloc (next_path, 10);\n+  auto_vec<basic_block> next_path;\n \n   FOR_EACH_EDGE (e, ei, last_bb->preds)\n     {\n-      hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n+      hash_set<basic_block> visited_bbs;\n \n       if (fsm_find_thread_path (new_bb, e->src, next_path, visited_bbs,\n \t\t\t\te->src->loop_father))\n \t++e_count;\n \n-      delete visited_bbs;\n-\n       /* If there is more than one path, stop.  */\n       if (e_count > 1)\n-\t{\n-\t  vec_free (next_path);\n-\t  return false;\n-\t}\n+\treturn false;\n     }\n \n   /* Stop if we have not found a path: this could occur when the recursion\n      is stopped by one of the bounds.  */\n   if (e_count == 0)\n-    {\n-      vec_free (next_path);\n-      return false;\n-    }\n+    return false;\n \n   /* Make sure we haven't already visited any of the nodes in\n      NEXT_PATH.  Don't add them here to avoid pollution.  */\n-  for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+  for (unsigned int i = 0; i + 1 < next_path.length (); i++)\n     {\n-      if (visited_bbs->contains ((*next_path)[i]))\n-\t{\n-\t  vec_free (next_path);\n-\t  return false;\n-\t}\n+      if (visited_bbs.contains (next_path[i]))\n+\treturn false;\n     }\n \n   /* Now add the nodes to VISISTED_BBS.  */\n-  for (unsigned int i = 0; i < next_path->length () - 1; i++)\n-    visited_bbs->add ((*next_path)[i]);\n+  for (unsigned int i = 0; i + 1 < next_path.length (); i++)\n+    visited_bbs.add (next_path[i]);\n \n   /* Append all the nodes from NEXT_PATH to PATH.  */\n-  vec_safe_splice (path, next_path);\n-  *next_path_length = next_path->length ();\n-  vec_free (next_path);\n+  path.safe_splice (next_path);\n+  *next_path_length = next_path.length ();\n \n   return true;\n }\n \n+/* If this is a profitable jump thread path, register it.\n+\n+   NAME is an SSA NAME with a possible constant value of ARG on PATH.\n+\n+   DEF_BB is the basic block that ultimately defines the constant.\n+\n+   SPEED_P indicate that we could increase code size to improve the\n+   code path.\n+*/\n+\n+static void\n+register_jump_thread_path_if_profitable (vec<basic_block> &path,\n+\t\t\t\t\t tree name,\n+\t\t\t\t\t tree arg,\n+\t\t\t\t\t basic_block def_bb,\n+\t\t\t\t\t bool speed_p)\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n+    return;\n+\n+  bool irreducible = false;\n+  edge taken_edge = profitable_jump_thread_path (path, def_bb, name, arg,\n+\t\t\t\t\t\t speed_p, &irreducible);\n+  if (taken_edge)\n+    {\n+      convert_and_register_jump_thread_path (path, taken_edge);\n+      path.pop ();\n+\n+      if (irreducible)\n+\tvect_free_loop_info_assumptions (path[0]->loop_father);\n+    }\n+}\n+\n static void fsm_find_control_statement_thread_paths (tree,\n-\t\t\t\t\t\t     hash_set<basic_block> *,\n-\t\t\t\t\t\t     vec<basic_block, va_gc> *&,\n+\t\t\t\t\t\t     hash_set<basic_block> &,\n+\t\t\t\t\t\t     vec<basic_block> &,\n \t\t\t\t\t\t     bool, bool);\n \n-/* Given PHI which defines NAME in block VAR_BB, recurse through the\n+/* Given PHI which defines NAME in block DEF_BB, recurse through the\n    PHI's arguments searching for paths where NAME will ultimately have\n    a constant value.\n \n@@ -534,9 +555,9 @@ static void fsm_find_control_statement_thread_paths (tree,\n    SPEED_P indicates if we are optimizing for speed over space.  */\n \n static void\n-handle_phi (gphi *phi, tree name, basic_block var_bb,\n-\t    hash_set<basic_block> *visited_bbs,\n-\t    vec<basic_block, va_gc> *&path,\n+handle_phi (gphi *phi, tree name, basic_block def_bb,\n+\t    hash_set<basic_block> &visited_bbs,\n+\t    vec<basic_block> &path,\n \t    bool seen_loop_phi, bool speed_p)\n {\n   /* Iterate over the arguments of PHI.  */\n@@ -546,37 +567,22 @@ handle_phi (gphi *phi, tree name, basic_block var_bb,\n       basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n \n       /* Skip edges pointing outside the current loop.  */\n-      if (!arg || var_bb->loop_father != bbi->loop_father)\n+      if (!arg || def_bb->loop_father != bbi->loop_father)\n \tcontinue;\n \n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  vec_safe_push (path, bbi);\n+\t  path.safe_push (bbi);\n \t  /* Recursively follow SSA_NAMEs looking for a constant\n \t     definition.  */\n \t  fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n \t\t\t\t\t\t   seen_loop_phi, speed_p);\n \n-\t  path->pop ();\n+\t  path.pop ();\n \t  continue;\n \t}\n \n-      if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n-\tcontinue;\n-\n-      /* If this is a profitable jump thread path, then convert it\n-\t into the canonical form and register it.  */\n-      bool irreducible = false;\n-      edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg,\n-\t\t\t\t\t\t     speed_p, &irreducible);\n-      if (taken_edge)\n-\t{\n-\t  convert_and_register_jump_thread_path (path, taken_edge);\n-\t  path->pop ();\n-\n-\t  if (irreducible)\n-\t    vect_free_loop_info_assumptions ((*path)[0]->loop_father);\n-\t}\n+      register_jump_thread_path_if_profitable (path, name, arg, bbi, speed_p);\n     }\n }\n \n@@ -610,7 +616,7 @@ handle_assignment_p (gimple *stmt)\n   return false;\n }\n \n-/* Given STMT which defines NAME in block VAR_BB, recurse through the\n+/* Given STMT which defines NAME in block DEF_BB, recurse through the\n    PHI's arguments searching for paths where NAME will ultimately have\n    a constant value.\n \n@@ -624,9 +630,9 @@ handle_assignment_p (gimple *stmt)\n    SPEED_P indicates if we are optimizing for speed over space.  */\n \n static void\n-handle_assignment (gimple *stmt, tree name, basic_block var_bb,\n-\t\t   hash_set<basic_block> *visited_bbs,\n-\t\t   vec<basic_block, va_gc> *&path,\n+handle_assignment (gimple *stmt, tree name, basic_block def_bb,\n+\t\t   hash_set<basic_block> &visited_bbs,\n+\t\t   vec<basic_block> &path,\n \t\t   bool seen_loop_phi, bool speed_p)\n {\n   tree arg = gimple_assign_rhs1 (stmt);\n@@ -637,40 +643,31 @@ handle_assignment (gimple *stmt, tree name, basic_block var_bb,\n \n   else\n     {\n-      /* profitable_jump_thread_path is going to push the current\n+      /* register_jump_thread_path_if_profitable will push the current\n \t block onto the path.  But the path will always have the current\n \t block at this point.  So we can just pop it.  */\n-      path->pop ();\n+      path.pop ();\n \n-      bool irreducible = false;\n-      edge taken_edge = profitable_jump_thread_path (path, var_bb,\n-\t\t\t\t\t\t     name, arg, speed_p,\n-\t\t\t\t\t\t     &irreducible);\n-      if (taken_edge)\n-\t{\n-\t  convert_and_register_jump_thread_path (path, taken_edge);\n-\t  path->pop ();\n-\n-\t  if (irreducible)\n-\t    vect_free_loop_info_assumptions ((*path)[0]->loop_father);\n-\t}\n+      register_jump_thread_path_if_profitable (path, name, arg, def_bb,\n+\t\t\t\t\t       speed_p);\n \n       /* And put the current block back onto the path so that the\n \t state of the stack is unchanged when we leave.  */\n-      vec_safe_push (path, var_bb);\n+      path.safe_push (def_bb);\n     }\n }\n \n-/* We trace the value of the SSA_NAME NAME back through any phi nodes looking\n-   for places where it gets a constant value and save the path.  Stop after\n-   having recorded MAX_PATHS jump threading paths.\n+/* We trace the value of the SSA_NAME NAME back through any phi nodes\n+   looking for places where it gets a constant value and save the\n+   path.\n \n-   SPEED_P indicate that we could increase code size to improve the code path */\n+   SPEED_P indicate that we could increase code size to improve the\n+   code path.  */\n \n static void\n fsm_find_control_statement_thread_paths (tree name,\n-\t\t\t\t\t hash_set<basic_block> *visited_bbs,\n-\t\t\t\t\t vec<basic_block, va_gc> *&path,\n+\t\t\t\t\t hash_set<basic_block> &visited_bbs,\n+\t\t\t\t\t vec<basic_block> &path,\n \t\t\t\t\t bool seen_loop_phi, bool speed_p)\n {\n   /* If NAME appears in an abnormal PHI, then don't try to trace its\n@@ -679,9 +676,9 @@ fsm_find_control_statement_thread_paths (tree name,\n     return;\n \n   gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-  basic_block var_bb = gimple_bb (def_stmt);\n+  basic_block def_bb = gimple_bb (def_stmt);\n \n-  if (var_bb == NULL)\n+  if (def_bb == NULL)\n     return;\n \n   /* We allow the SSA chain to contains PHIs and simple copies and constant\n@@ -700,11 +697,11 @@ fsm_find_control_statement_thread_paths (tree name,\n     return;\n \n   /* Avoid infinite recursion.  */\n-  if (visited_bbs->add (var_bb))\n+  if (visited_bbs.add (def_bb))\n     return;\n \n   int next_path_length = 0;\n-  basic_block last_bb_in_path = path->last ();\n+  basic_block last_bb_in_path = path.last ();\n \n   if (loop_containing_stmt (def_stmt)->header == gimple_bb (def_stmt))\n     {\n@@ -715,41 +712,42 @@ fsm_find_control_statement_thread_paths (tree name,\n     }\n \n   /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n-     LAST_BB_IN_PATH to a definition in VAR_BB.  When these basic blocks are\n-     different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n-  if (var_bb != last_bb_in_path)\n+     LAST_BB_IN_PATH to a definition in DEF_BB.  When these basic blocks are\n+     different, append to PATH the blocks from LAST_BB_IN_PATH to DEF_BB.  */\n+  if (def_bb != last_bb_in_path)\n     {\n-      /* When VAR_BB == LAST_BB_IN_PATH, then the first block in the path\n+      /* When DEF_BB == LAST_BB_IN_PATH, then the first block in the path\n \t will already be in VISITED_BBS.  When they are not equal, then we\n \t must ensure that first block is accounted for to ensure we do not\n \t create bogus jump threading paths.  */\n-      visited_bbs->add ((*path)[0]);\n-      if (!check_subpath_and_update_thread_path (last_bb_in_path, var_bb,\n+      visited_bbs.add (path[0]);\n+      if (!check_subpath_and_update_thread_path (last_bb_in_path, def_bb,\n \t\t\t\t\t\t visited_bbs, path,\n \t\t\t\t\t\t &next_path_length))\n \treturn;\n     }\n \n-  gcc_assert (path->last () == var_bb);\n+  gcc_assert (path.last () == def_bb);\n \n   if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    handle_phi (as_a <gphi *> (def_stmt), name, var_bb,\n+    handle_phi (as_a <gphi *> (def_stmt), name, def_bb,\n \t\tvisited_bbs, path, seen_loop_phi, speed_p);\n   else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    handle_assignment (def_stmt, name, var_bb,\n+    handle_assignment (def_stmt, name, def_bb,\n \t\t       visited_bbs, path, seen_loop_phi, speed_p);\n \n   /* Remove all the nodes that we added from NEXT_PATH.  */\n   if (next_path_length)\n-    vec_safe_truncate (path, (path->length () - next_path_length));\n+    path.truncate (path.length () - next_path_length);\n }\n \n /* Search backwards from BB looking for paths where NAME (an SSA_NAME)\n    is a constant.  Record such paths for jump threading.\n \n    It is assumed that BB ends with a control statement and that by\n    finding a path where NAME is a constant, we can thread the path.\n-   SPEED_P indicate that we could increase code size to improve the code path */\n+   SPEED_P indicate that we could increase code size to improve the\n+   code path.  */\n \n void  \n find_jump_threads_backwards (basic_block bb, bool speed_p)\n@@ -776,17 +774,13 @@ find_jump_threads_backwards (basic_block bb, bool speed_p)\n   if (!name || TREE_CODE (name) != SSA_NAME)\n     return;\n \n-  vec<basic_block, va_gc> *bb_path;\n-  vec_alloc (bb_path, 10);\n-  vec_safe_push (bb_path, bb);\n-  hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n+  auto_vec<basic_block> bb_path;\n+  bb_path.safe_push (bb);\n+  hash_set<basic_block> visited_bbs;\n \n   max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n   fsm_find_control_statement_thread_paths (name, visited_bbs, bb_path, false,\n \t\t\t\t\t   speed_p);\n-\n-  delete visited_bbs;\n-  vec_free (bb_path);\n }\n \n namespace {"}, {"sha": "28c81a6ec5706fffbf5d51239a5b230914a260d0", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff44c10ae1f4d3dc73abed85dfa785b70a553e1/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=cff44c10ae1f4d3dc73abed85dfa785b70a553e1", "patch": "@@ -2577,7 +2577,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   return retval;\n }\n \n-/* Delete the jump threading path PATH.  We have to explcitly delete\n+/* Delete the jump threading path PATH.  We have to explicitly delete\n    each entry in the vector, then the container.  */\n \n void"}]}