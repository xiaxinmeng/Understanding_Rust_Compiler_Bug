{"sha": "e5e442524724592b9f6e969354ba33c4f20f6ab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlNDQyNTI0NzI0NTkyYjlmNmU5NjkzNTRiYTMzYzRmMjBmNmFiMg==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-11-11T05:10:58Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-11-11T05:10:58Z"}, "message": "Error out for Cilk_spawn or array expression in forbidden places\n\n_Cilk_spawn or Cilk array expressions are only allowed on their own,\nbut not in for(), if(), switch, do, while, goto, etc.\nThe C parser didn't always check for that, which lead to ICEs earlier\nfor invalid code.\n\nAdd a generic helper that checks this and call it where needed\nin the C frontend.\n\nI chose to allow spawn/array for for init and increment expressions.\nWhile the Cilk spec could be interpreted to forbid it there too\nthere didn't seem any reason to not allow it.\n\nOne dark corner is spawn, array in statement expressions not at\nthe end. Right now that's forbidden too.\n\ngcc/c-family/:\n\n2014-11-10  Andi Kleen  <ak@linux.intel.com>\n\n\tPR c/60804\n\t* c-common.h (check_no_cilk): Declare.\n\t* cilk.c (get_error_location): New function.\n\t(check_no_cilk): Dito.\n\ngcc/c/:\n\n2014-11-10  Andi Kleen  <ak@linux.intel.com>\n\n\tPR c/60804\n\t* c-parser.c (c_parser_statement_after_labels): Call\n\tcheck_no_cilk.\n\t(c_parser_if_statement): Dito.\n\t(c_parser_switch_statement): Dito.\n\t(c_parser_while_statement): Dito.\n\t(c_parser_do_statement): Dito.\n\t(c_parser_for_statement): Dito.\n\t* c-typeck.c (c_finish_loop): Dito.\n\nFrom-SVN: r217336", "tree": {"sha": "71d74f86916e6654aeaf8532ad17469a9101b2cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71d74f86916e6654aeaf8532ad17469a9101b2cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e442524724592b9f6e969354ba33c4f20f6ab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e442524724592b9f6e969354ba33c4f20f6ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e442524724592b9f6e969354ba33c4f20f6ab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e442524724592b9f6e969354ba33c4f20f6ab2/comments", "author": null, "committer": null, "parents": [{"sha": "300553307af73f9a4ba83affc62c8263d3b90f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/300553307af73f9a4ba83affc62c8263d3b90f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/300553307af73f9a4ba83affc62c8263d3b90f9e"}], "stats": {"total": 135, "additions": 101, "deletions": 34}, "files": [{"sha": "33c7d29b8a19ef64a8910a868d7cba4cf47bb27f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e5e442524724592b9f6e969354ba33c4f20f6ab2", "patch": "@@ -1,3 +1,10 @@\n+2014-11-10  Andi Kleen  <ak@linux.intel.com>\n+\n+\tPR c/60804\n+\t* c-common.h (check_no_cilk): Declare.\n+\t* cilk.c (get_error_location): New function.\n+\t(check_no_cilk): Dito.\n+\n 2014-11-10  Andi Kleen  <ak@linux.intel.com>\n \n \t* cilk.c (recognize_spawn): Use expression location"}, {"sha": "ca6fc8beaf88323e335a3bae7fecd81b664ad2bb", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e5e442524724592b9f6e969354ba33c4f20f6ab2", "patch": "@@ -1414,4 +1414,6 @@ extern tree cilk_install_body_pedigree_operations (tree);\n extern void cilk_outline (tree, tree *, void *);\n extern bool contains_cilk_spawn_stmt (tree);\n extern tree cilk_for_number_of_iterations (tree);\n+extern bool check_no_cilk (tree, const char *, const char *,\n+\t\t           location_t loc = UNKNOWN_LOCATION);\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "a0cef4f3ab3c30221d647a97d139dd3a37b79f62", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=e5e442524724592b9f6e969354ba33c4f20f6ab2", "patch": "@@ -1324,3 +1324,42 @@ contains_cilk_spawn_stmt (tree expr)\n   return walk_tree (&expr, contains_cilk_spawn_stmt_walker, NULL, NULL)\n \t != NULL_TREE;\n }\n+\n+/* Return a error location for EXPR if LOC is not set.  */\n+\n+static location_t\n+get_error_location (tree expr, location_t loc)\n+{\n+  if (loc == UNKNOWN_LOCATION)\n+    {\n+      if (TREE_CODE (expr) == MODIFY_EXPR)\n+        expr = TREE_OPERAND (expr, 0);\n+      loc = EXPR_LOCATION (expr);\n+    }\n+  return loc;\n+}\n+\n+/* Check that no array notation or spawn statement is in EXPR.\n+   If not true generate an error at LOC for ARRAY_GMSGID or\n+   SPAWN_MSGID.  */\n+\n+bool\n+check_no_cilk (tree expr, const char *array_msgid, const char *spawn_msgid,\n+\t      location_t loc)\n+{\n+  if (!flag_cilkplus)\n+    return false;\n+  if (contains_array_notation_expr (expr))\n+    {\n+      loc = get_error_location (expr, loc);\n+      error_at (loc, array_msgid);\n+      return true;\n+    }\n+  if (walk_tree (&expr, contains_cilk_spawn_stmt_walker, NULL, NULL))\n+    {\n+      loc = get_error_location (expr, loc);\n+      error_at (loc, spawn_msgid);\n+      return true;\n+    }\n+  return false;\n+}"}, {"sha": "c4cf2bcd684edd0c733d703159a2be6bf8aa8b23", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=e5e442524724592b9f6e969354ba33c4f20f6ab2", "patch": "@@ -1,3 +1,15 @@\n+2014-11-10  Andi Kleen  <ak@linux.intel.com>\n+\n+\tPR c/60804\n+\t* c-parser.c (c_parser_statement_after_labels): Call\n+\tcheck_no_cilk.\n+\t(c_parser_if_statement): Dito.\n+\t(c_parser_switch_statement): Dito.\n+\t(c_parser_while_statement): Dito.\n+\t(c_parser_do_statement): Dito.\n+\t(c_parser_for_statement): Dito.\n+\t* c-typeck.c (c_finish_loop): Dito.\n+\n 2014-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* c-typeck.c (build_binary_op): Use OPT_Wshift_count_negative and"}, {"sha": "f90f6af776e9cc26224c24ba2877b2662b0b0edd", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=e5e442524724592b9f6e969354ba33c4f20f6ab2", "patch": "@@ -4965,6 +4965,11 @@ c_parser_statement_after_labels (c_parser *parser)\n \n \t      c_parser_consume_token (parser);\n \t      val = c_parser_expression (parser);\n+\t      if (check_no_cilk (val.value,\n+\t\t\t\t \"Cilk array notation cannot be used as a computed goto expression\",\n+\t\t\t\t \"%<_Cilk_spawn%> statement cannot be used as a computed goto expression\",\n+\t\t\t\t loc))\n+\t        val.value = error_mark_node;\n \t      val = convert_lvalue_to_rvalue (loc, val, false, true);\n \t      stmt = c_finish_goto_ptr (loc, val.value);\n \t    }\n@@ -5018,8 +5023,15 @@ c_parser_statement_after_labels (c_parser *parser)\n \t    {\n \t      struct c_expr expr = c_parser_expression (parser);\n \t      expr = convert_lvalue_to_rvalue (loc, expr, false, false);\n-\t      expr.value = c_fully_fold (expr.value, false, NULL);\n-\t      stmt = objc_build_throw_stmt (loc, expr.value);\n+\t      if (check_no_cilk (expr.value,\n+\t\t \"Cilk array notation cannot be used for a throw expression\",\n+\t\t \"%<_Cilk_spawn%> statement cannot be used for a throw expression\"))\n+\t        expr.value = error_mark_node;\n+\t      else\n+\t\t{\n+\t          expr.value = c_fully_fold (expr.value, false, NULL);\n+\t          stmt = objc_build_throw_stmt (loc, expr.value);\n+\t\t}\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -5194,6 +5206,11 @@ c_parser_if_statement (c_parser *parser)\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_paren_condition (parser);\n+  if (flag_cilkplus && contains_cilk_spawn_stmt (cond))\n+    {\n+      error_at (loc, \"if statement cannot contain %<Cilk_spawn%>\");\n+      cond = error_mark_node;\n+    }\n   in_if_block = parser->in_if_block;\n   parser->in_if_block = true;\n   first_body = c_parser_if_body (parser, &first_if);\n@@ -5240,13 +5257,12 @@ c_parser_switch_statement (c_parser *parser)\n       ce = c_parser_expression (parser);\n       ce = convert_lvalue_to_rvalue (switch_cond_loc, ce, true, false);\n       expr = ce.value;\n-      if (flag_cilkplus && contains_array_notation_expr (expr))\n-\t{\n-\t  error_at (switch_cond_loc,\n-\t\t    \"array notations cannot be used as a condition for switch \"\n-\t\t    \"statement\");\n-\t  expr = error_mark_node;\n-\t}\n+      /* ??? expr has no valid location?  */\n+      if (check_no_cilk (expr,\n+\t \"Cilk array notation cannot be used as a condition for switch statement\",\n+\t \"%<_Cilk_spawn%> statement cannot be used as a condition for switch statement\",\n+\t\t\t switch_cond_loc))\n+        expr = error_mark_node;\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   else\n@@ -5286,13 +5302,10 @@ c_parser_while_statement (c_parser *parser, bool ivdep)\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_paren_condition (parser);\n-  if (flag_cilkplus && contains_array_notation_expr (cond))\n-    {\n-      error_at (loc, \"array notations cannot be used as a condition for while \"\n-\t\t\"statement\");\n-      cond = error_mark_node;\n-    }\n-\n+  if (check_no_cilk (cond,\n+         \"Cilk array notation cannot be used as a condition for while statement\",\n+\t \"%<_Cilk_spawn%> statement cannot be used as a condition for while statement\"))\n+    cond = error_mark_node;\n   if (ivdep && cond != error_mark_node)\n     cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node,\n@@ -5338,12 +5351,10 @@ c_parser_do_statement (c_parser *parser, bool ivdep)\n   new_cont = c_cont_label;\n   c_cont_label = save_cont;\n   cond = c_parser_paren_condition (parser);\n-  if (flag_cilkplus && contains_array_notation_expr (cond))\n-    {\n-      error_at (loc, \"array notations cannot be used as a condition for a \"\n-\t\t\"do-while statement\");\n-      cond = error_mark_node;\n-    }\n+  if (check_no_cilk (cond,\n+\t \"Cilk array notation cannot be used as a condition for a do-while statement\",\n+\t \"%<_Cilk_spawn%> statement cannot be used as a condition for a do-while statement\"))\n+    cond = error_mark_node;\n   if (ivdep && cond != error_mark_node)\n     cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node,\n@@ -5495,6 +5506,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n \t    struct c_expr ce;\n \t    tree init_expression;\n \t    ce = c_parser_expression (parser);\n+\t    /* In theory we could forbid _Cilk_spawn here, as the spec says \"only in top\n+\t       level statement\", but it works just fine, so allow it.  */\n \t    init_expression = ce.value;\n \t    parser->objc_could_be_foreach_context = false;\n \t    if (c_parser_next_token_is_keyword (parser, RID_IN))\n@@ -5536,12 +5549,10 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n \t  else\n \t    {\n \t      cond = c_parser_condition (parser);\n-\t      if (flag_cilkplus && contains_array_notation_expr (cond))\n-\t\t{\n-\t\t  error_at (loc, \"array notations cannot be used in a \"\n-\t\t\t    \"condition for a for-loop\");\n-\t\t  cond = error_mark_node;\n-\t\t}\n+\t      if (check_no_cilk (cond,\n+\t\t \"Cilk array notation cannot be used in a condition for a for-loop\",\n+\t\t \"%<_Cilk_spawn%> statement cannot be used in a condition for a for-loop\"))\n+\t\tcond = error_mark_node;\n \t      c_parser_skip_until_found (parser, CPP_SEMICOLON,\n \t\t\t\t\t \"expected %<;%>\");\n \t    }"}, {"sha": "338ef44eefba190736ed1bba0f394e9e98d0c59c", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e442524724592b9f6e969354ba33c4f20f6ab2/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=e5e442524724592b9f6e969354ba33c4f20f6ab2", "patch": "@@ -9622,12 +9622,8 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n {\n   tree entry = NULL, exit = NULL, t;\n \n-  if (flag_cilkplus && contains_array_notation_expr (cond))\n-    {\n-      error_at (start_locus, \"array notation expression cannot be used in a \"\n-\t\t\"loop%'s condition\");\n-      return;\n-    }\n+  /* In theory could forbid cilk spawn for loop increment expression,\n+     but it should work just fine.  */\n   \n   /* If the condition is zero don't generate a loop construct.  */\n   if (cond && integer_zerop (cond))"}]}