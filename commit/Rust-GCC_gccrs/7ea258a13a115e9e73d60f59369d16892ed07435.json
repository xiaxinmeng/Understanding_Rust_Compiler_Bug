{"sha": "7ea258a13a115e9e73d60f59369d16892ed07435", "node_id": "C_kwDOANBUbNoAKDdlYTI1OGExM2ExMTVlOWU3M2Q2MGY1OTM2OWQxNjg5MmVkMDc0MzU", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-08-23T14:17:02Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-29T22:34:18Z"}, "message": "Process unsigned overflow relations for plus and minus is range-ops.\n\nIf a relation is available, calculate overflow and normal ranges. Then\napply as appropriate.\n\n\tgcc/\n\t* range-op.cc (plus_minus_ranges): New.\n\t(adjust_op1_for_overflow): New.\n\t(operator_plus::op1_range): Use new adjustment.\n\t(operator_plus::op2_range): Ditto.\n\t(operator_minus::op1_range): Ditto.\n\t* value-relation.h (relation_lt_le_gt_ge_p): New.\n\n\tgcc/testsuite/\n\t* gcc.dg/tree-ssa/pr79095.c: Test evrp pass rather than vrp1.", "tree": {"sha": "b4b6a91902b2930dd8dfb2483a067681afb32913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4b6a91902b2930dd8dfb2483a067681afb32913"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ea258a13a115e9e73d60f59369d16892ed07435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea258a13a115e9e73d60f59369d16892ed07435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea258a13a115e9e73d60f59369d16892ed07435", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea258a13a115e9e73d60f59369d16892ed07435/comments", "author": null, "committer": null, "parents": [{"sha": "67166c9ec35d58efd0225b74730983aa480a88f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67166c9ec35d58efd0225b74730983aa480a88f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67166c9ec35d58efd0225b74730983aa480a88f1"}], "stats": {"total": 129, "additions": 121, "deletions": 8}, "files": [{"sha": "7ef980315b66aba09aa3f4353c39a30dfefed051", "filename": "gcc/range-op.cc", "status": "modified", "additions": 116, "deletions": 5, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea258a13a115e9e73d60f59369d16892ed07435/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea258a13a115e9e73d60f59369d16892ed07435/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=7ea258a13a115e9e73d60f59369d16892ed07435", "patch": "@@ -1305,22 +1305,123 @@ operator_plus::wi_fold (irange &r, tree type,\n   value_range_with_overflow (r, type, new_lb, new_ub, ov_lb, ov_ub);\n }\n \n+// Given addition or subtraction, determine the possible NORMAL ranges and\n+// OVERFLOW ranges given an OFFSET range.  ADD_P is true for addition.\n+// Return the relation that exists between the LHS and OP1 in order for the\n+// NORMAL range to apply.\n+// a return value of VREL_VARYING means no ranges were applicable.\n+\n+static relation_kind\n+plus_minus_ranges (irange &r_ov, irange &r_normal, const irange &offset,\n+\t\tbool add_p)\n+{\n+  relation_kind kind = VREL_VARYING;\n+  // For now, only deal with constant adds.  This could be extended to ranges\n+  // when someone is so motivated.\n+  if (!offset.singleton_p () || offset.zero_p ())\n+    return kind;\n+\n+  // Always work with a positive offset.  ie a+ -2 -> a-2  and a- -2 > a+2\n+  wide_int off = offset.lower_bound ();\n+  if (wi::neg_p (off, SIGNED))\n+    {\n+      add_p = !add_p;\n+      off = wi::neg (off);\n+    }\n+\n+  wi::overflow_type ov;\n+  tree type = offset.type ();\n+  unsigned prec = TYPE_PRECISION (type);\n+  wide_int ub;\n+  wide_int lb;\n+  // calculate the normal range and relation for the operation.\n+  if (add_p)\n+    {\n+      //  [ 0 , INF - OFF]\n+      lb = wi::zero (prec);\n+      ub = wi::sub (wi::to_wide (vrp_val_max (type)), off, UNSIGNED, &ov);\n+      kind = VREL_GT;\n+    }\n+  else\n+    {\n+      //  [ OFF, INF ]\n+      lb = off;\n+      ub = wi::to_wide (vrp_val_max (type));\n+      kind = VREL_LT;\n+    }\n+  int_range<2> normal_range (type, lb, ub);\n+  int_range<2> ov_range (type, lb, ub, VR_ANTI_RANGE);\n+\n+  r_ov = ov_range;\n+  r_normal = normal_range;\n+  return kind;\n+}\n+\n+// Once op1 has been calculated by operator_plus or operator_minus, check\n+// to see if the relation passed causes any part of the calculation to\n+// be not possible.  ie\n+// a_2 = b_3 + 1  with a_2 < b_3 can refine the range of b_3 to [INF, INF]\n+// and that further refines a_2 to [0, 0].\n+// R is the value of op1, OP2 is the offset being added/subtracted, REL is the\n+// relation between LHS relatoin OP1  and ADD_P is true for PLUS, false for\n+// MINUS.    IF any adjustment can be made, R will reflect it.\n+\n+static void\n+adjust_op1_for_overflow (irange &r, const irange &op2, relation_kind rel,\n+\t\t\t bool add_p)\n+{\n+  tree type = r.type ();\n+  // Check for unsigned overflow and calculate the overflow part.\n+  signop s = TYPE_SIGN (type);\n+  if (!TYPE_OVERFLOW_WRAPS (type) || s == SIGNED)\n+    return;\n+\n+  // Only work with <, <=, >, >= relations.\n+  if (!relation_lt_le_gt_ge_p (rel))\n+    return;\n+\n+  // Get the ranges for this offset.\n+  int_range_max normal, overflow;\n+  relation_kind k = plus_minus_ranges (overflow, normal, op2, add_p);\n+\n+  // VREL_VARYING means there are no adjustments.\n+  if (k == VREL_VARYING)\n+    return;\n+\n+  // If the relations match use the normal range, otherwise use overflow range.\n+  if (relation_intersect (k, rel) == k)\n+    r.intersect (normal);\n+  else\n+    r.intersect (overflow);\n+  return;\n+}\n+\n bool\n operator_plus::op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t  relation_kind rel) const\n {\n-  return range_op_handler (MINUS_EXPR, type).fold_range (r, type, lhs, op2);\n+  if (lhs.undefined_p ())\n+    return false;\n+  // Start with the default operation.\n+  range_op_handler minus (MINUS_EXPR, type);\n+  if (!minus)\n+    return false;\n+  bool res = minus.fold_range (r, type, lhs, op2);\n+  // Check for a relation refinement.\n+  if (res)\n+    adjust_op1_for_overflow (r, op2, rel, true /* PLUS_EXPR */);\n+  return res;\n }\n \n bool\n operator_plus::op2_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op1,\n-\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+\t\t\t  relation_kind rel) const\n {\n-  return range_op_handler (MINUS_EXPR, type).fold_range (r, type, lhs, op1);\n+  return op1_range (r, type, lhs, op1, rel);\n }\n \n \n@@ -1472,7 +1573,17 @@ operator_minus::op1_range (irange &r, tree type,\n \t\t\t   const irange &op2,\n \t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n-  return range_op_handler (PLUS_EXPR, type).fold_range (r, type, lhs, op2);\n+  if (lhs.undefined_p ())\n+    return false;\n+  // Start with the default operation.\n+  range_op_handler minus (PLUS_EXPR, type);\n+  if (!minus)\n+    return false;\n+  bool res = minus.fold_range (r, type, lhs, op2);\n+  if (res)\n+    adjust_op1_for_overflow (r, op2, rel, false /* PLUS_EXPR */);\n+  return res;\n+\n }\n \n bool"}, {"sha": "b1751877756dbbce3a21bc250e3fa89e6ebed9d8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79095.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea258a13a115e9e73d60f59369d16892ed07435/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79095.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea258a13a115e9e73d60f59369d16892ed07435/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79095.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79095.c?ref=7ea258a13a115e9e73d60f59369d16892ed07435", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-ipa-icf -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fno-ipa-icf -fdump-tree-evrp\" } */\n \n extern void arf (unsigned x, unsigned y);\n extern void baz (unsigned x, unsigned y);\n@@ -429,8 +429,8 @@ f4nro (unsigned a, unsigned b)\n }\n \n /* All calls to baz should still reference a & b as arguments. */\n-/* { dg-final { scan-tree-dump-times \"baz \\\\(a_\\[0-9\\]+\\\\(D\\\\), b_\\[0-9\\]+\\\\)\" 32 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"baz \\\\(a_\\[0-9\\]+\\\\(D\\\\), b_\\[0-9\\]+\\\\)\" 32 \"evrp\"} } */\n \n \n /* All calls to arf should have constant arguments.  */\n-/* { dg-final { scan-tree-dump-times \"arf \\\\(\\[0-9\\]+, \\[0-9\\]+\\\\)\" 32 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"arf \\\\(\\[0-9\\]+, \\[0-9\\]+\\\\)\" 32 \"evrp\"} } */"}, {"sha": "e1347ea8ad81f642f8f7fe6b1ba5db5b533b951f", "filename": "gcc/value-relation.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea258a13a115e9e73d60f59369d16892ed07435/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea258a13a115e9e73d60f59369d16892ed07435/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=7ea258a13a115e9e73d60f59369d16892ed07435", "patch": "@@ -78,6 +78,8 @@ relation_kind relation_union (relation_kind r1, relation_kind r2);\n relation_kind relation_intersect (relation_kind r1, relation_kind r2);\n relation_kind relation_negate (relation_kind r);\n relation_kind relation_swap (relation_kind r);\n+inline bool relation_lt_le_gt_ge_p (relation_kind r)\n+\t\t\t\t    { return (r >= VREL_LT && r <= VREL_GE); }\n void print_relation (FILE *f, relation_kind rel);\n \n class relation_oracle"}]}