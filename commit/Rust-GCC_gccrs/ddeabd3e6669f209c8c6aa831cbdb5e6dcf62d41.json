{"sha": "ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRlYWJkM2U2NjY5ZjIwOWM4YzZhYTgzMWNiZGI1ZTZkY2Y2MmQ0MQ==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2014-09-05T10:50:04Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2014-09-05T10:50:04Z"}, "message": "[PATCH AArch64 1/2] Improve codegen of vector compares inc. tst instruction\n\ngcc/:\n\n\t* config/aarch64/aarch64-builtins.c (aarch64_types_cmtst_qualifiers,\n\tTYPES_TST): Define.\n\t(aarch64_fold_builtin): Update pattern for cmtst.\n\n\t* config/aarch64/aarch64-protos.h (aarch64_const_vec_all_same_int_p):\n\tDeclare.\n\n\t* config/aarch64/aarch64-simd-builtins.def (cmtst): Update qualifiers.\n\n\t* config/aarch64/aarch64-simd.md (aarch64_vcond_internal<mode><mode>):\n\tSwitch operands, separate out more cases, refactor.\n\n\t(aarch64_cmtst<mode>): Rewrite pattern to match (plus ... -1).\n\n\t* config/aarch64.c (aarch64_const_vec_all_same_int_p): Take single\n\targument; rename old version to...\n\t(aarch64_const_vec_all_same_in_range_p): ...this.\n\t(aarch64_print_operand, aarch64_simd_shift_imm_p): Follow renaming.\n\n\t* config/aarch64/predicates.md (aarch64_simd_imm_minus_one): Define.\n\ngcc/testsuite/:\n\n\t* gcc.target/aarch64/simd/int_comparisons.x: New file.\n\t* gcc.target/aarch64/simd/int_comparisons_1.c: New test.\n\t* gcc.target/aarch64/simd/int_comparisons_2.c: Ditto.\n\nFrom-SVN: r214948", "tree": {"sha": "77c1a64665a09ccb722416e639e91de379244c7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77c1a64665a09ccb722416e639e91de379244c7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/comments", "author": null, "committer": null, "parents": [{"sha": "e625e71548596d96bd4005194fc5d8f70966ad71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e625e71548596d96bd4005194fc5d8f70966ad71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e625e71548596d96bd4005194fc5d8f70966ad71"}], "stats": {"total": 449, "additions": 389, "deletions": 60}, "files": [{"sha": "4be40e90659bc3758251c840532e5f8e036a55c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -1,3 +1,26 @@\n+2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* config/aarch64/aarch64-builtins.c (aarch64_types_cmtst_qualifiers,\n+\tTYPES_TST): Define.\n+\t(aarch64_fold_builtin): Update pattern for cmtst.\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_const_vec_all_same_int_p):\n+\tDeclare.\n+\n+\t* config/aarch64/aarch64-simd-builtins.def (cmtst): Update qualifiers.\n+\n+\t* config/aarch64/aarch64-simd.md (aarch64_vcond_internal<mode><mode>):\n+\tSwitch operands, separate out more cases, refactor.\n+\n+\t(aarch64_cmtst<mode>): Rewrite pattern to match (plus ... -1).\n+\n+\t* config/aarch64.c (aarch64_const_vec_all_same_int_p): Take single\n+\targument; rename old version to...\n+\t(aarch64_const_vec_all_same_in_range_p): ...this.\n+\t(aarch64_print_operand, aarch64_simd_shift_imm_p): Follow renaming.\n+\n+\t* config/aarch64/predicates.md (aarch64_simd_imm_minus_one): Define.\n+\n 2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (enum aarch64_type_qualifiers):"}, {"sha": "32e902d627812fe2c721051b2875c8f0cbdf8583", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -144,6 +144,11 @@ aarch64_types_binop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_maybe_immediate };\n #define TYPES_BINOP (aarch64_types_binop_qualifiers)\n static enum aarch64_type_qualifiers\n+aarch64_types_cmtst_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_none,\n+      qualifier_internal, qualifier_internal };\n+#define TYPES_TST (aarch64_types_cmtst_qualifiers)\n+static enum aarch64_type_qualifiers\n aarch64_types_binopv_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_void, qualifier_none, qualifier_none };\n #define TYPES_BINOPV (aarch64_types_binopv_qualifiers)\n@@ -1285,7 +1290,7 @@ aarch64_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *args,\n       BUILTIN_VALLDI (BINOP, cmeq, 0)\n \treturn fold_build2 (EQ_EXPR, type, args[0], args[1]);\n \tbreak;\n-      BUILTIN_VSDQ_I_DI (BINOP, cmtst, 0)\n+      BUILTIN_VSDQ_I_DI (TST, cmtst, 0)\n \t{\n \t  tree and_node = fold_build2 (BIT_AND_EXPR, type, args[0], args[1]);\n \t  tree vec_zero_node = build_zero_cst (type);"}, {"sha": "a041cad74da22f0d5395d77b28fa4fcec4da55a5", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -180,6 +180,7 @@ bool aarch64_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t       enum reg_class);\n enum aarch64_symbol_type\n aarch64_classify_symbolic_expression (rtx, enum aarch64_symbol_context);\n+bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);\n bool aarch64_constant_address_p (rtx);\n bool aarch64_expand_movmem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);"}, {"sha": "9bde1ac8ca6326681f8c52f7c00b567bd5dedc43", "filename": "gcc/config/aarch64/aarch64-simd-builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -246,7 +246,7 @@\n   /* Implemented by aarch64_cm<cmp><mode>.  */\n   BUILTIN_VSDQ_I_DI (BINOP, cmgeu, 0)\n   BUILTIN_VSDQ_I_DI (BINOP, cmgtu, 0)\n-  BUILTIN_VSDQ_I_DI (BINOP, cmtst, 0)\n+  BUILTIN_VSDQ_I_DI (TST, cmtst, 0)\n \n   /* Implemented by reduc_<sur>plus_<mode>.  */\n   BUILTIN_VALL (UNOP, reduc_splus_, 10)"}, {"sha": "6a45e91512ffe1c8c2ecd2b1ba4336baf87f7256", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 64, "deletions": 26, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -1912,58 +1912,94 @@\n \t  (match_operand:VDQ 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  int inverse = 0, has_zero_imm_form = 0;\n   rtx op1 = operands[1];\n   rtx op2 = operands[2];\n   rtx mask = gen_reg_rtx (<MODE>mode);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+\n+  /* Switching OP1 and OP2 is necessary for NE (to output a cmeq insn),\n+     and desirable for other comparisons if it results in FOO ? -1 : 0\n+     (this allows direct use of the comparison result without a bsl).  */\n+  if (code == NE\n+      || (code != EQ\n+\t  && op1 == CONST0_RTX (<V_cmp_result>mode)\n+\t  && op2 == CONSTM1_RTX (<V_cmp_result>mode)))\n+    {\n+      op1 = operands[2];\n+      op2 = operands[1];\n+      switch (code)\n+        {\n+        case LE: code = GT; break;\n+        case LT: code = GE; break;\n+        case GE: code = LT; break;\n+        case GT: code = LE; break;\n+        /* No case EQ.  */\n+        case NE: code = EQ; break;\n+        case LTU: code = GEU; break;\n+        case LEU: code = GTU; break;\n+        case GTU: code = LEU; break;\n+        case GEU: code = LTU; break;\n+        default: gcc_unreachable ();\n+        }\n+    }\n \n-  switch (GET_CODE (operands[3]))\n+  /* Make sure we can handle the last operand.  */\n+  switch (code)\n     {\n+    case NE:\n+      /* Normalized to EQ above.  */\n+      gcc_unreachable ();\n+\n     case LE:\n     case LT:\n-    case NE:\n-      inverse = 1;\n-      /* Fall through.  */\n     case GE:\n     case GT:\n     case EQ:\n-      has_zero_imm_form = 1;\n-      break;\n-    case LEU:\n-    case LTU:\n-      inverse = 1;\n-      break;\n+      /* These instructions have a form taking an immediate zero.  */\n+      if (operands[5] == CONST0_RTX (<MODE>mode))\n+        break;\n+      /* Fall through, as may need to load into register.  */\n     default:\n+      if (!REG_P (operands[5]))\n+        operands[5] = force_reg (<MODE>mode, operands[5]);\n       break;\n     }\n \n-  if (!REG_P (operands[5])\n-      && (operands[5] != CONST0_RTX (<MODE>mode) || !has_zero_imm_form))\n-    operands[5] = force_reg (<MODE>mode, operands[5]);\n-\n-  switch (GET_CODE (operands[3]))\n+  switch (code)\n     {\n     case LT:\n+      emit_insn (gen_aarch64_cmlt<mode> (mask, operands[4], operands[5]));\n+      break;\n+\n     case GE:\n       emit_insn (gen_aarch64_cmge<mode> (mask, operands[4], operands[5]));\n       break;\n \n     case LE:\n+      emit_insn (gen_aarch64_cmle<mode> (mask, operands[4], operands[5]));\n+      break;\n+\n     case GT:\n       emit_insn (gen_aarch64_cmgt<mode> (mask, operands[4], operands[5]));\n       break;\n \n     case LTU:\n+      emit_insn (gen_aarch64_cmgtu<mode> (mask, operands[5], operands[4]));\n+      break;\n+\n     case GEU:\n       emit_insn (gen_aarch64_cmgeu<mode> (mask, operands[4], operands[5]));\n       break;\n \n     case LEU:\n+      emit_insn (gen_aarch64_cmgeu<mode> (mask, operands[5], operands[4]));\n+      break;\n+\n     case GTU:\n       emit_insn (gen_aarch64_cmgtu<mode> (mask, operands[4], operands[5]));\n       break;\n \n-    case NE:\n+    /* NE has been normalized to EQ above.  */\n     case EQ:\n       emit_insn (gen_aarch64_cmeq<mode> (mask, operands[4], operands[5]));\n       break;\n@@ -1972,12 +2008,6 @@\n       gcc_unreachable ();\n     }\n \n-  if (inverse)\n-    {\n-      op1 = operands[2];\n-      op2 = operands[1];\n-    }\n-\n     /* If we have (a = (b CMP c) ? -1 : 0);\n        Then we can simply move the generated mask.  */\n \n@@ -3932,14 +3962,22 @@\n \n ;; cmtst\n \n+;; Although neg (ne (and x y) 0) is the natural way of expressing a cmtst,\n+;; we don't have any insns using ne, and aarch64_vcond_internal outputs\n+;; not (neg (eq (and x y) 0))\n+;; which is rewritten by simplify_rtx as\n+;; plus (eq (and x y) 0) -1.\n+\n (define_insn \"aarch64_cmtst<mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w\")\n-\t(neg:<V_cmp_result>\n-\t  (ne:<V_cmp_result>\n+\t(plus:<V_cmp_result>\n+\t  (eq:<V_cmp_result>\n \t    (and:VDQ\n \t      (match_operand:VDQ 1 \"register_operand\" \"w\")\n \t      (match_operand:VDQ 2 \"register_operand\" \"w\"))\n-\t    (vec_duplicate:<V_cmp_result> (const_int 0)))))]\n+\t    (match_operand:VDQ 3 \"aarch64_simd_imm_zero\"))\n+\t  (match_operand:<V_cmp_result> 4 \"aarch64_simd_imm_minus_one\")))\n+  ]\n   \"TARGET_SIMD\"\n   \"cmtst\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %<v>2<Vmtype>\"\n   [(set_attr \"type\" \"neon_tst<q>\")]"}, {"sha": "023f9fd259ddc33357f920e93024c8a64467ecc8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -137,9 +137,6 @@ static void aarch64_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_override_options_after_change (void);\n static bool aarch64_vector_mode_supported_p (enum machine_mode);\n static unsigned bit_count (unsigned HOST_WIDE_INT);\n-static bool aarch64_const_vec_all_same_int_p (rtx,\n-\t\t\t\t\t      HOST_WIDE_INT, HOST_WIDE_INT);\n-\n static bool aarch64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n \t\t\t\t\t\t const unsigned char *sel);\n static int aarch64_address_cost (rtx, enum machine_mode, addr_space_t, bool);\n@@ -3576,6 +3573,36 @@ aarch64_get_condition_code (rtx x)\n     }\n }\n \n+bool\n+aarch64_const_vec_all_same_in_range_p (rtx x,\n+\t\t\t\t  HOST_WIDE_INT minval,\n+\t\t\t\t  HOST_WIDE_INT maxval)\n+{\n+  HOST_WIDE_INT firstval;\n+  int count, i;\n+\n+  if (GET_CODE (x) != CONST_VECTOR\n+      || GET_MODE_CLASS (GET_MODE (x)) != MODE_VECTOR_INT)\n+    return false;\n+\n+  firstval = INTVAL (CONST_VECTOR_ELT (x, 0));\n+  if (firstval < minval || firstval > maxval)\n+    return false;\n+\n+  count = CONST_VECTOR_NUNITS (x);\n+  for (i = 1; i < count; i++)\n+    if (INTVAL (CONST_VECTOR_ELT (x, i)) != firstval)\n+      return false;\n+\n+  return true;\n+}\n+\n+bool\n+aarch64_const_vec_all_same_int_p (rtx x, HOST_WIDE_INT val)\n+{\n+  return aarch64_const_vec_all_same_in_range_p (x, val, val);\n+}\n+\n static unsigned\n bit_count (unsigned HOST_WIDE_INT value)\n {\n@@ -3827,9 +3854,10 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n \tcase CONST_VECTOR:\n \t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_INT)\n \t    {\n-\t      gcc_assert (aarch64_const_vec_all_same_int_p (x,\n-\t\t\t\t\t\t\t    HOST_WIDE_INT_MIN,\n-\t\t\t\t\t\t\t    HOST_WIDE_INT_MAX));\n+\t      gcc_assert (\n+\t\t  aarch64_const_vec_all_same_in_range_p (x,\n+\t\t\t\t\t\t\t HOST_WIDE_INT_MIN,\n+\t\t\t\t\t\t\t HOST_WIDE_INT_MAX));\n \t      asm_fprintf (f, \"%wd\", INTVAL (CONST_VECTOR_ELT (x, 0)));\n \t    }\n \t  else if (aarch64_simd_imm_zero_p (x, GET_MODE (x)))\n@@ -7732,39 +7760,15 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n #undef CHECK\n }\n \n-static bool\n-aarch64_const_vec_all_same_int_p (rtx x,\n-\t\t\t\t  HOST_WIDE_INT minval,\n-\t\t\t\t  HOST_WIDE_INT maxval)\n-{\n-  HOST_WIDE_INT firstval;\n-  int count, i;\n-\n-  if (GET_CODE (x) != CONST_VECTOR\n-      || GET_MODE_CLASS (GET_MODE (x)) != MODE_VECTOR_INT)\n-    return false;\n-\n-  firstval = INTVAL (CONST_VECTOR_ELT (x, 0));\n-  if (firstval < minval || firstval > maxval)\n-    return false;\n-\n-  count = CONST_VECTOR_NUNITS (x);\n-  for (i = 1; i < count; i++)\n-    if (INTVAL (CONST_VECTOR_ELT (x, i)) != firstval)\n-      return false;\n-\n-  return true;\n-}\n-\n /* Check of immediate shift constants are within range.  */\n bool\n aarch64_simd_shift_imm_p (rtx x, enum machine_mode mode, bool left)\n {\n   int bit_width = GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT;\n   if (left)\n-    return aarch64_const_vec_all_same_int_p (x, 0, bit_width - 1);\n+    return aarch64_const_vec_all_same_in_range_p (x, 0, bit_width - 1);\n   else\n-    return aarch64_const_vec_all_same_int_p (x, 1, bit_width);\n+    return aarch64_const_vec_all_same_in_range_p (x, 1, bit_width);\n }\n \n /* Return true if X is a uniform vector where all elements"}, {"sha": "8191169e89b1eaf04c00ea709af70412d2cee361", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -273,3 +273,9 @@\n {\n   return aarch64_simd_imm_zero_p (op, mode);\n })\n+\n+(define_special_predicate \"aarch64_simd_imm_minus_one\"\n+  (match_code \"const_vector\")\n+{\n+  return aarch64_const_vec_all_same_int_p (op, -1);\n+})"}, {"sha": "21570ea918f97747c4552e1b6a9a8085086c6796", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -1,3 +1,9 @@\n+2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* gcc.target/aarch64/simd/int_comparisons.x: New file.\n+\t* gcc.target/aarch64/simd/int_comparisons_1.c: New test.\n+\t* gcc.target/aarch64/simd/int_comparisons_2.c: Ditto.\n+\n 2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* gcc.target/aarch64/simd/vrbit_1.c: New test."}, {"sha": "3b468eb5af5f1e0c7f1c75aebe2e189def05dc5a", "filename": "gcc/testsuite/gcc.target/aarch64/simd/int_comparisons.x", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons.x?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -0,0 +1,68 @@\n+/*  test_vcXXX wrappers for all the vcXXX (vector compare) and vtst intrinsics\n+    in arm_neon.h (excluding the 64x1 variants as these generally produce scalar\n+    not vector ops).  */\n+#include \"arm_neon.h\"\n+\n+#define DONT_FORCE(X)\n+\n+#define FORCE_SIMD(V1)   asm volatile (\"mov %d0, %1.d[0]\"       \\\n+           : \"=w\"(V1)                                           \\\n+           : \"w\"(V1)                                            \\\n+           : /* No clobbers */);\n+\n+#define OP1(SIZE, OP, BASETYPE, SUFFIX, FORCE) uint##SIZE##_t\t\\\n+test_v##OP##SUFFIX (BASETYPE##SIZE##_t a)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  uint##SIZE##_t res;\t\t\t\t\t\t\\\n+  FORCE (a);\t\t\t\t\t\t\t\\\n+  res = v##OP##SUFFIX (a);\t\t\t\t\t\\\n+  FORCE (res);\t\t\t\t\t\t\t\\\n+  return res;\t\t\t\t\t\t\t\\\n+}\n+\n+#define OP2(SIZE, OP, BASETYPE, SUFFIX, FORCE) uint##SIZE##_t\t\\\n+test_v##OP##SUFFIX (BASETYPE##SIZE##_t a, BASETYPE##SIZE##_t b) \\\n+{\t\t\t\t\t\t\t\t\\\n+  uint##SIZE##_t res;\t\t\t\t\t\t\\\n+  FORCE (a);\t\t\t\t\t\t\t\\\n+  FORCE (b);\t\t\t\t\t\t\t\\\n+  res = v##OP##SUFFIX (a, b);\t\t\t\t\t\\\n+  FORCE (res);\t\t\t\t\t\t\t\\\n+  return res;\t\t\t\t\t\t\t\\\n+}\n+\n+#define UNSIGNED_OPS(SIZE, BASETYPE, SUFFIX, FORCE) \\\n+OP2 (SIZE, tst, BASETYPE, SUFFIX, FORCE) \\\n+OP1 (SIZE, ceqz, BASETYPE, SUFFIX, FORCE) \\\n+OP2 (SIZE, ceq, BASETYPE, SUFFIX, FORCE) \\\n+OP2 (SIZE, cge, BASETYPE, SUFFIX, FORCE) \\\n+OP2 (SIZE, cgt, BASETYPE, SUFFIX, FORCE) \\\n+OP2 (SIZE, cle, BASETYPE, SUFFIX, FORCE) \\\n+OP2 (SIZE, clt, BASETYPE, SUFFIX, FORCE)\n+\n+#define ALL_OPS(SIZE, BASETYPE, SUFFIX, FORCE) \\\n+OP1 (SIZE, cgez, BASETYPE, SUFFIX, FORCE) \\\n+OP1 (SIZE, cgtz, BASETYPE, SUFFIX, FORCE) \\\n+OP1 (SIZE, clez, BASETYPE, SUFFIX, FORCE) \\\n+OP1 (SIZE, cltz, BASETYPE, SUFFIX, FORCE) \\\n+UNSIGNED_OPS (SIZE, BASETYPE, SUFFIX, FORCE)\n+\n+ALL_OPS (8x8, int, _s8, DONT_FORCE)\n+ALL_OPS (16x4, int, _s16, DONT_FORCE)\n+ALL_OPS (32x2, int, _s32, DONT_FORCE)\n+ALL_OPS (64x1, int, _s64, DONT_FORCE)\n+ALL_OPS (64, int, d_s64, FORCE_SIMD)\n+ALL_OPS (8x16, int, q_s8, DONT_FORCE)\n+ALL_OPS (16x8, int, q_s16, DONT_FORCE)\n+ALL_OPS (32x4, int, q_s32, DONT_FORCE)\n+ALL_OPS (64x2, int, q_s64, DONT_FORCE)\n+UNSIGNED_OPS (8x8, uint, _u8, DONT_FORCE)\n+UNSIGNED_OPS (16x4, uint, _u16, DONT_FORCE)\n+UNSIGNED_OPS (32x2, uint, _u32, DONT_FORCE)\n+UNSIGNED_OPS (64x1, uint, _u64, DONT_FORCE)\n+UNSIGNED_OPS (64, uint, d_u64, FORCE_SIMD)\n+UNSIGNED_OPS (8x16, uint, q_u8, DONT_FORCE)\n+UNSIGNED_OPS (16x8, uint, q_u16, DONT_FORCE)\n+UNSIGNED_OPS (32x4, uint, q_u32, DONT_FORCE)\n+UNSIGNED_OPS (64x2, uint, q_u64, DONT_FORCE)\n+"}, {"sha": "86c6ed28538affcc4c3ef6cacd74d002e32b0931", "filename": "gcc/testsuite/gcc.target/aarch64/simd/int_comparisons_1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_1.c?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-inline\" } */\n+\n+/* Scan-assembler test, so, incorporate as little other code as possible.  */\n+\n+#include \"arm_neon.h\"\n+#include \"int_comparisons.x\"\n+\n+/* Operations on all 18 integer types:  (q?)_[su](8|16|32|64), d_[su]64.\n+   (d?)_[us]64 generate regs of form 'd0' rather than e.g. 'v0.2d'.  */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmeq\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmeq\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 4 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmeq\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\]\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmeq\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]+d\\[0-9\\]+\" 4 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmtst\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\]\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmtst\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]+d\\[0-9\\]+\" 4 } } */\n+\n+/* vcge + vcle both implemented with cmge (signed) or cmhs (unsigned).  */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\]\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]+d\\[0-9\\]+\" 4 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmhs\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\]\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmhs\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]+d\\[0-9\\]+\" 4 } } */\n+\n+/* vcgt + vclt both implemented with cmgt (signed) or cmhi (unsigned).  */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmgt\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\]\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmgt\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]+d\\[0-9\\]+\" 4 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmhi\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\]\" 14 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmhi\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]+d\\[0-9\\]+\" 4 } } */\n+\n+/* Comparisons against immediate zero, on the 8 signed integer types only.  */\n+\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n+/*  For int64_t and int64x1_t, combine_simplify_rtx failure of\n+    https://gcc.gnu.org/ml/gcc/2014-06/msg00253.html\n+    prevents generation of cmge....#0, instead producing mvn + sshr.  */\n+/* { #dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmgt\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmgt\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmle\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmle\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmlt\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n+/* For int64_t and int64x1_t, cmlt ... #0 and sshr ... #63 are equivalent,\n+   so allow either.  cmgez issue above results in extra 2 * sshr....63.  */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\](?:cmlt|sshr)\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?(?:0|63)\" 4 } } */\n+\n+// All should have been compiled into single insns without inverting result:\n+/* { dg-final { scan-assembler-not \"not\" } } */"}, {"sha": "35882311934d4ab5ece61bed4739e999fecec24b", "filename": "gcc/testsuite/gcc.target/aarch64/simd/int_comparisons_2.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_2.c?ref=ddeabd3e6669f209c8c6aa831cbdb5e6dcf62d41", "patch": "@@ -0,0 +1,131 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline\" } */\n+/* Stops the test_xxx methods being inlined into main, thus preventing constant\n+   propagation.  */\n+\n+#include \"int_comparisons.x\"\n+\n+extern void abort (void);\n+\n+#define CHECK2(R0, R1) if (res[0] != R0 || res[1] != R1) abort ()\n+\n+#define TEST2(BASETYPE, SUFFIX, RESTYPE, ST1_SUFFIX) {\t\t\t\\\n+  BASETYPE##_t _a[2] = {2, 3};\t\t\t\t\t\t\\\n+  BASETYPE##x2_t a = vld1##SUFFIX (_a);\t\t\t\t\t\\\n+  BASETYPE##_t _b[2] = {1, 3};\t\t\t\t\t\t\\\n+  BASETYPE##x2_t b = vld1##SUFFIX (_b);\t\t\t\t\t\\\n+  RESTYPE res[2];\t\t\t\t\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vclt##SUFFIX (a, b)); CHECK2 (0, 0);\t\\\n+  vst1##ST1_SUFFIX (res, test_vclt##SUFFIX (b, a)); CHECK2 (-1, 0);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcle##SUFFIX (a, b)); CHECK2 (0, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcle##SUFFIX (b, a)); CHECK2 (-1, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vceq##SUFFIX (a, b)); CHECK2 (0, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcge##SUFFIX (a, b)); CHECK2 (-1, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcge##SUFFIX (b, a)); CHECK2 (0, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcgt##SUFFIX (a, b)); CHECK2 (-1, 0);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcgt##SUFFIX (b, a)); CHECK2 (0, 0);\t\\\n+  vst1##ST1_SUFFIX (res, test_vtst##SUFFIX (a, b)); CHECK2 (0, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vtst##SUFFIX (a + 1, b)); CHECK2 (-1, 0); \\\n+}\n+\n+#define CHECK4(T, R0, R1, R2, R3)\t\t\\\n+  if (res[0] != (T)R0 || res[1] != (T)R1\t\\\n+      || res[2] != (T)R2 || res[3] != (T)R3) abort ()\n+\n+#define TEST4(BASETYPE, SUFFIX, RESTYPE, ST1_SUFFIX) {\t\\\n+  BASETYPE##_t _a[4] = {1, 2, 3, 4};\t\t\t\\\n+  BASETYPE##x4_t a = vld1##SUFFIX (_a);\t\t\t\\\n+  BASETYPE##_t _b[4] = {4, 2, 1, 3};\t\t\t\\\n+  BASETYPE##x4_t b = vld1##SUFFIX (_b);\t\t\t\\\n+  RESTYPE res[4];\t\t\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vclt##SUFFIX (a, b));\t\\\n+  CHECK4 (RESTYPE, -1, 0, 0, 0);\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vcle##SUFFIX (a, b));\t\\\n+  CHECK4 (RESTYPE, -1, -1, 0, 0);\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vceq##SUFFIX (a, b));\t\\\n+  CHECK4 (RESTYPE, 0, -1, 0, 0);\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vcge##SUFFIX (a, b));\t\\\n+  CHECK4 (RESTYPE, 0, -1, -1, -1);\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vcgt##SUFFIX (a, b));\t\\\n+  CHECK4 (RESTYPE, 0, 0, -1, -1);\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vtst##SUFFIX (a, b));\t\\\n+  CHECK4 (RESTYPE, 0, -1, -1, 0);\t\t\t\\\n+}\n+\n+#define CHECK8(T, R0, R1, R2, R3, R4, R5, R6, R7)\t\t\t       \\\n+  if (res[0] != (T)R0 || res[1] != (T)R1 || res[2] != (T)R2 || res[3] != (T)R3 \\\n+      || res[4] != (T)R4 || res[5] != (T)R5 || res[6] != (T)R6\t\t       \\\n+      || res[7] != (T)R7) abort ()\n+\n+#define TEST8(BASETYPE, SUFFIX, RESTYPE, ST1_SUFFIX) {\t\\\n+  BASETYPE##_t _a[8] = {1, 2, 3, 4, 5, 6, 7, 8};\t\\\n+  BASETYPE##x8_t a = vld1##SUFFIX (_a);\t\t\t\\\n+  BASETYPE##_t _b[8] = {4, 2, 1, 3, 2, 6, 8, 9};\t\\\n+  BASETYPE##x8_t b = vld1##SUFFIX (_b);\t\t\t\\\n+  RESTYPE res[8];\t\t\t\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vclt##SUFFIX (a, b));\t\\\n+  CHECK8 (RESTYPE, -1, 0, 0, 0, 0, 0, -1, -1);\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vcle##SUFFIX (a, b));\t\\\n+  CHECK8 (RESTYPE, -1, -1, 0, 0, 0, -1, -1, -1);\t\\\n+  vst1##ST1_SUFFIX (res, test_vceq##SUFFIX (a, b));\t\\\n+  CHECK8 (RESTYPE, 0, -1, 0, 0, 0, -1, 0, 0);\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vcge##SUFFIX (a, b));\t\\\n+  CHECK8 (RESTYPE, 0, -1, -1, -1, -1, -1, 0, 0);\t\\\n+  vst1##ST1_SUFFIX (res, test_vcgt##SUFFIX (a, b));\t\\\n+  CHECK8 (RESTYPE, 0, 0, -1, -1, -1, 0, 0, 0);\t\t\\\n+  vst1##ST1_SUFFIX (res, test_vtst##SUFFIX (a, b));\t\\\n+  CHECK8 (RESTYPE, 0, -1, -1, 0, 0, -1, 0, -1);\t\t\\\n+}\n+\n+/* 16-way tests use same 8 values twice.  */\n+#define CHECK16(T, R0, R1, R2, R3, R4, R5, R6, R7)\t\t\t       \\\n+  if (res[0] != (T)R0 || res[1] != (T)R1 || res[2] != (T)R2 || res[3] != (T)R3 \\\n+      || res[4] != (T)R4 || res[5] != (T)R5 || res[6] != (T)R6\t\t       \\\n+      || res[7] != (T)R7 || res[8] != (T)R0 || res[9] != (T)R1\t\t       \\\n+      || res[10] != (T)R2 || res[11] != (T)R3 || res[12] != (T)R4\t       \\\n+      || res[13] != (T)R5 || res[14] != (T)R6 || res[15] != (T)R7) abort ()\n+\n+#define TEST16(BASETYPE, SUFFIX, RESTYPE, ST1_SUFFIX) {\t\t\t  \\\n+  BASETYPE##_t _a[16] = {1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8}; \\\n+  BASETYPE##x16_t a = vld1##SUFFIX (_a);\t\t\t\t  \\\n+  BASETYPE##_t _b[16] = {4, 2, 1, 3, 2, 6, 8, 9, 4, 2, 1, 3, 2, 6, 8, 9}; \\\n+  BASETYPE##x16_t b = vld1##SUFFIX (_b);\t\t\t\t  \\\n+  RESTYPE res[16];\t\t\t\t\t\t\t  \\\n+  vst1##ST1_SUFFIX (res, test_vclt##SUFFIX (a, b));\t\t\t  \\\n+  CHECK16 (RESTYPE, -1, 0, 0, 0, 0, 0, -1, -1);\t\t\t\t  \\\n+  vst1##ST1_SUFFIX (res, test_vcle##SUFFIX (a, b));\t\t\t  \\\n+  CHECK16 (RESTYPE, -1, -1, 0, 0, 0, -1, -1, -1);\t\t\t  \\\n+  vst1##ST1_SUFFIX (res, test_vceq##SUFFIX (a, b));\t\t\t  \\\n+  CHECK16 (RESTYPE, 0, -1, 0, 0, 0, -1, 0, 0);\t\t\t\t  \\\n+  vst1##ST1_SUFFIX (res, test_vcge##SUFFIX (a, b));\t\t\t  \\\n+  CHECK16 (RESTYPE, 0, -1, -1, -1, -1, -1, 0, 0);\t\t\t  \\\n+  vst1##ST1_SUFFIX (res, test_vcgt##SUFFIX (a, b));\t\t\t  \\\n+  CHECK16 (RESTYPE, 0, 0, -1, -1, -1, 0, 0, 0);\t\t\t\t  \\\n+  vst1##ST1_SUFFIX (res, test_vtst##SUFFIX (a, b));\t\t\t  \\\n+  CHECK16 (RESTYPE, 0, -1, -1, 0, 0, -1, 0, -1);\t\t\t  \\\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  TEST2 (int32, _s32, uint32_t, _u32);\n+  TEST2 (uint32, _u32, uint32_t, _u32);\n+  TEST2 (int64, q_s64, uint64_t, q_u64);\n+  TEST2 (uint64, q_u64, uint64_t, q_u64);\n+\n+  TEST4 (int16, _s16, uint16_t, _u16);\n+  TEST4 (uint16, _u16, uint16_t, _u16);\n+  TEST4 (int32, q_s32, uint32_t, q_u32);\n+  TEST4 (uint32, q_u32, uint32_t, q_u32);\n+\n+  TEST8 (int8, _s8, uint8_t, _u8);\n+  TEST8 (uint8, _u8, uint8_t, _u8);\n+  TEST8 (int16, q_s16, uint16_t, q_u16);\n+  TEST8 (uint16, q_u16, uint16_t, q_u16);\n+\n+  TEST16 (int8, q_s8, uint8_t, q_u8);\n+  TEST16 (uint8, q_u8, uint8_t, q_u8);\n+\n+  return 0;\n+}\n+"}]}