{"sha": "64e13bcd19db627535a6309d9d5f7b24e5724453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRlMTNiY2QxOWRiNjI3NTM1YTYzMDlkOWQ1ZjdiMjRlNTcyNDQ1Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-06-05T18:25:02Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-06-05T18:25:02Z"}, "message": "re PR tree-optimization/61289 (Bad jump threading generates infinite loop)\n\n\tPR tree-optimization/61289\n\t* tree-ssa-threadedge.c (invalidate_equivalences): Remove SRC_MAP and\n\tDST_MAP parameters.   Invalidate by walking all the SSA_NAME_VALUES\n\tlooking for those which match LHS.  All callers changed.\n\t(record_temporary_equivalences_from_phis): Remove SRC_MAP and DST_MAP\n\tparameters and code which manipulated them.  All callers changed.\n\t(record_temporary_equivalences_from_stmts_at_dest): Remove SRC_MAP\n\tand DST_MAP parameters.  Simplify invalidation code by just calling\n\tinvalidate_equivalences.  All callers changed.\n\t(thread_across_edge): Simplify now that we don't need to maintain\n\tthe map of equivalences to invalidate.\n\n        PR tree-optimization/61289\n\t* g++.dg/pr61289.C: New test.\n\t* g++.dg/pr61289-2.C: New test.\n\nFrom-SVN: r211287", "tree": {"sha": "0afbad485408a86a7342dfe9a0124455a357a1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0afbad485408a86a7342dfe9a0124455a357a1b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64e13bcd19db627535a6309d9d5f7b24e5724453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e13bcd19db627535a6309d9d5f7b24e5724453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64e13bcd19db627535a6309d9d5f7b24e5724453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e13bcd19db627535a6309d9d5f7b24e5724453/comments", "author": null, "committer": null, "parents": [{"sha": "406d36639601910fe29b23e2ce3e08ffc06ccde7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406d36639601910fe29b23e2ce3e08ffc06ccde7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406d36639601910fe29b23e2ce3e08ffc06ccde7"}], "stats": {"total": 251, "additions": 163, "deletions": 88}, "files": [{"sha": "94a30d45e8bad14c8ef05c56dcf6c7609c50210a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64e13bcd19db627535a6309d9d5f7b24e5724453", "patch": "@@ -1,3 +1,17 @@\n+2014-06-05  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/61289\n+\t* tree-ssa-threadedge.c (invalidate_equivalences): Remove SRC_MAP and\n+\tDST_MAP parameters.   Invalidate by walking all the SSA_NAME_VALUES\n+\tlooking for those which match LHS.  All callers changed.\n+\t(record_temporary_equivalences_from_phis): Remove SRC_MAP and DST_MAP\n+\tparameters and code which manipulated them.  All callers changed.\n+\t(record_temporary_equivalences_from_stmts_at_dest): Remove SRC_MAP\n+\tand DST_MAP parameters.  Simplify invalidation code by just calling\n+\tinvalidate_equivalences.  All callers changed.\n+\t(thread_across_edge): Simplify now that we don't need to maintain\n+\tthe map of equivalences to invalidate.\n+\n 2014-06-05  Kai Tietz  <ktietz@redhat.com>\n \t    Richard Henderson  <rth@redhat.com>\n "}, {"sha": "5fb5103deb85e8bfcb171a0c5902b26751a8c462", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64e13bcd19db627535a6309d9d5f7b24e5724453", "patch": "@@ -1,3 +1,9 @@\n+2014-06-05  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/61289\n+\t* g++.dg/pr61289.C: New test.\n+\t* g++.dg/pr61289-2.C: New test.\n+\n 2014-06-05  Richard Biener  <rguenther@suse.de>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "4cc3ebe468d4e0279e2c0874735a05e6e3e7019e", "filename": "gcc/testsuite/g++.dg/pr61289-2.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61289-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61289-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61289-2.c?ref=64e13bcd19db627535a6309d9d5f7b24e5724453", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-exceptions\" } */\n+struct S\n+{\n+  inline int fn1 () const { return s; }\n+  __attribute__ ((noinline, noclone)) S *fn2 (int);\n+  __attribute__ ((noinline, noclone)) void fn3 ();\n+  __attribute__ ((noinline, noclone)) static S *fn4 (int);\n+  S (int i) : s (i) {}\n+  int s;\n+};\n+\n+int a = 0;\n+S *b = 0;\n+\n+S *\n+S::fn2 (int i)\n+{\n+  a++;\n+  if (a == 1)\n+    return b;\n+  if (a > 3)\n+    __builtin_abort ();\n+  b = this;\n+  return new S (i + s);\n+}\n+\n+S *\n+S::fn4 (int i)\n+{\n+  b = new S (i);\n+  return b;\n+}\n+\n+void\n+S::fn3 ()\n+{\n+  delete this;\n+}\n+\n+void\n+foo ()\n+{\n+  S *c = S::fn4 (20);\n+  for (int i = 0; i < 2;)\n+    {\n+      S *d = c->fn2 (c->fn1 () + 10);\n+      if (c != d)\n+{\n+  c->fn3 ();\n+  c = d;\n+  ++i;\n+}\n+    }\n+  c->fn3 ();\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+}"}, {"sha": "ea7ccea304d7e6f6d1201ebb6199bc69db488111", "filename": "gcc/testsuite/g++.dg/pr61289.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61289.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61289.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61289.C?ref=64e13bcd19db627535a6309d9d5f7b24e5724453", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-exceptions\" } */\n+\n+struct S\n+{\n+  inline int fn1 () const { return s; }\n+  __attribute__ ((noinline, noclone)) S *fn2 (int);\n+  __attribute__ ((noinline, noclone)) void fn3 ();\n+  __attribute__ ((noinline, noclone)) static S *fn4 (int);\n+  S (int i) : s (i) {}\n+  int s;\n+};\n+\n+int a = 0;\n+S *b = 0;\n+\n+S *\n+S::fn2 (int i)\n+{\n+  a++;\n+  if (a == 1)\n+    return b;\n+  if (a > 3)\n+    __builtin_abort ();\n+  b = this;\n+  return new S (i + s);\n+}\n+\n+S *\n+S::fn4 (int i)\n+{\n+  b = new S (i);\n+  return b;\n+}\n+\n+void\n+S::fn3 ()\n+{\n+  delete this;\n+}\n+\n+void\n+foo ()\n+{\n+  S *c = S::fn4 (20);\n+  for (int i = 0; i < 2;)\n+    {\n+      S *d = c->fn2 (c->fn1 () + 10);\n+      if (d != c)\n+{\n+  c->fn3 ();\n+  c = d;\n+  ++i;\n+}\n+    }\n+  c->fn3 ();\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+}"}, {"sha": "ba9e1fe30f4444ab448a1fd16447b644d4d9a9f4", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 18, "deletions": 88, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e13bcd19db627535a6309d9d5f7b24e5724453/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=64e13bcd19db627535a6309d9d5f7b24e5724453", "patch": "@@ -200,9 +200,7 @@ record_temporary_equivalence (tree x, tree y, vec<tree> *stack)\n    traversing back edges less painful.  */\n \n static bool\n-record_temporary_equivalences_from_phis (edge e, vec<tree> *stack,\n-\t\t\t\t\t bool backedge_seen,\n-\t\t\t\t\t bitmap src_map, bitmap dst_map)\n+record_temporary_equivalences_from_phis (edge e, vec<tree> *stack)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -230,14 +228,6 @@ record_temporary_equivalences_from_phis (edge e, vec<tree> *stack,\n \tstmt_count++;\n \n       record_temporary_equivalence (dst, src, stack);\n-\n-      /* If we have crossed a backedge, then start recording equivalences\n-\t we might need to invalidate.  */\n-      if (backedge_seen && TREE_CODE (src) == SSA_NAME)\n-\t{\n-\t  bitmap_set_bit (src_map, SSA_NAME_VERSION (src));\n-\t  bitmap_set_bit (dst_map, SSA_NAME_VERSION (dst));\n-\t}\n     }\n   return true;\n }\n@@ -295,29 +285,15 @@ fold_assignment_stmt (gimple stmt)\n /* A new value has been assigned to LHS.  If necessary, invalidate any\n    equivalences that are no longer valid.  */\n static void\n-invalidate_equivalences (tree lhs, vec<tree> *stack,\n-\t\t\t bitmap src_map, bitmap dst_map)\n+invalidate_equivalences (tree lhs, vec<tree> *stack)\n {\n-  /* SRC_MAP contains the source SSA_NAMEs for equivalences created by PHI\n-     nodes.  If an entry in SRC_MAP changes, there's some destination that\n-     has been recorded as equivalent to the source and that equivalency\n-     needs to be eliminated.  */\n-  if (bitmap_bit_p (src_map, SSA_NAME_VERSION (lhs)))\n-    {\n-      unsigned int i;\n-      bitmap_iterator bi;\n-\n-      /* We know that the LHS of STMT was used as the RHS in an equivalency\n-\t created by a PHI.  All the LHS of such PHIs were recorded into DST_MAP.\n-\t So we can iterate over them to see if any have the LHS of STMT as\n-\t an equivalence, and if so, remove the equivalence as it is no longer\n-\t valid.  */\n-      EXECUTE_IF_SET_IN_BITMAP (dst_map, 0, i, bi)\n-\t{\n-\t  if (SSA_NAME_VALUE (ssa_name (i)) == lhs)\n-\t    record_temporary_equivalence (ssa_name (i), NULL_TREE, stack);\n-\t}\n-    }\n+\n+  for (unsigned int i = 1; i < num_ssa_names; i++)\n+    if (ssa_name (i) && SSA_NAME_VALUE (ssa_name (i)) == lhs)\n+      record_temporary_equivalence (ssa_name (i), NULL_TREE, stack);\n+\n+  if (SSA_NAME_VALUE (lhs))\n+    record_temporary_equivalence (lhs, NULL_TREE, stack);\n }\n \n /* Try to simplify each statement in E->dest, ultimately leading to\n@@ -342,9 +318,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t\t\t\t\t\t  vec<tree> *stack,\n \t\t\t\t\t\t  tree (*simplify) (gimple,\n \t\t\t\t\t\t\t\t    gimple),\n-\t\t\t\t\t\t  bool backedge_seen,\n-\t\t\t\t\t\t  bitmap src_map,\n-\t\t\t\t\t\t  bitmap dst_map)\n+\t\t\t\t\t\t  bool backedge_seen)\n {\n   gimple stmt = NULL;\n   gimple_stmt_iterator gsi;\n@@ -400,19 +374,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \n \t  if (backedge_seen)\n \t    FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n-\t      {\n-\t\t/* This call only invalidates equivalences created by\n-\t\t   PHI nodes.  This is by design to keep the cost of\n-\t\t   of invalidation reasonable.  */\n-\t\tinvalidate_equivalences (op, stack, src_map, dst_map);\n-\n-\t\t/* However, conditionals can imply values for real\n-\t\t   operands as well.  And those won't be recorded in the\n-\t\t   maps.  In fact, those equivalences may be recorded totally\n-\t\t   outside the threading code.  We can just create a new\n-\t\t   temporary NULL equivalence here.  */\n-\t        record_temporary_equivalence (op, NULL_TREE, stack);\n-\t      }\n+\t      invalidate_equivalences (op, stack);\n \n \t  continue;\n \t}\n@@ -452,8 +414,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t      if (backedge_seen)\n \t\t{\n \t\t  tree lhs = gimple_get_lhs (stmt);\n-\t\t  record_temporary_equivalence (lhs, NULL_TREE, stack);\n-\t\t  invalidate_equivalences (lhs, stack, src_map, dst_map);\n+\t\t  invalidate_equivalences (lhs, stack);\n \t\t}\n \t      continue;\n \t    }\n@@ -531,11 +492,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t      || is_gimple_min_invariant (cached_lhs)))\n \trecord_temporary_equivalence (gimple_get_lhs (stmt), cached_lhs, stack);\n       else if (backedge_seen)\n-\trecord_temporary_equivalence (gimple_get_lhs (stmt), NULL_TREE, stack);\n-\n-      if (backedge_seen)\n-\tinvalidate_equivalences (gimple_get_lhs (stmt), stack,\n-\t\t\t\t src_map, dst_map);\n+\tinvalidate_equivalences (gimple_get_lhs (stmt), stack);\n     }\n   return stmt;\n }\n@@ -982,9 +939,7 @@ thread_through_normal_block (edge e,\n \t\t\t     tree (*simplify) (gimple, gimple),\n \t\t\t     vec<jump_thread_edge *> *path,\n \t\t\t     bitmap visited,\n-\t\t\t     bool *backedge_seen_p,\n-\t\t\t     bitmap src_map,\n-\t\t\t     bitmap dst_map)\n+\t\t\t     bool *backedge_seen_p)\n {\n   /* If we have traversed a backedge, then we do not want to look\n      at certain expressions in the table that can not be relied upon.\n@@ -994,16 +949,14 @@ thread_through_normal_block (edge e,\n     simplify = dummy_simplify;\n \n   /* PHIs create temporary equivalences.  */\n-  if (!record_temporary_equivalences_from_phis (e, stack, *backedge_seen_p,\n-\t\t\t\t\t\tsrc_map, dst_map))\n+  if (!record_temporary_equivalences_from_phis (e, stack))\n     return 0;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n   gimple stmt\n     = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify,\n-\t\t\t\t\t\t\t*backedge_seen_p,\n-\t\t\t\t\t\t\tsrc_map, dst_map);\n+\t\t\t\t\t\t\t*backedge_seen_p);\n \n   /* If we didn't look at all the statements, the most likely reason is\n      there were too many and thus duplicating this block is not profitable.\n@@ -1112,8 +1065,6 @@ thread_across_edge (gimple dummy_cond,\n \t\t    tree (*simplify) (gimple, gimple))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n-  bitmap src_map = BITMAP_ALLOC (NULL);\n-  bitmap dst_map = BITMAP_ALLOC (NULL);\n   bool backedge_seen;\n \n   stmt_count = 0;\n@@ -1129,16 +1080,13 @@ thread_across_edge (gimple dummy_cond,\n   int threaded = thread_through_normal_block (e, dummy_cond,\n \t\t\t\t\t      handle_dominating_asserts,\n \t\t\t\t\t      stack, simplify, path,\n-\t\t\t\t\t      visited, &backedge_seen,\n-\t\t\t\t\t      src_map, dst_map);\n+\t\t\t\t\t      visited, &backedge_seen);\n   if (threaded > 0)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n       remove_temporary_equivalences (stack);\n       BITMAP_FREE (visited);\n-      BITMAP_FREE (src_map);\n-      BITMAP_FREE (dst_map);\n       register_jump_thread (path);\n       return;\n     }\n@@ -1160,8 +1108,6 @@ thread_across_edge (gimple dummy_cond,\n       if (threaded < 0)\n \t{\n \t  BITMAP_FREE (visited);\n-\t  BITMAP_FREE (src_map);\n-\t  BITMAP_FREE (dst_map);\n \t  remove_temporary_equivalences (stack);\n \t  return;\n \t}\n@@ -1190,26 +1136,15 @@ thread_across_edge (gimple dummy_cond,\n \t{\n \t  remove_temporary_equivalences (stack);\n \t  BITMAP_FREE (visited);\n-\t  BITMAP_FREE (src_map);\n-\t  BITMAP_FREE (dst_map);\n \t  return;\n \t}\n \n-    /* We need to restore the state of the maps to this point each loop\n-       iteration.  */\n-    bitmap src_map_copy = BITMAP_ALLOC (NULL);\n-    bitmap dst_map_copy = BITMAP_ALLOC (NULL);\n-    bitmap_copy (src_map_copy, src_map);\n-    bitmap_copy (dst_map_copy, dst_map);\n-\n     /* Look at each successor of E->dest to see if we can thread through it.  */\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       {\n \t/* Push a fresh marker so we can unwind the equivalences created\n \t   for each of E->dest's successors.  */\n \tstack->safe_push (NULL_TREE);\n-\tbitmap_copy (src_map, src_map_copy);\n-\tbitmap_copy (dst_map, dst_map_copy);\n      \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n@@ -1245,8 +1180,7 @@ thread_across_edge (gimple dummy_cond,\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n \t\t\t\t\t       handle_dominating_asserts,\n \t\t\t\t\t       stack, simplify, path, visited,\n-\t\t\t\t\t       &backedge_seen,\n-\t\t\t\t\t       src_map, dst_map) > 0;\n+\t\t\t\t\t       &backedge_seen) > 0;\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */\n@@ -1265,10 +1199,6 @@ thread_across_edge (gimple dummy_cond,\n \tremove_temporary_equivalences (stack);\n       }\n     BITMAP_FREE (visited);\n-    BITMAP_FREE (src_map);\n-    BITMAP_FREE (dst_map);\n-    BITMAP_FREE (src_map_copy);\n-    BITMAP_FREE (dst_map_copy);\n   }\n \n   remove_temporary_equivalences (stack);"}]}