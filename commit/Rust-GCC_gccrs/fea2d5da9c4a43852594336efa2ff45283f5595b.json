{"sha": "fea2d5da9c4a43852594336efa2ff45283f5595b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVhMmQ1ZGE5YzRhNDM4NTI1OTQzMzZlZmEyZmY0NTI4M2Y1NTk1Yg==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-02-24T03:28:39Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-02-24T03:28:39Z"}, "message": "Handle compiling multiple input files at once, and @FILE syntax. See ChangeLog.\n\nFrom-SVN: r40024", "tree": {"sha": "8922ef8858d3181ab08328253b29081a198508fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8922ef8858d3181ab08328253b29081a198508fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fea2d5da9c4a43852594336efa2ff45283f5595b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea2d5da9c4a43852594336efa2ff45283f5595b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea2d5da9c4a43852594336efa2ff45283f5595b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea2d5da9c4a43852594336efa2ff45283f5595b/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1aed31b63c536a400353aa86d6fe8fc04147ac52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aed31b63c536a400353aa86d6fe8fc04147ac52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aed31b63c536a400353aa86d6fe8fc04147ac52"}], "stats": {"total": 294, "additions": 208, "deletions": 86}, "files": [{"sha": "56cd3cce1deb48eaf275c3598d63341491ba2db8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -1,3 +1,31 @@\n+2001-02-16  Per Bothner  <per@bothner.com>\n+\n+\tHandle compiling multiple input files at once, and @FILE syntax.\n+\t* java-tree.h (flag_filelist_file, init_src_parse):  New declarations.\n+\t* jcf-parse.c (parse_source_file):  Split into ...\n+\t(parse_source_file_1):  New function - and:\n+\t(parse_source_file_2):  New function.\n+\t(yyparse):  On -ffilelist-file, open and scan named file.\n+\tOn first pass over files, only do parse_source_file_1.\n+\tA new second pass calls parse_source_file_2 for each file to compile.\n+\t(init_jcf_parse):  Call init_src_parse.\n+\t* jvspec.c (INDIRECT_FILE_ARG):  New flag.\n+\t(lang_specific_driver):  Support @FILELIST-FILE syntax, as well\n+\tas multiple input file combined in one compilation.\n+\t* lang-options.h:  Add -ffilelist-file\n+\t* lang.c (flag_filelist_file):  New flag variable.\n+\t(lang_f_options):  Handle -ffilelist-file.\n+\t* lex.c (java_init_lex): Don't clear ctxp->incomplete_class.\n+\t* parse.h (struct parse_ctxt):  Remove fields incomplete_class and\n+\tgclass_list - use global fields of src_parse_roots instead.\n+\t* parse.y (src_parse_roots):  New array.\n+\t(incomplete_class_list, gclass_list):  New macros.\n+\t(push_parser_context, java_pop_parser_context,\n+\tjava_parser_context_resume):  Don't fiddle with deleted fields.\n+\t(various):  Use incomplete_class gclass_list and global macros\n+\tinstead of parse_ctxt fields - the lists are global.\n+\t(init_src_parse):  New function.\n+\n Fri Feb 23 15:28:39 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (set_block): Set NAMES and BLOCKS from BLOCK."}, {"sha": "cadd5523a07e5ac4e1d75a1925beefa9e4043934", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -138,6 +138,8 @@ extern int flag_assume_compiled;\n \n extern int flag_emit_class_files;\n \n+extern int flag_filelist_file;\n+\n /* When non zero, assume all native functions are implemented with\n    JNI, not CNI.  */\n \n@@ -1111,6 +1113,7 @@ extern boolean java_hash_compare_tree_node PARAMS ((hash_table_key,\n \t\t\t\t\t\t    hash_table_key));\n extern void java_check_methods PARAMS ((tree));\n extern void init_jcf_parse PARAMS((void));\n+extern void init_src_parse PARAMS((void));\n \n extern int cxx_keyword_p PARAMS ((const char *, int));\n extern tree java_mangle_decl PARAMS ((struct obstack *, tree));"}, {"sha": "6ace7e8134d0cbeb79680dbe2fc9a72011957fc9", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 88, "deletions": 11, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -89,7 +89,8 @@ static void handle_innerclass_attribute PARAMS ((int count, JCF *));\n static tree give_name_to_class PARAMS ((JCF *jcf, int index));\n static void parse_zip_file_entries PARAMS ((void));\n static void process_zip_dir PARAMS ((FILE *));\n-static void parse_source_file PARAMS ((tree, FILE *));\n+static void parse_source_file_1 PARAMS ((tree, FILE *));\n+static void parse_source_file_2 PARAMS ((void));\n static void jcf_parse_source PARAMS ((void));\n static int jcf_figure_file_type PARAMS ((JCF *));\n static void parse_class_file PARAMS ((void));\n@@ -641,7 +642,8 @@ jcf_parse_source ()\n     {\n       if (!(finput = fopen (input_filename, \"r\")))\n \tfatal_io_error (\"can't reopen %s\", input_filename);\n-      parse_source_file (file, finput);\n+      parse_source_file_1 (file, finput);\n+      parse_source_file_2 ();\n       if (fclose (finput))\n \tfatal_io_error (\"can't close %s\", input_filename);\n     }\n@@ -822,7 +824,7 @@ parse_class_file ()\n /* Parse a source file, as pointed by the current value of INPUT_FILENAME. */\n \n static void\n-parse_source_file (file, finput)\n+parse_source_file_1 (file, finput)\n      tree file;\n      FILE *finput;\n {\n@@ -853,6 +855,14 @@ parse_source_file (file, finput)\n \n   java_parse ();\t\t    /* Parse and build partial tree nodes. */\n   java_parse_abort_on_error ();\n+}\n+\n+/* Process a parsed source file, resolving names etc. */\n+\n+static void\n+parse_source_file_2 ()\n+{\n+  int save_error_count = java_error_count;\n   java_complete_class ();\t    /* Parse unsatisfied class decl. */\n   java_parse_abort_on_error ();\n   java_check_circular_reference (); /* Check on circular references */\n@@ -876,18 +886,73 @@ predefined_filename_p (node)\n int\n yyparse ()\n {\n-  int several_files = 0;\n-  char *list = xstrdup (input_filename), *next;\n+  int filename_count = 0;\n+  char *list, *next;\n   tree node;\n   FILE *finput;\n \n+  if (flag_filelist_file)\n+    {\n+      int avail = 2000;\n+      finput = fopen (input_filename, \"r\");\n+      if (finput == NULL)\n+\tfatal_io_error (\"can't open %s\", input_filename);\n+      list = xmalloc(avail);\n+      next = list;\n+      for (;;)\n+\t{\n+\t  int count;\n+\t  if (avail < 500)\n+\t    {\n+\t      count = next - list;\n+\t      avail = 2 * (count + avail);\n+\t      list = xrealloc (list, avail);\n+\t      next = list + count;\n+\t      avail = avail - count;\n+\t    }\n+\t  /* Subtract to to guarantee space for final '\\0'. */\n+\t  count = fread (next, 1, avail - 1, finput);\n+\t  if (count == 0)\n+\t    {\n+\t      if (! feof (finput))\n+\t\tfatal_io_error (\"error closing %s\", input_filename);\n+\t      *next = '\\0';\n+\t      break;\n+\t    }\n+\t  avail -= count;\n+\t  next += count;\n+\t}\n+      fclose (finput);\n+    }\n+  else\n+    list = xstrdup (input_filename);\n+\n   do \n     {\n-      next = strchr (list, '&');\n-      if (next)\n+      for (next = list; ; )\n \t{\n-\t  *next++ = '\\0';\n-\t  several_files = 1;\n+\t  char *ch = *next;\n+\t  if (ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' '\n+\t      || ch == '&' /* FIXME */)\n+\t    {\n+\t      if (next == list)\n+\t\t{\n+\t\t  next++;\n+\t\t  list = next;\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *next++ = '\\0';\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (ch == '\\0')\n+\t    {\n+\t      next = NULL;\n+\t      break;\n+\t    }\n+\t  next++;\n \t}\n \n       if (list[0]) \n@@ -898,12 +963,14 @@ yyparse ()\n \n \t  int len = strlen (list);\n \n-\t  if (*list != '/' && several_files)\n+\t  if (*list != '/' && filename_count > 0)\n \t    obstack_grow (&temporary_obstack, \"./\", 2);\n \n \t  obstack_grow0 (&temporary_obstack, list, len);\n \t  value = obstack_finish (&temporary_obstack);\n \n+\t  filename_count++;\n+\n \t  /* Exclude file that we see twice on the command line. For\n \t     all files except {Class,Error,Object,RuntimeException,String,\n \t     Throwable}.java we can rely on maybe_get_identifier. For\n@@ -943,6 +1010,9 @@ yyparse ()\n     }\n   while (next);\n \n+  if (filename_count == 0)\n+    warning (\"no input file specified\");\n+\n   current_jcf = main_jcf;\n   current_file_list = nreverse (current_file_list);\n   for (node = current_file_list; node; node = TREE_CHAIN (node))\n@@ -985,13 +1055,18 @@ yyparse ()\n \tcase JCF_SOURCE:\n \t  java_push_parser_context ();\n \t  java_parser_context_save_global ();\n-\t  parse_source_file (name, finput);\n+\t  parse_source_file_1 (name, finput);\n \t  java_parser_context_restore_global ();\n \t  java_pop_parser_context (1);\n \t  break;\n \t}\n     }\n \n+  for (ctxp = ctxp_for_generation;  ctxp;  ctxp = ctxp->next)\n+    {\n+      parse_source_file_2 ();\n+    }\n+\n   java_expand_classes ();\n   if (!java_report_errors () && !flag_syntax_only)\n     emit_register_classes ();\n@@ -1137,4 +1212,6 @@ init_jcf_parse ()\n   ggc_add_tree_root (parse_roots, sizeof (parse_roots) / sizeof(tree));\n \n   ggc_add_root (&current_jcf, 1, sizeof (JCF), (void (*)(void *))ggc_mark_jcf);\n+\n+  init_src_parse ();\n }"}, {"sha": "684811ac5ee46359a60ce885f3da367dbdd39c49", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -38,6 +38,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define JAVA_FILE_ARG\t(1<<3)\n /* True if this arg is a .class input file name. */\n #define CLASS_FILE_ARG\t(1<<4)\n+/* True if this arg is @FILE - where FILE contains a list of filenames. */\n+#define INDIRECT_FILE_ARG (1<<5)\n \n static char *find_spec_file\tPARAMS ((const char *));\n \n@@ -47,11 +49,6 @@ int lang_specific_extra_outfiles = 0;\n /* True if we should add -shared-libgcc to the command-line.  */\n int shared_libgcc = 1;\n \n-/* Once we have the proper support in jc1 (and gcc.c) working,\n-   set COMBINE_INPUTS to one.  This enables combining multiple *.java\n-   and *.class input files to be passed to a single jc1 invocation. */\n-#define COMBINE_INPUTS 0\n-\n const char jvgenmain_spec[] =\n   \"jvgenmain %{D*} %i %{!pipe:%umain.i} |\\n\\\n    cc1 %{!pipe:%Umain.i} %1 \\\n@@ -108,29 +105,27 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n      link in libgcj.  */\n   int library = 1;\n \n-#if COMBINE_INPUTS\n   /* This will be 1 if multiple input files (.class and/or .java)\n      should be passed to a single jc1 invocation. */\n   int combine_inputs = 0;\n \n   /* Index of last .java or .class argument. */\n   int last_input_index;\n \n-  /* A buffer containing the concatenation of the inputs files\n-     (e.g. \"foo.java&bar.class&baz.class\"). if combine_inputs. */\n-  char* combined_inputs_buffer;\n-\n-  /* Next available location in combined_inputs_buffer. */\n-  int combined_inputs_pos;\n-\n   /* Number of .java and .class source file arguments seen. */\n   int java_files_count = 0;\n   int class_files_count = 0;\n+  /* Number of '@FILES' arguments seen. */\n+  int indirect_files_count = 0;\n \n   /* Cumulative length of the  .java and .class source file names. */\n   int java_files_length = 0;\n   int class_files_length = 0;\n-#endif\n+\n+  /* Name of file containing list of files to compile. */\n+  char *filelist_filename;\n+\n+  FILE *filelist_file;\n \n   /* The number of arguments being added to what's in argv, other than\n      libraries.  We use this to track the number of times we've inserted\n@@ -149,6 +144,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n      already gave a language for the file.  */\n   int saw_speclang = 0;\n \n+#if 0\n   /* \"-lm\" or \"-lmath\" if it appears on the command line.  */\n   const char *saw_math ATTRIBUTE_UNUSED = 0;\n \n@@ -163,6 +159,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n   /* Saw `-lgcj' on command line.  */\n   int saw_libgcj ATTRIBUTE_UNUSED = 0;\n+#endif\n \n   /* Saw -C or -o option, respectively. */\n   int saw_C = 0;\n@@ -251,9 +248,6 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t    {\n \t      saw_C = 1;\n \t      want_spec_file = 0;\n-#if COMBINE_INPUTS\n-\t      combine_inputs = 1;\n-#endif\n \t      if (library != 0)\n \t\tadded -= 2;\n \t      library = 0;\n@@ -317,17 +311,20 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t}\n       else\n \t{\n-#if COMBINE_INPUTS\n \t  int len; \n-#endif\n \n \t  if (saw_speclang)\n \t    {\n \t      saw_speclang = 0;\n \t      continue;\n \t    }\n \n-#if COMBINE_INPUTS\n+\t  if (argv[i][0] == '@')\n+\t    {\n+\t      args[i] |= INDIRECT_FILE_ARG;\n+\t      indirect_files_count++;\n+\t    }\n+\n \t  len = strlen (argv[i]);\n \t  if (len > 5 && strcmp (argv[i] + len - 5, \".java\") == 0)\n \t    {\n@@ -343,7 +340,6 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t      class_files_length += len;\n \t      last_input_index = i;\n \t    }\n-#endif\n \t}\n     }\n \n@@ -357,33 +353,34 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   if (saw_C)\n     {\n       num_args += 3;\n-#if COMBINE_INPUTS\n-      class_files_length = 0;\n-      num_args -= class_files_count;\n+      if (class_files_count > 0)\n+\t{\n+\t  error (\"Warning: already-compiled .class files ignored with -C\"); \n+\t  class_files_count = 0;\n+\t  num_args -= class_files_count;\n+\t}\n       num_args += 2;  /* For -o NONE. */\n-#endif\n       if (saw_o)\n \tfatal (\"cannot specify both -C and -o\");\n     }\n-#if COMBINE_INPUTS\n   if (saw_o && java_files_count + (saw_C ? 0 : class_files_count) > 1)\n     combine_inputs = 1;\n+  if (class_files_count > 1)\n+    combine_inputs = 1;\n \n   if (combine_inputs)\n     {\n-      int len = java_files_length + java_files_count - 1;\n-      num_args -= java_files_count;\n+      filelist_filename = make_temp_file (\"jx\");\n+      if (filelist_filename == NULL)\n+\tfatal (\"cannot create temporary file\");\n+      record_temp_file (filelist_filename, 1, 0);\n+      filelist_file = fopen (filelist_filename, \"w\");\n+      if (filelist_file == NULL)\n+\tpfatal_with_name (filelist_filename);\n+      num_args -= java_files_count + class_files_count;\n       num_args++;  /* Add one for the combined arg. */\n-      if (class_files_length > 0)\n-\t{\n-\t  len += class_files_length + class_files_count - 1;\n-\t  num_args -= class_files_count;\n-\t}\n-      combined_inputs_buffer = (char*) xmalloc (len);\n-      combined_inputs_pos = 0;\n     }\n   /* If we know we don't have to do anything, bail now.  */\n-#endif\n #if 0\n   if (! added && ! library && main_class_name == NULL && ! saw_C)\n     {\n@@ -400,6 +397,11 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n     num_args++;\n   num_args++;\n \n+  if (combine_inputs || indirect_files_count > 0)\n+    num_args += 2;\n+  if (combine_inputs && indirect_files_count > 0)\n+    fatal(\"using both @FILE with multiple files not implemented\");\n+\n   /* There's no point adding -shared-libgcc if we don't have a shared\n      libgcc.  */\n #ifndef ENABLE_SHARED_LIBGCC\n@@ -409,9 +411,16 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   num_args += shared_libgcc;\n \n   arglist = (const char **) xmalloc ((num_args + 1) * sizeof (char *));\n+  j = 0;\n \n-  for (i = 0, j = 0; i < argc; i++, j++)\n+  for (i = 0; i < argc; i++, j++)\n     {\n+      if (i == 1 && (combine_inputs || indirect_files_count > 0))\n+\t{\n+\t  arglist[j++] = \"-ffilelist-file\";\n+\t  arglist[j++] = \"-xjava\";\n+\t}\n+\n       arglist[j] = argv[i];\n \n       if ((args[i] & PARAM_ARG) || i == 0)\n@@ -449,35 +458,32 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t  continue;\n \t}\n \n+      if ((args[i] & INDIRECT_FILE_ARG) != 0)\n+\t{\n+\t  arglist[j] = argv[i]+1;  /* Drop '@'. */\n+\t}\n+\n       if ((args[i] & CLASS_FILE_ARG) && saw_C)\n \t{\n \t  --j;\n \t  continue;\n \t}\n \n-#if COMBINE_INPUTS\n       if (combine_inputs && (args[i] & (CLASS_FILE_ARG|JAVA_FILE_ARG)) != 0)\n \t{\n-\t  if (combined_inputs_pos > 0)\n-\t    combined_inputs_buffer[combined_inputs_pos++] = '&';\n-\t  strcpy (&combined_inputs_buffer[combined_inputs_pos], argv[i]);\n-\t  combined_inputs_pos += strlen (argv[i]);\n+\t  fputs (argv[i], filelist_file);\n+\t  fputc ('\\n', filelist_file);\n \t  --j;\n \t  continue;\n \t}\n-#endif\n   }\n \n-#if COMBINE_INPUTS\n   if (combine_inputs)\n     {\n-      combined_inputs_buffer[combined_inputs_pos] = '\\0';\n-#if 0\n-      if (! saw_C)\n-#endif\n-      arglist[j++] = combined_inputs_buffer;\n+      if (fclose (filelist_file))\n+\tpfatal_with_name (filelist_filename);\n+      arglist[j++] = filelist_filename;\n     }\n-#endif\n \n   /* If we saw no -O or -g option, default to -g1, for javac compatibility. */\n   if (saw_g + saw_O == 0)\n@@ -494,10 +500,8 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n       arglist[j++] = \"-fsyntax-only\";\n       arglist[j++] = \"-femit-class-files\";\n       arglist[j++] = \"-S\";\n-#if COMBINE_INPUTS\n       arglist[j++] = \"-o\";\n       arglist[j++] = \"NONE\";\n-#endif\n     }\n   \n   if (shared_libgcc)"}, {"sha": "776b432a712cae726c6edc504e9c1ce0763f9835", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -33,6 +33,7 @@ DEFINE_LANG_NAME (\"Java\")\n   { \"-fno-assume-compiled\", \"\" },\n   { \"-femit-class-file\", \"\" },\n   { \"-femit-class-files\", \"Dump class files to <name>.class\" },\n+  { \"-ffilelist-file\", \"input file is list of file names to compile\" },\n   { \"-fuse-boehm-gc\", \"Generate code for Boehm GC\" },\n   { \"-fhash-synchronization\", \"Don't put synchronization structure in each object\" },\n   { \"-fjni\", \"Assume native functions are implemented using JNI\" },"}, {"sha": "1680d99d2ae5a91d53bccbeeb332130ccb42b8f6", "filename": "gcc/java/lang.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -105,6 +105,10 @@ int flag_assume_compiled = 1;\n \n int flag_emit_class_files = 0;\n \n+/* Nonzero if input file is a file with a list of filenames to compile. */\n+\n+int flag_filelist_file = 0;\n+\n /* When non zero, we emit xref strings. Values of the flag for xref\n    backends are defined in xref_flag_table, xref.c.  */\n \n@@ -156,6 +160,7 @@ lang_f_options[] =\n {\n   {\"emit-class-file\", &flag_emit_class_files, 1},\n   {\"emit-class-files\", &flag_emit_class_files, 1},\n+  {\"filelist-file\", &flag_filelist_file, 1},\n   {\"use-divide-subroutine\", &flag_use_divide_subroutine, 1},\n   {\"use-boehm-gc\", &flag_use_boehm_gc, 1},\n   {\"hash-synchronization\", &flag_hash_synchronization, 1},"}, {"sha": "3b43fa0ac5f31f03a9d2adda33339fc153958e64", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -120,7 +120,7 @@ java_init_lex (finput, encoding)\n     wfl_to_string = build_expr_wfl (get_identifier (\"toString\"), NULL, 0, 0);\n \n   CPC_INITIALIZER_LIST (ctxp) = CPC_STATIC_INITIALIZER_LIST (ctxp) =\n-    CPC_INSTANCE_INITIALIZER_LIST (ctxp) = ctxp->incomplete_class = NULL_TREE;\n+    CPC_INSTANCE_INITIALIZER_LIST (ctxp) = NULL_TREE;\n \n   memset ((PTR) ctxp->modifier_ctx, 0, 11*sizeof (ctxp->modifier_ctx[0]));\n   memset ((PTR) current_jcf, 0, sizeof (JCF));"}, {"sha": "ad87bc64d486148270b3e279f263d3937ef817f1", "filename": "gcc/java/parse.y", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea2d5da9c4a43852594336efa2ff45283f5595b/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=fea2d5da9c4a43852594336efa2ff45283f5595b", "patch": "@@ -348,7 +348,7 @@ static int in_instance_initializer;\n struct parser_ctxt *ctxp;\n \n /* List of things that were analyzed for which code will be generated */\n-static struct parser_ctxt *ctxp_for_generation = NULL;\n+struct parser_ctxt *ctxp_for_generation = NULL;\n \n /* binop_lookup maps token to tree_code. It is used where binary\n    operations are involved and required by the parser. RDIV_EXPR\n@@ -411,6 +411,14 @@ static tree current_this;\n    the list of the catch clauses of the currently analysed try block. */\n static tree currently_caught_type_list;\n \n+static tree src_parse_roots[2] = { NULL_TREE, NULL_TREE };\n+\n+/* All classes seen from source code */\n+#define gclass_list src_parse_roots[0]\n+\n+/* List of non-complete classes */\n+#define incomplete_class_list src_parse_roots[1]\n+\n /* Check modifiers. If one doesn't fit, retrieve it in its declaration\n    line and point it out.  */\n /* Should point out the one that don't fit. ASCII/unicode, going\n@@ -2640,11 +2648,6 @@ void\n java_push_parser_context ()\n {\n   create_new_parser_context (0);\n-  if (ctxp->next)\n-    {\n-      ctxp->incomplete_class = ctxp->next->incomplete_class;\n-      ctxp->gclass_list = ctxp->next->gclass_list;\n-    }\n }  \n \n void \n@@ -2661,8 +2664,6 @@ java_pop_parser_context (generate)\n   next = ctxp->next;\n   if (next)\n     {\n-      next->incomplete_class = ctxp->incomplete_class;\n-      next->gclass_list = ctxp->gclass_list;\n       lineno = ctxp->lineno;\n       current_class = ctxp->class_type;\n     }\n@@ -2776,8 +2777,6 @@ java_parser_context_resume ()\n   struct parser_ctxt *restored = saver->next; /* This one is the old current */\n \n   /* We need to inherit the list of classes to complete/generate */\n-  restored->incomplete_class = old->incomplete_class;\n-  restored->gclass_list = old->gclass_list;\n   restored->classd_list = old->classd_list;\n   restored->class_list = old->class_list;\n \n@@ -3652,7 +3651,7 @@ maybe_create_class_interface_decl (decl, raw_name, qualified_name, cl)\n   ctxp->class_list = decl;\n \n   /* Create a new nodes in the global lists */\n-  ctxp->gclass_list = tree_cons (NULL_TREE, decl, ctxp->gclass_list);\n+  gclass_list = tree_cons (NULL_TREE, decl, gclass_list);\n   all_class_list = tree_cons (NULL_TREE, decl, all_class_list);\n \n   /* Install a new dependency list element */\n@@ -4991,16 +4990,16 @@ obtain_incomplete_type (type_name)\n   else\n     abort ();\n \n-  for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))\n+  for (ptr = incomplete_class_list; ptr; ptr = TREE_CHAIN (ptr))\n     if (TYPE_NAME (ptr) == name)\n       break;\n \n   if (!ptr)\n     {\n       BUILD_PTR_FROM_NAME (ptr, name);\n       layout_type (ptr);\n-      TREE_CHAIN (ptr) = ctxp->incomplete_class;\n-      ctxp->incomplete_class = ptr;\n+      TREE_CHAIN (ptr) = incomplete_class_list;\n+      incomplete_class_list = ptr;\n     }\n \n   return ptr;\n@@ -7285,7 +7284,7 @@ java_reorder_fields ()\n       initialized_p = 1;\n     }\n \n-  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n+  for (current = gclass_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n \n@@ -7315,11 +7314,11 @@ java_reorder_fields ()\n \t  }\n       }\n     }\n-  stop_reordering = TREE_TYPE (TREE_VALUE (ctxp->gclass_list));\n+  stop_reordering = TREE_TYPE (TREE_VALUE (gclass_list));\n }\n \n-/* Layout the methods of all classes loaded in one way on an\n-   other. Check methods of source parsed classes. Then reorder the\n+/* Layout the methods of all classes loaded in one way or another.\n+   Check methods of source parsed classes. Then reorder the\n    fields and layout the classes or the type of all source parsed\n    classes */\n \n@@ -7335,12 +7334,12 @@ java_layout_classes ()\n   all_class_list = NULL_TREE;\n \n   /* Then check the methods of all parsed classes */\n-  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n+  for (current = gclass_list; current; current = TREE_CHAIN (current))\n     if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n       java_check_methods (TREE_VALUE (current));\n   java_parse_abort_on_error ();\n \n-  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n+  for (current = gclass_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n       layout_class (current_class);\n@@ -15688,8 +15687,6 @@ mark_parser_ctxt (p)\n   ggc_mark_tree (pc->class_type);\n   ggc_mark_tree (pc->function_decl);\n   ggc_mark_tree (pc->package);\n-  ggc_mark_tree (pc->incomplete_class);\n-  ggc_mark_tree (pc->gclass_list);\n   ggc_mark_tree (pc->class_list);\n   ggc_mark_tree (pc->current_parsed_class);\n   ggc_mark_tree (pc->current_parsed_class_un);\n@@ -15705,3 +15702,10 @@ mark_parser_ctxt (p)\n   if (pc->next)\n     mark_parser_ctxt (&pc->next);\n }\n+\n+void\n+init_src_parse ()\n+{\n+  /* Register roots with the garbage collector.  */\n+  ggc_add_tree_root (src_parse_roots, sizeof (src_parse_roots) / sizeof(tree));\n+}"}]}