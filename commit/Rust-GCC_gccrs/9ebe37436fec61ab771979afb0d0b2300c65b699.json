{"sha": "9ebe37436fec61ab771979afb0d0b2300c65b699", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViZTM3NDM2ZmVjNjFhYjc3MTk3OWFmYjBkMGIyMzAwYzY1YjY5OQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2005-11-15T14:03:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T14:03:45Z"}, "message": "sem_res.adb (Resolve_Call): Provide a better error message whenever a procedure call is used as a select...\n\n2005-11-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_res.adb (Resolve_Call): Provide a better error message whenever\n\ta procedure call is used as a select statement trigger and is not an\n\tentry renaming or a primitive of a limited interface.\n\t(Valid_Conversion): If the operand has a single interpretation do not\n\tremove address operations.\n\t(Check_Infinite_Recursion): Skip freeze nodes when looking for a raise\n\tstatement to inhibit warning.\n\t(Resolve_Unary_Op): Do not produce a warning when\n\tprocessing an expression of the form -(A mod B)\n\tUse Universal_Real instead of Long_Long_Float when we need a high\n\tprecision float type for the generated code (prevents gratuitous\n\tVax_Float stuff when pragma Float_Representation (Vax_Float) used)\n\t(Resolve_Concatenation_Arg): Improve error message when argument is an\n\tambiguous call to a function that returns an array.\n\t(Make_Call_Into_Operator, Operand_Type_In_Scope): Do not check that\n\tthere is an implicit operator in the given scope if we are within an\n\tinstance: legality check has been performed on the generic.\n\t(Resolve_Unary_Op): Apply warnings checks on argument of Abs operator\n\tafter resolving operand, to avoid false warnings on overloaded calls.\n\nFrom-SVN: r107005", "tree": {"sha": "b8f9d4297a05a9ce1bf5767b2e0356f3fdaf3532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f9d4297a05a9ce1bf5767b2e0356f3fdaf3532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ebe37436fec61ab771979afb0d0b2300c65b699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ebe37436fec61ab771979afb0d0b2300c65b699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ebe37436fec61ab771979afb0d0b2300c65b699", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ebe37436fec61ab771979afb0d0b2300c65b699/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0356699b567f9e97ddb50e55ea623676af9a44d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0356699b567f9e97ddb50e55ea623676af9a44d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0356699b567f9e97ddb50e55ea623676af9a44d4"}], "stats": {"total": 193, "additions": 111, "deletions": 82}, "files": [{"sha": "f9093455fbbffb8e8bcd57674da8ffcd4dc155ef", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 111, "deletions": 82, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe37436fec61ab771979afb0d0b2300c65b699/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe37436fec61ab771979afb0d0b2300c65b699/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=9ebe37436fec61ab771979afb0d0b2300c65b699", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -280,7 +280,6 @@ package body Sem_Res is\n       if Suppress = All_Checks then\n          declare\n             Svg : constant Suppress_Array := Scope_Suppress;\n-\n          begin\n             Scope_Suppress := (others => True);\n             Analyze_And_Resolve (N, Typ);\n@@ -322,7 +321,6 @@ package body Sem_Res is\n       if Suppress = All_Checks then\n          declare\n             Svg : constant Suppress_Array := Scope_Suppress;\n-\n          begin\n             Scope_Suppress := (others => True);\n             Analyze_And_Resolve (N);\n@@ -685,12 +683,30 @@ package body Sem_Res is\n             if Nkind (Parent (N)) = N_Return_Statement\n               and then Same_Argument_List\n             then\n-               exit when not Is_List_Member (Parent (N))\n-                 or else (Nkind (Prev (Parent (N))) /= N_Raise_Statement\n-                            and then\n-                          (Nkind (Prev (Parent (N))) not in N_Raise_xxx_Error\n-                             or else\n-                           Present (Condition (Prev (Parent (N))))));\n+               exit when not Is_List_Member (Parent (N));\n+\n+               --  OK, return statement is in a statement list, look for raise\n+\n+               declare\n+                  Nod : Node_Id;\n+\n+               begin\n+                  --  Skip past N_Freeze_Entity nodes generated by expansion\n+\n+                  Nod := Prev (Parent (N));\n+                  while Present (Nod)\n+                    and then Nkind (Nod) = N_Freeze_Entity\n+                  loop\n+                     Prev (Nod);\n+                  end loop;\n+\n+                  --  If no raise statement, give warning\n+\n+                  exit when Nkind (Nod) /= N_Raise_Statement\n+                    and then\n+                      (Nkind (Nod) not in N_Raise_xxx_Error\n+                         or else Present (Condition (Nod)));\n+               end;\n             end if;\n \n             return False;\n@@ -1124,6 +1140,13 @@ package body Sem_Res is\n          then\n             null;\n \n+         --  Visibility does not need to be checked in an instance: if the\n+         --  operator was not visible in the generic it has been diagnosed\n+         --  already, else there is an implicit copy of it in the instance.\n+\n+         elsif In_Instance then\n+            null;\n+\n          elsif (Op_Name =  Name_Op_Multiply\n               or else Op_Name = Name_Op_Divide)\n            and then Is_Fixed_Point_Type (Etype (Left_Opnd  (Op_Node)))\n@@ -2316,7 +2339,6 @@ package body Sem_Res is\n       if Suppress = All_Checks then\n          declare\n             Svg : constant Suppress_Array := Scope_Suppress;\n-\n          begin\n             Scope_Suppress := (others => True);\n             Resolve (N, Typ);\n@@ -2326,7 +2348,6 @@ package body Sem_Res is\n       else\n          declare\n             Svg : constant Boolean := Scope_Suppress (Suppress);\n-\n          begin\n             Scope_Suppress (Suppress) := True;\n             Resolve (N, Typ);\n@@ -3519,7 +3540,6 @@ package body Sem_Res is\n       It      : Interp;\n       Norm_OK : Boolean;\n       Scop    : Entity_Id;\n-      W       : Node_Id;\n \n    begin\n       --  The context imposes a unique interpretation with type Typ on a\n@@ -3659,39 +3679,9 @@ package body Sem_Res is\n          Kill_Current_Values;\n       end if;\n \n-      --  Deal with call to obsolescent subprogram. Note that we always allow\n-      --  such calls in the compiler itself and the run-time, since we assume\n-      --  that we know what we are doing in such cases. For example, the calls\n-      --  in Ada.Characters.Handling to its own obsolescent subprograms are\n-      --  just fine.\n-\n-      if Is_Obsolescent (Nam) and then not GNAT_Mode then\n-         Check_Restriction (No_Obsolescent_Features, N);\n-\n-         if Warn_On_Obsolescent_Feature then\n-            Error_Msg_NE (\"call to obsolescent subprogram&?\", N, Nam);\n-\n-            --  Output additional warning if present\n-\n-            W := Obsolescent_Warning (Nam);\n+      --  Check for call to subprogram marked Is_Obsolescent\n \n-            if Present (W) then\n-               Name_Buffer (1) := '|';\n-               Name_Buffer (2) := '?';\n-               Name_Len := 2;\n-\n-               --  Add characters to message, and output message\n-\n-               for J in 1 .. String_Length (Strval (W)) loop\n-                  Add_Char_To_Name_Buffer (''');\n-                  Add_Char_To_Name_Buffer\n-                    (Get_Character (Get_String_Char (Strval (W), J)));\n-               end loop;\n-\n-               Error_Msg_N (Name_Buffer (1 .. Name_Len), N);\n-            end if;\n-         end if;\n-      end if;\n+      Check_Obsolescent (Nam, N);\n \n       --  Check that a procedure call does not occur in the context of the\n       --  entry call statement of a conditional or timed entry call. Note that\n@@ -3720,7 +3710,8 @@ package body Sem_Res is\n            and then not Is_Controlling_Limited_Procedure (Nam)\n          then\n             Error_Msg_N\n-              (\"procedure or entry call required in select statement\", N);\n+             (\"entry call, entry renaming or dispatching primitive \" &\n+              \"of limited or synchronized interface required\", N);\n          end if;\n       end if;\n \n@@ -5469,25 +5460,47 @@ package body Sem_Res is\n                  and then Has_Compatible_Type (Arg, Typ)\n                  and then Etype (Arg) /= Any_Type\n                then\n-                  Error_Msg_N (\"ambiguous operand for concatenation!\", Arg);\n \n                   declare\n-                     I  : Interp_Index;\n-                     It : Interp;\n+                     I    : Interp_Index;\n+                     It   : Interp;\n+                     Func : Entity_Id;\n \n                   begin\n                      Get_First_Interp (Arg, I, It);\n-                     while Present (It.Nam) loop\n-                        if Base_Type (Etype (It.Nam)) = Base_Type (Typ)\n-                          or else Base_Type (Etype (It.Nam)) =\n-                            Base_Type (Component_Type (Typ))\n-                        then\n+                     Func := It.Nam;\n+                     Get_Next_Interp (I, It);\n+\n+                     --  Special-case the error message when the overloading\n+                     --  is caused by a function that yields and array and\n+                     --  can be called without parameters.\n+\n+                     if It.Nam = Func then\n+                        Error_Msg_Sloc := Sloc (Func);\n+                        Error_Msg_N (\"\\ambiguous call to function#\", Arg);\n+                        Error_Msg_NE\n+                          (\"\\interpretation as call yields&\", Arg, Typ);\n+                        Error_Msg_NE\n+                          (\"\\interpretation as indexing of call yields&\",\n+                            Arg, Component_Type (Typ));\n+\n+                     else\n+                        Error_Msg_N (\"ambiguous operand for concatenation!\",\n+                          Arg);\n+                        Get_First_Interp (Arg, I, It);\n+                        while Present (It.Nam) loop\n                            Error_Msg_Sloc := Sloc (It.Nam);\n-                           Error_Msg_N (\"\\possible interpretation#\", Arg);\n-                        end if;\n \n-                        Get_Next_Interp (I, It);\n-                     end loop;\n+                           if Base_Type (It.Typ) = Base_Type (Typ)\n+                             or else Base_Type (It.Typ) =\n+                               Base_Type (Component_Type (Typ))\n+                           then\n+                              Error_Msg_N (\"\\possible interpretation#\", Arg);\n+                           end if;\n+\n+                           Get_Next_Interp (I, It);\n+                        end loop;\n+                     end if;\n                   end;\n                end if;\n \n@@ -6536,13 +6549,14 @@ package body Sem_Res is\n             end if;\n \n             --  Resolve the real operand with largest available precision\n+\n             if Etype (Right_Opnd (Operand)) = Universal_Real then\n                Rop := New_Copy_Tree (Right_Opnd (Operand));\n             else\n                Rop := New_Copy_Tree (Left_Opnd (Operand));\n             end if;\n \n-            Resolve (Rop, Standard_Long_Long_Float);\n+            Resolve (Rop, Universal_Real);\n \n             --  If the operand is a literal (it could be a non-static and\n             --  illegal exponentiation) check whether the use of Duration\n@@ -6690,23 +6704,11 @@ package body Sem_Res is\n       Hi    : Uint;\n \n    begin\n-      --  Generate warning for expressions like abs (x mod 2)\n-\n-      if Warn_On_Redundant_Constructs\n-        and then Nkind (N) = N_Op_Abs\n-      then\n-         Determine_Range (Right_Opnd (N), OK, Lo, Hi);\n-\n-         if OK and then Hi >= Lo and then Lo >= 0 then\n-            Error_Msg_N\n-             (\"?abs applied to known non-negative value has no effect\", N);\n-         end if;\n-      end if;\n-\n       --  Generate warning for expressions like -5 mod 3\n \n       if Paren_Count (N) = 0\n         and then Nkind (N) = N_Op_Minus\n+        and then Paren_Count (Right_Opnd (N)) = 0\n         and then Nkind (Right_Opnd (N)) = N_Op_Mod\n         and then Comes_From_Source (N)\n       then\n@@ -6732,6 +6734,19 @@ package body Sem_Res is\n       Set_Etype (N, B_Typ);\n       Resolve (R, B_Typ);\n \n+      --  Generate warning for expressions like abs (x mod 2)\n+\n+      if Warn_On_Redundant_Constructs\n+        and then Nkind (N) = N_Op_Abs\n+      then\n+         Determine_Range (Right_Opnd (N), OK, Lo, Hi);\n+\n+         if OK and then Hi >= Lo and then Lo >= 0 then\n+            Error_Msg_N\n+             (\"?abs applied to known non-negative value has no effect\", N);\n+         end if;\n+      end if;\n+\n       Check_Unset_Reference (R);\n       Generate_Operator_Reference (N, B_Typ);\n       Eval_Unary_Op (N);\n@@ -7187,21 +7202,35 @@ package body Sem_Res is\n             --  is no context type and the removal of the spurious operations\n             --  must be done explicitly here.\n \n+            --  The node may be labelled overloaded, but still contain only\n+            --  one interpretation because others were discarded in previous\n+            --  filters. If this is the case, retain the single interpretation\n+            --  if legal.\n+\n             Get_First_Interp (Operand, I, It);\n+            Opnd_Type := It.Typ;\n+            Get_Next_Interp (I, It);\n \n-            while Present (It.Typ) loop\n-               if It.Typ = Standard_Void_Type then\n-                  Remove_Interp (I);\n-               end if;\n+            if Present (It.Typ)\n+              and then Opnd_Type /= Standard_Void_Type\n+            then\n+               --  More than one candidate interpretation is available\n \n-               if Present (System_Aux_Id)\n-                 and then Is_Descendent_Of_Address (It.Typ)\n-               then\n-                  Remove_Interp (I);\n-               end if;\n+               Get_First_Interp (Operand, I, It);\n+               while Present (It.Typ) loop\n+                  if It.Typ = Standard_Void_Type then\n+                     Remove_Interp (I);\n+                  end if;\n \n-               Get_Next_Interp (I, It);\n-            end loop;\n+                  if Present (System_Aux_Id)\n+                    and then Is_Descendent_Of_Address (It.Typ)\n+                  then\n+                     Remove_Interp (I);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end if;\n \n             Get_First_Interp (Operand, I, It);\n             I1  := I;"}]}