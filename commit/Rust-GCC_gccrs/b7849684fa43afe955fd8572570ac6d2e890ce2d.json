{"sha": "b7849684fa43afe955fd8572570ac6d2e890ce2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4NDk2ODRmYTQzYWZlOTU1ZmQ4NTcyNTcwYWM2ZDJlODkwY2UyZA==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@rice.edu", "date": "2003-08-23T01:32:59Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2003-08-23T01:32:59Z"}, "message": "pa.c: Replace 'GNU CC' with 'GCC'.\n\n2003-08-22  Jason Eckhardt  <jle@rice.edu>\n\n\t* config/pa/pa.c: Replace 'GNU CC' with 'GCC'.\n\tRemove all uses of PARAMS macro.\n\tConvert all function definitions to ISO C90 syntax.\n\t* config/pa/elf.h: Replace 'GNU CC' with 'GCC'.\n\t* config/pa/fptr.c: Likewise.\n\t* config/pa/lib2funcs.asm: Likewise.\n\t* config/pa/long_double.h: Likewise.\n\t* config/pa/milli64.S: Likewise.\n\t* config/pa/pa-64.h: Likewise.\n\t* config/pa/pa-hpux.h: Likewise.\n\t* config/pa/pa-hpux10.h: Likewise.\n\t* config/pa/pa-hpux11.h: Likewise.\n\t* config/pa/pa-linux.h: Likewise.\n\t* config/pa/pa-modes.def: Likewise.\n\t* config/pa/pa-osf.h: Likewise.\n\t* config/pa/pa-pro-end.h: Likewise.\n\t* config/pa/pa.md: Likewise.\n\t* config/pa/pa32-linux.h: Likewise.\n\t* config/pa/pa64-linux.h: Likewise.\n\t* config/pa/pa64-hpux.h: Likewise.\n\t* config/pa/pa64-regs.h: Likewise.\n\t* config/pa/quadlib.c: Likewise.\n\t* config/pa/rtems.h: Likewise.\n\t* config/pa/pa-protos.h: Replace 'GNU CC' with 'GCC' and remove\n\tall uses of the PARAMS macro.\n\t* config/pa/pa.h: Likewise.\n\t* config/pa/som.h: Likewise.\n\n        * config/iq2000/iq2000.c: Replace 'GNU CC' with 'GCC'.\n        Remove all uses of PARAMS macro.\n        Convert all function definitions to ISO C90 syntax.\n\t* config/iq2000-protos.h: Replace 'GNU CC' with 'GCC'.\n        Remove all uses of PARAMS macro.\n\t* config/iq2000.h: Remove all uses of PARAMS macro.\n        * config/iq2000/iq2000.md: Replace 'GNU CC' with 'GCC'.\n\nFrom-SVN: r70715", "tree": {"sha": "43ea53572d799d4473019c4467020f44a0547321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43ea53572d799d4473019c4467020f44a0547321"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7849684fa43afe955fd8572570ac6d2e890ce2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7849684fa43afe955fd8572570ac6d2e890ce2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7849684fa43afe955fd8572570ac6d2e890ce2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7849684fa43afe955fd8572570ac6d2e890ce2d/comments", "author": null, "committer": null, "parents": [{"sha": "416cf582d382973bda9dd516b9044e60d107dd43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416cf582d382973bda9dd516b9044e60d107dd43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416cf582d382973bda9dd516b9044e60d107dd43"}], "stats": {"total": 1554, "additions": 620, "deletions": 934}, "files": [{"sha": "0aa8268e3455168424c4a3b867392182859b0408", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,3 +1,41 @@\n+2003-08-22  Jason Eckhardt  <jle@rice.edu>\n+\n+\t* config/pa/pa.c: Replace 'GNU CC' with 'GCC'.\n+\tRemove all uses of PARAMS macro.\n+\tConvert all function definitions to ISO C90 syntax.\n+\t* config/pa/elf.h: Replace 'GNU CC' with 'GCC'.\n+\t* config/pa/fptr.c: Likewise.\n+\t* config/pa/lib2funcs.asm: Likewise.\n+\t* config/pa/long_double.h: Likewise.\n+\t* config/pa/milli64.S: Likewise.\n+\t* config/pa/pa-64.h: Likewise.\n+\t* config/pa/pa-hpux.h: Likewise.\n+\t* config/pa/pa-hpux10.h: Likewise.\n+\t* config/pa/pa-hpux11.h: Likewise.\n+\t* config/pa/pa-linux.h: Likewise.\n+\t* config/pa/pa-modes.def: Likewise.\n+\t* config/pa/pa-osf.h: Likewise.\n+\t* config/pa/pa-pro-end.h: Likewise.\n+\t* config/pa/pa.md: Likewise.\n+\t* config/pa/pa32-linux.h: Likewise.\n+\t* config/pa/pa64-linux.h: Likewise.\n+\t* config/pa/pa64-hpux.h: Likewise.\n+\t* config/pa/pa64-regs.h: Likewise.\n+\t* config/pa/quadlib.c: Likewise.\n+\t* config/pa/rtems.h: Likewise.\n+\t* config/pa/pa-protos.h: Replace 'GNU CC' with 'GCC' and remove\n+\tall uses of the PARAMS macro. \n+\t* config/pa/pa.h: Likewise.\n+\t* config/pa/som.h: Likewise.\n+\n+        * config/iq2000/iq2000.c: Replace 'GNU CC' with 'GCC'.\n+        Remove all uses of PARAMS macro.\n+        Convert all function definitions to ISO C90 syntax.\n+\t* config/iq2000-protos.h: Replace 'GNU CC' with 'GCC'.\n+        Remove all uses of PARAMS macro.\n+\t* config/iq2000.h: Remove all uses of PARAMS macro.\n+        * config/iq2000/iq2000.md: Replace 'GNU CC' with 'GCC'.\n+\n 2003-08-23  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390-protos.h (s390_output_pool_entry): Declare."}, {"sha": "8901fd300b1fceead726883dda6052ceed06d758", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,64 +1,64 @@\n /* Definitions of target machine for GNU compiler for iq2000.\n    Copyright (C) 2003 Free Software Foundation, Inc.\n \n-   This file is part of GNU CC.\n+   This file is part of GCC.\n \n-   GNU CC is free software; you can redistribute it and/or modify\n+   GCC is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2, or (at your option)\n    any later version.\n \n-   GNU CC is distributed in the hope that it will be useful,\n+   GCC is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n \n    You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to\n+   along with GCC; see the file COPYING.  If not, write to\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA. */\n \n #ifndef GCC_IQ2000_PROTOS_H\n #define GCC_IQ2000_PROTOS_H\n \n-extern int iq2000_check_split PARAMS ((rtx, enum machine_mode));\n-extern int iq2000_reg_mode_ok_for_base_p PARAMS ((rtx, enum machine_mode, int));\n-extern int iq2000_legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n-extern const char* iq2000_fill_delay_slot PARAMS ((const char*, enum delay_type, rtx*, rtx));\n-extern const char *iq2000_move_1word PARAMS ((rtx *, rtx, int));\n-extern int iq2000_address_cost PARAMS ((rtx));\n-extern void override_options PARAMS ((void));\n-extern HOST_WIDE_INT iq2000_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n-extern void final_prescan_insn PARAMS ((rtx, rtx*, int));\n-extern HOST_WIDE_INT compute_frame_size PARAMS ((HOST_WIDE_INT));\n+extern int iq2000_check_split (rtx, enum machine_mode);\n+extern int iq2000_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n+extern int iq2000_legitimate_address_p (enum machine_mode, rtx, int);\n+extern const char* iq2000_fill_delay_slot (const char*, enum delay_type, rtx*, rtx);\n+extern const char *iq2000_move_1word (rtx *, rtx, int);\n+extern int iq2000_address_cost (rtx);\n+extern void override_options (void);\n+extern HOST_WIDE_INT iq2000_debugger_offset (rtx, HOST_WIDE_INT);\n+extern void final_prescan_insn (rtx, rtx*, int);\n+extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT);\n extern int iq2000_initial_elimination_offset (int, int);\n-extern void iq2000_expand_prologue PARAMS ((void));\n-extern void iq2000_expand_epilogue PARAMS ((void));\n-extern void iq2000_expand_eh_return PARAMS ((rtx));\n-extern int iq2000_can_use_return_insn PARAMS ((void));\n-int function_arg_pass_by_reference PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n-int iq2000_adjust_insn_length PARAMS ((rtx, int));\n-char *iq2000_output_conditional_branch PARAMS ((rtx, rtx*, int, int, int, int));\n-extern void iq2000_init_builtins PARAMS ((void));\n-extern void iq2000_setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS, int, tree, int*, int));\n-extern void print_operand_address PARAMS ((FILE*, rtx));\n-extern void print_operand PARAMS ((FILE*, rtx, int));\n+extern void iq2000_expand_prologue (void);\n+extern void iq2000_expand_epilogue (void);\n+extern void iq2000_expand_eh_return (rtx);\n+extern int iq2000_can_use_return_insn (void);\n+int function_arg_pass_by_reference (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n+int iq2000_adjust_insn_length (rtx, int);\n+char *iq2000_output_conditional_branch (rtx, rtx*, int, int, int, int);\n+extern void iq2000_init_builtins (void);\n+extern void iq2000_setup_incoming_varargs (CUMULATIVE_ARGS, int, tree, int*, int);\n+extern void print_operand_address (FILE*, rtx);\n+extern void print_operand (FILE*, rtx, int);\n \n #ifdef RTX_CODE\n-extern rtx gen_int_relational PARAMS ((enum rtx_code, rtx, rtx, rtx, int*));\n-extern void gen_conditional_branch PARAMS ((rtx *, enum rtx_code));\n+extern rtx gen_int_relational (enum rtx_code, rtx, rtx, rtx, int*);\n+extern void gen_conditional_branch (rtx *, enum rtx_code);\n #endif\n \n #ifdef TREE_CODE\n-extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS*, tree, rtx));\n-extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n-extern struct rtx_def* function_arg PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n-extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS*, enum machine_mode, tree, int));\n-extern void iq2000_va_start PARAMS ((tree, rtx));\n-extern rtx iq2000_va_arg PARAMS ((tree, tree));\n-extern rtx iq2000_function_value PARAMS ((tree, tree));\n-extern rtx iq2000_expand_builtin PARAMS ((tree, rtx, rtx,\n-\t\t\t\t\t  enum machine_mode, int));\n+extern void init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);\n+extern void function_arg_advance (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n+extern struct rtx_def* function_arg (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n+extern int function_arg_partial_nregs (CUMULATIVE_ARGS*, enum machine_mode, tree, int);\n+extern void iq2000_va_start (tree, rtx);\n+extern rtx iq2000_va_arg (tree, tree);\n+extern rtx iq2000_function_value (tree, tree);\n+extern rtx iq2000_expand_builtin (tree, rtx, rtx,\n+\t\t\t\t  enum machine_mode, int);\n #endif\n \n #endif /* ! GCC_IQ2000_PROTOS_H */"}, {"sha": "08c074f8928f5e685236f87ddb6d984e089f0a4f", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 103, "deletions": 211, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Subroutines used for code generation on Vitesse IQ2000 processors\n    Copyright (C) 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n@@ -66,23 +66,23 @@ enum internal_test {\n \n struct constant;\n \n-static void iq2000_count_memory_refs PARAMS ((rtx, int));\n-static enum internal_test map_test_to_internal_test PARAMS ((enum rtx_code));\n-static rtx iq2000_add_large_offset_to_sp PARAMS ((HOST_WIDE_INT));\n-static void iq2000_annotate_frame_insn PARAMS ((rtx, rtx));\n-static void iq2000_emit_frame_related_store PARAMS ((rtx, rtx,\n-\t\t\t\t\t\t     HOST_WIDE_INT));\n-static struct machine_function * iq2000_init_machine_status PARAMS ((void));\n-static void save_restore_insns PARAMS ((int));\n-static void abort_with_insn PARAMS ((rtx, const char *))\n+static void iq2000_count_memory_refs (rtx, int);\n+static enum internal_test map_test_to_internal_test (enum rtx_code);\n+static rtx iq2000_add_large_offset_to_sp (HOST_WIDE_INT);\n+static void iq2000_annotate_frame_insn (rtx, rtx);\n+static void iq2000_emit_frame_related_store (rtx, rtx,\n+\t\t\t\t\t     HOST_WIDE_INT);\n+static struct machine_function * iq2000_init_machine_status (void);\n+static void save_restore_insns (int);\n+static void abort_with_insn (rtx, const char *)\n      ATTRIBUTE_NORETURN;\n-static int symbolic_expression_p PARAMS ((rtx));\n-static enum processor_type iq2000_parse_cpu PARAMS ((const char *));\n-static void iq2000_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t       unsigned HOST_WIDE_INT));\n-static void iq2000_select_section PARAMS ((tree, int, unsigned HOST_WIDE_INT));\n-static rtx expand_one_builtin PARAMS ((enum insn_code, rtx, tree, enum rtx_code*,\n-\t\t\t\t       int));\n+static int symbolic_expression_p (rtx);\n+static enum processor_type iq2000_parse_cpu (const char *);\n+static void iq2000_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t       unsigned HOST_WIDE_INT);\n+static void iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n+static rtx expand_one_builtin (enum insn_code, rtx, tree, enum rtx_code*,\n+\t\t\t       int);\n \f\n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -181,9 +181,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n    integer is needed.  */\n \n int\n-uns_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+uns_arith_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n     return 1;\n@@ -194,9 +192,7 @@ uns_arith_operand (op, mode)\n /* Return 1 if OP can be used as an operand where a 16 bit integer is needed. */\n \n int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n     return 1;\n@@ -207,9 +203,7 @@ arith_operand (op, mode)\n /* Return 1 if OP is a integer which fits in 16 bits  */\n \n int\n-small_int (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n }\n@@ -218,9 +212,7 @@ small_int (op, mode)\n    instruction.  */\n \n int\n-large_int (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+large_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT value;\n \n@@ -247,9 +239,7 @@ large_int (op, mode)\n /* Return 1 if OP is a register or the constant 0.  */\n \n int\n-reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -274,9 +264,7 @@ reg_or_0_operand (op, mode)\n    (ie, register + small offset).  */\n \n int\n-simple_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx addr, plus0, plus1;\n \n@@ -328,9 +316,7 @@ simple_memory_operand (op, mode)\n /* Return nonzero if the code of this rtx pattern is EQ or NE.  */\n \n int\n-equality_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+equality_op (rtx op, enum machine_mode mode)\n {\n   if (mode != GET_MODE (op))\n     return 0;\n@@ -341,9 +327,7 @@ equality_op (op, mode)\n /* Return nonzero if the code is a relational operations (EQ, LE, etc.) */\n \n int\n-cmp_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cmp_op (rtx op, enum machine_mode mode)\n {\n   if (mode != GET_MODE (op))\n     return 0;\n@@ -354,9 +338,7 @@ cmp_op (op, mode)\n /* Return nonzero if the operand is either the PC or a label_ref.  */\n \n int\n-pc_or_label_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (op == pc_rtx)\n     return 1;\n@@ -370,9 +352,7 @@ pc_or_label_operand (op, mode)\n /* Return nonzero if OP is a valid operand for a call instruction.  */\n \n int\n-call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (CONSTANT_ADDRESS_P (op)\n \t  || (GET_CODE (op) == REG && op != arg_pointer_rtx\n@@ -383,9 +363,7 @@ call_insn_operand (op, mode)\n /* Return nonzero if OP is valid as a source operand for a move instruction.  */\n \n int\n-move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_operand (rtx op, enum machine_mode mode)\n {\n   /* Accept any general operand after reload has started; doing so\n      avoids losing if reload does an in-place replacement of a register\n@@ -398,9 +376,7 @@ move_operand (op, mode)\n /* Return nonzero if OP is a constant power of 2.  */\n \n int\n-power_of_2_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+power_of_2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int intval;\n \n@@ -415,9 +391,7 @@ power_of_2_operand (op, mode)\n /* Return nonzero if we split the address into high and low parts.  */\n \n int\n-iq2000_check_split (address, mode)\n-     rtx address;\n-     enum machine_mode mode;\n+iq2000_check_split (rtx address, enum machine_mode mode)\n {\n   /* This is the same check used in simple_memory_operand.\n      We use it here because LO_SUM is not offsettable.  */\n@@ -436,10 +410,9 @@ iq2000_check_split (address, mode)\n /* Return nonzero if REG is valid for MODE.  */\n \n int\n-iq2000_reg_mode_ok_for_base_p (reg, mode, strict)\n-     rtx reg;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int strict;\n+iq2000_reg_mode_ok_for_base_p (rtx reg,\n+\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t       int strict)\n {\n   return (strict\n \t  ? REGNO_MODE_OK_FOR_BASE_P (REGNO (reg), mode)\n@@ -451,10 +424,7 @@ iq2000_reg_mode_ok_for_base_p (reg, mode, strict)\n    function is called during reload.  */\n \n int\n-iq2000_legitimate_address_p (mode, xinsn, strict)\n-     enum machine_mode mode;\n-     rtx xinsn;\n-     int strict;\n+iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n {\n   if (TARGET_DEBUG_A_MODE)\n     {\n@@ -531,11 +501,8 @@ iq2000_legitimate_address_p (mode, xinsn, strict)\n    it needs.  */\n \n const char *\n-iq2000_fill_delay_slot (ret, type, operands, cur_insn)\n-     const char *ret;\t\t/* normal string to return */\n-     enum delay_type type;\t/* type of delay */\n-     rtx operands[];\t\t/* operands to use */\n-     rtx cur_insn;\t\t/* current insn */\n+iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n+\t\t\trtx cur_insn)\n {\n   register rtx set_reg;\n   register enum machine_mode mode;\n@@ -596,9 +563,7 @@ iq2000_fill_delay_slot (ret, type, operands, cur_insn)\n    appropriate counter for -mstats.  */\n \n static void\n-iq2000_count_memory_refs (op, num)\n-     rtx op;\n-     int num;\n+iq2000_count_memory_refs (rtx op, int num)\n {\n   int additional = 0;\n   int n_words = 0;\n@@ -710,10 +675,7 @@ iq2000_count_memory_refs (op, num)\n /* Return the appropriate instructions to move one operand to another.  */\n \n const char *\n-iq2000_move_1word (operands, insn, unsignedp)\n-     rtx operands[];\n-     rtx insn;\n-     int unsignedp;\n+iq2000_move_1word (rtx operands[], rtx insn, int unsignedp)\n {\n   const char *ret = 0;\n   rtx op0 = operands[0];\n@@ -943,8 +905,7 @@ iq2000_move_1word (operands, insn, unsignedp)\n /* Provide the costs of an addressing mode that contains ADDR.  */\n \n int\n-iq2000_address_cost (addr)\n-     rtx addr;\n+iq2000_address_cost (rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -1011,8 +972,7 @@ iq2000_address_cost (addr)\n /* Make normal rtx_code into something we can index from an array.  */\n \n static enum internal_test\n-map_test_to_internal_test (test_code)\n-     enum rtx_code test_code;\n+map_test_to_internal_test (enum rtx_code test_code)\n {\n   enum internal_test test = ITEST_MAX;\n \n@@ -1037,16 +997,16 @@ map_test_to_internal_test (test_code)\n /* Generate the code to compare two integer values.  The return value is:\n    (reg:SI xx)\t\tThe pseudo register the comparison is in\n    0\t\t       \tNo register, generate a simple branch.\n-*/\n+\n+   TEST_CODE: relational test (EQ, etc).\n+   RESULT: result to store comp. or 0 if branch.\n+   CMP0: first operand to compare \n+   CMP1: second operand to compare \n+   *P_INVERT: NULL or ptr to hold whether branch needs to reverse its test.  */\n \n rtx\n-gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n-     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n-     rtx result;\t\t/* result to store comp. or 0 if branch */\n-     rtx cmp0;\t\t\t/* first operand to compare */\n-     rtx cmp1;\t\t\t/* second operand to compare */\n-     int *p_invert;\t\t/* NULL or ptr to hold whether branch needs */\n-\t\t\t\t/* to reverse its test */\n+gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n+\t\t    int *p_invert)\n {\n   struct cmp_info\n   {\n@@ -1210,9 +1170,7 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n    The comparison operands are saved away by cmp{si,di,sf,df}.  */\n \n void\n-gen_conditional_branch (operands, test_code)\n-     rtx operands[];\n-     enum rtx_code test_code;\n+gen_conditional_branch (rtx operands[], enum rtx_code test_code)\n {\n   enum cmp_type type = branch_type;\n   rtx cmp0 = branch_cmp[0];\n@@ -1284,10 +1242,8 @@ gen_conditional_branch (operands, test_code)\n /* Initialize CUMULATIVE_ARGS for a function.  */\n \n void\n-init_cumulative_args (cum, fntype, libname)\n-     CUMULATIVE_ARGS *cum;\t\t/* argument info to initialize */\n-     tree fntype;\t\t\t/* tree ptr for function decl */\n-     rtx libname ATTRIBUTE_UNUSED;\t/* SYMBOL_REF of library name or 0 */\n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n+\t\t      rtx libname ATTRIBUTE_UNUSED)\n {\n   static CUMULATIVE_ARGS zero_cum;\n   tree param, next_param;\n@@ -1328,11 +1284,8 @@ init_cumulative_args (cum, fntype, libname)\n /* Advance the argument to the next argument position.  */\n \n void\n-function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* whether or not the argument was named */\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t\t      int named)\n {\n   if (TARGET_DEBUG_D_MODE)\n     {\n@@ -1396,11 +1349,8 @@ function_arg_advance (cum, mode, type, named)\n    or 0 if the argument is to be passed on the stack.  */\n \n struct rtx_def *\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t      int named)\n {\n   rtx ret;\n   int regbase = -1;\n@@ -1560,11 +1510,9 @@ function_arg (cum, mode, type, named)\n }\n \n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type ATTRIBUTE_UNUSED;/* type of the argument or 0 if lib support */\n-     int named ATTRIBUTE_UNUSED;/* != 0 for normal args, == 0 for ... args */\n+function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t    tree type ATTRIBUTE_UNUSED,\n+\t\t\t    int named ATTRIBUTE_UNUSED)\n {\n   if (mode == DImode\n \t   && cum->arg_words == MAX_ARGS_IN_REGISTERS - (unsigned)1)\n@@ -1581,9 +1529,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n /* Implement va_start.  */\n \n void\n-iq2000_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+iq2000_va_start (tree valist, rtx nextarg)\n {\n   int int_arg_words;\n \n@@ -1607,8 +1553,7 @@ iq2000_va_start (valist, nextarg)\n /* Implement va_arg.  */\n \n rtx\n-iq2000_va_arg (valist, type)\n-     tree valist, type;\n+iq2000_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size, rsize;\n   rtx addr_rtx;\n@@ -1809,9 +1754,7 @@ iq2000_va_arg (valist, type)\n /* Abort after printing out a specific insn.  */\n \n static void\n-abort_with_insn (insn, reason)\n-     rtx insn;\n-     const char *reason;\n+abort_with_insn (rtx insn, const char *reason)\n {\n   error (reason);\n   debug_rtx (insn);\n@@ -1821,7 +1764,7 @@ abort_with_insn (insn, reason)\n /* Detect any conflicts in the switches.  */\n \n void\n-override_options ()\n+override_options (void)\n {\n   register enum processor_type iq2000_cpu;\n \n@@ -1901,7 +1844,7 @@ override_options ()\n /* Allocate a chunk of memory for per-function machine-dependent data.  */\n \n static struct machine_function *\n-iq2000_init_machine_status ()\n+iq2000_init_machine_status (void)\n {\n   return ((struct machine_function *)\n \t  ggc_alloc_cleared (sizeof (struct machine_function)));\n@@ -1912,9 +1855,7 @@ iq2000_init_machine_status ()\n    pointer after the initial adjustments.  */\n \n HOST_WIDE_INT\n-iq2000_debugger_offset (addr, offset)\n-     rtx addr;\n-     HOST_WIDE_INT offset;\n+iq2000_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n {\n   rtx offset2 = const0_rtx;\n   rtx reg = eliminate_constant_term (addr, &offset2);\n@@ -1949,10 +1890,8 @@ iq2000_debugger_offset (addr, offset)\n    of load delays, and also to update the delay slot statistics.  */\n \n void\n-final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx opvec[] ATTRIBUTE_UNUSED;\n-     int noperands ATTRIBUTE_UNUSED;\n+final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n+\t\t    int noperands ATTRIBUTE_UNUSED)\n {\n   if (dslots_number_nops > 0)\n     {\n@@ -2048,8 +1987,7 @@ final_prescan_insn (insn, opvec, noperands)\n */\n \n HOST_WIDE_INT\n-compute_frame_size (size)\n-     HOST_WIDE_INT size;\t/* # of var. bytes allocated */\n+compute_frame_size (HOST_WIDE_INT size)\n {\n   int regno;\n   HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up */\n@@ -2154,9 +2092,7 @@ compute_frame_size (size)\n    the stack pointer or hard frame pointer.  */\n \n int\n-iq2000_initial_elimination_offset (from, to)\n-     int from;\n-     int to ATTRIBUTE_UNUSED;\n+iq2000_initial_elimination_offset (int from, int to ATTRIBUTE_UNUSED)\n {\n   int offset;\n \n@@ -2193,8 +2129,7 @@ iq2000_initial_elimination_offset (from, to)\n    OFFSET is too large to add in a single instruction.  */\n \n static rtx\n-iq2000_add_large_offset_to_sp (offset)\n-     HOST_WIDE_INT offset;\n+iq2000_add_large_offset_to_sp (HOST_WIDE_INT offset)\n {\n   rtx reg = gen_rtx_REG (Pmode, IQ2000_TEMP2_REGNUM);\n   rtx offset_rtx = GEN_INT (offset);\n@@ -2208,8 +2143,7 @@ iq2000_add_large_offset_to_sp (offset)\n    operation DWARF_PATTERN.  */\n \n static void\n-iq2000_annotate_frame_insn (insn, dwarf_pattern)\n-     rtx insn, dwarf_pattern;\n+iq2000_annotate_frame_insn (rtx insn, rtx dwarf_pattern)\n {\n   RTX_FRAME_RELATED_P (insn) = 1;\n   REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n@@ -2221,10 +2155,7 @@ iq2000_annotate_frame_insn (insn, dwarf_pattern)\n    frame related and note that it stores REG at (SP + OFFSET).  */\n \n static void\n-iq2000_emit_frame_related_store (mem, reg, offset)\n-     rtx mem;\n-     rtx reg;\n-     HOST_WIDE_INT offset;\n+iq2000_emit_frame_related_store (rtx mem, rtx reg, HOST_WIDE_INT offset)\n {\n   rtx dwarf_address = plus_constant (stack_pointer_rtx, offset);\n   rtx dwarf_mem = gen_rtx_MEM (GET_MODE (reg), dwarf_address);\n@@ -2234,8 +2165,7 @@ iq2000_emit_frame_related_store (mem, reg, offset)\n }\n \n static void\n-save_restore_insns (store_p)\n-     int store_p;\t/* true if this is prologue */\n+save_restore_insns (int store_p)\n {\n   long mask = cfun->machine->frame.mask;\n   int regno;\n@@ -2317,7 +2247,7 @@ save_restore_insns (store_p)\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n-iq2000_expand_prologue ()\n+iq2000_expand_prologue (void)\n {\n   int regno;\n   HOST_WIDE_INT tsize;\n@@ -2506,7 +2436,7 @@ iq2000_expand_prologue ()\n /* Expand the epilogue into a bunch of separate insns.  */\n \n void\n-iq2000_expand_epilogue ()\n+iq2000_expand_epilogue (void)\n {\n   HOST_WIDE_INT tsize = cfun->machine->frame.total_size;\n   rtx tsize_rtx = GEN_INT (tsize);\n@@ -2567,8 +2497,7 @@ iq2000_expand_epilogue ()\n }\n \n void\n-iq2000_expand_eh_return (address)\n-     rtx address;\n+iq2000_expand_eh_return (rtx address)\n {\n   HOST_WIDE_INT gp_offset = cfun->machine->frame.gp_sp_offset;\n   rtx scratch;\n@@ -2582,7 +2511,7 @@ iq2000_expand_eh_return (address)\n    was created.  */\n \n int\n-iq2000_can_use_return_insn ()\n+iq2000_can_use_return_insn (void)\n {\n   if (! reload_completed)\n     return 0;\n@@ -2599,8 +2528,7 @@ iq2000_can_use_return_insn ()\n /* Returns non-zero if X contains a SYMBOL_REF.  */\n \n static int\n-symbolic_expression_p (x)\n-     rtx x;\n+symbolic_expression_p (rtx x)\n {\n   if (GET_CODE (x) == SYMBOL_REF)\n     return 1;\n@@ -2623,10 +2551,8 @@ symbolic_expression_p (x)\n    mode MODE.  */\n \n static void\n-iq2000_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align;\n+iq2000_select_rtx_section (enum machine_mode mode, rtx x ATTRIBUTE_UNUSED,\n+\t\t\t   unsigned HOST_WIDE_INT align)\n {\n   /* For embedded applications, always put constants in read-only data,\n      in order to reduce RAM usage.  */\n@@ -2643,10 +2569,8 @@ iq2000_select_rtx_section (mode, x, align)\n    are done correctly.  */\n \n static void\n-iq2000_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+iq2000_select_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n+\t\t       unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (TARGET_EMBEDDED_DATA)\n     {\n@@ -2689,9 +2613,7 @@ iq2000_select_section (decl, reloc, align)\n    FUNC.  */\n \n rtx\n-iq2000_function_value (valtype, func)\n-     tree valtype;\n-     tree func ATTRIBUTE_UNUSED;\n+iq2000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n {\n   int reg = GP_RETURN;\n   enum machine_mode mode = TYPE_MODE (valtype);\n@@ -2708,11 +2630,9 @@ iq2000_function_value (valtype, func)\n    nonzero when an argument must be passed by reference.  */\n \n int\n-function_arg_pass_by_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t\tenum machine_mode mode, tree type,\n+\t\t\t\tint named ATTRIBUTE_UNUSED)\n {\n   int size;\n \n@@ -2742,9 +2662,7 @@ function_arg_pass_by_reference (cum, mode, type, named)\n    attributes in the machine-description file.  */\n \n int\n-iq2000_adjust_insn_length (insn, length)\n-     rtx insn;\n-     int length;\n+iq2000_adjust_insn_length (rtx insn, int length)\n {\n   /* A unconditional jump has an unfilled delay slot if it is not part\n      of a sequence.  A conditional jump normally has a delay slot */\n@@ -2772,18 +2690,8 @@ iq2000_adjust_insn_length (insn, length)\n    reversed conditional branch around a `jr' instruction.  */\n \n char *\n-iq2000_output_conditional_branch (insn,\n-\t\t\t\toperands,\n-\t\t\t\ttwo_operands_p,\n-\t\t\t\tfloat_p,\n-\t\t\t\tinverted_p,\n-\t\t\t\tlength)\n-     rtx insn;\n-     rtx *operands;\n-     int two_operands_p;\n-     int float_p;\n-     int inverted_p;\n-     int length;\n+iq2000_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n+\t\t\t\t  int float_p, int inverted_p, int length)\n {\n   static char buffer[200];\n   /* The kind of comparison we are doing.  */\n@@ -2936,8 +2844,7 @@ iq2000_output_conditional_branch (insn,\n }\n \n static enum processor_type\n-iq2000_parse_cpu (cpu_string)\n-     const char *cpu_string;\n+iq2000_parse_cpu (const char *cpu_string)\n {\n   const char *p = cpu_string;\n   enum processor_type cpu;\n@@ -2962,7 +2869,7 @@ iq2000_parse_cpu (cpu_string)\n   builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL, NULL_TREE)\n \n void\n-iq2000_init_builtins ()\n+iq2000_init_builtins (void)\n {\n   tree endlink = void_list_node;\n   tree void_ftype, void_ftype_int, void_ftype_int_int;\n@@ -3095,12 +3002,8 @@ void_ftype_int_int_int\n    has an rtx CODE */\n \n static rtx\n-expand_one_builtin (icode, target, arglist, code, argcount)\n-  enum insn_code icode;\n-  rtx target;\n-  tree arglist;\n-  enum rtx_code *code;\n-  int argcount;\n+expand_one_builtin (enum insn_code icode, rtx target, tree arglist,\n+\t\t    enum rtx_code *code, int argcount)\n {\n   rtx pat;\n   tree arg [5];\n@@ -3177,12 +3080,9 @@ expand_one_builtin (icode, target, arglist, code, argcount)\n    IGNORE is nonzero if the value is to be ignored.  */\n \n rtx\n-iq2000_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+iq2000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -3362,12 +3262,9 @@ iq2000_expand_builtin (exp, target, subtarget, mode, ignore)\n }\n \f\n void\n-iq2000_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl) \n-     CUMULATIVE_ARGS cum;\n-     int             mode ATTRIBUTE_UNUSED;\n-     tree            type ATTRIBUTE_UNUSED;\n-     int *           pretend_size;\n-     int             no_rtl;\n+iq2000_setup_incoming_varargs (CUMULATIVE_ARGS cum, int mode ATTRIBUTE_UNUSED,\n+\t\t\t       tree type ATTRIBUTE_UNUSED, int *pretend_size,\n+\t\t\t       int no_rtl) \n {\n   unsigned int iq2000_off = (! (cum).last_arg_fp); \n   unsigned int iq2000_fp_off = ((cum).last_arg_fp); \n@@ -3410,9 +3307,7 @@ iq2000_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   if (!addr)\n     error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n@@ -3541,10 +3436,7 @@ print_operand_address (file, addr)\n    '+'\tPrint the name of the gp register (gp or $28).  */\n \n void\n-print_operand (file, op, letter)\n-     FILE *file;\t\t/* file to write to */\n-     rtx op;\t\t\t/* operand to print */\n-     int letter;\t\t/* %<letter> or 0 */\n+print_operand (FILE *file, rtx op, int letter)\n {\n   register enum rtx_code code;\n "}, {"sha": "0d9c91404f23c5628b557351dce87128783c1e07", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1153,9 +1153,9 @@ extern struct rtx_def *iq2000_load_reg3;\t/* 3rd reg to check for load delay */\n extern struct rtx_def *iq2000_load_reg4;\t/* 4th reg to check for load delay */\n \n /* Functions to change what output section we are using.  */\n-extern void\t\trdata_section PARAMS ((void));\n-extern void\t\tsdata_section PARAMS ((void));\n-extern void\t\tsbss_section PARAMS ((void));\n+extern void\t\trdata_section (void);\n+extern void\t\tsdata_section (void);\n+extern void\t\tsbss_section (void);\n \n #define BITMASK_UPPER16\t((unsigned long)0xffff << 16)\t/* 0xffff0000 */\n #define BITMASK_LOWER16\t((unsigned long)0xffff)\t\t/* 0x0000ffff */"}, {"sha": "4f6b23b328e555e32af923d39839409e474fcd7f", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n ;;  iq2000.md\t     Machine Description for Vitesse IQ2000 processors\n ;;  Copyright (C) 2003 Free Software Foundation, Inc.\n \n-;; This file is part of GNU CC.\n+;; This file is part of GCC.\n \n-;; GNU CC is free software; you can redistribute it and/or modify\n+;; GCC is free software; you can redistribute it and/or modify\n ;; it under the terms of the GNU General Public License as published by\n ;; the Free Software Foundation; either version 2, or (at your option)\n ;; any later version.\n \n-;; GNU CC is distributed in the hope that it will be useful,\n+;; GCC is distributed in the hope that it will be useful,\n ;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n ;; GNU General Public License for more details.\n \n ;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n+;; along with GCC; see the file COPYING.  If not, write to\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n "}, {"sha": "0752e7b5b29d0a04dd44e7944261250333fe2380", "filename": "gcc/config/pa/elf.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Felf.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions for ELF assembler support.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "fe48edf765b85090e2ff9f1485968e24b1a835aa", "filename": "gcc/config/pa/fptr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Ffptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Ffptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ffptr.c?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,21 +1,21 @@\n /* Subroutine for function pointer canonicalization on PA-RISC with ELF32.\n-   Copyright 2002 Free Software Foundation, Inc.\n+   Copyright 2002, 2003 Free Software Foundation, Inc.\n    Contributed by John David Anglin (dave.anglin@nrc.ca).\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "8f5278baedba6e9e0d8b87ef8e36e41d07f6a9dc", "filename": "gcc/config/pa/lib2funcs.asm", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Flib2funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Flib2funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flib2funcs.asm?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -2,14 +2,14 @@\n ;  Subroutines for out of line prologues and epilogues on for the HPPA\n ;  Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n \n-;  This file is part of GNU CC.\n+;  This file is part of GCC.\n \n-;  GNU CC is free software; you can redistribute it and/or modify\n+;  GCC is free software; you can redistribute it and/or modify\n ;  it under the terms of the GNU General Public License as published by\n ;  the Free Software Foundation; either version 2, or (at your option)\n ;  any later version.\n \n-;  GNU CC is distributed in the hope that it will be useful,\n+;  GCC is distributed in the hope that it will be useful,\n ;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n ;  GNU General Public License for more details.\n@@ -24,7 +24,7 @@\n ;  executable.)\n \n ;  You should have received a copy of the GNU General Public License\n-;  along with GNU CC; see the file COPYING.  If not, write to\n+;  along with GCC; see the file COPYING.  If not, write to\n ;  the Free Software Foundation, 59 Temple Place - Suite 330,\n ;  Boston, MA 02111-1307, USA.\n "}, {"sha": "11504cac54aa37039092bbb275bfa82b42ec1120", "filename": "gcc/config/pa/long_double.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Flong_double.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Flong_double.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flong_double.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions of long double support for GNU compiler.\n-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "60eb5d210f786d8369894d0a9da730a11d08db49", "filename": "gcc/config/pa/milli64.S", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fmilli64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fmilli64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fmilli64.S?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -2,12 +2,12 @@\n    adapted for gcc by Paul Bame <bame@debian.org>\n    and Alan Modra <alan@linuxcare.com.au>.\n \n-   Copyright 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.\n \n-   This file is part of GNU CC and is released under the terms of\n+   This file is part of GCC and is released under the terms of\n    of the GNU General Public License as published by the Free Software\n    Foundation; either version 2, or (at your option) any later version.\n-   See the file COPYING in the top-level GNU CC source directory for a copy\n+   See the file COPYING in the top-level GCC source directory for a copy\n    of the license.  */\n \n "}, {"sha": "a76a8aab8e17263bfee888059840e43b61f1b330", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,21 +1,21 @@\n /* Definitions of target machine for GNU compiler, for HPs using the\n    64bit runtime model.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "bea7331d67691a7a4f8670663ec070ee18e7a202", "filename": "gcc/config/pa/pa-hpux.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions of target machine for GNU compiler, for HP-UX.\n-   Copyright (C) 1991, 1995, 1996, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1995, 1996, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "b9d06d5f642a2f4b23d1b91a619719276a369f2e", "filename": "gcc/config/pa/pa-hpux10.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-hpux10.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-hpux10.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux10.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,22 +1,22 @@\n /* Definitions of target machine for GNU compiler, for HP PA-RISC\n-   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002\n+   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@defmacro.cs.utah.edu)\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "7a7b3be5a68605adc6622ebcc9c3670f59ea42d5", "filename": "gcc/config/pa/pa-hpux11.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-hpux11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-hpux11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux11.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions of target machine for GNU compiler, for HP PA-RISC\n    Copyright (C) 1998, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "027c946dba3621a7c1df2d8a8690df7d15b83ff3", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions for PA_RISC with ELF format\n-   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "c57c9bc4bc95d7a614dbd4a3633513aa49a09d93", "filename": "gcc/config/pa/pa-modes.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-modes.def?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,23 +1,23 @@\n /* Definitions of target machine for GNU compiler, for the HP Spectrum.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) of Cygnus Support\n    and Tim Moore (moore@defmacro.cs.utah.edu) of the Center for\n    Software Science at the University of Utah.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "a824da6128d5f346ed42aea6d79bf1301142a949", "filename": "gcc/config/pa/pa-osf.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-osf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-osf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-osf.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,21 +1,21 @@\n /* Definitions of target machine for GNU compiler, for HP PA-RISC 1.1\n-   Copyright (C) 1991, 1995, 1996, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1995, 1996, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@defmacro.cs.utah.edu)\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "5fc06e23e286ffc0dc0b90d972f5902a4cacd228", "filename": "gcc/config/pa/pa-pro-end.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-pro-end.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-pro-end.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-pro-end.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions of target machine for GNU compiler, for PRO.\n-   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "f5f15cb3fd32b10ed8037e32bc1d06fee46a3150", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 118, "deletions": 118, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,165 +1,165 @@\n /* Prototypes for pa.c functions used in the md file & elsewhere.\n    Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #ifdef RTX_CODE\n /* Prototype function used in various macros.  */\n-extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int symbolic_operand (rtx, enum machine_mode);\n \n /* Used in insn-*.c.  */\n-extern int following_call PARAMS ((rtx));\n-extern int function_label_operand PARAMS ((rtx, enum machine_mode));\n-extern int lhs_lshift_cint_operand PARAMS ((rtx, enum machine_mode));\n+extern int following_call (rtx);\n+extern int function_label_operand (rtx, enum machine_mode);\n+extern int lhs_lshift_cint_operand (rtx, enum machine_mode);\n \n #ifdef TREE_CODE\n-extern void hppa_va_start PARAMS ((tree, rtx));\n-extern rtx hppa_va_arg PARAMS ((tree, tree));\n+extern void hppa_va_start (tree, rtx);\n+extern rtx hppa_va_arg (tree, tree);\n #endif /* TREE_CODE */\n-extern rtx hppa_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern rtx hppa_legitimize_address (rtx, rtx, enum machine_mode);\n \n /* Define functions in pa.c and used in insn-output.c.  */\n \n-extern const char *output_and PARAMS ((rtx *));\n-extern const char *output_ior PARAMS ((rtx *));\n-extern const char *output_move_double PARAMS ((rtx *));\n-extern const char *output_fp_move_double PARAMS ((rtx *));\n-extern const char *output_block_move PARAMS ((rtx *, int));\n-extern const char *output_cbranch PARAMS ((rtx *, int, int, int, rtx));\n-extern const char *output_lbranch PARAMS ((rtx, rtx));\n-extern const char *output_bb PARAMS ((rtx *, int, int, int, rtx, int));\n-extern const char *output_bvb PARAMS ((rtx *, int, int, int, rtx, int));\n-extern const char *output_dbra PARAMS ((rtx *, rtx, int));\n-extern const char *output_movb PARAMS ((rtx *, rtx, int, int));\n-extern const char *output_parallel_movb PARAMS ((rtx *, int));\n-extern const char *output_parallel_addb PARAMS ((rtx *, int));\n-extern const char *output_call PARAMS ((rtx, rtx, int));\n-extern const char *output_indirect_call PARAMS ((rtx, rtx));\n-extern const char *output_millicode_call PARAMS ((rtx, rtx));\n-extern const char *output_mul_insn PARAMS ((int, rtx));\n-extern const char *output_div_insn PARAMS ((rtx *, int, rtx));\n-extern const char *output_mod_insn PARAMS ((int, rtx));\n-extern const char *singlemove_string PARAMS ((rtx *));\n-extern void output_arg_descriptor PARAMS ((rtx));\n-extern void output_global_address PARAMS ((FILE *, rtx, int));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n-extern struct rtx_def *gen_cmp_fp PARAMS ((enum rtx_code, rtx, rtx));\n-extern void hppa_encode_label PARAMS ((rtx));\n-extern int arith11_operand PARAMS ((rtx, enum machine_mode));\n-extern int adddi3_operand PARAMS ((rtx, enum machine_mode));\n-extern int symbolic_expression_p PARAMS ((rtx));\n-extern int symbolic_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int pa_adjust_insn_length PARAMS ((rtx, int));\n-extern int int11_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_cint_move_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith5_operand PARAMS ((rtx, enum machine_mode));\n-extern int uint5_operand PARAMS ((rtx, enum machine_mode));\n-extern int pic_label_operand PARAMS ((rtx, enum machine_mode));\n-extern int plus_xor_ior_operator PARAMS ((rtx, enum machine_mode));\n-extern int basereg_operand PARAMS ((rtx, enum machine_mode));\n-extern int shadd_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_operand PARAMS ((rtx, enum machine_mode));\n-extern int read_only_operand PARAMS ((rtx, enum machine_mode));\n-extern int move_operand PARAMS ((rtx, enum machine_mode));\n-extern int and_operand PARAMS ((rtx, enum machine_mode));\n-extern int ior_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith32_operand PARAMS ((rtx, enum machine_mode));\n-extern int uint32_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_nonsymb_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_before_reload_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_0_or_nonsymb_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int pre_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int post_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int div_operand PARAMS ((rtx, enum machine_mode));\n-extern int int5_operand PARAMS ((rtx, enum machine_mode));\n-extern int movb_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int ireg_or_int5_operand PARAMS ((rtx, enum machine_mode));\n-extern int fmpyaddoperands PARAMS ((rtx *));\n-extern int fmpysuboperands PARAMS ((rtx *));\n-extern int call_operand_address PARAMS ((rtx, enum machine_mode));\n-extern int ior_operand PARAMS ((rtx, enum machine_mode));\n-extern void emit_bcond_fp PARAMS ((enum rtx_code, rtx));\n-extern int emit_move_sequence PARAMS ((rtx *, enum machine_mode, rtx));\n-extern int emit_hpdiv_const PARAMS ((rtx *, int));\n-extern int is_function_label_plus_const PARAMS ((rtx));\n-extern int jump_in_call_delay PARAMS ((rtx));\n-extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode, rtx));\n-extern int hppa_fpstore_bypass_p PARAMS ((rtx, rtx));\n-extern int attr_length_millicode_call PARAMS ((rtx));\n-extern int attr_length_call PARAMS ((rtx, int));\n-extern int attr_length_indirect_call PARAMS ((rtx));\n-extern int attr_length_save_restore_dltp PARAMS ((rtx));\n+extern const char *output_and (rtx *);\n+extern const char *output_ior (rtx *);\n+extern const char *output_move_double (rtx *);\n+extern const char *output_fp_move_double (rtx *);\n+extern const char *output_block_move (rtx *, int);\n+extern const char *output_cbranch (rtx *, int, int, int, rtx);\n+extern const char *output_lbranch (rtx, rtx);\n+extern const char *output_bb (rtx *, int, int, int, rtx, int);\n+extern const char *output_bvb (rtx *, int, int, int, rtx, int);\n+extern const char *output_dbra (rtx *, rtx, int);\n+extern const char *output_movb (rtx *, rtx, int, int);\n+extern const char *output_parallel_movb (rtx *, int);\n+extern const char *output_parallel_addb (rtx *, int);\n+extern const char *output_call (rtx, rtx, int);\n+extern const char *output_indirect_call (rtx, rtx);\n+extern const char *output_millicode_call (rtx, rtx);\n+extern const char *output_mul_insn (int, rtx);\n+extern const char *output_div_insn (rtx *, int, rtx);\n+extern const char *output_mod_insn (int, rtx);\n+extern const char *singlemove_string (rtx *);\n+extern void output_arg_descriptor (rtx);\n+extern void output_global_address (FILE *, rtx, int);\n+extern void print_operand (FILE *, rtx, int);\n+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern struct rtx_def *gen_cmp_fp (enum rtx_code, rtx, rtx);\n+extern void hppa_encode_label (rtx);\n+extern int arith11_operand (rtx, enum machine_mode);\n+extern int adddi3_operand (rtx, enum machine_mode);\n+extern int symbolic_expression_p (rtx);\n+extern int symbolic_memory_operand (rtx, enum machine_mode);\n+extern int pa_adjust_insn_length (rtx, int);\n+extern int int11_operand (rtx, enum machine_mode);\n+extern int reg_or_cint_move_operand (rtx, enum machine_mode);\n+extern int arith5_operand (rtx, enum machine_mode);\n+extern int uint5_operand (rtx, enum machine_mode);\n+extern int pic_label_operand (rtx, enum machine_mode);\n+extern int plus_xor_ior_operator (rtx, enum machine_mode);\n+extern int basereg_operand (rtx, enum machine_mode);\n+extern int shadd_operand (rtx, enum machine_mode);\n+extern int arith_operand (rtx, enum machine_mode);\n+extern int read_only_operand (rtx, enum machine_mode);\n+extern int move_operand (rtx, enum machine_mode);\n+extern int and_operand (rtx, enum machine_mode);\n+extern int ior_operand (rtx, enum machine_mode);\n+extern int arith32_operand (rtx, enum machine_mode);\n+extern int uint32_operand (rtx, enum machine_mode);\n+extern int reg_or_nonsymb_mem_operand (rtx, enum machine_mode);\n+extern int reg_before_reload_operand (rtx, enum machine_mode);\n+extern int reg_or_0_operand (rtx, enum machine_mode);\n+extern int reg_or_0_or_nonsymb_mem_operand (rtx, enum machine_mode);\n+extern int pre_cint_operand (rtx, enum machine_mode);\n+extern int post_cint_operand (rtx, enum machine_mode);\n+extern int div_operand (rtx, enum machine_mode);\n+extern int int5_operand (rtx, enum machine_mode);\n+extern int movb_comparison_operator (rtx, enum machine_mode);\n+extern int ireg_or_int5_operand (rtx, enum machine_mode);\n+extern int fmpyaddoperands (rtx *);\n+extern int fmpysuboperands (rtx *);\n+extern int call_operand_address (rtx, enum machine_mode);\n+extern int ior_operand (rtx, enum machine_mode);\n+extern void emit_bcond_fp (enum rtx_code, rtx);\n+extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n+extern int emit_hpdiv_const (rtx *, int);\n+extern int is_function_label_plus_const (rtx);\n+extern int jump_in_call_delay (rtx);\n+extern enum reg_class secondary_reload_class (enum reg_class,\n+\t\t\t\t\t      enum machine_mode, rtx);\n+extern int hppa_fpstore_bypass_p (rtx, rtx);\n+extern int attr_length_millicode_call (rtx);\n+extern int attr_length_call (rtx, int);\n+extern int attr_length_indirect_call (rtx);\n+extern int attr_length_save_restore_dltp (rtx);\n \n /* Declare functions defined in pa.c and used in templates.  */\n \n-extern struct rtx_def *return_addr_rtx PARAMS ((int, rtx));\n+extern struct rtx_def *return_addr_rtx (int, rtx);\n \n-extern int fp_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_double_operand PARAMS ((rtx, enum machine_mode));\n-extern int ireg_operand PARAMS ((rtx, enum machine_mode));\n-extern int lhs_lshift_operand PARAMS ((rtx, enum machine_mode));\n-extern int pc_or_label_operand PARAMS ((rtx, enum machine_mode));\n+extern int fp_reg_operand (rtx, enum machine_mode);\n+extern int arith_double_operand (rtx, enum machine_mode);\n+extern int ireg_operand (rtx, enum machine_mode);\n+extern int lhs_lshift_operand (rtx, enum machine_mode);\n+extern int pc_or_label_operand (rtx, enum machine_mode);\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n #ifdef TREE_CODE\n-extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n+extern enum direction function_arg_padding (enum machine_mode, tree);\n #endif\n #endif /* ARGS_SIZE_RTX */\n-extern int non_hard_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int eq_neq_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int insn_refs_are_delayed PARAMS ((rtx));\n+extern int non_hard_reg_operand (rtx, enum machine_mode);\n+extern int eq_neq_comparison_operator (rtx, enum machine_mode);\n+extern int insn_refs_are_delayed (rtx);\n #endif /* RTX_CODE */\n \n /* Prototype function used in macro CONST_OK_FOR_LETTER_P.  */\n-extern int zdepi_cint_p PARAMS ((unsigned HOST_WIDE_INT));\n-\n-extern struct rtx_def *hppa_builtin_saveregs PARAMS ((void));\n-\n-extern void override_options PARAMS ((void));\n-extern void output_ascii PARAMS ((FILE *, const char *, int));\n-extern int compute_frame_size PARAMS ((int, int *));\n-extern int and_mask_p PARAMS ((unsigned HOST_WIDE_INT));\n-extern int cint_ok_for_move PARAMS ((HOST_WIDE_INT));\n-extern void hppa_expand_prologue PARAMS ((void));\n-extern void hppa_expand_epilogue PARAMS ((void));\n-extern int hppa_can_use_return_insn_p PARAMS ((void));\n-extern int ior_mask_p PARAMS ((unsigned HOST_WIDE_INT));\n-extern void compute_zdepdi_operands PARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t     unsigned *));\n+extern int zdepi_cint_p (unsigned HOST_WIDE_INT);\n+\n+extern struct rtx_def *hppa_builtin_saveregs (void);\n+\n+extern void override_options (void);\n+extern void output_ascii (FILE *, const char *, int);\n+extern int compute_frame_size (int, int *);\n+extern int and_mask_p (unsigned HOST_WIDE_INT);\n+extern int cint_ok_for_move (HOST_WIDE_INT);\n+extern void hppa_expand_prologue (void);\n+extern void hppa_expand_epilogue (void);\n+extern int hppa_can_use_return_insn_p (void);\n+extern int ior_mask_p (unsigned HOST_WIDE_INT);\n+extern void compute_zdepdi_operands (unsigned HOST_WIDE_INT,\n+\t\t\t\t     unsigned *);\n #ifdef RTX_CODE\n-extern const char * output_64bit_and PARAMS ((rtx *));\n-extern const char * output_64bit_ior PARAMS ((rtx *));\n-extern int cmpib_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern const char * output_64bit_and (rtx *);\n+extern const char * output_64bit_ior (rtx *);\n+extern int cmpib_comparison_operator (rtx, enum machine_mode);\n #endif\n \n \n \n #ifdef TREE_CODE\n-extern int reloc_needed PARAMS ((tree));\n+extern int reloc_needed (tree);\n #ifdef RTX_CODE\n-extern rtx function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t tree, int));\n-extern rtx function_value PARAMS ((tree, tree));\n+extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t tree, int);\n+extern rtx function_value (tree, tree);\n #endif\n-extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t       tree, int));\n+extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n+\t\t\t\t       enum machine_mode,\n+\t\t\t\t       tree, int);\n #endif /* TREE_CODE */"}, {"sha": "9c207d6d591e28e7fad0064c91d0ae3fb7bba088", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 215, "deletions": 459, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -3,20 +3,20 @@\n    2002, 2003 Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n@@ -50,22 +50,21 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n-static int hppa_use_dfa_pipeline_interface PARAMS ((void));\n+static int hppa_use_dfa_pipeline_interface (void);\n \n #undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hppa_use_dfa_pipeline_interface\n \n static int\n-hppa_use_dfa_pipeline_interface ()\n+hppa_use_dfa_pipeline_interface (void)\n {\n   return 1;\n }\n \n /* Return nonzero if there is a bypass for the output of \n    OUT_INSN and the fp store IN_INSN.  */\n int\n-hppa_fpstore_bypass_p (out_insn, in_insn)\n-     rtx out_insn, in_insn;\n+hppa_fpstore_bypass_p (rtx out_insn, rtx in_insn)\n {\n   enum machine_mode store_mode;\n   enum machine_mode other_mode;\n@@ -96,56 +95,56 @@ hppa_fpstore_bypass_p (out_insn, in_insn)\n #endif\n #endif\n \n-static int hppa_address_cost PARAMS ((rtx));\n-static bool hppa_rtx_costs PARAMS ((rtx, int, int, int *));\n-static inline rtx force_mode PARAMS ((enum machine_mode, rtx));\n-static void pa_reorg PARAMS ((void));\n-static void pa_combine_instructions PARAMS ((void));\n-static int pa_can_combine_p PARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n-static int forward_branch_p PARAMS ((rtx));\n-static int shadd_constant_p PARAMS ((int));\n-static void compute_zdepwi_operands PARAMS ((unsigned HOST_WIDE_INT, unsigned *));\n-static int compute_movstrsi_length PARAMS ((rtx));\n-static bool pa_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void remove_useless_addtr_insns PARAMS ((int));\n-static void store_reg PARAMS ((int, int, int));\n-static void store_reg_modify PARAMS ((int, int, int));\n-static void load_reg PARAMS ((int, int, int));\n-static void set_reg_plus_d PARAMS ((int, int, int, int));\n-static void pa_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void update_total_code_bytes PARAMS ((int));\n-static void pa_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static int pa_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int pa_adjust_priority PARAMS ((rtx, int));\n-static int pa_issue_rate PARAMS ((void));\n-static void pa_select_section PARAMS ((tree, int, unsigned HOST_WIDE_INT))\n+static int hppa_address_cost (rtx);\n+static bool hppa_rtx_costs (rtx, int, int, int *);\n+static inline rtx force_mode (enum machine_mode, rtx);\n+static void pa_reorg (void);\n+static void pa_combine_instructions (void);\n+static int pa_can_combine_p (rtx, rtx, rtx, int, rtx, rtx, rtx);\n+static int forward_branch_p (rtx);\n+static int shadd_constant_p (int);\n+static void compute_zdepwi_operands (unsigned HOST_WIDE_INT, unsigned *);\n+static int compute_movstrsi_length (rtx);\n+static bool pa_assemble_integer (rtx, unsigned int, int);\n+static void remove_useless_addtr_insns (int);\n+static void store_reg (int, int, int);\n+static void store_reg_modify (int, int, int);\n+static void load_reg (int, int, int);\n+static void set_reg_plus_d (int, int, int, int);\n+static void pa_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void update_total_code_bytes (int);\n+static void pa_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static int pa_adjust_cost (rtx, rtx, rtx, int);\n+static int pa_adjust_priority (rtx, int);\n+static int pa_issue_rate (void);\n+static void pa_select_section (tree, int, unsigned HOST_WIDE_INT)\n      ATTRIBUTE_UNUSED;\n-static void pa_encode_section_info PARAMS ((tree, rtx, int));\n-static const char *pa_strip_name_encoding PARAMS ((const char *));\n-static bool pa_function_ok_for_sibcall PARAMS ((tree, tree));\n-static void pa_globalize_label PARAMS ((FILE *, const char *))\n+static void pa_encode_section_info (tree, rtx, int);\n+static const char *pa_strip_name_encoding (const char *);\n+static bool pa_function_ok_for_sibcall (tree, tree);\n+static void pa_globalize_label (FILE *, const char *)\n      ATTRIBUTE_UNUSED;\n-static void pa_asm_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t    HOST_WIDE_INT, tree));\n+static void pa_asm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t    HOST_WIDE_INT, tree);\n #if !defined(USE_COLLECT2)\n-static void pa_asm_out_constructor PARAMS ((rtx, int));\n-static void pa_asm_out_destructor PARAMS ((rtx, int));\n+static void pa_asm_out_constructor (rtx, int);\n+static void pa_asm_out_destructor (rtx, int);\n #endif\n-static void pa_init_builtins PARAMS ((void));\n-static void copy_fp_args PARAMS ((rtx)) ATTRIBUTE_UNUSED;\n-static int length_fp_args PARAMS ((rtx)) ATTRIBUTE_UNUSED;\n-static struct deferred_plabel *get_plabel PARAMS ((const char *))\n+static void pa_init_builtins (void);\n+static void copy_fp_args (rtx) ATTRIBUTE_UNUSED;\n+static int length_fp_args (rtx) ATTRIBUTE_UNUSED;\n+static struct deferred_plabel *get_plabel (const char *)\n      ATTRIBUTE_UNUSED;\n-static inline void pa_file_start_level PARAMS ((void)) ATTRIBUTE_UNUSED;\n-static inline void pa_file_start_space PARAMS ((int)) ATTRIBUTE_UNUSED;\n-static inline void pa_file_start_file PARAMS ((int)) ATTRIBUTE_UNUSED;\n-static inline void pa_file_start_mcount PARAMS ((const char*)) ATTRIBUTE_UNUSED;\n-static void pa_elf_file_start PARAMS ((void)) ATTRIBUTE_UNUSED;\n-static void pa_som_file_start PARAMS ((void)) ATTRIBUTE_UNUSED;\n-static void pa_linux_file_start PARAMS ((void)) ATTRIBUTE_UNUSED;\n-static void pa_hpux64_gas_file_start PARAMS ((void)) ATTRIBUTE_UNUSED;\n-static void pa_hpux64_hpas_file_start PARAMS ((void)) ATTRIBUTE_UNUSED;\n-static void output_deferred_plabels PARAMS ((void));\n+static inline void pa_file_start_level (void) ATTRIBUTE_UNUSED;\n+static inline void pa_file_start_space (int) ATTRIBUTE_UNUSED;\n+static inline void pa_file_start_file (int) ATTRIBUTE_UNUSED;\n+static inline void pa_file_start_mcount (const char*) ATTRIBUTE_UNUSED;\n+static void pa_elf_file_start (void) ATTRIBUTE_UNUSED;\n+static void pa_som_file_start (void) ATTRIBUTE_UNUSED;\n+static void pa_linux_file_start (void) ATTRIBUTE_UNUSED;\n+static void pa_hpux64_gas_file_start (void) ATTRIBUTE_UNUSED;\n+static void pa_hpux64_hpas_file_start (void) ATTRIBUTE_UNUSED;\n+static void output_deferred_plabels (void);\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -168,7 +167,7 @@ const char *pa_arch_string;\n    registers which were saved by the current function's prologue.  */\n static int gr_saved, fr_saved;\n \n-static rtx find_addr_reg PARAMS ((rtx));\n+static rtx find_addr_reg (rtx);\n \n /* Keep track of the number of bytes we have output in the CODE subspace\n    during this compilation so we'll know when to emit inline long-calls.  */\n@@ -257,7 +256,7 @@ static size_t n_deferred_plabels = 0;\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n-override_options ()\n+override_options (void)\n {\n   if (pa_cpu_string == NULL)\n     pa_cpu_string = TARGET_SCHED_DEFAULT;\n@@ -366,7 +365,7 @@ override_options ()\n }\n \n static void\n-pa_init_builtins ()\n+pa_init_builtins (void)\n {\n #ifdef DONT_HAVE_FPUTC_UNLOCKED\n   built_in_decls[(int) BUILT_IN_FPUTC_UNLOCKED] = NULL_TREE;\n@@ -377,9 +376,7 @@ pa_init_builtins ()\n /* Return nonzero only if OP is a register of mode MODE,\n    or CONST0_RTX.  */\n int\n-reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   return (op == CONST0_RTX (mode) || register_operand (op, mode));\n }\n@@ -390,9 +387,7 @@ reg_or_0_operand (op, mode)\n    For 2.5 try to eliminate either call_operand_address or\n    function_label_operand, they perform very similar functions.  */\n int\n-call_operand_address (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call_operand_address (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_MODE (op) == word_mode\n \t  && CONSTANT_P (op) && ! TARGET_PORTABLE_RUNTIME);\n@@ -402,8 +397,7 @@ call_operand_address (op, mode)\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */\n int\n-symbolic_expression_p (x)\n-     register rtx x;\n+symbolic_expression_p (rtx x)\n {\n \n   /* Strip off any HIGH.  */\n@@ -414,9 +408,7 @@ symbolic_expression_p (x)\n }\n \n int\n-symbolic_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -437,9 +429,7 @@ symbolic_operand (op, mode)\n    operand of mode MODE.  */\n \n int\n-symbolic_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -454,9 +444,7 @@ symbolic_memory_operand (op, mode)\n    not symbolic.  */\n \n int\n-reg_or_nonsymb_mem_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+reg_or_nonsymb_mem_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -471,9 +459,7 @@ reg_or_nonsymb_mem_operand (op, mode)\n    that is not symbolic.  */\n \n int\n-reg_or_0_or_nonsymb_mem_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+reg_or_0_or_nonsymb_mem_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -494,9 +480,7 @@ reg_or_0_or_nonsymb_mem_operand (op, mode)\n    if reload didn't find a hard register for the operand.  */\n \n int\n-reg_before_reload_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+reg_before_reload_operand (rtx op, enum machine_mode mode)\n {\n   /* Don't accept a SUBREG since it will need a reload.  */\n   if (GET_CODE (op) == SUBREG)\n@@ -516,8 +500,7 @@ reg_before_reload_operand (op, mode)\n /* Accept any constant that can be moved in one instruction into a\n    general register.  */\n int\n-cint_ok_for_move (intval)\n-     HOST_WIDE_INT intval;\n+cint_ok_for_move (HOST_WIDE_INT intval)\n {\n   /* OK if ldo, ldil, or zdepi, can be used.  */\n   return (CONST_OK_FOR_LETTER_P (intval, 'J')\n@@ -528,9 +511,7 @@ cint_ok_for_move (intval)\n /* Accept anything that can be moved in one instruction into a general\n    register.  */\n int\n-move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -581,9 +562,7 @@ move_operand (op, mode)\n /* Accept REG and any CONST_INT that can be moved in one instruction into a\n    general register.  */\n int\n-reg_or_cint_move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_cint_move_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     return 1;\n@@ -595,9 +574,7 @@ reg_or_cint_move_operand (op, mode)\n }\n \n int\n-pic_label_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pic_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (!flag_pic)\n     return 0;\n@@ -616,9 +593,7 @@ pic_label_operand (op, mode)\n }\n \n int\n-fp_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+fp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return reg_renumber && FP_REG_P (op);\n }\n@@ -629,9 +604,7 @@ fp_reg_operand (op, mode)\n    three operand arithmetic insn that accepts registers of mode MODE\n    or 14-bit signed integers.  */\n int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && INT_14_BITS (op)));\n@@ -641,9 +614,7 @@ arith_operand (op, mode)\n    three operand arithmetic insn that accepts registers of mode MODE\n    or 11-bit signed integers.  */\n int\n-arith11_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith11_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n@@ -652,9 +623,7 @@ arith11_operand (op, mode)\n /* Return truth value of whether OP can be used as an operand in a\n    adddi3 insn.  */\n int\n-adddi3_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+adddi3_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n@@ -664,9 +633,7 @@ adddi3_operand (op, mode)\n /* A constant integer suitable for use in a PRE_MODIFY memory\n    reference.  */\n int\n-pre_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pre_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10);\n@@ -675,18 +642,14 @@ pre_cint_operand (op, mode)\n /* A constant integer suitable for use in a POST_MODIFY memory\n    reference.  */\n int\n-post_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+post_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && INTVAL (op) < 0x2000 && INTVAL (op) >= -0x10);\n }\n \n int\n-arith_double_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_double_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_DOUBLE\n@@ -701,19 +664,15 @@ arith_double_operand (op, mode)\n    is an integer register.  */\n \n int\n-ireg_or_int5_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+ireg_or_int5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT && INT_5_BITS (op))\n \t  || (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32));\n }\n \n /* Return nonzero if OP is an integer register, else return zero.  */\n int\n-ireg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+ireg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32);\n }\n@@ -722,33 +681,25 @@ ireg_operand (op, mode)\n    range constraining immediate operands in three-address insns.  */\n \n int\n-int5_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+int5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && INT_5_BITS (op));\n }\n \n int\n-uint5_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+uint5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && INT_U5_BITS (op));\n }\n \n int\n-int11_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+int11_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n }\n \n int\n-uint32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+uint32_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n #if HOST_BITS_PER_WIDE_INT > 32\n   /* All allowed constants will fit a CONST_INT.  */\n@@ -762,9 +713,7 @@ uint32_operand (op, mode)\n }\n \n int\n-arith5_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith5_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode) || int5_operand (op, mode);\n }\n@@ -773,8 +722,7 @@ arith5_operand (op, mode)\n    zdepi first sign extends a 5 bit signed number to a given field\n    length, then places this field anywhere in a zero.  */\n int\n-zdepi_cint_p (x)\n-     unsigned HOST_WIDE_INT x;\n+zdepi_cint_p (unsigned HOST_WIDE_INT x)\n {\n   unsigned HOST_WIDE_INT lsb_mask, t;\n \n@@ -792,8 +740,7 @@ zdepi_cint_p (x)\n    1....10....0\n    1..10..01..1  */\n int\n-and_mask_p (mask)\n-     unsigned HOST_WIDE_INT mask;\n+and_mask_p (unsigned HOST_WIDE_INT mask)\n {\n   mask = ~mask;\n   mask += mask & -mask;\n@@ -802,36 +749,29 @@ and_mask_p (mask)\n \n /* True iff depi or extru can be used to compute (reg & OP).  */\n int\n-and_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+and_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && and_mask_p (INTVAL (op))));\n }\n \n /* True iff depi can be used to compute (reg | MASK).  */\n int\n-ior_mask_p (mask)\n-     unsigned HOST_WIDE_INT mask;\n+ior_mask_p (unsigned HOST_WIDE_INT mask)\n {\n   mask += mask & -mask;\n   return (mask & (mask - 1)) == 0;\n }\n \n /* True iff depi can be used to compute (reg | OP).  */\n int\n-ior_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+ior_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op)));\n }\n \n int\n-lhs_lshift_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+lhs_lshift_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode) || lhs_lshift_cint_operand (op, mode);\n }\n@@ -840,9 +780,7 @@ lhs_lshift_operand (op, mode)\n    Such values can be the left hand side x in (x << r), using the zvdepi\n    instruction.  */\n int\n-lhs_lshift_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+lhs_lshift_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   unsigned HOST_WIDE_INT x;\n   if (GET_CODE (op) != CONST_INT)\n@@ -852,17 +790,13 @@ lhs_lshift_cint_operand (op, mode)\n }\n \n int\n-arith32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith32_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode) || GET_CODE (op) == CONST_INT;\n }\n \n int\n-pc_or_label_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == PC || GET_CODE (op) == LABEL_REF);\n }\n@@ -873,9 +807,7 @@ pc_or_label_operand (op, mode)\n    than one register, we lose.  */\n \n rtx\n-legitimize_pic_address (orig, mode, reg)\n-     rtx orig, reg;\n-     enum machine_mode mode;\n+legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n {\n   rtx pic_ref = orig;\n \n@@ -997,9 +929,8 @@ legitimize_pic_address (orig, mode, reg)\n    a register.  */\n \n rtx\n-hppa_legitimize_address (x, oldx, mode)\n-     rtx x, oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode)\n {\n   rtx orig = x;\n \n@@ -1347,8 +1278,7 @@ hppa_legitimize_address (x, oldx, mode)\n    as GO_IF_LEGITIMATE_ADDRESS.  */\n \n static int\n-hppa_address_cost (X)\n-     rtx X;\n+hppa_address_cost (rtx X)\n {\n   switch (GET_CODE (X))\n     {\n@@ -1368,10 +1298,7 @@ hppa_address_cost (X)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-hppa_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+hppa_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -1447,9 +1374,7 @@ hppa_rtx_costs (x, code, outer_code, total)\n /* Ensure mode of ORIG, a REG rtx, is MODE.  Returns either ORIG or a\n    new rtx with the correct mode.  */\n static inline rtx\n-force_mode (mode, orig)\n-     enum machine_mode mode;\n-     rtx orig;\n+force_mode (enum machine_mode mode, rtx orig)\n {\n   if (mode == GET_MODE (orig))\n     return orig;\n@@ -1471,10 +1396,7 @@ force_mode (mode, orig)\n    of SCRATCH_REG in the proper mode.  */\n \n int\n-emit_move_sequence (operands, mode, scratch_reg)\n-     rtx *operands;\n-     enum machine_mode mode;\n-     rtx scratch_reg;\n+emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n@@ -1966,8 +1888,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n    it will need a link/runtime reloc).  */\n \n int\n-reloc_needed (exp)\n-     tree exp;\n+reloc_needed (tree exp)\n {\n   int reloc = 0;\n \n@@ -2011,9 +1932,7 @@ reloc_needed (exp)\n    will be true.  */\n \n int\n-read_only_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+read_only_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (operand) == CONST)\n     operand = XEXP (XEXP (operand, 0), 0);\n@@ -2034,8 +1953,7 @@ read_only_operand (operand, mode)\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.   */\n const char *\n-singlemove_string (operands)\n-     rtx *operands;\n+singlemove_string (rtx *operands)\n {\n   HOST_WIDE_INT intval;\n \n@@ -2080,9 +1998,7 @@ singlemove_string (operands)\n    useful for copying IMM to a register using the zdepi\n    instructions.  Store the immediate value to insert in OP[0].  */\n static void\n-compute_zdepwi_operands (imm, op)\n-     unsigned HOST_WIDE_INT imm;\n-     unsigned *op;\n+compute_zdepwi_operands (unsigned HOST_WIDE_INT imm, unsigned *op)\n {\n   int lsb, len;\n \n@@ -2119,9 +2035,7 @@ compute_zdepwi_operands (imm, op)\n    useful for copying IMM to a register using the depdi,z\n    instructions.  Store the immediate value to insert in OP[0].  */\n void\n-compute_zdepdi_operands (imm, op)\n-     unsigned HOST_WIDE_INT imm;\n-     unsigned *op;\n+compute_zdepdi_operands (unsigned HOST_WIDE_INT imm, unsigned *op)\n {\n   HOST_WIDE_INT lsb, len;\n \n@@ -2159,8 +2073,7 @@ compute_zdepdi_operands (imm, op)\n    with operands OPERANDS.  */\n \n const char *\n-output_move_double (operands)\n-     rtx *operands;\n+output_move_double (rtx *operands)\n {\n   enum { REGOP, OFFSOP, MEMOP, CNSTOP, RNDOP } optype0, optype1;\n   rtx latehalf[2];\n@@ -2435,8 +2348,7 @@ output_move_double (operands)\n }\n \f\n const char *\n-output_fp_move_double (operands)\n-     rtx *operands;\n+output_fp_move_double (rtx *operands)\n {\n   if (FP_REG_P (operands[0]))\n     {\n@@ -2474,8 +2386,7 @@ output_fp_move_double (operands)\n    ADDR can be effectively incremented by incrementing REG.  */\n \n static rtx\n-find_addr_reg (addr)\n-     rtx addr;\n+find_addr_reg (rtx addr)\n {\n   while (GET_CODE (addr) == PLUS)\n     {\n@@ -2506,9 +2417,7 @@ find_addr_reg (addr)\n    OPERANDS[6] is another temporary register.   */\n \n const char *\n-output_block_move (operands, size_is_constant)\n-     rtx *operands;\n-     int size_is_constant ATTRIBUTE_UNUSED;\n+output_block_move (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n {\n   int align = INTVAL (operands[5]);\n   unsigned long n_bytes = INTVAL (operands[4]);\n@@ -2607,8 +2516,7 @@ output_block_move (operands, size_is_constant)\n    count insns rather than emit them.  */\n \n static int\n-compute_movstrsi_length (insn)\n-     rtx insn;\n+compute_movstrsi_length (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   unsigned int align = INTVAL (XEXP (XVECEXP (pat, 0, 7), 0));\n@@ -2639,8 +2547,7 @@ compute_movstrsi_length (insn)\n \f\n \n const char *\n-output_and (operands)\n-     rtx *operands;\n+output_and (rtx *operands)\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     {\n@@ -2692,8 +2599,7 @@ output_and (operands)\n /* Return a string to perform a bitwise-and of operands[1] with operands[2]\n    storing the result in operands[0].  */\n const char *\n-output_64bit_and (operands)\n-     rtx *operands;\n+output_64bit_and (rtx *operands)\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     {\n@@ -2743,8 +2649,7 @@ output_64bit_and (operands)\n }\n \n const char *\n-output_ior (operands)\n-     rtx *operands;\n+output_ior (rtx *operands)\n {\n   unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n   int bs0, bs1, p, len;\n@@ -2774,8 +2679,7 @@ output_ior (operands)\n /* Return a string to perform a bitwise-and of operands[1] with operands[2]\n    storing the result in operands[0].  */\n const char *\n-output_64bit_ior (operands)\n-     rtx *operands;\n+output_64bit_ior (rtx *operands)\n {\n   unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n   int bs0, bs1, p, len;\n@@ -2808,10 +2712,7 @@ output_64bit_ior (operands)\n    be preceded by P%.  */\n \n static bool\n-pa_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+pa_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (size == UNITS_PER_WORD && aligned_p\n       && function_label_operand (x, VOIDmode))\n@@ -2826,10 +2727,7 @@ pa_assemble_integer (x, size, aligned_p)\n \f\n /* Output an ascii string.  */\n void\n-output_ascii (file, p, size)\n-     FILE *file;\n-     const char *p;\n-     int size;\n+output_ascii (FILE *file, const char *p, int size)\n {\n   int i;\n   int chars_output;\n@@ -2896,8 +2794,7 @@ output_ascii (file, p, size)\n    when there's a 1:1 correspondence between fcmp and ftest/fbranch\n    instructions.  */\n static void\n-remove_useless_addtr_insns (check_notes)\n-     int check_notes;\n+remove_useless_addtr_insns (int check_notes)\n {\n   rtx insn;\n   static int pass = 0;\n@@ -3108,8 +3005,7 @@ static int local_fsize, save_fregs;\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n \n static void\n-store_reg (reg, disp, base)\n-     int reg, disp, base;\n+store_reg (int reg, int disp, int base)\n {\n   rtx insn, dest, src, basereg;\n \n@@ -3149,8 +3045,7 @@ store_reg (reg, disp, base)\n    add MOD to BASE.  MOD must be <= 8k.  */\n \n static void\n-store_reg_modify (base, reg, mod)\n-     int base, reg, mod;\n+store_reg_modify (int base, int reg, int mod)\n {\n   rtx insn, basereg, srcreg, delta;\n \n@@ -3197,8 +3092,7 @@ store_reg_modify (base, reg, mod)\n    There is code in expand_hppa_{prologue,epilogue} that knows about this.  */\n \n static void\n-set_reg_plus_d (reg, base, disp, note)\n-     int reg, base, disp, note;\n+set_reg_plus_d (int reg, int base, int disp, int note)\n {\n   rtx insn;\n \n@@ -3225,9 +3119,7 @@ set_reg_plus_d (reg, base, disp, note)\n }\n \n int\n-compute_frame_size (size, fregs_live)\n-     int size;\n-     int *fregs_live;\n+compute_frame_size (int size, int *fregs_live)\n {\n   int freg_saved = 0;\n   int i, j;\n@@ -3320,9 +3212,7 @@ compute_frame_size (size, fregs_live)\n    to do this is made in regclass.c.  */\n \n static void\n-pa_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+pa_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* The function's label and associated .PROC must never be\n      separated and must be output *after* any profiling declarations\n@@ -3371,7 +3261,7 @@ pa_output_function_prologue (file, size)\n }\n \n void\n-hppa_expand_prologue ()\n+hppa_expand_prologue (void)\n {\n   int merge_sp_adjust_with_store = 0;\n   int size = get_frame_size ();\n@@ -3664,8 +3554,7 @@ hppa_expand_prologue ()\n    Handle case where DISP > 8k by using the add_high_const patterns.  */\n \n static void\n-load_reg (reg, disp, base)\n-     int reg, disp, base;\n+load_reg (int reg, int disp, int base)\n {\n   rtx src, dest, basereg;\n \n@@ -3690,8 +3579,7 @@ load_reg (reg, disp, base)\n /* Update the total code bytes output to the text section.  */\n \n static void\n-update_total_code_bytes (nbytes)\n-     int nbytes;\n+update_total_code_bytes (int nbytes)\n {\n   if ((TARGET_PORTABLE_RUNTIME || !TARGET_GAS || !TARGET_SOM)\n       && !IN_NAMED_SECTION_P (cfun->decl))\n@@ -3720,9 +3608,7 @@ update_total_code_bytes (nbytes)\n    adjustments before returning.  */\n \n static void\n-pa_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+pa_output_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   rtx insn = get_last_insn ();\n \n@@ -3770,7 +3656,7 @@ pa_output_function_epilogue (file, size)\n }\n \n void\n-hppa_expand_epilogue ()\n+hppa_expand_epilogue (void)\n {\n   rtx tmpreg;\n   int offset, i;\n@@ -3946,14 +3832,13 @@ hppa_expand_epilogue ()\n }\n \n rtx\n-hppa_pic_save_rtx ()\n+hppa_pic_save_rtx (void)\n {\n   return get_hard_reg_initial_val (word_mode, PIC_OFFSET_TABLE_REGNUM);\n }\n \n void\n-hppa_profile_hook (label_no)\n-     int label_no;\n+hppa_profile_hook (int label_no)\n {\n   rtx begin_label_rtx, call_insn;\n   char begin_label_name[16];\n@@ -4039,9 +3924,7 @@ hppa_profile_hook (label_no)\n    return location is in a shared library.  */\n \n rtx\n-return_addr_rtx (count, frameaddr)\n-     int count;\n-     rtx frameaddr;\n+return_addr_rtx (int count, rtx frameaddr)\n {\n   rtx label;\n   rtx rp;\n@@ -4120,7 +4003,7 @@ return_addr_rtx (count, frameaddr)\n    It's only valid if %r2 hasn't been saved into the caller's frame\n    (we're not profiling and %r2 isn't live anywhere).  */\n int\n-hppa_can_use_return_insn_p ()\n+hppa_can_use_return_insn_p (void)\n {\n   return (reload_completed\n \t  && (compute_frame_size (get_frame_size (), 0) ? 0 : 1)\n@@ -4129,9 +4012,7 @@ hppa_can_use_return_insn_p ()\n }\n \n void\n-emit_bcond_fp (code, operand0)\n-     enum rtx_code code;\n-     rtx operand0;\n+emit_bcond_fp (enum rtx_code code, rtx operand0)\n {\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n \t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n@@ -4145,9 +4026,7 @@ emit_bcond_fp (code, operand0)\n }\n \n rtx\n-gen_cmp_fp (code, operand0, operand1)\n-     enum rtx_code code;\n-     rtx operand0, operand1;\n+gen_cmp_fp (enum rtx_code code, rtx operand0, rtx operand1)\n {\n   return gen_rtx_SET (VOIDmode, gen_rtx_REG (CCFPmode, 0),\n \t\t      gen_rtx_fmt_ee (code, CCFPmode, operand0, operand1));\n@@ -4157,11 +4036,7 @@ gen_cmp_fp (code, operand0, operand1)\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-pa_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n+pa_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   enum attr_type attr_type;\n \n@@ -4349,9 +4224,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n /* Adjust scheduling priorities.  We use this to try and keep addil\n    and the next use of %r1 close together.  */\n static int\n-pa_adjust_priority (insn, priority)\n-     rtx insn;\n-     int priority;\n+pa_adjust_priority (rtx insn, int priority)\n {\n   rtx set = single_set (insn);\n   rtx src, dest;\n@@ -4383,7 +4256,7 @@ pa_adjust_priority (insn, priority)\n    The 7XXX processors can issue two insns at a time.\n    The 8000 can issue 4 insns at a time.  */\n static int\n-pa_issue_rate ()\n+pa_issue_rate (void)\n {\n   switch (pa_cpu)\n     {\n@@ -4411,9 +4284,7 @@ pa_issue_rate ()\n    Also compute the length of an inline block move here as it is too\n    complicated to express as a length attribute in pa.md.  */\n int\n-pa_adjust_insn_length (insn, length)\n-    rtx insn;\n-    int length;\n+pa_adjust_insn_length (rtx insn, int length)\n {\n   rtx pat = PATTERN (insn);\n \n@@ -4472,10 +4343,7 @@ pa_adjust_insn_length (insn, length)\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -4840,10 +4708,7 @@ print_operand (file, x, code)\n /* output a SYMBOL_REF or a CONST expression involving a SYMBOL_REF.  */\n \n void\n-output_global_address (file, x, round_constant)\n-     FILE *file;\n-     rtx x;\n-     int round_constant;\n+output_global_address (FILE *file, rtx x, int round_constant)\n {\n \n   /* Imagine  (high (const (plus ...))).  */\n@@ -4921,7 +4786,7 @@ output_global_address (file, x, round_constant)\n    There are several possible versions.  */\n #define aputs(x) fputs(x, asm_out_file)\n static inline void\n-pa_file_start_level ()\n+pa_file_start_level (void)\n {\n   if (TARGET_64BIT)\n     aputs (\"\\t.LEVEL 2.0w\\n\");\n@@ -4934,8 +4799,7 @@ pa_file_start_level ()\n }\n \n static inline void\n-pa_file_start_space (sortspace)\n-     int sortspace;\n+pa_file_start_space (int sortspace)\n {\n   aputs (\"\\t.SPACE $PRIVATE$\");\n   if (sortspace)\n@@ -4950,8 +4814,7 @@ pa_file_start_space (sortspace)\n }\n \n static inline void\n-pa_file_start_file (want_version)\n-     int want_version;\n+pa_file_start_file (int want_version)\n {\n   if (write_symbols != NO_DEBUG)\n     {\n@@ -4962,23 +4825,22 @@ pa_file_start_file (want_version)\n }\n \n static inline void\n-pa_file_start_mcount (aswhat)\n-     const char *aswhat;\n+pa_file_start_mcount (const char *aswhat)\n {\n   if (profile_flag)\n     fprintf (asm_out_file, \"\\t.IMPORT _mcount,%s\\n\", aswhat);\n }\n   \n static void\n-pa_elf_file_start ()\n+pa_elf_file_start (void)\n {\n   pa_file_start_level ();\n   pa_file_start_mcount (\"ENTRY\");\n   pa_file_start_file (0);\n }\n \n static void\n-pa_som_file_start ()\n+pa_som_file_start (void)\n {\n   pa_file_start_level ();\n   pa_file_start_space (0);\n@@ -4989,15 +4851,15 @@ pa_som_file_start ()\n }\n \n static void\n-pa_linux_file_start ()\n+pa_linux_file_start (void)\n {\n   pa_file_start_file (1);\n   pa_file_start_level ();\n   pa_file_start_mcount (\"CODE\");\n }\n \n static void\n-pa_hpux64_gas_file_start ()\n+pa_hpux64_gas_file_start (void)\n {\n   pa_file_start_level ();\n #ifdef ASM_OUTPUT_TYPE_DIRECTIVE\n@@ -5008,7 +4870,7 @@ pa_hpux64_gas_file_start ()\n }\n \n static void\n-pa_hpux64_hpas_file_start ()\n+pa_hpux64_hpas_file_start (void)\n {\n   pa_file_start_level ();\n   pa_file_start_space (1);\n@@ -5018,8 +4880,7 @@ pa_hpux64_hpas_file_start ()\n #undef aputs\n \n static struct deferred_plabel *\n-get_plabel (fname)\n-     const char *fname;\n+get_plabel (const char *fname)\n {\n   size_t i;\n \n@@ -5059,7 +4920,7 @@ get_plabel (fname)\n }\n \n static void\n-output_deferred_plabels ()\n+output_deferred_plabels (void)\n {\n   size_t i;\n   /* If we have deferred plabels, then we need to switch into the data\n@@ -5085,15 +4946,14 @@ output_deferred_plabels ()\n    Keep track of which ones we have used.  */\n \n enum millicodes { remI, remU, divI, divU, mulI, end1000 };\n-static void import_milli\t\t\tPARAMS ((enum millicodes));\n+static void import_milli (enum millicodes);\n static char imported[(int) end1000];\n static const char * const milli_names[] = {\"remI\", \"remU\", \"divI\", \"divU\", \"mulI\"};\n static const char import_string[] = \".IMPORT $$....,MILLICODE\";\n #define MILLI_START 10\n \n static void\n-import_milli (code)\n-     enum millicodes code;\n+import_milli (enum millicodes code)\n {\n   char str[sizeof (import_string)];\n \n@@ -5110,9 +4970,7 @@ import_milli (code)\n    the proper registers.  */\n \n const char *\n-output_mul_insn (unsignedp, insn)\n-     int unsignedp ATTRIBUTE_UNUSED;\n-     rtx insn;\n+output_mul_insn (int unsignedp ATTRIBUTE_UNUSED, rtx insn)\n {\n   import_milli (mulI);\n   return output_millicode_call (insn, gen_rtx_SYMBOL_REF (Pmode, \"$$mulI\"));\n@@ -5131,9 +4989,7 @@ static const int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0,\n static int div_milli[16][2];\n \n int\n-div_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+div_operand (rtx op, enum machine_mode mode)\n {\n   return (mode == SImode\n \t  && ((GET_CODE (op) == REG && REGNO (op) == 25)\n@@ -5142,9 +4998,7 @@ div_operand (op, mode)\n }\n \n int\n-emit_hpdiv_const (operands, unsignedp)\n-     rtx *operands;\n-     int unsignedp;\n+emit_hpdiv_const (rtx *operands, int unsignedp)\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) > 0\n@@ -5174,10 +5028,7 @@ emit_hpdiv_const (operands, unsignedp)\n }\n \n const char *\n-output_div_insn (operands, unsignedp, insn)\n-     rtx *operands;\n-     int unsignedp;\n-     rtx insn;\n+output_div_insn (rtx *operands, int unsignedp, rtx insn)\n {\n   int divisor;\n \n@@ -5231,9 +5082,7 @@ output_div_insn (operands, unsignedp, insn)\n /* Output a $$rem millicode to do mod.  */\n \n const char *\n-output_mod_insn (unsignedp, insn)\n-     int unsignedp;\n-     rtx insn;\n+output_mod_insn (int unsignedp, rtx insn)\n {\n   if (unsignedp)\n     {\n@@ -5250,8 +5099,7 @@ output_mod_insn (unsignedp, insn)\n }\n \n void\n-output_arg_descriptor (call_insn)\n-     rtx call_insn;\n+output_arg_descriptor (rtx call_insn)\n {\n   const char *arg_regs[4];\n   enum machine_mode arg_mode;\n@@ -5335,10 +5183,7 @@ output_arg_descriptor (call_insn)\n    It might be worthwhile to try and make this a leaf function too.  */\n \n enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n+secondary_reload_class (enum reg_class class, enum machine_mode mode, rtx in)\n {\n   int regno, is_symbolic;\n \n@@ -5426,9 +5271,7 @@ secondary_reload_class (class, mode, in)\n }\n \n enum direction\n-function_arg_padding (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+function_arg_padding (enum machine_mode mode, tree type)\n {\n   if (mode == BLKmode\n       || (TARGET_64BIT && type && AGGREGATE_TYPE_P (type)))\n@@ -5467,7 +5310,7 @@ function_arg_padding (mode, type)\n    va_list.  A pointer to this constructor is returned.  */\n \n struct rtx_def *\n-hppa_builtin_saveregs ()\n+hppa_builtin_saveregs (void)\n {\n   rtx offset, dest;\n   tree fntype = TREE_TYPE (current_function_decl);\n@@ -5536,17 +5379,14 @@ hppa_builtin_saveregs ()\n }\n \n void\n-hppa_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+hppa_va_start (tree valist, rtx nextarg)\n {\n   nextarg = expand_builtin_saveregs ();\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \n rtx\n-hppa_va_arg (valist, type)\n-     tree valist, type;\n+hppa_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size = int_size_in_bytes (type);\n   HOST_WIDE_INT ofs;\n@@ -5654,10 +5494,7 @@ hppa_va_arg (valist, type)\n    parameters.  */\n \n const char *\n-output_cbranch (operands, nullify, length, negated, insn)\n-     rtx *operands;\n-     int nullify, length, negated;\n-     rtx insn;\n+output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n {\n   static char buf[100];\n   int useskip = 0;\n@@ -5842,8 +5679,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n    maximum range of a simple branch instruction.  */\n \n const char *\n-output_lbranch (dest, insn)\n-     rtx dest, insn;\n+output_lbranch (rtx dest, rtx insn)\n {\n   rtx xoperands[2];\n  \n@@ -5961,11 +5797,8 @@ output_lbranch (dest, insn)\n    above.  it returns the appropriate output template to emit the branch.  */\n \n const char *\n-output_bb (operands, nullify, length, negated, insn, which)\n-     rtx *operands ATTRIBUTE_UNUSED;\n-     int nullify, length, negated;\n-     rtx insn;\n-     int which;\n+output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n+\t   int negated, rtx insn, int which)\n {\n   static char buf[100];\n   int useskip = 0;\n@@ -6109,11 +5942,8 @@ output_bb (operands, nullify, length, negated, insn, which)\n    branch.  */\n \n const char *\n-output_bvb (operands, nullify, length, negated, insn, which)\n-     rtx *operands ATTRIBUTE_UNUSED;\n-     int nullify, length, negated;\n-     rtx insn;\n-     int which;\n+output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n+\t    int negated, rtx insn, int which)\n {\n   static char buf[100];\n   int useskip = 0;\n@@ -6255,10 +6085,7 @@ output_bvb (operands, nullify, length, negated, insn, which)\n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n-output_dbra (operands, insn, which_alternative)\n-     rtx *operands;\n-     rtx insn;\n-     int which_alternative;\n+output_dbra (rtx *operands, rtx insn, int which_alternative)\n {\n \n   /* A conditional branch to the following instruction (eg the delay slot) is\n@@ -6361,11 +6188,8 @@ output_dbra (operands, insn, which_alternative)\n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n-output_movb (operands, insn, which_alternative, reverse_comparison)\n-     rtx *operands;\n-     rtx insn;\n-     int which_alternative;\n-     int reverse_comparison;\n+output_movb (rtx *operands, rtx insn, int which_alternative,\n+\t     int reverse_comparison)\n {\n \n   /* A conditional branch to the following instruction (eg the delay slot) is\n@@ -6471,8 +6295,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \n /* Copy any FP arguments in INSN into integer registers.  */\n static void\n-copy_fp_args (insn)\n-     rtx insn;\n+copy_fp_args (rtx insn)\n {\n   rtx link;\n   rtx xoperands[2];\n@@ -6515,8 +6338,7 @@ copy_fp_args (insn)\n \n /* Compute length of the FP argument copy sequence for INSN.  */\n static int\n-length_fp_args (insn)\n-     rtx insn;\n+length_fp_args (rtx insn)\n {\n   int length = 0;\n   rtx link;\n@@ -6553,8 +6375,7 @@ length_fp_args (insn)\n    over estimate the length than to under estimate it.  */\n \n int\n-attr_length_millicode_call (insn)\n-     rtx insn;\n+attr_length_millicode_call (rtx insn)\n {\n   unsigned long distance = -1;\n   unsigned long total = IN_NAMED_SECTION_P (cfun->decl) ? 0 : total_code_bytes;\n@@ -6593,9 +6414,7 @@ attr_length_millicode_call (insn)\n    CALL_DEST is the routine we are calling.  */\n \n const char *\n-output_millicode_call (insn, call_dest)\n-     rtx insn;\n-     rtx call_dest;\n+output_millicode_call (rtx insn, rtx call_dest)\n {\n   int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n@@ -6756,9 +6575,7 @@ output_millicode_call (insn, call_dest)\n    these sequences.  */\n \n int\n-attr_length_call (insn, sibcall)\n-     rtx insn;\n-     int sibcall;\n+attr_length_call (rtx insn, int sibcall)\n {\n   int local_call;\n   rtx call_dest;\n@@ -6841,10 +6658,7 @@ attr_length_call (insn, sibcall)\n    CALL_DEST is the routine we are calling.  */\n \n const char *\n-output_call (insn, call_dest, sibcall)\n-     rtx insn;\n-     rtx call_dest;\n-     int sibcall;\n+output_call (rtx insn, rtx call_dest, int sibcall)\n {\n   int delay_insn_deleted = 0;\n   int delay_slot_filled = 0;\n@@ -7137,8 +6951,7 @@ output_call (insn, call_dest, sibcall)\n    the sequence itself.  */\n \n int\n-attr_length_indirect_call (insn)\n-     rtx insn;\n+attr_length_indirect_call (rtx insn)\n {\n   unsigned long distance = -1;\n   unsigned long total = IN_NAMED_SECTION_P (cfun->decl) ? 0 : total_code_bytes;\n@@ -7169,9 +6982,7 @@ attr_length_indirect_call (insn)\n }\n \n const char *\n-output_indirect_call (insn, call_dest)\n-     rtx insn;\n-     rtx call_dest;\n+output_indirect_call (rtx insn, rtx call_dest)\n {\n   rtx xoperands[1];\n \n@@ -7233,8 +7044,7 @@ output_indirect_call (insn, call_dest)\n    within the same translation unit.  */\n \n int\n-attr_length_save_restore_dltp (insn)\n-     rtx insn;\n+attr_length_save_restore_dltp (rtx insn)\n {\n   if (find_reg_note (insn, REG_NORETURN, NULL_RTX))\n     return 0;\n@@ -7248,8 +7058,7 @@ attr_length_save_restore_dltp (insn)\n    space), and special magic is needed to construct their address.  */\n \n void\n-hppa_encode_label (sym)\n-     rtx sym;\n+hppa_encode_label (rtx sym)\n {\n   const char *str = XSTR (sym, 0);\n   int len = strlen (str) + 1;\n@@ -7263,10 +7072,7 @@ hppa_encode_label (sym)\n }\n \n static void\n-pa_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+pa_encode_section_info (tree decl, rtx rtl, int first)\n {\n   if (first && TEXT_SPACE_P (decl))\n     {\n@@ -7279,18 +7085,15 @@ pa_encode_section_info (decl, rtl, first)\n /* This is sort of inverse to pa_encode_section_info.  */\n \n static const char *\n-pa_strip_name_encoding (str)\n-     const char *str;\n+pa_strip_name_encoding (const char *str)\n {\n   str += (*str == '@');\n   str += (*str == '*');\n   return str;\n }\n \n int\n-function_label_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+function_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == SYMBOL_REF && FUNCTION_NAME_P (XSTR (op, 0));\n }\n@@ -7299,8 +7102,7 @@ function_label_operand (op, mode)\n    with a constant.  Used to keep certain patterns from matching\n    during instruction combination.  */\n int\n-is_function_label_plus_const (op)\n-     rtx op;\n+is_function_label_plus_const (rtx op)\n {\n   /* Strip off any CONST.  */\n   if (GET_CODE (op) == CONST)\n@@ -7314,12 +7116,9 @@ is_function_label_plus_const (op)\n /* Output assembly code for a thunk to FUNCTION.  */\n \n static void\n-pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk_fndecl;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n+pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n+\t\t\tHOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t\ttree function)\n {\n   const char *fname = XSTR (XEXP (DECL_RTL (function), 0), 0);\n   const char *tname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n@@ -7580,9 +7379,7 @@ pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n    It is safe to perform a sibcall optimization when the target function\n    will never return.  */\n static bool\n-pa_function_ok_for_sibcall (decl, exp)\n-     tree decl;\n-     tree exp ATTRIBUTE_UNUSED;\n+pa_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   /* Sibcalls are ok for TARGET_ELF32 as along as the linker is used in\n      single subspace mode and the call is not indirect.  As far as I know,\n@@ -7609,8 +7406,7 @@ pa_function_ok_for_sibcall (decl, exp)\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpyadd instructions.  */\n int\n-fmpyaddoperands (operands)\n-     rtx *operands;\n+fmpyaddoperands (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -7667,9 +7463,7 @@ fmpyaddoperands (operands)\n \n #if !defined(USE_COLLECT2)\n static void\n-pa_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+pa_asm_out_constructor (rtx symbol, int priority)\n {\n   if (!function_label_operand (symbol, VOIDmode))\n     hppa_encode_label (symbol);\n@@ -7686,9 +7480,7 @@ pa_asm_out_constructor (symbol, priority)\n }\n \n static void\n-pa_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+pa_asm_out_destructor (rtx symbol, int priority)\n {\n   if (!function_label_operand (symbol, VOIDmode))\n     hppa_encode_label (symbol);\n@@ -7708,8 +7500,7 @@ pa_asm_out_destructor (symbol, priority)\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpysub instructions.  */\n int\n-fmpysuboperands (operands)\n-     rtx *operands;\n+fmpysuboperands (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -7763,9 +7554,7 @@ fmpysuboperands (operands)\n }\n \n int\n-plus_xor_ior_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+plus_xor_ior_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == PLUS || GET_CODE (op) == XOR\n \t  || GET_CODE (op) == IOR);\n@@ -7774,8 +7563,7 @@ plus_xor_ior_operator (op, mode)\n /* Return 1 if the given constant is 2, 4, or 8.  These are the valid\n    constants for shadd instructions.  */\n static int\n-shadd_constant_p (val)\n-     int val;\n+shadd_constant_p (int val)\n {\n   if (val == 2 || val == 4 || val == 8)\n     return 1;\n@@ -7786,19 +7574,15 @@ shadd_constant_p (val)\n /* Return 1 if OP is a CONST_INT with the value 2, 4, or 8.  These are\n    the valid constant for shadd instructions.  */\n int\n-shadd_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+shadd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && shadd_constant_p (INTVAL (op)));\n }\n \n /* Return 1 if OP is valid as a base register in a reg + reg address.  */\n \n int\n-basereg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+basereg_operand (rtx op, enum machine_mode mode)\n {\n   /* cse will create some unscaled indexed addresses, however; it\n      generally isn't a win on the PA, so avoid creating unscaled\n@@ -7826,18 +7610,15 @@ basereg_operand (op, mode)\n /* Return 1 if this operand is anything other than a hard register.  */\n \n int\n-non_hard_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+non_hard_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ! (GET_CODE (op) == REG && REGNO (op) < FIRST_PSEUDO_REGISTER);\n }\n \n /* Return 1 if INSN branches forward.  Should be using insn_addresses\n    to avoid walking through all the insns...  */\n static int\n-forward_branch_p (insn)\n-     rtx insn;\n+forward_branch_p (rtx insn)\n {\n   rtx label = JUMP_LABEL (insn);\n \n@@ -7854,27 +7635,22 @@ forward_branch_p (insn)\n \n /* Return 1 if OP is an equality comparison, else return 0.  */\n int\n-eq_neq_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+eq_neq_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n \n /* Return 1 if OP is an operator suitable for use in a movb instruction.  */\n int\n-movb_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+movb_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == EQ || GET_CODE (op) == NE\n \t  || GET_CODE (op) == LT || GET_CODE (op) == GE);\n }\n \n /* Return 1 if INSN is in the delay slot of a call instruction.  */\n int\n-jump_in_call_delay (insn)\n-     rtx insn;\n+jump_in_call_delay (rtx insn)\n {\n \n   if (GET_CODE (insn) != JUMP_INSN)\n@@ -7897,9 +7673,7 @@ jump_in_call_delay (insn)\n /* Output an unconditional move and branch insn.  */\n \n const char *\n-output_parallel_movb (operands, length)\n-     rtx *operands;\n-     int length;\n+output_parallel_movb (rtx *operands, int length)\n {\n   /* These are the cases in which we win.  */\n   if (length == 4)\n@@ -7928,9 +7702,7 @@ output_parallel_movb (operands, length)\n /* Output an unconditional add and branch insn.  */\n \n const char *\n-output_parallel_addb (operands, length)\n-     rtx *operands;\n-     int length;\n+output_parallel_addb (rtx *operands, int length)\n {\n   /* To make life easy we want operand0 to be the shared input/output\n      operand and operand1 to be the readonly operand.  */\n@@ -7961,8 +7733,7 @@ output_parallel_addb (operands, length)\n    the delay slot of the call.  */\n \n int\n-following_call (insn)\n-     rtx insn;\n+following_call (rtx insn)\n {\n   if (! TARGET_JUMP_IN_DELAY)\n     return 0;\n@@ -8020,7 +7791,7 @@ following_call (insn)\n    when using GAS (allows for better link time optimizations).  */\n \n static void\n-pa_reorg ()\n+pa_reorg (void)\n {\n   rtx insn;\n \n@@ -8191,7 +7962,7 @@ pa_reorg ()\n       branch length restrictions.  */\n \n static void\n-pa_combine_instructions ()\n+pa_combine_instructions (void)\n {\n   rtx anchor, new;\n \n@@ -8387,10 +8158,8 @@ pa_combine_instructions ()\n }\n \n static int\n-pa_can_combine_p (new, anchor, floater, reversed, dest, src1, src2)\n-     rtx new, anchor, floater;\n-     int reversed;\n-     rtx dest, src1, src2;\n+pa_can_combine_p (rtx new, rtx anchor, rtx floater, int reversed, rtx dest,\n+\t\t  rtx src1, rtx src2)\n {\n   int insn_code_number;\n   rtx start, end;\n@@ -8465,8 +8234,7 @@ pa_can_combine_p (new, anchor, floater, reversed, dest, src1, src2)\n    filter out things it will not accept -- SEQUENCE, USE and CLOBBER insns\n    in particular.  */\n int\n-insn_refs_are_delayed (insn)\n-     rtx insn;\n+insn_refs_are_delayed (rtx insn)\n {\n   return ((GET_CODE (insn) == INSN\n \t   && GET_CODE (PATTERN (insn)) != SEQUENCE\n@@ -8485,9 +8253,7 @@ insn_refs_are_delayed (insn)\n    to match the HP Compiler ABI.  */\n \n rtx\n-function_value (valtype, func)\n-    tree valtype;\n-    tree func ATTRIBUTE_UNUSED;\n+function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n {\n   enum machine_mode valmode;\n \n@@ -8535,11 +8301,8 @@ function_value (valtype, func)\n    ??? We might want to restructure this so that it looks more like other\n    ports.  */\n rtx\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t      int named ATTRIBUTE_UNUSED)\n {\n   int max_arg_words = (TARGET_64BIT ? 8 : 4);\n   int alignment = 0;\n@@ -8738,11 +8501,8 @@ function_arg (cum, mode, type, named)\n    then this routine should return zero. It is currently called only for\n    the 64-bit target.  */\n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n {\n   unsigned int max_arg_words = 8;\n   unsigned int offset = 0;\n@@ -8766,9 +8526,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n    MATCH_OPERATOR to recognize all the branch insns.  */\n \n int\n-cmpib_comparison_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+cmpib_comparison_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n           && (GET_CODE (op) == EQ\n@@ -8809,9 +8567,7 @@ pa_select_section (exp, reloc, align)\n }\n \n static void\n-pa_globalize_label (stream, name)\n-     FILE *stream;\n-     const char *name;\n+pa_globalize_label (FILE *stream, const char *name)\n {\n   /* We only handle DATA objects here, functions are globalized in\n      ASM_DECLARE_FUNCTION_NAME.  */"}, {"sha": "ce69b3bc19bb5aac3650ff55ecef0d949088e146", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -5,20 +5,20 @@\n    and Tim Moore (moore@defmacro.cs.utah.edu) of the Center for\n    Software Science at the University of Utah.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n@@ -550,7 +550,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Function to return the rtx used to save the pic offset table register\n    across function calls.  */\n-extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n+extern struct rtx_def *hppa_pic_save_rtx (void);\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n@@ -962,7 +962,7 @@ extern enum cmp_type hppa_branch_type;\n   (*targetm.asm_out.internal_label) (FILE, FUNC_BEGIN_PROLOG_LABEL, LABEL)\n \n #define PROFILE_HOOK(label_no) hppa_profile_hook (label_no)\n-void hppa_profile_hook PARAMS ((int label_no));\n+void hppa_profile_hook (int label_no);\n \n /* The profile counter if emitted must come before the prologue.  */\n #define PROFILE_BEFORE_PROLOGUE 1"}, {"sha": "b5c994017ba6a9fd87f9d0ebcd692263e0fbcfe9", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,23 +1,23 @@\n-;;- Machine description for HP PA-RISC architecture for GNU C compiler\n+;;- Machine description for HP PA-RISC architecture for GCC compiler\n ;;   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n ;;   2002, 2003 Free Software Foundation, Inc.\n ;;   Contributed by the Center for Software Science at the University\n ;;   of Utah.\n \n-;; This file is part of GNU CC.\n+;; This file is part of GCC.\n \n-;; GNU CC is free software; you can redistribute it and/or modify\n+;; GCC is free software; you can redistribute it and/or modify\n ;; it under the terms of the GNU General Public License as published by\n ;; the Free Software Foundation; either version 2, or (at your option)\n ;; any later version.\n \n-;; GNU CC is distributed in the hope that it will be useful,\n+;; GCC is distributed in the hope that it will be useful,\n ;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n ;; GNU General Public License for more details.\n \n ;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n+;; along with GCC; see the file COPYING.  If not, write to\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n "}, {"sha": "494395949204c6e2abb67eae150324079285e603", "filename": "gcc/config/pa/pa32-linux.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-linux.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions for PA_RISC with ELF-32 format\n    Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "4b9e1a3ac9b38acf9d288f24e0b6dc30ac572dd4", "filename": "gcc/config/pa/pa64-hpux.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -2,20 +2,20 @@\n    HPUX using the 64bit runtime model.\n    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "5d7fdbee1810a9f849c495e32b3181e7f745aa09", "filename": "gcc/config/pa/pa64-linux.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-linux.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions for PA_RISC with ELF format on 64-bit Linux\n    Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "29cc230c79bfa14686792d5acc35c7364d9daf93", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n-/* Configuration for GNU C-compiler for PA-RISC.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* Configuration for GCC-compiler for PA-RISC.\n+   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "cfec5e9723c9f8a87c0896c3df6d7a754b4f7dc0", "filename": "gcc/config/pa/quadlib.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fquadlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fquadlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fquadlib.c?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,9 +1,9 @@\n /* Subroutines for long double support.\n    Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n@@ -17,13 +17,13 @@ do apply in other respects; for example, they cover modification of\n the file, and distribution when not linked into a combine\n executable.)\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "5450cfb2fb12a8b8f4522fdd49ad60b2d1880bc5", "filename": "gcc/config/pa/rtems.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Frtems.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -2,20 +2,20 @@\n    Copyright (C) 1997, 2000, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Joel Sherrill (joel@OARcorp.com).\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n "}, {"sha": "fae73922a9808c661f872b249b3d50cc61d7c959", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7849684fa43afe955fd8572570ac6d2e890ce2d/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=b7849684fa43afe955fd8572570ac6d2e890ce2d", "patch": "@@ -1,20 +1,20 @@\n /* Definitions for SOM assembler support.\n    Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n@@ -232,7 +232,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define EXTRA_SECTIONS in_readonly_data\n \n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n-extern void readonly_data PARAMS ((void));\t\t\t\t\\\n+extern void readonly_data (void);\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n readonly_data ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\"}]}