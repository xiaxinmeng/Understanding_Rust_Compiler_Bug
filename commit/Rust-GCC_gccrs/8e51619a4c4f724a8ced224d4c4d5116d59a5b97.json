{"sha": "8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU1MTYxOWE0YzRmNzI0YThjZWQyMjRkNGM0ZDUxMTZkNTlhNWI5Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-07-26T20:10:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-07-26T20:10:43Z"}, "message": "function.c (assign_parms): Handle frontend-directed pass by invisible reference.\n\n        * function.c (assign_parms): Handle frontend-directed pass by\n        invisible reference.\ncp/\n        * call.c (build_over_call): Likewise.\n        (cp_convert_parm_for_inlining): New fn.\n        (convert_for_arg_passing): New fn.\n        (convert_default_arg, build_over_call): Use it.\n        (type_passed_as): New fn.\n        * pt.c (tsubst_decl): Use it.\n        * decl2.c (cp_build_parm_decl): New fn.\n        (build_artificial_parm): Use it.\n        (start_static_storage_duration_function): Likewise.\n        * decl.c (start_cleanup_fn, grokdeclarater): Likewise.\n        (grokparms): Don't mess with DECL_ARG_TYPE.\n        * typeck.c (convert_arguments): Use convert_for_arg_passing.\n        * cp-lang.c (LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING):\n        Define.\n        * cp-tree.h: Declare new fns.\n\nFrom-SVN: r55781", "tree": {"sha": "9feb5c92f6ca92e0e155d86992b0be0d7a2f82a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9feb5c92f6ca92e0e155d86992b0be0d7a2f82a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a7f132d3dc5c2c543b5f9fb7fa098b0208c6474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7f132d3dc5c2c543b5f9fb7fa098b0208c6474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7f132d3dc5c2c543b5f9fb7fa098b0208c6474"}], "stats": {"total": 164, "additions": 118, "deletions": 46}, "files": [{"sha": "138d317e41f019cf93e532657770feb53aad6df5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -1,3 +1,8 @@\n+2002-07-26  Jason Merrill  <jason@redhat.com>\n+\n+\t* function.c (assign_parms): Handle frontend-directed pass by\n+\tinvisible reference.\n+\n 2002-07-26  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* doc/cppopts.texi: Update."}, {"sha": "8fc09b11d22e5db6c02cad31c9979da1423c9dfb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -1,3 +1,21 @@\n+2002-07-26  Jason Merrill  <jason@redhat.com>\n+\n+\t* call.c (build_over_call): Likewise.\n+\t(cp_convert_parm_for_inlining): New fn.\n+        (convert_for_arg_passing): New fn.\n+        (convert_default_arg, build_over_call): Use it.\n+\t(type_passed_as): New fn.\n+\t* pt.c (tsubst_decl): Use it.\n+\t* decl2.c (cp_build_parm_decl): New fn.\n+\t(build_artificial_parm): Use it.\n+\t(start_static_storage_duration_function): Likewise.\n+\t* decl.c (start_cleanup_fn, grokdeclarater): Likewise.\n+\t(grokparms): Don't mess with DECL_ARG_TYPE.\n+\t* typeck.c (convert_arguments): Use convert_for_arg_passing.\n+\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING):\n+\tDefine.\n+\t* cp-tree.h: Declare new fns.\n+\t\n 2002-07-26  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cp-tree.h (flag_operator_names): Remove."}, {"sha": "1599d0b993f60b2ab1c0a52d8a8ebbd16862ceb7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -4128,15 +4128,60 @@ convert_default_arg (type, arg, fn, parmnum)\n \n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n \t\t\t\t\t\"default argument\", fn, parmnum);\n-      if (PROMOTE_PROTOTYPES\n-\t  && INTEGRAL_TYPE_P (type)\n-\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\targ = default_conversion (arg);\n+      arg = convert_for_arg_passing (type, arg);\n     }\n \n   return arg;\n }\n \n+/* Returns the type which will really be used for passing an argument of\n+   type TYPE.  */\n+\n+tree\n+type_passed_as (type)\n+     tree type;\n+{\n+  /* Pass classes with copy ctors by invisible reference.  */\n+  if (TREE_ADDRESSABLE (type))\n+    type = build_reference_type (type);\n+  else if (PROMOTE_PROTOTYPES\n+\t   && INTEGRAL_TYPE_P (type)\n+\t   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+    type = integer_type_node;\n+\n+  return type;\n+}\n+\n+/* Actually perform the appropriate conversion.  */\n+\n+tree\n+convert_for_arg_passing (type, val)\n+     tree type, val;\n+{\n+  /* Pass classes with copy ctors by invisible reference.  */\n+  if (TREE_ADDRESSABLE (type))\n+    val = build1 (ADDR_EXPR, build_reference_type (type), val);\n+  else if (PROMOTE_PROTOTYPES\n+\t   && INTEGRAL_TYPE_P (type)\n+\t   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+    val = default_conversion (val);\n+  return val;\n+}\n+\n+/* Convert VALUE for assignment into inlined parameter PARM.  */\n+\n+tree\n+cp_convert_parm_for_inlining (parm, value, fn)\n+     tree parm, value;\n+     tree fn ATTRIBUTE_UNUSED;\n+{\n+  /* When inlining, we don't need to mess with invisible references, so\n+     undo the ADDR_EXPR.  */\n+  if (TREE_ADDRESSABLE (TREE_TYPE (parm)))\n+    value = build_indirect_ref (value, NULL);\n+  return value;\n+}\n+\n /* Subroutine of the various build_*_call functions.  Overload resolution\n    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.\n    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a\n@@ -4222,10 +4267,7 @@ build_over_call (cand, args, flags)\n       val = convert_like_with_context\n \t(conv, TREE_VALUE (arg), fn, i - is_method);\n \n-      if (PROMOTE_PROTOTYPES\n-\t  && INTEGRAL_TYPE_P (type)\n-\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\tval = default_conversion (val);\n+      val = convert_for_arg_passing (type, val);\n       converted_args = tree_cons (NULL_TREE, val, converted_args);\n     }\n "}, {"sha": "a44d4b6b8a19f10df861631416044a4f63098075", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -120,6 +120,9 @@ static bool cxx_warn_unused_global_decl PARAMS ((tree));\n #undef LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING\n #define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n   cp_copy_res_decl_for_inlining\n+#undef LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING\n+#define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n+  cp_convert_parm_for_inlining\n #undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P anon_aggr_type_p\n #undef LANG_HOOKS_TREE_INLINING_START_INLINING"}, {"sha": "ae88df2c8ce5585581b887290f27347397bdad98", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -3679,6 +3679,9 @@ extern tree convert_default_arg                 PARAMS ((tree, tree, tree, int))\n extern tree convert_arg_to_ellipsis             PARAMS ((tree));\n extern tree build_x_va_arg                      PARAMS ((tree, tree));\n extern tree cxx_type_promotes_to\t\tPARAMS ((tree));\n+extern tree type_passed_as                      PARAMS ((tree));\n+extern tree convert_for_arg_passing             PARAMS ((tree, tree));\n+extern tree cp_convert_parm_for_inlining        PARAMS ((tree, tree, tree));\n extern int is_properly_derived_from             PARAMS ((tree, tree));\n extern tree initialize_reference                PARAMS ((tree, tree));\n extern tree strip_top_quals                     PARAMS ((tree));\n@@ -3958,6 +3961,7 @@ extern void mark_used\t\t\t\tPARAMS ((tree));\n extern tree handle_class_head\t\t\t(enum tag_types, tree, tree, tree, int, int *);\n extern tree lookup_arg_dependent                PARAMS ((tree, tree, tree));\n extern void finish_static_data_member_decl      PARAMS ((tree, tree, tree, int));\n+extern tree cp_build_parm_decl                  PARAMS ((tree, tree));\n extern tree build_artificial_parm               PARAMS ((tree, tree));\n extern tree get_guard                           PARAMS ((tree));\n extern tree get_guard_cond                      PARAMS ((tree));"}, {"sha": "14021a411d15c3006688bce4739a728f46d3f385", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -8518,9 +8518,8 @@ start_cleanup_fn ()\n     {\n       tree parmdecl;\n \n-      parmdecl = build_decl (PARM_DECL, NULL_TREE, ptr_type_node);\n+      parmdecl = cp_build_parm_decl (NULL_TREE, ptr_type_node);\n       DECL_CONTEXT (parmdecl) = fndecl;\n-      DECL_ARG_TYPE (parmdecl) = ptr_type_node;\n       TREE_USED (parmdecl) = 1;\n       DECL_ARGUMENTS (fndecl) = parmdecl;\n     }\n@@ -11366,7 +11365,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n       for (args = TYPE_ARG_TYPES (type); args; args = TREE_CHAIN (args))\n \t{\n-\t  tree decl = build_decl (PARM_DECL, NULL_TREE, TREE_VALUE (args));\n+\t  tree decl = cp_build_parm_decl (NULL_TREE, TREE_VALUE (args));\n \n \t  TREE_CHAIN (decl) = decls;\n \t  decls = decl;\n@@ -11510,17 +11509,10 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \n     if (decl_context == PARM)\n       {\n-\tdecl = build_decl (PARM_DECL, declarator, type);\n+\tdecl = cp_build_parm_decl (declarator, type);\n \n \tbad_specifiers (decl, \"parameter\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n-\n-\t/* Compute the type actually passed in the parmlist,\n-\t   for the case where there is no prototype.\n-\t   (For example, shorts and chars are passed as ints.)\n-\t   When there is a prototype, this is overridden later.  */\n-\n-\tDECL_ARG_TYPE (decl) = type_promotes_to (type);\n       }\n     else if (decl_context == FIELD)\n       {\n@@ -12206,11 +12198,6 @@ grokparms (first_parm)\n \t\t\t  decl, ptr ? \"pointer\" : \"reference\", t);\n \t    }\n \n-\t  DECL_ARG_TYPE (decl) = TREE_TYPE (decl);\n-\t  if (PROMOTE_PROTOTYPES\n-\t      && INTEGRAL_TYPE_P (type)\n-\t      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\t    DECL_ARG_TYPE (decl) = integer_type_node;\n \t  if (!any_error && init)\n \t    init = check_default_argument (decl, init);\n \t  else"}, {"sha": "0a2da36c5b0837356ada1c59fed0fdf8e142d485", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -795,6 +795,19 @@ grok_x_components (specs)\n   finish_member_declaration (build_decl (FIELD_DECL, NULL_TREE, t)); \n }\n \n+/* Build a PARM_DECL with NAME and TYPE, and set DECL_ARG_TYPE\n+   appropriately.  */\n+\n+tree\n+cp_build_parm_decl (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree parm = build_decl (PARM_DECL, name, type);\n+  DECL_ARG_TYPE (parm) = type_passed_as (type);\n+  return parm;\n+}\n+\n /* Returns a PARM_DECL for a parameter of the indicated TYPE, with the\n    indicated NAME.  */\n \n@@ -803,14 +816,11 @@ build_artificial_parm (name, type)\n      tree name;\n      tree type;\n {\n-  tree parm;\n-\n-  parm = build_decl (PARM_DECL, name, type);\n+  tree parm = cp_build_parm_decl (name, type);\n   DECL_ARTIFICIAL (parm) = 1;\n   /* All our artificial parms are implicitly `const'; they cannot be\n      assigned to.  */\n   TREE_READONLY (parm) = 1;\n-  DECL_ARG_TYPE (parm) = type;\n   return parm;\n }\n \n@@ -2853,16 +2863,13 @@ start_static_storage_duration_function ()\n   VARRAY_PUSH_TREE (ssdf_decls, ssdf_decl);\n \n   /* Create the argument list.  */\n-  initialize_p_decl = build_decl (PARM_DECL,\n-\t\t\t\t  get_identifier (INITIALIZE_P_IDENTIFIER),\n-\t\t\t\t  integer_type_node);\n+  initialize_p_decl = cp_build_parm_decl\n+    (get_identifier (INITIALIZE_P_IDENTIFIER), integer_type_node);\n   DECL_CONTEXT (initialize_p_decl) = ssdf_decl;\n-  DECL_ARG_TYPE (initialize_p_decl) = integer_type_node;\n   TREE_USED (initialize_p_decl) = 1;\n-  priority_decl = build_decl (PARM_DECL, get_identifier (PRIORITY_IDENTIFIER),\n-\t\t\t      integer_type_node);\n+  priority_decl = cp_build_parm_decl\n+    (get_identifier (PRIORITY_IDENTIFIER), integer_type_node);\n   DECL_CONTEXT (priority_decl) = ssdf_decl;\n-  DECL_ARG_TYPE (priority_decl) = integer_type_node;\n   TREE_USED (priority_decl) = 1;\n \n   TREE_CHAIN (initialize_p_decl) = priority_decl;"}, {"sha": "3b99c95ee3e759810a471bd563ebc7eb740ed472", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -2494,7 +2494,9 @@ build_new_1 (exp)\n \t     constructor, that would fix the nesting problem and we could\n \t     do away with this complexity.  But that would complicate other\n \t     things; in particular, it would make it difficult to bail out\n-\t     if the allocation function returns null.  */\n+\t     if the allocation function returns null.  Er, no, it wouldn't;\n+\t     we just don't run the constructor.  The standard says it's\n+\t     unspecified whether or not the args are evaluated.  */\n \n \t  if (cleanup)\n \t    {"}, {"sha": "ca8b2c2225a2cd63e5e4d8898538a642fcd7d27c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -6012,7 +6012,7 @@ tsubst_decl (t, args, type, complain)\n \tr = copy_node (t);\n \tif (DECL_TEMPLATE_PARM_P (t))\n \t  SET_DECL_TEMPLATE_PARM_P (r);\n-\t\n+\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n@@ -6023,10 +6023,9 @@ tsubst_decl (t, args, type, complain)\n \t\t\t\t     complain, in_decl);\n \n \tDECL_CONTEXT (r) = NULL_TREE;\n-\tif (!DECL_TEMPLATE_PARM_P (r) && PROMOTE_PROTOTYPES\n-\t    && INTEGRAL_TYPE_P (type)\n-\t    && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\t  DECL_ARG_TYPE (r) = integer_type_node;\n+\n+\tif (!DECL_TEMPLATE_PARM_P (r))\n+\t  DECL_ARG_TYPE (r) = type_passed_as (type);\n \tif (TREE_CHAIN (t))\n \t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args,\n \t\t\t\t   complain, TREE_CHAIN (t));"}, {"sha": "07199d60b41c6b4e9669fa001c0aaa3626e94a2d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -3112,11 +3112,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t      parmval = convert_for_initialization\n \t\t(NULL_TREE, type, val, flags,\n \t\t \"argument passing\", fndecl, i);\n-\t      if (PROMOTE_PROTOTYPES\n-\t\t  && INTEGRAL_TYPE_P (type)\n-\t\t  && (TYPE_PRECISION (type)\n-\t\t      < TYPE_PRECISION (integer_type_node)))\n-\t\tparmval = default_conversion (parmval);\n+\t      parmval = convert_for_arg_passing (type, parmval);\n \t    }\n \n \t  if (parmval == error_mark_node)"}, {"sha": "98c1965870846f7e5b64afa32064578f45955756", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e51619a4c4f724a8ced224d4c4d5116d59a5b97/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8e51619a4c4f724a8ced224d4c4d5116d59a5b97", "patch": "@@ -4425,6 +4425,15 @@ assign_parms (fndecl)\n \t  passed_pointer = 1;\n \t  passed_mode = nominal_mode = Pmode;\n \t}\n+      /* See if the frontend wants to pass this by invisible reference.  */\n+      else if (passed_type != nominal_type\n+\t       && POINTER_TYPE_P (passed_type)\n+\t       && TREE_TYPE (passed_type) == nominal_type)\n+\t{\n+\t  nominal_type = passed_type;\n+\t  passed_pointer = 1;\n+\t  passed_mode = nominal_mode = Pmode;\n+\t}\n \n       promoted_mode = passed_mode;\n "}]}