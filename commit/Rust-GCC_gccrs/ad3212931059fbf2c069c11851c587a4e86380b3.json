{"sha": "ad3212931059fbf2c069c11851c587a4e86380b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQzMjEyOTMxMDU5ZmJmMmMwNjljMTE4NTFjNTg3YTRlODYzODBiMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-03-18T10:52:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-03-18T10:52:04Z"}, "message": "semantics.c: New file, containing routines to perform the semantic phase of parsing.\n\n\t* semantics.c: New file, containing routines to perform the\n\tsemantic phase of parsing.\n\t* parse.y: Use it.\n\t* pt.c (tsubst_expr): Likewise.\n\t* cp-tree.h: Declare the various functions in semantics.c.\n\tProvide macros to access _STMT tree nodes.\n\t* cp-tree.def: Add ASM_STMT tree node.\n\t* Makefile.in, Make-lang.in: Add dependencies on and for\n\tsemantics.c.\n\nFrom-SVN: r18658", "tree": {"sha": "c837a98a88ced12290d46507bb5f3592c37addbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c837a98a88ced12290d46507bb5f3592c37addbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad3212931059fbf2c069c11851c587a4e86380b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad3212931059fbf2c069c11851c587a4e86380b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad3212931059fbf2c069c11851c587a4e86380b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad3212931059fbf2c069c11851c587a4e86380b3/comments", "author": null, "committer": null, "parents": [{"sha": "cbe3672526c7686edca6e3c5e81a6bb9369f36e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe3672526c7686edca6e3c5e81a6bb9369f36e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe3672526c7686edca6e3c5e81a6bb9369f36e0"}], "stats": {"total": 8275, "additions": 4124, "deletions": 4151}, "files": [{"sha": "723c5a2f365034696bcc9be5817d6ab963bee743", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -1,3 +1,15 @@\n+Wed Mar 18 10:09:51 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* semantics.c: New file, containing routines to perform the\n+\tsemantic phase of parsing.\n+\t* parse.y: Use it.\n+\t* pt.c (tsubst_expr): Likewise.\n+\t* cp-tree.h: Declare the various functions in semantics.c.\n+\tProvide macros to access _STMT tree nodes.\n+\t* cp-tree.def: Add ASM_STMT tree node.\n+\t* Makefile.in, Make-lang.in: Add dependencies on and for\n+\tsemantics.c.\n+\t\n Wed Mar 18 00:24:10 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (push_template_decl): Only check primary templates."}, {"sha": "67fca2e315cd5d3a0db8c03308f53bdab63e4f0f", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -122,7 +122,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/search.c $(srcdir)/cp/typeck.c $(srcdir)/cp/decl.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n  $(srcdir)/cp/parse.y $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c \\\n- $(srcdir)/cp/repo.c\n+ $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c\n \n cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o \\\n \t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def"}, {"sha": "f677dfe7b1e5e205894e829fc5f241c6e08144ef", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -166,7 +166,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n \n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n- except.o friend.o init.o method.o search.o tree.o xref.o repo.o\n+ except.o friend.o init.o method.o search.o semantics.o tree.o xref.o repo.o\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -259,6 +259,8 @@ error.o : error.c $(CONFIG_H) $(CXX_TREE_H)\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H)\n sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n repo.o : repo.c $(CONFIG_H) $(CXX_TREE_H)\n+semantics.o: semantics.c $(CONFIG_H) $(CXX_TREE_H) lex.h $(srcdir)/../except.h\n+\n #\f\n # These exist for maintenance purposes.\n "}, {"sha": "98217c3892f84d20c661147e3573bd899bc382e6", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -200,6 +200,7 @@ DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n+DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n \n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)"}, {"sha": "0c4cfcd78f8ded51caa1287530dc2a2cd508cd92", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -1524,6 +1524,37 @@ extern int flag_new_for_scope;\n #define builtin_function(NAME, TYPE, CODE, LIBNAME) \\\n   define_function (NAME, TYPE, CODE, (void (*) PROTO((tree)))pushdecl, LIBNAME)\n \n+/* These macros provide convenient access to the various _STMT nodes\n+   created when parsing template declarations.  */\n+#define IF_COND(NODE)           TREE_OPERAND (NODE, 0)\n+#define THEN_CLAUSE(NODE)       TREE_OPERAND (NODE, 1)\n+#define ELSE_CLAUSE(NODE)       TREE_OPERAND (NODE, 2)\n+#define WHILE_COND(NODE)        TREE_OPERAND (NODE, 0)\n+#define WHILE_BODY(NODE)        TREE_OPERAND (NODE, 1)\n+#define DO_COND(NODE)           TREE_OPERAND (NODE, 0)\n+#define DO_BODY(NODE)           TREE_OPERAND (NODE, 1)\n+#define RETURN_EXPR(NODE)       TREE_OPERAND (NODE, 0)\n+#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (NODE, 0)\n+#define FOR_INIT_STMT(NODE)     TREE_OPERAND (NODE, 0)\n+#define FOR_COND(NODE)          TREE_OPERAND (NODE, 1)\n+#define FOR_EXPR(NODE)          TREE_OPERAND (NODE, 2)\n+#define FOR_BODY(NODE)          TREE_OPERAND (NODE, 3)\n+#define SWITCH_COND(NODE)       TREE_OPERAND (NODE, 0)\n+#define SWITCH_BODY(NODE)       TREE_OPERAND (NODE, 1)\n+#define CASE_LOW(NODE)          TREE_OPERAND (NODE, 0)\n+#define CASE_HIGH(NODE)         TREE_OPERAND (NODE, 1)\n+#define GOTO_DESTINATION(NODE)  TREE_OPERAND (NODE, 0)\n+#define TRY_STMTS(NODE)         TREE_OPERAND (NODE, 0)\n+#define TRY_HANDLERS(NODE)      TREE_OPERAND (NODE, 1)\n+#define HANDLER_PARMS(NODE)     TREE_OPERAND (NODE, 0)\n+#define HANDLER_BODY(NODE)      TREE_OPERAND (NODE, 1)\n+#define COMPOUND_BODY(NODE)     TREE_OPERAND (NODE, 0)\n+#define ASM_CV_QUAL(NODE)       TREE_OPERAND (NODE, 0)\n+#define ASM_STRING(NODE)        TREE_OPERAND (NODE, 1)\n+#define ASM_OUTPUTS(NODE)       TREE_OPERAND (NODE, 2)\n+#define ASM_INPUTS(NODE)        TREE_OPERAND (NODE, 3)\n+#define ASM_CLOBBERS(NODE)      TREE_OPERAND (NODE, 4)\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types { record_type, class_type, union_type, enum_type,\n \t\t   signature_type };\n@@ -2511,6 +2542,42 @@ extern tree current_scope\t\t\tPROTO((void));\n extern tree lookup_conversions\t\t\tPROTO((tree));\n extern tree get_template_base\t\t\tPROTO((tree, tree));\n \n+/* in semantics.c */\n+extern void finish_expr_stmt                    PROTO((tree));\n+extern tree begin_if_stmt                       PROTO((void));\n+extern void finish_if_stmt_cond                 PROTO((tree, tree));\n+extern tree finish_then_clause                  PROTO((tree));\n+extern void begin_else_clause                   PROTO((void));\n+extern void finish_else_clause                  PROTO((tree));\n+extern void finish_if_stmt                      PROTO((void));\n+extern tree begin_while_stmt                    PROTO((void));\n+extern void finish_while_stmt_cond              PROTO((tree, tree));\n+extern void finish_while_stmt                   PROTO((tree));\n+extern tree begin_do_stmt                       PROTO((void));\n+extern void finish_do_body                      PROTO((tree));\n+extern void finish_do_stmt                      PROTO((tree, tree));\n+extern void finish_return_stmt                  PROTO((tree));\n+extern tree begin_for_stmt                      PROTO((void));\n+extern void finish_for_init_stmt                PROTO((tree));\n+extern void finish_for_cond                     PROTO((tree, tree));\n+extern void finish_for_expression               PROTO((tree, tree));\n+extern void finish_for_stmt                     PROTO((tree, tree));\n+extern void finish_break_stmt                   PROTO((void));\n+extern void finish_continue_stmt                PROTO((void));\n+extern void begin_switch_stmt                   PROTO((void));\n+extern tree finish_switch_cond                  PROTO((tree));\n+extern void finish_switch_stmt                  PROTO((tree, tree));\n+extern void finish_case_label                   PROTO((tree, tree));\n+extern void finish_goto_stmt                    PROTO((tree));\n+extern tree begin_try_block                     PROTO((void));\n+extern void finish_try_block                    PROTO((tree));\n+extern void finish_handler_sequence             PROTO((tree));\n+extern tree begin_handler                       PROTO((void));\n+extern void finish_handler_parms                PROTO((tree));\n+extern void finish_handler                      PROTO((tree));\n+extern tree begin_compound_stmt                 PROTO((int));\n+extern tree finish_compound_stmt                PROTO((int, tree));\n+extern void finish_asm_stmt                     PROTO((tree, tree, tree, tree, tree));\n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));\n extern tree build_signature_reference_type\tPROTO((tree, int, int));"}, {"sha": "d42efe2a9913779ed15f479a7254a5ae34fe3592", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3143, "deletions": 3528, "changes": 6671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=ad3212931059fbf2c069c11851c587a4e86380b3"}, {"sha": "a9821fafc8ed9343b2770a3085f7a377792845dc", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 72, "deletions": 467, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -263,7 +263,7 @@ empty_parms ()\n %type <ttype> complete_type_name notype_identifier nonnested_type\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <ttype> new_initializer new_placement\n-%type <ttype> using_decl .poplevel\n+%type <ttype> using_decl\n %type <ttype> typename_sub typename_sub0 typename_sub1 typename_sub2\n %type <ttype> explicit_template_type\n /* in order to recognize aggr tags as defining and thus shadowing.  */\n@@ -1002,7 +1002,7 @@ paren_expr_or_null:\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' expr ')'\n-\t\t{ $$ = condition_conversion ($2); }\n+                { $$ = $2; }\n \t;\n \n paren_cond_or_null:\n@@ -1011,7 +1011,7 @@ paren_cond_or_null:\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' condition ')'\n-\t\t{ $$ = condition_conversion ($2); }\n+                { $$ = $2; }\n \t;\n \n xcond:\n@@ -1062,24 +1062,9 @@ compstmtend:\n \n already_scoped_stmt:\n \t  '{'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n-\t\t      COMPOUND_STMT_NO_SCOPE ($<ttype>$) = 1;\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t}\n+                { $<ttype>$ = begin_compound_stmt (1); }\n \t  compstmtend\n-\t\t{ \n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  finish_stmt (); \n-\t\t}\n+                { finish_compound_stmt (1, $<ttype>2); }\n \t| simple_stmt\n \t;\n \n@@ -3437,20 +3422,6 @@ errstmt:\n \t  error ';'\n \t;\n \n-/* build the LET_STMT node before parsing its contents,\n-  so that any LET_STMTs within the context can have their display pointers\n-  set up to point at this one.  */\n-\n-.pushlevel:\n-\t  /* empty */\n-\t\t{ do_pushlevel (); }\n-\t;\n-\n-.poplevel:\n-\t  /* empty */\n-\t\t{ $$ = do_poplevel (); }\n-\t;\n-\n /* Read zero or more forward-declarations for labels\n    that nested functions can jump to.  */\n maybe_label_decls:\n@@ -3487,439 +3458,127 @@ compstmt_or_error:\n \n compstmt:\n \t  '{'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t}\n-\t  .pushlevel compstmtend .poplevel\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  $$ = $5;\n-\t\t}\n+                { $<ttype>$ = begin_compound_stmt (0); }\n+\t  compstmtend \n+                { $$ = finish_compound_stmt (0, $<ttype>2); }\n \t;\n \n simple_if:\n \t  IF\n \t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t        NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-                  cond_stmt_keyword = \"if\";\n-\t\t}\n-\t  .pushlevel paren_cond_or_null\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      if (last_tree != $<ttype>2)\n-\t\t        {\n-\t\t\t  TREE_OPERAND ($<ttype>2, 0) = last_tree;\n-\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t\t  last_tree = $<ttype>2;\n-\t\t\t}\n-\t\t      else\n-\t\t        TREE_OPERAND ($<ttype>2, 0) = $4;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_start_cond ($4, 0);\n-\t\t    }\n-\t\t}\n-\t  implicitly_scoped_stmt\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      $<ttype>$ = last_tree = $<ttype>2;\n-\t\t    }\n+\t\t  $<ttype>$ = begin_if_stmt ();\n+\t\t  cond_stmt_keyword = \"if\";\n \t\t}\n+            paren_cond_or_null\n+                { finish_if_stmt_cond ($3, $<ttype>2); }\n+\t    implicitly_scoped_stmt\n+                { $<ttype>$ = finish_then_clause ($<ttype>2); }\n \t;\n \n implicitly_scoped_stmt:\n \t  compstmt\n-\t\t{ finish_stmt (); }\n-\t| .pushlevel\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t}\n-\t  simple_stmt .poplevel\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  $$ = $4;\n-\t\t}\n+\t|       { $<ttype>$ = begin_compound_stmt (0); }\n+\t  simple_stmt \n+                { $$ = finish_compound_stmt (0, $<ttype>1); }\n \t;\n \n stmt:\n \t  compstmt\n-\t\t{ finish_stmt (); }\n+                {}\n \t| simple_stmt\n \t;\n \n simple_stmt:\n \t  decl\n \t\t{ finish_stmt (); }\n \t| expr ';'\n-\t\t{\n-\t\t  tree expr = $1;\n-\t\t  if (! processing_template_decl)\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      /* Do default conversion if safe and possibly important,\n-\t\t         in case within ({...}).  */\n-\t\t      if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t\t           && lvalue_p (expr))\n-\t\t          || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n-\t\t        expr = default_conversion (expr);\n-\t\t    }\n-\t\t  cplus_expand_expr_stmt (expr);\n-\t\t  clear_momentary ();\n-\t\t  finish_stmt (); }\n+                { finish_expr_stmt ($1); }\n \t| simple_if ELSE\n-\t\t{ if (! processing_template_decl) expand_start_else (); }\n+                { begin_else_clause (); }\n \t  implicitly_scoped_stmt\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>1, 2) = TREE_CHAIN ($<ttype>1);\n-\t\t      TREE_CHAIN ($<ttype>1) = NULL_TREE;\n-\t\t      last_tree = $<ttype>1;\n-\t\t    }\n-\t\t  else\n-\t\t    expand_end_cond ();\n+                { \n+\t\t  finish_else_clause ($<ttype>1); \n+\t\t  finish_if_stmt ();\n \t\t}\n-\t  .poplevel\n-\t\t{ finish_stmt (); }\n \t| simple_if  %prec IF\n-\t\t{ if (! processing_template_decl) expand_end_cond ();\n-\t\t  do_poplevel ();\n-\t\t  finish_stmt (); }\n+                { finish_if_stmt (); }\n \t| WHILE\n \t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_nop ();\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_start_loop (1); \n-\t\t    }\n+\t\t  $<ttype>$ = begin_while_stmt ();\n \t\t  cond_stmt_keyword = \"while\";\n \t\t}\n-\t  .pushlevel paren_cond_or_null\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      if (last_tree != $<ttype>2)\n-\t\t        {\n-\t\t\t  TREE_OPERAND ($<ttype>2, 0) = last_tree;\n-\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t\t  last_tree = $<ttype>2;\n-\t\t\t}\n-\t\t      else\n-\t\t        TREE_OPERAND ($<ttype>2, 0) = $4;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_exit_loop_if_false (0, $4);\n-\t\t    }\n-\n-\t\t  /* If the condition wasn't a declaration, clear out the\n-\t\t     block we made for it and start a new one here so the\n-\t\t     optimization in expand_end_loop will work.  */\n-\t\t  if (getdecls () == NULL_TREE)\n-\t\t    {\n-\t\t      do_poplevel ();\n-\t\t      do_pushlevel ();\n-\t\t    }\n-\t\t}\n-\t  already_scoped_stmt .poplevel\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  else\n-\t\t    expand_end_loop ();\n-\t\t  finish_stmt ();\n-\t\t}\n+\t  paren_cond_or_null\n+                { finish_while_stmt_cond ($3, $<ttype>2); }\n+\t  already_scoped_stmt\n+                { finish_while_stmt ($<ttype>2); }\n \t| DO\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_nop ();\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_start_loop_continue_elsewhere (1);\n-\t\t    }\n-\t\t}\n+                { $<ttype>$ = begin_do_stmt (); }\n \t  implicitly_scoped_stmt WHILE\n \t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      expand_loop_continue_here ();\n-\t\t      cond_stmt_keyword = \"do\";\n-\t\t    }\n+\t\t  finish_do_body ($<ttype>2);\n+\t\t  cond_stmt_keyword = \"do\";\n \t\t}\n \t  paren_expr_or_null ';'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    TREE_OPERAND ($<ttype>2, 1) = $6;\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_exit_loop_if_false (0, $6);\n-\t\t      expand_end_loop ();\n-\t\t    }\n-\t\t  clear_momentary ();\n-\t\t  finish_stmt ();\n-\t\t}\n+                { finish_do_stmt ($6, $<ttype>2); }\n \t| FOR\n-\t\t{ if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n-\t\t\t\t\t        NULL_TREE, NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-                  else\n-\t\t    emit_line_note (input_filename, lineno);\n-\t\t  if (flag_new_for_scope > 0)\n-\t\t    {\n-\t\t      /* Conditionalize .pushlevel */\n-\t\t      pushlevel (0);\n-\t\t      note_level_for_for ();\n-\t\t      clear_last_expr ();\n-\t\t      push_momentary ();\n-\t\t      expand_start_bindings (0);\n-\t\t    }\n-\t\t}\n+                { $<ttype>$ = begin_for_stmt (); }\n \t  '(' for.init.statement\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      if (last_tree != $<ttype>2)\n-\t\t\t{\n-\t\t\t  TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t\t  last_tree = $<ttype>2;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_nop ();\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_start_loop_continue_elsewhere (1); \n-\t\t    }\n-\t\t}\n-\t  .pushlevel xcond ';'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      if (last_tree != $<ttype>2)\n-\t\t        {\n-\t\t\t  TREE_OPERAND ($<ttype>2, 1) = last_tree;\n-\t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t\t  last_tree = $<ttype>2;\n-\t\t\t}\n-\t\t      else\n-\t\t        TREE_OPERAND ($<ttype>2, 1) = $7;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      if ($7) expand_exit_loop_if_false (0, $7);\n-\t\t    }\n-\n-\t\t  /* If the condition wasn't a declaration, clear out the\n-\t\t     block we made for it and start a new one here so the\n-\t\t     optimization in expand_end_loop will work.  */\n-\t\t  if (getdecls () == NULL_TREE)\n-\t\t    {\n-\t\t      do_poplevel ();\n-\t\t      do_pushlevel ();\n-\t\t    }\n-\t\t}\n+                { finish_for_init_stmt ($<ttype>2); }\n+\t  xcond ';'\n+                { finish_for_cond ($6, $<ttype>2); }\n \t  xexpr ')'\n-\t\t/* Don't let the tree nodes for $10 be discarded\n-\t\t   by clear_momentary during the parsing of the next stmt.  */\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    TREE_OPERAND ($<ttype>2, 2) = $10;\n-\t\t  push_momentary ();\n-\t\t}\n-\t  already_scoped_stmt .poplevel\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 3) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_loop_continue_here ();\n-\t\t      if ($10) cplus_expand_expr_stmt ($10);\n-\t\t      expand_end_loop ();\n-\t\t    }\n-\t\t  pop_momentary ();\n-\t\t  if (flag_new_for_scope > 0)\n-\t\t    {\n-\t\t      do_poplevel ();\n-\t\t    }\n-\t\t  finish_stmt (); }\n-\t| SWITCH .pushlevel '(' condition ')'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (SWITCH_STMT, $4, NULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      c_expand_start_case ($4);\n-\t\t    }\n-\t\t  push_switch ();\n-\t\t  /* Don't let the tree nodes for $4 be discarded by\n-\t\t     clear_momentary during the parsing of the next stmt.  */\n-\t\t  push_momentary ();\n-\t\t}\n+                { finish_for_expr ($9, $<ttype>2); }\n+\t  already_scoped_stmt\n+                { finish_for_stmt ($9, $<ttype>2); }\n+\t| SWITCH \n+                { begin_switch_stmt (); }\n+\t    '(' condition ')'\n+                { $<ttype>$ = finish_switch_cond ($4); }\n \t  implicitly_scoped_stmt\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>6, 1) = TREE_CHAIN ($<ttype>6);\n-\t\t      TREE_CHAIN ($<ttype>6) = NULL_TREE;\n-\t\t      last_tree = $<ttype>6;\n-\t\t    }\n-\t\t  else\n-\t\t    expand_end_case ($4);\n-\t\t  pop_momentary ();\n-\t\t  pop_switch (); \n-\t\t}\n-\t  .poplevel\n-\t\t{ finish_stmt (); }\n+                { finish_switch_stmt ($4, $<ttype>6); }\n \t| CASE expr_no_commas ':'\n-\t\t{ do_case ($2, NULL_TREE); }\n+                { finish_case_label ($2, NULL_TREE); }\n \t  stmt\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-\t\t{ do_case ($2, $4); }\n+                { finish_case_label ($2, $4); }\n \t  stmt\n \t| DEFAULT ':'\n-\t\t{ do_case (NULL_TREE, NULL_TREE); }\n+\t\t{ finish_case_label (NULL_TREE, NULL_TREE); }\n \t  stmt\n \t| BREAK ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if (processing_template_decl)\n-\t\t    add_tree (build_min_nt (BREAK_STMT));\n-\t\t  else if ( ! expand_exit_something ())\n-\t\t    error (\"break statement not within loop or switch\"); }\n+                { finish_break_stmt (); }\n \t| CONTINUE ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if (processing_template_decl)\n-\t\t    add_tree (build_min_nt (CONTINUE_STMT));\n-\t\t  else if (! expand_continue_loop (0))\n-\t\t    error (\"continue statement not within a loop\"); }\n+                { finish_continue_stmt (); }\n \t| RETURN ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  c_expand_return (NULL_TREE); }\n+                { finish_return_stmt (NULL_TREE); }\n \t| RETURN expr ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  c_expand_return ($2);\n-\t\t  finish_stmt ();\n-\t\t}\n+                { finish_return_stmt ($2); }\n \t| asm_keyword maybe_cv_qualifier '(' string ')' ';'\n-\t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_asm ($4);\n-\t\t  finish_stmt ();\n+\t\t{ \n+\t\t  finish_asm_stmt ($2, $4, NULL_TREE, NULL_TREE,\n+\t\t\t\t   NULL_TREE); \n \t\t}\n \t/* This is the case with just output operands.  */\n \t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ')' ';'\n-\t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno);\n-\t\t  finish_stmt ();\n+\t\t{ \n+\t\t  finish_asm_stmt ($2, $4, $6, NULL_TREE,\n+\t\t\t\t   NULL_TREE); \n \t\t}\n \t/* This is the case with input operands as well.  */\n \t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':' asm_operands ')' ';'\n-\t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno);\n-\t\t  finish_stmt ();\n-\t\t}\n+\t\t{ finish_asm_stmt ($2, $4, $6, $8, NULL_TREE); }\n \t/* This is the case with clobbered registers as well.  */\n \t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'\n \t  asm_operands ':' asm_clobbers ')' ';'\n-\t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  c_expand_asm_operands ($4, $6, $8, $10,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno);\n-\t\t  finish_stmt ();\n-\t\t}\n+\t\t{ finish_asm_stmt ($2, $4, $6, $8, $10); }\n \t| GOTO '*' expr ';'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    add_tree (build_min_nt (GOTO_STMT, $3));\n-\t\t  else\n-\t\t    { emit_line_note (input_filename, lineno);\n-\t\t      expand_computed_goto ($3); }\n+                { \n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n+\t\t  finish_goto_stmt ($3);\n \t\t}\n \t| GOTO identifier ';'\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    add_tree (build_min_nt (GOTO_STMT, $2));\n-\t\t  else\n-\t\t    {\n-\t\t      tree decl;\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      decl = lookup_label ($2);\n-\t\t      TREE_USED (decl) = 1;\n-\t\t      expand_goto (decl); \n-\t\t    }\n-\t\t}\n+                { finish_goto_stmt ($2); }\n \t| label_colon stmt\n \t\t{ finish_stmt (); }\n \t| label_colon '}'\n@@ -3951,41 +3610,11 @@ function_try_block:\n \n try_block:\n \t  TRY\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (TRY_BLOCK, NULL_TREE,\n-\t\t\t\t\t\tNULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      emit_line_note (input_filename, lineno);\n-\t\t      expand_start_try_stmts ();\n-\t\t    }\n-\t\t}\n+                { $<ttype>$ = begin_try_block (); }\n \t  compstmt\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  else\n-\t\t    expand_start_all_catch ();\n-\t\t}\n+                { finish_try_block ($<ttype>2); }\n \t  handler_seq\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  else\n-\t\t    expand_end_all_catch ();\n-\t\t}\n+                { finish_handler_sequence ($<ttype>2); }\n \t;\n \n handler_seq:\n@@ -3995,35 +3624,11 @@ handler_seq:\n \n handler:\n \t  CATCH\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      $<ttype>$ = build_min_nt (HANDLER, NULL_TREE,\n-\t\t\t\t\t\tNULL_TREE);\n-\t\t      add_tree ($<ttype>$);\n-\t\t    }\n-\t\t}\n-\t  .pushlevel handler_args\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t}\t  \n+                { $<ttype>$ = begin_handler(); }\n+          handler_args\n+                { finish_handler_parms ($<ttype>2); }\n \t  compstmt\n-\t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    {\n-\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n-\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n-\t\t      last_tree = $<ttype>2;\n-\t\t    }\n-\t\t  else\n-\t\t    expand_end_catch_block ();\n-\t\t}\t  \n-\t  .poplevel\n+                { finish_handler ($<ttype>2); }\n \t;\n \n type_specifier_seq:"}, {"sha": "865893e720e7ce02d62c2daedfc7e7069cb58cb1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 77, "deletions": 154, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -4690,24 +4690,14 @@ tsubst_expr (t, args, in_decl)\n     {\n     case RETURN_STMT:\n       lineno = TREE_COMPLEXITY (t);\n-      emit_line_note (input_filename, lineno);\n-      c_expand_return\n-\t(tsubst_expr (TREE_OPERAND (t, 0), args, in_decl));\n-      finish_stmt ();\n+      finish_return_stmt (tsubst_expr (RETURN_EXPR (t),\n+\t\t\t\t       args, in_decl));\n       break;\n \n     case EXPR_STMT:\n       lineno = TREE_COMPLEXITY (t);\n-      emit_line_note (input_filename, lineno);\n-      t = tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n-      /* Do default conversion if safe and possibly important,\n-\t in case within ({...}).  */\n-      if ((TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE && lvalue_p (t))\n-\t  || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-\tt = default_conversion (t);\n-      cplus_expand_expr_stmt (t);\n-      clear_momentary ();\n-      finish_stmt ();\n+      finish_expr_stmt (tsubst_expr (EXPR_STMT_EXPR (t),\n+\t\t\t\t     args, in_decl));\n       break;\n \n     case DECL_STMT:\n@@ -4731,184 +4721,117 @@ tsubst_expr (t, args, in_decl)\n     case FOR_STMT:\n       {\n \ttree tmp;\n-\tint init_scope = (flag_new_for_scope > 0 && TREE_OPERAND (t, 0)\n-\t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == DECL_STMT);\n-\tint cond_scope = (TREE_OPERAND (t, 1)\n-\t\t\t  && TREE_CODE (TREE_OPERAND (t, 1)) == DECL_STMT);\n-\n \tlineno = TREE_COMPLEXITY (t);\n-\temit_line_note (input_filename, lineno);\n-\tif (init_scope)\n-\t  do_pushlevel ();\n-\tfor (tmp = TREE_OPERAND (t, 0); tmp; tmp = TREE_CHAIN (tmp))\n-\t  tsubst_expr (tmp, args, in_decl);\n-\temit_nop ();\n-\temit_line_note (input_filename, lineno);\n-\texpand_start_loop_continue_elsewhere (1); \n-\n-\tif (cond_scope)\n-\t  do_pushlevel ();\n-\ttmp = tsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n-\temit_line_note (input_filename, lineno);\n-\tif (tmp)\n-\t  expand_exit_loop_if_false (0, condition_conversion (tmp));\n \n-\tif (! cond_scope)\n-\t  do_pushlevel ();\n-\ttsubst_expr (TREE_OPERAND (t, 3), args, in_decl);\n-\tdo_poplevel ();\n-\n-\temit_line_note (input_filename, lineno);\n-\texpand_loop_continue_here ();\n-\ttmp = tsubst_expr (TREE_OPERAND (t, 2), args, in_decl);\n-\tif (tmp)\n-\t  cplus_expand_expr_stmt (tmp);\n-\n-\texpand_end_loop ();\n-\tif (init_scope)\n-\t  do_poplevel ();\n-\tfinish_stmt ();\n+\tbegin_for_stmt ();\n+\tfor (tmp = FOR_INIT_STMT (t); tmp; tmp = TREE_CHAIN (tmp))\n+\t  tsubst_expr (tmp, args, in_decl);\n+\tfinish_for_init_stmt (NULL_TREE);\n+\tfinish_for_cond (tsubst_expr (FOR_COND (t), args,\n+\t\t\t\t      in_decl),\n+\t\t\t NULL_TREE);\n+\ttmp = tsubst_expr (FOR_EXPR (t), args, in_decl);\n+\tfinish_for_expr (tmp, NULL_TREE);\n+\ttsubst_expr (FOR_BODY (t), args, in_decl);\n+\tfinish_for_stmt (tmp, NULL_TREE);\n       }\n       break;\n \n     case WHILE_STMT:\n       {\n-\ttree cond;\n-\n \tlineno = TREE_COMPLEXITY (t);\n-\temit_nop ();\n-\temit_line_note (input_filename, lineno);\n-\texpand_start_loop (1); \n-\n-\tcond = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (cond) == DECL_STMT)\n-\t  do_pushlevel ();\n-\tcond = tsubst_expr (cond, args, in_decl);\n-\temit_line_note (input_filename, lineno);\n-\texpand_exit_loop_if_false (0, condition_conversion (cond));\n-\n-\tif (TREE_CODE (TREE_OPERAND (t, 0)) != DECL_STMT)\n-\t  do_pushlevel ();\n-\ttsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n-\tdo_poplevel ();\n-\n-\texpand_end_loop ();\n-\tfinish_stmt ();\n+\tbegin_while_stmt ();\n+\tfinish_while_stmt_cond (tsubst_expr (WHILE_COND (t),\n+\t\t\t\t\t     args, in_decl),\n+\t\t\t\tNULL_TREE);\n+\ttsubst_expr (WHILE_BODY (t), args, in_decl);\n+\tfinish_while_stmt (NULL_TREE);\n       }\n       break;\n \n     case DO_STMT:\n       {\n-\ttree cond;\n-\n \tlineno = TREE_COMPLEXITY (t);\n-\temit_nop ();\n-\temit_line_note (input_filename, lineno);\n-\texpand_start_loop_continue_elsewhere (1); \n-\n-\ttsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n-\texpand_loop_continue_here ();\n-\n-\tcond = tsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n-\temit_line_note (input_filename, lineno);\n-\texpand_exit_loop_if_false (0, condition_conversion (cond));\n-\texpand_end_loop ();\n-\n-\tclear_momentary ();\n-\tfinish_stmt ();\n+\tbegin_do_stmt ();\n+\ttsubst_expr (DO_BODY (t), args, in_decl);\n+\tfinish_do_body (NULL_TREE);\n+\tfinish_do_stmt (tsubst_expr (DO_COND (t), args,\n+\t\t\t\t     in_decl),\n+\t\t\tNULL_TREE);\n       }\n       break;\n \n     case IF_STMT:\n       {\n \ttree tmp;\n-\tint cond_scope = (TREE_CODE (TREE_OPERAND (t, 0)) == DECL_STMT);\n \n \tlineno = TREE_COMPLEXITY (t);\n-\tif (cond_scope)\n-\t  do_pushlevel ();\n-\ttmp = tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n-\temit_line_note (input_filename, lineno);\n-\texpand_start_cond (condition_conversion (tmp), 0);\n-\t\n-\tif (tmp = TREE_OPERAND (t, 1), tmp)\n-\t  tsubst_expr (tmp, args, in_decl);\n+\tbegin_if_stmt ();\n+\tfinish_if_stmt_cond (tsubst_expr (IF_COND (t),\n+\t\t\t\t\t  args, in_decl),\n+\t\t\t     NULL_TREE);\n \n-\tif (tmp = TREE_OPERAND (t, 2), tmp)\n+\tif (tmp = THEN_CLAUSE (t), tmp)\n \t  {\n-\t    expand_start_else ();\n \t    tsubst_expr (tmp, args, in_decl);\n+\t    finish_then_clause (NULL_TREE);\n \t  }\n \n-\texpand_end_cond ();\n-\n-\tif (cond_scope)\n-\t  do_poplevel ();\n+\tif (tmp = ELSE_CLAUSE (t), tmp)\n+\t  {\n+\t    begin_else_clause ();\n+\t    tsubst_expr (tmp, args, in_decl);\n+\t    finish_else_clause (NULL_TREE);\n+\t  }\n \n-\tfinish_stmt ();\n+\tfinish_if_stmt ();\n       }\n       break;\n \n     case COMPOUND_STMT:\n       {\n-\ttree substmt = TREE_OPERAND (t, 0);\n+\ttree substmt;\n \n \tlineno = TREE_COMPLEXITY (t);\n-\n-\tif (COMPOUND_STMT_NO_SCOPE (t) == 0)\n-\t  do_pushlevel ();\n-\n-\tfor (; substmt; substmt = TREE_CHAIN (substmt))\n+\tbegin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+\tfor (substmt = COMPOUND_BODY (t); \n+\t     substmt != NULL_TREE;\n+\t     substmt = TREE_CHAIN (substmt))\n \t  tsubst_expr (substmt, args, in_decl);\n-\n-\tif (COMPOUND_STMT_NO_SCOPE (t) == 0)\n-\t  return do_poplevel ();\n+\treturn finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n+\t\t\t\t     NULL_TREE);\n       }\n       break;\n \n     case BREAK_STMT:\n       lineno = TREE_COMPLEXITY (t);\n-      emit_line_note (input_filename, lineno);\n-      if (! expand_exit_something ())\n-\terror (\"break statement not within loop or switch\");\n+      finish_break_stmt ();\n       break;\n \n     case CONTINUE_STMT:\n       lineno = TREE_COMPLEXITY (t);\n-      emit_line_note (input_filename, lineno);\n-      if (! expand_continue_loop (0))\n-\terror (\"continue statement not within a loop\");\n+      finish_continue_stmt ();\n       break;\n \n     case SWITCH_STMT:\n       {\n \ttree val, tmp;\n-\tint cond_scope = (TREE_CODE (TREE_OPERAND (t, 0)) == DECL_STMT);\n \n \tlineno = TREE_COMPLEXITY (t);\n-\tif (cond_scope)\n-\t  do_pushlevel ();\n-\tval = tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n-\temit_line_note (input_filename, lineno);\n-\tc_expand_start_case (val);\n-\tpush_switch ();\n+\tbegin_switch_stmt ();\n+\tval = tsubst_expr (SWITCH_COND (t), args, in_decl);\n+\tfinish_switch_cond (val);\n \t\n \tif (tmp = TREE_OPERAND (t, 1), tmp)\n \t  tsubst_expr (tmp, args, in_decl);\n \n-\texpand_end_case (val);\n-\tpop_switch ();\n-\n-\tif (cond_scope)\n-\t  do_poplevel ();\n-\n-\tfinish_stmt ();\n+\tfinish_switch_stmt (val, NULL_TREE);\n       }\n       break;\n \n     case CASE_LABEL:\n-      do_case (tsubst_expr (TREE_OPERAND (t, 0), args, in_decl),\n-\t       tsubst_expr (TREE_OPERAND (t, 1), args, in_decl));\n+      finish_case_label (tsubst_expr (CASE_LOW (t), args, in_decl),\n+\t\t\t tsubst_expr (CASE_HIGH (t), args, in_decl));\n       break;\n \n     case LABEL_DECL:\n@@ -4920,47 +4843,47 @@ tsubst_expr (t, args, in_decl)\n \n     case GOTO_STMT:\n       lineno = TREE_COMPLEXITY (t);\n-      emit_line_note (input_filename, lineno);\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == IDENTIFIER_NODE)\n-\t{\n-\t  tree decl = lookup_label (TREE_OPERAND (t, 0));\n-\t  TREE_USED (decl) = 1;\n-\t  expand_goto (decl);\n-\t}\n-      else\n-\texpand_computed_goto\n-\t  (tsubst_expr (TREE_OPERAND (t, 0), args, in_decl));\n+      finish_goto_stmt (tsubst_expr (GOTO_DESTINATION (t),\n+\t\t\t\t     args, in_decl));\n+      break;\n+\n+    case ASM_STMT:\n+      lineno = TREE_COMPLEXITY (t);\n+      finish_asm_stmt (tsubst_expr (ASM_CV_QUAL (t), args, in_decl),\n+\t\t       tsubst_expr (ASM_STRING (t), args, in_decl),\n+\t\t       tsubst_expr (ASM_OUTPUTS (t), args, in_decl),\n+\t\t       tsubst_expr (ASM_INPUTS (t), args, in_decl), \n+\t\t       tsubst_expr (ASM_CLOBBERS (t), args, in_decl));\n       break;\n \n     case TRY_BLOCK:\n       lineno = TREE_COMPLEXITY (t);\n-      emit_line_note (input_filename, lineno);\n-      expand_start_try_stmts ();\n-      tsubst_expr (TREE_OPERAND (t, 0), args, in_decl);\n-      expand_start_all_catch ();\n+      begin_try_block ();\n+      tsubst_expr (TRY_STMTS (t), args, in_decl);\n+      finish_try_block (NULL_TREE);\n       {\n-\ttree handler = TREE_OPERAND (t, 1);\n+\ttree handler = TRY_HANDLERS (t);\n \tfor (; handler; handler = TREE_CHAIN (handler))\n \t  tsubst_expr (handler, args, in_decl);\n       }\n-      expand_end_all_catch ();\n+      finish_handler_sequence (NULL_TREE);\n       break;\n \n     case HANDLER:\n       lineno = TREE_COMPLEXITY (t);\n-      do_pushlevel ();\n-      if (TREE_OPERAND (t, 0))\n+      begin_handler ();\n+      if (HANDLER_PARMS (t))\n \t{\n-\t  tree d = TREE_OPERAND (t, 0);\n+\t  tree d = HANDLER_PARMS (t);\n \t  expand_start_catch_block\n \t    (tsubst (TREE_OPERAND (d, 1), args, in_decl),\n \t     tsubst (TREE_OPERAND (d, 0), args, in_decl));\n \t}\n       else\n \texpand_start_catch_block (NULL_TREE, NULL_TREE);\n-      tsubst_expr (TREE_OPERAND (t, 1), args, in_decl);\n-      expand_end_catch_block ();\n-      do_poplevel ();\n+      finish_handler_parms (NULL_TREE);\n+      tsubst_expr (HANDLER_BODY (t), args, in_decl);\n+      finish_handler (NULL_TREE);\n       break;\n \n     case TAG_DEFN:"}, {"sha": "f30224669554a80a94761bcfa581db378905906f", "filename": "gcc/cp/semantics.c", "status": "added", "additions": 748, "deletions": 0, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad3212931059fbf2c069c11851c587a4e86380b3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ad3212931059fbf2c069c11851c587a4e86380b3", "patch": "@@ -0,0 +1,748 @@\n+/* Perform the semantic phase of parsing, i.e., the process of\n+   building tree structure, checking semantic consistency, and\n+   building RTL.  These routines are used both during actual parsing\n+   and during the instantiation of template functions. \n+\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Written by Mark Mitchell (mmitchell@usa.net) based on code found\n+   formerly in parse.y and pt.c.  \n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"except.h\"\n+#include \"lex.h\"\n+\n+/* There routines provide a modular interface to perform many parsing\n+   operations.  They may therefore be used during actual parsing, or\n+   during template instantiation, which may be regarded as a\n+   degenerate form of parsing.  Since the current g++ parser is\n+   lacking in several respects, and will be reimplemented, we are\n+   attempting to move most code that is not directly related to\n+   parsing into this file; that will make implementing the new parser\n+   much easier since it will be able to make use of these routines.  */\n+\n+/* When parsing a template, LAST_TREE contains the last statement\n+   parsed.  These are chained together through the TREE_CHAIN field,\n+   but often need to be re-organized since the parse is performed\n+   bottom-up.  This macro makes LAST_TREE the indicated SUBSTMT of\n+   STMT.  */\n+\n+#define RECHAIN_STMTS(stmt, substmt, last)\t\\\n+  do {\t\t\t\t\t\t\\\n+    substmt = last;\t\t\t        \\\n+    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n+    last_tree = stmt;\t\t\t\t\\\n+  } while (0)\n+\n+#define RECHAIN_STMTS_FROM_LAST(stmt, substmt)\t\\\n+  RECHAIN_STMTS (stmt, substmt, last_tree)\n+\n+#define RECHAIN_STMTS_FROM_CHAIN(stmt, substmt)\t\\\n+  RECHAIN_STMTS (stmt, substmt, TREE_CHAIN (stmt))\n+\n+/* Finish an expression-statement, whose EXPRESSION is as indicated.  */\n+\n+void \n+finish_expr_stmt (expr)\n+     tree expr;\n+{\n+  if (!processing_template_decl)\n+    {\n+      emit_line_note (input_filename, lineno);\n+      /* Do default conversion if safe and possibly important,\n+\t in case within ({...}).  */\n+      if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+\t   && lvalue_p (expr))\n+\t  || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n+\texpr = default_conversion (expr);\n+    }\n+  \n+  cplus_expand_expr_stmt (expr);\n+  clear_momentary ();\n+  finish_stmt ();\n+}\n+\n+/* Begin an if-statement.  Returns a newly created IF_STMT if\n+   appropriate.  */\n+\n+tree\n+begin_if_stmt ()\n+{\n+  tree r;\n+\n+  if (processing_template_decl)\n+    {\n+      r = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+      add_tree (r);\n+    }\n+  else\n+    r = NULL_TREE;\n+\n+  do_pushlevel ();\n+\n+  return r;\n+}\n+\n+/* Process the COND of an if-statement, which may be given by\n+   IF_STMT.  */\n+\n+void \n+finish_if_stmt_cond (cond, if_stmt)\n+     tree cond;\n+     tree if_stmt;\n+{\n+  if (processing_template_decl)\n+    {\n+      if (last_tree != if_stmt)\n+\tRECHAIN_STMTS_FROM_LAST (if_stmt, IF_COND (if_stmt));\n+      else\n+\tIF_COND (if_stmt) = cond;\n+    }\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      expand_start_cond (condition_conversion (cond), 0);\n+    }\n+}\n+\n+/* Finish the then-clause of an if-statement, which may be given by\n+   IF_STMT.  */\n+\n+tree\n+finish_then_clause (if_stmt)\n+     tree if_stmt;\n+{\n+  if (processing_template_decl)\n+    {\n+      RECHAIN_STMTS_FROM_CHAIN (if_stmt, \n+\t\t\t\tTHEN_CLAUSE (if_stmt));\n+      last_tree = if_stmt;\n+      return if_stmt;\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Begin the else-clause of an if-statement.  */\n+\n+void \n+begin_else_clause ()\n+{\n+  if (!processing_template_decl)\n+    expand_start_else ();\n+}\n+\n+/* Finish the else-clause of an if-statement, which may be given by\n+   IF_STMT.  */\n+\n+void\n+finish_else_clause (if_stmt)\n+     tree if_stmt;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (if_stmt, ELSE_CLAUSE (if_stmt));\n+}\n+\n+/* Finsh an if-statement.  */\n+\n+void \n+finish_if_stmt ()\n+{\n+  if (!processing_template_decl)\n+    expand_end_cond ();\n+\n+  do_poplevel ();\n+  finish_stmt ();\n+}\n+\n+/* Begin a while-statement.  Returns a newly created WHILE_STMT if\n+   appropriate.  */\n+\n+tree\n+begin_while_stmt ()\n+{\n+  tree r;\n+\n+  if (processing_template_decl)\n+    {\n+      r = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n+      add_tree (r);\n+    }\n+  else\n+    {\n+      emit_nop ();\n+      emit_line_note (input_filename, lineno);\n+      expand_start_loop (1); \n+      r = NULL_TREE;\n+    }\n+\n+  do_pushlevel ();\n+\n+  return r;\n+}\n+\n+/* Process the COND of an if-statement, which may be given by\n+   WHILE_STMT.  */\n+\n+void \n+finish_while_stmt_cond (cond, while_stmt)\n+     tree cond;\n+     tree while_stmt;\n+{\n+  if (processing_template_decl)\n+    {\n+      if (last_tree != while_stmt)\n+\tRECHAIN_STMTS_FROM_LAST (while_stmt, \n+\t\t\t\t      WHILE_COND (while_stmt)); \n+      else\n+\tTREE_OPERAND (while_stmt, 0) = cond;\n+    }\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      expand_exit_loop_if_false (0, condition_conversion (cond));\n+    }\n+\n+  /* If COND wasn't a declaration, clear out the\n+     block we made for it and start a new one here so the\n+     optimization in expand_end_loop will work.  */\n+  if (getdecls () == NULL_TREE)\n+    {\n+      do_poplevel ();\n+      do_pushlevel ();\n+    }\n+}\n+\n+/* Finish a while-statement, which may be given by WHILE_STMT.  */\n+\n+void \n+finish_while_stmt (while_stmt)\n+     tree while_stmt;\n+{\n+  do_poplevel ();\n+\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (while_stmt, WHILE_BODY (while_stmt));\n+  else\n+    expand_end_loop ();\n+  finish_stmt ();\n+}\n+\n+/* Begin a do-statement.  Returns a newly created DO_STMT if\n+   appropriate.  */\n+\n+tree\n+begin_do_stmt ()\n+{\n+  if (processing_template_decl)\n+    {\n+      tree r = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n+      add_tree (r);\n+      return r;\n+    }\n+  else\n+    {\n+      emit_nop ();\n+      emit_line_note (input_filename, lineno);\n+      expand_start_loop_continue_elsewhere (1);\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Finish the body of a do-statement, which may be given by DO_STMT.  */\n+\n+void\n+finish_do_body (do_stmt)\n+     tree do_stmt;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (do_stmt, DO_BODY (do_stmt));\n+  else\n+    expand_loop_continue_here ();\n+}\n+\n+/* Finish a do-statement, which may be given by DO_STMT, and whose\n+   COND is as indicated.  */\n+\n+void\n+finish_do_stmt (cond, do_stmt)\n+     tree cond;\n+     tree do_stmt;\n+{\n+  if (processing_template_decl)\n+    DO_COND (do_stmt) = cond;\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      expand_exit_loop_if_false (0, condition_conversion (cond));\n+      expand_end_loop ();\n+    }\n+\n+  clear_momentary ();\n+  finish_stmt ();\n+}\n+\n+/* Finish a return-statement.  The EXPRESSION returned, if any, is as\n+   indicated.  */\n+\n+void\n+finish_return_stmt (expr)\n+     tree expr;\n+{\n+  emit_line_note (input_filename, lineno);\n+  c_expand_return (expr);\n+  finish_stmt ();\n+}\n+\n+/* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */\n+\n+tree\n+begin_for_stmt ()\n+{\n+  tree r;\n+\n+  if (processing_template_decl)\n+    {\n+      r = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n+\t\t\tNULL_TREE, NULL_TREE);\n+      add_tree (r);\n+    }\n+  else\n+    r = NULL_TREE;\n+\n+  if (flag_new_for_scope > 0)\n+    {\n+      do_pushlevel ();\n+      note_level_for_for ();\n+    }\n+\n+  return r;\n+}\n+\n+/* Finish the for-init-statement of a for-statement, which may be\n+   given by FOR_STMT.  */\n+\n+void\n+finish_for_init_stmt (for_stmt)\n+     tree for_stmt;\n+{\n+  if (processing_template_decl)\n+    {\n+      if (last_tree != for_stmt)\n+\tRECHAIN_STMTS_FROM_CHAIN (for_stmt, FOR_INIT_STMT (for_stmt));\n+    }\n+  else\n+    {\n+      emit_nop ();\n+      emit_line_note (input_filename, lineno);\n+      expand_start_loop_continue_elsewhere (1); \n+    }\n+\n+  do_pushlevel ();\n+}\n+\n+/* Finish the COND of a for-statement, which may be given by\n+   FOR_STMT.  */\n+\n+void\n+finish_for_cond (cond, for_stmt)\n+     tree cond;\n+     tree for_stmt;\n+{\n+  if (processing_template_decl)\n+    {\n+      if (last_tree != for_stmt)\n+\tRECHAIN_STMTS_FROM_LAST (for_stmt, FOR_COND (for_stmt));\n+      else\n+\tFOR_COND (for_stmt) = cond;\n+    }\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      if (cond) \n+\texpand_exit_loop_if_false (0, cond);\n+    }\n+  \n+  /* If the cond wasn't a declaration, clear out the\n+     block we made for it and start a new one here so the\n+     optimization in expand_end_loop will work.  */\n+  if (getdecls () == NULL_TREE)\n+    {\n+      do_poplevel ();\n+      do_pushlevel ();\n+    }  \n+}\n+\n+/* Finish the increment-EXPRESSION in a for-statement, which may be\n+   given by FOR_STMT.  */\n+\n+void\n+finish_for_expr (expr, for_stmt)\n+     tree expr;\n+     tree for_stmt;\n+{\n+  if (processing_template_decl)\n+    FOR_EXPR (for_stmt) = expr;\n+\n+  /* Don't let the tree nodes for EXPR be discarded\n+     by clear_momentary during the parsing of the next stmt.  */\n+  push_momentary ();\n+}\n+\n+/* Finish the body of a for-statement, which may be given by\n+   FOR_STMT.  The increment-EXPR for the loop must be\n+   provided.  */\n+\n+void\n+finish_for_stmt (expr, for_stmt)\n+     tree expr;\n+     tree for_stmt;\n+{\n+  /* Pop the scope for the body of the loop.  */\n+  do_poplevel ();\n+\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (for_stmt, FOR_BODY (for_stmt));\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      expand_loop_continue_here ();\n+      if (expr) \n+\tcplus_expand_expr_stmt (expr);\n+      expand_end_loop ();\n+    }\n+\n+  pop_momentary ();\n+\n+  if (flag_new_for_scope > 0)\n+    do_poplevel ();\n+\n+  finish_stmt (); \n+}\n+\n+/* Finish a break-statement.  */\n+\n+void\n+finish_break_stmt ()\n+{\n+  emit_line_note (input_filename, lineno);\n+  if (processing_template_decl)\n+    add_tree (build_min_nt (BREAK_STMT));\n+  else if ( ! expand_exit_something ())\n+    cp_error (\"break statement not within loop or switch\");\n+}\n+\n+/* Finish a continue-statement.  */\n+\n+void\n+finish_continue_stmt ()\n+{\n+  emit_line_note (input_filename, lineno);\n+  if (processing_template_decl)\n+    add_tree (build_min_nt (CONTINUE_STMT));\n+  else if (! expand_continue_loop (0))\n+    cp_error (\"continue statement not within a loop\");   \n+}\n+\n+/* Begin a switch-statement.  */\n+\n+void\n+begin_switch_stmt ()\n+{\n+  do_pushlevel ();\n+}\n+\n+/* Finish the cond of a switch-statement.  Returns a new\n+   SWITCH_STMT if appropriate.  */ \n+\n+tree\n+finish_switch_cond (cond)\n+     tree cond;\n+{\n+  tree r;\n+\n+  if (processing_template_decl)\n+    {\n+      r = build_min_nt (SWITCH_STMT, cond, NULL_TREE);\n+      add_tree (r);\n+    }\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      c_expand_start_case (cond);\n+      r = NULL_TREE;\n+    }\n+  push_switch ();\n+\n+  /* Don't let the tree nodes for COND be discarded by\n+     clear_momentary during the parsing of the next stmt.  */\n+  push_momentary ();\n+\n+  return r;\n+}\n+\n+/* Finish the body of a switch-statement, which may be given by\n+   SWITCH_STMT.  The COND to switch on is indicated.  */\n+\n+void\n+finish_switch_stmt (cond, switch_stmt)\n+     tree cond;\n+     tree switch_stmt;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (switch_stmt, SWITCH_BODY (switch_stmt));\n+  else\n+    expand_end_case (cond);\n+  pop_momentary ();\n+  pop_switch (); \n+  do_poplevel ();\n+  finish_stmt ();\n+}\n+\n+/* Finish a case-label.  */\n+\n+void \n+finish_case_label (low_value, high_value)\n+     tree low_value;\n+     tree high_value;\n+{\n+  do_case (low_value, high_value);\n+}\n+\n+\n+/* Finish a goto-statement.  */\n+\n+void\n+finish_goto_stmt (destination)\n+     tree destination;\n+{\n+  if (processing_template_decl)\n+    add_tree (build_min_nt (GOTO_STMT, destination));\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+\n+      if (TREE_CODE (destination) == IDENTIFIER_NODE)\n+\t{\n+\t  tree decl = lookup_label (destination);\n+\t  TREE_USED (decl) = 1;\n+\t  expand_goto (decl); \n+\t}\n+      else\n+\texpand_computed_goto (destination);\n+    }\n+}\n+\n+/* Begin a try-block.  Returns a newly-created TRY_BLOCK if\n+   appropriate.  */\n+\n+tree\n+begin_try_block ()\n+{\n+  if (processing_template_decl)\n+    {\n+      tree r = build_min_nt (TRY_BLOCK, NULL_TREE,\n+\t\t\t     NULL_TREE);\n+      add_tree (r);\n+      return r;\n+    }\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      expand_start_try_stmts ();\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Finish a try-block, which may be given by TRY_BLOCK.  */\n+\n+void\n+finish_try_block (try_block)\n+     tree try_block;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_LAST (try_block, TRY_STMTS (try_block));\n+  else\n+    expand_start_all_catch ();  \n+}\n+\n+/* Finish a handler-sequence for a try-block, which may be given by\n+   TRY_BLOCK.  */\n+\n+void\n+finish_handler_sequence (try_block)\n+     tree try_block;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (try_block, TRY_HANDLERS (try_block));\n+  else\n+    expand_end_all_catch ();\n+}\n+\n+/* Begin a handler.  Returns a HANDLER if appropriate.  */\n+\n+tree\n+begin_handler ()\n+{\n+  tree r;\n+\n+  if (processing_template_decl)\n+    {\n+      r = build_min_nt (HANDLER, NULL_TREE, NULL_TREE);\n+      add_tree (r);\n+    }\n+  else\n+    r = NULL_TREE;\n+\n+  do_pushlevel ();\n+\n+  return r;\n+}\n+\n+/* Finish the handler-parameters for a handler, which may be given by\n+   HANDLER.  */\n+\n+void\n+finish_handler_parms (handler)\n+     tree handler;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (handler, HANDLER_PARMS (handler));\n+}\n+\n+/* Finish a handler, which may be given by HANDLER.  */\n+\n+void\n+finish_handler (handler)\n+     tree handler;\n+{\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (handler, HANDLER_BODY (handler));\n+  else\n+    expand_end_catch_block ();\n+\n+  do_poplevel ();\n+}\n+\n+/* Begin a compound-statement.  If HAS_NO_SCOPE is non-zero, the\n+   compound-statement does not define a scope.  Returns a new\n+   COMPOUND_STMT if appropriate.  */\n+\n+tree\n+begin_compound_stmt (has_no_scope)\n+     int has_no_scope;\n+{\n+  tree r; \n+\n+  if (processing_template_decl)\n+    {\n+      r = build_min_nt (COMPOUND_STMT, NULL_TREE);\n+      add_tree (r);\n+      if (has_no_scope)\n+\tCOMPOUND_STMT_NO_SCOPE (r) = 1;\n+    }\n+  else\n+    r = NULL_TREE;\n+\n+  if (!has_no_scope)\n+    do_pushlevel ();\n+\n+  return r;\n+}\n+\n+\n+/* Finish a compound-statement, which may be given by COMPOUND_STMT.\n+   If HAS_NO_SCOPE is non-zero, the compound statement does not define\n+   a scope.  */\n+\n+tree\n+finish_compound_stmt (has_no_scope, compound_stmt)\n+     int has_no_scope;\n+     tree compound_stmt;\n+{\n+  tree r;\n+\n+  if (!has_no_scope)\n+    r = do_poplevel ();\n+  else\n+    r = NULL_TREE;\n+\n+  if (processing_template_decl)\n+    RECHAIN_STMTS_FROM_CHAIN (compound_stmt, \n+\t\t\t      COMPOUND_BODY (compound_stmt));\n+\n+  finish_stmt ();\n+\n+  return r;\n+}\n+\n+/* Finish an asm-statement, whose components are a CV_QUALIFIER, a\n+   STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some\n+   CLOBBERS.  */\n+\n+void\n+finish_asm_stmt (cv_qualifier, string, output_operands,\n+\t\t      input_operands, clobbers)\n+     tree cv_qualifier;\n+     tree string;\n+     tree output_operands;\n+     tree input_operands;\n+     tree clobbers;\n+{\n+  if (TREE_CHAIN (string))\n+    combine_strings (string);\n+\n+  if (processing_template_decl)\n+    {\n+      tree r = build_min_nt (ASM_STMT, cv_qualifier, string,\n+\t\t\t     output_operands, input_operands,\n+\t\t\t     clobbers);\n+      add_tree (r);\n+    }\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      if (output_operands != NULL_TREE)\n+\t{\n+\t  if (cv_qualifier != NULL_TREE\n+\t      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n+\t    cp_warning (\"%s qualifier ignored on asm\",\n+\t\t\tIDENTIFIER_POINTER (cv_qualifier));\n+\t    \n+\t  c_expand_asm_operands (string, output_operands,\n+\t\t\t\t input_operands, \n+\t\t\t\t clobbers,\n+\t\t\t\t cv_qualifier \n+\t\t\t\t == ridpointers[(int) RID_VOLATILE],\n+\t\t\t\t input_filename, lineno);\n+\t}\n+      else\n+\t{\n+\t  if (cv_qualifier != NULL_TREE)\n+\t    cp_warning (\"%s qualifier ignored on asm\",\n+\t\t\tIDENTIFIER_POINTER (cv_qualifier));\n+\t  expand_asm (string);\n+\t}\n+\n+      finish_stmt ();\n+    }\n+}"}]}