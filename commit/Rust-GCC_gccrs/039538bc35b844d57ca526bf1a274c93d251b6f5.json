{"sha": "039538bc35b844d57ca526bf1a274c93d251b6f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM5NTM4YmMzNWI4NDRkNTdjYTUyNmJmMWEyNzRjOTNkMjUxYjZmNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-30T11:34:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-30T11:34:41Z"}, "message": "[multiple changes]\n\n2014-10-30  Yannick Moy  <moy@adacore.com>\n\n\t* inline.adb (Has_Single_Return_In_GNATprove_Mode):\n\tReturn False when return statement is inside one or more blocks.\n\n2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Is_Subprogram_Call): Account for the case where an\n\tobject declaration initialized by a function call that returns\n\tan unconstrained result may be rewritted as a renaming of the\n\tsecondary stack result.\n\n2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry for aspect Extensions_Visible in\n\ttable Canonical_Aspect.\n\t* aspects.ads: Add entry for aspect Extensions_Visible in\n\ttables Aspect_Argument, Aspect_Delay, Aspect_Id, Aspect_Names,\n\tImplementation_Defined_Aspect.\n\t* einfo.adb (Get_Pragma): Include pragma Extensions_Visible in\n\tthe list of contract pragmas.\n\t* par-prag.adb Pragma Extensions_Visible does not require special\n\tprocessing from the parser.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Prevent an\n\timplicit class-wide conversion of a formal parameter\n\tof a specific tagged type whose related subprogram is\n\tsubject to pragma Extensions_Visible with value \"False\".\n\t(Check_Abstract_Overriding): Add various overriding checks\n\trelated to pragma Extensions_Visible.\n\t(Derive_Subprogram):\n\tA subprogram subject to pragma Extensions_Visible with value\n\tFalse requires overriding if the subprogram has at least one\n\tcontrolling OUT parameter.\n\t(Is_EVF_Procedure): New routine.\n\t* sem_ch4.adb (Analyze_Type_Conversion): A formal parameter of\n\ta specific tagged type whose related subprogram is subject to\n\tpragma Extensions_Visible with value \"False\" cannot appear in\n\ta class-wide conversion.\n\t* sem_ch6.adb (Analyze_Subprogram_Contract): Remove\n\tthe assertion to account for pragma Extensions_Visible.\n\t(Check_Overriding_Indicator): An overriding subprogram\n\tinherits the contact of the overridden subprogram.\n\t(New_Overloaded_Entity): An overriding subprogram inherits the\n\tcontact of the overridden subprogram.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Extensions_Visible.\n\t(Check_Aspect_At_Freeze_Point): Aspect Extensions_Visible does not\n\trequire special processing at the freeze point.\n\t* sem_prag.adb Add an entry for pragma Extensions_Visible in\n\ttable Sig_Flags.\n\t(Analyze_Pragma): Ensure that various SPARK\n\tpragmas lack identifiers in their arguments. Add processing for\n\tpragma Extensions_Visible.\n\t(Chain_CTC): Code reformatting.\n\t* sem_res.adb (Resolve_Actuals): A formal parameter of a\n\tspecific tagged type whose related subprogram is subject to\n\tpragma Extensions_Visible with value \"False\" cannot act as an\n\tactual in a subprogram with value \"True\".\n\t* sem_util.adb (Add_Classification): New routine.\n\t(Add_Contract_Item): Account for pragma Extensions_Visible. Code\n\treformatting.\n\t(Add_Contract_Test_Case): New routine.\n\t(Add_Pre_Post_Condition): New routine.\n\t(Extensions_Visible_Status): New routine.\n\t(Inherit_Subprogram_Contract): New routine.\n\t(Is_EVF_Expression): New routine.\n\t(Is_Specific_Tagged_Type): New routine.\n\t* sem_util.ads Add type Extensions_Visible_Mode and document all values.\n\t(Add_Contract_Item): Add pragma Extensions_Visible to the\n\tcomment on usage.\n\t(Inherit_Subprogram_Contract): New routine.\n\t(Is_EVF_Expression): New routine.\n\t(Is_Specific_Tagged_Type): New routine.\n\t* sinfo.adb (Is_Inherited): New routine.\n\t(Set_Is_Inherited): New routine.\n\t* sinfo.ads Add flag Is_Inherited along with its usage in\n\tnodes.\n\t(Is_Inherited): New routine along with pragma Inline.\n\t(Set_Is_Inherited): New routine along with pragma Inline.\n\t* snames.ads-tmpl: Add predefined name \"Extensions_Visible\"\n\tand a new Pragma_Id for the pragma.\n\nFrom-SVN: r216919", "tree": {"sha": "ae3d2ce7780de669626aac1dfe56ce4ac6df7aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae3d2ce7780de669626aac1dfe56ce4ac6df7aaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/039538bc35b844d57ca526bf1a274c93d251b6f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039538bc35b844d57ca526bf1a274c93d251b6f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039538bc35b844d57ca526bf1a274c93d251b6f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039538bc35b844d57ca526bf1a274c93d251b6f5/comments", "author": null, "committer": null, "parents": [{"sha": "67848724e5d99bd27d69fc63b211658995aa9437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67848724e5d99bd27d69fc63b211658995aa9437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67848724e5d99bd27d69fc63b211658995aa9437"}], "stats": {"total": 1005, "additions": 869, "deletions": 136}, "files": [{"sha": "65e0b602754273ec98df72b53ac8c4b0984a5b27", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -1,3 +1,135 @@\n+2014-10-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* inline.adb (Has_Single_Return_In_GNATprove_Mode):\n+\tReturn False when return statement is inside one or more blocks.\n+\n+2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Is_Subprogram_Call): Account for the case where an\n+\tobject declaration initialized by a function call that returns\n+\tan unconstrained result may be rewritted as a renaming of the\n+\tsecondary stack result.\n+\n+2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry for aspect Extensions_Visible in\n+\ttable Canonical_Aspect.\n+\t* aspects.ads: Add entry for aspect Extensions_Visible in\n+\ttables Aspect_Argument, Aspect_Delay, Aspect_Id, Aspect_Names,\n+\tImplementation_Defined_Aspect.\n+\t* einfo.adb (Get_Pragma): Include pragma Extensions_Visible in\n+\tthe list of contract pragmas.\n+\t* par-prag.adb Pragma Extensions_Visible does not require special\n+\tprocessing from the parser.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Prevent an\n+\timplicit class-wide conversion of a formal parameter\n+\tof a specific tagged type whose related subprogram is\n+\tsubject to pragma Extensions_Visible with value \"False\".\n+\t(Check_Abstract_Overriding): Add various overriding checks\n+\trelated to pragma Extensions_Visible.\n+\t(Derive_Subprogram):\n+\tA subprogram subject to pragma Extensions_Visible with value\n+\tFalse requires overriding if the subprogram has at least one\n+\tcontrolling OUT parameter.\n+\t(Is_EVF_Procedure): New routine.\n+\t* sem_ch4.adb (Analyze_Type_Conversion): A formal parameter of\n+\ta specific tagged type whose related subprogram is subject to\n+\tpragma Extensions_Visible with value \"False\" cannot appear in\n+\ta class-wide conversion.\n+\t* sem_ch6.adb (Analyze_Subprogram_Contract): Remove\n+\tthe assertion to account for pragma Extensions_Visible.\n+\t(Check_Overriding_Indicator): An overriding subprogram\n+\tinherits the contact of the overridden subprogram.\n+\t(New_Overloaded_Entity): An overriding subprogram inherits the\n+\tcontact of the overridden subprogram.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Extensions_Visible.\n+\t(Check_Aspect_At_Freeze_Point): Aspect Extensions_Visible does not\n+\trequire special processing at the freeze point.\n+\t* sem_prag.adb Add an entry for pragma Extensions_Visible in\n+\ttable Sig_Flags.\n+\t(Analyze_Pragma): Ensure that various SPARK\n+\tpragmas lack identifiers in their arguments. Add processing for\n+\tpragma Extensions_Visible.\n+\t(Chain_CTC): Code reformatting.\n+\t* sem_res.adb (Resolve_Actuals): A formal parameter of a\n+\tspecific tagged type whose related subprogram is subject to\n+\tpragma Extensions_Visible with value \"False\" cannot act as an\n+\tactual in a subprogram with value \"True\".\n+\t* sem_util.adb (Add_Classification): New routine.\n+\t(Add_Contract_Item): Account for pragma Extensions_Visible. Code\n+\treformatting.\n+\t(Add_Contract_Test_Case): New routine.\n+\t(Add_Pre_Post_Condition): New routine.\n+\t(Extensions_Visible_Status): New routine.\n+\t(Inherit_Subprogram_Contract): New routine.\n+\t(Is_EVF_Expression): New routine.\n+\t(Is_Specific_Tagged_Type): New routine.\n+\t* sem_util.ads Add type Extensions_Visible_Mode and document all values.\n+\t(Add_Contract_Item): Add pragma Extensions_Visible to the\n+\tcomment on usage.\n+\t(Inherit_Subprogram_Contract): New routine.\n+\t(Is_EVF_Expression): New routine.\n+\t(Is_Specific_Tagged_Type): New routine.\n+\t* sinfo.adb (Is_Inherited): New routine.\n+\t(Set_Is_Inherited): New routine.\n+\t* sinfo.ads Add flag Is_Inherited along with its usage in\n+\tnodes.\n+\t(Is_Inherited): New routine along with pragma Inline.\n+\t(Set_Is_Inherited): New routine along with pragma Inline.\n+\t* snames.ads-tmpl: Add predefined name \"Extensions_Visible\"\n+\tand a new Pragma_Id for the pragma.\n+\n+2014-10-30  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-proc.adb (Process_Case_Construction): Do not look for\n+\tthe ultimate extending project for a case variable.\n+\n+2014-10-30  Pierre-Marie Derodat  <derodat@adacore.com>\n+\n+\t* exp_dbug.adb, opt.ads (GNAT_Encodings): Import from C. Define\n+\tenumerators.\n+\t(gnat_encodings): Define a dummy variable for the AAMP back-end.\n+\t(Get_Encoded_Name): When -fgnat-encodings=all|gdb, encode names\n+\tfor all discrete types whose bounds do not match size and do so\n+\tonly for biased types when -fgnat-encodings=minimal.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not create ___XA\n+\tparallel types when array bounds are constant while the lower bound is\n+        not 1.  Also stop generating them because the bound type is\n+        larger than sizetype.\n+\t* gcc-interface/misc.c (gnat_encodings): New.\n+\n+2014-10-30  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* opt.adb (Set_Opt_Config_Switches): For an internal unit,\n+\talways reset Default_SSO to ' '.\n+\n+2014-10-30  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb (Freeze_Record_Type): Set SSO from default before\n+\tchecking SSO consistency.\n+\n+2014-10-30  Javier Miranda  <miranda@adacore.com>\n+\n+\t* inline.adb (Check_Package_Body_For_Inlining):\n+\tCleanup this subprogram to implement exactly the behavior\n+\tdocumented in the spec.\n+\n+2014-10-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-comutr.adb, a-cimutr.adb (Insert_Child): Add new variable First.\n+\tUpdate the position after all insertions have taken place.\n+\n+2014-10-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case License): Do not perform\n+\tanalysis of pragma arguments when in CodePeer mode, pragma has\n+\tdifferent format on other compilers.\n+\n+2014-10-30  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-os_lib.adb: Minor reformatting.\n+\n 2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc-interface/decl.c, gcc-interface/gigi.h, gcc-interface/misc.c,"}, {"sha": "ee8e8b831c8fc7e1b461663bc3db53051fe91548", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -522,6 +522,7 @@ package body Aspects is\n     Aspect_Effective_Writes             => Aspect_Effective_Writes,\n     Aspect_Elaborate_Body               => Aspect_Elaborate_Body,\n     Aspect_Export                       => Aspect_Export,\n+    Aspect_Extensions_Visible           => Aspect_Extensions_Visible,\n     Aspect_External_Name                => Aspect_External_Name,\n     Aspect_External_Tag                 => Aspect_External_Tag,\n     Aspect_Favor_Top_Level              => Aspect_Favor_Top_Level,"}, {"sha": "50bada041f0f3e0e32ae9ef7dc3ab6037f4bd75b", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -94,6 +94,7 @@ package Aspects is\n       Aspect_Dimension_System,              -- GNAT\n       Aspect_Dispatching_Domain,\n       Aspect_Dynamic_Predicate,\n+      Aspect_Extensions_Visible,            -- GNAT\n       Aspect_External_Name,\n       Aspect_External_Tag,\n       Aspect_Global,                        -- GNAT\n@@ -230,6 +231,7 @@ package Aspects is\n       Aspect_Dimension_System         => True,\n       Aspect_Effective_Reads          => True,\n       Aspect_Effective_Writes         => True,\n+      Aspect_Extensions_Visible       => True,\n       Aspect_Favor_Top_Level          => True,\n       Aspect_Global                   => True,\n       Aspect_Inline_Always            => True,\n@@ -318,6 +320,7 @@ package Aspects is\n       Aspect_Dimension_System          => Expression,\n       Aspect_Dispatching_Domain        => Expression,\n       Aspect_Dynamic_Predicate         => Expression,\n+      Aspect_Extensions_Visible        => Optional_Expression,\n       Aspect_External_Name             => Expression,\n       Aspect_External_Tag              => Expression,\n       Aspect_Global                    => Expression,\n@@ -408,9 +411,10 @@ package Aspects is\n       Aspect_Effective_Reads              => Name_Effective_Reads,\n       Aspect_Effective_Writes             => Name_Effective_Writes,\n       Aspect_Elaborate_Body               => Name_Elaborate_Body,\n+      Aspect_Export                       => Name_Export,\n+      Aspect_Extensions_Visible           => Name_Extensions_Visible,\n       Aspect_External_Name                => Name_External_Name,\n       Aspect_External_Tag                 => Name_External_Tag,\n-      Aspect_Export                       => Name_Export,\n       Aspect_Favor_Top_Level              => Name_Favor_Top_Level,\n       Aspect_Global                       => Name_Global,\n       Aspect_Implicit_Dereference         => Name_Implicit_Dereference,\n@@ -618,9 +622,9 @@ package Aspects is\n       Aspect_Dispatching_Domain           => Always_Delay,\n       Aspect_Dynamic_Predicate            => Always_Delay,\n       Aspect_Elaborate_Body               => Always_Delay,\n+      Aspect_Export                       => Always_Delay,\n       Aspect_External_Name                => Always_Delay,\n       Aspect_External_Tag                 => Always_Delay,\n-      Aspect_Export                       => Always_Delay,\n       Aspect_Favor_Top_Level              => Always_Delay,\n       Aspect_Implicit_Dereference         => Always_Delay,\n       Aspect_Import                       => Always_Delay,\n@@ -689,6 +693,7 @@ package Aspects is\n       Aspect_Dimension_System             => Never_Delay,\n       Aspect_Effective_Reads              => Never_Delay,\n       Aspect_Effective_Writes             => Never_Delay,\n+      Aspect_Extensions_Visible           => Never_Delay,\n       Aspect_Global                       => Never_Delay,\n       Aspect_Initial_Condition            => Never_Delay,\n       Aspect_Initializes                  => Never_Delay,"}, {"sha": "aaa6ea5f0606d2fc525d5f41e00181d5c7bdad3e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -6684,31 +6684,32 @@ package body Einfo is\n \n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n       Is_CDG  : constant Boolean :=\n-                  Id = Pragma_Abstract_State    or else\n-                  Id = Pragma_Async_Readers     or else\n-                  Id = Pragma_Async_Writers     or else\n-                  Id = Pragma_Depends           or else\n-                  Id = Pragma_Effective_Reads   or else\n-                  Id = Pragma_Effective_Writes  or else\n-                  Id = Pragma_Global            or else\n-                  Id = Pragma_Initial_Condition or else\n-                  Id = Pragma_Initializes       or else\n-                  Id = Pragma_Part_Of           or else\n-                  Id = Pragma_Refined_Depends   or else\n-                  Id = Pragma_Refined_Global    or else\n+                  Id = Pragma_Abstract_State     or else\n+                  Id = Pragma_Async_Readers      or else\n+                  Id = Pragma_Async_Writers      or else\n+                  Id = Pragma_Depends            or else\n+                  Id = Pragma_Effective_Reads    or else\n+                  Id = Pragma_Effective_Writes   or else\n+                  Id = Pragma_Extensions_Visible or else\n+                  Id = Pragma_Global             or else\n+                  Id = Pragma_Initial_Condition  or else\n+                  Id = Pragma_Initializes        or else\n+                  Id = Pragma_Part_Of            or else\n+                  Id = Pragma_Refined_Depends    or else\n+                  Id = Pragma_Refined_Global     or else\n                   Id = Pragma_Refined_State;\n       Is_CTC : constant Boolean :=\n-                  Id = Pragma_Contract_Cases    or else\n+                  Id = Pragma_Contract_Cases     or else\n                   Id = Pragma_Test_Case;\n       Is_PPC : constant Boolean :=\n-                  Id = Pragma_Precondition      or else\n-                  Id = Pragma_Postcondition     or else\n+                  Id = Pragma_Precondition       or else\n+                  Id = Pragma_Postcondition      or else\n                   Id = Pragma_Refined_Post;\n \n       In_Contract : constant Boolean := Is_CDG or Is_CTC or Is_PPC;\n \n-      Item   : Node_Id;\n-      Items  : Node_Id;\n+      Item  : Node_Id;\n+      Items : Node_Id;\n \n    begin\n       --  Handle pragmas that appear in N_Contract nodes. Those have to be"}, {"sha": "8d5dd36aee864b504a1831698f5f7d6194bad13f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -4532,11 +4532,14 @@ package body Exp_Ch7 is\n          function Is_Subprogram_Call (N : Node_Id) return Traverse_Result is\n          begin\n             --  Complex constructs are factored out by the expander and their\n-            --  occurrences are replaced with references to temporaries. Due to\n-            --  this expansion activity, inspect the original tree to detect\n-            --  subprogram calls.\n+            --  occurrences are replaced with references to temporaries or\n+            --  object renamings. Due to this expansion activity, inspect the\n+            --  original tree to detect subprogram calls.\n \n-            if Nkind (N) = N_Identifier and then Original_Node (N) /= N then\n+            if Nkind_In (N, N_Identifier,\n+                            N_Object_Renaming_Declaration)\n+              and then Original_Node (N) /= N\n+            then\n                Detect_Subprogram_Call (Original_Node (N));\n \n                --  The original construct contains a subprogram call, there is"}, {"sha": "8e2df38468f033f292516ec17503d1b0d868fe8b", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -933,7 +933,10 @@ package body Inline is\n       function Has_Single_Return_In_GNATprove_Mode return Boolean;\n       --  This function is called only in GNATprove mode, and it returns\n       --  True if the subprogram has no return statement or a single return\n-      --  statement as last statement.\n+      --  statement as last statement. It returns False for subprogram with\n+      --  a single return as last statement inside one or more blocks, as\n+      --  inlining would generate gotos in that case as well (although the\n+      --  goto is useless in that case).\n \n       function Uses_Secondary_Stack (Bod : Node_Id) return Boolean;\n       --  If the body of the subprogram includes a call that returns an\n@@ -1003,15 +1006,10 @@ package body Inline is\n       --  Start of processing for Has_Single_Return_In_GNATprove_Mode\n \n       begin\n-         --  Retrieve last statement inside possible block statements\n+         --  Retrieve the last statement\n \n          Last_Statement := Last (Statements (Handled_Statement_Sequence (N)));\n \n-         while Nkind (Last_Statement) = N_Block_Statement loop\n-            Last_Statement :=\n-              Last (Statements (Handled_Statement_Sequence (Last_Statement)));\n-         end loop;\n-\n          --  Check that the last statement is the only possible return\n          --  statement in the subprogram.\n \n@@ -2049,16 +2047,15 @@ package body Inline is\n       OK    : Boolean;\n \n    begin\n-      if Is_Compilation_Unit (P)\n+      if Front_End_Inlining\n+        and then Is_Compilation_Unit (P)\n         and then not Is_Generic_Instance (P)\n       then\n          Bname := Get_Body_Name (Get_Unit_Name (Unit (N)));\n \n          E := First_Entity (P);\n          while Present (E) loop\n-            if Has_Pragma_Inline_Always (E)\n-              or else (Front_End_Inlining and then Has_Pragma_Inline (E))\n-            then\n+            if Has_Pragma_Inline (E) then\n                if not Is_Loaded (Bname) then\n                   Load_Needed_Body (N, OK);\n "}, {"sha": "7bf57290ca5ebd8fff61ddca44212a4157b9f4ea", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -1220,6 +1220,7 @@ begin\n            Pragma_Export_Value                   |\n            Pragma_Export_Valued_Procedure        |\n            Pragma_Extend_System                  |\n+           Pragma_Extensions_Visible             |\n            Pragma_External                       |\n            Pragma_External_Name_Casing           |\n            Pragma_Favor_Top_Level                |"}, {"sha": "2546533432ca5e04359a7980cc48582e6c383197", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -2256,6 +2256,21 @@ package body Sem_Ch13 is\n                   Insert_Pragma (Aitem);\n                   goto Continue;\n \n+               --  Aspect Extensions_Visible is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related subprogram.\n+\n+               when Aspect_Extensions_Visible =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Extensions_Visible);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Global\n \n                --  Aspect Global is never delayed because it is equivalent to\n@@ -8817,6 +8832,7 @@ package body Sem_Ch13 is\n               Aspect_Default_Initial_Condition |\n               Aspect_Dimension                 |\n               Aspect_Dimension_System          |\n+              Aspect_Extensions_Visible        |\n               Aspect_Implicit_Dereference      |\n               Aspect_Initial_Condition         |\n               Aspect_Initializes               |"}, {"sha": "78b4697b6b349952e971de1e991918adf894f241", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -590,6 +590,12 @@ package body Sem_Ch3 is\n    --  Propagate static and dynamic predicate flags from a parent to the\n    --  subtype in a subtype declaration with and without constraints.\n \n+   function Is_EVF_Procedure (Subp : Entity_Id) return Boolean;\n+   --  Subsidiary to Check_Abstract_Overriding and Derive_Subprogram.\n+   --  Determine whether subprogram Subp is a procedure subject to pragma\n+   --  Extensions_Visible with value False and has at least one controlling\n+   --  parameter of mode OUT.\n+\n    function Is_Valid_Constraint_Kind\n      (T_Kind          : Type_Kind;\n       Constraint_Kind : Node_Kind) return Boolean;\n@@ -3638,8 +3644,8 @@ package body Sem_Ch3 is\n            and then Is_Access_Constant (Etype (E))\n          then\n             Error_Msg_N\n-              (\"access to variable cannot be initialized \"\n-               & \"with an access-to-constant expression\", E);\n+              (\"access to variable cannot be initialized with an \"\n+               & \"access-to-constant expression\", E);\n          end if;\n \n          if not Assignment_OK (N) then\n@@ -3694,6 +3700,17 @@ package body Sem_Ch3 is\n             Check_SPARK_05_Restriction\n               (\"initialization expression is not appropriate\", E);\n          end if;\n+\n+         --  A formal parameter of a specific tagged type whose related\n+         --  subprogram is subject to pragma Extensions_Visible with value\n+         --  \"False\" cannot be implicitly converted to a class-wide type by\n+         --  means of an initialization expression.\n+\n+         if Is_Class_Wide_Type (T) and then Is_EVF_Expression (E) then\n+            Error_Msg_N\n+              (\"formal parameter with Extensions_Visible False cannot be \"\n+               & \"implicitly converted to class-wide type\", E);\n+         end if;\n       end if;\n \n       --  If the No_Streams restriction is set, check that the type of the\n@@ -9790,6 +9807,15 @@ package body Sem_Ch3 is\n                   then\n                      null;\n \n+                  --  A null extension is not obliged to override an inherited\n+                  --  procedure subject to pragma Extensions_Visible with value\n+                  --  False and at least one controlling OUT parameter.\n+\n+                  elsif Is_Null_Extension (T)\n+                    and then Is_EVF_Procedure (Subp)\n+                  then\n+                     null;\n+\n                   else\n                      Error_Msg_NE\n                        (\"type must be declared abstract or & overridden\",\n@@ -9833,6 +9859,16 @@ package body Sem_Ch3 is\n                                 (\"\\& subprogram# is not visible\",\n                                  T, Subp);\n \n+                           --  Clarify the case where a non-null extension must\n+                           --  override inherited procedure subject to pragma\n+                           --  Extensions_Visible with value False and at least\n+                           --  one controlling OUT param.\n+\n+                           elsif Is_EVF_Procedure (E) then\n+                              Error_Msg_NE\n+                                (\"\\& # is subject to Extensions_Visible False\",\n+                                 T, Subp);\n+\n                            else\n                               Error_Msg_NE\n                                 (\"\\& has been inherited from subprogram #\",\n@@ -9902,6 +9938,20 @@ package body Sem_Ch3 is\n                Error_Msg_Node_2 := Subp;\n                Error_Msg_N (\"nonabstract type& has abstract subprogram&!\", T);\n             end if;\n+\n+         --  A subprogram subject to pragma Extensions_Visible with value\n+         --  \"True\" cannot override a subprogram subject to the same pragma\n+         --  with value \"False\".\n+\n+         elsif Extensions_Visible_Status (Subp) = Extensions_Visible_True\n+           and then Present (Overridden_Operation (Subp))\n+           and then Extensions_Visible_Status (Overridden_Operation (Subp)) =\n+                    Extensions_Visible_False\n+         then\n+            Error_Msg_Sloc := Sloc (Overridden_Operation (Subp));\n+            Error_Msg_N\n+              (\"subprogram & with Extensions_Visible True cannot override \"\n+               & \"subprogram # with Extensions_Visible False\", Subp);\n          end if;\n \n          --  Ada 2012 (AI05-0030): Perform checks related to pragma Implemented\n@@ -14254,8 +14304,7 @@ package body Sem_Ch3 is\n    --  Start of processing for Derive_Subprogram\n \n    begin\n-      New_Subp :=\n-         New_Entity (Nkind (Parent_Subp), Sloc (Derived_Type));\n+      New_Subp := New_Entity (Nkind (Parent_Subp), Sloc (Derived_Type));\n       Set_Ekind (New_Subp, Ekind (Parent_Subp));\n       Set_Contract (New_Subp, Make_Contract (Sloc (New_Subp)));\n \n@@ -14490,6 +14539,10 @@ package body Sem_Ch3 is\n       --  Ada 2005 (AI-228): Calculate the \"require overriding\" and \"abstract\"\n       --  properties of the subprogram, as defined in RM-3.9.3(4/2-6/2).\n \n+      --  A subprogram subject to pragma Extensions_Visible with value False\n+      --  requires overriding if the subprogram has at least one controlling\n+      --  OUT parameter.\n+\n       elsif Ada_Version >= Ada_2005\n         and then (Is_Abstract_Subprogram (Alias (New_Subp))\n                    or else (Is_Tagged_Type (Derived_Type)\n@@ -14500,7 +14553,8 @@ package body Sem_Ch3 is\n                                                        E_Anonymous_Access_Type\n                              and then Designated_Type (Etype (New_Subp)) =\n                                                         Derived_Type\n-                             and then not Is_Null_Extension (Derived_Type)))\n+                             and then not Is_Null_Extension (Derived_Type))\n+                   or else Is_EVF_Procedure (Alias (New_Subp)))\n         and then No (Actual_Subp)\n       then\n          if not Is_Tagged_Type (Derived_Type)\n@@ -17339,6 +17393,35 @@ package body Sem_Ch3 is\n         (Subt, Has_Dynamic_Predicate_Aspect (Par));\n    end Inherit_Predicate_Flags;\n \n+   ----------------------\n+   -- Is_EVF_Procedure --\n+   ----------------------\n+\n+   function Is_EVF_Procedure (Subp : Entity_Id) return Boolean is\n+      Formal : Entity_Id;\n+\n+   begin\n+      --  Examine the formals of an Extensions_Visible False procedure looking\n+      --  for a controlling OUT parameter.\n+\n+      if Ekind (Subp) = E_Procedure\n+        and then Extensions_Visible_Status (Subp) = Extensions_Visible_False\n+      then\n+         Formal := First_Formal (Subp);\n+         while Present (Formal) loop\n+            if Ekind (Formal) = E_Out_Parameter\n+              and then Is_Controlling_Formal (Formal)\n+            then\n+               return True;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Is_EVF_Procedure;\n+\n    -----------------------\n    -- Is_Null_Extension --\n    -----------------------"}, {"sha": "8b2a8050e2faa1611fe350fffc5c76f5324a1a28", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -4944,14 +4944,13 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Type_Conversion (N : Node_Id) is\n       Expr : constant Node_Id := Expression (N);\n-      T    : Entity_Id;\n+      Typ  : Entity_Id;\n \n    begin\n-      --  If Conversion_OK is set, then the Etype is already set, and the\n-      --  only processing required is to analyze the expression. This is\n-      --  used to construct certain \"illegal\" conversions which are not\n-      --  allowed by Ada semantics, but can be handled OK by Gigi, see\n-      --  Sinfo for further details.\n+      --  If Conversion_OK is set, then the Etype is already set, and the only\n+      --  processing required is to analyze the expression. This is used to\n+      --  construct certain \"illegal\" conversions which are not allowed by Ada\n+      --  semantics, but can be handled by Gigi, see Sinfo for further details.\n \n       if Conversion_OK (N) then\n          Analyze (Expr);\n@@ -4962,9 +4961,9 @@ package body Sem_Ch4 is\n       --  checks to make sure the argument of the conversion is appropriate.\n \n       Find_Type (Subtype_Mark (N));\n-      T := Entity (Subtype_Mark (N));\n-      Set_Etype (N, T);\n-      Check_Fully_Declared (T, N);\n+      Typ := Entity (Subtype_Mark (N));\n+      Set_Etype (N, Typ);\n+      Check_Fully_Declared (Typ, N);\n       Analyze_Expression (Expr);\n       Validate_Remote_Type_Type_Conversion (N);\n \n@@ -5002,22 +5001,31 @@ package body Sem_Ch4 is\n \n       elsif Nkind (Expr) = N_Character_Literal then\n          if Ada_Version = Ada_83 then\n-            Resolve (Expr, T);\n+            Resolve (Expr, Typ);\n          else\n             Error_Msg_N (\"argument of conversion cannot be character literal\",\n               N);\n             Error_Msg_N (\"\\use qualified expression instead\", N);\n          end if;\n \n       elsif Nkind (Expr) = N_Attribute_Reference\n-        and then\n-          Nam_In (Attribute_Name (Expr), Name_Access,\n-                                         Name_Unchecked_Access,\n-                                         Name_Unrestricted_Access)\n+        and then Nam_In (Attribute_Name (Expr), Name_Access,\n+                                                Name_Unchecked_Access,\n+                                                Name_Unrestricted_Access)\n       then\n          Error_Msg_N (\"argument of conversion cannot be access\", N);\n          Error_Msg_N (\"\\use qualified expression instead\", N);\n       end if;\n+\n+      --  A formal parameter of a specific tagged type whose related subprogram\n+      --  is subject to pragma Extensions_Visible with value \"False\" cannot\n+      --  appear in a class-wide conversion.\n+\n+      if Is_Class_Wide_Type (Typ) and then Is_EVF_Expression (Expr) then\n+         Error_Msg_N\n+           (\"formal parameter with Extensions_Visible False cannot be \"\n+            & \"converted to class-wide type\", Expr);\n+      end if;\n    end Analyze_Type_Conversion;\n \n    ----------------------\n@@ -7603,7 +7611,7 @@ package body Sem_Ch4 is\n             if not Is_Aliased_View (Obj) then\n                Error_Msg_NE\n                  (\"object in prefixed call to & must be aliased \"\n-                  & \" (RM-2005 4.3.1 (13))\", Prefix (First_Actual), Subprog);\n+                  & \"(RM-2005 4.3.1 (13))\", Prefix (First_Actual), Subprog);\n             end if;\n \n             Analyze (First_Actual);"}, {"sha": "6f28cbf4efa1ae9bee29ac9b41bdece7aab760e1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -4074,8 +4074,12 @@ package body Sem_Ch6 is\n \n             if Nam = Name_Depends then\n                Depends := Prag;\n-            else pragma Assert (Nam = Name_Global);\n+\n+            elsif Nam = Name_Global then\n                Global := Prag;\n+\n+            --  Note that pragma Extensions_Visible has already been analyzed\n+\n             end if;\n \n             Prag := Next_Pragma (Prag);\n@@ -5696,10 +5700,12 @@ package body Sem_Ch6 is\n                  and then Present (Alias (Overridden_Subp))\n                  and then Comes_From_Source (Alias (Overridden_Subp))\n                then\n-                  Set_Overridden_Operation (Subp, Alias (Overridden_Subp));\n+                  Set_Overridden_Operation    (Subp, Alias (Overridden_Subp));\n+                  Inherit_Subprogram_Contract (Subp, Alias (Overridden_Subp));\n \n                else\n-                  Set_Overridden_Operation (Subp, Overridden_Subp);\n+                  Set_Overridden_Operation    (Subp, Overridden_Subp);\n+                  Inherit_Subprogram_Contract (Subp, Overridden_Subp);\n                end if;\n             end if;\n          end if;\n@@ -9457,9 +9463,12 @@ package body Sem_Ch6 is\n                   --  E overrides the operation from which S is inherited.\n \n                   if Present (Alias (S)) then\n-                     Set_Overridden_Operation (E, Alias (S));\n+                     Set_Overridden_Operation    (E, Alias (S));\n+                     Inherit_Subprogram_Contract (E, Alias (S));\n+\n                   else\n-                     Set_Overridden_Operation (E, S);\n+                     Set_Overridden_Operation    (E, S);\n+                     Inherit_Subprogram_Contract (E, S);\n                   end if;\n \n                   if Comes_From_Source (E) then\n@@ -9625,7 +9634,8 @@ package body Sem_Ch6 is\n                        and then Present (Alias (E))\n                        and then Comes_From_Source (Alias (E))\n                      then\n-                        Set_Overridden_Operation (S, Alias (E));\n+                        Set_Overridden_Operation    (S, Alias (E));\n+                        Inherit_Subprogram_Contract (S, Alias (E));\n \n                      --  Normal case of setting entity as overridden\n \n@@ -9637,7 +9647,8 @@ package body Sem_Ch6 is\n                      --  must check whether the target is an init_proc.\n \n                      elsif not Is_Init_Proc (S) then\n-                        Set_Overridden_Operation (S, E);\n+                        Set_Overridden_Operation    (S, E);\n+                        Inherit_Subprogram_Contract (S, E);\n                      end if;\n \n                      Check_Overriding_Indicator (S, E, Is_Primitive => True);\n@@ -9660,7 +9671,8 @@ package body Sem_Ch6 is\n                              Is_Predefined_Dispatching_Operation (Alias (E)))\n                      then\n                         if Present (Alias (E)) then\n-                           Set_Overridden_Operation (S, Alias (E));\n+                           Set_Overridden_Operation    (S, Alias (E));\n+                           Inherit_Subprogram_Contract (S, Alias (E));\n                         end if;\n                      end if;\n "}, {"sha": "b5ca29e4a043f462e4f82458f5c46490697829bd", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 167, "deletions": 28, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -3842,9 +3842,9 @@ package body Sem_Prag is\n                --  pragma is inserted in its declarative part.\n \n                elsif From_Aspect_Specification (N)\n+                 and then  Ent = Current_Scope\n                  and then\n                    Nkind (Unit_Declaration_Node (Ent)) = N_Subprogram_Body\n-                 and then  Ent = Current_Scope\n                then\n                   OK := True;\n \n@@ -5370,7 +5370,9 @@ package body Sem_Prag is\n          ---------------\n \n          procedure Chain_CTC (PO : Node_Id) is\n-            S   : Entity_Id;\n+            Name : constant String_Id := Get_Name_From_CTC_Pragma (N);\n+            CTC  : Node_Id;\n+            S    : Entity_Id;\n \n          begin\n             if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n@@ -5399,31 +5401,23 @@ package body Sem_Prag is\n             --  There should not be another test-case with the same name\n             --  associated to this subprogram.\n \n-            declare\n-               Name : constant String_Id := Get_Name_From_CTC_Pragma (N);\n-               CTC  : Node_Id;\n+            CTC := Contract_Test_Cases (Contract (S));\n+            while Present (CTC) loop\n \n-            begin\n-               CTC := Contract_Test_Cases (Contract (S));\n-               while Present (CTC) loop\n+               --  Omit pragma Contract_Cases because it does not introduce\n+               --  a unique case name and it does not follow the syntax of\n+               --  Test_Case.\n \n-                  --  Omit pragma Contract_Cases because it does not introduce\n-                  --  a unique case name and it does not follow the syntax of\n-                  --  Test_Case.\n-\n-                  if Pragma_Name (CTC) = Name_Contract_Cases then\n-                     null;\n+               if Pragma_Name (CTC) = Name_Contract_Cases then\n+                  null;\n \n-                  elsif String_Equal\n-                          (Name, Get_Name_From_CTC_Pragma (CTC))\n-                  then\n-                     Error_Msg_Sloc := Sloc (CTC);\n-                     Error_Pragma (\"name for pragma% is already used#\");\n-                  end if;\n+               elsif String_Equal (Name, Get_Name_From_CTC_Pragma (CTC)) then\n+                  Error_Msg_Sloc := Sloc (CTC);\n+                  Error_Pragma (\"name for pragma% is already used#\");\n+               end if;\n \n-                  CTC := Next_Pragma (CTC);\n-               end loop;\n-            end;\n+               CTC := Next_Pragma (CTC);\n+            end loop;\n \n             --  Chain spec CTC pragma to list for subprogram\n \n@@ -10518,6 +10512,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Ensure_Aggregate_Form (Arg1);\n \n@@ -12292,6 +12287,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Ensure_Aggregate_Form (Arg1);\n \n@@ -12805,12 +12801,11 @@ package body Sem_Prag is\n                     Expression => Get_Pragma_Arg (Arg1)))));\n             Analyze (N);\n \n-         --------------------------------------\n-         -- Pragma_Default_Initial_Condition --\n-         --------------------------------------\n+         -------------------------------\n+         -- Default_Initial_Condition --\n+         -------------------------------\n \n-         --  pragma Pragma_Default_Initial_Condition\n-         --           [ (null | boolean_EXPRESSION) ];\n+         --  pragma Default_Initial_Condition [ (null | boolean_EXPRESSION) ];\n \n          when Pragma_Default_Initial_Condition => Default_Init_Cond : declare\n             Discard : Boolean;\n@@ -12819,6 +12814,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_At_Most_N_Arguments (1);\n \n             Stmt := Prev (N);\n@@ -13883,6 +13879,135 @@ package body Sem_Prag is\n                Ada_Version_Pragma := Empty;\n             end if;\n \n+         ------------------------\n+         -- Extensions_Visible --\n+         ------------------------\n+\n+         --  pragma Extensions_Visible [ (boolean_EXPRESSION) ];\n+\n+         when Pragma_Extensions_Visible => Extensions_Visible : declare\n+            Context : constant Node_Id := Parent (N);\n+            Expr    : Node_Id;\n+            Formal  : Entity_Id;\n+            Subp    : Entity_Id;\n+            Stmt    : Node_Id;\n+\n+            Has_OK_Formal : Boolean := False;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_At_Most_N_Arguments  (1);\n+\n+            Subp := Empty;\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n+\n+               --  The associated [generic] subprogram declaration has been\n+               --  found, stop the search.\n+\n+               elsif Nkind_In (Stmt, N_Generic_Subprogram_Declaration,\n+                                     N_Subprogram_Declaration)\n+               then\n+                  Subp := Defining_Entity (Stmt);\n+                  exit;\n+\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n+\n+               else\n+                  Error_Pragma (\"pragma % must apply to a subprogram\");\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            --  When the pragma applies to a stand alone subprogram body, it\n+            --  appears within the declarations of the body. In that case the\n+            --  enclosing construct is the proper context. This check is done\n+            --  after the traversal above to allow for duplicate detection.\n+\n+            if Nkind (Context) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Context))\n+            then\n+               Subp := Defining_Entity (Context);\n+            end if;\n+\n+            if No (Subp) then\n+               Error_Pragma (\"pragma % must apply to a subprogram\");\n+               return;\n+            end if;\n+\n+            --  Examine the formals of the related subprogram\n+\n+            Formal := First_Formal (Subp);\n+            while Present (Formal) loop\n+\n+               --  At least one of the formals is of a specific tagged type,\n+               --  the pragma is legal.\n+\n+               if Is_Specific_Tagged_Type (Etype (Formal)) then\n+                  Has_OK_Formal := True;\n+                  exit;\n+\n+               --  A generic subprogram with at least one formal of a private\n+               --  type ensures the legality of the pragma because the actual\n+               --  may be specifically tagged. Note that this is verified by\n+               --  the check above at instantiation time.\n+\n+               elsif Is_Private_Type (Etype (Formal))\n+                 and then Is_Generic_Type (Etype (Formal))\n+               then\n+                  Has_OK_Formal := True;\n+                  exit;\n+               end if;\n+\n+               Next_Formal (Formal);\n+            end loop;\n+\n+            if not Has_OK_Formal then\n+               Error_Msg_Name_1 := Pname;\n+               Error_Msg_N (Fix_Error (\"incorrect placement of pragma %\"), N);\n+               Error_Msg_NE\n+                 (\"\\subprogram & lacks parameter of specific tagged or \"\n+                  & \"generic private type\", N, Subp);\n+               return;\n+            end if;\n+\n+            --  Analyze the Boolean expression (if any)\n+\n+            if Present (Arg1) then\n+               Expr := Get_Pragma_Arg (Arg1);\n+\n+               Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+               if not Is_OK_Static_Expression (Expr) then\n+                  Error_Pragma_Arg\n+                    (\"expression of pragma % must be static\", Expr);\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  Chain the pragma on the contract for further processing\n+\n+            Add_Contract_Item (N, Subp);\n+         end Extensions_Visible;\n+\n          --------------\n          -- External --\n          --------------\n@@ -14713,6 +14838,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n             --  Ensure the proper placement of the pragma. Initial_Condition\n@@ -14827,6 +14953,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Ensure_Aggregate_Form (Arg1);\n \n@@ -15760,6 +15887,15 @@ package body Sem_Prag is\n \n          when Pragma_License =>\n             GNAT_Pragma;\n+\n+            --  Do not analyze pragma any further in CodePeer mode, to avoid\n+            --  extraneous errors in this implementation-dependent pragma,\n+            --  which has a different profile on other compilers.\n+\n+            if CodePeer_Mode then\n+               return;\n+            end if;\n+\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n             Check_Valid_Configuration_Pragma;\n@@ -17296,6 +17432,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n             --  Ensure the proper placement of the pragma. Part_Of must appear\n@@ -18675,6 +18812,7 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n+            Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n             --  Ensure the proper placement of the pragma. Refined states must\n@@ -24918,6 +25056,7 @@ package body Sem_Prag is\n       Pragma_Export_Valued_Procedure        => -1,\n       Pragma_Extend_System                  => -1,\n       Pragma_Extensions_Allowed             =>  0,\n+      Pragma_Extensions_Visible             =>  0,\n       Pragma_External                       => -1,\n       Pragma_Favor_Top_Level                =>  0,\n       Pragma_External_Name_Casing           =>  0,"}, {"sha": "e26ff7049080ae122e5c897d19397d0631caf45c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -3260,8 +3260,8 @@ package body Sem_Res is\n \n                if not Is_Aliased_View (Act) then\n                   Error_Msg_NE\n-                    (\"object in prefixed call to& must be aliased\"\n-                         & \" (RM-2005 4.3.1 (13))\",\n+                    (\"object in prefixed call to& must be aliased \"\n+                     & \"(RM-2005 4.3.1 (13))\",\n                     Prefix (Act), Nam);\n                end if;\n \n@@ -4418,6 +4418,22 @@ package body Sem_Res is\n                end if;\n             end if;\n \n+            --  A formal parameter of a specific tagged type whose related\n+            --  subprogram is subject to pragma Extensions_Visible with value\n+            --  \"False\" cannot act as an actual in a subprogram with value\n+            --  \"True\".\n+\n+            if Is_EVF_Expression (A)\n+              and then Extensions_Visible_Status (Nam) =\n+                       Extensions_Visible_True\n+            then\n+               Error_Msg_N\n+                 (\"formal parameter with Extensions_Visible False cannot act \"\n+                  & \"as actual parameter\", A);\n+               Error_Msg_NE\n+                 (\"\\subprogram & has Extensions_Visible True\", A, Nam);\n+            end if;\n+\n             Next_Actual (A);\n \n          --  Case where actual is not present"}, {"sha": "db8cdd717bdc0819de44d02d5a38210882a1649b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 288, "deletions": 42, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -251,8 +251,52 @@ package body Sem_Util is\n \n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id) is\n       Items : constant Node_Id := Contract (Id);\n-      Nam   : Name_Id;\n-      N     : Node_Id;\n+\n+      procedure Add_Classification;\n+      --  Prepend Prag to the list of classifications\n+\n+      procedure Add_Contract_Test_Case;\n+      --  Prepend Prag to the list of contract and test cases\n+\n+      procedure Add_Pre_Post_Condition;\n+      --  Prepend Prag to the list of pre- and postconditions\n+\n+      ------------------------\n+      -- Add_Classification --\n+      ------------------------\n+\n+      procedure Add_Classification is\n+      begin\n+         Set_Next_Pragma (Prag, Classifications (Items));\n+         Set_Classifications (Items, Prag);\n+      end Add_Classification;\n+\n+      ----------------------------\n+      -- Add_Contract_Test_Case --\n+      ----------------------------\n+\n+      procedure Add_Contract_Test_Case is\n+      begin\n+         Set_Next_Pragma (Prag, Contract_Test_Cases (Items));\n+         Set_Contract_Test_Cases (Items, Prag);\n+      end Add_Contract_Test_Case;\n+\n+      ----------------------------\n+      -- Add_Pre_Post_Condition --\n+      ----------------------------\n+\n+      procedure Add_Pre_Post_Condition is\n+      begin\n+         Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n+         Set_Pre_Post_Conditions (Items, Prag);\n+      end Add_Pre_Post_Condition;\n+\n+      --  Local variables\n+\n+      Nam : Name_Id;\n+      PPC : Node_Id;\n+\n+   --  Start of processing for Add_Contract_Item\n \n    begin\n       --  The related context must have a contract and the item to be added\n@@ -275,14 +319,12 @@ package body Sem_Util is\n                          Name_Initial_Condition,\n                          Name_Initializes)\n          then\n-            Set_Next_Pragma (Prag, Classifications (Items));\n-            Set_Classifications (Items, Prag);\n+            Add_Classification;\n \n          --  Indicator Part_Of must be associated with a package instantiation\n \n          elsif Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n-            Set_Next_Pragma (Prag, Classifications (Items));\n-            Set_Classifications (Items, Prag);\n+            Add_Classification;\n \n          --  The pragma is not a proper contract item\n \n@@ -295,8 +337,7 @@ package body Sem_Util is\n \n       elsif Ekind (Id) = E_Package_Body then\n          if Nam = Name_Refined_State then\n-            Set_Next_Pragma (Prag, Classifications (Items));\n-            Set_Classifications (Items, Prag);\n+            Add_Classification;\n \n          --  The pragma is not a proper contract item\n \n@@ -308,6 +349,7 @@ package body Sem_Util is\n       --  applicable pragmas are:\n       --    Contract_Cases\n       --    Depends\n+      --    Extensions_Visible\n       --    Global\n       --    Post\n       --    Postcondition\n@@ -319,51 +361,49 @@ package body Sem_Util is\n         or else Is_Generic_Subprogram (Id)\n         or else Is_Subprogram (Id)\n       then\n-         if Nam_In (Nam, Name_Precondition,\n-                         Name_Postcondition,\n-                         Name_Pre,\n-                         Name_Post,\n+         if Nam_In (Nam, Name_Pre,\n+                         Name_Precondition,\n                          Name_uPre,\n+                         Name_Post,\n+                         Name_Postcondition,\n                          Name_uPost)\n          then\n-            --  Before we add a precondition or postcondition to the list,\n-            --  make sure we do not have a disallowed duplicate, which can\n-            --  happen if we use a pragma for Pre[_Class] or Post[_Class]\n-            --  instead of the corresponding aspect.\n+            --  Before we add a precondition or postcondition to the list, make\n+            --  sure we do not have a disallowed duplicate, which can happen if\n+            --  we use a pragma for Pre[_Class] or Post[_Class] instead of the\n+            --  corresponding aspect.\n \n             if not From_Aspect_Specification (Prag)\n-              and then Nam_In (Nam, Name_Pre_Class,\n-                                    Name_Pre,\n+              and then Nam_In (Nam, Name_Pre,\n                                     Name_uPre,\n-                                    Name_Post_Class,\n                                     Name_Post,\n-                                    Name_uPost)\n+                                    Name_Post_Class)\n             then\n-               N := Pre_Post_Conditions (Items);\n-               while Present (N) loop\n-                  if not Split_PPC (N)\n-                    and then Original_Aspect_Name (N) = Nam\n+               PPC := Pre_Post_Conditions (Items);\n+               while Present (PPC) loop\n+                  if not Split_PPC (PPC)\n+                    and then Original_Aspect_Name (PPC) = Nam\n                   then\n-                     Error_Msg_Sloc := Sloc (N);\n+                     Error_Msg_Sloc := Sloc (PPC);\n                      Error_Msg_NE\n                        (\"duplication of aspect for & given#\", Prag, Id);\n                      return;\n-                  else\n-                     N := Next_Pragma (N);\n                   end if;\n+\n+                  PPC := Next_Pragma (PPC);\n                end loop;\n             end if;\n \n-            Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n-            Set_Pre_Post_Conditions (Items, Prag);\n+            Add_Pre_Post_Condition;\n \n          elsif Nam_In (Nam, Name_Contract_Cases, Name_Test_Case) then\n-            Set_Next_Pragma (Prag, Contract_Test_Cases (Items));\n-            Set_Contract_Test_Cases (Items, Prag);\n+            Add_Contract_Test_Case;\n \n-         elsif Nam_In (Nam, Name_Depends, Name_Global) then\n-            Set_Next_Pragma (Prag, Classifications (Items));\n-            Set_Classifications (Items, Prag);\n+         elsif Nam_In (Nam, Name_Depends,\n+                            Name_Extensions_Visible,\n+                            Name_Global)\n+         then\n+            Add_Classification;\n \n          --  The pragma is not a proper contract item\n \n@@ -377,13 +417,11 @@ package body Sem_Util is\n       --    Refined_Post\n \n       elsif Ekind (Id) = E_Subprogram_Body then\n-         if Nam = Name_Refined_Post then\n-            Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n-            Set_Pre_Post_Conditions (Items, Prag);\n+         if Nam_In (Nam, Name_Refined_Depends, Name_Refined_Global) then\n+            Add_Classification;\n \n-         elsif Nam_In (Nam, Name_Refined_Depends, Name_Refined_Global) then\n-            Set_Next_Pragma (Prag, Classifications (Items));\n-            Set_Classifications (Items, Prag);\n+         elsif Nam = Name_Refined_Post then\n+            Add_Pre_Post_Condition;\n \n          --  The pragma is not a proper contract item\n \n@@ -405,8 +443,7 @@ package body Sem_Util is\n                          Name_Effective_Writes,\n                          Name_Part_Of)\n          then\n-            Set_Next_Pragma (Prag, Classifications (Items));\n-            Set_Classifications (Items, Prag);\n+            Add_Classification;\n \n          --  The pragma is not a proper contract item\n \n@@ -5772,6 +5809,84 @@ package body Sem_Util is\n       end if;\n    end Explain_Limited_Type;\n \n+   -------------------------------\n+   -- Extensions_Visible_Status --\n+   -------------------------------\n+\n+   function Extensions_Visible_Status\n+     (Id : Entity_Id) return Extensions_Visible_Mode\n+   is\n+      Arg1 : Node_Id;\n+      Expr : Node_Id;\n+      Prag : Node_Id;\n+      Subp : Entity_Id;\n+\n+   begin\n+      if SPARK_Mode = On then\n+\n+         --  When a formal parameter is subject to Extensions_Visible, the\n+         --  pragma is stored in the contract of related subprogram.\n+\n+         if Is_Formal (Id) then\n+            Subp := Scope (Id);\n+\n+         elsif Is_Subprogram_Or_Generic_Subprogram (Id) then\n+            Subp := Id;\n+\n+         --  No other construct carries this pragma\n+\n+         else\n+            return Extensions_Visible_None;\n+         end if;\n+\n+         Prag := Get_Pragma (Subp, Pragma_Extensions_Visible);\n+\n+         --  Extract the value from the Boolean expression (if any)\n+\n+         if Present (Prag) then\n+            Arg1 := First (Pragma_Argument_Associations (Prag));\n+\n+            --  The pragma appears with an argument\n+\n+            if Present (Arg1) then\n+               Expr := Get_Pragma_Arg (Arg1);\n+\n+               --  Guarg against cascading errors when the argument of pragma\n+               --  Extensions_Visible is not a valid static Boolean expression.\n+\n+               if Error_Posted (Expr) then\n+                  return Extensions_Visible_None;\n+\n+               elsif Is_True (Expr_Value (Expr)) then\n+                  return Extensions_Visible_True;\n+\n+               else\n+                  return Extensions_Visible_False;\n+               end if;\n+\n+            --  Otherwise the pragma defaults to True\n+\n+            else\n+               return Extensions_Visible_True;\n+            end if;\n+\n+         --  Otherwise pragma Expresions_Visible is not inherited or directly\n+         --  specified, its value defaults to \"False\".\n+\n+         else\n+            return Extensions_Visible_False;\n+         end if;\n+\n+      --  When SPARK_Mode is disabled, all semantic checks related to pragma\n+      --  Extensions_Visible are disabled as well. Instead of saturating the\n+      --  code with \"if SPARK_Mode /= Off then\" checks, the predicate returns\n+      --  a default value.\n+\n+      else\n+         return Extensions_Visible_None;\n+      end if;\n+   end Extensions_Visible_Status;\n+\n    -----------------\n    -- Find_Actual --\n    -----------------\n@@ -9330,6 +9445,51 @@ package body Sem_Util is\n       end if;\n    end Inherit_Rep_Item_Chain;\n \n+   ---------------------------------\n+   -- Inherit_Subprogram_Contract --\n+   ---------------------------------\n+\n+   procedure Inherit_Subprogram_Contract\n+     (Subp      : Entity_Id;\n+      From_Subp : Entity_Id)\n+   is\n+      procedure Inherit_Pragma (Prag_Id : Pragma_Id);\n+      --  Propagate a pragma denoted by Prag_Id from From_Subp's contract to\n+      --  Subp's contract.\n+\n+      --------------------\n+      -- Inherit_Pragma --\n+      --------------------\n+\n+      procedure Inherit_Pragma (Prag_Id : Pragma_Id) is\n+         Prag     : constant Node_Id := Get_Pragma (From_Subp, Prag_Id);\n+         New_Prag : Node_Id;\n+\n+      begin\n+         --  A pragma cannot be part of more than one First_Pragma/Next_Pragma\n+         --  chains, therefore the node must be replicated. The new pragma is\n+         --  flagged is inherited for distrinction purposes.\n+\n+         if Present (Prag) then\n+            New_Prag := New_Copy_Tree (Prag);\n+            Set_Is_Inherited (New_Prag);\n+\n+            Add_Contract_Item (New_Prag, Subp);\n+         end if;\n+      end Inherit_Pragma;\n+\n+   --   Start of processing for Inherit_Subprogram_Contract\n+\n+   begin\n+      --  Inheritance is carried out only when both subprograms have contracts\n+\n+      if Present (Contract (Subp))\n+        and then Present (Contract (From_Subp))\n+      then\n+         Inherit_Pragma (Pragma_Extensions_Visible);\n+      end if;\n+   end Inherit_Subprogram_Contract;\n+\n    ---------------------------------\n    -- Insert_Explicit_Dereference --\n    ---------------------------------\n@@ -10516,6 +10676,71 @@ package body Sem_Util is\n       end if;\n    end Is_Expression_Function;\n \n+   -----------------------\n+   -- Is_EVF_Expression --\n+   -----------------------\n+\n+   function Is_EVF_Expression (N : Node_Id) return Boolean is\n+      Orig_N : constant Node_Id := Original_Node (N);\n+      Alt    : Node_Id;\n+      Expr   : Node_Id;\n+      Id     : Entity_Id;\n+\n+   begin\n+      --  Detect a reference to a formal parameter of a specific tagged type\n+      --  whose related subprogram is subject to pragma Expresions_Visible with\n+      --  value \"False\".\n+\n+      if Is_Entity_Name (N) and then Present (Entity (N)) then\n+         Id := Entity (N);\n+\n+         return\n+           Is_Formal (Id)\n+             and then Is_Specific_Tagged_Type (Etype (Id))\n+             and then Extensions_Visible_Status (Id) =\n+                      Extensions_Visible_False;\n+\n+      --  A case expression is an EVF expression when it contains at least one\n+      --  EVF dependent_expression. Note that a case expression may have been\n+      --  expanded, hence the use of Original_Node.\n+\n+      elsif Nkind (Orig_N) = N_Case_Expression then\n+         Alt := First (Alternatives (Orig_N));\n+         while Present (Alt) loop\n+            if Is_EVF_Expression (Expression (Alt)) then\n+               return True;\n+            end if;\n+\n+            Next (Alt);\n+         end loop;\n+\n+      --  An if expression is an EVF expression when it contains at least one\n+      --  EVF dependent_expression. Note that an if expression may have been\n+      --  expanded, hence the use of Original_Node.\n+\n+      elsif Nkind (Orig_N) = N_If_Expression then\n+         Expr := Next (First (Expressions (Orig_N)));\n+         while Present (Expr) loop\n+            if Is_EVF_Expression (Expr) then\n+               return True;\n+            end if;\n+\n+            Next (Expr);\n+         end loop;\n+\n+      --  A qualified expression or a type conversion is an EVF expression when\n+      --  its operand is an EVF expression.\n+\n+      elsif Nkind_In (N, N_Qualified_Expression,\n+                         N_Unchecked_Type_Conversion,\n+                         N_Type_Conversion)\n+      then\n+         return Is_EVF_Expression (Expression (N));\n+      end if;\n+\n+      return False;\n+   end Is_EVF_Expression;\n+\n    --------------\n    -- Is_False --\n    --------------\n@@ -11885,6 +12110,27 @@ package body Sem_Util is\n       end if;\n    end Is_SPARK_05_Object_Reference;\n \n+   -----------------------------\n+   -- Is_Specific_Tagged_Type --\n+   -----------------------------\n+\n+   function Is_Specific_Tagged_Type (Typ : Entity_Id) return Boolean is\n+      Full_Typ : Entity_Id;\n+\n+   begin\n+      --  Handle private types\n+\n+      if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n+         Full_Typ := Full_View (Typ);\n+      else\n+         Full_Typ := Typ;\n+      end if;\n+\n+      --  A specific tagged type is a non-class-wide tagged type\n+\n+      return Is_Tagged_Type (Full_Typ) and not Is_Class_Wide_Type (Full_Typ);\n+   end Is_Specific_Tagged_Type;\n+\n    ------------------\n    -- Is_Statement --\n    ------------------"}, {"sha": "558255751413224b24952d288162077f24d74c23", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -60,6 +60,7 @@ package Sem_Util is\n    --    Depends\n    --    Effective_Reads\n    --    Effective_Writes\n+   --    Extensions_Visible\n    --    Global\n    --    Initial_Condition\n    --    Initializes\n@@ -566,6 +567,26 @@ package Sem_Util is\n    --  continuation lines to the message explaining why type T is limited.\n    --  Messages are placed at node N.\n \n+   type Extensions_Visible_Mode is\n+     (Extensions_Visible_None,\n+      --  Extensions_Visible does not yield a mode when SPARK_Mode is off. This\n+      --  value acts as a default in a non-SPARK compilation.\n+\n+      Extensions_Visible_False,\n+      --  A value of \"False\" signifies that Extensions_Visible is either\n+      --  missing or the pragma is present and the value of its Boolean\n+      --  expression is False.\n+\n+      Extensions_Visible_True);\n+      --  A value of \"True\" signifies that Extensions_Visible is present and\n+      --  the value of its Boolean expression is True.\n+\n+   function Extensions_Visible_Status\n+     (Id : Entity_Id) return Extensions_Visible_Mode;\n+   --  Given the entity of a subprogram or formal parameter subject to pragma\n+   --  Extensions_Visible, return the Boolean value denoted by the expression\n+   --  of the pragma.\n+\n    procedure Find_Actual\n      (N      : Node_Id;\n       Formal : out Entity_Id;\n@@ -1087,6 +1108,14 @@ package Sem_Util is\n    --  Inherit the rep item chain of type From_Typ without clobbering any\n    --  existing rep items on Typ's chain. Typ is the destination type.\n \n+   procedure Inherit_Subprogram_Contract\n+     (Subp      : Entity_Id;\n+      From_Subp : Entity_Id);\n+   --  Inherit relevant contract items from source subprogram From_Subp. Subp\n+   --  denotes the destination subprogram. The inherited items are:\n+   --    Extensions_Visible\n+   --  ??? it would be nice if this routine handles Pre'Class and Post'Class\n+\n    procedure Insert_Explicit_Dereference (N : Node_Id);\n    --  In a context that requires a composite or subprogram type and where a\n    --  prefix is an access type, rewrite the access type node N (which is the\n@@ -1208,6 +1237,16 @@ package Sem_Util is\n    --  expression function call, and should be inlined unconditionally. Also\n    --  used to determine that such a call does not constitute a freeze point.\n \n+   function Is_EVF_Expression (N : Node_Id) return Boolean;\n+   --  Determine whether node N denotes a reference to a formal parameter of\n+   --  a specific tagged type whose related subprogram is subject to pragma\n+   --  Extensions_Visible with value \"False\". Several other constructs fall\n+   --  under this category:\n+   --    1) A qualified expression whose operand is EVF\n+   --    2) A type conversion whose operand is EVF\n+   --    3) An if expression with at least one EVF dependent_expression\n+   --    4) A case expression with at least one EVF dependent_expression\n+\n    function Is_False (U : Uint) return Boolean;\n    pragma Inline (Is_False);\n    --  The argument is a Uint value which is the Boolean'Pos value of a Boolean\n@@ -1345,6 +1384,9 @@ package Sem_Util is\n    --  constants, formal parameters, and selected_components of those are\n    --  valid objects in SPARK 2005.\n \n+   function Is_Specific_Tagged_Type (Typ : Entity_Id) return Boolean;\n+   --  Determine whether an arbitrary [private] type is specifically tagged\n+\n    function Is_Statement (N : Node_Id) return Boolean;\n    pragma Inline (Is_Statement);\n    --  Check if the node N is a statement node. Note that this includes"}, {"sha": "e9f6dd7ab9d9ea2ad5d5a520650c89317a8cc050", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -1889,6 +1889,14 @@ package body Sinfo is\n       return Flag11 (N);\n    end Is_In_Discriminant_Check;\n \n+   function Is_Inherited\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag4 (N);\n+   end Is_Inherited;\n+\n    function Is_Machine_Number\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5078,6 +5086,14 @@ package body Sinfo is\n       Set_Flag11 (N, Val);\n    end Set_Is_In_Discriminant_Check;\n \n+   procedure Set_Is_Inherited\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag4 (N, Val);\n+   end Set_Is_Inherited;\n+\n    procedure Set_Is_Machine_Number\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "7a3bc6ff0164c3f911ccd8d7f31d47354767de7d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -1573,6 +1573,10 @@ package Sinfo is\n    --    discriminant check has a correct value cannot be performed in this\n    --    case (or the discriminant check may be optimized away).\n \n+   --  Is_Inherited (Flag4-Sem)\n+   --    This flag is set in an N_Pragma node that appears in a N_Contract node\n+   --    to indicate that the pragma has been inherited from a parent context.\n+\n    --  Is_Machine_Number (Flag11-Sem)\n    --    This flag is set in an N_Real_Literal node to indicate that the value\n    --    is a machine number. This avoids some unnecessary cases of converting\n@@ -2384,11 +2388,12 @@ package Sinfo is\n       --  Next_Rep_Item (Node5-Sem)\n       --  Class_Present (Flag6) set if from Aspect with 'Class\n       --  From_Aspect_Specification (Flag13-Sem)\n+      --  Import_Interface_Present (Flag16-Sem)\n+      --  Is_Checked (Flag11-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n       --  Is_Ignored (Flag9-Sem)\n-      --  Is_Checked (Flag11-Sem)\n-      --  Import_Interface_Present (Flag16-Sem)\n+      --  Is_Inherited (Flag4-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n       --  Uneval_Old_Accept (Flag7-Sem)\n       --  Uneval_Old_Warn (Flag18-Sem)\n@@ -9229,6 +9234,9 @@ package Sinfo is\n    function Is_In_Discriminant_Check\n      (N : Node_Id) return Boolean;    -- Flag11\n \n+   function Is_Inherited\n+     (N : Node_Id) return Boolean;    -- Flag4\n+\n    function Is_Machine_Number\n      (N : Node_Id) return Boolean;    -- Flag11\n \n@@ -10246,6 +10254,9 @@ package Sinfo is\n    procedure Set_Is_In_Discriminant_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n+   procedure Set_Is_Inherited\n+     (N : Node_Id; Val : Boolean := True);    -- Flag4\n+\n    procedure Set_Is_Machine_Number\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n@@ -12629,6 +12640,7 @@ package Sinfo is\n    pragma Inline (Is_Folded_In_Parser);\n    pragma Inline (Is_Ignored);\n    pragma Inline (Is_In_Discriminant_Check);\n+   pragma Inline (Is_Inherited);\n    pragma Inline (Is_Machine_Number);\n    pragma Inline (Is_Null_Loop);\n    pragma Inline (Is_Overloaded);\n@@ -12963,6 +12975,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Folded_In_Parser);\n    pragma Inline (Set_Is_Ignored);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n+   pragma Inline (Set_Is_Inherited);\n    pragma Inline (Set_Is_Machine_Number);\n    pragma Inline (Set_Is_Null_Loop);\n    pragma Inline (Set_Is_Overloaded);"}, {"sha": "42a9984a1c48319159fdf144af470b1588732c2c", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039538bc35b844d57ca526bf1a274c93d251b6f5/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=039538bc35b844d57ca526bf1a274c93d251b6f5", "patch": "@@ -494,6 +494,7 @@ package Snames is\n    Name_Export_Procedure               : constant Name_Id := N + $; -- GNAT\n    Name_Export_Value                   : constant Name_Id := N + $; -- GNAT\n    Name_Export_Valued_Procedure        : constant Name_Id := N + $; -- GNAT\n+   Name_Extensions_Visible             : constant Name_Id := N + $; -- GNAT\n    Name_External                       : constant Name_Id := N + $; -- GNAT\n    Name_Finalize_Storage_Only          : constant Name_Id := N + $; -- GNAT\n    Name_Global                         : constant Name_Id := N + $; -- GNAT\n@@ -1828,6 +1829,7 @@ package Snames is\n       Pragma_Export_Procedure,\n       Pragma_Export_Value,\n       Pragma_Export_Valued_Procedure,\n+      Pragma_Extensions_Visible,\n       Pragma_External,\n       Pragma_Finalize_Storage_Only,\n       Pragma_Global,"}]}