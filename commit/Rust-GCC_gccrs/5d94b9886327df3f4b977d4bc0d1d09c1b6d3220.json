{"sha": "5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ5NGI5ODg2MzI3ZGYzZjRiOTc3ZDRiYzBkMWQwOWMxYjZkMzIyMA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-09-23T10:14:23Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-09-23T10:14:23Z"}, "message": "re PR target/50446 ([avr] Implement rotate patterns with offset 1)\n\n\tPR target/50446\n\t* config/avr/avr.md (rotlqi3): Support all offsets 0..7.\n\t(rotlqi3_4): Turn insn into expander.\n\t(*rotlqi3): New insn.\n\t(rotlhi3, rotlsi3): Support rotate left/right by 1.\n\t(*rotlhi2.1, *rotlhi2.15): New insns.\n\t(*rotlsi2.1, *rotlsi2.31): New insns.\n\t* config/avr/constraints.md (C03, C05, C06, C07): New constraints.\n\nFrom-SVN: r179116", "tree": {"sha": "f91cb94b7c6d3afa66fa6743fe352b3a8b63d84e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f91cb94b7c6d3afa66fa6743fe352b3a8b63d84e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9acebb8a99e519c40f0f3fb419c9adbb1c2c8209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9acebb8a99e519c40f0f3fb419c9adbb1c2c8209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9acebb8a99e519c40f0f3fb419c9adbb1c2c8209"}], "stats": {"total": 152, "additions": 130, "deletions": 22}, "files": [{"sha": "5fcf03cfb82e57066000abea3ec861f5faadb2c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "patch": "@@ -1,3 +1,14 @@\n+2011-09-23  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50446\n+\t* config/avr/avr.md (rotlqi3): Support all offsets 0..7.\n+\t(rotlqi3_4): Turn insn into expander.\n+\t(*rotlqi3): New insn.\n+\t(rotlhi3, rotlsi3): Support rotate left/right by 1.\n+\t(*rotlhi2.1, *rotlhi2.15): New insns.\n+\t(*rotlsi2.1, *rotlsi2.31): New insns.\n+\t* config/avr/constraints.md (C03, C05, C06, C07): New constraints.\n+\n 2011-09-23  Bin Cheng  <bin.cheng@arm.com>\n \n \t* config/arm/bpabi.h (BE8_LINK_SPEC): Add cortex-m arch "}, {"sha": "c7a28c74f0eb074bb1eec5f5b2a106570b6ccd0b", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 99, "deletions": 22, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "patch": "@@ -2390,23 +2390,38 @@\n \n (define_expand \"rotlqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(rotate:QI (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+        (rotate:QI (match_operand:QI 1 \"register_operand\" \"\")\n+                   (match_operand:QI 2 \"const_0_to_7_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (!CONST_INT_P (operands[2]) || (INTVAL (operands[2]) != 4))\n-    FAIL;\n-}\")\n+  {\n+    if (!CONST_INT_P (operands[2]))\n+      FAIL;\n \n-(define_insn \"rotlqi3_4\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(rotate:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 4)))]\n+    operands[2] = gen_int_mode (INTVAL (operands[2]) & 7, QImode);\n+  })\n+\n+;; Expander used by __builtin_avr_swap\n+(define_expand \"rotlqi3_4\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (rotate:QI (match_operand:QI 1 \"register_operand\" \"\")\n+                   (const_int 4)))])\n+\n+(define_insn \"*rotlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\"               \"=r,r,r  ,r  ,r  ,r  ,r  ,r\")\n+        (rotate:QI (match_operand:QI 1 \"register_operand\"     \"0,0,0  ,0  ,0  ,0  ,0  ,0\")\n+                   (match_operand:QI 2 \"const_0_to_7_operand\" \"P,K,C03,C04,C05,C06,C07,L\")))]\n   \"\"\n-  \"swap %0\"\n-  [(set_attr \"length\" \"1\")\n-   (set_attr \"cc\" \"none\")])\n+  \"@\n+\tlsl %0\\;adc %0,__zero_reg__\n+\tlsl %0\\;adc %0,__zero_reg__\\;lsl %0\\;adc %0,__zero_reg__\n+\tswap %0\\;bst %0,0\\;ror %0\\;bld %0,7\n+\tswap %0\n+\tswap %0\\;lsl %0\\;adc %0,__zero_reg__\n+\tswap %0\\;lsl %0\\;adc %0,__zero_reg__\\;lsl %0\\;adc %0,__zero_reg__\n+\tbst %0,0\\;ror %0\\;bld %0,7\n+\t\"\n+  [(set_attr \"length\" \"2,4,4,1,3,5,3,0\")\n+   (set_attr \"cc\" \"set_n,set_n,clobber,none,set_n,set_n,clobber,none\")])\n \n ;; Split all rotates of HI,SI and DImode registers where rotation is by\n ;; a whole number of bytes.  The split creates the appropriate moves and\n@@ -2418,33 +2433,91 @@\n (define_mode_attr rotx [(DI \"&r,&r,X\") (SI \"&r,&r,X\") (HI \"X,X,X\")])\n (define_mode_attr rotsmode [(DI \"QI\") (SI \"HI\") (HI \"QI\")])\n \n+;; \"rotlhi3\"\n+;; \"rotlsi3\"\n+;; \"rotldi3\"\n (define_expand \"rotl<mode>3\"\n   [(parallel [(set (match_operand:HIDI 0 \"register_operand\" \"\")\n-\t\t   (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"\")\n-\t\t\t\t(match_operand:VOID 2 \"const_int_operand\" \"\")))\n-\t\t(clobber (match_dup 3))])]\n+                   (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"\")\n+                                (match_operand:VOID 2 \"const_int_operand\" \"\")))\n+              (clobber (match_dup 3))])]\n   \"\"\n   {\n-    if (CONST_INT_P (operands[2])\n-        && 0 == INTVAL (operands[2]) % 8)\n+    int offset;\n+\n+    if (!CONST_INT_P (operands[2]))\n+      FAIL;\n+\n+    offset = INTVAL (operands[2]);\n+ \n+    if (0 == offset % 8)\n       {\n-        if (AVR_HAVE_MOVW && 0 == INTVAL (operands[2]) % 16)\n+        if (AVR_HAVE_MOVW && 0 == offset % 16)\n           operands[3] = gen_rtx_SCRATCH (<rotsmode>mode);\n         else\n           operands[3] = gen_rtx_SCRATCH (QImode);\n       }\n+    else if (<MODE>mode != DImode\n+             && (offset == 1\n+                 || offset == GET_MODE_BITSIZE (<MODE>mode) -1))\n+      {\n+        /*; Support rotate left/right by 1  */\n+\n+        emit_move_insn (operands[0],\n+                        gen_rtx_ROTATE (<MODE>mode, operands[1], operands[2]));\n+        DONE;\n+      }\n     else\n       FAIL;\n   })\n \n+(define_insn \"*rotlhi2.1\"\n+  [(set (match_operand:HI 0 \"register_operand\"           \"=r\")\n+        (rotate:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+                   (const_int 1)))]\n+  \"\"\n+  \"lsl %A0\\;rol %B0\\;adc %A0,__zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*rotlhi2.15\"\n+  [(set (match_operand:HI 0 \"register_operand\"           \"=r\")\n+        (rotate:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+                   (const_int 15)))]\n+  \"\"\n+  \"bst %A0,0\\;ror %B0\\;ror %A0\\;bld %B0,7\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*rotlsi2.1\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r\")\n+        (rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                   (const_int 1)))]\n+  \"\"\n+  \"lsl %A0\\;rol %B0\\;rol %C0\\;rol %D0\\;adc %A0,__zero_reg__\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*rotlsi2.31\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r\")\n+        (rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                   (const_int 31)))]\n+  \"\"\n+  \"bst %A0,0\\;ror %D0\\;ror %C0\\;ror %B0\\;ror %A0\\;bld %D0,7\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n \n ;; Overlapping non-HImode registers often (but not always) need a scratch.\n ;; The best we can do is use early clobber alternative \"#&r\" so that\n ;; completely non-overlapping operands dont get a scratch but # so register\n ;; allocation does not prefer non-overlapping.\n \n \n-; Split word aligned rotates using scratch that is mode dependent.\n+;; Split word aligned rotates using scratch that is mode dependent.\n+\n+;; \"*rotwhi\"\n+;; \"*rotwsi\"\n+;; \"*rotwdi\"\n (define_insn_and_split \"*rotw<mode>\"\n   [(set (match_operand:HIDI 0 \"register_operand\" \"=r,r,#&r\")\n         (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"0,r,r\")\n@@ -2462,7 +2535,11 @@\n   })\n \n \n-; Split byte aligned rotates using scratch that is always QI mode.\n+;; Split byte aligned rotates using scratch that is always QI mode.\n+\n+;; \"*rotbhi\"\n+;; \"*rotbsi\"\n+;; \"*rotbdi\"\n (define_insn_and_split \"*rotb<mode>\"\n   [(set (match_operand:HIDI 0 \"register_operand\" \"=r,r,#&r\")\n         (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"0,r,r\")"}, {"sha": "f02c1978673b0d2a1b28d58fa34ea0a431e48c2e", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d94b9886327df3f4b977d4bc0d1d09c1b6d3220/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=5d94b9886327df3f4b977d4bc0d1d09c1b6d3220", "patch": "@@ -108,11 +108,31 @@\n   (and (match_code \"mem\")\n        (match_test \"extra_constraint_Q (op)\")))\n \n+(define_constraint \"C03\"\n+  \"Constant integer 3.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 3\")))\n+\n (define_constraint \"C04\"\n   \"Constant integer 4.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival == 4\")))\n \n+(define_constraint \"C05\"\n+  \"Constant integer 5.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 5\")))\n+\n+(define_constraint \"C06\"\n+  \"Constant integer 6.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 6\")))\n+\n+(define_constraint \"C07\"\n+  \"Constant integer 7.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 7\")))\n+\n (define_constraint \"Ca2\"\n   \"Constant 2-byte integer that allows AND without clobber register.\"\n   (and (match_code \"const_int\")"}]}