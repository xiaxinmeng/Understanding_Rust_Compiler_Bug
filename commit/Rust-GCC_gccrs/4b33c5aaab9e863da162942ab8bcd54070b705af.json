{"sha": "4b33c5aaab9e863da162942ab8bcd54070b705af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIzM2M1YWFhYjllODYzZGExNjI5NDJhYjhiY2Q1NDA3MGI3MDVhZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-31T19:25:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-31T19:25:58Z"}, "message": "dwarf2out: Fix up ranges for -gdwarf-5 -gsplit-dwarf [PR99490]\n\nFor -gdwarf-4 -gsplit-dwarf we used to emit .debug_ranges section\n(so in the binaries/shared libraries) with DW_AT_ranges from skeleton\nunits as well as .debug_info.dwo pointing to it through DW_FORM_sec_offset\n(and DW_AT_GNU_ranges_base pointing into section, not sure for what\nreason exactly).\nWhen DWARF5 support was being added, we've started using .debug_rnglists\nsection, added DW_AT_rnglists_base to the DW_TAG_skeleton_unit, kept\nDW_AT_ranges with DW_FORM_sec_offset in the skeleton and switched\nover to DW_FORM_rnglistx for DW_AT_ranges in .debug_info.dwo.\nBut the DWARF5 spec actually means for the ranges section (at least\neverything for those DW_AT_ranges in .debug_info.dwo) to sit\nin .debug_rnglists.dwo section next to the .debug_info.dwo, rather than\nhaving consumers look it up in the binary/shared library instead.\nBased on some discussions in the DWARF discuss mailing list:\nhttp://lists.dwarfstd.org/pipermail/dwarf-discuss-dwarfstd.org/2021-March/thread.html#4765\nthis patch mostly follows what LLVM emits for that right now:\n1) small .debug_rnglists section (when needed) just to cover the\n   skeleton DW_AT_ranges (if present); the content of the section\n   uses the Split DWARFy DW_RLE_* codes with addrx encodings where\n   possible\n2) DW_AT_ranges in the skeleton uses DW_FORM_sec_offset (difference\n   from LLVM which uses DW_FORM_rnglistx, which makes it larger\n   and ambiguous)\n3) DW_AT_rnglists_base attribute is gone from the skeleton (again,\n   unlike LLVM where it is just confusing what exactly it means because\n   it is inherited; it would make sense if we emitted DW_FORM_rnglistx\n   in non-split DWARF, but unless ranges are shared, I'm afraid we'd\n   make DWARF larger with fewer relocations by that)\n4) usually big .debug_rnglists.dwo section again with using DW_RLE_*x*\n   where possible\n5) DW_AT_ranges with DW_FORM_rnglistx from .debug_info.dwo referring to\n   that .debug_rnglists.dwo ranges\n\n2021-03-31  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/99490\n\t* dwarf2out.c (debug_ranges_dwo_section): New variable.\n\t(DW_RANGES_IDX_SKELETON): Define.\n\t(struct dw_ranges): Add begin_entry and end_entry members.\n\t(DEBUG_DWO_RNGLISTS_SECTION): Define.\n\t(add_ranges_num): Adjust r initializer for addition of *_entry\n\tmembers.\n\t(add_ranges_by_labels): For -gsplit-dwarf and force_direct,\n\tset idx to DW_RANGES_IDX_SKELETON.\n\t(use_distinct_base_address_for_range): New function.\n\t(index_rnglists): Don't set r->idx if it is equal to\n\tDW_RANGES_IDX_SKELETON.  Initialize r->begin_entry and\n\tr->end_entry for -gsplit-dwarf if those will be needed by\n\toutput_rnglists.\n\t(output_rnglists): Add DWO argument.  If true, switch to\n\tdebug_ranges_dwo_section rather than debug_ranges_section.\n\tAdjust l1/l2 label indexes.  Only output the offset table when\n\tdwo is true and don't include in there the skeleton range\n\tentry if present.  For -gsplit-dwarf, skip ranges that belong\n\tto the other rnglists section.  Change return type from void\n\tto bool and return true if there are any range entries for\n\tthe other section.  For dwarf_split_debug_info use\n\tDW_RLE_startx_endx, DW_RLE_startx_length and DW_RLE_base_addressx\n\tentries instead of DW_RLE_start_end, DW_RLE_start_length and\n\tDW_RLE_base_address.  Use use_distinct_base_address_for_range.\n\t(init_sections_and_labels): Initialize debug_ranges_dwo_section\n\tif -gsplit-dwarf and DWARF >= 5.  Adjust ranges_section_label\n\tand range_base_label indexes.\n\t(dwarf2out_finish): Call index_rnglists earlier before finalizing\n\t.debug_addr.  Never emit DW_AT_rnglists_base attribute.  For\n\t-gsplit-dwarf and DWARF >= 5 call output_rnglists up to twice\n\twith different dwo arguments.\n\t(dwarf2out_c_finalize): Clear debug_ranges_dwo_section.", "tree": {"sha": "5463624b432d22c63764083009ae9ebe769acd32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5463624b432d22c63764083009ae9ebe769acd32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b33c5aaab9e863da162942ab8bcd54070b705af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b33c5aaab9e863da162942ab8bcd54070b705af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b33c5aaab9e863da162942ab8bcd54070b705af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b33c5aaab9e863da162942ab8bcd54070b705af/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1"}], "stats": {"total": 255, "additions": 211, "deletions": 44}, "files": [{"sha": "7a15debcb4858d8732d1ad2e1ac1fa84027dd838", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 211, "deletions": 44, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b33c5aaab9e863da162942ab8bcd54070b705af/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b33c5aaab9e863da162942ab8bcd54070b705af/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4b33c5aaab9e863da162942ab8bcd54070b705af", "patch": "@@ -171,6 +171,7 @@ static GTY(()) section *debug_line_str_section;\n static GTY(()) section *debug_str_dwo_section;\n static GTY(()) section *debug_str_offsets_section;\n static GTY(()) section *debug_ranges_section;\n+static GTY(()) section *debug_ranges_dwo_section;\n static GTY(()) section *debug_frame_section;\n \n /* Maximum size (in bytes) of an artificially generated label.  */\n@@ -3151,11 +3152,17 @@ struct GTY(()) dw_ranges {\n   /* If this is positive, it's a block number, otherwise it's a\n      bitwise-negated index into dw_ranges_by_label.  */\n   int num;\n+  /* If idx is equal to DW_RANGES_IDX_SKELETON, it should be emitted\n+     into .debug_rnglists section rather than .debug_rnglists.dwo\n+     for -gsplit-dwarf and DWARF >= 5.  */\n+#define DW_RANGES_IDX_SKELETON ((1U << 31) - 1)\n   /* Index for the range list for DW_FORM_rnglistx.  */\n   unsigned int idx : 31;\n   /* True if this range might be possibly in a different section\n      from previous entry.  */\n   unsigned int maybe_new_sec : 1;\n+  addr_table_entry *begin_entry;\n+  addr_table_entry *end_entry;\n };\n \n /* A structure to hold a macinfo entry.  */\n@@ -4098,6 +4105,9 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_RNGLISTS_SECTION\n #define DEBUG_RNGLISTS_SECTION\t\".debug_rnglists\"\n #endif\n+#ifndef DEBUG_DWO_RNGLISTS_SECTION\n+#define DEBUG_DWO_RNGLISTS_SECTION\t\".debug_rnglists.dwo\"\n+#endif\n #ifndef DEBUG_LINE_STR_SECTION\n #define DEBUG_LINE_STR_SECTION  \".debug_line_str\"\n #endif\n@@ -11750,7 +11760,7 @@ output_aranges (void)\n static unsigned int\n add_ranges_num (int num, bool maybe_new_sec)\n {\n-  dw_ranges r = { NULL, num, 0, maybe_new_sec };\n+  dw_ranges r = { NULL, num, 0, maybe_new_sec, NULL, NULL };\n   vec_safe_push (ranges_table, r);\n   return vec_safe_length (ranges_table) - 1;\n }\n@@ -11795,6 +11805,8 @@ add_ranges_by_labels (dw_die_ref die, const char *begin, const char *end,\n       add_AT_range_list (die, DW_AT_ranges, offset, force_direct);\n       *added = true;\n       note_rnglist_head (offset);\n+      if (dwarf_split_debug_info && force_direct)\n+\t(*ranges_table)[offset].idx = DW_RANGES_IDX_SKELETON;\n     }\n }\n \n@@ -11919,39 +11931,116 @@ asm_outputs_debug_line_str (void)\n     }\n }\n \n+/* Return true if it is beneficial to use DW_RLE_base_address{,x}.\n+   I is index of the following range.  */\n \n-/* Assign .debug_rnglists indexes.  */\n+static bool\n+use_distinct_base_address_for_range (unsigned int i)\n+{\n+  if (i >= vec_safe_length (ranges_table))\n+    return false;\n+\n+  dw_ranges *r2 = &(*ranges_table)[i];\n+  /* Use DW_RLE_base_address{,x} if there is a next range in the\n+     range list and is guaranteed to be in the same section.  */\n+  return r2->num != 0 && r2->label == NULL && !r2->maybe_new_sec;\n+}\n+\n+/* Assign .debug_rnglists indexes and unique indexes into the debug_addr\n+   section when needed.  */\n \n static void\n index_rnglists (void)\n {\n   unsigned i;\n   dw_ranges *r;\n+  bool base = false;\n \n   FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n-    if (r->label)\n-      r->idx = rnglist_idx++;\n+    {\n+      if (r->label && r->idx != DW_RANGES_IDX_SKELETON)\n+\tr->idx = rnglist_idx++;\n+\n+      if (!have_multiple_function_sections)\n+\tcontinue;\n+      int block_num = r->num;\n+      if (HAVE_AS_LEB128 && (r->label || r->maybe_new_sec))\n+\tbase = false;\n+      if (block_num > 0)\n+\t{\n+\t  char blabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t  char elabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (blabel, BLOCK_BEGIN_LABEL, block_num);\n+\t  ASM_GENERATE_INTERNAL_LABEL (elabel, BLOCK_END_LABEL, block_num);\n+\n+\t  if (HAVE_AS_LEB128)\n+\t    {\n+\t      if (!base && use_distinct_base_address_for_range (i + 1))\n+\t\t{\n+\t\t  r->begin_entry = add_addr_table_entry (xstrdup (blabel),\n+\t\t\t\t\t\t\t ate_kind_label);\n+\t\t  base = true;\n+\t\t}\n+\t      if (base)\n+\t\t/* If we have a base, no need for further\n+\t\t   begin_entry/end_entry, as DW_RLE_offset_pair will be\n+\t\t   used.  */\n+\t\tcontinue;\n+\t      r->begin_entry\n+\t\t= add_addr_table_entry (xstrdup (blabel), ate_kind_label);\n+\t      /* No need for end_entry, DW_RLE_start{,x}_length will use\n+\t\t length as opposed to a pair of addresses.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      r->begin_entry\n+\t\t= add_addr_table_entry (xstrdup (blabel), ate_kind_label);\n+\t      r->end_entry\n+\t\t= add_addr_table_entry (xstrdup (elabel), ate_kind_label);\n+\t    }\n+\t}\n+\n+      /* Negative block_num stands for an index into ranges_by_label.  */\n+      else if (block_num < 0)\n+\t{\n+\t  int lab_idx = - block_num - 1;\n+\t  const char *blabel = (*ranges_by_label)[lab_idx].begin;\n+\t  const char *elabel = (*ranges_by_label)[lab_idx].end;\n+\n+\t  r->begin_entry\n+\t    = add_addr_table_entry (xstrdup (blabel), ate_kind_label);\n+\t  if (!HAVE_AS_LEB128)\n+\t    r->end_entry\n+\t      = add_addr_table_entry (xstrdup (elabel), ate_kind_label);\n+\t}\n+    }\n }\n \n-/* Emit .debug_rnglists section.  */\n+/* Emit .debug_rnglists or (when DWO is true) .debug_rnglists.dwo section.  */\n \n-static void\n-output_rnglists (unsigned generation)\n+static bool\n+output_rnglists (unsigned generation, bool dwo)\n {\n   unsigned i;\n   dw_ranges *r;\n   char l1[MAX_ARTIFICIAL_LABEL_BYTES];\n   char l2[MAX_ARTIFICIAL_LABEL_BYTES];\n   char basebuf[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-  switch_to_section (debug_ranges_section);\n-  ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);\n+  if (dwo)\n+    switch_to_section (debug_ranges_dwo_section);\n+  else\n+    {\n+      switch_to_section (debug_ranges_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);\n+    }\n   /* There are up to 4 unique ranges labels per generation.\n      See also init_sections_and_labels.  */\n   ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_RANGES_SECTION_LABEL,\n-\t\t\t       2 + generation * 4);\n+\t\t\t       2 + 2 * dwo + generation * 6);\n   ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_RANGES_SECTION_LABEL,\n-\t\t\t       3 + generation * 4);\n+\t\t\t       3 + 2 * dwo + generation * 6);\n   if (DWARF_INITIAL_LENGTH_SIZE - dwarf_offset_size == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n \t\t\t \"Initial length escape value indicating \"\n@@ -11968,29 +12057,43 @@ output_rnglists (unsigned generation)\n      the offset table plus corresponding DW_FORM_rnglistx uleb128 indexes\n      into it are usually larger than just DW_FORM_sec_offset offsets\n      into the .debug_rnglists section.  */\n-  dw2_asm_output_data (4, dwarf_split_debug_info ? rnglist_idx : 0,\n+  dw2_asm_output_data (4, dwo ? rnglist_idx : 0,\n \t\t       \"Offset Entry Count\");\n-  if (dwarf_split_debug_info)\n+  if (dwo)\n     {\n       ASM_OUTPUT_LABEL (asm_out_file, ranges_base_label);\n       FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n-\tif (r->label)\n+\tif (r->label && r->idx != DW_RANGES_IDX_SKELETON)\n \t  dw2_asm_output_delta (dwarf_offset_size, r->label,\n \t\t\t\tranges_base_label, NULL);\n     }\n \n   const char *lab = \"\";\n-  unsigned int len = vec_safe_length (ranges_table);\n   const char *base = NULL;\n+  bool skipping = false;\n+  bool ret = false;\n   FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n     {\n       int block_num = r->num;\n \n       if (r->label)\n \t{\n+\t  if (dwarf_split_debug_info\n+\t      && (r->idx == DW_RANGES_IDX_SKELETON) == dwo)\n+\t    {\n+\t      ret = true;\n+\t      skipping = true;\n+\t      continue;\n+\t    }\n \t  ASM_OUTPUT_LABEL (asm_out_file, r->label);\n \t  lab = r->label;\n \t}\n+      if (skipping)\n+\t{\n+\t  if (block_num == 0)\n+\t    skipping = false;\n+\t  continue;\n+\t}\n       if (HAVE_AS_LEB128 && (r->label || r->maybe_new_sec))\n \tbase = NULL;\n       if (block_num > 0)\n@@ -12016,23 +12119,25 @@ output_rnglists (unsigned generation)\n \t\t\t\t\t\t\"Range end address (%s)\", lab);\n \t\t  continue;\n \t\t}\n-\t      if (base == NULL)\n+\t      if (base == NULL && use_distinct_base_address_for_range (i + 1))\n \t\t{\n-\t\t  dw_ranges *r2 = NULL;\n-\t\t  if (i < len - 1)\n-\t\t    r2 = &(*ranges_table)[i + 1];\n-\t\t  if (r2\n-\t\t      && r2->num != 0\n-\t\t      && r2->label == NULL\n-\t\t      && !r2->maybe_new_sec)\n+\t\t  if (dwarf_split_debug_info)\n+\t\t    {\n+\t\t      dw2_asm_output_data (1, DW_RLE_base_addressx,\n+\t\t\t\t\t   \"DW_RLE_base_addressx (%s)\", lab);\n+\t\t      dw2_asm_output_data_uleb128 (r->begin_entry->index,\n+\t\t\t\t\t\t   \"Base address index (%s)\",\n+\t\t\t\t\t\t   blabel);\n+\t\t    }\n+\t\t  else\n \t\t    {\n \t\t      dw2_asm_output_data (1, DW_RLE_base_address,\n \t\t\t\t\t   \"DW_RLE_base_address (%s)\", lab);\n \t\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n \t\t\t\t\t   \"Base address (%s)\", lab);\n-\t\t      strcpy (basebuf, blabel);\n-\t\t      base = basebuf;\n \t\t    }\n+\t\t  strcpy (basebuf, blabel);\n+\t\t  base = basebuf;\n \t\t}\n \t      if (base)\n \t\t{\n@@ -12044,13 +12149,35 @@ output_rnglists (unsigned generation)\n \t\t\t\t\t\t\"Range end address (%s)\", lab);\n \t\t  continue;\n \t\t}\n-\t      dw2_asm_output_data (1, DW_RLE_start_length,\n-\t\t\t\t   \"DW_RLE_start_length (%s)\", lab);\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n-\t\t\t\t   \"Range begin address (%s)\", lab);\n+\t      if (dwarf_split_debug_info)\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_RLE_startx_length,\n+\t\t\t\t       \"DW_RLE_startx_length (%s)\", lab);\n+\t\t  dw2_asm_output_data_uleb128 (r->begin_entry->index,\n+\t\t\t\t\t       \"Range begin address index \"\n+\t\t\t\t\t       \"(%s)\", blabel);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_RLE_start_length,\n+\t\t\t\t       \"DW_RLE_start_length (%s)\", lab);\n+\t\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t       \"Range begin address (%s)\", lab);\n+\t\t}\n \t      dw2_asm_output_delta_uleb128 (elabel, blabel,\n \t\t\t\t\t    \"Range length (%s)\", lab);\n \t    }\n+\t  else if (dwarf_split_debug_info)\n+\t    {\n+\t      dw2_asm_output_data (1, DW_RLE_startx_endx,\n+\t\t\t\t   \"DW_RLE_startx_endx (%s)\", lab);\n+\t      dw2_asm_output_data_uleb128 (r->begin_entry->index,\n+\t\t\t\t\t   \"Range begin address index \"\n+\t\t\t\t\t   \"(%s)\", blabel);\n+\t      dw2_asm_output_data_uleb128 (r->end_entry->index,\n+\t\t\t\t\t   \"Range end address index \"\n+\t\t\t\t\t   \"(%s)\", elabel);\n+\t    }\n \t  else\n \t    {\n \t      dw2_asm_output_data (1, DW_RLE_start_end,\n@@ -12073,13 +12200,35 @@ output_rnglists (unsigned generation)\n \t    gcc_unreachable ();\n \t  if (HAVE_AS_LEB128)\n \t    {\n-\t      dw2_asm_output_data (1, DW_RLE_start_length,\n-\t\t\t\t   \"DW_RLE_start_length (%s)\", lab);\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n-\t\t\t\t   \"Range begin address (%s)\", lab);\n+\t      if (dwarf_split_debug_info)\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_RLE_startx_length,\n+\t\t\t\t       \"DW_RLE_startx_length (%s)\", lab);\n+\t\t  dw2_asm_output_data_uleb128 (r->begin_entry->index,\n+\t\t\t\t\t       \"Range begin address index \"\n+\t\t\t\t\t       \"(%s)\", blabel);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_RLE_start_length,\n+\t\t\t\t       \"DW_RLE_start_length (%s)\", lab);\n+\t\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t       \"Range begin address (%s)\", lab);\n+\t\t}\n \t      dw2_asm_output_delta_uleb128 (elabel, blabel,\n \t\t\t\t\t    \"Range length (%s)\", lab);\n \t    }\n+\t  else if (dwarf_split_debug_info)\n+\t    {\n+\t      dw2_asm_output_data (1, DW_RLE_startx_endx,\n+\t\t\t\t   \"DW_RLE_startx_endx (%s)\", lab);\n+\t      dw2_asm_output_data_uleb128 (r->begin_entry->index,\n+\t\t\t\t\t   \"Range begin address index \"\n+\t\t\t\t\t   \"(%s)\", blabel);\n+\t      dw2_asm_output_data_uleb128 (r->end_entry->index,\n+\t\t\t\t\t   \"Range end address index \"\n+\t\t\t\t\t   \"(%s)\", elabel);\n+\t    }\n \t  else\n \t    {\n \t      dw2_asm_output_data (1, DW_RLE_start_end,\n@@ -12095,6 +12244,7 @@ output_rnglists (unsigned generation)\n \t\t\t     \"DW_RLE_end_of_list (%s)\", lab);\n     }\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n+  return ret;\n }\n \n /* Data structure containing information about input files.  */\n@@ -28833,6 +28983,10 @@ init_sections_and_labels (bool early_lto_debug)\n \t  debug_macinfo_section = get_section (debug_macinfo_section_name,\n \t\t\t\t\t       SECTION_DEBUG | SECTION_EXCLUDE,\n \t\t\t\t\t       NULL);\n+\t  if (dwarf_version >= 5)\n+\t    debug_ranges_dwo_section\n+\t      = get_section (DEBUG_DWO_RNGLISTS_SECTION,\n+\t\t\t     SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n \t}\n       debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,\n \t\t\t\t\t   SECTION_DEBUG, NULL);\n@@ -28867,15 +29021,15 @@ init_sections_and_labels (bool early_lto_debug)\n   ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label,\n \t\t\t       DEBUG_LINE_SECTION_LABEL,\n \t\t\t       init_sections_and_labels_generation);\n-  /* There are up to 4 unique ranges labels per generation.\n+  /* There are up to 6 unique ranges labels per generation.\n      See also output_rnglists.  */\n   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,\n \t\t\t       DEBUG_RANGES_SECTION_LABEL,\n-\t\t\t       init_sections_and_labels_generation * 4);\n+\t\t\t       init_sections_and_labels_generation * 6);\n   if (dwarf_version >= 5 && dwarf_split_debug_info)\n     ASM_GENERATE_INTERNAL_LABEL (ranges_base_label,\n \t\t\t\t DEBUG_RANGES_SECTION_LABEL,\n-\t\t\t\t 1 + init_sections_and_labels_generation * 4);\n+\t\t\t\t 1 + init_sections_and_labels_generation * 6);\n   ASM_GENERATE_INTERNAL_LABEL (debug_addr_section_label,\n \t\t\t       DEBUG_ADDR_SECTION_LABEL,\n \t\t\t       init_sections_and_labels_generation);\n@@ -31675,6 +31829,9 @@ dwarf2out_finish (const char *filename)\n \t  index_location_lists (comp_unit_die ());\n \t}\n \n+      if (dwarf_version >= 5 && !vec_safe_is_empty (ranges_table))\n+\tindex_rnglists ();\n+\n       if (addr_index_table != NULL)\n         {\n           unsigned int index = 0;\n@@ -31740,9 +31897,6 @@ dwarf2out_finish (const char *filename)\n       int mark;\n       struct md5_ctx ctx;\n \n-      if (dwarf_version >= 5 && !vec_safe_is_empty (ranges_table))\n-\tindex_rnglists ();\n-\n       /* Compute a checksum of the comp_unit to use as the dwo_id.  */\n       md5_init_ctx (&ctx);\n       mark = 0;\n@@ -31762,10 +31916,7 @@ dwarf2out_finish (const char *filename)\n         comp-unit DIE.  */\n       if (!vec_safe_is_empty (ranges_table))\n \t{\n-\t  if (dwarf_version >= 5)\n-\t    add_AT_lineptr (main_comp_unit_die, DW_AT_rnglists_base,\n-\t\t\t    ranges_base_label);\n-\t  else\n+\t  if (dwarf_version < 5)\n \t    add_AT_lineptr (main_comp_unit_die, DW_AT_GNU_ranges_base,\n \t\t\t    ranges_section_label);\n \t}\n@@ -31843,7 +31994,22 @@ dwarf2out_finish (const char *filename)\n   if (!vec_safe_is_empty (ranges_table))\n     {\n       if (dwarf_version >= 5)\n-\toutput_rnglists (generation);\n+\t{\n+\t  if (dwarf_split_debug_info)\n+\t    {\n+\t      /* We don't know right now whether there are any\n+\t\t ranges for .debug_rnglists and any for .debug_rnglists.dwo.\n+\t\t Depending on into which of those two belongs the first\n+\t\t ranges_table entry, emit that section first and that\n+\t\t output_rnglists call will return true if the other kind of\n+\t\t ranges needs to be emitted as well.  */\n+\t      bool dwo = (*ranges_table)[0].idx != DW_RANGES_IDX_SKELETON;\n+\t      if (output_rnglists (generation, dwo))\n+\t\toutput_rnglists (generation, !dwo);\n+\t    }\n+\t  else\n+\t    output_rnglists (generation, false);\n+\t}\n       else\n \toutput_ranges ();\n     }\n@@ -32467,6 +32633,7 @@ dwarf2out_c_finalize (void)\n   debug_str_dwo_section = NULL;\n   debug_str_offsets_section = NULL;\n   debug_ranges_section = NULL;\n+  debug_ranges_dwo_section = NULL;\n   debug_frame_section = NULL;\n   fde_vec = NULL;\n   debug_str_hash = NULL;"}]}