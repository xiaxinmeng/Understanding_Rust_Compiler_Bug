{"sha": "53dba8028ceabba1ca8b8bf4f3868fcc0c954c24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkYmE4MDI4Y2VhYmJhMWNhOGI4YmY0ZjM4NjhmY2MwYzk1NGMyNA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-01-19T21:09:25Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-01-19T21:09:25Z"}, "message": "tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Always subtract the offset of the selected field.\n\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Always subtract\n\tthe offset of the selected field.\n\nFrom-SVN: r93918", "tree": {"sha": "107ece69e881b32f2086f7ccab4817eec5fbae98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/107ece69e881b32f2086f7ccab4817eec5fbae98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24/comments", "author": null, "committer": null, "parents": [{"sha": "04d38c3bc120922088eb3c437c060a04ea255e3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d38c3bc120922088eb3c437c060a04ea255e3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04d38c3bc120922088eb3c437c060a04ea255e3f"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "77867e86d3f5665bdaac045c161383f84418f2db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53dba8028ceabba1ca8b8bf4f3868fcc0c954c24", "patch": "@@ -1,3 +1,8 @@\n+2005-01-19  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Always subtract\n+\tthe offset of the selected field.\n+\n 2005-01-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-cfg.c (remove_forwarder_block): Fix the check to"}, {"sha": "697e97e0c82044ad93b54343192463374b6b41a4", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dba8028ceabba1ca8b8bf4f3868fcc0c954c24/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=53dba8028ceabba1ca8b8bf4f3868fcc0c954c24", "patch": "@@ -1449,45 +1449,39 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \tcontinue;\n \n       field_type = TREE_TYPE (f);\n-      if (cmp < 0)\n-\t{\n-\t  /* Don't care about offsets into the middle of scalars.  */\n-\t  if (!AGGREGATE_TYPE_P (field_type))\n-\t    continue;\n-\n-\t  /* Check for array at the end of the struct.  This is often\n-\t     used as for flexible array members.  We should be able to\n-\t     turn this into an array access anyway.  */\n-\t  if (TREE_CODE (field_type) == ARRAY_TYPE)\n-\t    tail_array_field = f;\n-\n-\t  /* Check the end of the field against the offset.  */\n-\t  if (!DECL_SIZE_UNIT (f)\n-\t      || TREE_CODE (DECL_SIZE_UNIT (f)) != INTEGER_CST)\n-\t    continue;\n-\t  t = int_const_binop (MINUS_EXPR, offset, DECL_FIELD_OFFSET (f), 1);\n-\t  if (!tree_int_cst_lt (t, DECL_SIZE_UNIT (f)))\n-\t    continue;\n-\n-\t  /* If we matched, then set offset to the displacement into\n-\t     this field.  */\n-\t  offset = t;\n-\t}\n \n       /* Here we exactly match the offset being checked.  If the types match,\n \t then we can return that field.  */\n-      else if (lang_hooks.types_compatible_p (orig_type, field_type))\n+      if (cmp == 0\n+\t  && lang_hooks.types_compatible_p (orig_type, field_type))\n \t{\n \t  if (base_is_ptr)\n \t    base = build1 (INDIRECT_REF, record_type, base);\n \t  t = build (COMPONENT_REF, field_type, base, f, NULL_TREE);\n \t  return t;\n \t}\n+      \n+      /* Don't care about offsets into the middle of scalars.  */\n+      if (!AGGREGATE_TYPE_P (field_type))\n+\tcontinue;\n \n-      /* Don't care about type-punning of scalars.  */\n-      else if (!AGGREGATE_TYPE_P (field_type))\n-\treturn NULL_TREE;\n+      /* Check for array at the end of the struct.  This is often\n+\t used as for flexible array members.  We should be able to\n+\t turn this into an array access anyway.  */\n+      if (TREE_CODE (field_type) == ARRAY_TYPE)\n+\ttail_array_field = f;\n+\n+      /* Check the end of the field against the offset.  */\n+      if (!DECL_SIZE_UNIT (f)\n+\t  || TREE_CODE (DECL_SIZE_UNIT (f)) != INTEGER_CST)\n+\tcontinue;\n+      t = int_const_binop (MINUS_EXPR, offset, field_offset, 1);\n+      if (!tree_int_cst_lt (t, DECL_SIZE_UNIT (f)))\n+\tcontinue;\n \n+      /* If we matched, then set offset to the displacement into\n+\t this field.  */\n+      offset = t;\n       goto found;\n     }\n \n@@ -1496,6 +1490,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \n   f = tail_array_field;\n   field_type = TREE_TYPE (f);\n+  offset = int_const_binop (MINUS_EXPR, offset, byte_position (f), 1);\n \n  found:\n   /* If we get here, we've got an aggregate field, and a possibly "}]}