{"sha": "d4453ee5ef96f8110e078f4921611e16529a108c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ0NTNlZTVlZjk2ZjgxMTBlMDc4ZjQ5MjE2MTFlMTY1MjlhMTA4Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-01T14:12:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-01T14:12:02Z"}, "message": "(decode_field_reference): New parm PAND_MASK.\n\n(unextend): New parm MASK.\n(fold_truthop): Pass new parms to decode_field_reference and unextend.\n\nFrom-SVN: r10098", "tree": {"sha": "2f9d22ab3d14e701a29807618af8d206416b56b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f9d22ab3d14e701a29807618af8d206416b56b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4453ee5ef96f8110e078f4921611e16529a108c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4453ee5ef96f8110e078f4921611e16529a108c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4453ee5ef96f8110e078f4921611e16529a108c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4453ee5ef96f8110e078f4921611e16529a108c/comments", "author": null, "committer": null, "parents": [{"sha": "09026fe42cebcdc9b881c6820876e5b66b18133c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09026fe42cebcdc9b881c6820876e5b66b18133c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09026fe42cebcdc9b881c6820876e5b66b18133c"}], "stats": {"total": 38, "additions": 27, "deletions": 11}, "files": [{"sha": "4c86dac094daf445270c8cb15374293e620dab0f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4453ee5ef96f8110e078f4921611e16529a108c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4453ee5ef96f8110e078f4921611e16529a108c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d4453ee5ef96f8110e078f4921611e16529a108c", "patch": "@@ -71,12 +71,12 @@ static tree optimize_bit_field_compare PROTO((enum tree_code, tree,\n \t\t\t\t\t      tree, tree));\n static tree decode_field_reference PROTO((tree, int *, int *,\n \t\t\t\t\t  enum machine_mode *, int *,\n-\t\t\t\t\t  int *, tree *));\n+\t\t\t\t\t  int *, tree *, tree *));\n static int all_ones_mask_p PROTO((tree, int));\n static int simple_operand_p PROTO((tree));\n static tree range_test\tPROTO((enum tree_code, tree, enum tree_code,\n \t\t\t       enum tree_code, tree, tree, tree));\n-static tree unextend\tPROTO((tree, int, int));\n+static tree unextend\tPROTO((tree, int, int, tree));\n static tree fold_truthop PROTO((enum tree_code, tree, tree, tree));\n static tree strip_compound_expr PROTO((tree, tree));\n \n@@ -2382,17 +2382,20 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n    *PMASK is set to the mask used.  This is either contained in a\n    BIT_AND_EXPR or derived from the width of the field.\n \n+   *PAND_MASK is set the the mask found in a BIT_AND_EXPR, if any.\n+\n    Return 0 if this is not a component reference or is one that we can't\n    do anything with.  */\n \n static tree\n decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n-\t\t\tpvolatilep, pmask)\n+\t\t\tpvolatilep, pmask, pand_mask)\n      tree exp;\n      int *pbitsize, *pbitpos;\n      enum machine_mode *pmode;\n      int *punsignedp, *pvolatilep;\n      tree *pmask;\n+     tree *pand_mask;\n {\n   tree and_mask = 0;\n   tree mask, inner, offset;\n@@ -2439,6 +2442,7 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n \t\t\tconvert (unsigned_type, and_mask), mask));\n \n   *pmask = mask;\n+  *pand_mask = and_mask;\n   return inner;\n }\n \n@@ -2621,13 +2625,15 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \f\n /* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P\n    bit value.  Arrange things so the extra bits will be set to zero if and\n-   only if C is signed-extended to its full width.  */\n+   only if C is signed-extended to its full width.  If MASK is nonzero,\n+   it is an INTEGER_CST that should be AND'ed with the extra bits.  */\n \n static tree\n-unextend (c, p, unsignedp)\n+unextend (c, p, unsignedp, mask)\n      tree c;\n      int p;\n      int unsignedp;\n+     tree mask;\n {\n   tree type = TREE_TYPE (c);\n   int modesize = GET_MODE_BITSIZE (TYPE_MODE (type));\n@@ -2646,6 +2652,9 @@ unextend (c, p, unsignedp)\n   temp = const_binop (BIT_AND_EXPR, temp, size_int (1), 0);\n   temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n   temp = const_binop (RSHIFT_EXPR, temp, size_int (modesize - p - 1), 0);\n+  if (mask != 0)\n+    temp = const_binop (BIT_AND_EXPR, temp, convert (TREE_TYPE (c), mask), 0);\n+\n   return convert (type, const_binop (BIT_XOR_EXPR, c, temp, 0));\n }\n \f\n@@ -2699,6 +2708,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n   enum machine_mode ll_mode, lr_mode, rl_mode, rr_mode;\n   enum machine_mode lnmode, rnmode;\n   tree ll_mask, lr_mask, rl_mask, rr_mask;\n+  tree ll_and_mask, lr_and_mask, rl_and_mask, rr_and_mask;\n   tree l_const, r_const;\n   tree type, result;\n   int first_bit, end_bit;\n@@ -2788,16 +2798,20 @@ fold_truthop (code, truth_type, lhs, rhs)\n   volatilep = 0;\n   ll_inner = decode_field_reference (ll_arg,\n \t\t\t\t     &ll_bitsize, &ll_bitpos, &ll_mode,\n-\t\t\t\t     &ll_unsignedp, &volatilep, &ll_mask);\n+\t\t\t\t     &ll_unsignedp, &volatilep, &ll_mask,\n+\t\t\t\t     &ll_and_mask);\n   lr_inner = decode_field_reference (lr_arg,\n \t\t\t\t     &lr_bitsize, &lr_bitpos, &lr_mode,\n-\t\t\t\t     &lr_unsignedp, &volatilep, &lr_mask);\n+\t\t\t\t     &lr_unsignedp, &volatilep, &lr_mask,\n+\t\t\t\t     &lr_and_mask);\n   rl_inner = decode_field_reference (rl_arg,\n \t\t\t\t     &rl_bitsize, &rl_bitpos, &rl_mode,\n-\t\t\t\t     &rl_unsignedp, &volatilep, &rl_mask);\n+\t\t\t\t     &rl_unsignedp, &volatilep, &rl_mask,\n+\t\t\t\t     &rl_and_mask);\n   rr_inner = decode_field_reference (rr_arg,\n \t\t\t\t     &rr_bitsize, &rr_bitpos, &rr_mode,\n-\t\t\t\t     &rr_unsignedp, &volatilep, &rr_mask);\n+\t\t\t\t     &rr_unsignedp, &volatilep, &rr_mask,\n+\t\t\t\t     &rr_and_mask);\n \n   /* It must be true that the inner operation on the lhs of each\n      comparison must be the same if we are to be able to do anything.\n@@ -2866,7 +2880,8 @@ fold_truthop (code, truth_type, lhs, rhs)\n \n   if (l_const)\n     {\n-      l_const = unextend (convert (type, l_const), ll_bitsize, ll_unsignedp);\n+      l_const = convert (type, l_const);\n+      l_const = unextend (l_const,  ll_bitsize, ll_unsignedp, ll_and_mask);\n       l_const = const_binop (LSHIFT_EXPR, l_const, size_int (xll_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, l_const,\n \t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n@@ -2883,7 +2898,8 @@ fold_truthop (code, truth_type, lhs, rhs)\n     }\n   if (r_const)\n     {\n-      r_const = unextend (convert (type, r_const), rl_bitsize, rl_unsignedp);\n+      r_const = convert (type, r_const);\n+      r_const = unextend (r_const, rl_bitsize, rl_unsignedp, rl_and_mask);\n       r_const = const_binop (LSHIFT_EXPR, r_const, size_int (xrl_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, r_const,\n \t\t\t\t\tfold (build1 (BIT_NOT_EXPR,"}]}