{"sha": "f4381d6204dfb3dcb2e70b88e4fe83542a741004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQzODFkNjIwNGRmYjNkY2IyZTcwYjg4ZTRmZTgzNTQyYTc0MTAwNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-06T21:41:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-06T21:41:28Z"}, "message": "decl.c (redeclaration_error_message): If two TEMPLATE_DECLs have the same DECL_RESULT, it's not a redefinition.\n\n\t* decl.c (redeclaration_error_message): If two TEMPLATE_DECLs have\n\tthe same DECL_RESULT, it's not a redefinition.\n\t* pt.c (tsubst_decl): Remove code to handle illegal\n\tspecializations.\n\nFrom-SVN: r34438", "tree": {"sha": "83d17983110863a12abf16e13bd04f5a68676a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83d17983110863a12abf16e13bd04f5a68676a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4381d6204dfb3dcb2e70b88e4fe83542a741004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4381d6204dfb3dcb2e70b88e4fe83542a741004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4381d6204dfb3dcb2e70b88e4fe83542a741004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4381d6204dfb3dcb2e70b88e4fe83542a741004/comments", "author": null, "committer": null, "parents": [{"sha": "80e08b3052408b922cd79b50da4023690ccf0757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80e08b3052408b922cd79b50da4023690ccf0757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80e08b3052408b922cd79b50da4023690ccf0757"}], "stats": {"total": 57, "additions": 2, "deletions": 55}, "files": [{"sha": "b7abbc871e4ecdecdbe0c8ec5994d46978879717", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4381d6204dfb3dcb2e70b88e4fe83542a741004/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4381d6204dfb3dcb2e70b88e4fe83542a741004/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f4381d6204dfb3dcb2e70b88e4fe83542a741004", "patch": "@@ -4729,6 +4729,8 @@ redeclaration_error_message (newdecl, olddecl)\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n       if ((TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n+\t   && (DECL_TEMPLATE_RESULT (newdecl) \n+\t       != DECL_TEMPLATE_RESULT (olddecl))\n \t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (newdecl))\n \t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)))\n \t  || (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL"}, {"sha": "aab25c90b222941418a02e243aed1d379d0ab948", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4381d6204dfb3dcb2e70b88e4fe83542a741004/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4381d6204dfb3dcb2e70b88e4fe83542a741004/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f4381d6204dfb3dcb2e70b88e4fe83542a741004", "patch": "@@ -5569,61 +5569,6 @@ tsubst_decl (t, args, type, in_decl)\n \tif (TREE_CODE (decl) == TYPE_DECL)\n \t  break;\n \n-\tfor (spec = DECL_TEMPLATE_SPECIALIZATIONS (t);\n-\t     spec != NULL_TREE;\n-\t     spec = TREE_CHAIN (spec))\n-\t  {\n-\t    /* It helps to consider example here.  Consider:\n-\n-\t       template <class T>\n-\t       struct S {\n-\t         template <class U>\n-\t\t void f(U u);\n-\n-\t\t template <>\n-\t\t void f(T* t) {}\n-\t       };\n-\t       \n-\t       Now, for example, we are instantiating S<int>::f(U u).  \n-\t       We want to make a template:\n-\n-\t       template <class U>\n-\t       void S<int>::f(U);\n-\n-\t       It will have a specialization, for the case U = int*, of\n-\t       the form:\n-\n-\t       template <>\n-\t       void S<int>::f<int*>(int*);\n-\n-\t       This specialization will be an instantiation of\n-\t       the specialization given in the declaration of S, with\n-\t       argument list int*.  */\n-\n-\t    tree fn = TREE_VALUE (spec);\n-\t    tree spec_args;\n-\t    tree new_fn;\n-\n-\t    if (!DECL_TEMPLATE_SPECIALIZATION (fn))\n-\t      /* Instantiations are on the same list, but they're of\n-\t\t no concern to us.  */\n-\t      continue;\n-\n-\t    if (TREE_CODE (fn) != TEMPLATE_DECL)\n-\t      /* A full specialization.  There's no need to record\n-\t\t that here.  */\n-\t      continue;\n-\n-\t    spec_args = tsubst (DECL_TI_ARGS (fn), args,\n-\t\t\t\t/*complain=*/1, in_decl); \n-\t    new_fn\n-\t      = tsubst (DECL_TEMPLATE_RESULT (most_general_template (fn)), \n-\t\t\tspec_args, /*complain=*/1, in_decl); \n-\t    DECL_TI_TEMPLATE (new_fn) = fn;\n-\t    register_specialization (new_fn, r, \n-\t\t\t\t     INNERMOST_TEMPLATE_ARGS (spec_args));\n-\t  }\n-\n \t/* Record this partial instantiation.  */\n \tregister_specialization (r, t, \n \t\t\t\t DECL_TI_ARGS (DECL_TEMPLATE_RESULT (r)));"}]}