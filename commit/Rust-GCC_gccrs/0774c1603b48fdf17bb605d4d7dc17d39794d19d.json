{"sha": "0774c1603b48fdf17bb605d4d7dc17d39794d19d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc3NGMxNjAzYjQ4ZmRmMTdiYjYwNWQ0ZDdkYzE3ZDM5Nzk0ZDE5ZA==", "commit": {"author": {"name": "Alexander Ivchenko", "email": "alexander.ivchenko@intel.com", "date": "2014-09-16T11:00:24Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-09-16T11:00:24Z"}, "message": "AVX-512. Extend extract insn patterns.\n\ngcc/\n\t* config/i386/i386.c\n\t(ix86_expand_vector_extract): Handle V32HI and V64QI modes.\n\t* config/i386/sse.md\n\t(define_mode_iterator VI48F_256): New.\n\t(define_mode_attr extract_type): Ditto.\n\t(define_mode_attr extract_suf): Ditto.\n\t(define_mode_iterator AVX512_VEC): Ditto.\n\t(define_expand\n\t\"<extract_type>_vextract<shuffletype><extract_suf>_mask\"): Use\n\tAVX512_VEC.\n\t(define_insn \"avx512dq_vextract<shuffletype>64x2_1_maskm\"): New.\n\t(define_insn\n\t\"<mask_codefor>avx512dq_vextract<shuffletype>64x2_1<mask_name>\"):\n\tDitto.\n\t(define_mode_attr extract_type_2): Ditto.\n\t(define_mode_attr extract_suf_2): Ditto.\n\t(define_mode_iterator AVX512_VEC_2): Ditto.\n\t(define_expand\n\t\"<extract_type_2>_vextract<shuffletype><extract_suf_2>_mask\"): Use\n\tAVX512_VEC_2 mode iterator.\n\t(define_insn \"vec_extract_hi_<mode>_maskm\"): Ditto.\n\t(define_expand \"avx512vl_vextractf128<mode>\"): Ditto.\n\t(define_insn_and_split \"vec_extract_lo_<mode>\"): Delete.\n\t(define_insn \"vec_extract_lo_<mode><mask_name>\"): New.\n\t(define_split for V16FI mode): Ditto.\n\t(define_insn_and_split \"vec_extract_lo_<mode>\"): Delete.\n\t(define_insn \"vec_extract_lo_<mode><mask_name>\"): New.\n\t(define_split for VI8F_256 mode): Ditto.\n\t(define_insn \"vec_extract_hi_<mode><mask_name>\"): Add masking.\n\t(define_insn_and_split \"vec_extract_lo_<mode>\"): Delete.\n\t(define_insn \"vec_extract_lo_<mode><mask_name>\"): New.\n\t(define_split for VI4F_256 mode): Ditto.\n\t(define_insn \"vec_extract_lo_<mode>_maskm\"): Ditto.\n\t(define_insn \"vec_extract_hi_<mode>_maskm\"): Ditto.\n\t(define_insn \"vec_extract_hi_<mode><mask_name>\"): Add masking.\n\t(define_mode_iterator VEC_EXTRACT_MODE): Add V64QI and V32HI modes.\n\t(define_insn \"vcvtph2ps<mask_name>\"): Fix pattern condition.\n\t(define_insn \"avx512f_vextract<shuffletype>32x4_1_maskm\"): Ditto.\n\t(define_insn \"<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>\"):\n\tUpdate `type' attribute, remove explicit `memory' attribute calculation.\n\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Anna Tikhonova <anna.tikhonova@intel.com>\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Maxim Kuznetsov <maxim.kuznetsov@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r215296", "tree": {"sha": "f083a1af9e920f77fdcb00aa78df7f66fe048647", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f083a1af9e920f77fdcb00aa78df7f66fe048647"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0774c1603b48fdf17bb605d4d7dc17d39794d19d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0774c1603b48fdf17bb605d4d7dc17d39794d19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0774c1603b48fdf17bb605d4d7dc17d39794d19d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0774c1603b48fdf17bb605d4d7dc17d39794d19d/comments", "author": null, "committer": null, "parents": [{"sha": "7c943bd87c364895f3a49f6e90fd9c366a3ff945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c943bd87c364895f3a49f6e90fd9c366a3ff945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c943bd87c364895f3a49f6e90fd9c366a3ff945"}], "stats": {"total": 447, "additions": 359, "deletions": 88}, "files": [{"sha": "4ba66a70b4e220fb080d83dc85d18f48432c368d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0774c1603b48fdf17bb605d4d7dc17d39794d19d", "patch": "@@ -1,3 +1,53 @@\n+2014-09-16  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n+\t    Anna Tikhonova  <anna.tikhonova@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* config/i386/i386.c\n+\t(ix86_expand_vector_extract): Handle V32HI and V64QI modes.\n+\t* config/i386/sse.md\n+\t(define_mode_iterator VI48F_256): New.\n+\t(define_mode_attr extract_type): Ditto.\n+\t(define_mode_attr extract_suf): Ditto.\n+\t(define_mode_iterator AVX512_VEC): Ditto.\n+\t(define_expand\n+\t\"<extract_type>_vextract<shuffletype><extract_suf>_mask\"): Use\n+\tAVX512_VEC.\n+\t(define_insn \"avx512dq_vextract<shuffletype>64x2_1_maskm\"): New.\n+\t(define_insn\n+\t\"<mask_codefor>avx512dq_vextract<shuffletype>64x2_1<mask_name>\"):\n+\tDitto.\n+\t(define_mode_attr extract_type_2): Ditto.\n+\t(define_mode_attr extract_suf_2): Ditto.\n+\t(define_mode_iterator AVX512_VEC_2): Ditto.\n+\t(define_expand\n+\t\"<extract_type_2>_vextract<shuffletype><extract_suf_2>_mask\"): Use\n+\tAVX512_VEC_2 mode iterator.\n+\t(define_insn \"vec_extract_hi_<mode>_maskm\"): Ditto.\n+\t(define_expand \"avx512vl_vextractf128<mode>\"): Ditto.\n+\t(define_insn_and_split \"vec_extract_lo_<mode>\"): Delete.\n+\t(define_insn \"vec_extract_lo_<mode><mask_name>\"): New.\n+\t(define_split for V16FI mode): Ditto.\n+\t(define_insn_and_split \"vec_extract_lo_<mode>\"): Delete.\n+\t(define_insn \"vec_extract_lo_<mode><mask_name>\"): New.\n+\t(define_split for VI8F_256 mode): Ditto.\n+\t(define_insn \"vec_extract_hi_<mode><mask_name>\"): Add masking.\n+\t(define_insn_and_split \"vec_extract_lo_<mode>\"): Delete.\n+\t(define_insn \"vec_extract_lo_<mode><mask_name>\"): New.\n+\t(define_split for VI4F_256 mode): Ditto.\n+\t(define_insn \"vec_extract_lo_<mode>_maskm\"): Ditto.\n+\t(define_insn \"vec_extract_hi_<mode>_maskm\"): Ditto.\n+\t(define_insn \"vec_extract_hi_<mode><mask_name>\"): Add masking.\n+\t(define_mode_iterator VEC_EXTRACT_MODE): Add V64QI and V32HI modes.\n+\t(define_insn \"vcvtph2ps<mask_name>\"): Fix pattern condition.\n+\t(define_insn \"avx512f_vextract<shuffletype>32x4_1_maskm\"): Ditto.\n+\t(define_insn \"<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>\"):\n+\tUpdate `type' attribute, remove explicit `memory' attribute calculation.\n+\n 2014-09-16  Kito Cheng  <kito@0xlab.org>\n \n \t* ira.c (ira): Don't initialize ira_spilled_reg_stack_slots and"}, {"sha": "6337aa5b43b0e009f89305c8fb1a5b4996e54d89", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0774c1603b48fdf17bb605d4d7dc17d39794d19d", "patch": "@@ -40979,6 +40979,32 @@ ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n \t}\n       break;\n \n+    case V32HImode:\n+      if (TARGET_AVX512BW)\n+\t{\n+\t  tmp = gen_reg_rtx (V16HImode);\n+\t  if (elt < 16)\n+\t    emit_insn (gen_vec_extract_lo_v32hi (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v32hi (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 15);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V64QImode:\n+      if (TARGET_AVX512BW)\n+\t{\n+\t  tmp = gen_reg_rtx (V32QImode);\n+\t  if (elt < 32)\n+\t    emit_insn (gen_vec_extract_lo_v64qi (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v64qi (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 31);\n+\t  return;\n+\t}\n+      break;\n+\n     case V16SFmode:\n       tmp = gen_reg_rtx (V8SFmode);\n       if (elt < 8)"}, {"sha": "533308b2f50bb9bfbd515c4a5ba49faf5ec57839", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 282, "deletions": 88, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=0774c1603b48fdf17bb605d4d7dc17d39794d19d", "patch": "@@ -534,6 +534,7 @@\n    (V4DI \"TARGET_AVX512VL\") (V4DF \"TARGET_AVX512VL\")\n    (V4SI \"TARGET_AVX512VL\") (V4SF \"TARGET_AVX512VL\")\n    (V2DI \"TARGET_AVX512VL\") (V2DF \"TARGET_AVX512VL\")])\n+(define_mode_iterator VI48F_256 [V8SI V8SF V4DI V4DF])\n \n ;; Mapping from float mode to required SSE level\n (define_mode_attr sse\n@@ -6319,44 +6320,64 @@\n   operands[1] = adjust_address (operands[1], SFmode, INTVAL (operands[2]) * 4);\n })\n \n-(define_expand \"avx512f_vextract<shuffletype>32x4_mask\"\n+(define_mode_attr extract_type\n+  [(V16SF \"avx512f\") (V16SI \"avx512f\") (V8DF \"avx512dq\") (V8DI \"avx512dq\")])\n+\n+(define_mode_attr extract_suf\n+  [(V16SF \"32x4\") (V16SI \"32x4\") (V8DF \"64x2\") (V8DI \"64x2\")])\n+\n+(define_mode_iterator AVX512_VEC\n+  [(V8DF \"TARGET_AVX512DQ\") (V8DI \"TARGET_AVX512DQ\") V16SF V16SI])\n+\n+(define_expand \"<extract_type>_vextract<shuffletype><extract_suf>_mask\"\n   [(match_operand:<ssequartermode> 0 \"nonimmediate_operand\")\n-   (match_operand:V16FI 1 \"register_operand\")\n+   (match_operand:AVX512_VEC 1 \"register_operand\")\n    (match_operand:SI 2 \"const_0_to_3_operand\")\n    (match_operand:<ssequartermode> 3 \"nonimmediate_operand\")\n    (match_operand:QI 4 \"register_operand\")]\n   \"TARGET_AVX512F\"\n {\n+  int mask;\n+  mask = INTVAL (operands[2]);\n+\n   if (MEM_P (operands[0]) && GET_CODE (operands[3]) == CONST_VECTOR)\n     operands[0] = force_reg (<ssequartermode>mode, operands[0]);\n-  switch (INTVAL (operands[2]))\n-    {\n-    case 0:\n-      emit_insn (gen_avx512f_vextract<shuffletype>32x4_1_mask (operands[0],\n-          operands[1], GEN_INT (0), GEN_INT (1), GEN_INT (2),\n-          GEN_INT (3), operands[3], operands[4]));\n-      break;\n-    case 1:\n-      emit_insn (gen_avx512f_vextract<shuffletype>32x4_1_mask (operands[0],\n-          operands[1], GEN_INT (4), GEN_INT (5), GEN_INT (6),\n-          GEN_INT (7), operands[3], operands[4]));\n-      break;\n-    case 2:\n-      emit_insn (gen_avx512f_vextract<shuffletype>32x4_1_mask (operands[0],\n-          operands[1], GEN_INT (8), GEN_INT (9), GEN_INT (10),\n-          GEN_INT (11), operands[3], operands[4]));\n-      break;\n-    case 3:\n-      emit_insn (gen_avx512f_vextract<shuffletype>32x4_1_mask (operands[0],\n-          operands[1], GEN_INT (12), GEN_INT (13), GEN_INT (14),\n-          GEN_INT (15), operands[3], operands[4]));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+\n+  if (<MODE>mode == V16SImode || <MODE>mode == V16SFmode)\n+    emit_insn (gen_avx512f_vextract<shuffletype>32x4_1_mask (operands[0],\n+        operands[1], GEN_INT (mask * 4), GEN_INT (mask * 4 + 1),\n+\tGEN_INT (mask * 4 + 2), GEN_INT (mask * 4 + 3), operands[3],\n+\toperands[4]));\n+  else\n+    emit_insn (gen_avx512dq_vextract<shuffletype>64x2_1_mask (operands[0],\n+        operands[1], GEN_INT (mask * 2), GEN_INT (mask * 2 + 1), operands[3],\n+\toperands[4]));\n   DONE;\n })\n \n+(define_insn \"avx512dq_vextract<shuffletype>64x2_1_maskm\"\n+  [(set (match_operand:<ssequartermode> 0 \"memory_operand\" \"=m\")\n+\t(vec_merge:<ssequartermode>\n+\t  (vec_select:<ssequartermode>\n+\t    (match_operand:V8FI 1 \"register_operand\" \"v\")\n+\t    (parallel [(match_operand 2  \"const_0_to_7_operand\")\n+\t      (match_operand 3  \"const_0_to_7_operand\")]))\n+\t  (match_operand:<ssequartermode> 4 \"memory_operand\" \"0\")\n+\t  (match_operand:QI 5 \"register_operand\" \"k\")))]\n+  \"TARGET_AVX512DQ\n+   && (INTVAL (operands[2]) % 2 == 0)\n+   && (INTVAL (operands[2]) == INTVAL (operands[3]) - 1 )\"\n+{\n+  operands[2] = GEN_INT ((INTVAL (operands[2])) >> 1);\n+  return \"vextract<shuffletype>64x2\\t{%2, %1, %0%{%5%}|%0%{%5%}, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"memory\" \"store\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n (define_insn \"avx512f_vextract<shuffletype>32x4_1_maskm\"\n   [(set (match_operand:<ssequartermode> 0 \"memory_operand\" \"=m\")\n \t(vec_merge:<ssequartermode>\n@@ -6369,7 +6390,8 @@\n \t  (match_operand:<ssequartermode> 6 \"memory_operand\" \"0\")\n \t  (match_operand:QI 7 \"register_operand\" \"Yk\")))]\n   \"TARGET_AVX512F\n-   && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)\n+   && ((INTVAL (operands[2]) % 4 == 0)\n+       && INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)\n        && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)\n        && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))\"\n {\n@@ -6383,6 +6405,23 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n+(define_insn \"<mask_codefor>avx512dq_vextract<shuffletype>64x2_1<mask_name>\"\n+  [(set (match_operand:<ssequartermode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n+\t(vec_select:<ssequartermode>\n+\t  (match_operand:V8FI 1 \"register_operand\" \"v\")\n+\t  (parallel [(match_operand 2  \"const_0_to_7_operand\")\n+            (match_operand 3  \"const_0_to_7_operand\")])))]\n+  \"TARGET_AVX512DQ && (INTVAL (operands[2]) == INTVAL (operands[3]) - 1)\"\n+{\n+  operands[2] = GEN_INT ((INTVAL (operands[2])) >> 1);\n+  return \"vextract<shuffletype>64x2\\t{%2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n (define_insn \"<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>\"\n   [(set (match_operand:<ssequartermode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n \t(vec_select:<ssequartermode>\n@@ -6399,19 +6438,24 @@\n   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);\n   return \"vextract<shuffletype>32x4\\t{%2, %1, %0<mask_operand6>|%0<mask_operand6>, %1, %2}\";\n }\n-  [(set_attr \"type\" \"sselog\")\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n-   (set (attr \"memory\")\n-      (if_then_else (match_test \"MEM_P (operands[0])\")\n-\t(const_string \"store\")\n-\t(const_string \"none\")))\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_expand \"avx512f_vextract<shuffletype>64x4_mask\"\n+(define_mode_attr extract_type_2\n+  [(V16SF \"avx512dq\") (V16SI \"avx512dq\") (V8DF \"avx512f\") (V8DI \"avx512f\")])\n+\n+(define_mode_attr extract_suf_2\n+  [(V16SF \"32x8\") (V16SI \"32x8\") (V8DF \"64x4\") (V8DI \"64x4\")])\n+\n+(define_mode_iterator AVX512_VEC_2\n+  [(V16SF \"TARGET_AVX512DQ\") (V16SI \"TARGET_AVX512DQ\") V8DF V8DI])\n+\n+(define_expand \"<extract_type_2>_vextract<shuffletype><extract_suf_2>_mask\"\n   [(match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n-   (match_operand:V8FI 1 \"register_operand\")\n+   (match_operand:AVX512_VEC_2 1 \"register_operand\")\n    (match_operand:SI 2 \"const_0_to_1_operand\")\n    (match_operand:<ssehalfvecmode> 3 \"nonimmediate_operand\")\n    (match_operand:QI 4 \"register_operand\")]\n@@ -6467,8 +6511,8 @@\n \t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n \t  (match_operand:QI 3 \"register_operand\" \"Yk\")))]\n   \"TARGET_AVX512F\"\n-\"vextract<shuffletype>64x4\\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}\"\n-  [(set_attr \"type\" \"sselog\")\n+  \"vextract<shuffletype>64x4\\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}\"\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"evex\")\n@@ -6487,13 +6531,9 @@\n   else\n     return \"#\";\n }\n-  [(set_attr \"type\" \"sselog\")\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n-   (set (attr \"memory\")\n-      (if_then_else (match_test \"MEM_P (operands[0])\")\n-\t(const_string \"store\")\n-\t(const_string \"none\")))\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n@@ -6523,13 +6563,28 @@\n             (const_int 6) (const_int 7)])))]\n   \"TARGET_AVX512F\"\n   \"vextract<shuffletype>64x4\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\"\n-  [(set_attr \"type\" \"sselog\")\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"vec_extract_hi_<mode>_maskm\"\n+   [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+\t(vec_merge:<ssehalfvecmode>\n+\t  (vec_select:<ssehalfvecmode>\n+\t    (match_operand:V16FI 1 \"register_operand\" \"v\")\n+\t    (parallel [(const_int 8) (const_int 9)\n+\t      (const_int 10) (const_int 11)\n+\t      (const_int 12) (const_int 13)\n+\t      (const_int 14) (const_int 15)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"k\")))]\n+  \"TARGET_AVX512DQ\"\n+  \"vextract<shuffletype>32x8\\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}\"\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n-   (set (attr \"memory\")\n-      (if_then_else (match_test \"MEM_P (operands[0])\")\n-\t(const_string \"store\")\n-\t(const_string \"none\")))\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n@@ -6541,7 +6596,7 @@\n             (const_int 10) (const_int 11)\n \t    (const_int 12) (const_int 13)\n \t    (const_int 14) (const_int 15)])))]\n-  \"TARGET_AVX512F && (!<mask_applied> || TARGET_AVX512DQ)\"\n+  \"TARGET_AVX512F && <mask_avx512dq_condition>\"\n   \"@\n    vextract<shuffletype>32x8\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\n    vextracti64x4\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n@@ -6552,6 +6607,35 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n+(define_expand \"avx512vl_vextractf128<mode>\"\n+  [(match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n+   (match_operand:VI48F_256 1 \"register_operand\")\n+   (match_operand:SI 2 \"const_0_to_1_operand\")\n+   (match_operand:<ssehalfvecmode> 3 \"vector_move_operand\")\n+   (match_operand:QI 4 \"register_operand\")]\n+  \"TARGET_AVX512DQ && TARGET_AVX512VL\"\n+{\n+  rtx (*insn)(rtx, rtx, rtx, rtx);\n+\n+  if (MEM_P (operands[0]) && GET_CODE (operands[3]) == CONST_VECTOR)\n+    operands[0] = force_reg (<ssehalfvecmode>mode, operands[0]);\n+\n+  switch (INTVAL (operands[2]))\n+    {\n+    case 0:\n+      insn = gen_vec_extract_lo_<mode>_mask;\n+      break;\n+    case 1:\n+      insn = gen_vec_extract_hi_<mode>_mask;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (insn (operands[0], operands[1], operands[3], operands[4]));\n+  DONE;\n+})\n+\n (define_expand \"avx_vextractf128<mode>\"\n   [(match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n    (match_operand:V_256 1 \"register_operand\")\n@@ -6576,19 +6660,36 @@\n   DONE;\n })\n \n-(define_insn_and_split \"vec_extract_lo_<mode>\"\n+(define_insn \"vec_extract_lo_<mode><mask_name>\"\n   [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n \t(vec_select:<ssehalfvecmode>\n \t  (match_operand:V16FI 1 \"nonimmediate_operand\" \"vm,v\")\n \t  (parallel [(const_int 0) (const_int 1)\n                      (const_int 2) (const_int 3)\n                      (const_int 4) (const_int 5)\n                      (const_int 6) (const_int 7)])))]\n-  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n+  \"TARGET_AVX512F\n+   && <mask_mode512bit_condition>\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n+  if (<mask_applied>)\n+    return \"vextract<shuffletype>32x8\\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}\";\n+  else\n+    return \"#\";\n+})\n+\n+(define_split\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n+\t(vec_select:<ssehalfvecmode>\n+\t  (match_operand:V16FI 1 \"nonimmediate_operand\")\n+\t  (parallel [(const_int 0) (const_int 1)\n+            (const_int 2) (const_int 3)\n+\t    (const_int 4) (const_int 5)\n+\t    (const_int 6) (const_int 7)])))]\n+  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && reload_completed\"\n+   [(const_int 0)]\n+ {\n   rtx op1 = operands[1];\n   if (REG_P (op1))\n     op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n@@ -6598,66 +6699,159 @@\n   DONE;\n })\n \n-(define_insn_and_split \"vec_extract_lo_<mode>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=x,m\")\n+(define_insn \"vec_extract_lo_<mode><mask_name>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=v,m\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI8F_256 1 \"nonimmediate_operand\" \"xm,x\")\n+\t  (match_operand:VI8F_256 1 \"nonimmediate_operand\" \"vm,v\")\n \t  (parallel [(const_int 0) (const_int 1)])))]\n-  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))]\n+  \"TARGET_AVX\n+   && <mask_avx512vl_condition> && <mask_avx512dq_condition>\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (operands[1]));\n+  if (<mask_applied>)\n+    return \"vextract<shuffletype>64x2\\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}\";\n   else\n-    operands[1] = adjust_address (operands[1], <ssehalfvecmode>mode, 0);\n+    return \"#\";\n+}\n+   [(set_attr \"type\" \"sselog\")\n+    (set_attr \"prefix_extra\" \"1\")\n+    (set_attr \"length_immediate\" \"1\")\n+    (set_attr \"memory\" \"none,store\")\n+    (set_attr \"prefix\" \"evex\")\n+    (set_attr \"mode\" \"XI\")])\n+\n+(define_split\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n+\t(vec_select:<ssehalfvecmode>\n+\t  (match_operand:VI8F_256 1 \"nonimmediate_operand\")\n+\t  (parallel [(const_int 0) (const_int 1)])))]\n+  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+  && reload_completed\"\n+   [(const_int 0)]\n+{\n+  rtx op1 = operands[1];\n+  if (REG_P (op1))\n+    op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n+  else\n+    op1 = gen_lowpart (<ssehalfvecmode>mode, op1);\n+  emit_move_insn (operands[0], op1);\n+  DONE;\n })\n \n-(define_insn \"vec_extract_hi_<mode>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=x,m\")\n+(define_insn \"vec_extract_hi_<mode><mask_name>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=v,<store_mask_constraint>\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI8F_256 1 \"register_operand\" \"x,x\")\n+\t  (match_operand:VI8F_256 1 \"register_operand\" \"v,v\")\n \t  (parallel [(const_int 2) (const_int 3)])))]\n   \"TARGET_AVX\"\n-  \"vextract<i128>\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n+{\n+  if (TARGET_AVX512DQ && TARGET_AVX512VL)\n+    return \"vextract<shuffletype>64x2\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\";\n+  else\n+    return \"vextract<i128>\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+}\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"memory\" \"none,store\")\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn_and_split \"vec_extract_lo_<mode>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=x,m\")\n+(define_split\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI4F_256 1 \"nonimmediate_operand\" \"xm,x\")\n+\t  (match_operand:VI4F_256 1 \"nonimmediate_operand\")\n \t  (parallel [(const_int 0) (const_int 1)\n \t\t     (const_int 2) (const_int 3)])))]\n-  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))]\n+  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1])) && reload_completed\"\n+   [(const_int 0)]\n {\n-  if (REG_P (operands[1]))\n-    operands[1] = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (operands[1]));\n+  rtx op1 = operands[1];\n+  if (REG_P (op1))\n+    op1 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op1));\n   else\n-    operands[1] = adjust_address (operands[1], <ssehalfvecmode>mode, 0);\n+    op1 = gen_lowpart (<ssehalfvecmode>mode, op1);\n+  emit_move_insn (operands[0], op1);\n+  DONE;\n })\n \n-(define_insn \"vec_extract_hi_<mode>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=x,m\")\n+\n+(define_insn \"vec_extract_lo_<mode><mask_name>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n+\t(vec_select:<ssehalfvecmode>\n+\t  (match_operand:VI4F_256 1 \"nonimmediate_operand\" \"v\")\n+\t  (parallel [(const_int 0) (const_int 1)\n+\t\t     (const_int 2) (const_int 3)])))]\n+  \"TARGET_AVX && <mask_avx512vl_condition> && <mask_avx512dq_condition>\"\n+{\n+  if (<mask_applied>)\n+    return \"vextract<shuffletype>32x4\\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}\";\n+  else\n+    return \"#\";\n+}\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"vec_extract_lo_<mode>_maskm\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+\t(vec_merge:<ssehalfvecmode>\n+\t  (vec_select:<ssehalfvecmode>\n+\t    (match_operand:VI4F_256 1 \"register_operand\" \"v\")\n+\t    (parallel [(const_int 0) (const_int 1)\n+\t\t      (const_int 2) (const_int 3)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"k\")))]\n+  \"TARGET_AVX512VL && TARGET_AVX512F\"\n+  \"vextract<shuffletype>32x4\\t{$0x0, %1, %0%{3%}|%0%{%3%}, %1, 0x0}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"vec_extract_hi_<mode>_maskm\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+\t(vec_merge:<ssehalfvecmode>\n+\t  (vec_select:<ssehalfvecmode>\n+\t    (match_operand:VI4F_256 1 \"register_operand\" \"v\")\n+\t    (parallel [(const_int 4) (const_int 5)\n+\t\t      (const_int 6) (const_int 7)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n+\t  (match_operand:<ssehalfvecmode> 3 \"register_operand\" \"k\")))]\n+  \"TARGET_AVX512F && TARGET_AVX512VL\"\n+{\n+  return \"vextract<shuffletype>32x4\\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}\";\n+}\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"vec_extract_hi_<mode><mask_name>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI4F_256 1 \"register_operand\" \"x,x\")\n+\t  (match_operand:VI4F_256 1 \"register_operand\" \"v\")\n \t  (parallel [(const_int 4) (const_int 5)\n \t\t     (const_int 6) (const_int 7)])))]\n-  \"TARGET_AVX\"\n-  \"vextract<i128>\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n-  [(set_attr \"type\" \"sselog\")\n+  \"TARGET_AVX && <mask_avx512vl_condition>\"\n+{\n+  if (TARGET_AVX512VL)\n+    return \"vextract<shuffletype>32x4\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\";\n+  else\n+    return \"vextract<i128>\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+}\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"memory\" \"none,store\")\n-   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"prefix\")\n+     (if_then_else\n+       (match_test \"TARGET_AVX512VL\")\n+     (const_string \"evex\")\n+     (const_string \"vex\")))\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n (define_insn_and_split \"vec_extract_lo_v32hi\"\n@@ -6846,8 +7040,8 @@\n \n ;; Modes handled by vec_extract patterns.\n (define_mode_iterator VEC_EXTRACT_MODE\n-  [(V32QI \"TARGET_AVX\") V16QI\n-   (V16HI \"TARGET_AVX\") V8HI\n+  [(V64QI \"TARGET_AVX512BW\") (V32QI \"TARGET_AVX\") V16QI\n+   (V32HI \"TARGET_AVX512BW\") (V16HI \"TARGET_AVX\") V8HI\n    (V16SI \"TARGET_AVX512F\") (V8SI \"TARGET_AVX\") V4SI\n    (V8DI \"TARGET_AVX512F\") (V4DI \"TARGET_AVX\") V2DI\n    (V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n@@ -16498,7 +16692,7 @@\n \t\t\t(match_operand:SI 2 \"const_0_to_255_operand\" \"N\")]\n \t\t       UNSPEC_VCVTPS2PH)\n \t  (match_operand:V4HI 3 \"const0_operand\")))]\n-  \"TARGET_F16C && <mask_avx512vl_condition>\"\n+  \"(TARGET_F16C || TARGET_AVX512VL) && <mask_avx512vl_condition>\"\n   \"vcvtps2ph\\t{%2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2}\"\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"prefix\" \"maybe_evex\")"}, {"sha": "91228c8976b8a15edeba6631249f46b145bc8cfc", "filename": "gcc/config/i386/subst.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2Fconfig%2Fi386%2Fsubst.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0774c1603b48fdf17bb605d4d7dc17d39794d19d/gcc%2Fconfig%2Fi386%2Fsubst.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsubst.md?ref=0774c1603b48fdf17bb605d4d7dc17d39794d19d", "patch": "@@ -57,6 +57,7 @@\n (define_subst_attr \"mask_mode512bit_condition\" \"mask\" \"1\" \"(<MODE_SIZE> == 64 || TARGET_AVX512VL)\")\n (define_subst_attr \"mask_avx512vl_condition\" \"mask\" \"1\" \"TARGET_AVX512VL\")\n (define_subst_attr \"mask_avx512bw_condition\" \"mask\" \"1\" \"TARGET_AVX512BW\")\n+(define_subst_attr \"mask_avx512dq_condition\" \"mask\" \"1\" \"TARGET_AVX512DQ\")\n (define_subst_attr \"store_mask_constraint\" \"mask\" \"vm\" \"v\")\n (define_subst_attr \"store_mask_predicate\" \"mask\" \"nonimmediate_operand\" \"register_operand\")\n (define_subst_attr \"mask_prefix\" \"mask\" \"vex\" \"evex\")"}]}