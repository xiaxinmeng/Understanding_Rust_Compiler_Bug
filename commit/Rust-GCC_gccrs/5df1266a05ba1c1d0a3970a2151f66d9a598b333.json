{"sha": "5df1266a05ba1c1d0a3970a2151f66d9a598b333", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRmMTI2NmEwNWJhMWMxZDBhMzk3MGEyMTUxZjY2ZDlhNTk4YjMzMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T12:55:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T12:55:50Z"}, "message": "[multiple changes]\n\n2012-07-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb (Check_Component_Storage_Order): Do not reject a\n\tnested composite with different scalar storage order if it is\n\tbyte aligned.\n\n2012-07-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* gnat_rm.texi: Update documentation for Scalar_Storage_Order.\n\n2012-07-16  Tristan Gingold  <gingold@adacore.com>\n\n\t* a-exexpr.adb (Propagate_Exception): Adjust call to\n\tException_Traces procedures.\n\t* a-exexpr-gcc.adb (Setup_Current_Excep): Now a\n\tfunction that returns an access to the Ada occurrence.\n\t(Propagate_GCC_Exception): Adjust calls.\n\t* raise.h (struct Exception_Occurrence): Declare.\n\t* a-exextr.adb: Remove useless pragma.\t(Notify_Handled_Exception,\n\tNotify_Unhandled_Exception) (Unhandled_Exception_Terminate):\n\tAdd Excep parameter.\n\t* a-except.adb (Notify_Handled_Exception,\n\tNotify_Unhandled_Exception) (Unhandled_Exception_Terminate):\n\tAdd Excep parameter.\n\t(Process_Raise_Exception): Adjust calls.\n\t* a-except-2005.adb (Notify_Handled_Exception,\n\tNotify_Unhandled_Exception) (Unhandled_Exception_Terminate): Add\n\tExcep parameter.\n\t(Raise_Exception): Calls Raise_Exception_Always.\n\t* raise-gcc.c (__gnat_setup_current_excep,\n\t__gnat_notify_handled_exception)\n\t(__gnat_notify_unhandled_exception): Adjust declarations.\n\t(PERSONALITY_FUNCTION): Adjust calls.\n\t(__gnat_personality_seh0): Remove warning.\n\n2012-07-16  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_eval.adb (Test_Expression_Is_Foldable): Adding documentation.\n\t(Eval_Relational_Op): Adding documentation.\n\nFrom-SVN: r189532", "tree": {"sha": "15da4473a32f859d7ef09103804af2ae6a9451ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15da4473a32f859d7ef09103804af2ae6a9451ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5df1266a05ba1c1d0a3970a2151f66d9a598b333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5df1266a05ba1c1d0a3970a2151f66d9a598b333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5df1266a05ba1c1d0a3970a2151f66d9a598b333", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5df1266a05ba1c1d0a3970a2151f66d9a598b333/comments", "author": null, "committer": null, "parents": [{"sha": "e187fa72fb4806da5b93af1d346446b9fc7f0993", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e187fa72fb4806da5b93af1d346446b9fc7f0993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e187fa72fb4806da5b93af1d346446b9fc7f0993"}], "stats": {"total": 433, "additions": 255, "deletions": 178}, "files": [{"sha": "b18dbac96e976bf23215d29e74bb95c0f867ca4b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -1,3 +1,43 @@\n+2012-07-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb (Check_Component_Storage_Order): Do not reject a\n+\tnested composite with different scalar storage order if it is\n+\tbyte aligned.\n+\n+2012-07-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gnat_rm.texi: Update documentation for Scalar_Storage_Order.\n+\n+2012-07-16  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* a-exexpr.adb (Propagate_Exception): Adjust call to\n+\tException_Traces procedures.\n+\t* a-exexpr-gcc.adb (Setup_Current_Excep): Now a\n+\tfunction that returns an access to the Ada occurrence.\n+\t(Propagate_GCC_Exception): Adjust calls.\n+\t* raise.h (struct Exception_Occurrence): Declare.\n+\t* a-exextr.adb: Remove useless pragma.\t(Notify_Handled_Exception,\n+\tNotify_Unhandled_Exception) (Unhandled_Exception_Terminate):\n+\tAdd Excep parameter.\n+\t* a-except.adb (Notify_Handled_Exception,\n+\tNotify_Unhandled_Exception) (Unhandled_Exception_Terminate):\n+\tAdd Excep parameter.\n+\t(Process_Raise_Exception): Adjust calls.\n+\t* a-except-2005.adb (Notify_Handled_Exception,\n+\tNotify_Unhandled_Exception) (Unhandled_Exception_Terminate): Add\n+\tExcep parameter.\n+\t(Raise_Exception): Calls Raise_Exception_Always.\n+\t* raise-gcc.c (__gnat_setup_current_excep,\n+\t__gnat_notify_handled_exception)\n+\t(__gnat_notify_unhandled_exception): Adjust declarations.\n+\t(PERSONALITY_FUNCTION): Adjust calls.\n+\t(__gnat_personality_seh0): Remove warning.\n+\n+2012-07-16  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_eval.adb (Test_Expression_Is_Foldable): Adding documentation.\n+\t(Eval_Relational_Op): Adding documentation.\n+\n 2012-07-16  Robert Dewar  <dewar@adacore.com>\n \n \t* freeze.adb, g-debpoo.adb, exp_ch3.adb: Minor reformatting."}, {"sha": "c69c7762476e8bbd5a4ed9f869ced084453c4bec", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -209,19 +209,19 @@ package body Ada.Exceptions is\n       --  exported to be usable by the Ada exception handling personality\n       --  routine when the GCC 3 mechanism is used.\n \n-      procedure Notify_Handled_Exception;\n+      procedure Notify_Handled_Exception (Excep : EOA);\n       pragma Export\n         (C, Notify_Handled_Exception, \"__gnat_notify_handled_exception\");\n       --  This routine is called for a handled occurrence is about to be\n       --  propagated.\n \n-      procedure Notify_Unhandled_Exception;\n+      procedure Notify_Unhandled_Exception (Excep : EOA);\n       pragma Export\n         (C, Notify_Unhandled_Exception, \"__gnat_notify_unhandled_exception\");\n       --  This routine is called when an unhandled occurrence is about to be\n       --  propagated.\n \n-      procedure Unhandled_Exception_Terminate;\n+      procedure Unhandled_Exception_Terminate (Excep : EOA);\n       pragma No_Return (Unhandled_Exception_Terminate);\n       --  This procedure is called to terminate execution following an\n       --  unhandled exception. The exception information, including\n@@ -395,15 +395,16 @@ package body Ada.Exceptions is\n    --  Reraises the exception referenced by the Current_Excep field of\n    --  the TSD (all fields of this exception occurrence are set). Abort\n    --  is deferred before the reraise operation.\n+   --  Called from System.Tasking.RendezVous.Exceptional_Complete_RendezVous\n \n    procedure Transfer_Occurrence\n      (Target : Exception_Occurrence_Access;\n       Source : Exception_Occurrence);\n    pragma Export (C, Transfer_Occurrence, \"__gnat_transfer_occurrence\");\n-   --  Called from System.Tasking.RendezVous.Exceptional_Complete_RendezVous\n-   --  to setup Target from Source as an exception to be propagated in the\n-   --  caller task. Target is expected to be a pointer to the fixed TSD\n-   --  occurrence for this task.\n+   --  Called from s-tasren.adb:Local_Complete_RendezVous and\n+   --  s-tpobop.adb:Exceptional_Complete_Entry_Body to setup Target from\n+   --  Source as an exception to be propagated in the caller task. Target is\n+   --  expected to be a pointer to the fixed TSD occurrence for this task.\n \n    -----------------------------\n    -- Run-Time Check Routines --\n@@ -953,8 +954,6 @@ package body Ada.Exceptions is\n       Message : String := \"\")\n    is\n       EF : Exception_Id := E;\n-      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-\n    begin\n       --  Raise CE if E = Null_ID (AI-446)\n \n@@ -964,14 +963,7 @@ package body Ada.Exceptions is\n \n       --  Go ahead and raise appropriate exception\n \n-      Exception_Data.Set_Exception_Msg (X, EF, Message);\n-\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Complete_Occurrence (X);\n-      Exception_Propagation.Propagate_Exception (X);\n+      Raise_Exception_Always (EF, Message);\n    end Raise_Exception;\n \n    ----------------------------"}, {"sha": "3d3ba615cc70fc7be495107dbbe1578e0184d5ce", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -189,19 +189,19 @@ package body Ada.Exceptions is\n       --  exported to be usable by the Ada exception handling personality\n       --  routine when the GCC 3 mechanism is used.\n \n-      procedure Notify_Handled_Exception;\n+      procedure Notify_Handled_Exception (Excep : EOA);\n       pragma Export\n         (C, Notify_Handled_Exception, \"__gnat_notify_handled_exception\");\n       --  This routine is called for a handled occurrence is about to be\n       --  propagated.\n \n-      procedure Notify_Unhandled_Exception;\n+      procedure Notify_Unhandled_Exception (Excep : EOA);\n       pragma Export\n         (C, Notify_Unhandled_Exception, \"__gnat_notify_unhandled_exception\");\n       --  This routine is called when an unhandled occurrence is about to be\n       --  propagated.\n \n-      procedure Unhandled_Exception_Terminate;\n+      procedure Unhandled_Exception_Terminate (Excep : EOA);\n       pragma No_Return (Unhandled_Exception_Terminate);\n       --  This procedure is called to terminate program execution following an\n       --  unhandled exception. The exception information, including traceback\n@@ -895,14 +895,14 @@ package body Ada.Exceptions is\n       if Jumpbuf_Ptr /= Null_Address then\n          if not Excep.Exception_Raised then\n             Excep.Exception_Raised := True;\n-            Exception_Traces.Notify_Handled_Exception;\n+            Exception_Traces.Notify_Handled_Exception (Excep);\n          end if;\n \n          builtin_longjmp (Jumpbuf_Ptr, 1);\n \n       else\n-         Exception_Traces.Notify_Unhandled_Exception;\n-         Exception_Traces.Unhandled_Exception_Terminate;\n+         Exception_Traces.Notify_Unhandled_Exception (Excep);\n+         Exception_Traces.Unhandled_Exception_Terminate (Excep);\n       end if;\n    end Process_Raise_Exception;\n "}, {"sha": "e266cb442c121023ce5edd499d0b67a794f46e1b", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -202,8 +202,9 @@ package body Exception_Propagation is\n    --  Called to implement raise without exception, ie reraise.  Called\n    --  directly from gigi.\n \n-   procedure Setup_Current_Excep\n-     (GCC_Exception : not null GCC_Exception_Access);\n+   function Setup_Current_Excep\n+     (GCC_Exception : not null GCC_Exception_Access)\n+     return EOA;\n    pragma Export (C, Setup_Current_Excep, \"__gnat_setup_current_excep\");\n    --  Write Get_Current_Excep.all from GCC_Exception\n \n@@ -342,8 +343,9 @@ package body Exception_Propagation is\n    -- Setup_Current_Excep --\n    -------------------------\n \n-   procedure Setup_Current_Excep\n+   function Setup_Current_Excep\n      (GCC_Exception : not null GCC_Exception_Access)\n+     return EOA\n    is\n       Excep : constant EOA := Get_Current_Excep.all;\n \n@@ -359,6 +361,8 @@ package body Exception_Propagation is\n                                 To_GNAT_GCC_Exception (GCC_Exception);\n          begin\n             Excep.all := GNAT_Occurrence.Occurrence;\n+\n+            return GNAT_Occurrence.Occurrence'Access;\n          end;\n       else\n \n@@ -370,6 +374,8 @@ package body Exception_Propagation is\n          Excep.Exception_Raised := True;\n          Excep.Pid := Local_Partition_ID;\n          Excep.Num_Tracebacks := 0;\n+\n+         return Excep;\n       end if;\n    end Setup_Current_Excep;\n \n@@ -420,6 +426,7 @@ package body Exception_Propagation is\n    procedure Propagate_GCC_Exception\n      (GCC_Exception : not null GCC_Exception_Access)\n    is\n+      Excep : EOA;\n    begin\n       --  Perform a standard raise first. If a regular handler is found, it\n       --  will be entered after all the intermediate cleanups have run. If\n@@ -432,8 +439,8 @@ package body Exception_Propagation is\n       --  the necessary steps to enable the debugger to gain control while the\n       --  stack is still intact.\n \n-      Setup_Current_Excep (GCC_Exception);\n-      Notify_Unhandled_Exception;\n+      Excep := Setup_Current_Excep (GCC_Exception);\n+      Notify_Unhandled_Exception (Excep);\n \n       --  Now, un a forced unwind to trigger cleanups. Control should not\n       --  resume there, if there are cleanups and in any cases as the\n@@ -466,9 +473,10 @@ package body Exception_Propagation is\n    procedure Unhandled_Except_Handler\n      (GCC_Exception : not null GCC_Exception_Access)\n    is\n+      Excep : EOA;\n    begin\n-      Setup_Current_Excep (GCC_Exception);\n-      Unhandled_Exception_Terminate;\n+      Excep := Setup_Current_Excep (GCC_Exception);\n+      Unhandled_Exception_Terminate (Excep);\n    end Unhandled_Except_Handler;\n \n    -------------"}, {"sha": "bf5f680d8b14c59086baf549acfd1d69854446f9", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -43,7 +43,7 @@ package body Exception_Propagation is\n    pragma No_Return (builtin_longjmp);\n    pragma Import (Intrinsic, builtin_longjmp, \"__builtin_longjmp\");\n \n-   procedure Propagate_Continue (Excep : EOA);\n+   procedure Propagate_Continue (E : Exception_Id);\n    pragma No_Return (Propagate_Continue);\n    pragma Export (C, Propagate_Continue, \"__gnat_raise_nodefer_with_msg\");\n    --  A call to this procedure is inserted automatically by GIGI, in order\n@@ -74,24 +74,25 @@ package body Exception_Propagation is\n       if Jumpbuf_Ptr /= Null_Address then\n          if not Excep.Exception_Raised then\n             Excep.Exception_Raised := True;\n-            Exception_Traces.Notify_Handled_Exception;\n+            Exception_Traces.Notify_Handled_Exception (Excep);\n          end if;\n \n          builtin_longjmp (Jumpbuf_Ptr, 1);\n \n       else\n-         Exception_Traces.Notify_Unhandled_Exception;\n-         Exception_Traces.Unhandled_Exception_Terminate;\n+         Exception_Traces.Notify_Unhandled_Exception (Excep);\n+         Exception_Traces.Unhandled_Exception_Terminate (Excep);\n       end if;\n    end Propagate_Exception;\n \n    ------------------------\n    -- Propagate_Continue --\n    ------------------------\n \n-   procedure Propagate_Continue (Excep : EOA) is\n+   procedure Propagate_Continue (E : Exception_Id) is\n+      pragma Unreferenced (E);\n    begin\n-      Propagate_Exception (Excep);\n+      Propagate_Exception (Get_Current_Excep.all);\n    end Propagate_Continue;\n \n end Exception_Propagation;"}, {"sha": "fe4b706f7ee304719782d1be31bfb97960b388a5", "filename": "gcc/ada/a-exextr.adb", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-exextr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fa-exextr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exextr.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -72,17 +72,6 @@ package body Exception_Traces is\n    --  latter case because Notify_Handled_Exception may be called for an\n    --  actually unhandled occurrence in the Front-End-SJLJ case.\n \n-   --------------------------------\n-   -- Import Run-Time C Routines --\n-   --------------------------------\n-\n-   --  The purpose of the following pragma Import is to ensure that we\n-   --  generate appropriate subprogram descriptors for all C routines in\n-   --  the standard GNAT library that can raise exceptions. This ensures\n-   --  that the exception propagation can properly find these routines\n-\n-   pragma Propagate_Exceptions;\n-\n    ----------------------\n    -- Notify_Exception --\n    ----------------------\n@@ -132,18 +121,16 @@ package body Exception_Traces is\n    -- Notify_Handled_Exception --\n    ------------------------------\n \n-   procedure Notify_Handled_Exception is\n+   procedure Notify_Handled_Exception (Excep : EOA) is\n    begin\n-      Notify_Exception (Get_Current_Excep.all, Is_Unhandled => False);\n+      Notify_Exception (Excep, Is_Unhandled => False);\n    end Notify_Handled_Exception;\n \n    --------------------------------\n    -- Notify_Unhandled_Exception --\n    --------------------------------\n \n-   procedure Notify_Unhandled_Exception is\n-      Excep : constant EOA := Get_Current_Excep.all;\n-\n+   procedure Notify_Unhandled_Exception (Excep : EOA) is\n    begin\n       --  Check whether there is any termination handler to be executed for\n       --  the environment task, and execute it if needed. Here we handle both\n@@ -161,8 +148,8 @@ package body Exception_Traces is\n    -- Unhandled_Exception_Terminate --\n    -----------------------------------\n \n-   procedure Unhandled_Exception_Terminate is\n-      Excep : Exception_Occurrence;\n+   procedure Unhandled_Exception_Terminate (Excep : EOA) is\n+      Occ : Exception_Occurrence;\n       --  This occurrence will be used to display a message after finalization.\n       --  It is necessary to save a copy here, or else the designated value\n       --  could be overwritten if an exception is raised during finalization\n@@ -172,8 +159,8 @@ package body Exception_Traces is\n       --  that there is enough room on the stack however.\n \n    begin\n-      Save_Occurrence (Excep, Get_Current_Excep.all.all);\n-      Last_Chance_Handler (Excep);\n+      Save_Occurrence (Occ, Excep.all);\n+      Last_Chance_Handler (Occ);\n    end Unhandled_Exception_Terminate;\n \n    ------------------------------------"}, {"sha": "9b9f6189700c57ff691a96715771f03d0d657a99", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -1029,6 +1029,10 @@ package body Freeze is\n       Err_Node  : Node_Id;\n       ADC       : Node_Id;\n \n+      Comp_Byte_Aligned : Boolean;\n+      --  Set True for the record case, when Comp starts on a byte boundary\n+      --  (in which case it is allowed to have different storage order).\n+\n    begin\n       --  Record case\n \n@@ -1037,13 +1041,18 @@ package body Freeze is\n          Comp_Type := Etype (Comp);\n          Comp_Def  := Component_Definition (Parent (Comp));\n \n+         Comp_Byte_Aligned := Present (Component_Clause (Comp))\n+           and then Normalized_First_Bit (Comp) mod System_Storage_Unit = 0;\n+\n       --  Array case\n \n       else\n          Err_Node  := Encl_Type;\n          Comp_Type := Component_Type (Encl_Type);\n          Comp_Def  := Component_Definition\n                         (Type_Definition (Declaration_Node (Encl_Type)));\n+\n+         Comp_Byte_Aligned := False;\n       end if;\n \n       --  Note: the Reverse_Storage_Order flag is set on the base type, but\n@@ -1054,14 +1063,20 @@ package body Freeze is\n                (First_Subtype (Comp_Type),\n                 Attribute_Scalar_Storage_Order);\n \n-      if (Is_Record_Type (Comp_Type) or else Is_Array_Type (Comp_Type))\n-           and then\n-             (No (ADC) or else Reverse_Storage_Order (Encl_Type) /=\n-                               Reverse_Storage_Order (Etype (Comp_Type)))\n-      then\n-         Error_Msg_N\n-           (\"component type must have same scalar storage order as \"\n-            & \"enclosing composite\", Err_Node);\n+      if Is_Record_Type (Comp_Type) or else Is_Array_Type (Comp_Type) then\n+         if No (ADC) then\n+            Error_Msg_N (\"nested composite must have explicit scalar \"\n+                         & \"storage order\", Err_Node);\n+\n+         elsif (Reverse_Storage_Order (Encl_Type)\n+                  /=\n+                Reverse_Storage_Order (Etype (Comp_Type)))\n+           and then not Comp_Byte_Aligned\n+         then\n+            Error_Msg_N\n+              (\"type of non-byte-aligned component must have same scalar \"\n+               & \"storage order as enclosing composite\", Err_Node);\n+         end if;\n \n       elsif Aliased_Present (Comp_Def) then\n          Error_Msg_N"}, {"sha": "0c860910d7d2a5f3159e94bdf2234e1f8410c45f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -6709,7 +6709,7 @@ this attribute.\n @cindex Scalar storage order\n @findex Scalar_Storage_Order\n @noindent\n-For every record subtype @var{S}, the representation attribute\n+For every array or record type @var{S}, the representation attribute\n @code{Scalar_Storage_Order} denotes the order in which storage elements\n that make up scalar components are ordered within S. Other properties are\n as for standard representation attribute @code{Bit_Order}, as defined by\n@@ -6721,6 +6721,11 @@ equal to @code{@var{S}'Bit_Order}. Note: This means that if a\n then the type's @code{Bit_Order} shall be specified explicitly and set to\n the same value.\n \n+If a component of S has itself a record or array type, then it shall also\n+have a @code{Scalar_Storage_Order} attribute definition clause. In addition,\n+if the component does not start on a byte boundary, then the scalar storage\n+order specified for S and for the nested component type shall be identical.\n+\n A confirming @code{Scalar_Storage_Order} attribute definition clause (i.e.\n with a value equal to @code{System.Default_Bit_Order}) has no effect.\n "}, {"sha": "418e080d51dda6fc516ccc90b4cef17029afbda1", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -77,7 +77,8 @@ __gnat_Unwind_RaiseException (_Unwind_Exception *);\n _Unwind_Reason_Code\n __gnat_Unwind_ForcedUnwind (_Unwind_Exception *, void *, void *);\n \n-extern void __gnat_setup_current_excep (_Unwind_Exception *);\n+extern struct Exception_Occurrence *__gnat_setup_current_excep\n+ (_Unwind_Exception *);\n extern void __gnat_unhandled_except_handler (_Unwind_Exception *);\n \n #include \"dwarf2.h\"\n@@ -1001,8 +1002,8 @@ setup_to_install (_Unwind_Context *uw_context,\n /* The following is defined from a-except.adb. Its purpose is to enable\n    automatic backtraces upon exception raise, as provided through the\n    GNAT.Traceback facilities.  */\n-extern void __gnat_notify_handled_exception (void);\n-extern void __gnat_notify_unhandled_exception (void);\n+extern void __gnat_notify_handled_exception (struct Exception_Occurrence *);\n+extern void __gnat_notify_unhandled_exception (struct Exception_Occurrence *);\n \n /* Below is the eh personality routine per se. We currently assume that only\n    GNU-Ada exceptions are met.  */\n@@ -1131,14 +1132,16 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n \t}\n       else\n \t{\n+\t  struct Exception_Occurrence *excep;\n+\n \t  /* Trigger the appropriate notification routines before the second\n \t     phase starts, which ensures the stack is still intact.\n              First, setup the Ada occurrence.  */\n-          __gnat_setup_current_excep (uw_exception);\n+          excep = __gnat_setup_current_excep (uw_exception);\n \t  if (action.kind == unhandler)\n-\t    __gnat_notify_unhandled_exception ();\n+\t    __gnat_notify_unhandled_exception (excep);\n \t  else\n-\t    __gnat_notify_handled_exception ();\n+\t    __gnat_notify_handled_exception (excep);\n \n \t  return _URC_HANDLER_FOUND;\n \t}\n@@ -1324,7 +1327,7 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t  CONTEXT context;\n \t  PRUNTIME_FUNCTION mf_func = NULL;\n \t  ULONG64 mf_imagebase;\n-\t  ULONG64 mf_rsp;\n+\t  ULONG64 mf_rsp = 0;\n \n \t  /* Get the context.  */\n \t  RtlCaptureContext (&context);"}, {"sha": "57611542350cfd6d66b7d88478e79cb226e2d0aa", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -49,6 +49,8 @@ struct Exception_Data\n \n typedef struct Exception_Data *Exception_Id;\n \n+struct Exception_Occurrence;\n+\n extern void _gnat_builtin_longjmp\t(void *, int);\n extern void __gnat_unhandled_terminate\t(void);\n extern void *__gnat_malloc\t\t(__SIZE_TYPE__);"}, {"sha": "1268ee4f45d8ee164653e658c8da0bc52a15feca", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 130, "deletions": 106, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df1266a05ba1c1d0a3970a2151f66d9a598b333/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=5df1266a05ba1c1d0a3970a2151f66d9a598b333", "patch": "@@ -214,6 +214,16 @@ package body Sem_Eval is\n    --  e.g. in the two operand case below, for string comparison, the result\n    --  is not static even though the two operands are static. In such cases,\n    --  the caller must reset the Is_Static_Expression flag in N.\n+   --\n+   --  If Fold and Stat are both set to False then this routine performs also\n+   --  the following extra actions:\n+   --\n+   --    * If either operand is Any_Type then propagate it to result to\n+   --      prevent cascaded errors.\n+   --\n+   --    * If some operand raises constraint error, then replace the node N\n+   --      with the raise constraint error node. This replacement inherits the\n+   --      Is_Static_Expression flag from the operands.\n \n    procedure Test_Expression_Is_Foldable\n      (N    : Node_Id;\n@@ -2702,8 +2712,6 @@ package body Sem_Eval is\n       Typ    : constant Entity_Id := Etype (Left);\n       Otype  : Entity_Id := Empty;\n       Result : Boolean;\n-      Stat   : Boolean;\n-      Fold   : Boolean;\n \n    begin\n       --  One special case to deal with first. If we can tell that the result\n@@ -2919,128 +2927,144 @@ package body Sem_Eval is\n          end Length_Mismatch;\n       end if;\n \n-      --  Test for expression being foldable\n-\n-      Test_Expression_Is_Foldable (N, Left, Right, Stat, Fold);\n-\n-      --  Only comparisons of scalars can give static results. In particular,\n-      --  comparisons of strings never yield a static result, even if both\n-      --  operands are static strings.\n-\n-      if not Is_Scalar_Type (Typ) then\n-         Stat := False;\n-         Set_Is_Static_Expression (N, False);\n-      end if;\n+      declare\n+         Is_Static_Expression : Boolean;\n+         Is_Foldable          : Boolean;\n+         pragma Unreferenced (Is_Foldable);\n \n-      --  For operators on universal numeric types called as functions with\n-      --  an explicit scope, determine appropriate specific numeric type, and\n-      --  diagnose possible ambiguity.\n+      begin\n+         --  Initialize the value of Is_Static_Expression. The value of\n+         --  Is_Foldable returned by Test_Expression_Is_Foldable is not needed\n+         --  since, even when some operand is a variable, we can still perform\n+         --  the static evaluation of the expression in some cases (for\n+         --  example, for a variable of a subtype of Integer we statically\n+         --  know that any value stored in such variable is smaller than\n+         --  Integer'Last).\n+\n+         Test_Expression_Is_Foldable\n+           (N, Left, Right, Is_Static_Expression, Is_Foldable);\n+\n+         --  Only comparisons of scalars can give static results. In\n+         --  particular, comparisons of strings never yield a static\n+         --  result, even if both operands are static strings.\n+\n+         if not Is_Scalar_Type (Typ) then\n+            Is_Static_Expression := False;\n+            Set_Is_Static_Expression (N, False);\n+         end if;\n \n-      if Is_Universal_Numeric_Type (Etype (Left))\n-           and then\n-         Is_Universal_Numeric_Type (Etype (Right))\n-      then\n-         Otype := Find_Universal_Operator_Type (N);\n-      end if;\n+         --  For operators on universal numeric types called as functions with\n+         --  an explicit scope, determine appropriate specific numeric type,\n+         --  and diagnose possible ambiguity.\n \n-      --  For static real type expressions, we cannot use Compile_Time_Compare\n-      --  since it worries about run-time results which are not exact.\n+         if Is_Universal_Numeric_Type (Etype (Left))\n+              and then\n+            Is_Universal_Numeric_Type (Etype (Right))\n+         then\n+            Otype := Find_Universal_Operator_Type (N);\n+         end if;\n \n-      if Stat and then Is_Real_Type (Typ) then\n-         declare\n-            Left_Real  : constant Ureal := Expr_Value_R (Left);\n-            Right_Real : constant Ureal := Expr_Value_R (Right);\n+         --  For static real type expressions, we cannot use\n+         --  Compile_Time_Compare since it worries about run-time\n+         --  results which are not exact.\n \n-         begin\n-            case Nkind (N) is\n-               when N_Op_Eq => Result := (Left_Real =  Right_Real);\n-               when N_Op_Ne => Result := (Left_Real /= Right_Real);\n-               when N_Op_Lt => Result := (Left_Real <  Right_Real);\n-               when N_Op_Le => Result := (Left_Real <= Right_Real);\n-               when N_Op_Gt => Result := (Left_Real >  Right_Real);\n-               when N_Op_Ge => Result := (Left_Real >= Right_Real);\n+         if Is_Static_Expression and then Is_Real_Type (Typ) then\n+            declare\n+               Left_Real  : constant Ureal := Expr_Value_R (Left);\n+               Right_Real : constant Ureal := Expr_Value_R (Right);\n \n-               when others =>\n-                  raise Program_Error;\n-            end case;\n+            begin\n+               case Nkind (N) is\n+                  when N_Op_Eq => Result := (Left_Real =  Right_Real);\n+                  when N_Op_Ne => Result := (Left_Real /= Right_Real);\n+                  when N_Op_Lt => Result := (Left_Real <  Right_Real);\n+                  when N_Op_Le => Result := (Left_Real <= Right_Real);\n+                  when N_Op_Gt => Result := (Left_Real >  Right_Real);\n+                  when N_Op_Ge => Result := (Left_Real >= Right_Real);\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n \n-            Fold_Uint (N, Test (Result), True);\n-         end;\n+               Fold_Uint (N, Test (Result), True);\n+            end;\n \n-      --  For all other cases, we use Compile_Time_Compare to do the compare\n+         --  For all other cases, we use Compile_Time_Compare to do the compare\n \n-      else\n-         declare\n-            CR : constant Compare_Result :=\n-                   Compile_Time_Compare (Left, Right, Assume_Valid => False);\n+         else\n+            declare\n+               CR : constant Compare_Result :=\n+                      Compile_Time_Compare\n+                        (Left, Right, Assume_Valid => False);\n \n-         begin\n-            if CR = Unknown then\n-               return;\n-            end if;\n+            begin\n+               if CR = Unknown then\n+                  return;\n+               end if;\n \n-            case Nkind (N) is\n-               when N_Op_Eq =>\n-                  if CR = EQ then\n-                     Result := True;\n-                  elsif CR = NE or else CR = GT or else CR = LT then\n-                     Result := False;\n-                  else\n-                     return;\n-                  end if;\n+               case Nkind (N) is\n+                  when N_Op_Eq =>\n+                     if CR = EQ then\n+                        Result := True;\n+                     elsif CR = NE or else CR = GT or else CR = LT then\n+                        Result := False;\n+                     else\n+                        return;\n+                     end if;\n \n-               when N_Op_Ne =>\n-                  if CR = NE or else CR = GT or else CR = LT then\n-                     Result := True;\n-                  elsif CR = EQ then\n-                     Result := False;\n-                  else\n-                     return;\n-                  end if;\n+                  when N_Op_Ne =>\n+                     if CR = NE or else CR = GT or else CR = LT then\n+                        Result := True;\n+                     elsif CR = EQ then\n+                        Result := False;\n+                     else\n+                        return;\n+                     end if;\n \n-               when N_Op_Lt =>\n-                  if CR = LT then\n-                     Result := True;\n-                  elsif CR = EQ or else CR = GT or else CR = GE then\n-                     Result := False;\n-                  else\n-                     return;\n-                  end if;\n+                  when N_Op_Lt =>\n+                     if CR = LT then\n+                        Result := True;\n+                     elsif CR = EQ or else CR = GT or else CR = GE then\n+                        Result := False;\n+                     else\n+                        return;\n+                     end if;\n \n-               when N_Op_Le =>\n-                  if CR = LT or else CR = EQ or else CR = LE then\n-                     Result := True;\n-                  elsif CR = GT then\n-                     Result := False;\n-                  else\n-                     return;\n-                  end if;\n+                  when N_Op_Le =>\n+                     if CR = LT or else CR = EQ or else CR = LE then\n+                        Result := True;\n+                     elsif CR = GT then\n+                        Result := False;\n+                     else\n+                        return;\n+                     end if;\n \n-               when N_Op_Gt =>\n-                  if CR = GT then\n-                     Result := True;\n-                  elsif CR = EQ or else CR = LT or else CR = LE then\n-                     Result := False;\n-                  else\n-                     return;\n-                  end if;\n+                  when N_Op_Gt =>\n+                     if CR = GT then\n+                        Result := True;\n+                     elsif CR = EQ or else CR = LT or else CR = LE then\n+                        Result := False;\n+                     else\n+                        return;\n+                     end if;\n \n-               when N_Op_Ge =>\n-                  if CR = GT or else CR = EQ or else CR = GE then\n-                     Result := True;\n-                  elsif CR = LT then\n-                     Result := False;\n-                  else\n-                     return;\n-                  end if;\n+                  when N_Op_Ge =>\n+                     if CR = GT or else CR = EQ or else CR = GE then\n+                        Result := True;\n+                     elsif CR = LT then\n+                        Result := False;\n+                     else\n+                        return;\n+                     end if;\n \n-               when others =>\n-                  raise Program_Error;\n-            end case;\n-         end;\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n+            end;\n \n-         Fold_Uint (N, Test (Result), Stat);\n-      end if;\n+            Fold_Uint (N, Test (Result), Is_Static_Expression);\n+         end if;\n+      end;\n \n       --  For the case of a folded relational operator on a specific numeric\n       --  type, freeze operand type now."}]}