{"sha": "8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ0ODVlMmQyZmMxODk0YTdkYjJjYTBkNjBjZDA4ZWViNmI5ZTc2OA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-07-30T08:42:57Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-07-30T08:42:57Z"}, "message": "c4x.c (c4x_emit_move_sequence): Use loadqi_big_constant and loadhi_big_constant if applicable.\n\n\t* config/c4x/c4x.c (c4x_emit_move_sequence): Use loadqi_big_constant\n\tand loadhi_big_constant if applicable.\n\t* config/c4x/c4x.md (loadqi_big_constant, loadhi_big_constant): Tweak\n\tand add new splitter.s\n\nFrom-SVN: r35339", "tree": {"sha": "f7f4b331d3a6e2e40b98b8626171fc2b20caee67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7f4b331d3a6e2e40b98b8626171fc2b20caee67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/comments", "author": null, "committer": null, "parents": [{"sha": "b864825e85c6c651d5a7488aa60743ec3781591f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b864825e85c6c651d5a7488aa60743ec3781591f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b864825e85c6c651d5a7488aa60743ec3781591f"}], "stats": {"total": 544, "additions": 382, "deletions": 162}, "files": [{"sha": "9bf128e481b11be02e6e44e0e810aa8f23a95ae6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "patch": "@@ -1,3 +1,10 @@\n+2000-07-30  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (c4x_emit_move_sequence): Use loadqi_big_constant\n+\tand loadhi_big_constant if applicable.\n+\t* config/c4x/c4x.md (loadqi_big_constant, loadhi_big_constant): Tweak\n+\tand add new splitter.s\n+\n 2000-07-30  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (c4x_rptb_insert): Make more robust."}, {"sha": "15d04f76b7ed080dd8ab5ceb68b17d0fa569f314", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 264, "deletions": 159, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "patch": "@@ -60,7 +60,7 @@ rtx floatunshihf2_libfunc;\n \n static int c4x_leaf_function;\n \n-static char *float_reg_names[] = FLOAT_REGISTER_NAMES;\n+static const char *float_reg_names[] = FLOAT_REGISTER_NAMES;\n \n /* Array of the smallest class containing reg number REGNO, indexed by\n    REGNO.  Used by REGNO_REG_CLASS in c4x.h.  We assume that all these\n@@ -161,6 +161,27 @@ static tree pure_tree = NULL_TREE;\n static tree noreturn_tree = NULL_TREE;\n static tree interrupt_tree = NULL_TREE;\n \n+/* Forward declarations */\n+static void c4x_add_gc_roots PARAMS ((void));\n+static int c4x_isr_reg_used_p PARAMS ((unsigned int));\n+static int c4x_leaf_function_p PARAMS ((void));\n+static int c4x_assembler_function_p PARAMS ((void));\n+static int c4x_immed_float_p PARAMS ((rtx));\n+static int c4x_a_register PARAMS ((rtx));\n+static int c4x_x_register PARAMS ((rtx));\n+static int c4x_immed_int_constant PARAMS ((rtx));\n+static int c4x_immed_float_constant PARAMS ((rtx));\n+static int c4x_K_constant PARAMS ((rtx));\n+static int c4x_N_constant PARAMS ((rtx));\n+static int c4x_O_constant PARAMS ((rtx));\n+static int c4x_R_indirect PARAMS ((rtx));\n+static int c4x_S_indirect PARAMS ((rtx));\n+static void c4x_S_address_parse PARAMS ((rtx , int *, int *, int *, int *));\n+static int c4x_valid_operands PARAMS ((enum rtx_code, rtx *,\n+\t\t\t\t       enum machine_mode, int));\n+static int c4x_arn_reg_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n+static int c4x_arn_mem_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n+static void c4x_check_attribute PARAMS ((const char *, tree, tree, tree *));\n \n /* Called to register all of our global variables with the garbage\n    collector.  */\n@@ -374,7 +395,7 @@ c4x_output_ascii (stream, ptr, len)\n \n int\n c4x_hard_regno_mode_ok (regno, mode)\n-     int regno;\n+     unsigned int regno;\n      enum machine_mode mode;\n {\n   switch (mode)\n@@ -688,7 +709,7 @@ c4x_va_arg (valist, type)\n \n static int\n c4x_isr_reg_used_p (regno)\n-     int regno;\n+     unsigned int regno;\n {\n   /* Don't save/restore FP or ST, we handle them separately.  */\n   if (regno == FRAME_POINTER_REGNUM\n@@ -752,7 +773,7 @@ c4x_assembler_function_p ()\n }\n \n \n-static int\n+int\n c4x_interrupt_function_p ()\n {\n   if (lookup_attribute (\"interrupt\",\n@@ -769,55 +790,75 @@ c4x_interrupt_function_p ()\n     && ISDIGIT (current_function_name[6]);\n }\n \n-\n-/* Write function prologue.  */\n-\n void\n-c4x_function_prologue (file, size)\n-     FILE *file;\n-     int size;\n+c4x_expand_prologue ()\n {\n-  int regno;\n+  unsigned int regno;\n+  int size = get_frame_size ();\n+  rtx insn;\n \n-/* In functions where ar3 is not used but frame pointers are still\n-   specified, frame pointers are not adjusted (if >= -O2) and this is\n-   used so it won't be needlessly push the frame pointer.  */\n+  /* In functions where ar3 is not used but frame pointers are still\n+     specified, frame pointers are not adjusted (if >= -O2) and this\n+     is used so it won't needlessly push the frame pointer.  */\n   int dont_push_ar3;\n \n   /* For __assembler__ function don't build a prologue.  */\n   if (c4x_assembler_function_p ())\n     {\n-      fprintf (file, \"; *** Assembler Function ***\\n\");\n       return;\n     }\n+  \n+#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n+  if (profile_block_flag == 2)\n+    {\n+      FUNCTION_BLOCK_PROFILER_EXIT\n+    }\n+#endif\n \n   /* For __interrupt__ function build specific prologue.  */\n   if (c4x_interrupt_function_p ())\n     {\n       c4x_leaf_function = c4x_leaf_function_p ();\n-      fprintf (file, \"; *** Interrupt Entry %s ***\\n\",\n-\t       c4x_leaf_function ? \"(leaf)\" : \"\");\n-\n-      fprintf (file, \"\\tpush\\tst\\n\");\n+      \n+      insn = emit_insn (gen_push_st ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n       if (size)\n \t{\n-\t  fprintf (file, \"\\tpush\\tar3\\n\\tldi\\tsp,ar3\\n\");\n+          insn = emit_insn (gen_pushqi ( gen_rtx_REG (QImode, AR3_REGNO)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_insn (gen_movqi (gen_rtx_REG (QImode, AR3_REGNO),\n+\t\t\t\t       gen_rtx_REG (QImode, SP_REGNO)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t  /* FIXME: Assume ISR doesn't require more than 32767 words\n \t     of local variables.  */\n \t  if (size > 32767)\n \t    error (\"ISR %s requires %d words of local variables, \"\n \t\t   \"maximum is 32767.\", current_function_name, size);\n-\t  fprintf (file, \"\\taddi\\t%d,sp\\n\", size);\n+\t  insn = emit_insn (gen_addqi3 (gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t\tGEN_INT(size)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n \t  if (c4x_isr_reg_used_p (regno))\n \t    {\n-\t      fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n-\t      if (IS_EXT_REGNO (regno))\t/* Save 32MSB of R0--R11.  */\n-\t\tfprintf (file, \"\\tpushf\\t%s\\n\",\n-\t\t\t TARGET_TI ? reg_names[regno]\n-\t\t\t\t   : float_reg_names[regno]);\n+\t      if (regno == DP_REGNO)\n+\t\t{\n+\t\t  insn = emit_insn (gen_push_dp ());\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+                  insn = emit_insn (gen_pushqi (gen_rtx_REG (QImode, regno)));\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  if (IS_EXT_REGNO (regno))\n+\t\t    {\n+                      insn = emit_insn (gen_pushqf\n+\t\t\t\t\t(gen_rtx_REG (QFmode, regno)));\n+                      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n       /* We need to clear the repeat mode flag if the ISR is\n@@ -826,14 +867,20 @@ c4x_function_prologue (file, size)\n       if (regs_ever_live[RC_REGNO] \n \t  || regs_ever_live[RS_REGNO] \n \t  || regs_ever_live[RE_REGNO])\n-\tfprintf (file, \"\\tandn\\t0100h,st\\n\");\n+\t{\n+          insn = emit_insn (gen_andn_st (GEN_INT(~0x100)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n \n       /* Reload DP reg if we are paranoid about some turkey\n          violating small memory model rules.  */\n       if (TARGET_SMALL && TARGET_PARANOID)\n-\tfprintf (file, TARGET_C3X ?\n-\t\t \"\\tldp\\t@data_sec\\n\" :\n-\t\t \"\\tldpk\\t@data_sec\\n\");\n+\t{\n+          insn = emit_insn (gen_set_ldp_prologue\n+\t\t\t    (gen_rtx_REG (QImode, DP_REGNO),\n+\t\t\t     gen_rtx_SYMBOL_REF (QImode, \"data_sec\")));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n     }\n   else\n     {\n@@ -843,8 +890,11 @@ c4x_function_prologue (file, size)\n \t      || (current_function_args_size != 0)\n \t      || (optimize < 2))\n \t    {\n-\t      fprintf (file, \"\\tpush\\tar3\\n\");\n-\t      fprintf (file, \"\\tldi\\tsp,ar3\\n\");\n+              insn = emit_insn (gen_pushqi ( gen_rtx_REG (QImode, AR3_REGNO)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\t      insn = emit_insn (gen_movqi (gen_rtx_REG (QImode, AR3_REGNO),\n+\t\t\t\t           gen_rtx_REG (QImode, SP_REGNO)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n \t      dont_push_ar3 = 1;\n \t    }\n \t  else\n@@ -865,28 +915,46 @@ c4x_function_prologue (file, size)\n \t      size += 1;\n \t    }\n \t}\n-\n+      \n       if (size > 32767)\n \t{\n \t  /* Local vars are too big, it will take multiple operations\n \t     to increment SP.  */\n \t  if (TARGET_C3X)\n \t    {\n-\t      fprintf (file, \"\\tldi\\t%d,r1\\n\", size >> 16);\n-\t      fprintf (file, \"\\tlsh\\t16,r1\\n\");\n+\t      insn = emit_insn (gen_movqi (gen_rtx_REG (QImode, R1_REGNO),\n+\t\t\t\t\t   GEN_INT(size >> 16)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\t      insn = emit_insn (gen_lshrqi3 (gen_rtx_REG (QImode, R1_REGNO),\n+\t\t\t\t\t     gen_rtx_REG (QImode, R1_REGNO),\n+\t\t\t\t\t     GEN_INT(-16)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n-\t    fprintf (file, \"\\tldhi\\t%d,r1\\n\", size >> 16);\n-\t  fprintf (file, \"\\tor\\t%d,r1\\n\", size & 0xffff);\n-\t  fprintf (file, \"\\taddi\\tr1,sp\\n\");\n+\t    {\n+\t      insn = emit_insn (gen_movqi (gen_rtx_REG (QImode, R1_REGNO),\n+\t\t\t\t\t   GEN_INT(size & ~0xffff)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  insn = emit_insn (gen_iorqi3 (gen_rtx_REG (QImode, R1_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, R1_REGNO),\n+\t\t\t\t\tGEN_INT(size & 0xffff)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_insn (gen_addqi3 (gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, R1_REGNO)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (size != 0)\n \t{\n \t  /* Local vars take up less than 32767 words, so we can directly\n \t     add the number.  */\n-\t  fprintf (file, \"\\taddi\\t%d,sp\\n\", size);\n+\t  insn = emit_insn (gen_addqi3 (gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        GEN_INT (size)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-\n+      \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n \t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n@@ -895,75 +963,82 @@ c4x_function_prologue (file, size)\n \t\t{\n \t\t  /* R6 and R7 are saved as floating point.  */\n \t\t  if (TARGET_PRESERVE_FLOAT)\n-\t\t    fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n-\t\t  fprintf (file, \"\\tpushf\\t%s\\n\",\n-\t\t\t   TARGET_TI ? reg_names[regno]\n-\t\t\t\t     : float_reg_names[regno]);\n+\t\t    {\n+                      insn = emit_insn (gen_pushqi\n+\t\t\t\t\t(gen_rtx_REG (QImode, regno)));\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t    }\n+                  insn = emit_insn (gen_pushqf (gen_rtx_REG (QFmode, regno)));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t}\n \t      else if ((! dont_push_ar3) || (regno != AR3_REGNO))\n \t\t{\n-\t\t  fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n+                  insn = emit_insn (gen_pushqi ( gen_rtx_REG (QImode, regno)));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t}\n \t    }\n \t}\n     }\n }\n \n \n-/* Write function epilogue.  */\n-\n void\n-c4x_function_epilogue (file, size)\n-     FILE *file;\n-     int size;\n+c4x_expand_epilogue()\n {\n   int regno;\n-  int restore_count = 0;\n-  int delayed_jump = 0;\n+  int jump = 0;\n   int dont_pop_ar3;\n   rtx insn;\n-\n-  insn = get_last_insn ();\n-  if (insn && GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-\n-  if (insn && GET_CODE (insn) == BARRIER)\n-    return;\n-\n+  int size = get_frame_size ();\n+  \n   /* For __assembler__ function build no epilogue.  */\n   if (c4x_assembler_function_p ())\n     {\n-      fprintf (file, \"\\trets\\n\");\t/* Play it safe.  */\n+      insn = emit_jump_insn (gen_return_from_epilogue ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n       return;\n     }\n \n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  if (profile_block_flag == 2)\n-    {\n-      FUNCTION_BLOCK_PROFILER_EXIT (file);\n-    }\n-#endif\n-\n   /* For __interrupt__ function build specific epilogue.  */\n   if (c4x_interrupt_function_p ())\n     {\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n \t{\n \t  if (! c4x_isr_reg_used_p (regno))\n \t    continue;\n-\t  if (IS_EXT_REGNO (regno))\n-\t    fprintf (file, \"\\tpopf\\t%s\\n\",\n-\t\t     TARGET_TI ? reg_names[regno]\n-\t\t\t       : float_reg_names[regno]);\n-\t  fprintf (file, \"\\tpop\\t%s\\n\", reg_names[regno]);\n+\t  if (regno == DP_REGNO)\n+\t    {\n+\t      insn = emit_insn (gen_pop_dp ());\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We have to use unspec because the compiler will delete insns\n+\t         that are not call-saved.  */\n+\t      if (IS_EXT_REGNO (regno))\n+\t\t{\n+                  insn = emit_insn (gen_popqf_unspec\n+\t\t\t\t    (gen_rtx_REG (QFmode, regno)));\n+\t          RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n+\t      insn = emit_insn (gen_popqi_unspec (gen_rtx_REG (QImode, regno)));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n \t}\n       if (size)\n \t{\n-\t  fprintf (file, \"\\tsubi\\t%d,sp\\n\", size);\n-\t  fprintf (file, \"\\tpop\\tar3\\n\");\n+\t  insn = emit_insn (gen_subqi3 (gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t\tGEN_INT(size)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_insn (gen_popqi\n+\t\t\t    (gen_rtx_REG (QImode, AR3_REGNO)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-      fprintf (file, \"\\tpop\\tst\\n\");\n-      fprintf (file, \"\\treti\\n\");\n+      insn = emit_insn (gen_pop_st ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_jump_insn (gen_return_from_interrupt_epilogue ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else\n     {\n@@ -973,14 +1048,19 @@ c4x_function_epilogue (file, size)\n \t      || (current_function_args_size != 0) \n \t      || (optimize < 2))\n \t    {\n-\t      /* R2 holds the return value.  */\n-\t      fprintf (file, \"\\tldi\\t*-ar3(1),r2\\n\");\n-\n+\t      insn = emit_insn\n+\t\t(gen_movqi (gen_rtx_REG (QImode, R2_REGNO),\n+\t\t\t    gen_rtx_MEM (QImode,\n+\t\t\t\t\t gen_rtx_PLUS \n+\t\t\t\t\t (QImode, gen_rtx_REG (QImode,\n+\t\t\t\t\t\t\t       AR3_REGNO),\n+\t\t\t\t\t  GEN_INT(-1)))));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      \n \t      /* We already have the return value and the fp,\n \t         so we need to add those to the stack.  */\n \t      size += 2;\n-\t      delayed_jump = 1;\n-\t      restore_count = 1;\n+\t      jump = 1;\n \t      dont_pop_ar3 = 1;\n \t    }\n \t  else\n@@ -1001,41 +1081,7 @@ c4x_function_epilogue (file, size)\n \t      size += 1;\n \t    }\n \t}\n-\n-      /* Now get the number of instructions required to restore the\n-         registers.  */\n-      for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n-\t{\n-\t  if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t      && ((! dont_pop_ar3) || (regno != AR3_REGNO)))\n-\t    {\n-\t      restore_count++;\n-\t      if (TARGET_PRESERVE_FLOAT\n-\t\t  && ((regno == R6_REGNO) || (regno == R7_REGNO)))\n-\t        restore_count++;\n-\t    }\n-\t}\n-\n-      /* Get the number of instructions required to restore the stack.  */\n-      if (size > 32767)\n-\trestore_count += (TARGET_C3X ? 4 : 3);\n-      else if (size != 0)\n-\trestore_count += 1;\n-\n-      if (delayed_jump && (restore_count < 3))\n-\t{\n-\t  /* We don't have enough instructions to account for the delayed\n-\t     branch, so put some nops in.  */\n-\n-\t  fprintf (file, \"\\tbud\\tr2\\n\");\n-\t  while (restore_count < 3)\n-\t    {\n-\t      fprintf (file, \"\\tnop\\n\");\n-\t      restore_count++;\n-\t    }\n-\t  restore_count = 0;\n-\t}\n-\n+      \n       /* Now restore the saved registers, putting in the delayed branch\n          where required.  */\n       for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n@@ -1044,76 +1090,98 @@ c4x_function_epilogue (file, size)\n \t    {\n \t      if (regno == AR3_REGNO && dont_pop_ar3)\n \t\tcontinue;\n-\n-\t      if (delayed_jump && (restore_count == 3))\n-\t\tfprintf (file, \"\\tbud\\tr2\\n\");\n-\n+\t      \n \t      /* R6 and R7 are saved as floating point.  */\n \t      if ((regno == R6_REGNO) || (regno == R7_REGNO))\n \t\t{\n-\t\t  fprintf (file, \"\\tpopf\\t%s\\n\",\n-\t\t           TARGET_TI ? reg_names[regno]\n-\t\t\t             : float_reg_names[regno]);\n+\t\t  insn = emit_insn (gen_popqf_unspec\n+\t\t\t\t    (gen_rtx_REG (QFmode, regno)));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  if (TARGET_PRESERVE_FLOAT)\n \t\t    {\n-\t              restore_count--;\n-\t              if (delayed_jump && (restore_count == 3))\n-\t\t        fprintf (file, \"\\tbud\\tr2\\n\");\n-\t\t      fprintf (file, \"\\tpop\\t%s\\n\", reg_names[regno]);\n+                      insn = emit_insn (gen_popqi_unspec\n+\t\t\t\t\t(gen_rtx_REG (QImode, regno)));\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t\t    }\n \t\t}\n \t      else\n-\t\tfprintf (file, \"\\tpop\\t%s\\n\", reg_names[regno]);\n-\t      restore_count--;\n+\t\t{\n+\t\t  insn = emit_insn (gen_popqi (gen_rtx_REG (QImode, regno)));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n \t    }\n \t}\n-\n-      if (delayed_jump && (restore_count == 3))\n-\tfprintf (file, \"\\tbud\\tr2\\n\");\n-\n+      \n       if (frame_pointer_needed)\n \t{\n \t  if ((size != 0)\n \t      || (current_function_args_size != 0)\n \t      || (optimize < 2))\n \t    {\n \t      /* Restore the old FP.  */\n-\t      fprintf (file, \"\\tldi\\t*ar3,ar3\\n\");\n-\t      restore_count--;\n-\n-\t      if (delayed_jump && (restore_count == 3))\n-\t\tfprintf (file, \"\\tbud\\tr2\\n\");\n+\t      insn = emit_insn \n+\t\t(gen_movqi \n+\t\t (gen_rtx_REG (QImode, AR3_REGNO),\n+\t\t  gen_rtx_MEM (QImode, gen_rtx_REG (QImode, AR3_REGNO))));\n+\t      \n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t}\n-\n+      \n       if (size > 32767)\n \t{\n \t  /* Local vars are too big, it will take multiple operations\n \t     to decrement SP.  */\n \t  if (TARGET_C3X)\n \t    {\n-\t      fprintf (file, \"\\tldi\\t%d,r3\\n\", size >> 16);\n-\t      if (delayed_jump)\n-\t\tfprintf (file, \"\\tbud\\tr2\\n\");\n-\t      fprintf (file, \"\\tlsh\\t16,r3\\n\");\n+\t      insn = emit_insn (gen_movqi (gen_rtx_REG (QImode, R3_REGNO),\n+\t\t\t\t\t   GEN_INT(size >> 16)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\t      insn = emit_insn (gen_lshrqi3 (gen_rtx_REG (QImode, R3_REGNO),\n+\t\t\t\t\t     gen_rtx_REG (QImode, R3_REGNO),\n+\t\t\t\t\t     GEN_INT(-16)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n-\t    fprintf (file, \"\\tldhi\\t%d,r3\\n\", size >> 16);\n-\t  fprintf (file, \"\\tor\\t%d,r3\\n\", size & 0xffff);\n-\t  fprintf (file, \"\\tsubi\\tr3,sp\\n\");\n+\t    {\n+\t      insn = emit_insn (gen_movqi (gen_rtx_REG (QImode, R3_REGNO),\n+\t\t\t\t\t   GEN_INT(size & ~0xffff)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  insn = emit_insn (gen_iorqi3 (gen_rtx_REG (QImode, R3_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, R3_REGNO),\n+\t\t\t\t\tGEN_INT(size & 0xffff)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_insn (gen_subqi3 (gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, R3_REGNO)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (size != 0)\n \t{\n \t  /* Local vars take up less than 32768 words, so we can directly\n \t     subtract the number.  */\n-\t  fprintf (file, \"\\tsubi\\t%d,sp\\n\", size);\n+\t  insn = emit_insn (gen_subqi3 (gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n+\t\t\t\t        GEN_INT(size)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      \n+      if (jump)\n+\t{\n+\t  insn = emit_insn (gen_indirect_jump (\n+\t\t\t\t\t       gen_rtx_REG (QImode, R2_REGNO)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      else\n+\t{\n+          insn = emit_jump_insn (gen_return_from_epilogue ());\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-\n-      if (! delayed_jump)\n-\tfprintf (file, \"\\trets\\n\");\n     }\n }\n \n+\n int\n c4x_null_epilogue_p ()\n {\n@@ -1137,6 +1205,7 @@ c4x_null_epilogue_p ()\n   return 0;\n }\n \n+\n int\n c4x_emit_move_sequence (operands, mode)\n      rtx *operands;\n@@ -1259,6 +1328,42 @@ c4x_emit_move_sequence (operands, mode)\n       return 1;\n     }\n \n+  if (mode == QImode\n+      && reg_operand (op0, mode)\n+      && const_int_operand (op1, mode)\n+      && ! IS_INT16_CONST (INTVAL (op1))\n+      && ! IS_HIGH_CONST (INTVAL (op1)))\n+    {\n+      emit_insn (gen_loadqi_big_constant (op0, op1));\n+      return 1;\n+    }\n+\n+  if (mode == HImode\n+      && reg_operand (op0, mode)\n+      && const_int_operand (op1, mode))\n+    {\n+      emit_insn (gen_loadhi_big_constant (op0, op1));\n+      return 1;\n+    }\n+\n+  if (mode == QImode\n+      && reg_operand (op0, mode)\n+      && const_int_operand (op1, mode)\n+      && ! IS_INT16_CONST (INTVAL (op1))\n+      && ! IS_HIGH_CONST (INTVAL (op1)))\n+    {\n+      emit_insn (gen_loadqi_big_constant (op0, op1));\n+      return 1;\n+    }\n+\n+  if (mode == HImode\n+      && reg_operand (op0, mode)\n+      && const_int_operand (op1, mode))\n+    {\n+      emit_insn (gen_loadhi_big_constant (op0, op1));\n+      return 1;\n+    }\n+\n   /* Adjust operands in case we have modified them.  */\n   operands[0] = op0;\n   operands[1] = op1;\n@@ -1313,7 +1418,7 @@ c4x_emit_libcall3 (libcall, code, mode, operands)\n      enum machine_mode mode;\n      rtx *operands;\n {\n-  return c4x_emit_libcall (libcall, code, mode, mode, 3, operands);\n+  c4x_emit_libcall (libcall, code, mode, mode, 3, operands);\n }\n \n \n@@ -1738,7 +1843,7 @@ c4x_gen_compare_reg (code, x, y)\n \n char *\n c4x_output_cbranch (form, seq)\n-     char *form;\n+     const char *form;\n      rtx seq;\n {\n   int delayed = 0;\n@@ -3684,7 +3789,7 @@ static int\n c4x_valid_operands (code, operands, mode, force)\n      enum rtx_code code;\n      rtx *operands;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      int force;\n {\n   rtx op1;\n@@ -3716,9 +3821,9 @@ c4x_valid_operands (code, operands, mode, force)\n \n   if (code1 == MEM && code2 == MEM)\n     {\n-      if (c4x_S_indirect (op1, mode) && c4x_S_indirect (op2, mode))\n+      if (c4x_S_indirect (op1) && c4x_S_indirect (op2))\n \treturn 1;\n-      return c4x_R_indirect (op1, mode) && c4x_R_indirect (op2, mode);\n+      return c4x_R_indirect (op1) && c4x_R_indirect (op2);\n     }\n \n   if (code1 == code2)\n@@ -3972,7 +4077,7 @@ static int\n c4x_arn_reg_operand (op, mode, regno)\n      rtx op;\n      enum machine_mode mode;\n-     int regno;\n+     unsigned int regno;\n {\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -3986,7 +4091,7 @@ static int\n c4x_arn_mem_operand (op, mode, regno)\n      rtx op;\n      enum machine_mode mode;\n-     int regno;\n+     unsigned int regno;\n {\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -4523,7 +4628,7 @@ c4x_file_end (fp)\n \n static void\n c4x_check_attribute (attrib, list, decl, attributes)\n-     char *attrib;\n+     const char *attrib;\n      tree list, decl, *attributes;\n {\n   while (list != NULL_TREE"}, {"sha": "12da60ed0a94c24f1613228a6c56e0ee4a284009", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=8d485e2d2fc1894a7db2ca0d60cd08eeb6b9e768", "patch": "@@ -1131,6 +1131,23 @@\n    (set (match_dup 0) (lo_sum:QI (match_dup 0) (match_dup 1)))]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"! TARGET_C3X\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && std_reg_operand (operands[0], QImode)\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ior:QI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & ~0xffff);\n+   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n+}\")\n+\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n \t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n@@ -1147,6 +1164,28 @@\n    operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n }\")\n \n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"TARGET_C3X && ! TARGET_SMALL\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && std_reg_operand (operands[0], QImode)\n+   && c4x_shiftable_constant (operands[1]) < 0\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ashift:QI (match_dup 0) (match_dup 4)))\n+   (set (match_dup 0) (ior:QI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+   /* Generate two's complement value of 16 MSBs.  */\n+   operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  (((INTVAL (operands[1]) >> 16) & 0xffff)\n+\t\t\t   - 0x8000) ^ ~0x7fff);\n+   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n+   operands[4] = gen_rtx (CONST_INT, VOIDmode, 16);\n+}\")\n+\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n \t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n@@ -1168,6 +1207,28 @@\n    operands[4] = gen_rtx (CONST_INT, VOIDmode, 16);\n }\")\n \n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"TARGET_C3X\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && std_reg_operand (operands[0], QImode)\n+   && c4x_shiftable_constant (operands[1]) >= 0\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ashift:QI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+   /* Generate two's complement value of MSBs.  */\n+   int shift = c4x_shiftable_constant (operands[1]);\n+\n+   operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  (((INTVAL (operands[1]) >> shift) & 0xffff)\n+\t\t\t   - 0x8000) ^ ~0x7fff);\n+   operands[3] = gen_rtx (CONST_INT, VOIDmode, shift);\n+}\")\n+\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n \t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n@@ -1189,6 +1250,29 @@\n    operands[3] = gen_rtx (CONST_INT, VOIDmode, shift);\n }\")\n \n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"! TARGET_SMALL\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && ! std_reg_operand (operands[0], QImode)\"\n+  [(set (match_dup 2) (high:QI (match_dup 3)))\n+   (set (match_dup 0) (match_dup 4))\n+   (use (match_dup 1))]\n+  \"\n+{\n+   rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+   operands[2] = dp_reg;\n+   operands[3] = force_const_mem (Pmode, operands[1]);\n+   operands[4] = change_address (operands[3], QImode,\n+\t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n+                                                 XEXP (operands[3], 0)));\n+   operands[3] = XEXP (operands[3], 0);\n+}\")\n+\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n \t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n@@ -1211,6 +1295,27 @@\n    operands[3] = XEXP (operands[3], 0);\n }\")\n \n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"TARGET_SMALL\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && ((TARGET_C3X && c4x_shiftable_constant (operands[1]) < 0)\n+       || ! std_reg_operand (operands[0], QImode))\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (use (match_dup 1))]\n+  \"\n+{\n+   rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+   operands[2] = force_const_mem (Pmode, operands[1]);\n+   operands[2] = change_address (operands[2], QImode,\n+\t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n+                                                 XEXP (operands[2], 0)));\n+}\")\n+\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n \t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n@@ -1233,7 +1338,8 @@\n \n (define_split\n   [(set (match_operand:HI 0 \"reg_operand\" \"\")\n-\t(match_operand:HI 1 \"const_int_operand\" \"\"))]\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n   \"reload_completed\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1315,7 +1421,8 @@\n \n (define_insn \"loadhi_big_constant\"\n   [(set (match_operand:HI 0 \"reg_operand\" \"=c*d\")\n-        (match_operand:HI 1 \"const_int_operand\" \"\"))]\n+        (match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n   \"\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")])\n@@ -1336,7 +1443,8 @@\n \n (define_insn \"loadqi_big_constant\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=c*d\")\n-        (match_operand:QI 1 \"const_int_operand\" \"\"))]\n+        (match_operand:QI 1 \"const_int_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n   \"! IS_INT16_CONST (INTVAL (operands[1]))\n    && ! IS_HIGH_CONST (INTVAL (operands[1]))\"\n   \"#\""}]}