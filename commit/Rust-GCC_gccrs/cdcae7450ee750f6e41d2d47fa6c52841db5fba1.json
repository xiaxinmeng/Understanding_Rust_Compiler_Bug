{"sha": "cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RjYWU3NDUwZWU3NTBmNmU0MWQyZDQ3ZmE2YzUyODQxZGI1ZmJhMQ==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2008-01-15T18:49:47Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2008-01-15T18:49:47Z"}, "message": "re PR c++/34751 (ICE with pointer to member and variadic templates)\n\n2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/34751\n\t* pt.c (coerce_template_parameter_pack): When substituting into\n\tthe type of a non-type template parameter pack. use the\n\tdeduced/substituted arguments.\n\t* parser.c (declarator_can_be_parameter_pack): A pointer-to-member\n\tcan be a parameter pack with the ellipsis following it.  When we\n\thave an erroneous declaration, allow it to be a parameter pack.\n\t(cp_parser_template_parameter): Complain about default\n\targuments on non-type template parameter packs, and parse them\n\tusing the new cp_parser_default_argument.\n\t(cp_parser_parameter_declaration): Complain about parameter packs\n\twith default arguments. Move parsing of default arguments into a\n\tnew function, cp_parser_default_argument.\n\t(cp_parser_default_argument): New; extracted from\n\tcp_parser_parameter_declaration.\n\n2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/34751\n\t* g++.dg/cpp0x/vt-34751.C: New.\n\nFrom-SVN: r131548", "tree": {"sha": "9b68e1a6f40c5f5f93069912e1b4c9c184633aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b68e1a6f40c5f5f93069912e1b4c9c184633aef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4439d02f0f5881b186b7d3430a9504310e227e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4439d02f0f5881b186b7d3430a9504310e227e30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4439d02f0f5881b186b7d3430a9504310e227e30"}], "stats": {"total": 177, "additions": 137, "deletions": 40}, "files": [{"sha": "6fec22f833de438ffa0291013ea0b7f8dbc17671", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "patch": "@@ -1,3 +1,21 @@\n+2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/34751\n+\t* pt.c (coerce_template_parameter_pack): When substituting into\n+\tthe type of a non-type template parameter pack. use the\n+\tdeduced/substituted arguments.\n+\t* parser.c (declarator_can_be_parameter_pack): A pointer-to-member\n+\tcan be a parameter pack with the ellipsis following it.  When we\n+\thave an erroneous declaration, allow it to be a parameter pack.\n+\t(cp_parser_template_parameter): Complain about default\n+\targuments on non-type template parameter packs, and parse them\n+\tusing the new cp_parser_default_argument.\n+\t(cp_parser_parameter_declaration): Complain about parameter packs\n+\twith default arguments. Move parsing of default arguments into a\n+\tnew function, cp_parser_default_argument.\n+\t(cp_parser_default_argument): New; extracted from\n+\tcp_parser_parameter_declaration.\n+\n 2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/34051"}, {"sha": "6462f35aaf8cb827287610f0ece0a1c9a2128a55", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 94, "deletions": 39, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "patch": "@@ -1071,12 +1071,13 @@ declarator_can_be_parameter_pack (cp_declarator *declarator)\n       switch ((int)declarator->kind)\n \t{\n \tcase cdk_id:\n-\tcase cdk_error:\n \tcase cdk_array:\n-\tcase cdk_ptrmem:\n \t  found = true;\n \t  break;\n-\t  \n+\n+\tcase cdk_error:\n+\t  return true;\n+\n \tdefault:\n \t  declarator = declarator->declarator;\n \t  break;\n@@ -1734,6 +1735,8 @@ static cp_parameter_declarator *cp_parser_parameter_declaration_list\n   (cp_parser *, bool *);\n static cp_parameter_declarator *cp_parser_parameter_declaration\n   (cp_parser *, bool, bool *);\n+static tree cp_parser_default_argument \n+  (cp_parser *, bool);\n static void cp_parser_function_body\n   (cp_parser *);\n static tree cp_parser_initializer\n@@ -9385,16 +9388,39 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \n   /* If the next token is an ellipsis, and we don't already have it\n      marked as a parameter pack, then we have a parameter pack (that\n-     has no declarator); */\n+     has no declarator).  */\n   if (!*is_parameter_pack\n       && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS)\n       && declarator_can_be_parameter_pack (parameter_declarator->declarator))\n     {\n-      /* Consume the `...'. */\n+      /* Consume the `...'.  */\n       cp_lexer_consume_token (parser->lexer);\n       maybe_warn_variadic_templates ();\n       \n       *is_parameter_pack = true;\n+\n+      /* Parameter packs cannot have default arguments.  However, a\n+\t user may try to do so, so we'll parse them and give an\n+\t appropriate diagnostic here.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t{\n+\t  /* Consume the `='.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t  /* Find the name of the parameter pack.  */     \n+\t  cp_declarator *id_declarator = parameter_declarator->declarator;\n+\t  while (id_declarator && id_declarator->kind != cdk_id)\n+\t    id_declarator = id_declarator->declarator;\n+\t  \n+\t  if (id_declarator && id_declarator->kind == cdk_id)\n+\t    error (\"template parameter pack %qD cannot have a default argument\",\n+\t\t   id_declarator->u.id.unqualified_name);\n+\t  else\n+\t    error (\"template parameter pack cannot have a default argument\");\n+\n+          /* Parse the default argument, but throw away the result.  */\n+          cp_parser_default_argument (parser, /*template_parm_p=*/true);\n+\t}\n     }\n \n   parm = grokdeclarator (parameter_declarator->declarator,\n@@ -13540,7 +13566,6 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   /* If the next token is `=', then process a default argument.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n     {\n-      bool saved_greater_than_is_operator_p;\n       /* Consume the `='.  */\n       cp_lexer_consume_token (parser->lexer);\n \n@@ -13646,39 +13671,9 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       /* Outside of a class definition, we can just parse the\n \t assignment-expression.  */\n       else\n-\t{\n-\t  bool saved_local_variables_forbidden_p;\n-\n-\t  /* Make sure that PARSER->GREATER_THAN_IS_OPERATOR_P is\n-\t     set correctly.  */\n-\t  saved_greater_than_is_operator_p\n-\t    = parser->greater_than_is_operator_p;\n-\t  parser->greater_than_is_operator_p = greater_than_is_operator_p;\n-\t  /* Local variable names (and the `this' keyword) may not\n-\t     appear in a default argument.  */\n-\t  saved_local_variables_forbidden_p\n-\t    = parser->local_variables_forbidden_p;\n-\t  parser->local_variables_forbidden_p = true;\n-\t  /* The default argument expression may cause implicitly\n-\t     defined member functions to be synthesized, which will\n-\t     result in garbage collection.  We must treat this\n-\t     situation as if we were within the body of function so as\n-\t     to avoid collecting live data on the stack.  */\n-\t  ++function_depth;\n-\t  /* Parse the assignment-expression.  */\n-\t  if (template_parm_p)\n-\t    push_deferring_access_checks (dk_no_deferred);\n-\t  default_argument\n-\t    = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n-\t  if (template_parm_p)\n-\t    pop_deferring_access_checks ();\n-\t  /* Restore saved state.  */\n-\t  --function_depth;\n-\t  parser->greater_than_is_operator_p\n-\t    = saved_greater_than_is_operator_p;\n-\t  parser->local_variables_forbidden_p\n-\t    = saved_local_variables_forbidden_p;\n-\t}\n+        default_argument \n+          = cp_parser_default_argument (parser, template_parm_p);\n+\n       if (!parser->default_arg_ok_p)\n \t{\n \t  if (!flag_pedantic_errors)\n@@ -13689,6 +13684,26 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t      default_argument = NULL_TREE;\n \t    }\n \t}\n+      else if ((declarator && declarator->parameter_pack_p)\n+\t       || (decl_specifiers.type\n+\t\t   && PACK_EXPANSION_P (decl_specifiers.type)))\n+\t{\n+\t  const char* kind = template_parm_p? \"template \" : \"\";\n+\t  \n+\t  /* Find the name of the parameter pack.  */     \n+\t  cp_declarator *id_declarator = declarator;\n+\t  while (id_declarator && id_declarator->kind != cdk_id)\n+\t    id_declarator = id_declarator->declarator;\n+\t  \n+\t  if (id_declarator && id_declarator->kind == cdk_id)\n+\t    error (\"%sparameter pack %qD cannot have a default argument\",\n+\t\t   kind, id_declarator->u.id.unqualified_name);\n+\t  else\n+\t    error (\"%sparameter pack cannot have a default argument\",\n+\t\t   kind);\n+\t  \n+\t  default_argument = NULL_TREE;\n+\t}\n     }\n   else\n     default_argument = NULL_TREE;\n@@ -13698,6 +13713,46 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t\t\t    default_argument);\n }\n \n+/* Parse a default argument and return it.\n+\n+   TEMPLATE_PARM_P is true if this is a default argument for a\n+   non-type template parameter.  */\n+static tree\n+cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n+{\n+  tree default_argument = NULL_TREE;\n+  bool saved_greater_than_is_operator_p;\n+  bool saved_local_variables_forbidden_p;\n+\n+  /* Make sure that PARSER->GREATER_THAN_IS_OPERATOR_P is\n+     set correctly.  */\n+  saved_greater_than_is_operator_p = parser->greater_than_is_operator_p;\n+  parser->greater_than_is_operator_p = !template_parm_p;\n+  /* Local variable names (and the `this' keyword) may not\n+     appear in a default argument.  */\n+  saved_local_variables_forbidden_p = parser->local_variables_forbidden_p;\n+  parser->local_variables_forbidden_p = true;\n+  /* The default argument expression may cause implicitly\n+     defined member functions to be synthesized, which will\n+     result in garbage collection.  We must treat this\n+     situation as if we were within the body of function so as\n+     to avoid collecting live data on the stack.  */\n+  ++function_depth;\n+  /* Parse the assignment-expression.  */\n+  if (template_parm_p)\n+    push_deferring_access_checks (dk_no_deferred);\n+  default_argument\n+    = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n+  if (template_parm_p)\n+    pop_deferring_access_checks ();\n+  /* Restore saved state.  */\n+  --function_depth;\n+  parser->greater_than_is_operator_p = saved_greater_than_is_operator_p;\n+  parser->local_variables_forbidden_p = saved_local_variables_forbidden_p;\n+\n+  return default_argument;\n+}\n+\n /* Parse a function-body.\n \n    function-body:"}, {"sha": "87c4bf5a853da7a9d1e04ce64219a14b0ff690ab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "patch": "@@ -5138,7 +5138,7 @@ coerce_template_parameter_pack (tree parms,\n     {\n       argument_pack = make_node (NONTYPE_ARGUMENT_PACK);\n       TREE_TYPE (argument_pack) \n-        = tsubst (TREE_TYPE (TREE_VALUE (parm)), args, complain, in_decl);\n+        = tsubst (TREE_TYPE (TREE_VALUE (parm)), new_args, complain, in_decl);\n       TREE_CONSTANT (argument_pack) = 1;\n     }\n "}, {"sha": "c6184f91da7e058fe815394c8e6faa4ed87ff15c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "patch": "@@ -1,3 +1,8 @@\n+2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/34751\n+\t* g++.dg/cpp0x/vt-34751.C: New.\n+\n 2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/34051"}, {"sha": "e3ca39e798ddf3702a579ca30536ffab12d6b12e", "filename": "gcc/testsuite/g++.dg/cpp0x/vt-34751.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-34751.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdcae7450ee750f6e41d2d47fa6c52841db5fba1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-34751.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-34751.C?ref=cdcae7450ee750f6e41d2d47fa6c52841db5fba1", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++0x\" }\n+// PR c++/34751\n+struct A {};\n+\n+template<typename... Args = int>  // { dg-error \"cannot have a default\" }\n+void f(Args... args = 0); // { dg-error \"cannot have a default argument\" }\n+\n+template<typename... Args> \n+void g(Args... = 0); // { dg-error \"cannot have a default argument\" }\n+\n+\n+template<int, typename T = A, int T::*...p = 0 > struct B {}; // { dg-error \"cannot have a default argument|no default argument\" }\n+\n+B<0> b;\n+\n+template<int, typename T = A, int T::*... = 0 > struct C {}; // { dg-error \"cannot have a default argument|no default argument\" }\n+\n+C<0> c;\n+"}]}