{"sha": "60d7a09b0671c2167248e0a6afee6920a18108ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBkN2EwOWIwNjcxYzIxNjcyNDhlMGE2YWZlZTY5MjBhMTgxMDhhYg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-03-06T20:26:15Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2010-03-06T20:26:15Z"}, "message": "re PR debug/41371 (var-tracking is slow and memory hungry)\n\n* var-tracking.c (dataflow_set_merge): Swap src and src2.\nReverted:\n2010-01-13  Jakub Jelinek  <jakub@redhat.com>\nPR debug/41371\n* var-tracking.c (values_to_unmark): New variable.\n(find_loc_in_1pdv): Clear VALUE_RECURSED_INTO of values in\nvalues_to_unmark vector.  Moved body to...\n(find_loc_in_1pdv_1): ... this.  Don't clear VALUE_RECURSED_INTO,\ninstead queue it into values_to_unmark vector.\n(vt_find_locations): Free values_to_unmark vector.\n\nFrom-SVN: r157257", "tree": {"sha": "55792437e6224f185a82adce91a012f3319caf99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55792437e6224f185a82adce91a012f3319caf99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60d7a09b0671c2167248e0a6afee6920a18108ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d7a09b0671c2167248e0a6afee6920a18108ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d7a09b0671c2167248e0a6afee6920a18108ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d7a09b0671c2167248e0a6afee6920a18108ab/comments", "author": null, "committer": null, "parents": [{"sha": "da61ffc84cc0be4cd0cca28608720563cfd77eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da61ffc84cc0be4cd0cca28608720563cfd77eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da61ffc84cc0be4cd0cca28608720563cfd77eba"}], "stats": {"total": 84, "additions": 38, "deletions": 46}, "files": [{"sha": "4871476cc720e45510cae091e205df1f19eb2f20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d7a09b0671c2167248e0a6afee6920a18108ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d7a09b0671c2167248e0a6afee6920a18108ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60d7a09b0671c2167248e0a6afee6920a18108ab", "patch": "@@ -1,3 +1,16 @@\n+2010-03-06  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* var-tracking.c (dataflow_set_merge): Swap src and src2.\n+\tReverted:\n+\t2010-01-13  Jakub Jelinek  <jakub@redhat.com>\n+\tPR debug/41371\n+\t* var-tracking.c (values_to_unmark): New variable.\n+\t(find_loc_in_1pdv): Clear VALUE_RECURSED_INTO of values in\n+\tvalues_to_unmark vector.  Moved body to...\n+\t(find_loc_in_1pdv_1): ... this.  Don't clear VALUE_RECURSED_INTO,\n+\tinstead queue it into values_to_unmark vector.\n+\t(vt_find_locations): Free values_to_unmark vector.\n+\n 2010-03-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* Makefile.in (PLUGINCC, PLUGINCFLAGS): New variables."}, {"sha": "8cc7675c38d0af66ec18b85ca0d8610fec8ae1c5", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d7a09b0671c2167248e0a6afee6920a18108ab/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d7a09b0671c2167248e0a6afee6920a18108ab/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=60d7a09b0671c2167248e0a6afee6920a18108ab", "patch": "@@ -2251,18 +2251,12 @@ dv_changed_p (decl_or_value dv)\n \t  : DECL_CHANGED (dv_as_decl (dv)));\n }\n \n-/* Vector of VALUEs that should have VALUE_RECURSED_INTO bit cleared\n-   at the end of find_loc_in_1pdv.  Not a static variable in find_loc_in_1pdv\n-   to avoid constant allocation/freeing of it.  */\n-static VEC(rtx, heap) *values_to_unmark;\n-\n-/* Helper function for find_loc_in_1pdv.\n-   Return a location list node whose loc is rtx_equal to LOC, in the\n+/* Return a location list node whose loc is rtx_equal to LOC, in the\n    location list of a one-part variable or value VAR, or in that of\n    any values recursively mentioned in the location lists.  */\n \n static location_chain\n-find_loc_in_1pdv_1 (rtx loc, variable var, htab_t vars)\n+find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n {\n   location_chain node;\n \n@@ -2290,33 +2284,18 @@ find_loc_in_1pdv_1 (rtx loc, variable var, htab_t vars)\n \t  {\n \t    location_chain where;\n \t    VALUE_RECURSED_INTO (node->loc) = true;\n-\t    VEC_safe_push (rtx, heap, values_to_unmark, node->loc);\n-\t    if ((where = find_loc_in_1pdv_1 (loc, var, vars)))\n-\t      return where;\n+\t    if ((where = find_loc_in_1pdv (loc, var, vars)))\n+\t      {\n+\t\tVALUE_RECURSED_INTO (node->loc) = false;\n+\t\treturn where;\n+\t      }\n+\t    VALUE_RECURSED_INTO (node->loc) = false;\n \t  }\n       }\n \n   return NULL;\n }\n \n-/* Return a location list node whose loc is rtx_equal to LOC, in the\n-   location list of a one-part variable or value VAR, or in that of\n-   any values recursively mentioned in the location lists.  */\n-\n-static location_chain\n-find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n-{\n-  location_chain ret;\n-  unsigned int i;\n-  rtx value;\n-\n-  ret = find_loc_in_1pdv_1 (loc, var, vars);\n-  for (i = 0; VEC_iterate (rtx, values_to_unmark, i, value); i++)\n-    VALUE_RECURSED_INTO (value) = false;\n-  VEC_truncate (rtx, values_to_unmark, 0);\n-  return ret;\n-}\n-\n /* Hash table iteration argument passed to variable_merge.  */\n struct dfset_merge\n {\n@@ -3278,10 +3257,10 @@ variable_merge_over_cur (void **s1slot, void *data)\n   return 1;\n }\n \n-/* Combine variable in *S1SLOT (in DSM->src) with the corresponding\n-   entry in DSM->src.  Only multi-part variables are combined, using\n-   variable_union.  onepart dvs were already combined with\n-   intersection in variable_merge_over_cur().  */\n+/* Copy s2slot (in DSM->src) to DSM->dst if the variable is a\n+   multi-part variable.  Unions of multi-part variables and\n+   intersections of one-part ones will be handled in\n+   variable_merge_over_cur().  */\n \n static int\n variable_merge_over_src (void **s2slot, void *data)\n@@ -3304,34 +3283,35 @@ variable_merge_over_src (void **s2slot, void *data)\n   return 1;\n }\n \n-/* Combine dataflow set information from SRC into DST, using PDST\n+/* Combine dataflow set information from SRC2 into DST, using PDST\n    to carry over information across passes.  */\n \n static void\n-dataflow_set_merge (dataflow_set *dst, dataflow_set *src)\n+dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n {\n-  dataflow_set src2 = *dst;\n+  dataflow_set cur = *dst;\n+  dataflow_set *src1 = &cur;\n   struct dfset_merge dsm;\n   int i;\n-  size_t src_elems, dst_elems;\n+  size_t src1_elems, src2_elems;\n \n-  src_elems = htab_elements (shared_hash_htab (src->vars));\n-  dst_elems = htab_elements (shared_hash_htab (src2.vars));\n+  src1_elems = htab_elements (shared_hash_htab (src1->vars));\n+  src2_elems = htab_elements (shared_hash_htab (src2->vars));\n   dataflow_set_init (dst);\n-  dst->stack_adjust = src2.stack_adjust;\n+  dst->stack_adjust = cur.stack_adjust;\n   shared_hash_destroy (dst->vars);\n   dst->vars = (shared_hash) pool_alloc (shared_hash_pool);\n   dst->vars->refcount = 1;\n   dst->vars->htab\n-    = htab_create (MAX (src_elems, dst_elems), variable_htab_hash,\n+    = htab_create (MAX (src1_elems, src2_elems), variable_htab_hash,\n \t\t   variable_htab_eq, variable_htab_free);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    attrs_list_mpdv_union (&dst->regs[i], src->regs[i], src2.regs[i]);\n+    attrs_list_mpdv_union (&dst->regs[i], src1->regs[i], src2->regs[i]);\n \n   dsm.dst = dst;\n-  dsm.src = &src2;\n-  dsm.cur = src;\n+  dsm.src = src2;\n+  dsm.cur = src1;\n   dsm.src_onepart_cnt = 0;\n \n   htab_traverse (shared_hash_htab (dsm.src->vars), variable_merge_over_src,\n@@ -3342,7 +3322,7 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src)\n   if (dsm.src_onepart_cnt)\n     dst_can_be_shared = false;\n \n-  dataflow_set_destroy (&src2);\n+  dataflow_set_destroy (src1);\n }\n \n /* Mark register equivalences.  */\n@@ -5853,7 +5833,6 @@ vt_find_locations (void)\n     FOR_EACH_BB (bb)\n       gcc_assert (VTI (bb)->flooded);\n \n-  VEC_free (rtx, heap, values_to_unmark);\n   free (bb_order);\n   fibheap_delete (worklist);\n   fibheap_delete (pending);"}]}