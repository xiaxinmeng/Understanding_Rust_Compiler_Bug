{"sha": "8e8889204245049467914f72b9ff664f31e56e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4ODg5MjA0MjQ1MDQ5NDY3OTE0ZjcyYjlmZjY2NGYzMWU1NmUyNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:57:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:57:28Z"}, "message": "[multiple changes]\n\n2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Make_Bignum_Block): Use the new secondary stack\n\tbuild routines to manage the mark.\n\t* exp_ch7.adb (Create_Finalizer, Expand_Cleanup_Actions):\n\tUse the new secodary stack build routines to manage the mark.\n\t(Insert_Actions_In_Scope_Around): Add new formal parameter\n\tManage_SS along with comment on its usage. Code and comment\n\treformatting. Mark and release the secondary stack when the\n\tcontext warrants it.\n\t(Make_Transient_Block): Update the call\n\tto Insert_Actions_In_Scope_Around to account for parameter Manage_SS.\n\t(Wrap_Transient_Declaration): Remove local variable\n\tUses_SS. Ensure that the secondary stack is marked and released\n\twhen the related object declaration appears in a library level\n\tpackage or package body. Code and comment reformatting.\n\t* exp_util.ads, exp_util.adb (Build_SS_Mark_Call): New routine.\n\t(Build_SS_Release_Call): New routine.\n\n2014-07-30  Steve Baird  <baird@adacore.com>\n\n\t* exp_attr.adb: Revert previous change, not needed after all.\n\n2014-07-30  Vincent Celier  <celier@adacore.com>\n\n\t* makeutl.adb (Queue.Insert_Project_Sources): Insert with\n\tClosure => True for interfaces of Stand-Alone Libraries.\n\t* makeutl.ads (Source_Info (Format => Gprbuild)): Add new\n\tBoolean component Closure, defaulted to False.\n\n2014-07-30  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb: Fix typo in error message.\n\nFrom-SVN: r213291", "tree": {"sha": "3a9f0a9cf2cbc3f681d537a7013b511b331160b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a9f0a9cf2cbc3f681d537a7013b511b331160b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e8889204245049467914f72b9ff664f31e56e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8889204245049467914f72b9ff664f31e56e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8889204245049467914f72b9ff664f31e56e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8889204245049467914f72b9ff664f31e56e24/comments", "author": null, "committer": null, "parents": [{"sha": "63a4aa4375a94ca120752f77fc1376f03144722c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a4aa4375a94ca120752f77fc1376f03144722c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a4aa4375a94ca120752f77fc1376f03144722c"}], "stats": {"total": 419, "additions": 281, "deletions": 138}, "files": [{"sha": "8d00c1b6676417625f89301585f92baa09d439a4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -1,3 +1,37 @@\n+2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Make_Bignum_Block): Use the new secondary stack\n+\tbuild routines to manage the mark.\n+\t* exp_ch7.adb (Create_Finalizer, Expand_Cleanup_Actions):\n+\tUse the new secodary stack build routines to manage the mark.\n+\t(Insert_Actions_In_Scope_Around): Add new formal parameter\n+\tManage_SS along with comment on its usage. Code and comment\n+\treformatting. Mark and release the secondary stack when the\n+\tcontext warrants it.\n+\t(Make_Transient_Block): Update the call\n+\tto Insert_Actions_In_Scope_Around to account for parameter Manage_SS.\n+\t(Wrap_Transient_Declaration): Remove local variable\n+\tUses_SS. Ensure that the secondary stack is marked and released\n+\twhen the related object declaration appears in a library level\n+\tpackage or package body. Code and comment reformatting.\n+\t* exp_util.ads, exp_util.adb (Build_SS_Mark_Call): New routine.\n+\t(Build_SS_Release_Call): New routine.\n+\n+2014-07-30  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_attr.adb: Revert previous change, not needed after all.\n+\n+2014-07-30  Vincent Celier  <celier@adacore.com>\n+\n+\t* makeutl.adb (Queue.Insert_Project_Sources): Insert with\n+\tClosure => True for interfaces of Stand-Alone Libraries.\n+\t* makeutl.ads (Source_Info (Format => Gprbuild)): Add new\n+\tBoolean component Closure, defaulted to False.\n+\n+2014-07-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb: Fix typo in error message.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb (Process_Range_Expr_In_Decl): Use _FIRST/_LAST"}, {"sha": "aea726c5f713142d7986db66ca4f3646ed6caeb0", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -7477,22 +7477,12 @@ package body Checks is\n    begin\n       return\n         Make_Block_Statement (Loc,\n-          Declarations => New_List (\n-            Make_Object_Declaration (Loc,\n-              Defining_Identifier => M,\n-              Object_Definition   =>\n-                New_Occurrence_Of (RTE (RE_Mark_Id), Loc),\n-              Expression          =>\n-                Make_Function_Call (Loc,\n-                  Name => New_Occurrence_Of (RTE (RE_SS_Mark), Loc)))),\n+          Declarations               =>\n+            New_List (Build_SS_Mark_Call (Loc, M)),\n \n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (\n-                Make_Procedure_Call_Statement (Loc,\n-                  Name => New_Occurrence_Of (RTE (RE_SS_Release), Loc),\n-                  Parameter_Associations => New_List (\n-                    New_Occurrence_Of (M, Loc))))));\n+              Statements => New_List (Build_SS_Release_Call (Loc, M))));\n    end Make_Bignum_Block;\n \n    ----------------------------------"}, {"sha": "43051fae1a6cd9af947a4544977d464599170ea8", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -2884,11 +2884,9 @@ package body Exp_Attr is\n          --  For scalar type, if low bound is a reference to an entity, just\n          --  replace with a direct reference. Note that we can only have a\n          --  reference to a constant entity at this stage, anything else would\n-         --  have already been rewritten. We do not do this rewriting if we\n-         --  are in CodePeer mode, since CodePeer prefers to see the explicit\n-         --  First attribute reference.\n+         --  have already been rewritten.\n \n-         elsif Is_Scalar_Type (Ptyp) and then not CodePeer_Mode then\n+         elsif Is_Scalar_Type (Ptyp) then\n             declare\n                Lo : constant Node_Id := Type_Low_Bound (Ptyp);\n             begin\n@@ -3562,11 +3560,9 @@ package body Exp_Attr is\n          --  For scalar type, if low bound is a reference to an entity, just\n          --  replace with a direct reference. Note that we can only have a\n          --  reference to a constant entity at this stage, anything else would\n-         --  have already been rewritten. We do not do this rewriting if we\n-         --  are in CodePeer mode, since CodePeer prefers to see the explicit\n-         --  Last attribute reference.\n+         --  have already been rewritten.\n \n-         elsif Is_Scalar_Type (Ptyp) and then not CodePeer_Mode then\n+         elsif Is_Scalar_Type (Ptyp) then\n             declare\n                Hi : constant Node_Id := Type_High_Bound (Ptyp);\n             begin"}, {"sha": "687ac1fa55a7531b3582c503db85c2ab5aef9c2c", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 122, "deletions": 100, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -130,10 +130,14 @@ package body Exp_Ch7 is\n    --  pointers of N until it find the appropriate node to wrap. If it returns\n    --  Empty, it means that no transient scope is needed in this context.\n \n-   procedure Insert_Actions_In_Scope_Around (N : Node_Id; Clean : Boolean);\n+   procedure Insert_Actions_In_Scope_Around\n+     (N         : Node_Id;\n+      Clean     : Boolean;\n+      Manage_SS : Boolean);\n    --  Insert the before-actions kept in the scope stack before N, and the\n-   --  after-actions after N, which must be a member of a list. If Clean is\n-   --  True, also insert the cleanup actions.\n+   --  after-actions after N, which must be a member of a list. If flag Clean\n+   --  is set, insert any cleanup actions. If flag Manage_SS is set, insert\n+   --  calls to mark and release the secondary stack.\n \n    function Make_Transient_Block\n      (Loc    : Source_Ptr;\n@@ -1477,12 +1481,7 @@ package body Exp_Ch7 is\n          --  Release the secondary stack mark\n \n          if Present (Mark_Id) then\n-            Append_To (Finalizer_Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of (RTE (RE_SS_Release), Loc),\n-                Parameter_Associations => New_List (\n-                  New_Occurrence_Of (Mark_Id, Loc))));\n+            Append_To (Finalizer_Stmts, Build_SS_Release_Call (Loc, Mark_Id));\n          end if;\n \n          --  Protect the statements with abort defer/undefer. This is only when\n@@ -3963,15 +3962,7 @@ package body Exp_Ch7 is\n          if Needs_Sec_Stack_Mark then\n             Mark := Make_Temporary (Loc, 'M');\n \n-            Append_To (New_Decls,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Mark,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (RTE (RE_Mark_Id), Loc),\n-                Expression          =>\n-                  Make_Function_Call (Loc,\n-                    Name => New_Occurrence_Of (RTE (RE_SS_Mark), Loc))));\n-\n+            Append_To (New_Decls, Build_SS_Mark_Call (Loc, Mark));\n             Set_Uses_Sec_Stack (Scop, False);\n          end if;\n \n@@ -4590,7 +4581,11 @@ package body Exp_Ch7 is\n    -- Insert_Actions_In_Scope_Around --\n    ------------------------------------\n \n-   procedure Insert_Actions_In_Scope_Around (N : Node_Id; Clean : Boolean) is\n+   procedure Insert_Actions_In_Scope_Around\n+     (N         : Node_Id;\n+      Clean     : Boolean;\n+      Manage_SS : Boolean)\n+   is\n       Act_Before  : constant List_Id :=\n         Scope_Stack.Table (Scope_Stack.Last).Actions_To_Be_Wrapped (Before);\n       Act_After   : constant List_Id :=\n@@ -4952,86 +4947,101 @@ package body Exp_Ch7 is\n          end if;\n       end Process_Transient_Objects;\n \n+      --  Local variables\n+\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Node_To_Wrap : constant Node_Id    := Node_To_Be_Wrapped;\n+      First_Obj    : Node_Id;\n+      Last_Obj     : Node_Id;\n+      Mark_Id      : Entity_Id;\n+      Target       : Node_Id;\n+\n    --  Start of processing for Insert_Actions_In_Scope_Around\n \n    begin\n       if No (Act_Before) and then No (Act_After) and then No (Act_Cleanup) then\n          return;\n       end if;\n \n-      declare\n-         Node_To_Wrap : constant Node_Id := Node_To_Be_Wrapped;\n-         First_Obj    : Node_Id;\n-         Last_Obj     : Node_Id;\n-         Target       : Node_Id;\n+      --  If the node to be wrapped is the trigger of an asynchronous select,\n+      --  it is not part of a statement list. The actions must be inserted\n+      --  before the select itself, which is part of some list of statements.\n+      --  Note that the triggering alternative includes the triggering\n+      --  statement and an optional statement list. If the node to be wrapped\n+      --  is part of that list, the normal insertion applies.\n \n-      begin\n-         --  If the node to be wrapped is the trigger of an asynchronous\n-         --  select, it is not part of a statement list. The actions must be\n-         --  inserted before the select itself, which is part of some list of\n-         --  statements. Note that the triggering alternative includes the\n-         --  triggering statement and an optional statement list. If the node\n-         --  to be wrapped is part of that list, the normal insertion applies.\n-\n-         if Nkind (Parent (Node_To_Wrap)) = N_Triggering_Alternative\n-           and then not Is_List_Member (Node_To_Wrap)\n-         then\n-            Target := Parent (Parent (Node_To_Wrap));\n-         else\n-            Target := N;\n-         end if;\n+      if Nkind (Parent (Node_To_Wrap)) = N_Triggering_Alternative\n+        and then not Is_List_Member (Node_To_Wrap)\n+      then\n+         Target := Parent (Parent (Node_To_Wrap));\n+      else\n+         Target := N;\n+      end if;\n \n-         First_Obj := Target;\n-         Last_Obj  := Target;\n+      First_Obj := Target;\n+      Last_Obj  := Target;\n \n-         --  Add all actions associated with a transient scope into the main\n-         --  tree. There are several scenarios here:\n+      --  Add all actions associated with a transient scope into the main tree.\n+      --  There are several scenarios here:\n \n-         --       +--- Before ----+        +----- After ---+\n-         --    1) First_Obj ....... Target ........ Last_Obj\n+      --       +--- Before ----+        +----- After ---+\n+      --    1) First_Obj ....... Target ........ Last_Obj\n \n-         --    2) First_Obj ....... Target\n+      --    2) First_Obj ....... Target\n \n-         --    3)                   Target ........ Last_Obj\n+      --    3)                   Target ........ Last_Obj\n \n-         if Present (Act_Before) then\n+      --  Flag declarations are inserted before the first object\n \n-            --  Flag declarations are inserted before the first object\n+      if Present (Act_Before) then\n+         First_Obj := First (Act_Before);\n+         Insert_List_Before (Target, Act_Before);\n+      end if;\n \n-            First_Obj := First (Act_Before);\n+      --  Finalization calls are inserted after the last object\n \n-            Insert_List_Before (Target, Act_Before);\n-         end if;\n+      if Present (Act_After) then\n+         Last_Obj := Last (Act_After);\n+         Insert_List_After (Target, Act_After);\n+      end if;\n \n-         if Present (Act_After) then\n+      --  Mark and release the secondary stack when the context warrants it\n \n-            --  Finalization calls are inserted after the last object\n+      if Manage_SS then\n+         Mark_Id := Make_Temporary (Loc, 'M');\n \n-            Last_Obj := Last (Act_After);\n+         --  Generate:\n+         --    Mnn : constant Mark_Id := SS_Mark;\n \n-            Insert_List_After (Target, Act_After);\n-         end if;\n+         Insert_Before_And_Analyze\n+           (First_Obj, Build_SS_Mark_Call (Loc, Mark_Id));\n \n-         --  Check for transient controlled objects associated with Target and\n-         --  generate the appropriate finalization actions for them.\n+         --  Generate:\n+         --    SS_Release (Mnn);\n \n-         Process_Transient_Objects\n-           (First_Object => First_Obj,\n-            Last_Object  => Last_Obj,\n-            Related_Node => Target);\n+         Insert_After_And_Analyze\n+           (Last_Obj, Build_SS_Release_Call (Loc, Mark_Id));\n+      end if;\n \n-         --  Reset the action lists\n+      --  Check for transient controlled objects associated with Target and\n+      --  generate the appropriate finalization actions for them.\n \n-         Scope_Stack.Table\n-           (Scope_Stack.Last).Actions_To_Be_Wrapped (Before) := No_List;\n-         Scope_Stack.Table\n-           (Scope_Stack.Last).Actions_To_Be_Wrapped (After)  := No_List;\n+      Process_Transient_Objects\n+        (First_Object => First_Obj,\n+         Last_Object  => Last_Obj,\n+         Related_Node => Target);\n \n-         if Clean then\n-            Scope_Stack.Table\n-              (Scope_Stack.Last).Actions_To_Be_Wrapped (Cleanup) := No_List;\n-         end if;\n-      end;\n+      --  Reset the action lists\n+\n+      Scope_Stack.Table\n+        (Scope_Stack.Last).Actions_To_Be_Wrapped (Before) := No_List;\n+      Scope_Stack.Table\n+        (Scope_Stack.Last).Actions_To_Be_Wrapped (After)  := No_List;\n+\n+      if Clean then\n+         Scope_Stack.Table\n+           (Scope_Stack.Last).Actions_To_Be_Wrapped (Cleanup) := No_List;\n+      end if;\n    end Insert_Actions_In_Scope_Around;\n \n    ------------------------------\n@@ -8019,7 +8029,8 @@ package body Exp_Ch7 is\n       --  nodes needed by those actions. Do not insert cleanup actions here,\n       --  they will be transferred to the newly created block.\n \n-      Insert_Actions_In_Scope_Around (Action, Clean => False);\n+      Insert_Actions_In_Scope_Around\n+        (Action, Clean => False, Manage_SS => False);\n \n       Insert := Prev (Action);\n       if Present (Insert) then\n@@ -8145,43 +8156,54 @@ package body Exp_Ch7 is\n    --    [Deep_]Finalize (_v2);\n \n    procedure Wrap_Transient_Declaration (N : Node_Id) is\n-      Encl_S  : Entity_Id;\n-      S       : Entity_Id;\n-      Uses_SS : Boolean;\n+      Curr_S : Entity_Id;\n+      Encl_S : Entity_Id;\n \n    begin\n-      S := Current_Scope;\n-      Encl_S := Scope (S);\n-\n-      --  Insert Actions kept in the Scope stack. Since we are not generating\n-      --  a block, we must also insert the cleanup actions in the tree now.\n-\n-      Insert_Actions_In_Scope_Around (N, Clean => True);\n-\n-      --  If the declaration is consuming some secondary stack, mark the\n-      --  enclosing scope appropriately.\n-\n-      Uses_SS := Uses_Sec_Stack (S);\n+      Curr_S := Current_Scope;\n+      Encl_S := Scope (Curr_S);\n+\n+      --  Insert all actions inluding cleanup generated while analyzing or\n+      --  expanding the transient context back into the tree. Manage the\n+      --  secondary stack when the object declaration appears in a library\n+      --  level package [body]. This is not needed for .NET/JVM as those do\n+      --  not support the secondary stack.\n+\n+      Insert_Actions_In_Scope_Around\n+        (N         => N,\n+         Clean     => True,\n+         Manage_SS =>\n+           VM_Target = No_VM\n+             and then Uses_Sec_Stack (Curr_S)\n+             and then Nkind (N) = N_Object_Declaration\n+             and then Ekind_In (Encl_S, E_Package, E_Package_Body)\n+             and then Is_Library_Level_Entity (Encl_S));\n       Pop_Scope;\n \n-      --  Put the local entities back in the enclosing scope, and set the\n-      --  Is_Public flag appropriately.\n+      --  Relocate local entities declared within the transient scope to the\n+      --  enclosing scope. This action sets their Is_Public flag accordingly.\n+\n+      Transfer_Entities (Curr_S, Encl_S);\n \n-      Transfer_Entities (S, Encl_S);\n+      --  Mark the enclosing dynamic scope to ensure that the secondary stack\n+      --  is properly released upon exiting the said scope. This is not needed\n+      --  for .NET/JVM as those do not support the secondary stack.\n \n-      --  Mark the enclosing dynamic scope so that the sec stack will be\n-      --  released upon its exit unless this is a function that returns on\n-      --  the sec stack in which case this will be done by the caller.\n+      if VM_Target = No_VM and then Uses_Sec_Stack (Curr_S) then\n+         Curr_S := Enclosing_Dynamic_Scope (Curr_S);\n \n-      if VM_Target = No_VM and then Uses_SS then\n-         S := Enclosing_Dynamic_Scope (S);\n+         --  Do not mark a function that returns on the secondary stack as the\n+         --  reclamation is done by the caller.\n \n-         if Ekind (S) = E_Function\n-           and then Requires_Transient_Scope (Etype (S))\n+         if Ekind (Curr_S) = E_Function\n+           and then Requires_Transient_Scope (Etype (Curr_S))\n          then\n             null;\n+\n+         --  Otherwise mark the enclosing dynamic scope\n+\n          else\n-            Set_Uses_Sec_Stack (S);\n+            Set_Uses_Sec_Stack (Curr_S);\n             Check_Restriction (No_Secondary_Stack, N);\n          end if;\n       end if;"}, {"sha": "f12cf6ab4c3af74b91edf3ed5c389302f55f0ed0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -1013,6 +1013,49 @@ package body Exp_Util is\n       end if;\n    end Build_Runtime_Call;\n \n+   ------------------------\n+   -- Build_SS_Mark_Call --\n+   ------------------------\n+\n+   function Build_SS_Mark_Call\n+     (Loc  : Source_Ptr;\n+      Mark : Entity_Id) return Node_Id\n+   is\n+   begin\n+      --  Generate:\n+      --    Mark : constant Mark_Id := SS_Mark;\n+\n+      return\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Mark,\n+          Constant_Present    => True,\n+          Object_Definition   =>\n+            New_Occurrence_Of (RTE (RE_Mark_Id), Loc),\n+          Expression          =>\n+            Make_Function_Call (Loc,\n+              Name => New_Occurrence_Of (RTE (RE_SS_Mark), Loc)));\n+   end Build_SS_Mark_Call;\n+\n+   ---------------------------\n+   -- Build_SS_Release_Call --\n+   ---------------------------\n+\n+   function Build_SS_Release_Call\n+     (Loc  : Source_Ptr;\n+      Mark : Entity_Id) return Node_Id\n+   is\n+   begin\n+      --  Generate:\n+      --    SS_Release (Mark);\n+\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   =>\n+            New_Occurrence_Of (RTE (RE_SS_Release), Loc),\n+          Parameter_Associations => New_List (\n+            New_Occurrence_Of (Mark, Loc)));\n+   end Build_SS_Release_Call;\n+\n    ----------------------------\n    -- Build_Task_Array_Image --\n    ----------------------------"}, {"sha": "a47c787323777162721914134359683348adc82f", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -244,6 +244,18 @@ package Exp_Util is\n    --  information for the tree and for error messages. The call node is not\n    --  analyzed on return, the caller is responsible for analyzing it.\n \n+   function Build_SS_Mark_Call\n+     (Loc  : Source_Ptr;\n+      Mark : Entity_Id) return Node_Id;\n+   --  Build a call to routine System.Secondary_Stack.Mark. Mark denotes the\n+   --  entity of the secondary stack mark.\n+\n+   function Build_SS_Release_Call\n+     (Loc  : Source_Ptr;\n+      Mark : Entity_Id) return Node_Id;\n+   --  Build a call to routine System.Secondary_Stack.Release. Mark denotes the\n+   --  entity of the secondary stack mark.\n+\n    function Build_Task_Image_Decls\n      (Loc          : Source_Ptr;\n       Id_Ref       : Node_Id;"}, {"sha": "51f95692f76b558e96d9a0bdc46cd1d2eef541c4", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -2754,9 +2754,10 @@ package body Makeutl is\n                         Debug_Output\n                           (\"   -> \", Name_Id (Root_Source.Display_File));\n                         Dummy := Queue.Insert_No_Roots\n-                          (Source => (Format => Format_Gprbuild,\n-                                      Tree   => Source.Tree,\n-                                      Id     => Root_Source));\n+                          (Source => (Format  => Format_Gprbuild,\n+                                      Tree    => Source.Tree,\n+                                      Id      => Root_Source,\n+                                      Closure => False));\n \n                         Initialize_Source_Record (Root_Source);\n \n@@ -2926,8 +2927,10 @@ package body Makeutl is\n             --  False, put the Ada sources only when they are in a library\n             --  project.\n \n-            Iter   : Source_Iterator;\n-            Source : Prj.Source_Id;\n+            Iter    : Source_Iterator;\n+            Source  : Prj.Source_Id;\n+            OK      : Boolean;\n+            Closure : Boolean;\n \n          begin\n             --  Nothing to do when \"-u\" was specified and some files were\n@@ -2971,10 +2974,46 @@ package body Makeutl is\n                           or else Source.Project.Library)\n                        and then not Is_Subunit (Source)\n                      then\n-                        Queue.Insert\n-                          (Source => (Format => Format_Gprbuild,\n-                                      Tree   => Tree,\n-                                      Id     => Source));\n+                        OK := True;\n+                        Closure := False;\n+\n+                        if Source.Unit /= No_Unit_Index\n+                          and then Source.Project.Library\n+                          and then Source.Project.Standalone_Library /= No\n+                        then\n+                           --  Check if the unit is in the interface\n+                           OK := False;\n+\n+                           declare\n+                              List : String_List_Id :=\n+                                Source.Project.Lib_Interface_ALIs;\n+                              Element : String_Element;\n+\n+                           begin\n+                              while List /= Nil_String loop\n+                                 Element :=\n+                                   Project_Tree.Shared.String_Elements.Table\n+                                     (List);\n+\n+                                 if Element.Value = Name_Id (Source.Dep_Name)\n+                                 then\n+                                    OK := True;\n+                                    Closure := True;\n+                                    exit;\n+                                 end if;\n+\n+                                 List := Element.Next;\n+                              end loop;\n+                           end;\n+                        end if;\n+\n+                        if OK then\n+                           Queue.Insert\n+                             (Source => (Format  => Format_Gprbuild,\n+                                         Tree    => Tree,\n+                                         Id      => Source,\n+                                         Closure => Closure));\n+                        end if;\n                      end if;\n                   end if;\n                end if;\n@@ -3064,9 +3103,10 @@ package body Makeutl is\n                                or else Src_Id.Project.Library_Kind = Static)\n                   then\n                      Queue.Insert\n-                       (Source => (Format => Format_Gprbuild,\n-                                   Tree   => Project_Tree,\n-                                   Id     => Src_Id));\n+                       (Source => (Format  => Format_Gprbuild,\n+                                   Tree    => Project_Tree,\n+                                   Id      => Src_Id,\n+                                   Closure => True));\n                   end if;\n                end if;\n             end loop;\n@@ -3151,7 +3191,11 @@ package body Makeutl is\n             Data.Need_Linking     := False;\n \n          else\n-            Data.Closure_Needed   := Has_Mains;\n+            Data.Closure_Needed   :=\n+              Has_Mains\n+              or else\n+                (Root_Project.Library\n+                 and then Root_Project.Standalone_Library /= No);\n             Data.Need_Compilation := All_Phases or Option_Compile_Only;\n             Data.Need_Binding     := All_Phases or Option_Bind_Only;\n             Data.Need_Linking     := (All_Phases or Option_Link_Only)"}, {"sha": "77f0f04976d94f4410fbf9d4e5acfee5c948bde9", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -489,8 +489,9 @@ package Makeutl is\n          record\n             case Format is\n                when Format_Gprbuild =>\n-                  Tree : Project_Tree_Ref := No_Project_Tree;\n-                  Id   : Source_Id        := No_Source;\n+                  Tree    : Project_Tree_Ref := No_Project_Tree;\n+                  Id      : Source_Id        := No_Source;\n+                  Closure : Boolean          := False;\n \n                when Format_Gnatmake =>\n                   File    : File_Name_Type := No_File;\n@@ -504,7 +505,8 @@ package Makeutl is\n       --  depends on the builder, and in particular whether it only supports\n       --  project-based files (in which case we have a full Source_Id record).\n \n-      No_Source_Info : constant Source_Info := (Format_Gprbuild, null, null);\n+      No_Source_Info : constant Source_Info :=\n+                                  (Format_Gprbuild, null, null, False);\n \n       procedure Initialize\n         (Queue_Per_Obj_Dir : Boolean;"}, {"sha": "28277bcefafc2c2305b453b7cd775241ae523617", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8889204245049467914f72b9ff664f31e56e24/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8e8889204245049467914f72b9ff664f31e56e24", "patch": "@@ -6262,7 +6262,7 @@ package body Sem_Res is\n                --  expressions, that are not handled by GNATprove.\n \n                elsif Is_Potentially_Unevaluated (N) then\n-                  Error_Msg_NE (\"?no contextual anlysis of &\", N, Nam);\n+                  Error_Msg_NE (\"?no contextual analysis of &\", N, Nam);\n                   Error_Msg_N\n                     (\"\\call appears in potentially unevaluated context\", N);\n                   Set_Is_Inlined_Always (Nam_UA, False);"}]}