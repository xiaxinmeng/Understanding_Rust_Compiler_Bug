{"sha": "1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgyM2JmNTNhYmY0N2JjZDI0MTdkYTkwZGYxY2Q0YmE0YzJiZjA5NA==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2004-09-13T19:32:05Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2004-09-13T19:32:05Z"}, "message": "SB-1 specific MIPS vector instructions.\n\n* config/mips/mips.c (CODE_FOR_mips_sqrt_ps): New.\n(sb1_bdesc, bdesc_map, bdesc_arrays): New.\n(mips_expand_builtin): Add SB-1 support.  Use bdesc_map and\nbdesc_arrays instead of mips_bdesc.\n(mips_init_builtins): Likewise.\n* config/mips/mips.h (TARGET_SB1): New.\n(HAVE_SQRT_P): Delete.\n* config/mips/mips.md (divide_condition): Support V2SF.\n(sqrt_condition, recip_condition): New.\n(div<mode>3): Use ANYF instead of SCALARF.\n(*div<mode>3): Use ANYF instead of SCALARF.  Use UNITMODE instead of\nMODE.\n(*recip<mode>3, *rsqrt<mode>a, *rsqrt<mode>b): Use recip_condition\ninstead of ISA_HAS_FP4.  Use ANYF instead of SCALARF.  Use UNITMODE\ninstead of MODE.\n(sqrt<mode>2): Use sqrt_condition instead of HAVE_SQRT_P.  Use ANYF\ninstead of SCALARF.  Use UNITMODE instead of MODE.\n* gcc.target/mips/sb1-1.c: New testcase.\n\nFrom-SVN: r87446", "tree": {"sha": "fdd719c5ecab0d5cb658394d19273841bfdcd19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdd719c5ecab0d5cb658394d19273841bfdcd19d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/comments", "author": null, "committer": null, "parents": [{"sha": "c8a52525540fd5688ce0d3bb10305032027bef25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a52525540fd5688ce0d3bb10305032027bef25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a52525540fd5688ce0d3bb10305032027bef25"}], "stats": {"total": 198, "additions": 155, "deletions": 43}, "files": [{"sha": "6eac4dc471b4bce72e28f81f8e6e6ac4f9c1f0b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "patch": "@@ -1,3 +1,23 @@\n+2004-09-13  James E Wilson  <wilson@specifixinc.com>\n+\n+\t* config/mips/mips.c (CODE_FOR_mips_sqrt_ps): New.\n+\t(sb1_bdesc, bdesc_map, bdesc_arrays): New.\n+\t(mips_expand_builtin): Add SB-1 support.  Use bdesc_map and\n+\tbdesc_arrays instead of mips_bdesc.\n+\t(mips_init_builtins): Likewise.\n+\t* config/mips/mips.h (TARGET_SB1): New.\n+\t(HAVE_SQRT_P): Delete.\n+\t* config/mips/mips.md (divide_condition): Support V2SF.\n+\t(sqrt_condition, recip_condition): New.\n+\t(div<mode>3): Use ANYF instead of SCALARF.\n+\t(*div<mode>3): Use ANYF instead of SCALARF.  Use UNITMODE instead of\n+\tMODE.\n+\t(*recip<mode>3, *rsqrt<mode>a, *rsqrt<mode>b): Use recip_condition\n+\tinstead of ISA_HAS_FP4.  Use ANYF instead of SCALARF.  Use UNITMODE\n+\tinstead of MODE.\n+\t(sqrt<mode>2): Use sqrt_condition instead of HAVE_SQRT_P.  Use ANYF\n+\tinstead of SCALARF.  Use UNITMODE instead of MODE.\n+\n 2004-09-13  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config.in: Regenerate after removal of libbanshee."}, {"sha": "c564f4e7f186e8ef072f2a980ec4ec179fa75d8b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "patch": "@@ -9410,6 +9410,36 @@ static const struct builtin_description mips_bdesc[] =\n   MIPS_FP_CONDITIONS (CMP_BUILTINS)\n };\n \n+/* Builtin functions for the SB-1 processor.  */\n+\n+#define CODE_FOR_mips_sqrt_ps CODE_FOR_sqrtv2sf2\n+\n+static const struct builtin_description sb1_bdesc[] =\n+{\n+  DIRECT_BUILTIN (sqrt_ps, MIPS_V2SF_FTYPE_V2SF, MASK_PAIRED_SINGLE)\n+};\n+\n+/* This helps provide a mapping from builtin function codes to bdesc\n+   arrays.  */\n+\n+struct bdesc_map\n+{\n+  /* The builtin function table that this entry describes.  */\n+  const struct builtin_description *bdesc;\n+\n+  /* The number of entries in the builtin function table.  */\n+  unsigned int size;\n+\n+  /* The target processor that supports these builtin functions.\n+     PROCESSOR_DEFAULT means we enable them for all processors.  */\n+  enum processor_type proc;\n+};\n+\n+static const struct bdesc_map bdesc_arrays[] =\n+{\n+  { mips_bdesc, ARRAY_SIZE (mips_bdesc), PROCESSOR_DEFAULT },\n+  { sb1_bdesc, ARRAY_SIZE (sb1_bdesc), PROCESSOR_SB1 }\n+};\n \n /* Take the head of argument list *ARGLIST and convert it into a form\n    suitable for input operand OP of instruction ICODE.  Return the value\n@@ -9457,31 +9487,44 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   enum mips_builtin_type type;\n   tree fndecl, arglist;\n   unsigned int fcode;\n+  const struct builtin_description *bdesc;\n+  const struct bdesc_map *m;\n \n   fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   arglist = TREE_OPERAND (exp, 1);\n   fcode = DECL_FUNCTION_CODE (fndecl);\n-  if (fcode >= ARRAY_SIZE (mips_bdesc))\n+\n+  bdesc = NULL;\n+  for (m = bdesc_arrays; m < &bdesc_arrays[ARRAY_SIZE (bdesc_arrays)]; m++)\n+    {\n+      if (fcode < m->size)\n+\t{\n+\t  bdesc = m->bdesc;\n+\t  icode = bdesc[fcode].icode;\n+\t  type = bdesc[fcode].builtin_type;\n+\t  break;\n+\t}\n+      fcode -= m->size;\n+    }\n+  if (bdesc == NULL)\n     return 0;\n \n-  icode = mips_bdesc[fcode].icode;\n-  type = mips_bdesc[fcode].builtin_type;\n   switch (type)\n     {\n     case MIPS_BUILTIN_DIRECT:\n       return mips_expand_builtin_direct (icode, target, arglist);\n \n     case MIPS_BUILTIN_MOVT:\n     case MIPS_BUILTIN_MOVF:\n-      return mips_expand_builtin_movtf (type, icode, mips_bdesc[fcode].cond,\n+      return mips_expand_builtin_movtf (type, icode, bdesc[fcode].cond,\n \t\t\t\t\ttarget, arglist);\n \n     case MIPS_BUILTIN_CMP_ANY:\n     case MIPS_BUILTIN_CMP_ALL:\n     case MIPS_BUILTIN_CMP_UPPER:\n     case MIPS_BUILTIN_CMP_LOWER:\n     case MIPS_BUILTIN_CMP_SINGLE:\n-      return mips_expand_builtin_compare (type, icode, mips_bdesc[fcode].cond,\n+      return mips_expand_builtin_compare (type, icode, bdesc[fcode].cond,\n \t\t\t\t\t  target, arglist);\n \n     default:\n@@ -9495,8 +9538,10 @@ void\n mips_init_builtins (void)\n {\n   const struct builtin_description *d;\n+  const struct bdesc_map *m;\n   tree types[(int) MIPS_MAX_FTYPE_MAX];\n   tree V2SF_type_node;\n+  unsigned int offset;\n \n   /* We have only builtins for -mpaired-single and -mips3d.  */\n   if (!TARGET_PAIRED_SINGLE_FLOAT)\n@@ -9561,10 +9606,20 @@ mips_init_builtins (void)\n     = build_function_type_list (double_type_node,\n \t\t\t\tdouble_type_node, double_type_node, NULL_TREE);\n \n-  for (d = mips_bdesc; d < &mips_bdesc[ARRAY_SIZE (mips_bdesc)]; d++)\n-    if ((d->target_flags & target_flags) == d->target_flags)\n-      lang_hooks.builtin_function (d->name, types[d->function_type],\n-\t\t\t\t   d - mips_bdesc, BUILT_IN_MD, NULL, NULL);\n+  /* Iterate through all of the bdesc arrays, initializing all of the\n+     builtin functions.  */\n+\n+  offset = 0;\n+  for (m = bdesc_arrays; m < &bdesc_arrays[ARRAY_SIZE (bdesc_arrays)]; m++)\n+    {\n+      if (m->proc == PROCESSOR_DEFAULT || (m->proc == mips_arch))\n+\tfor (d = m->bdesc; d < &m->bdesc[m->size]; d++)\n+\t  if ((d->target_flags & target_flags) == d->target_flags)\n+\t    lang_hooks.builtin_function (d->name, types[d->function_type],\n+\t\t\t\t\t d - m->bdesc + offset,\n+\t\t\t\t\t BUILT_IN_MD, NULL, NULL);\n+      offset += m->size;\n+    }\n }\n \n /* Expand a MIPS_BUILTIN_DIRECT function.  ICODE is the code of the"}, {"sha": "ddca621abfcca791fb0af8d414c532b1a104734b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "patch": "@@ -302,6 +302,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TARGET_MIPS5500             (mips_arch == PROCESSOR_R5500)\n #define TARGET_MIPS7000             (mips_arch == PROCESSOR_R7000)\n #define TARGET_MIPS9000             (mips_arch == PROCESSOR_R9000)\n+#define TARGET_SB1                  (mips_arch == PROCESSOR_SB1)\n #define TARGET_SR71K                (mips_arch == PROCESSOR_SR71000)\n \n /* Scheduling target defines.  */\n@@ -822,11 +823,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define GENERATE_MULT3_DI       ((TARGET_MIPS3900)                      \\\n \t\t\t\t && !TARGET_MIPS16)\n \n-/* Macros to decide whether certain features are available or not,\n-   depending on the instruction set architecture level.  */\n-\n-#define HAVE_SQRT_P()\t\t(!ISA_MIPS1)\n-\n /* True if the ABI can only work with 64-bit integer registers.  We\n    generally allow ad-hoc variations for TARGET_SINGLE_FLOAT, but\n    otherwise floating-point registers must also be 64-bit.  */"}, {"sha": "fb50b3bdab276b36b9e76aa625a6e14828ab58a6", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "patch": "@@ -381,7 +381,17 @@\n ;; Therefore, we only allow div.s if not working around SB-1 rev2\n ;; errata or if a slight loss of precision is OK.\n (define_mode_attr divide_condition\n-  [DF (SF \"!TARGET_FIX_SB1 || flag_unsafe_math_optimizations\")])\n+  [DF (SF \"!TARGET_FIX_SB1 || flag_unsafe_math_optimizations\")\n+   (V2SF \"TARGET_SB1 && (!TARGET_FIX_SB1 || flag_unsafe_math_optimizations)\")])\n+\n+; This attribute gives the condition for which sqrt instructions exist.\n+(define_mode_attr sqrt_condition\n+  [(SF \"!ISA_MIPS1\") (DF \"!ISA_MIPS1\") (V2SF \"TARGET_SB1\")])\n+\n+; This attribute gives the condition for which recip and rsqrt instructions\n+; exist.\n+(define_mode_attr recip_condition\n+  [(SF \"ISA_HAS_FP4\") (DF \"ISA_HAS_FP4\") (V2SF \"TARGET_SB1\")])\n \n ;; This code macro allows all branch instructions to be generated from\n ;; a single define_expand template.\n@@ -1703,9 +1713,9 @@\n ;;\n \n (define_expand \"div<mode>3\"\n-  [(set (match_operand:SCALARF 0 \"register_operand\")\n-\t(div:SCALARF (match_operand:SCALARF 1 \"reg_or_1_operand\")\n-\t\t     (match_operand:SCALARF 2 \"register_operand\")))]\n+  [(set (match_operand:ANYF 0 \"register_operand\")\n+\t(div:ANYF (match_operand:ANYF 1 \"reg_or_1_operand\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\")))]\n   \"<divide_condition>\"\n {\n   if (const_1_operand (operands[1], <MODE>mode))\n@@ -1726,9 +1736,9 @@\n ;; long latency op destination register.\n \n (define_insn \"*div<mode>3\"\n-  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n-\t(div:SCALARF (match_operand:SCALARF 1 \"register_operand\" \"f\")\n-\t\t     (match_operand:SCALARF 2 \"register_operand\" \"f\")))]\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(div:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n   \"<divide_condition>\"\n {\n   if (TARGET_FIX_SB1)\n@@ -1737,25 +1747,25 @@\n     return \"div.<fmt>\\t%0,%1,%2\";\n }\n   [(set_attr \"type\" \"fdiv\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<UNITMODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n                       (const_int 4)))])\n \n (define_insn \"*recip<mode>3\"\n-  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n-\t(div:SCALARF (match_operand:SCALARF 1 \"const_1_operand\" \"\")\n-\t\t     (match_operand:SCALARF 2 \"register_operand\" \"f\")))]\n-  \"ISA_HAS_FP4 && flag_unsafe_math_optimizations\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(div:ANYF (match_operand:ANYF 1 \"const_1_operand\" \"\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"<recip_condition> && flag_unsafe_math_optimizations\"\n {\n   if (TARGET_FIX_SB1)\n     return \"recip.<fmt>\\t%0,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n     return \"recip.<fmt>\\t%0,%2\";\n }\n   [(set_attr \"type\" \"frdiv\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<UNITMODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n@@ -1798,55 +1808,53 @@\n ;; \"*div[sd]f3\" comment for details).\n \n (define_insn \"sqrt<mode>2\"\n-  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n-\t(sqrt:SCALARF (match_operand:SCALARF 1 \"register_operand\" \"f\")))]\n-  \"HAVE_SQRT_P()\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(sqrt:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"<sqrt_condition>\"\n {\n   if (TARGET_FIX_SB1)\n     return \"sqrt.<fmt>\\t%0,%1\\;mov.<fmt>\\t%0,%0\";\n   else\n     return \"sqrt.<fmt>\\t%0,%1\";\n }\n   [(set_attr \"type\" \"fsqrt\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<UNITMODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n                       (const_int 4)))])\n \n (define_insn \"*rsqrt<mode>a\"\n-  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n-\t(div:SCALARF\n-\t (match_operand:SCALARF 1 \"const_1_operand\" \"\")\n-\t (sqrt:SCALARF (match_operand:SCALARF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && flag_unsafe_math_optimizations\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(div:ANYF (match_operand:ANYF 1 \"const_1_operand\" \"\")\n+\t\t  (sqrt:ANYF (match_operand:ANYF 2 \"register_operand\" \"f\"))))]\n+  \"<recip_condition> && flag_unsafe_math_optimizations\"\n {\n   if (TARGET_FIX_SB1)\n     return \"rsqrt.<fmt>\\t%0,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n     return \"rsqrt.<fmt>\\t%0,%2\";\n }\n   [(set_attr \"type\" \"frsqrt\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<UNITMODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n                       (const_int 4)))])\n \n (define_insn \"*rsqrt<mode>b\"\n-  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n-\t(sqrt:SCALARF\n-\t (div:SCALARF (match_operand:SCALARF 1 \"const_1_operand\" \"\")\n-\t\t      (match_operand:SCALARF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && flag_unsafe_math_optimizations\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(sqrt:ANYF (div:ANYF (match_operand:ANYF 1 \"const_1_operand\" \"\")\n+\t\t\t     (match_operand:ANYF 2 \"register_operand\" \"f\"))))]\n+  \"<recip_condition> && flag_unsafe_math_optimizations\"\n {\n   if (TARGET_FIX_SB1)\n     return \"rsqrt.<fmt>\\t%0,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n     return \"rsqrt.<fmt>\\t%0,%2\";\n }\n   [(set_attr \"type\" \"frsqrt\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<UNITMODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)"}, {"sha": "4736e13e528c7470775061d08954dd029952693d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "patch": "@@ -1,3 +1,7 @@\n+2004-09-13  James E Wilson  <wilson@specifixinc.com>\n+\n+\t* gcc.target/mips/sb1-1.c: New testcase.\n+\n 2004-09-12  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* lib/g77-dg.exp: Remove unused file."}, {"sha": "b6d671b7756f90542d4a118dcb815f80f53c855f", "filename": "gcc/testsuite/gcc.target/mips/sb1-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsb1-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1823bf53abf47bcd2417da90df1cd4ba4c2bf094/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsb1-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsb1-1.c?ref=1823bf53abf47bcd2417da90df1cd4ba4c2bf094", "patch": "@@ -0,0 +1,29 @@\n+/* Test SB-1 v2sf extensions.  */\n+/* { dg-do compile { target mipsisa64*-*-* } } */ \n+/* { dg-options \"-march=sb1 -O2 -mpaired-single -mhard-float -mfp64 -ffast-math\" } */ \n+/* { dg-final { scan-assembler \"div.ps\" } } */ \n+/* { dg-final { scan-assembler \"recip.ps\" } } */ \n+/* { dg-final { scan-assembler \"sqrt.ps\" } } */ \n+/* { dg-final { scan-assembler \"rsqrt.ps\" } } */ \n+\n+typedef float v2sf __attribute__ ((vector_size (8)));\n+\n+v2sf divide (v2sf a, v2sf b)\n+{\n+  return a / b;\n+}\n+\n+v2sf recip (v2sf a)\n+{\n+  return ((v2sf) {1.0, 1.0}) / a;\n+}\n+\n+v2sf squareroot (v2sf a)\n+{\n+  return __builtin_mips_sqrt_ps (a);\n+}\n+\n+v2sf rsqrt (v2sf a)\n+{\n+  return ((v2sf) {1.0, 1.0}) / __builtin_mips_sqrt_ps (a);\n+}"}]}