{"sha": "d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0MzBkOWEwYzAyY2FjNDY1NWNlZGQxZTQ4OWFkMWVhMDhkZmZiMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-13T20:42:01Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-13T20:42:01Z"}, "message": "re PR fortran/48351 ([OOP]  Realloc on assignment fails if parent component is CLASS)\n\n2012-01-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/48351\n\t* trans-array.c (structure_alloc_comps): Suppress interative\n\tcall to self, when current component is deallocated using\n\tgfc_trans_dealloc_allocated.\n\t* class.c (gfc_build_class_symbol): Copy the 'alloc_comp'\n\tattribute from the declared type to the class structure.\n\n2012-01-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/48351\n\t* gfortran.dg/alloc_comp_assign.f03: New.\n\t* gfortran.dg/allocatable_scalar_9.f90: Reduce count of\n\t__BUILTIN_FREE from 38 to 32.\n\nFrom-SVN: r183162", "tree": {"sha": "07819544bb4329a28bcdd3999adbd130affead4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07819544bb4329a28bcdd3999adbd130affead4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/comments", "author": null, "committer": null, "parents": [{"sha": "04771457dcb662ecb0cab80e5f432ab5827f6ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04771457dcb662ecb0cab80e5f432ab5827f6ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04771457dcb662ecb0cab80e5f432ab5827f6ec4"}], "stats": {"total": 110, "additions": 94, "deletions": 16}, "files": [{"sha": "3fe6d9dc823db9115ff4a1bc88642f2e4fc24d42", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "patch": "@@ -1,3 +1,12 @@\n+2012-01-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/48351\n+\t* trans-array.c (structure_alloc_comps): Suppress interative\n+\tcall to self, when current component is deallocated using\n+\tgfc_trans_dealloc_allocated.\n+\t* class.c (gfc_build_class_symbol): Copy the 'alloc_comp'\n+\tattribute from the declared type to the class structure.\n+\n 2012-01-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51842"}, {"sha": "a17fc0a1fa52243794627ff0157d356f4016bf87", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "patch": "@@ -432,6 +432,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n     }\n     \n   fclass->attr.extension = ts->u.derived->attr.extension + 1;\n+  fclass->attr.alloc_comp = ts->u.derived->attr.alloc_comp;\n   fclass->attr.is_class = 1;\n   ts->u.derived = fclass;\n   attr->allocatable = attr->pointer = attr->dimension = attr->codimension = 0;"}, {"sha": "57793cee44a262f76f8e6d510ebe67777e39ddc3", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "patch": "@@ -7238,6 +7238,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   gfc_loopinfo loop;\n   stmtblock_t fnblock;\n   stmtblock_t loopbody;\n+  stmtblock_t tmpblock;\n   tree decl_type;\n   tree tmp;\n   tree comp;\n@@ -7249,6 +7250,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   tree ctype;\n   tree vref, dref;\n   tree null_cond = NULL_TREE;\n+  bool called_dealloc_with_status;\n \n   gfc_init_block (&fnblock);\n \n@@ -7359,25 +7361,20 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       switch (purpose)\n \t{\n \tcase DEALLOCATE_ALLOC_COMP:\n-\t  if (cmp_has_alloc_comps && !c->attr.pointer)\n-\t    {\n-\t      /* Do not deallocate the components of ultimate pointer\n-\t\t components.  */\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n-\t\t\t\t\t   rank, purpose);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\t    }\n+\n+\t  /* gfc_deallocate_scalar_with_status calls gfc_deallocate_alloc_comp\n+\t     (ie. this function) so generate all the calls and suppress the\n+\t     recursion from here, if necessary.  */\n+\t  called_dealloc_with_status = false;\n+\t  gfc_init_block (&tmpblock);\n \n \t  if (c->attr.allocatable\n \t      && (c->attr.dimension || c->attr.codimension))\n \t    {\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable)\n \t    {\n@@ -7387,12 +7384,13 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t      tmp = gfc_deallocate_scalar_with_status (comp, NULL, true, NULL,\n \t\t\t\t\t\t       c->ts);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\t      called_dealloc_with_status = true;\n \n \t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t     void_type_node, comp,\n \t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n \t    {\n@@ -7412,14 +7410,33 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t{\n \t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL, true, NULL,\n \t\t\t\t\t\t\t   CLASS_DATA (c)->ts);\n-\t\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t\t  gfc_add_expr_to_block (&tmpblock, tmp);\n+\t\t  called_dealloc_with_status = true;\n \n \t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t\t void_type_node, comp,\n \t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n \t\t}\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\t    }\n+\n+\t  if (cmp_has_alloc_comps\n+\t\t&& !c->attr.pointer\n+\t\t&& !called_dealloc_with_status)\n+\t    {\n+\t      /* Do not deallocate the components of ultimate pointer\n+\t\t components or iteratively call self if call has been made\n+\t\t to gfc_trans_dealloc_allocated  */\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n+\t      rank = c->as ? c->as->rank : 0;\n+\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n+\t\t\t\t\t   rank, purpose);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n+\n+\t  /* Now add the deallocation of this component.  */\n+\t  gfc_add_block_to_block (&fnblock, &tmpblock);\n \t  break;\n \n \tcase NULLIFY_ALLOC_COMP:"}, {"sha": "44cf019f1fa22a0f594db926b6e189afe3f76af3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "patch": "@@ -1,3 +1,10 @@\n+2012-01-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/48351\n+\t* gfortran.dg/alloc_comp_assign.f03: New.\n+\t* gfortran.dg/allocatable_scalar_9.f90: Reduce count of\n+\t__BUILTIN_FREE from 38 to 32.\n+\n 2012-01-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/20681"}, {"sha": "b44769d9668ff051c7f5aa8effe5bbd6446dd98b", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_12.f03", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_12.f03?ref=d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+! PR48351 - automatic (re)allocation of allocatable components of class objects\n+!\n+! Contributed by Nasser M. Abbasi on comp.lang.fortran\n+!\n+module foo\n+  implicit none\n+  type :: foo_t\n+    private\n+    real, allocatable :: u(:)\n+  contains\n+    procedure :: make\n+    procedure :: disp\n+  end type foo_t\n+contains\n+  subroutine make(this,u)\n+    implicit none\n+    class(foo_t) :: this\n+    real, intent(in) :: u(:)\n+    this%u = u(int (u))       ! The failure to allocate occurred here.\n+    if (.not.allocated (this%u)) call abort\n+  end subroutine make\n+  function disp(this)\n+    implicit none\n+    class(foo_t) :: this\n+    real, allocatable :: disp (:)\n+    if (allocated (this%u)) disp = this%u\n+  end function\n+end module foo\n+\n+program main2\n+  use foo\n+  implicit none\n+  type(foo_t) :: o\n+  real, allocatable :: u(:)\n+  u=real ([3,2,1,4])\n+  call o%make(u)\n+  if (any (int (o%disp()) .ne. [1,2,3,4])) call abort\n+  u=real ([2,1])\n+  call o%make(u)\n+  if (any (int (o%disp()) .ne. [1,2])) call abort\n+end program main2\n+! { dg-final { cleanup-modules \"foo\" } }\n+"}, {"sha": "f4c6599b02c4bb472bbecfa1a29a83d7cc8b4b13", "filename": "gcc/testsuite/gfortran.dg/allocatable_scalar_9.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6430d9a0c02cac4655cedd1e489ad1ea08dffb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_9.f90?ref=d6430d9a0c02cac4655cedd1e489ad1ea08dffb2", "patch": "@@ -49,7 +49,7 @@ end module m\n if(allocated(na4%b4)) call abort()\n end\n \n-! { dg-final { scan-tree-dump-times \"__builtin_free\" 38 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 32 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n \n ! { dg-final { cleanup-modules \"m\" } }"}]}