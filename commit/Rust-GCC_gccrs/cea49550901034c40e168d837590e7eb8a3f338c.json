{"sha": "cea49550901034c40e168d837590e7eb8a3f338c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhNDk1NTA5MDEwMzRjNDBlMTY4ZDgzNzU5MGU3ZWI4YTNmMzM4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-23T00:02:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-23T00:02:55Z"}, "message": "re PR middle-end/17075 (miscompilation with tail calls in cfgexpand)\n\n        PR 17075\n        * cfgexpand.c (expand_gimple_tailcall): Detect when we can both\n        create new blocks and fall through.\n        (expand_gimple_basic_block): Update to match.\n\nFrom-SVN: r86389", "tree": {"sha": "b04722eda4b3e12103ee4f6c6e4bce9694847ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b04722eda4b3e12103ee4f6c6e4bce9694847ef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cea49550901034c40e168d837590e7eb8a3f338c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea49550901034c40e168d837590e7eb8a3f338c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea49550901034c40e168d837590e7eb8a3f338c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea49550901034c40e168d837590e7eb8a3f338c/comments", "author": null, "committer": null, "parents": [{"sha": "0b540f12b0f00d4ca8c282d6988cc06026527c41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b540f12b0f00d4ca8c282d6988cc06026527c41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b540f12b0f00d4ca8c282d6988cc06026527c41"}], "stats": {"total": 47, "additions": 38, "deletions": 9}, "files": [{"sha": "99864a89aa6457aad823eb86d6e18cafff658778", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea49550901034c40e168d837590e7eb8a3f338c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea49550901034c40e168d837590e7eb8a3f338c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cea49550901034c40e168d837590e7eb8a3f338c", "patch": "@@ -1,3 +1,10 @@\n+2004-08-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 17075\n+\t* cfgexpand.c (expand_gimple_tailcall): Detect when we can both\n+\tcreate new blocks and fall through.\n+\t(expand_gimple_basic_block): Update to match.\n+\n 2004-08-22  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* reload.c (find_reloads_address): Make return value tri-state."}, {"sha": "b6ba991da743bce213c731961467a392e2b3d9a9", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea49550901034c40e168d837590e7eb8a3f338c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea49550901034c40e168d837590e7eb8a3f338c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=cea49550901034c40e168d837590e7eb8a3f338c", "patch": "@@ -129,10 +129,15 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n /* A subroutine of expand_gimple_basic_block.  Expand one CALL_EXPR\n    that has CALL_EXPR_TAILCALL set.  Returns non-null if we actually\n    generated a tail call (something that might be denied by the ABI\n-   rules governing the call; see calls.c).  */\n+   rules governing the call; see calls.c).\n+\n+   Sets CAN_FALLTHRU if we generated a *conditional* tail call, and\n+   can still reach the rest of BB.  The case here is __builtin_sqrt,\n+   where the NaN result goes through the external function (with a\n+   tailcall) and the normal result happens via a sqrt instruction.  */\n \n static basic_block\n-expand_gimple_tailcall (basic_block bb, tree stmt)\n+expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n {\n   rtx last = get_last_insn ();\n   edge e;\n@@ -145,6 +150,7 @@ expand_gimple_tailcall (basic_block bb, tree stmt)\n     if (CALL_P (last) && SIBLING_CALL_P (last))\n       goto found;\n \n+  *can_fallthru = true;\n   return NULL;\n \n  found:\n@@ -191,12 +197,17 @@ expand_gimple_tailcall (basic_block bb, tree stmt)\n   last = NEXT_INSN (last);\n   if (!BARRIER_P (last))\n     abort ();\n+\n+  *can_fallthru = false;\n   while (NEXT_INSN (last))\n     {\n       /* For instance an sqrt builtin expander expands if with\n \t sibcall in the then and label for `else`.  */\n       if (LABEL_P (NEXT_INSN (last)))\n-\tbreak;\n+\t{\n+\t  *can_fallthru = true;\n+\t  break;\n+\t}\n       delete_insn (NEXT_INSN (last));\n     }\n \n@@ -277,26 +288,37 @@ expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n   for (; !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       tree stmt = bsi_stmt (bsi);\n-      basic_block new_bb = NULL;\n+      basic_block new_bb;\n \n       if (!stmt)\n \tcontinue;\n \n       /* Expand this statement, then evaluate the resulting RTL and\n \t fixup the CFG accordingly.  */\n       if (TREE_CODE (stmt) == COND_EXPR)\n-\tnew_bb = expand_gimple_cond_expr (bb, stmt);\n+\t{\n+\t  new_bb = expand_gimple_cond_expr (bb, stmt);\n+\t  if (new_bb)\n+\t    return new_bb;\n+\t}\n       else\n \t{\n \t  tree call = get_call_expr_in (stmt);\n \t  if (call && CALL_EXPR_TAILCALL (call))\n-\t    new_bb = expand_gimple_tailcall (bb, stmt);\n+\t    {\n+\t      bool can_fallthru;\n+\t      new_bb = expand_gimple_tailcall (bb, stmt, &can_fallthru);\n+\t      if (new_bb)\n+\t\t{\n+\t\t  if (can_fallthru)\n+\t\t    bb = new_bb;\n+\t\t  else\n+\t\t    return new_bb;\n+\t\t}\n+\t    }\n \t  else\n \t    expand_expr_stmt (stmt);\n \t}\n-\n-      if (new_bb)\n-\treturn new_bb;\n     }\n \n   do_pending_stack_adjust ();"}]}