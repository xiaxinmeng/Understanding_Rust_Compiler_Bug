{"sha": "8d933e3147616e970f36e1b01d2b389ecc87b15c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5MzNlMzE0NzYxNmU5NzBmMzZlMWIwMWQyYjM4OWVjYzg3YjE1Yw==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-05-09T18:22:11Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-05-09T18:22:11Z"}, "message": "s390.c: (s390_branch_condition_mask...\n\n2005-05-09  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* config/s390/s390.c: (s390_branch_condition_mask,\n\ts390_branch_condition_mnemonic, s390_extra_constraint_str,\n\ts390_const_ok_for_constraint_p, s390_expand_plus_operand,\n\tlegitimize_pic_address, s390_emit_tls_call_insn,\n\tlegitimize_tls_address, legitimize_tls_address,\n\ts390_expand_addcc, print_shift_count_operand, print_operand,\n\taddr_generation_dependency_p, annotate_constant_pool_refs,\n\ts390_split_branches, find_constant_pool_ref,\n\treplace_constant_pool_ref, s390_add_constant, s390_find_constant,\n\ts390_find_execute, s390_mainpool_start, s390_chunkify_start,\n\ts390_output_pool_entry, s390_function_value,\n\ts390_call_saved_register_used, s390_emit_call): Replace\n\tconditional aborts by gcc_assert and unconditional by gcc_unreachable.\n\t(s390_select_ccmode, s390_match_ccmode_set, s390_extract_part,\n\ts390_cannot_force_const_mem, s390_output_dwarf_dtprel,\n\tget_some_local_dynamic_name, s390_function_arg_size,\n\ts390_function_arg_advance, s390_function_arg,\n\ts390_expand_builtin, s390_gen_rtx_const_DI): Replace abort in\n\tdefault case by gcc_unreachable.\n\t* config/s390/s390.md: (\"*cjump_31\", \"*icjump_31\", \"*jump31\"): Replace\n\tconditional abort by gcc_assert.\n\t(\"doloop_si31\"): Replace abort in last else by gcc_unreachable.\n\t(\"main_pool\", \"pool\"): Replace unconditional abort by gcc_unreachable.\n\nFrom-SVN: r99466", "tree": {"sha": "ef68ccb363b1123c85f0e3819673dd6524ed2fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef68ccb363b1123c85f0e3819673dd6524ed2fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d933e3147616e970f36e1b01d2b389ecc87b15c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d933e3147616e970f36e1b01d2b389ecc87b15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d933e3147616e970f36e1b01d2b389ecc87b15c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d933e3147616e970f36e1b01d2b389ecc87b15c/comments", "author": null, "committer": null, "parents": [{"sha": "5d81b82b3027ac70ff610a0f8f2e1a24665390ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d81b82b3027ac70ff610a0f8f2e1a24665390ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d81b82b3027ac70ff610a0f8f2e1a24665390ae"}], "stats": {"total": 289, "additions": 142, "deletions": 147}, "files": [{"sha": "950061c599ea7a31f9b751bf2d6be49dda3f5ab9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d933e3147616e970f36e1b01d2b389ecc87b15c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d933e3147616e970f36e1b01d2b389ecc87b15c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d933e3147616e970f36e1b01d2b389ecc87b15c", "patch": "@@ -1,3 +1,29 @@\n+2005-05-09  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390.c: (s390_branch_condition_mask,\n+\ts390_branch_condition_mnemonic, s390_extra_constraint_str,\n+\ts390_const_ok_for_constraint_p, s390_expand_plus_operand,\n+\tlegitimize_pic_address, s390_emit_tls_call_insn,\n+\tlegitimize_tls_address, legitimize_tls_address,\n+\ts390_expand_addcc, print_shift_count_operand, print_operand,\n+\taddr_generation_dependency_p, annotate_constant_pool_refs,\n+\ts390_split_branches, find_constant_pool_ref,\n+\treplace_constant_pool_ref, s390_add_constant, s390_find_constant,\n+\ts390_find_execute, s390_mainpool_start, s390_chunkify_start,\n+\ts390_output_pool_entry, s390_function_value,\n+\ts390_call_saved_register_used, s390_emit_call): Replace\n+\tconditional aborts by gcc_assert and unconditional by gcc_unreachable.\n+\t(s390_select_ccmode, s390_match_ccmode_set, s390_extract_part,\n+\ts390_cannot_force_const_mem, s390_output_dwarf_dtprel,\n+\tget_some_local_dynamic_name, s390_function_arg_size,\n+\ts390_function_arg_advance, s390_function_arg,\n+\ts390_expand_builtin, s390_gen_rtx_const_DI): Replace abort in\n+\tdefault case by gcc_unreachable.\n+\t* config/s390/s390.md: (\"*cjump_31\", \"*icjump_31\", \"*jump31\"): Replace\n+\tconditional abort by gcc_assert.\n+\t(\"doloop_si31\"): Replace abort in last else by gcc_unreachable.\n+\t(\"main_pool\", \"pool\"): Replace unconditional abort by gcc_unreachable.\n+\n 2005-05-09  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.c: (s390_decompose_address,"}, {"sha": "2c2647e03f79438b554779ea4a6d4a714684da2d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 103, "deletions": 132, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d933e3147616e970f36e1b01d2b389ecc87b15c/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d933e3147616e970f36e1b01d2b389ecc87b15c/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8d933e3147616e970f36e1b01d2b389ecc87b15c", "patch": "@@ -264,8 +264,7 @@ s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n {\n   enum machine_mode set_mode;\n \n-  if (GET_CODE (set) != SET)\n-    abort ();\n+  gcc_assert (GET_CODE (set) == SET);\n \n   if (GET_CODE (SET_DEST (set)) != REG || !CC_REGNO_P (REGNO (SET_DEST (set))))\n     return 1;\n@@ -301,7 +300,7 @@ s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return (GET_MODE (SET_SRC (set)) == set_mode);\n@@ -485,7 +484,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n \treturn CCUmode;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n }\n \n@@ -639,10 +638,9 @@ s390_branch_condition_mask (rtx code)\n   const int CC2 = 1 << 1;\n   const int CC3 = 1 << 0;\n \n-  if (GET_CODE (XEXP (code, 0)) != REG\n-      || REGNO (XEXP (code, 0)) != CC_REGNUM\n-      || XEXP (code, 1) != const0_rtx)\n-    abort ();\n+  gcc_assert (GET_CODE (XEXP (code, 0)) == REG);\n+  gcc_assert (REGNO (XEXP (code, 0)) == CC_REGNUM);\n+  gcc_assert (XEXP (code, 1) == const0_rtx);\n \n   switch (GET_MODE (XEXP (code, 0)))\n     {\n@@ -841,8 +839,7 @@ s390_branch_condition_mnemonic (rtx code, int inv)\n   if (inv)\n     mask ^= 15;\n \n-  if (mask < 1 || mask > 14)\n-    abort ();\n+  gcc_assert (mask >= 1 && mask <= 14);\n \n   return mnemonic[mask];\n }\n@@ -872,7 +869,7 @@ s390_extract_part (rtx op, enum machine_mode mode, int def)\n \treturn value & part_mask;\n     }\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* If OP is an integer constant of mode MODE with exactly one\n@@ -1563,8 +1560,7 @@ s390_extra_constraint_str (rtx op, int c, const char * str)\n {\n   struct s390_address addr;\n \n-  if (c != str[0])\n-    abort ();\n+  gcc_assert (c == str[0]);\n \n   /* Check for offsettable variants of memory constraints.  */\n   if (c == 'A')\n@@ -1692,8 +1688,7 @@ s390_const_ok_for_constraint_p (HOST_WIDE_INT value,\n   int def;\n   int part, part_goal;\n \n-  if (c != str[0])\n-    abort ();\n+  gcc_assert (c == str[0]);\n \n   switch (str[0])\n     {\n@@ -2162,7 +2157,7 @@ s390_cannot_force_const_mem (rtx x)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2295,8 +2290,8 @@ s390_expand_plus_operand (rtx target, rtx src,\n   struct s390_address ad;\n \n   /* src must be a PLUS; get its two operands.  */\n-  if (GET_CODE (src) != PLUS || GET_MODE (src) != Pmode)\n-    abort ();\n+  gcc_assert (GET_CODE (src) == PLUS);\n+  gcc_assert (GET_MODE (src) == Pmode);\n \n   /* Check if any of the two operands is already scheduled\n      for replacement by reload.  This can happen e.g. when\n@@ -2330,7 +2325,7 @@ s390_expand_plus_operand (rtx target, rtx src,\n       if (sum1 == scratch && sum2 == scratch)\n \t{\n \t  debug_rtx (src);\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       src = gen_rtx_PLUS (Pmode, sum1, sum2);\n@@ -2550,8 +2545,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  addr = XEXP (addr, 0);\n \t  if (GET_CODE (addr) == UNSPEC)\n \t    {\n-\t      if (XVECLEN (addr, 0) != 1)\n-                abort ();\n+\t      gcc_assert (XVECLEN (addr, 0) == 1);\n               switch (XINT (addr, 1))\n                 {\n                   /* If someone moved a GOT-relative UNSPEC\n@@ -2599,11 +2593,11 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n                   /* Everything else cannot happen.  */\n                   default:\n-                    abort ();\n+                    gcc_unreachable ();\n                 }\n \t    }\n-\t  else if (GET_CODE (addr) != PLUS)\n-\t    abort ();\n+\t  else \n+\t    gcc_assert (GET_CODE (addr) == PLUS);\n \t}\n       if (GET_CODE (addr) == PLUS)\n \t{\n@@ -2677,8 +2671,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t           && GET_CODE (op1) == CONST_INT\n \t           && XINT (op0, 1) == UNSPEC_GOTOFF)\n             {\n-\t      if (XVECLEN (op0, 0) != 1)\n-                abort ();\n+\t      gcc_assert (XVECLEN (op0, 0) == 1);\n \n               new = force_const_mem (Pmode, orig);\n             }\n@@ -2735,8 +2728,7 @@ s390_emit_tls_call_insn (rtx result_reg, rtx tls_call)\n {\n   rtx insn;\n \n-  if (!flag_pic)\n-    abort ();\n+  gcc_assert (flag_pic);\n \n   if (!s390_tls_symbol)\n     s390_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_offset\");\n@@ -2908,22 +2900,20 @@ legitimize_tls_address (rtx addr, rtx reg)\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   else if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == UNSPEC)\n     {\n       switch (XINT (XEXP (addr, 0), 1))\n \t{\n \tcase UNSPEC_INDNTPOFF:\n-\t  if (TARGET_CPU_ZARCH)\n-\t    new = addr;\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_CPU_ZARCH);\n+\t  new = addr;\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -2940,7 +2930,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n     }\n \n   else\n-    abort ();  /* for now ... */\n+    gcc_unreachable ();  /* for now ... */\n \n   return new;\n }\n@@ -3373,6 +3363,7 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n   rtx op_res;\n   rtx insn;\n   rtvec p;\n+  int ret;\n \n   if ((GET_MODE (cmp_op0) == SImode || GET_MODE (cmp_op0) == VOIDmode)\n       && (GET_MODE (cmp_op1) == SImode || GET_MODE (cmp_op1) == VOIDmode))\n@@ -3428,8 +3419,8 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n       insn = gen_rtx_SET (VOIDmode, gen_rtx_REG (cc_mode, CC_REGNUM),\n \t\t\t  gen_rtx_COMPARE (cc_mode, cmp_op0, cmp_op1));\n       /* We use insn_invalid_p here to add clobbers if required.  */\n-      if (insn_invalid_p (emit_insn (insn)))\n-\tabort ();\n+      ret = insn_invalid_p (emit_insn (insn));\n+      gcc_assert (!ret);\n \n       /* Emit ALC instruction pattern.  */\n       op_res = gen_rtx_fmt_ee (cmp_code, GET_MODE (dst),\n@@ -3500,8 +3491,8 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n       insn = gen_rtx_SET (VOIDmode, gen_rtx_REG (cc_mode, CC_REGNUM),\n \t\t\t  gen_rtx_COMPARE (cc_mode, cmp_op0, cmp_op1));\n       /* We use insn_invalid_p here to add clobbers if required.  */\n-      if (insn_invalid_p (emit_insn (insn)))\n-\tabort ();\n+      ret = insn_invalid_p (emit_insn (insn));\n+      gcc_assert (!ret);\n \n       /* Emit SLB instruction pattern.  */\n       if (!register_operand (src, GET_MODE (dst)))\n@@ -3541,7 +3532,7 @@ s390_output_dwarf_dtprel (FILE *file, int size, rtx x)\n       fputs (\"\\t.quad\\t\", file);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   output_addr_const (file, x);\n   fputs (\"@DTPOFF\", file);\n@@ -3607,10 +3598,12 @@ print_shift_count_operand (FILE *file, rtx op)\n     op = SUBREG_REG (op);\n \n   /* Sanity check.  */\n-  if (op && (GET_CODE (op) != REG\n-\t     || REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t     || REGNO_REG_CLASS (REGNO (op)) != ADDR_REGS))\n-    abort ();\n+  if (op)\n+    {\n+      gcc_assert (GET_CODE (op) == REG);\n+      gcc_assert (REGNO (op) < FIRST_PSEUDO_REGISTER);\n+      gcc_assert (REGNO_REG_CLASS (REGNO (op)) == ADDR_REGS);\n+    }\n \n   /* Shift counts are truncated to the low six bits anyway.  */\n   fprintf (file, HOST_WIDE_INT_PRINT_DEC, offset & 63);\n@@ -3657,7 +3650,7 @@ get_some_local_dynamic_name (void)\n         && for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n       return cfun->machine->some_ld_name;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Output machine-dependent UNSPECs occurring in address constant X\n@@ -3794,18 +3787,19 @@ print_operand (FILE *file, rtx x, int code)\n \t  assemble_name (file, get_some_local_dynamic_name ());\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       return;\n \n     case 'O':\n       {\n         struct s390_address ad;\n+\tint ret;\n \n-        if (GET_CODE (x) != MEM\n-            || !s390_decompose_address (XEXP (x, 0), &ad)\n-\t    || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n-            || ad.indx)\n-          abort ();\n+        gcc_assert (GET_CODE (x) == MEM);\n+\tret = s390_decompose_address (XEXP (x, 0), &ad);\n+\tgcc_assert (ret);\n+\tgcc_assert (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base));\n+\tgcc_assert (!ad.indx);\n \n         if (ad.disp)\n           output_addr_const (file, ad.disp);\n@@ -3817,12 +3811,13 @@ print_operand (FILE *file, rtx x, int code)\n     case 'R':\n       {\n         struct s390_address ad;\n+\tint ret;\n \n-        if (GET_CODE (x) != MEM\n-            || !s390_decompose_address (XEXP (x, 0), &ad)\n-\t    || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n-            || ad.indx)\n-          abort ();\n+        gcc_assert (GET_CODE (x) == MEM);\n+\tret = s390_decompose_address (XEXP (x, 0), &ad);\n+\tgcc_assert (ret);\n+\tgcc_assert (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base));\n+\tgcc_assert (!ad.indx);\n \n         if (ad.base)\n           fprintf (file, \"%s\", reg_names[REGNO (ad.base)]);\n@@ -3834,12 +3829,13 @@ print_operand (FILE *file, rtx x, int code)\n     case 'S':\n       {\n \tstruct s390_address ad;\n+\tint ret;\n \n-\tif (GET_CODE (x) != MEM\n-\t    || !s390_decompose_address (XEXP (x, 0), &ad)\n-\t    || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n-\t    || ad.indx)\n-\t  abort ();\n+        gcc_assert (GET_CODE (x) == MEM);\n+\tret = s390_decompose_address (XEXP (x, 0), &ad);\n+\tgcc_assert (ret);\n+\tgcc_assert (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base));\n+\tgcc_assert (!ad.indx);\n \n \tif (ad.disp)\n \t  output_addr_const (file, ad.disp);\n@@ -3857,7 +3853,7 @@ print_operand (FILE *file, rtx x, int code)\n       else if (GET_CODE (x) == MEM)\n \tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 4));\n       else\n-        abort ();\n+        gcc_unreachable ();\n       break;\n \n     case 'M':\n@@ -3866,7 +3862,7 @@ print_operand (FILE *file, rtx x, int code)\n       else if (GET_CODE (x) == MEM)\n \tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 8));\n       else\n-        abort ();\n+        gcc_unreachable ();\n       break;\n \n     case 'Y':\n@@ -3909,16 +3905,15 @@ print_operand (FILE *file, rtx x, int code)\n       break;\n \n     case CONST_DOUBLE:\n-      if (GET_MODE (x) != VOIDmode)\n-        abort ();\n+      gcc_assert (GET_MODE (x) == VOIDmode);\n       if (code == 'b')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x) & 0xff);\n       else if (code == 'x')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x) & 0xffff);\n       else if (code == 'h')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((CONST_DOUBLE_LOW (x) & 0xffff) ^ 0x8000) - 0x8000);\n       else\n-        abort ();\n+        gcc_unreachable ();\n       break;\n \n     default:\n@@ -4011,14 +4006,11 @@ addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n \t      pat = PATTERN (insn);\n \t      if (GET_CODE (pat) == PARALLEL)\n \t\t{\n-\t\t  if (XVECLEN (pat, 0) != 2)\n-\t\t    abort();\n+\t\t  gcc_assert (XVECLEN (pat, 0) == 2);\n \t\t  pat = XVECEXP (pat, 0, 0);\n \t\t}\n-\t      if (GET_CODE (pat) == SET)\n-\t\treturn refers_to_regno_p (regno, regno+1, SET_SRC (pat), 0);\n-\t      else\n-\t\tabort();\n+\t      gcc_assert (GET_CODE (pat) == SET);\n+\t      return refers_to_regno_p (regno, regno+1, SET_SRC (pat), 0);\n \t    }\n \t  else if (get_attr_atype (insn) == ATYPE_AGEN)\n \t    return reg_used_in_mem_p (regno, PATTERN (insn));\n@@ -4108,9 +4100,8 @@ annotate_constant_pool_refs (rtx *x)\n   int i, j;\n   const char *fmt;\n \n-  if (GET_CODE (*x) == SYMBOL_REF\n-      && CONSTANT_POOL_ADDRESS_P (*x))\n-    abort ();\n+  gcc_assert (GET_CODE (*x) != SYMBOL_REF\n+\t      || !CONSTANT_POOL_ADDRESS_P (*x));\n \n   /* Literal pool references can only occur inside a MEM ...  */\n   if (GET_CODE (*x) == MEM)\n@@ -4210,7 +4201,7 @@ static int\n s390_split_branches (void)\n {\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-  int new_literal = 0;\n+  int new_literal = 0, ret;\n   rtx insn, pat, tmp, target;\n   rtx *label;\n \n@@ -4281,8 +4272,8 @@ s390_split_branches (void)\n \t  target = gen_rtx_PLUS (Pmode, temp_reg, target);\n \t}\n \n-      if (!validate_change (insn, label, target, 0))\n-\tabort ();\n+      ret = validate_change (insn, label, target, 0);\n+      gcc_assert (ret);\n     }\n \n   return new_literal;\n@@ -4312,21 +4303,19 @@ find_constant_pool_ref (rtx x, rtx *ref)\n       && XINT (x, 1) == UNSPECV_POOL_ENTRY)\n     return;\n \n-  if (GET_CODE (x) == SYMBOL_REF\n-      && CONSTANT_POOL_ADDRESS_P (x))\n-    abort ();\n+  gcc_assert (GET_CODE (x) != SYMBOL_REF\n+              || !CONSTANT_POOL_ADDRESS_P (x));\n \n   if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_LTREF)\n     {\n       rtx sym = XVECEXP (x, 0, 0);\n-      if (GET_CODE (sym) != SYMBOL_REF\n-\t  || !CONSTANT_POOL_ADDRESS_P (sym))\n-\tabort ();\n+      gcc_assert (GET_CODE (sym) == SYMBOL_REF\n+\t          && CONSTANT_POOL_ADDRESS_P (sym));\n \n       if (*ref == NULL_RTX)\n \t*ref = sym;\n-      else if (*ref != sym)\n-\tabort ();\n+      else \n+\tgcc_assert (*ref == sym);\n \n       return;\n     }\n@@ -4355,8 +4344,7 @@ replace_constant_pool_ref (rtx *x, rtx ref, rtx offset)\n   int i, j;\n   const char *fmt;\n \n-  if (*x == ref)\n-    abort ();\n+  gcc_assert (*x != ref);\n \n   if (GET_CODE (*x) == UNSPEC\n       && XINT (*x, 1) == UNSPEC_LTREF\n@@ -4581,8 +4569,7 @@ s390_add_constant (struct constant_pool *pool, rtx val, enum machine_mode mode)\n   for (i = 0; i < NR_C_MODES; i++)\n     if (constant_modes[i] == mode)\n       break;\n-  if (i == NR_C_MODES)\n-    abort ();\n+  gcc_assert (i != NR_C_MODES);\n \n   for (c = pool->constants[i]; c != NULL; c = c->next)\n     if (rtx_equal_p (val, c->value))\n@@ -4614,15 +4601,13 @@ s390_find_constant (struct constant_pool *pool, rtx val,\n   for (i = 0; i < NR_C_MODES; i++)\n     if (constant_modes[i] == mode)\n       break;\n-  if (i == NR_C_MODES)\n-    abort ();\n+  gcc_assert (i != NR_C_MODES);\n \n   for (c = pool->constants[i]; c != NULL; c = c->next)\n     if (rtx_equal_p (val, c->value))\n       break;\n \n-  if (c == NULL)\n-    abort ();\n+  gcc_assert (c);\n \n   offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label),\n                                  gen_rtx_LABEL_REF (Pmode, pool->label));\n@@ -4684,8 +4669,7 @@ s390_find_execute (struct constant_pool *pool, rtx insn)\n     if (INSN_UID (insn) == INSN_UID (c->value))\n       break;\n \n-  if (c == NULL)\n-    abort ();\n+  gcc_assert (c);\n \n   offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label),\n \t\t\t\t gen_rtx_LABEL_REF (Pmode, pool->label));\n@@ -4886,8 +4870,7 @@ s390_mainpool_start (void)\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC_VOLATILE\n \t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPECV_MAIN_POOL)\n \t{\n-\t  if (pool->pool_insn)\n-\t    abort ();\n+\t  gcc_assert (!pool->pool_insn);\n \t  pool->pool_insn = insn;\n \t}\n \n@@ -4908,8 +4891,7 @@ s390_mainpool_start (void)\n \t}\n     }\n \n-  if (!pool->pool_insn && pool->size > 0)\n-    abort ();\n+  gcc_assert (pool->pool_insn || pool->size == 0);\n \n   if (pool->size >= 4096)\n     {\n@@ -5087,10 +5069,8 @@ s390_chunkify_start (void)\n \t  rtx ltrel_base = find_ltrel_base (PATTERN (insn));\n \t  if (ltrel_base)\n \t    {\n-\t      if (ltrel_base == pending_ltrel)\n-\t\tpending_ltrel = NULL_RTX;\n-\t      else\n-\t\tabort ();\n+\t      gcc_assert (ltrel_base == pending_ltrel);\n+\t      pending_ltrel = NULL_RTX;\n \t    }\n \t}\n \n@@ -5123,8 +5103,7 @@ s390_chunkify_start (void)\n \t\t  && GET_CODE (XEXP (constant, 0)) == UNSPEC\n \t\t  && XINT (XEXP (constant, 0), 1) == UNSPEC_LTREL_OFFSET)\n \t\t{\n-\t\t  if (pending_ltrel)\n-\t\t    abort ();\n+\t\t  gcc_assert (!pending_ltrel);\n \t\t  pending_ltrel = pool_ref;\n \t\t}\n \t    }\n@@ -5135,8 +5114,7 @@ s390_chunkify_start (void)\n \t  if (curr_pool)\n \t    s390_add_pool_insn (curr_pool, insn);\n \t  /* An LTREL_BASE must follow within the same basic block.  */\n-\t  if (pending_ltrel)\n-\t    abort ();\n+\t  gcc_assert (!pending_ltrel);\n \t}\n \n       if (!curr_pool\n@@ -5214,9 +5192,7 @@ s390_chunkify_start (void)\n \n   if (curr_pool)\n     s390_end_pool (curr_pool, NULL_RTX);\n-  if (pending_ltrel)\n-    abort ();\n-\n+  gcc_assert (!pending_ltrel);\n \n   /* Find all labels that are branched into\n      from an insn belonging to a different chunk.  */\n@@ -5456,8 +5432,7 @@ s390_output_pool_entry (rtx exp, enum machine_mode mode, unsigned int align)\n   switch (GET_MODE_CLASS (mode))\n     {\n     case MODE_FLOAT:\n-      if (GET_CODE (exp) != CONST_DOUBLE)\n-\tabort ();\n+      gcc_assert (GET_CODE (exp) == CONST_DOUBLE);\n \n       REAL_VALUE_FROM_CONST_DOUBLE (r, exp);\n       assemble_real (r, mode, align);\n@@ -5468,7 +5443,7 @@ s390_output_pool_entry (rtx exp, enum machine_mode mode, unsigned int align)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -6557,7 +6532,7 @@ s390_function_arg_size (enum machine_mode mode, tree type)\n     return GET_MODE_SIZE (mode);\n \n   /* If we have neither type nor mode, abort */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return true if a function argument of type TYPE and mode MODE\n@@ -6685,7 +6660,7 @@ s390_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       cum->gprs += ((size + UNITS_PER_WORD-1) / UNITS_PER_WORD);\n     }\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \n /* Define where to put the arguments to a function.\n@@ -6737,7 +6712,7 @@ s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   else if (type == void_type_node)\n     return const0_rtx;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return true if return values of type TYPE should be returned\n@@ -6780,11 +6755,9 @@ s390_function_value (tree type, enum machine_mode mode)\n       mode = promote_mode (type, TYPE_MODE (type), &unsignedp, 1);\n     }\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT\n-      && GET_MODE_CLASS (mode) != MODE_FLOAT)\n-    abort ();\n-  if (GET_MODE_SIZE (mode) > 8)\n-    abort ();\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n+               || GET_MODE_CLASS (mode) == MODE_FLOAT);\n+  gcc_assert (GET_MODE_SIZE (mode) <= 8);\n \n   if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     return gen_rtx_REG (mode, 16);\n@@ -7219,7 +7192,7 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       pat = GEN_FCN (icode) (target, op[0], op[1]);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   if (!pat)\n     return NULL_RTX;\n@@ -7293,7 +7266,7 @@ s390_gen_rtx_const_DI (int high, int low)\n #if HOST_BITS_PER_WIDE_INT >= 32\n   return immed_double_const ((HOST_WIDE_INT)low, (HOST_WIDE_INT)high, DImode);\n #else\n-  abort ();\n+  gcc_unreachable ();\n #endif\n #endif\n }\n@@ -7654,19 +7627,18 @@ s390_call_saved_register_used (tree argument_list)\n       parameter = TREE_VALUE (argument_list);\n       argument_list = TREE_CHAIN (argument_list);\n \n-      if (!parameter)\n-\tabort();\n+      gcc_assert (parameter);\n \n       /* For an undeclared variable passed as parameter we will get\n \t an ERROR_MARK node here.  */\n       if (TREE_CODE (parameter) == ERROR_MARK)\n \treturn true;\n \n-      if (! (type = TREE_TYPE (parameter)))\n-\tabort();\n+      type = TREE_TYPE (parameter);\n+      gcc_assert (type);\n \n-      if (! (mode = TYPE_MODE (TREE_TYPE (parameter))))\n-\tabort();\n+      mode = TYPE_MODE (type);\n+      gcc_assert (mode);\n \n       if (pass_by_reference (&cum, mode, type, true))\n  \t{\n@@ -7844,8 +7816,7 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n     {\n       /* s390_function_ok_for_sibcall should\n \t have denied sibcalls in this case.  */\n-      if (retaddr_reg == NULL_RTX)\n-\tabort ();\n+      gcc_assert (retaddr_reg != NULL_RTX);\n \n       use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n     }"}, {"sha": "7c6e82178b1db7e6e8435f3932fd3a8cf4276c68", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d933e3147616e970f36e1b01d2b389ecc87b15c/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d933e3147616e970f36e1b01d2b389ecc87b15c/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=8d933e3147616e970f36e1b01d2b389ecc87b15c", "patch": "@@ -6038,10 +6038,8 @@\n           (pc)))]\n   \"!TARGET_CPU_ZARCH\"\n {\n-  if (get_attr_length (insn) == 4)\n-    return \"j%C1\\t%l0\";\n-  else\n-    abort ();\n+  gcc_assert (get_attr_length (insn) == 4);\n+  return \"j%C1\\t%l0\";\n }\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"branch\")\n@@ -6103,10 +6101,8 @@\n           (label_ref (match_operand 0 \"\" \"\"))))]\n   \"!TARGET_CPU_ZARCH\"\n {\n-  if (get_attr_length (insn) == 4)\n-    return \"j%D1\\t%l0\";\n-  else\n-    abort ();\n+  gcc_assert (get_attr_length (insn) == 4);\n+  return \"j%D1\\t%l0\";\n }\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"branch\")\n@@ -6247,7 +6243,7 @@\n   else if (get_attr_length (insn) == 4)\n     return \"brct\\t%1,%l0\";\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n   \"&& reload_completed\n    && (! REG_P (operands[2])\n@@ -6364,10 +6360,8 @@\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n   \"!TARGET_CPU_ZARCH\"\n {\n-  if (get_attr_length (insn) == 4)\n-    return \"j\\t%l0\";\n-  else\n-    abort ();\n+  gcc_assert (get_attr_length (insn) == 4);\n+  return \"j\\t%l0\";\n }\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"  \"branch\")\n@@ -6992,7 +6986,9 @@\n   [(set (match_operand 0 \"register_operand\" \"=a\")\n         (unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL))]\n   \"GET_MODE (operands[0]) == Pmode\"\n-  \"* abort ();\"\n+{\n+  gcc_unreachable ();\n+}\n   [(set (attr \"type\") \n         (if_then_else (ne (symbol_ref \"TARGET_CPU_ZARCH\") (const_int 0))\n                       (const_string \"larl\") (const_string \"la\")))])\n@@ -7016,7 +7012,9 @@\n (define_insn \"pool\"\n   [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"n\")] UNSPECV_POOL)]\n   \"\"\n-  \"* abort ();\"\n+{\n+  gcc_unreachable ();\n+}\n   [(set (attr \"length\") (symbol_ref \"INTVAL (operands[0])\"))])\n \n ;;"}]}