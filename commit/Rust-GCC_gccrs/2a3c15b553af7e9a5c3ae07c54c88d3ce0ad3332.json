{"sha": "2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzYzE1YjU1M2FmN2U5YTVjM2FlMDdjNTRjODhkM2NlMGFkMzMzMg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-04-28T01:08:30Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-04-28T01:08:30Z"}, "message": "(attribute_hash_list): New function.\n\n(build_type_attribute_variant): Call it.\n(valid_machine_attribute): Handle attributes with arguments.\n(is_attribute_p): New function.\n(lookup_attribute): New function.\n(attribute_in_list): Deleted.\n(attribute_list_contained): Check TREE_PURPOSE and TREE_VALUE.\n\nFrom-SVN: r9520", "tree": {"sha": "1b3572d26c8d5d60f2c6aea587940c3024136363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b3572d26c8d5d60f2c6aea587940c3024136363"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332/comments", "author": null, "committer": null, "parents": [{"sha": "9c1303987c80cd2549ef6a9c76074c86a8f986e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c1303987c80cd2549ef6a9c76074c86a8f986e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c1303987c80cd2549ef6a9c76074c86a8f986e2"}], "stats": {"total": 187, "additions": 136, "deletions": 51}, "files": [{"sha": "fcbfd5373c712fedc708badd8db45a039a4c3718", "filename": "gcc/tree.c", "status": "modified", "additions": 136, "deletions": 51, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2a3c15b553af7e9a5c3ae07c54c88d3ce0ad3332", "patch": "@@ -1645,7 +1645,7 @@ really_constant_p (exp)\n }\n \f\n /* Return first list element whose TREE_VALUE is ELEM.\n-   Return 0 if ELEM is not it LIST.  */\n+   Return 0 if ELEM is not in LIST.  */\n \n tree\n value_member (elem, list)\n@@ -1661,7 +1661,7 @@ value_member (elem, list)\n }\n \n /* Return first list element whose TREE_PURPOSE is ELEM.\n-   Return 0 if ELEM is not it LIST.  */\n+   Return 0 if ELEM is not in LIST.  */\n \n tree\n purpose_member (elem, list)\n@@ -1677,7 +1677,7 @@ purpose_member (elem, list)\n }\n \n /* Return first list element whose BINFO_TYPE is ELEM.\n-   Return 0 if ELEM is not it LIST.  */\n+   Return 0 if ELEM is not in LIST.  */\n \n tree\n binfo_member (elem, list)\n@@ -1710,6 +1710,9 @@ chain_member (elem, chain)\n \n /* Return nonzero if ELEM is equal to TREE_VALUE (CHAIN) for any piece of\n    chain CHAIN. */\n+/* ??? This function was added for machine specific attributes but is no\n+   longer used.  It could be deleted if we could confirm all front ends\n+   don't use it.  */\n \n int\n chain_member_value (elem, chain)\n@@ -1727,12 +1730,14 @@ chain_member_value (elem, chain)\n \n /* Return nonzero if ELEM is equal to TREE_PURPOSE (CHAIN)\n    for any piece of chain CHAIN. */\n+/* ??? This function was added for machine specific attributes but is no\n+   longer used.  It could be deleted if we could confirm all front ends\n+   don't use it.  */\n \n int\n chain_member_purpose (elem, chain)\n      tree elem, chain;\n {\n-\n   while (chain)\n     {\n       if (elem == TREE_PURPOSE (chain))\n@@ -2896,7 +2901,7 @@ build_type_attribute_variant (ttype, attribute)\n \n       hashcode = TYPE_HASH (TREE_CODE (ntype))\n \t\t + TYPE_HASH (TREE_TYPE (ntype))\n-\t\t + type_hash_list (attribute);\n+\t\t + attribute_hash_list (attribute);\n \n       switch (TREE_CODE (ntype))\n         {\n@@ -2936,20 +2941,25 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n   tree decl_attr_list = decl != 0 ? DECL_MACHINE_ATTRIBUTES (decl) : 0;\n   tree type_attr_list = TYPE_ATTRIBUTES (type);\n \n-  /* For now, we don't support args.  */\n-  if (attr_args != 0)\n-    return 0;\n+  if (TREE_CODE (attr_name) != IDENTIFIER_NODE)\n+    abort ();\n \n #ifdef VALID_MACHINE_DECL_ATTRIBUTE\n   if (decl != 0\n-      && VALID_MACHINE_DECL_ATTRIBUTE (decl, decl_attr_list, attr_name))\n+      && VALID_MACHINE_DECL_ATTRIBUTE (decl, decl_attr_list, attr_name, attr_args))\n     {\n-      if (! attribute_in_list (attr_name, decl_attr_list))\n-\t{\n-\t  decl_attr_list = tree_cons (NULL_TREE, attr_name, decl_attr_list);\n+      tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n+\t\t\t\t    decl_attr_list);\n \n-\t  /* Declarations are unique, build_decl_attribute_variant modifies\n-\t     the existing decl in situ.  */\n+      if (attr != NULL_TREE)\n+\t{\n+\t  /* Override existing arguments.  Declarations are unique so we can\n+\t     modify this in place.  */\n+\t  TREE_VALUE (attr) = attr_args;\n+\t}\n+      else\n+\t{\n+\t  decl_attr_list = tree_cons (attr_name, attr_args, decl_attr_list);\n \t  decl = build_decl_attribute_variant (decl, decl_attr_list);\n \t}\n \n@@ -2958,11 +2968,22 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n #endif\n \n #ifdef VALID_MACHINE_TYPE_ATTRIBUTE\n-  if (VALID_MACHINE_TYPE_ATTRIBUTE (type, type_attr_list, attr_name))\n+  if (VALID_MACHINE_TYPE_ATTRIBUTE (type, type_attr_list, attr_name, attr_args))\n     {\n-      if (! attribute_in_list (attr_name, type_attr_list))\n+      tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n+\t\t\t\t    type_attr_list);\n+\n+      if (attr != NULL_TREE)\n \t{\n-\t  type_attr_list = tree_cons (NULL_TREE, attr_name, type_attr_list);\n+\t  /* Override existing arguments.\n+\t     ??? This currently works since attribute arguments are not\n+\t     included in `attribute_hash_list'.  Something more complicated\n+\t     may be needed in the future.  */\n+\t  TREE_VALUE (attr) = attr_args;\n+\t}\n+      else\n+\t{\n+\t  type_attr_list = tree_cons (attr_name, attr_args, type_attr_list);\n \t  type = build_type_attribute_variant (type, type_attr_list);\n \t}\n       if (decl != 0)\n@@ -2973,6 +2994,77 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \n   return valid;\n }\n+\n+/* Return non-zero if IDENT is a valid name for attribute ATTR,\n+   or zero if not.\n+\n+   We try both `text' and `__text__', ATTR may be either one.  */\n+/* ??? It might be a reasonable simplification to require ATTR to be only\n+   `text'.  One might then also require attribute lists to be stored in\n+   their canonicalized form.  */\n+\n+int\n+is_attribute_p (attr, ident)\n+     char *attr;\n+     tree ident;\n+{\n+  int ident_len, attr_len;\n+  char *p;\n+\n+  if (TREE_CODE (ident) != IDENTIFIER_NODE)\n+    return 0;\n+\n+  if (strcmp (attr, IDENTIFIER_POINTER (ident)) == 0)\n+    return 1;\n+\n+  p = IDENTIFIER_POINTER (ident);\n+  ident_len = strlen (p);\n+  attr_len = strlen (attr);\n+\n+  /* If ATTR is `__text__', IDENT must be `text'; and vice versa.  */\n+  if (attr[0] == '_')\n+    {\n+      if (attr[1] != '_'\n+\t  || attr[attr_len - 2] != '_'\n+\t  || attr[attr_len - 1] != '_')\n+\tabort ();\n+      if (ident_len == attr_len - 4\n+\t  && strncmp (attr + 2, p, attr_len - 4) == 0)\n+\treturn 1;\n+    }\n+  else\n+    {\n+      if (ident_len == attr_len + 4\n+\t  && p[0] == '_' && p[1] == '_'\n+\t  && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n+\t  && strncmp (attr, p + 2, attr_len) == 0)\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Given an attribute name and a list of attributes, return a pointer to the\n+   attribute's list element if the attribute is part of the list, or NULL_TREE\n+   if not found.  */\n+\n+tree\n+lookup_attribute (attr_name, list)\n+     char *attr_name;\n+     tree list;\n+{\n+  tree l;\n+\n+  for (l = list; l; l = TREE_CHAIN (l))\n+    {\n+      if (TREE_CODE (TREE_PURPOSE (l)) != IDENTIFIER_NODE)\n+\tabort ();\n+      if (is_attribute_p (attr_name, TREE_PURPOSE (l)))\n+\treturn l;\n+    }\n+\n+  return NULL_TREE;\n+}\n \f\n /* Return a type like TYPE except that its TYPE_READONLY is CONSTP\n    and its TYPE_VOLATILE is VOLATILEP.\n@@ -3196,39 +3288,20 @@ type_hash_canon (hashcode, type)\n   return type;\n }\n \n-/* Given an attribute and a list of attributes, return true if the attribute\n-   is part of the list.  */\n+/* Compute a hash code for a list of attributes (chain of TREE_LIST nodes\n+   with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),\n+   by adding the hash codes of the individual attributes.  */\n \n int\n-attribute_in_list (attribute, list)\n-     tree attribute, list;\n+attribute_hash_list (list)\n+     tree list;\n {\n-  register tree purpose, chain;\n-\n-  /* Perform a quick check.  */\n-  if (value_member (attribute, list))\n-     return 1;\n-\n-  /* If it's not a TREE_LIST, we should have had a match by now.  */\n-  if (TREE_CODE (attribute) != TREE_LIST)\n-     return 0;\n-\n-  purpose = TREE_PURPOSE (attribute);\n-  chain = TREE_CHAIN (attribute);\n-\n-  for (; list; list = TREE_CHAIN (list))\n-    {\n-      register tree value;\n-\n-      value = TREE_VALUE (list);\n-\n-      if (TREE_CODE (value) == TREE_LIST\n-          && TREE_PURPOSE (value) == purpose\n-          && simple_cst_equal (TREE_CHAIN (value), chain) == 1)\n-\t return 1;\n-    }\n-\n-  return 0;\n+  register int hashcode;\n+  register tree tail;\n+  for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n+    /* ??? Do we want to add in TREE_VALUE too? */\n+    hashcode += TYPE_HASH (TREE_PURPOSE (tail));\n+  return hashcode;\n }\n \n /* Given two lists of attributes, return true if list l2 is\n@@ -3242,8 +3315,13 @@ attribute_list_equal (l1, l2)\n \t  && attribute_list_contained (l2, l1);\n }\n \n-/* Given two lists of attributes, return true if list l2 is\n-   completely contained within l1.  */\n+/* Given two lists of attributes, return true if list L2 is\n+   completely contained within L1.  */\n+/* ??? This would be faster if attribute names were stored in a canonicalized\n+   form.  Otherwise, if L1 uses `foo' and L2 uses `__foo__', the long method\n+   must be used to show these elements are equivalent (which they are).  */\n+/* ??? It's not clear that attributes with arguments will always be handled\n+   correctly.  */\n \n int\n attribute_list_contained (l1, l2)\n@@ -3255,9 +3333,10 @@ attribute_list_contained (l1, l2)\n   if (l1 == l2)\n      return 1;\n \n-  /* Then check the obvious, maybe the lists are similar.  */\n+  /* Maybe the lists are similar.  */\n   for (t1 = l1, t2 = l2;\n        t1 && t2\n+        && TREE_PURPOSE (t1) == TREE_PURPOSE (t2)\n         && TREE_VALUE (t1) == TREE_VALUE (t2);\n        t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2));\n \n@@ -3266,8 +3345,14 @@ attribute_list_contained (l1, l2)\n      return 1;\n \n   for (; t2; t2 = TREE_CHAIN (t2))\n-     if (! attribute_in_list (TREE_VALUE (t2), l1))\n+    {\n+      tree attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n+\n+      if (attr == NULL_TREE)\n \treturn 0;\n+      if (simple_cst_equal (TREE_VALUE (t2), TREE_VALUE (attr)) != 1)\n+\treturn 0;\n+    }\n \n   return 1;\n }"}]}