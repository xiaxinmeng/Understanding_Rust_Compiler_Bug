{"sha": "497b699b93759c7f84527f49a9644c3ea692405d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3YjY5OWI5Mzc1OWM3Zjg0NTI3ZjQ5YTk2NDRjM2VhNjkyNDA1ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:21:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:21:39Z"}, "message": "Remove global call sets: sel-sched.c\n\nThe main change here is to replace a crosses_call boolean with\na bitmask of the ABIs used by the crossed calls.  For space reasons,\nI didn't also add a HARD_REG_SET that tracks the set of registers\nthat are actually clobbered, which means that this is the one part\nof the series that doesn't benefit from -fipa-ra.  The existing\nFIXME suggests that the current structures aren't the preferred\nway of representing this anyhow, and the pass already makes\nconservative assumptions about call-crossing registers.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* sel-sched-ir.h (_def::crosses_call): Replace with...\n\t(_def::crossed_call_abis): ..this new field.\n\t(def_list_add): Take a mask of ABIs instead of a crosses_call\n\tboolean.\n\t* sel-sched-ir.c (def_list_add): Likewise.  Update initialization\n\tof _def accordingly.\n\t* sel-sched.c: Include function-abi.h.\n\t(hard_regs_data::regs_for_call_clobbered): Delete.\n\t(reg_rename::crosses_call): Replace with...\n\t(reg_rename::crossed_call_abis): ...this new field.\n\t(fur_static_params::crosses_call): Replace with...\n\t(fur_static_params::crossed_call_abis): ...this new field.\n\t(init_regs_for_mode): Don't initialize sel_hrd.regs_for_call_clobbered.\n\t(init_hard_regs_data): Use crtl->abi to test which registers the\n\tcurrent function would need to save before it uses them.\n\t(mark_unavailable_hard_regs): Update handling of call-clobbered\n\tregisters, using call_clobbers_in_region to find out which registers\n\tmight be call-clobbered (but without taking -fipa-ra into account\n\tfor now).  Remove separate handling of partially call-clobbered\n\tregisters.\n\t(verify_target_availability): Use crossed_call_abis instead of\n\tcrosses_call.\n\t(get_spec_check_type_for_insn, find_used_regs): Likewise.\n\t(fur_orig_expr_found, fur_on_enter, fur_orig_expr_not_found): Likewise.\n\nFrom-SVN: r276336", "tree": {"sha": "b2a1867421a87e4da2ffeeecd6244839917cf052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2a1867421a87e4da2ffeeecd6244839917cf052"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/497b699b93759c7f84527f49a9644c3ea692405d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497b699b93759c7f84527f49a9644c3ea692405d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497b699b93759c7f84527f49a9644c3ea692405d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497b699b93759c7f84527f49a9644c3ea692405d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2e2c6df346ab70eda7378a750cb96a1792de5b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2c6df346ab70eda7378a750cb96a1792de5b3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2c6df346ab70eda7378a750cb96a1792de5b3b"}], "stats": {"total": 122, "additions": 72, "deletions": 50}, "files": [{"sha": "6d2d20f1df97257c4cda007962767adc6cbe29fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=497b699b93759c7f84527f49a9644c3ea692405d", "patch": "@@ -1,3 +1,30 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* sel-sched-ir.h (_def::crosses_call): Replace with...\n+\t(_def::crossed_call_abis): ..this new field.\n+\t(def_list_add): Take a mask of ABIs instead of a crosses_call\n+\tboolean.\n+\t* sel-sched-ir.c (def_list_add): Likewise.  Update initialization\n+\tof _def accordingly.\n+\t* sel-sched.c: Include function-abi.h.\n+\t(hard_regs_data::regs_for_call_clobbered): Delete.\n+\t(reg_rename::crosses_call): Replace with...\n+\t(reg_rename::crossed_call_abis): ...this new field.\n+\t(fur_static_params::crosses_call): Replace with...\n+\t(fur_static_params::crossed_call_abis): ...this new field.\n+\t(init_regs_for_mode): Don't initialize sel_hrd.regs_for_call_clobbered.\n+\t(init_hard_regs_data): Use crtl->abi to test which registers the\n+\tcurrent function would need to save before it uses them.\n+\t(mark_unavailable_hard_regs): Update handling of call-clobbered\n+\tregisters, using call_clobbers_in_region to find out which registers\n+\tmight be call-clobbered (but without taking -fipa-ra into account\n+\tfor now).  Remove separate handling of partially call-clobbered\n+\tregisters.\n+\t(verify_target_availability): Use crossed_call_abis instead of\n+\tcrosses_call.\n+\t(get_spec_check_type_for_insn, find_used_regs): Likewise.\n+\t(fur_orig_expr_found, fur_on_enter, fur_orig_expr_not_found): Likewise.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* sched-deps.c (deps_analyze_insn): Use the ABI of the target"}, {"sha": "8a1d41473b9caf287f4a9eda03171e6c7b7bdb1f", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=497b699b93759c7f84527f49a9644c3ea692405d", "patch": "@@ -311,17 +311,18 @@ flist_clear (flist_t *lp)\n     flist_remove (lp);\n }\n \n-/* Add ORIGINAL_INSN the def list DL honoring CROSSES_CALL.  */\n+/* Add ORIGINAL_INSN the def list DL honoring CROSSED_CALL_ABIS.  */\n void\n-def_list_add (def_list_t *dl, insn_t original_insn, bool crosses_call)\n+def_list_add (def_list_t *dl, insn_t original_insn,\n+\t      unsigned int crossed_call_abis)\n {\n   def_t d;\n \n   _list_add (dl);\n   d = DEF_LIST_DEF (*dl);\n \n   d->orig_insn = original_insn;\n-  d->crosses_call = crosses_call;\n+  d->crossed_call_abis = crossed_call_abis;\n }\n \f\n "}, {"sha": "ddc76a73ede0dd719c2e013c3b0ad0155133aa8c", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=497b699b93759c7f84527f49a9644c3ea692405d", "patch": "@@ -188,12 +188,12 @@ struct _def\n {\n   insn_t orig_insn;\n \n-  /* FIXME: Get rid of CROSSES_CALL in each def, since if we're moving up\n+  /* FIXME: Get rid of CROSSED_CALL_ABIS in each def, since if we're moving up\n      rhs from two different places, but only one of the code motion paths\n      crosses a call, we can't use any of the call_used_regs, no matter which\n-     path or whether all paths crosses a call.  Thus we should move CROSSES_CALL\n-     to static params.  */\n-  bool crosses_call;\n+     path or whether all paths crosses a call.  Thus we should move\n+     CROSSED_CALL_ABIS to static params.  */\n+  unsigned int crossed_call_abis;\n };\n typedef struct _def *def_t;\n \n@@ -1510,7 +1510,7 @@ extern void flist_tail_init (flist_tail_t);\n \n extern fence_t flist_lookup (flist_t, insn_t);\n extern void flist_clear (flist_t *);\n-extern void def_list_add (def_list_t *, insn_t, bool);\n+extern void def_list_add (def_list_t *, insn_t, unsigned int);\n \n /* Target context functions.  */\n extern tc_t create_target_context (bool);"}, {"sha": "652784e79ed00fe4de7e872ec150cf18f24cd1eb", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497b699b93759c7f84527f49a9644c3ea692405d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=497b699b93759c7f84527f49a9644c3ea692405d", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sel-sched-dump.h\"\n #include \"sel-sched.h\"\n #include \"dbgcnt.h\"\n+#include \"function-abi.h\"\n \n /* Implementation of selective scheduling approach.\n    The below implementation follows the original approach with the following\n@@ -302,10 +303,6 @@ struct hard_regs_data\n      that the whole set is not computed yet.  */\n   HARD_REG_SET regs_for_rename[FIRST_PSEUDO_REGISTER];\n \n-  /* For every mode, this stores registers not available due to\n-     call clobbering.  */\n-  HARD_REG_SET regs_for_call_clobbered[NUM_MACHINE_MODES];\n-\n   /* All registers that are used or call used.  */\n   HARD_REG_SET regs_ever_used;\n \n@@ -325,8 +322,8 @@ struct reg_rename\n   /* These are *available* for renaming.  */\n   HARD_REG_SET available_for_renaming;\n \n-  /* Whether this code motion path crosses a call.  */\n-  bool crosses_call;\n+  /* The set of ABIs used by calls that the code motion path crosses.  */\n+  unsigned int crossed_call_abis : NUM_ABI_IDS;\n };\n \n /* A global structure that contains the needed information about harg\n@@ -390,8 +387,8 @@ struct fur_static_params\n   /* Pointer to the list of original insns definitions.  */\n   def_list_t *original_insns;\n \n-  /* True if a code motion path contains a CALL insn.  */\n-  bool crosses_call;\n+  /* The set of ABIs used by calls that the code motion path crosses.  */\n+  unsigned int crossed_call_abis : NUM_ABI_IDS;\n };\n \n typedef struct fur_static_params *fur_static_params_p;\n@@ -1067,7 +1064,6 @@ init_regs_for_mode (machine_mode mode)\n   int cur_reg;\n \n   CLEAR_HARD_REG_SET (sel_hrd.regs_for_mode[mode]);\n-  CLEAR_HARD_REG_SET (sel_hrd.regs_for_call_clobbered[mode]);\n \n   for (cur_reg = 0; cur_reg < FIRST_PSEUDO_REGISTER; cur_reg++)\n     {\n@@ -1102,10 +1098,6 @@ init_regs_for_mode (machine_mode mode)\n       if (i >= 0)\n         continue;\n \n-      if (targetm.hard_regno_call_part_clobbered (0, cur_reg, mode))\n-        SET_HARD_REG_BIT (sel_hrd.regs_for_call_clobbered[mode],\n-                          cur_reg);\n-\n       /* If the CUR_REG passed all the checks above,\n          then it's ok.  */\n       SET_HARD_REG_BIT (sel_hrd.regs_for_mode[mode], cur_reg);\n@@ -1123,7 +1115,8 @@ init_hard_regs_data (void)\n \n   CLEAR_HARD_REG_SET (sel_hrd.regs_ever_used);\n   for (cur_reg = 0; cur_reg < FIRST_PSEUDO_REGISTER; cur_reg++)\n-    if (df_regs_ever_live_p (cur_reg) || call_used_or_fixed_reg_p (cur_reg))\n+    if (df_regs_ever_live_p (cur_reg)\n+\t|| crtl->abi->clobbers_full_reg_p (cur_reg))\n       SET_HARD_REG_BIT (sel_hrd.regs_ever_used, cur_reg);\n \n   /* Initialize registers that are valid based on mode when this is\n@@ -1193,7 +1186,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n       SET_HARD_REG_SET (reg_rename_p->unavailable_hard_regs);\n \n       /* Give a chance for original register, if it isn't in used_regs.  */\n-      if (!def->crosses_call)\n+      if (!def->crossed_call_abis)\n         CLEAR_HARD_REG_BIT (reg_rename_p->unavailable_hard_regs, regno);\n \n       return;\n@@ -1224,33 +1217,32 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n     reg_rename_p->unavailable_hard_regs |= sel_hrd.stack_regs;\n #endif\n \n-  /* If there's a call on this path, make regs from call_used_or_fixed_regs\n-     unavailable.  */\n-  if (def->crosses_call)\n-    reg_rename_p->unavailable_hard_regs |= call_used_or_fixed_regs;\n+  mode = GET_MODE (orig_dest);\n+\n+  /* If there's a call on this path, make regs from full_reg_clobbers\n+     unavailable.\n \n-  /* Stop here before reload: we need FRAME_REGS, STACK_REGS, and crosses_call,\n-     but not register classes.  */\n+     ??? It would be better to track the set of clobbered registers\n+     directly, but that would be quite expensive in a def_t.  */\n+  if (def->crossed_call_abis)\n+    reg_rename_p->unavailable_hard_regs\n+      |= call_clobbers_in_region (def->crossed_call_abis,\n+\t\t\t\t  reg_class_contents[ALL_REGS], mode);\n+\n+  /* Stop here before reload: we need FRAME_REGS, STACK_REGS, and\n+     crossed_call_abis, but not register classes.  */\n   if (!reload_completed)\n     return;\n \n   /* Leave regs as 'available' only from the current\n      register class.  */\n   reg_rename_p->available_for_renaming = reg_class_contents[cl];\n \n-  mode = GET_MODE (orig_dest);\n-\n   /* Leave only registers available for this mode.  */\n   if (!sel_hrd.regs_for_mode_ok[mode])\n     init_regs_for_mode (mode);\n   reg_rename_p->available_for_renaming &= sel_hrd.regs_for_mode[mode];\n \n-  /* Exclude registers that are partially call clobbered.  */\n-  if (def->crosses_call\n-      && !targetm.hard_regno_call_part_clobbered (0, regno, mode))\n-    reg_rename_p->available_for_renaming\n-      &= ~sel_hrd.regs_for_call_clobbered[mode];\n-\n   /* Leave only those that are ok to rename.  */\n   EXECUTE_IF_SET_IN_HARD_REG_SET (reg_rename_p->available_for_renaming,\n                                   0, cur_reg, hrsi)\n@@ -1481,7 +1473,7 @@ choose_best_pseudo_reg (regset used_regs,\n \t      /* Don't let register cross a call if it doesn't already\n \t\t cross one.  This condition is written in accordance with\n \t\t that in sched-deps.c sched_analyze_reg().  */\n-\t      if (!reg_rename_p->crosses_call\n+\t      if (!reg_rename_p->crossed_call_abis\n \t\t  || REG_N_CALLS_CROSSED (orig_regno) > 0)\n \t\treturn gen_rtx_REG (mode, orig_regno);\n \t    }\n@@ -1508,7 +1500,8 @@ choose_best_pseudo_reg (regset used_regs,\n \n     max_regno = max_reg_num ();\n     maybe_extend_reg_info_p ();\n-    REG_N_CALLS_CROSSED (REGNO (new_reg)) = reg_rename_p->crosses_call ? 1 : 0;\n+    REG_N_CALLS_CROSSED (REGNO (new_reg))\n+      = reg_rename_p->crossed_call_abis ? 1 : 0;\n \n     return new_reg;\n   }\n@@ -1560,7 +1553,8 @@ verify_target_availability (expr_t expr, regset used_regs,\n        as well.  */\n     gcc_assert (scheduled_something_on_previous_fence || !live_available\n \t\t|| !hard_available\n-\t\t|| (!reload_completed && reg_rename_p->crosses_call\n+\t\t|| (!reload_completed\n+\t\t    && reg_rename_p->crossed_call_abis\n \t\t    && REG_N_CALLS_CROSSED (regno) == 0));\n }\n \n@@ -3248,7 +3242,7 @@ get_spec_check_type_for_insn (insn_t insn, expr_t expr)\n    All the original operations found during the traversal are saved in the\n    ORIGINAL_INSNS list.\n \n-   REG_RENAME_P->CROSSES_CALL is true, if there is a call insn on the path\n+   REG_RENAME_P->CROSSED_CALL_ABIS is true, if there is a call insn on the path\n    from INSN to original insn. In this case CALL_USED_REG_SET will be added\n    to unavailable hard regs at the point original operation is found.  */\n \n@@ -3269,7 +3263,7 @@ find_used_regs (insn_t insn, av_set_t orig_ops, regset used_regs,\n   bitmap_clear (code_motion_visited_blocks);\n \n   /* Init parameters for code_motion_path_driver.  */\n-  sparams.crosses_call = false;\n+  sparams.crossed_call_abis = 0;\n   sparams.original_insns = original_insns;\n   sparams.used_regs = used_regs;\n \n@@ -3278,7 +3272,7 @@ find_used_regs (insn_t insn, av_set_t orig_ops, regset used_regs,\n \n   res = code_motion_path_driver (insn, orig_ops, NULL, &lparams, &sparams);\n \n-  reg_rename_p->crosses_call |= sparams.crosses_call;\n+  reg_rename_p->crossed_call_abis |= sparams.crossed_call_abis;\n \n   gcc_assert (res == 1);\n   gcc_assert (original_insns && *original_insns);\n@@ -6006,7 +6000,7 @@ move_op_orig_expr_found (insn_t insn, expr_t expr,\n \n /* The function is called when original expr is found.\n    INSN - current insn traversed, EXPR - the corresponding expr found,\n-   crosses_call and original_insns in STATIC_PARAMS are updated.  */\n+   crossed_call_abis and original_insns in STATIC_PARAMS are updated.  */\n static void\n fur_orig_expr_found (insn_t insn, expr_t expr ATTRIBUTE_UNUSED,\n                      cmpd_local_params_p lparams ATTRIBUTE_UNUSED,\n@@ -6016,9 +6010,9 @@ fur_orig_expr_found (insn_t insn, expr_t expr ATTRIBUTE_UNUSED,\n   regset tmp;\n \n   if (CALL_P (insn))\n-    params->crosses_call = true;\n+    params->crossed_call_abis |= 1 << insn_callee_abi (insn).id ();\n \n-  def_list_add (params->original_insns, insn, params->crosses_call);\n+  def_list_add (params->original_insns, insn, params->crossed_call_abis);\n \n   /* Mark the registers that do not meet the following condition:\n     (2) not among the live registers of the point\n@@ -6176,10 +6170,10 @@ fur_on_enter (insn_t insn ATTRIBUTE_UNUSED, cmpd_local_params_p local_params,\n \t least one insn in ORIGINAL_INSNS.  */\n       gcc_assert (*sparams->original_insns);\n \n-      /* Adjust CROSSES_CALL, since we may have come to this block along\n+      /* Adjust CROSSED_CALL_ABIS, since we may have come to this block along\n \t different path.  */\n-      DEF_LIST_DEF (*sparams->original_insns)->crosses_call\n-\t  |= sparams->crosses_call;\n+      DEF_LIST_DEF (*sparams->original_insns)->crossed_call_abis\n+\t|= sparams->crossed_call_abis;\n     }\n   else\n     local_params->old_original_insns = *sparams->original_insns;\n@@ -6233,7 +6227,7 @@ fur_orig_expr_not_found (insn_t insn, av_set_t orig_ops, void *static_params)\n   fur_static_params_p sparams = (fur_static_params_p) static_params;\n \n   if (CALL_P (insn))\n-    sparams->crosses_call = true;\n+    sparams->crossed_call_abis |= 1 << insn_callee_abi (insn).id ();\n   else if (DEBUG_INSN_P (insn))\n     return true;\n "}]}