{"sha": "1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFhNGNiM2EzY2QxMjgwYzA0MzYwZDU1MDRhM2Q5ZTE1ZTUyYWEyMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:48:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:48:10Z"}, "message": "(layout_union): Handle QUAL_UNION_TYPE.\n\n(layout_type): Call layout_union for QUAL_UNION_TYPE and treat it\nlike UNION_TYPE elsewhere.\n\nFrom-SVN: r4119", "tree": {"sha": "e9738b7b651cb06b9bf94ef7ee275cdc60db6005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9738b7b651cb06b9bf94ef7ee275cdc60db6005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22/comments", "author": null, "committer": null, "parents": [{"sha": "c1b98a9573da874bdfc9a0d4fa2a1b1445488e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1b98a9573da874bdfc9a0d4fa2a1b1445488e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1b98a9573da874bdfc9a0d4fa2a1b1445488e01"}], "stats": {"total": 41, "additions": 30, "deletions": 11}, "files": [{"sha": "c0efe3dab89920781c702561bb8e327ad11c024f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=1aa4cb3a3cd1280c04360d5504a3d9e15e52aa22", "patch": "@@ -518,7 +518,7 @@ layout_record (rec)\n   return pending_statics;\n }\n \f\n-/* Lay out a UNION_TYPE type.\n+/* Lay out a UNION_TYPE or QUAL_UNION_TYPE type.\n    Lay out all the fields, set their positions to zero,\n    and compute the size and alignment of the union (maximum of any field).\n    Note that if you set the TYPE_ALIGN before calling this\n@@ -541,6 +541,12 @@ layout_union (rec)\n   register int const_size = 0;\n   register tree var_size = 0;\n \n+  /* If this is a QUAL_UNION_TYPE, we want to process the fields in\n+     the reverse order in building the COND_EXPR that denotes its\n+     size.  We reverse them again later.  */\n+  if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n+    TYPE_FIELDS (rec) = nreverse (TYPE_FIELDS (rec));\n+\n   for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))\n     {\n       /* Enums which are local to this class need not be laid out.  */\n@@ -561,17 +567,28 @@ layout_union (rec)\n \tunion_align = MAX (union_align, TYPE_ALIGN (TREE_TYPE (field)));\n #endif\n \n-      /* Set union_size to max (decl_size, union_size).\n-\t There are more and less general ways to do this.\n-\t Use only CONST_SIZE unless forced to use VAR_SIZE.  */\n+      if (TREE_CODE (rec) == UNION_TYPE)\n+\t{\n+\t  /* Set union_size to max (decl_size, union_size).\n+\t     There are more and less general ways to do this.\n+\t     Use only CONST_SIZE unless forced to use VAR_SIZE.  */\n \n-      if (TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n-\tconst_size = MAX (const_size, TREE_INT_CST_LOW (DECL_SIZE (field)));\n-      else if (var_size == 0)\n-\tvar_size = DECL_SIZE (field);\n-      else\n-\tvar_size = size_binop (MAX_EXPR, var_size, DECL_SIZE (field));\n-    }\n+\t  if (TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+\t    const_size\n+\t      = MAX (const_size, TREE_INT_CST_LOW (DECL_SIZE (field)));\n+\t  else if (var_size == 0)\n+\t    var_size = DECL_SIZE (field);\n+\t  else\n+\t    var_size = size_binop (MAX_EXPR, var_size, DECL_SIZE (field));\n+\t}\n+      else if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n+\tvar_size = fold (build (COND_EXPR, sizetype, DECL_QUALIFIER (field),\n+\t\t\t\tDECL_SIZE (field),\n+\t\t\t\tvar_size ? var_size : integer_zero_node));\n+      }\n+\n+  if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n+    TYPE_FIELDS (rec) = nreverse (TYPE_FIELDS (rec));\n \n   /* Determine the ultimate size of the union (in bytes).  */\n   if (NULL == var_size)\n@@ -827,6 +844,7 @@ layout_type (type)\n       break;\n \n     case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n       layout_union (type);\n       TYPE_MODE (type) = BLKmode;\n       if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n@@ -893,6 +911,7 @@ layout_type (type)\n   if (TYPE_MODE (type) != BLKmode && TYPE_MODE (type) != VOIDmode\n       && (STRICT_ALIGNMENT\n \t  || (TREE_CODE (type) != RECORD_TYPE && TREE_CODE (type) != UNION_TYPE\n+\t      && TREE_CODE (type) != QUAL_UNION_TYPE\n \t      && TREE_CODE (type) != ARRAY_TYPE)))\n     TYPE_ALIGN (type) = GET_MODE_ALIGNMENT (TYPE_MODE (type));\n "}]}