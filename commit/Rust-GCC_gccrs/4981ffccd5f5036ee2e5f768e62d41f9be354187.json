{"sha": "4981ffccd5f5036ee2e5f768e62d41f9be354187", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk4MWZmY2NkNWY1MDM2ZWUyZTVmNzY4ZTYyZDQxZjliZTM1NDE4Nw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-12-13T10:34:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:34:35Z"}, "message": "s-stausa.ads (Stack_Analyzer): Remove First_Is_Topmost, redundant with Stack_Grows_Down in System.Parameters.\n\n2007-12-06  Olivier Hainque  <hainque@adacore.com>\n\n\t* s-stausa.ads (Stack_Analyzer): Remove First_Is_Topmost, redundant\n\twith Stack_Grows_Down in System.Parameters. Rename Array_Address into\n\tStack_Overlay_Address and document that we are using an internal\n\tabstraction.\n\t(Byte_Size, Unsigned_32_Size): Remove, now useless.\n\t(Pattern_Type, Bytes_Per_Pattern): New subtype and constant, to be used\n\tconsistently throughout the various implementation pieces.\n\n\t* s-stausa.adb (Stack_Slots): New type, abstraction for the stack\n\toverlay we are using to fill the stack area with patterns.\n\t(Top_Slot_Index_In, Bottom_Slot_Index_In): Operations on Stack_Slots.\n\t(Push_Index_Step_For, Pop_Index_Step_For): Likewise.\n\t(Fill_Stack, Compute_Result): Use the Stack_Slots abstraction.\n\nFrom-SVN: r130863", "tree": {"sha": "763bd2f1a7122eb762a5be3e8bbdb5703bedcfc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/763bd2f1a7122eb762a5be3e8bbdb5703bedcfc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4981ffccd5f5036ee2e5f768e62d41f9be354187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4981ffccd5f5036ee2e5f768e62d41f9be354187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4981ffccd5f5036ee2e5f768e62d41f9be354187", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4981ffccd5f5036ee2e5f768e62d41f9be354187/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "90de1450e5cbdc1bfc16ed8e08bc5db33f2b8bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90de1450e5cbdc1bfc16ed8e08bc5db33f2b8bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90de1450e5cbdc1bfc16ed8e08bc5db33f2b8bcc"}], "stats": {"total": 300, "additions": 193, "deletions": 107}, "files": [{"sha": "42fe418d7c585cc619521a8f45bc96850b21cfef", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 186, "deletions": 96, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4981ffccd5f5036ee2e5f768e62d41f9be354187/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4981ffccd5f5036ee2e5f768e62d41f9be354187/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=4981ffccd5f5036ee2e5f768e62d41f9be354187", "patch": "@@ -41,12 +41,141 @@ package body System.Stack_Usage is\n    use System.IO;\n    use Interfaces;\n \n-   Index_Str               : constant String  := \"Index\";\n-   Task_Name_Str           : constant String  := \"Task Name\";\n-   Stack_Size_Str          : constant String  := \"Stack Size\";\n-   Actual_Size_Str         : constant String  := \"Stack usage [min - max]\";\n-   Pattern_Array_Elem_Size : constant Natural :=\n-                               (Unsigned_32_Size / Byte_Size);\n+   -----------------\n+   -- Stack_Slots --\n+   -----------------\n+\n+   --  Stackl_Slots is an internal data type to represent a sequence of real\n+   --  stack slots initialized with a provided pattern, with operations to\n+   --  abstract away the target call stack growth direction.\n+\n+   type Stack_Slots is array (Integer range <>) of Pattern_Type;\n+   for Stack_Slots'Component_Size use Pattern_Type'Object_Size;\n+\n+   --  We will carefully handle the initializations ourselves and might want\n+   --  to remap an initialized overlay later on with an address clause.\n+\n+   pragma Suppress_Initialization (Stack_Slots);\n+\n+   --  The abstract Stack_Slots operations all operate over the simple array\n+   --  memory model:\n+\n+   --  memory addresses increasing ---->\n+\n+   --  Slots('First)                                           Slots('Last)\n+   --    |                                                             |\n+   --    V                                                             V\n+   --  +------------------------------------------------------------------+\n+   --  |####|                                                        |####|\n+   --  +------------------------------------------------------------------+\n+\n+   --  What we call Top or Bottom always denotes call chain leaves or entry\n+   --  points respectively, and their relative positions in the stack array\n+   --  depends on the target stack growth direction:\n+\n+   --                           Stack_Grows_Down\n+\n+   --                <----- calls push frames towards decreasing addresses\n+\n+   --   Top(most) Slot                                   Bottom(most) Slot\n+   --    |                                                            |\n+   --    V                                                            V\n+   --  +------------------------------------------------------------------+\n+   --  |####|                            | leaf frame | ... | entry frame |\n+   --  +------------------------------------------------------------------+\n+\n+   --                           Stack_Grows_Up\n+\n+   --   calls push frames towards increasing addresses ----->\n+\n+   --   Bottom(most) Slot                                    Top(most) Slot\n+   --    |                                                             |\n+   --    V                                                             V\n+   --  +------------------------------------------------------------------+\n+   --  | entry frame | ... | leaf frame |                            |####|\n+   --  +------------------------------------------------------------------+\n+\n+   function Top_Slot_Index_In (Stack : Stack_Slots) return Integer;\n+   --  Index of the stack Top slot in the Slots array, denoting the latest\n+   --  possible slot available to call chain leaves.\n+\n+   function Bottom_Slot_Index_In (Stack : Stack_Slots) return Integer;\n+   --  Index of the stack Bottom slot in the Slots array, denoting the first\n+   --  possible slot available to call chain entry points.\n+\n+   function Push_Index_Step_For (Stack : Stack_Slots) return Integer;\n+   --  By how much do we need to update a Slots index to Push a single slot on\n+   --  the stack.\n+\n+   function Pop_Index_Step_For (Stack : Stack_Slots) return Integer;\n+   --  By how much do we need to update a Slots index to Pop a single slot off\n+   --  the stack.\n+\n+   pragma Inline_Always (Top_Slot_Index_In);\n+   pragma Inline_Always (Bottom_Slot_Index_In);\n+   pragma Inline_Always (Push_Index_Step_For);\n+   pragma Inline_Always (Pop_Index_Step_For);\n+\n+   -----------------------\n+   -- Top_Slot_Index_In --\n+   -----------------------\n+\n+   function Top_Slot_Index_In (Stack : Stack_Slots) return Integer is\n+   begin\n+      if System.Parameters.Stack_Grows_Down then\n+         return Stack'First;\n+      else\n+         return Stack'Last;\n+      end if;\n+   end Top_Slot_Index_In;\n+\n+   ----------------------------\n+   --  Bottom_Slot_Index_In  --\n+   ----------------------------\n+\n+   function Bottom_Slot_Index_In (Stack : Stack_Slots) return Integer is\n+   begin\n+      if System.Parameters.Stack_Grows_Down then\n+         return Stack'Last;\n+      else\n+         return Stack'First;\n+      end if;\n+   end Bottom_Slot_Index_In;\n+\n+   -------------------------\n+   -- Push_Index_Step_For --\n+   -------------------------\n+\n+   function Push_Index_Step_For (Stack : Stack_Slots) return Integer is\n+      pragma Unreferenced (Stack);\n+   begin\n+      if System.Parameters.Stack_Grows_Down then\n+         return -1;\n+      else\n+         return +1;\n+      end if;\n+   end Push_Index_Step_For;\n+\n+   ------------------------\n+   -- Pop_Index_Step_For --\n+   ------------------------\n+\n+   function Pop_Index_Step_For (Stack : Stack_Slots) return Integer is\n+   begin\n+      return -Push_Index_Step_For (Stack);\n+   end Pop_Index_Step_For;\n+\n+   -------------------\n+   -- Unit Services --\n+   -------------------\n+\n+   --  Now the implementation of the services offered by this unit, on top of\n+   --  the Stack_Slots abstraction above.\n+\n+   Index_Str       : constant String  := \"Index\";\n+   Task_Name_Str   : constant String  := \"Task Name\";\n+   Stack_Size_Str  : constant String  := \"Stack Size\";\n+   Actual_Size_Str : constant String  := \"Stack usage [min - max]\";\n \n    function Get_Usage_Range (Result : Task_Result) return String;\n    --  Return string representing the range of possible result of stack usage\n@@ -62,30 +191,6 @@ package body System.Stack_Usage is\n    --  proper layout. They hold the maximum length of the string representing\n    --  the Stack_Size and Actual_Use values.\n \n-   function Closer_To_Bottom\n-     (A1 : Stack_Address;\n-      A2 : Stack_Address) return Boolean;\n-   pragma Inline (Closer_To_Bottom);\n-   --  Return True if, according to the direction of the stack growth, A1 is\n-   --  closer to the bottom than A2. Inlined to reduce the size of the stack\n-   --  used by the instrumentation code.\n-\n-   ----------------------\n-   -- Closer_To_Bottom --\n-   ----------------------\n-\n-   function Closer_To_Bottom\n-     (A1 : Stack_Address;\n-      A2 : Stack_Address) return Boolean\n-   is\n-   begin\n-      if System.Parameters.Stack_Grows_Down then\n-         return A1 > A2;\n-      else\n-         return A2 > A1;\n-      end if;\n-   end Closer_To_Bottom;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -154,39 +259,17 @@ package body System.Stack_Usage is\n       --  big, the more an \"instrumentation threshold at writing\" error is\n       --  likely to happen.\n \n-      type Unsigned_32_Arr is\n-        array (1 .. Analyzer.Size / Pattern_Array_Elem_Size) of Unsigned_32;\n-      for Unsigned_32_Arr'Component_Size use 32;\n-\n-      package Arr_Addr is\n-        new System.Address_To_Access_Conversions (Unsigned_32_Arr);\n-\n-      Arr : aliased Unsigned_32_Arr;\n+      Stack : aliased Stack_Slots (1 .. Analyzer.Size / Bytes_Per_Pattern);\n \n    begin\n-      --  Fill the stack with the pattern\n-\n-      for J in Unsigned_32_Arr'Range loop\n-         Arr (J) := Analyzer.Pattern;\n-      end loop;\n+      Stack := (others => Analyzer.Pattern);\n \n-      --  Initialize the analyzer value\n+      Analyzer.Stack_Overlay_Address := Stack'Address;\n \n-      Analyzer.Array_Address := Arr_Addr.To_Address (Arr'Access);\n-      Analyzer.Bottom_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n+      Analyzer.Bottom_Pattern_Mark :=\n+        To_Stack_Address (Stack (Bottom_Slot_Index_In (Stack))'Address);\n       Analyzer.Top_Pattern_Mark :=\n-        To_Stack_Address (Arr (Unsigned_32_Arr'Last)'Address);\n-\n-      if\n-        Closer_To_Bottom\n-          (Analyzer.Top_Pattern_Mark, Analyzer.Bottom_Pattern_Mark)\n-      then\n-         Analyzer.Bottom_Pattern_Mark := Analyzer.Top_Pattern_Mark;\n-         Analyzer.Top_Pattern_Mark := To_Stack_Address (Arr (1)'Address);\n-         Analyzer.First_Is_Topmost := True;\n-      else\n-         Analyzer.First_Is_Topmost := False;\n-      end if;\n+        To_Stack_Address (Stack (Top_Slot_Index_In (Stack))'Address);\n \n       --  If Arr has been packed, the following assertion must be true (we add\n       --  the size of the element whose address is:\n@@ -263,33 +346,35 @@ package body System.Stack_Usage is\n       --  is, the more an \"instrumentation threshold at reading\" error is\n       --  likely to happen.\n \n-      type Unsigned_32_Arr is\n-        array (1 .. Analyzer.Size / Pattern_Array_Elem_Size) of Unsigned_32;\n-      for Unsigned_32_Arr'Component_Size use 32;\n-\n-      package Arr_Addr is\n-        new System.Address_To_Access_Conversions (Unsigned_32_Arr);\n-\n-      Arr_Access : Arr_Addr.Object_Pointer;\n+      Stack : Stack_Slots (1 .. Analyzer.Size / Bytes_Per_Pattern);\n+      for Stack'Address use Analyzer.Stack_Overlay_Address;\n \n    begin\n-      Arr_Access := Arr_Addr.To_Pointer (Analyzer.Array_Address);\n       Analyzer.Topmost_Touched_Mark := Analyzer.Bottom_Pattern_Mark;\n \n-      --  Look backward from the end of the stack to the beginning. The first\n-      --  index not equals to the patterns marks the beginning of the used\n-      --  stack.\n-\n-      for J in Unsigned_32_Arr'Range loop\n-         if Arr_Access (J) /= Analyzer.Pattern then\n-            Analyzer.Topmost_Touched_Mark :=\n-              To_Stack_Address (Arr_Access (J)'Address);\n-\n-            if Analyzer.First_Is_Topmost then\n+      --  Look backward from the topmost possible end of the marked stack to\n+      --  the bottom of it. The first index not equals to the patterns marks\n+      --  the beginning of the used stack.\n+\n+      declare\n+         Top_Index    : constant Integer := Top_Slot_Index_In (Stack);\n+         Bottom_Index : constant Integer := Bottom_Slot_Index_In (Stack);\n+         Step         : constant Integer := Pop_Index_Step_For (Stack);\n+         J            : Integer;\n+\n+      begin\n+         J := Top_Index;\n+         loop\n+            if Stack (J) /= Analyzer.Pattern then\n+               Analyzer.Topmost_Touched_Mark\n+                 := To_Stack_Address (Stack (J)'Address);\n                exit;\n             end if;\n-         end if;\n-      end loop;\n+\n+            exit when J = Bottom_Index;\n+            J := J + Step;\n+         end loop;\n+      end;\n    end Compute_Result;\n \n    ---------------------\n@@ -303,7 +388,7 @@ package body System.Stack_Usage is\n                        Natural'Image (Result.Measure + Result.Overflow_Guard);\n    begin\n       return \"[\" & Min_Used_Str (2 .. Min_Used_Str'Last) & \" -\"\n-        & Max_Used_Str & \"]\";\n+             & Max_Used_Str & \"]\";\n    end Get_Usage_Range;\n \n    ---------------------\n@@ -323,12 +408,15 @@ package body System.Stack_Usage is\n       Result_Id_Blanks  : constant\n         String (1 .. Index_Str'Length - Result_Id_Str'Length)    :=\n           (others => ' ');\n+\n       Stack_Size_Blanks : constant\n         String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n           (others => ' ');\n+\n       Actual_Use_Blanks : constant\n         String (1 .. Max_Actual_Use_Len - Actual_Use_Str'Length) :=\n           (others => ' ');\n+\n    begin\n       Set_Output (Standard_Error);\n       Put (Result_Id_Blanks & Natural'Image (Result_Id));\n@@ -350,9 +438,9 @@ package body System.Stack_Usage is\n       Max_Actual_Use_Result_Id               : Natural := Result_Array'First;\n       Max_Stack_Size_Len, Max_Actual_Use_Len : Natural := 0;\n \n-      Task_Name_Blanks :\n-        constant String (1 .. Task_Name_Length - Task_Name_Str'Length) :=\n-                                                 (others => ' ');\n+      Task_Name_Blanks : constant\n+        String (1 .. Task_Name_Length - Task_Name_Str'Length) :=\n+          (others => ' ');\n \n    begin\n       Set_Output (Standard_Error);\n@@ -392,10 +480,11 @@ package body System.Stack_Usage is\n          declare\n             Stack_Size_Blanks  : constant\n               String (1 .. Max_Stack_Size_Len - Stack_Size_Str'Length) :=\n-              (others => ' ');\n+                (others => ' ');\n+\n             Stack_Usage_Blanks : constant\n               String (1 .. Max_Actual_Use_Len - Actual_Size_Str'Length) :=\n-              (others => ' ');\n+                (others => ' ');\n \n          begin\n             if Stack_Size_Str'Length > Max_Stack_Size_Len then\n@@ -421,9 +510,10 @@ package body System.Stack_Usage is\n             Output_Result\n               (J, Result_Array (J), Max_Stack_Size_Len, Max_Actual_Use_Len);\n          end loop;\n-      else\n-         --  If there are no result stored, we'll still display the labels\n \n+      --  Case of no result stored, still display the labels\n+\n+      else\n          Put\n            (Index_Str & \" | \" & Task_Name_Str & Task_Name_Blanks & \" | \"\n             & Stack_Size_Str & \" | \" & Actual_Size_Str);\n@@ -437,14 +527,15 @@ package body System.Stack_Usage is\n \n    procedure Report_Result (Analyzer : Stack_Analyzer) is\n       Result : constant Task_Result :=\n-        (Task_Name      => Analyzer.Task_Name,\n-         Max_Size       => Analyzer.Size + Analyzer.Overflow_Guard,\n-         Measure        => Stack_Size\n-                             (Analyzer.Topmost_Touched_Mark,\n-                              Analyzer.Bottom_Of_Stack),\n-         Overflow_Guard => Analyzer.Overflow_Guard -\n-                             Natural (Analyzer.Bottom_Of_Stack -\n-                               Analyzer.Bottom_Pattern_Mark));\n+                 (Task_Name      => Analyzer.Task_Name,\n+                  Max_Size       => Analyzer.Size + Analyzer.Overflow_Guard,\n+                  Measure        => Stack_Size\n+                                      (Analyzer.Topmost_Touched_Mark,\n+                                       Analyzer.Bottom_Of_Stack),\n+                  Overflow_Guard => Analyzer.Overflow_Guard -\n+                                      Natural (Analyzer.Bottom_Of_Stack -\n+                                        Analyzer.Bottom_Pattern_Mark));\n+\n    begin\n       if Analyzer.Result_Id in Result_Array'Range then\n \n@@ -453,7 +544,6 @@ package body System.Stack_Usage is\n          Result_Array (Analyzer.Result_Id) := Result;\n \n       else\n-\n          --  If the result cannot be stored, then we display it right away\n \n          declare"}, {"sha": "4da9c00aef821c0305950ba0f47e5bfef8300890", "filename": "gcc/ada/s-stausa.ads", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4981ffccd5f5036ee2e5f768e62d41f9be354187/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4981ffccd5f5036ee2e5f768e62d41f9be354187/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=4981ffccd5f5036ee2e5f768e62d41f9be354187", "patch": "@@ -41,9 +41,6 @@ package System.Stack_Usage is\n \n    package SSE renames System.Storage_Elements;\n \n-   Byte_Size : constant := 8;\n-   Unsigned_32_Size : constant := 4 * Byte_Size;\n-\n    --  The alignment clause seems dubious, what about architectures where\n    --  the maximum alignment is less than 4???\n    --  Anyway, why not use Interfaces.Unsigned_32???\n@@ -270,14 +267,17 @@ private\n    package Unsigned_32_Addr is\n      new System.Address_To_Access_Conversions (Interfaces.Unsigned_32);\n \n+   subtype Pattern_Type is Interfaces.Unsigned_32;\n+   Bytes_Per_Pattern : constant := Pattern_Type'Object_Size / Storage_Unit;\n+\n    type Stack_Analyzer is record\n       Task_Name : String (1 .. Task_Name_Length);\n       --  Name of the task\n \n       Size : Natural;\n       --  Size of the pattern zone\n \n-      Pattern : Interfaces.Unsigned_32;\n+      Pattern : Pattern_Type;\n       --  Pattern used to recognize untouched memory\n \n       Bottom_Pattern_Mark : Stack_Address;\n@@ -296,13 +296,9 @@ private\n       --  Address of the bottom of the stack, as given by the caller of\n       --  Initialize_Analyzer.\n \n-      Array_Address : System.Address;\n-      --  Address of the array of Unsigned_32 that represents the pattern zone\n-\n-      First_Is_Topmost : Boolean;\n-      --  Set to true if the first element of the array of Unsigned_32 that\n-      --  represents the pattern zone is at the topmost address of the\n-      --  pattern zone; false if it is the bottommost address.\n+      Stack_Overlay_Address : System.Address;\n+      --  Address of the stack abstraction object we overlay over a\n+      --  task's real stack, typically a pattern-initialized array.\n \n       Result_Id : Positive;\n       --  Id of the result. If less than value given to gnatbind -u corresponds"}]}