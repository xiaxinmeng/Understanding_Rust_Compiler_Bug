{"sha": "9566a90c6b3691f90c67a1db620f337842d35838", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2NmE5MGM2YjM2OTFmOTBjNjdhMWRiNjIwZjMzNzg0MmQzNTgzOA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-01-12T10:11:13Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-01-12T10:11:13Z"}, "message": "InetAddress.java (ANY_IF): moved from ServerSocket.\n\n        * java/net/InetAddress.java (ANY_IF): moved from ServerSocket.\n        * java/net/DatagramSocket.java (DatagramSocket): use ANY_IF from\n        InetAddress.\n        * java/net/MulticastSocket.java (MulticastSocket): Likewise.\n        * java/net/Socket.java: Merge with Classpath.\n        * java/net/ServerSocket.java: Likewise.\n\nFrom-SVN: r48797", "tree": {"sha": "91031c9de9f57606f82c06f6060a409dd4ed0d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91031c9de9f57606f82c06f6060a409dd4ed0d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9566a90c6b3691f90c67a1db620f337842d35838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9566a90c6b3691f90c67a1db620f337842d35838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9566a90c6b3691f90c67a1db620f337842d35838", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9566a90c6b3691f90c67a1db620f337842d35838/comments", "author": null, "committer": null, "parents": [{"sha": "e37af218eed960ea5d499158db780aa4821e02cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37af218eed960ea5d499158db780aa4821e02cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e37af218eed960ea5d499158db780aa4821e02cc"}], "stats": {"total": 869, "additions": 716, "deletions": 153}, "files": [{"sha": "b6c0d79716a011ce70f097f3ef79aa553abbace2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9566a90c6b3691f90c67a1db620f337842d35838", "patch": "@@ -1,3 +1,12 @@\n+2002-01-11  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/net/InetAddress.java (ANY_IF): moved from ServerSocket.\n+\t* java/net/DatagramSocket.java (DatagramSocket): use ANY_IF from\n+\tInetAddress.\n+\t* java/net/MulticastSocket.java (MulticastSocket): Likewise.\n+\t* java/net/Socket.java: Merge with Classpath.\n+\t* java/net/ServerSocket.java: Likewise.\n+\n 2002-01-11  Chris Sears  <cbsears_sf@yahoo.com>\n \n \t* interpret.cc (NULLARRAYCHECK): New macro."}, {"sha": "6e33e3b122b04b473361792d5cf05862e24d0429", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=9566a90c6b3691f90c67a1db620f337842d35838", "patch": "@@ -28,12 +28,12 @@\n \n   public DatagramSocket() throws SocketException\n   {\n-    this(0, ServerSocket.ANY_IF);\n+    this(0, null);\n   }\n \n   public DatagramSocket(int port) throws SocketException\n   {\n-    this(port, ServerSocket.ANY_IF);\n+    this(port, null);\n   }\n \n   public DatagramSocket(int port, InetAddress laddr) throws SocketException\n@@ -66,7 +66,7 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n     if (this instanceof MulticastSocket)\n       impl.setOption(SocketOptions.SO_REUSEADDR, new Boolean(true));\n \n-    impl.bind(port, laddr == null ? ServerSocket.ANY_IF : laddr);\n+    impl.bind(port, laddr == null ? InetAddress.ANY_IF : laddr);\n   }\n \n   public void close()"}, {"sha": "49bc3105fb158a6548f2edb592ac30e3776454e5", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=9566a90c6b3691f90c67a1db620f337842d35838", "patch": "@@ -240,6 +240,10 @@ public static InetAddress[] getAllByName (String host)\n     return lookup(host, null, true);\n   }\n \n+  static final byte[] zeros = {0,0,0,0};\n+  /* dummy InetAddress, used to bind socket to any (all) network interfaces */\n+  static final InetAddress ANY_IF = new InetAddress(zeros, null);\n+    \n   private static final byte[] localhostAddress = { 127, 0, 0, 1 };\n \n   private static native String getLocalHostname ();"}, {"sha": "b0c0813c7f3b304bb2dab10462de4dfa75be1d9f", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=9566a90c6b3691f90c67a1db620f337842d35838", "patch": "@@ -64,7 +64,7 @@ public class MulticastSocket extends DatagramSocket\n   */\n   public MulticastSocket() throws IOException\n   {\n-    super(0, ServerSocket.ANY_IF);\n+    super(0, null);\n   }\n \n /**\n@@ -76,7 +76,7 @@ public MulticastSocket() throws IOException\n   */\n   public MulticastSocket(int port) throws IOException\n   {\n-    super(port, ServerSocket.ANY_IF);\n+    super(port, null);\n   }\n \n /**"}, {"sha": "23792a93840a79162a0d0b68736d73bb06886675", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 190, "deletions": 36, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=9566a90c6b3691f90c67a1db620f337842d35838", "patch": "@@ -1,111 +1,265 @@\n-// ServerSocket.java\n+/* ServerSocket.java -- Class for implementing server side sockets\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-/**\n-  * @author Per Bothner <bothner@cygnus.com>\n-  * @date January 6, 1999.\n-  */\n-\n-/** Written using on-line Java Platform 1.2 API Specification.\n-  * Status:  I believe all methods are implemented.\n-  */\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.net;\n-import java.io.*;\n \n+import java.io.IOException;\n+\n+/* Written using on-line Java Platform 1.2 API Specification.\n+ * Status:  I believe all methods are implemented.\n+ */\n+\n+/**\n+ * This class models server side sockets.  The basic model is that the\n+ * server socket is created and bound to some well known port.  It then\n+ * listens for and accepts connections.  At that point the client and\n+ * server sockets are ready to communicate with one another utilizing\n+ * whatever application layer protocol they desire.\n+ * <p>\n+ * As with the <code>Socket</code> class, most instance methods of this class \n+ * simply redirect their calls to an implementation class.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Per Bothner (bothner@cygnus.com)\n+ */\n public class ServerSocket\n {\n-  static SocketImplFactory factory;\n-  SocketImpl impl;\n \n-  static final byte[] zeros = {0,0,0,0};\n-  /* dummy InetAddress, used to bind socket to any (all) network interfaces */\n-  static final InetAddress ANY_IF = new InetAddress(zeros, null);\n+  // Class Variables\n+\n+  /**\n+   * This is the user defined SocketImplFactory, if one is supplied\n+   */\n+  private static SocketImplFactory factory;\n \n+  // Instance Variables\n+\n+  /**\n+   * This is the SocketImp object to which most instance methods in this\n+   * class are redirected\n+   */\n+  private SocketImpl impl;\n+\n+  /**\n+   * Private constructor that simply sets the implementation.\n+   */\n+  private ServerSocket()\n+  {\n+    if (factory != null)\n+      impl = factory.createSocketImpl();\n+    else\n+      impl = new PlainSocketImpl();\n+  }\n+\n+  /**\n+   * Creates a server socket and binds it to the specified port.  If the\n+   * port number is 0, a random free port will be chosen.  The pending\n+   * connection queue on this socket will be set to 50.\n+   *\n+   * @param port The port number to bind to\n+   * \n+   * @exception IOException If an error occurs\n+   */\n   public ServerSocket (int port)\n     throws java.io.IOException\n   {\n     this(port, 50);\n   }\n \n+  /**\n+   * Creates a server socket and binds it to the specified port.  If the\n+   * port number is 0, a random free port will be chosen.  The pending\n+   * connection queue on this socket will be set to the value passed as\n+   * arg2.\n+   *\n+   * @param port The port number to bind to\n+   * @param backlog The length of the pending connection queue\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public ServerSocket (int port, int backlog)\n     throws java.io.IOException\n   {\n-    this(port, backlog, ANY_IF);\n+    this(port, backlog, null);\n   }\n \n+  /**\n+   * Creates a server socket and binds it to the specified port.  If the\n+   * port number is 0, a random free port will be chosen.  The pending\n+   * connection queue on this socket will be set to the value passed as\n+   * backlog.  The third argument specifies a particular local address to\n+   * bind t or null to bind to all local address.\n+   *\n+   * @param port The port number to bind to\n+   * @param backlog The length of the pending connection queue\n+   * @param bindAddr The address to bind to, or null to bind to all addresses\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public ServerSocket (int port, int backlog, InetAddress bindAddr)\n     throws java.io.IOException\n   {\n-    if (factory == null)\n-      this.impl = new PlainSocketImpl();\n-    else\n-      this.impl = factory.createSocketImpl();\n+    this();\n+    if (impl == null)\n+      throw new IOException(\"Cannot initialize Socket implementation\");\n+\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkListen(port);\n+\n+    if (bindAddr == null)\n+      bindAddr = InetAddress.ANY_IF;\n+\n     impl.create(true);\n-    impl.bind(bindAddr == null ? ANY_IF : bindAddr, port);\n+    impl.bind(bindAddr, port);\n     impl.listen(backlog);\n   }\n \n+  /**\n+   * This method returns the local address to which this socket is bound\n+   *\n+   * @return The socket's local address\n+   */\n   public InetAddress getInetAddress()\n   {\n     return impl.getInetAddress();\n   }\n \n+  /**\n+   * This method returns the local port number to which this socket is bound\n+   *\n+   * @return The socket's port number\n+   */\n   public int getLocalPort()\n   {\n     return impl.getLocalPort();\n   }\n \n+  /**\n+   * Accepts a new connection and returns a connected <code>Socket</code> \n+   * instance representing that connection.  This method will block until a \n+   * connection is available.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public Socket accept ()  throws IOException\n   {\n-    Socket s = new Socket(Socket.factory == null ? new PlainSocketImpl()\n-\t\t\t  : Socket.factory.createSocketImpl());\n+    Socket s = new Socket();\n     implAccept (s);\n+\n     return s;\n   }\n \n+  /**\n+   * This protected method is used to help subclasses override \n+   * <code>ServerSocket.accept()</code>.  The passed in socket will be\n+   * connected when this method returns.\n+   *\n+   * @param socket The socket that is used for the accepted connection\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   protected final void implAccept (Socket s)  throws IOException\n   {\n     impl.accept(s.impl);\n   }\n \n+  /**\n+   * Closes this socket and stops listening for connections\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void close () throws IOException\n   {\n     impl.close();\n   }\n \n-  public synchronized void setSoTimeout (int timeout) throws SocketException\n+  /**\n+   * Sets the value of SO_TIMEOUT.  A value of 0 implies that SO_TIMEOUT is\n+   * disabled (ie, operations never time out).  This is the number of \n+   * milliseconds a socket operation can block before an\n+   * InterruptedIOException is thrown.\n+   *\n+   * @param timeout The new SO_TIMEOUT value\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public void setSoTimeout (int timeout) throws SocketException\n   {\n     if (timeout < 0)\n-      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n+      throw new IllegalArgumentException(\"SO_TIMEOUT value must be >= 0\");\n \n     impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n-  public synchronized int getSoTimeout () throws SocketException\n+  /**\n+   * Retrieves the current value of the SO_TIMEOUT setting.  A value of 0\n+   * implies that SO_TIMEOUT is disabled (ie, operations never time out).\n+   * This is the number of milliseconds a socket operation can block before\n+   * an InterruptedIOException is thrown.\n+   *\n+   * @return The value of SO_TIMEOUT\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public int getSoTimeout () throws IOException\n   {\n     Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n-    if (timeout instanceof Integer) \n-      return ((Integer)timeout).intValue();\n-    else\n-      return 0;\n+\n+    if (!(timeout instanceof Integer))\n+      throw new IOException(\"Internal Error\");\n+\n+    return ((Integer)timeout).intValue();\n   }\n \n+  /**\n+   * Returns the value of this socket as a <code>String</code>. \n+   *\n+   * @return This socket represented as a <code>String</code>.\n+   */\n   public String toString ()\n   {\n-    return \"ServerSocket\" + impl.toString();\n+    return \"ServerSocket \" + impl.toString();\n   }\n \n+  // Class methods\n+\n+  /**\n+   * Sets the <code>SocketImplFactory</code> for all \n+   * <code>ServerSocket</code>'s.  This may only be done\n+   * once per virtual machine.  Subsequent attempts will generate an\n+   * exception.  Note that a <code>SecurityManager</code> check is made prior\n+   * to setting the factory.  If insufficient privileges exist to set the\n+   * factory, an exception will be thrown\n+   *\n+   * @exception SecurityException If this operation is not allowed by the\n+   * <code>SecurityManager</code>.\n+   * @exception SocketException If the factory object is already defined\n+   * @exception IOException If any other error occurs\n+   */\n   public static synchronized void setSocketFactory (SocketImplFactory fac)\n     throws IOException\n   {"}, {"sha": "6bd6183cceaf8ffa010d75cece881d96a36dac5f", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 508, "deletions": 112, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a90c6b3691f90c67a1db620f337842d35838/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=9566a90c6b3691f90c67a1db620f337842d35838", "patch": "@@ -1,263 +1,659 @@\n-// Socket.java\n+/* Socket.java -- Client socket implementation\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/* Copyright (C) 1999  Free Software Foundation\n+package java.net;\n \n-   This file is part of libgcj.\n+import java.io.*;\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+/* Written using on-line Java Platform 1.2 API Specification.\n+ * Status:  I believe all methods are implemented.\n+ */\n \n /**\n-  * @author Per Bothner <bothner@cygnus.com>\n-  * @date January 6, 1999.\n-  */\n-\n-/** Written using on-line Java Platform 1.2 API Specification.\n-  * Status:  I believe all methods are implemented.\n-  */\n-\n-package java.net;\n-import java.io.*;\n-\n+ * This class models a client site socket.  A socket is a TCP/IP endpoint\n+ * for network communications conceptually similar to a file handle.\n+ * <p>\n+ * This class does not actually do any work.  Instead, it redirects all of\n+ * its calls to a socket implementation object which implements the\n+ * <code>SocketImpl</code> interface.  The implementation class is \n+ * instantiated by factory class that implements the \n+ * <code>SocketImplFactory interface</code>.  A default\n+ * factory is provided, however the factory may be set by a call to\n+ * the <code>setSocketImplFactory</code> method.  Note that this may only be \n+ * done once per virtual machine.  If a subsequent attempt is made to set the\n+ * factory, a <code>SocketException</code> will be thrown.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Per Bothner (bothner@cygnus.com)\n+ */\n public class Socket\n {\n+\n+  // Class Variables\n+\n+  /**\n+   * This is the user SocketImplFactory for this class.  If this variable is\n+   * null, a default factory is used.\n+   */\n   static SocketImplFactory factory;\n+\n+  // Instance Variables\n+\n+  /**\n+   * The implementation object to which calls are redirected\n+   */\n   SocketImpl impl;\n \n+  // Constructors\n+\n+  /**\n+   * Initializes a new instance of <code>Socket</code> object without \n+   * connecting to a remote host.  This useful for subclasses of socket that \n+   * might want this behavior.\n+   */\n   protected Socket ()\n   {\n+    if (factory != null)\n+      impl = factory.createSocketImpl();\n+    else\n+      impl = new PlainSocketImpl();\n   }\n \n+  /**\n+   * Initializes a new instance of <code>Socket</code> object without\n+   * connecting to a remote host.  This is useful for subclasses of socket\n+   * that might want this behavior.  \n+   * <p>\n+   * Additionally, this socket will be created using the supplied\n+   * implementation class instead the default class or one returned by a\n+   * factory.  This value can be <code>null</code>, but if it is, all instance\n+   * methods in <code>Socket</code> should be overridden because most of them\n+   * rely on this value being populated.\n+   *\n+   * @param impl The <code>SocketImpl</code> to use for this\n+   *             <code>Socket</code>\n+   *\n+   * @exception SocketException If an error occurs\n+   */\n   protected Socket (SocketImpl impl) throws SocketException\n   {\n     this.impl = impl;\n   }\n \n+  /**\n+   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * hostname and port specified as arguments.\n+   *\n+   * @param host The name of the host to connect to\n+   * @param port The port number to connect to\n+   *\n+   * @exception UnknownHostException If the hostname cannot be resolved to a\n+   * network address.\n+   * @exception IOException If an error occurs\n+   */\n   public Socket (String host, int port)\n     throws UnknownHostException, IOException\n   {\n-    this(factory == null ? new PlainSocketImpl() : factory.createSocketImpl());\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(host, port);\n-    impl.create(true);\n-    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n-    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n-    // that default.  JDK 1.2 doc infers not to do a bind.\n-    impl.connect(host, port);\n+    this(InetAddress.getByName(host), port, null, 0, true);\n   }\n \n+  /**\n+   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * address and port number specified as arguments.\n+   *\n+   * @param address The address to connect to\n+   * @param port The port number to connect to\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public Socket (InetAddress address, int port)\n     throws IOException \n   {\n-    this(factory == null ? new PlainSocketImpl() : factory.createSocketImpl());\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(address.getHostName(), port);\n-    impl.create(true);\n-    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n-    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n-    // that default.  JDK 1.2 doc infers not to do a bind.\n-    impl.connect(address, port);\n+    this(address, port, null, 0, true);\n   }\n \n+  /**\n+   * Initializes a new instance of <code>Socket</code> that connects to the \n+   * named host on the specified port and binds to the specified local address \n+   * and port.\n+   *\n+   * @param host The name of the remote host to connect to.\n+   * @param port The remote port to connect to.\n+   * @param loadAddr The local address to bind to.\n+   * @param localPort The local port to bind to.\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code>\n+   * exists and does not allow a connection to the specified host/port or\n+   * binding to the specified local host/port.\n+   * @exception IOException If a connection error occurs.\n+   */\n   public Socket (String host, int port,\n \t\t InetAddress localAddr, int localPort) throws IOException\n   {\n-    this(factory == null ? new PlainSocketImpl() : factory.createSocketImpl());\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(host, port);\n-    impl.create(true);\n-    // FIXME: JCL p. 1587 says if localAddr is null, use getLocalAddress().\n-    impl.bind(localAddr, localPort);\n-    impl.connect(host, port);\n+    this(InetAddress.getByName(host), port, localAddr, localPort, true);\n   }\n \n+  /**\n+   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * address and port number specified as arguments, plus binds to the \n+   * specified local address and port.\n+   *\n+   * @param address The remote address to connect to\n+   * @param port The remote port to connect to\n+   * @param localAddr The local address to connect to\n+   * @param localPort The local port to connect to\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public Socket (InetAddress address, int port,\n \t\t InetAddress localAddr, int localPort) throws IOException\n   {\n-    this(factory == null ? new PlainSocketImpl() : factory.createSocketImpl());\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(address.getHostName(), port);\n-    impl.create(true);\n-    // FIXME: JCL p. 1587 says if localAddr is null, use getLocalAddress().\n-    impl.bind(localAddr, localPort);\n-    impl.connect(address, port);\n+    this(address, port, localAddr, localPort, true);\n   }\n \n   /**\n-   * @deprecated Use DatagramSocket instead for UDP transport.\n+   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * hostname and port specified as arguments.  If the stream argument is set \n+   * to <code>true</code>, then a stream socket is created.  If it is \n+   * <code>false</code>, a datagram socket is created.\n+   *\n+   * @param host The name of the host to connect to\n+   * @param port The port to connect to\n+   * @param stream <code>true</code> for a stream socket, <code>false</code>\n+   * for a datagram socket\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @deprecated Use the <code>DatagramSocket</code> class to create\n+   * datagram oriented sockets.\n    */\n   public Socket (String host, int port, boolean stream) throws IOException\n   {\n-    impl = factory == null ? new PlainSocketImpl()\n-      : factory.createSocketImpl();\n-    impl.create(stream);\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(host, port);\n-    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n-    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n-    // that default.  JDK 1.2 doc infers not to do a bind.\n-    impl.connect(host, port);\n+    this(InetAddress.getByName(host), port, null, 0, stream);\n   }\n \n   /**\n-   * @deprecated Use DatagramSocket instead for UDP transport.\n+   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * address and port number specified as arguments.  If the stream param is \n+   * <code>true</code>, a stream socket will be created, otherwise a datagram \n+   * socket is created.\n+   *\n+   * @param host The address to connect to\n+   * @param port The port number to connect to\n+   * @param stream <code>true</code> to create a stream socket, \n+   * <code>false</code> to create a datagram socket.\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @deprecated Use the <code>DatagramSocket</code> class to create\n+   * datagram oriented sockets.\n    */\n   public Socket (InetAddress host, int port, boolean stream) throws IOException\n   {\n-    impl = factory == null ? new PlainSocketImpl()\n-      : factory.createSocketImpl();\n+    this(host, port, null, 0, stream);\n+  }\n+\n+  /**\n+   * This constructor is where the real work takes place.  Connect to the\n+   * specified address and port.  Use default local values if not specified,\n+   * otherwise use the local host and port passed in.  Create as stream or\n+   * datagram based on \"stream\" argument.\n+   * <p>\n+   *\n+   * @param raddr The remote address to connect to\n+   * @param rport The remote port to connect to\n+   * @param laddr The local address to connect to\n+   * @param lport The local port to connect to\n+   * @param stream true for a stream socket, false for a datagram socket\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n+                 boolean stream) throws IOException\n+  {\n+    this();\n+    if (impl == null)\n+      throw new IOException(\"Cannot initialize Socket implementation\");\n+\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkConnect(raddr.getHostName(), rport);\n+\n     impl.create(stream);\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(host.getHostName(), port);\n+\n     // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n     // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n     // that default.  JDK 1.2 doc infers not to do a bind.\n-    impl.connect(host, port);\n+    if (laddr != null)\n+      impl.bind(laddr, lport);\n+\n+    if (raddr != null)\n+      impl.connect(raddr, rport);\n   }\n \n+  /**\n+   * Returns the address of the remote end of the socket.  If this socket\n+   * is not connected, then <code>null</code> is returned.\n+   *\n+   * @return The remote address this socket is connected to\n+   */\n   public InetAddress getInetAddress ()\n   {\n-    return impl.getInetAddress();\n+    if (impl != null)\n+      return impl.getInetAddress();\n+\n+    return null;\n   }\n \n+  /**\n+   * Returns the local address to which this socket is bound.  If this socket\n+   * is not connected, then <code>null</code> is returned.\n+   *\n+   * @return The local address\n+   */\n   public InetAddress getLocalAddress ()\n   {\n-    // FIXME: see note in DatagramSocket.java about checkConnect() and security\n+    if (impl == null)\n+      return null;\n+\n+    InetAddress addr = null;\n     try\n       {\n-\treturn (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);\n+        addr = (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);\n       }\n-    catch (SocketException x)\n+    catch(SocketException e)\n       {\n-\t// (hopefully) shouldn't happen\n-\tSystem.err.println(x);\n-        throw new java.lang.InternalError(\"Error in PlainSocketImpl.getOption\");\n+        // (hopefully) shouldn't happen\n+        // throw new java.lang.InternalError\n+        //      (\"Error in PlainSocketImpl.getOption\");\n+        return null;\n       }\n+\n+    // FIXME: According to libgcj, checkConnect() is supposed to be called\n+    // before performing this operation.  Problems: 1) We don't have the\n+    // addr until after we do it, so we do a post check.  2). The docs I\n+    // see don't require this in the Socket case, only DatagramSocket, but\n+    // we'll assume they mean both.\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkConnect(addr.getHostName(), getLocalPort());\n+\n+    return addr;\n   }\n \n+  /**\n+   * Returns the port number of the remote end of the socket connection.  If\n+   * this socket is not connected, then -1 is returned.\n+   *\n+   * @return The remote port this socket is connected to\n+   */\n   public int getPort ()\n   {\n-    return impl.getPort();\n+    if (impl != null)\n+      return impl.getPort();\n+\n+    return -1;\n   }\n \n+  /**\n+   * Returns the local port number to which this socket is bound.  If this\n+   * socket is not connected, then -1 is returned.\n+   *\n+   * @return The local port\n+   */\n   public int getLocalPort ()\n   {\n-    return impl.getLocalPort();\n+    if (impl != null)\n+      return impl.getLocalPort();\n+\n+    return -1;\n   }\n \n+  /**\n+   * Returns an InputStream for reading from this socket.\n+   *\n+   * @return The InputStream object\n+   *\n+   * @exception IOException If an error occurs or Socket is not connected\n+   */\n   public InputStream getInputStream () throws IOException\n   {\n-    return impl.getInputStream();\n+    if (impl != null)\n+      return(impl.getInputStream());\n+\n+    throw new IOException(\"Not connected\");\n   }\n \n+  /**\n+   * Returns an OutputStream for writing to this socket.\n+   *\n+   * @return The OutputStream object\n+   *\n+   * @exception IOException If an error occurs or Socket is not connected\n+   */\n   public OutputStream getOutputStream () throws IOException\n   {\n-    return impl.getOutputStream();\n+    if (impl != null)\n+      return impl.getOutputStream();\n+\n+    throw new IOException(\"Not connected\");\n   }\n \n+  /**\n+   * Sets the TCP_NODELAY option on the socket. \n+   *\n+   * @param on true to enable, false to disable\n+   * \n+   * @exception SocketException If an error occurs or Socket is not connected\n+   */\n   public void setTcpNoDelay (boolean on)  throws SocketException\n   {\n-    impl.setOption( SocketOptions.TCP_NODELAY, new Boolean(on) );\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    impl.setOption(SocketOptions.TCP_NODELAY, new Boolean(on));\n   }\n \n+  /**\n+   * Tests whether or not the TCP_NODELAY option is set on the socket. \n+   * Returns true if enabled, false if disabled. When on it disables the\n+   * Nagle algorithm which means that packets are always send immediatly and\n+   * never merged together to reduce network trafic.\n+   *\n+   * @return Whether or not TCP_NODELAY is set\n+   * \n+   * @exception SocketException If an error occurs or Socket not connected\n+   */\n   public boolean getTcpNoDelay() throws SocketException\n   {\n-    Boolean bool = (Boolean)impl.getOption( SocketOptions.TCP_NODELAY );\n-    return bool.booleanValue();\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    Object on = impl.getOption(SocketOptions.TCP_NODELAY);\n+  \n+    if (on instanceof Boolean)\n+      return(((Boolean)on).booleanValue());\n+    else\n+      throw new SocketException(\"Internal Error\");\n   }\n \n+  /**\n+   * Sets the value of the SO_LINGER option on the socket.  If the \n+   * SO_LINGER option is set on a socket and there is still data waiting to\n+   * be sent when the socket is closed, then the close operation will block\n+   * until either that data is delivered or until the timeout period\n+   * expires.  The linger interval is specified in hundreths of a second\n+   * (platform specific?)\n+   *\n+   * @param on true to enable SO_LINGER, false to disable\n+   * @param linger The SO_LINGER timeout in hundreths of a second or -1 if \n+   * SO_LINGER not set.\n+   *\n+   * @exception SocketException If an error occurs or Socket not connected\n+   */\n   public void setSoLinger(boolean on, int linger) throws SocketException\n   {\n-    if ( on && (linger >= 0) ) \n+    if (impl == null)\n+      throw new SocketException(\"No socket created\");\n+\n+    if (on == true)\n       {\n-\tif (linger > 65535)\n-\t  linger = 65535;\n-\timpl.setOption( SocketOptions.SO_LINGER, new Integer(linger) );\n-      } \n-    else if ( on && (linger < 0) ) \n-      throw new IllegalArgumentException(\"SO_LINGER must be >= 0\");\n+        if (linger < 0)\n+          throw new IllegalArgumentException(\"SO_LINGER must be >= 0\");\n+\n+        if (linger > 65535)\n+          linger = 65535;\n+\n+        impl.setOption(SocketOptions.SO_LINGER, new Integer(linger));\n+      }\n     else\n-      impl.setOption( SocketOptions.SO_LINGER, new Boolean(false) );\n+      {\n+        impl.setOption(SocketOptions.SO_LINGER, new Boolean(false));\n+      }\n   }\n \n+  /**\n+   * Returns the value of the SO_LINGER option on the socket.  If the \n+   * SO_LINGER option is set on a socket and there is still data waiting to\n+   * be sent when the socket is closed, then the close operation will block\n+   * until either that data is delivered or until the timeout period\n+   * expires.  This method either returns the timeouts (in hundredths of\n+   * of a second (platform specific?)) if SO_LINGER is set, or -1 if\n+   * SO_LINGER is not set.\n+   *\n+   * @return The SO_LINGER timeout in hundreths of a second or -1 \n+   * if SO_LINGER not set\n+   *\n+   * @exception SocketException If an error occurs or Socket is not connected\n+   */\n   public int getSoLinger() throws SocketException\n   {\n-    Object linger = impl.getOption(SocketOptions.SO_LINGER);    \n-    if (linger instanceof Integer) \n-      return ((Integer)linger).intValue();\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    Object linger = impl.getOption(SocketOptions.SO_LINGER);\n+    if (linger instanceof Integer)\n+      return(((Integer)linger).intValue());\n     else\n       return -1;\n   }\n \n+  /**\n+   * Sets the value of the SO_TIMEOUT option on the socket.  If this value\n+   * is set, and an read/write is performed that does not complete within\n+   * the timeout period, a short count is returned (or an EWOULDBLOCK signal\n+   * would be sent in Unix if no data had been read).  A value of 0 for\n+   * this option implies that there is no timeout (ie, operations will \n+   * block forever).  On systems that have separate read and write timeout\n+   * values, this method returns the read timeout.  This\n+   * value is in thousandths of a second (****????*****)\n+   *\n+   * @param timeout The length of the timeout in thousandth's of a second or \n+   * 0 if not set\n+   *\n+   * @exception SocketException If an error occurs or Socket not connected\n+   */\n   public synchronized void setSoTimeout (int timeout) throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+    \n     if (timeout < 0)\n-      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n-\n+      throw new IllegalArgumentException(\"SO_TIMEOUT value must be >= 0\");\n+      \n     impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n+  /**\n+   * Returns the value of the SO_TIMEOUT option on the socket.  If this value\n+   * is set, and an read/write is performed that does not complete within\n+   * the timeout period, a short count is returned (or an EWOULDBLOCK signal\n+   * would be sent in Unix if no data had been read).  A value of 0 for\n+   * this option implies that there is no timeout (ie, operations will \n+   * block forever).  On systems that have separate read and write timeout\n+   * values, this method returns the read timeout.  This\n+   * value is in thousandths of a second (implementation specific?).\n+   *\n+   * @return The length of the timeout in thousandth's of a second or 0 \n+   * if not set\n+   *\n+   * @exception SocketException If an error occurs or Socket not connected\n+   */\n   public synchronized int getSoTimeout () throws SocketException\n   {\n+    if (impl == null) \n+      throw new SocketException(\"Not connected\");\n+\n     Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n-    if (timeout instanceof Integer) \n-      return ((Integer)timeout).intValue();\n+    if (timeout instanceof Integer)\n+      return(((Integer)timeout).intValue());\n     else\n       return 0;\n   }\n \n-  // JDK1.2\n+  /**\n+   * This method sets the value for the system level socket option\n+   * SO_SNDBUF to the specified value.  Note that valid values for this\n+   * option are specific to a given operating system.\n+   *\n+   * @param size The new send buffer size.\n+   *\n+   * @exception SocketException If an error occurs or Socket not connected\n+   *\n+   * @since Java 1.2\n+   */\n   public void setSendBufferSize (int size) throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+    \n     if (size <= 0)\n-      throw new IllegalArgumentException(\"Invalid buffer size: \" + size);\n-\n+      throw new IllegalArgumentException(\"SO_SNDBUF value must be > 0\");\n+    \n     impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n   }\n \n-  // JDK1.2\n+  /**\n+   * This method returns the value of the system level socket option\n+   * SO_SNDBUF, which is used by the operating system to tune buffer\n+   * sizes for data transfers.\n+   *\n+   * @return The send buffer size.\n+   *\n+   * @exception SocketException If an error occurs or socket not connected\n+   *\n+   * @since Java 1.2\n+   */\n   public int getSendBufferSize () throws SocketException\n   {\n-    Integer buf = (Integer)impl.getOption(SocketOptions.SO_SNDBUF);\n-    return buf.intValue();\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    Object buf = impl.getOption(SocketOptions.SO_SNDBUF);\n+\n+    if (buf instanceof Integer)\n+      return(((Integer)buf).intValue());\n+    else\n+      throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n \n-  // JDK1.2\n+  /**\n+   * This method sets the value for the system level socket option\n+   * SO_RCVBUF to the specified value.  Note that valid values for this\n+   * option are specific to a given operating system.\n+   *\n+   * @param size The new receive buffer size.\n+   *\n+   * @exception SocketException If an error occurs or Socket is not connected\n+   *\n+   * @since Java 1.2\n+   */\n   public void setReceiveBufferSize (int size) throws SocketException\n   {\n-    if (size <= 0)\n-      throw new IllegalArgumentException(\"Invalid buffer size: \" + size);\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n \n+    if (size <= 0)\n+      throw new IllegalArgumentException(\"SO_RCVBUF value must be > 0\");\n+      \n     impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n   }\n \n-  // JDK1.2\n+  /**\n+   * This method returns the value of the system level socket option\n+   * SO_RCVBUF, which is used by the operating system to tune buffer\n+   * sizes for data transfers.\n+   *\n+   * @return The receive buffer size.\n+   *\n+   * @exception SocketException If an error occurs or Socket is not connected\n+   *\n+   * @since Java 1.2\n+   */\n   public int getReceiveBufferSize () throws SocketException\n   {\n-    Integer buf = (Integer)impl.getOption(SocketOptions.SO_RCVBUF);\n-    return buf.intValue();\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    Object buf = impl.getOption(SocketOptions.SO_RCVBUF);\n+\n+    if (buf instanceof Integer)\n+      return(((Integer)buf).intValue());\n+    else\n+      throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n \n+  /**\n+   * Closes the socket.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public synchronized void close ()  throws IOException\n   {\n-    impl.close();\n+    if (impl != null)\n+      impl.close();\n   }\n \n+  /**\n+   * Converts this <code>Socket</code> to a <code>String</code>.\n+   *\n+   * @return The <code>String</code> representation of this <code>Socket</code>\n+   */\n   public String toString ()\n   {\n-    return \"Socket\" + impl.toString();\n+    return(\"Socket \" + impl);\n   }\n \n+  // Class Methods\n+\n+  /**\n+   * Sets the <code>SocketImplFactory</code>.  This may be done only once per \n+   * virtual machine.  Subsequent attempts will generate a \n+   * <code>SocketException</code>.  Note that a <code>SecurityManager</code>\n+   * check is made prior to setting the factory.  If \n+   * insufficient privileges exist to set the factory, then an \n+   * <code>IOException</code> will be thrown.\n+   *\n+   * @exception SecurityException If the <code>SecurityManager</code> does\n+   * not allow this operation.\n+   * @exception SocketException If the SocketImplFactory is already defined\n+   * @exception IOException If any other error occurs\n+   */\n   public static synchronized void setSocketImplFactory (SocketImplFactory fac)\n     throws IOException\n   {\n+    // See if already set\n+    if (factory != null)\n+      throw new SocketException(\"SocketImplFactory already defined\");\n+\n+    // Check permissions\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkSetFactory();\n+\n     factory = fac;\n   }\n }"}]}