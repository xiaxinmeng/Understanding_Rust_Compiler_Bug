{"sha": "1d481ba83c705072441d4a3c52902c4e3573069f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ0ODFiYTgzYzcwNTA3MjQ0MWQ0YTNjNTI5MDJjNGUzNTczMDY5Zg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-11-22T21:33:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-11-22T21:33:47Z"}, "message": "re PR tree-optimization/18529 (When the lower bound of a loop is non-constant we cannot find the number of iterations)\n\n\tPR tree-optimization/18529\n\t* fold-const.c (fold_to_nonsharp_ineq_using_bound): New function.\n\t(simple_operand_p): Use STRIP_NOPS.  Consider SSA names simple.\n\t(fold): Call fold_to_nonsharp_ineq_using_bound.\n\t* tree-ssa-loop-niter.c (simplify_replace_tree): New function.\n\t(number_of_iterations_cond): Fold the expressions before futher\n\tprocessing.\n\t(tree_simplify_using_condition): Handle case when cond or expr is\n\tan EQ_EXPR specially.\n\nFrom-SVN: r91031", "tree": {"sha": "d8660e4627f3ddc5b8cbe84ddc41e85ff94cac90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8660e4627f3ddc5b8cbe84ddc41e85ff94cac90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d481ba83c705072441d4a3c52902c4e3573069f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d481ba83c705072441d4a3c52902c4e3573069f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d481ba83c705072441d4a3c52902c4e3573069f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d481ba83c705072441d4a3c52902c4e3573069f/comments", "author": null, "committer": null, "parents": [{"sha": "392cd098c5d7aa57b0a5ae934f8ee0ce9945130c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392cd098c5d7aa57b0a5ae934f8ee0ce9945130c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/392cd098c5d7aa57b0a5ae934f8ee0ce9945130c"}], "stats": {"total": 164, "additions": 157, "deletions": 7}, "files": [{"sha": "2c974a0d81d4a0a6f6082ea8ad726f7daf40d132", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d481ba83c705072441d4a3c52902c4e3573069f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d481ba83c705072441d4a3c52902c4e3573069f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d481ba83c705072441d4a3c52902c4e3573069f", "patch": "@@ -1,3 +1,15 @@\n+2004-11-22  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/18529\n+\t* fold-const.c (fold_to_nonsharp_ineq_using_bound): New function.\n+\t(simple_operand_p): Use STRIP_NOPS.  Consider SSA names simple.\n+\t(fold): Call fold_to_nonsharp_ineq_using_bound.\n+\t* tree-ssa-loop-niter.c (simplify_replace_tree): New function.\n+\t(number_of_iterations_cond): Fold the expressions before futher\n+\tprocessing.\n+\t(tree_simplify_using_condition): Handle case when cond or expr is\n+\tan EQ_EXPR specially.\n+\n 2004-11-22 Daniel Berlin  <dberlin@dberlin.org>\n \n         * tree-ssa.c (verify_ssa): SSA_OP_ALL_USES should be"}, {"sha": "611ac145093a1702109c37f609e2b5d852a2eb87", "filename": "gcc/fold-const.c", "status": "modified", "additions": 63, "deletions": 5, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d481ba83c705072441d4a3c52902c4e3573069f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d481ba83c705072441d4a3c52902c4e3573069f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1d481ba83c705072441d4a3c52902c4e3573069f", "patch": "@@ -3424,13 +3424,10 @@ static int\n simple_operand_p (tree exp)\n {\n   /* Strip any conversions that don't change the machine mode.  */\n-  while ((TREE_CODE (exp) == NOP_EXPR\n-\t  || TREE_CODE (exp) == CONVERT_EXPR)\n-\t && (TYPE_MODE (TREE_TYPE (exp))\n-\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n-    exp = TREE_OPERAND (exp, 0);\n+  STRIP_NOPS (exp);\n \n   return (CONSTANT_CLASS_P (exp)\n+\t  || TREE_CODE (exp) == SSA_NAME\n \t  || (DECL_P (exp)\n \t      && ! TREE_ADDRESSABLE (exp)\n \t      && ! TREE_THIS_VOLATILE (exp)\n@@ -6180,6 +6177,51 @@ try_move_mult_to_index (tree type, enum tree_code code, tree addr, tree mult)\n   return build1 (ADDR_EXPR, type, ret);\n }\n \n+\n+/* Fold A < X && A + 1 > Y to A < X && A >= Y.  Normally A + 1 > Y\n+   means A >= Y && A != MAX, but in this case we know that\n+   A < X <= MAX.  INEQ is A + 1 > Y, BOUND is A < X.  */\n+\n+static tree\n+fold_to_nonsharp_ineq_using_bound (tree ineq, tree bound)\n+{\n+  tree a, typea, type = TREE_TYPE (ineq), a1, diff, y;\n+\n+  if (TREE_CODE (bound) == LT_EXPR)\n+    a = TREE_OPERAND (bound, 0);\n+  else if (TREE_CODE (bound) == GT_EXPR)\n+    a = TREE_OPERAND (bound, 1);\n+  else\n+    return NULL_TREE;\n+\n+  typea = TREE_TYPE (a);\n+  if (!INTEGRAL_TYPE_P (typea)\n+      && !POINTER_TYPE_P (typea))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (ineq) == LT_EXPR)\n+    {\n+      a1 = TREE_OPERAND (ineq, 1);\n+      y = TREE_OPERAND (ineq, 0);\n+    }\n+  else if (TREE_CODE (ineq) == GT_EXPR)\n+    {\n+      a1 = TREE_OPERAND (ineq, 0);\n+      y = TREE_OPERAND (ineq, 1);\n+    }\n+  else\n+    return NULL_TREE;\n+\n+  if (TREE_TYPE (a1) != typea)\n+    return NULL_TREE;\n+\n+  diff = fold (build2 (MINUS_EXPR, typea, a1, a));\n+  if (!integer_onep (diff))\n+    return NULL_TREE;\n+\n+  return fold (build2 (GE_EXPR, type, a, y));\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -8023,6 +8065,22 @@ fold (tree expr)\n \t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n \n+      /* A < X && A + 1 > Y ==> A < X && A >= Y.  Normally A + 1 > Y\n+\t means A >= Y && A != MAX, but in this case we know that\n+\t A < X <= MAX.  */\n+\n+      if (!TREE_SIDE_EFFECTS (arg0)\n+\t  && !TREE_SIDE_EFFECTS (arg1))\n+\t{\n+\t  tem = fold_to_nonsharp_ineq_using_bound (arg0, arg1);\n+\t  if (tem)\n+\t    return fold (build2 (code, type, tem, arg1));\n+\n+\t  tem = fold_to_nonsharp_ineq_using_bound (arg1, arg0);\n+\t  if (tem)\n+\t    return fold (build2 (code, type, arg0, tem));\n+\t}\n+\n     truth_andor:\n       /* We only do these simplifications if we are optimizing.  */\n       if (!optimize)"}, {"sha": "c83113430bcd055585df32bd6ba5943f026e14c8", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d481ba83c705072441d4a3c52902c4e3573069f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d481ba83c705072441d4a3c52902c4e3573069f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=1d481ba83c705072441d4a3c52902c4e3573069f", "patch": "@@ -372,12 +372,12 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \n \t  if (zero_p (step0))\n \t    {\n-\t      base0 = build2 (PLUS_EXPR, type, base0, delta);\n+\t      base0 = fold (build2 (PLUS_EXPR, type, base0, delta));\n \t      base0 = fold (build2 (MINUS_EXPR, type, base0, step));\n \t    }\n \t  else\n \t    {\n-\t      base1 = build2 (MINUS_EXPR, type, base1, delta);\n+\t      base1 = fold (build2 (MINUS_EXPR, type, base1, delta));\n \t      base1 = fold (build2 (PLUS_EXPR, type, base1, step));\n \t    }\n \n@@ -555,6 +555,41 @@ simplify_using_outer_evolutions (struct loop *loop, tree expr)\n   return expr;\n }\n \n+/* Substitute NEW for OLD in EXPR and fold the result.  */\n+\n+static tree\n+simplify_replace_tree (tree expr, tree old, tree new)\n+{\n+  unsigned i, n;\n+  tree ret = NULL_TREE, e, se;\n+\n+  if (!expr)\n+    return NULL_TREE;\n+\n+  if (expr == old\n+      || operand_equal_p (expr, old, 0))\n+    return unshare_expr (new);\n+\n+  if (!EXPR_P (expr))\n+    return expr;\n+\n+  n = TREE_CODE_LENGTH (TREE_CODE (expr));\n+  for (i = 0; i < n; i++)\n+    {\n+      e = TREE_OPERAND (expr, i);\n+      se = simplify_replace_tree (e, old, new);\n+      if (e == se)\n+\tcontinue;\n+\n+      if (!ret)\n+\tret = copy_node (expr);\n+\n+      TREE_OPERAND (ret, i) = se;\n+    }\n+\n+  return (ret ? fold (ret) : expr);\n+}\n+\n /* Tries to simplify EXPR using the condition COND.  Returns the simplified\n    expression (or EXPR unchanged, if no simplification was possible).*/\n \n@@ -603,6 +638,51 @@ tree_simplify_using_condition (tree cond, tree expr)\n       return expr;\n     }\n \n+  /* In case COND is equality, we may be able to simplify EXPR by copy/constant\n+     propagation, and vice versa.  Fold does not handle this, since it is\n+     considered too expensive.  */\n+  if (TREE_CODE (cond) == EQ_EXPR)\n+    {\n+      e0 = TREE_OPERAND (cond, 0);\n+      e1 = TREE_OPERAND (cond, 1);\n+\n+      /* We know that e0 == e1.  Check whether we cannot simplify expr\n+\t using this fact.  */\n+      e = simplify_replace_tree (expr, e0, e1);\n+      if (zero_p (e) || nonzero_p (e))\n+\treturn e;\n+\n+      e = simplify_replace_tree (expr, e1, e0);\n+      if (zero_p (e) || nonzero_p (e))\n+\treturn e;\n+    }\n+  if (TREE_CODE (expr) == EQ_EXPR)\n+    {\n+      e0 = TREE_OPERAND (expr, 0);\n+      e1 = TREE_OPERAND (expr, 1);\n+\n+      /* If e0 == e1 (EXPR) implies !COND, then EXPR cannot be true.  */\n+      e = simplify_replace_tree (cond, e0, e1);\n+      if (zero_p (e))\n+\treturn e;\n+      e = simplify_replace_tree (cond, e1, e0);\n+      if (zero_p (e))\n+\treturn e;\n+    }\n+  if (TREE_CODE (expr) == NE_EXPR)\n+    {\n+      e0 = TREE_OPERAND (expr, 0);\n+      e1 = TREE_OPERAND (expr, 1);\n+\n+      /* If e0 == e1 (!EXPR) implies !COND, then EXPR must be true.  */\n+      e = simplify_replace_tree (cond, e0, e1);\n+      if (zero_p (e))\n+\treturn boolean_true_node;\n+      e = simplify_replace_tree (cond, e1, e0);\n+      if (zero_p (e))\n+\treturn boolean_true_node;\n+    }\n+\n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n   e = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,"}]}