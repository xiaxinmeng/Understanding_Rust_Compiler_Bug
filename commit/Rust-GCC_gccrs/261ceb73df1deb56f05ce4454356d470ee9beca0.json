{"sha": "261ceb73df1deb56f05ce4454356d470ee9beca0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYxY2ViNzNkZjFkZWI1NmYwNWNlNDQ1NDM1NmQ0NzBlZTliZWNhMA==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-07-12T14:35:46Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-07-12T14:35:46Z"}, "message": "Delete moved source files.\n\nFrom-SVN: r176205", "tree": {"sha": "2a50942288f491390ec94fa2d1b0a2133324e308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a50942288f491390ec94fa2d1b0a2133324e308"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/261ceb73df1deb56f05ce4454356d470ee9beca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261ceb73df1deb56f05ce4454356d470ee9beca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261ceb73df1deb56f05ce4454356d470ee9beca0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261ceb73df1deb56f05ce4454356d470ee9beca0/comments", "author": null, "committer": null, "parents": [{"sha": "12c4ecb13a60ac686ec32b61ece46372d0d19760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c4ecb13a60ac686ec32b61ece46372d0d19760", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c4ecb13a60ac686ec32b61ece46372d0d19760"}], "stats": {"total": 1316, "additions": 0, "deletions": 1316}, "files": [{"sha": "19f2fdae67d29076bcefb231fcbf7364861a6e24", "filename": "gcc/config/dfp-bit.c", "status": "removed", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c4ecb13a60ac686ec32b61ece46372d0d19760/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c4ecb13a60ac686ec32b61ece46372d0d19760/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=12c4ecb13a60ac686ec32b61ece46372d0d19760", "patch": "@@ -1,680 +0,0 @@\n-/* This is a software decimal floating point library.\n-   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* This implements IEEE 754 decimal floating point arithmetic, but\n-   does not provide a mechanism for setting the rounding mode, or for\n-   generating or handling exceptions.  Conversions between decimal\n-   floating point types and other types depend on C library functions.\n-\n-   Contributed by Ben Elliston  <bje@au.ibm.com>.  */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-/* FIXME: compile with -std=gnu99 to get these from stdlib.h */\n-extern float strtof (const char *, char **);\n-extern long double strtold (const char *, char **);\n-#include <string.h>\n-#include <limits.h>\n-\n-#include \"config/dfp-bit.h\"\n-\n-/* Forward declarations.  */\n-#if WIDTH == 32 || WIDTH_TO == 32\n-void __host_to_ieee_32 (_Decimal32 in, decimal32 *out);\n-void __ieee_to_host_32 (decimal32 in, _Decimal32 *out);\n-#endif\n-#if WIDTH == 64 || WIDTH_TO == 64\n-void __host_to_ieee_64 (_Decimal64 in, decimal64 *out);\n-void __ieee_to_host_64 (decimal64 in, _Decimal64 *out);\n-#endif\n-#if WIDTH == 128 || WIDTH_TO == 128\n-void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);\n-void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);\n-#endif\n-\n-/* A pointer to a binary decFloat operation.  */\n-typedef decFloat* (*dfp_binary_func)\n-     (decFloat *, const decFloat *, const decFloat *, decContext *);\n-\f\n-/* Binary operations.  */\n-\n-/* Use a decFloat (decDouble or decQuad) function to perform a DFP\n-   binary operation.  */\n-static inline decFloat\n-dfp_binary_op (dfp_binary_func op, decFloat arg_a, decFloat arg_b)\n-{\n-  decFloat result;\n-  decContext context;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-\n-  /* Perform the operation.  */\n-  op (&result, &arg_a, &arg_b, &context);\n-\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    {\n-      /* decNumber exception flags we care about here.  */\n-      int ieee_flags;\n-      int dec_flags = DEC_IEEE_854_Division_by_zero | DEC_IEEE_854_Inexact\n-\t\t      | DEC_IEEE_854_Invalid_operation | DEC_IEEE_854_Overflow\n-\t\t      | DEC_IEEE_854_Underflow;\n-      dec_flags &= context.status;\n-      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n-      if (ieee_flags != 0)\n-        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n-    }\n-\n-  return result;\n-}\n-\n-#if WIDTH == 32\n-/* The decNumber package doesn't provide arithmetic for decSingle (32 bits);\n-   convert to decDouble, use the operation for that, and convert back.  */\n-static inline _Decimal32\n-d32_binary_op (dfp_binary_func op, _Decimal32 arg_a, _Decimal32 arg_b)\n-{\n-  union { _Decimal32 c; decSingle f; } a32, b32, res32;\n-  decDouble a, b, res;\n-  decContext context;\n-\n-  /* Widen the operands and perform the operation.  */\n-  a32.c = arg_a;\n-  b32.c = arg_b;\n-  decSingleToWider (&a32.f, &a);\n-  decSingleToWider (&b32.f, &b);\n-  res = dfp_binary_op (op, a, b);\n-\n-  /* Narrow the result, which might result in an underflow or overflow.  */\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-  decSingleFromWider (&res32.f, &res, &context);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    {\n-      /* decNumber exception flags we care about here.  */\n-      int ieee_flags;\n-      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Overflow\n-\t\t      | DEC_IEEE_854_Underflow;\n-      dec_flags &= context.status;\n-      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n-      if (ieee_flags != 0)\n-        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n-    }\n-\n-  return res32.c;\n-}\n-#else\n-/* decFloat operations are supported for decDouble (64 bits) and\n-   decQuad (128 bits).  The bit patterns for the types are the same.  */\n-static inline DFP_C_TYPE\n-dnn_binary_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  union { DFP_C_TYPE c; decFloat f; } a, b, result;\n-\n-  a.c = arg_a;\n-  b.c = arg_b;\n-  result.f = dfp_binary_op (op, a.f, b.f);\n-  return result.c;\n-}\n-#endif\n-\n-/* Comparison operations.  */\n-\n-/* Use a decFloat (decDouble or decQuad) function to perform a DFP\n-   comparison.  */\n-static inline CMPtype\n-dfp_compare_op (dfp_binary_func op, decFloat arg_a, decFloat arg_b)\n-{\n-  decContext context;\n-  decFloat res;\n-  int result;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-\n-  /* Perform the comparison.  */\n-  op (&res, &arg_a, &arg_b, &context);\n-\n-  if (DEC_FLOAT_IS_SIGNED (&res))\n-    result = -1;\n-  else if (DEC_FLOAT_IS_ZERO (&res))\n-    result = 0;\n-  else if (DEC_FLOAT_IS_NAN (&res))\n-    result = -2;\n-  else\n-    result = 1;\n-\n-  return (CMPtype) result;\n-}\n-\n-#if WIDTH == 32\n-/* The decNumber package doesn't provide comparisons for decSingle (32 bits);\n-   convert to decDouble, use the operation for that, and convert back.  */\n-static inline CMPtype\n-d32_compare_op (dfp_binary_func op, _Decimal32 arg_a, _Decimal32 arg_b)\n-{\n-  union { _Decimal32 c; decSingle f; } a32, b32;\n-  decDouble a, b;\n-\n-  a32.c = arg_a;\n-  b32.c = arg_b;\n-  decSingleToWider (&a32.f, &a);\n-  decSingleToWider (&b32.f, &b);\n-  return dfp_compare_op (op, a, b);  \n-}\n-#else\n-/* decFloat comparisons are supported for decDouble (64 bits) and\n-   decQuad (128 bits).  The bit patterns for the types are the same.  */\n-static inline CMPtype\n-dnn_compare_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  union { DFP_C_TYPE c; decFloat f; } a, b;\n-\n-  a.c = arg_a;\n-  b.c = arg_b;\n-  return dfp_compare_op (op, a.f, b.f);  \n-}\n-#endif\n-\f\n-#if defined(L_conv_sd)\n-void\n-__host_to_ieee_32 (_Decimal32 in, decimal32 *out)\n-{\n-  memcpy (out, &in, 4);\n-}\n-\n-void\n-__ieee_to_host_32 (decimal32 in, _Decimal32 *out)\n-{\n-  memcpy (out, &in, 4);\n-}\n-#endif /* L_conv_sd */\n-\n-#if defined(L_conv_dd)\n-void\n-__host_to_ieee_64 (_Decimal64 in, decimal64 *out)\n-{\n-  memcpy (out, &in, 8);\n-}\n-\n-void\n-__ieee_to_host_64 (decimal64 in, _Decimal64 *out)\n-{\n-  memcpy (out, &in, 8);\n-}\n-#endif /* L_conv_dd */\n-\n-#if defined(L_conv_td)\n-void\n-__host_to_ieee_128 (_Decimal128 in, decimal128 *out)\n-{\n-  memcpy (out, &in, 16);\n-}\n-\n-void\n-__ieee_to_host_128 (decimal128 in, _Decimal128 *out)\n-{\n-  memcpy (out, &in, 16);\n-}\n-#endif /* L_conv_td */\n-\n-#if defined(L_addsub_sd) || defined(L_addsub_dd) || defined(L_addsub_td)\n-DFP_C_TYPE\n-DFP_ADD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  return DFP_BINARY_OP (DEC_FLOAT_ADD, arg_a, arg_b);\n-}\n-\n-DFP_C_TYPE\n-DFP_SUB (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  return DFP_BINARY_OP (DEC_FLOAT_SUBTRACT, arg_a, arg_b);\n-}\n-#endif /* L_addsub */\n-\n-#if defined(L_mul_sd) || defined(L_mul_dd) || defined(L_mul_td)\n-DFP_C_TYPE\n-DFP_MULTIPLY (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  return DFP_BINARY_OP (DEC_FLOAT_MULTIPLY, arg_a, arg_b);\n-}\n-#endif /* L_mul */\n-\n-#if defined(L_div_sd) || defined(L_div_dd) || defined(L_div_td)\n-DFP_C_TYPE\n-DFP_DIVIDE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  return DFP_BINARY_OP (DEC_FLOAT_DIVIDE, arg_a, arg_b);\n-}\n-#endif /* L_div */\n-\n-#if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n-CMPtype\n-DFP_EQ (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  CMPtype stat;\n-  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n-  /* For EQ return zero for true, nonzero for false.  */\n-  return stat != 0;\n-}\n-#endif /* L_eq */\n-\n-#if defined (L_ne_sd) || defined (L_ne_dd) || defined (L_ne_td)\n-CMPtype\n-DFP_NE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  int stat;\n-  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n-  /* For NE return zero for true, nonzero for false.  */\n-  if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n-    return 1;\n-  return stat != 0;\n-}\n-#endif /* L_ne */\n-\n-#if defined (L_lt_sd) || defined (L_lt_dd) || defined (L_lt_td)\n-CMPtype\n-DFP_LT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  int stat;\n-  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n-  /* For LT return -1 (<0) for true, 1 for false.  */\n-  return (stat == -1) ? -1 : 1;\n-}\n-#endif /* L_lt */\n-\n-#if defined (L_gt_sd) || defined (L_gt_dd) || defined (L_gt_td)\n-CMPtype\n-DFP_GT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  int stat;\n-  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n-  /* For GT return 1 (>0) for true, -1 for false.  */\n-  return (stat == 1) ? 1 : -1;\n-}\n-#endif\n-\n-#if defined (L_le_sd) || defined (L_le_dd) || defined (L_le_td)\n-CMPtype\n-DFP_LE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  int stat;\n-  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n-  /* For LE return 0 (<= 0) for true, 1 for false.  */\n-  if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n-    return 1;\n-  return stat == 1;\n-}\n-#endif /* L_le */\n-\n-#if defined (L_ge_sd) || defined (L_ge_dd) || defined (L_ge_td)\n-CMPtype\n-DFP_GE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  int stat;\n-  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n-  /* For GE return 1 (>=0) for true, -1 for false.  */\n-  if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n-    return -1;\n-  return (stat != -1) ? 1 : -1;\n-}\n-#endif /* L_ge */\n-\n-#define BUFMAX 128\n-\n-/* Check for floating point exceptions that are relevant for conversions\n-   between decimal float values and handle them.  */\n-static inline void\n-dfp_conversion_exceptions (const int status)\n-{\n-  /* decNumber exception flags we care about here.  */\n-  int ieee_flags;\n-  int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n-\t\t  | DEC_IEEE_854_Overflow;\n-  dec_flags &= status;\n-  ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n-  if (ieee_flags != 0)\n-    DFP_HANDLE_EXCEPTIONS (ieee_flags);\n-}\n-\n-#if defined (L_sd_to_dd)\n-/* Use decNumber to convert directly from _Decimal32 to _Decimal64.  */\n-_Decimal64\n-DFP_TO_DFP (_Decimal32 f_from)\n-{\n-  union { _Decimal32 c; decSingle f; } from;\n-  union { _Decimal64 c; decDouble f; } to;\n-\n-  from.c = f_from;\n-  to.f = *decSingleToWider (&from.f, &to.f);\n-  return to.c;\n-}\n-#endif\n-\n-#if defined (L_sd_to_td)\n-/* Use decNumber to convert directly from _Decimal32 to _Decimal128.  */\n-_Decimal128\n-DFP_TO_DFP (_Decimal32 f_from)\n-{\n-  union { _Decimal32 c; decSingle f; } from;\n-  union { _Decimal128 c; decQuad f; } to;\n-  decDouble temp;\n-\n-  from.c = f_from;\n-  temp = *decSingleToWider (&from.f, &temp);\n-  to.f = *decDoubleToWider (&temp, &to.f);\n-  return to.c;\n-}\n-#endif\n-\n-#if defined (L_dd_to_td)\n-/* Use decNumber to convert directly from _Decimal64 to _Decimal128.  */\n-_Decimal128\n-DFP_TO_DFP (_Decimal64 f_from)\n-{\n-  union { _Decimal64 c; decDouble f; } from;\n-  union { _Decimal128 c; decQuad f; } to;\n-\n-  from.c = f_from;\n-  to.f = *decDoubleToWider (&from.f, &to.f);\n-  return to.c;\n-}\n-#endif\n-\n-#if defined (L_dd_to_sd)\n-/* Use decNumber to convert directly from _Decimal64 to _Decimal32.  */\n-_Decimal32\n-DFP_TO_DFP (_Decimal64 f_from)\n-{\n-  union { _Decimal32 c; decSingle f; } to;\n-  union { _Decimal64 c; decDouble f; } from;\n-  decContext context;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-  from.c = f_from;\n-  to.f = *decSingleFromWider (&to.f, &from.f, &context);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-  return to.c;\n-}\n-#endif\n-\n-#if defined (L_td_to_sd)\n-/* Use decNumber to convert directly from _Decimal128 to _Decimal32.  */\n-_Decimal32\n-DFP_TO_DFP (_Decimal128 f_from)\n-{\n-  union { _Decimal32 c; decSingle f; } to;\n-  union { _Decimal128 c; decQuad f; } from;\n-  decDouble temp;\n-  decContext context;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-  from.c = f_from;\n-  temp = *decDoubleFromWider (&temp, &from.f, &context);\n-  to.f = *decSingleFromWider (&to.f, &temp, &context);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-  return to.c;\n-}\n-#endif\n-\n-#if defined (L_td_to_dd)\n-/* Use decNumber to convert directly from _Decimal128 to _Decimal64.  */\n-_Decimal64\n-DFP_TO_DFP (_Decimal128 f_from)\n-{\n-  union { _Decimal64 c; decDouble f; } to;\n-  union { _Decimal128 c; decQuad f; } from;\n-  decContext context;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-  from.c = f_from;\n-  to.f = *decDoubleFromWider (&to.f, &from.f, &context);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-  return to.c;\n-}\n-#endif\n-\n-#if defined (L_dd_to_si) || defined (L_td_to_si) \\\n-  || defined (L_dd_to_usi) || defined (L_td_to_usi)\n-/* Use decNumber to convert directly from decimal float to integer types.  */\n-INT_TYPE\n-DFP_TO_INT (DFP_C_TYPE x)\n-{\n-  union { DFP_C_TYPE c; decFloat f; } u;\n-  decContext context;\n-  INT_TYPE i;\n-\n-  decContextDefault (&context, DEC_INIT_DECIMAL128);\n-  context.round = DEC_ROUND_DOWN;\n-  u.c = x;\n-  i = DEC_FLOAT_TO_INT (&u.f, &context, context.round);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-  return i;\n-}\n-#endif\n-\n-#if defined (L_sd_to_si) || (L_sd_to_usi)\n-/* Use decNumber to convert directly from decimal float to integer types.  */\n-INT_TYPE\n-DFP_TO_INT (_Decimal32 x)\n-{\n-  union { _Decimal32 c; decSingle f; } u32;\n-  decDouble f64;\n-  decContext context;\n-  INT_TYPE i;\n-\n-  decContextDefault (&context, DEC_INIT_DECIMAL128);\n-  context.round = DEC_ROUND_DOWN;\n-  u32.c = x;\n-  f64 = *decSingleToWider (&u32.f, &f64);\n-  i = DEC_FLOAT_TO_INT (&f64, &context, context.round);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-  return i;\n-}\n-#endif\n-\n-#if defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n-  || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n-/* decNumber doesn't provide support for conversions to 64-bit integer\n-   types, so do it the hard way.  */\n-INT_TYPE\n-DFP_TO_INT (DFP_C_TYPE x)\n-{\n-  /* decNumber's decimal* types have the same format as C's _Decimal*\n-     types, but they have different calling conventions.  */\n-\n-  /* TODO: Decimal float to integer conversions should raise FE_INVALID\n-     if the result value does not fit into the result type.  */\n-\n-  IEEE_TYPE s;\n-  char buf[BUFMAX];\n-  char *pos;\n-  decNumber qval, n1, n2;\n-  decContext context;\n-\n-  /* Use a large context to avoid losing precision.  */\n-  decContextDefault (&context, DEC_INIT_DECIMAL128);\n-  /* Need non-default rounding mode here.  */\n-  context.round = DEC_ROUND_DOWN;\n-\n-  HOST_TO_IEEE (x, &s);\n-  TO_INTERNAL (&s, &n1);\n-  /* Rescale if the exponent is less than zero.  */\n-  decNumberToIntegralValue (&n2, &n1, &context);\n-  /* Get a value to use for the quantize call.  */\n-  decNumberFromString (&qval, \"1.\", &context);\n-  /* Force the exponent to zero.  */\n-  decNumberQuantize (&n1, &n2, &qval, &context);\n-  /* Get a string, which at this point will not include an exponent.  */\n-  decNumberToString (&n1, buf);\n-  /* Ignore the fractional part.  */\n-  pos = strchr (buf, '.');\n-  if (pos)\n-    *pos = 0;\n-  /* Use a C library function to convert to the integral type.  */\n-  return STR_TO_INT (buf, NULL, 10);\n-}\n-#endif\n-\n-#if defined (L_si_to_dd) || defined (L_si_to_td) \\\n-  || defined (L_usi_to_dd) || defined (L_usi_to_td)\n-/* Use decNumber to convert directly from integer to decimal float types.  */\n-DFP_C_TYPE\n-INT_TO_DFP (INT_TYPE i)\n-{\n-  union { DFP_C_TYPE c; decFloat f; } u;\n-\n-  u.f = *DEC_FLOAT_FROM_INT (&u.f, i);\n-  return u.c;\n-}\n-#endif\n-\n-#if defined (L_si_to_sd) || defined (L_usi_to_sd)\n-_Decimal32\n-/* Use decNumber to convert directly from integer to decimal float types.  */\n-INT_TO_DFP (INT_TYPE i)\n-{\n-  union { _Decimal32 c; decSingle f; } u32;\n-  decDouble f64;\n-  decContext context;\n-\n-  decContextDefault (&context, DEC_INIT_DECIMAL128);\n-  f64 = *DEC_FLOAT_FROM_INT (&f64, i);\n-  u32.f = *decSingleFromWider (&u32.f, &f64, &context);\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-  return u32.c;\n-}\n-#endif\n-\n-#if defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n-  || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n-/* decNumber doesn't provide support for conversions from 64-bit integer\n-   types, so do it the hard way.  */\n-DFP_C_TYPE\n-INT_TO_DFP (INT_TYPE i)\n-{\n-  DFP_C_TYPE f;\n-  IEEE_TYPE s;\n-  char buf[BUFMAX];\n-  decContext context;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-\n-  /* Use a C library function to get a floating point string.  */\n-  sprintf (buf, INT_FMT \".\", CAST_FOR_FMT(i));\n-  /* Convert from the floating point string to a decimal* type.  */\n-  FROM_STRING (&s, buf, &context);\n-  IEEE_TO_HOST (s, &f);\n-\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    dfp_conversion_exceptions (context.status);\n-\n-  return f;\n-}\n-#endif\n-\n-#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n- || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n- || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n-     && LONG_DOUBLE_HAS_XF_MODE) \\\n- || ((defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf)) \\\n-     && LONG_DOUBLE_HAS_TF_MODE)\n-BFP_TYPE\n-DFP_TO_BFP (DFP_C_TYPE f)\n-{\n-  IEEE_TYPE s;\n-  char buf[BUFMAX];\n-\n-  HOST_TO_IEEE (f, &s);\n-  /* Write the value to a string.  */\n-  TO_STRING (&s, buf);\n-  /* Read it as the binary floating point type and return that.  */\n-  return STR_TO_BFP (buf, NULL);\n-}\n-#endif\n-                                                                                \n-#if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n- || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n- || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n-     && LONG_DOUBLE_HAS_XF_MODE) \\\n- || ((defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)) \\\n-     && LONG_DOUBLE_HAS_TF_MODE)\n-DFP_C_TYPE\n-BFP_TO_DFP (BFP_TYPE x)\n-{\n-  DFP_C_TYPE f;\n-  IEEE_TYPE s;\n-  char buf[BUFMAX];\n-  decContext context;\n-\n-  decContextDefault (&context, CONTEXT_INIT);\n-  DFP_INIT_ROUNDMODE (context.round);\n-\n-  /* Use a C library function to write the floating point value to a string.  */\n-  sprintf (buf, BFP_FMT, (BFP_VIA_TYPE) x);\n-\n-  /* Convert from the floating point string to a decimal* type.  */\n-  FROM_STRING (&s, buf, &context);\n-  IEEE_TO_HOST (s, &f);\n-\n-  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n-    {\n-      /* decNumber exception flags we care about here.  */\n-      int ieee_flags;\n-      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n-\t\t      | DEC_IEEE_854_Overflow | DEC_IEEE_854_Underflow;\n-      dec_flags &= context.status;\n-      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n-      if (ieee_flags != 0)\n-        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n-    }\n-\n-  return f;\n-}\n-#endif\n-\n-#if defined (L_unord_sd) || defined (L_unord_dd) || defined (L_unord_td)\n-CMPtype\n-DFP_UNORD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n-{\n-  decNumber arg1, arg2;\n-  IEEE_TYPE a, b;\n-\n-  HOST_TO_IEEE (arg_a, &a);\n-  HOST_TO_IEEE (arg_b, &b);\n-  TO_INTERNAL (&a, &arg1);\n-  TO_INTERNAL (&b, &arg2);\n-  return (decNumberIsNaN (&arg1) || decNumberIsNaN (&arg2));\n-}\n-#endif /* L_unord_sd || L_unord_dd || L_unord_td */"}, {"sha": "45b79086bc928e2b102e3e8893dc99a037dca499", "filename": "gcc/config/dfp-bit.h", "status": "removed", "additions": 0, "deletions": 626, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c4ecb13a60ac686ec32b61ece46372d0d19760/gcc%2Fconfig%2Fdfp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c4ecb13a60ac686ec32b61ece46372d0d19760/gcc%2Fconfig%2Fdfp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.h?ref=12c4ecb13a60ac686ec32b61ece46372d0d19760", "patch": "@@ -1,626 +0,0 @@\n-/* Header file for dfp-bit.c.\n-   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef _DFPBIT_H\n-#define _DFPBIT_H\n-\n-#include <float.h>\n-#include <fenv.h>\n-#include <decRound.h>\n-#include <decExcept.h>\n-#include \"tconfig.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n-#endif\n-\n-/* We need to know the size of long double that the C library supports.\n-   Don't use LIBGCC2_HAS_XF_MODE or LIBGCC2_HAS_TF_MODE here because\n-   some targets set both of those.  */\n-\n-#define LONG_DOUBLE_HAS_XF_MODE \\\n-  (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n-\n-#define LONG_DOUBLE_HAS_TF_MODE \\\n-  (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-\n-/* Depending on WIDTH, define a number of macros:\n-\n-   DFP_C_TYPE: type of the arguments to the libgcc functions;\n-\t(eg _Decimal32)\n-\n-   IEEE_TYPE: the corresponding (encoded) IEEE754 type;\n-\t(eg decimal32)\n-   \n-   TO_INTERNAL: the name of the decNumber function to convert an\n-   encoded value into the decNumber internal representation;\n-\n-   TO_ENCODED: the name of the decNumber function to convert an\n-   internally represented decNumber into the encoded\n-   representation.\n-\n-   FROM_STRING: the name of the decNumber function to read an\n-   encoded value from a string.\n-\n-   TO_STRING: the name of the decNumber function to write an\n-   encoded value to a string.  */\n-\n-#if WIDTH == 32\n-#define DFP_C_TYPE\t_Decimal32\n-#define IEEE_TYPE\tdecimal32\n-#define HOST_TO_IEEE\t__host_to_ieee_32\n-#define IEEE_TO_HOST\t__ieee_to_host_32\n-#define TO_INTERNAL\t__decimal32ToNumber\n-#define TO_ENCODED\t__decimal32FromNumber\n-#define FROM_STRING\t__decimal32FromString\n-#define TO_STRING\t__decimal32ToString\n-#elif WIDTH == 64\n-#define DFP_C_TYPE\t_Decimal64\n-#define IEEE_TYPE\tdecimal64\n-#define HOST_TO_IEEE\t__host_to_ieee_64\n-#define IEEE_TO_HOST\t__ieee_to_host_64\n-#define TO_INTERNAL\t__decimal64ToNumber\n-#define TO_ENCODED\t__decimal64FromNumber\n-#define FROM_STRING\t__decimal64FromString\n-#define TO_STRING\t__decimal64ToString\n-#elif WIDTH == 128\n-#define DFP_C_TYPE\t_Decimal128\n-#define IEEE_TYPE\tdecimal128\n-#define HOST_TO_IEEE\t__host_to_ieee_128\n-#define IEEE_TO_HOST\t__ieee_to_host_128\n-#define TO_INTERNAL\t__decimal128ToNumber\n-#define TO_ENCODED\t__decimal128FromNumber\n-#define FROM_STRING\t__decimal128FromString\n-#define TO_STRING\t__decimal128ToString\n-#else\n-#error invalid decimal float word width\n-#endif\n-\n-/* We define __DEC_EVAL_METHOD__ to 2, saying that we evaluate all\n-   operations and constants to the range and precision of the _Decimal128\n-   type.  Make it so.  */\n-#if WIDTH == 32\n-#define CONTEXT_INIT DEC_INIT_DECIMAL32\n-#elif WIDTH == 64\n-#define CONTEXT_INIT DEC_INIT_DECIMAL64\n-#elif WIDTH == 128\n-#define CONTEXT_INIT DEC_INIT_DECIMAL128\n-#endif\n-\n-#ifndef DFP_INIT_ROUNDMODE\n-#define DFP_INIT_ROUNDMODE(A) A = DEC_ROUND_HALF_EVEN\n-#endif\n-\n-#ifdef DFP_EXCEPTIONS_ENABLED\n-/* Return IEEE exception flags based on decNumber status flags.  */\n-#define DFP_IEEE_FLAGS(DEC_FLAGS) __extension__\t\t\t\\\n-({int _fe_flags = 0;\t\t\t\t\t\t\\\n-  if ((dec_flags & DEC_IEEE_854_Division_by_zero) != 0)\t\t\\\n-    _fe_flags |= FE_DIVBYZERO;\t\t\t\t\t\\\n-  if ((dec_flags & DEC_IEEE_854_Inexact) != 0)\t\t\t\\\n-    _fe_flags |= FE_INEXACT;\t\t\t\t\t\\\n-  if ((dec_flags & DEC_IEEE_854_Invalid_operation) != 0)\t\\\n-    _fe_flags |= FE_INVALID;\t\t\t\t\t\\\n-  if ((dec_flags & DEC_IEEE_854_Overflow) != 0)\t\t\t\\\n-    _fe_flags |= FE_OVERFLOW;\t\t\t\t\t\\\n-  if ((dec_flags & DEC_IEEE_854_Underflow) != 0)\t\t\\\n-    _fe_flags |= FE_UNDERFLOW;\t\t\t\t\t\\\n-  _fe_flags; })\n-#else\n-#define DFP_EXCEPTIONS_ENABLED 0\n-#define DFP_IEEE_FLAGS(A) 0\n-#define DFP_HANDLE_EXCEPTIONS(A) do {} while (0)\n-#endif\n-\n-/* Conversions between different decimal float types use WIDTH_TO to\n-   determine additional macros to define.  */\n-\n-#if defined (L_dd_to_sd) || defined (L_td_to_sd)\n-#define WIDTH_TO 32\n-#elif defined (L_sd_to_dd) || defined (L_td_to_dd)\n-#define WIDTH_TO 64\n-#elif defined (L_sd_to_td) || defined (L_dd_to_td)\n-#define WIDTH_TO 128\n-#endif\n-\n-/* If WIDTH_TO is defined, define additional macros:\n-\n-   DFP_C_TYPE_TO: type of the result of dfp to dfp conversion.\n-\n-   IEEE_TYPE_TO: the corresponding (encoded) IEEE754 type.\n-\n-   TO_ENCODED_TO: the name of the decNumber function to convert an\n-   internally represented decNumber into the encoded representation\n-   for the destination.  */\n-\n-#if WIDTH_TO == 32\n-#define DFP_C_TYPE_TO\t_Decimal32\n-#define IEEE_TYPE_TO\tdecimal32\n-#define TO_ENCODED_TO\t__decimal32FromNumber\n-#define IEEE_TO_HOST_TO __ieee_to_host_32\n-#elif WIDTH_TO == 64\n-#define DFP_C_TYPE_TO\t_Decimal64\n-#define IEEE_TYPE_TO\tdecimal64\n-#define TO_ENCODED_TO\t__decimal64FromNumber\n-#define IEEE_TO_HOST_TO __ieee_to_host_64\n-#elif WIDTH_TO == 128\n-#define DFP_C_TYPE_TO\t_Decimal128\n-#define IEEE_TYPE_TO\tdecimal128\n-#define TO_ENCODED_TO\t__decimal128FromNumber\n-#define IEEE_TO_HOST_TO __ieee_to_host_128\n-#endif\n-\n-/* Conversions between decimal float types and integral types use INT_KIND\n-   to determine the data type and C functions to use.  */\n-\n-#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si)  \\\n-   || defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td)\n-#define INT_KIND 1\n-#elif defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n-   || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td)\n-#define INT_KIND 2\n-#elif defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n-   || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td)\n-#define INT_KIND 3\n-#elif defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi) \\\n-   || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n-#define INT_KIND 4\n-#endif\n-\n-/*  If INT_KIND is defined, define additional macros:\n-\n-    INT_TYPE: The integer data type.\n-\n-    INT_FMT: The format string for writing the integer to a string.\n-\n-    CAST_FOR_FMT: Cast variable of INT_KIND to C type for sprintf.\n-    This works for ILP32 and LP64, won't for other type size systems.\n-\n-    STR_TO_INT: The function to read the integer from a string.  */\n-\n-#if INT_KIND == 1\n-#define INT_TYPE SItype\n-#define INT_FMT \"%d\"\n-#define CAST_FOR_FMT(A) (int)A\n-#define STR_TO_INT strtol\n-#elif INT_KIND == 2\n-#define INT_TYPE DItype\n-#define INT_FMT \"%lld\"\n-#define CAST_FOR_FMT(A) (long long)A\n-#define STR_TO_INT strtoll\n-#elif INT_KIND == 3\n-#define INT_TYPE USItype\n-#define INT_FMT \"%u\"\n-#define CAST_FOR_FMT(A) (unsigned int)A\n-#define STR_TO_INT strtoul\n-#elif INT_KIND == 4\n-#define INT_TYPE UDItype\n-#define INT_FMT \"%llu\"\n-#define CAST_FOR_FMT(A) (unsigned long long)A\n-#define STR_TO_INT strtoull\n-#endif\n-\n-/* Conversions between decimal float types and binary float types use\n-   BFP_KIND to determine the data type and C functions to use.  */\n-\n-#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n- || defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td)\n-#define BFP_KIND 1\n-#elif defined (L_sd_to_df) || defined (L_dd_to_df ) || defined (L_td_to_df) \\\n- ||   defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td)\n-#define BFP_KIND 2\n-#elif defined (L_sd_to_xf) || defined (L_dd_to_xf ) || defined (L_td_to_xf) \\\n- ||   defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)\n-#define BFP_KIND 3\n-#elif defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf) \\\n- ||   defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)\n-#define BFP_KIND 4\n-#endif\n-\n-/*  If BFP_KIND is defined, define additional macros:\n-\n-    BFP_TYPE: The binary floating point data type.\n-\n-    BFP_FMT: The format string for writing the value to a string.\n-    The number of decimal digits printed is\n-       ceil (nbits / log2 (10.) + 1)\n-    as described in David Matula's CACM 19(3) 716-723 June 1968 paper.\n-\n-    BFP_VIA_TYPE: Type to which to cast a variable of BPF_TYPE for a\n-    call to sprintf.\n-    \n-    STR_TO_BFP: The function to read the value from a string.  */\n-\n-#if BFP_KIND == 1\n-#define BFP_TYPE SFtype\n-#define BFP_FMT \"%.9e\"\n-#define BFP_VIA_TYPE double\n-#define STR_TO_BFP strtof\n-\n-#elif BFP_KIND == 2\n-#define BFP_TYPE DFtype\n-#define BFP_FMT \"%.17e\"\n-#define BFP_VIA_TYPE double\n-#define STR_TO_BFP strtod\n-\n-#elif BFP_KIND == 3\n-#if LONG_DOUBLE_HAS_XF_MODE\n-#define BFP_TYPE XFtype\n-#define BFP_FMT \"%.21Le\"\n-#define BFP_VIA_TYPE long double\n-#define STR_TO_BFP strtold\n-#endif /* LONG_DOUBLE_HAS_XF_MODE */\n-\n-#elif BFP_KIND == 4\n-#if LONG_DOUBLE_HAS_TF_MODE\n-#define BFP_TYPE TFtype\n-#if LDBL_MANT_DIG == 106\n-#define BFP_FMT \"%.33Le\"\n-#elif LDBL_MANT_DIG == 113\n-#define BFP_FMT \"%.36Le\"\n-#else\n-#error \"unknown long double size, cannot define BFP_FMT\"\n-#endif /* LDBL_MANT_DIG */\n-#define STR_TO_BFP strtold\n-#define BFP_VIA_TYPE long double\n-#endif /* LONG_DOUBLE_HAS_TF_MODE */\n-\n-#endif /* BFP_KIND */\n-\n-#if WIDTH == 128 || WIDTH_TO == 128\n-#include \"decimal128.h\"\n-#include \"decQuad.h\"\n-#endif\n-#if WIDTH == 64 || WIDTH_TO == 64\n-#include \"decimal64.h\"\n-#include \"decDouble.h\"\n-#endif\n-#if WIDTH == 32 || WIDTH_TO == 32\n-#include \"decimal32.h\"\n-#include \"decSingle.h\"\n-#endif\n-#include \"decNumber.h\"\n-\n-/* Names of arithmetic functions.  */\n-\n-#if ENABLE_DECIMAL_BID_FORMAT\n-#define DPD_BID_NAME(DPD,BID) BID\n-#else\n-#define DPD_BID_NAME(DPD,BID) DPD\n-#endif\n-\n-#if WIDTH == 32\n-#define DFP_ADD\t\tDPD_BID_NAME(__dpd_addsd3,__bid_addsd3)\n-#define DFP_SUB\t\tDPD_BID_NAME(__dpd_subsd3,__bid_subsd3)\n-#define DFP_MULTIPLY\tDPD_BID_NAME(__dpd_mulsd3,__bid_mulsd3)\n-#define DFP_DIVIDE\tDPD_BID_NAME(__dpd_divsd3,__bid_divsd3)\n-#define DFP_EQ\t\tDPD_BID_NAME(__dpd_eqsd2,__bid_eqsd2)\n-#define DFP_NE\t\tDPD_BID_NAME(__dpd_nesd2,__bid_nesd2)\n-#define DFP_LT\t\tDPD_BID_NAME(__dpd_ltsd2,__bid_ltsd2)\n-#define DFP_GT\t\tDPD_BID_NAME(__dpd_gtsd2,__bid_gtsd2)\n-#define DFP_LE\t\tDPD_BID_NAME(__dpd_lesd2,__bid_lesd2)\n-#define DFP_GE\t\tDPD_BID_NAME(__dpd_gesd2,__bid_gesd2)\n-#define DFP_UNORD\tDPD_BID_NAME(__dpd_unordsd2,__bid_unordsd2)\n-#elif WIDTH == 64\n-#define DFP_ADD\t\tDPD_BID_NAME(__dpd_adddd3,__bid_adddd3)\n-#define DFP_SUB\t\tDPD_BID_NAME(__dpd_subdd3,__bid_subdd3)\n-#define DFP_MULTIPLY\tDPD_BID_NAME(__dpd_muldd3,__bid_muldd3)\n-#define DFP_DIVIDE\tDPD_BID_NAME(__dpd_divdd3,__bid_divdd3)\n-#define DFP_EQ\t\tDPD_BID_NAME(__dpd_eqdd2,__bid_eqdd2)\n-#define DFP_NE\t\tDPD_BID_NAME(__dpd_nedd2,__bid_nedd2)\n-#define DFP_LT\t\tDPD_BID_NAME(__dpd_ltdd2,__bid_ltdd2)\n-#define DFP_GT\t\tDPD_BID_NAME(__dpd_gtdd2,__bid_gtdd2)\n-#define DFP_LE\t\tDPD_BID_NAME(__dpd_ledd2,__bid_ledd2)\n-#define DFP_GE\t\tDPD_BID_NAME(__dpd_gedd2,__bid_gedd2)\n-#define DFP_UNORD\tDPD_BID_NAME(__dpd_unorddd2,__bid_unorddd2)\n-#elif WIDTH == 128\n-#define DFP_ADD\t\tDPD_BID_NAME(__dpd_addtd3,__bid_addtd3)\n-#define DFP_SUB\t\tDPD_BID_NAME(__dpd_subtd3,__bid_subtd3)\n-#define DFP_MULTIPLY\tDPD_BID_NAME(__dpd_multd3,__bid_multd3)\n-#define DFP_DIVIDE\tDPD_BID_NAME(__dpd_divtd3,__bid_divtd3)\n-#define DFP_EQ\t\tDPD_BID_NAME(__dpd_eqtd2,__bid_eqtd2)\n-#define DFP_NE\t\tDPD_BID_NAME(__dpd_netd2,__bid_netd2)\n-#define DFP_LT\t\tDPD_BID_NAME(__dpd_lttd2,__bid_lttd2)\n-#define DFP_GT\t\tDPD_BID_NAME(__dpd_gttd2,__bid_gttd2)\n-#define DFP_LE\t\tDPD_BID_NAME(__dpd_letd2,__bid_letd2)\n-#define DFP_GE\t\tDPD_BID_NAME(__dpd_getd2,__bid_getd2)\n-#define DFP_UNORD\tDPD_BID_NAME(__dpd_unordtd2,__bid_unordtd2)\n-#endif\n-\n-/* Names of decNumber functions for DPD arithmetic.  */\n-\n-#if WIDTH == 32\n-#define decFloat\t\tdecDouble\n-#define DFP_BINARY_OP\t\td32_binary_op\n-#define DFP_COMPARE_OP\t\td32_compare_op\n-#define DEC_FLOAT_ADD\t\tdecDoubleAdd\n-#define DEC_FLOAT_SUBTRACT\tdecDoubleSubtract\n-#define DEC_FLOAT_MULTIPLY\tdecDoubleMultiply\n-#define DEC_FLOAT_DIVIDE\tdecDoubleDivide\n-#define DEC_FLOAT_COMPARE\tdecDoubleCompare\n-#define DEC_FLOAT_IS_ZERO\tdecDoubleIsZero\n-#define DEC_FLOAT_IS_NAN\tdecDoubleIsNaN\n-#define DEC_FLOAT_IS_SIGNED\tdecDoubleIsSigned\n-#elif WIDTH == 64\n-#define DFP_BINARY_OP\t\tdnn_binary_op\n-#define DFP_COMPARE_OP\t\tdnn_compare_op\n-#define decFloat\t\tdecDouble\n-#define DEC_FLOAT_ADD\t\tdecDoubleAdd\n-#define DEC_FLOAT_SUBTRACT\tdecDoubleSubtract\n-#define DEC_FLOAT_MULTIPLY\tdecDoubleMultiply\n-#define DEC_FLOAT_DIVIDE\tdecDoubleDivide\n-#define DEC_FLOAT_COMPARE\tdecDoubleCompare\n-#define DEC_FLOAT_IS_ZERO\tdecDoubleIsZero\n-#define DEC_FLOAT_IS_NAN\tdecDoubleIsNaN\n-#define DEC_FLOAT_IS_SIGNED\tdecDoubleIsSigned\n-#elif WIDTH == 128\n-#define DFP_BINARY_OP\t\tdnn_binary_op\n-#define DFP_COMPARE_OP\t\tdnn_compare_op\n-#define decFloat\t\tdecQuad\n-#define DEC_FLOAT_ADD\t\tdecQuadAdd\n-#define DEC_FLOAT_SUBTRACT\tdecQuadSubtract\n-#define DEC_FLOAT_MULTIPLY\tdecQuadMultiply\n-#define DEC_FLOAT_DIVIDE\tdecQuadDivide\n-#define DEC_FLOAT_COMPARE\tdecQuadCompare\n-#define DEC_FLOAT_IS_ZERO\tdecQuadIsZero\n-#define DEC_FLOAT_IS_NAN\tdecQuadIsNaN\n-#define DEC_FLOAT_IS_SIGNED\tdecQuadIsSigned\n-#endif\n-\n-/* Names of functions to convert between different decimal float types.  */\n-\n-#if WIDTH == 32\n-#if WIDTH_TO == 64\n-#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsddd2,__bid_extendsddd2)\n-#elif WIDTH_TO == 128\n-#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsdtd2,__bid_extendsdtd2)\n-#endif\n-#elif WIDTH == 64\t\n-#if WIDTH_TO == 32\n-#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_truncddsd2,__bid_truncddsd2)\n-#elif WIDTH_TO == 128\n-#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_extendddtd2,__bid_extendddtd2)\n-#endif\n-#elif WIDTH == 128\n-#if WIDTH_TO == 32\n-#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctdsd2,__bid_trunctdsd2)\n-#elif WIDTH_TO == 64\n-#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctddd2,__bid_trunctddd2)\n-#endif\n-#endif\n-\n-/* Names of functions to convert between decimal float and integers.  */\n-\n-#if WIDTH == 32\n-#if INT_KIND == 1\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsisd,__bid_floatsisd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixsdsi,__bid_fixsdsi)\n-#define DEC_FLOAT_FROM_INT decDoubleFromInt32\n-#define DEC_FLOAT_TO_INT   decDoubleToInt32\n-#elif INT_KIND == 2\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatdisd,__bid_floatdisd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixsddi,__bid_fixsddi)\n-#elif INT_KIND == 3\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssisd,__bid_floatunssisd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunssdsi,__bid_fixunssdsi)\n-#define DEC_FLOAT_FROM_INT decDoubleFromUInt32\n-#define DEC_FLOAT_TO_INT   decDoubleToUInt32\n-#elif INT_KIND == 4\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsdisd,__bid_floatunsdisd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunssddi,__bid_fixunssddi)\n-#endif\n-#elif WIDTH == 64\n-#define decFloat\tdecDouble\n-#if INT_KIND == 1\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsidd,__bid_floatsidd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixddsi,__bid_fixddsi)\n-#define DEC_FLOAT_FROM_INT decDoubleFromInt32\n-#define DEC_FLOAT_TO_INT   decDoubleToInt32\n-#elif INT_KIND == 2\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatdidd,__bid_floatdidd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixdddi,__bid_fixdddi)\n-#elif INT_KIND == 3\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssidd,__bid_floatunssidd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunsddsi,__bid_fixunsddsi)\n-#define DEC_FLOAT_FROM_INT decDoubleFromUInt32\n-#define DEC_FLOAT_TO_INT   decDoubleToUInt32\n-#elif INT_KIND == 4\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsdidd,__bid_floatunsdidd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunsdddi,__bid_fixunsdddi)\n-#endif\n-#elif WIDTH == 128\n-#define decFloat\tdecQuad\n-#if INT_KIND == 1\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsitd,__bid_floatsitd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixtdsi,__bid_fixtdsi)\n-#define DEC_FLOAT_FROM_INT decQuadFromInt32\n-#define DEC_FLOAT_TO_INT   decQuadToInt32\n-#elif INT_KIND == 2\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatditd,__bid_floatditd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixtddi,__bid_fixtddi)\n-#elif INT_KIND == 3\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssitd,__bid_floatunssitd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunstdsi,__bid_fixunstdsi)\n-#define DEC_FLOAT_FROM_INT decQuadFromUInt32\n-#define DEC_FLOAT_TO_INT   decQuadToUInt32\n-#elif INT_KIND == 4\n-#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsditd,__bid_floatunsditd)\n-#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunstddi,__bid_fixunstddi)\n-#endif\n-#endif\n-\n-/* Names of functions to convert between decimal float and binary float.  */\n-\n-#if WIDTH == 32\n-#if BFP_KIND == 1\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsfsd,__bid_extendsfsd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_truncsdsf,__bid_truncsdsf)\n-#elif BFP_KIND == 2\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncdfsd,__bid_truncdfsd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsddf,__bid_extendsddf)\n-#elif BFP_KIND == 3\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncxfsd,__bid_truncxfsd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsdxf,__bid_extendsdxf)\n-#elif BFP_KIND == 4\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctfsd,__bid_trunctfsd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsdtf,__bid_extendsdtf)\n-#endif /* BFP_KIND */\n-\n-#elif WIDTH == 64\n-#if BFP_KIND == 1\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsfdd,__bid_extendsfdd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_truncddsf,__bid_truncddsf)\n-#elif BFP_KIND == 2\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extenddfdd,__bid_extenddfdd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_truncdddf,__bid_truncdddf)\n-#elif BFP_KIND == 3\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncxfdd,__bid_truncxfdd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendddxf,__bid_extendddxf)\n-#elif BFP_KIND == 4\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctfdd,__bid_trunctfdd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendddtf,__bid_extendddtf)\n-#endif /* BFP_KIND */\n-\n-#elif WIDTH == 128\n-#if BFP_KIND == 1\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsftd,__bid_extendsftd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdsf,__bid_trunctdsf)\n-#elif BFP_KIND == 2\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extenddftd,__bid_extenddftd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctddf,__bid_trunctddf)\n-#elif BFP_KIND == 3\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendxftd,__bid_extendxftd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdxf,__bid_trunctdxf)\n-#elif BFP_KIND == 4\n-#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendtftd,__bid_extendtftd)\n-#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdtf,__bid_trunctdtf)\n-#endif /* BFP_KIND */\n-\n-#endif /* WIDTH */\n-\n-/* Some handy typedefs.  */\n-\n-typedef float SFtype __attribute__ ((mode (SF)));\n-typedef float DFtype __attribute__ ((mode (DF)));\n-#if LONG_DOUBLE_HAS_XF_MODE\n-typedef float XFtype __attribute__ ((mode (XF)));\n-#endif /* LONG_DOUBLE_HAS_XF_MODE */\n-#if LONG_DOUBLE_HAS_TF_MODE\n-typedef float TFtype __attribute__ ((mode (TF)));\n-#endif /* LONG_DOUBLE_HAS_TF_MODE */\n-\n-typedef int SItype __attribute__ ((mode (SI)));\n-typedef int DItype __attribute__ ((mode (DI)));\n-typedef unsigned int USItype __attribute__ ((mode (SI)));\n-typedef unsigned int UDItype __attribute__ ((mode (DI)));\n-\n-/* The type of the result of a decimal float comparison.  This must\n-   match `__libgcc_cmp_return__' in GCC for the target.  */\n-\n-typedef int CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n-\n-/* Prototypes.  */\n-\n-#if defined (L_mul_sd) || defined (L_mul_dd) || defined (L_mul_td)\n-extern DFP_C_TYPE DFP_MULTIPLY (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_div_sd) || defined (L_div_dd) || defined (L_div_td)\n-extern DFP_C_TYPE DFP_DIVIDE (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_addsub_sd) || defined (L_addsub_dd) || defined (L_addsub_td)\n-extern DFP_C_TYPE DFP_ADD (DFP_C_TYPE, DFP_C_TYPE);\n-extern DFP_C_TYPE DFP_SUB (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n-extern CMPtype DFP_EQ (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_ne_sd) || defined (L_ne_dd) || defined (L_ne_td)\n-extern CMPtype DFP_NE (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_lt_sd) || defined (L_lt_dd) || defined (L_lt_td)\n-extern CMPtype DFP_LT (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_gt_sd) || defined (L_gt_dd) || defined (L_gt_td)\n-extern CMPtype DFP_GT (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_le_sd) || defined (L_le_dd) || defined (L_le_td)\n-extern CMPtype DFP_LE (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_ge_sd) || defined (L_ge_dd) || defined (L_ge_td)\n-extern CMPtype DFP_GE (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_unord_sd) || defined (L_unord_dd) || defined (L_unord_td)\n-extern CMPtype DFP_UNORD (DFP_C_TYPE, DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_sd_to_dd) || defined (L_sd_to_td) || defined (L_dd_to_sd) \\\n- || defined (L_dd_to_td) || defined (L_td_to_sd) || defined (L_td_to_dd)\n-extern DFP_C_TYPE_TO DFP_TO_DFP (DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si) \\\n- || defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n- || defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n- || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n-extern INT_TYPE DFP_TO_INT (DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td) \\\n- || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n- || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td) \\\n- || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n-extern DFP_C_TYPE INT_TO_DFP (INT_TYPE);\n-#endif\n-\n-#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n- || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n- || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n-     && LONG_DOUBLE_HAS_XF_MODE) \\\n- || ((defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf)) \\\n-     && LONG_DOUBLE_HAS_TF_MODE)\n-extern BFP_TYPE DFP_TO_BFP (DFP_C_TYPE);\n-#endif\n-\n-#if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n- || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n- || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n-     && LONG_DOUBLE_HAS_XF_MODE) \\\n- || ((defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)) \\\n-     && LONG_DOUBLE_HAS_TF_MODE)\n-extern DFP_C_TYPE BFP_TO_DFP (BFP_TYPE);\n-#endif\n-\n-#endif /* _DFPBIT_H */"}, {"sha": "6bf6246d8c7055944b736e012cfb559ebce0c184", "filename": "gcc/config/t-dfprules", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c4ecb13a60ac686ec32b61ece46372d0d19760/gcc%2Fconfig%2Ft-dfprules", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c4ecb13a60ac686ec32b61ece46372d0d19760/gcc%2Fconfig%2Ft-dfprules", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-dfprules?ref=12c4ecb13a60ac686ec32b61ece46372d0d19760", "patch": "@@ -1,10 +0,0 @@\n-# Use DFP_ENABLE to build decimal floating point support routines for\n-# all decimal floating point types (32-bit, 64-bit and 128-bit). We\n-# use `true' for clarity, but any value will do.\n-#\n-DFP_ENABLE = true\n-\n-# DFP_CFLAGS can be used to pass target-specific CFLAGS when compiling\n-# dfp-bit.c.  This is useful for overriding the definition of macros.\n-#\n-# DFP_CFLAGS = -DFOO=bar"}]}