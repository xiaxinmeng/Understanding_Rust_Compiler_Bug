{"sha": "5194b51ed9714808d88827531e91474895b6c706", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5NGI1MWVkOTcxNDgwOGQ4ODgyNzUzMWU5MTQ3NDg5NWI2YzcwNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-16T21:55:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-17T03:24:28Z"}, "message": "PR c++/93286 - ICE with __is_constructible and variadic template.\n\nHere we had been recursing in tsubst_copy_and_build if type2 was a TREE_LIST\nbecause that function knew how to deal with pack expansions, and tsubst\ndidn't.  But tsubst_copy_and_build expects to be dealing with expressions,\nso we crash when trying to convert_from_reference a type.\n\n\t* pt.c (tsubst) [TREE_LIST]: Handle pack expansion.\n\t(tsubst_copy_and_build) [TRAIT_EXPR]: Always use tsubst for type2.", "tree": {"sha": "1676c1dcbae6a4b3468682a5b9596653f6d88db9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1676c1dcbae6a4b3468682a5b9596653f6d88db9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5194b51ed9714808d88827531e91474895b6c706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5194b51ed9714808d88827531e91474895b6c706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5194b51ed9714808d88827531e91474895b6c706", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5194b51ed9714808d88827531e91474895b6c706/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1113de9499dadd2402fa97d0009d5d0b5af0987b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1113de9499dadd2402fa97d0009d5d0b5af0987b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1113de9499dadd2402fa97d0009d5d0b5af0987b"}], "stats": {"total": 96, "additions": 89, "deletions": 7}, "files": [{"sha": "c37e461bcc5303e1a73968a7483e44c8df574e80", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5194b51ed9714808d88827531e91474895b6c706/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5194b51ed9714808d88827531e91474895b6c706/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5194b51ed9714808d88827531e91474895b6c706", "patch": "@@ -1,5 +1,9 @@\n 2020-01-16  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/93286 - ICE with __is_constructible and variadic template.\n+\t* pt.c (tsubst) [TREE_LIST]: Handle pack expansion.\n+\t(tsubst_copy_and_build) [TRAIT_EXPR]: Always use tsubst for type2.\n+\n \tPR c++/93280 - ICE with aggregate assignment and DMI.\n \t* init.c (get_nsdmi): Set TARGET_EXPR_DIRECT_INIT_P here.\n \t* typeck2.c (digest_nsdmi_init): Not here."}, {"sha": "872f8ff8f52c7c907b10c99b5d432280f0ba4642", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5194b51ed9714808d88827531e91474895b6c706/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5194b51ed9714808d88827531e91474895b6c706/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5194b51ed9714808d88827531e91474895b6c706", "patch": "@@ -15350,6 +15350,71 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (t == void_list_node)\n \t  return t;\n \n+\tif ((TREE_PURPOSE (t) && PACK_EXPANSION_P (TREE_PURPOSE (t)))\n+\t    || (TREE_VALUE (t) && PACK_EXPANSION_P (TREE_VALUE (t))))\n+\t  {\n+\t    /* We have pack expansions, so expand those and\n+\t       create a new list out of it.  */\n+\n+\t    /* Expand the argument expressions.  */\n+\t    tree purposevec = NULL_TREE;\n+\t    if (TREE_PURPOSE (t))\n+\t      purposevec = tsubst_pack_expansion (TREE_PURPOSE (t), args,\n+\t\t\t\t\t\t  complain, in_decl);\n+\t    if (purposevec == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    tree valuevec = NULL_TREE;\n+\t    if (TREE_VALUE (t))\n+\t      valuevec = tsubst_pack_expansion (TREE_VALUE (t), args,\n+\t\t\t\t\t\tcomplain, in_decl);\n+\t    if (valuevec == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    /* Build the rest of the list.  */\n+\t    tree chain = TREE_CHAIN (t);\n+\t    if (chain && chain != void_type_node)\n+\t      chain = tsubst (chain, args, complain, in_decl);\n+\t    if (chain == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    /* Determine the number of arguments.  */\n+\t    int len = -1;\n+\t    if (purposevec && TREE_CODE (purposevec) == TREE_VEC)\n+\t      {\n+\t\tlen = TREE_VEC_LENGTH (purposevec);\n+\t\tgcc_assert (!valuevec || len == TREE_VEC_LENGTH (valuevec));\n+\t      }\n+\t    else if (TREE_CODE (valuevec) == TREE_VEC)\n+\t      len = TREE_VEC_LENGTH (valuevec);\n+\t    else\n+\t      {\n+\t\t/* Since we only performed a partial substitution into\n+\t\t   the argument pack, we only RETURN (a single list\n+\t\t   node.  */\n+\t\tif (purposevec == TREE_PURPOSE (t)\n+\t\t    && valuevec == TREE_VALUE (t)\n+\t\t    && chain == TREE_CHAIN (t))\n+\t\t  return t;\n+\n+\t\treturn tree_cons (purposevec, valuevec, chain);\n+\t      }\n+\n+\t    /* Convert the argument vectors into a TREE_LIST.  */\n+\t    for (int i = len; i-- > 0; )\n+\t      {\n+\t\tpurpose = (purposevec ? TREE_VEC_ELT (purposevec, i)\n+\t\t\t   : NULL_TREE);\n+\t\tvalue = (valuevec ? TREE_VEC_ELT (valuevec, i)\n+\t\t\t : NULL_TREE);\n+\n+\t\t/* Build the list (backwards).  */\n+\t\tchain = hash_tree_cons (purpose, value, chain);\n+\t      }\n+\n+\t    return chain;\n+\t  }\n+\n \tpurpose = TREE_PURPOSE (t);\n \tif (purpose)\n \t  {\n@@ -20158,13 +20223,8 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree type1 = tsubst (TRAIT_EXPR_TYPE1 (t), args,\n \t\t\t     complain, in_decl);\n-\n-\ttree type2 = TRAIT_EXPR_TYPE2 (t);\n-\tif (type2 && TREE_CODE (type2) == TREE_LIST)\n-\t  type2 = RECUR (type2);\n-\telse if (type2)\n-\t  type2 = tsubst (type2, args, complain, in_decl);\n-\n+\ttree type2 = tsubst (TRAIT_EXPR_TYPE2 (t), args,\n+\t\t\t     complain, in_decl);\n \tRETURN (finish_trait_expr (TRAIT_EXPR_LOCATION (t),\n \t\t\t\t   TRAIT_EXPR_KIND (t), type1, type2));\n       }"}, {"sha": "6dfe3c0166186fc94acb877a88ba6013cb2992de", "filename": "gcc/testsuite/g++.dg/ext/is_constructible4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5194b51ed9714808d88827531e91474895b6c706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5194b51ed9714808d88827531e91474895b6c706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_constructible4.C?ref=5194b51ed9714808d88827531e91474895b6c706", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/93286\n+// { dg-do compile { target c++14 } }\n+\n+struct A { static const bool value = true; };\n+template <bool> using __bool_constant = A;\n+template <typename... _Args>\n+struct B : __bool_constant<__is_constructible(int, _Args...)> {};\n+template <bool> using enable_if_t = int;\n+template <typename... _Args> bool is_constructible_v = B<_Args...>::value;\n+class C {\n+  template <typename _Tp, typename = enable_if_t<is_constructible_v<_Tp>>>\n+  C(_Tp &&);\n+};\n+using Effect_t = C;\n+void fn1(Effect_t effect) {\n+  int i;\n+  [](int &effect) {}(i);\n+}"}]}