{"sha": "185ebd6c71d791ea2f333a23382589620e9bf848", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg1ZWJkNmM3MWQ3OTFlYTJmMzMzYTIzMzgyNTg5NjIwZTliZjg0OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-12-29T11:36:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-12-29T11:36:22Z"}, "message": "Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>:\n\n        * rtl.def (CONSTANT_P_RTX): Clarify commentary.\n        * expr.c (expand_builtin, case BUILT_IN_CONSTANT_P): Rework to\n        consider constant CONSTRUCTOR constant and to defer some cases\n        to cse.\n        * cse.c (fold_rtx, case CONST): Add handling for CONSTANT_P_RTX.\n        * regclass.c (reg_scan_mark_refs, case CONST): Likewise.\nRichard Henderson  <rth@cygnus.com>\n        * expr.c (init_expr_once): Kill can_handle_constant_p recognition.\n        * cse.c (fold_rtx, case 'x'): Remove standalone CONSTANT_P_RTX code.\n\nFrom-SVN: r24439", "tree": {"sha": "8baca97ed11c13d1b3be83dcd58d2863c4017a2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8baca97ed11c13d1b3be83dcd58d2863c4017a2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/185ebd6c71d791ea2f333a23382589620e9bf848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/185ebd6c71d791ea2f333a23382589620e9bf848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/185ebd6c71d791ea2f333a23382589620e9bf848", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/185ebd6c71d791ea2f333a23382589620e9bf848/comments", "author": null, "committer": null, "parents": [{"sha": "eb8da8684cfdf019f0b0edfd834a479ac366f1d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8da8684cfdf019f0b0edfd834a479ac366f1d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8da8684cfdf019f0b0edfd834a479ac366f1d4"}], "stats": {"total": 171, "additions": 125, "deletions": 46}, "files": [{"sha": "cb230d9c80e6a538d0dfd7d91d99abf07293db0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=185ebd6c71d791ea2f333a23382589620e9bf848", "patch": "@@ -1,3 +1,23 @@\n+Tue Dec 29 11:32:54 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>:\n+\n+\t* rtl.def (CONSTANT_P_RTX): Clarify commentary.\n+\t* expr.c (expand_builtin, case BUILT_IN_CONSTANT_P): Rework to\n+\tconsider constant CONSTRUCTOR constant and to defer some cases\n+\tto cse.\n+\t* cse.c (fold_rtx, case CONST): Add handling for CONSTANT_P_RTX.\n+\t* regclass.c (reg_scan_mark_refs, case CONST): Likewise.\n+\n+Tue Dec 29 11:30:10 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* expr.c (init_expr_once): Kill can_handle_constant_p recognition.\n+\t* cse.c (fold_rtx, case 'x'): Remove standalone CONSTANT_P_RTX code.\n+\n+\t* alpha.c (reg_or_6bit_operand): Remove CONSTANT_P_RTX handling.\n+\t(reg_or_8bit_operand, cint8_operand, add_operand): Likewise.\n+\t(sext_add_operand, and_operand, or_operand): Likewise.\n+\t(reg_or_cint_operand, some_operand, input_operand): Likewise.\n+\t* alpha.h (PREDICATE_CODES): Likewise.\n+\n Sat Dec 26 23:26:26 PST 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "9ca293185be39caa8e500595f7b9826771afde7b", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=185ebd6c71d791ea2f333a23382589620e9bf848", "patch": "@@ -4931,6 +4931,21 @@ fold_rtx (x, insn)\n   switch (code)\n     {\n     case CONST:\n+      /* If the operand is a CONSTANT_P_RTX, see if what's inside it\n+\t is known to be constant and replace the whole thing with a\n+\t CONST_INT of either zero or one.  Note that this code assumes\n+\t that an insn that recognizes a CONST will also recognize a\n+\t CONST_INT, but that seems to be a safe assumption.  */\n+      if (GET_CODE (XEXP (x, 0)) == CONSTANT_P_RTX)\n+\t{\n+\t  x = equiv_constant (fold_rtx (XEXP (XEXP (x, 0), 0), 0));\n+\t  return (x != 0 && (GET_CODE (x) == CONST_INT\n+\t\t\t     || GET_CODE (x) == CONST_DOUBLE)\n+\t\t  ? const1_rtx : const0_rtx);\n+\t}\n+\n+      /* ... fall through ... */\n+\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case SYMBOL_REF:\n@@ -5850,12 +5865,6 @@ fold_rtx (x, insn)\n \t\t\t\t\tconst_arg1 ? const_arg1 : folded_arg1,\n \t\t\t\t\tconst_arg2 ? const_arg2 : XEXP (x, 2));\n       break;\n-\n-    case 'x':\n-      /* Always eliminate CONSTANT_P_RTX at this stage. */\n-      if (code == CONSTANT_P_RTX)\n-\treturn (const_arg0 ? const1_rtx : const0_rtx);\n-      break;\n     }\n \n   return new ? new : x;"}, {"sha": "09a7eb1f16ad47c779ce7acd0b86606189dde3f3", "filename": "gcc/expr.c", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=185ebd6c71d791ea2f333a23382589620e9bf848", "patch": "@@ -101,11 +101,6 @@ static rtx saveregs_value;\n /* Similarly for __builtin_apply_args.  */\n static rtx apply_args_value;\n \n-/* Nonzero if the machine description has been fixed to accept\n-   CONSTANT_P_RTX patterns.  We will emit a warning and continue\n-   if we find we must actually use such a beast.  */\n-static int can_handle_constant_p;\n-\n /* Don't check memory usage, since code is being emitted to check a memory\n    usage.  Used when current_function_check_memory_usage is true, to avoid\n    infinite recursion.  */\n@@ -309,14 +304,6 @@ init_expr_once ()\n \t  }\n     }\n \n-  /* Find out if CONSTANT_P_RTX is accepted.  */\n-  SET_DEST (pat) = gen_rtx_REG (TYPE_MODE (integer_type_node),\n-\t\t\t        FIRST_PSEUDO_REGISTER);\n-  SET_SRC (pat) = gen_rtx_CONSTANT_P_RTX (TYPE_MODE (integer_type_node),\n-\t\t\t\t\t  SET_DEST (pat));\n-  if (recog (pat, insn, &num_clobbers) >= 0)\n-    can_handle_constant_p = 1;\n-\n   end_sequence ();\n   obfree (free_point);\n }\n@@ -9010,36 +8997,42 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       else\n \t{\n \t  tree arg = TREE_VALUE (arglist);\n+\t  rtx tmp;\n \n+\t  /* We return 1 for a numeric type that's known to be a constant\n+\t     value at compile-time or for an aggregate type that's a\n+\t     literal constant.  */\n \t  STRIP_NOPS (arg);\n-\t  if (really_constant_p (arg)\n+\n+\t  /* If we know this is a constant, emit the constant of one.  */\n+\t  if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'c'\n+\t      || (TREE_CODE (arg) == CONSTRUCTOR\n+\t\t  && TREE_CONSTANT (arg))\n \t      || (TREE_CODE (arg) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == STRING_CST))\n \t    return const1_rtx;\n \n-\t  /* Only emit CONSTANT_P_RTX if CSE will be run. \n-\t     Moreover, we don't want to expand trees that have side effects,\n-\t     as the original __builtin_constant_p did not evaluate its      \n-\t     argument at all, and we would break existing usage by changing \n-\t     this.  This quirk was generally useful, eliminating a bit of hair\n-\t     in the writing of the macros that use this function.  Now the    \n-\t     same thing can be better accomplished in an inline function.  */\n-\n-\t  if (! cse_not_expected && ! TREE_SIDE_EFFECTS (arg))\n-\t    {\n-\t      /* Lazy fixup of old code: issue a warning and fail the test.  */\n-\t      if (! can_handle_constant_p)\n-\t\t{\n-\t\t  warning (\"Delayed evaluation of __builtin_constant_p not supported on this target.\");\n-\t\t  warning (\"Please report this as a bug to egcs-bugs@cygnus.com.\");\n-\t\t  return const0_rtx;\n-\t\t}\n-\t      return gen_rtx_CONSTANT_P_RTX (TYPE_MODE (integer_type_node),\n-\t\t\t\t             expand_expr (arg, NULL_RTX,\n-\t\t\t\t\t\t\t  VOIDmode, 0));\n-\t    }\n+\t  /* If we aren't going to be running CSE or this expression\n+\t     has side effects, show we don't know it to be a constant.\n+\t     Likewise if it's a pointer or aggregate type since in those\n+\t     case we only want literals, since those are only optimized\n+\t     when generating RTL, not later.  */\n+\t  if (TREE_SIDE_EFFECTS (arg) || cse_not_expected\n+\t      || AGGREGATE_TYPE_P (TREE_TYPE (arg))\n+\t      || POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t    return const0_rtx;\n \n-\t  return const0_rtx;\n+\t  /* Otherwise, emit (const (constant_p_rtx (ARG))) and let CSE\n+\t     get a chance to see if it can deduce whether ARG is constant.  */\n+\t  /* ??? We always generate the CONST in ptr_mode since that's\n+\t     certain to be valid on this machine, then convert it to\n+\t     whatever we need.  */\n+\n+\t  tmp = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n+\t  tmp = gen_rtx_CONSTANT_P_RTX (ptr_mode, tmp);\n+\t  tmp = gen_rtx_CONST (ptr_mode, tmp);\n+\t  tmp = convert_to_mode (mode, tmp, 0);\n+\t  return tmp;\n \t}\n \n     case BUILT_IN_FRAME_ADDRESS:"}, {"sha": "4389bee4583834ce53a101a5f5de3e7f4eb044b5", "filename": "gcc/extend.texi", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=185ebd6c71d791ea2f333a23382589620e9bf848", "patch": "@@ -64,6 +64,7 @@ C++ Language}, for extensions that apply @emph{only} to C++.\n * Function Names::\tPrintable strings which are the name of the current\n \t\t\t function.\n * Return Address::      Getting the return or frame address of a function.\n+* Other Builtins::      Other built-in functions.\n @end menu\n @end ifset\n @ifclear INTERNALS\n@@ -2904,6 +2905,7 @@ These functions may be used to get information about the callers of a\n function.\n \n @table @code\n+@findex __builtin_return_address\n @item __builtin_return_address (@var{level})\n This function returns the return address of the current function, or of\n one of its callers.  The @var{level} argument is number of frames to\n@@ -2920,6 +2922,7 @@ of the stack has been reached, this function will return @code{0}.\n This function should only be used with a non-zero argument for debugging\n purposes.\n \n+@findex __builtin_frame_address\n @item __builtin_frame_address (@var{level})\n This function is similar to @code{__builtin_return_address}, but it\n returns the address of the function frame rather than the return address\n@@ -2940,6 +2943,55 @@ The caveats that apply to @code{__builtin_return_address} apply to this\n function as well.\n @end table\n \n+@node Other Builtins\n+@section Other built-in functions provided by GNU CC\n+\n+GNU CC provides a large number of built-in functions other than the ones\n+mentioned above.  Some of these are for internal use in the processing\n+of exceptions or variable-length argument lists and will not be\n+documented here because they may change from time to time; we do not\n+recommend general use of these functions.\n+\n+The remaining functions are provided for optimization purposes.\n+\n+GNU CC includes builtin versions of many of the functions in the\n+standard C library.  These will always be treated as having the same\n+meaning as the C library function even if you specify the\n+@samp{-fno-builtin} (@pxref{C Dialect Options}) option.  These functions\n+correspond to the C library functions @code{alloca}, @code{ffs},\n+@code{abs}, @code{fabsf}, @code{fabs}, @code{fabsl}, @code{labs},\n+@code{memcpy}, @code{memcmp}, @code{strcmp}, @code{strcpy},\n+@code{strlen}, @code{sqrtf}, @code{sqrt}, @code{sqrtl}, @code{sinf},\n+@code{sin}, @code{sinl}, @code{cosf}, @code{cos}, and @code{cosl}.\n+\n+@findex __builtin_constant_p\n+You can use the builtin function @code{__builtin_constant_p} to\n+determine if a value is known to be constant at compile-time and hence\n+that GNU CC can perform constant-folding on expressions involving that\n+value.  The argument of the function is the value to test.  The function\n+returns the integer 1 if the argument is known to be a compile-time\n+constant and 0 if it is not known to be a compile-time constant.  A\n+return of 0 does not indicate that the value is @emph{not} a constant,\n+but merely that GNU CC cannot prove it is a constant with the specified\n+value of the @samp{-O} option.\n+\n+You would typically use this function in an embedded application where\n+memory was a critical resource.  If you have some complex calculation,\n+you may want it to be folded if it involves constants, but need to call\n+a function if it does not.  For example:\n+\n+#define Scale_Value(X)  \\\n+  (__builtin_constant_p (X) ? ((X) * SCALE + OFFSET) : Scale (X))\n+@end smallexample\n+\n+You may use this builtin function in either a macro or an inline\n+function.  However, if you use it in an inlined function and pass an\n+argument of the function as the argument to the builtin, GNU CC will\n+never return 1 when you call the inline function with a string constant\n+or constructor expression (@pxref{Constructors}) and will not return 1\n+when you pass a constant numeric value to the inline function unless you\n+specify the @samp{-O} option.\n+\n @node C++ Extensions\n @chapter Extensions to the C++ Language\n @cindex extensions, C++ language"}, {"sha": "489f8240407df7ee76406220272c34553084db72", "filename": "gcc/regclass.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=185ebd6c71d791ea2f333a23382589620e9bf848", "patch": "@@ -2032,8 +2032,12 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n   code = GET_CODE (x);\n   switch (code)\n     {\n-    case CONST_INT:\n     case CONST:\n+      if (GET_CODE (XEXP (x, 0)) == CONSTANT_P_RTX)\n+\treg_scan_mark_refs (XEXP (XEXP (x, 0), 0), insn, note_flag, min_regno);\n+      return;\n+\n+    case CONST_INT:\n     case CONST_DOUBLE:\n     case CC0:\n     case PC:"}, {"sha": "8f47d406412a1b885dc40a18f0429c76091b3776", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185ebd6c71d791ea2f333a23382589620e9bf848/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=185ebd6c71d791ea2f333a23382589620e9bf848", "patch": "@@ -850,9 +850,10 @@ DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", 'x')\n    0 is the live bitmap.  Operand 1 is the original block number.  */\n DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", 'x')\n \n-/* A unary `__builtin_constant_p' expression.  These are only emitted\n-   during RTL generation, and then only if optimize > 0.  They are\n-   eliminated by the first CSE pass. */\n+/* A unary `__builtin_constant_p' expression.  This RTL code may only be used\n+   as an operand of a CONST.  This pattern is only emitted during RTL\n+   generation and then only if optimize > 0.  It is converted by the first\n+   CSE pass into the appropriate CONST_INT.  */\n DEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n \n /*"}]}