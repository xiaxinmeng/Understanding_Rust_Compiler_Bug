{"sha": "75de60e68b46c555a87822a78d20c7197bddffb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkZTYwZTY4YjQ2YzU1NWE4NzgyMmE3OGQyMGM3MTk3YmRkZmZiNQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-31T16:54:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-31T16:54:37Z"}, "message": "Merge #453\n\n453: reusing AST::Attribute and remove HIR::Attribute r=philberty a=thomasyonug\n\nDeleting HIR::Attribute and reusing AST::Attribute. \r\n\r\nSome relative reusing classes below:\r\n1. DelimTokenTree\r\n2. AttrInputMetaItemContainer\r\n3. AttrInputLiteral\r\n4. MetaItemLitExpr\r\n5. MetaItemPathLit\r\n6. MetaItemPath\r\n7. MetaItemSeq\r\n8. MetaWord\r\n9. MetaNameValueStr\r\n10. MetaListPath\r\n11. MetaListNameValueStr\r\n12. Attrbute\r\n13. AttrInput\r\n14. MacroParser\n\nCo-authored-by: Thomas Young <wenzhang5800@gmail.com>", "tree": {"sha": "06f5ef0fb27db2d41f2d44254a2fc160fd5aa7be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f5ef0fb27db2d41f2d44254a2fc160fd5aa7be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75de60e68b46c555a87822a78d20c7197bddffb5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgtRTNCRBK7hj4Ov3rIwAAW7cIACAHxWJ/vxn4dCLF0ylDonjI\nW11e1APpNu7zTEgeSS0WicM2KkKhLq5bCeDTpYS+w+hn1Crd/EYENJ0+feZXxYLs\nYloUCOGh3nndTPBO8gvWsFOppIcn6TeyU8pueWljau7IkWNXdB0GGMjDTFUdP8E9\nCAB7lTECZu+1pIJSAojmWIdWcXlBJl02KYyaKWIyyHljx2Tu6kp5zBZNSMI9waVE\nLJLwVQchmHqef+HL5L8N5bx72zEZ8y9Jqw9bk2znGEbmJu1i/GQ+MUP+pATSyK56\ndR5nW4oOghRJwxXl0H2yrqsEfVuo2Cko6yquQ7ZEPsKWRG2NXodOlKYXMezz2xo=\n=hBEz\n-----END PGP SIGNATURE-----\n", "payload": "tree 06f5ef0fb27db2d41f2d44254a2fc160fd5aa7be\nparent 0a3696a4a810e2b9f372b0dc4f79c044ff59811b\nparent a3539302cd0b144eeec4aa5113c0d479ac96f2d5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622480077 +0000\ncommitter GitHub <noreply@github.com> 1622480077 +0000\n\nMerge #453\n\n453: reusing AST::Attribute and remove HIR::Attribute r=philberty a=thomasyonug\n\nDeleting HIR::Attribute and reusing AST::Attribute. \r\n\r\nSome relative reusing classes below:\r\n1. DelimTokenTree\r\n2. AttrInputMetaItemContainer\r\n3. AttrInputLiteral\r\n4. MetaItemLitExpr\r\n5. MetaItemPathLit\r\n6. MetaItemPath\r\n7. MetaItemSeq\r\n8. MetaWord\r\n9. MetaNameValueStr\r\n10. MetaListPath\r\n11. MetaListNameValueStr\r\n12. Attrbute\r\n13. AttrInput\r\n14. MacroParser\n\nCo-authored-by: Thomas Young <wenzhang5800@gmail.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75de60e68b46c555a87822a78d20c7197bddffb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75de60e68b46c555a87822a78d20c7197bddffb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75de60e68b46c555a87822a78d20c7197bddffb5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a3696a4a810e2b9f372b0dc4f79c044ff59811b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a3696a4a810e2b9f372b0dc4f79c044ff59811b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a3696a4a810e2b9f372b0dc4f79c044ff59811b"}, {"sha": "a3539302cd0b144eeec4aa5113c0d479ac96f2d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3539302cd0b144eeec4aa5113c0d479ac96f2d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3539302cd0b144eeec4aa5113c0d479ac96f2d5"}], "stats": {"total": 3014, "additions": 664, "deletions": 2350}, "files": [{"sha": "1a58f1a3ac54f8160b9eb1b1f38f90dcb2110d3c", "filename": "gcc/rust/analysis/rust-hir-liveness-base.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fanalysis%2Frust-hir-liveness-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fanalysis%2Frust-hir-liveness-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-hir-liveness-base.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -33,8 +33,6 @@ class LivenessBase : public HIR::HIRVisitor\n public:\n   virtual ~LivenessBase () {}\n   virtual void visit (HIR::Token &) override {}\n-  virtual void visit (HIR::DelimTokenTree &) override {}\n-  virtual void visit (HIR::AttrInputMetaItemContainer &) override {}\n   virtual void visit (HIR::IdentifierExpr &) override {}\n   virtual void visit (HIR::Lifetime &) override {}\n   virtual void visit (HIR::LifetimeParam &) override {}\n@@ -47,9 +45,6 @@ class LivenessBase : public HIR::HIRVisitor\n   virtual void visit (HIR::QualifiedPathInType &) override {}\n \n   virtual void visit (HIR::LiteralExpr &) override {}\n-  virtual void visit (HIR::AttrInputLiteral &) override {}\n-  virtual void visit (HIR::MetaItemLitExpr &) override {}\n-  virtual void visit (HIR::MetaItemPathLit &) override {}\n   virtual void visit (HIR::BorrowExpr &) override {}\n   virtual void visit (HIR::DereferenceExpr &) override {}\n   virtual void visit (HIR::ErrorPropagationExpr &) override {}\n@@ -161,12 +156,6 @@ class LivenessBase : public HIR::HIRVisitor\n   virtual void visit (HIR::MacroMatcher &) override {}\n   virtual void visit (HIR::MacroRulesDefinition &) override {}\n   virtual void visit (HIR::MacroInvocation &) override {}\n-  virtual void visit (HIR::MetaItemPath &) override {}\n-  virtual void visit (HIR::MetaItemSeq &) override {}\n-  virtual void visit (HIR::MetaWord &) override {}\n-  virtual void visit (HIR::MetaNameValueStr &) override {}\n-  virtual void visit (HIR::MetaListPaths &) override {}\n-  virtual void visit (HIR::MetaListNameValueStr &) override {}\n \n   virtual void visit (HIR::LiteralPattern &) override {}\n   virtual void visit (HIR::IdentifierPattern &) override {}"}, {"sha": "9b57484d5f35434a122507179cf1ba93e210843a", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -3998,6 +3998,14 @@ MaybeNamedParam::as_string () const\n   return str;\n }\n \n+MetaItemInner::~MetaItemInner () = default;\n+\n+std::unique_ptr<MetaNameValueStr>\n+MetaItemInner::to_meta_name_value_str () const\n+{\n+  return nullptr;\n+}\n+\n std::string\n MetaItemSeq::as_string () const\n {"}, {"sha": "08f29d1b1ed237854e6e2e886a02155efdad5ee2", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -38,6 +38,7 @@ struct Session;\n namespace AST {\n // foward decl: ast visitor\n class ASTVisitor;\n+using AttrVec = std::vector<Attribute>;\n \n // Delimiter types - used in macros and whatever.\n enum DelimType\n@@ -583,18 +584,15 @@ class MetaItemInner\n     return std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n   }\n \n-  virtual ~MetaItemInner () {}\n+  virtual ~MetaItemInner ();\n \n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n   /* HACK: used to simplify parsing - creates a copy of that type, or returns\n    * null */\n-  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const\n-  {\n-    return nullptr;\n-  }\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const;\n \n   // HACK: used to simplify parsing - same thing\n   virtual SimplePath to_path_item () const"}, {"sha": "24a7ccc73194291d392a35db04daf3cbc3a020c9", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -32,13 +32,7 @@ class HIRCompileBase : public HIR::HIRVisitor\n   virtual ~HIRCompileBase () {}\n \n   // rust-ast.h\n-  // virtual void visit(AttrInput& attr_input) {}\n-  // virtual void visit(TokenTree& token_tree) {}\n-  // virtual void visit(MacroMatch& macro_match) {}\n   virtual void visit (HIR::Token &tok) {}\n-  virtual void visit (HIR::DelimTokenTree &delim_tok_tree) {}\n-  virtual void visit (HIR::AttrInputMetaItemContainer &input) {}\n-  // virtual void visit(MetaItem& meta_item) {}\n   // virtual void visit(Stmt& stmt) {}\n   // virtual void visit(Expr& expr) {}\n   virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n@@ -63,9 +57,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n \n   // rust-expr.h\n   virtual void visit (HIR::LiteralExpr &expr) {}\n-  virtual void visit (HIR::AttrInputLiteral &attr_input) {}\n-  virtual void visit (HIR::MetaItemLitExpr &meta_item) {}\n-  virtual void visit (HIR::MetaItemPathLit &meta_item) {}\n   virtual void visit (HIR::BorrowExpr &expr) {}\n   virtual void visit (HIR::DereferenceExpr &expr) {}\n   virtual void visit (HIR::ErrorPropagationExpr &expr) {}\n@@ -179,12 +170,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n   virtual void visit (HIR::MacroMatcher &matcher) {}\n   virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n   virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n-  virtual void visit (HIR::MetaItemPath &meta_item) {}\n-  virtual void visit (HIR::MetaItemSeq &meta_item) {}\n-  virtual void visit (HIR::MetaWord &meta_item) {}\n-  virtual void visit (HIR::MetaNameValueStr &meta_item) {}\n-  virtual void visit (HIR::MetaListPaths &meta_item) {}\n-  virtual void visit (HIR::MetaListNameValueStr &meta_item) {}\n \n   // rust-pattern.h\n   virtual void visit (HIR::LiteralPattern &pattern) {}"}, {"sha": "27b85e9aebc086a655f22333c3e68b803e2b5c2a", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -3273,7 +3273,7 @@ MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n /* Determines whether any cfg predicate is false and hence item with attributes\n  * should be stripped. Note that attributes must be expanded before calling. */\n bool\n-MacroExpander::fails_cfg (const std::vector<AST::Attribute> &attrs) const\n+MacroExpander::fails_cfg (const AST::AttrVec &attrs) const\n {\n   for (const auto &attr : attrs)\n     {\n@@ -3286,7 +3286,7 @@ MacroExpander::fails_cfg (const std::vector<AST::Attribute> &attrs) const\n /* Determines whether any cfg predicate is false and hence item with attributes\n  * should be stripped. Will expand attributes as well. */\n bool\n-MacroExpander::fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const\n+MacroExpander::fails_cfg_with_expand (AST::AttrVec &attrs) const\n {\n   // TODO: maybe have something that strips cfg attributes that evaluate true?\n   for (auto &attr : attrs)\n@@ -3329,7 +3329,7 @@ MacroExpander::fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const\n \n // Expands cfg_attr attributes.\n void\n-MacroExpander::expand_cfg_attrs (std::vector<AST::Attribute> &attrs)\n+MacroExpander::expand_cfg_attrs (AST::AttrVec &attrs)\n {\n   for (std::size_t i = 0; i < attrs.size (); i++)\n     {\n@@ -3342,8 +3342,7 @@ MacroExpander::expand_cfg_attrs (std::vector<AST::Attribute> &attrs)\n \t  if (attr.check_cfg_predicate (session))\n \t    {\n \t      // split off cfg_attr\n-\t      std::vector<AST::Attribute> new_attrs\n-\t\t= attr.separate_cfg_attrs ();\n+\t      AST::AttrVec new_attrs = attr.separate_cfg_attrs ();\n \n \t      // remove attr from vector\n \t      attrs.erase (attrs.begin () + i);"}, {"sha": "a458b0d8bbd1e8a06ac8348ad413cfea320f5d02", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -67,9 +67,9 @@ struct MacroExpander\n   AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc,\n \t\t\t\t      AST::MacroRulesDefinition &rules_def);\n \n-  void expand_cfg_attrs (std::vector<AST::Attribute> &attrs);\n-  bool fails_cfg (const std::vector<AST::Attribute> &attr) const;\n-  bool fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const;\n+  void expand_cfg_attrs (AST::AttrVec &attrs);\n+  bool fails_cfg (const AST::AttrVec &attr) const;\n+  bool fails_cfg_with_expand (AST::AttrVec &attrs) const;\n \n   // Expand the data of a cfg! macro.\n   void parse_macro_to_meta_item (AST::MacroInvocData &invoc);"}, {"sha": "77ca50de19690fb97b20f620d6e850772adb6680", "filename": "gcc/rust/hir/rust-ast-lower-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -142,7 +142,7 @@ class ASTLoweringExprWithBlock : public ASTLoweringBase\n \n   void visit (AST::LoopExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n     HIR::BlockExpr *loop_block\n       = ASTLoweringBlock::translate (expr.get_loop_block ().get (),\n \t\t\t\t     &terminated);"}, {"sha": "0aeaf090b36de263bafb37f8fbe2279254eae447", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -80,7 +80,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::TupleIndexExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::Expr *tuple_expr\n       = ASTLoweringExpr::translate (expr.get_tuple_expr ().get (), &terminated);\n@@ -99,8 +99,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::TupleExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> inner_attribs;\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec inner_attribs;\n+    AST::AttrVec outer_attribs;\n     std::vector<std::unique_ptr<HIR::Expr> > tuple_elements;\n     for (auto &e : expr.get_tuple_elems ())\n       {\n@@ -163,7 +163,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::CallExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n     HIR::Expr *func\n       = ASTLoweringExpr::translate (expr.get_function_expr ().get ());\n     std::vector<std::unique_ptr<HIR::Expr> > params;\n@@ -186,7 +186,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::MethodCallExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::PathExprSegment method_path\n       = lower_path_expr_seg (expr.get_method_name ());\n@@ -240,8 +240,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::ArrayExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n-    std::vector<HIR::Attribute> inner_attribs;\n+    AST::AttrVec outer_attribs;\n+    AST::AttrVec inner_attribs;\n \n     expr.get_array_elems ()->accept_vis (*this);\n     rust_assert (translated_array_elems != nullptr);\n@@ -259,7 +259,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::ArrayIndexExpr &expr) override\n   {\n-    std::vector<Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n     HIR::Expr *array_expr\n       = ASTLoweringExpr::translate (expr.get_array_expr ().get ());\n     HIR::Expr *array_index_expr\n@@ -402,7 +402,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::NegationExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::Expr *negated_value\n       = ASTLoweringExpr::translate (expr.get_negated_expr ().get ());\n@@ -482,8 +482,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::StructExprStructFields &struct_expr) override\n   {\n-    std::vector<HIR::Attribute> inner_attribs;\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec inner_attribs;\n+    AST::AttrVec outer_attribs;\n \n     // bit of a hack for now\n     HIR::PathInExpression *path\n@@ -522,8 +522,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::GroupedExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> inner_attribs;\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec inner_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::Expr *paren_expr\n       = ASTLoweringExpr::translate (expr.get_expr_in_parens ().get ());\n@@ -541,8 +541,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::FieldAccessExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> inner_attribs;\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec inner_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::Expr *receiver\n       = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n@@ -570,7 +570,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::BreakExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n     HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n     HIR::Expr *break_expr\n       = expr.has_break_expr ()\n@@ -590,7 +590,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::ContinueExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n     HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n \n     auto crate_num = mappings->get_current_crate ();\n@@ -605,7 +605,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::BorrowExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::Expr *borrow_lvalue\n       = ASTLoweringExpr::translate (expr.get_borrowed_expr ().get ());\n@@ -624,7 +624,7 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::DereferenceExpr &expr) override\n   {\n-    std::vector<HIR::Attribute> outer_attribs;\n+    AST::AttrVec outer_attribs;\n \n     HIR::Expr *dref_lvalue\n       = ASTLoweringExpr::translate (expr.get_dereferenced_expr ().get ());"}, {"sha": "43cc256790fd1f606081a9a9a9f2676a5e0f3cde", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -60,7 +60,7 @@ class ASTLowerImplItem : public ASTLoweringBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n@@ -86,7 +86,7 @@ class ASTLowerImplItem : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n@@ -169,7 +169,7 @@ class ASTLowerImplItem : public ASTLoweringBase\n   void visit (AST::Method &method) override\n   {\n     // ignore for now and leave empty\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers ("}, {"sha": "10ec203b21aea640c23f9e74fce735c433ec87c8", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -58,7 +58,7 @@ class ASTLoweringItem : public ASTLoweringBase\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n \n     std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n     if (alias.has_generics ())\n@@ -98,11 +98,11 @@ class ASTLoweringItem : public ASTLoweringBase\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n \n     std::vector<HIR::TupleField> fields;\n     struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n-      std::vector<HIR::Attribute> outer_attrs;\n+      AST::AttrVec outer_attrs;\n       HIR::Visibility vis = HIR::Visibility::create_public ();\n       HIR::Type *type\n \t= ASTLoweringType::translate (field.get_field_type ().get ());\n@@ -154,12 +154,12 @@ class ASTLoweringItem : public ASTLoweringBase\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n \n     bool is_unit = struct_decl.is_unit_struct ();\n     std::vector<HIR::StructField> fields;\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n-      std::vector<HIR::Attribute> outer_attrs;\n+      AST::AttrVec outer_attrs;\n       HIR::Visibility vis = HIR::Visibility::create_public ();\n       HIR::Type *type\n \t= ASTLoweringType::translate (field.get_field_type ().get ());\n@@ -201,7 +201,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::StaticItem &var) override\n   {\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     HIR::Type *type = ASTLoweringType::translate (var.get_type ().get ());\n@@ -227,7 +227,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n@@ -253,7 +253,7 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n@@ -337,8 +337,8 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n-    std::vector<HIR::Attribute> inner_attrs;\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec inner_attrs;\n+    AST::AttrVec outer_attrs;\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));"}, {"sha": "053474973654b0cc5632935b19ed4fd1f7458fd2", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -86,7 +86,7 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::LetStmt &stmt) override\n   {\n-    std::vector<HIR::Attribute> outer_attrs;\n+    AST::AttrVec outer_attrs;\n     HIR::Pattern *variables\n       = ASTLoweringPattern::translate (stmt.get_pattern ().get ());\n     HIR::Type *type = stmt.has_type ()"}, {"sha": "635c018062687372c3b96e68bba434ac8ed88011", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -295,7 +295,7 @@ class ASTLowerGenericParam : public ASTLoweringBase\n \n   void visit (AST::TypeParam &param) override\n   {\n-    HIR::Attribute outer_attr = HIR::Attribute::create_empty ();\n+    AST::Attribute outer_attr = AST::Attribute::create_empty ();\n     std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n     HIR::Type *type = param.has_type ()\n \t\t\t? ASTLoweringType::translate (param.get_type ().get ())"}, {"sha": "b43608910a01ee6923773e2dbe78a64883eeded3", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -40,7 +40,7 @@ HIR::Crate\n ASTLowering::go ()\n {\n   std::vector<std::unique_ptr<HIR::Item> > items;\n-  std::vector<HIR::Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n   bool has_utf8bom = false;\n   bool has_shebang = false;\n \n@@ -65,8 +65,8 @@ ASTLowering::go ()\n void\n ASTLoweringBlock::visit (AST::BlockExpr &expr)\n {\n-  std::vector<HIR::Attribute> inner_attribs;\n-  std::vector<HIR::Attribute> outer_attribs;\n+  AST::AttrVec inner_attribs;\n+  AST::AttrVec outer_attribs;\n \n   std::vector<std::unique_ptr<HIR::Stmt> > block_stmts;\n   bool block_did_terminate = false;\n@@ -240,7 +240,7 @@ ASTLowerStructExprField::visit (AST::StructExprFieldIdentifier &field)\n void\n ASTLoweringExprWithBlock::visit (AST::WhileLoopExpr &expr)\n {\n-  std::vector<HIR::Attribute> outer_attribs;\n+  AST::AttrVec outer_attribs;\n   HIR::BlockExpr *loop_block\n     = ASTLoweringBlock::translate (expr.get_loop_block ().get (), &terminated);\n "}, {"sha": "f39c85997f3ef42b674af5cb3bdc819293441fa3", "filename": "gcc/rust/hir/tree/rust-hir-cond-compilation.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_AST_CONDCOMPILATION\n #define RUST_AST_CONDCOMPILATION\n \n+#include \"rust-ast-full-decls.h\"\n #include \"rust-hir.h\"\n \n namespace Rust {\n@@ -206,18 +207,18 @@ class CfgAttribute\n // TODO: inline\n struct CfgAttrs\n {\n-  std::vector<Attribute> cfg_attrs;\n+  AST::AttrVec cfg_attrs;\n };\n \n // TODO: relationship to other attributes?\n class CfgAttrAttribute\n {\n   std::unique_ptr<ConfigurationPredicate> config_to_include;\n-  std::vector<Attribute> cfg_attrs;\n+  AST::AttrVec cfg_attrs;\n \n public:\n   CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n-\t\t    std::vector<Attribute> cfg_attrs)\n+\t\t    AST::AttrVec cfg_attrs)\n     : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n   {}\n "}, {"sha": "7a5227a3a8076385761ba337ba3bf5794c25d158", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 74, "deletions": 166, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_HIR_EXPR_H\n #define RUST_HIR_EXPR_H\n \n+#include \"rust-ast-full-decls.h\"\n #include \"rust-hir.h\"\n #include \"rust-hir-path.h\"\n #include \"operator.h\"\n@@ -32,7 +33,7 @@ class ExprWithBlock : public Expr\n   // TODO: should this mean that a BlockExpr should be a member variable?\n protected:\n   ExprWithBlock (Analysis::NodeMapping mappings,\n-\t\t std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t\t AST::AttrVec outer_attrs = AST::AttrVec ())\n     : Expr (std::move (mappings), std::move (outer_attrs))\n   {}\n \n@@ -72,14 +73,13 @@ class LiteralExpr : public ExprWithoutBlock\n \n   LiteralExpr (Analysis::NodeMapping mappings, std::string value_as_string,\n \t       Literal::LitType type, PrimitiveCoreType type_hint,\n-\t       Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t       Location locus, AST::AttrVec outer_attrs = AST::AttrVec ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n   LiteralExpr (Analysis::NodeMapping mappings, Literal literal, Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t       AST::AttrVec outer_attrs = AST::AttrVec ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       literal (std::move (literal)), locus (locus)\n   {}\n@@ -120,86 +120,6 @@ class LiteralExpr : public ExprWithoutBlock\n   }\n };\n \n-// Literal expression attribute body (non-macro attribute)\n-class AttrInputLiteral : public AttrInput\n-{\n-  // Literal expression WITHOUT SUFFIX\n-  // std::unique_ptr<LiteralExpr> literal_expr;\n-  LiteralExpr\n-    literal_expr; // as not using polymorphic behaviour, doesn't require pointer\n-  // TODO: will require pointer if LiteralExpr is changed to have subclassing\n-\n-  // TODO: should this store location data?\n-\n-public:\n-  AttrInputLiteral (LiteralExpr lit_expr) : literal_expr (std::move (lit_expr))\n-  {}\n-\n-  std::string as_string () const override\n-  {\n-    return \" = \" + literal_expr.as_string ();\n-  }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  AttrInputLiteral *clone_attr_input_impl () const override\n-  {\n-    return new AttrInputLiteral (*this);\n-  }\n-};\n-\n-/* literal expr only meta item inner - TODO possibly replace with inheritance of\n- * LiteralExpr itself? */\n-class MetaItemLitExpr : public MetaItemInner\n-{\n-  LiteralExpr lit_expr;\n-\n-public:\n-  MetaItemLitExpr (LiteralExpr lit_expr) : lit_expr (std::move (lit_expr)) {}\n-\n-  std::string as_string () const override { return lit_expr.as_string (); }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaItemLitExpr *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaItemLitExpr (*this);\n-  }\n-};\n-\n-// more generic meta item \"path = lit\" form\n-class MetaItemPathLit : public MetaItem\n-{\n-  SimplePath path;\n-  LiteralExpr lit;\n-\n-public:\n-  MetaItemPathLit (SimplePath path, LiteralExpr lit_expr)\n-    : path (std::move (path)), lit (std::move (lit_expr))\n-  {}\n-\n-  std::string as_string () const override\n-  {\n-    return path.as_string () + \" = \" + lit.as_string ();\n-  }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaItemPathLit *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaItemPathLit (*this);\n-  }\n-};\n-\n /* Represents an expression using unary or binary operators as HIR node. Can be\n  * overloaded. */\n class OperatorExpr : public ExprWithoutBlock\n@@ -216,7 +136,7 @@ class OperatorExpr : public ExprWithoutBlock\n   // Constructor (only for initialisation of expr purposes)\n   OperatorExpr (Analysis::NodeMapping mappings,\n \t\tstd::unique_ptr<Expr> main_or_left_expr,\n-\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+\t\tAST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       locus (locus), main_or_left_expr (std::move (main_or_left_expr))\n   {}\n@@ -261,8 +181,7 @@ class BorrowExpr : public OperatorExpr\n \n   BorrowExpr (Analysis::NodeMapping mappings,\n \t      std::unique_ptr<Expr> borrow_lvalue, bool is_mut_borrow,\n-\t      bool is_double_borrow, std::vector<Attribute> outer_attribs,\n-\t      Location locus)\n+\t      bool is_double_borrow, AST::AttrVec outer_attribs, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (borrow_lvalue),\n \t\t    std::move (outer_attribs), locus),\n       is_mut (is_mut_borrow), double_borrow (is_double_borrow)\n@@ -298,7 +217,7 @@ class DereferenceExpr : public OperatorExpr\n   // Constructor calls OperatorExpr's protected constructor\n   DereferenceExpr (Analysis::NodeMapping mappings,\n \t\t   std::unique_ptr<Expr> deref_lvalue,\n-\t\t   std::vector<Attribute> outer_attribs, Location locus)\n+\t\t   AST::AttrVec outer_attribs, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (deref_lvalue),\n \t\t    std::move (outer_attribs), locus)\n   {}\n@@ -330,7 +249,7 @@ class ErrorPropagationExpr : public OperatorExpr\n   // Constructor calls OperatorExpr's protected constructor\n   ErrorPropagationExpr (Analysis::NodeMapping mappings,\n \t\t\tstd::unique_ptr<Expr> potential_error_value,\n-\t\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+\t\t\tAST::AttrVec outer_attribs, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (potential_error_value),\n \t\t    std::move (outer_attribs), locus)\n   {}\n@@ -373,7 +292,7 @@ class NegationExpr : public OperatorExpr\n   // Constructor calls OperatorExpr's protected constructor\n   NegationExpr (Analysis::NodeMapping mappings,\n \t\tstd::unique_ptr<Expr> negated_value, ExprType expr_kind,\n-\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+\t\tAST::AttrVec outer_attribs, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (negated_value),\n \t\t    std::move (outer_attribs), locus),\n       expr_type (expr_kind)\n@@ -422,7 +341,7 @@ class ArithmeticOrLogicalExpr : public OperatorExpr\n \t\t\t   std::unique_ptr<Expr> right_value,\n \t\t\t   ExprType expr_kind, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (left_value),\n-\t\t    std::vector<Attribute> (), locus),\n+\t\t    AST::AttrVec (), locus),\n       expr_type (expr_kind), right_expr (std::move (right_value))\n   {}\n   // outer attributes not allowed\n@@ -496,7 +415,7 @@ class ComparisonExpr : public OperatorExpr\n \t\t  std::unique_ptr<Expr> right_value, ExprType comparison_kind,\n \t\t  Location locus)\n     : OperatorExpr (std::move (mappings), std::move (left_value),\n-\t\t    std::vector<Attribute> (), locus),\n+\t\t    AST::AttrVec (), locus),\n       expr_type (comparison_kind), right_expr (std::move (right_value))\n   {}\n   // outer attributes not allowed\n@@ -566,7 +485,7 @@ class LazyBooleanExpr : public OperatorExpr\n \t\t   std::unique_ptr<Expr> right_bool_expr, ExprType expr_kind,\n \t\t   Location locus)\n     : OperatorExpr (std::move (mappings), std::move (left_bool_expr),\n-\t\t    std::vector<Attribute> (), locus),\n+\t\t    AST::AttrVec (), locus),\n       expr_type (expr_kind), right_expr (std::move (right_bool_expr))\n   {}\n   // outer attributes not allowed\n@@ -632,7 +551,7 @@ class TypeCastExpr : public OperatorExpr\n \t\tstd::unique_ptr<Expr> expr_to_cast,\n \t\tstd::unique_ptr<TypeNoBounds> type_to_cast_to, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (expr_to_cast),\n-\t\t    std::vector<Attribute> (), locus),\n+\t\t    AST::AttrVec (), locus),\n       type_to_convert_to (std::move (type_to_cast_to))\n   {}\n   // outer attributes not allowed\n@@ -688,7 +607,7 @@ class AssignmentExpr : public OperatorExpr\n \t\t  std::unique_ptr<Expr> value_to_assign_to,\n \t\t  std::unique_ptr<Expr> value_to_assign, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (value_to_assign_to),\n-\t\t    std::vector<Attribute> (), locus),\n+\t\t    AST::AttrVec (), locus),\n       right_expr (std::move (value_to_assign))\n   {}\n   // outer attributes not allowed\n@@ -740,20 +659,20 @@ class AssignmentExpr : public OperatorExpr\n // Expression in parentheses (i.e. like literally just any 3 + (2 * 6))\n class GroupedExpr : public ExprWithoutBlock\n {\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n   std::unique_ptr<Expr> expr_in_parens;\n \n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  AST::AttrVec get_inner_attrs () const { return inner_attrs; }\n \n   GroupedExpr (Analysis::NodeMapping mappings,\n \t       std::unique_ptr<Expr> parenthesised_expr,\n-\t       std::vector<Attribute> inner_attribs,\n-\t       std::vector<Attribute> outer_attribs, Location locus)\n+\t       AST::AttrVec inner_attribs, AST::AttrVec outer_attribs,\n+\t       Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       expr_in_parens (std::move (parenthesised_expr)), locus (locus)\n@@ -937,24 +856,24 @@ class ArrayElemsCopied : public ArrayElems\n // Array definition-ish expression\n class ArrayExpr : public ExprWithoutBlock\n {\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n   std::unique_ptr<ArrayElems> internal_elements;\n \n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  AST::AttrVec get_inner_attrs () const { return inner_attrs; }\n \n   // Returns whether array expr has array elems or if it is just empty.\n   bool has_array_elems () const { return internal_elements != nullptr; }\n \n   // Constructor requires ArrayElems pointer\n   ArrayExpr (Analysis::NodeMapping mappings,\n \t     std::unique_ptr<ArrayElems> array_elems,\n-\t     std::vector<Attribute> inner_attribs,\n-\t     std::vector<Attribute> outer_attribs, Location locus)\n+\t     AST::AttrVec inner_attribs, AST::AttrVec outer_attribs,\n+\t     Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       internal_elements (std::move (array_elems)), locus (locus)\n@@ -1024,7 +943,7 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   ArrayIndexExpr (Analysis::NodeMapping mappings,\n \t\t  std::unique_ptr<Expr> array_expr,\n \t\t  std::unique_ptr<Expr> array_index_expr,\n-\t\t  std::vector<Attribute> outer_attribs, Location locus)\n+\t\t  AST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       array_expr (std::move (array_expr)),\n       index_expr (std::move (array_index_expr)), locus (locus)\n@@ -1079,7 +998,7 @@ class ArrayIndexExpr : public ExprWithoutBlock\n // HIR representation of a tuple\n class TupleExpr : public ExprWithoutBlock\n {\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n \n   std::vector<std::unique_ptr<Expr> > tuple_elems;\n   // replaces (inlined version of) TupleElements\n@@ -1089,12 +1008,12 @@ class TupleExpr : public ExprWithoutBlock\n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  AST::AttrVec get_inner_attrs () const { return inner_attrs; }\n \n   TupleExpr (Analysis::NodeMapping mappings,\n \t     std::vector<std::unique_ptr<Expr> > tuple_elements,\n-\t     std::vector<Attribute> inner_attribs,\n-\t     std::vector<Attribute> outer_attribs, Location locus)\n+\t     AST::AttrVec inner_attribs, AST::AttrVec outer_attribs,\n+\t     Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       tuple_elems (std::move (tuple_elements)), locus (locus)\n@@ -1179,7 +1098,7 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   TupleIndexExpr (Analysis::NodeMapping mappings,\n \t\t  std::unique_ptr<Expr> tuple_expr, TupleIndex index,\n-\t\t  std::vector<Attribute> outer_attribs, Location locus)\n+\t\t  AST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       tuple_expr (std::move (tuple_expr)), tuple_index (index), locus (locus)\n   {}\n@@ -1241,7 +1160,7 @@ class StructExpr : public ExprWithoutBlock\n \n   // Protected constructor to allow initialising struct_name\n   StructExpr (Analysis::NodeMapping mappings, PathInExpression struct_path,\n-\t      std::vector<Attribute> outer_attribs)\n+\t      AST::AttrVec outer_attribs)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       struct_name (std::move (struct_path))\n   {}\n@@ -1255,20 +1174,19 @@ class StructExpr : public ExprWithoutBlock\n // Actual HIR node of the struct creator (with no fields). Not abstract!\n class StructExprStruct : public StructExpr\n {\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n \n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  AST::AttrVec get_inner_attrs () const { return inner_attrs; }\n \n   // Constructor has to call protected constructor of base class\n   StructExprStruct (Analysis::NodeMapping mappings,\n-\t\t    PathInExpression struct_path,\n-\t\t    std::vector<Attribute> inner_attribs,\n-\t\t    std::vector<Attribute> outer_attribs, Location locus)\n+\t\t    PathInExpression struct_path, AST::AttrVec inner_attribs,\n+\t\t    AST::AttrVec outer_attribs, Location locus)\n     : StructExpr (std::move (mappings), std::move (struct_path),\n \t\t  std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)), locus (locus)\n@@ -1520,9 +1438,8 @@ class StructExprStructFields : public StructExprStruct\n   StructExprStructFields (\n     Analysis::NodeMapping mappings, PathInExpression struct_path,\n     std::vector<std::unique_ptr<StructExprField> > expr_fields, Location locus,\n-    StructBase *base_struct,\n-    std::vector<Attribute> inner_attribs = std::vector<Attribute> (),\n-    std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    StructBase *base_struct, AST::AttrVec inner_attribs = AST::AttrVec (),\n+    AST::AttrVec outer_attribs = AST::AttrVec ())\n     : StructExprStruct (std::move (mappings), std::move (struct_path),\n \t\t\tstd::move (inner_attribs), std::move (outer_attribs),\n \t\t\tlocus),\n@@ -1617,8 +1534,8 @@ class StructExprStructBase : public StructExprStruct\n \n   StructExprStructBase (Analysis::NodeMapping mappings,\n \t\t\tPathInExpression struct_path, StructBase base_struct,\n-\t\t\tstd::vector<Attribute> inner_attribs,\n-\t\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+\t\t\tAST::AttrVec inner_attribs, AST::AttrVec outer_attribs,\n+\t\t\tLocation locus)\n     : StructExprStruct (std::move (mappings), std::move (struct_path),\n \t\t\tstd::move (inner_attribs), std::move (outer_attribs),\n \t\t\tlocus),\n@@ -1647,24 +1564,24 @@ class StructExprStructBase : public StructExprStruct\n // HIR node of a tuple struct creator\n class StructExprTuple : public StructExpr\n {\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n   std::vector<std::unique_ptr<Expr> > exprs;\n \n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  const AST::AttrVec &get_inner_attrs () const { return inner_attrs; }\n \n   /*inline std::vector<std::unique_ptr<Expr>> get_exprs() const {\n       return exprs;\n   }*/\n \n   StructExprTuple (Analysis::NodeMapping mappings, PathInExpression struct_path,\n \t\t   std::vector<std::unique_ptr<Expr> > tuple_exprs,\n-\t\t   std::vector<Attribute> inner_attribs,\n-\t\t   std::vector<Attribute> outer_attribs, Location locus)\n+\t\t   AST::AttrVec inner_attribs, AST::AttrVec outer_attribs,\n+\t\t   Location locus)\n     : StructExpr (std::move (mappings), std::move (struct_path),\n \t\t  std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)), exprs (std::move (tuple_exprs)),\n@@ -1728,7 +1645,7 @@ class StructExprUnit : public StructExpr\n   std::string as_string () const override { return struct_name.as_string (); }\n \n   StructExprUnit (Analysis::NodeMapping mappings, PathInExpression struct_path,\n-\t\t  std::vector<Attribute> outer_attribs, Location locus)\n+\t\t  AST::AttrVec outer_attribs, Location locus)\n     : StructExpr (std::move (mappings), std::move (struct_path),\n \t\t  std::move (outer_attribs)),\n       locus (locus)\n@@ -1765,7 +1682,7 @@ class EnumVariantExpr : public ExprWithoutBlock\n   // Protected constructor for initialising enum_variant_path\n   EnumVariantExpr (Analysis::NodeMapping mappings,\n \t\t   PathInExpression path_to_enum_variant,\n-\t\t   std::vector<Attribute> outer_attribs)\n+\t\t   AST::AttrVec outer_attribs)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       enum_variant_path (std::move (path_to_enum_variant))\n   {}\n@@ -1920,7 +1837,7 @@ class EnumExprStruct : public EnumVariantExpr\n   EnumExprStruct (Analysis::NodeMapping mappings,\n \t\t  PathInExpression enum_variant_path,\n \t\t  std::vector<std::unique_ptr<EnumExprField> > variant_fields,\n-\t\t  std::vector<Attribute> outer_attribs, Location locus)\n+\t\t  AST::AttrVec outer_attribs, Location locus)\n     : EnumVariantExpr (std::move (mappings), std::move (enum_variant_path),\n \t\t       std::move (outer_attribs)),\n       fields (std::move (variant_fields)), locus (locus)\n@@ -1990,7 +1907,7 @@ class EnumExprTuple : public EnumVariantExpr\n   EnumExprTuple (Analysis::NodeMapping mappings,\n \t\t PathInExpression enum_variant_path,\n \t\t std::vector<std::unique_ptr<Expr> > variant_values,\n-\t\t std::vector<Attribute> outer_attribs, Location locus)\n+\t\t AST::AttrVec outer_attribs, Location locus)\n     : EnumVariantExpr (std::move (mappings), std::move (enum_variant_path),\n \t\t       std::move (outer_attribs)),\n       values (std::move (variant_values)), locus (locus)\n@@ -2057,7 +1974,7 @@ class EnumExprFieldless : public EnumVariantExpr\n \n   EnumExprFieldless (Analysis::NodeMapping mappings,\n \t\t     PathInExpression enum_variant_path,\n-\t\t     std::vector<Attribute> outer_attribs, Location locus)\n+\t\t     AST::AttrVec outer_attribs, Location locus)\n     : EnumVariantExpr (std::move (mappings), std::move (enum_variant_path),\n \t\t       std::move (outer_attribs)),\n       locus (locus)\n@@ -2101,7 +2018,7 @@ class CallExpr : public ExprWithoutBlock\n \n   CallExpr (Analysis::NodeMapping mappings, std::unique_ptr<Expr> function_expr,\n \t    std::vector<std::unique_ptr<Expr> > function_params,\n-\t    std::vector<Attribute> outer_attribs, Location locus)\n+\t    AST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       function (std::move (function_expr)),\n       params (std::move (function_params)), locus (locus)\n@@ -2192,7 +2109,7 @@ class MethodCallExpr : public ExprWithoutBlock\n \t\t  std::unique_ptr<Expr> call_receiver,\n \t\t  PathExprSegment method_path,\n \t\t  std::vector<std::unique_ptr<Expr> > method_params,\n-\t\t  std::vector<Attribute> outer_attribs, Location locus)\n+\t\t  AST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       receiver (std::move (call_receiver)),\n       method_name (std::move (method_path)), params (std::move (method_params)),\n@@ -2286,7 +2203,7 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   FieldAccessExpr (Analysis::NodeMapping mappings,\n \t\t   std::unique_ptr<Expr> field_access_receiver,\n-\t\t   Identifier field_name, std::vector<Attribute> outer_attribs,\n+\t\t   Identifier field_name, AST::AttrVec outer_attribs,\n \t\t   Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       receiver (std::move (field_access_receiver)),\n@@ -2411,7 +2328,7 @@ class ClosureExpr : public ExprWithoutBlock\n protected:\n   ClosureExpr (Analysis::NodeMapping mappings,\n \t       std::vector<ClosureParam> closure_params, bool has_move,\n-\t       std::vector<Attribute> outer_attribs, Location locus)\n+\t       AST::AttrVec outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       has_move (has_move), params (std::move (closure_params)), locus (locus)\n   {}\n@@ -2436,8 +2353,7 @@ class ClosureExprInner : public ClosureExpr\n \t\t    std::unique_ptr<Expr> closure_inner_expr,\n \t\t    std::vector<ClosureParam> closure_params, Location locus,\n \t\t    bool is_move = false,\n-\t\t    std::vector<Attribute> outer_attribs\n-\t\t    = std::vector<Attribute> ())\n+\t\t    AST::AttrVec outer_attribs = AST::AttrVec ())\n     : ClosureExpr (std::move (mappings), std::move (closure_params), is_move,\n \t\t   std::move (outer_attribs), locus),\n       closure_inner (std::move (closure_inner_expr))\n@@ -2486,7 +2402,7 @@ class ClosureExprInner : public ClosureExpr\n class BlockExpr : public ExprWithBlock\n {\n public:\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n \n   std::vector<std::unique_ptr<Stmt> > statements;\n   std::unique_ptr<Expr> expr; // inlined from Statements\n@@ -2507,8 +2423,8 @@ class BlockExpr : public ExprWithBlock\n   BlockExpr (Analysis::NodeMapping mappings,\n \t     std::vector<std::unique_ptr<Stmt> > block_statements,\n \t     std::unique_ptr<Expr> block_expr, bool tail_reachable,\n-\t     std::vector<Attribute> inner_attribs,\n-\t     std::vector<Attribute> outer_attribs, Location locus)\n+\t     AST::AttrVec inner_attribs, AST::AttrVec outer_attribs,\n+\t     Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       statements (std::move (block_statements)), expr (std::move (block_expr)),\n@@ -2623,8 +2539,7 @@ class ClosureExprInnerTyped : public ClosureExpr\n \t\t\t std::unique_ptr<BlockExpr> closure_expr,\n \t\t\t std::vector<ClosureParam> closure_params,\n \t\t\t Location locus, bool is_move = false,\n-\t\t\t std::vector<Attribute> outer_attribs\n-\t\t\t = std::vector<Attribute> ())\n+\t\t\t AST::AttrVec outer_attribs = AST::AttrVec ())\n     : ClosureExpr (std::move (mappings), std::move (closure_params), is_move,\n \t\t   std::move (outer_attribs), locus),\n       return_type (std::move (closure_return_type)),\n@@ -2687,8 +2602,7 @@ class ContinueExpr : public ExprWithoutBlock\n \n   // Constructor for a ContinueExpr with a label.\n   ContinueExpr (Analysis::NodeMapping mappings, Location locus, Lifetime label,\n-\t\tstd::vector<Attribute> outer_attribs\n-\t\t= std::vector<Attribute> ())\n+\t\tAST::AttrVec outer_attribs = AST::AttrVec ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       label (std::move (label)), locus (locus)\n   {}\n@@ -2742,7 +2656,7 @@ class BreakExpr : public ExprWithoutBlock\n   BreakExpr (Analysis::NodeMapping mappings, Location locus,\n \t     Lifetime break_label,\n \t     std::unique_ptr<Expr> expr_in_break = nullptr,\n-\t     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+\t     AST::AttrVec outer_attribs = AST::AttrVec ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       label (std::move (break_label)), break_expr (std::move (expr_in_break)),\n       locus (locus)\n@@ -2803,8 +2717,7 @@ class RangeExpr : public ExprWithoutBlock\n protected:\n   // outer attributes not allowed before range expressions\n   RangeExpr (Analysis::NodeMapping mappings, Location locus)\n-    : ExprWithoutBlock (std::move (mappings), std::vector<Attribute> ()),\n-      locus (locus)\n+    : ExprWithoutBlock (std::move (mappings), AST::AttrVec ()), locus (locus)\n   {}\n \n public:\n@@ -3122,7 +3035,7 @@ class ReturnExpr : public ExprWithoutBlock\n   // Constructor for ReturnExpr.\n   ReturnExpr (Analysis::NodeMapping mappings, Location locus,\n \t      std::unique_ptr<Expr> returned_expr = nullptr,\n-\t      std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+\t      AST::AttrVec outer_attribs = AST::AttrVec ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n       return_expr (std::move (returned_expr)), locus (locus)\n   {}\n@@ -3190,7 +3103,7 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   UnsafeBlockExpr (Analysis::NodeMapping mappings,\n \t\t   std::unique_ptr<BlockExpr> block_expr,\n-\t\t   std::vector<Attribute> outer_attribs, Location locus)\n+\t\t   AST::AttrVec outer_attribs, Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attribs)),\n       expr (std::move (block_expr)), locus (locus)\n   {}\n@@ -3282,8 +3195,7 @@ class BaseLoopExpr : public ExprWithBlock\n   BaseLoopExpr (Analysis::NodeMapping mappings,\n \t\tstd::unique_ptr<BlockExpr> loop_block, Location locus,\n \t\tLoopLabel loop_label,\n-\t\tstd::vector<Attribute> outer_attribs\n-\t\t= std::vector<Attribute> ())\n+\t\tAST::AttrVec outer_attribs = AST::AttrVec ())\n     : ExprWithBlock (std::move (mappings), std::move (outer_attribs)),\n       loop_label (std::move (loop_label)), loop_block (std::move (loop_block)),\n       locus (locus)\n@@ -3331,8 +3243,7 @@ class LoopExpr : public BaseLoopExpr\n   // Constructor for LoopExpr\n   LoopExpr (Analysis::NodeMapping mappings,\n \t    std::unique_ptr<BlockExpr> loop_block, Location locus,\n-\t    LoopLabel loop_label,\n-\t    std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+\t    LoopLabel loop_label, AST::AttrVec outer_attribs = AST::AttrVec ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_block), locus,\n \t\t    std::move (loop_label), std::move (outer_attribs))\n   {}\n@@ -3365,8 +3276,7 @@ class WhileLoopExpr : public BaseLoopExpr\n \t\t std::unique_ptr<Expr> loop_condition,\n \t\t std::unique_ptr<BlockExpr> loop_block, Location locus,\n \t\t LoopLabel loop_label,\n-\t\t std::vector<Attribute> outer_attribs\n-\t\t = std::vector<Attribute> ())\n+\t\t AST::AttrVec outer_attribs = AST::AttrVec ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_block), locus,\n \t\t    std::move (loop_label), std::move (outer_attribs)),\n       condition (std::move (loop_condition))\n@@ -3429,8 +3339,7 @@ class WhileLetLoopExpr : public BaseLoopExpr\n \t\t    std::unique_ptr<Expr> condition,\n \t\t    std::unique_ptr<BlockExpr> loop_block, Location locus,\n \t\t    LoopLabel loop_label,\n-\t\t    std::vector<Attribute> outer_attribs\n-\t\t    = std::vector<Attribute> ())\n+\t\t    AST::AttrVec outer_attribs = AST::AttrVec ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_block), locus,\n \t\t    std::move (loop_label), std::move (outer_attribs)),\n       match_arm_patterns (std::move (match_arm_patterns)),\n@@ -3502,7 +3411,7 @@ class ForLoopExpr : public BaseLoopExpr\n \t       std::unique_ptr<Expr> iterator_expr,\n \t       std::unique_ptr<BlockExpr> loop_body, Location locus,\n \t       LoopLabel loop_label,\n-\t       std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+\t       AST::AttrVec outer_attribs = AST::AttrVec ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_body), locus,\n \t\t    std::move (loop_label), std::move (outer_attribs)),\n       pattern (std::move (loop_pattern)),\n@@ -3566,7 +3475,7 @@ class IfExpr : public ExprWithBlock\n \n   IfExpr (Analysis::NodeMapping mappings, std::unique_ptr<Expr> condition,\n \t  std::unique_ptr<BlockExpr> if_block, Location locus)\n-    : ExprWithBlock (std::move (mappings), std::vector<Attribute> ()),\n+    : ExprWithBlock (std::move (mappings), AST::AttrVec ()),\n       condition (std::move (condition)), if_block (std::move (if_block)),\n       locus (locus)\n   {}\n@@ -3784,7 +3693,7 @@ class IfLetExpr : public ExprWithBlock\n \t     std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n \t     Location locus)\n-    : ExprWithBlock (std::move (mappings), std::vector<Attribute> ()),\n+    : ExprWithBlock (std::move (mappings), AST::AttrVec ()),\n       match_arm_patterns (std::move (match_arm_patterns)),\n       value (std::move (value)), if_block (std::move (if_block)), locus (locus)\n   {}\n@@ -4119,7 +4028,7 @@ class IfLetExprConseqIfLet : public IfLetExpr\n struct MatchArm\n {\n private:\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n   // MatchArmPatterns patterns;\n   std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n \n@@ -4136,7 +4045,7 @@ struct MatchArm\n   // Constructor for match arm with a guard expression\n   MatchArm (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t    std::unique_ptr<Expr> guard_expr = nullptr,\n-\t    std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t    AST::AttrVec outer_attrs = AST::AttrVec ())\n     : outer_attrs (std::move (outer_attrs)),\n       match_arm_patterns (std::move (match_arm_patterns)),\n       guard_expr (std::move (guard_expr))\n@@ -4346,7 +4255,7 @@ class MatchCaseExpr : public MatchCase\n class MatchExpr : public ExprWithBlock\n {\n   std::unique_ptr<Expr> branch_value;\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n \n   // bool has_match_arms;\n   // MatchArms match_arms;\n@@ -4364,9 +4273,8 @@ class MatchExpr : public ExprWithBlock\n \n   MatchExpr (Analysis::NodeMapping mappings, std::unique_ptr<Expr> branch_value,\n \t     // std::vector<std::unique_ptr<MatchCase> > match_arms,\n-\t     std::vector<MatchCase> match_arms,\n-\t     std::vector<Attribute> inner_attrs,\n-\t     std::vector<Attribute> outer_attrs, Location locus)\n+\t     std::vector<MatchCase> match_arms, AST::AttrVec inner_attrs,\n+\t     AST::AttrVec outer_attrs, Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attrs)),\n       branch_value (std::move (branch_value)),\n       inner_attrs (std::move (inner_attrs)),\n@@ -4433,7 +4341,7 @@ class AwaitExpr : public ExprWithoutBlock\n public:\n   // TODO: ensure outer attributes are actually allowed\n   AwaitExpr (Analysis::NodeMapping mappings, std::unique_ptr<Expr> awaited_expr,\n-\t     std::vector<Attribute> outer_attrs, Location locus)\n+\t     AST::AttrVec outer_attrs, Location locus)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       awaited_expr (std::move (awaited_expr)), locus (locus)\n   {}\n@@ -4486,7 +4394,7 @@ class AsyncBlockExpr : public ExprWithBlock\n public:\n   AsyncBlockExpr (Analysis::NodeMapping mappings,\n \t\t  std::unique_ptr<BlockExpr> block_expr, bool has_move,\n-\t\t  std::vector<Attribute> outer_attrs, Location locus)\n+\t\t  AST::AttrVec outer_attrs, Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attrs)),\n       has_move (has_move), block_expr (std::move (block_expr)), locus (locus)\n   {}"}, {"sha": "cdbc0a04cd41e6e7e172e5c021b7bd52c48c75cd", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -24,19 +24,10 @@\n namespace Rust {\n namespace HIR {\n // rust-ast.h\n-class AttrInput;\n class TokenTree;\n class MacroMatch;\n class Token;\n struct Literal;\n-class DelimTokenTree;\n-class PathSegment;\n-class SimplePathSegment;\n-class SimplePath;\n-struct Attribute;\n-class MetaItemInner;\n-class AttrInputMetaItemContainer;\n-class MetaItem;\n class Stmt;\n class Item;\n class Expr;\n@@ -76,8 +67,6 @@ class QualifiedPathInType;\n class ExprWithBlock;\n class LiteralExpr;\n class AttrInputLiteral;\n-class MetaItemLitExpr;\n-class MetaItemPathLit;\n class OperatorExpr;\n class BorrowExpr;\n class DereferenceExpr;\n@@ -227,12 +216,6 @@ struct MacroTranscriber;\n struct MacroRule;\n class MacroRulesDefinition;\n class MacroInvocation;\n-class MetaItemPath;\n-class MetaItemSeq;\n-class MetaWord;\n-class MetaNameValueStr;\n-class MetaListPaths;\n-class MetaListNameValueStr;\n \n // rust-pattern.h\n class LiteralPattern;"}, {"sha": "dce85f38713184e380dc2349f452f0d78a2e3502", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 26, "deletions": 748, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -16,6 +16,7 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-hir-visitor.h\"\n #include \"rust-diagnostics.h\"\n@@ -52,15 +53,15 @@ indent_spaces (enum indent_mode mode)\n \n // Gets a string in a certain delim type.\n std::string\n-get_string_in_delims (std::string str_input, DelimType delim_type)\n+get_string_in_delims (std::string str_input, AST::DelimType delim_type)\n {\n   switch (delim_type)\n     {\n-    case PARENS:\n+    case AST::DelimType::PARENS:\n       return \"(\" + str_input + \")\";\n-    case SQUARE:\n+    case AST::DelimType::SQUARE:\n       return \"[\" + str_input + \"]\";\n-    case CURLY:\n+    case AST::DelimType::CURLY:\n       return \"{\" + str_input + \"}\";\n     default:\n       return \"ERROR-MARK-STRING (delims)\";\n@@ -162,67 +163,6 @@ Crate::as_string () const\n   return str + \"\\n::\" + get_mappings ().as_string () + \"\\n\";\n }\n \n-std::string\n-Attribute::as_string () const\n-{\n-  std::string path_str = path.as_string ();\n-  if (attr_input == nullptr)\n-    {\n-      return path_str;\n-    }\n-  else\n-    {\n-      return path_str + attr_input->as_string ();\n-    }\n-}\n-\n-std::string\n-DelimTokenTree::as_string () const\n-{\n-  std::string start_delim;\n-  std::string end_delim;\n-  switch (delim_type)\n-    {\n-    case PARENS:\n-      start_delim = \"(\";\n-      end_delim = \")\";\n-      break;\n-    case SQUARE:\n-      start_delim = \"[\";\n-      end_delim = \"]\";\n-      break;\n-    case CURLY:\n-      start_delim = \"{\";\n-      end_delim = \"}\";\n-      break;\n-    default:\n-      fprintf (stderr, \"Invalid delimiter type, \"\n-\t\t       \"Should be PARENS, SQUARE, or CURLY.\");\n-      return \"Invalid delimiter type\";\n-    }\n-  std::string str = start_delim;\n-  if (!token_trees.empty ())\n-    {\n-      for (const auto &tree : token_trees)\n-\t{\n-\t  // DEBUG: null pointer check\n-\t  if (tree == nullptr)\n-\t    {\n-\t      fprintf (\n-\t\tstderr,\n-\t\t\"something really terrible has gone wrong - null pointer \"\n-\t\t\"token tree in delim token tree.\");\n-\t      return \"nullptr_POINTER_MARK\";\n-\t    }\n-\n-\t  str += tree->as_string ();\n-\t}\n-    }\n-  str += end_delim;\n-\n-  return str;\n-}\n-\n std::string\n Token::as_string () const\n {\n@@ -235,49 +175,6 @@ Token::as_string () const\n   return quote + str + quote;\n }\n \n-std::string\n-SimplePathSegment::as_string () const\n-{\n-  return segment_name;\n-}\n-\n-std::string\n-SimplePath::as_string () const\n-{\n-  std::string path;\n-  if (has_opening_scope_resolution)\n-    {\n-      path = \"::\";\n-    }\n-\n-  // crappy hack because doing proper for loop would be more code\n-  bool first_time = true;\n-  for (const auto &segment : segments)\n-    {\n-      if (first_time)\n-\t{\n-\t  path += segment.as_string ();\n-\t  first_time = false;\n-\t}\n-      else\n-\t{\n-\t  path += \"::\" + segment.as_string ();\n-\t}\n-\n-      // DEBUG: remove later. Checks for path error.\n-      if (segment.is_error ())\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"segment in path is error - this should've been filtered \"\n-\t\t   \"out. first segment \"\n-\t\t   \"was '%s' \\n\",\n-\t\t   segments.at (0).as_string ().c_str ());\n-\t}\n-    }\n-\n-  return path;\n-}\n-\n std::string\n Visibility::as_string () const\n {\n@@ -1456,13 +1353,13 @@ MacroRulesDefinition::as_string () const\n   str += \"\\n Delim type: \";\n   switch (delim_type)\n     {\n-    case PARENS:\n+    case AST::DelimType::PARENS:\n       str += \"parentheses\";\n       break;\n-    case SQUARE:\n+    case AST::DelimType::SQUARE:\n       str += \"square\";\n       break;\n-    case CURLY:\n+    case AST::DelimType::CURLY:\n       str += \"curly\";\n       break;\n     default:\n@@ -2460,13 +2357,13 @@ MacroMatcher::as_string () const\n \n   switch (delim_type)\n     {\n-    case PARENS:\n+    case AST::DelimType::PARENS:\n       str += \"parentheses\";\n       break;\n-    case SQUARE:\n+    case AST::DelimType::SQUARE:\n       str += \"square\";\n       break;\n-    case CURLY:\n+    case AST::DelimType::CURLY:\n       str += \"curly\";\n       break;\n     default:\n@@ -2677,30 +2574,30 @@ TypeParam::as_string () const\n   return str;\n }\n \n-SimplePath\n+AST::SimplePath\n PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n {\n   if (!has_segments ())\n     {\n-      return SimplePath::create_empty ();\n+      return AST::SimplePath::create_empty ();\n     }\n \n   // create vector of reserved size (to minimise reallocations)\n-  std::vector<SimplePathSegment> simple_segments;\n+  std::vector<AST::SimplePathSegment> simple_segments;\n   simple_segments.reserve (segments.size ());\n \n   for (const auto &segment : segments)\n     {\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment.has_generic_args () || segment.as_string () == \"Self\")\n \t{\n-\t  return SimplePath::create_empty ();\n+\t  return AST::SimplePath::create_empty ();\n \t}\n \n       // create segment and add to vector\n       std::string segment_str = segment.as_string ();\n       simple_segments.push_back (\n-\tSimplePathSegment (std::move (segment_str), segment.get_locus ()));\n+\tAST::SimplePathSegment (std::move (segment_str), segment.get_locus ()));\n     }\n \n   // kind of a HACK to get locus depending on opening scope resolution\n@@ -2714,20 +2611,20 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n       locus = simple_segments[0].get_locus ();\n     }\n \n-  return SimplePath (std::move (simple_segments), with_opening_scope_resolution,\n-\t\t     locus);\n+  return AST::SimplePath (std::move (simple_segments),\n+\t\t\t  with_opening_scope_resolution, locus);\n }\n \n-SimplePath\n+AST::SimplePath\n TypePath::as_simple_path () const\n {\n   if (segments.empty ())\n     {\n-      return SimplePath::create_empty ();\n+      return AST::SimplePath::create_empty ();\n     }\n \n   // create vector of reserved size (to minimise reallocations)\n-  std::vector<SimplePathSegment> simple_segments;\n+  std::vector<AST::SimplePathSegment> simple_segments;\n   simple_segments.reserve (segments.size ());\n \n   for (const auto &segment : segments)\n@@ -2736,17 +2633,18 @@ TypePath::as_simple_path () const\n       if (segment == nullptr || segment->is_error ()\n \t  || !segment->is_ident_only () || segment->as_string () == \"Self\")\n \t{\n-\t  return SimplePath::create_empty ();\n+\t  return AST::SimplePath::create_empty ();\n \t}\n \n       // create segment and add to vector\n       std::string segment_str = segment->as_string ();\n       simple_segments.push_back (\n-\tSimplePathSegment (std::move (segment_str), segment->get_locus ()));\n+\tAST::SimplePathSegment (std::move (segment_str),\n+\t\t\t\tsegment->get_locus ()));\n     }\n \n-  return SimplePath (std::move (simple_segments), has_opening_scope_resolution,\n-\t\t     locus);\n+  return AST::SimplePath (std::move (simple_segments),\n+\t\t\t  has_opening_scope_resolution, locus);\n }\n \n std::string\n@@ -4391,78 +4289,6 @@ MaybeNamedParam::as_string () const\n   return str;\n }\n \n-std::string\n-MetaItemSeq::as_string () const\n-{\n-  std::string path_str = path.as_string () + \"(\";\n-\n-  auto i = seq.begin ();\n-  auto e = seq.end ();\n-\n-  for (; i != e; i++)\n-    {\n-      path_str += (*i)->as_string ();\n-      if (e != i + 1)\n-\tpath_str += \", \";\n-    }\n-\n-  return path_str + \")\";\n-}\n-\n-std::string\n-MetaListPaths::as_string () const\n-{\n-  std::string str = ident + \"(\";\n-\n-  auto i = paths.begin ();\n-  auto e = paths.end ();\n-\n-  for (; i != e; i++)\n-    {\n-      str += (*i).as_string ();\n-      if (e != i + 1)\n-\tstr += \", \";\n-    }\n-\n-  return str + \")\";\n-}\n-\n-std::string\n-MetaListNameValueStr::as_string () const\n-{\n-  std::string str = ident + \"(\";\n-\n-  auto i = strs.begin ();\n-  auto e = strs.end ();\n-\n-  for (; i != e; i++)\n-    {\n-      str += (*i).as_string ();\n-      if (e != i + 1)\n-\tstr += \", \";\n-    }\n-\n-  return str + \")\";\n-}\n-\n-std::string\n-AttrInputMetaItemContainer::as_string () const\n-{\n-  std::string str = \"(\";\n-\n-  auto i = items.begin ();\n-  auto e = items.end ();\n-\n-  for (; i != e; i++)\n-    {\n-      str += (*i)->as_string ();\n-      if (e != i + 1)\n-\tstr += \", \";\n-    }\n-\n-  return str + \")\";\n-}\n-\n /* Override that calls the function recursively on all items contained within\n  * the module. */\n void\n@@ -4475,412 +4301,6 @@ ModuleBodied::add_crate_name (std::vector<std::string> &names) const\n     item->add_crate_name (names);\n }\n \n-void\n-Attribute::parse_attr_to_meta_item ()\n-{\n-  // only parse if has attribute input\n-  if (!has_attr_input ())\n-    return;\n-\n-  std::unique_ptr<AttrInput> converted_input (\n-    attr_input->parse_to_meta_item ());\n-\n-  if (converted_input != nullptr)\n-    attr_input = std::move (converted_input);\n-}\n-\n-AttrInput *\n-DelimTokenTree::parse_to_meta_item () const\n-{\n-  // must have token trees\n-  if (token_trees.empty ())\n-    return nullptr;\n-\n-  /* assume top-level delim token tree in attribute - convert all nested ones\n-   * to token stream */\n-  std::vector<std::unique_ptr<Token> > token_stream = to_token_stream ();\n-\n-  MacroParser parser (std::move (token_stream));\n-  std::vector<std::unique_ptr<MetaItemInner> > meta_items (\n-    parser.parse_meta_item_seq ());\n-\n-  return new AttrInputMetaItemContainer (std::move (meta_items));\n-}\n-\n-std::unique_ptr<MetaItemInner>\n-MacroParser::parse_meta_item_inner ()\n-{\n-  // if first tok not identifier, not a \"special\" case one\n-  if (peek_token ()->get_id () != IDENTIFIER)\n-    {\n-      switch (peek_token ()->get_id ())\n-\t{\n-\tcase CHAR_LITERAL:\n-\tcase STRING_LITERAL:\n-\tcase BYTE_CHAR_LITERAL:\n-\tcase BYTE_STRING_LITERAL:\n-\tcase INT_LITERAL:\n-\tcase FLOAT_LITERAL:\n-\tcase TRUE_LITERAL:\n-\tcase FALSE_LITERAL:\n-\t  // stream_pos++;\n-\t  return parse_meta_item_lit ();\n-\tcase SUPER:\n-\tcase SELF:\n-\tcase CRATE:\n-\tcase DOLLAR_SIGN:\n-\t  case SCOPE_RESOLUTION: {\n-\t    return parse_path_meta_item ();\n-\t  }\n-\tdefault:\n-\t  rust_error_at (peek_token ()->get_locus (),\n-\t\t\t \"unrecognised token '%s' in meta item\",\n-\t\t\t get_token_description (peek_token ()->get_id ()));\n-\t  return nullptr;\n-\t}\n-    }\n-\n-  // else, check for path\n-  if (peek_token (1)->get_id () == SCOPE_RESOLUTION)\n-    {\n-      // path\n-      return parse_path_meta_item ();\n-    }\n-\n-  Identifier ident = peek_token ()->as_string ();\n-  if (is_end_meta_item_tok (peek_token (1)->get_id ()))\n-    {\n-      // meta word syntax\n-      skip_token ();\n-      return std::unique_ptr<MetaWord> (new MetaWord (std::move (ident)));\n-    }\n-\n-  if (peek_token (1)->get_id () == EQUAL)\n-    {\n-      // maybe meta name value str syntax - check next 2 tokens\n-      if (peek_token (2)->get_id () == STRING_LITERAL\n-\t  && is_end_meta_item_tok (peek_token (3)->get_id ()))\n-\t{\n-\t  // meta name value str syntax\n-\t  std::string value = peek_token (2)->as_string ();\n-\n-\t  skip_token (2);\n-\n-\t  return std::unique_ptr<MetaNameValueStr> (\n-\t    new MetaNameValueStr (std::move (ident), std::move (value)));\n-\t}\n-      else\n-\t{\n-\t  // just interpret as path-based meta item\n-\t  return parse_path_meta_item ();\n-\t}\n-    }\n-\n-  if (peek_token (1)->get_id () != LEFT_PAREN)\n-    {\n-      rust_error_at (peek_token (1)->get_locus (),\n-\t\t     \"unexpected token '%s' after identifier in attribute\",\n-\t\t     get_token_description (peek_token (1)->get_id ()));\n-      return nullptr;\n-    }\n-\n-  /* HACK: parse parenthesised sequence, and then try conversions to other\n-   * stuff */\n-  std::vector<std::unique_ptr<MetaItemInner> > meta_items\n-    = parse_meta_item_seq ();\n-\n-  // pass for meta name value str\n-  std::vector<MetaNameValueStr> meta_name_value_str_items;\n-  for (const auto &item : meta_items)\n-    {\n-      std::unique_ptr<MetaNameValueStr> converted_item\n-\t= item->to_meta_name_value_str ();\n-      if (converted_item == nullptr)\n-\t{\n-\t  meta_name_value_str_items.clear ();\n-\t  break;\n-\t}\n-      meta_name_value_str_items.push_back (std::move (*converted_item));\n-    }\n-  // if valid, return this\n-  if (!meta_name_value_str_items.empty ())\n-    {\n-      return std::unique_ptr<MetaListNameValueStr> (\n-\tnew MetaListNameValueStr (std::move (ident),\n-\t\t\t\t  std::move (meta_name_value_str_items)));\n-    }\n-\n-  // pass for meta list idents\n-  /*std::vector<Identifier> ident_items;\n-  for (const auto& item : meta_items) {\n-      std::unique_ptr<Identifier> converted_ident(item->to_ident_item());\n-      if (converted_ident == nullptr) {\n-\t  ident_items.clear();\n-\t  break;\n-      }\n-      ident_items.push_back(std::move(*converted_ident));\n-  }\n-  // if valid return this\n-  if (!ident_items.empty()) {\n-      return std::unique_ptr<MetaListIdents>(new\n-  MetaListIdents(std::move(ident),\n-  std::move(ident_items)));\n-  }*/\n-  // as currently no meta list ident, currently no path. may change in future\n-\n-  // pass for meta list paths\n-  std::vector<SimplePath> path_items;\n-  for (const auto &item : meta_items)\n-    {\n-      SimplePath converted_path (item->to_path_item ());\n-      if (converted_path.is_empty ())\n-\t{\n-\t  path_items.clear ();\n-\t  break;\n-\t}\n-      path_items.push_back (std::move (converted_path));\n-    }\n-  if (!path_items.empty ())\n-    {\n-      return std::unique_ptr<MetaListPaths> (\n-\tnew MetaListPaths (std::move (ident), std::move (path_items)));\n-    }\n-\n-  rust_error_at (Linemap::unknown_location (),\n-\t\t \"failed to parse any meta item inner\");\n-  return nullptr;\n-}\n-\n-bool\n-MacroParser::is_end_meta_item_tok (TokenId id) const\n-{\n-  return id == COMMA || id == RIGHT_PAREN;\n-}\n-\n-std::unique_ptr<MetaItem>\n-MacroParser::parse_path_meta_item ()\n-{\n-  SimplePath path = parse_simple_path ();\n-  if (path.is_empty ())\n-    {\n-      rust_error_at (peek_token ()->get_locus (),\n-\t\t     \"failed to parse simple path in attribute\");\n-      return nullptr;\n-    }\n-\n-  switch (peek_token ()->get_id ())\n-    {\n-      case LEFT_PAREN: {\n-\tstd::vector<std::unique_ptr<MetaItemInner> > meta_items\n-\t  = parse_meta_item_seq ();\n-\n-\treturn std::unique_ptr<MetaItemSeq> (\n-\t  new MetaItemSeq (std::move (path), std::move (meta_items)));\n-      }\n-      case EQUAL: {\n-\tskip_token ();\n-\n-\tLocation locus = peek_token ()->get_locus ();\n-\tLiteral lit = parse_literal ();\n-\tif (lit.is_error ())\n-\t  {\n-\t    rust_error_at (peek_token ()->get_locus (),\n-\t\t\t   \"failed to parse literal in attribute\");\n-\t    return nullptr;\n-\t  }\n-\tLiteralExpr expr (Analysis::NodeMapping::get_error (), std::move (lit),\n-\t\t\t  locus);\n-\t// stream_pos++;\n-\t/* shouldn't be required anymore due to parsing literal actually\n-\t * skipping the token */\n-\treturn std::unique_ptr<MetaItemPathLit> (\n-\t  new MetaItemPathLit (std::move (path), std::move (expr)));\n-      }\n-    case COMMA:\n-      // just simple path\n-      return std::unique_ptr<MetaItemPath> (\n-\tnew MetaItemPath (std::move (path)));\n-    default:\n-      rust_error_at (peek_token ()->get_locus (),\n-\t\t     \"unrecognised token '%s' in meta item\",\n-\t\t     get_token_description (peek_token ()->get_id ()));\n-      return nullptr;\n-    }\n-}\n-\n-/* Parses a parenthesised sequence of meta item inners. Parentheses are\n- * required here. */\n-std::vector<std::unique_ptr<MetaItemInner> >\n-MacroParser::parse_meta_item_seq ()\n-{\n-  if (stream_pos != 0)\n-    {\n-      // warning?\n-      fprintf (stderr,\n-\t       \"WARNING: stream pos for parse_meta_item_seq is not 0!\\n\");\n-    }\n-\n-  // int i = 0;\n-  int vec_length = token_stream.size ();\n-  std::vector<std::unique_ptr<MetaItemInner> > meta_items;\n-\n-  if (peek_token ()->get_id () != LEFT_PAREN)\n-    {\n-      rust_error_at (peek_token ()->get_locus (),\n-\t\t     \"missing left paren in delim token tree\");\n-      return {};\n-    }\n-  skip_token ();\n-\n-  while (stream_pos < vec_length && peek_token ()->get_id () != RIGHT_PAREN)\n-    {\n-      std::unique_ptr<MetaItemInner> inner = parse_meta_item_inner ();\n-      if (inner == nullptr)\n-\t{\n-\t  rust_error_at (peek_token ()->get_locus (),\n-\t\t\t \"failed to parse inner meta item in attribute\");\n-\t  return {};\n-\t}\n-      meta_items.push_back (std::move (inner));\n-\n-      if (peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      skip_token ();\n-    }\n-\n-  if (peek_token ()->get_id () != RIGHT_PAREN)\n-    {\n-      rust_error_at (peek_token ()->get_locus (),\n-\t\t     \"missing right paren in delim token tree\");\n-      return {};\n-    }\n-  skip_token ();\n-\n-  return meta_items;\n-}\n-\n-/* Collects any nested token trees into a flat token stream, suitable for\n- * parsing. */\n-std::vector<std::unique_ptr<Token> >\n-DelimTokenTree::to_token_stream () const\n-{\n-  std::vector<std::unique_ptr<Token> > tokens;\n-\n-  // simulate presence of delimiters\n-  tokens.push_back (\n-    std::unique_ptr<Token> (new Token (LEFT_PAREN, Linemap::unknown_location (),\n-\t\t\t\t       \"\", CORETYPE_UNKNOWN)));\n-\n-  for (const auto &tree : token_trees)\n-    {\n-      std::vector<std::unique_ptr<Token> > stream = tree->to_token_stream ();\n-\n-      tokens.insert (tokens.end (), std::make_move_iterator (stream.begin ()),\n-\t\t     std::make_move_iterator (stream.end ()));\n-    }\n-\n-  tokens.push_back (std::unique_ptr<Token> (\n-    new Token (RIGHT_PAREN, Linemap::unknown_location (), \"\",\n-\t       CORETYPE_UNKNOWN)));\n-\n-  tokens.shrink_to_fit ();\n-\n-  return tokens;\n-}\n-\n-Literal\n-MacroParser::parse_literal ()\n-{\n-  // marcos need to be removed from HIR\n-  gcc_unreachable ();\n-}\n-\n-SimplePath\n-MacroParser::parse_simple_path ()\n-{\n-  bool has_opening_scope_res = false;\n-  if (peek_token ()->get_id () == SCOPE_RESOLUTION)\n-    {\n-      has_opening_scope_res = true;\n-      skip_token ();\n-    }\n-\n-  std::vector<SimplePathSegment> segments;\n-\n-  SimplePathSegment segment = parse_simple_path_segment ();\n-  if (segment.is_error ())\n-    {\n-      rust_error_at (\n-\tpeek_token ()->get_locus (),\n-\t\"failed to parse simple path segment in attribute simple path\");\n-      return SimplePath::create_empty ();\n-    }\n-  segments.push_back (std::move (segment));\n-\n-  while (peek_token ()->get_id () == SCOPE_RESOLUTION)\n-    {\n-      skip_token ();\n-\n-      SimplePathSegment segment = parse_simple_path_segment ();\n-      if (segment.is_error ())\n-\t{\n-\t  rust_error_at (\n-\t    peek_token ()->get_locus (),\n-\t    \"failed to parse simple path segment in attribute simple path\");\n-\t  return SimplePath::create_empty ();\n-\t}\n-      segments.push_back (std::move (segment));\n-    }\n-  segments.shrink_to_fit ();\n-\n-  return SimplePath (std::move (segments), has_opening_scope_res);\n-}\n-\n-SimplePathSegment\n-MacroParser::parse_simple_path_segment ()\n-{\n-  const std::unique_ptr<Token> &tok = peek_token ();\n-  switch (tok->get_id ())\n-    {\n-    case IDENTIFIER:\n-      skip_token ();\n-      return SimplePathSegment (tok->as_string (), tok->get_locus ());\n-    case SUPER:\n-      skip_token ();\n-      return SimplePathSegment (\"super\", tok->get_locus ());\n-    case SELF:\n-      skip_token ();\n-      return SimplePathSegment (\"self\", tok->get_locus ());\n-    case CRATE:\n-      skip_token ();\n-      return SimplePathSegment (\"crate\", tok->get_locus ());\n-    case DOLLAR_SIGN:\n-      if (peek_token (1)->get_id () == CRATE)\n-\t{\n-\t  skip_token (1);\n-\t  return SimplePathSegment (\"$crate\", tok->get_locus ());\n-\t}\n-      gcc_fallthrough ();\n-    default:\n-      rust_error_at (tok->get_locus (),\n-\t\t     \"unexpected token '%s' in simple path segment\",\n-\t\t     get_token_description (tok->get_id ()));\n-      return SimplePathSegment::create_error ();\n-    }\n-}\n-\n-std::unique_ptr<MetaItemLitExpr>\n-MacroParser::parse_meta_item_lit ()\n-{\n-  Location locus = peek_token ()->get_locus ();\n-  LiteralExpr lit_expr (Analysis::NodeMapping::get_error (), parse_literal (),\n-\t\t\tlocus);\n-  return std::unique_ptr<MetaItemLitExpr> (\n-    new MetaItemLitExpr (std::move (lit_expr)));\n-}\n-\n std::vector<std::unique_ptr<Token> >\n Token::to_token_stream () const\n {\n@@ -4892,83 +4312,6 @@ Token::to_token_stream () const\n   return dummy_vector;\n }\n \n-Attribute\n-MetaNameValueStr::to_attribute () const\n-{\n-  LiteralExpr lit_expr (Analysis::NodeMapping::get_error (), str,\n-\t\t\tLiteral::LitType::STRING,\n-\t\t\tPrimitiveCoreType::CORETYPE_STR, Location ());\n-  return Attribute (SimplePath::from_str (ident),\n-\t\t    std::unique_ptr<AttrInputLiteral> (\n-\t\t      new AttrInputLiteral (std::move (lit_expr))));\n-}\n-\n-Attribute\n-MetaItemPath::to_attribute () const\n-{\n-  return Attribute (path, nullptr);\n-}\n-\n-Attribute\n-MetaItemSeq::to_attribute () const\n-{\n-  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n-  new_seq.reserve (seq.size ());\n-  for (const auto &e : seq)\n-    new_seq.push_back (e->clone_meta_item_inner ());\n-\n-  std::unique_ptr<AttrInputMetaItemContainer> new_seq_container (\n-    new AttrInputMetaItemContainer (std::move (new_seq)));\n-  return Attribute (path, std::move (new_seq_container));\n-}\n-\n-Attribute\n-MetaWord::to_attribute () const\n-{\n-  return Attribute (SimplePath::from_str (ident), nullptr);\n-}\n-\n-Attribute\n-MetaListPaths::to_attribute () const\n-{\n-  /* probably one of the most annoying conversions - have to lose specificity by\n-   * turning it into just AttrInputMetaItemContainer (i.e. paths-only nature is\n-   * no longer known). If conversions back are required, might have to do a\n-   * \"check all are paths\" pass or something. */\n-\n-  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n-  new_seq.reserve (paths.size ());\n-  for (const auto &e : paths)\n-    new_seq.push_back (std::unique_ptr<MetaItemPath> (new MetaItemPath (e)));\n-\n-  std::unique_ptr<AttrInputMetaItemContainer> new_seq_container (\n-    new AttrInputMetaItemContainer (std::move (new_seq)));\n-  return Attribute (SimplePath::from_str (ident),\n-\t\t    std::move (new_seq_container));\n-}\n-\n-Attribute\n-MetaListNameValueStr::to_attribute () const\n-{\n-  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n-  new_seq.reserve (strs.size ());\n-  for (const auto &e : strs)\n-    new_seq.push_back (\n-      std::unique_ptr<MetaNameValueStr> (new MetaNameValueStr (e)));\n-\n-  std::unique_ptr<AttrInputMetaItemContainer> new_seq_container (\n-    new AttrInputMetaItemContainer (std::move (new_seq)));\n-  return Attribute (SimplePath::from_str (ident),\n-\t\t    std::move (new_seq_container));\n-}\n-\n-Attribute\n-MetaItemPathLit::to_attribute () const\n-{\n-  return Attribute (path, std::unique_ptr<AttrInputLiteral> (\n-\t\t\t    new AttrInputLiteral (lit)));\n-}\n-\n /* Visitor implementations - these are short but inlining can't happen anyway\n  * due to virtual functions and I didn't want to make the ast header includes\n  * any longer than they already are. */\n@@ -4979,12 +4322,6 @@ Token::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-DelimTokenTree::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n IdentifierExpr::accept_vis (HIRVisitor &vis)\n {\n@@ -5051,24 +4388,6 @@ LiteralExpr::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-AttrInputLiteral::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaItemLitExpr::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaItemPathLit::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n BorrowExpr::accept_vis (HIRVisitor &vis)\n {\n@@ -5903,46 +5222,5 @@ BareFunctionType::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-MetaItemSeq::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaItemPath::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaListPaths::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaNameValueStr::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaListNameValueStr::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-AttrInputMetaItemContainer::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MetaWord::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n } // namespace HIR\n } // namespace Rust"}, {"sha": "6ac936c552e14d9f84eb956626ba9ce05a558dda", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_HIR_ITEM_H\n #define RUST_HIR_ITEM_H\n \n+#include \"rust-ast-full-decls.h\"\n #include \"rust-hir.h\"\n #include \"rust-hir-path.h\"\n \n@@ -33,7 +34,7 @@ class TypeParam : public GenericParam\n {\n   // bool has_outer_attribute;\n   // std::unique_ptr<Attribute> outer_attr;\n-  Attribute outer_attr;\n+  AST::Attribute outer_attr;\n \n   Identifier type_representation;\n \n@@ -62,7 +63,7 @@ class TypeParam : public GenericParam\n \t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n \t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n \t     std::unique_ptr<Type> type = nullptr,\n-\t     Attribute outer_attr = Attribute::create_empty ())\n+\t     AST::Attribute outer_attr = AST::Attribute::create_empty ())\n     : GenericParam (mappings), outer_attr (std::move (outer_attr)),\n       type_representation (std::move (type_representation)),\n       type_param_bounds (std::move (type_param_bounds)),\n@@ -504,13 +505,13 @@ struct Visibility\n   // if vis is public, one of these\n   PublicVisType public_vis_type;\n   // Only assigned if public_vis_type is IN_PATH\n-  SimplePath in_path;\n+  AST::SimplePath in_path;\n \n   // should this store location info?\n \n public:\n   // Creates a Visibility - TODO make constructor protected or private?\n-  Visibility (PublicVisType public_vis_type, SimplePath in_path)\n+  Visibility (PublicVisType public_vis_type, AST::SimplePath in_path)\n     : public_vis_type (public_vis_type), in_path (std::move (in_path))\n   {}\n \n@@ -523,7 +524,7 @@ struct Visibility\n   // Creates an error visibility.\n   static Visibility create_error ()\n   {\n-    return Visibility (IN_PATH, SimplePath::create_empty ());\n+    return Visibility (IN_PATH, AST::SimplePath::create_empty ());\n   }\n \n   // Unique pointer custom clone function\n@@ -537,30 +538,30 @@ struct Visibility\n   // Creates a public visibility with no further features/arguments.\n   static Visibility create_public ()\n   {\n-    return Visibility (NONE, SimplePath::create_empty ());\n+    return Visibility (NONE, AST::SimplePath::create_empty ());\n   }\n \n   // Creates a public visibility with crate-relative paths or whatever.\n   static Visibility create_crate ()\n   {\n-    return Visibility (CRATE, SimplePath::create_empty ());\n+    return Visibility (CRATE, AST::SimplePath::create_empty ());\n   }\n \n   // Creates a public visibility with self-relative paths or whatever.\n   static Visibility create_self ()\n   {\n-    return Visibility (SELF, SimplePath::create_empty ());\n+    return Visibility (SELF, AST::SimplePath::create_empty ());\n   }\n \n   // Creates a public visibility with parent module-relative paths or\n   // whatever.\n   static Visibility create_super ()\n   {\n-    return Visibility (SUPER, SimplePath::create_empty ());\n+    return Visibility (SUPER, AST::SimplePath::create_empty ());\n   }\n \n   // Creates a public visibility with a given path or whatever.\n-  static Visibility create_in_path (SimplePath in_path)\n+  static Visibility create_in_path (AST::SimplePath in_path)\n   {\n     return Visibility (IN_PATH, std::move (in_path));\n   }\n@@ -582,7 +583,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   Analysis::NodeMapping mappings;\n \n   // moved from impl items for consistency\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n   Visibility vis;\n \n   FunctionQualifiers qualifiers;\n@@ -632,7 +633,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t  std::vector<Attribute> outer_attrs, Location locus = Location ())\n+\t  AST::AttrVec outer_attrs, Location locus = Location ())\n     : mappings (mappings), outer_attrs (std::move (outer_attrs)),\n       vis (std::move (vis)), qualifiers (std::move (qualifiers)),\n       method_name (std::move (method_name)),\n@@ -777,7 +778,7 @@ class VisItem : public Item\n protected:\n   // Visibility constructor\n   VisItem (Analysis::NodeMapping mappings, Visibility visibility,\n-\t   std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t   AST::AttrVec outer_attrs = AST::AttrVec ())\n     : Item (std::move (mappings), std::move (outer_attrs)),\n       visibility (std::move (visibility))\n   {}\n@@ -820,7 +821,7 @@ class Module : public VisItem\n   // Protected constructor\n   Module (Analysis::NodeMapping mappings, Identifier module_name,\n \t  Visibility visibility, Location locus,\n-\t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t  AST::AttrVec outer_attrs = AST::AttrVec ())\n     : VisItem (std::move (mappings), std::move (visibility),\n \t       std::move (outer_attrs)),\n       module_name (module_name), locus (locus)\n@@ -836,7 +837,7 @@ class Module : public VisItem\n class ModuleBodied : public Module\n {\n   // bool has_inner_attrs;\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n   // bool has_items;\n   std::vector<std::unique_ptr<Item> > items;\n \n@@ -854,8 +855,8 @@ class ModuleBodied : public Module\n \t\tstd::vector<std::unique_ptr<Item> > items\n \t\t= std::vector<std::unique_ptr<Item> > (),\n \t\tVisibility visibility = Visibility::create_error (),\n-\t\tstd::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n-\t\tstd::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t\tAST::AttrVec inner_attrs = AST::AttrVec (),\n+\t\tAST::AttrVec outer_attrs = AST::AttrVec ())\n     : Module (std::move (mappings), std::move (name), std::move (visibility),\n \t      locus, std::move (outer_attrs)),\n       inner_attrs (std::move (inner_attrs)), items (std::move (items))\n@@ -916,8 +917,7 @@ class ModuleNoBody : public Module\n \n   // Full constructor\n   ModuleNoBody (Analysis::NodeMapping mappings, Identifier name,\n-\t\tVisibility visibility, std::vector<Attribute> outer_attrs,\n-\t\tLocation locus)\n+\t\tVisibility visibility, AST::AttrVec outer_attrs, Location locus)\n     : Module (std::move (mappings), std::move (name), std::move (visibility),\n \t      locus, std::move (outer_attrs))\n   {}\n@@ -967,8 +967,8 @@ class ExternCrate : public VisItem\n \n   // Constructor\n   ExternCrate (Analysis::NodeMapping mappings, std::string referenced_crate,\n-\t       Visibility visibility, std::vector<Attribute> outer_attrs,\n-\t       Location locus, std::string as_clause_name = std::string ())\n+\t       Visibility visibility, AST::AttrVec outer_attrs, Location locus,\n+\t       std::string as_clause_name = std::string ())\n     : VisItem (std::move (mappings), std::move (visibility),\n \t       std::move (outer_attrs)),\n       referenced_crate (std::move (referenced_crate)),\n@@ -1040,10 +1040,10 @@ class UseTreeGlob : public UseTree\n \n private:\n   PathType glob_type;\n-  SimplePath path;\n+  AST::SimplePath path;\n \n public:\n-  UseTreeGlob (PathType glob_type, SimplePath path, Location locus)\n+  UseTreeGlob (PathType glob_type, AST::SimplePath path, Location locus)\n     : UseTree (locus), glob_type (glob_type), path (std::move (path))\n   {\n     if (this->glob_type != PATH_PREFIXED)\n@@ -1088,12 +1088,12 @@ class UseTreeList : public UseTree\n \n private:\n   PathType path_type;\n-  SimplePath path;\n+  AST::SimplePath path;\n \n   std::vector<std::unique_ptr<UseTree> > trees;\n \n public:\n-  UseTreeList (PathType path_type, SimplePath path,\n+  UseTreeList (PathType path_type, AST::SimplePath path,\n \t       std::vector<std::unique_ptr<UseTree> > trees, Location locus)\n     : UseTree (locus), path_type (path_type), path (std::move (path)),\n       trees (std::move (trees))\n@@ -1168,13 +1168,13 @@ class UseTreeRebind : public UseTree\n   };\n \n private:\n-  SimplePath path;\n+  AST::SimplePath path;\n \n   NewBindType bind_type;\n   Identifier identifier; // only if NewBindType is IDENTIFIER\n \n public:\n-  UseTreeRebind (NewBindType bind_type, SimplePath path, Location locus,\n+  UseTreeRebind (NewBindType bind_type, AST::SimplePath path, Location locus,\n \t\t Identifier identifier = std::string ())\n     : UseTree (locus), path (std::move (path)), bind_type (bind_type),\n       identifier (std::move (identifier))\n@@ -1212,7 +1212,7 @@ class UseDeclaration : public VisItem\n \n   UseDeclaration (Analysis::NodeMapping mappings,\n \t\t  std::unique_ptr<UseTree> use_tree, Visibility visibility,\n-\t\t  std::vector<Attribute> outer_attrs, Location locus)\n+\t\t  AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (visibility),\n \t       std::move (outer_attrs)),\n       use_tree (std::move (use_tree)), locus (locus)\n@@ -1312,7 +1312,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t    std::vector<Attribute> outer_attrs, Location locus)\n+\t    AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       qualifiers (std::move (qualifiers)),\n       function_name (std::move (function_name)),\n@@ -1474,7 +1474,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n   TypeAlias (Analysis::NodeMapping mappings, Identifier new_type_name,\n \t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t     WhereClause where_clause, std::unique_ptr<Type> existing_type,\n-\t     Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n+\t     Visibility vis, AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       new_type_name (std::move (new_type_name)),\n       generic_params (std::move (generic_params)),\n@@ -1600,7 +1600,7 @@ class Struct : public VisItem\n   Struct (Analysis::NodeMapping mappings, Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t  WhereClause where_clause, Visibility vis, Location locus,\n-\t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t  AST::AttrVec outer_attrs = AST::AttrVec ())\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       struct_name (std::move (struct_name)),\n       generic_params (std::move (generic_params)),\n@@ -1642,7 +1642,7 @@ struct StructField\n {\n public:\n   // bool has_outer_attributes;\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   // bool has_visibility;\n   Visibility visibility;\n@@ -1664,7 +1664,7 @@ struct StructField\n \n   StructField (Analysis::NodeMapping mappings, Identifier field_name,\n \t       std::unique_ptr<Type> field_type, Visibility vis, Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t       AST::AttrVec outer_attrs = AST::AttrVec ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n       field_name (std::move (field_name)), field_type (std::move (field_type)),\n       mappings (mappings), locus (locus)\n@@ -1724,7 +1724,7 @@ class StructStruct : public Struct\n \t\tIdentifier struct_name,\n \t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tWhereClause where_clause, bool is_unit, Visibility vis,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+\t\tAST::AttrVec outer_attrs, Location locus)\n     : Struct (std::move (mappings), std::move (struct_name),\n \t      std::move (generic_params), std::move (where_clause),\n \t      std::move (vis), locus, std::move (outer_attrs)),\n@@ -1735,7 +1735,7 @@ class StructStruct : public Struct\n   StructStruct (Analysis::NodeMapping mappings, Identifier struct_name,\n \t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tWhereClause where_clause, Visibility vis,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+\t\tAST::AttrVec outer_attrs, Location locus)\n     : Struct (std::move (mappings), std::move (struct_name),\n \t      std::move (generic_params), std::move (where_clause),\n \t      std::move (vis), locus, std::move (outer_attrs)),\n@@ -1779,7 +1779,7 @@ struct TupleField\n {\n private:\n   // bool has_outer_attributes;\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   // bool has_visibility;\n   Visibility visibility;\n@@ -1801,7 +1801,7 @@ struct TupleField\n   // Complete constructor\n   TupleField (Analysis::NodeMapping mapping, std::unique_ptr<Type> field_type,\n \t      Visibility vis, Location locus,\n-\t      std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+\t      AST::AttrVec outer_attrs = AST::AttrVec ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n       field_type (std::move (field_type)), locus (locus), mappings (mapping)\n   {}\n@@ -1856,7 +1856,7 @@ class TupleStruct : public Struct\n \t       Identifier struct_name,\n \t       std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t       WhereClause where_clause, Visibility vis,\n-\t       std::vector<Attribute> outer_attrs, Location locus)\n+\t       AST::AttrVec outer_attrs, Location locus)\n     : Struct (std::move (mappings), std::move (struct_name),\n \t      std::move (generic_params), std::move (where_clause),\n \t      std::move (vis), locus, std::move (outer_attrs)),\n@@ -1897,7 +1897,7 @@ class TupleStruct : public Struct\n class EnumItem\n {\n   // bool has_attrs;\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   Identifier variant_name;\n \n@@ -1909,8 +1909,7 @@ class EnumItem\n   // Returns whether enum item has outer attributes.\n   bool has_outer_attrs () const { return !outer_attrs.empty (); }\n \n-  EnumItem (Identifier variant_name, std::vector<Attribute> outer_attrs,\n-\t    Location locus)\n+  EnumItem (Identifier variant_name, AST::AttrVec outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n       variant_name (std::move (variant_name)), locus (locus)\n   {}\n@@ -1945,7 +1944,7 @@ class EnumItemTuple : public EnumItem\n   bool has_tuple_fields () const { return !tuple_fields.empty (); }\n \n   EnumItemTuple (Identifier variant_name, std::vector<TupleField> tuple_fields,\n-\t\t std::vector<Attribute> outer_attrs, Location locus)\n+\t\t AST::AttrVec outer_attrs, Location locus)\n     : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n       tuple_fields (std::move (tuple_fields))\n   {}\n@@ -1974,7 +1973,7 @@ class EnumItemStruct : public EnumItem\n \n   EnumItemStruct (Identifier variant_name,\n \t\t  std::vector<StructField> struct_fields,\n-\t\t  std::vector<Attribute> outer_attrs, Location locus)\n+\t\t  AST::AttrVec outer_attrs, Location locus)\n     : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n       struct_fields (std::move (struct_fields))\n   {}\n@@ -1998,7 +1997,7 @@ class EnumItemDiscriminant : public EnumItem\n \n public:\n   EnumItemDiscriminant (Identifier variant_name, std::unique_ptr<Expr> expr,\n-\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+\t\t\tAST::AttrVec outer_attrs, Location locus)\n     : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n       expression (std::move (expr))\n   {}\n@@ -2068,7 +2067,7 @@ class Enum : public VisItem\n   Enum (Analysis::NodeMapping mappings, Identifier enum_name, Visibility vis,\n \tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem> > items,\n-\tstd::vector<Attribute> outer_attrs, Location locus)\n+\tAST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       enum_name (std::move (enum_name)),\n       generic_params (std::move (generic_params)),\n@@ -2159,7 +2158,7 @@ class Union : public VisItem\n   Union (Analysis::NodeMapping mappings, Identifier union_name, Visibility vis,\n \t std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t WhereClause where_clause, std::vector<StructField> variants,\n-\t std::vector<Attribute> outer_attrs, Location locus)\n+\t AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       union_name (std::move (union_name)),\n       generic_params (std::move (generic_params)),\n@@ -2235,8 +2234,8 @@ class ConstantItem : public VisItem,\n \n   ConstantItem (Analysis::NodeMapping mappings, Identifier ident,\n \t\tVisibility vis, std::unique_ptr<Type> type,\n-\t\tstd::unique_ptr<Expr> const_expr,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+\t\tstd::unique_ptr<Expr> const_expr, AST::AttrVec outer_attrs,\n+\t\tLocation locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       identifier (std::move (ident)), type (std::move (type)),\n       const_expr (std::move (const_expr)), locus (locus)\n@@ -2329,8 +2328,7 @@ class StaticItem : public VisItem\n \n   StaticItem (Analysis::NodeMapping mappings, Identifier name, bool is_mut,\n \t      std::unique_ptr<Type> type, std::unique_ptr<Expr> expr,\n-\t      Visibility vis, std::vector<Attribute> outer_attrs,\n-\t      Location locus)\n+\t      Visibility vis, AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       has_mut (is_mut), name (std::move (name)), type (std::move (type)),\n       expr (std::move (expr)), locus (locus)\n@@ -2478,7 +2476,7 @@ struct TraitFunctionDecl\n // Actual trait item function declaration within traits\n class TraitItemFunc : public TraitItem\n {\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n   TraitFunctionDecl decl;\n   std::unique_ptr<BlockExpr> block_expr;\n   Location locus;\n@@ -2488,7 +2486,7 @@ class TraitItemFunc : public TraitItem\n   bool has_definition () const { return block_expr != nullptr; }\n \n   TraitItemFunc (TraitFunctionDecl decl, std::unique_ptr<BlockExpr> block_expr,\n-\t\t std::vector<Attribute> outer_attrs, Location locus)\n+\t\t AST::AttrVec outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), decl (std::move (decl)),\n       block_expr (std::move (block_expr)), locus (locus)\n   {}\n@@ -2629,7 +2627,7 @@ struct TraitMethodDecl\n // Actual trait item method declaration within traits\n class TraitItemMethod : public TraitItem\n {\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n   TraitMethodDecl decl;\n   std::unique_ptr<BlockExpr> block_expr;\n   Location locus;\n@@ -2639,7 +2637,7 @@ class TraitItemMethod : public TraitItem\n   bool has_definition () const { return block_expr != nullptr; }\n \n   TraitItemMethod (TraitMethodDecl decl, std::unique_ptr<BlockExpr> block_expr,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+\t\t   AST::AttrVec outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), decl (std::move (decl)),\n       block_expr (std::move (block_expr)), locus (locus)\n   {}\n@@ -2685,7 +2683,7 @@ class TraitItemMethod : public TraitItem\n // Constant item within traits\n class TraitItemConst : public TraitItem\n {\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n   Identifier name;\n   std::unique_ptr<Type> type;\n \n@@ -2699,8 +2697,8 @@ class TraitItemConst : public TraitItem\n   bool has_expression () const { return expr != nullptr; }\n \n   TraitItemConst (Identifier name, std::unique_ptr<Type> type,\n-\t\t  std::unique_ptr<Expr> expr,\n-\t\t  std::vector<Attribute> outer_attrs, Location locus)\n+\t\t  std::unique_ptr<Expr> expr, AST::AttrVec outer_attrs,\n+\t\t  Location locus)\n     : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n       type (std::move (type)), expr (std::move (expr)), locus (locus)\n   {}\n@@ -2746,7 +2744,7 @@ class TraitItemConst : public TraitItem\n // Type items within traits\n class TraitItemType : public TraitItem\n {\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   Identifier name;\n \n@@ -2764,7 +2762,7 @@ class TraitItemType : public TraitItem\n   TraitItemType (\n     Identifier name,\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    std::vector<Attribute> outer_attrs, Location locus)\n+    AST::AttrVec outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n@@ -2856,7 +2854,7 @@ class Trait : public VisItem\n \t std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n \t WhereClause where_clause,\n \t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n-\t std::vector<Attribute> outer_attrs, Location locus)\n+\t AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n@@ -2942,7 +2940,7 @@ class Impl : public VisItem\n   WhereClause where_clause;\n \n   // bool has_inner_attrs;\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n \n private:\n   // doesn't really need to be protected as write access probably not needed\n@@ -2972,8 +2970,8 @@ class Impl : public VisItem\n   Impl (Analysis::NodeMapping mappings,\n \tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n-\tVisibility vis, std::vector<Attribute> inner_attrs,\n-\tstd::vector<Attribute> outer_attrs, Location locus)\n+\tVisibility vis, AST::AttrVec inner_attrs, AST::AttrVec outer_attrs,\n+\tLocation locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       generic_params (std::move (generic_params)),\n       trait_type (std::move (trait_type)),\n@@ -3030,8 +3028,8 @@ class InherentImpl : public Impl\n \t\tstd::vector<std::unique_ptr<InherentImplItem> > impl_items,\n \t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n-\t\tVisibility vis, std::vector<Attribute> inner_attrs,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+\t\tVisibility vis, AST::AttrVec inner_attrs,\n+\t\tAST::AttrVec outer_attrs, Location locus)\n     : Impl (std::move (mappings), std::move (generic_params),\n \t    std::move (trait_type), std::move (where_clause), std::move (vis),\n \t    std::move (inner_attrs), std::move (outer_attrs), locus),\n@@ -3111,8 +3109,8 @@ class TraitImpl : public Impl\n \t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n \t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t     std::unique_ptr<Type> trait_type, WhereClause where_clause,\n-\t     Visibility vis, std::vector<Attribute> inner_attrs,\n-\t     std::vector<Attribute> outer_attrs, Location locus)\n+\t     Visibility vis, AST::AttrVec inner_attrs, AST::AttrVec outer_attrs,\n+\t     Location locus)\n     : Impl (std::move (mappings), std::move (generic_params),\n \t    std::move (trait_type), std::move (where_clause), std::move (vis),\n \t    std::move (inner_attrs), std::move (outer_attrs), locus),\n@@ -3173,7 +3171,7 @@ class TraitImpl : public Impl\n class ExternalItem\n {\n   // bool has_outer_attrs;\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   // bool has_visibility;\n   Visibility visibility;\n@@ -3203,8 +3201,8 @@ class ExternalItem\n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n protected:\n-  ExternalItem (Identifier item_name, Visibility vis,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+  ExternalItem (Identifier item_name, Visibility vis, AST::AttrVec outer_attrs,\n+\t\tLocation locus)\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n       item_name (std::move (item_name)), locus (locus)\n   {}\n@@ -3245,8 +3243,8 @@ class ExternalStaticItem : public ExternalItem\n \n public:\n   ExternalStaticItem (Identifier item_name, std::unique_ptr<Type> item_type,\n-\t\t      bool is_mut, Visibility vis,\n-\t\t      std::vector<Attribute> outer_attrs, Location locus)\n+\t\t      bool is_mut, Visibility vis, AST::AttrVec outer_attrs,\n+\t\t      Location locus)\n     : ExternalItem (std::move (item_name), std::move (vis),\n \t\t    std::move (outer_attrs), locus),\n       has_mut (is_mut), item_type (std::move (item_type))\n@@ -3374,7 +3372,7 @@ class ExternalFunctionItem : public ExternalItem\n     std::vector<std::unique_ptr<GenericParam> > generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n     std::vector<NamedFunctionParam> function_params, bool has_variadics,\n-    Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n+    Visibility vis, AST::AttrVec outer_attrs, Location locus)\n     : ExternalItem (std::move (item_name), std::move (vis),\n \t\t    std::move (outer_attrs), locus),\n       generic_params (std::move (generic_params)),\n@@ -3436,7 +3434,7 @@ class ExternBlock : public VisItem\n   std::string abi;\n \n   // bool has_inner_attrs;\n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n \n   // bool has_extern_items;\n   std::vector<std::unique_ptr<ExternalItem> > extern_items;\n@@ -3457,8 +3455,8 @@ class ExternBlock : public VisItem\n \n   ExternBlock (Analysis::NodeMapping mappings, std::string abi,\n \t       std::vector<std::unique_ptr<ExternalItem> > extern_items,\n-\t       Visibility vis, std::vector<Attribute> inner_attrs,\n-\t       std::vector<Attribute> outer_attrs, Location locus)\n+\t       Visibility vis, AST::AttrVec inner_attrs,\n+\t       AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       abi (std::move (abi)), inner_attrs (std::move (inner_attrs)),\n       extern_items (std::move (extern_items)), locus (locus)"}, {"sha": "775c92f3c754cf6609911b4c09b8d03697dd16c2", "filename": "gcc/rust/hir/tree/rust-hir-macro.h", "status": "modified", "additions": 16, "deletions": 243, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_HIR_MACRO_H\n #define RUST_HIR_MACRO_H\n \n+#include \"rust-ast-full-decls.h\"\n #include \"rust-hir.h\"\n \n namespace Rust {\n@@ -190,7 +191,7 @@ class MacroMatchRepetition : public MacroMatch\n // can't inline due to polymorphism\n class MacroMatcher : public MacroMatch\n {\n-  DelimType delim_type;\n+  AST::DelimType delim_type;\n   std::vector<std::unique_ptr<MacroMatch> > matches;\n \n   // TODO: think of way to mark invalid that doesn't take up more space\n@@ -199,7 +200,7 @@ class MacroMatcher : public MacroMatch\n   // TODO: should store location information?\n \n public:\n-  MacroMatcher (DelimType delim_type,\n+  MacroMatcher (AST::DelimType delim_type,\n \t\tstd::vector<std::unique_ptr<MacroMatch> > matches)\n     : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n   {}\n@@ -247,20 +248,21 @@ class MacroMatcher : public MacroMatch\n   }\n \n   // constructor only used to create error matcher\n-  MacroMatcher (bool is_invalid) : delim_type (PARENS), is_invalid (is_invalid)\n+  MacroMatcher (bool is_invalid)\n+    : delim_type (AST::DelimType::PARENS), is_invalid (is_invalid)\n   {}\n };\n \n // TODO: inline?\n struct MacroTranscriber\n {\n private:\n-  DelimTokenTree token_tree;\n+  AST::DelimTokenTree token_tree;\n \n   // TODO: should store location information?\n \n public:\n-  MacroTranscriber (DelimTokenTree token_tree)\n+  MacroTranscriber (AST::DelimTokenTree token_tree)\n     : token_tree (std::move (token_tree))\n   {}\n \n@@ -288,7 +290,7 @@ struct MacroRule\n   static MacroRule create_error ()\n   {\n     return MacroRule (MacroMatcher::create_error (),\n-\t\t      MacroTranscriber (DelimTokenTree::create_empty ()));\n+\t\t      MacroTranscriber (AST::DelimTokenTree::create_empty ()));\n   }\n \n   std::string as_string () const;\n@@ -300,7 +302,7 @@ class MacroRulesDefinition : public MacroItem\n   Identifier rule_name;\n   // MacroRulesDef rules_def; // TODO: inline\n   // only curly without required semicolon at end\n-  DelimType delim_type;\n+  AST::DelimType delim_type;\n   // MacroRules rules;\n   std::vector<MacroRule> rules; // inlined form\n \n@@ -310,8 +312,8 @@ class MacroRulesDefinition : public MacroItem\n   std::string as_string () const override;\n \n   MacroRulesDefinition (Analysis::NodeMapping mappings, Identifier rule_name,\n-\t\t\tDelimType delim_type, std::vector<MacroRule> rules,\n-\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+\t\t\tAST::DelimType delim_type, std::vector<MacroRule> rules,\n+\t\t\tAST::AttrVec outer_attrs, Location locus)\n     : MacroItem (std::move (mappings), std::move (outer_attrs)),\n       rule_name (std::move (rule_name)), delim_type (delim_type),\n       rules (std::move (rules)), locus (locus)\n@@ -334,16 +336,16 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n \t\t\tpublic ExprWithoutBlock\n {\n-  SimplePath path;\n-  DelimTokenTree token_tree;\n+  AST::SimplePath path;\n+  AST::DelimTokenTree token_tree;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  MacroInvocation (Analysis::NodeMapping mappings, SimplePath path,\n-\t\t   DelimTokenTree token_tree,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+  MacroInvocation (Analysis::NodeMapping mappings, AST::SimplePath path,\n+\t\t   AST::DelimTokenTree token_tree, AST::AttrVec outer_attrs,\n+\t\t   Location locus)\n     : TypeNoBounds (mappings),\n       ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       path (std::move (path)), token_tree (std::move (token_tree)),\n@@ -392,235 +394,6 @@ class MacroInvocation : public TypeNoBounds,\n   }\n };\n \n-// more generic meta item path-only form\n-class MetaItemPath : public MetaItem\n-{\n-  SimplePath path;\n-\n-public:\n-  MetaItemPath (SimplePath path) : path (std::move (path)) {}\n-\n-  std::string as_string () const override { return path.as_string (); }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  // HACK: used to simplify parsing - returns non-empty only in this case\n-  SimplePath to_path_item () const override\n-  {\n-    // this should copy construct - TODO ensure it does\n-    return path;\n-  }\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaItemPath *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaItemPath (*this);\n-  }\n-};\n-\n-// more generic meta item sequence form\n-class MetaItemSeq : public MetaItem\n-{\n-  SimplePath path;\n-  std::vector<std::unique_ptr<MetaItemInner> > seq;\n-\n-public:\n-  MetaItemSeq (SimplePath path,\n-\t       std::vector<std::unique_ptr<MetaItemInner> > seq)\n-    : path (std::move (path)), seq (std::move (seq))\n-  {}\n-\n-  // copy constructor with vector clone\n-  MetaItemSeq (const MetaItemSeq &other) : path (other.path)\n-  {\n-    seq.reserve (other.seq.size ());\n-    for (const auto &e : other.seq)\n-      seq.push_back (e->clone_meta_item_inner ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  MetaItemSeq &operator= (const MetaItemSeq &other)\n-  {\n-    MetaItem::operator= (other);\n-    path = other.path;\n-\n-    seq.reserve (other.seq.size ());\n-    for (const auto &e : other.seq)\n-      seq.push_back (e->clone_meta_item_inner ());\n-\n-    return *this;\n-  }\n-\n-  // default move constructors\n-  MetaItemSeq (MetaItemSeq &&other) = default;\n-  MetaItemSeq &operator= (MetaItemSeq &&other) = default;\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaItemSeq *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaItemSeq (*this);\n-  }\n-};\n-\n-// Preferred specialisation for single-identifier meta items.\n-class MetaWord : public MetaItem\n-{\n-  Identifier ident;\n-\n-public:\n-  MetaWord (Identifier ident) : ident (std::move (ident)) {}\n-\n-  std::string as_string () const override { return ident; }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaWord *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaWord (*this);\n-  }\n-};\n-\n-// Preferred specialisation for \"identifier '=' string literal\" meta items.\n-class MetaNameValueStr : public MetaItem\n-{\n-  Identifier ident;\n-  std::string str;\n-\n-public:\n-  MetaNameValueStr (Identifier ident, std::string str)\n-    : ident (std::move (ident)), str (std::move (str))\n-  {}\n-\n-  std::string as_string () const override { return ident + \" = \" + str; }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  // HACK: used to simplify parsing - creates a copy of this\n-  std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const override\n-  {\n-    return std::unique_ptr<MetaNameValueStr> (clone_meta_item_inner_impl ());\n-  }\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaNameValueStr *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaNameValueStr (*this);\n-  }\n-};\n-\n-// doubles up as MetaListIdents - determine via iterating through each path?\n-// Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n-class MetaListPaths : public MetaItem\n-{\n-  Identifier ident;\n-  std::vector<SimplePath> paths;\n-\n-public:\n-  MetaListPaths (Identifier ident, std::vector<SimplePath> paths)\n-    : ident (std::move (ident)), paths (std::move (paths))\n-  {}\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaListPaths *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaListPaths (*this);\n-  }\n-};\n-\n-// Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n-class MetaListNameValueStr : public MetaItem\n-{\n-  Identifier ident;\n-  std::vector<MetaNameValueStr> strs;\n-\n-public:\n-  MetaListNameValueStr (Identifier ident, std::vector<MetaNameValueStr> strs)\n-    : ident (std::move (ident)), strs (std::move (strs))\n-  {}\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Attribute to_attribute () const override;\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  MetaListNameValueStr *clone_meta_item_inner_impl () const override\n-  {\n-    return new MetaListNameValueStr (*this);\n-  }\n-};\n-\n-// Object that parses macros from a token stream.\n-struct MacroParser\n-{\n-private:\n-  std::vector<std::unique_ptr<Token> > token_stream;\n-  /* probably have to make this mutable (mutable int stream_pos) otherwise const\n-   * has to be removed up to DelimTokenTree or further ok since this changing\n-   * would have an effect on the results of the methods run (i.e. not logically\n-   * const), the parsing methods shouldn't be const */\n-  int stream_pos;\n-\n-public:\n-  MacroParser (std::vector<std::unique_ptr<Token> > token_stream,\n-\t       int stream_start_pos = 0)\n-    : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n-  {}\n-\n-  ~MacroParser () = default;\n-\n-  std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n-\n-private:\n-  // Parses a MetaItemInner.\n-  std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n-  // Returns whether token can end a meta item.\n-  bool is_end_meta_item_tok (TokenId id) const;\n-  // Parses a simple path.\n-  SimplePath parse_simple_path ();\n-  // Parses a segment of a simple path (but not scope resolution operator).\n-  SimplePathSegment parse_simple_path_segment ();\n-  // Parses a MetaItemLitExpr.\n-  std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n-  // Parses a literal.\n-  Literal parse_literal ();\n-  // Parses a meta item that begins with a simple path.\n-  std::unique_ptr<MetaItem> parse_path_meta_item ();\n-\n-  // TODO: should this be const?\n-  std::unique_ptr<Token> &peek_token (int i = 0)\n-  {\n-    return token_stream[stream_pos + i];\n-  }\n-\n-  void skip_token (int i = 0) { stream_pos += 1 + i; }\n-};\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "84f3e968647f78057c9b862304f15c55811b9d93", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -243,7 +243,8 @@ class PathPattern : public Pattern\n \n   /* Converts path segments to their equivalent SimplePath segments if possible,\n    * and creates a SimplePath from them. */\n-  SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n+  AST::SimplePath\n+  convert_to_simple_path (bool with_opening_scope_resolution) const;\n \n public:\n   /* Returns whether the path is a single segment (excluding qualified path\n@@ -285,8 +286,8 @@ class PathInExpression : public PathPattern, public PathExpr\n \t\t    std::vector<PathExprSegment> path_segments,\n \t\t    Location locus = Location (),\n \t\t    bool has_opening_scope_resolution = false,\n-\t\t    std::vector<Attribute> outer_attrs\n-\t\t    = std::vector<Attribute> ())\n+\t\t    std::vector<AST::Attribute> outer_attrs\n+\t\t    = std::vector<AST::Attribute> ())\n     : PathPattern (std::move (path_segments)),\n       PathExpr (std::move (mappings), std::move (outer_attrs)),\n       has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n@@ -304,7 +305,7 @@ class PathInExpression : public PathPattern, public PathExpr\n \n   /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n    * arguments). Otherwise returns an empty SimplePath. */\n-  SimplePath as_simple_path () const\n+  AST::SimplePath as_simple_path () const\n   {\n     /* delegate to parent class as can't access segments. however,\n      * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n@@ -655,7 +656,7 @@ class TypePath : public TypeNoBounds\n \n   /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n    * arguments). Otherwise returns an empty SimplePath. */\n-  SimplePath as_simple_path () const;\n+  AST::SimplePath as_simple_path () const;\n \n   // Creates a trait bound with a clone of this type path as its only element.\n   TraitBound *to_trait_bound (bool in_parens) const override;\n@@ -750,8 +751,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \t\t\t     QualifiedPathType qual_path_type,\n \t\t\t     std::vector<PathExprSegment> path_segments,\n \t\t\t     Location locus = Location (),\n-\t\t\t     std::vector<Attribute> outer_attrs\n-\t\t\t     = std::vector<Attribute> ())\n+\t\t\t     std::vector<AST::Attribute> outer_attrs\n+\t\t\t     = std::vector<AST::Attribute> ())\n     : PathPattern (std::move (path_segments)),\n       PathExpr (std::move (mappings), std::move (outer_attrs)),\n       path_type (std::move (qual_path_type)), locus (locus)"}, {"sha": "13177f292eecef859ba4729d0464b5f909bb94e2", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -376,26 +376,26 @@ class ReferencePattern : public Pattern\n struct StructPatternEtc\n {\n private:\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   // should this store location data?\n \n public:\n-  StructPatternEtc (std::vector<Attribute> outer_attribs)\n+  StructPatternEtc (AST::AttrVec outer_attribs)\n     : outer_attrs (std::move (outer_attribs))\n   {}\n \n   // Creates an empty StructPatternEtc\n   static StructPatternEtc create_empty ()\n   {\n-    return StructPatternEtc (std::vector<Attribute> ());\n+    return StructPatternEtc (AST::AttrVec ());\n   }\n };\n \n // Base class for a single field in a struct pattern - abstract\n class StructPatternField\n {\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n   Location locus;\n \n public:\n@@ -415,7 +415,7 @@ class StructPatternField\n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n protected:\n-  StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n+  StructPatternField (AST::AttrVec outer_attribs, Location locus)\n     : outer_attrs (std::move (outer_attribs)), locus (locus)\n   {}\n \n@@ -432,8 +432,7 @@ class StructPatternFieldTuplePat : public StructPatternField\n public:\n   StructPatternFieldTuplePat (TupleIndex index,\n \t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n-\t\t\t      std::vector<Attribute> outer_attribs,\n-\t\t\t      Location locus)\n+\t\t\t      AST::AttrVec outer_attribs, Location locus)\n     : StructPatternField (std::move (outer_attribs), locus), index (index),\n       tuple_pattern (std::move (tuple_pattern))\n   {}\n@@ -483,8 +482,7 @@ class StructPatternFieldIdentPat : public StructPatternField\n public:\n   StructPatternFieldIdentPat (Identifier ident,\n \t\t\t      std::unique_ptr<Pattern> ident_pattern,\n-\t\t\t      std::vector<Attribute> outer_attrs,\n-\t\t\t      Location locus)\n+\t\t\t      AST::AttrVec outer_attrs, Location locus)\n     : StructPatternField (std::move (outer_attrs), locus),\n       ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n   {}\n@@ -534,7 +532,7 @@ class StructPatternFieldIdent : public StructPatternField\n \n public:\n   StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n-\t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+\t\t\t   AST::AttrVec outer_attrs, Location locus)\n     : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n       has_mut (is_mut), ident (std::move (ident))\n   {}"}, {"sha": "584b0e358cd58a5fb488621fd5bb3f80ea70b196", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -52,7 +52,7 @@ class EmptyStmt : public Stmt\n class LetStmt : public Stmt\n {\n   // bool has_outer_attrs;\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   std::unique_ptr<Pattern> variables_pattern;\n \n@@ -79,7 +79,7 @@ class LetStmt : public Stmt\n   LetStmt (Analysis::NodeMapping mappings,\n \t   std::unique_ptr<Pattern> variables_pattern,\n \t   std::unique_ptr<Expr> init_expr, std::unique_ptr<Type> type,\n-\t   std::vector<Attribute> outer_attrs, Location locus)\n+\t   AST::AttrVec outer_attrs, Location locus)\n     : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attrs)),\n       variables_pattern (std::move (variables_pattern)),\n       type (std::move (type)), init_expr (std::move (init_expr)), locus (locus)"}, {"sha": "7e6752b75e8707acce8a9d5244f5d9ac4a3ea29a", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -37,8 +37,8 @@ class HIRVisitor\n   // virtual void visit(TokenTree& token_tree) = 0;\n   // virtual void visit(MacroMatch& macro_match) = 0;\n   virtual void visit (Token &tok) = 0;\n-  virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n-  virtual void visit (AttrInputMetaItemContainer &input) = 0;\n+  // virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n+  // virtual void visit (AttrInputMetaItemContainer &input) = 0;\n   // virtual void visit(MetaItem& meta_item) = 0;\n   // virtual void visit(Stmt& stmt) = 0;\n   // virtual void visit(Expr& expr) = 0;\n@@ -64,9 +64,9 @@ class HIRVisitor\n \n   // rust-expr.h\n   virtual void visit (LiteralExpr &expr) = 0;\n-  virtual void visit (AttrInputLiteral &attr_input) = 0;\n-  virtual void visit (MetaItemLitExpr &meta_item) = 0;\n-  virtual void visit (MetaItemPathLit &meta_item) = 0;\n+  // virtual void visit (AttrInputLiteral &attr_input) = 0;\n+  // virtual void visit (MetaItemLitExpr &meta_item) = 0;\n+  // virtual void visit (MetaItemPathLit &meta_item) = 0;\n   virtual void visit (BorrowExpr &expr) = 0;\n   virtual void visit (DereferenceExpr &expr) = 0;\n   virtual void visit (ErrorPropagationExpr &expr) = 0;\n@@ -179,12 +179,12 @@ class HIRVisitor\n   virtual void visit (MacroMatcher &matcher) = 0;\n   virtual void visit (MacroRulesDefinition &rules_def) = 0;\n   virtual void visit (MacroInvocation &macro_invoc) = 0;\n-  virtual void visit (MetaItemPath &meta_item) = 0;\n-  virtual void visit (MetaItemSeq &meta_item) = 0;\n-  virtual void visit (MetaWord &meta_item) = 0;\n-  virtual void visit (MetaNameValueStr &meta_item) = 0;\n-  virtual void visit (MetaListPaths &meta_item) = 0;\n-  virtual void visit (MetaListNameValueStr &meta_item) = 0;\n+  // virtual void visit (MetaItemPath &meta_item) = 0;\n+  // virtual void visit (MetaItemSeq &meta_item) = 0;\n+  // virtual void visit (MetaWord &meta_item) = 0;\n+  // virtual void visit (MetaNameValueStr &meta_item) = 0;\n+  // virtual void visit (MetaListPaths &meta_item) = 0;\n+  // virtual void visit (MetaListNameValueStr &meta_item) = 0;\n \n   // rust-pattern.h\n   virtual void visit (LiteralPattern &pattern) = 0;"}, {"sha": "decf0c939df216a0ae0a6399f42a25a775629f4a", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 18, "deletions": 492, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_HIR_BASE_H\n #define RUST_HIR_BASE_H\n \n+#include \"rust-ast.h\"\n #include \"rust-system.h\"\n #include \"rust-token.h\"\n #include \"rust-location.h\"\n@@ -32,38 +33,6 @@ namespace HIR {\n // foward decl: ast visitor\n class HIRVisitor;\n \n-// Delimiter types - used in macros and whatever.\n-enum DelimType\n-{\n-  PARENS,\n-  SQUARE,\n-  CURLY\n-};\n-\n-// Attribute body - abstract base class\n-class AttrInput\n-{\n-public:\n-  virtual ~AttrInput () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<AttrInput> clone_attr_input () const\n-  {\n-    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n-  }\n-\n-  virtual std::string as_string () const = 0;\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-\n-  // Parse attribute input to meta item, if possible\n-  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n-\n-protected:\n-  // pure virtual clone implementation\n-  virtual AttrInput *clone_attr_input_impl () const = 0;\n-};\n-\n // forward decl for use in token tree method\n class Token;\n \n@@ -263,445 +232,6 @@ struct Literal\n   bool is_error () const { return value_as_string == \"\"; }\n };\n \n-// A token tree with delimiters\n-class DelimTokenTree : public TokenTree, public AttrInput\n-{\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree> > token_trees;\n-  Location locus;\n-\n-protected:\n-  DelimTokenTree *clone_delim_tok_tree_impl () const\n-  {\n-    return new DelimTokenTree (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_attr_input_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_token_tree_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-public:\n-  DelimTokenTree (DelimType delim_type,\n-\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n-\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n-\t\t  Location locus = Location ())\n-    : delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n-  {}\n-\n-  // Copy constructor with vector clone\n-  DelimTokenTree (DelimTokenTree const &other)\n-    : delim_type (other.delim_type), locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  DelimTokenTree &operator= (DelimTokenTree const &other)\n-  {\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  DelimTokenTree (DelimTokenTree &&other) = default;\n-  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n-\n-  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  AttrInput *parse_to_meta_item () const override;\n-\n-  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n-\n-  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n-  {\n-    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n-  }\n-};\n-\n-/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n- * be defined */\n-class AttrInputLiteral;\n-\n-/* TODO: move applicable stuff into here or just don't include it because\n- * nothing uses it A segment of a path (maybe) */\n-class PathSegment\n-{\n-public:\n-  virtual ~PathSegment () {}\n-\n-  virtual std::string as_string () const = 0;\n-\n-  // TODO: add visitor here?\n-};\n-\n-// A segment of a simple path without generic or type arguments\n-class SimplePathSegment : public PathSegment\n-{\n-  std::string segment_name;\n-  Location locus;\n-\n-  // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n-public:\n-  // TODO: put checks in constructor to enforce this rule?\n-  SimplePathSegment (std::string segment_name, Location locus = Location ())\n-    : segment_name (std::move (segment_name)), locus (locus)\n-  {}\n-\n-  /* Returns whether simple path segment is in an invalid state (currently, if\n-   * empty). */\n-  bool is_error () const { return segment_name.empty (); }\n-\n-  // Creates an error SimplePathSegment\n-  static SimplePathSegment create_error ()\n-  {\n-    return SimplePathSegment (std::string (\"\"));\n-  }\n-\n-  std::string as_string () const override;\n-\n-  Location get_locus () const { return locus; }\n-\n-  // TODO: visitor pattern?\n-};\n-\n-// A simple path without generic or type arguments\n-class SimplePath\n-{\n-  bool has_opening_scope_resolution;\n-  std::vector<SimplePathSegment> segments;\n-  Location locus;\n-\n-public:\n-  // Constructor\n-  SimplePath (std::vector<SimplePathSegment> path_segments,\n-\t      bool has_opening_scope_resolution = false,\n-\t      Location locus = Location ())\n-    : has_opening_scope_resolution (has_opening_scope_resolution),\n-      segments (std::move (path_segments)), locus (locus)\n-  {}\n-\n-  // Creates an empty SimplePath.\n-  static SimplePath create_empty ()\n-  {\n-    return SimplePath (std::vector<SimplePathSegment> ());\n-  }\n-\n-  // Returns whether the SimplePath is empty, i.e. has path segments.\n-  bool is_empty () const { return segments.empty (); }\n-\n-  std::string as_string () const;\n-\n-  Location get_locus () const { return locus; }\n-\n-  // does this need visitor if not polymorphic? probably not\n-\n-  // path-to-string comparison operator\n-  bool operator== (const std::string &rhs)\n-  {\n-    return !has_opening_scope_resolution && segments.size () == 1\n-\t   && segments[0].as_string () == rhs;\n-  }\n-\n-  /* Creates a single-segment SimplePath from a string. This will not check to\n-   * ensure that this is a valid identifier in path, so be careful. Also, this\n-   * will have no location data.\n-   * TODO have checks? */\n-  static SimplePath from_str (std::string str)\n-  {\n-    std::vector<HIR::SimplePathSegment> single_segments\n-      = {HIR::SimplePathSegment (std::move (str))};\n-    return SimplePath (std::move (single_segments));\n-  }\n-};\n-\n-// aka Attr\n-// Attribute HIR representation\n-struct Attribute\n-{\n-private:\n-  SimplePath path;\n-\n-  // bool has_attr_input;\n-  std::unique_ptr<AttrInput> attr_input;\n-\n-  Location locus;\n-\n-  // TODO: maybe a variable storing whether attr input is parsed or not\n-\n-public:\n-  // Returns whether Attribute has AttrInput\n-  bool has_attr_input () const { return attr_input != nullptr; }\n-\n-  // Constructor has pointer AttrInput for polymorphism reasons\n-  Attribute (SimplePath path, std::unique_ptr<AttrInput> input,\n-\t     Location locus = Location ())\n-    : path (std::move (path)), attr_input (std::move (input)), locus (locus)\n-  {}\n-\n-  // default destructor\n-  ~Attribute () = default;\n-\n-  // Copy constructor must deep copy attr_input as unique pointer\n-  Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n-  {\n-    // guard to protect from null pointer dereference\n-    if (other.attr_input != nullptr)\n-      attr_input = other.attr_input->clone_attr_input ();\n-  }\n-\n-  // overload assignment operator to use custom clone method\n-  Attribute &operator= (Attribute const &other)\n-  {\n-    path = other.path;\n-    locus = other.locus;\n-    // guard to protect from null pointer dereference\n-    if (other.attr_input != nullptr)\n-      attr_input = other.attr_input->clone_attr_input ();\n-\n-    return *this;\n-  }\n-\n-  // default move semantics\n-  Attribute (Attribute &&other) = default;\n-  Attribute &operator= (Attribute &&other) = default;\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<Attribute> clone_attribute () const\n-  {\n-    return std::unique_ptr<Attribute> (clone_attribute_impl ());\n-  }\n-\n-  // Creates an empty attribute (which is invalid)\n-  static Attribute create_empty ()\n-  {\n-    return Attribute (SimplePath::create_empty (), nullptr);\n-  }\n-\n-  // Returns whether the attribute is considered an \"empty\" attribute.\n-  bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n-\n-  /* e.g.:\n-      #![crate_type = \"lib\"]\n-      #[test]\n-      #[cfg(target_os = \"linux\")]\n-      #[allow(non_camel_case_types)]\n-      #![allow(unused_variables)]\n-  */\n-\n-  // Full built-in attribute list:\n-  /*   cfg\n-   *   cfg_attr\n-   *   test\n-   *   ignore\n-   *   should_panic\n-   *   derive\n-   *   macro_export\n-   *   macro_use\n-   *   proc_macro\n-   *   proc_macro_derive\n-   *   proc_macro_attribute\n-   *   allow\n-   *   warn\n-   *   deny\n-   *   forbid\n-   *   deprecated\n-   *   must_use\n-   *   link\n-   *   link_name\n-   *   no_link\n-   *   repr\n-   *   crate_type\n-   *   no_main\n-   *   export_name\n-   *   link_section\n-   *   no_mangle\n-   *   used\n-   *   crate_name\n-   *   inline\n-   *   cold\n-   *   no_builtins\n-   *   target_feature\n-   *   doc\n-   *   no_std\n-   *   no_implicit_prelude\n-   *   path\n-   *   recursion_limit\n-   *   type_length_limit\n-   *   panic_handler\n-   *   global_allocator\n-   *   windows_subsystem\n-   *   feature     */\n-\n-  std::string as_string () const;\n-\n-  // TODO: does this require visitor pattern as not polymorphic?\n-\n-  // Maybe change to const-reference in future\n-  SimplePath get_path () const { return path; }\n-\n-  // Call to parse attribute body to meta item syntax.\n-  void parse_attr_to_meta_item ();\n-\n-protected:\n-  // not virtual as currently no subclasses of Attribute, but could be in future\n-  /*virtual*/ Attribute *clone_attribute_impl () const\n-  {\n-    return new Attribute (*this);\n-  }\n-};\n-\n-// Forward decl - defined in rust-macro.h\n-class MetaNameValueStr;\n-\n-// abstract base meta item inner class\n-class MetaItemInner\n-{\n-protected:\n-  // pure virtual as MetaItemInner\n-  virtual MetaItemInner *clone_meta_item_inner_impl () const = 0;\n-\n-public:\n-  // Unique pointer custom clone function\n-  std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n-  {\n-    return std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n-  }\n-\n-  virtual ~MetaItemInner () {}\n-\n-  virtual std::string as_string () const = 0;\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-\n-  /* HACK: used to simplify parsing - creates a copy of that type, or returns\n-   * null */\n-  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const\n-  {\n-    return nullptr;\n-  }\n-\n-  // HACK: used to simplify parsing - same thing\n-  virtual SimplePath to_path_item () const\n-  {\n-    return SimplePath::create_empty ();\n-  }\n-\n-  virtual Attribute to_attribute () const { return Attribute::create_empty (); }\n-};\n-\n-// Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n-class AttrInputMetaItemContainer : public AttrInput\n-{\n-  std::vector<std::unique_ptr<MetaItemInner> > items;\n-\n-public:\n-  AttrInputMetaItemContainer (\n-    std::vector<std::unique_ptr<MetaItemInner> > items)\n-    : items (std::move (items))\n-  {}\n-\n-  // no destructor definition required\n-\n-  // default move constructors\n-  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n-  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n-    = default;\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  // Clones this object.\n-  std::unique_ptr<AttrInputMetaItemContainer>\n-  clone_attr_input_meta_item_container () const\n-  {\n-    return std::unique_ptr<AttrInputMetaItemContainer> (\n-      clone_attr_input_meta_item_container_impl ());\n-  }\n-\n-protected:\n-  // Use covariance to implement clone function as returning this type\n-  AttrInputMetaItemContainer *clone_attr_input_impl () const override\n-  {\n-    return clone_attr_input_meta_item_container_impl ();\n-  }\n-\n-  AttrInputMetaItemContainer *clone_attr_input_meta_item_container_impl () const\n-  {\n-    return new AttrInputMetaItemContainer (*this);\n-  }\n-\n-  // copy constructor with vector clone\n-  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n-  {\n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_meta_item_inner ());\n-  }\n-\n-  // copy assignment operator with vector clone\n-  AttrInputMetaItemContainer &\n-  operator= (const AttrInputMetaItemContainer &other)\n-  {\n-    AttrInput::operator= (other);\n-\n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_meta_item_inner ());\n-\n-    return *this;\n-  }\n-};\n-\n-// abstract base meta item class\n-class MetaItem : public MetaItemInner\n-{\n-};\n-\n-// Forward decl - defined in rust-expr.h\n-class MetaItemLitExpr;\n-\n-// Forward decl - defined in rust-expr.h\n-class MetaItemPathLit;\n-\n-// Forward decl - defined in rust-macro.h\n-class MetaItemPath;\n-\n-// Forward decl - defined in rust-macro.h\n-class MetaItemSeq;\n-\n-// Forward decl - defined in rust-macro.h\n-class MetaWord;\n-\n-// Forward decl - defined in rust-macro.h\n-class MetaListPaths;\n-\n-// Forward decl - defined in rust-macro.h\n-struct MetaListNameValueStr;\n-\n /* Base statement abstract class. Note that most \"statements\" are not allowed in\n  * top-level module scope - only a subclass of statements called \"items\" are. */\n class Stmt\n@@ -739,7 +269,7 @@ class Stmt\n // Rust \"item\" HIR node (declaration of top-level/module-level allowed stuff)\n class Item : public Stmt\n {\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   // TODO: should outer attrs be defined here or in each derived class?\n \n@@ -763,7 +293,7 @@ class Item : public Stmt\n protected:\n   // Constructor\n   Item (Analysis::NodeMapping mappings,\n-\tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+\tAST::AttrVec outer_attribs = AST::AttrVec ())\n     : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attribs))\n   {}\n \n@@ -783,12 +313,12 @@ class ExprWithoutBlock;\n class Expr\n {\n   // TODO: move outer attribute data to derived classes?\n-  std::vector<Attribute> outer_attrs;\n+  AST::AttrVec outer_attrs;\n \n   Analysis::NodeMapping mappings;\n \n public:\n-  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n \n   // Unique pointer custom clone function\n   std::unique_ptr<Expr> clone_expr () const\n@@ -827,13 +357,13 @@ class Expr\n protected:\n   // Constructor\n   Expr (Analysis::NodeMapping mappings,\n-\tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+\tAST::AttrVec outer_attribs = AST::AttrVec ())\n     : outer_attrs (std::move (outer_attribs)), mappings (std::move (mappings))\n   {}\n \n   // TODO: think of less hacky way to implement this kind of thing\n   // Sets outer attributes.\n-  void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n+  void set_outer_attrs (AST::AttrVec outer_attrs_to_set)\n   {\n     outer_attrs = std::move (outer_attrs_to_set);\n   }\n@@ -845,8 +375,7 @@ class ExprWithoutBlock : public Expr\n protected:\n   // Constructor\n   ExprWithoutBlock (Analysis::NodeMapping mappings,\n-\t\t    std::vector<Attribute> outer_attribs\n-\t\t    = std::vector<Attribute> ())\n+\t\t    AST::AttrVec outer_attribs = AST::AttrVec ())\n     : Expr (std::move (mappings), std::move (outer_attribs))\n   {}\n \n@@ -891,8 +420,7 @@ class IdentifierExpr : public ExprWithoutBlock\n \n   IdentifierExpr (Analysis::NodeMapping mappings, Identifier ident,\n \t\t  Location locus = Location (),\n-\t\t  std::vector<Attribute> outer_attrs\n-\t\t  = std::vector<Attribute> ())\n+\t\t  AST::AttrVec outer_attrs = AST::AttrVec ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       ident (std::move (ident)), locus (locus)\n   {}\n@@ -1155,7 +683,7 @@ class LifetimeParam : public GenericParam\n \n   // bool has_outer_attribute;\n   // std::unique_ptr<Attribute> outer_attr;\n-  Attribute outer_attr;\n+  AST::Attribute outer_attr;\n \n   Location locus;\n \n@@ -1176,7 +704,7 @@ class LifetimeParam : public GenericParam\n \t\t Location locus = Location (),\n \t\t std::vector<Lifetime> lifetime_bounds\n \t\t = std::vector<Lifetime> (),\n-\t\t Attribute outer_attr = Attribute::create_empty ())\n+\t\t AST::Attribute outer_attr = AST::Attribute::create_empty ())\n     : GenericParam (mappings, GenericKind::LIFETIME),\n       lifetime (std::move (lifetime)),\n       lifetime_bounds (std::move (lifetime_bounds)),\n@@ -1231,8 +759,7 @@ class MacroItem : public Item\n   /*public:\n   std::string as_string() const;*/\n protected:\n-  MacroItem (Analysis::NodeMapping mappings,\n-\t     std::vector<Attribute> outer_attribs)\n+  MacroItem (Analysis::NodeMapping mappings, AST::AttrVec outer_attribs)\n     : Item (std::move (mappings), std::move (outer_attribs))\n   {}\n };\n@@ -1325,7 +852,7 @@ struct Crate\n   bool has_utf8bom;\n   bool has_shebang;\n \n-  std::vector<Attribute> inner_attrs;\n+  AST::AttrVec inner_attrs;\n   // dodgy spacing required here\n   /* TODO: is it better to have a vector of items here or a module (implicit\n    * top-level one)? */\n@@ -1335,9 +862,9 @@ struct Crate\n \n public:\n   // Constructor\n-  Crate (std::vector<std::unique_ptr<Item> > items,\n-\t std::vector<Attribute> inner_attrs, Analysis::NodeMapping mappings,\n-\t bool has_utf8bom = false, bool has_shebang = false)\n+  Crate (std::vector<std::unique_ptr<Item> > items, AST::AttrVec inner_attrs,\n+\t Analysis::NodeMapping mappings, bool has_utf8bom = false,\n+\t bool has_shebang = false)\n     : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n       inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n       mappings (mappings)\n@@ -1384,8 +911,7 @@ struct Crate\n class PathExpr : public ExprWithoutBlock\n {\n protected:\n-  PathExpr (Analysis::NodeMapping mappings,\n-\t    std::vector<Attribute> outer_attribs)\n+  PathExpr (Analysis::NodeMapping mappings, AST::AttrVec outer_attribs)\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs))\n   {}\n \n@@ -1394,7 +920,7 @@ class PathExpr : public ExprWithoutBlock\n \n   /* Replaces the outer attributes of this path expression with the given outer\n    * attributes. */\n-  void replace_outer_attrs (std::vector<Attribute> outer_attrs)\n+  void replace_outer_attrs (AST::AttrVec outer_attrs)\n   {\n     set_outer_attrs (std::move (outer_attrs));\n   }"}, {"sha": "7ea779aa40868a08937c3ff07f91f2095bb33e4e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 218, "deletions": 287, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -402,7 +402,7 @@ Parser<ManagedTokenSource>::parse_crate ()\n   bool has_shebang = false;\n \n   // parse inner attributes\n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse items\n   std::vector<std::unique_ptr<AST::Item>> items;\n@@ -437,10 +437,10 @@ Parser<ManagedTokenSource>::parse_crate ()\n \n // Parse a contiguous block of inner attributes.\n template <typename ManagedTokenSource>\n-std::vector<AST::Attribute>\n+AST::AttrVec\n Parser<ManagedTokenSource>::parse_inner_attributes ()\n {\n-  std::vector<AST::Attribute> inner_attributes;\n+  AST::AttrVec inner_attributes;\n \n   // only try to parse it if it starts with \"#!\" not only \"#\"\n   while (lexer.peek_token ()->get_id () == HASH\n@@ -1018,7 +1018,7 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n   // has a \"called_from_statement\" parameter for better error message handling\n \n   // parse outer attributes for item\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // TODO: decide how to deal with VisItem vs MacroItem dichotomy\n   /* best current solution: catch all keywords that would imply a VisItem in a\n@@ -1096,10 +1096,10 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n \n // Parses a contiguous block of outer attributes.\n template <typename ManagedTokenSource>\n-std::vector<AST::Attribute>\n+AST::AttrVec\n Parser<ManagedTokenSource>::parse_outer_attributes ()\n {\n-  std::vector<AST::Attribute> outer_attributes;\n+  AST::AttrVec outer_attributes;\n \n   while (lexer.peek_token ()->get_id () == HASH)\n     {\n@@ -1168,8 +1168,7 @@ Parser<ManagedTokenSource>::parse_outer_attribute ()\n // Parses a VisItem (item that can have non-default visibility).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::VisItem>\n-Parser<ManagedTokenSource>::parse_vis_item (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_vis_item (AST::AttrVec outer_attrs)\n {\n   // parse visibility, which may or may not exist\n   AST::Visibility vis = parse_visibility ();\n@@ -1306,8 +1305,7 @@ Parser<ManagedTokenSource>::parse_vis_item (\n // Parses a MacroItem (either a MacroInvocationSemi or MacroRulesDefinition).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroItem>\n-Parser<ManagedTokenSource>::parse_macro_item (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_macro_item (AST::AttrVec outer_attrs)\n {\n   const_TokenPtr t = lexer.peek_token ();\n \n@@ -1345,8 +1343,7 @@ Parser<ManagedTokenSource>::parse_macro_item (\n // Parses a macro rules definition syntax extension whatever thing.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroRulesDefinition>\n-Parser<ManagedTokenSource>::parse_macro_rules_def (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_macro_rules_def (AST::AttrVec outer_attrs)\n {\n   // ensure that first token is identifier saying \"macro_rules\"\n   const_TokenPtr t = lexer.peek_token ();\n@@ -1510,7 +1507,7 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroInvocationSemi>\n Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   Location macro_locus = lexer.peek_token ()->get_locus ();\n   AST::SimplePath path = parse_simple_path ();\n@@ -1628,8 +1625,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n // Parses a non-semicoloned macro invocation (i.e. as pattern or expression).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroInvocation>\n-Parser<ManagedTokenSource>::parse_macro_invocation (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_macro_invocation (AST::AttrVec outer_attrs)\n {\n   // parse macro path\n   AST::SimplePath macro_path = parse_simple_path ();\n@@ -2065,8 +2061,8 @@ Parser<ManagedTokenSource>::parse_visibility ()\n // Parses a module - either a bodied module or a module defined in another file.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Module>\n-Parser<ManagedTokenSource>::parse_module (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_module (AST::Visibility vis,\n+\t\t\t\t\t  AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (MOD);\n@@ -2093,7 +2089,7 @@ Parser<ManagedTokenSource>::parse_module (\n \tlexer.skip_token ();\n \n \t// parse inner attributes\n-\tstd::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+\tAST::AttrVec inner_attrs = parse_inner_attributes ();\n \n \t// parse items\n \tstd::vector<std::unique_ptr<AST::Item>> items;\n@@ -2140,8 +2136,8 @@ Parser<ManagedTokenSource>::parse_module (\n // Parses an extern crate declaration (dependency on external crate)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExternCrate>\n-Parser<ManagedTokenSource>::parse_extern_crate (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_extern_crate (AST::Visibility vis,\n+\t\t\t\t\t\tAST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   if (!skip_token (EXTERN_TOK))\n@@ -2236,8 +2232,8 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n // Parses a use declaration.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::UseDeclaration>\n-Parser<ManagedTokenSource>::parse_use_decl (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_use_decl (AST::Visibility vis,\n+\t\t\t\t\t    AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   if (!skip_token (USE))\n@@ -2509,8 +2505,8 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n // Parses a function (not a method).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Function>\n-Parser<ManagedTokenSource>::parse_function (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_function (AST::Visibility vis,\n+\t\t\t\t\t    AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   // Get qualifiers for function if they exist\n@@ -3431,7 +3427,7 @@ AST::FunctionParam\n Parser<ManagedTokenSource>::parse_function_param ()\n {\n   // parse outer attributes if they exist\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // TODO: should saved location be at start of outer attributes or pattern?\n   Location locus = lexer.peek_token ()->get_locus ();\n@@ -3902,8 +3898,8 @@ Parser<ManagedTokenSource>::parse_lifetime ()\n // Parses a \"type alias\" (typedef) item.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TypeAlias>\n-Parser<ManagedTokenSource>::parse_type_alias (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_type_alias (AST::Visibility vis,\n+\t\t\t\t\t      AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (TYPE);\n@@ -3951,8 +3947,8 @@ Parser<ManagedTokenSource>::parse_type_alias (\n // Parse a struct item AST node.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Struct>\n-Parser<ManagedTokenSource>::parse_struct (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_struct (AST::Visibility vis,\n+\t\t\t\t\t  AST::AttrVec outer_attrs)\n {\n   /* TODO: determine best way to parse the proper struct vs tuple struct - share\n    * most of initial constructs so lookahead might be impossible, and if not\n@@ -4154,7 +4150,7 @@ AST::StructField\n Parser<ManagedTokenSource>::parse_struct_field ()\n {\n   // parse outer attributes, if they exist\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // parse visibility, if it exists\n   AST::Visibility vis = parse_visibility ();\n@@ -4254,7 +4250,7 @@ AST::TupleField\n Parser<ManagedTokenSource>::parse_tuple_field ()\n {\n   // parse outer attributes if they exist\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // parse visibility if it exists\n   AST::Visibility vis = parse_visibility ();\n@@ -4280,7 +4276,7 @@ Parser<ManagedTokenSource>::parse_tuple_field ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Enum>\n Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n-\t\t\t\t\tstd::vector<AST::Attribute> outer_attrs)\n+\t\t\t\t\tAST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (ENUM_TOK);\n@@ -4404,7 +4400,7 @@ std::unique_ptr<AST::EnumItem>\n Parser<ManagedTokenSource>::parse_enum_item ()\n {\n   // parse outer attributes if they exist\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // parse name for enum item, which is required\n   const_TokenPtr item_name_tok = lexer.peek_token ();\n@@ -4476,8 +4472,8 @@ Parser<ManagedTokenSource>::parse_enum_item ()\n // Parses a C-style (and C-compat) untagged union declaration.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Union>\n-Parser<ManagedTokenSource>::parse_union (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_union (AST::Visibility vis,\n+\t\t\t\t\t AST::AttrVec outer_attrs)\n {\n   /* hack - \"weak keyword\" by finding identifier called \"union\" (lookahead in\n    * item switch) */\n@@ -4529,8 +4525,8 @@ Parser<ManagedTokenSource>::parse_union (\n  * the program - like constexpr). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ConstantItem>\n-Parser<ManagedTokenSource>::parse_const_item (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_const_item (AST::Visibility vis,\n+\t\t\t\t\t      AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (CONST);\n@@ -4593,8 +4589,8 @@ Parser<ManagedTokenSource>::parse_const_item (\n // Parses a \"static item\" (static storage item, with 'static lifetime).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::StaticItem>\n-Parser<ManagedTokenSource>::parse_static_item (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_static_item (AST::Visibility vis,\n+\t\t\t\t\t       AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (STATIC_TOK);\n@@ -4643,8 +4639,8 @@ Parser<ManagedTokenSource>::parse_static_item (\n // Parses a trait definition item, including unsafe ones.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Trait>\n-Parser<ManagedTokenSource>::parse_trait (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_trait (AST::Visibility vis,\n+\t\t\t\t\t AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   bool is_unsafe = false;\n@@ -4687,7 +4683,7 @@ Parser<ManagedTokenSource>::parse_trait (\n     }\n \n   // parse inner attrs (if they exist)\n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse trait items\n   std::vector<std::unique_ptr<AST::TraitItem>> trait_items;\n@@ -4730,7 +4726,7 @@ std::unique_ptr<AST::TraitItem>\n Parser<ManagedTokenSource>::parse_trait_item ()\n {\n   // parse outer attributes (if they exist)\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // lookahead to determine what type of trait item to parse\n   const_TokenPtr tok = lexer.peek_token ();\n@@ -4889,8 +4885,7 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n // Parse a typedef trait item.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TraitItemType>\n-Parser<ManagedTokenSource>::parse_trait_type (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_trait_type (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (TYPE);\n@@ -4925,8 +4920,7 @@ Parser<ManagedTokenSource>::parse_trait_type (\n // Parses a constant trait item.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TraitItemConst>\n-Parser<ManagedTokenSource>::parse_trait_const (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_trait_const (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (CONST);\n@@ -4971,7 +4965,7 @@ Parser<ManagedTokenSource>::parse_trait_const (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Impl>\n Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n-\t\t\t\t\tstd::vector<AST::Attribute> outer_attrs)\n+\t\t\t\t\tAST::AttrVec outer_attrs)\n {\n   /* Note that only trait impls are allowed to be unsafe. So if unsafe, it must\n    * be a trait impl. However, this isn't enough for full disambiguation, so\n@@ -5041,7 +5035,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n \t}\n \n       // parse inner attributes (optional)\n-      std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+      AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n       // parse inherent impl items\n       std::vector<std::unique_ptr<AST::InherentImplItem>> impl_items;\n@@ -5116,7 +5110,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n \t}\n \n       // parse inner attributes (optional)\n-      std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+      AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n       // parse trait impl items\n       std::vector<std::unique_ptr<AST::TraitImplItem>> impl_items;\n@@ -5172,7 +5166,7 @@ std::unique_ptr<AST::InherentImplItem>\n Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n {\n   // parse outer attributes (if they exist)\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // TODO: cleanup - currently an unreadable mess\n \n@@ -5288,7 +5282,7 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::InherentImplItem>\n Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+  AST::Visibility vis, AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   // parse function or method qualifiers\n@@ -5393,7 +5387,7 @@ std::unique_ptr<AST::TraitImplItem>\n Parser<ManagedTokenSource>::parse_trait_impl_item ()\n {\n   // parse outer attributes (if they exist)\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // TODO: clean this function up, it is basically unreadable hacks\n \n@@ -5511,7 +5505,7 @@ Parser<ManagedTokenSource>::parse_trait_impl_item ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TraitImplItem>\n Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+  AST::Visibility vis, AST::AttrVec outer_attrs)\n {\n   // this shares virtually all logic with parse_inherent_impl_function_or_method\n   // - template?\n@@ -5670,8 +5664,8 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n // Parses an extern block of declarations.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExternBlock>\n-Parser<ManagedTokenSource>::parse_extern_block (\n-  AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_extern_block (AST::Visibility vis,\n+\t\t\t\t\t\tAST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (EXTERN_TOK);\n@@ -5691,7 +5685,7 @@ Parser<ManagedTokenSource>::parse_extern_block (\n       return nullptr;\n     }\n \n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse declarations inside extern block\n   std::vector<std::unique_ptr<AST::ExternalItem>> extern_items;\n@@ -5736,7 +5730,7 @@ std::unique_ptr<AST::ExternalItem>\n Parser<ManagedTokenSource>::parse_external_item ()\n {\n   // parse optional outer attributes\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   Location locus = lexer.peek_token ()->get_locus ();\n \n@@ -5823,13 +5817,12 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t// parse parameters\n \tstd::vector<AST::NamedFunctionParam> function_params;\n \tbool is_variadic = false;\n-\tstd::vector<AST::Attribute> variadic_attrs;\n+\tAST::AttrVec variadic_attrs;\n \n \tconst_TokenPtr t = lexer.peek_token ();\n \twhile (t->get_id () != RIGHT_PAREN)\n \t  {\n-\t    std::vector<AST::Attribute> maybe_variadic_attrs\n-\t      = parse_outer_attributes ();\n+\t    AST::AttrVec maybe_variadic_attrs = parse_outer_attributes ();\n \t    if (lexer.peek_token ()->get_id () == ELLIPSIS)\n \t      {\n \t\t// variadic - use attrs for this\n@@ -5920,7 +5913,7 @@ Parser<ManagedTokenSource>::parse_external_item ()\n template <typename ManagedTokenSource>\n AST::NamedFunctionParam\n Parser<ManagedTokenSource>::parse_named_function_param (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   // parse identifier/_\n   std::string name;\n@@ -5979,7 +5972,7 @@ Parser<ManagedTokenSource>::parse_stmt ()\n     }\n \n   // parse outer attributes\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // parsing this will be annoying because of the many different possibilities\n   /* best may be just to copy paste in parse_item switch, and failing that try\n@@ -6054,8 +6047,7 @@ Parser<ManagedTokenSource>::parse_stmt ()\n // Parses a let statement.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LetStmt>\n-Parser<ManagedTokenSource>::parse_let_stmt (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (LET);\n@@ -6951,16 +6943,14 @@ Parser<ManagedTokenSource>::parse_method ()\n \t\t      std::move (generic_params), std::move (self_param),\n \t\t      std::move (function_params), std::move (return_type),\n \t\t      std::move (where_clause), std::move (block_expr),\n-\t\t      AST::Visibility::create_error (),\n-\t\t      std::vector<AST::Attribute> (), locus);\n+\t\t      AST::Visibility::create_error (), AST::AttrVec (), locus);\n }\n \n /* Parses an expression statement (disambiguates to expression with or without\n  * block statement). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmt>\n-Parser<ManagedTokenSource>::parse_expr_stmt (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n {\n   /* potential thoughts - define new virtual method \"has_block()\" on expr. parse\n    * expr and then determine whether semicolon is needed as a result of this\n@@ -7026,8 +7016,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (\n \n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprWithBlock>\n-Parser<ManagedTokenSource>::parse_expr_with_block (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_with_block (AST::AttrVec outer_attrs)\n {\n   std::unique_ptr<AST::ExprWithBlock> expr_parsed = nullptr;\n \n@@ -7121,7 +7110,7 @@ Parser<ManagedTokenSource>::parse_expr_with_block (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmtWithBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   auto expr_parsed = parse_expr_with_block (std::move (outer_attrs));\n   auto locus = expr_parsed->get_locus ();\n@@ -7137,7 +7126,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmtWithoutBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   /* TODO: maybe move more logic for expr without block in here for better error\n    * handling */\n@@ -7172,8 +7161,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n  * disambiguates). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprWithoutBlock>\n-Parser<ManagedTokenSource>::parse_expr_without_block (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_without_block (AST::AttrVec outer_attrs)\n {\n   /* Notes on types of expr without block:\n    *  - literal expr          tokens that are literals\n@@ -7278,8 +7266,8 @@ Parser<ManagedTokenSource>::parse_expr_without_block (\n // Parses a block expression, including the curly braces at start and end.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::BlockExpr>\n-Parser<ManagedTokenSource>::parse_block_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_block_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t      bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -7296,7 +7284,7 @@ Parser<ManagedTokenSource>::parse_block_expr (\n       locus = lexer.peek_token ()->get_locus () - 1;\n     }\n \n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse statements and expression\n   std::vector<std::unique_ptr<AST::Stmt>> stmts;\n@@ -7355,13 +7343,12 @@ Parser<ManagedTokenSource>::parse_block_expr (\n  * precedence. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::GroupedExpr>\n-Parser<ManagedTokenSource>::parse_grouped_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_grouped_expr (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (LEFT_PAREN);\n \n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse required expr inside parentheses\n   std::unique_ptr<AST::Expr> expr_in_parens = parse_expr ();\n@@ -7386,8 +7373,7 @@ Parser<ManagedTokenSource>::parse_grouped_expr (\n // Parses a closure expression (closure definition).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ClosureExpr>\n-Parser<ManagedTokenSource>::parse_closure_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_closure_expr (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   // detect optional \"move\"\n@@ -7511,8 +7497,7 @@ Parser<ManagedTokenSource>::parse_closure_expr (\n // Parses a literal token (to literal expression).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LiteralExpr>\n-Parser<ManagedTokenSource>::parse_literal_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_literal_expr (AST::AttrVec outer_attrs)\n {\n   // TODO: change if literal representation in lexer changes\n \n@@ -7588,8 +7573,8 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n // Parses a return expression (including any expression to return).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ReturnExpr>\n-Parser<ManagedTokenSource>::parse_return_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_return_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t       bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -7609,7 +7594,7 @@ Parser<ManagedTokenSource>::parse_return_expr (\n   ParseRestrictions restrictions;\n   restrictions.expr_can_be_null = true;\n   std::unique_ptr<AST::Expr> returned_expr\n-    = parse_expr (std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (AST::AttrVec (), restrictions);\n \n   return std::unique_ptr<AST::ReturnExpr> (\n     new AST::ReturnExpr (std::move (returned_expr), std::move (outer_attrs),\n@@ -7620,8 +7605,8 @@ Parser<ManagedTokenSource>::parse_return_expr (\n  * expression). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::BreakExpr>\n-Parser<ManagedTokenSource>::parse_break_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_break_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t      bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -7648,7 +7633,7 @@ Parser<ManagedTokenSource>::parse_break_expr (\n   ParseRestrictions restrictions;\n   restrictions.expr_can_be_null = true;\n   std::unique_ptr<AST::Expr> return_expr\n-    = parse_expr (std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (AST::AttrVec (), restrictions);\n \n   return std::unique_ptr<AST::BreakExpr> (\n     new AST::BreakExpr (std::move (label), std::move (return_expr),\n@@ -7658,8 +7643,8 @@ Parser<ManagedTokenSource>::parse_break_expr (\n // Parses a continue expression (including any label to continue from).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ContinueExpr>\n-Parser<ManagedTokenSource>::parse_continue_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_continue_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -7716,8 +7701,8 @@ Parser<ManagedTokenSource>::parse_loop_label ()\n  * expressions don't support them. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfExpr>\n-Parser<ManagedTokenSource>::parse_if_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_if_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t   bool pratt_parse)\n {\n   // TODO: make having outer attributes an error?\n   Location locus = Linemap::unknown_location ();\n@@ -7878,8 +7863,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n  * expressions don't support them. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfLetExpr>\n-Parser<ManagedTokenSource>::parse_if_let_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_if_let_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t       bool pratt_parse)\n {\n   // TODO: make having outer attributes an error?\n   Location locus = Linemap::unknown_location ();\n@@ -8069,9 +8054,9 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n  * parsed via parse_labelled_loop_expr, which would call this. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LoopExpr>\n-Parser<ManagedTokenSource>::parse_loop_expr (\n-  std::vector<AST::Attribute> outer_attrs, AST::LoopLabel label,\n-  bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_loop_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t     AST::LoopLabel label,\n+\t\t\t\t\t     bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -8115,9 +8100,9 @@ Parser<ManagedTokenSource>::parse_loop_expr (\n  * via parse_labelled_loop_expr, which would call this. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::WhileLoopExpr>\n-Parser<ManagedTokenSource>::parse_while_loop_expr (\n-  std::vector<AST::Attribute> outer_attrs, AST::LoopLabel label,\n-  bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_while_loop_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t   AST::LoopLabel label,\n+\t\t\t\t\t\t   bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -8190,8 +8175,8 @@ Parser<ManagedTokenSource>::parse_while_loop_expr (\n  * parsed via parse_labelled_loop_expr, which would call this. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::WhileLetLoopExpr>\n-Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n-  std::vector<AST::Attribute> outer_attrs, AST::LoopLabel label)\n+Parser<ManagedTokenSource>::parse_while_let_loop_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t       AST::LoopLabel label)\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n@@ -8264,8 +8249,8 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n  * parse_labelled_loop_expr, which would call this. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ForLoopExpr>\n-Parser<ManagedTokenSource>::parse_for_loop_expr (\n-  std::vector<AST::Attribute> outer_attrs, AST::LoopLabel label)\n+Parser<ManagedTokenSource>::parse_for_loop_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t AST::LoopLabel label)\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n@@ -8329,8 +8314,7 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (\n // Parses a loop expression with label (any kind of loop - disambiguates).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::BaseLoopExpr>\n-Parser<ManagedTokenSource>::parse_labelled_loop_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_labelled_loop_expr (AST::AttrVec outer_attrs)\n {\n   /* TODO: decide whether it should not work if there is no label, or parse it\n    * with no label at the moment, I will make it not work with no label because\n@@ -8394,8 +8378,8 @@ Parser<ManagedTokenSource>::parse_labelled_loop_expr (\n // Parses a match expression.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MatchExpr>\n-Parser<ManagedTokenSource>::parse_match_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t      bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -8435,7 +8419,7 @@ Parser<ManagedTokenSource>::parse_match_expr (\n     }\n \n   // parse inner attributes (if they exist)\n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse match arms (if they exist)\n   // std::vector<std::unique_ptr<AST::MatchCase> > match_arms;\n@@ -8526,7 +8510,7 @@ AST::MatchArm\n Parser<ManagedTokenSource>::parse_match_arm ()\n {\n   // parse optional outer attributes\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // DEBUG\n   fprintf (stderr, \"about to start parsing match arm patterns\\n\");\n@@ -8648,8 +8632,7 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n // Parses an async block expression.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::AsyncBlockExpr>\n-Parser<ManagedTokenSource>::parse_async_block_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_async_block_expr (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (ASYNC);\n@@ -8683,8 +8666,7 @@ Parser<ManagedTokenSource>::parse_async_block_expr (\n // Parses an unsafe block expression.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::UnsafeBlockExpr>\n-Parser<ManagedTokenSource>::parse_unsafe_block_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_unsafe_block_expr (AST::AttrVec outer_attrs)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (UNSAFE);\n@@ -8710,8 +8692,8 @@ Parser<ManagedTokenSource>::parse_unsafe_block_expr (\n // Parses an array definition expression.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArrayExpr>\n-Parser<ManagedTokenSource>::parse_array_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_array_expr (AST::AttrVec outer_attrs,\n+\t\t\t\t\t      bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n   if (!pratt_parse)\n@@ -8726,7 +8708,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n     }\n \n   // parse optional inner attributes\n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // parse the \"array elements\" section, which is optional\n   if (lexer.peek_token ()->get_id () == RIGHT_SQUARE)\n@@ -8863,7 +8845,7 @@ template <typename ManagedTokenSource>\n AST::ClosureParam\n Parser<ManagedTokenSource>::parse_closure_param ()\n {\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // parse pattern (which is required)\n   std::unique_ptr<AST::Pattern> pattern = parse_pattern ();\n@@ -8900,7 +8882,7 @@ Parser<ManagedTokenSource>::parse_closure_param ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprWithoutBlock>\n Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n-  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n+  AST::AttrVec outer_attrs, bool pratt_parse)\n {\n   // adjustment to allow Pratt parsing to reuse function without copy-paste\n   Location locus = Linemap::unknown_location ();\n@@ -8916,7 +8898,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n     }\n \n   // parse optional inner attributes\n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n     {\n@@ -9571,8 +9553,7 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n // Parses a maybe named param used in bare function types.\n template <typename ManagedTokenSource>\n AST::MaybeNamedParam\n-Parser<ManagedTokenSource>::parse_maybe_named_param (\n-  std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_maybe_named_param (AST::AttrVec outer_attrs)\n {\n   /* Basically guess that param is named if first token is identifier or\n    * underscore and second token is semicolon. This should probably have no\n@@ -9635,12 +9616,12 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n   // parse function params, if they exist\n   std::vector<AST::MaybeNamedParam> params;\n   bool is_variadic = false;\n-  std::vector<AST::Attribute> variadic_attrs;\n+  AST::AttrVec variadic_attrs;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)\n     {\n-      std::vector<AST::Attribute> temp_attrs = parse_outer_attributes ();\n+      AST::AttrVec temp_attrs = parse_outer_attributes ();\n \n       if (lexer.peek_token ()->get_id () == ELLIPSIS)\n \t{\n@@ -10562,8 +10543,8 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t\tLinemap::unknown_location (), has_ellipsis_syntax));\n \t    }\n \t  case EXCLAM:\n-\t    return parse_macro_invocation_partial (\n-\t      std::move (path), std::vector<AST::Attribute> ());\n+\t    return parse_macro_invocation_partial (std::move (path),\n+\t\t\t\t\t\t   AST::AttrVec ());\n \t    case LEFT_PAREN: {\n \t      // tuple struct\n \t      lexer.skip_token ();\n@@ -11006,8 +10987,7 @@ Parser<ManagedTokenSource>::parse_ident_leading_pattern ()\n   switch (t->get_id ())\n     {\n     case EXCLAM:\n-      return parse_macro_invocation_partial (std::move (path),\n-\t\t\t\t\t     std::vector<AST::Attribute> ());\n+      return parse_macro_invocation_partial (std::move (path), AST::AttrVec ());\n       case LEFT_PAREN: {\n \t// tuple struct\n \tlexer.skip_token ();\n@@ -11273,14 +11253,14 @@ Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n {\n   std::vector<std::unique_ptr<AST::StructPatternField>> fields;\n \n-  std::vector<AST::Attribute> etc_attrs;\n+  AST::AttrVec etc_attrs;\n   bool has_etc = false;\n \n   // try parsing struct pattern fields\n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_CURLY)\n     {\n-      std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+      AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n       // parse etc (must be last in struct pattern, so breaks)\n       if (lexer.peek_token ()->get_id () == DOT_DOT)\n@@ -11326,7 +11306,7 @@ std::unique_ptr<AST::StructPatternField>\n Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n {\n   // parse outer attributes (if they exist)\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   return parse_struct_pattern_field_partial (std::move (outer_attrs));\n }\n@@ -11336,7 +11316,7 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::StructPatternField>\n Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   // branch based on next token\n   const_TokenPtr t = lexer.peek_token ();\n@@ -11455,7 +11435,7 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (\n template <typename ManagedTokenSource>\n ExprOrStmt\n Parser<ManagedTokenSource>::parse_stmt_or_expr_with_block (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   auto expr = parse_expr_with_block (std::move (outer_attrs));\n   if (expr == nullptr)\n@@ -11496,7 +11476,7 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n     }\n \n   // parse outer attributes\n-  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+  AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n   // parsing this will be annoying because of the many different possibilities\n   /* best may be just to copy paste in parse_item switch, and failing that try\n@@ -11724,7 +11704,7 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n template <typename ManagedTokenSource>\n ExprOrStmt\n Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   // attempt to parse path\n   Location stmt_or_expr_loc = lexer.peek_token ()->get_locus ();\n@@ -12049,7 +12029,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n template <typename ManagedTokenSource>\n ExprOrStmt\n Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   Location macro_locus = lexer.peek_token ()->get_locus ();\n   AST::SimplePath macro_path = parse_simple_path ();\n@@ -12328,7 +12308,7 @@ Parser<ManagedTokenSource>::skip_after_end_attribute ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n-\t\t\t\t\tstd::vector<AST::Attribute> outer_attrs,\n+\t\t\t\t\tAST::AttrVec outer_attrs,\n \t\t\t\t\tParseRestrictions restrictions)\n {\n   const_TokenPtr current_token = lexer.peek_token ();\n@@ -12352,8 +12332,8 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n       current_token = lexer.peek_token ();\n       lexer.skip_token ();\n \n-      expr = left_denotation (current_token, std::move (expr),\n-\t\t\t      std::vector<AST::Attribute> (), restrictions);\n+      expr = left_denotation (current_token, std::move (expr), AST::AttrVec (),\n+\t\t\t      restrictions);\n \n       if (expr == nullptr)\n \t{\n@@ -12371,7 +12351,7 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n // Parse expression with lowest left binding power.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n-Parser<ManagedTokenSource>::parse_expr (std::vector<AST::Attribute> outer_attrs,\n+Parser<ManagedTokenSource>::parse_expr (AST::AttrVec outer_attrs,\n \t\t\t\t\tParseRestrictions restrictions)\n {\n   return parse_expr (LBP_LOWEST, std::move (outer_attrs), restrictions);\n@@ -12383,9 +12363,9 @@ Parser<ManagedTokenSource>::parse_expr (std::vector<AST::Attribute> outer_attrs,\n  * simplify stuff. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n-Parser<ManagedTokenSource>::null_denotation (\n-  const_TokenPtr tok, std::vector<AST::Attribute> outer_attrs,\n-  ParseRestrictions restrictions)\n+Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n+\t\t\t\t\t     AST::AttrVec outer_attrs,\n+\t\t\t\t\t     ParseRestrictions restrictions)\n {\n   /* note: tok is previous character in input stream, not current one, as\n    * parse_expr skips it before passing it in */\n@@ -12823,9 +12803,10 @@ Parser<ManagedTokenSource>::null_denotation (\n  * that implements the left denotation for the token given. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n-Parser<ManagedTokenSource>::left_denotation (\n-  const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs, ParseRestrictions restrictions)\n+Parser<ManagedTokenSource>::left_denotation (const_TokenPtr tok,\n+\t\t\t\t\t     std::unique_ptr<AST::Expr> left,\n+\t\t\t\t\t     AST::AttrVec outer_attrs,\n+\t\t\t\t\t     ParseRestrictions restrictions)\n {\n   // Token passed in has already been skipped, so peek gives \"next\" token\n   switch (tok->get_id ())\n@@ -13182,14 +13163,14 @@ get_lbp_for_arithmetic_or_logical_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_arithmetic_or_logical_expr (\n-  const_TokenPtr, std::unique_ptr<AST::Expr> left, std::vector<AST::Attribute>,\n+  const_TokenPtr, std::unique_ptr<AST::Expr> left, AST::AttrVec,\n   AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n   ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n     = parse_expr (get_lbp_for_arithmetic_or_logical_expr (expr_type),\n-\t\t  std::vector<AST::Attribute> (), restrictions);\n+\t\t  AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13206,12 +13187,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_binary_plus_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_PLUS, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_PLUS, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13228,12 +13208,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_binary_minus_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_MINUS, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_MINUS, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13251,12 +13230,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_binary_mult_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_MUL, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_MUL, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13274,12 +13252,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_binary_div_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_DIV, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_DIV, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13297,12 +13274,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_binary_mod_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_MOD, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_MOD, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13321,12 +13297,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_bitwise_and_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_AMP, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_AMP, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13345,12 +13320,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_bitwise_or_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_PIPE, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_PIPE, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13369,12 +13343,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_bitwise_xor_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_CARET, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_CARET, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13392,12 +13365,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_left_shift_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_L_SHIFT, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_L_SHIFT, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13415,12 +13387,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n Parser<ManagedTokenSource>::parse_right_shift_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_R_SHIFT, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_R_SHIFT, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13466,13 +13437,13 @@ get_lbp_for_comparison_expr (AST::ComparisonExpr::ExprType expr_type)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_comparison_expr (\n-  const_TokenPtr, std::unique_ptr<AST::Expr> left, std::vector<AST::Attribute>,\n+  const_TokenPtr, std::unique_ptr<AST::Expr> left, AST::AttrVec,\n   AST::ComparisonExpr::ExprType expr_type, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (get_lbp_for_comparison_expr (expr_type),\n-\t\t  std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (get_lbp_for_comparison_expr (expr_type), AST::AttrVec (),\n+\t\t  restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13489,12 +13460,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_binary_equal_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_EQUAL, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_EQUAL, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13511,12 +13481,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_binary_not_equal_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_NOT_EQUAL, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_NOT_EQUAL, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13533,13 +13502,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_binary_greater_than_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_GREATER_THAN, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_GREATER_THAN, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13556,13 +13523,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_binary_less_than_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_SMALLER_THAN, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_SMALLER_THAN, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13579,13 +13544,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_binary_greater_equal_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_GREATER_EQUAL, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_GREATER_EQUAL, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13602,13 +13565,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_binary_less_equal_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_SMALLER_EQUAL, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_SMALLER_EQUAL, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13625,12 +13586,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::LazyBooleanExpr>\n Parser<ManagedTokenSource>::parse_lazy_or_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_LOGICAL_OR, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_LOGICAL_OR, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13647,13 +13607,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::LazyBooleanExpr>\n Parser<ManagedTokenSource>::parse_lazy_and_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_LOGICAL_AND, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_LOGICAL_AND, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n \n@@ -13670,7 +13628,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::TypeCastExpr>\n Parser<ManagedTokenSource>::parse_type_cast_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> expr_to_cast,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED,\n   ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n@@ -13691,12 +13649,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::AssignmentExpr>\n Parser<ManagedTokenSource>::parse_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_ASSIG - 1, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13748,14 +13705,14 @@ get_lbp_for_compound_assignment_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_compound_assignment_expr (\n-  const_TokenPtr, std::unique_ptr<AST::Expr> left, std::vector<AST::Attribute>,\n+  const_TokenPtr, std::unique_ptr<AST::Expr> left, AST::AttrVec,\n   AST::CompoundAssignmentExpr::ExprType expr_type,\n   ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n     = parse_expr (get_lbp_for_compound_assignment_expr (expr_type) - 1,\n-\t\t  std::vector<AST::Attribute> (), restrictions);\n+\t\t  AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13773,13 +13730,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_plus_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_PLUS_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_PLUS_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13797,13 +13752,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_minus_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_MINUS_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_MINUS_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13822,13 +13775,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_mult_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_MULT_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_MULT_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13847,13 +13798,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_div_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_DIV_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_DIV_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13872,13 +13821,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_mod_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_MOD_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_MOD_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13897,13 +13844,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_and_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_AMP_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_AMP_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13922,13 +13867,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_or_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_PIPE_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_PIPE_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13947,13 +13890,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_xor_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_CARET_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_CARET_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13972,13 +13913,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_left_shift_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_L_SHIFT_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_L_SHIFT_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -13997,13 +13936,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CompoundAssignmentExpr>\n Parser<ManagedTokenSource>::parse_right_shift_assig_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_R_SHIFT_ASSIG - 1, std::vector<AST::Attribute> (),\n-\t\t  restrictions);\n+    = parse_expr (LBP_R_SHIFT_ASSIG - 1, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: ensure right-associativity for this - 'LBP - 1' may do this?\n@@ -14022,7 +13959,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::AwaitExpr>\n Parser<ManagedTokenSource>::parse_await_expr (\n   const_TokenPtr tok, std::unique_ptr<AST::Expr> expr_to_await,\n-  std::vector<AST::Attribute> outer_attrs)\n+  AST::AttrVec outer_attrs)\n {\n   /* skip \"await\" identifier (as \".\" has already been consumed in\n    * parse_expression) this assumes that the identifier was already identified\n@@ -14051,13 +13988,12 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::RangeExpr>\n Parser<ManagedTokenSource>::parse_led_range_exclusive_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // FIXME: this probably parses expressions accidently or whatever\n   // try parsing RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_DOT_DOT, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_DOT_DOT, AST::AttrVec (), restrictions);\n \n   Location locus = left->get_locus_slow ();\n \n@@ -14080,12 +14016,11 @@ Parser<ManagedTokenSource>::parse_led_range_exclusive_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::RangeExpr>\n Parser<ManagedTokenSource>::parse_nud_range_exclusive_expr (\n-  const_TokenPtr tok, std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED)\n+  const_TokenPtr tok, AST::AttrVec outer_attrs ATTRIBUTE_UNUSED)\n {\n   // FIXME: this probably parses expressions accidently or whatever\n   // try parsing RHS (as tok has already been consumed in parse_expression)\n-  std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_DOT_DOT, std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::Expr> right = parse_expr (LBP_DOT_DOT, AST::AttrVec ());\n \n   Location locus = tok->get_locus ();\n \n@@ -14108,12 +14043,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::RangeFromToInclExpr>\n Parser<ManagedTokenSource>::parse_range_inclusive_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> left,\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED,\n-  ParseRestrictions restrictions)\n+  AST::AttrVec outer_attrs ATTRIBUTE_UNUSED, ParseRestrictions restrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right\n-    = parse_expr (LBP_DOT_DOT_EQ, std::vector<AST::Attribute> (), restrictions);\n+    = parse_expr (LBP_DOT_DOT_EQ, AST::AttrVec (), restrictions);\n   if (right == nullptr)\n     return nullptr;\n   // FIXME: make non-associative\n@@ -14129,7 +14063,7 @@ Parser<ManagedTokenSource>::parse_range_inclusive_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::RangeToInclExpr>\n Parser<ManagedTokenSource>::parse_range_to_inclusive_expr (\n-  const_TokenPtr tok, std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED)\n+  const_TokenPtr tok, AST::AttrVec outer_attrs ATTRIBUTE_UNUSED)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   std::unique_ptr<AST::Expr> right = parse_expr (LBP_DOT_DOT_EQ);\n@@ -14148,8 +14082,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::TupleIndexExpr>\n Parser<ManagedTokenSource>::parse_tuple_index_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> tuple_expr,\n-  std::vector<AST::Attribute> outer_attrs,\n-  ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n {\n   // parse int literal (as token already skipped)\n   const_TokenPtr index_tok = expect_token (INT_LITERAL);\n@@ -14174,11 +14107,11 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArrayIndexExpr>\n Parser<ManagedTokenSource>::parse_index_expr (\n   const_TokenPtr, std::unique_ptr<AST::Expr> array_expr,\n-  std::vector<AST::Attribute> outer_attrs, ParseRestrictions)\n+  AST::AttrVec outer_attrs, ParseRestrictions)\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   /*std::unique_ptr<AST::Expr> index_expr\n-    = parse_expr (LBP_ARRAY_REF, std::vector<AST::Attribute> (),\n+    = parse_expr (LBP_ARRAY_REF, AST::AttrVec (),\n     restrictions);*/\n   // TODO: conceptually, should treat [] as brackets, so just parse all expr\n   std::unique_ptr<AST::Expr> index_expr = parse_expr ();\n@@ -14205,8 +14138,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::FieldAccessExpr>\n Parser<ManagedTokenSource>::parse_field_access_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> struct_expr,\n-  std::vector<AST::Attribute> outer_attrs,\n-  ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n {\n   /* get field name identifier (assume that this is a field access expr and not\n    * await, for instance) */\n@@ -14226,7 +14158,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::MethodCallExpr>\n Parser<ManagedTokenSource>::parse_method_call_expr (\n   const_TokenPtr tok, std::unique_ptr<AST::Expr> receiver_expr,\n-  std::vector<AST::Attribute> outer_attrs, ParseRestrictions)\n+  AST::AttrVec outer_attrs, ParseRestrictions)\n {\n   // parse path expr segment\n   AST::PathExprSegment segment = parse_path_expr_segment ();\n@@ -14289,7 +14221,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::CallExpr>\n Parser<ManagedTokenSource>::parse_function_call_expr (\n   const_TokenPtr, std::unique_ptr<AST::Expr> function_expr,\n-  std::vector<AST::Attribute> outer_attrs, ParseRestrictions)\n+  AST::AttrVec outer_attrs, ParseRestrictions)\n {\n   // parse function params (if they exist)\n   std::vector<std::unique_ptr<AST::Expr>> params;\n@@ -14335,7 +14267,7 @@ Parser<ManagedTokenSource>::parse_function_call_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroInvocation>\n Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n-  AST::PathInExpression path, std::vector<AST::Attribute> outer_attrs)\n+  AST::PathInExpression path, AST::AttrVec outer_attrs)\n {\n   // macro invocation\n   if (!skip_token (EXCLAM))\n@@ -14371,7 +14303,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::StructExprStruct>\n Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n-  AST::PathInExpression path, std::vector<AST::Attribute> outer_attrs)\n+  AST::PathInExpression path, AST::AttrVec outer_attrs)\n {\n   // assume struct expr struct (as struct-enum disambiguation requires name\n   // lookup) again, make statement if final ';'\n@@ -14381,7 +14313,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n     }\n \n   // parse inner attributes\n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   // branch based on next token\n   const_TokenPtr t = lexer.peek_token ();\n@@ -14508,14 +14440,14 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::CallExpr>\n Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n-  AST::PathInExpression path, std::vector<AST::Attribute> outer_attrs)\n+  AST::PathInExpression path, AST::AttrVec outer_attrs)\n {\n   if (!skip_token (LEFT_PAREN))\n     {\n       return nullptr;\n     }\n \n-  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+  AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n   std::vector<std::unique_ptr<AST::Expr>> exprs;\n \n@@ -14673,8 +14605,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n // Parses a closure expression with pratt parsing (from null denotation).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ClosureExpr>\n-Parser<ManagedTokenSource>::parse_closure_expr_pratt (\n-  const_TokenPtr tok, std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_closure_expr_pratt (const_TokenPtr tok,\n+\t\t\t\t\t\t      AST::AttrVec outer_attrs)\n {\n   // TODO: does this need pratt parsing (for precedence)? probably not, but idk\n   Location locus = tok->get_locus ();\n@@ -14806,8 +14738,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::TupleIndexExpr>\n Parser<ManagedTokenSource>::parse_tuple_index_expr_float (\n   const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n-  std::vector<AST::Attribute> outer_attrs,\n-  ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n {\n   // only works on float literals\n   if (tok->get_id () != FLOAT_LITERAL)"}, {"sha": "bde2613f03d83d516b321e622e361951e0f5ce2e", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 146, "deletions": 186, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -101,9 +101,9 @@ template <typename ManagedTokenSource> class Parser\n   void parse_statement_seq (bool (Parser::*done) ());\n \n   // AST-related stuff - maybe move or something?\n-  std::vector<AST::Attribute> parse_inner_attributes ();\n+  AST::AttrVec parse_inner_attributes ();\n   AST::Attribute parse_inner_attribute ();\n-  std::vector<AST::Attribute> parse_outer_attributes ();\n+  AST::AttrVec parse_outer_attributes ();\n   AST::Attribute parse_outer_attribute ();\n   AST::Attribute parse_attribute_body ();\n   std::unique_ptr<AST::AttrInput> parse_attr_input ();\n@@ -128,11 +128,11 @@ template <typename ManagedTokenSource> class Parser\n   AST::DelimTokenTree parse_delim_token_tree ();\n   std::unique_ptr<AST::TokenTree> parse_token_tree ();\n   std::unique_ptr<AST::MacroRulesDefinition>\n-  parse_macro_rules_def (std::vector<AST::Attribute> outer_attrs);\n+  parse_macro_rules_def (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocationSemi>\n-  parse_macro_invocation_semi (std::vector<AST::Attribute> outer_attrs);\n+  parse_macro_invocation_semi (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocation>\n-  parse_macro_invocation (std::vector<AST::Attribute> outer_attrs);\n+  parse_macro_invocation (AST::AttrVec outer_attrs);\n   AST::MacroRule parse_macro_rule ();\n   AST::MacroMatcher parse_macro_matcher ();\n   std::unique_ptr<AST::MacroMatch> parse_macro_match ();\n@@ -142,23 +142,20 @@ template <typename ManagedTokenSource> class Parser\n   // Top-level item-related\n   std::vector<std::unique_ptr<AST::Item> > parse_items ();\n   std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n-  std::unique_ptr<AST::VisItem>\n-  parse_vis_item (std::vector<AST::Attribute> outer_attrs);\n-  std::unique_ptr<AST::MacroItem>\n-  parse_macro_item (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::VisItem> parse_vis_item (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroItem> parse_macro_item (AST::AttrVec outer_attrs);\n   AST::Visibility parse_visibility ();\n \n   // VisItem subclass-related\n-  std::unique_ptr<AST::Module>\n-  parse_module (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Module> parse_module (AST::Visibility vis,\n+\t\t\t\t\t     AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExternCrate>\n-  parse_extern_crate (AST::Visibility vis,\n-\t\t      std::vector<AST::Attribute> outer_attrs);\n+  parse_extern_crate (AST::Visibility vis, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::UseDeclaration>\n-  parse_use_decl (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  parse_use_decl (AST::Visibility vis, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::UseTree> parse_use_tree ();\n-  std::unique_ptr<AST::Function>\n-  parse_function (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Function> parse_function (AST::Visibility vis,\n+\t\t\t\t\t\t AST::AttrVec outer_attrs);\n   AST::FunctionQualifiers parse_function_qualifiers ();\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params_in_angles ();\n@@ -207,359 +204,328 @@ template <typename ManagedTokenSource> class Parser\n   template <typename EndTokenPred>\n   std::vector<AST::Lifetime> parse_lifetime_bounds (EndTokenPred is_end_token);\n   AST::Lifetime parse_lifetime ();\n-  std::unique_ptr<AST::TypeAlias>\n-  parse_type_alias (AST::Visibility vis,\n-\t\t    std::vector<AST::Attribute> outer_attrs);\n-  std::unique_ptr<AST::Struct>\n-  parse_struct (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TypeAlias> parse_type_alias (AST::Visibility vis,\n+\t\t\t\t\t\t    AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::Struct> parse_struct (AST::Visibility vis,\n+\t\t\t\t\t     AST::AttrVec outer_attrs);\n   std::vector<AST::StructField> parse_struct_fields ();\n   template <typename EndTokenPred>\n   std::vector<AST::StructField> parse_struct_fields (EndTokenPred is_end_token);\n   AST::StructField parse_struct_field ();\n   std::vector<AST::TupleField> parse_tuple_fields ();\n   AST::TupleField parse_tuple_field ();\n-  std::unique_ptr<AST::Enum>\n-  parse_enum (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Enum> parse_enum (AST::Visibility vis,\n+\t\t\t\t\t AST::AttrVec outer_attrs);\n   std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::EnumItem> >\n   parse_enum_items (EndTokenPred is_end_token);\n   std::unique_ptr<AST::EnumItem> parse_enum_item ();\n-  std::unique_ptr<AST::Union>\n-  parse_union (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Union> parse_union (AST::Visibility vis,\n+\t\t\t\t\t   AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ConstantItem>\n-  parse_const_item (AST::Visibility vis,\n-\t\t    std::vector<AST::Attribute> outer_attrs);\n-  std::unique_ptr<AST::StaticItem>\n-  parse_static_item (AST::Visibility vis,\n-\t\t     std::vector<AST::Attribute> outer_attrs);\n-  std::unique_ptr<AST::Trait>\n-  parse_trait (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  parse_const_item (AST::Visibility vis, AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::StaticItem> parse_static_item (AST::Visibility vis,\n+\t\t\t\t\t\t      AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::Trait> parse_trait (AST::Visibility vis,\n+\t\t\t\t\t   AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TraitItem> parse_trait_item ();\n   std::unique_ptr<AST::TraitItemType>\n-  parse_trait_type (std::vector<AST::Attribute> outer_attrs);\n+  parse_trait_type (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TraitItemConst>\n-  parse_trait_const (std::vector<AST::Attribute> outer_attrs);\n+  parse_trait_const (AST::AttrVec outer_attrs);\n   AST::SelfParam parse_self_param ();\n-  std::unique_ptr<AST::Impl>\n-  parse_impl (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Impl> parse_impl (AST::Visibility vis,\n+\t\t\t\t\t AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n   std::unique_ptr<AST::InherentImplItem>\n-  parse_inherent_impl_function_or_method (\n-    AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  parse_inherent_impl_function_or_method (AST::Visibility vis,\n+\t\t\t\t\t  AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n   std::unique_ptr<AST::TraitImplItem>\n   parse_trait_impl_function_or_method (AST::Visibility vis,\n-\t\t\t\t       std::vector<AST::Attribute> outer_attrs);\n+\t\t\t\t       AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExternBlock>\n-  parse_extern_block (AST::Visibility vis,\n-\t\t      std::vector<AST::Attribute> outer_attrs);\n+  parse_extern_block (AST::Visibility vis, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n-  AST::NamedFunctionParam\n-  parse_named_function_param (std::vector<AST::Attribute> outer_attrs\n-\t\t\t      = std::vector<AST::Attribute> ());\n+  AST::NamedFunctionParam parse_named_function_param (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t      = AST::AttrVec ());\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)\n-  std::unique_ptr<AST::Expr> parse_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t\t\t\t = std::vector<AST::Attribute> (),\n-\t\t\t\t\t ParseRestrictions restrictions\n-\t\t\t\t\t = ParseRestrictions ());\n-  std::unique_ptr<AST::Expr> parse_expr (int right_binding_power,\n-\t\t\t\t\t std::vector<AST::Attribute> outer_attrs\n-\t\t\t\t\t = std::vector<AST::Attribute> (),\n-\t\t\t\t\t ParseRestrictions restrictions\n-\t\t\t\t\t = ParseRestrictions ());\n   std::unique_ptr<AST::Expr>\n-  null_denotation (const_TokenPtr t,\n-\t\t   std::vector<AST::Attribute> outer_attrs\n-\t\t   = std::vector<AST::Attribute> (),\n+  parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::Expr>\n+  parse_expr (int right_binding_power,\n+\t      AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::Expr>\n+  null_denotation (const_TokenPtr t, AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t   ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::Expr>\n   left_denotation (const_TokenPtr t, std::unique_ptr<AST::Expr> left,\n-\t\t   std::vector<AST::Attribute> outer_attrs\n-\t\t   = std::vector<AST::Attribute> (),\n+\t\t   AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t   ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_arithmetic_or_logical_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n-    AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n+    AST::AttrVec outer_attrs, AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_plus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  AST::AttrVec outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_minus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t   std::vector<AST::Attribute> outer_attrs,\n+\t\t\t   AST::AttrVec outer_attrs,\n \t\t\t   ParseRestrictions restrictions\n \t\t\t   = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_mult_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  AST::AttrVec outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_div_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_mod_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_bitwise_and_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  AST::AttrVec outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_bitwise_or_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_bitwise_xor_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  AST::AttrVec outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_left_shift_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_right_shift_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  AST::AttrVec outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr>\n   parse_comparison_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t AST::ComparisonExpr::ExprType expr_type,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr>\n   parse_binary_equal_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t   std::vector<AST::Attribute> outer_attrs,\n+\t\t\t   AST::AttrVec outer_attrs,\n \t\t\t   ParseRestrictions restrictions\n \t\t\t   = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::LazyBooleanExpr>\n   parse_lazy_or_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t      std::vector<AST::Attribute> outer_attrs,\n+\t\t      AST::AttrVec outer_attrs,\n \t\t      ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::LazyBooleanExpr>\n   parse_lazy_and_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t       std::vector<AST::Attribute> outer_attrs,\n+\t\t       AST::AttrVec outer_attrs,\n \t\t       ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::TypeCastExpr>\n   parse_type_cast_expr (const_TokenPtr tok,\n \t\t\tstd::unique_ptr<AST::Expr> expr_to_cast,\n-\t\t\tstd::vector<AST::Attribute> outer_attrs,\n+\t\t\tAST::AttrVec outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::AssignmentExpr>\n   parse_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t    std::vector<AST::Attribute> outer_attrs,\n+\t\t    AST::AttrVec outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr> parse_compound_assignment_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n-    AST::CompoundAssignmentExpr::ExprType expr_type,\n+    AST::AttrVec outer_attrs, AST::CompoundAssignmentExpr::ExprType expr_type,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_plus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_minus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  AST::AttrVec outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_mult_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs,\n+\t\t\t AST::AttrVec outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_div_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\tstd::vector<AST::Attribute> outer_attrs,\n+\t\t\tAST::AttrVec outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_mod_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\tstd::vector<AST::Attribute> outer_attrs,\n+\t\t\tAST::AttrVec outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_and_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\tstd::vector<AST::Attribute> outer_attrs,\n+\t\t\tAST::AttrVec outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_or_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t       std::vector<AST::Attribute> outer_attrs,\n+\t\t       AST::AttrVec outer_attrs,\n \t\t       ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_xor_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\tstd::vector<AST::Attribute> outer_attrs,\n+\t\t\tAST::AttrVec outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::AwaitExpr>\n   parse_await_expr (const_TokenPtr tok,\n \t\t    std::unique_ptr<AST::Expr> expr_to_await,\n-\t\t    std::vector<AST::Attribute> outer_attrs);\n+\t\t    AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> receiver_expr,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CallExpr> parse_function_call_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> function_expr,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::RangeExpr>\n-  parse_nud_range_exclusive_expr (const_TokenPtr tok,\n-\t\t\t\t  std::vector<AST::Attribute> outer_attrs);\n+  parse_nud_range_exclusive_expr (const_TokenPtr tok, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::RangeToInclExpr>\n-  parse_range_to_inclusive_expr (const_TokenPtr tok,\n-\t\t\t\t std::vector<AST::Attribute> outer_attrs);\n+  parse_range_to_inclusive_expr (const_TokenPtr tok, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> struct_expr,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArrayIndexExpr>\n   parse_index_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> array_expr,\n-\t\t    std::vector<AST::Attribute> outer_attrs,\n+\t\t    AST::AttrVec outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation_partial (AST::PathInExpression path,\n-\t\t\t\t  std::vector<AST::Attribute> outer_attrs);\n+\t\t\t\t  AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::StructExprStruct>\n   parse_struct_expr_struct_partial (AST::PathInExpression path,\n-\t\t\t\t    std::vector<AST::Attribute> outer_attrs);\n+\t\t\t\t    AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::CallExpr>\n   parse_struct_expr_tuple_partial (AST::PathInExpression path,\n-\t\t\t\t   std::vector<AST::Attribute> outer_attrs);\n+\t\t\t\t   AST::AttrVec outer_attrs);\n   AST::PathInExpression parse_path_in_expression_pratt (const_TokenPtr tok);\n   std::unique_ptr<AST::ClosureExpr>\n   parse_closure_expr_pratt (const_TokenPtr tok,\n-\t\t\t    std::vector<AST::Attribute> outer_attrs\n-\t\t\t    = std::vector<AST::Attribute> ());\n+\t\t\t    AST::AttrVec outer_attrs = AST::AttrVec ());\n   std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float (\n     const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n-    std::vector<AST::Attribute> outer_attrs,\n+    AST::AttrVec outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n \n   // Expression-related (non-Pratt parsed)\n   std::unique_ptr<AST::ExprWithBlock>\n-  parse_expr_with_block (std::vector<AST::Attribute> outer_attrs);\n+  parse_expr_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_expr_without_block (std::vector<AST::Attribute> outer_attrs\n-\t\t\t    = std::vector<AST::Attribute> ());\n-  std::unique_ptr<AST::BlockExpr>\n-  parse_block_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t    = std::vector<AST::Attribute> (),\n-\t\t    bool pratt_parse = false);\n-  std::unique_ptr<AST::IfExpr>\n-  parse_if_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t = std::vector<AST::Attribute> (),\n-\t\t bool pratt_parse = false);\n-  std::unique_ptr<AST::IfLetExpr>\n-  parse_if_let_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t     = std::vector<AST::Attribute> (),\n-\t\t     bool pratt_parse = false);\n-  std::unique_ptr<AST::LoopExpr> parse_loop_expr (\n-    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> (),\n-    AST::LoopLabel label = AST::LoopLabel::error (), bool pratt_parse = false);\n-  std::unique_ptr<AST::WhileLoopExpr> parse_while_loop_expr (\n-    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> (),\n-    AST::LoopLabel label = AST::LoopLabel::error (), bool pratt_parse = false);\n+  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec ());\n+  std::unique_ptr<AST::BlockExpr> parse_block_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t    = AST::AttrVec (),\n+\t\t\t\t\t\t    bool pratt_parse = false);\n+  std::unique_ptr<AST::IfExpr> parse_if_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t      = AST::AttrVec (),\n+\t\t\t\t\t      bool pratt_parse = false);\n+  std::unique_ptr<AST::IfLetExpr> parse_if_let_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t     = AST::AttrVec (),\n+\t\t\t\t\t\t     bool pratt_parse = false);\n+  std::unique_ptr<AST::LoopExpr>\n+  parse_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t   AST::LoopLabel label = AST::LoopLabel::error (),\n+\t\t   bool pratt_parse = false);\n+  std::unique_ptr<AST::WhileLoopExpr>\n+  parse_while_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t AST::LoopLabel label = AST::LoopLabel::error (),\n+\t\t\t bool pratt_parse = false);\n   std::unique_ptr<AST::WhileLetLoopExpr>\n-  parse_while_let_loop_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t\t     = std::vector<AST::Attribute> (),\n+  parse_while_let_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t\t     AST::LoopLabel label = AST::LoopLabel::error ());\n   std::unique_ptr<AST::ForLoopExpr>\n-  parse_for_loop_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t       = std::vector<AST::Attribute> (),\n+  parse_for_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t       AST::LoopLabel label = AST::LoopLabel::error ());\n-  std::unique_ptr<AST::MatchExpr>\n-  parse_match_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t    = std::vector<AST::Attribute> (),\n-\t\t    bool pratt_parse = false);\n+  std::unique_ptr<AST::MatchExpr> parse_match_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t    = AST::AttrVec (),\n+\t\t\t\t\t\t    bool pratt_parse = false);\n   AST::MatchArm parse_match_arm ();\n   std::vector<std::unique_ptr<AST::Pattern> >\n   parse_match_arm_patterns (TokenId end_token_id);\n   std::unique_ptr<AST::BaseLoopExpr>\n-  parse_labelled_loop_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t\t    = std::vector<AST::Attribute> ());\n+  parse_labelled_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n   AST::LoopLabel parse_loop_label ();\n   std::unique_ptr<AST::AsyncBlockExpr>\n-  parse_async_block_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t\t  = std::vector<AST::Attribute> ());\n+  parse_async_block_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n   std::unique_ptr<AST::UnsafeBlockExpr>\n-  parse_unsafe_block_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t\t   = std::vector<AST::Attribute> ());\n-  std::unique_ptr<AST::GroupedExpr>\n-  parse_grouped_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t      = std::vector<AST::Attribute> ());\n-  std::unique_ptr<AST::ClosureExpr>\n-  parse_closure_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t      = std::vector<AST::Attribute> ());\n+  parse_unsafe_block_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n+  std::unique_ptr<AST::GroupedExpr> parse_grouped_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+  std::unique_ptr<AST::ClosureExpr> parse_closure_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n   AST::ClosureParam parse_closure_param ();\n-  std::unique_ptr<AST::LiteralExpr>\n-  parse_literal_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t      = std::vector<AST::Attribute> ());\n-  std::unique_ptr<AST::ReturnExpr>\n-  parse_return_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t     = std::vector<AST::Attribute> (),\n-\t\t     bool pratt_parse = false);\n-  std::unique_ptr<AST::BreakExpr>\n-  parse_break_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t    = std::vector<AST::Attribute> (),\n-\t\t    bool pratt_parse = false);\n+  std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+  std::unique_ptr<AST::ReturnExpr> parse_return_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t      = AST::AttrVec (),\n+\t\t\t\t\t\t      bool pratt_parse = false);\n+  std::unique_ptr<AST::BreakExpr> parse_break_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t    = AST::AttrVec (),\n+\t\t\t\t\t\t    bool pratt_parse = false);\n   std::unique_ptr<AST::ContinueExpr>\n-  parse_continue_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t       = std::vector<AST::Attribute> (),\n+  parse_continue_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t       bool pratt_parse = false);\n-  std::unique_ptr<AST::ArrayExpr>\n-  parse_array_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t    = std::vector<AST::Attribute> (),\n-\t\t    bool pratt_parse = false);\n+  std::unique_ptr<AST::ArrayExpr> parse_array_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t    = AST::AttrVec (),\n+\t\t\t\t\t\t    bool pratt_parse = false);\n   std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_grouped_or_tuple_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t\t       = std::vector<AST::Attribute> (),\n+  parse_grouped_or_tuple_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t\t       bool pratt_parse = false);\n   std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n   bool will_be_expr_with_block ();\n@@ -575,26 +541,20 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n   std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n-  AST::MaybeNamedParam\n-  parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n+  AST::MaybeNamedParam parse_maybe_named_param (AST::AttrVec outer_attrs);\n \n   // Statement-related\n   std::unique_ptr<AST::Stmt> parse_stmt ();\n-  std::unique_ptr<AST::LetStmt>\n-  parse_let_stmt (std::vector<AST::Attribute> outer_attrs);\n-  std::unique_ptr<AST::ExprStmt>\n-  parse_expr_stmt (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithBlock>\n-  parse_expr_stmt_with_block (std::vector<AST::Attribute> outer_attrs);\n+  parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithoutBlock>\n-  parse_expr_stmt_without_block (std::vector<AST::Attribute> outer_attrs);\n+  parse_expr_stmt_without_block (AST::AttrVec outer_attrs);\n   ExprOrStmt parse_stmt_or_expr_without_block ();\n-  ExprOrStmt\n-  parse_stmt_or_expr_with_block (std::vector<AST::Attribute> outer_attrs);\n-  ExprOrStmt\n-  parse_macro_invocation_maybe_semi (std::vector<AST::Attribute> outer_attrs);\n-  ExprOrStmt\n-  parse_path_based_stmt_or_expr (std::vector<AST::Attribute> outer_attrs);\n+  ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n+  ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);\n+  ExprOrStmt parse_path_based_stmt_or_expr (AST::AttrVec outer_attrs);\n \n   // Pattern-related\n   std::unique_ptr<AST::Pattern> parse_pattern ();\n@@ -609,7 +569,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::StructPatternElements parse_struct_pattern_elems ();\n   std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n   std::unique_ptr<AST::StructPatternField>\n-  parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n+  parse_struct_pattern_field_partial (AST::AttrVec outer_attrs);\n \n   int left_binding_power (const_TokenPtr token);\n "}, {"sha": "6ed556a9aa6bf485d519b4cc2cd0477e2dc45a50", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -657,7 +657,7 @@ Session::register_plugins (AST::Crate &crate ATTRIBUTE_UNUSED)\n \n // TODO: move somewhere else\n bool\n-contains_name (const std::vector<AST::Attribute> &attrs, std::string name)\n+contains_name (const AST::AttrVec &attrs, std::string name)\n {\n   for (const auto &attr : attrs)\n     {"}, {"sha": "108d37250384ba95e891c6b1b343ecd81706f2c0", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -36,8 +36,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual ~ConstFoldBase () {}\n \n   virtual void visit (HIR::Token &) override {}\n-  virtual void visit (HIR::DelimTokenTree &) override {}\n-  virtual void visit (HIR::AttrInputMetaItemContainer &) override {}\n   virtual void visit (HIR::IdentifierExpr &) override {}\n   virtual void visit (HIR::Lifetime &) override {}\n   virtual void visit (HIR::LifetimeParam &) override {}\n@@ -50,9 +48,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::QualifiedPathInType &) override {}\n \n   virtual void visit (HIR::LiteralExpr &) override {}\n-  virtual void visit (HIR::AttrInputLiteral &) override {}\n-  virtual void visit (HIR::MetaItemLitExpr &) override {}\n-  virtual void visit (HIR::MetaItemPathLit &) override {}\n   virtual void visit (HIR::BorrowExpr &) override {}\n   virtual void visit (HIR::DereferenceExpr &) override {}\n   virtual void visit (HIR::ErrorPropagationExpr &) override {}\n@@ -164,12 +159,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::MacroMatcher &) override {}\n   virtual void visit (HIR::MacroRulesDefinition &) override {}\n   virtual void visit (HIR::MacroInvocation &) override {}\n-  virtual void visit (HIR::MetaItemPath &) override {}\n-  virtual void visit (HIR::MetaItemSeq &) override {}\n-  virtual void visit (HIR::MetaWord &) override {}\n-  virtual void visit (HIR::MetaNameValueStr &) override {}\n-  virtual void visit (HIR::MetaListPaths &) override {}\n-  virtual void visit (HIR::MetaListNameValueStr &) override {}\n \n   virtual void visit (HIR::LiteralPattern &) override {}\n   virtual void visit (HIR::IdentifierPattern &) override {}"}, {"sha": "a0ec0a0651dcfd6ba05ac979299fd90c1c2fda96", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -35,8 +35,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual ~TypeCheckBase () {}\n \n   virtual void visit (HIR::Token &) override {}\n-  virtual void visit (HIR::DelimTokenTree &) override {}\n-  virtual void visit (HIR::AttrInputMetaItemContainer &) override {}\n   virtual void visit (HIR::IdentifierExpr &) override {}\n   virtual void visit (HIR::Lifetime &) override {}\n   virtual void visit (HIR::LifetimeParam &) override {}\n@@ -49,9 +47,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::QualifiedPathInType &) override {}\n \n   virtual void visit (HIR::LiteralExpr &) override {}\n-  virtual void visit (HIR::AttrInputLiteral &) override {}\n-  virtual void visit (HIR::MetaItemLitExpr &) override {}\n-  virtual void visit (HIR::MetaItemPathLit &) override {}\n   virtual void visit (HIR::BorrowExpr &) override {}\n   virtual void visit (HIR::DereferenceExpr &) override {}\n   virtual void visit (HIR::ErrorPropagationExpr &) override {}\n@@ -163,12 +158,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::MacroMatcher &) override {}\n   virtual void visit (HIR::MacroRulesDefinition &) override {}\n   virtual void visit (HIR::MacroInvocation &) override {}\n-  virtual void visit (HIR::MetaItemPath &) override {}\n-  virtual void visit (HIR::MetaItemSeq &) override {}\n-  virtual void visit (HIR::MetaWord &) override {}\n-  virtual void visit (HIR::MetaNameValueStr &) override {}\n-  virtual void visit (HIR::MetaListPaths &) override {}\n-  virtual void visit (HIR::MetaListNameValueStr &) override {}\n \n   virtual void visit (HIR::LiteralPattern &) override {}\n   virtual void visit (HIR::IdentifierPattern &) override {}"}, {"sha": "d21fb3ddd639440286439e4f164bef14da62c8f7", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75de60e68b46c555a87822a78d20c7197bddffb5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=75de60e68b46c555a87822a78d20c7197bddffb5", "patch": "@@ -208,7 +208,7 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \n \t      HIR::StructExprField *implicit_field = nullptr;\n \n-\t      std::vector<HIR::Attribute> outer_attribs;\n+\t      AST::AttrVec outer_attribs;\n \t      auto crate_num = mappings->get_current_crate ();\n \t      Analysis::NodeMapping mapping (\n \t\tcrate_num,"}]}