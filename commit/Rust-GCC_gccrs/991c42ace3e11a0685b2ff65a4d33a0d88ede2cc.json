{"sha": "991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkxYzQyYWNlM2UxMWEwNjg1YjJmZjY1YTRkMzNhMGQ4OGVkZTJjYw==", "commit": {"author": {"name": "Jan-Benedict Glaw", "email": "jbglaw@lug-owl.de", "date": "2007-02-19T12:34:12Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-02-19T12:34:12Z"}, "message": "* config/cris/cris.c (cris_movem_load_rest_p, cris_store_multiple_op_p)\n\t(cris_print_index, cris_print_operand, cris_print_operand_address)\n\t(cris_reload_address_legitimized, cris_rtx_costs, cris_address_cost)\n\t(cris_side_effect_mode_ok, cris_valid_pic_const, cris_split_movdx)\n\t(cris_expand_pic_call_address): Use xxx_P predicate macros instead of\n\tGET_CODE () == xxx.\n\t* config/cris/cris.h (SECONDARY_RELOAD_CLASS, EXTRA_CONSTRAINT_Q,\n\tEXTRA_CONSTRAINT_T, BDAP_INDEX_P, BIAP_INDEX_P, SIMPLE_ADDRESS_P,\n\tGO_IF_LEGITIMATE_ADDRESS): Ditto.\n\t* config/cris/cris.md (define_insns: *btst, movdi, *mov_side<mode>)\n\t(*mov_sidesisf, *mov_side<mode>_mem, *mov_sidesisf_mem)\n\t(*clear_side<mode>, movsi, *movsi_internal, *ext_sideqihi)\n\t(*ext_side<mode>si, *op_side<mode>, *op_swap_side<mode>, addsi3)\n\t(*extopqihi_side, *extop<mode>si_side, *extopqihi_swap_side)\n\t(*extop<mode>si_swap_side, addi_mul, *addi,andsi3, andhi3, ashl<mode>3)\n\t(uminsi3, call, call_value): Ditto.\n\t(define_split: indir_to_reg_split, unnamed): Ditto.\n\nFrom-SVN: r122128", "tree": {"sha": "0a3b579b165e56cbe97c9b776afa8ecddc9ae7e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a3b579b165e56cbe97c9b776afa8ecddc9ae7e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/comments", "author": {"login": "jbglaw", "id": 7965297, "node_id": "MDQ6VXNlcjc5NjUyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7965297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbglaw", "html_url": "https://github.com/jbglaw", "followers_url": "https://api.github.com/users/jbglaw/followers", "following_url": "https://api.github.com/users/jbglaw/following{/other_user}", "gists_url": "https://api.github.com/users/jbglaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbglaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbglaw/subscriptions", "organizations_url": "https://api.github.com/users/jbglaw/orgs", "repos_url": "https://api.github.com/users/jbglaw/repos", "events_url": "https://api.github.com/users/jbglaw/events{/privacy}", "received_events_url": "https://api.github.com/users/jbglaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "602fea7c2637ac820a8e80bf8c7b9ea9e7a776da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602fea7c2637ac820a8e80bf8c7b9ea9e7a776da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602fea7c2637ac820a8e80bf8c7b9ea9e7a776da"}], "stats": {"total": 235, "additions": 123, "deletions": 112}, "files": [{"sha": "e6cdb6ea97b404bec652057750aa569c11bda141", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "patch": "@@ -1,3 +1,23 @@\n+2007-02-19  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n+\n+\t* config/cris/cris.c (cris_movem_load_rest_p, cris_store_multiple_op_p)\n+\t(cris_print_index, cris_print_operand, cris_print_operand_address)\n+\t(cris_reload_address_legitimized, cris_rtx_costs, cris_address_cost)\n+\t(cris_side_effect_mode_ok, cris_valid_pic_const, cris_split_movdx)\n+\t(cris_expand_pic_call_address): Use xxx_P predicate macros instead of\n+\tGET_CODE () == xxx.\n+\t* config/cris/cris.h (SECONDARY_RELOAD_CLASS, EXTRA_CONSTRAINT_Q,\n+\tEXTRA_CONSTRAINT_T, BDAP_INDEX_P, BIAP_INDEX_P, SIMPLE_ADDRESS_P,\n+\tGO_IF_LEGITIMATE_ADDRESS): Ditto.\n+\t* config/cris/cris.md (define_insns: *btst, movdi, *mov_side<mode>)\n+\t(*mov_sidesisf, *mov_side<mode>_mem, *mov_sidesisf_mem)\n+\t(*clear_side<mode>, movsi, *movsi_internal, *ext_sideqihi)\n+\t(*ext_side<mode>si, *op_side<mode>, *op_swap_side<mode>, addsi3)\n+\t(*extopqihi_side, *extop<mode>si_side, *extopqihi_swap_side)\n+\t(*extop<mode>si_swap_side, addi_mul, *addi,andsi3, andhi3, ashl<mode>3)\n+\t(uminsi3, call, call_value): Ditto.\n+\t(define_split: indir_to_reg_split, unnamed): Ditto.\n+\n 2007-02-19  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/30975"}, {"sha": "ad97764226ba37b59e4a0bb5c7d7ac8783a964c1", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "patch": "@@ -205,8 +205,8 @@ cris_movem_load_rest_p (rtx op, int offs)\n      other than (MEM reg).  */\n   if (reg_count <= 1\n       || GET_CODE (XVECEXP (op, 0, offs)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, offs))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, offs))) != MEM)\n+      || !REG_P (SET_DEST (XVECEXP (op, 0, offs)))\n+      || !MEM_P (SET_SRC (XVECEXP (op, 0, offs))))\n     return false;\n \n   /* Check a possible post-inc indicator.  */\n@@ -221,7 +221,7 @@ cris_movem_load_rest_p (rtx op, int offs)\n \t  || !REG_P (reg)\n \t  || !REG_P (SET_DEST (XVECEXP (op, 0, offs + 1)))\n \t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, offs + 1)))\n-\t  || GET_CODE (inc) != CONST_INT\n+\t  || !CONST_INT_P (inc)\n \t  || INTVAL (inc) != (HOST_WIDE_INT) reg_count * 4)\n \treturn false;\n       i = offs + 2;\n@@ -237,10 +237,10 @@ cris_movem_load_rest_p (rtx op, int offs)\n   src_addr = XEXP (SET_SRC (elt), 0);\n \n   if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_DEST (elt)) != REG\n+      || !REG_P (SET_DEST (elt))\n       || GET_MODE (SET_DEST (elt)) != SImode\n       || REGNO (SET_DEST (elt)) != regno\n-      || GET_CODE (SET_SRC (elt)) != MEM\n+      || !MEM_P (SET_SRC (elt))\n       || GET_MODE (SET_SRC (elt)) != SImode\n       || !memory_address_p (SImode, src_addr))\n     return false;\n@@ -251,14 +251,14 @@ cris_movem_load_rest_p (rtx op, int offs)\n       regno += regno_dir;\n \n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || !REG_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != SImode\n \t  || REGNO (SET_DEST (elt)) != regno\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || !MEM_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != SImode\n \t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || !CONST_INT_P (XEXP (XEXP (SET_SRC (elt), 0), 1))\n \t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != setno * 4)\n \treturn false;\n     }\n@@ -295,8 +295,7 @@ cris_store_multiple_op_p (rtx op)\n \n   dest = SET_DEST (elt);\n \n-  if (GET_CODE (SET_SRC (elt)) != REG\n-      || GET_CODE (dest) != MEM)\n+  if (!REG_P (SET_SRC (elt)) || !MEM_P (dest))\n     return false;\n \n   dest_addr = XEXP (dest, 0);\n@@ -313,7 +312,7 @@ cris_store_multiple_op_p (rtx op)\n \t  || !REG_P (reg)\n \t  || !REG_P (SET_DEST (XVECEXP (op, 0, 1)))\n \t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, 1)))\n-\t  || GET_CODE (inc) != CONST_INT\n+\t  || !CONST_INT_P (inc)\n \t  /* Support increment by number of registers, and by the offset\n \t     of the destination, if it has the form (MEM (PLUS reg\n \t     offset)).  */\n@@ -323,7 +322,7 @@ cris_store_multiple_op_p (rtx op)\n \t       || (GET_CODE (dest_addr) == PLUS\n \t\t   && REG_P (XEXP (dest_addr, 0))\n \t\t   && REGNO (XEXP (dest_addr, 0)) == REGNO (reg)\n-\t\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT\n+\t\t   && CONST_INT_P (XEXP (dest_addr, 1))\n \t\t   && INTVAL (XEXP (dest_addr, 1)) == INTVAL (inc))))\n \treturn false;\n \n@@ -337,10 +336,10 @@ cris_store_multiple_op_p (rtx op)\n   regno = reg_count - 1;\n \n   if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_SRC (elt)) != REG\n+      || !REG_P (SET_SRC (elt))\n       || GET_MODE (SET_SRC (elt)) != SImode\n       || REGNO (SET_SRC (elt)) != (unsigned int) regno\n-      || GET_CODE (SET_DEST (elt)) != MEM\n+      || !MEM_P (SET_DEST (elt))\n       || GET_MODE (SET_DEST (elt)) != SImode)\n     return false;\n \n@@ -351,7 +350,7 @@ cris_store_multiple_op_p (rtx op)\n     }\n   else if (GET_CODE (dest_addr) == PLUS\n \t   && REG_P (XEXP (dest_addr, 0))\n-\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)\n+\t   && CONST_INT_P (XEXP (dest_addr, 1)))\n     {\n       dest_base = XEXP (dest_addr, 0);\n       offset = INTVAL (XEXP (dest_addr, 1));\n@@ -365,14 +364,14 @@ cris_store_multiple_op_p (rtx op)\n       regno += regno_dir;\n \n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || !REG_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != SImode\n \t  || REGNO (SET_SRC (elt)) != (unsigned int) regno\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || !MEM_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != SImode\n \t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_base)\n-\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || !CONST_INT_P (XEXP (XEXP (SET_DEST (elt), 0), 1))\n \t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != setno * 4 + offset)\n \treturn false;\n     }\n@@ -501,7 +500,7 @@ cris_print_index (rtx index, FILE *file)\n \n   /* Make the index \"additive\" unless we'll output a negative number, in\n      which case the sign character is free (as in free beer).  */\n-  if (GET_CODE (index) != CONST_INT || INTVAL (index) >= 0)\n+  if (!CONST_INT_P (index) || INTVAL (index) >= 0)\n     putc ('+', file);\n \n   if (REG_P (index))\n@@ -515,8 +514,7 @@ cris_print_index (rtx index, FILE *file)\n \n       putc (INTVAL (XEXP (index, 1)) == 2 ? 'w' : 'd', file);\n     }\n-  else if (GET_CODE (index) == SIGN_EXTEND &&\n-\t   GET_CODE (inner) == MEM)\n+  else if (GET_CODE (index) == SIGN_EXTEND && MEM_P (inner))\n     {\n       rtx inner_inner = XEXP (inner, 0);\n \n@@ -533,7 +531,7 @@ cris_print_index (rtx index, FILE *file)\n \t  putc (GET_MODE (inner) == HImode ? 'w' : 'b', file);\n \t}\n     }\n-  else if (GET_CODE (index) == MEM)\n+  else if (MEM_P (index))\n     {\n       if (GET_CODE (inner) == POST_INC)\n \tfprintf (file, \"[$%s+].d\", reg_names[REGNO (XEXP (inner, 0))]);\n@@ -669,7 +667,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     case 'b':\n       /* Print the unsigned supplied integer as if it were signed\n \t and < 0, i.e print 255 or 65535 as -1, 254, 65534 as -2, etc.  */\n-      if (GET_CODE (x) != CONST_INT\n+      if (!CONST_INT_P (x)\n \t  || ! CONST_OK_FOR_LETTER_P (INTVAL (x), 'O'))\n \tLOSE_AND_RETURN (\"invalid operand for 'b' modifier\", x);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n@@ -711,7 +709,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n \n \t/* The lowest mem operand is in the first item, but perhaps it\n \t   needs to be output as postincremented.  */\n-\taddr = GET_CODE (SET_SRC (XVECEXP (x, 0, 0))) == MEM\n+\taddr = MEM_P (SET_SRC (XVECEXP (x, 0, 0)))\n \t  ? XEXP (SET_SRC (XVECEXP (x, 0, 0)), 0)\n \t  : XEXP (SET_DEST (XVECEXP (x, 0, 0)), 0);\n \n@@ -739,7 +737,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n \n     case 'p':\n       /* Adjust a power of two to its log2.  */\n-      if (GET_CODE (x) != CONST_INT || exact_log2 (INTVAL (x)) < 0 )\n+      if (!CONST_INT_P (x) || exact_log2 (INTVAL (x)) < 0 )\n \tLOSE_AND_RETURN (\"invalid operand for 'p' modifier\", x);\n       fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n       return;\n@@ -749,7 +747,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t respectively.  This modifier also terminates the inhibiting\n          effects of the 'x' modifier.  */\n       cris_output_insn_is_bound = 0;\n-      if (GET_MODE (x) == VOIDmode && GET_CODE (x) == CONST_INT)\n+      if (GET_MODE (x) == VOIDmode && CONST_INT_P (x))\n \t{\n \t  if (INTVAL (x) >= 0)\n \t    {\n@@ -777,7 +775,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     case 'z':\n       /* Const_int: print b for -127 <= x <= 255,\n \t w for -32768 <= x <= 65535, else die.  */\n-      if (GET_CODE (x) != CONST_INT\n+      if (!CONST_INT_P (x)\n \t  || INTVAL (x) < -32768 || INTVAL (x) > 65535)\n \tLOSE_AND_RETURN (\"invalid operand for 'z' modifier\", x);\n       putc (INTVAL (x) >= -128 && INTVAL (x) <= 255 ? 'b' : 'w', file);\n@@ -883,7 +881,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t cris_output_insn_is_bound is nonzero.  */\n       if (GET_CODE (operand) != SIGN_EXTEND\n \t  && GET_CODE (operand) != ZERO_EXTEND\n-\t  && GET_CODE (operand) != CONST_INT)\n+\t  && !CONST_INT_P (operand))\n \tLOSE_AND_RETURN (\"invalid operand for 'e' modifier\", x);\n \n       if (cris_output_insn_is_bound)\n@@ -893,7 +891,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t}\n \n       putc (GET_CODE (operand) == SIGN_EXTEND\n-\t    || (GET_CODE (operand) == CONST_INT && INTVAL (operand) < 0)\n+\t    || (CONST_INT_P (operand) && INTVAL (operand) < 0)\n \t    ? 's' : 'u', file);\n       return;\n \n@@ -912,7 +910,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_LOW (x));\n \t  return;\n \t}\n-      else if (HOST_BITS_PER_WIDE_INT > 32 && GET_CODE (operand) == CONST_INT)\n+      else if (HOST_BITS_PER_WIDE_INT > 32 && CONST_INT_P (operand))\n \t{\n \t  fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n \t\t   INTVAL (x) & ((unsigned int) 0x7fffffff * 2 + 1));\n@@ -925,7 +923,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     case 'A':\n       /* When emitting an add for the high part of a DImode constant, we\n \t want to use addq for 0 and adds.w for -1.  */\n-      if (GET_CODE (operand) != CONST_INT)\n+      if (!CONST_INT_P (operand))\n \tLOSE_AND_RETURN (\"invalid operand for 'A' modifier\", x);\n       fprintf (file, INTVAL (operand) < 0 ? \"adds.w\" : \"addq\");\n       return;\n@@ -948,7 +946,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     case 'D':\n       /* When emitting an sub for the high part of a DImode constant, we\n \t want to use subq for 0 and subs.w for -1.  */\n-      if (GET_CODE (operand) != CONST_INT)\n+      if (!CONST_INT_P (operand))\n \tLOSE_AND_RETURN (\"invalid operand for 'D' modifier\", x);\n       fprintf (file, INTVAL (operand) < 0 ? \"subs.w\" : \"subq\");\n       return;\n@@ -962,7 +960,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     case 'T':\n       /* Print the size letter for an operand to a MULT, which must be a\n \t const_int with a suitable value.  */\n-      if (GET_CODE (operand) != CONST_INT || INTVAL (operand) > 4)\n+      if (!CONST_INT_P (operand) || INTVAL (operand) > 4)\n \tLOSE_AND_RETURN (\"invalid operand for 'T' modifier\", x);\n       fprintf (file, \"%s\", mults[INTVAL (operand)]);\n       return;\n@@ -1021,14 +1019,14 @@ cris_print_operand (FILE *file, rtx x, int code)\n     case ASHIFT:\n       {\n \t/* For a (MULT (reg X) const_int) we output \"rX.S\".  */\n-\tint i = GET_CODE (XEXP (operand, 1)) == CONST_INT\n+\tint i = CONST_INT_P (XEXP (operand, 1))\n \t  ? INTVAL (XEXP (operand, 1)) : INTVAL (XEXP (operand, 0));\n-\trtx reg = GET_CODE (XEXP (operand, 1)) == CONST_INT\n+\trtx reg = CONST_INT_P (XEXP (operand, 1))\n \t  ? XEXP (operand, 0) : XEXP (operand, 1);\n \n-\tif (GET_CODE (reg) != REG\n-\t    || (GET_CODE (XEXP (operand, 0)) != CONST_INT\n-\t\t&& GET_CODE (XEXP (operand, 1)) != CONST_INT))\n+\tif (!REG_P (reg)\n+\t    || (!CONST_INT_P (XEXP (operand, 0))\n+\t\t&& !CONST_INT_P (XEXP (operand, 1))))\n \t  LOSE_AND_RETURN (\"unexpected multiplicative operand\", x);\n \n \tcris_print_base (reg, file);\n@@ -1084,7 +1082,7 @@ cris_print_operand_address (FILE *file, rtx x)\n       else\n \tLOSE_AND_RETURN (\"unrecognized address\", x);\n     }\n-  else if (GET_CODE (x) == MEM)\n+  else if (MEM_P (x))\n     {\n       /* A DIP.  Output more indirection characters.  */\n       putc ('[', file);\n@@ -1238,8 +1236,7 @@ cris_reload_address_legitimized (rtx x,\n   if (!REG_P (op1))\n     return false;\n \n-  if (GET_CODE (op0) == SIGN_EXTEND\n-      && GET_CODE (XEXP (op0, 0)) == MEM)\n+  if (GET_CODE (op0) == SIGN_EXTEND && MEM_P (XEXP (op0, 0)))\n     {\n       rtx op00 = XEXP (op0, 0);\n       rtx op000 = XEXP (op00, 0);\n@@ -1390,7 +1387,7 @@ cris_notice_update_cc (rtx exp, rtx insn)\n \t      if (GET_CODE (SET_SRC (exp)) == ZERO_EXTRACT\n \t\t  && XEXP (SET_SRC (exp), 1) == const1_rtx)\n \t\t{\n-\t\t  if (GET_CODE (XEXP (SET_SRC (exp), 0)) == CONST_INT)\n+\t\t  if (CONST_INT_P (XEXP (SET_SRC (exp), 0)))\n \t\t    /* Using cmpq.  */\n \t\t    cc_status.flags = CC_INVERTED;\n \t\t  else\n@@ -1487,9 +1484,9 @@ cris_notice_update_cc (rtx exp, rtx insn)\n \t\t  return;\n \t\t}\n \t    }\n-\t  else if (GET_CODE (SET_DEST (exp)) == MEM\n+\t  else if (MEM_P (SET_DEST (exp))\n \t\t   || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n-\t\t       && GET_CODE (XEXP (SET_DEST (exp), 0)) == MEM))\n+\t\t       && MEM_P (XEXP (SET_DEST (exp), 0))))\n \t    {\n \t      /* When SET to MEM, then CC is not changed (except for\n \t\t overlap).  */\n@@ -1511,7 +1508,7 @@ cris_notice_update_cc (rtx exp, rtx insn)\n \t      && REG_P (XEXP (XVECEXP (exp, 0, 1), 0)))\n \t    {\n \t      if (REG_P (XEXP (XVECEXP (exp, 0, 0), 0))\n-\t\t  && GET_CODE (XEXP (XVECEXP (exp, 0, 0), 1)) == MEM)\n+\t\t  && MEM_P (XEXP (XVECEXP (exp, 0, 0), 1)))\n \t\t{\n \t\t  /* For \"move.S [rx=ry+o],rz\", say CC reflects\n \t\t     value1=rz and value2=[rx] */\n@@ -1530,7 +1527,7 @@ cris_notice_update_cc (rtx exp, rtx insn)\n \t\t}\n \t      else if ((REG_P (XEXP (XVECEXP (exp, 0, 0), 1))\n \t\t\t|| XEXP (XVECEXP (exp, 0, 0), 1) == const0_rtx)\n-\t\t       && GET_CODE (XEXP (XVECEXP (exp, 0, 0), 0)) == MEM)\n+\t\t       && MEM_P (XEXP (XVECEXP (exp, 0, 0), 0)))\n \t\t{\n \t\t  /* For \"move.S rz,[rx=ry+o]\" and \"clear.S [rx=ry+o]\",\n \t\t     say flags are not changed, except for overlap.  */\n@@ -1662,7 +1659,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case MULT:\n       /* Identify values that are no powers of two.  Powers of 2 are\n          taken care of already and those values should not be changed.  */\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (x, 1))\n           || exact_log2 (INTVAL (XEXP (x, 1)) < 0))\n \t{\n \t  /* If we have a multiply insn, then the cost is between\n@@ -1683,7 +1680,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case MOD:\n     case UMOD:\n     case DIV:\n-      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (x, 1))\n           || exact_log2 (INTVAL (XEXP (x, 1)) < 0))\n \t{\n \t  /* Estimate this as 4 + 8 * #of bits.  */\n@@ -1693,9 +1690,9 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case AND:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n           /* Two constants may actually happen before optimization.  */\n-          && GET_CODE (XEXP (x, 0)) != CONST_INT\n+          && !CONST_INT_P (XEXP (x, 0))\n           && !CONST_OK_FOR_LETTER_P (INTVAL (XEXP (x, 1)), 'I'))\n \t{\n \t  *total = (rtx_cost (XEXP (x, 0), outer_code) + 2\n@@ -1729,7 +1726,7 @@ cris_address_cost (rtx x)\n \n   /* An indirect mem must be a DIP.  This means two bytes extra for code,\n      and 4 bytes extra for memory read, i.e.  (2 + 4) / 2.  */\n-  if (GET_CODE (x) == MEM)\n+  if (MEM_P (x))\n     return (2 + 4) / 2;\n \n   /* Assume (2 + 4) / 2 for a single constant; a dword, since it needs\n@@ -1752,14 +1749,12 @@ cris_address_cost (rtx x)\n \n     /* A BDAP (quick) is 2 extra bytes.  Any constant operand to the\n        PLUS is always found in tem2.  */\n-    if (GET_CODE (tem2) == CONST_INT\n-\t&& INTVAL (tem2) < 128 && INTVAL (tem2) >= -128)\n+    if (CONST_INT_P (tem2) && INTVAL (tem2) < 128 && INTVAL (tem2) >= -128)\n       return 2 / 2;\n \n     /* A BDAP -32768 .. 32767 is like BDAP quick, but with 2 extra\n        bytes.  */\n-    if (GET_CODE (tem2) == CONST_INT\n-\t&& CONST_OK_FOR_LETTER_P (INTVAL (tem2), 'L'))\n+    if (CONST_INT_P (tem2) && CONST_OK_FOR_LETTER_P (INTVAL (tem2), 'L'))\n       return (2 + 2) / 2;\n \n     /* A BDAP with some other constant is 2 bytes extra.  */\n@@ -1858,20 +1853,19 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n       /* Do not allow rx = rx + n if a normal add or sub with same size\n \t would do.  */\n       if (rtx_equal_p (ops[lreg], reg_rtx)\n-\t  && GET_CODE (val_rtx) == CONST_INT\n+\t  && CONST_INT_P (val_rtx)\n \t  && (INTVAL (val_rtx) <= 63 && INTVAL (val_rtx) >= -63))\n \treturn 0;\n \n       /* Check allowed cases, like [r(+)?].[bwd] and const.  */\n       if (CONSTANT_P (val_rtx))\n \treturn 1;\n \n-      if (GET_CODE (val_rtx) == MEM\n-\t  && BASE_OR_AUTOINCR_P (XEXP (val_rtx, 0)))\n+      if (MEM_P (val_rtx) && BASE_OR_AUTOINCR_P (XEXP (val_rtx, 0)))\n \treturn 1;\n \n       if (GET_CODE (val_rtx) == SIGN_EXTEND\n-\t  && GET_CODE (XEXP (val_rtx, 0)) == MEM\n+\t  && MEM_P (XEXP (val_rtx, 0))\n \t  && BASE_OR_AUTOINCR_P (XEXP (XEXP (val_rtx, 0), 0)))\n \treturn 1;\n \n@@ -1958,7 +1952,7 @@ cris_valid_pic_const (rtx x)\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == UNSPEC\n       && XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREL\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     x = XEXP (x, 0);\n \n   if (GET_CODE (x) == UNSPEC)\n@@ -2306,12 +2300,12 @@ cris_split_movdx (rtx *operands)\n   CRIS_ASSERT (GET_CODE (dest) != SUBREG && GET_CODE (src) != SUBREG);\n \n   start_sequence ();\n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       int dregno = REGNO (dest);\n \n       /* Reg-to-reg copy.  */\n-      if (GET_CODE (src) == REG)\n+      if (REG_P (src))\n \t{\n \t  int sregno = REGNO (src);\n \n@@ -2329,7 +2323,7 @@ cris_split_movdx (rtx *operands)\n \t\t\t\t  operand_subword (src, !reverse, TRUE, mode)));\n \t}\n       /* Constant-to-reg copy.  */\n-      else if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE)\n+      else if (CONST_INT_P (src) || GET_CODE (src) == CONST_DOUBLE)\n \t{\n \t  rtx words[2];\n \t  split_double (src, &words[0], &words[1]);\n@@ -2342,7 +2336,7 @@ cris_split_movdx (rtx *operands)\n \t\t\t\t  words[1]));\n \t}\n       /* Mem-to-reg copy.  */\n-      else if (GET_CODE (src) == MEM)\n+      else if (MEM_P (src))\n \t{\n \t  /* If the high-address word is used in the address, we must load it\n \t     last.  Otherwise, load it first.  */\n@@ -2416,8 +2410,8 @@ cris_split_movdx (rtx *operands)\n \tinternal_error (\"Unknown src\");\n     }\n   /* Reg-to-mem copy or clear mem.  */\n-  else if (GET_CODE (dest) == MEM\n-\t   && (GET_CODE (src) == REG\n+  else if (MEM_P (dest)\n+\t   && (REG_P (src)\n \t       || src == const0_rtx\n \t       || src == CONST0_RTX (DFmode)))\n     {\n@@ -2427,7 +2421,7 @@ cris_split_movdx (rtx *operands)\n \t{\n \t  rtx mem;\n \t  rtx insn;\n-\t  \n+\n \t  /* Whenever we emit insns with post-incremented addresses\n \t     ourselves, we must add a post-inc note manually.  */\n \t  mem = change_address (dest, SImode, addr);\n@@ -3183,7 +3177,7 @@ cris_expand_pic_call_address (rtx *opp)\n   /* It might be that code can be generated that jumps to 0 (or to a\n      specific address).  Don't die on that.  (There is a\n      testcase.)  */\n-  if (CONSTANT_ADDRESS_P (op) && GET_CODE (op) != CONST_INT)\n+  if (CONSTANT_ADDRESS_P (op) && CONST_INT_P (op))\n     {\n       enum cris_pic_symbol_type t = cris_pic_symbol_type_of (op);\n "}, {"sha": "93434ec5de979b28fe0b8cefc5ca309f6e3d9848", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "patch": "@@ -577,7 +577,7 @@ enum reg_class\n #define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   (((CLASS) != SPECIAL_REGS && (CLASS) != MOF_REGS)\t\\\n    || GET_MODE_SIZE (MODE) == 4\t\t\t\t\\\n-   || GET_CODE (X) != MEM\t\t\t\t\\\n+   || !MEM_P (X)\t\t\t\t\t\\\n    ? NO_REGS : GENERAL_REGS)\n \n /* For CRIS, this is always the size of MODE in words,\n@@ -643,7 +643,7 @@ enum reg_class\n   /* Just an indirect register (happens to also be\t\\\n      \"all\" slottable memory addressing modes not\t\\\n      covered by other constraints, i.e. '>').  */\t\\\n-  GET_CODE (X) == MEM && BASE_P (XEXP (X, 0))\t\t\\\n+  MEM_P (X) && BASE_P (XEXP (X, 0))\t\t\t\\\n  )\n \n #define EXTRA_CONSTRAINT_R(X)\t\t\t\t\t\\\n@@ -659,8 +659,8 @@ enum reg_class\n #define EXTRA_CONSTRAINT_T(X)\t\t\t\t\t\t\\\n  (\t\t\t\t\t\t\t\t\t\\\n   /* Memory three-address operand.  All are indirect-memory:  */\t\\\n-  GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n-  && ((GET_CODE (XEXP (X, 0)) == MEM\t\t\t\t\t\\\n+  MEM_P (X)\t\t\t\t\t\t\t\t\\\n+  && ((MEM_P (XEXP (X, 0))\t\t\t\t\t\t\\\n        /* Double indirect: [[reg]] or [[reg+]]?  */\t\t\t\\\n        && (BASE_OR_AUTOINCR_P (XEXP (XEXP (X, 0), 0))))\t\t\t\\\n       /* Just an explicit indirect reference: [const]?  */\t\t\\\n@@ -959,10 +959,10 @@ struct cum_args {int regs;};\n \n /* True if X is a valid (register) index for BDAP, i.e. [Rs].S or [Rs+].S.  */\n #define BDAP_INDEX_P(X)\t\t\t\t\t\\\n- ((GET_CODE (X) == MEM && GET_MODE (X) == SImode\t\\\n+ ((MEM_P (X) && GET_MODE (X) == SImode\t\t\t\\\n    && BASE_OR_AUTOINCR_P (XEXP (X, 0)))\t\t\t\\\n   || (GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == MEM\t\t\t\\\n+      && MEM_P (XEXP (X, 0))\t\t\t\t\\\n       && (GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n \t  || GET_MODE (XEXP (X, 0)) == QImode)\t\t\\\n       && BASE_OR_AUTOINCR_P (XEXP (XEXP (X, 0), 0))))\n@@ -973,14 +973,14 @@ struct cum_args {int regs;};\n   || (GET_CODE (X) == MULT\t\t\t\\\n       && BASE_P (XEXP (X, 0))\t\t\t\\\n       && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n+      && CONST_INT_P (XEXP (X, 1))\t\t\\\n       && (INTVAL (XEXP (X, 1)) == 2\t\t\\\n \t  || INTVAL (XEXP (X, 1)) == 4)))\n \n /* True if X is an address that doesn't need a prefix i.e. [Rs] or [Rs+].  */\n-#define SIMPLE_ADDRESS_P(X) \\\n- (BASE_P (X)\t\t\t\t\t\t\\\n-  || (GET_CODE (X) == POST_INC\t\t\t\t\\\n+#define SIMPLE_ADDRESS_P(X)\t\\\n+ (BASE_P (X)\t\t\t\\\n+  || (GET_CODE (X) == POST_INC\t\\\n       && BASE_P (XEXP (X, 0))))\n \n /* A PIC operand looks like a normal symbol here.  At output we dress it\n@@ -1013,7 +1013,7 @@ struct cum_args {int regs;};\n \t\t   || (BASE_P (x2) && BIAP_INDEX_P (x1)))))\t\\\n \t goto ADDR;\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n-   else if (GET_CODE (X) == MEM)\t\t\t\t\\\n+   else if (MEM_P (X))\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n        /* DIP (Rs).  Reject [[reg+]] and [[reg]] for\t\t\\\n \t  DImode (long long).  */\t\t\t\t\\"}, {"sha": "c35e7c2c50e4732bfdccf7800fb1f6858f085587", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991c42ace3e11a0685b2ff65a4d33a0d88ede2cc/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=991c42ace3e11a0685b2ff65a4d33a0d88ede2cc", "patch": "@@ -337,12 +337,12 @@\n \t (match_operand:SI 1 \"const_int_operand\" \"K,n,K,n,K,n,n\")\n \t (match_operand:SI 2 \"nonmemory_operand\" \"M,M,K,n,r,r,r\")))]\n   ;; Either it is a single bit, or consecutive ones starting at 0.\n-  \"GET_CODE (operands[1]) == CONST_INT\n+  \"CONST_INT_P (operands[1])\n    && (operands[1] == const1_rtx || operands[2] == const0_rtx)\n    && (REG_S_P (operands[0])\n        || (operands[1] == const1_rtx\n \t   && REG_S_P (operands[2])\n-\t   && GET_CODE (operands[0]) == CONST_INT\n+\t   && CONST_INT_P (operands[0])\n \t   && exact_log2 (INTVAL (operands[0])) >= 0))\"\n \n ;; The last \"&&\" condition above should be caught by some kind of\n@@ -409,7 +409,7 @@\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) == MEM && operands[1] != const0_rtx)\n+  if (MEM_P (operands[0]) && operands[1] != const0_rtx)\n     operands[1] = copy_to_mode_reg (DImode, operands[1]);\n \n   /* Some other ports (as of 2001-09-10 for example mcore and romp) also\n@@ -420,8 +420,7 @@\n      emitted) is the final value.  This construct from romp seems more\n      robust, especially considering the head comments from\n      emit_no_conflict_block.  */\n-  if ((GET_CODE (operands[1]) == CONST_INT\n-       || GET_CODE (operands[1]) == CONST_DOUBLE)\n+  if ((CONST_INT_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n       && ! reload_completed\n       && ! reload_in_progress)\n     {\n@@ -513,7 +512,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 1, 2, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[2]) != CONST_INT\n+      && (!CONST_INT_P (operands[2])\n \t  || INTVAL (operands[2]) > 127\n \t  || INTVAL (operands[2]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n@@ -540,7 +539,7 @@\n        || which_alternative == 3\n        || which_alternative == 6\n        || which_alternative == 8)\n-      && (GET_CODE (operands[2]) != CONST_INT\n+      && (!CONST_INT_P (operands[2])\n \t  || INTVAL (operands[2]) > 127\n \t  || INTVAL (operands[2]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n@@ -659,7 +658,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n {\n   if ((which_alternative == 0 || which_alternative == 4)\n-      && (GET_CODE (operands[1]) != CONST_INT\n+      && (!CONST_INT_P (operands[1])\n \t  || INTVAL (operands[1]) > 127\n \t  || INTVAL (operands[1]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'N')\n@@ -693,7 +692,7 @@\n    && cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n {\n   if ((which_alternative == 0 || which_alternative == 4)\n-      && (GET_CODE (operands[1]) != CONST_INT\n+      && (!CONST_INT_P (operands[1])\n \t  || INTVAL (operands[1]) > 127\n \t  || INTVAL (operands[1]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'N')\n@@ -766,7 +765,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 2, 0, 1, -1, -1)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[1]) != CONST_INT\n+      && (!CONST_INT_P (operands[1])\n \t  || INTVAL (operands[1]) > 127\n \t  || INTVAL (operands[1]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'N')\n@@ -787,7 +786,7 @@\n {\n   /* If the output goes to a MEM, make sure we have zero or a register as\n      input.  */\n-  if (GET_CODE (operands[0]) == MEM\n+  if (MEM_P (operands[0])\n       && ! REG_S_P (operands[1])\n       && operands[1] != const0_rtx\n       && ! no_new_pseudos)\n@@ -960,7 +959,7 @@\n \tif (GET_CODE (tem) == PLUS\n \t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n \t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n-\t    && GET_CODE (XEXP (tem, 1)) == CONST_INT)\n+\t    && CONST_INT_P (XEXP (tem, 1)))\n \t  tem = XEXP (tem, 0);\n \tgcc_assert (GET_CODE (tem) == UNSPEC);\n \tswitch (XINT (tem, 1))\n@@ -1047,7 +1046,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 1, 2, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[2]) != CONST_INT\n+      && (!CONST_INT_P (operands[2])\n \t  || INTVAL (operands[2]) > 127\n \t  || INTVAL (operands[2]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n@@ -1071,7 +1070,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 1, 2, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[2]) != CONST_INT\n+      && (!CONST_INT_P (operands[2])\n \t  || INTVAL (operands[2]) > 127\n \t  || INTVAL (operands[2]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n@@ -1348,7 +1347,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 4, 2, 3, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[3]) != CONST_INT\n+      && (!CONST_INT_P (operands[3])\n \t  || INTVAL (operands[3]) > 127\n \t  || INTVAL (operands[3]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'N')\n@@ -1406,7 +1405,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 4, 2, 3, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[3]) != CONST_INT\n+      && (!CONST_INT_P (operands[3])\n \t  || INTVAL (operands[3]) > 127\n \t  || INTVAL (operands[3]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'N')\n@@ -1482,7 +1481,7 @@\n \tif (GET_CODE (tem) == PLUS\n \t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n \t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n-\t    && GET_CODE (XEXP (tem, 1)) == CONST_INT)\n+\t    && CONST_INT_P (XEXP (tem, 1)))\n \t  tem = XEXP (tem, 0);\n \tgcc_assert (GET_CODE (tem) == UNSPEC);\n \tswitch (XINT (tem, 1))\n@@ -1679,7 +1678,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 4, 2, 3, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[3]) != CONST_INT\n+      && (!CONST_INT_P (operands[3])\n \t  || INTVAL (operands[3]) > 127\n \t  || INTVAL (operands[3]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'N')\n@@ -1708,7 +1707,7 @@\n    && cris_side_effect_mode_ok (PLUS, operands, 4, 2, 3, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[3]) != CONST_INT\n+      && (!CONST_INT_P (operands[3])\n \t  || INTVAL (operands[3]) > 127\n \t  || INTVAL (operands[3]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'N')\n@@ -1788,7 +1787,7 @@\n   \"cris_side_effect_mode_ok (PLUS, operands, 4, 2, 3, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[3]) != CONST_INT\n+      && (!CONST_INT_P (operands[3])\n \t  || INTVAL (operands[3]) > 127\n \t  || INTVAL (operands[3]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'N')\n@@ -1816,7 +1815,7 @@\n    && cris_side_effect_mode_ok (PLUS, operands, 4, 2, 3, -1, 0)\"\n {\n   if ((which_alternative == 0 || which_alternative == 3)\n-      && (GET_CODE (operands[3]) != CONST_INT\n+      && (!CONST_INT_P (operands[3])\n \t  || INTVAL (operands[3]) > 127\n \t  || INTVAL (operands[3]) < -128\n \t  || CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'N')\n@@ -1963,7 +1962,7 @@\n \t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"operands[0] != frame_pointer_rtx\n    && operands[1] != frame_pointer_rtx\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && (INTVAL (operands[2]) == 2\n        || INTVAL (operands[2]) == 4 || INTVAL (operands[2]) == 3\n        || INTVAL (operands[2]) == 5)\"\n@@ -1993,7 +1992,7 @@\n \t (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"operands[0] != frame_pointer_rtx\n    && operands[1] != frame_pointer_rtx\n-   && GET_CODE (operands[3]) == CONST_INT\n+   && CONST_INT_P (operands[3])\n    && (INTVAL (operands[3]) == 1\n        || INTVAL (operands[3]) == 2 || INTVAL (operands[3]) == 4)\"\n   \"addi %2%T3,%0\"\n@@ -2185,7 +2184,7 @@\n \t\t(match_operand:SI 2 \"general_operand\"\t \"\")))]\n   \"\"\n {\n-  if (! (GET_CODE (operands[2]) == CONST_INT\n+  if (! (CONST_INT_P (operands[2])\n \t && (((INTVAL (operands[2]) == -256\n \t       || INTVAL (operands[2]) == -65536)\n \t      && rtx_equal_p (operands[1], operands[0]))\n@@ -2283,7 +2282,7 @@\n \t\t(match_operand:HI 2 \"general_operand\"  \"\")))]\n   \"\"\n {\n-  if (! (GET_CODE (operands[2]) == CONST_INT\n+  if (! (CONST_INT_P (operands[2])\n \t && (((INTVAL (operands[2]) == -256\n \t       || INTVAL (operands[2]) == 65280)\n \t      && rtx_equal_p (operands[1], operands[0]))\n@@ -2619,8 +2618,7 @@\n   \"\"\n {\n   return\n-    (GET_CODE (operands[2]) == CONST_INT\n-     && INTVAL (operands[2]) > <nbitsm1>)\n+    (CONST_INT_P (operands[2]) && INTVAL (operands[2]) > <nbitsm1>)\n     ? \"moveq 0,%0\"\n     : (CONSTANT_P (operands[2])\n        ? \"lslq %2,%0\" : \"lsl<m> %2,%0\");\n@@ -2677,7 +2675,7 @@\n \t\t  (match_operand:SI 2 \"general_operand\"   \"r,Q>,g,!To\")))]\n   \"\"\n {\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     {\n       /* Constant operands are zero-extended, so only 32-bit operands\n \t may be negative.  */\n@@ -2890,7 +2888,7 @@\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n   if (flag_pic)\n     cris_expand_pic_call_address (&operands[0]);\n })\n@@ -2931,7 +2929,7 @@\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"\"\n {\n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n   if (flag_pic)\n     cris_expand_pic_call_address (&operands[1]);\n })\n@@ -3640,8 +3638,7 @@\n   \"reload_completed\n    && REG_P (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n-   && (GET_CODE (XEXP (operands[1], 0)) == MEM\n-       || CONSTANT_P (XEXP (operands[1], 0)))\n+   && (MEM_P (XEXP (operands[1], 0)) || CONSTANT_P (XEXP (operands[1], 0)))\n    && REGNO (operands[0]) < CRIS_LAST_GENERAL_REGISTER\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 0) (match_dup 3))]\n@@ -3659,7 +3656,7 @@\n   \"reload_completed\n    && REG_P (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n-   && (GET_CODE (XEXP (operands[1], 0)) == MEM\n+   && (MEM_P (XEXP (operands[1], 0))\n        || CONSTANT_P (XEXP (operands[1], 0)))\"\n   [(set (match_dup 2) (match_dup 5))\n    (set (match_dup 0) (match_op_dup 4 [(match_dup 3)]))]"}]}