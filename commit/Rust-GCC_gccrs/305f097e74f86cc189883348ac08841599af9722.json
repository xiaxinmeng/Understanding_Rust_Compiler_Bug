{"sha": "305f097e74f86cc189883348ac08841599af9722", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA1ZjA5N2U3NGY4NmNjMTg5ODgzMzQ4YWMwODg0MTU5OWFmOTcyMg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-03-22T07:44:32Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-03-22T07:44:32Z"}, "message": "(output_fix_trunc): Use MEMs in insn as stack temps.\n\nNo need to allocate & deallocate stack space on the fly.\n(clear_386_stack_locals): New function.\n(assign_386_stack_local): New function.\n\nFrom-SVN: r3829", "tree": {"sha": "60c4c061c0f28c36e4c7b113bddb4a176e3953be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60c4c061c0f28c36e4c7b113bddb4a176e3953be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/305f097e74f86cc189883348ac08841599af9722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305f097e74f86cc189883348ac08841599af9722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305f097e74f86cc189883348ac08841599af9722", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305f097e74f86cc189883348ac08841599af9722/comments", "author": null, "committer": null, "parents": [{"sha": "d398b3b1338cccbc2861959d2eef8515af9cf6c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d398b3b1338cccbc2861959d2eef8515af9cf6c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d398b3b1338cccbc2861959d2eef8515af9cf6c3"}], "stats": {"total": 78, "additions": 51, "deletions": 27}, "files": [{"sha": "960bfd4090f8bb0aaf1c9b32d3327409941b7059", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305f097e74f86cc189883348ac08841599af9722/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305f097e74f86cc189883348ac08841599af9722/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=305f097e74f86cc189883348ac08841599af9722", "patch": "@@ -1639,39 +1639,25 @@ output_fix_trunc (insn, operands)\n      rtx *operands;\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n-  rtx xops[6];\n+  rtx xops[2];\n \n   if (! STACK_TOP_P (operands[1]) ||\n       (GET_MODE (operands[0]) == DImode && ! stack_top_dies))\n     abort ();\n \n-  xops[0] = stack_pointer_rtx;\n-  xops[1] = AT_SP (SImode);\n-  xops[2] = adj_offsettable_operand (xops[1], 2);\n-  xops[3] = GEN_INT (4);\n-  xops[4] = GEN_INT (0xc00);\n-  xops[5] = operands[2];\n-\n-  output_asm_insn (AS2 (sub%L0,%3,%0), xops);\n-  output_asm_insn (AS1 (fnstc%W5,%1), xops);\n-  output_asm_insn (AS2 (mov%W5,%1,%5), xops);\n-  output_asm_insn (AS2 (or%W5,%4,%5), xops);\n-  output_asm_insn (AS2 (mov%W5,%5,%2), xops);\n-  output_asm_insn (AS1 (fldc%W5,%2), xops);\n+  xops[0] = GEN_INT (12);\n+  xops[1] = operands[4];\n+\n+  output_asm_insn (AS1 (fnstc%W2,%2), operands);\n+  output_asm_insn (AS2 (mov%L2,%2,%4), operands);\n+  output_asm_insn (AS2 (mov%B1,%0,%h1), xops);\n+  output_asm_insn (AS2 (mov%L4,%4,%3), operands);\n+  output_asm_insn (AS1 (fldc%W3,%3), operands);\n \n   if (NON_STACK_REG_P (operands[0]))\n     output_to_reg (operands[0], stack_top_dies);\n   else if (GET_CODE (operands[0]) == MEM)\n     {\n-      /* If frame pointer elimination is being done, the MEM reference\n-\t might be an index off of the stack pointer.  In that case,\n-\t since we have already adjusted %esp above, adjust the operand\n-\t address so it points where it should. */\n-\n-      if (! frame_pointer_needed\n-\t  && reg_mentioned_p (stack_pointer_rtx, operands[0]))\n-\toperands[0] = adj_offsettable_operand (operands[0], 4);\n-\n       if (stack_top_dies)\n \toutput_asm_insn (AS1 (fistp%z0,%0), operands);\n       else\n@@ -1680,10 +1666,7 @@ output_fix_trunc (insn, operands)\n   else\n     abort ();\n \n-  output_asm_insn (AS1 (fldc%W5,%1), xops);\n-  output_asm_insn (AS2 (add%L0,%3,%0), xops);\n-\n-  RET;\n+  return AS1 (fldc%W2,%2);\n }\n \f\n /* Output code for INSN to compare OPERANDS.  The two operands might\n@@ -1845,3 +1828,44 @@ output_fp_cc0_set (insn)\n     }\n   RET;\n }\n+\f\n+#define MAX_386_STACK_LOCALS 2\n+\n+static rtx i386_stack_locals[(int) MAX_MACHINE_MODE][MAX_386_STACK_LOCALS];\n+\n+/* Clear stack slot assignments remembered from previous functions.\n+   This is called from INIT_EXPANDERS once before RTL is emitted for each\n+   function. */\n+\n+void\n+clear_386_stack_locals ()\n+{\n+  enum machine_mode mode;\n+  int n;\n+\n+  for (mode = VOIDmode; (int) mode < (int) MAX_MACHINE_MODE;\n+       mode = (enum machine_mode) ((int) mode + 1))\n+    for (n = 0; n < MAX_386_STACK_LOCALS; n++)\n+      i386_stack_locals[(int) mode][n] = NULL_RTX;\n+}\n+\n+/* Return a MEM corresponding to a stack slot with mode MODE.\n+   Allocate a new slot if necessary.\n+\n+   The RTL for a function can have several slots available: N is\n+   which slot to use.  */\n+\n+rtx\n+assign_386_stack_local (mode, n)\n+     enum machine_mode mode;\n+     int n;\n+{\n+  if (n < 0 || n >= MAX_386_STACK_LOCALS)\n+    abort ();\n+\n+  if (i386_stack_locals[(int) mode][n] == NULL_RTX)\n+    i386_stack_locals[(int) mode][n]\n+      = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n+\n+  return i386_stack_locals[(int) mode][n];\n+}"}]}