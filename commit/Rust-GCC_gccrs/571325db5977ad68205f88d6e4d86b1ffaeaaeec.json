{"sha": "571325db5977ad68205f88d6e4d86b1ffaeaaeec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcxMzI1ZGI1OTc3YWQ2ODIwNWY4OGQ2ZTRkODZiMWZmYWVhYWVlYw==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-05-14T15:27:37Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-05-14T15:27:37Z"}, "message": "re PR tree-optimization/14466 (missed PHI optimization (different types))\n\n2004-05-14  Andrew Pinski  <pinskia@physics.uc.edu>\n\n \t        PR optimization/14466\n        * tree-complex.c (make_temp): Remove.\n        (gimplify_val): Replace make_temp with make_rename_temp\n        and add NULL as the second argument.\n        (expand_complex_div_wide): Likewise.\n        * tree-dfa.c (make_rename_temp): New function.\n        * tree-flow.h (make_rename_temp): Declare.\n        * tree-sra.c (make_temp): Remove.\n        (lookup_scalar): Replace make_temp with make_rename_temp.\n        (create_scalar_copies): Likewise.\n        * tree-ssa-phiopt.c (conditional_replacement): When we\n        get non gimple create a temporary variable to hold the\n        casted expression.\n\n2004-05-14  Andrew Pinski  <pinskia@physics.uc.edu>\n\n\t        PR optimization/14466\n        * gcc.dg/tree-ssa/20040514-1.c: New test.\n\nFrom-SVN: r81847", "tree": {"sha": "045c5d0ec64afc180b33c76ab77d652bb726157b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/045c5d0ec64afc180b33c76ab77d652bb726157b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/571325db5977ad68205f88d6e4d86b1ffaeaaeec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571325db5977ad68205f88d6e4d86b1ffaeaaeec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/571325db5977ad68205f88d6e4d86b1ffaeaaeec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571325db5977ad68205f88d6e4d86b1ffaeaaeec/comments", "author": null, "committer": null, "parents": [{"sha": "a2f0e34d9ecd47343f8cdcc78841de15a7e5b2c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f0e34d9ecd47343f8cdcc78841de15a7e5b2c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f0e34d9ecd47343f8cdcc78841de15a7e5b2c0"}], "stats": {"total": 151, "additions": 110, "deletions": 41}, "files": [{"sha": "97cb0440a855eaf3261318dcbc46c4a450d3cb68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -1,3 +1,19 @@\n+2004-05-14  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR optimization/14466\n+\t* tree-complex.c (make_temp): Remove.\n+\t(gimplify_val): Replace make_temp with make_rename_temp\n+\tand add NULL as the second argument.\n+\t(expand_complex_div_wide): Likewise.\n+\t* tree-dfa.c (make_rename_temp): New function.\n+\t* tree-flow.h (make_rename_temp): Declare.\n+\t* tree-sra.c (make_temp): Remove.\n+\t(lookup_scalar): Replace make_temp with make_rename_temp.\n+\t(create_scalar_copies): Likewise.\n+\t* tree-ssa-phiopt.c (conditional_replacement): When we\n+\tget non gimple create a temporary variable to hold the\n+\tcasted expression.\n+\n 2004-05-14  Paul Brook  <paul@codesourcery.com>\n \n \t* stor-layout.c (update_alignment_for_field): Use"}, {"sha": "37ea91eb1bf5199f23193975ede9945d589001bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -1,3 +1,7 @@\n+2004-05-14  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* gcc.dg/tree-ssa/20040514-1.c: New test.\n+\n 2004-05-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortran.fortran-torture/compile/noncontinuation_1.f90: New "}, {"sha": "51f4b0f2fc2f3ce912d10069dad0e44017001b41", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040514-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-1.c?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-phiopt1-details\" } */\n+\n+int t( int i)\n+{\n+  int j;\n+  if(i ==0)\n+  {\n+   j = 1;\n+   goto end;\n+  }\n+  j = 0;\n+end:\n+  return j;\n+\n+/* Should have no ifs left after straightening.  */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"phiopt1\"} } */"}, {"sha": "66fa6129c6da5fbb4c10a72e82546b6748371d54", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -30,17 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n \n \n-/* Build a temporary.  Make sure and register it to be renamed.  */\n-\n-static tree\n-make_temp (tree type)\n-{\n-  tree t = create_tmp_var (type, NULL);\n-  add_referenced_tmp_var (t);\n-  bitmap_set_bit (vars_to_rename, var_ann (t)->uid);\n-  return t;\n-}\n-\n /* Force EXP to be a gimple_val.  */\n \n static tree\n@@ -51,7 +40,7 @@ gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n   if (is_gimple_val (exp))\n     return exp;\n \n-  t = make_temp (type);\n+  t = make_rename_temp (type, NULL);\n   new_stmt = build (MODIFY_EXPR, type, t, exp);\n \n   orig_stmt = bsi_stmt (*bsi);\n@@ -251,8 +240,8 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n       cond = build (COND_EXPR, void_type_node, cond, t1, t2);\n       bsi_insert_before (bsi, cond, BSI_SAME_STMT);\n \n-      min = make_temp (inner_type);\n-      max = make_temp (inner_type);\n+      min = make_rename_temp (inner_type, NULL);\n+      max = make_rename_temp (inner_type, NULL);\n       l3 = create_artificial_label ();\n \n       /* Split the original block, and create the TRUE and FALSE blocks.  */"}, {"sha": "e94640eee00c7dc95e53a71338fa237f396c06a4", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -486,6 +486,18 @@ create_ssa_name_ann (tree t)\n }\n \n \n+/* Build a temporary.  Make sure and register it to be renamed.  */\n+\n+tree\n+make_rename_temp (tree type, const char *prefix)\n+{\n+  tree t = create_tmp_var (type, prefix);\n+  add_referenced_tmp_var (t);\n+  bitmap_set_bit (vars_to_rename, var_ann (t)->uid);\n+  return t;\n+}\n+\n+\n \n /*---------------------------------------------------------------------------\n \t\t\t      Debugging functions"}, {"sha": "66995338a40d15b4b3b45c8cc144798a546ccbae", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -510,6 +510,7 @@ extern tree get_virtual_var (tree);\n extern void add_referenced_tmp_var (tree var);\n extern void mark_new_vars_to_rename (tree, bitmap);\n extern void redirect_immediate_uses (tree, tree);\n+extern tree make_rename_temp (tree, const char *);\n \n /* Flags used when computing reaching definitions and reached uses.  */\n #define TDFA_USE_OPS\t\t1 << 0"}, {"sha": "46a3c59e117c188b657a0d5bcc66288361e4a89a", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -112,17 +112,6 @@ sra_elt_eq (const void *x, const void *y)\n   return true;\n }\n \n-/* Build a temporary.  Make sure and register it to be renamed.  */\n-\n-static tree\n-make_temp (tree type, const char *prefix)\n-{\n-  tree t = create_tmp_var (type, prefix);\n-  add_referenced_tmp_var (t);\n-  bitmap_set_bit (vars_to_rename, var_ann (t)->uid);\n-  return t;\n-}\n-\n /* Mark all the variables in VDEF operands for STMT for renaming.\n    This becomes necessary when we modify all of a non-scalar.  */\n \n@@ -194,7 +183,7 @@ lookup_scalar (struct sra_elt *key, tree type)\n       res = xmalloc (sizeof (*res));\n       *slot = res;\n       *res = *key;\n-      res->replace = make_temp (type, \"SR\");\n+      res->replace = make_rename_temp (type, \"SR\");\n \n       if (DECL_NAME (key->base) && !DECL_IGNORED_P (key->base))\n \t{\n@@ -691,7 +680,7 @@ create_scalar_copies (tree lhs, tree rhs, enum sra_copy_mode mode)\n       tree stmt, tmp;\n \n       /* Add TMP = VA_ARG_EXPR <>  */\n-      tmp = make_temp (TREE_TYPE (rhs), NULL);\n+      tmp = make_rename_temp (TREE_TYPE (rhs), NULL);\n       stmt = csc_assign (&tsi, tmp, rhs);\n \n       /* Mark all the variables in VDEF operands for renaming, because"}, {"sha": "30c33cfb84ba21768237800a68af32d96e5c6e5d", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -72,6 +72,7 @@ extern void change_partition_var (var_map, tree, int);\n extern void compact_var_map (var_map, int);\n extern void remove_ssa_form (FILE *, var_map, int);\n extern void register_ssa_partitions_for_vars (bitmap vars, var_map map);\n+extern tree make_ssa_temp (tree);\n \n static inline int num_var_partitions (var_map);\n static inline tree var_to_partition_to_var (var_map, tree);"}, {"sha": "c302145393eb8fb160626cd031e866cbf5d981f0", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571325db5977ad68205f88d6e4d86b1ffaeaaeec/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=571325db5977ad68205f88d6e4d86b1ffaeaaeec", "patch": "@@ -37,9 +37,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static void tree_ssa_phiopt (void);\n static bool conditional_replacement (basic_block bb, tree phi, tree arg0,\n-                                     tree arg1);\n-\n-\n+                                     tree arg1);                            \n+                                  \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  ie if we have something\n    like:\n@@ -108,11 +107,13 @@ static bool\n conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n {\n   tree result;\n+  tree old_result = NULL;\n   basic_block other_block = NULL;\n   basic_block cond_block = NULL;\n   tree last0, last1, new, cond;\n   block_stmt_iterator bsi;\n   edge true_edge, false_edge;\n+  tree new_var = NULL;\n \n   /* The PHI arguments have the constants 0 and 1, then convert\n     it to the conditional.  */\n@@ -172,14 +173,20 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     return false;\n   \n   /* If the condition is not a naked SSA_NAME and its type does not\n-      match the type of the result, then we can not optimize this case\n-      as it would likely create non-gimple code when the condition\n-      was converted to the result's type.  */\n+      match the type of the result, then we have to create a new\n+      variable to optimize this case as it would likely create\n+      non-gimple code when the condition was converted to the\n+      result's type.  */\n+\n   cond = COND_EXPR_COND (last_stmt (cond_block));\n   result = PHI_RESULT (phi);\n   if (TREE_CODE (cond) != SSA_NAME\n       && !lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n-    return false;\n+    {\n+      new_var = make_rename_temp (TREE_TYPE (cond), NULL);\n+      old_result = cond;\n+      cond = new_var;\n+    }\n   \n   /* If the condition was a naked SSA_NAME and the type is not the\n       same as the type of the result, then convert the type of the\n@@ -190,6 +197,25 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   /* We need to know which is the true edge and which is the false\n       edge so that we know when to invert the condition below.  */\n   extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n+      \n+  /* Insert our new statement at the head of our block.  */\n+  bsi = bsi_start (bb);\n+  \n+  if (old_result)\n+    {\n+      tree new1;\n+      if (TREE_CODE_CLASS (TREE_CODE (old_result)) != '<')\n+        return false;\n+      \n+      new1 = build (TREE_CODE (old_result), TREE_TYPE (result),\n+                    TREE_OPERAND (old_result, 0),\n+                    TREE_OPERAND (old_result, 1));\n+      \n+      new1 = build (MODIFY_EXPR, TREE_TYPE (result),\n+                    new_var, new1);\n+      bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n+    }\n+  \n   \n   /* At this point we know we have a COND_EXPR with two successors.\n       One successor is BB, the other successor is an empty block which\n@@ -208,6 +234,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n       false edge as the value zero.  Note that those conditions are not\n       the same since only one of the outgoing edges from the COND_EXPR\n       will directly reach BB and thus be associated with an argument.  */\n+  \n   if ((PHI_ARG_EDGE (phi, 0) == true_edge && integer_onep (arg0))\n       || (PHI_ARG_EDGE (phi, 0) == false_edge && integer_zerop (arg0))\n       || (PHI_ARG_EDGE (phi, 1) == true_edge && integer_onep (arg1))\n@@ -218,11 +245,25 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     }\n   else\n     {\n-      cond = invert_truthvalue (cond);\n-  \n+      tree cond1 = invert_truthvalue (cond);\n+      \n+      cond = cond1;\n+      /* If what we get back is a conditional expression, there is no\n+\t way that is can be gimple.   */\n+      if (TREE_CODE (cond) == COND_EXPR)\n+\treturn false; \n+\n+      /* If what we get back is not gimple try to create it as gimple by\n+         using a temporary variable.   */\n       if (is_gimple_cast (cond)\n \t  && !is_gimple_val (TREE_OPERAND (cond, 0)))\n-\treturn false;\n+        {\n+          tree temp = TREE_OPERAND (cond, 0);\n+          tree new_var_1 = make_rename_temp (TREE_TYPE (temp), NULL);\n+          new = build (MODIFY_EXPR, TREE_TYPE (new_var_1), new_var_1, temp);\n+          bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+          cond = fold_convert (TREE_TYPE (result), new_var_1);\n+        }\n       \n       if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n           &&  !is_gimple_val (TREE_OPERAND (cond, 0)))\n@@ -232,9 +273,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n                     PHI_RESULT (phi), cond);\n     }\n   \n-  /* Insert our new statement at the head of our block.  */\n-  bsi = bsi_start (bb);\n-  bsi_insert_after (&bsi, new, BSI_SAME_STMT);\n+  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n   \n   /* Register our new statement as the defining statement for\n       the result.  */\n@@ -300,7 +339,8 @@ struct tree_opt_pass pass_phiopt =\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n-    | TODO_verify_ssa\n+    | TODO_verify_ssa | TODO_rename_vars\n+    | TODO_verify_flow\n };\n \t\t\t\t\t\t\t\t\t\t\t\t\n "}]}