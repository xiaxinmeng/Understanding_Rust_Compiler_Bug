{"sha": "24d28a8778f4c7efcebea6c785806082eeacf9fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRkMjhhODc3OGY0YzdlZmNlYmVhNmM3ODU4MDYwODJlZWFjZjlmZQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:03:03Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:03:03Z"}, "message": "[arm] Reduce cost of insns that are simple reg-reg moves.\n\nConsider this sequence during combine:\n\nTrying 18, 7 -> 22:\n   18: r118:SI=r122:SI\n      REG_DEAD r122:SI\n    7: r114:SI=0x1-r118:SI-ltu(cc:CC_RSB,0)\n      REG_DEAD r118:SI\n      REG_DEAD cc:CC_RSB\n   22: r1:SI=r114:SI\n      REG_DEAD r114:SI\nFailed to match this instruction:\n(set (reg:SI 1 r1 [+4 ])\n    (minus:SI (geu:SI (reg:CC_RSB 100 cc)\n            (const_int 0 [0]))\n        (reg:SI 122)))\nSuccessfully matched this instruction:\n(set (reg:SI 114)\n    (geu:SI (reg:CC_RSB 100 cc)\n        (const_int 0 [0])))\nSuccessfully matched this instruction:\n(set (reg:SI 1 r1 [+4 ])\n    (minus:SI (reg:SI 114)\n        (reg:SI 122)))\nallowing combination of insns 18, 7 and 22\noriginal costs 4 + 4 + 4 = 12\nreplacement costs 8 + 4 = 12\n\nThe costs are all correct, but we really don't want this combination\nto take place.  The original costs contain an insn that is a simple\nmove of one pseudo register to another and it is extremely likely that\nregister allocation will eliminate this insn entirely.  On the other\nhand, the resulting sequence really does expand into a sequence that\ncosts 12 (ie 3 insns).\n\nWe don't want to prevent combine from eliminating such moves, as this\ncan expose more combine opportunities, but we shouldn't rate them as\nprofitable in themselves.  We can do this be adjusting the costs\nslightly so that the benefit of eliminating such a simple insn is\nreduced.\n\nWe only do this before register allocation; after allocation we give\nsuch insns their full cost.\n\n\t* config/arm/arm.c (arm_insn_cost): New function.\n\t(TARGET_INSN_COST): Override default definition.\n\nFrom-SVN: r277174", "tree": {"sha": "993b7c76135348a63ba2951270c4556894b1c3b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/993b7c76135348a63ba2951270c4556894b1c3b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24d28a8778f4c7efcebea6c785806082eeacf9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d28a8778f4c7efcebea6c785806082eeacf9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d28a8778f4c7efcebea6c785806082eeacf9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d28a8778f4c7efcebea6c785806082eeacf9fe/comments", "author": null, "committer": null, "parents": [{"sha": "bbead5babc046279d886b059e68e613b0185b2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbead5babc046279d886b059e68e613b0185b2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbead5babc046279d886b059e68e613b0185b2ff"}], "stats": {"total": 26, "additions": 26, "deletions": 0}, "files": [{"sha": "91b80e52f504d704654ddf27db08d0ff74fcbd4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d28a8778f4c7efcebea6c785806082eeacf9fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d28a8778f4c7efcebea6c785806082eeacf9fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24d28a8778f4c7efcebea6c785806082eeacf9fe", "patch": "@@ -1,3 +1,8 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_insn_cost): New function.\n+\t(TARGET_INSN_COST): Override default definition.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.c (arm_rtx_costs_internal, case MINUS): Handle"}, {"sha": "bdea81d29d46e15f1121b32ffc1d2bac52e30755", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d28a8778f4c7efcebea6c785806082eeacf9fe/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d28a8778f4c7efcebea6c785806082eeacf9fe/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=24d28a8778f4c7efcebea6c785806082eeacf9fe", "patch": "@@ -181,6 +181,7 @@ static bool arm_have_conditional_execution (void);\n static bool arm_cannot_force_const_mem (machine_mode, rtx);\n static bool arm_legitimate_constant_p (machine_mode, rtx);\n static bool arm_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n+static int arm_insn_cost (rtx_insn *, bool);\n static int arm_address_cost (rtx, machine_mode, addr_space_t, bool);\n static int arm_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n static int arm_memory_move_cost (machine_mode, reg_class_t, bool);\n@@ -510,6 +511,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_RTX_COSTS arm_rtx_costs\n #undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST arm_address_cost\n+#undef TARGET_INSN_COST\n+#define TARGET_INSN_COST arm_insn_cost\n \n #undef TARGET_SHIFT_TRUNCATION_MASK\n #define TARGET_SHIFT_TRUNCATION_MASK arm_shift_truncation_mask\n@@ -11486,6 +11489,24 @@ arm_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n   return result;\n }\n \n+static int\n+arm_insn_cost (rtx_insn *insn, bool speed)\n+{\n+  int cost;\n+\n+  /* Don't cost a simple reg-reg move at a full insn cost: such moves\n+     will likely disappear during register allocation.  */\n+  if (!reload_completed\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && REG_P (SET_DEST (PATTERN (insn)))\n+      && REG_P (SET_SRC (PATTERN (insn))))\n+    return 2;\n+  cost = pattern_cost (PATTERN (insn), speed);\n+  /* If the cost is zero, then it's likely a complex insn.  We don't want the\n+     cost of these to be less than something we know about.  */\n+  return cost ? cost : COSTS_N_INSNS (2);\n+}\n+\n /* All address computations that can be done are free, but rtx cost returns\n    the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):"}]}