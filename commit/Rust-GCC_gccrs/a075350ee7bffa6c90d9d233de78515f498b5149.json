{"sha": "a075350ee7bffa6c90d9d233de78515f498b5149", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA3NTM1MGVlN2JmZmE2YzkwZDlkMjMzZGU3ODUxNWY0OThiNTE0OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-30T10:35:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-30T14:40:12Z"}, "message": "tree-optimization/101267 - fix SLP vect with masked operations\n\nThis fixes the missed handling of external/constant mask SLP\noperations, for the testcase in particular masked loads.  The\npatch adjusts the vect_check_scalar_mask API to reflect the\nrequired vect_is_simple_use SLP compatible API plus adjusts\nfor the special handling of masked loads in SLP discovery.\n\nThe issue is likely latent.\n\n2021-06-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101267\n\t* tree-vect-stmts.c (vect_check_scalar_mask): Adjust\n\tAPI and use SLP compatible interface of vect_is_simple_use.\n\tReject not vectorized SLP defs for callers that do not support\n\tthat.\n\t(vect_check_store_rhs): Handle masked stores and pass down\n\tthe appropriate operator index.\n\t(vectorizable_call): Adjust.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.  Handle SLP pecularity of\n\tmasked loads.\n\t(vect_is_simple_use): Remove special-casing of masked stores.\n\n\t* gfortran.dg/pr101267.f90: New testcase.", "tree": {"sha": "4bfcc0cb63c94c7cbdd8928be01a281c1de906d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bfcc0cb63c94c7cbdd8928be01a281c1de906d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a075350ee7bffa6c90d9d233de78515f498b5149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a075350ee7bffa6c90d9d233de78515f498b5149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a075350ee7bffa6c90d9d233de78515f498b5149", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a075350ee7bffa6c90d9d233de78515f498b5149/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e61ffa201403e3814a43b176883e176716b1492f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61ffa201403e3814a43b176883e176716b1492f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61ffa201403e3814a43b176883e176716b1492f"}], "stats": {"total": 115, "additions": 77, "deletions": 38}, "files": [{"sha": "12723cf9c221ed116faee02ebfc33c68f68ff275", "filename": "gcc/testsuite/gfortran.dg/pr101267.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a075350ee7bffa6c90d9d233de78515f498b5149/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr101267.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a075350ee7bffa6c90d9d233de78515f498b5149/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr101267.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr101267.f90?ref=a075350ee7bffa6c90d9d233de78515f498b5149", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! { dg-options \"-Ofast\" }\n+! { dg-additional-options \"-march=znver2\" { target x86_64-*-* i?86-*-* } }\n+   SUBROUTINE sfddagd( regime, znt,ite ,jte )\n+   REAL, DIMENSION( ime, IN) :: regime, znt\n+   REAL, DIMENSION( ite, jte) :: wndcor_u \n+   LOGICAL wrf_dm_on_monitor\n+   IF( int4 == 1 ) THEN\n+     DO j=jts,jtf\n+      DO i=itsu,itf\n+       reg =   regime(i,  j) \n+       IF( reg > 10.0 ) THEN\n+         znt0 = znt(i-1,  j) + znt(i,  j) \n+         IF( znt0 <= 0.2) THEN\n+           wndcor_u(i,j) = 0.2\n+         ENDIF\n+       ENDIF\n+      ENDDO\n+     ENDDO\n+     IF ( wrf_dm_on_monitor()) THEN\n+     ENDIF\n+   ENDIF\n+   END"}, {"sha": "e590f34d75d8d582e04841eb09a954cf8dc891f0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a075350ee7bffa6c90d9d233de78515f498b5149/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a075350ee7bffa6c90d9d233de78515f498b5149/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a075350ee7bffa6c90d9d233de78515f498b5149", "patch": "@@ -2439,39 +2439,55 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n   return true;\n }\n \n-/* Return true if boolean argument MASK is suitable for vectorizing\n-   conditional operation STMT_INFO.  When returning true, store the type\n-   of the definition in *MASK_DT_OUT and the type of the vectorized mask\n-   in *MASK_VECTYPE_OUT.  */\n+/* Return true if boolean argument at MASK_INDEX is suitable for vectorizing\n+   conditional operation STMT_INFO.  When returning true, store the mask\n+   in *MASK, the type of its definition in *MASK_DT_OUT, the type of the\n+   vectorized mask in *MASK_VECTYPE_OUT and the SLP node corresponding\n+   to the mask in *MASK_NODE if MASK_NODE is not NULL.  */\n \n static bool\n-vect_check_scalar_mask (vec_info *vinfo, stmt_vec_info stmt_info, tree mask,\n-\t\t\tvect_def_type *mask_dt_out,\n-\t\t\ttree *mask_vectype_out)\n+vect_check_scalar_mask (vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t\tslp_tree slp_node, unsigned mask_index,\n+\t\t\ttree *mask, slp_tree *mask_node,\n+\t\t\tvect_def_type *mask_dt_out, tree *mask_vectype_out)\n {\n-  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (mask)))\n+  enum vect_def_type mask_dt;\n+  tree mask_vectype;\n+  slp_tree mask_node_1;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, mask_index,\n+\t\t\t   mask, &mask_node_1, &mask_dt, &mask_vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"mask use not simple.\\n\");\n+      return false;\n+    }\n+\n+  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (*mask)))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"mask argument is not a boolean.\\n\");\n       return false;\n     }\n \n-  if (TREE_CODE (mask) != SSA_NAME)\n+  if (TREE_CODE (*mask) != SSA_NAME)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"mask argument is not an SSA name.\\n\");\n       return false;\n     }\n \n-  enum vect_def_type mask_dt;\n-  tree mask_vectype;\n-  if (!vect_is_simple_use (mask, vinfo, &mask_dt, &mask_vectype))\n+  /* If the caller is not prepared for adjusting an external/constant\n+     SLP mask vector type fail.  */\n+  if (slp_node\n+      && !mask_node\n+      && SLP_TREE_DEF_TYPE (mask_node_1) != vect_internal_def)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"mask use not simple.\\n\");\n+\t\t\t \"SLP mask argument is not vectorized.\\n\");\n       return false;\n     }\n \n@@ -2501,6 +2517,8 @@ vect_check_scalar_mask (vec_info *vinfo, stmt_vec_info stmt_info, tree mask,\n \n   *mask_dt_out = mask_dt;\n   *mask_vectype_out = mask_vectype;\n+  if (mask_node)\n+    *mask_node = mask_node_1;\n   return true;\n }\n \n@@ -2525,10 +2543,18 @@ vect_check_store_rhs (vec_info *vinfo, stmt_vec_info stmt_info,\n       return false;\n     }\n \n+  unsigned op_no = 0;\n+  if (gcall *call = dyn_cast <gcall *> (stmt_info->stmt))\n+    {\n+      if (gimple_call_internal_p (call)\n+\t  && internal_store_fn_p (gimple_call_internal_fn (call)))\n+\top_no = internal_fn_stored_value_index (gimple_call_internal_fn (call));\n+    }\n+\n   enum vect_def_type rhs_dt;\n   tree rhs_vectype;\n   slp_tree slp_op;\n-  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 0,\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, op_no,\n \t\t\t   &rhs, &slp_op, &rhs_dt, &rhs_vectype))\n     {\n       if (dump_enabled_p ())\n@@ -3163,9 +3189,8 @@ vectorizable_call (vec_info *vinfo,\n     {\n       if ((int) i == mask_opno)\n \t{\n-\t  op = gimple_call_arg (stmt, i);\n-\t  if (!vect_check_scalar_mask (vinfo,\n-\t\t\t\t       stmt_info, op, &dt[i], &vectypes[i]))\n+\t  if (!vect_check_scalar_mask (vinfo, stmt_info, slp_node, mask_opno,\n+\t\t\t\t       &op, &slp_op[i], &dt[i], &vectypes[i]))\n \t    return false;\n \t  continue;\n \t}\n@@ -7213,13 +7238,10 @@ vectorizable_store (vec_info *vinfo,\n \t}\n \n       int mask_index = internal_fn_mask_index (ifn);\n-      if (mask_index >= 0)\n-\t{\n-\t  mask = gimple_call_arg (call, mask_index);\n-\t  if (!vect_check_scalar_mask (vinfo, stmt_info, mask, &mask_dt,\n-\t\t\t\t       &mask_vectype))\n-\t    return false;\n-\t}\n+      if (mask_index >= 0\n+\t  && !vect_check_scalar_mask (vinfo, stmt_info, slp_node, mask_index,\n+\t\t\t\t      &mask, NULL, &mask_dt, &mask_vectype))\n+\treturn false;\n     }\n \n   op = vect_get_store_rhs (stmt_info);\n@@ -8494,13 +8516,13 @@ vectorizable_load (vec_info *vinfo,\n \treturn false;\n \n       int mask_index = internal_fn_mask_index (ifn);\n-      if (mask_index >= 0)\n-\t{\n-\t  mask = gimple_call_arg (call, mask_index);\n-\t  if (!vect_check_scalar_mask (vinfo, stmt_info, mask, &mask_dt,\n-\t\t\t\t       &mask_vectype))\n-\t    return false;\n-\t}\n+      if (mask_index >= 0\n+\t  && !vect_check_scalar_mask (vinfo, stmt_info, slp_node,\n+\t\t\t\t      /* ??? For SLP we only have operands for\n+\t\t\t\t\t the mask operand.  */\n+\t\t\t\t      slp_node ? 0 : mask_index,\n+\t\t\t\t      &mask, NULL, &mask_dt, &mask_vectype))\n+\treturn false;\n     }\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -11484,13 +11506,7 @@ vect_is_simple_use (vec_info *vinfo, stmt_vec_info stmt, slp_tree slp_node,\n \t    *op = gimple_op (ass, operand + 1);\n \t}\n       else if (gcall *call = dyn_cast <gcall *> (stmt->stmt))\n-\t{\n-\t  if (gimple_call_internal_p (call)\n-\t      && internal_store_fn_p (gimple_call_internal_fn (call)))\n-\t    operand = internal_fn_stored_value_index (gimple_call_internal_fn\n-\t\t\t\t\t\t\t\t\t(call));\n-\t  *op = gimple_call_arg (call, operand);\n-\t}\n+\t*op = gimple_call_arg (call, operand);\n       else\n \tgcc_unreachable ();\n       return vect_is_simple_use (*op, vinfo, dt, vectype, def_stmt_info_out);"}]}