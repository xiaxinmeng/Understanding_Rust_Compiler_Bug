{"sha": "bf498b07586693bd0751a7aed15be59cd3f96206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY0OThiMDc1ODY2OTNiZDA3NTFhN2FlZDE1YmU1OWNkM2Y5NjIwNg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-08-28T03:42:47Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-08-28T03:42:47Z"}, "message": "re PR fortran/78387 (OpenMP segfault/stack size exceeded writing to internal file)\n\n2017-08-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/78387\n\t* io/list_read.c (nml_read_obj): Remove use of stash.\n\t* io/transfer.c (st_read_done, st_write_done): Likewise.\n\t* io/unit.c (stash_internal_unit): Delete function.\n\t(get_unit): Remove use of stash.\n\t(init_units): Likewise.\n\t(close_units): Likewise.\n\t* io/write.c (nml_write_obj): Likewise:\n\nFrom-SVN: r251374", "tree": {"sha": "59b1526c6a783bc51b642935f339b817ae44428b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59b1526c6a783bc51b642935f339b817ae44428b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf498b07586693bd0751a7aed15be59cd3f96206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf498b07586693bd0751a7aed15be59cd3f96206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf498b07586693bd0751a7aed15be59cd3f96206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf498b07586693bd0751a7aed15be59cd3f96206/comments", "author": null, "committer": null, "parents": [{"sha": "77e320394453c43c4b452e1fdd5d829b1ee9bbe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e320394453c43c4b452e1fdd5d829b1ee9bbe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77e320394453c43c4b452e1fdd5d829b1ee9bbe9"}], "stats": {"total": 113, "additions": 18, "deletions": 95}, "files": [{"sha": "ba57e616f995b9560a280beb24ff7a718140268c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=bf498b07586693bd0751a7aed15be59cd3f96206", "patch": "@@ -1,3 +1,14 @@\n+2017-08-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/78387\n+\t* io/list_read.c (nml_read_obj): Remove use of stash.\n+\t* io/transfer.c (st_read_done, st_write_done): Likewise.\n+\t* io/unit.c (stash_internal_unit): Delete function.\n+\t(get_unit): Remove use of stash.\n+\t(init_units): Likewise.\n+\t(close_units): Likewise.\n+\t* io/write.c (nml_write_obj): Likewise:\n+\n 2017-07-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/81581"}, {"sha": "3c03a02cad8da0770aa7279e5d8073cf1aabc44f", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=bf498b07586693bd0751a7aed15be59cd3f96206", "patch": "@@ -3019,11 +3019,6 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info *nl, index_type offset,\n \t\t    child_iomsg_len = IOMSG_LEN;\n \t\t  }\n \n-\t\t/* If reading from an internal unit, stash it to allow\n-\t\t   the child procedure to access it.  */\n-\t\tif (is_internal_unit (dtp))\n-\t\t  stash_internal_unit (dtp);\n-\n \t\t/* Call the user defined formatted READ procedure.  */\n \t\tdtp->u.p.current_unit->child_dtio++;\n \t\tdtio_ptr ((void *)&list_obj, &unit, iotype, &vlist,"}, {"sha": "529637061b12e883d77fba938dadef0b6f7315dc", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=bf498b07586693bd0751a7aed15be59cd3f96206", "patch": "@@ -4080,8 +4080,7 @@ st_read_done (st_parameter_dt *dtp)\n   free_ionml (dtp);\n \n   /* If this is a parent READ statement we do not need to retain the\n-     internal unit structure for child use.  Free it and stash the unit\n-     number for reuse.  */\n+     internal unit structure for child use.  */\n   if (dtp->u.p.current_unit != NULL\n       && dtp->u.p.current_unit->child_dtio == 0)\n     {\n@@ -4095,7 +4094,6 @@ st_read_done (st_parameter_dt *dtp)\n \t  if (dtp->u.p.current_unit->ls)\n \t    free (dtp->u.p.current_unit->ls);\n \t  dtp->u.p.current_unit->ls = NULL;\n-\t  stash_internal_unit (dtp);\n \t}\n       if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n \t{\n@@ -4153,8 +4151,7 @@ st_write_done (st_parameter_dt *dtp)\n       free_ionml (dtp);\n \n       /* If this is a parent WRITE statement we do not need to retain the\n-\t internal unit structure for child use.  Free it and stash the\n-\t unit number for reuse.  */\n+\t internal unit structure for child use.  */\n       if (is_internal_unit (dtp) &&\n \t  (dtp->common.flags & IOPARM_DT_HAS_UDTIO) == 0)\n \t{\n@@ -4165,7 +4162,6 @@ st_write_done (st_parameter_dt *dtp)\n \t  if (dtp->u.p.current_unit->ls)\n \t    free (dtp->u.p.current_unit->ls);\n \t  dtp->u.p.current_unit->ls = NULL;\n-\t  stash_internal_unit (dtp);\n \t}\n       if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n \t{"}, {"sha": "e06867aa0a11c57cb351cd1bd578a85ecb1f70e4", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 5, "deletions": 79, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=bf498b07586693bd0751a7aed15be59cd3f96206", "patch": "@@ -94,16 +94,6 @@ static void newunit_free (int);\n /* Unit numbers assigned with NEWUNIT start from here.  */\n #define NEWUNIT_START -10\n \n-\n-#define NEWUNIT_STACK_SIZE 16\n-\n-/* A stack to save previously used newunit-assigned unit numbers to\n-   allow them to be reused without reallocating the gfc_unit structure\n-   which is still in the treap.  */\n-static gfc_saved_unit newunit_stack[NEWUNIT_STACK_SIZE];\n-static int newunit_tos = 0; /* Index to Top of Stack.  */\n-\n-\n #define CACHE_SIZE 3\n static gfc_unit *unit_cache[CACHE_SIZE];\n gfc_offset max_offset;\n@@ -538,22 +528,6 @@ set_internal_unit (st_parameter_dt *dtp, gfc_unit *iunit, int kind)\n }\n \n \n-/* stash_internal_unit()-- Push the internal unit number onto the\n-   avaialble stack.  */\n-void\n-stash_internal_unit (st_parameter_dt *dtp)\n-{\n-  __gthread_mutex_lock (&unit_lock);\n-  newunit_tos++;\n-  if (newunit_tos >= NEWUNIT_STACK_SIZE)\n-    internal_error (&dtp->common, \"stash_internal_unit(): Stack Size Exceeded\");\n-  newunit_stack[newunit_tos].unit_number = dtp->common.unit;\n-  newunit_stack[newunit_tos].unit = dtp->u.p.current_unit;\n-  __gthread_mutex_unlock (&unit_lock);\n-}\n-\n-\n-\n /* get_unit()-- Returns the unit structure associated with the integer\n    unit or the internal file.  */\n \n@@ -572,49 +546,13 @@ get_unit (st_parameter_dt *dtp, int do_create)\n       else\n \tinternal_error (&dtp->common, \"get_unit(): Bad internal unit KIND\");\n \n-      if ((dtp->common.flags & IOPARM_DT_HAS_UDTIO) != 0)\n-\t{\n-\t  dtp->u.p.unit_is_internal = 1;\n-\t  dtp->common.unit = newunit_alloc ();\n-\t  unit = get_gfc_unit (dtp->common.unit, do_create);\n-\t  set_internal_unit (dtp, unit, kind);\n-\t  fbuf_init (unit, 128);\n-\t  return unit;\n-\t}\n-      else\n-\t{\n-\t  __gthread_mutex_lock (&unit_lock);\n-\t  if (newunit_tos)\n-\t    {\n-\t      dtp->common.unit = newunit_stack[newunit_tos].unit_number;\n-\t      unit = newunit_stack[newunit_tos--].unit;\n-\t      __gthread_mutex_unlock (&unit_lock);\n-\t      unit->fbuf->act = unit->fbuf->pos = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      __gthread_mutex_unlock (&unit_lock);\n-\t      dtp->common.unit = newunit_alloc ();\n-\t      unit = xcalloc (1, sizeof (gfc_unit));\n-\t      fbuf_init (unit, 128);\n-\t    }\n-\t  set_internal_unit (dtp, unit, kind);\n-\t  return unit;\n-\t}\n-    }\n-\n-  /* If an internal unit number is passed from the parent to the child\n-     it should have been stashed on the newunit_stack ready to be used.\n-     Check for it now and return the internal unit if found.  */\n-  __gthread_mutex_lock (&unit_lock);\n-  if (newunit_tos && (dtp->common.unit <= NEWUNIT_START)\n-      && (dtp->common.unit == newunit_stack[newunit_tos].unit_number))\n-    {\n-      unit = newunit_stack[newunit_tos--].unit;\n-      __gthread_mutex_unlock (&unit_lock);\n+      dtp->u.p.unit_is_internal = 1;\n+      dtp->common.unit = newunit_alloc ();\n+      unit = get_gfc_unit (dtp->common.unit, do_create);\n+      set_internal_unit (dtp, unit, kind);\n+      fbuf_init (unit, 128);\n       return unit;\n     }\n-  __gthread_mutex_unlock (&unit_lock);\n \n   /* Has to be an external unit.  */\n   dtp->u.p.unit_is_internal = 0;\n@@ -752,10 +690,6 @@ init_units (void)\n   max_offset = 0;\n   for (i = 0; i < sizeof (max_offset) * 8 - 1; i++)\n     max_offset = max_offset + ((gfc_offset) 1 << i);\n-\n-  /* Initialize the newunit stack.  */\n-  memset (newunit_stack, 0, NEWUNIT_STACK_SIZE * sizeof(gfc_saved_unit));\n-  newunit_tos = 0;\n }\n \n \n@@ -837,14 +771,6 @@ close_units (void)\n     close_unit_1 (unit_root, 1);\n   __gthread_mutex_unlock (&unit_lock);\n \n-  while (newunit_tos != 0)\n-    if (newunit_stack[newunit_tos].unit)\n-      {\n-\tfbuf_destroy (newunit_stack[newunit_tos].unit);\n-\tfree (newunit_stack[newunit_tos].unit->s);\n-\tfree (newunit_stack[newunit_tos--].unit);\n-      }\n-\n   free (newunits);\n \n #ifdef HAVE_FREELOCALE"}, {"sha": "c9aad15009006255c91ca4d6858b4912221a6ec4", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf498b07586693bd0751a7aed15be59cd3f96206/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=bf498b07586693bd0751a7aed15be59cd3f96206", "patch": "@@ -2248,11 +2248,6 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info *obj, index_type offset,\n \t\t      child_iomsg_len = IOMSG_LEN;\n \t\t    }\n \n-\t\t  /* If writing to an internal unit, stash it to allow\n-\t\t     the child procedure to access it.  */\n-\t\t  if (is_internal_unit (dtp))\n-\t\t    stash_internal_unit (dtp);\n-\t\t      \n \t\t  /* Call the user defined formatted WRITE procedure.  */\n \t\t  dtp->u.p.current_unit->child_dtio++;\n \t\t  if (obj->type == BT_DERIVED)"}]}