{"sha": "9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5MDM4N2RjZjNmNmQ4MWUzMmNkY2ZkZjJiYTZhMzMyMWJlNjY5NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-03-14T07:24:29Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-03-14T07:24:29Z"}, "message": "rs6000-protos.h: Replace \"struct rtx_def *\" throughout with its typedef, \"rtx\".\n\n\t* config/rs6000/rs6000-protos.h: Replace \"struct rtx_def *\"\n\tthroughout with its typedef, \"rtx\".\n\t* config/rs6000/rs6000.c: Likewise.  Formatting fixes.\n\t(rs6000_tls_symbol_ref_1): Remove inline keyword.\n\t* config/rs6000/rs6000.h (REG_ALLOC_ORDER): Formatting.  Reorder\n\tregs in comment to match code.\n\nFrom-SVN: r96420", "tree": {"sha": "19919caa4efb504c36843359ccdc8dce915208e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19919caa4efb504c36843359ccdc8dce915208e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/comments", "author": null, "committer": null, "parents": [{"sha": "8de1fc1b60d0919e6d5ae255ed137280cb27af0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de1fc1b60d0919e6d5ae255ed137280cb27af0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de1fc1b60d0919e6d5ae255ed137280cb27af0f"}], "stats": {"total": 147, "additions": 77, "deletions": 70}, "files": [{"sha": "837b42d98c4efc3d8fe9cd995b828fc5d67526ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "patch": "@@ -1,3 +1,12 @@\n+2005-03-14  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000-protos.h: Replace \"struct rtx_def *\"\n+\tthroughout with its typedef, \"rtx\".\n+\t* config/rs6000/rs6000.c: Likewise.  Formatting fixes.\n+\t(rs6000_tls_symbol_ref_1): Remove inline keyword.\n+\t* config/rs6000/rs6000.h (REG_ALLOC_ORDER): Formatting.  Reorder\n+\tregs in comment to match code.\n+\n 2005-03-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* except.c (check_handled): Make it static."}, {"sha": "018de14ec2d397ea04e58fb3dfbd7f3dcb17c028", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "patch": "@@ -46,8 +46,8 @@ extern bool legitimate_constant_pool_address_p (rtx);\n extern bool legitimate_indirect_address_p (rtx, int);\n extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n \n-extern struct rtx_def *rs6000_got_register (rtx);\n-extern struct rtx_def *find_addr_reg (rtx);\n+extern rtx rs6000_got_register (rtx);\n+extern rtx find_addr_reg (rtx);\n extern int word_offset_memref_operand (rtx, enum machine_mode);\n extern rtx gen_easy_vector_constant_add_self (rtx);\n extern const char *output_vec_const_move (rtx *);\n@@ -83,9 +83,9 @@ extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n extern void output_toc (FILE *, rtx, int, enum machine_mode);\n extern void rs6000_initialize_trampoline (rtx, rtx, rtx);\n-extern struct rtx_def *rs6000_longcall_ref (rtx);\n+extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n-extern struct rtx_def *create_TOC_reference (rtx);\n+extern rtx create_TOC_reference (rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n@@ -108,11 +108,10 @@ extern unsigned int rs6000_special_round_type_align (tree, int, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int, int);\n extern int function_arg_boundary (enum machine_mode, tree);\n-extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t     enum machine_mode, tree, int);\n+extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern rtx rs6000_function_value (tree, tree);\n extern rtx rs6000_libcall_value (enum machine_mode);\n-extern struct rtx_def *rs6000_va_arg (tree, tree);\n+extern rtx rs6000_va_arg (tree, tree);\n extern int function_ok_for_sibcall (tree);\n extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n #ifdef ARGS_SIZE_RTX"}, {"sha": "602e83aa6afcae4db00871df8effe247d5b278ce", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "patch": "@@ -723,7 +723,7 @@ static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n static void rs6000_parse_float_gprs_option (void);\n static int first_altivec_reg_to_save (void);\n static unsigned int compute_vrsave_mask (void);\n-static void compute_save_world_info(rs6000_stack_t *info_ptr);\n+static void compute_save_world_info (rs6000_stack_t *info_ptr);\n static void is_altivec_return_reg (rtx, void *);\n static rtx generate_set_vrsave (rtx, rs6000_stack_t *, int);\n int easy_vector_constant (rtx, enum machine_mode);\n@@ -732,7 +732,7 @@ static rtx rs6000_dwarf_register_span (rtx);\n static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);\n static rtx rs6000_tls_get_addr (void);\n static rtx rs6000_got_sym (void);\n-static inline int rs6000_tls_symbol_ref_1 (rtx *, void *);\n+static int rs6000_tls_symbol_ref_1 (rtx *, void *);\n static const char *rs6000_get_some_local_dynamic_name (void);\n static int rs6000_get_some_local_dynamic_name_1 (rtx *, void *);\n static rtx rs6000_complex_function_value (enum machine_mode);\n@@ -2265,7 +2265,7 @@ small_data_operand (rtx op ATTRIBUTE_UNUSED,\n \t that must be 32k from _SDA_BASE_, not just the symbol.  */\n       summand = INTVAL (XEXP (sum, 1));\n       if (summand < 0 || (unsigned HOST_WIDE_INT) summand > g_switch_value)\n-       return 0;\n+\treturn 0;\n \n       sym_ref = XEXP (sum, 0);\n     }\n@@ -2312,7 +2312,7 @@ gpr_or_gpr_p (rtx op0, rtx op1)\n static int\n constant_pool_expr_1 (rtx op, int *have_sym, int *have_toc)\n {\n-  switch (GET_CODE(op))\n+  switch (GET_CODE (op))\n     {\n     case SYMBOL_REF:\n       if (RS6000_SYMBOL_REF_TLS_P (op))\n@@ -2488,7 +2488,7 @@ bool\n macho_lo_sum_memory_operand (rtx x, enum machine_mode mode)\n {\n   if (!TARGET_MACHO || !flag_pic\n-      || mode != SImode || GET_CODE(x) != MEM)\n+      || mode != SImode || GET_CODE (x) != MEM)\n     return false;\n   x = XEXP (x, 0);\n \n@@ -2924,7 +2924,7 @@ rs6000_tls_referenced_p (rtx x)\n /* Return 1 if *X is a thread-local symbol.  This is the same as\n    rs6000_tls_symbol_ref except for the type of the unused argument.  */\n \n-static inline int\n+static int\n rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n {\n   return RS6000_SYMBOL_REF_TLS_P (*x);\n@@ -4359,7 +4359,7 @@ spe_build_register_parallel (enum machine_mode mode, int gregno)\n       r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n       return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r3));\n     }\n-  abort();\n+  abort ();\n   return NULL_RTX;\n }\n \n@@ -4677,7 +4677,7 @@ rs6000_mixed_function_arg (enum machine_mode mode, tree type, int align_words)\n    with MODE and TYPE set to that of the pointer to the arg, not the arg\n    itself.  */\n \n-struct rtx_def *\n+rtx\n function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      tree type, int named)\n {\n@@ -5071,14 +5071,14 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n \n   for (i = 0; i < nregs; i++)\n     {\n-      rtx tem = adjust_address_nv (x, reg_mode, i*GET_MODE_SIZE(reg_mode));\n+      rtx tem = adjust_address_nv (x, reg_mode, i * GET_MODE_SIZE (reg_mode));\n       if (reload_completed)\n \t{\n \t  if (! strict_memory_address_p (reg_mode, XEXP (tem, 0)))\n \t    tem = NULL_RTX;\n \t  else\n \t    tem = simplify_gen_subreg (reg_mode, x, BLKmode,\n-\t\t\t\t       i * GET_MODE_SIZE(reg_mode));\n+\t\t\t\t       i * GET_MODE_SIZE (reg_mode));\n \t}\n       else\n \ttem = replace_equiv_address (tem, XEXP (tem, 0));\n@@ -7642,9 +7642,9 @@ altivec_init_builtins (void)\n          targetm.vectorize.builtin_mask_for_load.  */\n \n       decl = lang_hooks.builtin_function (\"__builtin_altivec_mask_for_load\",\n-                               v16qi_ftype_long_pcvoid,\n-                               ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n-                               BUILT_IN_MD, NULL, NULL_TREE);\n+\t\t\t\t\t  v16qi_ftype_long_pcvoid,\n+\t\t\t\t\t  ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n+\t\t\t\t\t  BUILT_IN_MD, NULL, NULL_TREE);\n       /* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */\n       altivec_builtin_mask_for_load = decl;\n     }\n@@ -7872,7 +7872,7 @@ rs6000_common_init_builtins (void)\n \t      type = v16qi_ftype_v16qi_v16qi_v16qi;\n \t      break;\n \t    default:\n-\t      abort();\n+\t      abort ();\n \t    }\n \t}\n       else if (mode0 == mode1 && mode1 == mode2 && mode3 == V16QImode)\n@@ -7892,7 +7892,7 @@ rs6000_common_init_builtins (void)\n \t      type = v16qi_ftype_v16qi_v16qi_v16qi;\n \t      break;\n \t    default:\n-\t      abort();\n+\t      abort ();\n \t    }\n \t}\n       else if (mode0 == V4SImode && mode1 == V16QImode && mode2 == V16QImode\n@@ -8975,7 +8975,7 @@ ccr_bit (rtx op, int scc_p)\n \f\n /* Return the GOT register.  */\n \n-struct rtx_def *\n+rtx\n rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n {\n   /* The second flow pass currently (June 1999) can't update\n@@ -9194,7 +9194,7 @@ print_operand (FILE *file, rtx x, int code)\n     case 'B':\n       /* If the low-order bit is zero, write 'r'; otherwise, write 'l'\n \t for 64-bit mask direction.  */\n-      putc (((INT_LOWPART(x) & 1) == 0 ? 'r' : 'l'), file);\n+      putc (((INT_LOWPART (x) & 1) == 0 ? 'r' : 'l'), file);\n       return;\n \n       /* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise\n@@ -12213,7 +12213,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n \n   if (INTVAL (todec) != -size)\n     {\n-      warning(\"stack frame too large\");\n+      warning (\"stack frame too large\");\n       emit_insn (gen_trap ());\n       return;\n     }\n@@ -12261,7 +12261,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n       if (size > 32767)\n \t{\n \t  /* Need a note here so that try_split doesn't get confused.  */\n-\t  if (get_last_insn() == NULL_RTX)\n+\t  if (get_last_insn () == NULL_RTX)\n \t    emit_note (NOTE_INSN_DELETED);\n \t  insn = emit_move_insn (tmp_reg, todec);\n \t  try_split (PATTERN (insn), insn, 0);\n@@ -14180,7 +14180,7 @@ rs6000_hash_constant (rtx k)\n \telse\n \t  {\n \t    size_t i;\n-\t    for (i = 0; i < sizeof(HOST_WIDE_INT)/sizeof(unsigned); i++)\n+\t    for (i = 0; i < sizeof (HOST_WIDE_INT) / sizeof (unsigned); i++)\n \t      result = result * 613 + (unsigned) (XWINT (k, fidx)\n \t\t\t\t\t\t  >> CHAR_BIT * i);\n \t  }\n@@ -14223,7 +14223,7 @@ toc_hash_eq (const void *h1, const void *h2)\n    to whether or not an object is a vtable.  */\n \n #define VTABLE_NAME_P(NAME)\t\t\t\t\\\n-  (strncmp (\"_vt.\", name, strlen(\"_vt.\")) == 0\t\t\\\n+  (strncmp (\"_vt.\", name, strlen (\"_vt.\")) == 0\t\t\\\n   || strncmp (\"_ZTV\", name, strlen (\"_ZTV\")) == 0\t\\\n   || strncmp (\"_ZTT\", name, strlen (\"_ZTT\")) == 0\t\\\n   || strncmp (\"_ZTI\", name, strlen (\"_ZTI\")) == 0\t\\\n@@ -15285,7 +15285,7 @@ get_next_active_insn (rtx insn, rtx tail)\n \n   while (next_insn\n   \t && next_insn != tail\n-\t && (GET_CODE(next_insn) == NOTE\n+\t && (GET_CODE (next_insn) == NOTE\n \t     || GET_CODE (PATTERN (next_insn)) == USE\n \t     || GET_CODE (PATTERN (next_insn)) == CLOBBER))\n     {\n@@ -15424,7 +15424,7 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns,\n \n       while (can_issue_more > 0)\n \t{\n-\t  nop = gen_nop();\n+\t  nop = gen_nop ();\n \t  emit_insn_before (nop, next_insn);\n \t  can_issue_more--;\n \t}\n@@ -15582,7 +15582,7 @@ redefine_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n \t}\n \n       if (GET_MODE (next_insn) == TImode && can_issue_more)\n-\tPUT_MODE(next_insn, VOIDmode);\n+\tPUT_MODE (next_insn, VOIDmode);\n       else if (!can_issue_more && GET_MODE (next_insn) != TImode)\n \tPUT_MODE (next_insn, TImode);\n \n@@ -15638,7 +15638,7 @@ pad_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n \t      && !insn_terminates_group_p (insn, current_group)\n \t      && !insn_terminates_group_p (next_insn, previous_group))\n \t    {\n-\t      if (!is_branch_slot_insn(next_insn))\n+\t      if (!is_branch_slot_insn (next_insn))\n \t\tcan_issue_more--;\n \n \t      while (can_issue_more)\n@@ -15942,7 +15942,7 @@ rs6000_set_default_type_attributes (tree type)\n /* Return a reference suitable for calling a function with the\n    longcall attribute.  */\n \n-struct rtx_def *\n+rtx\n rs6000_longcall_ref (rtx call_ref)\n {\n   const char *call_name;\n@@ -16097,7 +16097,7 @@ rs6000_elf_in_small_data_p (tree decl)\n    register by this routine since our caller will try to\n    increment the returned register via an \"la\" instruction.  */\n \n-struct rtx_def *\n+rtx\n find_addr_reg (rtx addr)\n {\n   while (GET_CODE (addr) == PLUS)\n@@ -16335,7 +16335,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n       fprintf (file, \"\\t.indirect_symbol %s\\n\", symbol_name);\n \n       label++;\n-      local_label_0 = alloca (sizeof(\"\\\"L0000000000$spb\\\"\"));\n+      local_label_0 = alloca (sizeof (\"\\\"L0000000000$spb\\\"\"));\n       sprintf (local_label_0, \"\\\"L%011d$spb\\\"\", label);\n \n       fprintf (file, \"\\tmflr r0\\n\");\n@@ -16377,7 +16377,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n    position-independent addresses go into a reg.  This is REG if non\n    zero, otherwise we allocate register(s) as necessary.  */\n \n-#define SMALL_INT(X) ((unsigned) (INTVAL(X) + 0x8000) < 0x10000)\n+#define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x8000) < 0x10000)\n \n rtx\n rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n@@ -16470,7 +16470,7 @@ rs6000_darwin_file_start (void)\n   const char *cpu_id = \"\";\n   size_t i;\n \n-  rs6000_file_start();\n+  rs6000_file_start ();\n \n   /* Determine the argument to -mcpu=.  Default to G3 if not specified.  */\n   for (i = 0; i < ARRAY_SIZE (rs6000_select); i++)"}, {"sha": "8e7a2543dc13bc023ab55181e02d4eeb42ae77a3", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9390387dcf3f6d81e32cdcfdf2ba6a3321be6695/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=9390387dcf3f6d81e32cdcfdf2ba6a3321be6695", "patch": "@@ -944,29 +944,28 @@ extern const char *rs6000_warn_altivec_long_switch;\n \tfp0\t\t(not saved or used for anything)\n \tfp13 - fp2\t(not saved; incoming fp arg registers)\n \tfp1\t\t(not saved; return value)\n- \tfp31 - fp14\t(saved; order given to save least number)\n+\tfp31 - fp14\t(saved; order given to save least number)\n \tcr7, cr6\t(not saved or special)\n \tcr1\t\t(not saved, but used for FP operations)\n \tcr0\t\t(not saved, but used for arithmetic operations)\n \tcr4, cr3, cr2\t(saved)\n-        r0\t\t(not saved; cannot be base reg)\n+\tr0\t\t(not saved; cannot be base reg)\n \tr9\t\t(not saved; best for TImode)\n \tr11, r10, r8-r4\t(not saved; highest used first to make less conflict)\n-\tr3     \t\t(not saved; return value register)\n+\tr3\t\t(not saved; return value register)\n \tr31 - r13\t(saved; order given to save least number)\n \tr12\t\t(not saved; if used for DImode or DFmode would use r13)\n \tmq\t\t(not saved; best to use it if we can)\n \tctr\t\t(not saved; when we have the choice ctr is better)\n \tlr\t\t(saved)\n-        cr5, r1, r2, ap, xer, vrsave, vscr (fixed)\n+\tcr5, r1, r2, ap, xer (fixed)\n+\tv0 - v1\t\t(not saved or used for anything)\n+\tv13 - v3\t(not saved; incoming vector arg registers)\n+\tv2\t\t(not saved; incoming vector arg reg; return value)\n+\tv19 - v14\t(not saved or used for anything)\n+\tv31 - v20\t(saved; order given to save least number)\n+\tvrsave, vscr\t(fixed)\n \tspe_acc, spefscr (fixed)\n-\n-\tAltiVec registers:\n-\tv0 - v1         (not saved or used for anything)\n-\tv13 - v3        (not saved; incoming vector arg registers)\n-\tv2              (not saved; incoming vector arg reg; return value)\n-\tv19 - v14       (not saved or used for anything)\n-\tv31 - v20       (saved; order given to save least number)\n */\n \n #if FIXED_R2 == 1\n@@ -977,28 +976,28 @@ extern const char *rs6000_warn_altivec_long_switch;\n #define MAYBE_R2_FIXED\n #endif\n \n-#define REG_ALLOC_ORDER\t\t\t\t\t\\\n-  {32, \t\t\t\t\t\t\t\\\n-   45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34,\t\\\n-   33,\t\t\t\t\t\t\t\\\n-   63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,\t\\\n-   50, 49, 48, 47, 46, \t\t\t\t\t\\\n-   75, 74, 69, 68, 72, 71, 70,\t\t\t\t\\\n-   0, MAYBE_R2_AVAILABLE\t\t\t\t\\\n-   9, 11, 10, 8, 7, 6, 5, 4,\t\t\t\t\\\n-   3,\t\t\t\t\t\t\t\\\n-   31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19,\t\\\n-   18, 17, 16, 15, 14, 13, 12,\t\t\t\t\\\n-   64, 66, 65, \t\t\t\t\t\t\\\n-   73, 1, MAYBE_R2_FIXED 67, 76,\t\t\t\\\n-   /* AltiVec registers.  */\t\t\t\t\\\n-   77, 78,\t\t\t\t\t\t\\\n-   90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80,\t\t\\\n-   79,\t\t\t\t\t\t\t\\\n-   96, 95, 94, 93, 92, 91,\t\t\t\t\\\n-   108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98,\t\\\n-   97, 109, 110\t\t\t\t\t\t\\\n-   , 111, 112                                              \\\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\\\n+  {32,\t\t\t\t\t\t\t\t\\\n+   45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34,\t\t\\\n+   33,\t\t\t\t\t\t\t\t\\\n+   63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,\t\t\\\n+   50, 49, 48, 47, 46,\t\t\t\t\t\t\\\n+   75, 74, 69, 68, 72, 71, 70,\t\t\t\t\t\\\n+   0, MAYBE_R2_AVAILABLE\t\t\t\t\t\\\n+   9, 11, 10, 8, 7, 6, 5, 4,\t\t\t\t\t\\\n+   3,\t\t\t\t\t\t\t\t\\\n+   31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19,\t\t\\\n+   18, 17, 16, 15, 14, 13, 12,\t\t\t\t\t\\\n+   64, 66, 65,\t\t\t\t\t\t\t\\\n+   73, 1, MAYBE_R2_FIXED 67, 76,\t\t\t\t\\\n+   /* AltiVec registers.  */\t\t\t\t\t\\\n+   77, 78,\t\t\t\t\t\t\t\\\n+   90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80,\t\t\t\\\n+   79,\t\t\t\t\t\t\t\t\\\n+   96, 95, 94, 93, 92, 91,\t\t\t\t\t\\\n+   108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97,\t\\\n+   109, 110,\t\t\t\t\t\t\t\\\n+   111, 112\t\t\t\t\t\t\t\\\n }\n \n /* True if register is floating-point.  */"}]}