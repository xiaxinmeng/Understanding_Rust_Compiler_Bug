{"sha": "b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhlYTZkYmNiZDFmYjU3MjI2MDAzZGY3ODViYjBiZTg0YTA2MTRmNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-07-16T15:01:59Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-07-16T15:01:59Z"}, "message": "re PR fortran/28384 (ICE on non-existent COMMON block)\n\n2006-07-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28384\n\t* trans-common.c (translate_common): If common_segment is NULL\n\temit error that common block does not exist.\n\n\tPR fortran/20844\n\t* io.c (check_io_constraints): It is an error if an ADVANCE\n\tspecifier appears without an explicit format.\n\n\tPR fortran/28201\n\t* resolve.c (resolve_generic_s): For a use_associated function,\n\tdo not search for an alternative symbol in the parent name\n\tspace.\n\n\tPR fortran/20893\n\t* resolve.c (resolve_elemental_actual): New function t combine\n\tall the checks of elemental procedure actual arguments. In\n\taddition, check of array valued optional args(this PR) has\n\tbeen added.\n\t(resolve_function, resolve_call): Remove parts that treated\n\telemental procedure actual arguments and call the above.\n\n2006-07-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20844\n\t* gfortran.dg/io_constaints_2.f90: Add the test for ADVANCE\n\tspecifiers requiring an explicit format tag..\n\n\tPR fortran/28201\n\t* gfortran.dg/generic_5: New test.\n\n\tPR fortran/20893\n\t* gfortran.dg/elemental_optional_args_1.f90: New test.\n\nFrom-SVN: r115499", "tree": {"sha": "388dd87c2767bf52d5aa28790427ec7a5bbd6e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/388dd87c2767bf52d5aa28790427ec7a5bbd6e9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/comments", "author": null, "committer": null, "parents": [{"sha": "3e27aa84ef34539400456774ade5f2caaa20b5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e27aa84ef34539400456774ade5f2caaa20b5e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e27aa84ef34539400456774ade5f2caaa20b5e9"}], "stats": {"total": 343, "additions": 280, "deletions": 63}, "files": [{"sha": "96fbeab5ff5623b4ab5965a86ecefd17a64bcf82", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -1,10 +1,33 @@\n+2006-07-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28384\n+\t* trans-common.c (translate_common): If common_segment is NULL\n+\temit error that common block does not exist.\n+\n+\tPR fortran/20844\n+\t* io.c (check_io_constraints): It is an error if an ADVANCE\n+\tspecifier appears without an explicit format.\n+\n+\tPR fortran/28201\n+\t* resolve.c (resolve_generic_s): For a use_associated function,\n+\tdo not search for an alternative symbol in the parent name\n+\tspace.\n+\n+\tPR fortran/20893\n+\t* resolve.c (resolve_elemental_actual): New function t combine\n+\tall the checks of elemental procedure actual arguments. In\n+\taddition, check of array valued optional args(this PR) has\n+\tbeen added.\n+\t(resolve_function, resolve_call): Remove parts that treated\n+\telemental procedure actual arguments and call the above.\n+\n 2006-07-14  Steven G. Kargl  <kargls@comcast.net>\n \n \t* trans-expr.c (gfc_trans_string_copy): Evaluate the string lengths\n \n 006-07-13  Paul Thomas  <pault@gcc.gnu.org>\n \n-\tPR fortran/28174\n+\tPR fortran/28353\n \t* trans-expr.c (gfc_conv_aliased_arg): Missing formal arg means\n \tthat intent is INOUT (fixes regression).\n "}, {"sha": "6cf74ee69f70bd1ed9fd4d3e63c68c3c2a3bedc1", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -2340,6 +2340,12 @@ if (condition) \\\n \t\t     \"List directed format(*) is not allowed with a \"\n \t\t     \"ADVANCE=specifier at %L.\", &expr->where);\n \n+      io_constraint (dt->format_expr == NULL\n+\t\t       && dt->format_label == NULL\n+\t\t       && dt->namelist == NULL,\n+\t\t     \"the ADVANCE=specifier at %L must appear with an \"\n+\t\t     \"explicit format expression\", &expr->where);\n+\n       if (expr->expr_type == EXPR_CONSTANT && expr->ts.type == BT_CHARACTER)\n \t{\n \t  const char * advance = expr->value.character.string;"}, {"sha": "aee04eccd6c5eb1f4fe9e361ece9aa3b3b43ed65", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 147, "deletions": 62, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -910,6 +910,147 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n }\n \n \n+/* Do the checks of the actual argument list that are specific to elemental\n+   procedures.  If called with c == NULL, we have a function, otherwise if\n+   expr == NULL, we have a subroutine.  */\n+static try\n+resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n+{\n+  gfc_actual_arglist *arg0;\n+  gfc_actual_arglist *arg;\n+  gfc_symbol *esym = NULL;\n+  gfc_intrinsic_sym *isym = NULL;\n+  gfc_expr *e = NULL;\n+  gfc_intrinsic_arg *iformal = NULL;\n+  gfc_formal_arglist *eformal = NULL;\n+  bool formal_optional = false;\n+  bool set_by_optional = false;\n+  int i;\n+  int rank = 0;\n+\n+  /* Is this an elemental procedure?  */\n+  if (expr && expr->value.function.actual != NULL)\n+    {\n+      if (expr->value.function.esym != NULL\n+\t    && expr->value.function.esym->attr.elemental)\n+\t{\n+\t  arg0 = expr->value.function.actual;\n+\t  esym = expr->value.function.esym;\n+\t}\n+      else if (expr->value.function.isym != NULL\n+\t\t && expr->value.function.isym->elemental)\n+\t{\n+\t  arg0 = expr->value.function.actual;\n+\t  isym = expr->value.function.isym;\n+\t}\n+      else\n+\treturn SUCCESS;\n+    }\n+  else if (c && c->ext.actual != NULL\n+\t     && c->symtree->n.sym->attr.elemental)\n+    {\n+      arg0 = c->ext.actual;\n+      esym = c->symtree->n.sym;\n+    }\n+  else\n+    return SUCCESS;\n+\n+  /* The rank of an elemental is the rank of its array argument(s).  */\n+  for (arg = arg0; arg; arg = arg->next)\n+    {\n+      if (arg->expr != NULL && arg->expr->rank > 0)\n+\t{\n+\t  rank = arg->expr->rank;\n+\t  if (arg->expr->expr_type == EXPR_VARIABLE\n+\t\t&& arg->expr->symtree->n.sym->attr.optional)\n+\t    set_by_optional = true;\n+\n+\t  /* Function specific; set the result rank and shape.  */\n+\t  if (expr)\n+\t    {\n+\t      expr->rank = rank;\n+\t      if (!expr->shape && arg->expr->shape)\n+\t\t{\n+\t\t  expr->shape = gfc_get_shape (rank);\n+\t\t  for (i = 0; i < rank; i++)\n+\t\t    mpz_init_set (expr->shape[i], arg->expr->shape[i]);\n+\t\t}\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  /* If it is an array, it shall not be supplied as an actual argument\n+     to an elemental procedure unless an array of the same rank is supplied\n+     as an actual argument corresponding to a nonoptional dummy argument of\n+     that elemental procedure(12.4.1.5).  */\n+  formal_optional = false;\n+  if (isym)\n+    iformal = isym->formal;\n+  else\n+    eformal = esym->formal;\n+\n+  for (arg = arg0; arg; arg = arg->next)\n+    {\n+      if (eformal)\n+\t{\n+\t  if (eformal->sym && eformal->sym->attr.optional)\n+\t    formal_optional = true;\n+\t  eformal = eformal->next;\n+\t}\n+      else if (isym && iformal)\n+\t{\n+\t  if (iformal->optional)\n+\t    formal_optional = true;\n+\t  iformal = iformal->next;\n+\t}\n+      else if (isym)\n+\tformal_optional = true;\n+\n+      if (arg->expr != NULL\n+\t    && arg->expr->expr_type == EXPR_VARIABLE\n+\t    && arg->expr->symtree->n.sym->attr.optional\n+\t    && formal_optional\n+\t    && arg->expr->rank\n+\t    && (set_by_optional || arg->expr->rank != rank)) \n+\t{\n+\t  gfc_error (\"'%s' at %L is an array and OPTIONAL; it cannot \"\n+\t\t     \"therefore be an actual argument of an ELEMENTAL \" \n+\t\t     \"procedure unless there is a non-optional argument \"\n+\t\t     \"with the same rank (12.4.1.5)\",\n+\t\t     arg->expr->symtree->n.sym->name, &arg->expr->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  for (arg = arg0; arg; arg = arg->next)\n+    {\n+      if (arg->expr == NULL || arg->expr->rank == 0)\n+\tcontinue;\n+\n+      /* Being elemental, the last upper bound of an assumed size array\n+\t argument must be present.  */\n+      if (resolve_assumed_size_actual (arg->expr))\n+\treturn FAILURE;\n+\n+      if (expr)\n+\tcontinue;\n+\n+      /* Elemental subroutine array actual arguments must conform.  */\n+      if (e != NULL)\n+\t{\n+\t  if (gfc_check_conformance (\"elemental subroutine\", arg->expr, e)\n+\t\t== FAILURE)\n+\t    return FAILURE;\n+\t}\n+      else\n+\te = arg->expr;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Go through each actual argument in ACTUAL and see if it can be\n    implemented as an inlined, non-copying intrinsic.  FNSYM is the\n    function being called, or NULL if not known.  */\n@@ -1237,7 +1378,6 @@ resolve_function (gfc_expr * expr)\n   const char *name;\n   try t;\n   int temp;\n-  int i;\n \n   sym = NULL;\n   if (expr->symtree)\n@@ -1313,38 +1453,9 @@ resolve_function (gfc_expr * expr)\n   temp = need_full_assumed_size;\n   need_full_assumed_size = 0;\n \n-  if (expr->value.function.actual != NULL\n-      && ((expr->value.function.esym != NULL\n-\t   && expr->value.function.esym->attr.elemental)\n-\t  || (expr->value.function.isym != NULL\n-\t      && expr->value.function.isym->elemental)))\n-    {\n-      /* The rank of an elemental is the rank of its array argument(s).  */\n-      for (arg = expr->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if (arg->expr != NULL && arg->expr->rank > 0)\n-\t    {\n-\t      expr->rank = arg->expr->rank;\n-\t      if (!expr->shape && arg->expr->shape)\n-\t\t{\n-\t\t  expr->shape = gfc_get_shape (expr->rank);\n-\t\t  for (i = 0; i < expr->rank; i++)\n-\t\t    mpz_init_set (expr->shape[i], arg->expr->shape[i]);\n-\t        }\n-\t      break;\n-\t    }\n-\t}\n+  if (resolve_elemental_actual (expr, NULL) == FAILURE)\n+    return FAILURE;\n \n-      /* Being elemental, the last upper bound of an assumed size array\n-\t argument must be present.  */\n-      for (arg = expr->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if (arg->expr != NULL\n-\t\t&& arg->expr->rank > 0\n-\t\t&& resolve_assumed_size_actual (arg->expr))\n-\t    return FAILURE;\n-\t}\n-    }\n   if (omp_workshare_flag\n       && expr->value.function.esym\n       && ! gfc_elemental (expr->value.function.esym))\n@@ -1500,7 +1611,7 @@ resolve_generic_s (gfc_code * c)\n   if (m == MATCH_ERROR)\n     return FAILURE;\n \n-  if (sym->ns->parent != NULL)\n+  if (sym->ns->parent != NULL && !sym->attr.use_assoc)\n     {\n       gfc_find_symbol (sym->name, sym->ns->parent, 1, &sym);\n       if (sym != NULL)\n@@ -1730,35 +1841,9 @@ resolve_call (gfc_code * c)\n \tgfc_internal_error (\"resolve_subroutine(): bad function type\");\n       }\n \n-  /* Some checks of elemental subroutines.  */\n-  if (c->ext.actual != NULL\n-      && c->symtree->n.sym->attr.elemental)\n-    {\n-      gfc_actual_arglist * a;\n-      gfc_expr * e;\n-      e = NULL;\n-\n-      for (a = c->ext.actual; a; a = a->next)\n-\t{\n-\t  if (a->expr == NULL || a->expr->rank == 0)\n-\t    continue;\n-\n-\t /* The last upper bound of an assumed size array argument must\n-\t    be present.  */\n-\t  if (resolve_assumed_size_actual (a->expr))\n-\t    return FAILURE;\n-\n-\t  /* Array actual arguments must conform.  */\n-\t  if (e != NULL)\n-\t    {\n-\t      if (gfc_check_conformance (\"elemental subroutine\", a->expr, e)\n-\t\t\t== FAILURE)\n-\t\treturn FAILURE;\n-\t    }\n-\t  else\n-\t    e = a->expr;\n-\t}\n-    }\n+  /* Some checks of elemental subroutine actual arguments.  */\n+  if (resolve_elemental_actual (NULL, c) == FAILURE)\n+    return FAILURE;\n \n   if (t == SUCCESS)\n     find_noncopying_intrinsics (c->resolved_sym, c->ext.actual);"}, {"sha": "5350eacdef05c14f6fb7e304ea747938b9cd655c", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -962,6 +962,13 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n       current_offset += s->length;\n     }\n \n+  if (common_segment == NULL)\n+    {\n+      gfc_error (\"COMMON '%s' at %L does not exist\",\n+\t\t common->name, &common->where);\n+      return;\n+    }\n+\n   if (common_segment->offset != 0)\n     {\n       gfc_warning (\"COMMON '%s' at %L requires %d bytes of padding at start\","}, {"sha": "68b45a291ecae77666f469e434578b502d7604df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -1,3 +1,15 @@\n+2006-07-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20844\n+\t* gfortran.dg/io_constaints_2.f90: Add the test for ADVANCE\n+\tspecifiers requiring an explicit format tag..\n+\n+\tPR fortran/28201\n+\t* gfortran.dg/generic_5: New test.\n+\n+\tPR fortran/20893\n+\t* gfortran.dg/elemental_optional_args_1.f90: New test.\n+\n 2006-07-16  Olivier Hainque  <hainque@adacore.com>\n \n \t* gnat.dg/assert.ads: New file."}, {"sha": "258b6b0f76a0b4d4212fe518f8b940e94e02ab59", "filename": "gcc/testsuite/gfortran.dg/elemental_optional_args_1.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_1.f90?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile }\n+! Check the fix for PR20893, in which actual arguments could violate: \n+! \"(5) If it is an array, it shall not be supplied as an actual argument to\n+! an elemental procedure unless an array of the same rank is supplied as an\n+! actual argument corresponding to a nonoptional dummy argument of that \n+! elemental procedure.\" (12.4.1.5)\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+  CALL T1(1,2)\n+CONTAINS\n+  SUBROUTINE T1(A1,A2,A3)\n+    INTEGER           :: A1,A2, A4(2)\n+    INTEGER, OPTIONAL :: A3(2)\n+    interface\n+      elemental function efoo (B1,B2,B3) result(bar)\n+        INTEGER, intent(in)           :: B1, B2\n+        integer           :: bar\n+        INTEGER, OPTIONAL, intent(in) :: B3\n+      end function efoo\n+    end interface\n+\n+! check an intrinsic function\n+    write(6,*) MAX(A1,A2,A3) ! { dg-error \"array and OPTIONAL\" }\n+    write(6,*) MAX(A1,A3,A2)\n+    write(6,*) MAX(A1,A4,A3)\n+! check an internal elemental function\n+    write(6,*) foo(A1,A2,A3) ! { dg-error \"array and OPTIONAL\" }\n+    write(6,*) foo(A1,A3,A2)\n+    write(6,*) foo(A1,A4,A3)\n+! check an external elemental function\n+    write(6,*) efoo(A1,A2,A3) ! { dg-error \"array and OPTIONAL\" }\n+    write(6,*) efoo(A1,A3,A2)\n+    write(6,*) efoo(A1,A4,A3)\n+! check an elemental subroutine\n+    call foobar (A1,A2,A3) ! { dg-error \"array and OPTIONAL\" } \n+    call foobar (A1,A2,A4)\n+    call foobar (A1,A4,A4)\n+  END SUBROUTINE\n+  elemental function foo (B1,B2,B3) result(bar)\n+    INTEGER, intent(in)           :: B1, B2\n+    integer           :: bar\n+    INTEGER, OPTIONAL, intent(in) :: B3\n+    bar = 1\n+  end function foo\n+  elemental subroutine foobar (B1,B2,B3)\n+    INTEGER, intent(OUT)           :: B1\n+    INTEGER, optional, intent(in)  :: B2, B3\n+    B1 = 1\n+  end subroutine foobar\n+\n+END\n\\ No newline at end of file"}, {"sha": "037dba27c651858eecdfefbc2db430ef0c3c8b1f", "filename": "gcc/testsuite/gfortran.dg/generic_5.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_5.f90?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! Tests the patch for PR28201, in which the call to ice would cause an ICE\n+! because resolve.c(resolve_generic_s) would try to look in the parent\n+! namespace to see if the subroutine was part of a legal generic interface.\n+! In this case, there is nothing to test, hence the ICE.\n+!\n+! Contributed by Daniel Franke  <franke.daniel@gmail.com>\n+!\n+!\n+MODULE ice_gfortran\n+  INTERFACE ice\n+    MODULE PROCEDURE ice_i\n+  END INTERFACE\n+\n+CONTAINS\n+  SUBROUTINE ice_i(i)\n+    INTEGER, INTENT(IN) :: i\n+    ! do nothing\n+  END SUBROUTINE\n+END MODULE\n+\n+MODULE provoke_ice\n+CONTAINS\n+  SUBROUTINE provoke\n+    USE ice_gfortran\n+    CALL ice(23.0)   ! { dg-error \"is not an intrinsic subroutine\" }\n+  END SUBROUTINE\n+END MODULE\n+"}, {"sha": "c2a49e29d16d8b051ad12acad4a10ad94004626a", "filename": "gcc/testsuite/gfortran.dg/io_constraints_2.f90", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ea6dbcbd1fb57226003df785bb0be84a0614f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_2.f90?ref=b8ea6dbcbd1fb57226003df785bb0be84a0614f7", "patch": "@@ -1,6 +1,7 @@\n ! { dg-do compile }\n ! Part II of the test  of the IO constraints patch, which fixes PRs:\n ! PRs 25053, 25063, 25064, 25066, 25067, 25068, 25069, 25307 and 20862.\n+! Modified2006-07-08 to check the patch for PR20844.\n !\n ! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n !\n@@ -52,6 +53,8 @@ end module global\n  READ(buffer, fmt='(i6)', advance='YES') a      ! { dg-error \"internal file\" }\n  READ(1, NML=NL, advance='YES')                 ! { dg-error \"NAMELIST IO is not allowed\" }\n \n+ READ(1, advance='YES')                         ! { dg-error \"must appear with an explicit format\" }\n+\n  write(1, fmt='(i6)', advance='YES', size = c(1)) a ! { dg-error \"output\" }\n  write(1, fmt='(i6)', advance='YES', eor = 100) a   ! { dg-error \"output\" }\n "}]}