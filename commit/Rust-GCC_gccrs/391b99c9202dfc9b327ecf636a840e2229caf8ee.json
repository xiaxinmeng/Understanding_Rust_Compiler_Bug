{"sha": "391b99c9202dfc9b327ecf636a840e2229caf8ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxYjk5YzkyMDJkZmM5YjMyN2VjZjYzNmE4NDBlMjIyOWNhZjhlZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T02:54:46Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-22T02:54:46Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r561", "tree": {"sha": "6eb8d50d6e71783594855a7fe10a388984e7f809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6eb8d50d6e71783594855a7fe10a388984e7f809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/391b99c9202dfc9b327ecf636a840e2229caf8ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391b99c9202dfc9b327ecf636a840e2229caf8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391b99c9202dfc9b327ecf636a840e2229caf8ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391b99c9202dfc9b327ecf636a840e2229caf8ee/comments", "author": null, "committer": null, "parents": [{"sha": "c87cec5a520f1cca3151df30f077949c9965dd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87cec5a520f1cca3151df30f077949c9965dd46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87cec5a520f1cca3151df30f077949c9965dd46"}], "stats": {"total": 165, "additions": 76, "deletions": 89}, "files": [{"sha": "0979e8007b6d4a67da12d3a55938a42619077dd0", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 76, "deletions": 89, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391b99c9202dfc9b327ecf636a840e2229caf8ee/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391b99c9202dfc9b327ecf636a840e2229caf8ee/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=391b99c9202dfc9b327ecf636a840e2229caf8ee", "patch": "@@ -1059,16 +1059,13 @@ output_move_double (operands)\n \top1 = operands[1], op2 = operands[0];\n \n       /* Now see if we can trust the address to be 8-byte aligned.  */\n-      /* Trust global variables.  */\n+      /* Trust double-precision floats in global variables.  */\n \n-      if (GET_CODE (op2) == LO_SUM)\n+      if (GET_CODE (XEXP (op2, 0)) == LO_SUM && GET_MODE (op2) == DFmode)\n \t{\n-\t  operands[0] = op1;\n-\t  operands[1] = op2;\n-\n \t  if (final_sequence)\n \t    abort ();\n-\t  return \"ldd %1,%0\";\n+\t  return (op1 == operands[0] ? \"ldd %1,%0\" : \"std %1,%0\");\n \t}\n \n       if (GET_CODE (XEXP (op2, 0)) == PLUS)\n@@ -1102,12 +1099,12 @@ output_move_double (operands)\n \t       && GET_MODE (operands[1]) == DFmode\n \t       && (CONSTANT_P (XEXP (operands[1], 0))\n \t\t   /* Let user ask for it anyway.  */\n-\t\t   || TARGET_ALIGN))\n+\t\t   || TARGET_HOPE_ALIGN))\n \treturn \"ldd %1,%0\";\n       else if (GET_CODE (operands[0]) == MEM\n \t       && GET_MODE (operands[0]) == DFmode\n \t       && (CONSTANT_P (XEXP (operands[0], 0))\n-\t\t   || TARGET_ALIGN))\n+\t\t   || TARGET_HOPE_ALIGN))\n \treturn \"std %1,%0\";\n     }\n \n@@ -1183,7 +1180,7 @@ output_fp_move_double (operands)\n       addr = XEXP (operands[1], 0);\n \n       /* Use ldd if known to be aligned.  */\n-      if (TARGET_ALIGN\n+      if (TARGET_HOPE_ALIGN\n \t  || (GET_CODE (addr) == PLUS\n \t      && (((XEXP (addr, 0) == frame_pointer_rtx\n \t\t    || XEXP (addr, 0) == stack_pointer_rtx)\n@@ -1215,7 +1212,7 @@ output_fp_move_double (operands)\n       addr = XEXP (operands[0], 0);\n \n       /* Use std if we can be sure it is well-aligned.  */\n-      if (TARGET_ALIGN\n+      if (TARGET_HOPE_ALIGN\n \t  || (GET_CODE (addr) == PLUS\n \t      && (((XEXP (addr, 0) == frame_pointer_rtx\n \t\t    || XEXP (addr, 0) == stack_pointer_rtx)\n@@ -1433,111 +1430,101 @@ output_block_move (operands)\n   xoperands[1] = operands[1];\n   xoperands[2] = temp1;\n \n-  /* We can't move more than this many bytes at a time\n-     because we have only one register to move them through.  */\n-  if (align > GET_MODE_SIZE (GET_MODE (temp1)))\n+  /* We can't move more than this many bytes at a time because we have only\n+     one register, %g1, to move them through.  */\n+  if (align > UNITS_PER_WORD)\n     {\n-      align = GET_MODE_SIZE (GET_MODE (temp1));\n-      alignrtx = gen_rtx (CONST_INT, VOIDmode, GET_MODE_SIZE (GET_MODE (temp1)));\n+      align = UNITS_PER_WORD;\n+      alignrtx = gen_rtx (CONST_INT, VOIDmode, UNITS_PER_WORD);\n     }\n \n-  /* If the size isn't known to be a multiple of the alignment,\n-     we have to do it in smaller pieces.  If we could determine that\n-     the size was a multiple of 2 (or whatever), we could be smarter\n-     about this.  */\n-  if (GET_CODE (sizertx) != CONST_INT)\n-    align = 1;\n-  else\n+  /* We consider 8 ld/st pairs, for a total of 16 inline insns to be\n+     reasonable here.  (Actually will emit a maximum of 18 inline insns for\n+     the case of size == 31 and align == 4).  */\n+\n+  if (GET_CODE (sizertx) == CONST_INT && (INTVAL (sizertx) / align) <= 8\n+      && memory_address_p (QImode, plus_constant_for_output (xoperands[0],\n+\t\t\t\t\t\t\t     INTVAL (sizertx)))\n+      && memory_address_p (QImode, plus_constant_for_output (xoperands[1],\n+\t\t\t\t\t\t\t     INTVAL (sizertx))))\n     {\n       int size = INTVAL (sizertx);\n-      while (size % align)\n-\talign >>= 1;\n-    }\n+      int offset = 0;\n \n-  if (align != INTVAL (alignrtx))\n-    alignrtx = gen_rtx (CONST_INT, VOIDmode, align);\n-\n-  /* Recognize special cases of block moves.  These occur\n-     when GNU C++ is forced to treat something as BLKmode\n-     to keep it in memory, when its mode could be represented\n-     with something smaller.\n+      /* We will store different integers into this particular RTX.  */\n+      xoperands[2] = rtx_alloc (CONST_INT);\n+      PUT_MODE (xoperands[2], VOIDmode);\n \n-     We cannot do this for global variables, since we don't know\n-     what pages they don't cross.  Sigh.  */\n-  if (GET_CODE (sizertx) == CONST_INT && INTVAL (sizertx) <= 16)\n-    {\n-      int size = INTVAL (sizertx);\n+      /* This case is currently not handled.  Abort instead of generating\n+\t bad code.  */\n+      if (align > 4)\n+\tabort ();\n \n-      if (align == 1)\n+      if (align >= 4)\n \t{\n-\t  if (memory_address_p (QImode,\n-\t\t\t\tplus_constant_for_output (xoperands[0], size))\n-\t      && memory_address_p (QImode,\n-\t\t\t\t   plus_constant_for_output (xoperands[1],\n-\t\t\t\t\t\t\t     size)))\n+\t  for (i = (size >> 2) - 1; i >= 0; i--)\n \t    {\n-\t      /* We will store different integers into this particular RTX.  */\n-\t      xoperands[2] = rtx_alloc (CONST_INT);\n-\t      PUT_MODE (xoperands[2], VOIDmode);\n-\t      for (i = size-1; i >= 0; i--)\n-\t\t{\n-\t\t  INTVAL (xoperands[2]) = i;\n-\t\t  output_asm_insn (\"ldub [%a1+%2],%%g1\\n\\tstb %%g1,[%a0+%2]\",\n-\t\t\t\t   xoperands);\n-\t\t}\n-\t      return \"\";\n+\t      INTVAL (xoperands[2]) = (i << 2) + offset;\n+\t      output_asm_insn (\"ld [%a1+%2],%%g1\\n\\tst %%g1,[%a0+%2]\",\n+\t\t\t       xoperands);\n \t    }\n+\t  offset += (size & ~0x3);\n+\t  size = size & 0x3;\n+\t  if (size == 0)\n+\t    return \"\";\n \t}\n-      else if (align == 2)\n+\n+      if (align >= 2)\n \t{\n-\t  if (memory_address_p (HImode,\n-\t\t\t\tplus_constant_for_output (xoperands[0], size))\n-\t      && memory_address_p (HImode,\n-\t\t\t\t   plus_constant_for_output (xoperands[1],\n-\t\t\t\t\t\t\t     size)))\n+\t  for (i = (size >> 1) - 1; i >= 0; i--)\n \t    {\n-\t      /* We will store different integers into this particular RTX.  */\n-\t      xoperands[2] = rtx_alloc (CONST_INT);\n-\t      PUT_MODE (xoperands[2], VOIDmode);\n-\t      for (i = (size>>1)-1; i >= 0; i--)\n-\t\t{\n-\t\t  INTVAL (xoperands[2]) = i<<1;\n-\t\t  output_asm_insn (\"lduh [%a1+%2],%%g1\\n\\tsth %%g1,[%a0+%2]\",\n-\t\t\t\t   xoperands);\n-\t\t}\n-\t      return \"\";\n+\t      INTVAL (xoperands[2]) = (i << 1) + offset;\n+\t      output_asm_insn (\"lduh [%a1+%2],%%g1\\n\\tsth %%g1,[%a0+%2]\",\n+\t\t\t       xoperands);\n \t    }\n+\t  offset += (size & ~0x1);\n+\t  size = size & 0x1;\n+\t  if (size == 0)\n+\t    return \"\";\n \t}\n-      else\n+\n+      if (align >= 1)\n \t{\n-\t  if (memory_address_p (SImode,\n-\t\t\t\tplus_constant_for_output (xoperands[0], size))\n-\t      && memory_address_p (SImode,\n-\t\t\t\t   plus_constant_for_output (xoperands[1],\n-\t\t\t\t\t\t\t     size)))\n+\t  for (i = size - 1; i >= 0; i--)\n \t    {\n-\t      /* We will store different integers into this particular RTX.  */\n-\t      xoperands[2] = rtx_alloc (CONST_INT);\n-\t      PUT_MODE (xoperands[2], VOIDmode);\n-\t      for (i = (size>>2)-1; i >= 0; i--)\n-\t\t{\n-\t\t  INTVAL (xoperands[2]) = i<<2;\n-\t\t  output_asm_insn (\"ld [%a1+%2],%%g1\\n\\tst %%g1,[%a0+%2]\",\n-\t\t\t\t   xoperands);\n-\t\t}\n-\t      return \"\";\n+\t      INTVAL (xoperands[2]) = i + offset;\n+\t      output_asm_insn (\"ldub [%a1+%2],%%g1\\n\\tstb %%g1,[%a0+%2]\",\n+\t\t\t       xoperands);\n \t    }\n+\t  return \"\";\n \t}\n+\n+      /* We should never reach here.  */\n+      abort ();\n+    }\n+\n+  /* If the size isn't known to be a multiple of the alignment,\n+     we have to do it in smaller pieces.  If we could determine that\n+     the size was a multiple of 2 (or whatever), we could be smarter\n+     about this.  */\n+  if (GET_CODE (sizertx) != CONST_INT)\n+    align = 1;\n+  else\n+    {\n+      int size = INTVAL (sizertx);\n+      while (size % align)\n+\talign >>= 1;\n     }\n \n+  if (align != INTVAL (alignrtx))\n+    alignrtx = gen_rtx (CONST_INT, VOIDmode, align);\n+\n   xoperands[3] = gen_rtx (CONST_INT, VOIDmode, movstrsi_label++);\n   xoperands[4] = gen_rtx (CONST_INT, VOIDmode, align);\n   xoperands[5] = gen_rtx (CONST_INT, VOIDmode, movstrsi_label++);\n \n-  /* This is the size of the transfer.\n-     Either use the register which already contains the size,\n-     or use a free register (used by no operands).\n-     Also emit code to decrement the size value by ALIGN.  */\n+  /* This is the size of the transfer.  Emit code to decrement the size\n+     value by ALIGN, and store the result in the temp1 register.  */\n   output_size_for_block_move (sizertx, temp1, alignrtx);\n \n   /* Must handle the case when the size is zero or negative, so the first thing"}]}