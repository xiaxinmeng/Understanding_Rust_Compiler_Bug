{"sha": "4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIyMjhlNjFhOThkOGJkZDEyODZlNTM2YTFmNzRjZGJjZTUwZDBmZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-16T09:55:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-16T09:55:54Z"}, "message": "tree-cfg.c (verify_types_in_gimple_reference): Verify TARGET_MEM_REF a bit.\n\n2010-08-16  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-cfg.c (verify_types_in_gimple_reference): Verify\n\tTARGET_MEM_REF a bit.\n\t* tree-ssa-address.c (addr_for_mem_ref): Adjust.\n\t(create_mem_ref_raw): Always create TMR_OFFSET, store the\n\talias pointer type via it.\n\t(copy_mem_ref_info): Adjust.\n\t(maybe_fold_tmr): Likewise.\n\t* tree.c (mem_ref_offset): Also handle TARGET_MEM_REF.\n\t(reference_alias_ptr_type): Likewise.\n\t* tree.def (TARGET_MEM_REF): Remove TMR_ORIGINAL operand,\n\tadjust documentation of TMR_OFFSET operand.\n\t* alias.c (get_alias_set): Do not look at TMR_ORIGINAL but\n\tuse the alias pointer type.\n\t* expr.c (expand_expr_real_1): Do not use TMR_ORIGINAL to\n\tinitialize mem attrs but the TMR itself.\n\t* tree-eh.c (tree_could_trap_p): Handle TARGET_MEM_REF\n\tsimilar to MEM_REF.\n\t* tree-pretty-print.c (dump_generic_node): Do not dump TMR_ORIGINAL.\n\t* tree-ssa-loop-ivopts.c (idx_remove_ssa_names): Remove.\n\t(unshare_and_remove_ssa_names): Likewise.\n\t(copy_ref_info): Adjust.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Simplify\n\tTARGET_MEM_REF case.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Do not look\n\tat TMR_ORIGINAL.\n\t* tree.h (TMR_ORIGINAL): Remove.\n\t* gimple.c (get_base_address): For TARGET_MEM_REF with a\n\tsymbol return that.\n\t* tree-dfa.c (get_ref_base_and_extent): Handle TARGET_MEM_REF\n\twith a symbol.\n\t(get_addr_base_and_unit_offset): Likewise.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Handle\n\tTARGET_MEM_REFs.\n\t(indirect_ref_may_alias_decl_p): Likewise.\n\t(refs_may_alias_p_1): Do not bail out for TARGET_MEM_REFs.\n\nFrom-SVN: r163278", "tree": {"sha": "4edd6a80f5f5a0a0c23401f9e90a871371fc79be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4edd6a80f5f5a0a0c23401f9e90a871371fc79be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa4e6c7b4b3faf893227ef83e0b815917acc4976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4e6c7b4b3faf893227ef83e0b815917acc4976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4e6c7b4b3faf893227ef83e0b815917acc4976"}], "stats": {"total": 353, "additions": 213, "deletions": 140}, "files": [{"sha": "57df2abca9c6b6423eccc7e54c664a17d5033637", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -1,3 +1,41 @@\n+2010-08-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-cfg.c (verify_types_in_gimple_reference): Verify\n+\tTARGET_MEM_REF a bit.\n+\t* tree-ssa-address.c (addr_for_mem_ref): Adjust.\n+\t(create_mem_ref_raw): Always create TMR_OFFSET, store the\n+\talias pointer type via it.\n+\t(copy_mem_ref_info): Adjust.\n+\t(maybe_fold_tmr): Likewise.\n+\t* tree.c (mem_ref_offset): Also handle TARGET_MEM_REF.\n+\t(reference_alias_ptr_type): Likewise.\n+\t* tree.def (TARGET_MEM_REF): Remove TMR_ORIGINAL operand,\n+\tadjust documentation of TMR_OFFSET operand.\n+\t* alias.c (get_alias_set): Do not look at TMR_ORIGINAL but\n+\tuse the alias pointer type.\n+\t* expr.c (expand_expr_real_1): Do not use TMR_ORIGINAL to\n+\tinitialize mem attrs but the TMR itself.\n+\t* tree-eh.c (tree_could_trap_p): Handle TARGET_MEM_REF\n+\tsimilar to MEM_REF.\n+\t* tree-pretty-print.c (dump_generic_node): Do not dump TMR_ORIGINAL.\n+\t* tree-ssa-loop-ivopts.c (idx_remove_ssa_names): Remove.\n+\t(unshare_and_remove_ssa_names): Likewise.\n+\t(copy_ref_info): Adjust.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Simplify\n+\tTARGET_MEM_REF case.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Do not look\n+\tat TMR_ORIGINAL.\n+\t* tree.h (TMR_ORIGINAL): Remove.\n+\t* gimple.c (get_base_address): For TARGET_MEM_REF with a\n+\tsymbol return that.\n+\t* tree-dfa.c (get_ref_base_and_extent): Handle TARGET_MEM_REF\n+\twith a symbol.\n+\t(get_addr_base_and_unit_offset): Likewise.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Handle\n+\tTARGET_MEM_REFs.\n+\t(indirect_ref_may_alias_decl_p): Likewise.\n+\t(refs_may_alias_p_1): Do not bail out for TARGET_MEM_REFs.\n+\n 2010-08-15  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* doc/invoke.texi (-fomit-frame-pointer): Document that starting"}, {"sha": "6defc79d7a04f45256c7ad1488d5480c6ea43fab", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -619,10 +619,6 @@ get_alias_set (tree t)\n       if (set != -1)\n \treturn set;\n \n-      /* Retrieve the original memory reference if needed.  */\n-      if (TREE_CODE (t) == TARGET_MEM_REF)\n-\tt = TMR_ORIGINAL (t);\n-\n       /* Get the base object of the reference.  */\n       inner = t;\n       while (handled_component_p (inner))\n@@ -643,6 +639,8 @@ get_alias_set (tree t)\n \t  if (set != -1)\n \t    return set;\n \t}\n+      else if (TREE_CODE (inner) == TARGET_MEM_REF)\n+\treturn get_deref_alias_set (TMR_OFFSET (inner));\n       else if (TREE_CODE (inner) == MEM_REF)\n \t{\n \t  set = get_deref_alias_set_1 (TREE_OPERAND (inner, 1));"}, {"sha": "2cfb5b379ff869cba9565b0968f0cc5b23e71c13", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -8658,25 +8658,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \taddr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n \tstruct mem_address addr;\n-\ttree base;\n \n \tget_address_description (exp, &addr);\n \top0 = addr_for_mem_ref (&addr, as, true);\n \top0 = memory_address_addr_space (mode, op0, as);\n \ttemp = gen_rtx_MEM (mode, op0);\n-\tset_mem_attributes (temp, TMR_ORIGINAL (exp), 0);\n+\tset_mem_attributes (temp, exp, 0);\n \tset_mem_addr_space (temp, as);\n-\tbase = get_base_address (TMR_ORIGINAL (exp));\n-\tif (base\n-\t    && (INDIRECT_REF_P (base) || TREE_CODE (base) == MEM_REF)\n-\t    && TMR_BASE (exp)\n-\t    && TREE_CODE (TMR_BASE (exp)) == SSA_NAME\n-\t    && POINTER_TYPE_P (TREE_TYPE (TMR_BASE (exp))))\n-\t  {\n-\t    set_mem_expr (temp, build1 (INDIRECT_REF,\n-\t\t\t\t\tTREE_TYPE (exp), TMR_BASE (exp)));\n-\t    set_mem_offset (temp, NULL_RTX);\n-\t  }\n       }\n       return temp;\n "}, {"sha": "64d338ccfacde8a689ca41b0a02a7d59d4b34588", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -3009,6 +3009,9 @@ get_base_address (tree t)\n   if (TREE_CODE (t) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n     t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+  else if (TREE_CODE (t) == TARGET_MEM_REF\n+\t   && TMR_SYMBOL (t))\n+    t = TMR_SYMBOL (t);\n \n   if (SSA_VAR_P (t)\n       || TREE_CODE (t) == STRING_CST"}, {"sha": "34f982d8878c8794a221104987e06ca61ed60f44", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -2988,6 +2988,17 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \t  return true;\n \t}\n     }\n+  else if (TREE_CODE (expr) == TARGET_MEM_REF)\n+    {\n+      if (!TMR_OFFSET (expr)\n+\t  || TREE_CODE (TMR_OFFSET (expr)) != INTEGER_CST\n+\t  || !POINTER_TYPE_P (TREE_TYPE (TMR_OFFSET (expr))))\n+\t{\n+\t  error (\"Invalid offset operand in TARGET_MEM_REF.\");\n+\t  debug_generic_stmt (expr);\n+\t  return true;\n+\t}\n+    }\n \n   return ((require_lvalue || !is_gimple_min_invariant (expr))\n \t  && verify_types_in_gimple_min_lval (expr));"}, {"sha": "10fd41e5e0faec99d2e0e1dac707ad01c96a0867", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -878,6 +878,37 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    }\n \t  goto done;\n \n+\tcase TARGET_MEM_REF:\n+\t  /* Hand back the decl for MEM[&decl, off].  */\n+\t  if (TMR_SYMBOL (exp))\n+\t    {\n+\t      /* Via the variable index we can reach the whole object.  */\n+\t      if (TMR_INDEX (exp))\n+\t\t{\n+\t\t  exp = TMR_SYMBOL (exp);\n+\t\t  bit_offset = 0;\n+\t\t  maxsize = -1;\n+\t\t  goto done;\n+\t\t}\n+\t      if (integer_zerop (TMR_OFFSET (exp)))\n+\t\texp = TMR_SYMBOL (exp);\n+\t      else\n+\t\t{\n+\t\t  double_int off = mem_ref_offset (exp);\n+\t\t  off = double_int_lshift (off,\n+\t\t\t\t\t   BITS_PER_UNIT == 8\n+\t\t\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t\t   HOST_BITS_PER_DOUBLE_INT, true);\n+\t\t  off = double_int_add (off, shwi_to_double_int (bit_offset));\n+\t\t  if (double_int_fits_in_shwi_p (off))\n+\t\t    {\n+\t\t      bit_offset = double_int_to_shwi (off);\n+\t\t      exp = TMR_SYMBOL (exp);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  goto done;\n+\n \tdefault:\n \t  goto done;\n \t}\n@@ -1010,6 +1041,22 @@ get_addr_base_and_unit_offset (tree exp, HOST_WIDE_INT *poffset)\n \t    }\n \t  goto done;\n \n+\tcase TARGET_MEM_REF:\n+\t  /* Hand back the decl for MEM[&decl, off].  */\n+\t  if (TMR_SYMBOL (exp))\n+\t    {\n+\t      if (TMR_SYMBOL (exp))\n+\t\treturn NULL_TREE;\n+\t      if (!integer_zerop (TMR_OFFSET (exp)))\n+\t\t{\n+\t\t  double_int off = mem_ref_offset (exp);\n+\t\t  gcc_assert (off.high == -1 || off.high == 0);\n+\t\t  byte_offset += double_int_to_shwi (off);\n+\t\t}\n+\t      exp = TMR_SYMBOL (exp);\n+\t    }\n+\t  goto done;\n+\n \tdefault:\n \t  goto done;\n \t}"}, {"sha": "d5b5360014ce0d73b0d36b78c245309410553a7b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -2405,11 +2405,10 @@ tree_could_trap_p (tree expr)\n   switch (code)\n     {\n     case TARGET_MEM_REF:\n-      /* For TARGET_MEM_REFs use the information based on the original\n-\t reference.  */\n-      expr = TMR_ORIGINAL (expr);\n-      code = TREE_CODE (expr);\n-      goto restart;\n+      if (TMR_SYMBOL (expr)\n+\t  && !TMR_INDEX (expr))\n+\treturn false;\n+      return !TREE_THIS_NOTRAP (expr);\n \n     case COMPONENT_REF:\n     case REALPART_EXPR:"}, {"sha": "1dc612151bb7a0f4be21a2f512cc94c64f8b64e7", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -893,13 +893,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t    dump_generic_node (buffer, tmp, spc, flags, false);\n \t  }\n \tpp_string (buffer, \"]\");\n-\tif (flags & TDF_DETAILS)\n-\t  {\n-\t    pp_string (buffer, \"{\");\n-\t    dump_generic_node (buffer, TMR_ORIGINAL (node), spc, flags,\n-\t\t\t       false);\n-\t    pp_string (buffer, \"}\");\n-\t  }\n       }\n       break;\n "}, {"sha": "305a0135e552b6bef01198f9d9ba341b2aea60a1", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -198,7 +198,10 @@ addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n     st = NULL_RTX;\n \n   if (addr->offset && !integer_zerop (addr->offset))\n-    off = immed_double_int_const (tree_to_double_int (addr->offset), address_mode);\n+    off = immed_double_int_const\n+\t    (double_int_sext (tree_to_double_int (addr->offset),\n+\t\t\t      TYPE_PRECISION (TREE_TYPE (addr->offset))),\n+\t     address_mode);\n   else\n     off = NULL_RTX;\n \n@@ -346,31 +349,29 @@ create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr)\n   if (addr->step && integer_onep (addr->step))\n     addr->step = NULL_TREE;\n \n-  if (addr->offset && integer_zerop (addr->offset))\n-    addr->offset = NULL_TREE;\n+  if (addr->offset)\n+    addr->offset = fold_convert (alias_ptr_type, addr->offset);\n+  else\n+    addr->offset = build_int_cst (alias_ptr_type, 0);\n \n   /* If possible use a plain MEM_REF instead of a TARGET_MEM_REF.  */\n   if (alias_ptr_type\n       && !addr->index\n       && !addr->step\n       && (!addr->base || POINTER_TYPE_P (TREE_TYPE (addr->base))))\n     {\n-      tree base, offset;\n+      tree base;\n       gcc_assert (!addr->symbol ^ !addr->base);\n       if (addr->symbol)\n \tbase = build_fold_addr_expr (addr->symbol);\n       else\n \tbase = addr->base;\n-      if (addr->offset)\n-\toffset = fold_convert (alias_ptr_type, addr->offset);\n-      else\n-\toffset = build_int_cst (alias_ptr_type, 0);\n-      return fold_build2 (MEM_REF, type, base, offset);\n+      return fold_build2 (MEM_REF, type, base, addr->offset);\n     }\n \n-  return build6 (TARGET_MEM_REF, type,\n+  return build5 (TARGET_MEM_REF, type,\n \t\t addr->symbol, addr->base, addr->index,\n-\t\t addr->step, addr->offset, NULL);\n+\t\t addr->step, addr->offset);\n }\n \n /* Returns true if OBJ is an object whose address is a link time constant.  */\n@@ -820,7 +821,6 @@ void\n copy_mem_ref_info (tree to, tree from)\n {\n   /* And the info about the original reference.  */\n-  TMR_ORIGINAL (to) = TMR_ORIGINAL (from);\n   TREE_SIDE_EFFECTS (to) = TREE_SIDE_EFFECTS (from);\n   TREE_THIS_VOLATILE (to) = TREE_THIS_VOLATILE (from);\n }\n@@ -839,13 +839,9 @@ maybe_fold_tmr (tree ref)\n \n   if (addr.base && TREE_CODE (addr.base) == INTEGER_CST)\n     {\n-      if (addr.offset)\n-\taddr.offset = fold_binary_to_constant (PLUS_EXPR, sizetype,\n-\t\t\taddr.offset,\n-\t\t\tfold_convert (sizetype, addr.base));\n-      else\n-\taddr.offset = addr.base;\n-\n+      addr.offset = fold_binary_to_constant (PLUS_EXPR,\n+\t\t\t\t\t     TREE_TYPE (addr.offset),\n+\t\t\t\t\t     addr.offset, addr.base);\n       addr.base = NULL_TREE;\n       changed = true;\n     }\n@@ -860,22 +856,17 @@ maybe_fold_tmr (tree ref)\n \t  addr.step = NULL_TREE;\n \t}\n \n-      if (addr.offset)\n-\t{\n-\t  addr.offset = fold_binary_to_constant (PLUS_EXPR, sizetype,\n-\t\t\t\t\t\t addr.offset, off);\n-\t}\n-      else\n-\taddr.offset = off;\n-\n+      addr.offset = fold_binary_to_constant (PLUS_EXPR,\n+\t\t\t\t\t     TREE_TYPE (addr.offset),\n+\t\t\t\t\t     addr.offset, off);\n       addr.index = NULL_TREE;\n       changed = true;\n     }\n \n   if (!changed)\n     return NULL_TREE;\n \n-  ret = create_mem_ref_raw (TREE_TYPE (ref), NULL_TREE, &addr);\n+  ret = create_mem_ref_raw (TREE_TYPE (ref), TREE_TYPE (addr.offset), &addr);\n   if (!ret)\n     return NULL_TREE;\n "}, {"sha": "849c25004e6d811676bfebf8ef2df01292ad7cd5", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 75, "deletions": 21, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -666,13 +666,24 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t\t       alias_set_type ref2_alias_set,\n \t\t\t       alias_set_type base2_alias_set, bool tbaa_p)\n {\n-  tree ptr1 = TREE_OPERAND (base1, 0);\n+  tree ptr1;\n   tree ptrtype1;\n   HOST_WIDE_INT offset1p = offset1, offset2p = offset2;\n \n+  if (TREE_CODE (base1) == TARGET_MEM_REF)\n+    {\n+      if (!TMR_BASE (base1)\n+\t  || !POINTER_TYPE_P (TMR_BASE (base1)))\n+\treturn true;\n+      ptr1 = TMR_BASE (base1);\n+    }\n+  else\n+    ptr1 = TREE_OPERAND (base1, 0);\n+\n   /* The offset embedded in MEM_REFs can be negative.  Bias them\n      so that the resulting offset adjustment is positive.  */\n-  if (TREE_CODE (base1) == MEM_REF)\n+  if (TREE_CODE (base1) == MEM_REF\n+      || TREE_CODE (base1) == TARGET_MEM_REF)\n     {\n       double_int moff = mem_ref_offset (base1);\n       moff = double_int_lshift (moff,\n@@ -690,7 +701,8 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n      (the pointer base cannot validly point to an offset less than zero\n      of the variable).\n      They also cannot alias if the pointer may not point to the decl.  */\n-  if (!ranges_overlap_p (MAX (0, offset1p), -1, offset2p, max_size2))\n+  if ((TREE_CODE (base1) != TARGET_MEM_REF || !TMR_INDEX (base1))\n+      && !ranges_overlap_p (MAX (0, offset1p), -1, offset2p, max_size2))\n     return false;\n   if (!ptr_deref_may_alias_decl_p (ptr1, base2))\n     return false;\n@@ -701,6 +713,8 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \n   if (TREE_CODE (base1) == MEM_REF)\n     ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n+  else if (TREE_CODE (base1) == TARGET_MEM_REF)\n+    ptrtype1 = TREE_TYPE (TMR_OFFSET (base1));\n   else\n     ptrtype1 = TREE_TYPE (ptr1);\n \n@@ -719,8 +733,9 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n      is relative to the start of the type which we ensure by\n      comparing rvalue and access type and disregarding the constant\n      pointer offset.  */\n-  if ((TREE_CODE (base1) != MEM_REF\n-       || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n+  if ((TREE_CODE (base1) != TARGET_MEM_REF || !TMR_INDEX (base1))\n+      && (TREE_CODE (base1) != MEM_REF\n+\t  || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n       && same_type_for_tbaa (TREE_TYPE (ptrtype1), TREE_TYPE (base2)) == 1)\n     return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n \n@@ -757,6 +772,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if (ref1 && ref2\n       && handled_component_p (ref1)\n       && handled_component_p (ref2)\n+      && TREE_CODE (base1) != TARGET_MEM_REF\n       && (TREE_CODE (base1) != MEM_REF\n \t  || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1))\n     return aliasing_component_refs_p (ref1, TREE_TYPE (ptrtype1),\n@@ -786,19 +802,51 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t\t   alias_set_type ref2_alias_set,\n \t\t\t   alias_set_type base2_alias_set, bool tbaa_p)\n {\n-  tree ptr1 = TREE_OPERAND (base1, 0);\n-  tree ptr2 = TREE_OPERAND (base2, 0);\n+  tree ptr1;\n+  tree ptr2;\n   tree ptrtype1, ptrtype2;\n \n+  if (TREE_CODE (base1) == TARGET_MEM_REF)\n+    {\n+      if (!TMR_BASE (base1)\n+\t  || !POINTER_TYPE_P (TMR_BASE (base1)))\n+\treturn true;\n+      ptr1 = TMR_BASE (base1);\n+    }\n+  else\n+    ptr1 = TREE_OPERAND (base1, 0);\n+\n+  if (TREE_CODE (base2) == TARGET_MEM_REF)\n+    {\n+      if (!TMR_BASE (base2)\n+\t  || !POINTER_TYPE_P (TMR_BASE (base2)))\n+\treturn true;\n+      ptr2 = TMR_BASE (base2);\n+    }\n+  else\n+    ptr2 = TREE_OPERAND (base2, 0);\n+\n   /* If both bases are based on pointers they cannot alias if they may not\n      point to the same memory object or if they point to the same object\n      and the accesses do not overlap.  */\n   if ((!cfun || gimple_in_ssa_p (cfun))\n-      && operand_equal_p (ptr1, ptr2, 0))\n+      && operand_equal_p (ptr1, ptr2, 0)\n+      && (((TREE_CODE (base1) != TARGET_MEM_REF\n+\t    || !TMR_INDEX (base1))\n+\t   && (TREE_CODE (base2) != TARGET_MEM_REF\n+\t       || !TMR_INDEX (base2)))\n+\t  || (TREE_CODE (base1) == TARGET_MEM_REF\n+\t      && TREE_CODE (base2) == TARGET_MEM_REF\n+\t      && (TMR_STEP (base1) == TMR_STEP (base2)\n+\t\t  || (TMR_STEP (base1) && TMR_STEP (base2)\n+\t\t      && operand_equal_p (TMR_STEP (base1),\n+\t\t\t\t\t  TMR_STEP (base2), 0)))\n+\t      && operand_equal_p (TMR_INDEX (base1), TMR_INDEX (base2), 0))))\n     {\n       /* The offset embedded in MEM_REFs can be negative.  Bias them\n \t so that the resulting offset adjustment is positive.  */\n-      if (TREE_CODE (base1) == MEM_REF)\n+      if (TREE_CODE (base1) == MEM_REF\n+\t  || TREE_CODE (base1) == TARGET_MEM_REF)\n \t{\n \t  double_int moff = mem_ref_offset (base1);\n \t  moff = double_int_lshift (moff,\n@@ -810,7 +858,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t  else\n \t    offset1 += moff.low;\n \t}\n-      if (TREE_CODE (base2) == MEM_REF)\n+      if (TREE_CODE (base2) == MEM_REF\n+\t  || TREE_CODE (base2) == TARGET_MEM_REF)\n \t{\n \t  double_int moff = mem_ref_offset (base2);\n \t  moff = double_int_lshift (moff,\n@@ -833,10 +882,14 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \n   if (TREE_CODE (base1) == MEM_REF)\n     ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n+  else if (TREE_CODE (base1) == TARGET_MEM_REF)\n+    ptrtype1 = TREE_TYPE (TMR_OFFSET (base1));\n   else\n     ptrtype1 = TREE_TYPE (ptr1);\n   if (TREE_CODE (base2) == MEM_REF)\n     ptrtype2 = TREE_TYPE (TREE_OPERAND (base2, 1));\n+  else if (TREE_CODE (base2) == TARGET_MEM_REF)\n+    ptrtype2 = TREE_TYPE (TMR_OFFSET (base2));\n   else\n     ptrtype2 = TREE_TYPE (ptr2);\n \n@@ -853,8 +906,10 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   /* If both references are through the same type, they do not alias\n      if the accesses do not overlap.  This does extra disambiguation\n      for mixed/pointer accesses but requires strict aliasing.  */\n-  if ((TREE_CODE (base1) != MEM_REF\n-       || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n+  if ((TREE_CODE (base1) != TARGET_MEM_REF || !TMR_INDEX (base1))\n+      && (TREE_CODE (base2) != TARGET_MEM_REF || !TMR_INDEX (base2))\n+      && (TREE_CODE (base1) != MEM_REF\n+\t  || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n       && (TREE_CODE (base2) != MEM_REF\n \t  || same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) == 1)\n       && same_type_for_tbaa (TREE_TYPE (ptrtype1),\n@@ -870,6 +925,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if (ref1 && ref2\n       && handled_component_p (ref1)\n       && handled_component_p (ref2)\n+      && TREE_CODE (base1) != TARGET_MEM_REF\n+      && TREE_CODE (base2) != TARGET_MEM_REF\n       && (TREE_CODE (base1) != MEM_REF\n \t  || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n       && (TREE_CODE (base2) != MEM_REF\n@@ -947,8 +1004,12 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n     return decl_refs_may_alias_p (base1, offset1, max_size1,\n \t\t\t\t  base2, offset2, max_size2);\n \n-  ind1_p = INDIRECT_REF_P (base1) || (TREE_CODE (base1) == MEM_REF);\n-  ind2_p = INDIRECT_REF_P (base2) || (TREE_CODE (base2) == MEM_REF);\n+  ind1_p = (INDIRECT_REF_P (base1)\n+\t    || (TREE_CODE (base1) == MEM_REF)\n+\t    || (TREE_CODE (base1) == TARGET_MEM_REF));\n+  ind2_p = (INDIRECT_REF_P (base2)\n+\t    || (TREE_CODE (base2) == MEM_REF)\n+\t    || (TREE_CODE (base2) == TARGET_MEM_REF));\n \n   /* Canonicalize the pointer-vs-decl case.  */\n   if (ind1_p && var2_p)\n@@ -973,13 +1034,6 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n \t\t\t\t ao_ref_alias_set (ref2)))\n     return false;\n \n-  /* If one reference is a TARGET_MEM_REF weird things are allowed.  Still\n-     TBAA disambiguation based on the access type is possible, so bail\n-     out only after that check.  */\n-  if ((ref1->ref && TREE_CODE (ref1->ref) == TARGET_MEM_REF)\n-      || (ref2->ref && TREE_CODE (ref2->ref) == TARGET_MEM_REF))\n-    return true;\n-\n   /* Dispatch to the pointer-vs-decl or pointer-vs-pointer disambiguators.  */\n   if (var1_p && ind2_p)\n     return indirect_ref_may_alias_decl_p (ref2->ref, base2,"}, {"sha": "f0c3ca9f6d77e18007e2af9af869c947ad3ba0c4", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -5880,57 +5880,13 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n     }\n }\n \n-/* Replaces ssa name in index IDX by its basic variable.  Callback for\n-   for_each_index.  */\n-\n-static bool\n-idx_remove_ssa_names (tree base, tree *idx,\n-\t\t      void *data ATTRIBUTE_UNUSED)\n-{\n-  tree *op;\n-\n-  if (TREE_CODE (*idx) == SSA_NAME)\n-    *idx = SSA_NAME_VAR (*idx);\n-\n-  if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)\n-    {\n-      op = &TREE_OPERAND (base, 2);\n-      if (*op\n-\t  && TREE_CODE (*op) == SSA_NAME)\n-\t*op = SSA_NAME_VAR (*op);\n-      op = &TREE_OPERAND (base, 3);\n-      if (*op\n-\t  && TREE_CODE (*op) == SSA_NAME)\n-\t*op = SSA_NAME_VAR (*op);\n-    }\n-\n-  return true;\n-}\n-\n-/* Unshares REF and replaces ssa names inside it by their basic variables.  */\n-\n-static tree\n-unshare_and_remove_ssa_names (tree ref)\n-{\n-  ref = unshare_expr (ref);\n-  for_each_index (&ref, idx_remove_ssa_names, NULL);\n-\n-  return ref;\n-}\n-\n /* Copies the reference information from OLD_REF to NEW_REF.  */\n \n static void\n copy_ref_info (tree new_ref, tree old_ref)\n {\n   tree new_ptr_base = NULL_TREE;\n \n-  if (TREE_CODE (old_ref) == TARGET_MEM_REF\n-      && TREE_CODE (new_ref) == TARGET_MEM_REF)\n-    TMR_ORIGINAL (new_ref) = TMR_ORIGINAL (old_ref);\n-  else if (TREE_CODE (new_ref) == TARGET_MEM_REF)\n-    TMR_ORIGINAL (new_ref) = unshare_and_remove_ssa_names (old_ref);\n-\n   TREE_SIDE_EFFECTS (new_ref) = TREE_SIDE_EFFECTS (old_ref);\n   TREE_THIS_VOLATILE (new_ref) = TREE_THIS_VOLATILE (old_ref);\n "}, {"sha": "e17aefc2eee9a0679d73a04d4a4f9b1df3505bbb", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -2773,8 +2773,6 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n       break;\n     case TARGET_MEM_REF:\n       {\n-\tvn_reference_op_t nextop = VEC_index (vn_reference_op_s, ref->operands,\n-\t\t\t\t\t      *operand);\n \tpre_expr op0expr;\n \ttree genop0 = NULL_TREE;\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n@@ -2790,15 +2788,13 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t      return NULL_TREE;\n \t  }\n \tif (DECL_P (baseop))\n-\t  return build6 (TARGET_MEM_REF, currop->type,\n+\t  return build5 (TARGET_MEM_REF, currop->type,\n \t\t\t baseop, NULL_TREE,\n-\t\t\t genop0, currop->op1, currop->op2,\n-\t\t\t unshare_expr (nextop->op1));\n+\t\t\t genop0, currop->op1, currop->op2);\n \telse\n-\t  return build6 (TARGET_MEM_REF, currop->type,\n+\t  return build5 (TARGET_MEM_REF, currop->type,\n \t\t\t NULL_TREE, baseop,\n-\t\t\t genop0, currop->op1, currop->op2,\n-\t\t\t unshare_expr (nextop->op1));\n+\t\t\t genop0, currop->op1, currop->op2);\n       }\n       break;\n     case ADDR_EXPR:"}, {"sha": "21662d65713e1a063a0ac315bdb52c3fb7fcff98", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -595,7 +595,6 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n       temp.type = NULL_TREE;\n       temp.opcode = TREE_CODE (base);\n       temp.op0 = base;\n-      temp.op1 = TMR_ORIGINAL (ref);\n       temp.off = -1;\n       VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n       return;"}, {"sha": "c4092ab5dee5d44ddada84bbe387548a175bfce1", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -3906,12 +3906,12 @@ build_simple_mem_ref_loc (location_t loc, tree ptr)\n   return tem;\n }\n \n-/* Return the constant offset of a MEM_REF tree T.  */\n+/* Return the constant offset of a MEM_REF or TARGET_MEM_REF tree T.  */\n \n double_int\n mem_ref_offset (const_tree t)\n {\n-  tree toff = TREE_OPERAND (t, 1);\n+  tree toff = TREE_CODE (t) == MEM_REF ? TREE_OPERAND (t, 1) : TMR_OFFSET (t);\n   return double_int_sext (tree_to_double_int (toff),\n \t\t\t  TYPE_PRECISION (TREE_TYPE (toff)));\n }\n@@ -3928,8 +3928,9 @@ reference_alias_ptr_type (const_tree t)\n     base = TREE_OPERAND (base, 0);\n   if (TREE_CODE (base) == MEM_REF)\n     return TREE_TYPE (TREE_OPERAND (base, 1));\n-  else if (TREE_CODE (base) == TARGET_MEM_REF\n-\t   || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n+  else if (TREE_CODE (base) == TARGET_MEM_REF)\n+    return TREE_TYPE (TMR_OFFSET (base)); \n+  else if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n     return NULL_TREE;\n   else\n     return build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (base)));"}, {"sha": "c71a8751709a2386cec6b0f7d3e545632d621134", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -958,13 +958,13 @@ DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n    SYMBOL + BASE + STEP * INDEX + OFFSET.  Only variations and values valid on\n    the target are allowed.\n \n-   The type of STEP, INDEX and OFFSET is sizetype.  The type of BASE is\n+   The type of STEP and INDEX is sizetype.  The type of BASE is\n    sizetype or a pointer type (if SYMBOL is NULL).\n \n-   The sixth argument is the reference to the original memory access, which\n-   is preserved for the purpose of alias analysis.  */\n+   The type of OFFSET is a pointer type and determines TBAA the same as\n+   the constant offset operand in MEM_REF.  */\n \n-DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 6)\n+DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 5)\n \n /* Memory addressing.  Operands are a pointer and a tree constant integer\n    byte offset of the pointer type that when dereferenced yields the"}, {"sha": "d16a475a35337e36346fc5f7bd85c10cf50e0357", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b228e61a98d8bdd1286e536a1f74cdbce50d0ff/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4b228e61a98d8bdd1286e536a1f74cdbce50d0ff", "patch": "@@ -1622,7 +1622,6 @@ extern void protected_set_expr_location (tree, location_t);\n #define TMR_INDEX(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 2))\n #define TMR_STEP(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 3))\n #define TMR_OFFSET(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))\n-#define TMR_ORIGINAL(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 5))\n \n /* The operands of a BIND_EXPR.  */\n #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))"}]}