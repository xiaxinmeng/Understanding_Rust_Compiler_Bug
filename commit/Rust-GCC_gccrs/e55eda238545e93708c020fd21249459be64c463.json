{"sha": "e55eda238545e93708c020fd21249459be64c463", "node_id": "C_kwDOANBUbNoAKGU1NWVkYTIzODU0NWU5MzcwOGMwMjBmZDIxMjQ5NDU5YmU2NGM0NjM", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-13T12:35:38Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-13T13:08:18Z"}, "message": "d: Improve TypeInfo errors when compiling in -fno-rtti mode\n\nThe existing TypeInfo errors can be cryptic.  This alters the diagnostic\nto include which expression is requiring `object.TypeInfo'.\n\ngcc/d/ChangeLog:\n\n\t* d-tree.h (check_typeinfo_type): Add Expression* parameter.\n\t(build_typeinfo): Likewise.  Declare new override.\n\t* expr.cc (ExprVisitor): Call build_typeinfo with Expression*.\n\t* typeinfo.cc (check_typeinfo_type): Include expression in the\n\tdiagnostic message.\n\t(build_typeinfo): New override.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/rtti1.d: New test.", "tree": {"sha": "892ec8d4a3b62874fd18f7090497147e64fa7494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/892ec8d4a3b62874fd18f7090497147e64fa7494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e55eda238545e93708c020fd21249459be64c463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55eda238545e93708c020fd21249459be64c463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e55eda238545e93708c020fd21249459be64c463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55eda238545e93708c020fd21249459be64c463/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1158fe43407568f20415b16575ddbfff216bf8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1158fe43407568f20415b16575ddbfff216bf8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1158fe43407568f20415b16575ddbfff216bf8b6"}], "stats": {"total": 93, "additions": 63, "deletions": 30}, "files": [{"sha": "5f6b9d610010687505afd9826160d580922caa00", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55eda238545e93708c020fd21249459be64c463/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55eda238545e93708c020fd21249459be64c463/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=e55eda238545e93708c020fd21249459be64c463", "patch": "@@ -671,8 +671,9 @@ extern tree layout_classinfo (ClassDeclaration *);\n extern unsigned base_vtable_offset (ClassDeclaration *, BaseClass *);\n extern tree get_typeinfo_decl (TypeInfoDeclaration *);\n extern tree get_classinfo_decl (ClassDeclaration *);\n-extern void check_typeinfo_type (const Loc &, Scope *);\n-extern tree build_typeinfo (const Loc &, Type *);\n+extern void check_typeinfo_type (const Loc &, Scope *, Expression * = NULL);\n+extern tree build_typeinfo (const Loc &, Type *, Expression * = NULL);\n+extern tree build_typeinfo (Expression *, Type *);\n extern void create_typeinfo (Type *, Module *);\n extern void create_tinfo_types (Module *);\n extern void layout_cpp_typeinfo (ClassDeclaration *);"}, {"sha": "fba397bed35a92ed1b82e62ff84738ef2edef3ac", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55eda238545e93708c020fd21249459be64c463/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55eda238545e93708c020fd21249459be64c463/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=e55eda238545e93708c020fd21249459be64c463", "patch": "@@ -427,7 +427,7 @@ class ExprVisitor : public Visitor\n \t    tree result = build_libcall (LIBCALL_ADEQ2, e->type, 3,\n \t\t\t\t\t d_array_convert (e->e1),\n \t\t\t\t\t d_array_convert (e->e2),\n-\t\t\t\t\t build_typeinfo (e->loc, t1array));\n+\t\t\t\t\t build_typeinfo (e, t1array));\n \n \t    if (e->op == EXP::notEqual)\n \t      result = build1 (TRUTH_NOT_EXPR, build_ctype (e->type), result);\n@@ -450,7 +450,7 @@ class ExprVisitor : public Visitor\n       {\n \t/* Use _aaEqual() for associative arrays.  */\n \ttree result = build_libcall (LIBCALL_AAEQUAL, e->type, 3,\n-\t\t\t\t     build_typeinfo (e->loc, tb1),\n+\t\t\t\t     build_typeinfo (e, tb1),\n \t\t\t\t     build_expr (e->e1),\n \t\t\t\t     build_expr (e->e2));\n \n@@ -484,7 +484,7 @@ class ExprVisitor : public Visitor\n     /* Build a call to _aaInX().  */\n     this->result_ = build_libcall (LIBCALL_AAINX, e->type, 3,\n \t\t\t\t   build_expr (e->e2),\n-\t\t\t\t   build_typeinfo (e->loc, tkey),\n+\t\t\t\t   build_typeinfo (e, tkey),\n \t\t\t\t   build_address (key));\n   }\n \n@@ -728,13 +728,13 @@ class ExprVisitor : public Visitor\n \t\t\t\t   size_int (ndims), build_address (var));\n \n \tresult = build_libcall (LIBCALL_ARRAYCATNTX, e->type, 2,\n-\t\t\t\tbuild_typeinfo (e->loc, e->type), arrs);\n+\t\t\t\tbuild_typeinfo (e, e->type), arrs);\n       }\n     else\n       {\n \t/* Handle single concatenation (a ~ b).  */\n \tresult = build_libcall (LIBCALL_ARRAYCATT, e->type, 3,\n-\t\t\t\tbuild_typeinfo (e->loc, e->type),\n+\t\t\t\tbuild_typeinfo (e, e->type),\n \t\t\t\td_array_convert (etype, e->e1),\n \t\t\t\td_array_convert (etype, e->e2));\n       }\n@@ -903,7 +903,7 @@ class ExprVisitor : public Visitor\n \n \t\t/* So we can call postblits on const/immutable objects.  */\n \t\tType *tm = etype->unSharedOf ()->mutableOf ();\n-\t\ttree ti = build_typeinfo (e->loc, tm);\n+\t\ttree ti = build_typeinfo (e, tm);\n \n \t\t/* Generate: _d_arraysetassign (t1.ptr, &t2, t1.length, ti);  */\n \t\tresult = build_libcall (LIBCALL_ARRAYSETASSIGN, Type::tvoid, 4,\n@@ -977,7 +977,7 @@ class ExprVisitor : public Visitor\n \t      {\n \t\t/* Generate: _d_arrayassign(ti, from, to);  */\n \t\tthis->result_ = build_libcall (LIBCALL_ARRAYASSIGN, e->type, 3,\n-\t\t\t\t\t       build_typeinfo (e->loc, etype),\n+\t\t\t\t\t       build_typeinfo (e, etype),\n \t\t\t\t\t       d_array_convert (e->e2),\n \t\t\t\t\t       d_array_convert (e->e1));\n \t      }\n@@ -1122,7 +1122,7 @@ class ExprVisitor : public Visitor\n \tType *arrtype = (e->type->ty == TY::Tsarray)\n \t  ? etype->arrayOf () : e->type;\n \ttree result = build_libcall (libcall, arrtype, 4,\n-\t\t\t\t     build_typeinfo (e->loc, etype),\n+\t\t\t\t     build_typeinfo (e, etype),\n \t\t\t\t     d_array_convert (e->e2),\n \t\t\t\t     d_array_convert (e->e1),\n \t\t\t\t     build_address (elembuf));\n@@ -1193,13 +1193,13 @@ class ExprVisitor : public Visitor\n \t  {\n \t    libcall = LIBCALL_AAGETY;\n \t    ptr = build_address (build_expr (e->e1));\n-\t    tinfo = build_typeinfo (e->loc, tb1->unSharedOf ()->mutableOf ());\n+\t    tinfo = build_typeinfo (e, tb1->unSharedOf ()->mutableOf ());\n \t  }\n \telse\n \t  {\n \t    libcall = LIBCALL_AAGETRVALUEX;\n \t    ptr = build_expr (e->e1);\n-\t    tinfo = build_typeinfo (e->loc, tkey);\n+\t    tinfo = build_typeinfo (e, tkey);\n \t  }\n \n \t/* Index the associative array.  */\n@@ -1427,7 +1427,7 @@ class ExprVisitor : public Visitor\n \n \tthis->result_ = build_libcall (LIBCALL_AADELX, Type::tbool, 3,\n \t\t\t\t       build_expr (e->e1),\n-\t\t\t\t       build_typeinfo (e->loc, tkey),\n+\t\t\t\t       build_typeinfo (e, tkey),\n \t\t\t\t       build_address (index));\n       }\n     else\n@@ -1981,7 +1981,7 @@ class ExprVisitor : public Visitor\n   {\n     if (Type *tid = isType (e->obj))\n       {\n-\ttree ti = build_typeinfo (e->loc, tid);\n+\ttree ti = build_typeinfo (e, tid);\n \n \t/* If the typeinfo is at an offset.  */\n \tif (tid->vtinfo->offset)\n@@ -2319,7 +2319,7 @@ class ExprVisitor : public Visitor\n \t/* Generate: _d_newitemT()  */\n \tlibcall_fn libcall = htype->isZeroInit ()\n \t  ? LIBCALL_NEWITEMT : LIBCALL_NEWITEMIT;\n-\ttree arg = build_typeinfo (e->loc, e->newtype);\n+\ttree arg = build_typeinfo (e, e->newtype);\n \tnew_call = build_libcall (libcall, tb, 1, arg);\n \n \tif (e->member || !e->arguments)\n@@ -2387,7 +2387,7 @@ class ExprVisitor : public Visitor\n \t    libcall_fn libcall = tarray->next->isZeroInit ()\n \t      ? LIBCALL_NEWARRAYT : LIBCALL_NEWARRAYIT;\n \t    result = build_libcall (libcall, tb, 2,\n-\t\t\t\t    build_typeinfo (e->loc, e->type),\n+\t\t\t\t    build_typeinfo (e, e->type),\n \t\t\t\t    build_expr (arg));\n \t  }\n \telse\n@@ -2419,7 +2419,7 @@ class ExprVisitor : public Visitor\n \t    libcall_fn libcall = telem->isZeroInit ()\n \t      ? LIBCALL_NEWARRAYMTX : LIBCALL_NEWARRAYMITX;\n \n-\t    tree tinfo = build_typeinfo (e->loc, e->type);\n+\t    tree tinfo = build_typeinfo (e, e->type);\n \t    tree dims = d_array_value (build_ctype (Type::tsize_t->arrayOf ()),\n \t\t\t\t       size_int (e->arguments->length),\n \t\t\t\t       build_address (var));\n@@ -2446,7 +2446,7 @@ class ExprVisitor : public Visitor\n \tlibcall_fn libcall = tpointer->next->isZeroInit (e->loc)\n \t  ? LIBCALL_NEWITEMT : LIBCALL_NEWITEMIT;\n \n-\ttree arg = build_typeinfo (e->loc, e->newtype);\n+\ttree arg = build_typeinfo (e, e->newtype);\n \tresult = build_libcall (libcall, tb, 1, arg);\n \n \tif (e->arguments && e->arguments->length == 1)\n@@ -2691,7 +2691,7 @@ class ExprVisitor : public Visitor\n \t/* Allocate space on the memory managed heap.  */\n \ttree mem = build_libcall (LIBCALL_ARRAYLITERALTX,\n \t\t\t\t  etype->pointerTo (), 2,\n-\t\t\t\t  build_typeinfo (e->loc, etype->arrayOf ()),\n+\t\t\t\t  build_typeinfo (e, etype->arrayOf ()),\n \t\t\t\t  size_int (e->elements->length));\n \tmem = d_save_expr (mem);\n \n@@ -2748,7 +2748,7 @@ class ExprVisitor : public Visitor\n \t\t\t       build_address (avals));\n \n     tree mem = build_libcall (LIBCALL_ASSOCARRAYLITERALTX, Type::tvoidptr, 3,\n-\t\t\t      build_typeinfo (e->loc, ta), keys, vals);\n+\t\t\t      build_typeinfo (e, ta), keys, vals);\n \n     /* Return an associative array pointed to by MEM.  */\n     tree aatype = build_ctype (ta);"}, {"sha": "1647521555da5824edba7425f4b46ef26705d506", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55eda238545e93708c020fd21249459be64c463/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55eda238545e93708c020fd21249459be64c463/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=e55eda238545e93708c020fd21249459be64c463", "patch": "@@ -1394,21 +1394,29 @@ get_classinfo_decl (ClassDeclaration *decl)\n }\n \n /* Performs sanity checks on the `object.TypeInfo' type, raising an error if\n-   RTTI is disabled, or the type is missing.  */\n+   RTTI is disabled, or the type is missing.  LOC is the location used for error\n+   messages.  SC is the context, and EXPR is expression where TypeInfo is\n+   required from, if either are set.  */\n \n void\n-check_typeinfo_type (const Loc &loc, Scope *sc)\n+check_typeinfo_type (const Loc &loc, Scope *sc, Expression *expr)\n {\n   if (!global.params.useTypeInfo)\n     {\n-      static int warned = 0;\n-\n       /* Even when compiling without RTTI we should still be able to evaluate\n \t TypeInfo at compile-time, just not at run-time.  */\n-      if (!warned && (!sc || !(sc->flags & SCOPEctfe)))\n+      if (!sc || !(sc->flags & SCOPEctfe))\n \t{\n-\t  error_at (make_location_t (loc),\n-\t\t    \"%<object.TypeInfo%> cannot be used with %<-fno-rtti%>\");\n+\t  static int warned = 0;\n+\n+\t  if (expr != NULL)\n+\t    error_at (make_location_t (loc),\n+\t\t     \"expression %qs requires %<object.TypeInfo%> and cannot \"\n+\t\t     \"be used with %<-fno-rtti%>\", expr->toChars ());\n+\t  else if (!warned)\n+\t    error_at (make_location_t (loc),\n+\t\t      \"%<object.TypeInfo%> cannot be used with %<-fno-rtti%>\");\n+\n \t  warned = 1;\n \t}\n     }\n@@ -1429,17 +1437,23 @@ check_typeinfo_type (const Loc &loc, Scope *sc)\n     }\n }\n \n-/* Returns typeinfo reference for TYPE.  */\n+/* Returns typeinfo reference for TYPE.  LOC is the location used for error\n+   messages.  EXPR is the expression where TypeInfo is required, if set.  */\n \n tree\n-build_typeinfo (const Loc &loc, Type *type)\n+build_typeinfo (const Loc &loc, Type *type, Expression *expr)\n {\n   gcc_assert (type->ty != TY::Terror);\n-  check_typeinfo_type (loc, NULL);\n+  check_typeinfo_type (loc, NULL, expr);\n   create_typeinfo (type, NULL);\n   return build_address (get_typeinfo_decl (type->vtinfo));\n }\n \n+tree build_typeinfo (Expression *expr, Type *type)\n+{\n+  return build_typeinfo (expr->loc, type, expr);\n+}\n+\n /* Like layout_classinfo, but generates an Object that wraps around a\n    pointer to C++ type_info so it can be distinguished from D TypeInfo.  */\n "}, {"sha": "ed5f3440689e14729a9420b15be275c033c824c6", "filename": "gcc/testsuite/gdc.dg/rtti1.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e55eda238545e93708c020fd21249459be64c463/gcc%2Ftestsuite%2Fgdc.dg%2Frtti1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e55eda238545e93708c020fd21249459be64c463/gcc%2Ftestsuite%2Fgdc.dg%2Frtti1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Frtti1.d?ref=e55eda238545e93708c020fd21249459be64c463", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-options \"-fno-rtti\" }\n+// { dg-shouldfail \"expressions depend on TypeInfo\" }\n+\n+int* testInExp(int key, int[int] aa)\n+{\n+    return key in aa; // { dg-error \"requires .object.TypeInfo. and cannot be used with .-fno-rtti.\" }\n+}\n+\n+bool testAAEqual(int[string] aa1, int[string] aa2)\n+{\n+    return aa1 == aa2; // { dg-error \"requires .object.TypeInfo. and cannot be used with .-fno-rtti.\" }\n+}\n+\n+string testConcat(string a, string b)\n+{\n+    return a ~ b; // { dg-error \"requires .object.TypeInfo. and cannot be used with .-fno-rtti.\" }\n+}"}]}