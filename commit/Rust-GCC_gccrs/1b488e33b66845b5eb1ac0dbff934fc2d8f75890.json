{"sha": "1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI0ODhlMzNiNjY4NDViNWViMWFjMGRiZmY5MzRmYzJkOGY3NTg5MA==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-08-22T00:58:28Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-08-22T00:58:28Z"}, "message": "regex.h: Executor caller.\n\n2013-08-22  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.h: Executor caller.\n\t* include/bits/regex_executor.h: Fix empty grouping problem.\n\t* include/bits/regex_executor.tcc: Same.\n\t* testsuite/28_regex/algorithms/regex_match/ecma/cstring_emptygroup.cc:\n\t  New.\n\nFrom-SVN: r201914", "tree": {"sha": "cd120fcb09910f198fb7bde5934a7cd9b3e79d4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd120fcb09910f198fb7bde5934a7cd9b3e79d4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ad30113d636b59a11688d541149942b16b6ee5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad30113d636b59a11688d541149942b16b6ee5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ad30113d636b59a11688d541149942b16b6ee5b"}], "stats": {"total": 324, "additions": 235, "deletions": 89}, "files": [{"sha": "c614b326e35743d727ed591ea514417529df174a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "patch": "@@ -1,3 +1,11 @@\n+2013-08-22  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.h: Executor caller.\n+\t* include/bits/regex_executor.h: Fix empty grouping problem.\n+\t* include/bits/regex_executor.tcc: Same.\n+\t* testsuite/28_regex/algorithms/regex_match/ecma/cstring_emptygroup.cc:\n+\t  New.\n+\n 2013-08-20  Phil Muldoon  <pmuldoon@redhat.com>\n \n \tPR libstdc++/53477"}, {"sha": "f5932edaadb0058735a9c8e2600e8852a8c6f83c", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "patch": "@@ -2211,7 +2211,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__re._M_automaton == nullptr)\n         return false;\n-      if (__detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match())\n+      __detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match();\n+      if (__m.size() > 0 && __m[0].matched)\n         {\n           for (auto __it : __m)\n             if (!__it.matched)\n@@ -2371,22 +2372,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__re._M_automaton == nullptr)\n         return false;\n       for (auto __cur = __first; __cur != __last; ++__cur) // Any KMP-like algo?\n-        if (__detail::__get_executor(__cur, __last, __m, __re, __flags)\n-              ->_M_search_from_first())\n-          {\n-            for (auto __it : __m)\n-              if (!__it.matched)\n-                __it.first = __it.second = __last;\n-            __m.at(__m.size()).first = __first;\n-            __m.at(__m.size()).second = __m[0].first;\n-            __m.at(__m.size()+1).first = __m[0].second;\n-            __m.at(__m.size()+1).second = __last;\n-            __m.at(__m.size()).matched =\n-              (__m.prefix().first != __m.prefix().second);\n-            __m.at(__m.size()+1).matched =\n-              (__m.suffix().first != __m.suffix().second);\n-            return true;\n-          }\n+        {\n+          __detail::__get_executor(__cur, __last, __m, __re, __flags)\n+            ->_M_search_from_first();\n+          if (__m.size() > 0 && __m[0].matched)\n+\t    {\n+\t      for (auto __it : __m)\n+\t\tif (!__it.matched)\n+\t\t  __it.first = __it.second = __last;\n+\t      __m.at(__m.size()).first = __first;\n+\t      __m.at(__m.size()).second = __m[0].first;\n+\t      __m.at(__m.size()+1).first = __m[0].second;\n+\t      __m.at(__m.size()+1).second = __last;\n+\t      __m.at(__m.size()).matched =\n+\t\t(__m.prefix().first != __m.prefix().second);\n+\t      __m.at(__m.size()+1).matched =\n+\t\t(__m.suffix().first != __m.suffix().second);\n+\t      return true;\n+\t    }\n+        }\n       return false;\n     }\n "}, {"sha": "e2d6e6e412d87f911fb1279802e1b94a7d129af5", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 59, "deletions": 35, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "patch": "@@ -28,12 +28,17 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n+// TODO: convert comments to doxygen format.\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename, typename>\n     class basic_regex;\n \n+  template<typename>\n+    class sub_match;\n+\n   template<typename, typename>\n     class match_results;\n _GLIBCXX_END_NAMESPACE_VERSION\n@@ -52,19 +57,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class _Executor\n     {\n     public:\n-      typedef match_results<_BiIter, _Alloc>   _ResultsT;\n-      typedef regex_constants::match_flag_type _FlagT;\n+      typedef match_results<_BiIter, _Alloc>          _ResultsT;\n+      typedef std::vector<sub_match<_BiIter>, _Alloc> _ResultsVec;\n+      typedef regex_constants::match_flag_type        _FlagT;\n \n       virtual\n       ~_Executor()\n       { }\n \n       // Set matched when string exactly match the pattern.\n-      virtual bool\n+      virtual void\n       _M_match() = 0;\n \n       // Set matched when some prefix of the string matches the pattern.\n-      virtual bool\n+      virtual void\n       _M_search_from_first() = 0;\n \n     protected:\n@@ -74,20 +80,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                 _ResultsT& __results,\n                 _FlagT     __flags,\n                 _SizeT     __size)\n-      : _M_current(__begin), _M_end(__end),\n-        _M_results(__results), _M_flags(__flags)\n+      : _M_current(__begin), _M_end(__end), _M_results(__results),\n+        _M_flags(__flags)\n       {\n-        __results.resize(__size + 2);\n-        for (auto __it : __results)\n-          __it.matched = false;\n+        __size += 2;\n+        _M_results.resize(__size);\n+        for (auto __i = 0; __i < __size; __i++)\n+          _M_results[__i].matched = false;\n       }\n \n-      _BiIter    _M_current;\n-      _BiIter    _M_end;\n-      _ResultsT& _M_results;\n-      _FlagT     _M_flags;\n+      _BiIter       _M_current;\n+      _BiIter       _M_end;\n+      _ResultsVec&  _M_results;\n+      _FlagT        _M_flags;\n     };\n \n+  // A _DFSExecutor perform a DFS on given NFA and input string. At the very\n+  // beginning the executor stands in the start state, then it try every\n+  // possible state transition in current state recursively. Some state\n+  // transitions consume input string, say, a single-char-matcher or a\n+  // back-reference matcher; some not, like assertion or other anchor nodes.\n+  // When the input is exhausted and the current state is an accepting state,\n+  // the whole executor return true.\n+  //\n+  // TODO: This approach is exponentially slow for certain input.\n+  //       Try to compile the NFA to a DFA.\n+  //\n+  // Time complexity: exponential\n+  // Space complexity: O(__end - __begin)\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     class _DFSExecutor\n@@ -97,6 +117,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n       typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n       typedef typename _BaseT::_ResultsT                   _ResultsT;\n+      typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n       typedef regex_constants::match_flag_type             _FlagT;\n \n       _DFSExecutor(_BiIter        __begin,\n@@ -105,37 +126,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                    const _RegexT& __nfa,\n                    _FlagT         __flags)\n       : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n-        _M_traits(_TraitsT()), _M_nfa(__nfa)\n+        _M_traits(_TraitsT()), _M_nfa(__nfa), _M_results_ret(this->_M_results)\n       { }\n \n-      bool\n+      void\n       _M_match()\n-      { return _M_dfs<true>(_M_nfa._M_start()); }\n+      { _M_dfs<true>(_M_nfa._M_start()); }\n \n-      bool\n+      void\n       _M_search_from_first()\n-      { return _M_dfs<false>(_M_nfa._M_start()); }\n+      { _M_dfs<false>(_M_nfa._M_start()); }\n \n     private:\n       template<bool __match_mode>\n         bool\n         _M_dfs(_StateIdT __i);\n \n+      _ResultsVec    _M_results_ret;\n       _TraitsT       _M_traits;\n       const _RegexT& _M_nfa;\n     };\n \n-  // It's essentially a variant of Single-Source-Shortest-Path problem, where,\n-  // the matching results is the final distance and should be minimized.\n-  // Instead of using Dijkstra Algorithm, I pick up the queue-optimizaed\n-  // (BFS-like) Bellman-Ford algorithm,\n-  // SPFA(http://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm).\n+  // Like the DFS approach, it try every possible state transition; Unlike DFS,\n+  // it uses a queue instead of a stack to store matching states. It's a BFS\n+  // approach.\n+  //\n+  // Russ Cox's article(http://swtch.com/~rsc/regexp/regexp1.html) explained\n+  // this algorithm clearly.\n   //\n   // Every entry of _M_covered saves the solution(grouping status) for every\n-  // matching head. When states transfer, solutions will be compared and\n+  // matching head. When states transit, solutions will be compared and\n   // deduplicated(based on which greedy mode we have).\n   //\n-  // Time complexity: O(_M_str_cur.size() * _M_nfa.size())\n+  // Time complexity: O((__end - __begin) * _M_nfa.size())\n   // Space complexity: O(_M_nfa.size() * _M_nfa.mark_count())\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n@@ -146,34 +169,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n       typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n       typedef typename _BaseT::_ResultsT                   _ResultsT;\n-      typedef std::unique_ptr<_ResultsT>                   _ResultsPtr;\n+      typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n+      typedef std::unique_ptr<_ResultsVec>                 _ResultsPtr;\n       typedef regex_constants::match_flag_type             _FlagT;\n \n       _BFSExecutor(_BiIter        __begin,\n                    _BiIter        __end,\n-                   _ResultsT&      __results,\n+                   _ResultsT&     __results,\n                    const _RegexT& __nfa,\n                    _FlagT         __flags)\n       : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n         _M_nfa(__nfa)\n       {\n         if (_M_nfa._M_start() != _S_invalid_state_id)\n           _M_covered[_M_nfa._M_start()] =\n-            _ResultsPtr(new _ResultsT(this->_M_results));\n+            _ResultsPtr(new _ResultsVec(this->_M_results));\n         _M_e_closure();\n       }\n \n-      bool\n+      void\n       _M_match()\n-      { return _M_main_loop<true>(); }\n+      { _M_main_loop<true>(); }\n \n-      bool\n+      void\n       _M_search_from_first()\n-      { return _M_main_loop<false>(); }\n+      { _M_main_loop<false>(); }\n \n     private:\n       template<bool __match_mode>\n-        bool\n+        void\n         _M_main_loop();\n \n       void\n@@ -183,13 +207,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_move();\n \n       bool\n-      _M_match_less_than(_StateIdT __u, _StateIdT __v) const;\n+      _M_match_less_than(const _ResultsVec& __u, const _ResultsVec& __v) const;\n \n       bool\n       _M_includes_some() const;\n \n       std::map<_StateIdT, _ResultsPtr>     _M_covered;\n-      const _RegexT& _M_nfa;\n+      const _RegexT&                       _M_nfa;\n     };\n \n  //@} regex-detail"}, {"sha": "9115ea0ebf2d98f89ece67613786007d4abd97d9", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 89, "deletions": 37, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "patch": "@@ -34,19 +34,18 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  // TODO: This is too slow. Try to compile the NFA to a DFA.\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n   template<bool __match_mode>\n     bool _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_dfs(_StateIdT __i)\n     {\n-      auto& __current = this->_M_current;\n-      auto& __end = this->_M_end;\n-      auto& __results = this->_M_results;\n       if (__i == _S_invalid_state_id)\n         // This is not that certain. Need deeper investigate.\n         return false;\n+      auto& __current = this->_M_current;\n+      auto& __end = this->_M_end;\n+      auto& __results = _M_results_ret;\n       const auto& __state = _M_nfa[__i];\n       bool __ret = false;\n       switch (__state._M_opcode)\n@@ -59,14 +58,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n             || _M_dfs<__match_mode>(__state._M_next);\n           break;\n         case _S_opcode_subexpr_begin:\n-          __results.at(__state._M_subexpr).first = __current;\n-          __ret = _M_dfs<__match_mode>(__state._M_next);\n+          // Here's the critical part: if there's nothing changed since last\n+          // visit, do NOT continue. This prevents the executor from get into\n+          // infinite loop when use \"()*\" to match \"\".\n+          //\n+          // Every change on __results will be roll back after the recursion\n+          // step finished.\n+          if (!__results[__state._M_subexpr].matched\n+              || __results[__state._M_subexpr].first != __current)\n+            {\n+              auto __back = __current;\n+              __results[__state._M_subexpr].first = __current;\n+              __ret = _M_dfs<__match_mode>(__state._M_next);\n+              __results[__state._M_subexpr].first = __back;\n+            }\n           break;\n         case _S_opcode_subexpr_end:\n-          __results.at(__state._M_subexpr).second = __current;\n-          __results.at(__state._M_subexpr).matched = true;\n-          __ret = _M_dfs<__match_mode>(__state._M_next);\n-          __results.at(__state._M_subexpr).matched = __ret;\n+          if (__results[__state._M_subexpr].second != __current\n+              || __results[__state._M_subexpr].matched != true)\n+            {\n+              auto __back = __results[__state._M_subexpr];\n+              __results[__state._M_subexpr].second = __current;\n+              __results[__state._M_subexpr].matched = true;\n+              __ret = _M_dfs<__match_mode>(__state._M_next);\n+              __results[__state._M_subexpr] = __back;\n+            }\n+          else\n+            __ret = _M_dfs<__match_mode>(__state._M_next);\n           break;\n         case _S_opcode_match:\n           if (__current != __end && __state._M_matches(*__current))\n@@ -82,7 +100,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         // If matched, keep going; else just return to try another state.\n         case _S_opcode_backref:\n           {\n-            auto& __submatch = __results.at(__state._M_backref_index);\n+            auto& __submatch = __results[__state._M_backref_index];\n             if (!__submatch.matched)\n               break;\n             auto __last = __current;\n@@ -92,19 +110,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n               ++__last;\n             if (_M_traits.transform(__submatch.first, __submatch.second)\n                 == _M_traits.transform(__current, __last))\n-              {\n-                auto __backup = __current;\n-                __current = __last;\n+              if (__last != __current)\n+                {\n+                  auto __backup = __current;\n+                  __current = __last;\n+                  __ret = _M_dfs<__match_mode>(__state._M_next);\n+                  __current = __backup;\n+                }\n+              else\n                 __ret = _M_dfs<__match_mode>(__state._M_next);\n-                __current = __backup;\n-              }\n           }\n           break;\n         case _S_opcode_accept:\n           if (__match_mode)\n             __ret = __current == __end;\n           else\n             __ret = true;\n+          if (__ret)\n+            this->_M_results = __results;\n           break;\n         default:\n           _GLIBCXX_DEBUG_ASSERT(false);\n@@ -115,22 +138,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n   template<bool __match_mode>\n-    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_main_loop()\n     {\n       while (this->_M_current != this->_M_end)\n         {\n           if (!__match_mode)\n             if (_M_includes_some())\n-              return true;\n+              return;\n           _M_move();\n           ++this->_M_current;\n           _M_e_closure();\n         }\n-      return _M_includes_some();\n+      _M_includes_some();\n     }\n \n-  // The SPFA approach.\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n@@ -152,13 +174,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           const auto& __state = _M_nfa[__u];\n \n           // Can be implemented using method, but there're too much arguments.\n+          // I would use macro function before C++11, but lambda is a better\n+          // choice, since hopefully compiler can inline it.\n           auto __add_visited_state = [&](_StateIdT __v)\n           {\n             if (__v == _S_invalid_state_id)\n               return;\n-            if (_M_match_less_than(__u, __v))\n+            if (_M_covered.count(__u) != 0\n+                && (_M_covered.count(__v) == 0\n+                    || _M_match_less_than(*_M_covered[__u], *_M_covered[__v])))\n               {\n-                _M_covered[__v] = _ResultsPtr(new _ResultsT(*_M_covered[__u]));\n+                _M_covered[__v] = _ResultsPtr(new _ResultsVec(*_M_covered[__u]));\n                 // if a state is updated, it's outgoing neighbors should be\n                 // reconsidered too. Push them to the queue.\n                 if (!__in_q[__v])\n@@ -176,13 +202,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                 __add_visited_state(__state._M_alt);\n                 break;\n               case _S_opcode_subexpr_begin:\n-                _M_covered[__u]->at(__state._M_subexpr).first = __current;\n-                __add_visited_state(__state._M_next);\n+                {\n+                  auto& __cu = *_M_covered[__u];\n+                  auto __back = __cu[__state._M_subexpr].first;\n+                  __cu[__state._M_subexpr].first = __current;\n+                  __add_visited_state(__state._M_next);\n+                  __cu[__state._M_subexpr].first = __back;\n+                }\n                 break;\n               case _S_opcode_subexpr_end:\n-                _M_covered[__u]->at(__state._M_subexpr).second = __current;\n-                _M_covered[__u]->at(__state._M_subexpr).matched = true;\n-                __add_visited_state(__state._M_next);\n+                {\n+                  auto& __cu = *_M_covered[__u];\n+                  auto __back = __cu[__state._M_subexpr];\n+                  __cu[__state._M_subexpr].second = __current;\n+                  __cu[__state._M_subexpr].matched = true;\n+                  __add_visited_state(__state._M_next);\n+                  __cu[__state._M_subexpr] = __back;\n+                }\n                 break;\n               case _S_opcode_match:\n                 break;\n@@ -206,24 +242,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           const auto& __state = _M_nfa[__it.first];\n           if (__state._M_opcode == _S_opcode_match\n               && __state._M_matches(*this->_M_current))\n-            if (_M_match_less_than(__it.first, __state._M_next)\n-                && __state._M_next != _S_invalid_state_id)\n-              __next[__state._M_next] = move(__it.second);\n+            if (__state._M_next != _S_invalid_state_id)\n+              if (__next.count(__state._M_next) == 0\n+                  || _M_match_less_than(*__it.second, *__next[__state._M_next]))\n+                __next[__state._M_next] = move(__it.second);\n         }\n       _M_covered = move(__next);\n     }\n \n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_match_less_than(_StateIdT __u, _StateIdT __v) const\n+    _M_match_less_than(const _ResultsVec& __u, const _ResultsVec& __v) const\n     {\n-      if (_M_covered.count(__u) == 0)\n-        return false;\n-      if (_M_covered.count(__v) > 0)\n-        return true;\n       // TODO: Greedy and Non-greedy support\n-      return true;\n+      _GLIBCXX_DEBUG_ASSERT(__u.size() == __v.size());\n+      auto __size = __u.size();\n+      for (auto __i = 0; __i < __size; __i++)\n+        {\n+          auto& __uit = __u[__i], __vit = __v[__i];\n+          if (__uit.matched && !__vit.matched)\n+            return true;\n+          if (!__uit.matched && __vit.matched)\n+            return false;\n+          if (__uit.matched && __vit.matched)\n+            {\n+              // GREEDY\n+              if (__uit.first != __vit.first)\n+                return __uit.first < __vit.first;\n+              if (__uit.second != __vit.second)\n+                return __uit.second > __vit.second;\n+            }\n+        }\n+      return false;\n     }\n \n   template<typename _BiIter, typename _Alloc,\n@@ -265,11 +316,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n         _ExecutorPtr;\n       typedef _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _DFSExecutorT;\n+      typedef _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _BFSExecutorT;\n       auto __p = std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n         (__re._M_automaton);\n       if (__p->_M_has_backref)\n         return _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p, __flags));\n-      return _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p, __flags));\n+      return _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, *__p, __flags));\n     }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "e112db55e4ad54e2b70a3657c067d21415090163", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/cstring_emptygroup.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fcstring_emptygroup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b488e33b66845b5eb1ac0dbff934fc2d8f75890/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fcstring_emptygroup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fcstring_emptygroup.cc?ref=1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-22  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ECMAScript empty-grouping against a C-string.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    regex re(\"()*\\\\1\");\n+    cmatch m;\n+    const char s[] = \"\";\n+    VERIFY( regex_match(s, m, re) );\n+    VERIFY( m.size() == 2 );\n+    VERIFY( m[0].matched );\n+    VERIFY( m[1].matched );\n+  }\n+  {\n+    regex re(\"()*\");\n+    cmatch m;\n+    const char s[] = \"\";\n+    VERIFY( regex_match(s, m, re) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}