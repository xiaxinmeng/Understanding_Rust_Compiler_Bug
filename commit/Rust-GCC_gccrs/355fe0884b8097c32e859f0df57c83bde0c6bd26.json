{"sha": "355fe0884b8097c32e859f0df57c83bde0c6bd26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1ZmUwODg0YjgwOTdjMzJlODU5ZjBkZjU3YzgzYmRlMGM2YmQyNg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde@tbsaunde.org", "date": "2015-09-20T00:52:59Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-09-20T00:52:59Z"}, "message": "switch from gimple to gimple*\n\nThis renames the gimple_statement_base struct to gimple removes the\ntypedef of gimple_statement_base * to gimple, and then adjusts all of\nthe places that use the type.\n\ngcc/ChangeLog:\n\n2015-09-19  Trevor Saunders  <tbsaunde@tbsaunde.org>\n\n\t* coretypes.h (gimple): Change typedef to be a forward\n\tdeclaration.\n\t* gimple.h (gimple_statement_base): rename to gimple.\n\t* (all functions and types using gimple): Adjust.\n\t* *.[ch]: Likewise.\n\ngcc/cp/ChangeLog:\n\n2015-09-19  Trevor Saunders  <tbsaunde@tbsaunde.org>\n\n\t* cp-gimplify.c (gimplify_must_not_throw_expr): Adjust.\n\nFrom-SVN: r227941", "tree": {"sha": "aadb7908b4b80ecaf7e744ca1ae42a59a12b07ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aadb7908b4b80ecaf7e744ca1ae42a59a12b07ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355fe0884b8097c32e859f0df57c83bde0c6bd26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355fe0884b8097c32e859f0df57c83bde0c6bd26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355fe0884b8097c32e859f0df57c83bde0c6bd26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355fe0884b8097c32e859f0df57c83bde0c6bd26/comments", "author": {"login": "tbsaunde", "id": 349840, "node_id": "MDQ6VXNlcjM0OTg0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/349840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbsaunde", "html_url": "https://github.com/tbsaunde", "followers_url": "https://api.github.com/users/tbsaunde/followers", "following_url": "https://api.github.com/users/tbsaunde/following{/other_user}", "gists_url": "https://api.github.com/users/tbsaunde/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbsaunde/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbsaunde/subscriptions", "organizations_url": "https://api.github.com/users/tbsaunde/orgs", "repos_url": "https://api.github.com/users/tbsaunde/repos", "events_url": "https://api.github.com/users/tbsaunde/events{/privacy}", "received_events_url": "https://api.github.com/users/tbsaunde/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4f2a3e4588bbc3691b452d8a2c520e8196b0ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f2a3e4588bbc3691b452d8a2c520e8196b0ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f2a3e4588bbc3691b452d8a2c520e8196b0ef3"}], "stats": {"total": 6416, "additions": 3222, "deletions": 3194}, "files": [{"sha": "86e2c05e31ac94ceb54e499211b03a6bfb94fb53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1,3 +1,11 @@\n+2015-09-19  Trevor Saunders  <tbsaunde@tbsaunde.org>\n+\n+\t* coretypes.h (gimple): Change typedef to be a forward\n+\tdeclaration.\n+\t* gimple.h (gimple_statement_base): rename to gimple.\n+\t* (all functions and types using gimple): Adjust.\n+\t* *.[ch]: Likewise.\n+\n 2015-09-19  Andrew Dixie  <andrewd@gentrack.com>\n \t    David Edelsohn  <dje.gcc@gmail.com>\n "}, {"sha": "05c4ad4739a2b16272e6acb6e8376ad216f49d73", "filename": "gcc/asan.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -862,7 +862,7 @@ get_mem_refs_of_builtin_call (const gcall *call,\n    contains.  */\n \n static bool\n-has_stmt_been_instrumented_p (gimple stmt)\n+has_stmt_been_instrumented_p (gimple *stmt)\n {\n   if (gimple_assign_single_p (stmt))\n     {\n@@ -1591,7 +1591,7 @@ build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n {\n   tree t, uintptr_type = TREE_TYPE (base_addr);\n   tree shadow_type = TREE_TYPE (shadow_ptr_type);\n-  gimple g;\n+  gimple *g;\n \n   t = build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT);\n   g = gimple_build_assign (make_ssa_name (uintptr_type), RSHIFT_EXPR,\n@@ -1627,7 +1627,7 @@ maybe_create_ssa_name (location_t loc, tree base, gimple_stmt_iterator *iter,\n {\n   if (TREE_CODE (base) == SSA_NAME)\n     return base;\n-  gimple g = gimple_build_assign (make_ssa_name (TREE_TYPE (base)),\n+  gimple *g = gimple_build_assign (make_ssa_name (TREE_TYPE (base)),\n \t\t\t\t  TREE_CODE (base), base);\n   gimple_set_location (g, loc);\n   if (before_p)\n@@ -1646,7 +1646,7 @@ maybe_cast_to_ptrmode (location_t loc, tree len, gimple_stmt_iterator *iter,\n {\n   if (ptrofftype_p (len))\n     return len;\n-  gimple g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+  gimple *g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n \t\t\t\t  NOP_EXPR, len);\n   gimple_set_location (g, loc);\n   if (before_p)\n@@ -1682,7 +1682,7 @@ build_check_stmt (location_t loc, tree base, tree len,\n \t\t  bool is_scalar_access, unsigned int align = 0)\n {\n   gimple_stmt_iterator gsi = *iter;\n-  gimple g;\n+  gimple *g;\n \n   gcc_assert (!(size_in_bytes > 0 && !is_non_zero_len));\n \n@@ -1972,7 +1972,7 @@ instrument_builtin_call (gimple_stmt_iterator *iter)\n static bool\n maybe_instrument_assignment (gimple_stmt_iterator *iter)\n {\n-  gimple s = gsi_stmt (*iter);\n+  gimple *s = gsi_stmt (*iter);\n \n   gcc_assert (gimple_assign_single_p (s));\n \n@@ -2016,7 +2016,7 @@ maybe_instrument_assignment (gimple_stmt_iterator *iter)\n static bool\n maybe_instrument_call (gimple_stmt_iterator *iter)\n {\n-  gimple stmt = gsi_stmt (*iter);\n+  gimple *stmt = gsi_stmt (*iter);\n   bool is_builtin = gimple_call_builtin_p (stmt, BUILT_IN_NORMAL);\n \n   if (is_builtin && instrument_builtin_call (iter))\n@@ -2038,7 +2038,7 @@ maybe_instrument_call (gimple_stmt_iterator *iter)\n \t    }\n \t}\n       tree decl = builtin_decl_implicit (BUILT_IN_ASAN_HANDLE_NO_RETURN);\n-      gimple g = gimple_build_call (decl, 0);\n+      gimple *g = gimple_build_call (decl, 0);\n       gimple_set_location (g, gimple_location (stmt));\n       gsi_insert_before (iter, g, GSI_SAME_STMT);\n     }\n@@ -2080,7 +2080,7 @@ transform_statements (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i);)\n \t{\n-\t  gimple s = gsi_stmt (i);\n+\t  gimple *s = gsi_stmt (i);\n \n \t  if (has_stmt_been_instrumented_p (s))\n \t    gsi_next (&i);\n@@ -2533,7 +2533,7 @@ asan_finish_file (void)\n bool\n asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n {\n-  gimple g = gsi_stmt (*iter);\n+  gimple *g = gsi_stmt (*iter);\n   location_t loc = gimple_location (g);\n \n   bool recover_p\n@@ -2555,7 +2555,7 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n   if (use_calls)\n     {\n       /* Instrument using callbacks.  */\n-      gimple g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+      gimple *g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n \t\t\t\t      NOP_EXPR, base);\n       gimple_set_location (g, loc);\n       gsi_insert_before (iter, g, GSI_SAME_STMT);\n@@ -2646,7 +2646,7 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n \t & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n       tree shadow = build_shadow_mem_access (&gsi, loc, base_addr,\n \t\t\t\t\t     shadow_ptr_type);\n-      gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+      gimple *shadow_test = build_assign (NE_EXPR, shadow, 0);\n       gimple_seq seq = NULL;\n       gimple_seq_add_stmt (&seq, shadow_test);\n       /* Aligned (>= 8 bytes) can test just\n@@ -2693,7 +2693,7 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n \n \t  tree shadow = build_shadow_mem_access (&gsi, loc, base_end_addr,\n \t\t\t\t\t\t shadow_ptr_type);\n-\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  gimple *shadow_test = build_assign (NE_EXPR, shadow, 0);\n \t  gimple_seq seq = NULL;\n \t  gimple_seq_add_stmt (&seq, shadow_test);\n \t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,"}, {"sha": "25202c5282dea7f3dae10489d70f02fba211d158", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -125,7 +125,7 @@ typedef std::map<unsigned, gcov_type> icall_target_map;\n \n /* Set of gimple stmts. Used to track if the stmt has already been promoted\n    to direct call.  */\n-typedef std::set<gimple> stmt_set;\n+typedef std::set<gimple *> stmt_set;\n \n /* Represent count info of an inline stack.  */\n struct count_info\n@@ -291,7 +291,7 @@ class autofdo_source_profile\n \n   /* Find count_info for a given gimple STMT. If found, store the count_info\n      in INFO and return true; otherwise return false.  */\n-  bool get_count_info (gimple stmt, count_info *info) const;\n+  bool get_count_info (gimple *stmt, count_info *info) const;\n \n   /* Find total count of the callee of EDGE.  */\n   gcov_type get_callsite_total_count (struct cgraph_edge *edge) const;\n@@ -413,7 +413,7 @@ get_inline_stack (location_t locus, inline_stack *stack)\n    of DECL, The lower 16 bits stores the discriminator.  */\n \n static unsigned\n-get_relative_location_for_stmt (gimple stmt)\n+get_relative_location_for_stmt (gimple *stmt)\n {\n   location_t locus = gimple_location (stmt);\n   if (LOCATION_LOCUS (locus) == UNKNOWN_LOCATION)\n@@ -436,7 +436,7 @@ has_indirect_call (basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) == GIMPLE_CALL && !gimple_call_internal_p (stmt)\n           && (gimple_call_fn (stmt) == NULL\n               || TREE_CODE (gimple_call_fn (stmt)) != FUNCTION_DECL))\n@@ -722,7 +722,7 @@ autofdo_source_profile::get_function_instance_by_decl (tree decl) const\n    in INFO and return true; otherwise return false.  */\n \n bool\n-autofdo_source_profile::get_count_info (gimple stmt, count_info *info) const\n+autofdo_source_profile::get_count_info (gimple *stmt, count_info *info) const\n {\n   if (LOCATION_LOCUS (gimple_location (stmt)) == cfun->function_end_locus)\n     return false;\n@@ -950,7 +950,7 @@ static void\n afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n                     bool transform)\n {\n-  gimple gs = gsi_stmt (*gsi);\n+  gimple *gs = gsi_stmt (*gsi);\n   tree callee;\n \n   if (map.size () == 0)\n@@ -1055,7 +1055,7 @@ afdo_set_bb_count (basic_block bb, const stmt_set &promoted)\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       count_info info;\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (gimple_clobber_p (stmt) || is_gimple_debug (stmt))\n         continue;\n       if (afdo_source_profile->get_count_info (stmt, &info))\n@@ -1236,9 +1236,9 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n   basic_block bb;\n   FOR_ALL_BB_FN (bb, cfun)\n   {\n-    gimple def_stmt;\n+    gimple *def_stmt;\n     tree cmp_rhs, cmp_lhs;\n-    gimple cmp_stmt = last_stmt (bb);\n+    gimple *cmp_stmt = last_stmt (bb);\n     edge e;\n     edge_iterator ei;\n \n@@ -1418,7 +1418,7 @@ afdo_vpt_for_early_inline (stmt_set *promoted_stmts)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n         count_info info;\n-        gimple stmt = gsi_stmt (gsi);\n+\tgimple *stmt = gsi_stmt (gsi);\n         if (afdo_source_profile->get_count_info (stmt, &info))\n           bb_count = MAX (bb_count, info.count);\n       }"}, {"sha": "6e6f33dbd873268e207045bd599a3ee965b6bed7", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -626,7 +626,7 @@ setjmp_call_p (const_tree fndecl)\n /* Return true if STMT is an alloca call.  */\n \n bool\n-gimple_alloca_call_p (const_gimple stmt)\n+gimple_alloca_call_p (const gimple *stmt)\n {\n   tree fndecl;\n "}, {"sha": "c06185975f41b057aa612c8ad2c73daf6b9f1f5b", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);\n extern int setjmp_call_p (const_tree);\n-extern bool gimple_alloca_call_p (const_gimple);\n+extern bool gimple_alloca_call_p (const gimple *);\n extern bool alloca_call_p (const_tree);\n extern bool must_pass_in_stack_var_size (machine_mode, const_tree);\n extern bool must_pass_in_stack_var_size_or_pad (machine_mode, const_tree);"}, {"sha": "20348d9f02619b4ee80ff5912c1acb8b3f1b795c", "filename": "gcc/ccmp.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -79,11 +79,11 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Check whether G is a potential conditional compare candidate.  */\n static bool\n-ccmp_candidate_p (gimple g)\n+ccmp_candidate_p (gimple *g)\n {\n   tree rhs = gimple_assign_rhs_to_tree (g);\n   tree lhs, op0, op1;\n-  gimple gs0, gs1;\n+  gimple *gs0, *gs1;\n   enum tree_code tcode, tcode0, tcode1;\n   tcode = TREE_CODE (rhs);\n \n@@ -135,7 +135,7 @@ ccmp_candidate_p (gimple g)\n    PREP_SEQ returns all insns to prepare opearands for compare.\n    GEN_SEQ returnss all compare insns.  */\n static rtx\n-expand_ccmp_next (gimple g, enum tree_code code, rtx prev,\n+expand_ccmp_next (gimple *g, enum tree_code code, rtx prev,\n \t\t  rtx *prep_seq, rtx *gen_seq)\n {\n   enum rtx_code rcode;\n@@ -163,12 +163,12 @@ expand_ccmp_next (gimple g, enum tree_code code, rtx prev,\n    PREP_SEQ returns all insns to prepare opearand.\n    GEN_SEQ returns all compare insns.  */\n static rtx\n-expand_ccmp_expr_1 (gimple g, rtx *prep_seq, rtx *gen_seq)\n+expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n {\n   tree exp = gimple_assign_rhs_to_tree (g);\n   enum tree_code code = TREE_CODE (exp);\n-  gimple gs0 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 0));\n-  gimple gs1 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 1));\n+  gimple *gs0 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 0));\n+  gimple *gs1 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 1));\n   rtx tmp;\n   enum tree_code code0 = gimple_assign_rhs_code (gs0);\n   enum tree_code code1 = gimple_assign_rhs_code (gs1);\n@@ -230,7 +230,7 @@ expand_ccmp_expr_1 (gimple g, rtx *prep_seq, rtx *gen_seq)\n    Return NULL_RTX if G is not a legal candidate or expand fail.\n    Otherwise return the target.  */\n rtx\n-expand_ccmp_expr (gimple g)\n+expand_ccmp_expr (gimple *g)\n {\n   rtx_insn *last;\n   rtx tmp;"}, {"sha": "c00eb6dabc86a6cd61bc39777f63a5cfe03c1fd0", "filename": "gcc/ccmp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fccmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fccmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -20,6 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CCMP_H\n #define GCC_CCMP_H\n \n-extern rtx expand_ccmp_expr (gimple);\n+extern rtx expand_ccmp_expr (gimple *);\n \n #endif  /* GCC_CCMP_H  */"}, {"sha": "6c9284ffc8cb55f5faf047153839b1c8c5d875f6", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -93,7 +93,7 @@ struct ssaexpand SA;\n \n /* This variable holds the currently expanded gimple statement for purposes\n    of comminucating the profile info to the builtin expanders.  */\n-gimple currently_expanding_gimple_stmt;\n+gimple *currently_expanding_gimple_stmt;\n \n static rtx expand_debug_expr (tree);\n \n@@ -103,7 +103,7 @@ static bool defer_stack_allocation (tree, bool);\n    statement STMT.  */\n \n tree\n-gimple_assign_rhs_to_tree (gimple stmt)\n+gimple_assign_rhs_to_tree (gimple *stmt)\n {\n   tree t;\n   enum gimple_rhs_class grhs_class;\n@@ -522,7 +522,7 @@ stack_var_conflict_p (size_t x, size_t y)\n    enter its partition number into bitmap DATA.  */\n \n static bool\n-visit_op (gimple, tree op, tree, void *data)\n+visit_op (gimple *, tree op, tree, void *data)\n {\n   bitmap active = (bitmap)data;\n   op = get_base_address (op);\n@@ -542,7 +542,7 @@ visit_op (gimple, tree op, tree, void *data)\n    from bitmap DATA.  */\n \n static bool\n-visit_conflict (gimple, tree op, tree, void *data)\n+visit_conflict (gimple *, tree op, tree, void *data)\n {\n   bitmap active = (bitmap)data;\n   op = get_base_address (op);\n@@ -585,12 +585,12 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       walk_stmt_load_store_addr_ops (stmt, work, NULL, NULL, visit);\n     }\n   for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       if (gimple_clobber_p (stmt))\n \t{\n@@ -1996,7 +1996,7 @@ stack_protect_return_slot_p ()\n     for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n \t !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tgimple stmt = gsi_stmt (gsi);\n+\tgimple *stmt = gsi_stmt (gsi);\n \t/* This assumes that calls to internal-only functions never\n \t   use a return slot.  */\n \tif (is_gimple_call (stmt)\n@@ -2280,7 +2280,7 @@ expand_used_vars (void)\n    generated for STMT should have been appended.  */\n \n static void\n-maybe_dump_rtl_for_gimple_stmt (gimple stmt, rtx_insn *since)\n+maybe_dump_rtl_for_gimple_stmt (gimple *stmt, rtx_insn *since)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2423,7 +2423,7 @@ expand_gimple_cond (basic_block bb, gcond *stmt)\n \t      && integer_onep (op1)))\n       && bitmap_bit_p (SA.values, SSA_NAME_VERSION (op0)))\n     {\n-      gimple second = SSA_NAME_DEF_STMT (op0);\n+      gimple *second = SSA_NAME_DEF_STMT (op0);\n       if (gimple_code (second) == GIMPLE_ASSIGN)\n \t{\n \t  enum tree_code code2 = gimple_assign_rhs_code (second);\n@@ -2531,7 +2531,7 @@ expand_gimple_cond (basic_block bb, gcond *stmt)\n /* Mark all calls that can have a transaction restart.  */\n \n static void\n-mark_transaction_restart_calls (gimple stmt)\n+mark_transaction_restart_calls (gimple *stmt)\n {\n   struct tm_restart_node dummy;\n   tm_restart_node **slot;\n@@ -2595,7 +2595,7 @@ expand_call_stmt (gcall *stmt)\n   for (i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n       tree arg = gimple_call_arg (stmt, i);\n-      gimple def;\n+      gimple *def;\n       /* TER addresses into arguments of builtin functions so we have a\n \t chance to infer more correct alignment information.  See PR39954.  */\n       if (builtin_p\n@@ -3503,7 +3503,7 @@ expand_return (tree retval, tree bounds)\n    is no tailcalls and no GIMPLE_COND.  */\n \n static void\n-expand_gimple_stmt_1 (gimple stmt)\n+expand_gimple_stmt_1 (gimple *stmt)\n {\n   tree op0;\n \n@@ -3679,7 +3679,7 @@ expand_gimple_stmt_1 (gimple stmt)\n    location for diagnostics.  */\n \n static rtx_insn *\n-expand_gimple_stmt (gimple stmt)\n+expand_gimple_stmt (gimple *stmt)\n {\n   location_t saved_location = input_location;\n   rtx_insn *last = get_last_insn ();\n@@ -3989,7 +3989,7 @@ static hash_map<tree, tree> *deep_ter_debug_map;\n /* Split too deep TER chains for debug stmts using debug temporaries.  */\n \n static void\n-avoid_deep_ter_for_debug (gimple stmt, int depth)\n+avoid_deep_ter_for_debug (gimple *stmt, int depth)\n {\n   use_operand_p use_p;\n   ssa_op_iter iter;\n@@ -3998,7 +3998,7 @@ avoid_deep_ter_for_debug (gimple stmt, int depth)\n       tree use = USE_FROM_PTR (use_p);\n       if (TREE_CODE (use) != SSA_NAME || SSA_NAME_IS_DEFAULT_DEF (use))\n \tcontinue;\n-      gimple g = get_gimple_for_ssa_name (use);\n+      gimple *g = get_gimple_for_ssa_name (use);\n       if (g == NULL)\n \tcontinue;\n       if (depth > 6 && !stmt_ends_bb_p (g))\n@@ -4010,7 +4010,7 @@ avoid_deep_ter_for_debug (gimple stmt, int depth)\n \t  if (vexpr != NULL)\n \t    continue;\n \t  vexpr = make_node (DEBUG_EXPR_DECL);\n-\t  gimple def_temp = gimple_build_debug_bind (vexpr, use, g);\n+\t  gimple *def_temp = gimple_build_debug_bind (vexpr, use, g);\n \t  DECL_ARTIFICIAL (vexpr) = 1;\n \t  TREE_TYPE (vexpr) = TREE_TYPE (use);\n \t  DECL_MODE (vexpr) = TYPE_MODE (TREE_TYPE (use));\n@@ -4929,7 +4929,7 @@ expand_debug_expr (tree exp)\n \n     case SSA_NAME:\n       {\n-\tgimple g = get_gimple_for_ssa_name (exp);\n+\tgimple *g = get_gimple_for_ssa_name (exp);\n \tif (g)\n \t  {\n \t    tree t = NULL_TREE;\n@@ -5303,12 +5303,12 @@ reorder_operands (basic_block bb)\n   unsigned int i = 0, n = 0;\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n-  gimple stmt;\n+  gimple *stmt;\n   bool swap;\n   tree op0, op1;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n-  gimple def0, def1;\n+  gimple *def0, *def1;\n \n   /* Compute cost of each statement using estimate_num_insns.  */\n   stmts = bb_seq (bb);\n@@ -5330,7 +5330,7 @@ reorder_operands (basic_block bb)\n       FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t{\n \t  tree use = USE_FROM_PTR (use_p);\n-\t  gimple def_stmt;\n+\t  gimple *def_stmt;\n \t  if (TREE_CODE (use) != SSA_NAME)\n \t    continue;\n \t  def_stmt = get_gimple_for_ssa_name (use);\n@@ -5379,7 +5379,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n {\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n-  gimple stmt = NULL;\n+  gimple *stmt = NULL;\n   rtx_note *note;\n   rtx_insn *last;\n   edge e;\n@@ -5494,7 +5494,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t{\n \t  ssa_op_iter iter;\n \t  tree op;\n-\t  gimple def;\n+\t  gimple *def;\n \n \t  location_t sloc = curr_insn_location ();\n \n@@ -5523,7 +5523,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t\t       instructions.  Generate a debug temporary, and\n \t\t       replace all uses of OP in debug insns with that\n \t\t       temporary.  */\n-\t\t    gimple debugstmt;\n+\t\t    gimple *debugstmt;\n \t\t    tree value = gimple_assign_rhs_to_tree (def);\n \t\t    tree vexpr = make_node (DEBUG_EXPR_DECL);\n \t\t    rtx val;\n@@ -5946,7 +5946,7 @@ discover_nonconstant_array_refs (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tgimple stmt = gsi_stmt (gsi);\n+\tgimple *stmt = gsi_stmt (gsi);\n \tif (!is_gimple_debug (stmt))\n \t  walk_gimple_op (stmt, discover_nonconstant_array_refs_r, NULL);\n       }"}, {"sha": "ff7f4befcb199b41dcc87ac89eb35cb28e446d95", "filename": "gcc/cfgexpand.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfgexpand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfgexpand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CFGEXPAND_H\n #define GCC_CFGEXPAND_H\n \n-extern tree gimple_assign_rhs_to_tree (gimple);\n+extern tree gimple_assign_rhs_to_tree (gimple *);\n extern HOST_WIDE_INT estimated_stack_frame_size (struct cgraph_node *);\n extern bool parm_in_stack_slot_p (tree);\n extern rtx get_rtl_for_parm_ssa_default_def (tree var);"}, {"sha": "0cd8e6220588959baa5a7c42076663c4592f0188", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -533,7 +533,7 @@ split_block_1 (basic_block bb, void *i)\n }\n \n edge\n-split_block (basic_block bb, gimple i)\n+split_block (basic_block bb, gimple *i)\n {\n   return split_block_1 (bb, i);\n }"}, {"sha": "0d25cf627fc21ffab6b268a5cfebd2944b8cf616", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -197,7 +197,7 @@ extern bool can_remove_branch_p (const_edge);\n extern void remove_branch (edge);\n extern void remove_edge (edge);\n extern edge split_block (basic_block, rtx);\n-extern edge split_block (basic_block, gimple);\n+extern edge split_block (basic_block, gimple *);\n extern edge split_block_after_labels (basic_block);\n extern bool move_block_after (basic_block, basic_block);\n extern void delete_basic_block (basic_block);"}, {"sha": "07b070bcf3e42401d041ef8beb4e9815fb702c9c", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -48,7 +48,7 @@ enum iv_extend_code\n \n struct GTY ((chain_next (\"%h.next\"))) nb_iter_bound {\n   /* The statement STMT is executed at most ...  */\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* ... BOUND + 1 times (BOUND must be an unsigned constant).\n      The + 1 is added for the following reasons:"}, {"sha": "1a64d7892eedacaac0026783c9b9bfdf33920bc2", "filename": "gcc/cgraph.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -670,7 +670,7 @@ cgraph_edge_hasher::hash (cgraph_edge *e)\n /* Returns a hash value for X (which really is a cgraph_edge).  */\n \n hashval_t\n-cgraph_edge_hasher::hash (gimple call_stmt)\n+cgraph_edge_hasher::hash (gimple *call_stmt)\n {\n   /* This is a really poor hash function, but it is what htab_hash_pointer\n      uses.  */\n@@ -680,7 +680,7 @@ cgraph_edge_hasher::hash (gimple call_stmt)\n /* Return nonzero if the call_stmt of cgraph_edge X is stmt *Y.  */\n \n inline bool\n-cgraph_edge_hasher::equal (cgraph_edge *x, gimple y)\n+cgraph_edge_hasher::equal (cgraph_edge *x, gimple *y)\n {\n   return x->call_stmt == y;\n }\n@@ -690,7 +690,7 @@ cgraph_edge_hasher::equal (cgraph_edge *x, gimple y)\n static inline void\n cgraph_update_edge_in_call_site_hash (cgraph_edge *e)\n {\n-  gimple call = e->call_stmt;\n+  gimple *call = e->call_stmt;\n   *e->caller->call_site_hash->find_slot_with_hash\n       (call, cgraph_edge_hasher::hash (call), INSERT) = e;\n }\n@@ -721,7 +721,7 @@ cgraph_add_edge_to_call_site_hash (cgraph_edge *e)\n    CALL_STMT.  */\n \n cgraph_edge *\n-cgraph_node::get_edge (gimple call_stmt)\n+cgraph_node::get_edge (gimple *call_stmt)\n {\n   cgraph_edge *e, *e2;\n   int n = 0;\n@@ -1272,7 +1272,7 @@ cgraph_edge::make_direct (cgraph_node *callee)\n /* If necessary, change the function declaration in the call statement\n    associated with E so that it corresponds to the edge callee.  */\n \n-gimple\n+gimple *\n cgraph_edge::redirect_call_stmt_to_callee (void)\n {\n   cgraph_edge *e = this;\n@@ -1475,7 +1475,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t\t\t\t\tTREE_TYPE (lhs), NULL);\n \t  var = get_or_create_ssa_default_def\n \t\t  (DECL_STRUCT_FUNCTION (e->caller->decl), var);\n-\t  gimple set_stmt = gimple_build_assign (lhs, var);\n+\t  gimple *set_stmt = gimple_build_assign (lhs, var);\n           gsi = gsi_for_stmt (new_stmt);\n \t  gsi_insert_before_without_update (&gsi, set_stmt, GSI_SAME_STMT);\n \t  update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), set_stmt);\n@@ -1512,8 +1512,8 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \n static void\n cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n-\t\t\t\t\tgimple old_stmt, tree old_call,\n-\t\t\t\t\tgimple new_stmt)\n+\t\t\t\t\tgimple *old_stmt, tree old_call,\n+\t\t\t\t\tgimple *new_stmt)\n {\n   tree new_call = (new_stmt && is_gimple_call (new_stmt))\n \t\t  ? gimple_call_fndecl (new_stmt) : 0;\n@@ -1596,7 +1596,8 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n    of OLD_STMT before it was updated (updating can happen inplace).  */\n \n void\n-cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_stmt)\n+cgraph_update_edges_for_call_stmt (gimple *old_stmt, tree old_decl,\n+\t\t\t\t   gimple *new_stmt)\n {\n   cgraph_node *orig = cgraph_node::get (cfun->decl);\n   cgraph_node *node;\n@@ -2695,7 +2696,7 @@ cgraph_edge::verify_count_and_frequency ()\n \n /* Switch to THIS_CFUN if needed and print STMT to stderr.  */\n static void\n-cgraph_debug_gimple_stmt (function *this_cfun, gimple stmt)\n+cgraph_debug_gimple_stmt (function *this_cfun, gimple *stmt)\n {\n   bool fndecl_was_null = false;\n   /* debug_gimple_stmt needs correct cfun */\n@@ -3084,7 +3085,7 @@ cgraph_node::verify_node (void)\n     {\n       if (this_cfun->cfg)\n \t{\n-\t  hash_set<gimple> stmts;\n+\t  hash_set<gimple *> stmts;\n \t  int i;\n \t  ipa_ref *ref = NULL;\n \n@@ -3099,7 +3100,7 @@ cgraph_node::verify_node (void)\n \t\t   !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n \t\t{\n-\t\t  gimple stmt = gsi_stmt (gsi);\n+\t\t  gimple *stmt = gsi_stmt (gsi);\n \t\t  stmts.add (stmt);\n \t\t  if (is_gimple_call (stmt))\n \t\t    {\n@@ -3356,7 +3357,7 @@ cgraph_node::get_fun (void)\n    return false.  */\n \n static bool\n-gimple_check_call_args (gimple stmt, tree fndecl, bool args_count_match)\n+gimple_check_call_args (gimple *stmt, tree fndecl, bool args_count_match)\n {\n   tree parms, p;\n   unsigned int i, nargs;\n@@ -3431,7 +3432,7 @@ gimple_check_call_args (gimple stmt, tree fndecl, bool args_count_match)\n    If we cannot verify this or there is a mismatch, return false.  */\n \n bool\n-gimple_check_call_matching_types (gimple call_stmt, tree callee,\n+gimple_check_call_matching_types (gimple *call_stmt, tree callee,\n \t\t\t\t  bool args_count_match)\n {\n   tree lhs;"}, {"sha": "607aef7c0ed62edefeee33b8e0a7d77ac5c3484e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -128,14 +128,14 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n      of the use and STMT the statement (if it exists).  */\n   ipa_ref *create_reference (symtab_node *referred_node,\n-\t\t\t     enum ipa_ref_use use_type, gimple stmt);\n+\t\t\t     enum ipa_ref_use use_type, gimple *stmt);\n \n   /* If VAL is a reference to a function or a variable, add a reference from\n      this symtab_node to the corresponding symbol table node.  USE_TYPE specify\n      type of the use and STMT the statement (if it exists).  Return the new\n      reference or NULL if none was created.  */\n   ipa_ref *maybe_create_reference (tree val, enum ipa_ref_use use_type,\n-\t\t\t\t   gimple stmt);\n+\t\t\t\t   gimple *stmt);\n \n   /* Clone all references from symtab NODE to this symtab_node.  */\n   void clone_references (symtab_node *node);\n@@ -147,15 +147,15 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   void clone_referring (symtab_node *node);\n \n   /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n-  ipa_ref *clone_reference (ipa_ref *ref, gimple stmt);\n+  ipa_ref *clone_reference (ipa_ref *ref, gimple *stmt);\n \n   /* Find the structure describing a reference to REFERRED_NODE\n      and associated with statement STMT.  */\n-  ipa_ref *find_reference (symtab_node *referred_node, gimple stmt,\n+  ipa_ref *find_reference (symtab_node *referred_node, gimple *stmt,\n \t\t\t   unsigned int lto_stmt_uid);\n \n   /* Remove all references that are associated with statement STMT.  */\n-  void remove_stmt_references (gimple stmt);\n+  void remove_stmt_references (gimple *stmt);\n \n   /* Remove all stmt references in non-speculative references.\n      Those are not maintained during inlining & clonning.\n@@ -774,11 +774,11 @@ struct cgraph_edge;\n \n struct cgraph_edge_hasher : ggc_ptr_hash<cgraph_edge>\n {\n-  typedef gimple compare_type;\n+  typedef gimple *compare_type;\n \n   static hashval_t hash (cgraph_edge *);\n-  static hashval_t hash (gimple);\n-  static bool equal (cgraph_edge *, gimple);\n+  static hashval_t hash (gimple *);\n+  static bool equal (cgraph_edge *, gimple *);\n };\n \n /* The cgraph data structure.\n@@ -794,14 +794,14 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Record all references from cgraph_node that are taken\n      in statement STMT.  */\n-  void record_stmt_references (gimple stmt);\n+  void record_stmt_references (gimple *stmt);\n \n   /* Like cgraph_set_call_stmt but walk the clone tree and update all\n      clones sharing the same function body.\n      When WHOLE_SPECULATIVE_EDGES is true, all three components of\n      speculative edge gets updated.  Otherwise we update only direct\n      call.  */\n-  void set_call_stmt_including_clones (gimple old_stmt, gcall *new_stmt,\n+  void set_call_stmt_including_clones (gimple *old_stmt, gcall *new_stmt,\n \t\t\t\t       bool update_speculative = true);\n \n   /* Walk the alias chain to return the function cgraph_node is alias of.\n@@ -1007,14 +1007,14 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n    same function body.  If clones already have edge for OLD_STMT; only\n    update the edge same way as cgraph_set_call_stmt_including_clones does.  */\n   void create_edge_including_clones (cgraph_node *callee,\n-\t\t\t\t     gimple old_stmt, gcall *stmt,\n+\t\t\t\t     gimple *old_stmt, gcall *stmt,\n \t\t\t\t     gcov_type count,\n \t\t\t\t     int freq,\n \t\t\t\t     cgraph_inline_failed_t reason);\n \n   /* Return the callgraph edge representing the GIMPLE_CALL statement\n      CALL_STMT.  */\n-  cgraph_edge *get_edge (gimple call_stmt);\n+  cgraph_edge *get_edge (gimple *call_stmt);\n \n   /* Collect all callers of cgraph_node and its aliases that are known to lead\n      to NODE (i.e. are not overwritable).  */\n@@ -1391,12 +1391,12 @@ class GTY(()) ipa_polymorphic_call_context {\n   /* Build context for pointer REF contained in FNDECL at statement STMT.\n      if INSTANCE is non-NULL, return pointer to the object described by\n      the context.  */\n-  ipa_polymorphic_call_context (tree fndecl, tree ref, gimple stmt,\n+  ipa_polymorphic_call_context (tree fndecl, tree ref, gimple *stmt,\n \t\t\t\ttree *instance = NULL);\n \n   /* Look for vtable stores or constructor calls to work out dynamic type\n      of memory location.  */\n-  bool get_dynamic_type (tree, tree, tree, gimple);\n+  bool get_dynamic_type (tree, tree, tree, gimple *);\n \n   /* Make context non-speculative.  */\n   void clear_speculation ();\n@@ -1537,7 +1537,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n \n   /* If necessary, change the function declaration in the call statement\n      associated with the edge so that it corresponds to the edge callee.  */\n-  gimple redirect_call_stmt_to_callee (void);\n+  gimple *redirect_call_stmt_to_callee (void);\n \n   /* Create clone of edge in the node N represented\n      by CALL_EXPR the callgraph.  */\n@@ -2177,13 +2177,13 @@ void cgraph_c_finalize (void);\n void release_function_body (tree);\n cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n \n-void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n+void cgraph_update_edges_for_call_stmt (gimple *, tree, gimple *);\n bool cgraph_function_possibly_inlined_p (tree);\n \n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n \n-extern bool gimple_check_call_matching_types (gimple, tree, bool);\n+extern bool gimple_check_call_matching_types (gimple *, tree, bool);\n \n /* In cgraphunit.c  */\n void cgraphunit_c_finalize (void);"}, {"sha": "33b01be83acfdd456514aaaf9cbb66ed1664ca86", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -220,7 +220,7 @@ compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n /* Mark address taken in STMT.  */\n \n static bool\n-mark_address (gimple stmt, tree addr, tree, void *data)\n+mark_address (gimple *stmt, tree addr, tree, void *data)\n {\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n@@ -243,7 +243,7 @@ mark_address (gimple stmt, tree addr, tree, void *data)\n /* Mark load of T.  */\n \n static bool\n-mark_load (gimple stmt, tree t, tree, void *data)\n+mark_load (gimple *stmt, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n   if (t && TREE_CODE (t) == FUNCTION_DECL)\n@@ -267,7 +267,7 @@ mark_load (gimple stmt, tree t, tree, void *data)\n /* Mark store of T.  */\n \n static bool\n-mark_store (gimple stmt, tree t, tree, void *data)\n+mark_store (gimple *stmt, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n   if (t && TREE_CODE (t) == VAR_DECL\n@@ -283,7 +283,7 @@ mark_store (gimple stmt, tree t, tree, void *data)\n /* Record all references from cgraph_node that are taken in statement STMT.  */\n \n void\n-cgraph_node::record_stmt_references (gimple stmt)\n+cgraph_node::record_stmt_references (gimple *stmt)\n {\n   walk_stmt_load_store_addr_ops (stmt, this, mark_load, mark_store,\n \t\t\t\t mark_address);\n@@ -334,7 +334,7 @@ pass_build_cgraph_edges::execute (function *fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree decl;\n \n \t  if (is_gimple_debug (stmt))\n@@ -432,7 +432,7 @@ cgraph_edge::rebuild_edges (void)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree decl;\n \n \t  if (gcall *call_stmt = dyn_cast <gcall *> (stmt))"}, {"sha": "e51431c4b68968dfd2f1ddf4e550fb9cdc4afc0a", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -724,7 +724,7 @@ cgraph_node::find_replacement (void)\n    call.  */\n \n void\n-cgraph_node::set_call_stmt_including_clones (gimple old_stmt,\n+cgraph_node::set_call_stmt_including_clones (gimple *old_stmt,\n \t\t\t\t\t     gcall *new_stmt,\n \t\t\t\t\t     bool update_speculative)\n {\n@@ -780,7 +780,7 @@ cgraph_node::set_call_stmt_including_clones (gimple old_stmt,\n \n void\n cgraph_node::create_edge_including_clones (cgraph_node *callee,\n-\t\t\t\t\t   gimple old_stmt, gcall *stmt,\n+\t\t\t\t\t   gimple *old_stmt, gcall *stmt,\n \t\t\t\t\t   gcov_type count,\n \t\t\t\t\t   int freq,\n \t\t\t\t\t   cgraph_inline_failed_t reason)"}, {"sha": "04a4d3f110088adcd86b50c60618a1a4725fa233", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1764,7 +1764,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t      {\n \t\ttmp = create_tmp_reg (TYPE_MAIN_VARIANT\n \t\t\t\t      (TREE_TYPE (arg)), \"arg\");\n-\t\tgimple stmt = gimple_build_assign (tmp, arg);\n+\t\tgimple *stmt = gimple_build_assign (tmp, arg);\n \t\tgsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n \t      }\n \t    vargs.quick_push (tmp);\n@@ -1808,7 +1808,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \n \t      if (TREE_CODE (TREE_TYPE (restmp)) == POINTER_TYPE)\n \t\t{\n-\t\t  gimple stmt;\n+\t\t  gimple *stmt;\n \t\t  edge e;\n \t\t  /* If the return type is a pointer, we need to\n \t\t     protect against NULL.  We know there will be an\n@@ -1854,7 +1854,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t\t\t     fixed_offset, virtual_offset);\n \t      if (true_label)\n \t\t{\n-\t\t  gimple stmt;\n+\t\t  gimple *stmt;\n \t\t  bsi = gsi_last_bb (else_bb);\n \t\t  stmt = gimple_build_assign (restmp,\n \t\t\t\t\t      build_zero_cst (TREE_TYPE (restmp)));"}, {"sha": "4ed2a8b6cb0be534065ec833942368fadb86451b", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1371,10 +1371,10 @@ bool\n aarch64_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n {\n   bool changed = false;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree call = gimple_call_fn (stmt);\n   tree fndecl;\n-  gimple new_stmt = NULL;\n+  gimple *new_stmt = NULL;\n \n   if (call)\n     {"}, {"sha": "eb2ae5f45eead18530bcd9363b9d34bc1381b32f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -5850,10 +5850,10 @@ alpha_build_builtin_va_list (void)\n /* Helper function for alpha_stdarg_optimize_hook.  Skip over casts\n    and constant additions.  */\n \n-static gimple\n+static gimple *\n va_list_skip_additions (tree lhs)\n {\n-  gimple stmt;\n+  gimple  *stmt;\n \n   for (;;)\n     {\n@@ -5900,11 +5900,11 @@ va_list_skip_additions (tree lhs)\n    current statement.  */\n \n static bool\n-alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n+alpha_stdarg_optimize_hook (struct stdarg_info *si, const gimple *stmt)\n {\n   tree base, offset, rhs;\n   int offset_arg = 1;\n-  gimple base_stmt;\n+  gimple *base_stmt;\n \n   if (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n       != GIMPLE_SINGLE_RHS)\n@@ -5961,13 +5961,13 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n   offset = gimple_op (stmt, 1 + offset_arg);\n   if (TREE_CODE (offset) == SSA_NAME)\n     {\n-      gimple offset_stmt = va_list_skip_additions (offset);\n+      gimple *offset_stmt = va_list_skip_additions (offset);\n \n       if (offset_stmt\n \t  && gimple_code (offset_stmt) == GIMPLE_PHI)\n \t{\n \t  HOST_WIDE_INT sub;\n-\t  gimple arg1_stmt, arg2_stmt;\n+\t  gimple *arg1_stmt, *arg2_stmt;\n \t  tree arg1, arg2;\n \t  enum tree_code code1, code2;\n \n@@ -5992,7 +5992,7 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n \t  else if (code2 == COMPONENT_REF\n \t\t   && (code1 == MINUS_EXPR || code1 == PLUS_EXPR))\n \t    {\n-\t      gimple tem = arg1_stmt;\n+\t      gimple *tem = arg1_stmt;\n \t      code2 = code1;\n \t      arg1_stmt = arg2_stmt;\n \t      arg2_stmt = tem;\n@@ -7088,9 +7088,9 @@ bool\n alpha_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n {\n   bool changed = false;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree call = gimple_call_fn (stmt);\n-  gimple new_stmt = NULL;\n+  gimple *new_stmt = NULL;\n \n   if (call)\n     {"}, {"sha": "d547cfd108a7729c548f52d4b7040409b545c335", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -34456,11 +34456,11 @@ static basic_block\n add_condition_to_bb (tree function_decl, tree version_decl,\n \t\t     tree predicate_chain, basic_block new_bb)\n {\n-  gimple return_stmt;\n+  gimple *return_stmt;\n   tree convert_expr, result_var;\n-  gimple convert_stmt;\n-  gimple call_cond_stmt;\n-  gimple if_else_stmt;\n+  gimple *convert_stmt;\n+  gimple *call_cond_stmt;\n+  gimple *if_else_stmt;\n \n   basic_block bb1, bb2, bb3;\n   edge e12, e23;\n@@ -34511,7 +34511,7 @@ add_condition_to_bb (tree function_decl, tree version_decl,\n         and_expr_var = cond_var;\n       else\n \t{\n-\t  gimple assign_stmt;\n+\t  gimple *assign_stmt;\n \t  /* Use MIN_EXPR to check if any integer is zero?.\n \t     and_expr_var = min_expr <cond_var, and_expr_var>  */\n \t  assign_stmt = gimple_build_assign (and_expr_var,\n@@ -34878,7 +34878,7 @@ dispatch_function_versions (tree dispatch_decl,\n \t\t\t    basic_block *empty_bb)\n {\n   tree default_decl;\n-  gimple ifunc_cpu_init_stmt;\n+  gimple *ifunc_cpu_init_stmt;\n   gimple_seq gseq;\n   int ix;\n   tree ele;\n@@ -40074,7 +40074,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t\t as that is a cheaper way to load all ones into\n \t\t a register than having to load a constant from\n \t\t memory.  */\n-\t      gimple def_stmt = SSA_NAME_DEF_STMT (arg3);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg3);\n \t      if (is_gimple_call (def_stmt))\n \t\t{\n \t\t  tree fndecl = gimple_call_fndecl (def_stmt);"}, {"sha": "5897ea82b8a7e7d8e947bf1e2bc03e7ac1896fd2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -4676,7 +4676,7 @@ rs6000_density_test (rs6000_cost_data *data)\n \n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n@@ -11480,7 +11480,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   int align;\n   tree ptrtype = build_pointer_type_for_mode (type, ptr_mode, true);\n   int regalign = 0;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (pass_by_reference (NULL, TYPE_MODE (type), type, false))\n     {"}, {"sha": "7b3df54ca3f91a738d16fc305ed7f930ffd24ab2", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -82,9 +82,8 @@ typedef const struct hwivec_def *const_hwivec;\n union tree_node;\n typedef union tree_node *tree;\n typedef const union tree_node *const_tree;\n-typedef struct gimple_statement_base *gimple;\n-typedef const struct gimple_statement_base *const_gimple;\n-typedef gimple gimple_seq;\n+struct gimple;\n+typedef gimple *gimple_seq;\n struct gimple_stmt_iterator;\n \n /* Forward decls for leaf gimple subclasses (for individual gimple codes)."}, {"sha": "ab71f92d5019888c4b5c5b769bc90edfd70e6cbc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1,3 +1,7 @@\n+2015-09-19  Trevor Saunders  <tbsaunde@tbsaunde.org>\n+\n+\t* cp-gimplify.c (gimplify_must_not_throw_expr): Adjust.\n+\n 2015-09-18  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement nested namespace definitions."}, {"sha": "32a3a89cb042783eb2776e20a962f71dcb8d6420", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -518,7 +518,7 @@ gimplify_must_not_throw_expr (tree *expr_p, gimple_seq *pre_p)\n   tree body = TREE_OPERAND (stmt, 0);\n   gimple_seq try_ = NULL;\n   gimple_seq catch_ = NULL;\n-  gimple mnt;\n+  gimple *mnt;\n \n   gimplify_and_add (body, &try_);\n   mnt = gimple_build_eh_must_not_throw (terminate_node);"}, {"sha": "e4c4748731e1c4910a33c53ce2276b2b66b7f702", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -343,7 +343,7 @@ dump_loc (int dump_kind, FILE *dfile, source_location loc)\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n \n void\n-dump_gimple_stmt (int dump_kind, int extra_dump_flags, gimple gs, int spc)\n+dump_gimple_stmt (int dump_kind, int extra_dump_flags, gimple *gs, int spc)\n {\n   if (dump_file && (dump_kind & pflags))\n     print_gimple_stmt (dump_file, gs, spc, dump_flags | extra_dump_flags);\n@@ -356,7 +356,7 @@ dump_gimple_stmt (int dump_kind, int extra_dump_flags, gimple gs, int spc)\n \n void\n dump_gimple_stmt_loc (int dump_kind, source_location loc, int extra_dump_flags,\n-                      gimple gs, int spc)\n+\t\t      gimple *gs, int spc)\n {\n   if (dump_file && (dump_kind & pflags))\n     {"}, {"sha": "5f30077c22e99ad8292e2a076857cc0a6a49744a", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -133,8 +133,8 @@ extern void dump_printf_loc (int, source_location,\n extern void dump_basic_block (int, basic_block, int);\n extern void dump_generic_expr_loc (int, source_location, int, tree);\n extern void dump_generic_expr (int, int, tree);\n-extern void dump_gimple_stmt_loc (int, source_location, int, gimple, int);\n-extern void dump_gimple_stmt (int, int, gimple, int);\n+extern void dump_gimple_stmt_loc (int, source_location, int, gimple *, int);\n+extern void dump_gimple_stmt (int, int, gimple *, int);\n extern void print_combine_total_stats (void);\n extern bool enable_rtl_dump_file (void);\n "}, {"sha": "fed18eeb2733a455c7b81606bea748272c2029e4", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -3138,12 +3138,12 @@ output_function_exception_table (const char *fnname)\n }\n \n void\n-set_eh_throw_stmt_table (function *fun, hash_map<gimple, int> *table)\n+set_eh_throw_stmt_table (function *fun, hash_map<gimple *, int> *table)\n {\n   fun->eh->throw_stmt_table = table;\n }\n \n-hash_map<gimple, int> *\n+hash_map<gimple *, int> *\n get_eh_throw_stmt_table (struct function *fun)\n {\n   return fun->eh->throw_stmt_table;"}, {"sha": "270275e7f3535746435f6b2a6ce823ccda594b0c", "filename": "gcc/except.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -201,7 +201,7 @@ struct GTY(()) eh_status\n \n   /* At the gimple level, a mapping from gimple statement to landing pad\n      or must-not-throw region.  See record_stmt_eh_region.  */\n-  hash_map<gimple, int> *GTY(()) throw_stmt_table;\n+  hash_map<gimple *, int> *GTY(()) throw_stmt_table;\n \n   /* All of the runtime type data used by the function.  These objects\n      are emitted to the lang-specific-data-area for the function.  */\n@@ -285,12 +285,12 @@ extern eh_landing_pad get_eh_landing_pad_from_rtx (const_rtx);\n extern void finish_eh_generation (void);\n \n struct GTY(()) throw_stmt_node {\n-  gimple stmt;\n+  gimple *stmt;\n   int lp_nr;\n };\n \n-extern hash_map<gimple, int> *get_eh_throw_stmt_table (struct function *);\n-extern void set_eh_throw_stmt_table (function *, hash_map<gimple, int> *);\n+extern hash_map<gimple *, int> *get_eh_throw_stmt_table (struct function *);\n+extern void set_eh_throw_stmt_table (function *, hash_map<gimple *, int> *);\n \n enum eh_personality_kind {\n   eh_personality_none,"}, {"sha": "0bbfccd4650e76f26f67240316204583a2913006", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -2371,10 +2371,10 @@ use_group_regs (rtx *call_fusage, rtx regs)\n    assigment and the code of the expresion on the RHS is CODE.  Return\n    NULL otherwise.  */\n \n-static gimple\n+static gimple *\n get_def_for_expr (tree name, enum tree_code code)\n {\n-  gimple def_stmt;\n+  gimple *def_stmt;\n \n   if (TREE_CODE (name) != SSA_NAME)\n     return NULL;\n@@ -2391,10 +2391,10 @@ get_def_for_expr (tree name, enum tree_code code)\n    assigment and the class of the expresion on the RHS is CLASS.  Return\n    NULL otherwise.  */\n \n-static gimple\n+static gimple *\n get_def_for_expr_class (tree name, enum tree_code_class tclass)\n {\n-  gimple def_stmt;\n+  gimple *def_stmt;\n \n   if (TREE_CODE (name) != SSA_NAME)\n     return NULL;\n@@ -4477,7 +4477,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n   tree op0, op1;\n   rtx value, result;\n   optab binop;\n-  gimple srcstmt;\n+  gimple *srcstmt;\n   enum tree_code code;\n \n   if (mode1 != VOIDmode\n@@ -4507,7 +4507,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n      be from a bitfield load.  */\n   if (TREE_CODE (op0) == SSA_NAME)\n     {\n-      gimple op0stmt = get_gimple_for_ssa_name (op0);\n+      gimple *op0stmt = get_gimple_for_ssa_name (op0);\n \n       /* We want to eventually have OP0 be the same as TO, which\n \t should be a bitfield.  */\n@@ -6619,7 +6619,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  && DECL_MODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) != BLKmode))\n     {\n       rtx temp;\n-      gimple nop_def;\n+      gimple *nop_def;\n \n       /* If EXP is a NOP_EXPR of precision less than its mode, then that\n \t implies a mask operation.  If the precision is the same size as\n@@ -7904,7 +7904,7 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n   rtx op00, op01, op1, op2;\n   enum rtx_code comparison_code;\n   machine_mode comparison_mode;\n-  gimple srcstmt;\n+  gimple *srcstmt;\n   rtx temp;\n   tree type = TREE_TYPE (treeop1);\n   int unsignedp = TYPE_UNSIGNED (type);\n@@ -8302,7 +8302,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t  && TYPE_MODE (TREE_TYPE (treeop0))\n \t     == TYPE_MODE (TREE_TYPE (treeop1)))\n \t{\n-\t  gimple def = get_def_for_expr (treeop1, NEGATE_EXPR);\n+\t  gimple *def = get_def_for_expr (treeop1, NEGATE_EXPR);\n \t  if (def)\n \t    {\n \t      treeop1 = gimple_assign_rhs1 (def);\n@@ -8490,7 +8490,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n     case FMA_EXPR:\n       {\n \toptab opt = fma_optab;\n-\tgimple def0, def2;\n+\tgimple *def0, *def2;\n \n \t/* If there is no insn for FMA, emit it as __builtin_fma{,f,l}\n \t   call.  */\n@@ -8896,7 +8896,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t    && TREE_CONSTANT (treeop1)\n \t    && TREE_CODE (treeop0) == SSA_NAME)\n \t  {\n-\t    gimple def = SSA_NAME_DEF_STMT (treeop0);\n+\t    gimple *def = SSA_NAME_DEF_STMT (treeop0);\n \t    if (is_gimple_assign (def)\n \t\t&& gimple_assign_rhs_code (def) == NOP_EXPR)\n \t      {\n@@ -9328,7 +9328,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n    into constant expressions.  */\n \n static bool\n-stmt_is_replaceable_p (gimple stmt)\n+stmt_is_replaceable_p (gimple *stmt)\n {\n   if (ssa_is_replaceable_p (stmt))\n     {\n@@ -9358,7 +9358,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n   struct separate_ops ops;\n   tree treeop0, treeop1, treeop2;\n   tree ssa_name = NULL_TREE;\n-  gimple g;\n+  gimple *g;\n \n   type = TREE_TYPE (exp);\n   mode = TYPE_MODE (type);\n@@ -9842,7 +9842,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t  = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n \tmachine_mode address_mode;\n \ttree base = TREE_OPERAND (exp, 0);\n-\tgimple def_stmt;\n+\tgimple *def_stmt;\n \tenum insn_code icode;\n \tunsigned align;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n@@ -11120,7 +11120,7 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n       && integer_zerop (arg1)\n       && (TYPE_PRECISION (ops->type) != 1 || TYPE_UNSIGNED (ops->type)))\n     {\n-      gimple srcstmt = get_def_for_expr (arg0, BIT_AND_EXPR);\n+      gimple *srcstmt = get_def_for_expr (arg0, BIT_AND_EXPR);\n       if (srcstmt\n \t  && integer_pow2p (gimple_assign_rhs2 (srcstmt)))\n \t{"}, {"sha": "c140c62856bb65be5cb9a589b81b2787f1e791aa", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -238,7 +238,7 @@ fold_defer_overflow_warnings (void)\n    deferred code.  */\n \n void\n-fold_undefer_overflow_warnings (bool issue, const_gimple stmt, int code)\n+fold_undefer_overflow_warnings (bool issue, const gimple *stmt, int code)\n {\n   const char *warnmsg;\n   location_t locus;"}, {"sha": "4a31e62600f96cfb8fac0dd6b22ba669d77f42a3", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -82,7 +82,7 @@ extern tree fold_ignored_result (tree);\n extern tree fold_abs_const (tree, tree);\n extern tree fold_indirect_ref_1 (location_t, tree, tree);\n extern void fold_defer_overflow_warnings (void);\n-extern void fold_undefer_overflow_warnings (bool, const_gimple, int);\n+extern void fold_undefer_overflow_warnings (bool, const gimple *, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n extern int operand_equal_p (const_tree, const_tree, unsigned int);"}, {"sha": "102a6350b5e7c11b0bc6c11846dc14f53d9eafe9", "filename": "gcc/genmatch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -2604,7 +2604,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n       fprintf_indent (f, indent,\n \t\t      \"    {\\n\");\n       fprintf_indent (f, indent,\n-\t\t      \"      gimple def_stmt = SSA_NAME_DEF_STMT (%s);\\n\",\n+\t\t      \"      gimple *def_stmt = SSA_NAME_DEF_STMT (%s);\\n\",\n \t\t      kid_opname);\n \n       indent += 6;"}, {"sha": "35c4f90c7f64e5acfd0a7ff6068267fb61e4cc79", "filename": "gcc/ggc.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -292,11 +292,10 @@ ggc_alloc_cleared_tree_node_stat (size_t s CXX_MEM_STAT_INFO)\n   return (union tree_node *) ggc_internal_cleared_alloc (s PASS_MEM_STAT);\n }\n \n-static inline struct gimple_statement_base *\n+static inline gimple *\n ggc_alloc_cleared_gimple_statement_stat (size_t s CXX_MEM_STAT_INFO)\n {\n-  return (struct gimple_statement_base *)\n-    ggc_internal_cleared_alloc (s PASS_MEM_STAT);\n+  return (gimple *) ggc_internal_cleared_alloc (s PASS_MEM_STAT);\n }\n \n static inline void"}, {"sha": "a7aa910ee181760acbe846596937cb7212d847b7", "filename": "gcc/gimple-builder.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -62,7 +62,7 @@ build_assign (enum tree_code code, tree op1, int val, tree lhs)\n }\n \n gassign *\n-build_assign (enum tree_code code, gimple g, int val, tree lhs )\n+build_assign (enum tree_code code, gimple *g, int val, tree lhs )\n {\n   return build_assign (code, gimple_assign_lhs (g), val, lhs);\n }\n@@ -85,19 +85,19 @@ build_assign (enum tree_code code, tree op1, tree op2, tree lhs)\n }\n \n gassign *\n-build_assign (enum tree_code code, gimple op1, tree op2, tree lhs)\n+build_assign (enum tree_code code, gimple *op1, tree op2, tree lhs)\n {\n   return build_assign (code, gimple_assign_lhs (op1), op2, lhs);\n }\n \n gassign *\n-build_assign (enum tree_code code, tree op1, gimple op2, tree lhs)\n+build_assign (enum tree_code code, tree op1, gimple *op2, tree lhs)\n {\n   return build_assign (code, op1, gimple_assign_lhs (op2), lhs);\n }\n \n gassign *\n-build_assign (enum tree_code code, gimple op1, gimple op2, tree lhs)\n+build_assign (enum tree_code code, gimple *op1, gimple *op2, tree lhs)\n {\n   return build_assign (code, gimple_assign_lhs (op1), gimple_assign_lhs (op2),\n                        lhs);\n@@ -116,7 +116,7 @@ build_type_cast (tree to_type, tree op, tree lhs)\n }\n \n gassign *\n-build_type_cast (tree to_type, gimple op, tree lhs)\n+build_type_cast (tree to_type, gimple *op, tree lhs)\n {\n   return build_type_cast (to_type, gimple_assign_lhs (op), lhs);\n }"}, {"sha": "7a00eccd698165b21b2b4354cc71b781d32fa20c", "filename": "gcc/gimple-builder.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -22,12 +22,13 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_GIMPLE_BUILDER_H\n \n gassign *build_assign (enum tree_code, tree, int, tree lhs = NULL_TREE);\n-gassign *build_assign (enum tree_code, gimple, int, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, gimple *, int, tree lhs = NULL_TREE);\n gassign *build_assign (enum tree_code, tree, tree, tree lhs = NULL_TREE);\n-gassign *build_assign (enum tree_code, gimple, tree, tree lhs = NULL_TREE);\n-gassign *build_assign (enum tree_code, tree, gimple, tree lhs = NULL_TREE);\n-gassign *build_assign (enum tree_code, gimple, gimple, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, gimple *, tree, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, tree, gimple *, tree lhs = NULL_TREE);\n+gassign *build_assign (enum tree_code, gimple *, gimple *,\n+\t\t       tree lhs = NULL_TREE);\n gassign *build_type_cast (tree, tree, tree lhs = NULL_TREE);\n-gassign *build_type_cast (tree, gimple, tree lhs = NULL_TREE);\n+gassign *build_type_cast (tree, gimple *, tree lhs = NULL_TREE);\n \n #endif /* GCC_GIMPLE_BUILDER_H */"}, {"sha": "51309f2da61ae1721aa0bb2b910eff4906d4d514", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -298,7 +298,7 @@ maybe_fold_reference (tree expr, bool is_lhs)\n static tree\n fold_gimple_assign (gimple_stmt_iterator *si)\n {\n-  gimple stmt = gsi_stmt (*si);\n+  gimple *stmt = gsi_stmt (*si);\n   enum tree_code subcode = gimple_assign_rhs_code (stmt);\n   location_t loc = gimple_location (stmt);\n \n@@ -446,18 +446,18 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n static void\n gsi_replace_with_seq_vops (gimple_stmt_iterator *si_p, gimple_seq stmts)\n {\n-  gimple stmt = gsi_stmt (*si_p);\n+  gimple *stmt = gsi_stmt (*si_p);\n \n   if (gimple_has_location (stmt))\n     annotate_all_with_location (stmts, gimple_location (stmt));\n \n   /* First iterate over the replacement statements backward, assigning\n      virtual operands to their defining statements.  */\n-  gimple laststore = NULL;\n+  gimple *laststore = NULL;\n   for (gimple_stmt_iterator i = gsi_last (stmts);\n        !gsi_end_p (i); gsi_prev (&i))\n     {\n-      gimple new_stmt = gsi_stmt (i);\n+      gimple *new_stmt = gsi_stmt (i);\n       if ((gimple_assign_single_p (new_stmt)\n \t   && !is_gimple_reg (gimple_assign_lhs (new_stmt)))\n \t  || (is_gimple_call (new_stmt)\n@@ -482,7 +482,7 @@ gsi_replace_with_seq_vops (gimple_stmt_iterator *si_p, gimple_seq stmts)\n   for (gimple_stmt_iterator i = gsi_start (stmts);\n        !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple new_stmt = gsi_stmt (i);\n+      gimple *new_stmt = gsi_stmt (i);\n       /* If the new statement possibly has a VUSE, update it with exact SSA\n \t name we know will reach this one.  */\n       if (gimple_has_mem_ops (new_stmt))\n@@ -524,7 +524,7 @@ void\n gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n {\n   tree lhs;\n-  gimple stmt, new_stmt;\n+  gimple *stmt, *new_stmt;\n   gimple_stmt_iterator i;\n   gimple_seq stmts = NULL;\n \n@@ -572,9 +572,9 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n static void\n replace_call_with_value (gimple_stmt_iterator *gsi, tree val)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n-  gimple repl;\n+  gimple *repl;\n   if (lhs)\n     {\n       if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (val)))\n@@ -596,9 +596,9 @@ replace_call_with_value (gimple_stmt_iterator *gsi, tree val)\n    again.  */\n \n static void\n-replace_call_with_call_and_fold (gimple_stmt_iterator *gsi, gimple repl)\n+replace_call_with_call_and_fold (gimple_stmt_iterator *gsi, gimple *repl)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   gimple_call_set_lhs (repl, gimple_call_lhs (stmt));\n   gimple_set_location (repl, gimple_location (stmt));\n   if (gimple_vdef (stmt)\n@@ -635,7 +635,7 @@ static bool\n gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t\t\t       tree dest, tree src, int endp)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n   tree len = gimple_call_arg (stmt, 2);\n   tree destvar, srcvar;\n@@ -644,7 +644,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n   /* If the LEN parameter is zero, return DEST.  */\n   if (integer_zerop (len))\n     {\n-      gimple repl;\n+      gimple *repl;\n       if (gimple_call_lhs (stmt))\n \trepl = gimple_build_assign (gimple_call_lhs (stmt), dest);\n       else\n@@ -724,7 +724,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t\t    srcmem = NULL_TREE;\n \t\t  if (srcmem)\n \t\t    {\n-\t\t      gimple new_stmt;\n+\t\t      gimple *new_stmt;\n \t\t      if (is_gimple_reg_type (TREE_TYPE (srcmem)))\n \t\t\t{\n \t\t\t  new_stmt = gimple_build_assign (NULL_TREE, srcmem);\n@@ -1010,7 +1010,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t    }\n \t}\n \n-      gimple new_stmt;\n+      gimple *new_stmt;\n       if (is_gimple_reg_type (TREE_TYPE (srcvar)))\n \t{\n \t  new_stmt = gimple_build_assign (NULL_TREE, srcvar);\n@@ -1047,7 +1047,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \n   dest = force_gimple_operand_gsi (gsi, dest, false, NULL_TREE, true,\n \t\t\t\t   GSI_SAME_STMT);\n-  gimple repl = gimple_build_assign (lhs, dest);\n+  gimple *repl = gimple_build_assign (lhs, dest);\n   gsi_replace (gsi, repl, false);\n   return true;\n }\n@@ -1058,7 +1058,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n static bool\n gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree etype;\n   unsigned HOST_WIDE_INT length, cval;\n \n@@ -1118,7 +1118,7 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n     }\n \n   var = fold_build2 (MEM_REF, etype, dest, build_int_cst (ptr_type_node, 0));\n-  gimple store = gimple_build_assign (var, build_int_cst_type (etype, cval));\n+  gimple *store = gimple_build_assign (var, build_int_cst_type (etype, cval));\n   gimple_set_vuse (store, gimple_vuse (stmt));\n   tree vdef = gimple_vdef (stmt);\n   if (vdef && TREE_CODE (vdef) == SSA_NAME)\n@@ -1129,7 +1129,7 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n   gsi_insert_before (gsi, store, GSI_SAME_STMT);\n   if (gimple_call_lhs (stmt))\n     {\n-      gimple asgn = gimple_build_assign (gimple_call_lhs (stmt), dest);\n+      gimple *asgn = gimple_build_assign (gimple_call_lhs (stmt), dest);\n       gsi_replace (gsi, asgn, false);\n     }\n   else\n@@ -1156,7 +1156,7 @@ static bool\n get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n {\n   tree var, val;\n-  gimple def_stmt;\n+  gimple *def_stmt;\n \n   if (TREE_CODE (arg) != SSA_NAME)\n     {\n@@ -1316,7 +1316,7 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n   len = size_binop_loc (loc, PLUS_EXPR, len, build_int_cst (size_type_node, 1));\n   len = force_gimple_operand_gsi (gsi, len, true,\n \t\t\t\t  NULL_TREE, true, GSI_SAME_STMT);\n-  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  gimple *repl = gimple_build_call (fn, 3, dest, src, len);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -1365,7 +1365,7 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n   len = fold_convert_loc (loc, size_type_node, len);\n   len = force_gimple_operand_gsi (gsi, len, true,\n \t\t\t\t  NULL_TREE, true, GSI_SAME_STMT);\n-  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  gimple *repl = gimple_build_call (fn, 3, dest, src, len);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -1391,7 +1391,7 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n static bool\n gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi, tree dst, tree src)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   location_t loc = gimple_location (stmt);\n \n   const char *p = c_getstr (src);\n@@ -1422,7 +1422,7 @@ gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi, tree dst, tree src)\n \n   /* Create strlen (dst).  */\n   gimple_seq stmts = NULL, stmts2;\n-  gimple repl = gimple_build_call (strlen_fn, 1, dst);\n+  gimple *repl = gimple_build_call (strlen_fn, 1, dst);\n   gimple_set_location (repl, loc);\n   if (gimple_in_ssa_p (cfun))\n     newdst = make_ssa_name (size_type_node);\n@@ -1471,7 +1471,7 @@ gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi, tree dst, tree src)\n static bool\n gimple_fold_builtin_strcat_chk (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree dest = gimple_call_arg (stmt, 0);\n   tree src = gimple_call_arg (stmt, 1);\n   tree size = gimple_call_arg (stmt, 2);\n@@ -1495,7 +1495,7 @@ gimple_fold_builtin_strcat_chk (gimple_stmt_iterator *gsi)\n   if (!fn)\n     return false;\n \n-  gimple repl = gimple_build_call (fn, 2, dest, src);\n+  gimple *repl = gimple_build_call (fn, 2, dest, src);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -1546,7 +1546,7 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n static bool \n gimple_fold_builtin_strncat_chk (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree dest = gimple_call_arg (stmt, 0);\n   tree src = gimple_call_arg (stmt, 1);\n   tree len = gimple_call_arg (stmt, 2);\n@@ -1579,7 +1579,7 @@ gimple_fold_builtin_strncat_chk (gimple_stmt_iterator *gsi)\n \t  if (!fn)\n \t    return false;\n \n-\t  gimple repl = gimple_build_call (fn, 3, dest, src, size);\n+\t  gimple *repl = gimple_build_call (fn, 3, dest, src, size);\n \t  replace_call_with_call_and_fold (gsi, repl);\n \t  return true;\n \t}\n@@ -1591,7 +1591,7 @@ gimple_fold_builtin_strncat_chk (gimple_stmt_iterator *gsi)\n   if (!fn)\n     return false;\n \n-  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  gimple *repl = gimple_build_call (fn, 3, dest, src, len);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -1608,7 +1608,7 @@ gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n \t\t\t   tree arg0, tree arg1,\n \t\t\t   bool unlocked)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   /* If we're using an unlocked function, assume the other unlocked\n      functions exist explicitly.  */\n@@ -1644,7 +1644,7 @@ gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n \t    if (!fn_fputc)\n \t      return false;\n \n-\t    gimple repl = gimple_build_call (fn_fputc, 2,\n+\t    gimple *repl = gimple_build_call (fn_fputc, 2,\n \t\t\t\t\t     build_int_cst\n \t\t\t\t\t     (integer_type_node, p[0]), arg1);\n \t    replace_call_with_call_and_fold (gsi, repl);\n@@ -1662,7 +1662,7 @@ gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n \tif (!fn_fwrite)\n \t  return false;\n \n-\tgimple repl = gimple_build_call (fn_fwrite, 4, arg0,\n+\tgimple *repl = gimple_build_call (fn_fwrite, 4, arg0,\n \t\t\t\t\t size_one_node, len, arg1);\n \treplace_call_with_call_and_fold (gsi, repl);\n \treturn true;\n@@ -1684,7 +1684,7 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n \t\t\t\ttree dest, tree src, tree len, tree size,\n \t\t\t\tenum built_in_function fcode)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   location_t loc = gimple_location (stmt);\n   bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree fn;\n@@ -1730,7 +1730,7 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n \t\t  if (!fn)\n \t\t    return false;\n \n-\t\t  gimple repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t\t  gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n \t\t  replace_call_with_call_and_fold (gsi, repl);\n \t\t  return true;\n \t\t}\n@@ -1768,7 +1768,7 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n   if (!fn)\n     return false;\n \n-  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  gimple *repl = gimple_build_call (fn, 3, dest, src, len);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -1785,7 +1785,7 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n \t\t\t\ttree src, tree size,\n \t\t\t\tenum built_in_function fcode)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   location_t loc = gimple_location (stmt);\n   bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree len, fn;\n@@ -1822,7 +1822,7 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n \t\t  if (!fn)\n \t\t    return false;\n \n-\t\t  gimple repl = gimple_build_call (fn, 3, dest, src, size);\n+\t\t  gimple *repl = gimple_build_call (fn, 3, dest, src, size);\n \t\t  replace_call_with_call_and_fold (gsi, repl);\n \t\t  return true;\n \t\t}\n@@ -1841,7 +1841,7 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n \t\t\t\t    build_int_cst (size_type_node, 1));\n \t      len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE,\n \t\t\t\t\t      true, GSI_SAME_STMT);\n-\t      gimple repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t      gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n \t      replace_call_with_call_and_fold (gsi, repl);\n \t      return true;\n \t    }\n@@ -1859,7 +1859,7 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n   if (!fn)\n     return false;\n \n-  gimple repl = gimple_build_call (fn, 2, dest, src);\n+  gimple *repl = gimple_build_call (fn, 2, dest, src);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -1875,7 +1875,7 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n \t\t\t\t tree len, tree size,\n \t\t\t\t enum built_in_function fcode)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree fn;\n \n@@ -1886,7 +1886,7 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n        fn = builtin_decl_explicit (BUILT_IN_STRNCPY_CHK);\n        if (fn)\n \t {\n-\t   gimple repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t   gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n \t   replace_call_with_call_and_fold (gsi, repl);\n \t   return true;\n \t }\n@@ -1919,7 +1919,7 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n   if (!fn)\n     return false;\n \n-  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  gimple *repl = gimple_build_call (fn, 3, dest, src, len);\n   replace_call_with_call_and_fold (gsi, repl);\n   return true;\n }\n@@ -2176,7 +2176,7 @@ gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n static bool\n gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree dest = gimple_call_arg (stmt, 0);\n   tree fmt = gimple_call_arg (stmt, 1);\n   tree orig = NULL_TREE;\n@@ -2214,7 +2214,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n       /* Convert sprintf (str, fmt) into strcpy (str, fmt) when\n \t 'format' is known to contain no % formats.  */\n       gimple_seq stmts = NULL;\n-      gimple repl = gimple_build_call (fn, 2, dest, fmt);\n+      gimple *repl = gimple_build_call (fn, 2, dest, fmt);\n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (gimple_call_lhs (stmt))\n \t{\n@@ -2262,7 +2262,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n \n       /* Convert sprintf (str1, \"%s\", str2) into strcpy (str1, str2).  */\n       gimple_seq stmts = NULL;\n-      gimple repl = gimple_build_call (fn, 2, dest, orig);\n+      gimple *repl = gimple_build_call (fn, 2, dest, orig);\n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (gimple_call_lhs (stmt))\n \t{\n@@ -2349,7 +2349,7 @@ gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi)\n \treturn false;\n \n       gimple_seq stmts = NULL;\n-      gimple repl = gimple_build_call (fn, 2, dest, fmt);\n+      gimple *repl = gimple_build_call (fn, 2, dest, fmt);\n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (gimple_call_lhs (stmt))\n \t{\n@@ -2401,7 +2401,7 @@ gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi)\n       /* Convert snprintf (str1, cst, \"%s\", str2) into\n \t strcpy (str1, str2) if strlen (str2) < cst.  */\n       gimple_seq stmts = NULL;\n-      gimple repl = gimple_build_call (fn, 2, dest, orig);\n+      gimple *repl = gimple_build_call (fn, 2, dest, orig);\n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (gimple_call_lhs (stmt))\n \t{\n@@ -2699,7 +2699,7 @@ gimple_fold_builtin_printf (gimple_stmt_iterator *gsi, tree fmt,\n static bool\n gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree len = get_maxval_strlen (gimple_call_arg (stmt, 0), 0);\n   if (!len)\n     return false;\n@@ -2970,7 +2970,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t\t\t{\n \t\t\t  tree var = create_tmp_var (TREE_TYPE (lhs));\n \t\t\t  tree def = get_or_create_ssa_default_def (cfun, var);\n-\t\t\t  gimple new_stmt = gimple_build_assign (lhs, def);\n+\t\t\t  gimple *new_stmt = gimple_build_assign (lhs, def);\n \t\t\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n \t\t\t}\n \t\t      gimple_call_set_lhs (stmt, NULL_TREE);\n@@ -2980,7 +2980,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t      else\n \t\t{\n \t\t  tree fndecl = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n-\t\t  gimple new_stmt = gimple_build_call (fndecl, 0);\n+\t\t  gimple *new_stmt = gimple_build_call (fndecl, 0);\n \t\t  gimple_set_location (new_stmt, gimple_location (stmt));\n \t\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t\t    {\n@@ -3191,7 +3191,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n /* Return true whether NAME has a use on STMT.  */\n \n static bool\n-has_use_on_stmt (tree name, gimple stmt)\n+has_use_on_stmt (tree name, gimple *stmt)\n {\n   imm_use_iterator iter;\n   use_operand_p use_p;\n@@ -3213,7 +3213,7 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t\t\t\t  code_helper rcode, tree *ops,\n \t\t\t\t  gimple_seq *seq, bool inplace)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   /* Play safe and do not allow abnormals to be mentioned in\n      newly created statements.  See also maybe_push_res_to_seq.\n@@ -3424,7 +3424,7 @@ static bool\n fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n {\n   bool changed = false;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   unsigned i;\n \n   /* First do required canonicalization of [TARGET_]MEM_REF addresses\n@@ -3770,7 +3770,7 @@ fold_stmt (gimple_stmt_iterator *gsi, tree (*valueize) (tree))\n bool\n fold_stmt_inplace (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   bool changed = fold_stmt_1 (gsi, true, no_follow_ssa_edges);\n   gcc_assert (gsi_stmt (*gsi) == stmt);\n   return changed;\n@@ -3831,7 +3831,7 @@ static bool\n same_bool_comparison_p (const_tree expr, enum tree_code code,\n \t\t\tconst_tree op1, const_tree op2)\n {\n-  gimple s;\n+  gimple *s;\n \n   /* The obvious case.  */\n   if (TREE_CODE (expr) == code\n@@ -3918,7 +3918,7 @@ static tree\n and_var_with_comparison (tree var, bool invert,\n \t\t\t enum tree_code code2, tree op2a, tree op2b);\n static tree\n-and_var_with_comparison_1 (gimple stmt, \n+and_var_with_comparison_1 (gimple *stmt,\n \t\t\t   enum tree_code code2, tree op2a, tree op2b);\n static tree\n or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n@@ -3927,7 +3927,7 @@ static tree\n or_var_with_comparison (tree var, bool invert,\n \t\t\tenum tree_code code2, tree op2a, tree op2b);\n static tree\n-or_var_with_comparison_1 (gimple stmt, \n+or_var_with_comparison_1 (gimple *stmt,\n \t\t\t  enum tree_code code2, tree op2a, tree op2b);\n \n /* Helper function for and_comparisons_1:  try to simplify the AND of the\n@@ -3940,7 +3940,7 @@ and_var_with_comparison (tree var, bool invert,\n \t\t\t enum tree_code code2, tree op2a, tree op2b)\n {\n   tree t;\n-  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n \n   /* We can only deal with variables whose definitions are assignments.  */\n   if (!is_gimple_assign (stmt))\n@@ -3963,7 +3963,7 @@ and_var_with_comparison (tree var, bool invert,\n    Return NULL_EXPR if we can't simplify this to a single expression.  */\n \n static tree\n-and_var_with_comparison_1 (gimple stmt,\n+and_var_with_comparison_1 (gimple *stmt,\n \t\t\t   enum tree_code code2, tree op2a, tree op2b)\n {\n   tree var = gimple_assign_lhs (stmt);\n@@ -4011,7 +4011,7 @@ and_var_with_comparison_1 (gimple stmt,\n     {\n       tree inner1 = gimple_assign_rhs1 (stmt);\n       tree inner2 = gimple_assign_rhs2 (stmt);\n-      gimple s;\n+      gimple *s;\n       tree t;\n       tree partial = NULL_TREE;\n       bool is_and = (innercode == BIT_AND_EXPR);\n@@ -4298,7 +4298,7 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n     {\n       bool invert = ((code1 == EQ_EXPR && integer_zerop (op1b))\n \t\t     || (code1 == NE_EXPR && integer_onep (op1b)));\n-      gimple stmt = SSA_NAME_DEF_STMT (op1a);\n+      gimple *stmt = SSA_NAME_DEF_STMT (op1a);\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_ASSIGN:\n@@ -4343,7 +4343,7 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n \t\t\t   && !SSA_NAME_IS_DEFAULT_DEF (arg))\n \t\t    {\n \t\t      tree temp;\n-\t\t      gimple def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t\t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n \t\t      /* In simple cases we can look through PHI nodes,\n \t\t\t but we have to be careful with loops.\n \t\t\t See PR49073.  */\n@@ -4403,7 +4403,7 @@ or_var_with_comparison (tree var, bool invert,\n \t\t\tenum tree_code code2, tree op2a, tree op2b)\n {\n   tree t;\n-  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n \n   /* We can only deal with variables whose definitions are assignments.  */\n   if (!is_gimple_assign (stmt))\n@@ -4426,7 +4426,7 @@ or_var_with_comparison (tree var, bool invert,\n    Return NULL_EXPR if we can't simplify this to a single expression.  */\n \n static tree\n-or_var_with_comparison_1 (gimple stmt,\n+or_var_with_comparison_1 (gimple *stmt,\n \t\t\t  enum tree_code code2, tree op2a, tree op2b)\n {\n   tree var = gimple_assign_lhs (stmt);\n@@ -4474,7 +4474,7 @@ or_var_with_comparison_1 (gimple stmt,\n     {\n       tree inner1 = gimple_assign_rhs1 (stmt);\n       tree inner2 = gimple_assign_rhs2 (stmt);\n-      gimple s;\n+      gimple *s;\n       tree t;\n       tree partial = NULL_TREE;\n       bool is_or = (innercode == BIT_IOR_EXPR);\n@@ -4762,7 +4762,7 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n     {\n       bool invert = ((code1 == EQ_EXPR && integer_zerop (op1b))\n \t\t     || (code1 == NE_EXPR && integer_onep (op1b)));\n-      gimple stmt = SSA_NAME_DEF_STMT (op1a);\n+      gimple *stmt = SSA_NAME_DEF_STMT (op1a);\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_ASSIGN:\n@@ -4807,7 +4807,7 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n \t\t\t   && !SSA_NAME_IS_DEFAULT_DEF (arg))\n \t\t    {\n \t\t      tree temp;\n-\t\t      gimple def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t\t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n \t\t      /* In simple cases we can look through PHI nodes,\n \t\t\t but we have to be careful with loops.\n \t\t\t See PR49073.  */\n@@ -4868,7 +4868,7 @@ maybe_fold_or_comparisons (enum tree_code code1, tree op1a, tree op1b,\n    to avoid the indirect function call overhead.  */\n \n tree\n-gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree),\n+gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t\t\t\ttree (*gvalueize) (tree))\n {\n   code_helper rcode;\n@@ -5159,7 +5159,7 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree),\n    returns a constant according to is_gimple_min_invariant.  */\n \n tree\n-gimple_fold_stmt_to_constant (gimple stmt, tree (*valueize) (tree))\n+gimple_fold_stmt_to_constant (gimple *stmt, tree (*valueize) (tree))\n {\n   tree res = gimple_fold_stmt_to_constant_1 (stmt, valueize);\n   if (res && is_gimple_min_invariant (res))\n@@ -5727,7 +5727,7 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo,\n bool\n gimple_val_nonnegative_real_p (tree val)\n {\n-  gimple def_stmt;\n+  gimple *def_stmt;\n \n   gcc_assert (val && SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)));\n \n@@ -6001,7 +6001,7 @@ arith_code_with_undefined_signed_overflow (tree_code code)\n    a modified form of STMT itself.  */\n \n gimple_seq\n-rewrite_to_defined_overflow (gimple stmt)\n+rewrite_to_defined_overflow (gimple *stmt)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -6026,7 +6026,7 @@ rewrite_to_defined_overflow (gimple stmt)\n   if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n     gimple_assign_set_rhs_code (stmt, PLUS_EXPR);\n   gimple_seq_add_stmt (&stmts, stmt);\n-  gimple cvt = gimple_build_assign (lhs, NOP_EXPR, gimple_assign_lhs (stmt));\n+  gimple *cvt = gimple_build_assign (lhs, NOP_EXPR, gimple_assign_lhs (stmt));\n   gimple_seq_add_stmt (&stmts, cvt);\n \n   return stmts;\n@@ -6061,7 +6061,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n \tres = make_ssa_name (type);\n       else\n \tres = create_tmp_reg (type);\n-      gimple stmt;\n+      gimple *stmt;\n       if (code == REALPART_EXPR\n \t  || code == IMAGPART_EXPR\n \t  || code == VIEW_CONVERT_EXPR)\n@@ -6090,7 +6090,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n \tres = make_ssa_name (type);\n       else\n \tres = create_tmp_reg (type);\n-      gimple stmt = gimple_build_assign (res, code, op0, op1);\n+      gimple *stmt = gimple_build_assign (res, code, op0, op1);\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (seq, stmt);\n     }\n@@ -6114,7 +6114,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n \tres = make_ssa_name (type);\n       else\n \tres = create_tmp_reg (type);\n-      gimple stmt;\n+      gimple *stmt;\n       if (code == BIT_FIELD_REF)\n \tstmt = gimple_build_assign (res, code,\n \t\t\t\t    build3 (code, type, op0, op1, op2));\n@@ -6140,7 +6140,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n   if (!res)\n     {\n       tree decl = builtin_decl_implicit (fn);\n-      gimple stmt = gimple_build_call (decl, 1, arg0);\n+      gimple *stmt = gimple_build_call (decl, 1, arg0);\n       if (!VOID_TYPE_P (type))\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n@@ -6169,7 +6169,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n   if (!res)\n     {\n       tree decl = builtin_decl_implicit (fn);\n-      gimple stmt = gimple_build_call (decl, 2, arg0, arg1);\n+      gimple *stmt = gimple_build_call (decl, 2, arg0, arg1);\n       if (!VOID_TYPE_P (type))\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n@@ -6200,7 +6200,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n   if (!res)\n     {\n       tree decl = builtin_decl_implicit (fn);\n-      gimple stmt = gimple_build_call (decl, 3, arg0, arg1, arg2);\n+      gimple *stmt = gimple_build_call (decl, 3, arg0, arg1, arg2);\n       if (!VOID_TYPE_P (type))\n \t{\n \t  if (gimple_in_ssa_p (cfun))"}, {"sha": "15948294ba74c37f4bb89da87d0933e3567c3870", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -36,9 +36,9 @@ extern bool arith_overflowed_p (enum tree_code, const_tree, const_tree,\n \t\t\t\tconst_tree);\n extern tree no_follow_ssa_edges (tree);\n extern tree follow_single_use_edges (tree);\n-extern tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree),\n+extern tree gimple_fold_stmt_to_constant_1 (gimple *, tree (*) (tree),\n \t\t\t\t\t    tree (*) (tree) = no_follow_ssa_edges);\n-extern tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n+extern tree gimple_fold_stmt_to_constant (gimple *, tree (*) (tree));\n extern tree fold_ctor_reference (tree, tree, unsigned HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT, tree);\n extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n@@ -51,7 +51,7 @@ extern tree gimple_get_virt_method_for_vtable (HOST_WIDE_INT, tree,\n extern bool gimple_val_nonnegative_real_p (tree);\n extern tree gimple_fold_indirect_ref (tree);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n-extern gimple_seq rewrite_to_defined_overflow (gimple);\n+extern gimple_seq rewrite_to_defined_overflow (gimple *);\n \n /* gimple_build, functionally matching fold_buildN, outputs stmts\n    int the provided sequence, matching and simplifying them on-the-fly."}, {"sha": "c998b65f65926883631bae6646381b2ce2b0fa75", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Mark the statement STMT as modified, and update it.  */\n \n static inline void\n-update_modified_stmt (gimple stmt)\n+update_modified_stmt (gimple *stmt)\n {\n   if (!ssa_operands_active (cfun))\n     return;\n@@ -370,10 +370,10 @@ gsi_split_seq_after (gimple_stmt_iterator i)\n    of gsi_replace.  */\n \n void\n-gsi_set_stmt (gimple_stmt_iterator *gsi, gimple stmt)\n+gsi_set_stmt (gimple_stmt_iterator *gsi, gimple *stmt)\n {\n-  gimple orig_stmt = gsi_stmt (*gsi);\n-  gimple prev, next;\n+  gimple *orig_stmt = gsi_stmt (*gsi);\n+  gimple *prev, *next;\n \n   stmt->next = next = orig_stmt->next;\n   stmt->prev = prev = orig_stmt->prev;\n@@ -431,9 +431,9 @@ gsi_split_seq_before (gimple_stmt_iterator *i, gimple_seq *pnew_seq)\n    cleanup is required.  */\n \n bool\n-gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n+gsi_replace (gimple_stmt_iterator *gsi, gimple *stmt, bool update_eh_info)\n {\n-  gimple orig_stmt = gsi_stmt (*gsi);\n+  gimple *orig_stmt = gsi_stmt (*gsi);\n   bool require_eh_edge_purge = false;\n \n   if (stmt == orig_stmt)\n@@ -476,7 +476,7 @@ gsi_replace_with_seq (gimple_stmt_iterator *gsi, gimple_seq seq,\n \t\t      bool update_eh_info)\n {\n   gimple_stmt_iterator seqi;\n-  gimple last;\n+  gimple *last;\n   if (gimple_seq_empty_p (seq))\n     {\n       gsi_remove (gsi, true);\n@@ -500,7 +500,7 @@ gsi_replace_with_seq (gimple_stmt_iterator *gsi, gimple_seq seq,\n    should use gsi_insert_before.  */\n \n void\n-gsi_insert_before_without_update (gimple_stmt_iterator *i, gimple stmt,\n+gsi_insert_before_without_update (gimple_stmt_iterator *i, gimple *stmt,\n                                   enum gsi_iterator_update m)\n {\n   gsi_insert_seq_nodes_before (i, stmt, stmt, m);\n@@ -512,7 +512,7 @@ gsi_insert_before_without_update (gimple_stmt_iterator *i, gimple stmt,\n    gsi_iterator_update).  */\n \n void\n-gsi_insert_before (gimple_stmt_iterator *i, gimple stmt,\n+gsi_insert_before (gimple_stmt_iterator *i, gimple *stmt,\n                    enum gsi_iterator_update m)\n {\n   update_modified_stmt (stmt);\n@@ -530,7 +530,7 @@ gsi_insert_before (gimple_stmt_iterator *i, gimple stmt,\n    should use gsi_insert_after.  */\n \n void\n-gsi_insert_after_without_update (gimple_stmt_iterator *i, gimple stmt,\n+gsi_insert_after_without_update (gimple_stmt_iterator *i, gimple *stmt,\n                                  enum gsi_iterator_update m)\n {\n   gsi_insert_seq_nodes_after (i, stmt, stmt, m);\n@@ -543,7 +543,7 @@ gsi_insert_after_without_update (gimple_stmt_iterator *i, gimple stmt,\n    gsi_iterator_update).  */\n \n void\n-gsi_insert_after (gimple_stmt_iterator *i, gimple stmt,\n+gsi_insert_after (gimple_stmt_iterator *i, gimple *stmt,\n \t\t  enum gsi_iterator_update m)\n {\n   update_modified_stmt (stmt);\n@@ -564,7 +564,7 @@ bool\n gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n {\n   gimple_seq_node cur, next, prev;\n-  gimple stmt = gsi_stmt (*i);\n+  gimple *stmt = gsi_stmt (*i);\n   bool require_eh_edge_purge = false;\n \n   if (gimple_code (stmt) != GIMPLE_PHI)\n@@ -610,7 +610,7 @@ gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n /* Finds iterator for STMT.  */\n \n gimple_stmt_iterator\n-gsi_for_stmt (gimple stmt)\n+gsi_for_stmt (gimple *stmt)\n {\n   gimple_stmt_iterator i;\n   basic_block bb = gimple_bb (stmt);\n@@ -643,7 +643,7 @@ gsi_for_phi (gphi *phi)\n void\n gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n {\n-  gimple stmt = gsi_stmt (*from);\n+  gimple *stmt = gsi_stmt (*from);\n   gsi_remove (from, false);\n \n   /* We must have GSI_NEW_STMT here, as gsi_move_after is sometimes used to\n@@ -658,7 +658,7 @@ gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n void\n gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n {\n-  gimple stmt = gsi_stmt (*from);\n+  gimple *stmt = gsi_stmt (*from);\n   gsi_remove (from, false);\n \n   /* For consistency with gsi_move_after, it might be better to have\n@@ -688,7 +688,7 @@ gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)\n    made until a call to gsi_commit_edge_inserts () is made.  */\n \n void\n-gsi_insert_on_edge (edge e, gimple stmt)\n+gsi_insert_on_edge (edge e, gimple *stmt)\n {\n   gimple_seq_add_stmt (&PENDING_STMT (e), stmt);\n }\n@@ -728,7 +728,7 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n \t\t\t     basic_block *new_bb)\n {\n   basic_block dest, src;\n-  gimple tmp;\n+  gimple *tmp;\n \n   dest = e->dest;\n \n@@ -806,7 +806,7 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n    block has to be created, it is returned.  */\n \n basic_block\n-gsi_insert_on_edge_immediate (edge e, gimple stmt)\n+gsi_insert_on_edge_immediate (edge e, gimple *stmt)\n {\n   gimple_stmt_iterator gsi;\n   basic_block new_bb = NULL;"}, {"sha": "b15d4233bf84f167d22e2a21758710ba43d09054", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -65,27 +65,27 @@ extern void gsi_insert_seq_after_without_update (gimple_stmt_iterator *,\n extern void gsi_insert_seq_after (gimple_stmt_iterator *, gimple_seq,\n \t\t\t\t  enum gsi_iterator_update);\n extern gimple_seq gsi_split_seq_after (gimple_stmt_iterator);\n-extern void gsi_set_stmt (gimple_stmt_iterator *, gimple);\n+extern void gsi_set_stmt (gimple_stmt_iterator *, gimple *);\n extern void gsi_split_seq_before (gimple_stmt_iterator *, gimple_seq *);\n-extern bool gsi_replace (gimple_stmt_iterator *, gimple, bool);\n+extern bool gsi_replace (gimple_stmt_iterator *, gimple *, bool);\n extern void gsi_replace_with_seq (gimple_stmt_iterator *, gimple_seq, bool);\n-extern void gsi_insert_before_without_update (gimple_stmt_iterator *, gimple,\n+extern void gsi_insert_before_without_update (gimple_stmt_iterator *, gimple *,\n \t\t\t\t\t      enum gsi_iterator_update);\n-extern void gsi_insert_before (gimple_stmt_iterator *, gimple,\n+extern void gsi_insert_before (gimple_stmt_iterator *, gimple *,\n \t\t\t       enum gsi_iterator_update);\n-extern void gsi_insert_after_without_update (gimple_stmt_iterator *, gimple,\n+extern void gsi_insert_after_without_update (gimple_stmt_iterator *, gimple *,\n \t\t\t\t\t     enum gsi_iterator_update);\n-extern void gsi_insert_after (gimple_stmt_iterator *, gimple,\n+extern void gsi_insert_after (gimple_stmt_iterator *, gimple *,\n \t\t\t      enum gsi_iterator_update);\n extern bool gsi_remove (gimple_stmt_iterator *, bool);\n-extern gimple_stmt_iterator gsi_for_stmt (gimple);\n+extern gimple_stmt_iterator gsi_for_stmt (gimple *);\n extern gphi_iterator gsi_for_phi (gphi *);\n extern void gsi_move_after (gimple_stmt_iterator *, gimple_stmt_iterator *);\n extern void gsi_move_before (gimple_stmt_iterator *, gimple_stmt_iterator *);\n extern void gsi_move_to_bb_end (gimple_stmt_iterator *, basic_block);\n-extern void gsi_insert_on_edge (edge, gimple);\n+extern void gsi_insert_on_edge (edge, gimple *);\n extern void gsi_insert_seq_on_edge (edge, gimple_seq);\n-extern basic_block gsi_insert_on_edge_immediate (edge, gimple);\n+extern basic_block gsi_insert_on_edge_immediate (edge, gimple *);\n extern basic_block gsi_insert_seq_on_edge_immediate (edge, gimple_seq);\n extern void gsi_commit_edge_inserts (void);\n extern void gsi_commit_one_edge_insert (edge, basic_block *);\n@@ -197,7 +197,7 @@ gsi_next (gimple_stmt_iterator *i)\n static inline void\n gsi_prev (gimple_stmt_iterator *i)\n {\n-  gimple prev = i->ptr->prev;\n+  gimple *prev = i->ptr->prev;\n   if (prev->next)\n     i->ptr = prev;\n   else\n@@ -206,7 +206,7 @@ gsi_prev (gimple_stmt_iterator *i)\n \n /* Return the current stmt.  */\n \n-static inline gimple\n+static inline gimple *\n gsi_stmt (gimple_stmt_iterator i)\n {\n   return i.ptr;"}, {"sha": "ba9198e921ad7deea4ab44c03f9340f4c31c8dba", "filename": "gcc/gimple-laddress.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-laddress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-laddress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-laddress.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -80,7 +80,7 @@ pass_laddress::execute (function *fun)\n     {\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  if (!is_gimple_assign (stmt)\n \t      || gimple_assign_rhs_code (stmt) != ADDR_EXPR\n \t      || is_gimple_invariant_address (gimple_assign_rhs1 (stmt)))\n@@ -117,7 +117,7 @@ pass_laddress::execute (function *fun)\n \t      base = build_fold_addr_expr (base);\n \t      base = force_gimple_operand_gsi (&gsi, base, true, NULL,\n \t\t\t\t\t       true, GSI_SAME_STMT);\n-\t      gimple g = gimple_build_assign (gimple_assign_lhs (stmt),\n+\t      gimple *g = gimple_build_assign (gimple_assign_lhs (stmt),\n \t\t\t\t\t      POINTER_PLUS_EXPR, base, offset);\n \t      gsi_replace (&gsi, g, false);\n \t    }"}, {"sha": "da5f938f5a3488b67eb5bb628f9355aa0babe82e", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -94,8 +94,8 @@ lower_function_body (void)\n   gimple_seq body = gimple_body (current_function_decl);\n   gimple_seq lowered_body;\n   gimple_stmt_iterator i;\n-  gimple bind;\n-  gimple x;\n+  gimple *bind;\n+  gimple *x;\n \n   /* The gimplifier should've left a body of exactly one statement,\n      namely a GIMPLE_BIND.  */\n@@ -219,7 +219,7 @@ lower_sequence (gimple_seq *seq, struct lower_data *data)\n static void\n lower_omp_directive (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   stmt = gsi_stmt (*gsi);\n \n@@ -240,7 +240,7 @@ lower_omp_directive (gimple_stmt_iterator *gsi, struct lower_data *data)\n static void\n lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   gimple_set_block (stmt, data->block);\n \n@@ -446,7 +446,7 @@ static void\n lower_try_catch (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n   bool cannot_fallthru;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   gimple_stmt_iterator i;\n \n   /* We don't handle GIMPLE_TRY_FINALLY.  */\n@@ -564,7 +564,7 @@ gimple_try_catch_may_fallthru (gtry *stmt)\n    we'll just delete the extra code later.  */\n \n bool\n-gimple_stmt_may_fallthru (gimple stmt)\n+gimple_stmt_may_fallthru (gimple *stmt)\n {\n   if (!stmt)\n     return true;\n@@ -641,7 +641,7 @@ static void\n lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n   greturn *stmt = as_a <greturn *> (gsi_stmt (*gsi));\n-  gimple t;\n+  gimple *t;\n   int i;\n   return_statements_t tmp_rs;\n \n@@ -731,12 +731,12 @@ lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n static void\n lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   location_t loc = gimple_location (stmt);\n   tree cont_label = create_artificial_label (loc);\n   tree next_label = create_artificial_label (loc);\n   tree dest, t, arg;\n-  gimple g;\n+  gimple *g;\n \n   /* __builtin_setjmp_{setup,receiver} aren't ECF_RETURNS_TWICE and for RTL\n      these builtins are modelled as non-local label jumps to the label\n@@ -816,7 +816,7 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n static void\n lower_builtin_posix_memalign (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt, call = gsi_stmt (*gsi);\n+  gimple *stmt, *call = gsi_stmt (*gsi);\n   tree pptr = gimple_call_arg (call, 0);\n   tree align = gimple_call_arg (call, 1);\n   tree res = gimple_call_lhs (call);\n@@ -839,7 +839,7 @@ lower_builtin_posix_memalign (gimple_stmt_iterator *gsi)\n     }\n   tree align_label = create_artificial_label (UNKNOWN_LOCATION);\n   tree noalign_label = create_artificial_label (UNKNOWN_LOCATION);\n-  gimple cond = gimple_build_cond (EQ_EXPR, res, integer_zero_node,\n+  gimple *cond = gimple_build_cond (EQ_EXPR, res, integer_zero_node,\n \t\t\t\t   align_label, noalign_label);\n   gsi_insert_after (gsi, cond, GSI_NEW_STMT);\n   gsi_insert_after (gsi, gimple_build_label (align_label), GSI_NEW_STMT);"}, {"sha": "294766a932f2e9c036688a217bd35d7b8fcde804", "filename": "gcc/gimple-low.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_LOW_H\n #define GCC_GIMPLE_LOW_H\n \n-extern bool gimple_stmt_may_fallthru (gimple);\n+extern bool gimple_stmt_may_fallthru (gimple *);\n extern bool gimple_seq_may_fallthru (gimple_seq);\n extern void record_vars_into (tree, tree);\n extern void record_vars (tree);"}, {"sha": "0587ce14019a8f40e7413f821b0681df7aeb5460", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -326,7 +326,7 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n       if (!res)\n \tres = make_ssa_name (type);\n       maybe_build_generic_op (rcode, type, &ops[0], ops[1], ops[2]);\n-      gimple new_stmt = gimple_build_assign (res, rcode,\n+      gimple *new_stmt = gimple_build_assign (res, rcode,\n \t\t\t\t\t     ops[0], ops[1], ops[2]);\n       gimple_seq_add_stmt_without_update (seq, new_stmt);\n       return res;\n@@ -355,7 +355,7 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n       gcc_assert (nargs != 0);\n       if (!res)\n \tres = make_ssa_name (type);\n-      gimple new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n+      gimple *new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n       gimple_call_set_lhs (new_stmt, res);\n       gimple_seq_add_stmt_without_update (seq, new_stmt);\n       return res;\n@@ -587,7 +587,7 @@ do_valueize (tree op, tree (*valueize)(tree), bool &valueized)\n    and the fold_stmt_to_constant APIs.  */\n \n bool\n-gimple_simplify (gimple stmt,\n+gimple_simplify (gimple *stmt,\n \t\t code_helper *rcode, tree *ops,\n \t\t gimple_seq *seq,\n \t\t tree (*valueize)(tree), tree (*top_valueize)(tree))"}, {"sha": "9e58755defb521f948e342b647d723eb0c6b7d5e", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -40,7 +40,7 @@ class code_helper\n   int rep;\n };\n \n-bool gimple_simplify (gimple, code_helper *, tree *, gimple_seq *,\n+bool gimple_simplify (gimple *, code_helper *, tree *, gimple_seq *,\n \t\t      tree (*)(tree), tree (*)(tree));\n tree maybe_push_res_to_seq (code_helper, tree, tree *,\n \t\t\t    gimple_seq *, tree res = NULL_TREE);"}, {"sha": "5fc0a21b2d6b71357ded309a7f6eaa5cadd88c26", "filename": "gcc/gimple-predict.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-predict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-predict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predict.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Return the predictor of GIMPLE_PREDICT statement GS.  */\n \n static inline enum br_predictor\n-gimple_predict_predictor (gimple gs)\n+gimple_predict_predictor (gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n   return (enum br_predictor) (gs->subcode & ~GF_PREDICT_TAKEN);\n@@ -36,7 +36,7 @@ gimple_predict_predictor (gimple gs)\n /* Set the predictor of GIMPLE_PREDICT statement GS to PREDICT.  */\n \n static inline void\n-gimple_predict_set_predictor (gimple gs, enum br_predictor predictor)\n+gimple_predict_set_predictor (gimple *gs, enum br_predictor predictor)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n   gs->subcode = (gs->subcode & GF_PREDICT_TAKEN)\n@@ -47,7 +47,7 @@ gimple_predict_set_predictor (gimple gs, enum br_predictor predictor)\n /* Return the outcome of GIMPLE_PREDICT statement GS.  */\n \n static inline enum prediction\n-gimple_predict_outcome (gimple gs)\n+gimple_predict_outcome (gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n   return (gs->subcode & GF_PREDICT_TAKEN) ? TAKEN : NOT_TAKEN;\n@@ -57,7 +57,7 @@ gimple_predict_outcome (gimple gs)\n /* Set the outcome of GIMPLE_PREDICT statement GS to OUTCOME.  */\n \n static inline void\n-gimple_predict_set_outcome (gimple gs, enum prediction outcome)\n+gimple_predict_set_outcome (gimple *gs, enum prediction outcome)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n   if (outcome == TAKEN)\n@@ -69,10 +69,10 @@ gimple_predict_set_outcome (gimple gs, enum prediction outcome)\n /* Build a GIMPLE_PREDICT statement.  PREDICT is one of the predictors from\n    predict.def, OUTCOME is NOT_TAKEN or TAKEN.  */\n \n-inline gimple\n+inline gimple *\n gimple_build_predict (enum br_predictor predictor, enum prediction outcome)\n {\n-  gimple p = gimple_alloc (GIMPLE_PREDICT, 0);\n+  gimple *p = gimple_alloc (GIMPLE_PREDICT, 0);\n   /* Ensure all the predictors fit into the lower bits of the subcode.  */\n   gcc_assert ((int) END_PREDICTORS <= GF_PREDICT_TAKEN);\n   gimple_predict_set_predictor (p, predictor);"}, {"sha": "f1a7e791e7cd381833674572429008804a9bed45", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -50,7 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n    gimple statement GS.  */\n \n static void\n-do_niy (pretty_printer *buffer, gimple gs)\n+do_niy (pretty_printer *buffer, gimple *gs)\n {\n   pp_printf (buffer, \"<<< Unknown GIMPLE statement: %s >>>\\n\",\n \t     gimple_code_name[(int) gimple_code (gs)]);\n@@ -70,7 +70,7 @@ newline_and_indent (pretty_printer *buffer, int spc)\n /* Print the GIMPLE statement GS on stderr.  */\n \n DEBUG_FUNCTION void\n-debug_gimple_stmt (gimple gs)\n+debug_gimple_stmt (gimple *gs)\n {\n   print_gimple_stmt (stderr, gs, 0, TDF_VOPS|TDF_MEMSYMS);\n }\n@@ -80,7 +80,7 @@ debug_gimple_stmt (gimple gs)\n    FLAGS as in pp_gimple_stmt_1.  */\n \n void\n-print_gimple_stmt (FILE *file, gimple g, int spc, int flags)\n+print_gimple_stmt (FILE *file, gimple *g, int spc, int flags)\n {\n   pretty_printer buffer;\n   pp_needs_newline (&buffer) = true;\n@@ -90,13 +90,13 @@ print_gimple_stmt (FILE *file, gimple g, int spc, int flags)\n }\n \n DEBUG_FUNCTION void\n-debug (gimple_statement_base &ref)\n+debug (gimple &ref)\n {\n   print_gimple_stmt (stderr, &ref, 0, 0);\n }\n \n DEBUG_FUNCTION void\n-debug (gimple_statement_base *ptr)\n+debug (gimple *ptr)\n {\n   if (ptr)\n     debug (*ptr);\n@@ -110,7 +110,7 @@ debug (gimple_statement_base *ptr)\n    of the statement.  */\n \n void\n-print_gimple_expr (FILE *file, gimple g, int spc, int flags)\n+print_gimple_expr (FILE *file, gimple *g, int spc, int flags)\n {\n   flags |= TDF_RHS_ONLY;\n   pretty_printer buffer;\n@@ -133,7 +133,7 @@ dump_gimple_seq (pretty_printer *buffer, gimple_seq seq, int spc, int flags)\n \n   for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple gs = gsi_stmt (i);\n+      gimple *gs = gsi_stmt (i);\n       INDENT (spc);\n       pp_gimple_stmt_1 (buffer, gs, spc, flags);\n       if (!gsi_one_before_end_p (i))\n@@ -192,11 +192,11 @@ dump_gimple_fmt (pretty_printer *buffer, int spc, int flags,\n         {\n           gimple_seq seq;\n           tree t;\n-          gimple g;\n+\t  gimple *g;\n           switch (*++c)\n             {\n               case 'G':\n-                g = va_arg (args, gimple);\n+\t\tg = va_arg (args, gimple *);\n                 tmp = gimple_code_name[gimple_code (g)];\n                 pp_string (buffer, tmp);\n                 break;\n@@ -1462,7 +1462,7 @@ dump_gimple_omp_sections (pretty_printer *buffer, gomp_sections *gs,\n    pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_block (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_block (pretty_printer *buffer, gimple *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S> >\", gs,\n@@ -1532,7 +1532,7 @@ dump_gimple_omp_critical (pretty_printer *buffer, gomp_critical *gs,\n /* Dump a GIMPLE_OMP_RETURN tuple on the pretty_printer BUFFER.  */\n \n static void\n-dump_gimple_omp_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_omp_return (pretty_printer *buffer, gimple *gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n@@ -2068,7 +2068,7 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer,\n    FLAGS are as in pp_gimple_stmt_1.  */\n \n static void\n-dump_gimple_mem_ops (pretty_printer *buffer, gimple gs, int spc, int flags)\n+dump_gimple_mem_ops (pretty_printer *buffer, gimple *gs, int spc, int flags)\n {\n   tree vdef = gimple_vdef (gs);\n   tree vuse = gimple_vuse (gs);\n@@ -2098,7 +2098,7 @@ dump_gimple_mem_ops (pretty_printer *buffer, gimple gs, int spc, int flags)\n    pp_flush on BUFFER to finalize the pretty printer.  */\n \n void\n-pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n+pp_gimple_stmt_1 (pretty_printer *buffer, gimple *gs, int spc, int flags)\n {\n   if (!gs)\n     return;\n@@ -2327,7 +2327,7 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent, int flags)\n     }\n   else\n     {\n-      gimple stmt = first_stmt (bb);\n+      gimple *stmt = first_stmt (bb);\n       if (!stmt || gimple_code (stmt) != GIMPLE_LABEL)\n \tfprintf (outf, \"%*s<bb %d>:\\n\", indent, \"\", bb->index);\n     }\n@@ -2375,7 +2375,7 @@ dump_phi_nodes (pretty_printer *buffer, basic_block bb, int indent, int flags)\n static void\n pp_cfg_jump (pretty_printer *buffer, basic_block bb)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   stmt = first_stmt (bb);\n \n@@ -2404,7 +2404,7 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n \t\t     int flags)\n {\n   edge e;\n-  gimple stmt;\n+  gimple *stmt;\n \n   stmt = last_stmt (bb);\n \n@@ -2455,7 +2455,7 @@ gimple_dump_bb_buff (pretty_printer *buffer, basic_block bb, int indent,\n \t\t     int flags)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   int label_indent = indent - 2;\n \n   if (label_indent < 0)\n@@ -2531,7 +2531,7 @@ gimple_dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n        gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       pp_bar (pp);\n       pp_write_text_to_stream (pp);\n       pp_gimple_stmt_1 (pp, stmt, 0, dump_flags);"}, {"sha": "1ab24b8dbfd2de8ae9fdb8151eb9dfe1b0ad8832", "filename": "gcc/gimple-pretty-print.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -24,14 +24,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n \n /* In gimple-pretty-print.c  */\n-extern void debug_gimple_stmt (gimple);\n+extern void debug_gimple_stmt (gimple *);\n extern void debug_gimple_seq (gimple_seq);\n extern void print_gimple_seq (FILE *, gimple_seq, int, int);\n-extern void print_gimple_stmt (FILE *, gimple, int, int);\n-extern void debug (gimple_statement_base &ref);\n-extern void debug (gimple_statement_base *ptr);\n-extern void print_gimple_expr (FILE *, gimple, int, int);\n-extern void pp_gimple_stmt_1 (pretty_printer *, gimple, int, int);\n+extern void print_gimple_stmt (FILE *, gimple *, int, int);\n+extern void debug (gimple &ref);\n+extern void debug (gimple *ptr);\n+extern void print_gimple_expr (FILE *, gimple *, int, int);\n+extern void pp_gimple_stmt_1 (pretty_printer *, gimple *, int, int);\n extern void gimple_dump_bb (FILE *, basic_block, int, int);\n extern void gimple_dump_bb_for_graph (pretty_printer *, basic_block);\n "}, {"sha": "aec3637d162fe123d6c8e1de59886cb0d21c7017", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -53,7 +53,7 @@ static bool cfg_altered;\n    This routine only makes a superficial check for a dereference.  Thus,\n    it must only be used if it is safe to return a false negative.  */\n static bool\n-check_loadstore (gimple stmt, tree op, tree, void *data)\n+check_loadstore (gimple *stmt, tree op, tree, void *data)\n {\n   if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n       && operand_equal_p (TREE_OPERAND (op, 0), (tree)data, 0))\n@@ -80,7 +80,7 @@ insert_trap (gimple_stmt_iterator *si_p, tree op)\n      If the dereference is a store and we can easily transform the RHS,\n      then simplify the RHS to enable more DCE.   Note that we require the\n      statement to be a GIMPLE_ASSIGN which filters out calls on the RHS.  */\n-  gimple stmt = gsi_stmt (*si_p);\n+  gimple *stmt = gsi_stmt (*si_p);\n   if (walk_stmt_load_store_ops (stmt, (void *)op, NULL, check_loadstore)\n       && is_gimple_assign (stmt)\n       && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (stmt))))\n@@ -136,7 +136,7 @@ insert_trap (gimple_stmt_iterator *si_p, tree op)\n \n basic_block\n isolate_path (basic_block bb, basic_block duplicate,\n-\t      edge e, gimple stmt, tree op, bool ret_zero)\n+\t      edge e, gimple *stmt, tree op, bool ret_zero)\n {\n   gimple_stmt_iterator si, si2;\n   edge_iterator ei;\n@@ -266,7 +266,7 @@ find_implicit_erroneous_behaviour (void)\n \t      tree op = gimple_phi_arg_def (phi, i);\n \t      edge e = gimple_phi_arg_edge (phi, i);\n \t      imm_use_iterator iter;\n-\t      gimple use_stmt;\n+\t      gimple *use_stmt;\n \n \t      next_i = i + 1;\n \n@@ -387,7 +387,7 @@ find_explicit_erroneous_behaviour (void)\n \t because of jump threading and constant propagation.  */\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  gimple stmt = gsi_stmt (si);\n+\t  gimple *stmt = gsi_stmt (si);\n \n \t  /* By passing null_pointer_node, we can use the\n \t     infer_nonnull_range functions to detect explicit NULL"}, {"sha": "7d549ca1cbe5e5c9850f774fc2204b0cd003b7d5", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -241,7 +241,7 @@ enum cand_kind\n struct slsr_cand_d\n {\n   /* The candidate statement S1.  */\n-  gimple cand_stmt;\n+  gimple *cand_stmt;\n \n   /* The base expression B:  often an SSA name, but not always.  */\n   tree base_expr;\n@@ -377,7 +377,7 @@ enum count_phis_status\n };\n  \n /* Pointer map embodying a mapping from statements to candidates.  */\n-static hash_map<gimple, slsr_cand_t> *stmt_cand_map;\n+static hash_map<gimple *, slsr_cand_t> *stmt_cand_map;\n \n /* Obstack for candidates.  */\n static struct obstack cand_obstack;\n@@ -626,7 +626,7 @@ record_potential_basis (slsr_cand_t c, tree base)\n      a2[i + 20][j] = 2;  */\n \n static slsr_cand_t\n-alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base,\n+alloc_cand_and_find_basis (enum cand_kind kind, gimple *gs, tree base,\n \t\t\t   const widest_int &index, tree stride, tree ctype,\n \t\t\t   unsigned savings)\n {\n@@ -667,7 +667,7 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base,\n    to SPEED.  */\n \n static int\n-stmt_cost (gimple gs, bool speed)\n+stmt_cost (gimple *gs, bool speed)\n {\n   tree lhs, rhs1, rhs2;\n   machine_mode lhs_mode;\n@@ -718,7 +718,7 @@ base_cand_from_table (tree base_in)\n {\n   slsr_cand_t *result;\n \n-  gimple def = SSA_NAME_DEF_STMT (base_in);\n+  gimple *def = SSA_NAME_DEF_STMT (base_in);\n   if (!def)\n     return (slsr_cand_t) NULL;\n \n@@ -733,7 +733,7 @@ base_cand_from_table (tree base_in)\n /* Add an entry to the statement-to-candidate mapping.  */\n \n static void\n-add_cand_for_stmt (gimple gs, slsr_cand_t c)\n+add_cand_for_stmt (gimple *gs, slsr_cand_t c)\n {\n   gcc_assert (!stmt_cand_map->put (gs, c));\n }\n@@ -763,7 +763,7 @@ slsr_process_phi (gphi *phi, bool speed)\n       slsr_cand_t arg_cand;\n       tree arg = gimple_phi_arg_def (phi, i);\n       tree derived_base_name = NULL_TREE;\n-      gimple arg_stmt = NULL;\n+      gimple *arg_stmt = NULL;\n       basic_block arg_bb = NULL;\n \n       if (TREE_CODE (arg) != SSA_NAME)\n@@ -980,7 +980,7 @@ restructure_reference (tree *pbase, tree *poffset, widest_int *pindex,\n    the candidate table and attempt to find a basis.  */\n \n static void\n-slsr_process_ref (gimple gs)\n+slsr_process_ref (gimple *gs)\n {\n   tree ref_expr, base, offset, type;\n   HOST_WIDE_INT bitsize, bitpos;\n@@ -1019,7 +1019,7 @@ slsr_process_ref (gimple gs)\n    candidate.  */\n \n static slsr_cand_t\n-create_mul_ssa_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n+create_mul_ssa_cand (gimple *gs, tree base_in, tree stride_in, bool speed)\n {\n   tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL_TREE;\n   widest_int index;\n@@ -1089,7 +1089,7 @@ create_mul_ssa_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n    candidate.  */\n \n static slsr_cand_t\n-create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n+create_mul_imm_cand (gimple *gs, tree base_in, tree stride_in, bool speed)\n {\n   tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL_TREE;\n   widest_int index, temp;\n@@ -1179,7 +1179,7 @@ create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n    find a basis.  */\n \n static void\n-slsr_process_mul (gimple gs, tree rhs1, tree rhs2, bool speed)\n+slsr_process_mul (gimple *gs, tree rhs1, tree rhs2, bool speed)\n {\n   slsr_cand_t c, c2;\n \n@@ -1221,7 +1221,7 @@ slsr_process_mul (gimple gs, tree rhs1, tree rhs2, bool speed)\n    Return the new candidate.  */\n \n static slsr_cand_t\n-create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n+create_add_ssa_cand (gimple *gs, tree base_in, tree addend_in,\n \t\t     bool subtract_p, bool speed)\n {\n   tree base = NULL_TREE, stride = NULL_TREE, ctype = NULL;\n@@ -1336,7 +1336,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n    about BASE_IN into the new candidate.  Return the new candidate.  */\n \n static slsr_cand_t\n-create_add_imm_cand (gimple gs, tree base_in, const widest_int &index_in,\n+create_add_imm_cand (gimple *gs, tree base_in, const widest_int &index_in,\n \t\t     bool speed)\n {\n   enum cand_kind kind = CAND_ADD;\n@@ -1399,7 +1399,7 @@ create_add_imm_cand (gimple gs, tree base_in, const widest_int &index_in,\n    make at least one appropriate entry in the candidate table.  */\n \n static void\n-slsr_process_add (gimple gs, tree rhs1, tree rhs2, bool speed)\n+slsr_process_add (gimple *gs, tree rhs1, tree rhs2, bool speed)\n {\n   bool subtract_p = gimple_assign_rhs_code (gs) == MINUS_EXPR;\n   slsr_cand_t c = NULL, c2;\n@@ -1454,7 +1454,7 @@ slsr_process_add (gimple gs, tree rhs1, tree rhs2, bool speed)\n    by -1.  */\n \n static void\n-slsr_process_neg (gimple gs, tree rhs1, bool speed)\n+slsr_process_neg (gimple *gs, tree rhs1, bool speed)\n {\n   /* Record a CAND_MULT interpretation for the multiply by -1.  */\n   slsr_cand_t c = create_mul_imm_cand (gs, rhs1, integer_minus_one_node, speed);\n@@ -1527,7 +1527,7 @@ legal_cast_p_1 (tree lhs, tree rhs)\n    have different semantics.  */\n \n static bool\n-legal_cast_p (gimple gs, tree rhs)\n+legal_cast_p (gimple *gs, tree rhs)\n {\n   if (!is_gimple_assign (gs)\n       || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (gs)))\n@@ -1541,7 +1541,7 @@ legal_cast_p (gimple gs, tree rhs)\n    appropriate entry in the candidate table.  */\n \n static void\n-slsr_process_cast (gimple gs, tree rhs1, bool speed)\n+slsr_process_cast (gimple *gs, tree rhs1, bool speed)\n {\n   tree lhs, ctype;\n   slsr_cand_t base_cand, c, c2;\n@@ -1606,7 +1606,7 @@ slsr_process_cast (gimple gs, tree rhs1, bool speed)\n    propagation, such as DOM.  */\n \n static void\n-slsr_process_copy (gimple gs, tree rhs1, bool speed)\n+slsr_process_copy (gimple *gs, tree rhs1, bool speed)\n {\n   slsr_cand_t base_cand, c, c2;\n   unsigned savings = 0;\n@@ -1677,7 +1677,7 @@ find_candidates_dom_walker::before_dom_children (basic_block bb)\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n        gsi_next (&gsi))\n     {\n-      gimple gs = gsi_stmt (gsi);\n+      gimple *gs = gsi_stmt (gsi);\n \n       if (gimple_vuse (gs) && gimple_assign_single_p (gs))\n \tslsr_process_ref (gs);\n@@ -2032,7 +2032,7 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)\n     {\n       enum tree_code code = PLUS_EXPR;\n       tree bump_tree;\n-      gimple stmt_to_print = NULL;\n+      gimple *stmt_to_print = NULL;\n \n       /* If the basis name and the candidate's LHS have incompatible\n \t types, introduce a cast.  */\n@@ -2231,7 +2231,7 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n    constant.  */\n \n static tree\n-create_phi_basis (slsr_cand_t c, gimple from_phi, tree basis_name,\n+create_phi_basis (slsr_cand_t c, gimple *from_phi, tree basis_name,\n \t\t  location_t loc, bool known_stride)\n {\n   int i;\n@@ -2265,7 +2265,7 @@ create_phi_basis (slsr_cand_t c, gimple from_phi, tree basis_name,\n \t  }\n       else\n \t{\n-\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  /* If there is another phi along this incoming edge, we must\n \t     process it in the same fashion to ensure that all basis\n@@ -2346,7 +2346,7 @@ replace_conditional_candidate (slsr_cand_t c)\n    for those phis as well.  */\n \n static int\n-phi_add_costs (gimple phi, slsr_cand_t c, int one_add_cost)\n+phi_add_costs (gimple *phi, slsr_cand_t c, int one_add_cost)\n {\n   unsigned i;\n   int cost = 0;\n@@ -2370,7 +2370,7 @@ phi_add_costs (gimple phi, slsr_cand_t c, int one_add_cost)\n \n       if (arg != phi_cand->base_expr)\n \t{\n-\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n \t    cost += phi_add_costs (arg_def, c, one_add_cost);\n@@ -2407,7 +2407,7 @@ replace_uncond_cands_and_profitable_phis (slsr_cand_t c)\n \t     savings to determine profitability.  */\n \t  bool speed = optimize_bb_for_speed_p (gimple_bb (c->cand_stmt));\n \t  int mult_savings = stmt_cost (c->cand_stmt, speed);\n-\t  gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+\t  gimple *phi = lookup_cand (c->def_phi)->cand_stmt;\n \t  tree phi_result = gimple_phi_result (phi);\n \t  int one_add_cost = add_cost (speed, \n \t\t\t\t       TYPE_MODE (TREE_TYPE (phi_result)));\n@@ -2558,7 +2558,7 @@ record_increment (slsr_cand_t c, widest_int increment, bool is_phi_adjust)\n    index of the basis.  */\n \n static void\n-record_phi_increments (slsr_cand_t basis, gimple phi)\n+record_phi_increments (slsr_cand_t basis, gimple *phi)\n {\n   unsigned i;\n   slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));\n@@ -2569,7 +2569,7 @@ record_phi_increments (slsr_cand_t basis, gimple phi)\n \n       if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n \t{\n-\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n \t    record_phi_increments (basis, arg_def);\n@@ -2627,7 +2627,8 @@ record_increments (slsr_cand_t c)\n    uses.  */\n \n static int\n-phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple phi, int *savings)\n+phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple *phi,\n+\t       int *savings)\n {\n   unsigned i;\n   int cost = 0;\n@@ -2640,7 +2641,7 @@ phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple phi, int *savings)\n \n       if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n \t{\n-\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n       \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n \t    {\n@@ -2733,7 +2734,7 @@ lowest_cost_path (int cost_in, int repl_savings, slsr_cand_t c,\n       && phi_dependent_cand_p (c)\n       && !cand_already_replaced (c))\n     {\n-      gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+      gimple *phi = lookup_cand (c->def_phi)->cand_stmt;\n       local_cost += phi_incr_cost (c, incr, phi, &savings);\n \n       if (has_single_use (gimple_phi_result (phi)))\n@@ -2777,7 +2778,7 @@ total_savings (int repl_savings, slsr_cand_t c, const widest_int &incr,\n       && !cand_already_replaced (c))\n     {\n       int phi_savings = 0;\n-      gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+      gimple *phi = lookup_cand (c->def_phi)->cand_stmt;\n       savings -= phi_incr_cost (c, incr, phi, &phi_savings);\n \n       if (has_single_use (gimple_phi_result (phi)))\n@@ -2984,7 +2985,7 @@ ncd_with_phi (slsr_cand_t c, const widest_int &incr, gphi *phi,\n \n       if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n \t{\n-\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n \t    ncd = ncd_with_phi (c, incr, as_a <gphi *> (arg_def), ncd,\n@@ -3160,7 +3161,7 @@ insert_initializers (slsr_cand_t c)\n       else\n \t{\n \t  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-\t  gimple basis_stmt = lookup_cand (c->basis)->cand_stmt;\n+\t  gimple *basis_stmt = lookup_cand (c->basis)->cand_stmt;\n \n \t  if (!gsi_end_p (gsi) && is_ctrl_stmt (gsi_stmt (gsi)))\n \t    gsi_insert_before (&gsi, init_stmt, GSI_SAME_STMT);\n@@ -3182,7 +3183,7 @@ insert_initializers (slsr_cand_t c)\n    are profitable to replace on behalf of candidate C.  */\n \n static bool\n-all_phi_incrs_profitable (slsr_cand_t c, gimple phi)\n+all_phi_incrs_profitable (slsr_cand_t c, gimple *phi)\n {\n   unsigned i;\n   slsr_cand_t basis = lookup_cand (c->basis);\n@@ -3194,7 +3195,7 @@ all_phi_incrs_profitable (slsr_cand_t c, gimple phi)\n \n       if (!operand_equal_p (arg, phi_cand->base_expr, 0))\n \t{\n-\t  gimple arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n \t    {\n@@ -3273,7 +3274,7 @@ introduce_cast_before_cand (slsr_cand_t c, tree to_type, tree from_expr)\n    If the replacement was made and we are doing a details dump,\n    return the revised statement, else NULL.  */\n \n-static gimple\n+static gimple *\n replace_rhs_if_not_dup (enum tree_code new_code, tree new_rhs1, tree new_rhs2,\n \t\t\tenum tree_code old_code, tree old_rhs1, tree old_rhs2,\n \t\t\tslsr_cand_t c)\n@@ -3308,7 +3309,7 @@ replace_rhs_if_not_dup (enum tree_code new_code, tree new_rhs1, tree new_rhs2,\n static void\n replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n {\n-  gimple stmt_to_print = NULL;\n+  gimple *stmt_to_print = NULL;\n   tree orig_rhs1, orig_rhs2;\n   tree rhs2;\n   enum tree_code orig_code, repl_code;\n@@ -3465,7 +3466,7 @@ replace_profitable_candidates (slsr_cand_t c)\n \t{\n \t  if (phi_dependent_cand_p (c))\n \t    {\n-\t      gimple phi = lookup_cand (c->def_phi)->cand_stmt;\n+\t      gimple *phi = lookup_cand (c->def_phi)->cand_stmt;\n \n \t      if (all_phi_incrs_profitable (c, phi))\n \t\t{\n@@ -3622,7 +3623,7 @@ pass_strength_reduction::execute (function *fun)\n   cand_vec.create (128);\n \n   /* Allocate the mapping from statements to candidate indices.  */\n-  stmt_cand_map = new hash_map<gimple, slsr_cand_t>;\n+  stmt_cand_map = new hash_map<gimple *, slsr_cand_t>;\n \n   /* Create the obstack where candidate chains will reside.  */\n   gcc_obstack_init (&chain_obstack);"}, {"sha": "c89071e8639124f8faf7b5f60c8337b94756a4f7", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n    or list of labels to represent transaction restart.  */\n \n struct GTY((for_user)) tm_restart_node {\n-  gimple stmt;\n+  gimple *stmt;\n   tree label_or_list;\n };\n \n@@ -72,7 +72,7 @@ struct GTY(()) gimple_df {\n      indirect call has been turned into a noreturn call.  When this\n      happens, all the instructions after the call are no longer\n      reachable and must be deleted as dead.  */\n-  vec<gimple, va_gc> *modified_noreturn_calls;\n+  vec<gimple *, va_gc> *modified_noreturn_calls;\n \n   /* Array of all SSA_NAMEs used in the function.  */\n   vec<tree, va_gc> *ssa_names;\n@@ -137,7 +137,7 @@ gimple_vop (const struct function *fun)\n /* Return the set of VUSE operand for statement G.  */\n \n static inline use_operand_p\n-gimple_vuse_op (const_gimple g)\n+gimple_vuse_op (const gimple *g)\n {\n   struct use_optype_d *ops;\n   const gimple_statement_with_memory_ops *mem_ops_stmt =\n@@ -154,7 +154,7 @@ gimple_vuse_op (const_gimple g)\n /* Return the set of VDEF operand for statement G.  */\n \n static inline def_operand_p\n-gimple_vdef_op (gimple g)\n+gimple_vdef_op (gimple *g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n      dyn_cast <gimple_statement_with_memory_ops *> (g);\n@@ -168,7 +168,7 @@ gimple_vdef_op (gimple g)\n /* Mark statement S as modified, and update it.  */\n \n static inline void\n-update_stmt (gimple s)\n+update_stmt (gimple *s)\n {\n   if (gimple_has_ops (s))\n     {\n@@ -180,7 +180,7 @@ update_stmt (gimple s)\n /* Update statement S if it has been optimized.  */\n \n static inline void\n-update_stmt_if_modified (gimple s)\n+update_stmt_if_modified (gimple *s)\n {\n   if (gimple_modified_p (s))\n     update_stmt_operands (cfun, s);\n@@ -189,7 +189,7 @@ update_stmt_if_modified (gimple s)\n /* Mark statement S as modified, and update it.  */\n \n static inline void\n-update_stmt_fn (struct function *fn, gimple s)\n+update_stmt_fn (struct function *fn, gimple *s)\n {\n   if (gimple_has_ops (s))\n     {"}, {"sha": "45bb45f52e453401d4f9697c398a6eb807adcc33", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -88,11 +88,11 @@ input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n /* Read a statement with tag TAG in function FN from block IB using\n    descriptors in DATA_IN.  */\n \n-static gimple\n+static gimple *\n input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t   enum LTO_tags tag)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   enum gimple_code code;\n   unsigned HOST_WIDE_INT num_ops;\n   size_t i;\n@@ -279,7 +279,7 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n   tag = streamer_read_record_start (ib);\n   while (tag)\n     {\n-      gimple stmt = input_gimple_stmt (ib, data_in, tag);\n+      gimple *stmt = input_gimple_stmt (ib, data_in, tag);\n       gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n \n       /* After the statement, expect a 0 delimiter or the EH region"}, {"sha": "0be5b6d21420fa681621547adf039c6bd7b33b3e", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -61,7 +61,7 @@ output_phi (struct output_block *ob, gphi *phi)\n /* Emit statement STMT on the main stream of output block OB.  */\n \n static void\n-output_gimple_stmt (struct output_block *ob, gimple stmt)\n+output_gimple_stmt (struct output_block *ob, gimple *stmt)\n {\n   unsigned i;\n   enum gimple_code code;\n@@ -223,7 +223,7 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n \t  int region;\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \n \t  output_gimple_stmt (ob, stmt);\n "}, {"sha": "e62cf62be1239e3c5d38d033dfd9b875629a257d", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    Otherwise, all the statements are walked and NULL returned.  */\n \n-gimple\n+gimple *\n walk_gimple_seq_mod (gimple_seq *pseq, walk_stmt_fn callback_stmt,\n \t\t     walk_tree_fn callback_op, struct walk_stmt_info *wi)\n {\n@@ -76,12 +76,12 @@ walk_gimple_seq_mod (gimple_seq *pseq, walk_stmt_fn callback_stmt,\n /* Like walk_gimple_seq_mod, but ensure that the head of SEQ isn't\n    changed by the callbacks.  */\n \n-gimple\n+gimple *\n walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n \t\t walk_tree_fn callback_op, struct walk_stmt_info *wi)\n {\n   gimple_seq seq2 = seq;\n-  gimple ret = walk_gimple_seq_mod (&seq2, callback_stmt, callback_op, wi);\n+  gimple *ret = walk_gimple_seq_mod (&seq2, callback_stmt, callback_op, wi);\n   gcc_assert (seq2 == seq);\n   return ret;\n }\n@@ -178,7 +178,7 @@ walk_gimple_asm (gasm *stmt, walk_tree_fn callback_op,\n    NULL_TREE if no CALLBACK_OP is specified.  */\n \n tree\n-walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n+walk_gimple_op (gimple *stmt, walk_tree_fn callback_op,\n \t\tstruct walk_stmt_info *wi)\n {\n   hash_set<tree> *pset = (wi) ? wi->pset : NULL;\n@@ -521,9 +521,9 @@ tree\n walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n \t\t  walk_tree_fn callback_op, struct walk_stmt_info *wi)\n {\n-  gimple ret;\n+  gimple *ret;\n   tree tree_ret;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (wi)\n     {\n@@ -688,7 +688,7 @@ get_base_loadstore (tree op)\n    Returns the results of these callbacks or'ed.  */\n \n bool\n-walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n+walk_stmt_load_store_addr_ops (gimple *stmt, void *data,\n \t\t\t       walk_stmt_load_store_addr_fn visit_load,\n \t\t\t       walk_stmt_load_store_addr_fn visit_store,\n \t\t\t       walk_stmt_load_store_addr_fn visit_addr)\n@@ -906,7 +906,7 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n    should make a faster clone for this case.  */\n \n bool\n-walk_stmt_load_store_ops (gimple stmt, void *data,\n+walk_stmt_load_store_ops (gimple *stmt, void *data,\n \t\t\t  walk_stmt_load_store_addr_fn visit_load,\n \t\t\t  walk_stmt_load_store_addr_fn visit_store)\n {"}, {"sha": "5b349a39cc9c4175885066b708b82e3aa4e07a43", "filename": "gcc/gimple-walk.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-walk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple-walk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -82,19 +82,19 @@ struct walk_stmt_info\n typedef tree (*walk_stmt_fn) (gimple_stmt_iterator *, bool *,\n \t\t\t      struct walk_stmt_info *);\n \n-extern gimple walk_gimple_seq_mod (gimple_seq *, walk_stmt_fn, walk_tree_fn,\n+extern gimple *walk_gimple_seq_mod (gimple_seq *, walk_stmt_fn, walk_tree_fn,\n \t\t\t\t   struct walk_stmt_info *);\n-extern gimple walk_gimple_seq (gimple_seq, walk_stmt_fn, walk_tree_fn,\n+extern gimple *walk_gimple_seq (gimple_seq, walk_stmt_fn, walk_tree_fn,\n \t\t\t       struct walk_stmt_info *);\n-extern tree walk_gimple_op (gimple, walk_tree_fn, struct walk_stmt_info *);\n+extern tree walk_gimple_op (gimple *, walk_tree_fn, struct walk_stmt_info *);\n extern tree walk_gimple_stmt (gimple_stmt_iterator *, walk_stmt_fn,\n \t\t\t      walk_tree_fn, struct walk_stmt_info *);\n-typedef bool (*walk_stmt_load_store_addr_fn) (gimple, tree, tree, void *);\n-extern bool walk_stmt_load_store_addr_ops (gimple, void *,\n+typedef bool (*walk_stmt_load_store_addr_fn) (gimple *, tree, tree, void *);\n+extern bool walk_stmt_load_store_addr_ops (gimple *, void *,\n \t\t\t\t\t   walk_stmt_load_store_addr_fn,\n \t\t\t\t\t   walk_stmt_load_store_addr_fn,\n \t\t\t\t\t   walk_stmt_load_store_addr_fn);\n-extern bool walk_stmt_load_store_ops (gimple, void *,\n+extern bool walk_stmt_load_store_ops (gimple *, void *,\n \t\t\t\t      walk_stmt_load_store_addr_fn,\n \t\t\t\t      walk_stmt_load_store_addr_fn);\n #endif /* GCC_GIMPLE_WALK_H */"}, {"sha": "c3762e19993a29ffe9c7b09b9fdf67494a60accc", "filename": "gcc/gimple.c", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -102,7 +102,7 @@ const enum gimple_code gcond::code_;\n /* Set the code for statement G to CODE.  */\n \n static inline void\n-gimple_set_code (gimple g, enum gimple_code code)\n+gimple_set_code (gimple *g, enum gimple_code code)\n {\n   g->code = code;\n }\n@@ -119,11 +119,11 @@ gimple_size (enum gimple_code code)\n /* Allocate memory for a GIMPLE statement with code CODE and NUM_OPS\n    operands.  */\n \n-gimple\n+gimple *\n gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n {\n   size_t size;\n-  gimple stmt;\n+  gimple *stmt;\n \n   size = gimple_size (code);\n   if (num_ops > 0)\n@@ -151,7 +151,7 @@ gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n /* Set SUBCODE to be the code of the expression computed by statement G.  */\n \n static inline void\n-gimple_set_subcode (gimple g, unsigned subcode)\n+gimple_set_subcode (gimple *g, unsigned subcode)\n {\n   /* We only have 16 bits for the RHS code.  Assert that we are not\n      overflowing it.  */\n@@ -168,11 +168,11 @@ gimple_set_subcode (gimple g, unsigned subcode)\n #define gimple_build_with_ops(c, s, n) \\\n   gimple_build_with_ops_stat (c, s, n MEM_STAT_INFO)\n \n-static gimple\n+static gimple *\n gimple_build_with_ops_stat (enum gimple_code code, unsigned subcode,\n \t\t            unsigned num_ops MEM_STAT_DECL)\n {\n-  gimple s = gimple_alloc_stat (code, num_ops PASS_MEM_STAT);\n+  gimple *s = gimple_alloc_stat (code, num_ops PASS_MEM_STAT);\n   gimple_set_subcode (s, subcode);\n \n   return s;\n@@ -536,7 +536,7 @@ gimple_build_goto (tree dest)\n \n /* Build a GIMPLE_NOP statement.  */\n \n-gimple\n+gimple *\n gimple_build_nop (void)\n {\n   return gimple_alloc (GIMPLE_NOP, 0);\n@@ -719,10 +719,10 @@ gimple_build_try (gimple_seq eval, gimple_seq cleanup,\n \n    CLEANUP is the cleanup expression.  */\n \n-gimple\n+gimple *\n gimple_build_wce (gimple_seq cleanup)\n {\n-  gimple p = gimple_alloc (GIMPLE_WITH_CLEANUP_EXPR, 0);\n+  gimple *p = gimple_alloc (GIMPLE_WITH_CLEANUP_EXPR, 0);\n   if (cleanup)\n     gimple_wce_set_cleanup (p, cleanup);\n \n@@ -797,7 +797,7 @@ gimple_build_eh_dispatch (int region)\n    VAR is bound to VALUE; block and location are taken from STMT.  */\n \n gdebug *\n-gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n+gimple_build_debug_bind_stat (tree var, tree value, gimple *stmt MEM_STAT_DECL)\n {\n   gdebug *p\n     = as_a <gdebug *> (gimple_build_with_ops_stat (GIMPLE_DEBUG,\n@@ -818,7 +818,7 @@ gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n \n gdebug *\n gimple_build_debug_source_bind_stat (tree var, tree value,\n-\t\t\t\t     gimple stmt MEM_STAT_DECL)\n+\t\t\t\t     gimple *stmt MEM_STAT_DECL)\n {\n   gdebug *p\n     = as_a <gdebug *> (\n@@ -934,10 +934,10 @@ gimple_build_omp_task (gimple_seq body, tree clauses, tree child_fn,\n \n    BODY is the sequence of statements in the section.  */\n \n-gimple\n+gimple *\n gimple_build_omp_section (gimple_seq body)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_SECTION, 0);\n+  gimple *p = gimple_alloc (GIMPLE_OMP_SECTION, 0);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -949,10 +949,10 @@ gimple_build_omp_section (gimple_seq body)\n \n    BODY is the sequence of statements to be executed by just the master.  */\n \n-gimple\n+gimple *\n gimple_build_omp_master (gimple_seq body)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_MASTER, 0);\n+  gimple *p = gimple_alloc (GIMPLE_OMP_MASTER, 0);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -965,10 +965,10 @@ gimple_build_omp_master (gimple_seq body)\n    BODY is the sequence of statements to be executed by the taskgroup\n    construct.  */\n \n-gimple\n+gimple *\n gimple_build_omp_taskgroup (gimple_seq body)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_TASKGROUP, 0);\n+  gimple *p = gimple_alloc (GIMPLE_OMP_TASKGROUP, 0);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -996,10 +996,10 @@ gimple_build_omp_continue (tree control_def, tree control_use)\n    BODY is the sequence of statements inside a loop that will executed in\n    sequence.  */\n \n-gimple\n+gimple *\n gimple_build_omp_ordered (gimple_seq body)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_ORDERED, 0);\n+  gimple *p = gimple_alloc (GIMPLE_OMP_ORDERED, 0);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -1010,10 +1010,10 @@ gimple_build_omp_ordered (gimple_seq body)\n /* Build a GIMPLE_OMP_RETURN statement.\n    WAIT_P is true if this is a non-waiting return.  */\n \n-gimple\n+gimple *\n gimple_build_omp_return (bool wait_p)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_RETURN, 0);\n+  gimple *p = gimple_alloc (GIMPLE_OMP_RETURN, 0);\n   if (wait_p)\n     gimple_omp_return_set_nowait (p);\n \n@@ -1042,7 +1042,7 @@ gimple_build_omp_sections (gimple_seq body, tree clauses)\n \n /* Build a GIMPLE_OMP_SECTIONS_SWITCH.  */\n \n-gimple\n+gimple *\n gimple_build_omp_sections_switch (void)\n {\n   return gimple_alloc (GIMPLE_OMP_SECTIONS_SWITCH, 0);\n@@ -1146,7 +1146,7 @@ gimple_build_transaction (gimple_seq body, tree label)\n /* Complain of a gimple type mismatch and die.  */\n \n void\n-gimple_check_failed (const_gimple gs, const char *file, int line,\n+gimple_check_failed (const gimple *gs, const char *file, int line,\n \t\t     const char *function, enum gimple_code code,\n \t\t     enum tree_code subcode)\n {\n@@ -1166,7 +1166,7 @@ gimple_check_failed (const_gimple gs, const char *file, int line,\n    *SEQ_P is NULL, a new sequence is allocated.  */\n \n void\n-gimple_seq_add_stmt (gimple_seq *seq_p, gimple gs)\n+gimple_seq_add_stmt (gimple_seq *seq_p, gimple *gs)\n {\n   gimple_stmt_iterator si;\n   if (gs == NULL)\n@@ -1183,7 +1183,7 @@ gimple_seq_add_stmt (gimple_seq *seq_p, gimple gs)\n    before the def/use vectors have been constructed.  */\n \n void\n-gimple_seq_add_stmt_without_update (gimple_seq *seq_p, gimple gs)\n+gimple_seq_add_stmt_without_update (gimple_seq *seq_p, gimple *gs)\n {\n   gimple_stmt_iterator si;\n \n@@ -1226,7 +1226,7 @@ gimple_seq_add_seq_without_update (gimple_seq *dst_p, gimple_seq src)\n /* Determine whether to assign a location to the statement GS.  */\n \n static bool\n-should_carry_location_p (gimple gs)\n+should_carry_location_p (gimple *gs)\n {\n   /* Don't emit a line note for a label.  We particularly don't want to\n      emit one for the break label, since it doesn't actually correspond\n@@ -1240,7 +1240,7 @@ should_carry_location_p (gimple gs)\n /* Set the location for gimple statement GS to LOCATION.  */\n \n static void\n-annotate_one_with_location (gimple gs, location_t location)\n+annotate_one_with_location (gimple *gs, location_t location)\n {\n   if (!gimple_has_location (gs)\n       && !gimple_do_not_emit_location_p (gs)\n@@ -1277,7 +1277,7 @@ annotate_all_with_location (gimple_seq stmt_p, location_t location)\n \n   for (i = gsi_start (stmt_p); !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple gs = gsi_stmt (i);\n+      gimple *gs = gsi_stmt (i);\n       annotate_one_with_location (gs, location);\n     }\n }\n@@ -1286,7 +1286,7 @@ annotate_all_with_location (gimple_seq stmt_p, location_t location)\n    statement.  */\n \n static bool\n-empty_stmt_p (gimple stmt)\n+empty_stmt_p (gimple *stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_NOP)\n     return true;\n@@ -1321,7 +1321,7 @@ gimple_seq_copy (gimple_seq src)\n {\n   gimple_stmt_iterator gsi;\n   gimple_seq new_seq = NULL;\n-  gimple stmt;\n+  gimple *stmt;\n \n   for (gsi = gsi_start (src); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n@@ -1337,7 +1337,7 @@ gimple_seq_copy (gimple_seq src)\n /* Return true if calls C1 and C2 are known to go to the same function.  */\n \n bool\n-gimple_call_same_target_p (const_gimple c1, const_gimple c2)\n+gimple_call_same_target_p (const gimple *c1, const gimple *c2)\n {\n   if (gimple_call_internal_p (c1))\n     return (gimple_call_internal_p (c2)\n@@ -1352,7 +1352,7 @@ gimple_call_same_target_p (const_gimple c1, const_gimple c2)\n    call_expr_flags, but for gimple tuples.  */\n \n int\n-gimple_call_flags (const_gimple stmt)\n+gimple_call_flags (const gimple *stmt)\n {\n   int flags;\n   tree decl = gimple_call_fndecl (stmt);\n@@ -1460,7 +1460,7 @@ gimple_call_return_flags (const gcall *stmt)\n /* Return true if GS is a copy assignment.  */\n \n bool\n-gimple_assign_copy_p (gimple gs)\n+gimple_assign_copy_p (gimple *gs)\n {\n   return (gimple_assign_single_p (gs)\n \t  && is_gimple_val (gimple_op (gs, 1)));\n@@ -1470,7 +1470,7 @@ gimple_assign_copy_p (gimple gs)\n /* Return true if GS is a SSA_NAME copy assignment.  */\n \n bool\n-gimple_assign_ssa_name_copy_p (gimple gs)\n+gimple_assign_ssa_name_copy_p (gimple *gs)\n {\n   return (gimple_assign_single_p (gs)\n \t  && TREE_CODE (gimple_assign_lhs (gs)) == SSA_NAME\n@@ -1493,7 +1493,7 @@ gimple_assign_ssa_name_copy_p (gimple gs)\n    treatment of unary NOPs is appropriate.  */\n \n bool\n-gimple_assign_unary_nop_p (gimple gs)\n+gimple_assign_unary_nop_p (gimple *gs)\n {\n   return (is_gimple_assign (gs)\n           && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (gs))\n@@ -1506,7 +1506,7 @@ gimple_assign_unary_nop_p (gimple gs)\n /* Set BB to be the basic block holding G.  */\n \n void\n-gimple_set_bb (gimple stmt, basic_block bb)\n+gimple_set_bb (gimple *stmt, basic_block bb)\n {\n   stmt->bb = bb;\n \n@@ -1580,13 +1580,13 @@ gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n \t\t\t\ttree op1, tree op2, tree op3)\n {\n   unsigned new_rhs_ops = get_gimple_rhs_num_ops (code);\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   /* If the new CODE needs more operands, allocate a new statement.  */\n   if (gimple_num_ops (stmt) < new_rhs_ops + 1)\n     {\n       tree lhs = gimple_assign_lhs (stmt);\n-      gimple new_stmt = gimple_alloc (gimple_code (stmt), new_rhs_ops + 1);\n+      gimple *new_stmt = gimple_alloc (gimple_code (stmt), new_rhs_ops + 1);\n       memcpy (new_stmt, stmt, gimple_size (gimple_code (stmt)));\n       gimple_init_singleton (new_stmt);\n       gsi_replace (gsi, new_stmt, true);\n@@ -1613,7 +1613,7 @@ gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n    statement other than an assignment or a call.  */\n \n tree\n-gimple_get_lhs (const_gimple stmt)\n+gimple_get_lhs (const gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n \n@@ -1630,7 +1630,7 @@ gimple_get_lhs (const_gimple stmt)\n    either a GIMPLE_ASSIGN or a GIMPLE_CALL.  */\n \n void\n-gimple_set_lhs (gimple stmt, tree lhs)\n+gimple_set_lhs (gimple *stmt, tree lhs)\n {\n   enum gimple_code code = gimple_code (stmt);\n \n@@ -1648,12 +1648,12 @@ gimple_set_lhs (gimple stmt, tree lhs)\n    and VUSE operand arrays are set to empty in the new copy.  The new\n    copy isn't part of any sequence.  */\n \n-gimple\n-gimple_copy (gimple stmt)\n+gimple *\n+gimple_copy (gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   unsigned num_ops = gimple_num_ops (stmt);\n-  gimple copy = gimple_alloc (code, num_ops);\n+  gimple *copy = gimple_alloc (code, num_ops);\n   unsigned i;\n \n   /* Shallow copy all the fields from STMT.  */\n@@ -1850,7 +1850,7 @@ gimple_copy (gimple stmt)\n    - Any of its operands are marked TREE_THIS_VOLATILE or TREE_SIDE_EFFECTS.  */\n \n bool\n-gimple_has_side_effects (const_gimple s)\n+gimple_has_side_effects (const gimple *s)\n {\n   if (is_gimple_debug (s))\n     return false;\n@@ -1886,7 +1886,7 @@ gimple_has_side_effects (const_gimple s)\n    S is a GIMPLE_ASSIGN, the LHS of the assignment is also checked.  */\n \n bool\n-gimple_could_trap_p_1 (gimple s, bool include_mem, bool include_stores)\n+gimple_could_trap_p_1 (gimple *s, bool include_mem, bool include_stores)\n {\n   tree t, div = NULL_TREE;\n   enum tree_code op;\n@@ -1932,15 +1932,15 @@ gimple_could_trap_p_1 (gimple s, bool include_mem, bool include_stores)\n /* Return true if statement S can trap.  */\n \n bool\n-gimple_could_trap_p (gimple s)\n+gimple_could_trap_p (gimple *s)\n {\n   return gimple_could_trap_p_1 (s, true, true);\n }\n \n /* Return true if RHS of a GIMPLE_ASSIGN S can trap.  */\n \n bool\n-gimple_assign_rhs_could_trap_p (gimple s)\n+gimple_assign_rhs_could_trap_p (gimple *s)\n {\n   gcc_assert (is_gimple_assign (s));\n   return gimple_could_trap_p_1 (s, true, false);\n@@ -2411,7 +2411,7 @@ gimple_get_alias_set (tree t)\n /* Helper for gimple_ior_addresses_taken_1.  */\n \n static bool\n-gimple_ior_addresses_taken_1 (gimple, tree addr, tree, void *data)\n+gimple_ior_addresses_taken_1 (gimple *, tree addr, tree, void *data)\n {\n   bitmap addresses_taken = (bitmap)data;\n   addr = get_base_address (addr);\n@@ -2429,7 +2429,7 @@ gimple_ior_addresses_taken_1 (gimple, tree addr, tree, void *data)\n    were any in this stmt.  */\n \n bool\n-gimple_ior_addresses_taken (bitmap addresses_taken, gimple stmt)\n+gimple_ior_addresses_taken (bitmap addresses_taken, gimple *stmt)\n {\n   return walk_stmt_load_store_addr_ops (stmt, addresses_taken, NULL, NULL,\n \t\t\t\t\tgimple_ior_addresses_taken_1);\n@@ -2458,7 +2458,7 @@ validate_type (tree type1, tree type2)\n    a decl of a builtin function.  */\n \n bool\n-gimple_builtin_call_types_compatible_p (const_gimple stmt, tree fndecl)\n+gimple_builtin_call_types_compatible_p (const gimple *stmt, tree fndecl)\n {\n   gcc_checking_assert (DECL_BUILT_IN_CLASS (fndecl) != NOT_BUILT_IN);\n \n@@ -2487,7 +2487,7 @@ gimple_builtin_call_types_compatible_p (const_gimple stmt, tree fndecl)\n /* Return true when STMT is builtins call.  */\n \n bool\n-gimple_call_builtin_p (const_gimple stmt)\n+gimple_call_builtin_p (const gimple *stmt)\n {\n   tree fndecl;\n   if (is_gimple_call (stmt)\n@@ -2500,7 +2500,7 @@ gimple_call_builtin_p (const_gimple stmt)\n /* Return true when STMT is builtins call to CLASS.  */\n \n bool\n-gimple_call_builtin_p (const_gimple stmt, enum built_in_class klass)\n+gimple_call_builtin_p (const gimple *stmt, enum built_in_class klass)\n {\n   tree fndecl;\n   if (is_gimple_call (stmt)\n@@ -2513,7 +2513,7 @@ gimple_call_builtin_p (const_gimple stmt, enum built_in_class klass)\n /* Return true when STMT is builtins call to CODE of CLASS.  */\n \n bool\n-gimple_call_builtin_p (const_gimple stmt, enum built_in_function code)\n+gimple_call_builtin_p (const gimple *stmt, enum built_in_function code)\n {\n   tree fndecl;\n   if (is_gimple_call (stmt)\n@@ -2569,7 +2569,7 @@ dump_decl_set (FILE *file, bitmap set)\n /* Return true when CALL is a call stmt that definitely doesn't\n    free any memory or makes it unavailable otherwise.  */\n bool\n-nonfreeing_call_p (gimple call)\n+nonfreeing_call_p (gimple *call)\n {\n   if (gimple_call_builtin_p (call, BUILT_IN_NORMAL)\n       && gimple_call_flags (call) & ECF_LEAF)\n@@ -2616,7 +2616,7 @@ nonfreeing_call_p (gimple call)\n    This routine only makes a superficial check for a dereference.  Thus\n    it must only be used if it is safe to return a false negative.  */\n static bool\n-check_loadstore (gimple, tree op, tree, void *data)\n+check_loadstore (gimple *, tree op, tree, void *data)\n {\n   if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n       && operand_equal_p (TREE_OPERAND (op, 0), (tree)data, 0))\n@@ -2628,7 +2628,7 @@ check_loadstore (gimple, tree op, tree, void *data)\n /* Return true if OP can be inferred to be non-NULL after STMT executes,\n    either by using a pointer dereference or attributes.  */\n bool\n-infer_nonnull_range (gimple stmt, tree op)\n+infer_nonnull_range (gimple *stmt, tree op)\n {\n   return infer_nonnull_range_by_dereference (stmt, op)\n     || infer_nonnull_range_by_attribute (stmt, op);\n@@ -2637,7 +2637,7 @@ infer_nonnull_range (gimple stmt, tree op)\n /* Return true if OP can be inferred to be non-NULL after STMT\n    executes by using a pointer dereference.  */\n bool\n-infer_nonnull_range_by_dereference (gimple stmt, tree op)\n+infer_nonnull_range_by_dereference (gimple *stmt, tree op)\n {\n   /* We can only assume that a pointer dereference will yield\n      non-NULL if -fdelete-null-pointer-checks is enabled.  */\n@@ -2656,7 +2656,7 @@ infer_nonnull_range_by_dereference (gimple stmt, tree op)\n /* Return true if OP can be inferred to be a non-NULL after STMT\n    executes by using attributes.  */\n bool\n-infer_nonnull_range_by_attribute (gimple stmt, tree op)\n+infer_nonnull_range_by_attribute (gimple *stmt, tree op)\n {\n   /* We can only assume that a pointer dereference will yield\n      non-NULL if -fdelete-null-pointer-checks is enabled.  */\n@@ -2933,7 +2933,7 @@ gimple_seq_discard (gimple_seq seq)\n \n   for (gsi = gsi_start (seq); !gsi_end_p (gsi); )\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       gsi_remove (&gsi, true);\n       release_defs (stmt);\n       ggc_free (stmt);\n@@ -2945,7 +2945,7 @@ gimple_seq_discard (gimple_seq seq)\n    to __builtiln_unreacahble or __cxa_pure_virutal.  */\n \n void\n-maybe_remove_unused_call_args (struct function *fn, gimple stmt)\n+maybe_remove_unused_call_args (struct function *fn, gimple *stmt)\n {\n   tree decl = gimple_call_fndecl (stmt);\n   if (TYPE_ARG_TYPES (TREE_TYPE (decl))"}, {"sha": "91c26b65f088f634742adedb6c1c7f09e5fed639", "filename": "gcc/gimple.h", "status": "modified", "additions": 349, "deletions": 349, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n #include \"gimple-expr.h\"\n \n-typedef gimple gimple_seq_node;\n+typedef gimple *gimple_seq_node;\n \n enum gimple_code {\n #define DEFGSCODE(SYM, STRING, STRUCT)\tSYM,\n@@ -44,20 +44,20 @@ template<typename T> struct remove_pointer<T *> { typedef T type; };\n /* Error out if a gimple tuple is addressed incorrectly.  */\n #if defined ENABLE_GIMPLE_CHECKING\n #define gcc_gimple_checking_assert(EXPR) gcc_assert (EXPR)\n-extern void gimple_check_failed (const_gimple, const char *, int,          \\\n+extern void gimple_check_failed (const gimple *, const char *, int,        \\\n                                  const char *, enum gimple_code,           \\\n \t\t\t\t enum tree_code) ATTRIBUTE_NORETURN;\n \n #define GIMPLE_CHECK(GS, CODE)\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    const_gimple __gs = (GS);\t\t\t\t\t\t\\\n+    const gimple *__gs = (GS);\t\t\t\t\t\t\\\n     if (gimple_code (__gs) != (CODE))\t\t\t\t\t\\\n       gimple_check_failed (__gs, __FILE__, __LINE__, __FUNCTION__,\t\\\n \t  \t\t   (CODE), ERROR_MARK);\t\t\t\t\\\n   } while (0)\n template <typename T>\n static inline T\n-GIMPLE_CHECK2(const_gimple gs,\n+GIMPLE_CHECK2(const gimple *gs,\n #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n \t      const char *file = __builtin_FILE (),\n \t      int line = __builtin_LINE (),\n@@ -76,7 +76,7 @@ GIMPLE_CHECK2(const_gimple gs,\n }\n template <typename T>\n static inline T\n-GIMPLE_CHECK2(gimple gs,\n+GIMPLE_CHECK2(gimple *gs,\n #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n \t      const char *file = __builtin_FILE (),\n \t      int line = __builtin_LINE (),\n@@ -98,13 +98,13 @@ GIMPLE_CHECK2(gimple gs,\n #define GIMPLE_CHECK(GS, CODE)\t\t\t(void)0\n template <typename T>\n static inline T\n-GIMPLE_CHECK2(gimple gs)\n+GIMPLE_CHECK2(gimple *gs)\n {\n   return as_a <T> (gs);\n }\n template <typename T>\n static inline T\n-GIMPLE_CHECK2(const_gimple gs)\n+GIMPLE_CHECK2(const gimple *gs)\n {\n   return as_a <T> (gs);\n }\n@@ -200,7 +200,7 @@ enum plf_mask {\n \n struct GTY((desc (\"gimple_statement_structure (&%h)\"), tag (\"GSS_BASE\"),\n \t    chain_next (\"%h.next\"), variable_size))\n-  gimple_statement_base\n+  gimple\n {\n   /* [ WORD 1 ]\n      Main identifying code for a tuple.  */\n@@ -261,16 +261,16 @@ struct GTY((desc (\"gimple_statement_structure (&%h)\"), tag (\"GSS_BASE\"),\n      A gimple statement is hence also a double-ended list of\n      statements, with the pointer itself being the first element,\n      and the prev pointer being the last.  */\n-  gimple next;\n-  gimple GTY((skip)) prev;\n+  gimple *next;\n+  gimple *GTY((skip)) prev;\n };\n \n \n /* Base structure for tuples with operands.  */\n \n /* This gimple subclass has no tag value.  */\n struct GTY(())\n-  gimple_statement_with_ops_base : public gimple_statement_base\n+  gimple_statement_with_ops_base : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -359,7 +359,7 @@ struct GTY((tag(\"GSS_CALL\")))\n /* OMP statements.  */\n \n struct GTY((tag(\"GSS_OMP\")))\n-  gimple_statement_omp : public gimple_statement_base\n+  gimple_statement_omp : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -371,7 +371,7 @@ struct GTY((tag(\"GSS_OMP\")))\n /* GIMPLE_BIND */\n \n struct GTY((tag(\"GSS_BIND\")))\n-  gbind : public gimple_statement_base\n+  gbind : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -395,7 +395,7 @@ struct GTY((tag(\"GSS_BIND\")))\n /* GIMPLE_CATCH */\n \n struct GTY((tag(\"GSS_CATCH\")))\n-  gcatch : public gimple_statement_base\n+  gcatch : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -410,7 +410,7 @@ struct GTY((tag(\"GSS_CATCH\")))\n /* GIMPLE_EH_FILTER */\n \n struct GTY((tag(\"GSS_EH_FILTER\")))\n-  geh_filter : public gimple_statement_base\n+  geh_filter : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -426,7 +426,7 @@ struct GTY((tag(\"GSS_EH_FILTER\")))\n /* GIMPLE_EH_ELSE */\n \n struct GTY((tag(\"GSS_EH_ELSE\")))\n-  geh_else : public gimple_statement_base\n+  geh_else : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -437,7 +437,7 @@ struct GTY((tag(\"GSS_EH_ELSE\")))\n /* GIMPLE_EH_MUST_NOT_THROW */\n \n struct GTY((tag(\"GSS_EH_MNT\")))\n-  geh_mnt : public gimple_statement_base\n+  geh_mnt : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -448,7 +448,7 @@ struct GTY((tag(\"GSS_EH_MNT\")))\n /* GIMPLE_PHI */\n \n struct GTY((tag(\"GSS_PHI\")))\n-  gphi : public gimple_statement_base\n+  gphi : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -467,7 +467,7 @@ struct GTY((tag(\"GSS_PHI\")))\n /* GIMPLE_RESX, GIMPLE_EH_DISPATCH */\n \n struct GTY((tag(\"GSS_EH_CTRL\")))\n-  gimple_statement_eh_ctrl : public gimple_statement_base\n+  gimple_statement_eh_ctrl : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -494,7 +494,7 @@ struct GTY((tag(\"GSS_EH_CTRL\")))\n /* GIMPLE_TRY */\n \n struct GTY((tag(\"GSS_TRY\")))\n-  gtry : public gimple_statement_base\n+  gtry : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -524,7 +524,7 @@ enum gimple_try_flags\n /* GIMPLE_WITH_CLEANUP_EXPR */\n \n struct GTY((tag(\"GSS_WCE\")))\n-  gimple_statement_wce : public gimple_statement_base\n+  gimple_statement_wce : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -706,7 +706,7 @@ struct GTY((tag(\"GSS_OMP_SECTIONS\")))\n          do not need the body field.  */\n \n struct GTY((tag(\"GSS_OMP_CONTINUE\")))\n-  gomp_continue : public gimple_statement_base\n+  gomp_continue : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -748,7 +748,7 @@ struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n    contains a sequence, which we don't need here.  */\n \n struct GTY((tag(\"GSS_OMP_ATOMIC_LOAD\")))\n-  gomp_atomic_load : public gimple_statement_base\n+  gomp_atomic_load : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -760,7 +760,7 @@ struct GTY((tag(\"GSS_OMP_ATOMIC_LOAD\")))\n    See note on GIMPLE_OMP_ATOMIC_LOAD.  */\n \n struct GTY((tag(\"GSS_OMP_ATOMIC_STORE_LAYOUT\")))\n-  gimple_statement_omp_atomic_store_layout : public gimple_statement_base\n+  gimple_statement_omp_atomic_store_layout : public gimple\n {\n   /* [ WORD 1-6 ] : base class */\n \n@@ -906,455 +906,455 @@ struct GTY((tag(\"GSS_WITH_MEM_OPS\")))\n template <>\n template <>\n inline bool\n-is_a_helper <gasm *>::test (gimple gs)\n+is_a_helper <gasm *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_ASM;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gassign *>::test (gimple gs)\n+is_a_helper <gassign *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_ASSIGN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gassign *>::test (const_gimple gs)\n+is_a_helper <const gassign *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_ASSIGN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gbind *>::test (gimple gs)\n+is_a_helper <gbind *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_BIND;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gcall *>::test (gimple gs)\n+is_a_helper <gcall *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_CALL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gcatch *>::test (gimple gs)\n+is_a_helper <gcatch *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_CATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gcond *>::test (gimple gs)\n+is_a_helper <gcond *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_COND;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gcond *>::test (const_gimple gs)\n+is_a_helper <const gcond *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_COND;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gdebug *>::test (gimple gs)\n+is_a_helper <gdebug *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_DEBUG;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <ggoto *>::test (gimple gs)\n+is_a_helper <ggoto *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_GOTO;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <glabel *>::test (gimple gs)\n+is_a_helper <glabel *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_LABEL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gresx *>::test (gimple gs)\n+is_a_helper <gresx *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_RESX;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <geh_dispatch *>::test (gimple gs)\n+is_a_helper <geh_dispatch *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_EH_DISPATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <geh_else *>::test (gimple gs)\n+is_a_helper <geh_else *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_EH_ELSE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <geh_filter *>::test (gimple gs)\n+is_a_helper <geh_filter *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_EH_FILTER;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <geh_mnt *>::test (gimple gs)\n+is_a_helper <geh_mnt *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_EH_MUST_NOT_THROW;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_atomic_load *>::test (gimple gs)\n+is_a_helper <gomp_atomic_load *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_LOAD;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_atomic_store *>::test (gimple gs)\n+is_a_helper <gomp_atomic_store *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_STORE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_return *>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_return *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_continue *>::test (gimple gs)\n+is_a_helper <gomp_continue *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_CONTINUE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_critical *>::test (gimple gs)\n+is_a_helper <gomp_critical *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_CRITICAL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_for *>::test (gimple gs)\n+is_a_helper <gomp_for *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_FOR;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_taskreg *>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_taskreg *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL || gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_parallel *>::test (gimple gs)\n+is_a_helper <gomp_parallel *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_target *>::test (gimple gs)\n+is_a_helper <gomp_target *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_TARGET;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_sections *>::test (gimple gs)\n+is_a_helper <gomp_sections *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_SECTIONS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_single *>::test (gimple gs)\n+is_a_helper <gomp_single *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_SINGLE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_teams *>::test (gimple gs)\n+is_a_helper <gomp_teams *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_TEAMS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gomp_task *>::test (gimple gs)\n+is_a_helper <gomp_task *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gphi *>::test (gimple gs)\n+is_a_helper <gphi *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_PHI;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <greturn *>::test (gimple gs)\n+is_a_helper <greturn *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gswitch *>::test (gimple gs)\n+is_a_helper <gswitch *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_SWITCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gtransaction *>::test (gimple gs)\n+is_a_helper <gtransaction *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_TRANSACTION;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gtry *>::test (gimple gs)\n+is_a_helper <gtry *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_TRY;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_wce *>::test (gimple gs)\n+is_a_helper <gimple_statement_wce *>::test (gimple *gs)\n {\n   return gs->code == GIMPLE_WITH_CLEANUP_EXPR;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gasm *>::test (const_gimple gs)\n+is_a_helper <const gasm *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_ASM;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gbind *>::test (const_gimple gs)\n+is_a_helper <const gbind *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_BIND;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gcall *>::test (const_gimple gs)\n+is_a_helper <const gcall *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_CALL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gcatch *>::test (const_gimple gs)\n+is_a_helper <const gcatch *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_CATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gresx *>::test (const_gimple gs)\n+is_a_helper <const gresx *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_RESX;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const geh_dispatch *>::test (const_gimple gs)\n+is_a_helper <const geh_dispatch *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_EH_DISPATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const geh_filter *>::test (const_gimple gs)\n+is_a_helper <const geh_filter *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_EH_FILTER;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_atomic_load *>::test (const_gimple gs)\n+is_a_helper <const gomp_atomic_load *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_LOAD;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_atomic_store *>::test (const_gimple gs)\n+is_a_helper <const gomp_atomic_store *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_STORE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_return *>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_return *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_continue *>::test (const_gimple gs)\n+is_a_helper <const gomp_continue *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_CONTINUE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_critical *>::test (const_gimple gs)\n+is_a_helper <const gomp_critical *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_CRITICAL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_for *>::test (const_gimple gs)\n+is_a_helper <const gomp_for *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_FOR;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_taskreg *>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_taskreg *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL || gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_parallel *>::test (const_gimple gs)\n+is_a_helper <const gomp_parallel *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_target *>::test (const_gimple gs)\n+is_a_helper <const gomp_target *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_TARGET;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_sections *>::test (const_gimple gs)\n+is_a_helper <const gomp_sections *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_SECTIONS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_single *>::test (const_gimple gs)\n+is_a_helper <const gomp_single *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_SINGLE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_teams *>::test (const_gimple gs)\n+is_a_helper <const gomp_teams *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_TEAMS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gomp_task *>::test (const_gimple gs)\n+is_a_helper <const gomp_task *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gphi *>::test (const_gimple gs)\n+is_a_helper <const gphi *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_PHI;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gtransaction *>::test (const_gimple gs)\n+is_a_helper <const gtransaction *>::test (const gimple *gs)\n {\n   return gs->code == GIMPLE_TRANSACTION;\n }\n@@ -1368,10 +1368,10 @@ extern enum gimple_statement_structure_enum const gss_for_code_[];\n \n /* This variable holds the currently expanded gimple statement for purposes\n    of comminucating the profile info to the builtin expanders.  */\n-extern gimple currently_expanding_gimple_stmt;\n+extern gimple *currently_expanding_gimple_stmt;\n \n #define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n-gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n+gimple *gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n greturn *gimple_build_return (tree);\n void gimple_call_reset_alias_info (gcall *);\n gcall *gimple_build_call_vec (tree, vec<tree> );\n@@ -1391,7 +1391,7 @@ gcond *gimple_build_cond_from_tree (tree, tree, tree);\n void gimple_cond_set_condition_from_tree (gcond *, tree);\n glabel *gimple_build_label (tree label);\n ggoto *gimple_build_goto (tree dest);\n-gimple gimple_build_nop (void);\n+gimple *gimple_build_nop (void);\n gbind *gimple_build_bind (tree, gimple_seq, tree);\n gasm *gimple_build_asm_vec (const char *, vec<tree, va_gc> *,\n \t\t\t\t vec<tree, va_gc> *, vec<tree, va_gc> *,\n@@ -1402,63 +1402,63 @@ geh_mnt *gimple_build_eh_must_not_throw (tree);\n geh_else *gimple_build_eh_else (gimple_seq, gimple_seq);\n gtry *gimple_build_try (gimple_seq, gimple_seq,\n \t\t\t\t\tenum gimple_try_flags);\n-gimple gimple_build_wce (gimple_seq);\n+gimple *gimple_build_wce (gimple_seq);\n gresx *gimple_build_resx (int);\n gswitch *gimple_build_switch_nlabels (unsigned, tree, tree);\n gswitch *gimple_build_switch (tree, tree, vec<tree> );\n geh_dispatch *gimple_build_eh_dispatch (int);\n-gdebug *gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n+gdebug *gimple_build_debug_bind_stat (tree, tree, gimple * MEM_STAT_DECL);\n #define gimple_build_debug_bind(var,val,stmt)\t\t\t\\\n   gimple_build_debug_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n-gdebug *gimple_build_debug_source_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n+gdebug *gimple_build_debug_source_bind_stat (tree, tree, gimple * MEM_STAT_DECL);\n #define gimple_build_debug_source_bind(var,val,stmt)\t\t\t\\\n   gimple_build_debug_source_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n gomp_critical *gimple_build_omp_critical (gimple_seq, tree);\n gomp_for *gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n gomp_parallel *gimple_build_omp_parallel (gimple_seq, tree, tree, tree);\n gomp_task *gimple_build_omp_task (gimple_seq, tree, tree, tree, tree,\n \t\t\t\t       tree, tree);\n-gimple gimple_build_omp_section (gimple_seq);\n-gimple gimple_build_omp_master (gimple_seq);\n-gimple gimple_build_omp_taskgroup (gimple_seq);\n+gimple *gimple_build_omp_section (gimple_seq);\n+gimple *gimple_build_omp_master (gimple_seq);\n+gimple *gimple_build_omp_taskgroup (gimple_seq);\n gomp_continue *gimple_build_omp_continue (tree, tree);\n-gimple gimple_build_omp_ordered (gimple_seq);\n-gimple gimple_build_omp_return (bool);\n+gimple *gimple_build_omp_ordered (gimple_seq);\n+gimple *gimple_build_omp_return (bool);\n gomp_sections *gimple_build_omp_sections (gimple_seq, tree);\n-gimple gimple_build_omp_sections_switch (void);\n+gimple *gimple_build_omp_sections_switch (void);\n gomp_single *gimple_build_omp_single (gimple_seq, tree);\n gomp_target *gimple_build_omp_target (gimple_seq, int, tree);\n gomp_teams *gimple_build_omp_teams (gimple_seq, tree);\n gomp_atomic_load *gimple_build_omp_atomic_load (tree, tree);\n gomp_atomic_store *gimple_build_omp_atomic_store (tree);\n gtransaction *gimple_build_transaction (gimple_seq, tree);\n-extern void gimple_seq_add_stmt (gimple_seq *, gimple);\n-extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple);\n+extern void gimple_seq_add_stmt (gimple_seq *, gimple *);\n+extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple *);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n void gimple_seq_add_seq_without_update (gimple_seq *, gimple_seq);\n extern void annotate_all_with_location_after (gimple_seq, gimple_stmt_iterator,\n \t\t\t\t\t      location_t);\n extern void annotate_all_with_location (gimple_seq, location_t);\n bool empty_body_p (gimple_seq);\n gimple_seq gimple_seq_copy (gimple_seq);\n-bool gimple_call_same_target_p (const_gimple, const_gimple);\n-int gimple_call_flags (const_gimple);\n+bool gimple_call_same_target_p (const gimple *, const gimple *);\n+int gimple_call_flags (const gimple *);\n int gimple_call_arg_flags (const gcall *, unsigned);\n int gimple_call_return_flags (const gcall *);\n-bool gimple_assign_copy_p (gimple);\n-bool gimple_assign_ssa_name_copy_p (gimple);\n-bool gimple_assign_unary_nop_p (gimple);\n-void gimple_set_bb (gimple, basic_block);\n+bool gimple_assign_copy_p (gimple *);\n+bool gimple_assign_ssa_name_copy_p (gimple *);\n+bool gimple_assign_unary_nop_p (gimple *);\n+void gimple_set_bb (gimple *, basic_block);\n void gimple_assign_set_rhs_from_tree (gimple_stmt_iterator *, tree);\n void gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *, enum tree_code,\n \t\t\t\t     tree, tree, tree);\n-tree gimple_get_lhs (const_gimple);\n-void gimple_set_lhs (gimple, tree);\n-gimple gimple_copy (gimple);\n-bool gimple_has_side_effects (const_gimple);\n-bool gimple_could_trap_p_1 (gimple, bool, bool);\n-bool gimple_could_trap_p (gimple);\n-bool gimple_assign_rhs_could_trap_p (gimple);\n+tree gimple_get_lhs (const gimple *);\n+void gimple_set_lhs (gimple *, tree);\n+gimple *gimple_copy (gimple *);\n+bool gimple_has_side_effects (const gimple *);\n+bool gimple_could_trap_p_1 (gimple *, bool, bool);\n+bool gimple_could_trap_p (gimple *);\n+bool gimple_assign_rhs_could_trap_p (gimple *);\n extern void dump_gimple_statistics (void);\n unsigned get_gimple_rhs_num_ops (enum tree_code);\n extern tree canonicalize_cond_expr_cond (tree);\n@@ -1467,22 +1467,22 @@ extern bool gimple_compare_field_offset (tree, tree);\n extern tree gimple_unsigned_type (tree);\n extern tree gimple_signed_type (tree);\n extern alias_set_type gimple_get_alias_set (tree);\n-extern bool gimple_ior_addresses_taken (bitmap, gimple);\n-extern bool gimple_builtin_call_types_compatible_p (const_gimple, tree);\n-extern bool gimple_call_builtin_p (const_gimple);\n-extern bool gimple_call_builtin_p (const_gimple, enum built_in_class);\n-extern bool gimple_call_builtin_p (const_gimple, enum built_in_function);\n+extern bool gimple_ior_addresses_taken (bitmap, gimple *);\n+extern bool gimple_builtin_call_types_compatible_p (const gimple *, tree);\n+extern bool gimple_call_builtin_p (const gimple *);\n+extern bool gimple_call_builtin_p (const gimple *, enum built_in_class);\n+extern bool gimple_call_builtin_p (const gimple *, enum built_in_function);\n extern bool gimple_asm_clobbers_memory_p (const gasm *);\n extern void dump_decl_set (FILE *, bitmap);\n-extern bool nonfreeing_call_p (gimple);\n-extern bool infer_nonnull_range (gimple, tree);\n-extern bool infer_nonnull_range_by_dereference (gimple, tree);\n-extern bool infer_nonnull_range_by_attribute (gimple, tree);\n+extern bool nonfreeing_call_p (gimple *);\n+extern bool infer_nonnull_range (gimple *, tree);\n+extern bool infer_nonnull_range_by_dereference (gimple *, tree);\n+extern bool infer_nonnull_range_by_attribute (gimple *, tree);\n extern void sort_case_labels (vec<tree>);\n extern void preprocess_case_label_vec_for_gimple (vec<tree>, tree, tree *);\n extern void gimple_seq_set_location (gimple_seq, location_t);\n extern void gimple_seq_discard (gimple_seq);\n-extern void maybe_remove_unused_call_args (struct function *, gimple);\n+extern void maybe_remove_unused_call_args (struct function *, gimple *);\n \n /* Formal (expression) temporary table handling: multiple occurrences of\n    the same scalar expression are evaluated into the same temporary.  */\n@@ -1525,7 +1525,7 @@ gimple_seq_first (gimple_seq s)\n \n /* Return the first statement in GIMPLE sequence S.  */\n \n-static inline gimple\n+static inline gimple *\n gimple_seq_first_stmt (gimple_seq s)\n {\n   gimple_seq_node n = gimple_seq_first (s);\n@@ -1554,7 +1554,7 @@ gimple_seq_last (gimple_seq s)\n \n /* Return the last statement in GIMPLE sequence S.  */\n \n-static inline gimple\n+static inline gimple *\n gimple_seq_last_stmt (gimple_seq s)\n {\n   gimple_seq_node n = gimple_seq_last (s);\n@@ -1591,7 +1591,7 @@ gimple_seq_empty_p (gimple_seq s)\n /* Allocate a new sequence and initialize its first element with STMT.  */\n \n static inline gimple_seq\n-gimple_seq_alloc_with_stmt (gimple stmt)\n+gimple_seq_alloc_with_stmt (gimple *stmt)\n {\n   gimple_seq seq = NULL;\n   gimple_seq_add_stmt (&seq, stmt);\n@@ -1626,7 +1626,7 @@ set_bb_seq (basic_block bb, gimple_seq seq)\n /* Return the code for GIMPLE statement G.  */\n \n static inline enum gimple_code\n-gimple_code (const_gimple g)\n+gimple_code (const gimple *g)\n {\n   return g->code;\n }\n@@ -1645,7 +1645,7 @@ gss_for_code (enum gimple_code code)\n /* Return which GSS code is used by GS.  */\n \n static inline enum gimple_statement_structure_enum\n-gimple_statement_structure (gimple gs)\n+gimple_statement_structure (gimple *gs)\n {\n   return gss_for_code (gimple_code (gs));\n }\n@@ -1655,7 +1655,7 @@ gimple_statement_structure (gimple gs)\n    High GIMPLE statements.  */\n \n static inline bool\n-gimple_has_substatements (gimple g)\n+gimple_has_substatements (gimple *g)\n {\n   switch (gimple_code (g))\n     {\n@@ -1689,7 +1689,7 @@ gimple_has_substatements (gimple g)\n /* Return the basic block holding statement G.  */\n \n static inline basic_block\n-gimple_bb (const_gimple g)\n+gimple_bb (const gimple *g)\n {\n   return g->bb;\n }\n@@ -1698,7 +1698,7 @@ gimple_bb (const_gimple g)\n /* Return the lexical scope block holding statement G.  */\n \n static inline tree\n-gimple_block (const_gimple g)\n+gimple_block (const gimple *g)\n {\n   return LOCATION_BLOCK (g->location);\n }\n@@ -1707,7 +1707,7 @@ gimple_block (const_gimple g)\n /* Set BLOCK to be the lexical scope block holding statement G.  */\n \n static inline void\n-gimple_set_block (gimple g, tree block)\n+gimple_set_block (gimple *g, tree block)\n {\n   if (block)\n     g->location =\n@@ -1720,7 +1720,7 @@ gimple_set_block (gimple g, tree block)\n /* Return location information for statement G.  */\n \n static inline location_t\n-gimple_location (const_gimple g)\n+gimple_location (const gimple *g)\n {\n   return g->location;\n }\n@@ -1729,15 +1729,15 @@ gimple_location (const_gimple g)\n    Otherwise, UNKNOWN_LOCATION is returned.  */\n \n static inline location_t\n-gimple_location_safe (const_gimple g)\n+gimple_location_safe (const gimple *g)\n {\n   return g ? gimple_location (g) : UNKNOWN_LOCATION;\n }\n \n /* Return pointer to location information for statement G.  */\n \n static inline const location_t *\n-gimple_location_ptr (const_gimple g)\n+gimple_location_ptr (const gimple *g)\n {\n   return &g->location;\n }\n@@ -1746,7 +1746,7 @@ gimple_location_ptr (const_gimple g)\n /* Set location information for statement G.  */\n \n static inline void\n-gimple_set_location (gimple g, location_t location)\n+gimple_set_location (gimple *g, location_t location)\n {\n   g->location = location;\n }\n@@ -1755,7 +1755,7 @@ gimple_set_location (gimple g, location_t location)\n /* Return true if G contains location information.  */\n \n static inline bool\n-gimple_has_location (const_gimple g)\n+gimple_has_location (const gimple *g)\n {\n   return LOCATION_LOCUS (gimple_location (g)) != UNKNOWN_LOCATION;\n }\n@@ -1764,7 +1764,7 @@ gimple_has_location (const_gimple g)\n /* Return the file name of the location of STMT.  */\n \n static inline const char *\n-gimple_filename (const_gimple stmt)\n+gimple_filename (const gimple *stmt)\n {\n   return LOCATION_FILE (gimple_location (stmt));\n }\n@@ -1773,7 +1773,7 @@ gimple_filename (const_gimple stmt)\n /* Return the line number of the location of STMT.  */\n \n static inline int\n-gimple_lineno (const_gimple stmt)\n+gimple_lineno (const gimple *stmt)\n {\n   return LOCATION_LINE (gimple_location (stmt));\n }\n@@ -1791,15 +1791,15 @@ gimple_seq_singleton_p (gimple_seq seq)\n /* Return true if no warnings should be emitted for statement STMT.  */\n \n static inline bool\n-gimple_no_warning_p (const_gimple stmt)\n+gimple_no_warning_p (const gimple *stmt)\n {\n   return stmt->no_warning;\n }\n \n /* Set the no_warning flag of STMT to NO_WARNING.  */\n \n static inline void\n-gimple_set_no_warning (gimple stmt, bool no_warning)\n+gimple_set_no_warning (gimple *stmt, bool no_warning)\n {\n   stmt->no_warning = (unsigned) no_warning;\n }\n@@ -1817,7 +1817,7 @@ gimple_set_no_warning (gimple stmt, bool no_warning)\n  */\n \n static inline void\n-gimple_set_visited (gimple stmt, bool visited_p)\n+gimple_set_visited (gimple *stmt, bool visited_p)\n {\n   stmt->visited = (unsigned) visited_p;\n }\n@@ -1835,7 +1835,7 @@ gimple_set_visited (gimple stmt, bool visited_p)\n    struct gimple statement_base.  */\n \n static inline bool\n-gimple_visited_p (gimple stmt)\n+gimple_visited_p (gimple *stmt)\n {\n   return stmt->visited;\n }\n@@ -1852,7 +1852,7 @@ gimple_visited_p (gimple stmt)\n    the 'plf' data member of struct gimple_statement_structure.  */\n \n static inline void\n-gimple_set_plf (gimple stmt, enum plf_mask plf, bool val_p)\n+gimple_set_plf (gimple *stmt, enum plf_mask plf, bool val_p)\n {\n   if (val_p)\n     stmt->plf |= (unsigned int) plf;\n@@ -1872,7 +1872,7 @@ gimple_set_plf (gimple stmt, enum plf_mask plf, bool val_p)\n    the 'plf' data member of struct gimple_statement_structure.  */\n \n static inline unsigned int\n-gimple_plf (gimple stmt, enum plf_mask plf)\n+gimple_plf (gimple *stmt, enum plf_mask plf)\n {\n   return stmt->plf & ((unsigned int) plf);\n }\n@@ -1886,7 +1886,7 @@ gimple_plf (gimple stmt, enum plf_mask plf)\n    to any value it sees fit.  */\n \n static inline void\n-gimple_set_uid (gimple g, unsigned uid)\n+gimple_set_uid (gimple *g, unsigned uid)\n {\n   g->uid = uid;\n }\n@@ -1900,7 +1900,7 @@ gimple_set_uid (gimple g, unsigned uid)\n    to any value it sees fit.  */\n \n static inline unsigned\n-gimple_uid (const_gimple g)\n+gimple_uid (const gimple *g)\n {\n   return g->uid;\n }\n@@ -1909,7 +1909,7 @@ gimple_uid (const_gimple g)\n /* Make statement G a singleton sequence.  */\n \n static inline void\n-gimple_init_singleton (gimple g)\n+gimple_init_singleton (gimple *g)\n {\n   g->next = NULL;\n   g->prev = g;\n@@ -1919,55 +1919,55 @@ gimple_init_singleton (gimple g)\n /* Return true if GIMPLE statement G has register or memory operands.  */\n \n static inline bool\n-gimple_has_ops (const_gimple g)\n+gimple_has_ops (const gimple *g)\n {\n   return gimple_code (g) >= GIMPLE_COND && gimple_code (g) <= GIMPLE_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_with_ops *>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_with_ops *>::test (const gimple *gs)\n {\n   return gimple_has_ops (gs);\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_with_ops *>::test (gimple gs)\n+is_a_helper <gimple_statement_with_ops *>::test (gimple *gs)\n {\n   return gimple_has_ops (gs);\n }\n \n /* Return true if GIMPLE statement G has memory operands.  */\n \n static inline bool\n-gimple_has_mem_ops (const_gimple g)\n+gimple_has_mem_ops (const gimple *g)\n {\n   return gimple_code (g) >= GIMPLE_ASSIGN && gimple_code (g) <= GIMPLE_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_with_memory_ops *>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_with_memory_ops *>::test (const gimple *gs)\n {\n   return gimple_has_mem_ops (gs);\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_with_memory_ops *>::test (gimple gs)\n+is_a_helper <gimple_statement_with_memory_ops *>::test (gimple *gs)\n {\n   return gimple_has_mem_ops (gs);\n }\n \n /* Return the set of USE operands for statement G.  */\n \n static inline struct use_optype_d *\n-gimple_use_ops (const_gimple g)\n+gimple_use_ops (const gimple *g)\n {\n   const gimple_statement_with_ops *ops_stmt =\n     dyn_cast <const gimple_statement_with_ops *> (g);\n@@ -1980,7 +1980,7 @@ gimple_use_ops (const_gimple g)\n /* Set USE to be the set of USE operands for statement G.  */\n \n static inline void\n-gimple_set_use_ops (gimple g, struct use_optype_d *use)\n+gimple_set_use_ops (gimple *g, struct use_optype_d *use)\n {\n   gimple_statement_with_ops *ops_stmt =\n     as_a <gimple_statement_with_ops *> (g);\n@@ -1991,7 +1991,7 @@ gimple_set_use_ops (gimple g, struct use_optype_d *use)\n /* Return the single VUSE operand of the statement G.  */\n \n static inline tree\n-gimple_vuse (const_gimple g)\n+gimple_vuse (const gimple *g)\n {\n   const gimple_statement_with_memory_ops *mem_ops_stmt =\n      dyn_cast <const gimple_statement_with_memory_ops *> (g);\n@@ -2003,7 +2003,7 @@ gimple_vuse (const_gimple g)\n /* Return the single VDEF operand of the statement G.  */\n \n static inline tree\n-gimple_vdef (const_gimple g)\n+gimple_vdef (const gimple *g)\n {\n   const gimple_statement_with_memory_ops *mem_ops_stmt =\n      dyn_cast <const gimple_statement_with_memory_ops *> (g);\n@@ -2015,7 +2015,7 @@ gimple_vdef (const_gimple g)\n /* Return the single VUSE operand of the statement G.  */\n \n static inline tree *\n-gimple_vuse_ptr (gimple g)\n+gimple_vuse_ptr (gimple *g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n      dyn_cast <gimple_statement_with_memory_ops *> (g);\n@@ -2027,7 +2027,7 @@ gimple_vuse_ptr (gimple g)\n /* Return the single VDEF operand of the statement G.  */\n \n static inline tree *\n-gimple_vdef_ptr (gimple g)\n+gimple_vdef_ptr (gimple *g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n      dyn_cast <gimple_statement_with_memory_ops *> (g);\n@@ -2039,7 +2039,7 @@ gimple_vdef_ptr (gimple g)\n /* Set the single VUSE operand of the statement G.  */\n \n static inline void\n-gimple_set_vuse (gimple g, tree vuse)\n+gimple_set_vuse (gimple *g, tree vuse)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n     as_a <gimple_statement_with_memory_ops *> (g);\n@@ -2049,7 +2049,7 @@ gimple_set_vuse (gimple g, tree vuse)\n /* Set the single VDEF operand of the statement G.  */\n \n static inline void\n-gimple_set_vdef (gimple g, tree vdef)\n+gimple_set_vdef (gimple *g, tree vdef)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n     as_a <gimple_statement_with_memory_ops *> (g);\n@@ -2061,7 +2061,7 @@ gimple_set_vdef (gimple g, tree vdef)\n    been set.  */\n \n static inline bool\n-gimple_modified_p (const_gimple g)\n+gimple_modified_p (const gimple *g)\n {\n   return (gimple_has_ops (g)) ? (bool) g->modified : false;\n }\n@@ -2071,7 +2071,7 @@ gimple_modified_p (const_gimple g)\n    a MODIFIED field.  */\n \n static inline void\n-gimple_set_modified (gimple s, bool modifiedp)\n+gimple_set_modified (gimple *s, bool modifiedp)\n {\n   if (gimple_has_ops (s))\n     s->modified = (unsigned) modifiedp;\n@@ -2085,7 +2085,7 @@ gimple_set_modified (gimple s, bool modifiedp)\n    three kinds of computation that GIMPLE supports.  */\n \n static inline enum tree_code\n-gimple_expr_code (const_gimple stmt)\n+gimple_expr_code (const gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   if (code == GIMPLE_ASSIGN || code == GIMPLE_COND)\n@@ -2101,7 +2101,7 @@ gimple_expr_code (const_gimple stmt)\n /* Return true if statement STMT contains volatile operands.  */\n \n static inline bool\n-gimple_has_volatile_ops (const_gimple stmt)\n+gimple_has_volatile_ops (const gimple *stmt)\n {\n   if (gimple_has_mem_ops (stmt))\n     return stmt->has_volatile_ops;\n@@ -2113,7 +2113,7 @@ gimple_has_volatile_ops (const_gimple stmt)\n /* Set the HAS_VOLATILE_OPS flag to VOLATILEP.  */\n \n static inline void\n-gimple_set_has_volatile_ops (gimple stmt, bool volatilep)\n+gimple_set_has_volatile_ops (gimple *stmt, bool volatilep)\n {\n   if (gimple_has_mem_ops (stmt))\n     stmt->has_volatile_ops = (unsigned) volatilep;\n@@ -2122,15 +2122,15 @@ gimple_set_has_volatile_ops (gimple stmt, bool volatilep)\n /* Return true if STMT is in a transaction.  */\n \n static inline bool\n-gimple_in_transaction (gimple stmt)\n+gimple_in_transaction (const gimple *stmt)\n {\n   return bb_in_transaction (gimple_bb (stmt));\n }\n \n /* Return true if statement STMT may access memory.  */\n \n static inline bool\n-gimple_references_memory_p (gimple stmt)\n+gimple_references_memory_p (gimple *stmt)\n {\n   return gimple_has_mem_ops (stmt) && gimple_vuse (stmt);\n }\n@@ -2139,7 +2139,7 @@ gimple_references_memory_p (gimple stmt)\n /* Return the subcode for OMP statement S.  */\n \n static inline unsigned\n-gimple_omp_subcode (const_gimple s)\n+gimple_omp_subcode (const gimple *s)\n {\n   gcc_gimple_checking_assert (gimple_code (s) >= GIMPLE_OMP_ATOMIC_LOAD\n \t      && gimple_code (s) <= GIMPLE_OMP_TEAMS);\n@@ -2149,7 +2149,7 @@ gimple_omp_subcode (const_gimple s)\n /* Set the subcode for OMP statement S to SUBCODE.  */\n \n static inline void\n-gimple_omp_set_subcode (gimple s, unsigned int subcode)\n+gimple_omp_set_subcode (gimple *s, unsigned int subcode)\n {\n   /* We only have 16 bits for the subcode.  Assert that we are not\n      overflowing it.  */\n@@ -2160,7 +2160,7 @@ gimple_omp_set_subcode (gimple s, unsigned int subcode)\n /* Set the nowait flag on OMP_RETURN statement S.  */\n \n static inline void\n-gimple_omp_return_set_nowait (gimple s)\n+gimple_omp_return_set_nowait (gimple *s)\n {\n   GIMPLE_CHECK (s, GIMPLE_OMP_RETURN);\n   s->subcode |= GF_OMP_RETURN_NOWAIT;\n@@ -2171,7 +2171,7 @@ gimple_omp_return_set_nowait (gimple s)\n    flag set.  */\n \n static inline bool\n-gimple_omp_return_nowait_p (const_gimple g)\n+gimple_omp_return_nowait_p (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_RETURN);\n   return (gimple_omp_subcode (g) & GF_OMP_RETURN_NOWAIT) != 0;\n@@ -2181,7 +2181,7 @@ gimple_omp_return_nowait_p (const_gimple g)\n /* Set the LHS of OMP return.  */\n \n static inline void\n-gimple_omp_return_set_lhs (gimple g, tree lhs)\n+gimple_omp_return_set_lhs (gimple *g, tree lhs)\n {\n   gimple_statement_omp_return *omp_return_stmt =\n     as_a <gimple_statement_omp_return *> (g);\n@@ -2192,7 +2192,7 @@ gimple_omp_return_set_lhs (gimple g, tree lhs)\n /* Get the LHS of OMP return.  */\n \n static inline tree\n-gimple_omp_return_lhs (const_gimple g)\n+gimple_omp_return_lhs (const gimple *g)\n {\n   const gimple_statement_omp_return *omp_return_stmt =\n     as_a <const gimple_statement_omp_return *> (g);\n@@ -2203,7 +2203,7 @@ gimple_omp_return_lhs (const_gimple g)\n /* Return a pointer to the LHS of OMP return.  */\n \n static inline tree *\n-gimple_omp_return_lhs_ptr (gimple g)\n+gimple_omp_return_lhs_ptr (gimple *g)\n {\n   gimple_statement_omp_return *omp_return_stmt =\n     as_a <gimple_statement_omp_return *> (g);\n@@ -2215,7 +2215,7 @@ gimple_omp_return_lhs_ptr (gimple g)\n    flag set.  */\n \n static inline bool\n-gimple_omp_section_last_p (const_gimple g)\n+gimple_omp_section_last_p (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_SECTION);\n   return (gimple_omp_subcode (g) & GF_OMP_SECTION_LAST) != 0;\n@@ -2225,7 +2225,7 @@ gimple_omp_section_last_p (const_gimple g)\n /* Set the GF_OMP_SECTION_LAST flag on G.  */\n \n static inline void\n-gimple_omp_section_set_last (gimple g)\n+gimple_omp_section_set_last (gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_SECTION);\n   g->subcode |= GF_OMP_SECTION_LAST;\n@@ -2236,7 +2236,7 @@ gimple_omp_section_set_last (gimple g)\n    GF_OMP_PARALLEL_COMBINED flag set.  */\n \n static inline bool\n-gimple_omp_parallel_combined_p (const_gimple g)\n+gimple_omp_parallel_combined_p (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_PARALLEL);\n   return (gimple_omp_subcode (g) & GF_OMP_PARALLEL_COMBINED) != 0;\n@@ -2247,7 +2247,7 @@ gimple_omp_parallel_combined_p (const_gimple g)\n    value of COMBINED_P.  */\n \n static inline void\n-gimple_omp_parallel_set_combined_p (gimple g, bool combined_p)\n+gimple_omp_parallel_set_combined_p (gimple *g, bool combined_p)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_PARALLEL);\n   if (combined_p)\n@@ -2261,7 +2261,7 @@ gimple_omp_parallel_set_combined_p (gimple g, bool combined_p)\n    GF_OMP_ATOMIC_NEED_VALUE flag set.  */\n \n static inline bool\n-gimple_omp_atomic_need_value_p (const_gimple g)\n+gimple_omp_atomic_need_value_p (const gimple *g)\n {\n   if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n     GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n@@ -2272,7 +2272,7 @@ gimple_omp_atomic_need_value_p (const_gimple g)\n /* Set the GF_OMP_ATOMIC_NEED_VALUE flag on G.  */\n \n static inline void\n-gimple_omp_atomic_set_need_value (gimple g)\n+gimple_omp_atomic_set_need_value (gimple *g)\n {\n   if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n     GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n@@ -2284,7 +2284,7 @@ gimple_omp_atomic_set_need_value (gimple g)\n    GF_OMP_ATOMIC_SEQ_CST flag set.  */\n \n static inline bool\n-gimple_omp_atomic_seq_cst_p (const_gimple g)\n+gimple_omp_atomic_seq_cst_p (const gimple *g)\n {\n   if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n     GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n@@ -2295,7 +2295,7 @@ gimple_omp_atomic_seq_cst_p (const_gimple g)\n /* Set the GF_OMP_ATOMIC_SEQ_CST flag on G.  */\n \n static inline void\n-gimple_omp_atomic_set_seq_cst (gimple g)\n+gimple_omp_atomic_set_seq_cst (gimple *g)\n {\n   if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n     GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n@@ -2306,7 +2306,7 @@ gimple_omp_atomic_set_seq_cst (gimple g)\n /* Return the number of operands for statement GS.  */\n \n static inline unsigned\n-gimple_num_ops (const_gimple gs)\n+gimple_num_ops (const gimple *gs)\n {\n   return gs->num_ops;\n }\n@@ -2315,7 +2315,7 @@ gimple_num_ops (const_gimple gs)\n /* Set the number of operands for statement GS.  */\n \n static inline void\n-gimple_set_num_ops (gimple gs, unsigned num_ops)\n+gimple_set_num_ops (gimple *gs, unsigned num_ops)\n {\n   gs->num_ops = num_ops;\n }\n@@ -2324,7 +2324,7 @@ gimple_set_num_ops (gimple gs, unsigned num_ops)\n /* Return the array of operands for statement GS.  */\n \n static inline tree *\n-gimple_ops (gimple gs)\n+gimple_ops (gimple *gs)\n {\n   size_t off;\n \n@@ -2341,7 +2341,7 @@ gimple_ops (gimple gs)\n /* Return operand I for statement GS.  */\n \n static inline tree\n-gimple_op (const_gimple gs, unsigned i)\n+gimple_op (const gimple *gs, unsigned i)\n {\n   if (gimple_has_ops (gs))\n     {\n@@ -2355,7 +2355,7 @@ gimple_op (const_gimple gs, unsigned i)\n /* Return a pointer to operand I for statement GS.  */\n \n static inline tree *\n-gimple_op_ptr (const_gimple gs, unsigned i)\n+gimple_op_ptr (const gimple *gs, unsigned i)\n {\n   if (gimple_has_ops (gs))\n     {\n@@ -2369,7 +2369,7 @@ gimple_op_ptr (const_gimple gs, unsigned i)\n /* Set operand I of statement GS to OP.  */\n \n static inline void\n-gimple_set_op (gimple gs, unsigned i, tree op)\n+gimple_set_op (gimple *gs, unsigned i, tree op)\n {\n   gcc_gimple_checking_assert (gimple_has_ops (gs) && i < gimple_num_ops (gs));\n \n@@ -2383,7 +2383,7 @@ gimple_set_op (gimple gs, unsigned i, tree op)\n /* Return true if GS is a GIMPLE_ASSIGN.  */\n \n static inline bool\n-is_gimple_assign (const_gimple gs)\n+is_gimple_assign (const gimple *gs)\n {\n   return gimple_code (gs) == GIMPLE_ASSIGN;\n }\n@@ -2406,7 +2406,7 @@ gimple_assign_lhs (const gassign *gs)\n }\n \n static inline tree\n-gimple_assign_lhs (const_gimple gs)\n+gimple_assign_lhs (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_lhs (ass);\n@@ -2422,7 +2422,7 @@ gimple_assign_lhs_ptr (const gassign *gs)\n }\n \n static inline tree *\n-gimple_assign_lhs_ptr (const_gimple gs)\n+gimple_assign_lhs_ptr (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_lhs_ptr (ass);\n@@ -2441,7 +2441,7 @@ gimple_assign_set_lhs (gassign *gs, tree lhs)\n }\n \n static inline void\n-gimple_assign_set_lhs (gimple gs, tree lhs)\n+gimple_assign_set_lhs (gimple *gs, tree lhs)\n {\n   gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n   gimple_assign_set_lhs (ass, lhs);\n@@ -2457,7 +2457,7 @@ gimple_assign_rhs1 (const gassign *gs)\n }\n \n static inline tree\n-gimple_assign_rhs1 (const_gimple gs)\n+gimple_assign_rhs1 (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_rhs1 (ass);\n@@ -2474,7 +2474,7 @@ gimple_assign_rhs1_ptr (const gassign *gs)\n }\n \n static inline tree *\n-gimple_assign_rhs1_ptr (const_gimple gs)\n+gimple_assign_rhs1_ptr (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_rhs1_ptr (ass);\n@@ -2489,7 +2489,7 @@ gimple_assign_set_rhs1 (gassign *gs, tree rhs)\n }\n \n static inline void\n-gimple_assign_set_rhs1 (gimple gs, tree rhs)\n+gimple_assign_set_rhs1 (gimple *gs, tree rhs)\n {\n   gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n   gimple_assign_set_rhs1 (ass, rhs);\n@@ -2509,7 +2509,7 @@ gimple_assign_rhs2 (const gassign *gs)\n }\n \n static inline tree\n-gimple_assign_rhs2 (const_gimple gs)\n+gimple_assign_rhs2 (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_rhs2 (ass);\n@@ -2527,7 +2527,7 @@ gimple_assign_rhs2_ptr (const gassign *gs)\n }\n \n static inline tree *\n-gimple_assign_rhs2_ptr (const_gimple gs)\n+gimple_assign_rhs2_ptr (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_rhs2_ptr (ass);\n@@ -2544,7 +2544,7 @@ gimple_assign_set_rhs2 (gassign *gs, tree rhs)\n }\n \n static inline void\n-gimple_assign_set_rhs2 (gimple gs, tree rhs)\n+gimple_assign_set_rhs2 (gimple *gs, tree rhs)\n {\n   gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n   return gimple_assign_set_rhs2 (ass, rhs);\n@@ -2563,7 +2563,7 @@ gimple_assign_rhs3 (const gassign *gs)\n }\n \n static inline tree\n-gimple_assign_rhs3 (const_gimple gs)\n+gimple_assign_rhs3 (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_rhs3 (ass);\n@@ -2573,7 +2573,7 @@ gimple_assign_rhs3 (const_gimple gs)\n    statement GS.  */\n \n static inline tree *\n-gimple_assign_rhs3_ptr (const_gimple gs)\n+gimple_assign_rhs3_ptr (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   gcc_gimple_checking_assert (gimple_num_ops (gs) >= 4);\n@@ -2591,7 +2591,7 @@ gimple_assign_set_rhs3 (gassign *gs, tree rhs)\n }\n \n static inline void\n-gimple_assign_set_rhs3 (gimple gs, tree rhs)\n+gimple_assign_set_rhs3 (gimple *gs, tree rhs)\n {\n   gassign *ass = GIMPLE_CHECK2<gassign *> (gs);\n   gimple_assign_set_rhs3 (ass, rhs);\n@@ -2629,7 +2629,7 @@ gimple_assign_nontemporal_move_p (const gassign *gs)\n /* Sets nontemporal move flag of GS to NONTEMPORAL.  */\n \n static inline void\n-gimple_assign_set_nontemporal_move (gimple gs, bool nontemporal)\n+gimple_assign_set_nontemporal_move (gimple *gs, bool nontemporal)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n   gs->nontemporal_move = nontemporal;\n@@ -2654,7 +2654,7 @@ gimple_assign_rhs_code (const gassign *gs)\n }\n \n static inline enum tree_code\n-gimple_assign_rhs_code (const_gimple gs)\n+gimple_assign_rhs_code (const gimple *gs)\n {\n   const gassign *ass = GIMPLE_CHECK2<const gassign *> (gs);\n   return gimple_assign_rhs_code (ass);\n@@ -2665,7 +2665,7 @@ gimple_assign_rhs_code (const_gimple gs)\n    assignment S.  */\n \n static inline void\n-gimple_assign_set_rhs_code (gimple s, enum tree_code code)\n+gimple_assign_set_rhs_code (gimple *s, enum tree_code code)\n {\n   GIMPLE_CHECK (s, GIMPLE_ASSIGN);\n   s->subcode = code;\n@@ -2677,7 +2677,7 @@ gimple_assign_set_rhs_code (gimple s, enum tree_code code)\n    This will never return GIMPLE_INVALID_RHS.  */\n \n static inline enum gimple_rhs_class\n-gimple_assign_rhs_class (const_gimple gs)\n+gimple_assign_rhs_class (const gimple *gs)\n {\n   return get_gimple_rhs_class (gimple_assign_rhs_code (gs));\n }\n@@ -2689,7 +2689,7 @@ gimple_assign_rhs_class (const_gimple gs)\n    and do not have the semantics of a copy, such as COND_EXPR.  */\n \n static inline bool\n-gimple_assign_single_p (const_gimple gs)\n+gimple_assign_single_p (const gimple *gs)\n {\n   return (is_gimple_assign (gs)\n           && gimple_assign_rhs_class (gs) == GIMPLE_SINGLE_RHS);\n@@ -2698,7 +2698,7 @@ gimple_assign_single_p (const_gimple gs)\n /* Return true if GS performs a store to its lhs.  */\n \n static inline bool\n-gimple_store_p (const_gimple gs)\n+gimple_store_p (const gimple *gs)\n {\n   tree lhs = gimple_get_lhs (gs);\n   return lhs && !is_gimple_reg (lhs);\n@@ -2707,7 +2707,7 @@ gimple_store_p (const_gimple gs)\n /* Return true if GS is an assignment that loads from its rhs1.  */\n \n static inline bool\n-gimple_assign_load_p (const_gimple gs)\n+gimple_assign_load_p (const gimple *gs)\n {\n   tree rhs;\n   if (!gimple_assign_single_p (gs))\n@@ -2724,7 +2724,7 @@ gimple_assign_load_p (const_gimple gs)\n /* Return true if S is a type-cast assignment.  */\n \n static inline bool\n-gimple_assign_cast_p (const_gimple s)\n+gimple_assign_cast_p (const gimple *s)\n {\n   if (is_gimple_assign (s))\n     {\n@@ -2740,7 +2740,7 @@ gimple_assign_cast_p (const_gimple s)\n /* Return true if S is a clobber statement.  */\n \n static inline bool\n-gimple_clobber_p (const_gimple s)\n+gimple_clobber_p (const gimple *s)\n {\n   return gimple_assign_single_p (s)\n          && TREE_CLOBBER_P (gimple_assign_rhs1 (s));\n@@ -2749,7 +2749,7 @@ gimple_clobber_p (const_gimple s)\n /* Return true if GS is a GIMPLE_CALL.  */\n \n static inline bool\n-is_gimple_call (const_gimple gs)\n+is_gimple_call (const gimple *gs)\n {\n   return gimple_code (gs) == GIMPLE_CALL;\n }\n@@ -2763,7 +2763,7 @@ gimple_call_lhs (const gcall *gs)\n }\n \n static inline tree\n-gimple_call_lhs (const_gimple gs)\n+gimple_call_lhs (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_lhs (gc);\n@@ -2779,7 +2779,7 @@ gimple_call_lhs_ptr (const gcall *gs)\n }\n \n static inline tree *\n-gimple_call_lhs_ptr (const_gimple gs)\n+gimple_call_lhs_ptr (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_lhs_ptr (gc);\n@@ -2797,7 +2797,7 @@ gimple_call_set_lhs (gcall *gs, tree lhs)\n }\n \n static inline void\n-gimple_call_set_lhs (gimple gs, tree lhs)\n+gimple_call_set_lhs (gimple *gs, tree lhs)\n {\n   gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n   gimple_call_set_lhs (gc, lhs);\n@@ -2814,7 +2814,7 @@ gimple_call_internal_p (const gcall *gs)\n }\n \n static inline bool\n-gimple_call_internal_p (const_gimple gs)\n+gimple_call_internal_p (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_internal_p (gc);\n@@ -2831,7 +2831,7 @@ gimple_call_with_bounds_p (const gcall *gs)\n }\n \n static inline bool\n-gimple_call_with_bounds_p (const_gimple gs)\n+gimple_call_with_bounds_p (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_with_bounds_p (gc);\n@@ -2851,7 +2851,7 @@ gimple_call_set_with_bounds (gcall *gs, bool with_bounds)\n }\n \n static inline void\n-gimple_call_set_with_bounds (gimple gs, bool with_bounds)\n+gimple_call_set_with_bounds (gimple *gs, bool with_bounds)\n {\n   gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n   gimple_call_set_with_bounds (gc, with_bounds);\n@@ -2868,7 +2868,7 @@ gimple_call_internal_fn (const gcall *gs)\n }\n \n static inline enum internal_fn\n-gimple_call_internal_fn (const_gimple gs)\n+gimple_call_internal_fn (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_internal_fn (gc);\n@@ -2887,7 +2887,7 @@ gimple_call_set_ctrl_altering (gcall *s, bool ctrl_altering_p)\n }\n \n static inline void\n-gimple_call_set_ctrl_altering (gimple s, bool ctrl_altering_p)\n+gimple_call_set_ctrl_altering (gimple *s, bool ctrl_altering_p)\n {\n   gcall *gc = GIMPLE_CHECK2<gcall *> (s);\n   gimple_call_set_ctrl_altering (gc, ctrl_altering_p);\n@@ -2903,7 +2903,7 @@ gimple_call_ctrl_altering_p (const gcall *gs)\n }\n \n static inline bool\n-gimple_call_ctrl_altering_p (const_gimple gs)\n+gimple_call_ctrl_altering_p (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_ctrl_altering_p (gc);\n@@ -2921,7 +2921,7 @@ gimple_call_fntype (const gcall *gs)\n }\n \n static inline tree\n-gimple_call_fntype (const_gimple gs)\n+gimple_call_fntype (const gimple *gs)\n {\n   const gcall *call_stmt = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_fntype (call_stmt);\n@@ -2947,7 +2947,7 @@ gimple_call_fn (const gcall *gs)\n }\n \n static inline tree\n-gimple_call_fn (const_gimple gs)\n+gimple_call_fn (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_fn (gc);\n@@ -2963,7 +2963,7 @@ gimple_call_fn_ptr (const gcall *gs)\n }\n \n static inline tree *\n-gimple_call_fn_ptr (const_gimple gs)\n+gimple_call_fn_ptr (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_fn_ptr (gc);\n@@ -2991,7 +2991,7 @@ gimple_call_set_fndecl (gcall *gs, tree decl)\n }\n \n static inline void\n-gimple_call_set_fndecl (gimple gs, tree decl)\n+gimple_call_set_fndecl (gimple *gs, tree decl)\n {\n   gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n   gimple_call_set_fndecl (gc, decl);\n@@ -3019,7 +3019,7 @@ gimple_call_fndecl (const gcall *gs)\n }\n \n static inline tree\n-gimple_call_fndecl (const_gimple gs)\n+gimple_call_fndecl (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_fndecl (gc);\n@@ -3051,7 +3051,7 @@ gimple_call_chain (const gcall *gs)\n }\n \n static inline tree\n-gimple_call_chain (const_gimple gs)\n+gimple_call_chain (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_chain (gc);\n@@ -3084,7 +3084,7 @@ gimple_call_num_args (const gcall *gs)\n }\n \n static inline unsigned\n-gimple_call_num_args (const_gimple gs)\n+gimple_call_num_args (const gimple *gs)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_num_args (gc);\n@@ -3101,7 +3101,7 @@ gimple_call_arg (const gcall *gs, unsigned index)\n }\n \n static inline tree\n-gimple_call_arg (const_gimple gs, unsigned index)\n+gimple_call_arg (const gimple *gs, unsigned index)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_arg (gc, index);\n@@ -3119,7 +3119,7 @@ gimple_call_arg_ptr (const gcall *gs, unsigned index)\n }\n \n static inline tree *\n-gimple_call_arg_ptr (const_gimple gs, unsigned index)\n+gimple_call_arg_ptr (const gimple *gs, unsigned index)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (gs);\n   return gimple_call_arg_ptr (gc, index);\n@@ -3136,7 +3136,7 @@ gimple_call_set_arg (gcall *gs, unsigned index, tree arg)\n }\n \n static inline void\n-gimple_call_set_arg (gimple gs, unsigned index, tree arg)\n+gimple_call_set_arg (gimple *gs, unsigned index, tree arg)\n {\n   gcall *gc = GIMPLE_CHECK2<gcall *> (gs);\n   gimple_call_set_arg (gc, index, arg);\n@@ -3243,7 +3243,7 @@ gimple_call_noreturn_p (const gcall *s)\n }\n \n static inline bool\n-gimple_call_noreturn_p (const_gimple s)\n+gimple_call_noreturn_p (const gimple *s)\n {\n   const gcall *gc = GIMPLE_CHECK2<const gcall *> (s);\n   return gimple_call_noreturn_p (gc);\n@@ -3325,7 +3325,7 @@ gimple_call_clobber_set (gcall *call_stmt)\n    non-NULL lhs.  */\n \n static inline bool\n-gimple_has_lhs (gimple stmt)\n+gimple_has_lhs (gimple *stmt)\n {\n   if (is_gimple_assign (stmt))\n     return true;\n@@ -3344,7 +3344,7 @@ gimple_cond_code (const gcond *gs)\n }\n \n static inline enum tree_code\n-gimple_cond_code (const_gimple gs)\n+gimple_cond_code (const gimple *gs)\n {\n   const gcond *gc = GIMPLE_CHECK2<const gcond *> (gs);\n   return gimple_cond_code (gc);\n@@ -3369,7 +3369,7 @@ gimple_cond_lhs (const gcond *gs)\n }\n \n static inline tree\n-gimple_cond_lhs (const_gimple gs)\n+gimple_cond_lhs (const gimple *gs)\n {\n   const gcond *gc = GIMPLE_CHECK2<const gcond *> (gs);\n   return gimple_cond_lhs (gc);\n@@ -3403,7 +3403,7 @@ gimple_cond_rhs (const gcond *gs)\n }\n \n static inline tree\n-gimple_cond_rhs (const_gimple gs)\n+gimple_cond_rhs (const gimple *gs)\n {\n   const gcond *gc = GIMPLE_CHECK2<const gcond *> (gs);\n   return gimple_cond_rhs (gc);\n@@ -3573,7 +3573,7 @@ gimple_label_set_label (glabel *gs, tree label)\n /* Return the destination of the unconditional jump GS.  */\n \n static inline tree\n-gimple_goto_dest (const_gimple gs)\n+gimple_goto_dest (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_GOTO);\n   return gimple_op (gs, 0);\n@@ -3646,7 +3646,7 @@ gimple_bind_set_body (gbind *bind_stmt, gimple_seq seq)\n /* Append a statement to the end of a GIMPLE_BIND's body.  */\n \n static inline void\n-gimple_bind_add_stmt (gbind *bind_stmt, gimple stmt)\n+gimple_bind_add_stmt (gbind *bind_stmt, gimple *stmt)\n {\n   gimple_seq_add_stmt (&bind_stmt->body, stmt);\n }\n@@ -3927,7 +3927,7 @@ gimple_catch_set_handler (gcatch *catch_stmt, gimple_seq handler)\n /* Return the types handled by GIMPLE_EH_FILTER statement GS.  */\n \n static inline tree\n-gimple_eh_filter_types (const_gimple gs)\n+gimple_eh_filter_types (const gimple *gs)\n {\n   const geh_filter *eh_filter_stmt = as_a <const geh_filter *> (gs);\n   return eh_filter_stmt->types;\n@@ -3938,7 +3938,7 @@ gimple_eh_filter_types (const_gimple gs)\n    GS.  */\n \n static inline tree *\n-gimple_eh_filter_types_ptr (gimple gs)\n+gimple_eh_filter_types_ptr (gimple *gs)\n {\n   geh_filter *eh_filter_stmt = as_a <geh_filter *> (gs);\n   return &eh_filter_stmt->types;\n@@ -3949,7 +3949,7 @@ gimple_eh_filter_types_ptr (gimple gs)\n    GIMPLE_EH_FILTER statement fails.  */\n \n static inline gimple_seq *\n-gimple_eh_filter_failure_ptr (gimple gs)\n+gimple_eh_filter_failure_ptr (gimple *gs)\n {\n   geh_filter *eh_filter_stmt = as_a <geh_filter *> (gs);\n   return &eh_filter_stmt->failure;\n@@ -3960,7 +3960,7 @@ gimple_eh_filter_failure_ptr (gimple gs)\n    statement fails.  */\n \n static inline gimple_seq\n-gimple_eh_filter_failure (gimple gs)\n+gimple_eh_filter_failure (gimple *gs)\n {\n   return *gimple_eh_filter_failure_ptr (gs);\n }\n@@ -4047,7 +4047,7 @@ gimple_eh_else_set_e_body (geh_else *eh_else_stmt, gimple_seq seq)\n    either GIMPLE_TRY_CATCH or GIMPLE_TRY_FINALLY.  */\n \n static inline enum gimple_try_flags\n-gimple_try_kind (const_gimple gs)\n+gimple_try_kind (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_TRY);\n   return (enum gimple_try_flags) (gs->subcode & GIMPLE_TRY_KIND);\n@@ -4069,7 +4069,7 @@ gimple_try_set_kind (gtry *gs, enum gimple_try_flags kind)\n /* Return the GIMPLE_TRY_CATCH_IS_CLEANUP flag.  */\n \n static inline bool\n-gimple_try_catch_is_cleanup (const_gimple gs)\n+gimple_try_catch_is_cleanup (const gimple *gs)\n {\n   gcc_gimple_checking_assert (gimple_try_kind (gs) == GIMPLE_TRY_CATCH);\n   return (gs->subcode & GIMPLE_TRY_CATCH_IS_CLEANUP) != 0;\n@@ -4080,7 +4080,7 @@ gimple_try_catch_is_cleanup (const_gimple gs)\n    body for GIMPLE_TRY GS.  */\n \n static inline gimple_seq *\n-gimple_try_eval_ptr (gimple gs)\n+gimple_try_eval_ptr (gimple *gs)\n {\n   gtry *try_stmt = as_a <gtry *> (gs);\n   return &try_stmt->eval;\n@@ -4090,7 +4090,7 @@ gimple_try_eval_ptr (gimple gs)\n /* Return the sequence of statements used as the body for GIMPLE_TRY GS.  */\n \n static inline gimple_seq\n-gimple_try_eval (gimple gs)\n+gimple_try_eval (gimple *gs)\n {\n   return *gimple_try_eval_ptr (gs);\n }\n@@ -4100,7 +4100,7 @@ gimple_try_eval (gimple gs)\n    GIMPLE_TRY GS.  */\n \n static inline gimple_seq *\n-gimple_try_cleanup_ptr (gimple gs)\n+gimple_try_cleanup_ptr (gimple *gs)\n {\n   gtry *try_stmt = as_a <gtry *> (gs);\n   return &try_stmt->cleanup;\n@@ -4111,7 +4111,7 @@ gimple_try_cleanup_ptr (gimple gs)\n    GIMPLE_TRY GS.  */\n \n static inline gimple_seq\n-gimple_try_cleanup (gimple gs)\n+gimple_try_cleanup (gimple *gs)\n {\n   return *gimple_try_cleanup_ptr (gs);\n }\n@@ -4153,7 +4153,7 @@ gimple_try_set_cleanup (gtry *try_stmt, gimple_seq cleanup)\n /* Return a pointer to the cleanup sequence for cleanup statement GS.  */\n \n static inline gimple_seq *\n-gimple_wce_cleanup_ptr (gimple gs)\n+gimple_wce_cleanup_ptr (gimple *gs)\n {\n   gimple_statement_wce *wce_stmt = as_a <gimple_statement_wce *> (gs);\n   return &wce_stmt->cleanup;\n@@ -4163,7 +4163,7 @@ gimple_wce_cleanup_ptr (gimple gs)\n /* Return the cleanup sequence for cleanup statement GS.  */\n \n static inline gimple_seq\n-gimple_wce_cleanup (gimple gs)\n+gimple_wce_cleanup (gimple *gs)\n {\n   return *gimple_wce_cleanup_ptr (gs);\n }\n@@ -4172,7 +4172,7 @@ gimple_wce_cleanup (gimple gs)\n /* Set CLEANUP to be the cleanup sequence for GS.  */\n \n static inline void\n-gimple_wce_set_cleanup (gimple gs, gimple_seq cleanup)\n+gimple_wce_set_cleanup (gimple *gs, gimple_seq cleanup)\n {\n   gimple_statement_wce *wce_stmt = as_a <gimple_statement_wce *> (gs);\n   wce_stmt->cleanup = cleanup;\n@@ -4182,7 +4182,7 @@ gimple_wce_set_cleanup (gimple gs, gimple_seq cleanup)\n /* Return the CLEANUP_EH_ONLY flag for a WCE tuple.  */\n \n static inline bool\n-gimple_wce_cleanup_eh_only (const_gimple gs)\n+gimple_wce_cleanup_eh_only (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_WITH_CLEANUP_EXPR);\n   return gs->subcode != 0;\n@@ -4192,7 +4192,7 @@ gimple_wce_cleanup_eh_only (const_gimple gs)\n /* Set the CLEANUP_EH_ONLY flag for a WCE tuple.  */\n \n static inline void\n-gimple_wce_set_cleanup_eh_only (gimple gs, bool eh_only_p)\n+gimple_wce_set_cleanup_eh_only (gimple *gs, bool eh_only_p)\n {\n   GIMPLE_CHECK (gs, GIMPLE_WITH_CLEANUP_EXPR);\n   gs->subcode = (unsigned int) eh_only_p;\n@@ -4202,7 +4202,7 @@ gimple_wce_set_cleanup_eh_only (gimple gs, bool eh_only_p)\n /* Return the maximum number of arguments supported by GIMPLE_PHI GS.  */\n \n static inline unsigned\n-gimple_phi_capacity (const_gimple gs)\n+gimple_phi_capacity (const gimple *gs)\n {\n   const gphi *phi_stmt = as_a <const gphi *> (gs);\n   return phi_stmt->capacity;\n@@ -4214,7 +4214,7 @@ gimple_phi_capacity (const_gimple gs)\n    GS.  */\n \n static inline unsigned\n-gimple_phi_num_args (const_gimple gs)\n+gimple_phi_num_args (const gimple *gs)\n {\n   const gphi *phi_stmt = as_a <const gphi *> (gs);\n   return phi_stmt->nargs;\n@@ -4224,7 +4224,7 @@ gimple_phi_num_args (const_gimple gs)\n /* Return the SSA name created by GIMPLE_PHI GS.  */\n \n static inline tree\n-gimple_phi_result (const_gimple gs)\n+gimple_phi_result (const gimple *gs)\n {\n   const gphi *phi_stmt = as_a <const gphi *> (gs);\n   return phi_stmt->result;\n@@ -4233,7 +4233,7 @@ gimple_phi_result (const_gimple gs)\n /* Return a pointer to the SSA name created by GIMPLE_PHI GS.  */\n \n static inline tree *\n-gimple_phi_result_ptr (gimple gs)\n+gimple_phi_result_ptr (gimple *gs)\n {\n   gphi *phi_stmt = as_a <gphi *> (gs);\n   return &phi_stmt->result;\n@@ -4254,7 +4254,7 @@ gimple_phi_set_result (gphi *phi, tree result)\n    GIMPLE_PHI GS.  */\n \n static inline struct phi_arg_d *\n-gimple_phi_arg (gimple gs, unsigned index)\n+gimple_phi_arg (gimple *gs, unsigned index)\n {\n   gphi *phi_stmt = as_a <gphi *> (gs);\n   gcc_gimple_checking_assert (index <= phi_stmt->capacity);\n@@ -4293,7 +4293,7 @@ phi_nodes_ptr (basic_block bb)\n /* Return the tree operand for argument I of PHI node GS.  */\n \n static inline tree\n-gimple_phi_arg_def (gimple gs, size_t index)\n+gimple_phi_arg_def (gimple *gs, size_t index)\n {\n   return gimple_phi_arg (gs, index)->def;\n }\n@@ -4475,15 +4475,15 @@ gimple_switch_set_default_label (gswitch *gs, tree label)\n /* Return true if GS is a GIMPLE_DEBUG statement.  */\n \n static inline bool\n-is_gimple_debug (const_gimple gs)\n+is_gimple_debug (const gimple *gs)\n {\n   return gimple_code (gs) == GIMPLE_DEBUG;\n }\n \n /* Return true if S is a GIMPLE_DEBUG BIND statement.  */\n \n static inline bool\n-gimple_debug_bind_p (const_gimple s)\n+gimple_debug_bind_p (const gimple *s)\n {\n   if (is_gimple_debug (s))\n     return s->subcode == GIMPLE_DEBUG_BIND;\n@@ -4494,7 +4494,7 @@ gimple_debug_bind_p (const_gimple s)\n /* Return the variable bound in a GIMPLE_DEBUG bind statement.  */\n \n static inline tree\n-gimple_debug_bind_get_var (gimple dbg)\n+gimple_debug_bind_get_var (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4505,7 +4505,7 @@ gimple_debug_bind_get_var (gimple dbg)\n    statement.  */\n \n static inline tree\n-gimple_debug_bind_get_value (gimple dbg)\n+gimple_debug_bind_get_value (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4516,7 +4516,7 @@ gimple_debug_bind_get_value (gimple dbg)\n    GIMPLE_DEBUG bind statement.  */\n \n static inline tree *\n-gimple_debug_bind_get_value_ptr (gimple dbg)\n+gimple_debug_bind_get_value_ptr (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4526,7 +4526,7 @@ gimple_debug_bind_get_value_ptr (gimple dbg)\n /* Set the variable bound in a GIMPLE_DEBUG bind statement.  */\n \n static inline void\n-gimple_debug_bind_set_var (gimple dbg, tree var)\n+gimple_debug_bind_set_var (gimple *dbg, tree var)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4537,7 +4537,7 @@ gimple_debug_bind_set_var (gimple dbg, tree var)\n    statement.  */\n \n static inline void\n-gimple_debug_bind_set_value (gimple dbg, tree value)\n+gimple_debug_bind_set_value (gimple *dbg, tree value)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4552,7 +4552,7 @@ gimple_debug_bind_set_value (gimple dbg, tree value)\n    statement.  */\n \n static inline void\n-gimple_debug_bind_reset_value (gimple dbg)\n+gimple_debug_bind_reset_value (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4563,7 +4563,7 @@ gimple_debug_bind_reset_value (gimple dbg)\n    value.  */\n \n static inline bool\n-gimple_debug_bind_has_value_p (gimple dbg)\n+gimple_debug_bind_has_value_p (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n@@ -4575,7 +4575,7 @@ gimple_debug_bind_has_value_p (gimple dbg)\n /* Return true if S is a GIMPLE_DEBUG SOURCE BIND statement.  */\n \n static inline bool\n-gimple_debug_source_bind_p (const_gimple s)\n+gimple_debug_source_bind_p (const gimple *s)\n {\n   if (is_gimple_debug (s))\n     return s->subcode == GIMPLE_DEBUG_SOURCE_BIND;\n@@ -4586,7 +4586,7 @@ gimple_debug_source_bind_p (const_gimple s)\n /* Return the variable bound in a GIMPLE_DEBUG source bind statement.  */\n \n static inline tree\n-gimple_debug_source_bind_get_var (gimple dbg)\n+gimple_debug_source_bind_get_var (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n@@ -4597,7 +4597,7 @@ gimple_debug_source_bind_get_var (gimple dbg)\n    statement.  */\n \n static inline tree\n-gimple_debug_source_bind_get_value (gimple dbg)\n+gimple_debug_source_bind_get_value (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n@@ -4608,7 +4608,7 @@ gimple_debug_source_bind_get_value (gimple dbg)\n    GIMPLE_DEBUG source bind statement.  */\n \n static inline tree *\n-gimple_debug_source_bind_get_value_ptr (gimple dbg)\n+gimple_debug_source_bind_get_value_ptr (gimple *dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n@@ -4618,7 +4618,7 @@ gimple_debug_source_bind_get_value_ptr (gimple dbg)\n /* Set the variable bound in a GIMPLE_DEBUG source bind statement.  */\n \n static inline void\n-gimple_debug_source_bind_set_var (gimple dbg, tree var)\n+gimple_debug_source_bind_set_var (gimple *dbg, tree var)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n@@ -4629,7 +4629,7 @@ gimple_debug_source_bind_set_var (gimple dbg, tree var)\n    statement.  */\n \n static inline void\n-gimple_debug_source_bind_set_value (gimple dbg, tree value)\n+gimple_debug_source_bind_set_value (gimple *dbg, tree value)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n   gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n@@ -4639,7 +4639,7 @@ gimple_debug_source_bind_set_value (gimple dbg, tree value)\n /* Return the line number for EXPR, or return -1 if we have no line\n    number information for it.  */\n static inline int\n-get_lineno (const_gimple stmt)\n+get_lineno (const gimple *stmt)\n {\n   location_t loc;\n \n@@ -4656,23 +4656,23 @@ get_lineno (const_gimple stmt)\n /* Return a pointer to the body for the OMP statement GS.  */\n \n static inline gimple_seq *\n-gimple_omp_body_ptr (gimple gs)\n+gimple_omp_body_ptr (gimple *gs)\n {\n   return &static_cast <gimple_statement_omp *> (gs)->body;\n }\n \n /* Return the body for the OMP statement GS.  */\n \n static inline gimple_seq\n-gimple_omp_body (gimple gs)\n+gimple_omp_body (gimple *gs)\n {\n   return *gimple_omp_body_ptr (gs);\n }\n \n /* Set BODY to be the body for the OMP statement GS.  */\n \n static inline void\n-gimple_omp_set_body (gimple gs, gimple_seq body)\n+gimple_omp_set_body (gimple *gs, gimple_seq body)\n {\n   static_cast <gimple_statement_omp *> (gs)->body = body;\n }\n@@ -4708,7 +4708,7 @@ gimple_omp_critical_set_name (gomp_critical *crit_stmt, tree name)\n /* Return the kind of the OMP_FOR statemement G.  */\n \n static inline int\n-gimple_omp_for_kind (const_gimple g)\n+gimple_omp_for_kind (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n   return (gimple_omp_subcode (g) & GF_OMP_FOR_KIND_MASK);\n@@ -4729,7 +4729,7 @@ gimple_omp_for_set_kind (gomp_for *g, int kind)\n    GF_OMP_FOR_COMBINED flag set.  */\n \n static inline bool\n-gimple_omp_for_combined_p (const_gimple g)\n+gimple_omp_for_combined_p (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n   return (gimple_omp_subcode (g) & GF_OMP_FOR_COMBINED) != 0;\n@@ -4753,7 +4753,7 @@ gimple_omp_for_set_combined_p (gomp_for *g, bool combined_p)\n    GF_OMP_FOR_COMBINED_INTO flag set.  */\n \n static inline bool\n-gimple_omp_for_combined_into_p (const_gimple g)\n+gimple_omp_for_combined_into_p (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n   return (gimple_omp_subcode (g) & GF_OMP_FOR_COMBINED_INTO) != 0;\n@@ -4776,7 +4776,7 @@ gimple_omp_for_set_combined_into_p (gomp_for *g, bool combined_p)\n /* Return the clauses associated with the OMP_FOR statement GS.  */\n \n static inline tree\n-gimple_omp_for_clauses (const_gimple gs)\n+gimple_omp_for_clauses (const gimple *gs)\n {\n   const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n   return omp_for_stmt->clauses;\n@@ -4787,7 +4787,7 @@ gimple_omp_for_clauses (const_gimple gs)\n    GS.  */\n \n static inline tree *\n-gimple_omp_for_clauses_ptr (gimple gs)\n+gimple_omp_for_clauses_ptr (gimple *gs)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   return &omp_for_stmt->clauses;\n@@ -4798,7 +4798,7 @@ gimple_omp_for_clauses_ptr (gimple gs)\n    GS.  */\n \n static inline void\n-gimple_omp_for_set_clauses (gimple gs, tree clauses)\n+gimple_omp_for_set_clauses (gimple *gs, tree clauses)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   omp_for_stmt->clauses = clauses;\n@@ -4808,7 +4808,7 @@ gimple_omp_for_set_clauses (gimple gs, tree clauses)\n /* Get the collapse count of the OMP_FOR statement GS.  */\n \n static inline size_t\n-gimple_omp_for_collapse (gimple gs)\n+gimple_omp_for_collapse (gimple *gs)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   return omp_for_stmt->collapse;\n@@ -4818,7 +4818,7 @@ gimple_omp_for_collapse (gimple gs)\n /* Return the condition code associated with the OMP_FOR statement GS.  */\n \n static inline enum tree_code\n-gimple_omp_for_cond (const_gimple gs, size_t i)\n+gimple_omp_for_cond (const gimple *gs, size_t i)\n {\n   const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4829,7 +4829,7 @@ gimple_omp_for_cond (const_gimple gs, size_t i)\n /* Set COND to be the condition code for the OMP_FOR statement GS.  */\n \n static inline void\n-gimple_omp_for_set_cond (gimple gs, size_t i, enum tree_code cond)\n+gimple_omp_for_set_cond (gimple *gs, size_t i, enum tree_code cond)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (TREE_CODE_CLASS (cond) == tcc_comparison\n@@ -4841,7 +4841,7 @@ gimple_omp_for_set_cond (gimple gs, size_t i, enum tree_code cond)\n /* Return the index variable for the OMP_FOR statement GS.  */\n \n static inline tree\n-gimple_omp_for_index (const_gimple gs, size_t i)\n+gimple_omp_for_index (const gimple *gs, size_t i)\n {\n   const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4852,7 +4852,7 @@ gimple_omp_for_index (const_gimple gs, size_t i)\n /* Return a pointer to the index variable for the OMP_FOR statement GS.  */\n \n static inline tree *\n-gimple_omp_for_index_ptr (gimple gs, size_t i)\n+gimple_omp_for_index_ptr (gimple *gs, size_t i)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4863,7 +4863,7 @@ gimple_omp_for_index_ptr (gimple gs, size_t i)\n /* Set INDEX to be the index variable for the OMP_FOR statement GS.  */\n \n static inline void\n-gimple_omp_for_set_index (gimple gs, size_t i, tree index)\n+gimple_omp_for_set_index (gimple *gs, size_t i, tree index)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4874,7 +4874,7 @@ gimple_omp_for_set_index (gimple gs, size_t i, tree index)\n /* Return the initial value for the OMP_FOR statement GS.  */\n \n static inline tree\n-gimple_omp_for_initial (const_gimple gs, size_t i)\n+gimple_omp_for_initial (const gimple *gs, size_t i)\n {\n   const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4885,7 +4885,7 @@ gimple_omp_for_initial (const_gimple gs, size_t i)\n /* Return a pointer to the initial value for the OMP_FOR statement GS.  */\n \n static inline tree *\n-gimple_omp_for_initial_ptr (gimple gs, size_t i)\n+gimple_omp_for_initial_ptr (gimple *gs, size_t i)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4896,7 +4896,7 @@ gimple_omp_for_initial_ptr (gimple gs, size_t i)\n /* Set INITIAL to be the initial value for the OMP_FOR statement GS.  */\n \n static inline void\n-gimple_omp_for_set_initial (gimple gs, size_t i, tree initial)\n+gimple_omp_for_set_initial (gimple *gs, size_t i, tree initial)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4907,7 +4907,7 @@ gimple_omp_for_set_initial (gimple gs, size_t i, tree initial)\n /* Return the final value for the OMP_FOR statement GS.  */\n \n static inline tree\n-gimple_omp_for_final (const_gimple gs, size_t i)\n+gimple_omp_for_final (const gimple *gs, size_t i)\n {\n   const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4918,7 +4918,7 @@ gimple_omp_for_final (const_gimple gs, size_t i)\n /* Return a pointer to the final value for the OMP_FOR statement GS.  */\n \n static inline tree *\n-gimple_omp_for_final_ptr (gimple gs, size_t i)\n+gimple_omp_for_final_ptr (gimple *gs, size_t i)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4929,7 +4929,7 @@ gimple_omp_for_final_ptr (gimple gs, size_t i)\n /* Set FINAL to be the final value for the OMP_FOR statement GS.  */\n \n static inline void\n-gimple_omp_for_set_final (gimple gs, size_t i, tree final)\n+gimple_omp_for_set_final (gimple *gs, size_t i, tree final)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4940,7 +4940,7 @@ gimple_omp_for_set_final (gimple gs, size_t i, tree final)\n /* Return the increment value for the OMP_FOR statement GS.  */\n \n static inline tree\n-gimple_omp_for_incr (const_gimple gs, size_t i)\n+gimple_omp_for_incr (const gimple *gs, size_t i)\n {\n   const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4951,7 +4951,7 @@ gimple_omp_for_incr (const_gimple gs, size_t i)\n /* Return a pointer to the increment value for the OMP_FOR statement GS.  */\n \n static inline tree *\n-gimple_omp_for_incr_ptr (gimple gs, size_t i)\n+gimple_omp_for_incr_ptr (gimple *gs, size_t i)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4962,7 +4962,7 @@ gimple_omp_for_incr_ptr (gimple gs, size_t i)\n /* Set INCR to be the increment value for the OMP_FOR statement GS.  */\n \n static inline void\n-gimple_omp_for_set_incr (gimple gs, size_t i, tree incr)\n+gimple_omp_for_set_incr (gimple *gs, size_t i, tree incr)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n@@ -4974,7 +4974,7 @@ gimple_omp_for_set_incr (gimple gs, size_t i, tree incr)\n    statement GS starts.  */\n \n static inline gimple_seq *\n-gimple_omp_for_pre_body_ptr (gimple gs)\n+gimple_omp_for_pre_body_ptr (gimple *gs)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   return &omp_for_stmt->pre_body;\n@@ -4985,7 +4985,7 @@ gimple_omp_for_pre_body_ptr (gimple gs)\n    statement GS starts.  */\n \n static inline gimple_seq\n-gimple_omp_for_pre_body (gimple gs)\n+gimple_omp_for_pre_body (gimple *gs)\n {\n   return *gimple_omp_for_pre_body_ptr (gs);\n }\n@@ -4995,7 +4995,7 @@ gimple_omp_for_pre_body (gimple gs)\n    OMP_FOR statement GS starts.  */\n \n static inline void\n-gimple_omp_for_set_pre_body (gimple gs, gimple_seq pre_body)\n+gimple_omp_for_set_pre_body (gimple *gs, gimple_seq pre_body)\n {\n   gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n   omp_for_stmt->pre_body = pre_body;\n@@ -5005,7 +5005,7 @@ gimple_omp_for_set_pre_body (gimple gs, gimple_seq pre_body)\n /* Return the clauses associated with OMP_PARALLEL GS.  */\n \n static inline tree\n-gimple_omp_parallel_clauses (const_gimple gs)\n+gimple_omp_parallel_clauses (const gimple *gs)\n {\n   const gomp_parallel *omp_parallel_stmt = as_a <const gomp_parallel *> (gs);\n   return omp_parallel_stmt->clauses;\n@@ -5091,7 +5091,7 @@ gimple_omp_parallel_set_data_arg (gomp_parallel *omp_parallel_stmt,\n /* Return the clauses associated with OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_task_clauses (const_gimple gs)\n+gimple_omp_task_clauses (const gimple *gs)\n {\n   const gomp_task *omp_task_stmt = as_a <const gomp_task *> (gs);\n   return omp_task_stmt->clauses;\n@@ -5101,7 +5101,7 @@ gimple_omp_task_clauses (const_gimple gs)\n /* Return a pointer to the clauses associated with OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_task_clauses_ptr (gimple gs)\n+gimple_omp_task_clauses_ptr (gimple *gs)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   return &omp_task_stmt->clauses;\n@@ -5112,7 +5112,7 @@ gimple_omp_task_clauses_ptr (gimple gs)\n    GS.  */\n \n static inline void\n-gimple_omp_task_set_clauses (gimple gs, tree clauses)\n+gimple_omp_task_set_clauses (gimple *gs, tree clauses)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   omp_task_stmt->clauses = clauses;\n@@ -5122,7 +5122,7 @@ gimple_omp_task_set_clauses (gimple gs, tree clauses)\n /* Return the child function used to hold the body of OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_task_child_fn (const_gimple gs)\n+gimple_omp_task_child_fn (const gimple *gs)\n {\n   const gomp_task *omp_task_stmt = as_a <const gomp_task *> (gs);\n   return omp_task_stmt->child_fn;\n@@ -5132,7 +5132,7 @@ gimple_omp_task_child_fn (const_gimple gs)\n    OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_task_child_fn_ptr (gimple gs)\n+gimple_omp_task_child_fn_ptr (gimple *gs)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   return &omp_task_stmt->child_fn;\n@@ -5142,7 +5142,7 @@ gimple_omp_task_child_fn_ptr (gimple gs)\n /* Set CHILD_FN to be the child function for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_task_set_child_fn (gimple gs, tree child_fn)\n+gimple_omp_task_set_child_fn (gimple *gs, tree child_fn)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   omp_task_stmt->child_fn = child_fn;\n@@ -5153,7 +5153,7 @@ gimple_omp_task_set_child_fn (gimple gs, tree child_fn)\n    from the parent to the children threads in OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_task_data_arg (const_gimple gs)\n+gimple_omp_task_data_arg (const gimple *gs)\n {\n   const gomp_task *omp_task_stmt = as_a <const gomp_task *> (gs);\n   return omp_task_stmt->data_arg;\n@@ -5163,7 +5163,7 @@ gimple_omp_task_data_arg (const_gimple gs)\n /* Return a pointer to the data argument for OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_task_data_arg_ptr (gimple gs)\n+gimple_omp_task_data_arg_ptr (gimple *gs)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   return &omp_task_stmt->data_arg;\n@@ -5173,7 +5173,7 @@ gimple_omp_task_data_arg_ptr (gimple gs)\n /* Set DATA_ARG to be the data argument for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_task_set_data_arg (gimple gs, tree data_arg)\n+gimple_omp_task_set_data_arg (gimple *gs, tree data_arg)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   omp_task_stmt->data_arg = data_arg;\n@@ -5183,7 +5183,7 @@ gimple_omp_task_set_data_arg (gimple gs, tree data_arg)\n /* Return the clauses associated with OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_taskreg_clauses (const_gimple gs)\n+gimple_omp_taskreg_clauses (const gimple *gs)\n {\n   const gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <const gimple_statement_omp_taskreg *> (gs);\n@@ -5194,7 +5194,7 @@ gimple_omp_taskreg_clauses (const_gimple gs)\n /* Return a pointer to the clauses associated with OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_taskreg_clauses_ptr (gimple gs)\n+gimple_omp_taskreg_clauses_ptr (gimple *gs)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <gimple_statement_omp_taskreg *> (gs);\n@@ -5206,7 +5206,7 @@ gimple_omp_taskreg_clauses_ptr (gimple gs)\n    GS.  */\n \n static inline void\n-gimple_omp_taskreg_set_clauses (gimple gs, tree clauses)\n+gimple_omp_taskreg_set_clauses (gimple *gs, tree clauses)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <gimple_statement_omp_taskreg *> (gs);\n@@ -5217,7 +5217,7 @@ gimple_omp_taskreg_set_clauses (gimple gs, tree clauses)\n /* Return the child function used to hold the body of OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_taskreg_child_fn (const_gimple gs)\n+gimple_omp_taskreg_child_fn (const gimple *gs)\n {\n   const gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <const gimple_statement_omp_taskreg *> (gs);\n@@ -5228,7 +5228,7 @@ gimple_omp_taskreg_child_fn (const_gimple gs)\n    OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_taskreg_child_fn_ptr (gimple gs)\n+gimple_omp_taskreg_child_fn_ptr (gimple *gs)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <gimple_statement_omp_taskreg *> (gs);\n@@ -5239,7 +5239,7 @@ gimple_omp_taskreg_child_fn_ptr (gimple gs)\n /* Set CHILD_FN to be the child function for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_taskreg_set_child_fn (gimple gs, tree child_fn)\n+gimple_omp_taskreg_set_child_fn (gimple *gs, tree child_fn)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <gimple_statement_omp_taskreg *> (gs);\n@@ -5251,7 +5251,7 @@ gimple_omp_taskreg_set_child_fn (gimple gs, tree child_fn)\n    from the parent to the children threads in OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_taskreg_data_arg (const_gimple gs)\n+gimple_omp_taskreg_data_arg (const gimple *gs)\n {\n   const gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <const gimple_statement_omp_taskreg *> (gs);\n@@ -5262,7 +5262,7 @@ gimple_omp_taskreg_data_arg (const_gimple gs)\n /* Return a pointer to the data argument for OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_taskreg_data_arg_ptr (gimple gs)\n+gimple_omp_taskreg_data_arg_ptr (gimple *gs)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <gimple_statement_omp_taskreg *> (gs);\n@@ -5273,7 +5273,7 @@ gimple_omp_taskreg_data_arg_ptr (gimple gs)\n /* Set DATA_ARG to be the data argument for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_taskreg_set_data_arg (gimple gs, tree data_arg)\n+gimple_omp_taskreg_set_data_arg (gimple *gs, tree data_arg)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt\n     = as_a <gimple_statement_omp_taskreg *> (gs);\n@@ -5284,7 +5284,7 @@ gimple_omp_taskreg_set_data_arg (gimple gs, tree data_arg)\n /* Return the copy function used to hold the body of OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_task_copy_fn (const_gimple gs)\n+gimple_omp_task_copy_fn (const gimple *gs)\n {\n   const gomp_task *omp_task_stmt = as_a <const gomp_task *> (gs);\n   return omp_task_stmt->copy_fn;\n@@ -5294,7 +5294,7 @@ gimple_omp_task_copy_fn (const_gimple gs)\n    OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_task_copy_fn_ptr (gimple gs)\n+gimple_omp_task_copy_fn_ptr (gimple *gs)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   return &omp_task_stmt->copy_fn;\n@@ -5304,7 +5304,7 @@ gimple_omp_task_copy_fn_ptr (gimple gs)\n /* Set CHILD_FN to be the copy function for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_task_set_copy_fn (gimple gs, tree copy_fn)\n+gimple_omp_task_set_copy_fn (gimple *gs, tree copy_fn)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   omp_task_stmt->copy_fn = copy_fn;\n@@ -5314,7 +5314,7 @@ gimple_omp_task_set_copy_fn (gimple gs, tree copy_fn)\n /* Return size of the data block in bytes in OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_task_arg_size (const_gimple gs)\n+gimple_omp_task_arg_size (const gimple *gs)\n {\n   const gomp_task *omp_task_stmt = as_a <const gomp_task *> (gs);\n   return omp_task_stmt->arg_size;\n@@ -5324,7 +5324,7 @@ gimple_omp_task_arg_size (const_gimple gs)\n /* Return a pointer to the data block size for OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_task_arg_size_ptr (gimple gs)\n+gimple_omp_task_arg_size_ptr (gimple *gs)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   return &omp_task_stmt->arg_size;\n@@ -5334,7 +5334,7 @@ gimple_omp_task_arg_size_ptr (gimple gs)\n /* Set ARG_SIZE to be the data block size for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_task_set_arg_size (gimple gs, tree arg_size)\n+gimple_omp_task_set_arg_size (gimple *gs, tree arg_size)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   omp_task_stmt->arg_size = arg_size;\n@@ -5344,7 +5344,7 @@ gimple_omp_task_set_arg_size (gimple gs, tree arg_size)\n /* Return align of the data block in bytes in OMP_TASK GS.  */\n \n static inline tree\n-gimple_omp_task_arg_align (const_gimple gs)\n+gimple_omp_task_arg_align (const gimple *gs)\n {\n   const gomp_task *omp_task_stmt = as_a <const gomp_task *> (gs);\n   return omp_task_stmt->arg_align;\n@@ -5354,7 +5354,7 @@ gimple_omp_task_arg_align (const_gimple gs)\n /* Return a pointer to the data block align for OMP_TASK GS.  */\n \n static inline tree *\n-gimple_omp_task_arg_align_ptr (gimple gs)\n+gimple_omp_task_arg_align_ptr (gimple *gs)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   return &omp_task_stmt->arg_align;\n@@ -5364,7 +5364,7 @@ gimple_omp_task_arg_align_ptr (gimple gs)\n /* Set ARG_SIZE to be the data block align for OMP_TASK GS.  */\n \n static inline void\n-gimple_omp_task_set_arg_align (gimple gs, tree arg_align)\n+gimple_omp_task_set_arg_align (gimple *gs, tree arg_align)\n {\n   gomp_task *omp_task_stmt = as_a <gomp_task *> (gs);\n   omp_task_stmt->arg_align = arg_align;\n@@ -5374,7 +5374,7 @@ gimple_omp_task_set_arg_align (gimple gs, tree arg_align)\n /* Return the clauses associated with OMP_SINGLE GS.  */\n \n static inline tree\n-gimple_omp_single_clauses (const_gimple gs)\n+gimple_omp_single_clauses (const gimple *gs)\n {\n   const gomp_single *omp_single_stmt = as_a <const gomp_single *> (gs);\n   return omp_single_stmt->clauses;\n@@ -5384,7 +5384,7 @@ gimple_omp_single_clauses (const_gimple gs)\n /* Return a pointer to the clauses associated with OMP_SINGLE GS.  */\n \n static inline tree *\n-gimple_omp_single_clauses_ptr (gimple gs)\n+gimple_omp_single_clauses_ptr (gimple *gs)\n {\n   gomp_single *omp_single_stmt = as_a <gomp_single *> (gs);\n   return &omp_single_stmt->clauses;\n@@ -5403,7 +5403,7 @@ gimple_omp_single_set_clauses (gomp_single *omp_single_stmt, tree clauses)\n /* Return the clauses associated with OMP_TARGET GS.  */\n \n static inline tree\n-gimple_omp_target_clauses (const_gimple gs)\n+gimple_omp_target_clauses (const gimple *gs)\n {\n   const gomp_target *omp_target_stmt = as_a <const gomp_target *> (gs);\n   return omp_target_stmt->clauses;\n@@ -5413,7 +5413,7 @@ gimple_omp_target_clauses (const_gimple gs)\n /* Return a pointer to the clauses associated with OMP_TARGET GS.  */\n \n static inline tree *\n-gimple_omp_target_clauses_ptr (gimple gs)\n+gimple_omp_target_clauses_ptr (gimple *gs)\n {\n   gomp_target *omp_target_stmt = as_a <gomp_target *> (gs);\n   return &omp_target_stmt->clauses;\n@@ -5433,7 +5433,7 @@ gimple_omp_target_set_clauses (gomp_target *omp_target_stmt,\n /* Return the kind of the OMP_TARGET G.  */\n \n static inline int\n-gimple_omp_target_kind (const_gimple g)\n+gimple_omp_target_kind (const gimple *g)\n {\n   GIMPLE_CHECK (g, GIMPLE_OMP_TARGET);\n   return (gimple_omp_subcode (g) & GF_OMP_TARGET_KIND_MASK);\n@@ -5510,7 +5510,7 @@ gimple_omp_target_set_data_arg (gomp_target *omp_target_stmt,\n /* Return the clauses associated with OMP_TEAMS GS.  */\n \n static inline tree\n-gimple_omp_teams_clauses (const_gimple gs)\n+gimple_omp_teams_clauses (const gimple *gs)\n {\n   const gomp_teams *omp_teams_stmt = as_a <const gomp_teams *> (gs);\n   return omp_teams_stmt->clauses;\n@@ -5520,7 +5520,7 @@ gimple_omp_teams_clauses (const_gimple gs)\n /* Return a pointer to the clauses associated with OMP_TEAMS GS.  */\n \n static inline tree *\n-gimple_omp_teams_clauses_ptr (gimple gs)\n+gimple_omp_teams_clauses_ptr (gimple *gs)\n {\n   gomp_teams *omp_teams_stmt = as_a <gomp_teams *> (gs);\n   return &omp_teams_stmt->clauses;\n@@ -5539,7 +5539,7 @@ gimple_omp_teams_set_clauses (gomp_teams *omp_teams_stmt, tree clauses)\n /* Return the clauses associated with OMP_SECTIONS GS.  */\n \n static inline tree\n-gimple_omp_sections_clauses (const_gimple gs)\n+gimple_omp_sections_clauses (const gimple *gs)\n {\n   const gomp_sections *omp_sections_stmt = as_a <const gomp_sections *> (gs);\n   return omp_sections_stmt->clauses;\n@@ -5549,7 +5549,7 @@ gimple_omp_sections_clauses (const_gimple gs)\n /* Return a pointer to the clauses associated with OMP_SECTIONS GS.  */\n \n static inline tree *\n-gimple_omp_sections_clauses_ptr (gimple gs)\n+gimple_omp_sections_clauses_ptr (gimple *gs)\n {\n   gomp_sections *omp_sections_stmt = as_a <gomp_sections *> (gs);\n   return &omp_sections_stmt->clauses;\n@@ -5560,7 +5560,7 @@ gimple_omp_sections_clauses_ptr (gimple gs)\n    GS.  */\n \n static inline void\n-gimple_omp_sections_set_clauses (gimple gs, tree clauses)\n+gimple_omp_sections_set_clauses (gimple *gs, tree clauses)\n {\n   gomp_sections *omp_sections_stmt = as_a <gomp_sections *> (gs);\n   omp_sections_stmt->clauses = clauses;\n@@ -5571,7 +5571,7 @@ gimple_omp_sections_set_clauses (gimple gs, tree clauses)\n    in GS.  */\n \n static inline tree\n-gimple_omp_sections_control (const_gimple gs)\n+gimple_omp_sections_control (const gimple *gs)\n {\n   const gomp_sections *omp_sections_stmt = as_a <const gomp_sections *> (gs);\n   return omp_sections_stmt->control;\n@@ -5582,7 +5582,7 @@ gimple_omp_sections_control (const_gimple gs)\n    GS.  */\n \n static inline tree *\n-gimple_omp_sections_control_ptr (gimple gs)\n+gimple_omp_sections_control_ptr (gimple *gs)\n {\n   gomp_sections *omp_sections_stmt = as_a <gomp_sections *> (gs);\n   return &omp_sections_stmt->control;\n@@ -5593,7 +5593,7 @@ gimple_omp_sections_control_ptr (gimple gs)\n    GIMPLE_OMP_SECTIONS in GS.  */\n \n static inline void\n-gimple_omp_sections_set_control (gimple gs, tree control)\n+gimple_omp_sections_set_control (gimple *gs, tree control)\n {\n   gomp_sections *omp_sections_stmt = as_a <gomp_sections *> (gs);\n   omp_sections_stmt->control = control;\n@@ -5828,7 +5828,7 @@ gimple_return_set_retval (greturn *gs, tree retval)\n /* Return the return bounds for GIMPLE_RETURN GS.  */\n \n static inline tree\n-gimple_return_retbnd (const_gimple gs)\n+gimple_return_retbnd (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RETURN);\n   return gimple_op (gs, 1);\n@@ -5838,7 +5838,7 @@ gimple_return_retbnd (const_gimple gs)\n /* Set RETVAL to be the return bounds for GIMPLE_RETURN GS.  */\n \n static inline void\n-gimple_return_set_retbnd (gimple gs, tree retval)\n+gimple_return_set_retbnd (gimple *gs, tree retval)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RETURN);\n   gimple_set_op (gs, 1, retval);\n@@ -5867,7 +5867,7 @@ gimple_return_set_retbnd (gimple gs, tree retval)\n     case GIMPLE_OMP_CONTINUE\n \n static inline bool\n-is_gimple_omp (const_gimple stmt)\n+is_gimple_omp (const gimple *stmt)\n {\n   switch (gimple_code (stmt))\n     {\n@@ -5882,7 +5882,7 @@ is_gimple_omp (const_gimple stmt)\n    specifically.  */\n \n static inline bool\n-is_gimple_omp_oacc (const_gimple stmt)\n+is_gimple_omp_oacc (const gimple *stmt)\n {\n   gcc_assert (is_gimple_omp (stmt));\n   switch (gimple_code (stmt))\n@@ -5916,7 +5916,7 @@ is_gimple_omp_oacc (const_gimple stmt)\n /* Return true if the OMP gimple statement STMT is offloaded.  */\n \n static inline bool\n-is_gimple_omp_offloaded (const_gimple stmt)\n+is_gimple_omp_offloaded (const gimple *stmt)\n {\n   gcc_assert (is_gimple_omp (stmt));\n   switch (gimple_code (stmt))\n@@ -5940,7 +5940,7 @@ is_gimple_omp_offloaded (const_gimple stmt)\n /* Returns TRUE if statement G is a GIMPLE_NOP.  */\n \n static inline bool\n-gimple_nop_p (const_gimple g)\n+gimple_nop_p (const gimple *g)\n {\n   return gimple_code (g) == GIMPLE_NOP;\n }\n@@ -5949,7 +5949,7 @@ gimple_nop_p (const_gimple g)\n /* Return true if GS is a GIMPLE_RESX.  */\n \n static inline bool\n-is_gimple_resx (const_gimple gs)\n+is_gimple_resx (const gimple *gs)\n {\n   return gimple_code (gs) == GIMPLE_RESX;\n }\n@@ -5958,7 +5958,7 @@ is_gimple_resx (const_gimple gs)\n    void_type_node if the statement computes nothing.  */\n \n static inline tree\n-gimple_expr_type (const_gimple stmt)\n+gimple_expr_type (const gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   /* In general we want to pass out a type that can be substituted\n@@ -6023,7 +6023,7 @@ gimple_alloc_kind (enum gimple_code code)\n    by annotate_all_with_location.  */\n \n static inline bool\n-gimple_do_not_emit_location_p (gimple g)\n+gimple_do_not_emit_location_p (gimple *g)\n {\n   return gimple_plf (g, GF_PLF_1);\n }\n@@ -6032,7 +6032,7 @@ gimple_do_not_emit_location_p (gimple g)\n    annotate_one_with_location.  */\n \n static inline void\n-gimple_set_do_not_emit_location (gimple g)\n+gimple_set_do_not_emit_location (gimple *g)\n {\n   /* The PLF flags are initialized to 0 when a new tuple is created,\n      so no need to initialize it anywhere.  */"}, {"sha": "b3b4b111bfa781c7d4cc1bd88d1d7ac7dd8eb320", "filename": "gcc/gimplify-me.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify-me.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify-me.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify-me.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -155,12 +155,12 @@ force_gimple_operand_gsi (gimple_stmt_iterator *gsi, tree expr,\n    GIMPLE statements are inserted before *GSI_P.  */\n \n void\n-gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n+gimple_regimplify_operands (gimple *stmt, gimple_stmt_iterator *gsi_p)\n {\n   size_t i, num_ops;\n   tree lhs;\n   gimple_seq pre = NULL;\n-  gimple post_stmt = NULL;\n+  gimple *post_stmt = NULL;\n \n   push_gimplify_context (gimple_in_ssa_p (cfun));\n "}, {"sha": "4a50c079a51fde395c0eef53f1d9ded64b1af5df", "filename": "gcc/gimplify-me.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify-me.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify-me.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify-me.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -32,6 +32,6 @@ extern tree force_gimple_operand_gsi_1 (gimple_stmt_iterator *, tree,\n \t\t\t\t\tbool, enum gsi_iterator_update);\n extern tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,\n \t\t\t\t      bool, enum gsi_iterator_update);\n-extern void gimple_regimplify_operands (gimple, gimple_stmt_iterator *);\n+extern void gimple_regimplify_operands (gimple *, gimple_stmt_iterator *);\n \n #endif /* GCC_GIMPLIFY_ME_H */"}, {"sha": "25a81f681a9443e1475cbbb3cf7c737fe88dd00a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -164,7 +164,7 @@ static enum gimplify_status gimplify_compound_expr (tree *, gimple_seq *, bool);\n    only.  */\n \n static inline void\n-gimplify_seq_add_stmt (gimple_seq *seq_p, gimple gs)\n+gimplify_seq_add_stmt (gimple_seq *seq_p, gimple *gs)\n {\n   gimple_seq_add_stmt_without_update (seq_p, gs);\n }\n@@ -253,7 +253,7 @@ push_gimplify_context (bool in_ssa, bool rhs_cond_ok)\n    BODY is not a sequence, but the first tuple in a sequence.  */\n \n void\n-pop_gimplify_context (gimple body)\n+pop_gimplify_context (gimple *body)\n {\n   struct gimplify_ctx *c = gimplify_ctxp;\n \n@@ -402,7 +402,7 @@ gimplify_and_add (tree t, gimple_seq *seq_p)\n    tuple in the sequence of generated tuples for this statement.\n    Return NULL if gimplifying T produced no tuples.  */\n \n-static gimple\n+static gimple *\n gimplify_and_return_first (tree t, gimple_seq *seq_p)\n {\n   gimple_stmt_iterator last = gsi_last (*seq_p);\n@@ -577,7 +577,7 @@ get_initialized_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p)\n    generate debug info for them; otherwise don't.  */\n \n void\n-declare_vars (tree vars, gimple gs, bool debug_info)\n+declare_vars (tree vars, gimple *gs, bool debug_info)\n {\n   tree last = vars;\n   if (last)\n@@ -1155,7 +1155,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \t  && flag_stack_reuse != SR_NONE)\n \t{\n \t  tree clobber = build_constructor (TREE_TYPE (t), NULL);\n-\t  gimple clobber_stmt;\n+\t  gimple *clobber_stmt;\n \t  TREE_THIS_VOLATILE (clobber) = 1;\n \t  clobber_stmt = gimple_build_assign (t, clobber);\n \t  gimple_set_location (clobber_stmt, end_locus);\n@@ -2297,7 +2297,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t\t\tEXPR_LOCATION (*expr_p));\n \t  vargs.quick_push (CALL_EXPR_ARG (*expr_p, i));\n \t}\n-      gimple call = gimple_build_call_internal_vec (ifn, vargs);\n+      gimple *call = gimple_build_call_internal_vec (ifn, vargs);\n       gimplify_seq_add_stmt (pre_p, call);\n       return GS_ALL_DONE;\n     }\n@@ -3167,7 +3167,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n \t      && TREE_OPERAND (expr, 2) != NULL_TREE\n \t      && gimple_seq_may_fallthru (seq))\n \t    {\n-\t      gimple g;\n+\t      gimple *g;\n \t      label_cont = create_artificial_label (UNKNOWN_LOCATION);\n \n \t      g = gimple_build_goto (label_cont);\n@@ -4547,7 +4547,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   tree *from_p = &TREE_OPERAND (*expr_p, 1);\n   tree *to_p = &TREE_OPERAND (*expr_p, 0);\n   enum gimplify_status ret = GS_UNHANDLED;\n-  gimple assign;\n+  gimple *assign;\n   location_t loc = EXPR_LOCATION (*expr_p);\n   gimple_stmt_iterator gsi;\n \n@@ -5307,7 +5307,7 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n \n   for (iter = gsi_start (body_sequence); !gsi_end_p (iter); )\n     {\n-      gimple wce = gsi_stmt (iter);\n+      gimple *wce = gsi_stmt (iter);\n \n       if (gimple_code (wce) == GIMPLE_WITH_CLEANUP_EXPR)\n \t{\n@@ -5365,7 +5365,7 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n static void\n gimple_push_cleanup (tree var, tree cleanup, bool eh_only, gimple_seq *pre_p)\n {\n-  gimple wce;\n+  gimple *wce;\n   gimple_seq cleanup_stmts = NULL;\n \n   /* Errors can result in improperly nested cleanups.  Which results in\n@@ -6907,7 +6907,7 @@ static void\n gimplify_omp_parallel (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n-  gimple g;\n+  gimple *g;\n   gimple_seq body = NULL;\n \n   gimplify_scan_omp_clauses (&OMP_PARALLEL_CLAUSES (expr), pre_p,\n@@ -6943,7 +6943,7 @@ static void\n gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n-  gimple g;\n+  gimple *g;\n   gimple_seq body = NULL;\n \n   gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p,\n@@ -7501,7 +7501,7 @@ static void\n gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_seq body = NULL;\n   enum omp_region_type ort;\n \n@@ -7530,7 +7530,7 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n   if (ort == ORT_TARGET || ort == ORT_TARGET_DATA)\n     {\n       push_gimplify_context ();\n-      gimple g = gimplify_and_return_first (OMP_BODY (expr), &body);\n+      gimple *g = gimplify_and_return_first (OMP_BODY (expr), &body);\n       if (gimple_code (g) == GIMPLE_BIND)\n \tpop_gimplify_context (g);\n       else\n@@ -7805,7 +7805,7 @@ static enum gimplify_status\n gimplify_transaction (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p, temp, tbody = TRANSACTION_EXPR_BODY (expr);\n-  gimple body_stmt;\n+  gimple *body_stmt;\n   gtransaction *trans_stmt;\n   gimple_seq body = NULL;\n   int subcode = 0;\n@@ -8485,7 +8485,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase CATCH_EXPR:\n \t  {\n-\t    gimple c;\n+\t    gimple *c;\n \t    gimple_seq handler = NULL;\n \t    gimplify_and_add (CATCH_BODY (*expr_p), &handler);\n \t    c = gimple_build_catch (CATCH_TYPES (*expr_p), handler);\n@@ -8496,7 +8496,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase EH_FILTER_EXPR:\n \t  {\n-\t    gimple ehf;\n+\t    gimple *ehf;\n \t    gimple_seq failure = NULL;\n \n \t    gimplify_and_add (EH_FILTER_FAILURE (*expr_p), &failure);\n@@ -8630,7 +8630,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase OMP_CRITICAL:\n \t  {\n \t    gimple_seq body = NULL;\n-\t    gimple g;\n+\t    gimple *g;\n \n \t    gimplify_and_add (OMP_BODY (*expr_p), &body);\n \t    switch (TREE_CODE (*expr_p))\n@@ -9207,7 +9207,7 @@ gimplify_body (tree fndecl, bool do_parms)\n {\n   location_t saved_location = input_location;\n   gimple_seq parm_stmts, seq;\n-  gimple outer_stmt;\n+  gimple *outer_stmt;\n   gbind *outer_bind;\n   struct cgraph_node *cgn;\n \n@@ -9423,7 +9423,7 @@ gimplify_function_tree (tree fndecl)\n     {\n       tree x;\n       gbind *new_bind;\n-      gimple tf;\n+      gimple *tf;\n       gimple_seq cleanup = NULL, body = NULL;\n       tree tmp_var;\n       gcall *call;\n@@ -9468,7 +9468,7 @@ gimplify_function_tree (tree fndecl)\n       && !lookup_attribute (\"no_sanitize_thread\", DECL_ATTRIBUTES (fndecl)))\n     {\n       gcall *call = gimple_build_call_internal (IFN_TSAN_FUNC_EXIT, 0);\n-      gimple tf = gimple_build_try (seq, call, GIMPLE_TRY_FINALLY);\n+      gimple *tf = gimple_build_try (seq, call, GIMPLE_TRY_FINALLY);\n       gbind *new_bind = gimple_build_bind (NULL, tf, gimple_bind_block (bind));\n       /* Clear the block for BIND, since it is no longer directly inside\n \t the function, but within a try block.  */\n@@ -9579,7 +9579,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n \n    This function returns the newly created GIMPLE_ASSIGN tuple.  */\n \n-gimple\n+gimple *\n gimplify_assign (tree dst, tree src, gimple_seq *seq_p)\n {\n   tree t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);"}, {"sha": "e350edc028576866147de4cd4fb4a04b673f9dcd", "filename": "gcc/gimplify.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -52,13 +52,13 @@ enum gimplify_status {\n extern void free_gimplify_stack (void);\n extern void push_gimplify_context (bool in_ssa = false,\n \t\t\t\t   bool rhs_cond_ok = false);\n-extern void pop_gimplify_context (gimple);\n+extern void pop_gimplify_context (gimple *);\n extern gbind *gimple_current_bind_expr (void);\n extern vec<gbind *> gimple_bind_expr_stack (void);\n extern void gimplify_and_add (tree, gimple_seq *);\n extern tree get_formal_tmp_var (tree, gimple_seq *);\n extern tree get_initialized_tmp_var (tree, gimple_seq *, gimple_seq *);\n-extern void declare_vars (tree, gimple, bool);\n+extern void declare_vars (tree, gimple *, bool);\n extern void gimple_add_tmp_var (tree);\n extern void gimple_add_tmp_var_fn (struct function *, tree);\n extern tree unshare_expr (tree);\n@@ -81,7 +81,7 @@ extern enum gimplify_status gimplify_arg (tree *, gimple_seq *, location_t);\n extern void gimplify_function_tree (tree);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, gimple_seq *,\n \t\t\t\t\t\t  gimple_seq *);\n-gimple gimplify_assign (tree, tree, gimple_seq *);\n+gimple *gimplify_assign (tree, tree, gimple_seq *);\n \n /* Return true if gimplify_one_sizepos doesn't need to gimplify\n    expr (when in TYPE_SIZE{,_UNIT} and similar type/decl size/bitsize"}, {"sha": "4bdeca0d9abfeb330736c6ec70c39a19a2625180", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1074,7 +1074,7 @@ scop_to_isl_ast (scop_p scop, ivs_params &ip)\n    DEF_STMT. GSI points to entry basic block of the TO_REGION.  */\n \n static void\n-copy_def(tree tr, gimple def_stmt, sese region, sese to_region, gimple_stmt_iterator *gsi)\n+copy_def(tree tr, gimple *def_stmt, sese region, sese to_region, gimple_stmt_iterator *gsi)\n {\n   if (!defined_in_sese_p (tr, region))\n     return;\n@@ -1090,14 +1090,14 @@ copy_def(tree tr, gimple def_stmt, sese region, sese to_region, gimple_stmt_iter\n       if (region->parameter_rename_map->get(use_tr))\n \tcontinue;\n \n-      gimple def_of_use = SSA_NAME_DEF_STMT (use_tr);\n+      gimple *def_of_use = SSA_NAME_DEF_STMT (use_tr);\n       if (!def_of_use)\n \tcontinue;\n \n       copy_def (use_tr, def_of_use, region, to_region, gsi);\n     }\n \n-  gimple copy = gimple_copy (def_stmt);\n+  gimple *copy = gimple_copy (def_stmt);\n   gsi_insert_after (gsi, copy, GSI_NEW_STMT);\n \n   /* Create new names for all the definitions created by COPY and\n@@ -1127,7 +1127,7 @@ copy_internal_parameters(sese region, sese to_region)\n   FOR_EACH_VEC_ELT (region->params, i, tr)\n     {\n       // If def is not in region.\n-      gimple def_stmt = SSA_NAME_DEF_STMT (tr);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (tr);\n       if (def_stmt)\n \tcopy_def (tr, def_stmt, region, to_region, &gsi);\n     }"}, {"sha": "d43975815de4521dc918771e0e881f88ccfc6a08", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -327,8 +327,8 @@ static void\n dump_gbb_cases (FILE *file, gimple_bb_p gbb)\n {\n   int i;\n-  gimple stmt;\n-  vec<gimple> cases;\n+  gimple *stmt;\n+  vec<gimple *> cases;\n \n   if (!gbb)\n     return;\n@@ -354,8 +354,8 @@ static void\n dump_gbb_conditions (FILE *file, gimple_bb_p gbb)\n {\n   int i;\n-  gimple stmt;\n-  vec<gimple> conditions;\n+  gimple *stmt;\n+  vec<gimple *> conditions;\n \n   if (!gbb)\n     return;"}, {"sha": "7c0dc21b01bf7a25fd8872eb35415185789fd8d6", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -288,7 +288,7 @@ graphite_can_represent_expr (basic_block scop_entry, loop_p loop,\n \n static bool\n stmt_has_simple_data_refs_p (loop_p outermost_loop ATTRIBUTE_UNUSED,\n-\t\t\t     gimple stmt)\n+\t\t\t     gimple *stmt)\n {\n   data_reference_p dr;\n   int j;\n@@ -338,7 +338,7 @@ stmt_has_simple_data_refs_p (loop_p outermost_loop ATTRIBUTE_UNUSED,\n \n static bool\n stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n-\t\t\tgimple stmt, basic_block bb)\n+\t\t\tgimple *stmt, basic_block bb)\n {\n   loop_p loop = bb->loop_father;\n \n@@ -450,7 +450,7 @@ stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n    scop should end before this statement.  The evaluation is limited using\n    OUTERMOST_LOOP as outermost loop that may change.  */\n \n-static gimple\n+static gimple *\n harmful_stmt_in_bb (basic_block scop_entry, loop_p outer_loop, basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -523,7 +523,7 @@ scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n {\n   loop_p loop = bb->loop_father;\n   struct scopdet_info result;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* XXX: ENTRY_BLOCK_PTR could be optimized in later steps.  */\n   basic_block entry_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n@@ -1208,7 +1208,7 @@ same_close_phi_node (gphi *p1, gphi *p2)\n static void\n remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n {\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n   tree res = gimple_phi_result (phi);"}, {"sha": "09a2f912f08b3c2826313f96b8695ad3b1947730", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -314,7 +314,7 @@ try_generate_gimple_bb (scop_p scop, basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       loop_p loop;\n \n       if (is_gimple_debug (stmt))\n@@ -903,7 +903,7 @@ find_params_in_bb (sese region, gimple_bb_p gbb)\n   int i;\n   unsigned j;\n   data_reference_p dr;\n-  gimple stmt;\n+  gimple *stmt;\n   loop_p loop = GBB_BB (gbb)->loop_father;\n \n   /* Find parameters in the access functions of data references.  */\n@@ -1154,7 +1154,7 @@ static void\n add_conditions_to_domain (poly_bb_p pbb)\n {\n   unsigned int i;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n \n   if (GBB_CONDITIONS (gbb).is_empty ())\n@@ -1213,7 +1213,7 @@ single_pred_cond_non_loop_exit (basic_block bb)\n     {\n       edge e = single_pred_edge (bb);\n       basic_block pred = e->src;\n-      gimple stmt;\n+      gimple *stmt;\n \n       if (loop_depth (pred->loop_father) > loop_depth (bb->loop_father))\n \treturn NULL;\n@@ -1236,7 +1236,7 @@ class sese_dom_walker : public dom_walker\n   virtual void after_dom_children (basic_block);\n \n private:\n-  auto_vec<gimple, 3> m_conditions, m_cases;\n+  auto_vec<gimple *, 3> m_conditions, m_cases;\n   sese m_region;\n };\n \n@@ -1935,11 +1935,11 @@ gsi_for_phi_node (gphi *stmt)\n    GBB_DATA_REFS vector of BB.  */\n \n static void\n-analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple> stmts)\n+analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple *> stmts)\n {\n   loop_p nest;\n   gimple_bb_p gbb;\n-  gimple stmt;\n+  gimple *stmt;\n   int i;\n   sese region = SCOP_REGION (scop);\n \n@@ -1970,11 +1970,11 @@ analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple> stmts)\n    on STMTS.  */\n \n static void\n-insert_stmts (scop_p scop, gimple stmt, gimple_seq stmts,\n+insert_stmts (scop_p scop, gimple *stmt, gimple_seq stmts,\n \t      gimple_stmt_iterator insert_gsi)\n {\n   gimple_stmt_iterator gsi;\n-  auto_vec<gimple, 3> x;\n+  auto_vec<gimple *, 3> x;\n \n   gimple_seq_add_stmt (&stmts, stmt);\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -1987,13 +1987,13 @@ insert_stmts (scop_p scop, gimple stmt, gimple_seq stmts,\n /* Insert the assignment \"RES := EXPR\" just after AFTER_STMT.  */\n \n static void\n-insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple after_stmt)\n+insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple *after_stmt)\n {\n   gimple_seq stmts;\n   gimple_stmt_iterator gsi;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gassign *stmt = gimple_build_assign (unshare_expr (res), var);\n-  auto_vec<gimple, 3> x;\n+  auto_vec<gimple *, 3> x;\n \n   gimple_seq_add_stmt (&stmts, stmt);\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -2048,9 +2048,9 @@ insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts = NULL;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n-  gimple stmt = gimple_build_assign (unshare_expr (res), var);\n+  gimple *stmt = gimple_build_assign (unshare_expr (res), var);\n   basic_block bb;\n-  auto_vec<gimple, 3> x;\n+  auto_vec<gimple *, 3> x;\n \n   gimple_seq_add_stmt (&stmts, stmt);\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -2086,7 +2086,7 @@ create_zero_dim_array (tree var, const char *base_name)\n /* Returns true when PHI is a loop close phi node.  */\n \n static bool\n-scalar_close_phi_node_p (gimple phi)\n+scalar_close_phi_node_p (gimple *phi)\n {\n   if (gimple_code (phi) != GIMPLE_PHI\n       || virtual_operand_p (gimple_phi_result (phi)))\n@@ -2105,7 +2105,7 @@ static void\n propagate_expr_outside_region (tree def, tree expr, sese region)\n {\n   imm_use_iterator imm_iter;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   gimple_seq stmts;\n   bool replaced_once = false;\n \n@@ -2143,12 +2143,12 @@ static void\n rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n {\n   sese region = SCOP_REGION (scop);\n-  gimple phi = gsi_stmt (*psi);\n+  gimple *phi = gsi_stmt (*psi);\n   tree res = gimple_phi_result (phi);\n   basic_block bb = gimple_bb (phi);\n   gimple_stmt_iterator gsi = gsi_after_labels (bb);\n   tree arg = gimple_phi_arg_def (phi, 0);\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Note that loop close phi nodes should have a single argument\n      because we translated the representation into a canonical form\n@@ -2228,7 +2228,7 @@ rewrite_phi_out_of_ssa (scop_p scop, gphi_iterator *psi)\n   basic_block bb = gimple_bb (phi);\n   tree res = gimple_phi_result (phi);\n   tree zero_dim_array = create_zero_dim_array (res, \"phi_out_of_ssa\");\n-  gimple stmt;\n+  gimple *stmt;\n \n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n@@ -2258,7 +2258,7 @@ static void\n rewrite_degenerate_phi (gphi_iterator *psi)\n {\n   tree rhs;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n   gphi *phi = psi->phi ();\n   tree res = gimple_phi_result (phi);\n@@ -2318,9 +2318,9 @@ rewrite_reductions_out_of_ssa (scop_p scop)\n \n static void\n rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n-\t\t\t\t    tree def, gimple use_stmt)\n+\t\t\t\t    tree def, gimple *use_stmt)\n {\n-  gimple name_stmt;\n+  gimple *name_stmt;\n   tree name;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n@@ -2345,14 +2345,14 @@ rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n    SCOP.  */\n \n static void\n-handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple stmt)\n+handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple *stmt)\n {\n   tree var = create_tmp_reg (TREE_TYPE (def));\n   tree new_name = make_ssa_name (var, stmt);\n   bool needs_copy = false;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   sese region = SCOP_REGION (scop);\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n@@ -2373,7 +2373,7 @@ handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple stmt)\n      arrays everywhere else.  */\n   if (needs_copy)\n     {\n-      gimple assign = gimple_build_assign (new_name, def);\n+      gimple *assign = gimple_build_assign (new_name, def);\n       gimple_stmt_iterator psi = gsi_after_labels (SESE_EXIT (region)->dest);\n \n       update_stmt (assign);\n@@ -2389,12 +2389,12 @@ static bool\n rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n {\n   sese region = SCOP_REGION (scop);\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   imm_use_iterator imm_iter;\n   tree def;\n   basic_block def_bb;\n   tree zero_dim_array = NULL_TREE;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   bool res = false;\n \n   switch (gimple_code (stmt))\n@@ -2529,7 +2529,7 @@ nb_data_writes_in_bb (basic_block bb)\n    polyhedral form.  */\n \n static edge\n-split_pbb (scop_p scop, poly_bb_p pbb, basic_block bb, gimple stmt)\n+split_pbb (scop_p scop, poly_bb_p pbb, basic_block bb, gimple *stmt)\n {\n   edge e1 = split_block (bb, stmt);\n   new_pbb_from_pbb (scop, pbb, e1->dest);\n@@ -2540,7 +2540,7 @@ split_pbb (scop_p scop, poly_bb_p pbb, basic_block bb, gimple stmt)\n    statements for which we want to ignore data dependences.  */\n \n static basic_block\n-split_reduction_stmt (scop_p scop, gimple stmt)\n+split_reduction_stmt (scop_p scop, gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   poly_bb_p pbb = pbb_from_bb (bb);\n@@ -2589,7 +2589,7 @@ split_reduction_stmt (scop_p scop, gimple stmt)\n /* Return true when stmt is a reduction operation.  */\n \n static inline bool\n-is_reduction_operation_p (gimple stmt)\n+is_reduction_operation_p (gimple *stmt)\n {\n   enum tree_code code;\n \n@@ -2631,7 +2631,7 @@ phi_contains_arg (gphi *phi, tree arg)\n static gphi *\n follow_ssa_with_commutative_ops (tree arg, tree lhs)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (TREE_CODE (arg) != SSA_NAME)\n     return NULL;\n@@ -2671,9 +2671,9 @@ follow_ssa_with_commutative_ops (tree arg, tree lhs)\n    the STMT.  Return the phi node of the reduction cycle, or NULL.  */\n \n static gphi *\n-detect_commutative_reduction_arg (tree lhs, gimple stmt, tree arg,\n-\t\t\t\t  vec<gimple> *in,\n-\t\t\t\t  vec<gimple> *out)\n+detect_commutative_reduction_arg (tree lhs, gimple *stmt, tree arg,\n+\t\t\t\t  vec<gimple *> *in,\n+\t\t\t\t  vec<gimple *> *out)\n {\n   gphi *phi = follow_ssa_with_commutative_ops (arg, lhs);\n \n@@ -2689,8 +2689,8 @@ detect_commutative_reduction_arg (tree lhs, gimple stmt, tree arg,\n    STMT.  Return the phi node of the reduction cycle, or NULL.  */\n \n static gphi *\n-detect_commutative_reduction_assign (gimple stmt, vec<gimple> *in,\n-\t\t\t\t     vec<gimple> *out)\n+detect_commutative_reduction_assign (gimple *stmt, vec<gimple *> *in,\n+\t\t\t\t     vec<gimple *> *out)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n \n@@ -2718,7 +2718,7 @@ detect_commutative_reduction_assign (gimple stmt, vec<gimple> *in,\n static gphi *\n follow_inital_value_to_phi (tree arg, tree lhs)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (!arg || TREE_CODE (arg) != SSA_NAME)\n     return NULL;\n@@ -2777,7 +2777,7 @@ initial_value_for_loop_phi (gphi *phi)\n    LOOP_PHI.  */\n \n static bool\n-used_outside_reduction (tree def, gimple loop_phi)\n+used_outside_reduction (tree def, gimple *loop_phi)\n {\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n@@ -2786,7 +2786,7 @@ used_outside_reduction (tree def, gimple loop_phi)\n   /* In LOOP, DEF should be used only in LOOP_PHI.  */\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n     {\n-      gimple stmt = USE_STMT (use_p);\n+      gimple *stmt = USE_STMT (use_p);\n \n       if (stmt != loop_phi\n \t  && !is_gimple_debug (stmt)\n@@ -2802,12 +2802,12 @@ used_outside_reduction (tree def, gimple loop_phi)\n    node of the reduction cycle, or NULL.  */\n \n static gphi *\n-detect_commutative_reduction (scop_p scop, gimple stmt, vec<gimple> *in,\n-\t\t\t      vec<gimple> *out)\n+detect_commutative_reduction (scop_p scop, gimple *stmt, vec<gimple *> *in,\n+\t\t\t      vec<gimple *> *out)\n {\n   if (scalar_close_phi_node_p (stmt))\n     {\n-      gimple def;\n+      gimple *def;\n       gphi *loop_phi, *phi, *close_phi = as_a <gphi *> (stmt);\n       tree init, lhs, arg = gimple_phi_arg_def (close_phi, 0);\n \n@@ -2848,7 +2848,7 @@ detect_commutative_reduction (scop_p scop, gimple stmt, vec<gimple> *in,\n \n static void\n translate_scalar_reduction_to_array_for_stmt (scop_p scop, tree red,\n-\t\t\t\t\t      gimple stmt, gphi *loop_phi)\n+\t\t\t\t\t      gimple *stmt, gphi *loop_phi)\n {\n   tree res = gimple_phi_result (loop_phi);\n   gassign *assign = gimple_build_assign (res, unshare_expr (red));\n@@ -2872,9 +2872,9 @@ remove_phi (gphi *phi)\n   tree def;\n   use_operand_p use_p;\n   gimple_stmt_iterator gsi;\n-  auto_vec<gimple, 3> update;\n+  auto_vec<gimple *, 3> update;\n   unsigned int i;\n-  gimple stmt;\n+  gimple *stmt;\n \n   def = PHI_RESULT (phi);\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n@@ -2904,7 +2904,7 @@ dr_indices_valid_in_loop (tree ref ATTRIBUTE_UNUSED, tree *index, void *data)\n {\n   loop_p loop;\n   basic_block header, def_bb;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (TREE_CODE (*index) != SSA_NAME)\n     return true;\n@@ -2933,7 +2933,7 @@ close_phi_written_to_memory (gphi *close_phi)\n {\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-  gimple stmt;\n+  gimple *stmt;\n   tree res, def = gimple_phi_result (close_phi);\n \n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n@@ -2981,16 +2981,16 @@ close_phi_written_to_memory (gphi *close_phi)\n \n static void\n translate_scalar_reduction_to_array (scop_p scop,\n-\t\t\t\t     vec<gimple> in,\n-\t\t\t\t     vec<gimple> out)\n+\t\t\t\t     vec<gimple *> in,\n+\t\t\t\t     vec<gimple *> out)\n {\n-  gimple loop_stmt;\n+  gimple *loop_stmt;\n   unsigned int i = out.length () - 1;\n   tree red = close_phi_written_to_memory (as_a <gphi *> (out[i]));\n \n   FOR_EACH_VEC_ELT (in, i, loop_stmt)\n     {\n-      gimple close_stmt = out[i];\n+      gimple *close_stmt = out[i];\n \n       if (i == 0)\n \t{\n@@ -3033,8 +3033,8 @@ rewrite_commutative_reductions_out_of_ssa_close_phi (scop_p scop,\n \t\t\t\t\t\t     gphi *close_phi)\n {\n   bool res;\n-  auto_vec<gimple, 10> in;\n-  auto_vec<gimple, 10> out;\n+  auto_vec<gimple *, 10> in;\n+  auto_vec<gimple *, 10> out;\n \n   detect_commutative_reduction (scop, close_phi, &in, &out);\n   res = in.length () > 1;"}, {"sha": "d84e0986912db952dd00fbc4d875ff00bda1ec2d", "filename": "gcc/gsstruct.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n    Each enum value should correspond with a single member of the union\n    gimple_statement_d.  */\n \n-DEFGSSTRUCT(GSS_BASE, gimple_statement_base, false)\n+DEFGSSTRUCT(GSS_BASE, gimple, false)\n DEFGSSTRUCT(GSS_WITH_OPS, gimple_statement_with_ops, true)\n DEFGSSTRUCT(GSS_WITH_MEM_OPS_BASE, gimple_statement_with_memory_ops_base, false)\n DEFGSSTRUCT(GSS_WITH_MEM_OPS, gimple_statement_with_memory_ops, true)"}, {"sha": "71f811cbfc87b8150b26396a9d1afcad1791f094", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -264,7 +264,7 @@ get_range_pos_neg (tree arg)\n   wide_int arg_min, arg_max;\n   while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n     {\n-      gimple g = SSA_NAME_DEF_STMT (arg);\n+      gimple *g = SSA_NAME_DEF_STMT (arg);\n       if (is_gimple_assign (g)\n \t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (g)))\n \t{\n@@ -346,7 +346,7 @@ get_min_precision (tree arg, signop sign)\n   wide_int arg_min, arg_max;\n   while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n     {\n-      gimple g = SSA_NAME_DEF_STMT (arg);\n+      gimple *g = SSA_NAME_DEF_STMT (arg);\n       if (is_gimple_assign (g)\n \t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (g)))\n \t{\n@@ -1661,7 +1661,7 @@ expand_UBSAN_CHECK_MUL (gcall *stmt)\n /* Helper function for {ADD,SUB,MUL}_OVERFLOW call stmt expansion.  */\n \n static void\n-expand_arith_overflow (enum tree_code code, gimple stmt)\n+expand_arith_overflow (enum tree_code code, gimple *stmt)\n {\n   tree lhs = gimple_call_lhs (stmt);\n   if (lhs == NULL_TREE)"}, {"sha": "a7a8e8e6d22f2bf67f8ed2a0f54f66196f636719", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -3466,7 +3466,7 @@ possible_polymorphic_call_target_p (tree otr_type,\n \n bool\n possible_polymorphic_call_target_p (tree ref,\n-\t\t\t\t    gimple stmt,\n+\t\t\t\t    gimple *stmt,\n \t\t\t\t    struct cgraph_node *n)\n {\n   ipa_polymorphic_call_context context (current_function_decl, ref, stmt);"}, {"sha": "4696c803617b4ea81c6f26352553fae2b3bd2bbd", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -614,7 +614,7 @@ func_checker::parse_labels (sem_bb *bb)\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb->bb); !gsi_end_p (gsi);\n        gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t{\n@@ -637,7 +637,7 @@ bool\n func_checker::compare_bb (sem_bb *bb1, sem_bb *bb2)\n {\n   gimple_stmt_iterator gsi1, gsi2;\n-  gimple s1, s2;\n+  gimple *s1, *s2;\n \n   gsi1 = gsi_start_bb_nondebug (bb1->bb);\n   gsi2 = gsi_start_bb_nondebug (bb2->bb);\n@@ -797,7 +797,7 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n    assignment statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_assign (gimple s1, gimple s2)\n+func_checker::compare_gimple_assign (gimple *s1, gimple *s2)\n {\n   tree arg1, arg2;\n   tree_code code1, code2;\n@@ -832,7 +832,7 @@ func_checker::compare_gimple_assign (gimple s1, gimple s2)\n    condition statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_cond (gimple s1, gimple s2)\n+func_checker::compare_gimple_cond (gimple *s1, gimple *s2)\n {\n   tree t1, t2;\n   tree_code code1, code2;\n@@ -958,7 +958,7 @@ func_checker::compare_gimple_return (const greturn *g1, const greturn *g2)\n    goto statements are semantically equivalent.  */\n \n bool\n-func_checker::compare_gimple_goto (gimple g1, gimple g2)\n+func_checker::compare_gimple_goto (gimple *g1, gimple *g2)\n {\n   tree dest1, dest2;\n "}, {"sha": "2fe717e8127099e2ea4044a9a80831b308559569", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -87,7 +87,7 @@ return_with_result (bool result, const char *func, unsigned int line)\n    FUNC is name of function and LINE is location in the source file.  */\n \n static inline bool\n-return_different_stmts_1 (gimple s1, gimple s2, const char *code,\n+return_different_stmts_1 (gimple *s1, gimple *s2, const char *code,\n \t\t\t  const char *func, unsigned int line)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -165,11 +165,11 @@ class func_checker\n \n   /* Verifies for given GIMPLEs S1 and S2 that\n      assignment statements are semantically equivalent.  */\n-  bool compare_gimple_assign (gimple s1, gimple s2);\n+  bool compare_gimple_assign (gimple *s1, gimple *s2);\n \n   /* Verifies for given GIMPLEs S1 and S2 that\n      condition statements are semantically equivalent.  */\n-  bool compare_gimple_cond (gimple s1, gimple s2);\n+  bool compare_gimple_cond (gimple *s1, gimple *s2);\n \n   /* Verifies for given GIMPLE_LABEL stmts S1 and S2 that\n      label statements are semantically equivalent.  */\n@@ -185,7 +185,7 @@ class func_checker\n \n   /* Verifies for given GIMPLEs S1 and S2 that\n      goto statements are semantically equivalent.  */\n-  bool compare_gimple_goto (gimple s1, gimple s2);\n+  bool compare_gimple_goto (gimple *s1, gimple *s2);\n \n   /* Verifies for given GIMPLE_RESX stmts S1 and S2 that\n      resx statements are semantically equivalent.  */"}, {"sha": "d39a3c12203b0423d406cadec833e20fd84947d9", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1425,7 +1425,7 @@ sem_function::init (void)\n \tfor (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t     gsi_next (&gsi))\n \t  {\n-\t    gimple stmt = gsi_stmt (gsi);\n+\t    gimple *stmt = gsi_stmt (gsi);\n \n \t    if (gimple_code (stmt) != GIMPLE_DEBUG\n \t\t&& gimple_code (stmt) != GIMPLE_PREDICT)\n@@ -1615,7 +1615,7 @@ sem_item::add_type (const_tree type, inchash::hash &hstate)\n /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n \n void\n-sem_function::hash_stmt (gimple stmt, inchash::hash &hstate)\n+sem_function::hash_stmt (gimple *stmt, inchash::hash &hstate)\n {\n   enum gimple_code code = gimple_code (stmt);\n "}, {"sha": "ba374264fe90a65122f3557547cfa2af35ac8f98", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -315,7 +315,7 @@ class sem_function: public sem_item\n   }\n \n   /* Improve accumulated hash for HSTATE based on a gimple statement STMT.  */\n-  void hash_stmt (gimple stmt, inchash::hash &inchash);\n+  void hash_stmt (gimple *stmt, inchash::hash &inchash);\n \n   /* Return true if polymorphic comparison must be processed.  */\n   bool compare_polymorphic_p (void);"}, {"sha": "108ff3e689f365e389fa2e2d8999f0b07262cc0a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1524,7 +1524,7 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n    parameter.  */\n \n static tree\n-unmodified_parm_1 (gimple stmt, tree op)\n+unmodified_parm_1 (gimple *stmt, tree op)\n {\n   /* SSA_NAME referring to parm default def?  */\n   if (TREE_CODE (op) == SSA_NAME\n@@ -1550,7 +1550,7 @@ unmodified_parm_1 (gimple stmt, tree op)\n    parameter.  Also traverse chains of SSA register assignments.  */\n \n static tree\n-unmodified_parm (gimple stmt, tree op)\n+unmodified_parm (gimple *stmt, tree op)\n {\n   tree res = unmodified_parm_1 (stmt, op);\n   if (res)\n@@ -1573,7 +1573,7 @@ unmodified_parm (gimple stmt, tree op)\n \n static bool\n unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,\n-\t\t\t\t  gimple stmt, tree op, int *index_p,\n+\t\t\t\t  gimple *stmt, tree op, int *index_p,\n \t\t\t\t  struct agg_position_info *aggpos)\n {\n   tree res = unmodified_parm_1 (stmt, op);\n@@ -1615,7 +1615,7 @@ unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,\n    penalty wrappers.  */\n \n static int\n-eliminated_by_inlining_prob (gimple stmt)\n+eliminated_by_inlining_prob (gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   enum tree_code rhs_code;\n@@ -1747,14 +1747,14 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t\t   struct inline_summary *summary,\n \t\t\t\t   basic_block bb)\n {\n-  gimple last;\n+  gimple *last;\n   tree op;\n   int index;\n   struct agg_position_info aggpos;\n   enum tree_code code, inverted_code;\n   edge e;\n   edge_iterator ei;\n-  gimple set_stmt;\n+  gimple *set_stmt;\n   tree op2;\n \n   last = last_stmt (bb);\n@@ -1829,7 +1829,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t\t     struct inline_summary *summary,\n \t\t\t\t     basic_block bb)\n {\n-  gimple lastg;\n+  gimple *lastg;\n   tree op;\n   int index;\n   struct agg_position_info aggpos;\n@@ -2031,7 +2031,7 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n static struct predicate\n will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \t\t\t       struct inline_summary *summary,\n-\t\t\t       gimple stmt,\n+\t\t\t       gimple *stmt,\n \t\t\t       vec<predicate_t> nonconstant_names)\n {\n   struct predicate p = true_predicate ();\n@@ -2119,7 +2119,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n struct record_modified_bb_info\n {\n   bitmap bb_set;\n-  gimple stmt;\n+  gimple *stmt;\n };\n \n /* Callback of walk_aliased_vdefs.  Records basic blocks where the value may be\n@@ -2147,7 +2147,7 @@ record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n    ought to be REG_BR_PROB_BASE / estimated_iters.  */\n \n static int\n-param_change_prob (gimple stmt, int i)\n+param_change_prob (gimple *stmt, int i)\n {\n   tree op = gimple_call_arg (stmt, i);\n   basic_block bb = gimple_bb (stmt);\n@@ -2240,7 +2240,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n   edge e;\n   edge_iterator ei;\n   basic_block first_bb = NULL;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (single_pred_p (bb))\n     {\n@@ -2355,14 +2355,14 @@ array_index_predicate (inline_summary *info,\n    an impact on the earlier inlining.\n    Here find this pattern and fix it up later.  */\n \n-static gimple\n+static gimple *\n find_foldable_builtin_expect (basic_block bb)\n {\n   gimple_stmt_iterator bsi;\n \n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n       if (gimple_call_builtin_p (stmt, BUILT_IN_EXPECT)\n \t  || (is_gimple_call (stmt)\n \t      && gimple_call_internal_p (stmt)\n@@ -2371,7 +2371,7 @@ find_foldable_builtin_expect (basic_block bb)\n           tree var = gimple_call_lhs (stmt);\n           tree arg = gimple_call_arg (stmt, 0);\n           use_operand_p use_p;\n-          gimple use_stmt;\n+\t  gimple *use_stmt;\n           bool match = false;\n           bool done = false;\n \n@@ -2381,7 +2381,7 @@ find_foldable_builtin_expect (basic_block bb)\n \n           while (TREE_CODE (arg) == SSA_NAME)\n             {\n-              gimple stmt_tmp = SSA_NAME_DEF_STMT (arg);\n+\t      gimple *stmt_tmp = SSA_NAME_DEF_STMT (arg);\n               if (!is_gimple_assign (stmt_tmp))\n                 break;\n               switch (gimple_assign_rhs_code (stmt_tmp))\n@@ -2443,7 +2443,7 @@ clobber_only_eh_bb_p (basic_block bb, bool need_eh = true)\n \n   for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (is_gimple_debug (stmt))\n \tcontinue;\n       if (gimple_clobber_p (stmt))\n@@ -2484,7 +2484,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   int nblocks, n;\n   int *order;\n   predicate array_index = true_predicate ();\n-  gimple fix_builtin_expect_stmt;\n+  gimple *fix_builtin_expect_stmt;\n \n   gcc_assert (my_function && my_function->cfg);\n   gcc_assert (cfun == my_function);\n@@ -2597,7 +2597,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n \t   gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n \t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n \t  int prob;\n@@ -2795,7 +2795,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n \t\t{\n-\t\t  gimple stmt = gsi_stmt (gsi);\n+\t\t  gimple *stmt = gsi_stmt (gsi);\n \t\t  affine_iv iv;\n \t\t  ssa_op_iter iter;\n \t\t  tree use;"}, {"sha": "8f3919c086fc5cbce0425470b72cfa872fb94b12", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1943,13 +1943,13 @@ inline_small_functions (void)\n \t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n \t\t   edge->caller->name (), edge->caller->order,\n \t\t   edge->call_stmt\n-\t\t   && (LOCATION_LOCUS (gimple_location ((const_gimple)\n+\t\t   && (LOCATION_LOCUS (gimple_location ((const gimple *)\n \t\t\t\t\t\t\tedge->call_stmt))\n \t\t       > BUILTINS_LOCATION)\n-\t\t   ? gimple_filename ((const_gimple) edge->call_stmt)\n+\t\t   ? gimple_filename ((const gimple *) edge->call_stmt)\n \t\t   : \"unknown\",\n \t\t   edge->call_stmt\n-\t\t   ? gimple_lineno ((const_gimple) edge->call_stmt)\n+\t\t   ? gimple_lineno ((const gimple *) edge->call_stmt)\n \t\t   : -1,\n \t\t   badness.to_double (),\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);"}, {"sha": "99770dedf11ead24ba918b13c1823be2cc9ce81b", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -540,7 +540,7 @@ inlined_polymorphic_ctor_dtor_block_p (tree block, bool check_clones)\n \n bool\n decl_maybe_in_construction_p (tree base, tree outer_type,\n-\t\t\t      gimple call, tree function)\n+\t\t\t      gimple *call, tree function)\n {\n   if (outer_type)\n     outer_type = TYPE_MAIN_VARIANT (outer_type);\n@@ -827,7 +827,7 @@ walk_ssa_copies (tree op, hash_set<tree> **global_visited = NULL)\n \t undefined anyway.  */\n       if (gimple_code (SSA_NAME_DEF_STMT (op)) == GIMPLE_PHI)\n \t{\n-\t  gimple phi = SSA_NAME_DEF_STMT (op);\n+\t  gimple *phi = SSA_NAME_DEF_STMT (op);\n \n \t  if (gimple_phi_num_args (phi) > 2)\n \t    goto done;\n@@ -873,7 +873,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree cst,\n \n ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t\t\t\t\t\t\t    tree ref,\n-\t\t\t\t\t\t\t    gimple stmt,\n+\t\t\t\t\t\t\t    gimple *stmt,\n \t\t\t\t\t\t\t    tree *instance)\n {\n   tree otr_type = NULL;\n@@ -1119,7 +1119,7 @@ struct type_change_info\n    and destructor functions.  */\n \n static bool\n-noncall_stmt_may_be_vtbl_ptr_store (gimple stmt)\n+noncall_stmt_may_be_vtbl_ptr_store (gimple *stmt)\n {\n   if (is_gimple_assign (stmt))\n     {\n@@ -1165,7 +1165,7 @@ noncall_stmt_may_be_vtbl_ptr_store (gimple stmt)\n    in unknown way or ERROR_MARK_NODE if type is unchanged.  */\n \n static tree\n-extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n+extr_type_from_vtbl_ptr_store (gimple *stmt, struct type_change_info *tci,\n \t\t\t       HOST_WIDE_INT *type_offset)\n {\n   HOST_WIDE_INT offset, size, max_size;\n@@ -1355,7 +1355,7 @@ record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset\n static bool\n check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (vdef);\n+  gimple *stmt = SSA_NAME_DEF_STMT (vdef);\n   struct type_change_info *tci = (struct type_change_info *) data;\n   tree fn;\n \n@@ -1486,13 +1486,13 @@ bool\n ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t\t\t\t\t\ttree otr_object,\n \t\t\t\t\t\ttree otr_type,\n-\t\t\t\t\t\tgimple call)\n+\t\t\t\t\t\tgimple *call)\n {\n   struct type_change_info tci;\n   ao_ref ao;\n   bool function_entry_reached = false;\n   tree instance_ref = NULL;\n-  gimple stmt = call;\n+  gimple *stmt = call;\n   /* Remember OFFSET before it is modified by restrict_to_inner_class.\n      This is because we do not update INSTANCE when walking inwards.  */\n   HOST_WIDE_INT instance_offset = offset;"}, {"sha": "655ba16bd9b8667130d4a1238b0e28f2b9395a87", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -191,7 +191,7 @@ ipa_profile_generate_summary (void)\n \tint size = 0;\n         for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t  {\n-\t    gimple stmt = gsi_stmt (gsi);\n+\t    gimple *stmt = gsi_stmt (gsi);\n \t    if (gimple_code (stmt) == GIMPLE_CALL\n \t\t&& !gimple_call_fndecl (stmt))\n \t      {"}, {"sha": "8dd947931308b42ce3c9e3fb10f7a75766e72c9e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -538,7 +538,7 @@ struct prop_type_change_info\n   */\n \n static bool\n-stmt_may_be_vtbl_ptr_store (gimple stmt)\n+stmt_may_be_vtbl_ptr_store (gimple *stmt)\n {\n   if (is_gimple_call (stmt))\n     return false;\n@@ -573,7 +573,7 @@ stmt_may_be_vtbl_ptr_store (gimple stmt)\n static bool\n check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (vdef);\n+  gimple *stmt = SSA_NAME_DEF_STMT (vdef);\n   struct prop_type_change_info *tci = (struct prop_type_change_info *) data;\n \n   if (stmt_may_be_vtbl_ptr_store (stmt))\n@@ -595,7 +595,7 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n    type of the THIS pointer.  */\n \n static bool\n-param_type_may_change_p (tree function, tree arg, gimple call)\n+param_type_may_change_p (tree function, tree arg, gimple *call)\n {\n   /* Pure functions can not do any changes on the dynamic type;\n      that require writting to memory.  */\n@@ -815,7 +815,7 @@ parm_bb_aa_status_for_bb (struct ipa_func_body_info *fbi, basic_block bb,\n \n static bool\n parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,\n-\t\t\t      gimple stmt, tree parm_load)\n+\t\t\t      gimple *stmt, tree parm_load)\n {\n   struct ipa_param_aa_status *paa;\n   bool modified = false;\n@@ -855,7 +855,7 @@ parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,\n static int\n load_from_unmodified_param (struct ipa_func_body_info *fbi,\n \t\t\t    vec<ipa_param_descriptor> descriptors,\n-\t\t\t    gimple stmt)\n+\t\t\t    gimple *stmt)\n {\n   int index;\n   tree op1;\n@@ -881,7 +881,7 @@ load_from_unmodified_param (struct ipa_func_body_info *fbi,\n \n static bool\n parm_ref_data_preserved_p (struct ipa_func_body_info *fbi,\n-\t\t\t   int index, gimple stmt, tree ref)\n+\t\t\t   int index, gimple *stmt, tree ref)\n {\n   struct ipa_param_aa_status *paa;\n   bool modified = false;\n@@ -920,7 +920,7 @@ parm_ref_data_preserved_p (struct ipa_func_body_info *fbi,\n \n static bool\n parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n-\t\t\t      gimple call, tree parm)\n+\t\t\t      gimple *call, tree parm)\n {\n   bool modified = false;\n   ao_ref refd;\n@@ -961,7 +961,7 @@ parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n bool\n ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \t\t\tvec<ipa_param_descriptor> descriptors,\n-\t\t\tgimple stmt, tree op, int *index_p,\n+\t\t\tgimple *stmt, tree op, int *index_p,\n \t\t\tHOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n \t\t\tbool *by_ref_p)\n {\n@@ -1014,7 +1014,7 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \t gdp = &p;\n       */\n \n-      gimple def = SSA_NAME_DEF_STMT (TREE_OPERAND (base, 0));\n+      gimple *def = SSA_NAME_DEF_STMT (TREE_OPERAND (base, 0));\n       index = load_from_unmodified_param (fbi, descriptors, def);\n     }\n \n@@ -1087,7 +1087,7 @@ static void\n compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n \t\t\t\t  struct ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n-\t\t\t\t  gcall *call, gimple stmt, tree name,\n+\t\t\t\t  gcall *call, gimple *stmt, tree name,\n \t\t\t\t  tree param_type)\n {\n   HOST_WIDE_INT offset, size, max_size;\n@@ -1171,7 +1171,7 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n    RHS stripped off the ADDR_EXPR is stored into *OBJ_P.  */\n \n static tree\n-get_ancestor_addr_info (gimple assign, tree *obj_p, HOST_WIDE_INT *offset)\n+get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n {\n   HOST_WIDE_INT size, max_size;\n   tree expr, parm, obj;\n@@ -1232,7 +1232,7 @@ compute_complex_ancestor_jump_func (struct ipa_func_body_info *fbi,\n \t\t\t\t    gcall *call, gphi *phi)\n {\n   HOST_WIDE_INT offset;\n-  gimple assign, cond;\n+  gimple *assign, *cond;\n   basic_block phi_bb, assign_bb, cond_bb;\n   tree tmp, parm, expr, obj;\n   int index, i;\n@@ -1329,7 +1329,7 @@ get_ssa_def_if_simple_copy (tree rhs)\n {\n   while (TREE_CODE (rhs) == SSA_NAME && !SSA_NAME_IS_DEFAULT_DEF (rhs))\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (rhs);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n \n       if (gimple_assign_single_p (def_stmt))\n \trhs = gimple_assign_rhs1 (def_stmt);\n@@ -1496,7 +1496,7 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n   for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n       struct ipa_known_agg_contents_list *n, **p;\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       HOST_WIDE_INT lhs_offset, lhs_size, lhs_max_size;\n       tree lhs, rhs, lhs_base;\n \n@@ -1695,7 +1695,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t    }\n \t  else\n \t    {\n-\t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n+\t      gimple *stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (is_gimple_assign (stmt))\n \t\tcompute_complex_assign_jump_func (fbi, info, jfunc,\n \t\t\t\t\t\t  call, stmt, arg, param_type);\n@@ -1760,7 +1760,7 @@ ipa_compute_jump_functions_for_bb (struct ipa_func_body_info *fbi, basic_block b\n    field rather than the pfn.  */\n \n static tree\n-ipa_get_stmt_member_ptr_load_param (gimple stmt, bool use_delta,\n+ipa_get_stmt_member_ptr_load_param (gimple *stmt, bool use_delta,\n \t\t\t\t    HOST_WIDE_INT *offset_p)\n {\n   tree rhs, rec, ref_field, ref_offset, fld, ptr_field, delta_field;\n@@ -1911,7 +1911,7 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n     }\n \n   int index;\n-  gimple def = SSA_NAME_DEF_STMT (target);\n+  gimple *def = SSA_NAME_DEF_STMT (target);\n   if (gimple_assign_single_p (def)\n       && ipa_load_from_parm_agg (fbi, info->descriptors, def,\n \t\t\t\t gimple_assign_rhs1 (def), &index, &offset,\n@@ -1938,8 +1938,8 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n   tree n2 = PHI_ARG_DEF (def, 1);\n   if (!ipa_is_ssa_with_stmt_def (n1) || !ipa_is_ssa_with_stmt_def (n2))\n     return;\n-  gimple d1 = SSA_NAME_DEF_STMT (n1);\n-  gimple d2 = SSA_NAME_DEF_STMT (n2);\n+  gimple *d1 = SSA_NAME_DEF_STMT (n1);\n+  gimple *d2 = SSA_NAME_DEF_STMT (n2);\n \n   tree rec;\n   basic_block bb, virt_bb;\n@@ -1971,7 +1971,7 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n   /* Third, let's see that the branching is done depending on the least\n      significant bit of the pfn. */\n \n-  gimple branch = last_stmt (bb);\n+  gimple *branch = last_stmt (bb);\n   if (!branch || gimple_code (branch) != GIMPLE_COND)\n     return;\n \n@@ -2062,7 +2062,7 @@ ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,\n   else\n     {\n       struct ipa_jump_func jfunc;\n-      gimple stmt = SSA_NAME_DEF_STMT (obj);\n+      gimple *stmt = SSA_NAME_DEF_STMT (obj);\n       tree expr;\n \n       expr = get_ancestor_addr_info (stmt, &obj, &anc_offset);\n@@ -2135,7 +2135,7 @@ ipa_analyze_call_uses (struct ipa_func_body_info *fbi, gcall *call)\n    formal parameters are called.  */\n \n static void\n-ipa_analyze_stmt_uses (struct ipa_func_body_info *fbi, gimple stmt)\n+ipa_analyze_stmt_uses (struct ipa_func_body_info *fbi, gimple *stmt)\n {\n   if (is_gimple_call (stmt))\n     ipa_analyze_call_uses (fbi, as_a <gcall *> (stmt));\n@@ -2146,7 +2146,7 @@ ipa_analyze_stmt_uses (struct ipa_func_body_info *fbi, gimple stmt)\n    passed in DATA.  */\n \n static bool\n-visit_ref_for_mod_analysis (gimple, tree op, tree, void *data)\n+visit_ref_for_mod_analysis (gimple *, tree op, tree, void *data)\n {\n   struct ipa_node_params *info = (struct ipa_node_params *) data;\n \n@@ -2173,7 +2173,7 @@ ipa_analyze_params_uses_in_bb (struct ipa_func_body_info *fbi, basic_block bb)\n   gimple_stmt_iterator gsi;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       if (is_gimple_debug (stmt))\n \tcontinue;\n@@ -3986,7 +3986,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t         a load into a temporary.  */\n \t      if (is_gimple_reg_type (TREE_TYPE (expr)))\n \t\t{\n-\t\t  gimple tem = gimple_build_assign (NULL_TREE, expr);\n+\t\t  gimple *tem = gimple_build_assign (NULL_TREE, expr);\n \t\t  if (gimple_in_ssa_p (cfun))\n \t\t    {\n \t\t      gimple_set_vuse (tem, gimple_vuse (stmt));\n@@ -4011,7 +4011,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t{\n \t  unsigned int ix;\n \t  tree ddecl = NULL_TREE, origin = DECL_ORIGIN (adj->base), arg;\n-\t  gimple def_temp;\n+\t  gimple *def_temp;\n \n \t  arg = gimple_call_arg (stmt, adj->base_index);\n \t  if (!useless_type_conversion_p (TREE_TYPE (origin), TREE_TYPE (arg)))\n@@ -5104,7 +5104,7 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       struct ipa_agg_replacement_value *v;\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       tree rhs, val, t;\n       HOST_WIDE_INT offset, size;\n       int index;"}, {"sha": "b9868bbbd5b184c750ad346b9fc9ea9e579ca6b5", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -637,7 +637,7 @@ void ipa_analyze_node (struct cgraph_node *);\n tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *, HOST_WIDE_INT,\n \t\t\t\t bool);\n bool ipa_load_from_parm_agg (struct ipa_func_body_info *,\n-\t\t\t     vec<ipa_param_descriptor>, gimple, tree, int *,\n+\t\t\t     vec<ipa_param_descriptor>, gimple *, tree, int *,\n \t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *, bool *);\n \n /* Debugging interface.  */"}, {"sha": "bc4490c2788176e30c0ac257920496f818627d8a", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -634,7 +634,7 @@ check_call (funct_state local, gcall *call, bool ipa)\n /* Wrapper around check_decl for loads in local more.  */\n \n static bool\n-check_load (gimple, tree op, tree, void *data)\n+check_load (gimple *, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, false, false);\n@@ -646,7 +646,7 @@ check_load (gimple, tree op, tree, void *data)\n /* Wrapper around check_decl for stores in local more.  */\n \n static bool\n-check_store (gimple, tree op, tree, void *data)\n+check_store (gimple *, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, true, false);\n@@ -658,7 +658,7 @@ check_store (gimple, tree op, tree, void *data)\n /* Wrapper around check_decl for loads in ipa mode.  */\n \n static bool\n-check_ipa_load (gimple, tree op, tree, void *data)\n+check_ipa_load (gimple *, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, false, true);\n@@ -670,7 +670,7 @@ check_ipa_load (gimple, tree op, tree, void *data)\n /* Wrapper around check_decl for stores in ipa mode.  */\n \n static bool\n-check_ipa_store (gimple, tree op, tree, void *data)\n+check_ipa_store (gimple *, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, true, true);\n@@ -684,7 +684,7 @@ check_ipa_store (gimple, tree op, tree, void *data)\n static void\n check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n {\n-  gimple stmt = gsi_stmt (*gsip);\n+  gimple *stmt = gsi_stmt (*gsip);\n \n   if (is_gimple_debug (stmt))\n     return;"}, {"sha": "abf64718fa7b23eeb4fa4266b518b5714ebca505", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -58,7 +58,7 @@ struct GTY(()) ipa_ref\n \n   symtab_node *referring;\n   symtab_node *referred;\n-  gimple stmt;\n+  gimple *stmt;\n   unsigned int lto_stmt_uid;\n   unsigned int referred_index;\n   ENUM_BITFIELD (ipa_ref_use) use:3;"}, {"sha": "ff47ea3ee27112946cedf93fa2c0b11dbae9ae83", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -166,7 +166,7 @@ static tree find_retbnd (basic_block return_bb);\n    variable, check it if it is present in bitmap passed via DATA.  */\n \n static bool\n-test_nonssa_use (gimple, tree t, tree, void *data)\n+test_nonssa_use (gimple *, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n \n@@ -251,7 +251,7 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n       for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n \t   gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  if (is_gimple_debug (stmt))\n \t    continue;\n \t  if (walk_stmt_load_store_addr_ops\n@@ -341,7 +341,7 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n    to optimize away an unused function call.  */\n \n static void\n-check_forbidden_calls (gimple stmt)\n+check_forbidden_calls (gimple *stmt)\n {\n   imm_use_iterator use_iter;\n   use_operand_p use_p;\n@@ -770,7 +770,7 @@ find_return_bb (void)\n   e = single_pred_edge (EXIT_BLOCK_PTR_FOR_FN (cfun));\n   for (bsi = gsi_last_bb (e->src); !gsi_end_p (bsi); gsi_prev (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n       if (gimple_code (stmt) == GIMPLE_LABEL\n \t  || is_gimple_debug (stmt)\n \t  || gimple_clobber_p (stmt))\n@@ -836,7 +836,7 @@ find_retbnd (basic_block return_bb)\n    Return true when access to T prevents splitting the function.  */\n \n static bool\n-mark_nonssa_use (gimple, tree t, tree, void *data)\n+mark_nonssa_use (gimple *, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n \n@@ -896,7 +896,7 @@ visit_bb (basic_block bb, basic_block return_bb,\n   for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n        gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n       tree op;\n       ssa_op_iter iter;\n       tree decl;\n@@ -1221,7 +1221,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n   tree retval = NULL, real_retval = NULL, retbnd = NULL;\n   bool split_part_return_p = false;\n   bool with_bounds = chkp_function_instrumented_p (current_function_decl);\n-  gimple last_stmt = NULL;\n+  gimple *last_stmt = NULL;\n   unsigned int i;\n   tree arg, ddef;\n   vec<tree, va_gc> **debug_args = NULL;\n@@ -1344,7 +1344,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n \t     !gsi_end_p (gsi);\n \t     gsi_next (&gsi))\n \t  {\n-\t    gimple stmt = gsi_stmt (gsi);\n+\t    gimple *stmt = gsi_stmt (gsi);\n \t    if (gimple_vuse (stmt))\n \t      {\n \t\tgimple_set_vuse (stmt, NULL_TREE);\n@@ -1431,7 +1431,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n \t  && is_gimple_reg (parm))\n \t{\n \t  tree ddecl;\n-\t  gimple def_temp;\n+\t  gimple *def_temp;\n \n \t  /* This needs to be done even without MAY_HAVE_DEBUG_STMTS,\n \t     otherwise if it didn't exist before, we'd end up with\n@@ -1465,7 +1465,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n       unsigned int i;\n       tree var, vexpr;\n       gimple_stmt_iterator cgsi;\n-      gimple def_temp;\n+      gimple *def_temp;\n \n       push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n       var = BLOCK_VARS (DECL_INITIAL (node->decl));\n@@ -1602,7 +1602,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n \t\t  gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n \t\t  if (!useless_type_conversion_p (TREE_TYPE (retval), restype))\n \t\t    {\n-\t\t      gimple cpy;\n+\t\t      gimple *cpy;\n \t\t      tree tem = create_tmp_reg (restype);\n \t\t      tem = make_ssa_name (tem, call);\n \t\t      cpy = gimple_build_assign (retval, NOP_EXPR, tem);\n@@ -1786,7 +1786,7 @@ execute_split_functions (void)\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n \t  int this_time, this_size;\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \n \t  this_size = estimate_num_insns (stmt, &eni_size_weights);\n \t  this_time = estimate_num_insns (stmt, &eni_time_weights) * freq;"}, {"sha": "1604641e1b5f1bc07d0590c12b04c79741a4ca6d", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -66,14 +66,14 @@ odr_type get_odr_type (tree, bool insert = false);\n bool type_in_anonymous_namespace_p (const_tree);\n bool type_with_linkage_p (const_tree);\n bool odr_type_p (const_tree);\n-bool possible_polymorphic_call_target_p (tree ref, gimple stmt, struct cgraph_node *n);\n+bool possible_polymorphic_call_target_p (tree ref, gimple *stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t     const ipa_polymorphic_call_context &);\n bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n \t\t\t\t         const ipa_polymorphic_call_context &,\n \t\t\t\t\t struct cgraph_node *);\n tree inlined_polymorphic_ctor_dtor_block_p (tree, bool);\n-bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n+bool decl_maybe_in_construction_p (tree, tree, gimple *, tree);\n tree vtable_pointer_value_to_binfo (const_tree);\n bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n tree subbinfo_with_vtable_at_offset (tree, unsigned HOST_WIDE_INT, tree);\n@@ -120,7 +120,7 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n \n inline vec <cgraph_node *>\n possible_polymorphic_call_targets (tree ref,\n-\t\t\t\t   gimple call,\n+\t\t\t\t   gimple *call,\n \t\t\t\t   bool *completep = NULL,\n \t\t\t\t   void **cache_token = NULL)\n {"}, {"sha": "e453b12037c3f5a2df2383398a7340e7d804a508", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -912,7 +912,7 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n    so they point to STMTS.  */\n \n static void\n-fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n+fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple **stmts,\n \t\t\t struct function *fn)\n {\n   struct cgraph_edge *cedge;\n@@ -954,7 +954,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n /* Fixup call_stmt pointers in NODE and all clones.  */\n \n static void\n-fixup_call_stmt_edges (struct cgraph_node *orig, gimple *stmts)\n+fixup_call_stmt_edges (struct cgraph_node *orig, gimple **stmts)\n {\n   struct cgraph_node *node;\n   struct function *fn;\n@@ -1047,7 +1047,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n {\n   struct function *fn;\n   enum LTO_tags tag;\n-  gimple *stmts;\n+  gimple **stmts;\n   basic_block bb;\n   struct cgraph_node *node;\n \n@@ -1104,29 +1104,29 @@ input_function (tree fn_decl, struct data_in *data_in,\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t}\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t}\n     }\n-  stmts = (gimple *) xcalloc (gimple_stmt_max_uid (fn), sizeof (gimple));\n+  stmts = (gimple **) xcalloc (gimple_stmt_max_uid (fn), sizeof (gimple *));\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n       gimple_stmt_iterator bsi = gsi_start_phis (bb);\n       while (!gsi_end_p (bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  gsi_next (&bsi);\n \t  stmts[gimple_uid (stmt)] = stmt;\n \t}\n       bsi = gsi_start_bb (bb);\n       while (!gsi_end_p (bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  /* If we're recompiling LTO objects with debug stmts but\n \t     we're not supposed to have debug stmts, remove them now.\n \t     We can't remove them earlier because this would cause uid"}, {"sha": "11daf7a9d7f6256dcea51d7a0c436fb8059cd32b", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -2077,7 +2077,7 @@ output_function (struct cgraph_node *node)\n \t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \t      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t    }\n \t}"}, {"sha": "7c92c94c9a45d93f48b9ca68f62c7cd246177e0a", "filename": "gcc/omp-low.c", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -152,7 +152,7 @@ struct omp_context\n \n   /* The tree of contexts corresponding to the encountered constructs.  */\n   struct omp_context *outer;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Map variables to fields in a structure that allows communication\n      between sending and receiving threads.  */\n@@ -734,7 +734,7 @@ static bool\n workshare_safe_to_combine_p (basic_block ws_entry_bb)\n {\n   struct omp_for_data fd;\n-  gimple ws_stmt = last_stmt (ws_entry_bb);\n+  gimple *ws_stmt = last_stmt (ws_entry_bb);\n \n   if (gimple_code (ws_stmt) == GIMPLE_OMP_SECTIONS)\n     return true;\n@@ -768,7 +768,7 @@ workshare_safe_to_combine_p (basic_block ws_entry_bb)\n    expanded.  */\n \n static vec<tree, va_gc> *\n-get_ws_args_for (gimple par_stmt, gimple ws_stmt)\n+get_ws_args_for (gimple *par_stmt, gimple *ws_stmt)\n {\n   tree t;\n   location_t loc = gimple_location (ws_stmt);\n@@ -864,8 +864,8 @@ determine_parallel_type (struct omp_region *region)\n \t  || (last_and_only_stmt (ws_entry_bb)\n \t      && last_and_only_stmt (par_exit_bb))))\n     {\n-      gimple par_stmt = last_stmt (par_entry_bb);\n-      gimple ws_stmt = last_stmt (ws_entry_bb);\n+      gimple *par_stmt = last_stmt (par_entry_bb);\n+      gimple *ws_stmt = last_stmt (ws_entry_bb);\n \n       if (region->inner->type == GIMPLE_OMP_FOR)\n \t{\n@@ -1469,7 +1469,7 @@ free_omp_regions (void)\n /* Create a new context, with OUTER_CTX being the surrounding context.  */\n \n static omp_context *\n-new_omp_context (gimple stmt, omp_context *outer_ctx)\n+new_omp_context (gimple *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx = XCNEW (omp_context);\n \n@@ -2238,7 +2238,7 @@ find_combined_for (gimple_stmt_iterator *gsi_p,\n \t\t   bool *handled_ops_p,\n \t\t   struct walk_stmt_info *wi)\n {\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n \n   *handled_ops_p = true;\n   switch (gimple_code (stmt))\n@@ -2289,7 +2289,7 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \t\t       find_combined_for, NULL, &wi);\n       if (wi.info)\n \t{\n-\t  gomp_for *for_stmt = as_a <gomp_for *> ((gimple) wi.info);\n+\t  gomp_for *for_stmt = as_a <gomp_for *> ((gimple *) wi.info);\n \t  struct omp_for_data fd;\n \t  extract_omp_for_data (for_stmt, &fd, NULL);\n \t  /* We need two temporaries with fd.loop.v type (istart/iend)\n@@ -2500,7 +2500,7 @@ enclosing_target_ctx (omp_context *ctx)\n }\n \n static bool\n-oacc_loop_or_target_p (gimple stmt)\n+oacc_loop_or_target_p (gimple *stmt)\n {\n   enum gimple_code outer_type = gimple_code (stmt);\n   return ((outer_type == GIMPLE_OMP_TARGET\n@@ -2708,7 +2708,7 @@ scan_omp_teams (gomp_teams *stmt, omp_context *outer_ctx)\n \n /* Check nesting restrictions.  */\n static bool\n-check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n+check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n {\n   /* No nesting of non-OpenACC STMT (that is, an OpenMP one, or a GOMP builtin)\n      inside an OpenACC CTX.  */\n@@ -3134,7 +3134,7 @@ static tree\n scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t struct walk_stmt_info *wi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   omp_context *ctx = (omp_context *) wi->info;\n \n   if (gimple_has_location (stmt))\n@@ -3270,7 +3270,7 @@ scan_omp (gimple_seq *body_p, omp_context *ctx)\n \n /* Build a call to GOMP_barrier.  */\n \n-static gimple\n+static gimple *\n build_omp_barrier (tree lhs)\n {\n   tree fndecl = builtin_decl_explicit (lhs ? BUILT_IN_GOMP_BARRIER_CANCEL\n@@ -3284,7 +3284,7 @@ build_omp_barrier (tree lhs)\n /* If a context was created for STMT when it was scanned, return it.  */\n \n static omp_context *\n-maybe_lookup_ctx (gimple stmt)\n+maybe_lookup_ctx (gimple *stmt)\n {\n   splay_tree_node n;\n   n = splay_tree_lookup (all_contexts, (splay_tree_key) stmt);\n@@ -4054,7 +4054,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t\t{\n \t\t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n-\t\t  gimple tseq;\n+\t\t  gimple *tseq;\n \t\t  x = build_outer_var_ref (var, ctx);\n \n \t\t  if (is_reference (var)\n@@ -4212,7 +4212,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       /* Don't want uninit warnings on simduid, it is always uninitialized,\n \t but we use it not for the value, but for the DECL_UID only.  */\n       TREE_NO_WARNING (uid) = 1;\n-      gimple g\n+      gimple *g\n \t= gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 1, uid);\n       gimple_call_set_lhs (g, lane);\n       gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n@@ -4457,7 +4457,7 @@ oacc_lower_reduction_var_helper (gimple_seq *stmt_seqp, omp_context *ctx,\n \n   tree t = NULL_TREE, array, x;\n   tree type = get_base_type (var);\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Now insert the partial reductions into the array.  */\n \n@@ -4503,7 +4503,7 @@ static void\n lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n {\n   gimple_seq sub_seq = NULL;\n-  gimple stmt;\n+  gimple *stmt;\n   tree x, c, tid = NULL_TREE;\n   int count = 0;\n \n@@ -4535,7 +4535,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n       /* Get the current thread id.  */\n       tree call = builtin_decl_explicit (BUILT_IN_GOACC_GET_THREAD_NUM);\n       tid = create_tmp_var (TREE_TYPE (TREE_TYPE (call)));\n-      gimple stmt = gimple_build_call (call, 0);\n+      gimple *stmt = gimple_build_call (call, 0);\n       gimple_call_set_lhs (stmt, tid);\n       gimple_seq_add_stmt (stmt_seqp, stmt);\n     }\n@@ -4837,7 +4837,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n {\n   tree t, t1, t2, val, cond, c, clauses, flags;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   enum built_in_function start_ix;\n   int start_ix2;\n   location_t clause_loc;\n@@ -5100,7 +5100,7 @@ expand_task_call (basic_block bb, gomp_task *entry_stmt)\n static gimple_seq\n maybe_catch_exception (gimple_seq body)\n {\n-  gimple g;\n+  gimple *g;\n   tree decl;\n \n   if (!flag_exceptions)\n@@ -5149,7 +5149,7 @@ remove_exit_barrier (struct omp_region *region)\n   basic_block exit_bb;\n   edge_iterator ei;\n   edge e;\n-  gimple stmt;\n+  gimple *stmt;\n   int any_addressable_vars = -1;\n \n   exit_bb = region->exit;\n@@ -5253,7 +5253,7 @@ remove_exit_barriers (struct omp_region *region)\n    scheduling point.  */\n \n static void\n-optimize_omp_library_calls (gimple entry_stmt)\n+optimize_omp_library_calls (gimple *entry_stmt)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n@@ -5268,7 +5268,7 @@ optimize_omp_library_calls (gimple entry_stmt)\n   FOR_EACH_BB_FN (bb, cfun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tgimple call = gsi_stmt (gsi);\n+\tgimple *call = gsi_stmt (gsi);\n \ttree decl;\n \n \tif (is_gimple_call (call)\n@@ -5336,7 +5336,7 @@ expand_omp_build_assign (gimple_stmt_iterator *gsi_p, tree to, tree from)\n   bool simple_p = DECL_P (to) && TREE_ADDRESSABLE (to);\n   from = force_gimple_operand_gsi (gsi_p, from, simple_p, NULL_TREE,\n \t\t\t\t   true, GSI_SAME_STMT);\n-  gimple stmt = gimple_build_assign (to, from);\n+  gimple *stmt = gimple_build_assign (to, from);\n   gsi_insert_before (gsi_p, stmt, GSI_SAME_STMT);\n   if (walk_tree (&from, expand_omp_regimplify_p, NULL, NULL)\n       || walk_tree (&to, expand_omp_regimplify_p, NULL, NULL))\n@@ -5355,7 +5355,7 @@ expand_omp_taskreg (struct omp_region *region)\n   struct function *child_cfun;\n   tree child_fn, block, t;\n   gimple_stmt_iterator gsi;\n-  gimple entry_stmt, stmt;\n+  gimple *entry_stmt, *stmt;\n   edge e;\n   vec<tree, va_gc> *ws_args;\n \n@@ -5430,11 +5430,11 @@ expand_omp_taskreg (struct omp_region *region)\n \t    = single_succ_p (entry_bb) ? single_succ (entry_bb)\n \t\t\t\t       : FALLTHRU_EDGE (entry_bb)->dest;\n \t  tree arg;\n-\t  gimple parcopy_stmt = NULL;\n+\t  gimple *parcopy_stmt = NULL;\n \n \t  for (gsi = gsi_start_bb (entry_succ_bb); ; gsi_next (&gsi))\n \t    {\n-\t      gimple stmt;\n+\t      gimple *stmt;\n \n \t      gcc_assert (!gsi_end_p (gsi));\n \t      stmt = gsi_stmt (gsi);\n@@ -5836,7 +5836,7 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \n static void\n expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n-\t\t\t  tree *counts, gimple inner_stmt, tree startvar)\n+\t\t\t  tree *counts, gimple *inner_stmt, tree startvar)\n {\n   int i;\n   if (gimple_omp_for_combined_p (fd->for_stmt))\n@@ -5935,7 +5935,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n   gimple_stmt_iterator gsi;\n   edge e;\n   tree t;\n-  gimple stmt;\n+  gimple *stmt;\n \n   last_bb = cont_bb;\n   for (i = fd->collapse - 1; i >= 0; i--)\n@@ -6097,7 +6097,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\tstruct omp_for_data *fd,\n \t\t\tenum built_in_function start_fn,\n \t\t\tenum built_in_function next_fn,\n-\t\t\tgimple inner_stmt)\n+\t\t\tgimple *inner_stmt)\n {\n   tree type, istart0, iend0, iend;\n   tree t, vmain, vback, bias = NULL_TREE;\n@@ -6422,7 +6422,7 @@ expand_omp_for_generic (struct omp_region *region,\n       phis = phi_nodes (l3_bb);\n       for (gsi = gsi_start (phis); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple phi = gsi_stmt (gsi);\n+\t  gimple *phi = gsi_stmt (gsi);\n \t  SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, ne),\n \t\t   PHI_ARG_DEF_FROM_EDGE (phi, e));\n \t}\n@@ -6520,7 +6520,7 @@ expand_omp_for_generic (struct omp_region *region,\n static void\n expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd,\n-\t\t\t       gimple inner_stmt)\n+\t\t\t       gimple *inner_stmt)\n {\n   tree n, q, s0, e0, e, t, tt, nthreads, threadid;\n   tree type, itype, vmain, vback;\n@@ -6944,7 +6944,7 @@ find_phi_with_arg_on_edge (tree arg, edge e)\n \n static void\n expand_omp_for_static_chunk (struct omp_region *region,\n-\t\t\t     struct omp_for_data *fd, gimple inner_stmt)\n+\t\t\t     struct omp_for_data *fd, gimple *inner_stmt)\n {\n   tree n, s0, e0, e, t;\n   tree trip_var, trip_init, trip_main, trip_back, nthreads, threadid;\n@@ -7508,7 +7508,7 @@ expand_cilk_for (struct omp_region *region, struct omp_for_data *fd)\n   tree n1 = low_val;\n   tree n2 = high_val;\n \n-  gimple stmt = gimple_build_assign (ind_var, n1);\n+  gimple *stmt = gimple_build_assign (ind_var, n1);\n \n   /* Replace the GIMPLE_OMP_FOR statement.  */\n   gsi_replace (&gsi, stmt, true);\n@@ -7674,7 +7674,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   tree type, t;\n   basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb, l2_bb, l2_dom_bb;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   gcond *cond_stmt;\n   bool broken_loop = region->cont == NULL;\n   edge e, ne;\n@@ -7924,7 +7924,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n /* Expand the OMP loop defined by REGION.  */\n \n static void\n-expand_omp_for (struct omp_region *region, gimple inner_stmt)\n+expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n {\n   struct omp_for_data fd;\n   struct omp_for_data_loop *loops;\n@@ -8030,7 +8030,7 @@ expand_omp_sections (struct omp_region *region)\n   basic_block entry_bb, l0_bb, l1_bb, l2_bb, default_bb;\n   gimple_stmt_iterator si, switch_si;\n   gomp_sections *sections_stmt;\n-  gimple stmt;\n+  gimple *stmt;\n   gomp_continue *cont;\n   edge_iterator ei;\n   edge e;\n@@ -8286,7 +8286,7 @@ expand_omp_atomic_load (basic_block load_bb, tree addr,\n   gimple_stmt_iterator gsi;\n   basic_block store_bb;\n   location_t loc;\n-  gimple stmt;\n+  gimple *stmt;\n   tree decl, call, type, itype;\n \n   gsi = gsi_last_bb (load_bb);\n@@ -8340,7 +8340,7 @@ expand_omp_atomic_store (basic_block load_bb, tree addr,\n   gimple_stmt_iterator gsi;\n   basic_block store_bb = single_succ (load_bb);\n   location_t loc;\n-  gimple stmt;\n+  gimple *stmt;\n   tree decl, call, type, itype;\n   machine_mode imode;\n   bool exchange;\n@@ -8421,7 +8421,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   tree lhs, rhs;\n   basic_block store_bb = single_succ (load_bb);\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   location_t loc;\n   enum tree_code code;\n   bool need_old, need_new;\n@@ -8567,7 +8567,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   tree type, itype, cmpxchg, iaddr;\n   gimple_stmt_iterator si;\n   basic_block loop_header = single_succ (load_bb);\n-  gimple phi, stmt;\n+  gimple *phi, *stmt;\n   edge e;\n   enum built_in_function fncode;\n \n@@ -8871,7 +8871,7 @@ expand_omp_target (struct omp_region *region)\n   tree child_fn, block, t;\n   gimple_stmt_iterator gsi;\n   gomp_target *entry_stmt;\n-  gimple stmt;\n+  gimple *stmt;\n   edge e;\n   bool offloaded, data_region;\n \n@@ -8936,7 +8936,7 @@ expand_omp_target (struct omp_region *region)\n \t  basic_block entry_succ_bb = single_succ (entry_bb);\n \t  gimple_stmt_iterator gsi;\n \t  tree arg;\n-\t  gimple tgtcopy_stmt = NULL;\n+\t  gimple *tgtcopy_stmt = NULL;\n \t  tree sender = TREE_VEC_ELT (data_arg, 0);\n \n \t  for (gsi = gsi_start_bb (entry_succ_bb); ; gsi_next (&gsi))\n@@ -9215,7 +9215,7 @@ expand_omp_target (struct omp_region *region)\n       t4 = build_fold_addr_expr (TREE_VEC_ELT (t, 2));\n     }\n \n-  gimple g;\n+  gimple *g;\n   /* The maximum number used by any start_ix, without varargs.  */\n   auto_vec<tree, 11> args;\n   args.quick_push (device);\n@@ -9366,7 +9366,7 @@ expand_omp (struct omp_region *region)\n   while (region)\n     {\n       location_t saved_location;\n-      gimple inner_stmt = NULL;\n+      gimple *inner_stmt = NULL;\n \n       /* First, determine whether this is a combined parallel+workshare\n        \t region.  */\n@@ -9444,7 +9444,7 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t\t     bool single_tree)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   basic_block son;\n \n   gsi = gsi_last_bb (bb);\n@@ -9693,7 +9693,7 @@ make_pass_expand_omp_ssa (gcc::context *ctxt)\n static void\n oacc_gimple_assign (tree dest, tree_code op, tree src, gimple_seq *seq)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (TREE_CODE (TREE_TYPE (dest)) != COMPLEX_TYPE)\n     {\n@@ -9778,7 +9778,7 @@ oacc_initialize_reduction_data (tree clauses, tree nthreads,\n \t\t\t\tgimple_seq *stmt_seqp, omp_context *ctx)\n {\n   tree c, t, oc;\n-  gimple stmt;\n+  gimple *stmt;\n   omp_context *octx;\n \n   /* Find the innermost OpenACC parallel context.  */\n@@ -9854,7 +9854,7 @@ oacc_finalize_reduction_data (tree clauses, tree nthreads,\n \t\t\t      gimple_seq *stmt_seqp, omp_context *ctx)\n {\n   tree c, x, var, array, loop_header, loop_body, loop_exit, type;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Create for loop.\n \n@@ -9974,7 +9974,7 @@ oacc_process_reduction_data (gimple_seq *body, gimple_seq *in_stmt_seqp,\n   gsi = gsi_start (*body);\n   while (!gsi_end_p (gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (gbind *bind_stmt = dyn_cast <gbind *> (stmt))\n \t{\n \t  inner = gimple_bind_body (bind_stmt);\n@@ -9993,7 +9993,7 @@ oacc_process_reduction_data (gimple_seq *body, gimple_seq *in_stmt_seqp,\n \tenter, exit;\n       bool reduction_found = false;\n \n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       switch (gimple_code (stmt))\n \t{\n@@ -10065,7 +10065,7 @@ oacc_process_reduction_data (gimple_seq *body, gimple_seq *in_stmt_seqp,\n static void\n maybe_add_implicit_barrier_cancel (omp_context *ctx, gimple_seq *body)\n {\n-  gimple omp_return = gimple_seq_last_stmt (*body);\n+  gimple *omp_return = gimple_seq_last_stmt (*body);\n   gcc_assert (gimple_code (omp_return) == GIMPLE_OMP_RETURN);\n   if (gimple_omp_return_nowait_p (omp_return))\n     return;\n@@ -10078,7 +10078,7 @@ maybe_add_implicit_barrier_cancel (omp_context *ctx, gimple_seq *body)\n       tree lhs = create_tmp_var (c_bool_type);\n       gimple_omp_return_set_lhs (omp_return, lhs);\n       tree fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n-      gimple g = gimple_build_cond (NE_EXPR, lhs,\n+      gimple *g = gimple_build_cond (NE_EXPR, lhs,\n \t\t\t\t    fold_convert (c_bool_type,\n \t\t\t\t\t\t  boolean_false_node),\n \t\t\t\t    ctx->outer->cancel_label, fallthru_label);\n@@ -10096,7 +10096,7 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   tree block, control;\n   gimple_stmt_iterator tgsi;\n   gomp_sections *stmt;\n-  gimple t;\n+  gimple *t;\n   gbind *new_stmt, *bind;\n   gimple_seq ilist, dlist, olist, new_body;\n \n@@ -10115,7 +10115,7 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   for (; !gsi_end_p (tgsi); gsi_next (&tgsi))\n     {\n       omp_context *sctx;\n-      gimple sec_start;\n+      gimple *sec_start;\n \n       sec_start = gsi_stmt (tgsi);\n       sctx = maybe_lookup_ctx (sec_start);\n@@ -10200,7 +10200,7 @@ lower_omp_single_simple (gomp_single *single_stmt, gimple_seq *pre_p)\n   location_t loc = gimple_location (single_stmt);\n   tree tlabel = create_artificial_label (loc);\n   tree flabel = create_artificial_label (loc);\n-  gimple call, cond;\n+  gimple *call, *cond;\n   tree lhs, decl;\n \n   decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_START);\n@@ -10307,7 +10307,7 @@ static void\n lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block;\n-  gimple t;\n+  gimple *t;\n   gomp_single *single_stmt = as_a <gomp_single *> (gsi_stmt (*gsi_p));\n   gbind *bind;\n   gimple_seq bind_body, bind_body_tail = NULL, dlist;\n@@ -10367,7 +10367,7 @@ static void\n lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block, lab = NULL, x, bfn_decl;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   gbind *bind;\n   location_t loc = gimple_location (stmt);\n   gimple_seq tseq;\n@@ -10408,7 +10408,7 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n static void\n lower_omp_taskgroup (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   gcall *x;\n   gbind *bind;\n   tree block = make_node (BLOCK);\n@@ -10438,7 +10438,7 @@ static void\n lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree block;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   gcall *x;\n   gbind *bind;\n \n@@ -10800,7 +10800,7 @@ check_combined_parallel (gimple_stmt_iterator *gsi_p,\n     \t\t\t struct walk_stmt_info *wi)\n {\n   int *info = (int *) wi->info;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n \n   *handled_ops_p = true;\n   switch (gimple_code (stmt))\n@@ -11099,10 +11099,10 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n }\n \n static void\n-lower_depend_clauses (gimple stmt, gimple_seq *iseq, gimple_seq *oseq)\n+lower_depend_clauses (gimple *stmt, gimple_seq *iseq, gimple_seq *oseq)\n {\n   tree c, clauses;\n-  gimple g;\n+  gimple *g;\n   size_t n_in = 0, n_out = 0, idx = 2, i;\n \n   clauses = find_omp_clause (gimple_omp_task_clauses (stmt),\n@@ -11168,7 +11168,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n   tree clauses;\n   tree child_fn, t;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   gbind *par_bind, *bind, *dep_bind = NULL;\n   gimple_seq par_body, olist, ilist, par_olist, par_rlist, par_ilist, new_body;\n   location_t loc = gimple_location (stmt);\n@@ -11723,7 +11723,7 @@ lower_omp_teams (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   location_t loc = gimple_location (teams_stmt);\n   tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TEAMS);\n-  gimple call = gimple_build_call (decl, 2, num_teams, thread_limit);\n+  gimple *call = gimple_build_call (decl, 2, num_teams, thread_limit);\n   gimple_set_location (call, loc);\n   gimple_seq_add_stmt (&bind_body, call);\n \n@@ -11774,7 +11774,7 @@ lower_omp_regimplify_p (tree *tp, int *walk_subtrees,\n static void\n lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n {\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   struct walk_stmt_info wi;\n   gcall *call_stmt;\n \n@@ -11930,7 +11930,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    gimple_call_set_lhs (call_stmt, lhs);\n \t    tree fallthru_label;\n \t    fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n-\t    gimple g;\n+\t    gimple *g;\n \t    g = gimple_build_label (fallthru_label);\n \t    gsi_insert_after (gsi_p, g, GSI_SAME_STMT);\n \t    g = gimple_build_cond (NE_EXPR, lhs,\n@@ -12069,7 +12069,7 @@ static splay_tree all_labels;\n \n static bool\n diagnose_sb_0 (gimple_stmt_iterator *gsi_p,\n-    \t       gimple branch_ctx, gimple label_ctx)\n+\t       gimple *branch_ctx, gimple *label_ctx)\n {\n   gcc_checking_assert (!branch_ctx || is_gimple_omp (branch_ctx));\n   gcc_checking_assert (!label_ctx || is_gimple_omp (label_ctx));\n@@ -12160,9 +12160,9 @@ static tree\n diagnose_sb_1 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     \t       struct walk_stmt_info *wi)\n {\n-  gimple context = (gimple) wi->info;\n-  gimple inner_context;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *context = (gimple *) wi->info;\n+  gimple *inner_context;\n+  gimple *stmt = gsi_stmt (*gsi_p);\n \n   *handled_ops_p = true;\n \n@@ -12220,9 +12220,9 @@ static tree\n diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     \t       struct walk_stmt_info *wi)\n {\n-  gimple context = (gimple) wi->info;\n+  gimple *context = (gimple *) wi->info;\n   splay_tree_node n;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n \n   *handled_ops_p = true;\n \n@@ -12265,15 +12265,15 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t      n = splay_tree_lookup (all_labels,\n \t\t\t\t     (splay_tree_key) lab);\n \t      diagnose_sb_0 (gsi_p, context,\n-\t\t\t     n ? (gimple) n->value : NULL);\n+\t\t\t     n ? (gimple *) n->value : NULL);\n \t    }\n \t  lab = gimple_cond_false_label (cond_stmt);\n \t  if (lab)\n \t    {\n \t      n = splay_tree_lookup (all_labels,\n \t\t\t\t     (splay_tree_key) lab);\n \t      diagnose_sb_0 (gsi_p, context,\n-\t\t\t     n ? (gimple) n->value : NULL);\n+\t\t\t     n ? (gimple *) n->value : NULL);\n \t    }\n \t}\n       break;\n@@ -12285,7 +12285,7 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t  break;\n \n \tn = splay_tree_lookup (all_labels, (splay_tree_key) lab);\n-\tdiagnose_sb_0 (gsi_p, context, n ? (gimple) n->value : NULL);\n+\tdiagnose_sb_0 (gsi_p, context, n ? (gimple *) n->value : NULL);\n       }\n       break;\n \n@@ -12297,7 +12297,7 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t  {\n \t    tree lab = CASE_LABEL (gimple_switch_label (switch_stmt, i));\n \t    n = splay_tree_lookup (all_labels, (splay_tree_key) lab);\n-\t    if (n && diagnose_sb_0 (gsi_p, context, (gimple) n->value))\n+\t    if (n && diagnose_sb_0 (gsi_p, context, (gimple *) n->value))\n \t      break;\n \t  }\n       }\n@@ -12320,7 +12320,7 @@ bool\n make_gimple_omp_edges (basic_block bb, struct omp_region **region,\n \t\t       int *region_idx)\n {\n-  gimple last = last_stmt (bb);\n+  gimple *last = last_stmt (bb);\n   enum gimple_code code = gimple_code (last);\n   struct omp_region *cur_region = *region;\n   bool fallthru = false;\n@@ -13142,7 +13142,7 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n \n struct modify_stmt_info {\n   ipa_parm_adjustment_vec adjustments;\n-  gimple stmt;\n+  gimple *stmt;\n   /* True if the parent statement was modified by\n      ipa_simd_modify_stmt_ops.  */\n   bool modified;\n@@ -13196,7 +13196,7 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n   if (tp != orig_tp)\n     {\n       repl = build_fold_addr_expr (repl);\n-      gimple stmt;\n+      gimple *stmt;\n       if (is_gimple_debug (info->stmt))\n \t{\n \t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n@@ -13296,7 +13296,7 @@ ipa_simd_modify_function_body (struct cgraph_node *node,\n \t\t    set_ssa_default_def (cfun, adjustments[j].base, NULL_TREE);\n \t\t    SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n \t\t    SSA_NAME_IS_DEFAULT_DEF (name) = 0;\n-\t\t    gimple stmt = gimple_build_assign (name, new_decl);\n+\t\t    gimple *stmt = gimple_build_assign (name, new_decl);\n \t\t    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \t\t  }\n \t\telse\n@@ -13315,7 +13315,7 @@ ipa_simd_modify_function_body (struct cgraph_node *node,\n       gsi = gsi_start_bb (bb);\n       while (!gsi_end_p (gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  info.stmt = stmt;\n \t  struct walk_stmt_info wi;\n \n@@ -13405,7 +13405,7 @@ simd_clone_adjust (struct cgraph_node *node)\n   edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n   e->probability = REG_BR_PROB_BASE;\n   gsi = gsi_last_bb (incr_bb);\n-  gimple g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n+  gimple *g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n \t\t\t\t  build_int_cst (unsigned_type_node, 1));\n   gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n \n@@ -13578,7 +13578,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \n \t    imm_use_iterator iter;\n \t    use_operand_p use_p;\n-\t    gimple use_stmt;\n+\t    gimple *use_stmt;\n \t    tree repl = gimple_get_lhs (g);\n \t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n \t      if (is_gimple_debug (use_stmt) || use_stmt == call)\n@@ -13632,7 +13632,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \n \t    imm_use_iterator iter;\n \t    use_operand_p use_p;\n-\t    gimple use_stmt;\n+\t    gimple *use_stmt;\n \t    if (TREE_ADDRESSABLE (orig_arg))\n \t      {\n \t\tgsi = gsi_after_labels (body_bb);"}, {"sha": "70b71b1594ccf28b3222901ddbc01a1fa3285549", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -2756,7 +2756,7 @@ execute_ipa_pass_list (opt_pass *pass)\n \n static void\n execute_ipa_stmt_fixups (opt_pass *pass,\n-\t\t\t struct cgraph_node *node, gimple *stmts)\n+\t\t\t struct cgraph_node *node, gimple **stmts)\n {\n   while (pass)\n     {\n@@ -2791,7 +2791,7 @@ execute_ipa_stmt_fixups (opt_pass *pass,\n /* Execute stmt fixup hooks of all IPA passes for NODE and STMTS.  */\n \n void\n-execute_all_ipa_stmt_fixups (struct cgraph_node *node, gimple *stmts)\n+execute_all_ipa_stmt_fixups (struct cgraph_node *node, gimple **stmts)\n {\n   pass_manager *passes = g->get_passes ();\n   execute_ipa_stmt_fixups (passes->all_regular_ipa_passes, node, stmts);"}, {"sha": "0b3016ce81f77528c113f84ed115e1eb54f81967", "filename": "gcc/predict.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1142,7 +1142,7 @@ is_comparison_with_loop_invariant_p (gcond *stmt, struct loop *loop,\n static bool\n expr_coherent_p (tree t1, tree t2)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   tree ssa_name_1 = NULL;\n   tree ssa_name_2 = NULL;\n \n@@ -1205,7 +1205,7 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n \t\t       enum tree_code loop_bound_code,\n \t\t       int loop_bound_step)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   tree compare_var, compare_base;\n   enum tree_code compare_code;\n   tree compare_step_var;\n@@ -1394,10 +1394,10 @@ predict_extra_loop_exits (edge exit_edge)\n {\n   unsigned i;\n   bool check_value_one;\n-  gimple lhs_def_stmt;\n+  gimple *lhs_def_stmt;\n   gphi *phi_stmt;\n   tree cmp_rhs, cmp_lhs;\n-  gimple last;\n+  gimple *last;\n   gcond *cmp_stmt;\n \n   last = last_stmt (exit_edge->src);\n@@ -1740,7 +1740,7 @@ static tree\n expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t       tree op1, bitmap visited, enum br_predictor *predictor)\n {\n-  gimple def;\n+  gimple *def;\n \n   if (predictor)\n     *predictor = PRED_UNCONDITIONAL;\n@@ -1935,7 +1935,7 @@ expr_expected_value (tree expr, bitmap visited,\n static void\n tree_predict_by_opcode (basic_block bb)\n {\n-  gimple stmt = last_stmt (bb);\n+  gimple *stmt = last_stmt (bb);\n   edge then_edge;\n   tree op0, op1;\n   tree type;\n@@ -2114,7 +2114,7 @@ apply_return_prediction (void)\n \n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n-      gimple last = last_stmt (e->src);\n+      gimple *last = last_stmt (e->src);\n       if (last\n \t  && gimple_code (last) == GIMPLE_RETURN)\n \t{\n@@ -2178,7 +2178,7 @@ tree_bb_level_predictions (void)\n \n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree decl;\n \n \t  if (is_gimple_call (stmt))\n@@ -2226,7 +2226,7 @@ tree_estimate_probability_bb (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n-  gimple last;\n+  gimple *last;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -2308,7 +2308,7 @@ tree_estimate_probability_bb (basic_block bb)\n \t  for (bi = gsi_start_bb (e->dest); !gsi_end_p (bi);\n \t       gsi_next (&bi))\n \t    {\n-\t      gimple stmt = gsi_stmt (bi);\n+\t      gimple *stmt = gsi_stmt (bi);\n \t      if (is_gimple_call (stmt)\n \t\t  /* Constant and pure calls are hardly used to signalize\n \t\t     something exceptional.  */\n@@ -3094,15 +3094,15 @@ unsigned int\n pass_strip_predict_hints::execute (function *fun)\n {\n   basic_block bb;\n-  gimple ass_stmt;\n+  gimple *ass_stmt;\n   tree var;\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator bi;\n       for (bi = gsi_start_bb (bb); !gsi_end_p (bi);)\n \t{\n-\t  gimple stmt = gsi_stmt (bi);\n+\t  gimple *stmt = gsi_stmt (bi);\n \n \t  if (gimple_code (stmt) == GIMPLE_PREDICT)\n \t    {"}, {"sha": "d599341bbd5f04cfcfa136c4d1cc0a36e9b49164", "filename": "gcc/profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -912,7 +912,7 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n   for (i = 0; i < values.length (); i++)\n     {\n       histogram_value hist = values[i];\n-      gimple stmt = hist->hvalue.stmt;\n+      gimple *stmt = hist->hvalue.stmt;\n \n       t = (int) hist->type;\n \n@@ -1052,7 +1052,7 @@ branch_prob (void)\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  gimple_stmt_iterator gsi;\n-\t  gimple last = NULL;\n+\t  gimple *last = NULL;\n \n \t  /* It may happen that there are compiler generated statements\n \t     without a locus at all.  Go through the basic block from the\n@@ -1118,7 +1118,7 @@ branch_prob (void)\n \t  if (have_exit_edge || need_exit_edge)\n \t    {\n \t      gimple_stmt_iterator gsi;\n-\t      gimple first;\n+\t      gimple *first;\n \n \t      gsi = gsi_start_nondebug_after_labels_bb (bb);\n \t      gcc_checking_assert (!gsi_end_p (gsi));\n@@ -1281,7 +1281,7 @@ branch_prob (void)\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \t      if (gimple_has_location (stmt))\n \t\toutput_location (gimple_filename (stmt), gimple_lineno (stmt),\n \t\t\t\t &offset, bb);"}, {"sha": "1ef556bd25c7138f87d280a794c1706d076dd0fb", "filename": "gcc/sanopt.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -81,7 +81,7 @@ maybe_get_single_definition (tree t)\n {\n   if (TREE_CODE (t) == SSA_NAME)\n     {\n-      gimple g = SSA_NAME_DEF_STMT (t);\n+      gimple *g = SSA_NAME_DEF_STMT (t);\n       if (gimple_assign_single_p (g))\n \treturn gimple_assign_rhs1 (g);\n     }\n@@ -151,16 +151,16 @@ struct sanopt_ctx\n {\n   /* This map maps a pointer (the first argument of UBSAN_NULL) to\n      a vector of UBSAN_NULL call statements that check this pointer.  */\n-  hash_map<tree, auto_vec<gimple> > null_check_map;\n+  hash_map<tree, auto_vec<gimple *> > null_check_map;\n \n   /* This map maps a pointer (the second argument of ASAN_CHECK) to\n      a vector of ASAN_CHECK call statements that check the access.  */\n-  hash_map<tree_operand_hash, auto_vec<gimple> > asan_check_map;\n+  hash_map<tree_operand_hash, auto_vec<gimple *> > asan_check_map;\n \n   /* This map maps a tree triplet (the first, second and fourth argument\n      of UBSAN_VPTR) to a vector of UBSAN_VPTR call statements that check\n      that virtual table pointer.  */\n-  hash_map<sanopt_tree_triplet_hash, auto_vec<gimple> > vptr_check_map;\n+  hash_map<sanopt_tree_triplet_hash, auto_vec<gimple *> > vptr_check_map;\n \n   /* Number of IFN_ASAN_CHECK statements.  */\n   int asan_num_accesses;\n@@ -214,7 +214,7 @@ imm_dom_path_with_freeing_call (basic_block bb, basic_block dom)\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (e->src); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  if (is_gimple_call (stmt) && !nonfreeing_call_p (stmt))\n \t    {\n@@ -265,12 +265,12 @@ imm_dom_path_with_freeing_call (basic_block bb, basic_block dom)\n /* Get the first dominating check from the list of stored checks.\n    Non-dominating checks are silently dropped.  */\n \n-static gimple\n-maybe_get_dominating_check (auto_vec<gimple> &v)\n+static gimple *\n+maybe_get_dominating_check (auto_vec<gimple *> &v)\n {\n   for (; !v.is_empty (); v.pop ())\n     {\n-      gimple g = v.last ();\n+      gimple *g = v.last ();\n       sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n       if (!si->visited_p)\n \t/* At this point we shouldn't have any statements\n@@ -283,16 +283,16 @@ maybe_get_dominating_check (auto_vec<gimple> &v)\n /* Optimize away redundant UBSAN_NULL calls.  */\n \n static bool\n-maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n {\n   gcc_assert (gimple_call_num_args (stmt) == 3);\n   tree ptr = gimple_call_arg (stmt, 0);\n   tree cur_align = gimple_call_arg (stmt, 2);\n   gcc_assert (TREE_CODE (cur_align) == INTEGER_CST);\n   bool remove = false;\n \n-  auto_vec<gimple> &v = ctx->null_check_map.get_or_insert (ptr);\n-  gimple g = maybe_get_dominating_check (v);\n+  auto_vec<gimple *> &v = ctx->null_check_map.get_or_insert (ptr);\n+  gimple *g = maybe_get_dominating_check (v);\n   if (!g)\n     {\n       /* For this PTR we don't have any UBSAN_NULL stmts recorded, so there's\n@@ -339,16 +339,16 @@ maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple stmt)\n    when we can actually optimize.  */\n \n static bool\n-maybe_optimize_ubsan_vptr_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+maybe_optimize_ubsan_vptr_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n {\n   gcc_assert (gimple_call_num_args (stmt) == 5);\n   sanopt_tree_triplet triplet;\n   triplet.t1 = gimple_call_arg (stmt, 0);\n   triplet.t2 = gimple_call_arg (stmt, 1);\n   triplet.t3 = gimple_call_arg (stmt, 3);\n \n-  auto_vec<gimple> &v = ctx->vptr_check_map.get_or_insert (triplet);\n-  gimple g = maybe_get_dominating_check (v);\n+  auto_vec<gimple *> &v = ctx->vptr_check_map.get_or_insert (triplet);\n+  gimple *g = maybe_get_dominating_check (v);\n   if (!g)\n     {\n       /* For this PTR we don't have any UBSAN_VPTR stmts recorded, so there's\n@@ -364,11 +364,11 @@ maybe_optimize_ubsan_vptr_ifn (struct sanopt_ctx *ctx, gimple stmt)\n    if preceded by checks in V.  */\n \n static bool\n-can_remove_asan_check (auto_vec<gimple> &v, tree len, basic_block bb)\n+can_remove_asan_check (auto_vec<gimple *> &v, tree len, basic_block bb)\n {\n   unsigned int i;\n-  gimple g;\n-  gimple to_pop = NULL;\n+  gimple *g;\n+  gimple *to_pop = NULL;\n   bool remove = false;\n   basic_block last_bb = bb;\n   bool cleanup = false;\n@@ -443,7 +443,7 @@ can_remove_asan_check (auto_vec<gimple> &v, tree len, basic_block bb)\n /* Optimize away redundant ASAN_CHECK calls.  */\n \n static bool\n-maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n {\n   gcc_assert (gimple_call_num_args (stmt) == 4);\n   tree ptr = gimple_call_arg (stmt, 1);\n@@ -458,19 +458,19 @@ maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n \n   gimple_set_uid (stmt, info->freeing_call_events);\n \n-  auto_vec<gimple> *ptr_checks = &ctx->asan_check_map.get_or_insert (ptr);\n+  auto_vec<gimple *> *ptr_checks = &ctx->asan_check_map.get_or_insert (ptr);\n \n   tree base_addr = maybe_get_single_definition (ptr);\n-  auto_vec<gimple> *base_checks = NULL;\n+  auto_vec<gimple *> *base_checks = NULL;\n   if (base_addr)\n     {\n       base_checks = &ctx->asan_check_map.get_or_insert (base_addr);\n       /* Original pointer might have been invalidated.  */\n       ptr_checks = ctx->asan_check_map.get (ptr);\n     }\n \n-  gimple g = maybe_get_dominating_check (*ptr_checks);\n-  gimple g2 = NULL;\n+  gimple *g = maybe_get_dominating_check (*ptr_checks);\n+  gimple *g2 = NULL;\n \n   if (base_checks)\n     /* Try with base address as well.  */\n@@ -525,7 +525,7 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       bool remove = false;\n \n       if (!is_gimple_call (stmt))\n@@ -667,7 +667,7 @@ pass_sanopt::execute (function *fun)\n       FOR_EACH_BB_FN (bb, fun)\n \tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t  {\n- \t    gimple stmt = gsi_stmt (gsi);\n+\t    gimple *stmt = gsi_stmt (gsi);\n \t    if (is_gimple_call (stmt) && gimple_call_internal_p (stmt)\n \t\t&& gimple_call_internal_fn (stmt) == IFN_ASAN_CHECK)\n \t      ++asan_num_accesses;\n@@ -682,7 +682,7 @@ pass_sanopt::execute (function *fun)\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  bool no_next = false;\n \n \t  if (!is_gimple_call (stmt))"}, {"sha": "db8c629199163c2b097c9d0b23fe8d10c45e3297", "filename": "gcc/sese.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -171,7 +171,7 @@ sese_build_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n   for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n        gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n \n       if (is_gimple_debug (stmt))\n \tcontinue;\n@@ -223,7 +223,7 @@ sese_reset_debug_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n \n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n \n       if (!is_gimple_debug (stmt))\n \tcontinue;\n@@ -400,7 +400,7 @@ set_rename (rename_map_type *rename_map, tree old_name, tree expr, sese region)\n    is set when the code generation cannot continue.  */\n \n static bool\n-rename_uses (gimple copy, rename_map_type *rename_map,\n+rename_uses (gimple *copy, rename_map_type *rename_map,\n \t     gimple_stmt_iterator *gsi_tgt,\n \t     sese region, loop_p loop, vec<tree> iv_map,\n \t     bool *gloog_error)\n@@ -519,8 +519,8 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n     {\n       def_operand_p def_p;\n       ssa_op_iter op_iter;\n-      gimple stmt = gsi_stmt (gsi);\n-      gimple copy;\n+      gimple *stmt = gsi_stmt (gsi);\n+      gimple *copy;\n       tree lhs;\n \n       /* Do not copy labels or conditions.  */\n@@ -745,7 +745,7 @@ set_ifsese_condition (ifsese if_region, tree condition)\n   sese region = if_region->region;\n   edge entry = region->entry;\n   basic_block bb = entry->dest;\n-  gimple last = last_stmt (bb);\n+  gimple *last = last_stmt (bb);\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   gcond *cond_stmt;\n \n@@ -770,7 +770,7 @@ invariant_in_sese_p_rec (tree t, sese region)\n   if (!defined_in_sese_p (t, region))\n     return true;\n \n-  gimple stmt = SSA_NAME_DEF_STMT (t);\n+  gimple *stmt = SSA_NAME_DEF_STMT (t);\n \n   if (gimple_code (stmt) == GIMPLE_PHI\n       || gimple_code (stmt) == GIMPLE_CALL)\n@@ -795,7 +795,7 @@ invariant_in_sese_p_rec (tree t, sese region)\n tree\n scalar_evolution_in_region (sese region, loop_p loop, tree t)\n {\n-  gimple def;\n+  gimple *def;\n   struct loop *def_loop;\n   basic_block before = block_before_sese (region);\n "}, {"sha": "6ce5cc87eaddbe9cc2622c2bba44a5b4f07da91f", "filename": "gcc/sese.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -119,7 +119,7 @@ bb_in_sese_p (basic_block bb, sese region)\n /* Returns true when STMT is defined in REGION.  */\n \n static inline bool\n-stmt_in_sese_p (gimple stmt, sese region)\n+stmt_in_sese_p (gimple *stmt, sese region)\n {\n   basic_block bb = gimple_bb (stmt);\n   return bb && bb_in_sese_p (bb, region);\n@@ -130,7 +130,7 @@ stmt_in_sese_p (gimple stmt, sese region)\n static inline bool\n defined_in_sese_p (tree name, sese region)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (name);\n+  gimple *stmt = SSA_NAME_DEF_STMT (name);\n   return stmt_in_sese_p (stmt, region);\n }\n \n@@ -289,8 +289,8 @@ typedef struct gimple_bb\n      corresponding element in CONDITION_CASES is not NULL_TREE.  For a\n      SWITCH_EXPR the corresponding element in CONDITION_CASES is a\n      CASE_LABEL_EXPR.  */\n-  vec<gimple> conditions;\n-  vec<gimple> condition_cases;\n+  vec<gimple *> conditions;\n+  vec<gimple *> condition_cases;\n   vec<data_reference_p> data_refs;\n } *gimple_bb_p;\n "}, {"sha": "e04b630b2ffe32af0df07f8eb6095e498e260db0", "filename": "gcc/ssa-iterators.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -115,7 +115,7 @@ struct imm_use_iterator\n \n \n extern bool single_imm_use_1 (const ssa_use_operand_t *head,\n-\t\t\t      use_operand_p *use_p, gimple *stmt);\n+\t\t\t      use_operand_p *use_p, gimple **stmt);\n \n \n enum ssa_op_iter_type {\n@@ -138,7 +138,7 @@ struct ssa_op_iter\n   unsigned i;\n   unsigned numops;\n   use_optype_p uses;\n-  gimple stmt;\n+  gimple *stmt;\n };\n \n /* NOTE: Keep these in sync with doc/tree-ssa.texi.  */\n@@ -291,7 +291,7 @@ set_ssa_use_from_ptr (use_operand_p use, tree val)\n /* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occurring\n    in STMT.  */\n static inline void\n-link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, gimple stmt)\n+link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, gimple *stmt)\n {\n   if (stmt)\n     link_imm_use (linknode, def);\n@@ -321,7 +321,7 @@ relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n    in STMT.  */\n static inline void\n relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old,\n-\t\t     gimple stmt)\n+\t\t     gimple *stmt)\n {\n   if (stmt)\n     relink_imm_use (linknode, old);\n@@ -411,7 +411,7 @@ has_single_use (const_tree var)\n /* If VAR has only a single immediate nondebug use, return true, and\n    set USE_P and STMT to the use pointer and stmt of occurrence.  */\n static inline bool\n-single_imm_use (const_tree var, use_operand_p *use_p, gimple *stmt)\n+single_imm_use (const_tree var, use_operand_p *use_p, gimple **stmt)\n {\n   const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n \n@@ -586,7 +586,7 @@ clear_and_done_ssa_iter (ssa_op_iter *ptr)\n \n /* Initialize the iterator PTR to the virtual defs in STMT.  */\n static inline void\n-op_iter_init (ssa_op_iter *ptr, gimple stmt, int flags)\n+op_iter_init (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   /* PHI nodes require a different iterator initialization path.  We\n      do not support iterating over virtual defs or uses without\n@@ -627,7 +627,7 @@ op_iter_init (ssa_op_iter *ptr, gimple stmt, int flags)\n /* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n    the first use.  */\n static inline use_operand_p\n-op_iter_init_use (ssa_op_iter *ptr, gimple stmt, int flags)\n+op_iter_init_use (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   gcc_checking_assert ((flags & SSA_OP_ALL_DEFS) == 0\n \t\t       && (flags & SSA_OP_USE));\n@@ -639,7 +639,7 @@ op_iter_init_use (ssa_op_iter *ptr, gimple stmt, int flags)\n /* Initialize iterator PTR to the def operands in STMT based on FLAGS. Return\n    the first def.  */\n static inline def_operand_p\n-op_iter_init_def (ssa_op_iter *ptr, gimple stmt, int flags)\n+op_iter_init_def (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   gcc_checking_assert ((flags & SSA_OP_ALL_USES) == 0\n \t\t       && (flags & SSA_OP_DEF));\n@@ -651,7 +651,7 @@ op_iter_init_def (ssa_op_iter *ptr, gimple stmt, int flags)\n /* Initialize iterator PTR to the operands in STMT based on FLAGS. Return\n    the first operand as a tree.  */\n static inline tree\n-op_iter_init_tree (ssa_op_iter *ptr, gimple stmt, int flags)\n+op_iter_init_tree (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   op_iter_init (ptr, stmt, flags);\n   ptr->iter_type = ssa_op_iter_tree;\n@@ -662,7 +662,7 @@ op_iter_init_tree (ssa_op_iter *ptr, gimple stmt, int flags)\n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n    return NULL.  */\n static inline tree\n-single_ssa_tree_operand (gimple stmt, int flags)\n+single_ssa_tree_operand (gimple *stmt, int flags)\n {\n   tree var;\n   ssa_op_iter iter;\n@@ -680,7 +680,7 @@ single_ssa_tree_operand (gimple stmt, int flags)\n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n    return NULL.  */\n static inline use_operand_p\n-single_ssa_use_operand (gimple stmt, int flags)\n+single_ssa_use_operand (gimple *stmt, int flags)\n {\n   use_operand_p var;\n   ssa_op_iter iter;\n@@ -699,7 +699,7 @@ single_ssa_use_operand (gimple stmt, int flags)\n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n    return NULL.  */\n static inline def_operand_p\n-single_ssa_def_operand (gimple stmt, int flags)\n+single_ssa_def_operand (gimple *stmt, int flags)\n {\n   def_operand_p var;\n   ssa_op_iter iter;\n@@ -717,7 +717,7 @@ single_ssa_def_operand (gimple stmt, int flags)\n /* Return true if there are zero operands in STMT matching the type\n    given in FLAGS.  */\n static inline bool\n-zero_ssa_operands (gimple stmt, int flags)\n+zero_ssa_operands (gimple *stmt, int flags)\n {\n   ssa_op_iter iter;\n \n@@ -728,7 +728,7 @@ zero_ssa_operands (gimple stmt, int flags)\n \n /* Return the number of operands matching FLAGS in STMT.  */\n static inline int\n-num_ssa_operands (gimple stmt, int flags)\n+num_ssa_operands (gimple *stmt, int flags)\n {\n   ssa_op_iter iter;\n   tree t;\n@@ -867,7 +867,7 @@ link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n {\n   use_operand_p use_p;\n   use_operand_p last_p = head;\n-  gimple head_stmt = USE_STMT (head);\n+  gimple *head_stmt = USE_STMT (head);\n   tree use = USE_FROM_PTR (head);\n   ssa_op_iter op_iter;\n   int flag;\n@@ -902,7 +902,7 @@ link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n }\n \n /* Initialize IMM to traverse over uses of VAR.  Return the first statement.  */\n-static inline gimple\n+static inline gimple *\n first_imm_use_stmt (imm_use_iterator *imm, tree var)\n {\n   imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -927,7 +927,7 @@ first_imm_use_stmt (imm_use_iterator *imm, tree var)\n \n /* Bump IMM to the next stmt which has a use of var.  */\n \n-static inline gimple\n+static inline gimple *\n next_imm_use_stmt (imm_use_iterator *imm)\n {\n   imm->imm_use = imm->iter_node.next;\n@@ -977,7 +977,7 @@ next_imm_use_on_stmt (imm_use_iterator *imm)\n \n /* Delink all immediate_use information for STMT.  */\n static inline void\n-delink_stmt_imm_use (gimple stmt)\n+delink_stmt_imm_use (gimple *stmt)\n {\n    ssa_op_iter iter;\n    use_operand_p use_p;"}, {"sha": "c33aa016705804a941942aab5057d9d2be971bdd", "filename": "gcc/symtab.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -478,7 +478,7 @@ symtab_node::create_reference (symtab_node *referred_node,\n \n ipa_ref *\n symtab_node::create_reference (symtab_node *referred_node,\n-\t\t\t       enum ipa_ref_use use_type, gimple stmt)\n+\t\t\t       enum ipa_ref_use use_type, gimple *stmt)\n {\n   ipa_ref *ref = NULL, *ref2 = NULL;\n   ipa_ref_list *list, *list2;\n@@ -533,7 +533,7 @@ symtab_node::create_reference (symtab_node *referred_node,\n \n ipa_ref *\n symtab_node::maybe_create_reference (tree val, enum ipa_ref_use use_type,\n-\t\t\t\t     gimple stmt)\n+\t\t\t\t     gimple *stmt)\n {\n   STRIP_NOPS (val);\n   if (TREE_CODE (val) != ADDR_EXPR)\n@@ -588,7 +588,7 @@ symtab_node::clone_referring (symtab_node *node)\n /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n \n ipa_ref *\n-symtab_node::clone_reference (ipa_ref *ref, gimple stmt)\n+symtab_node::clone_reference (ipa_ref *ref, gimple *stmt)\n {\n   bool speculative = ref->speculative;\n   unsigned int stmt_uid = ref->lto_stmt_uid;\n@@ -605,7 +605,7 @@ symtab_node::clone_reference (ipa_ref *ref, gimple stmt)\n \n ipa_ref *\n symtab_node::find_reference (symtab_node *referred_node,\n-\t\t\t     gimple stmt, unsigned int lto_stmt_uid)\n+\t\t\t     gimple *stmt, unsigned int lto_stmt_uid)\n {\n   ipa_ref *r = NULL;\n   int i;\n@@ -623,7 +623,7 @@ symtab_node::find_reference (symtab_node *referred_node,\n /* Remove all references that are associated with statement STMT.  */\n \n void\n-symtab_node::remove_stmt_references (gimple stmt)\n+symtab_node::remove_stmt_references (gimple *stmt)\n {\n   ipa_ref *r = NULL;\n   int i = 0;"}, {"sha": "71867c4013743f6d350d46a2992c71556e9089ab", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1059,7 +1059,7 @@ helper_const_non_const_cast (const char *p)\n #define CONST_CAST_RTX(X) CONST_CAST (struct rtx_def *, (X))\n #define CONST_CAST_RTX_INSN(X) CONST_CAST (struct rtx_insn *, (X))\n #define CONST_CAST_BB(X) CONST_CAST (struct basic_block_def *, (X))\n-#define CONST_CAST_GIMPLE(X) CONST_CAST (struct gimple_statement_base *, (X))\n+#define CONST_CAST_GIMPLE(X) CONST_CAST (gimple *, (X))\n \n /* Activate certain diagnostics as warnings (not errors via the\n    -Werror flag).  */"}, {"sha": "f33070984cba6ba7284f6c304beccf1f173917f1", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -3814,7 +3814,7 @@ DEFHOOK_UNDOC\n \"Perform architecture specific checking of statements gimplified\\\n  from @code{VA_ARG_EXPR}.  @var{stmt} is the statement.  Returns true if\\\n  the statement doesn't need to be checked for @code{va_list} references.\",\n- bool, (struct stdarg_info *ai, const_gimple stmt), NULL)\n+ bool, (struct stdarg_info *ai, const gimple *stmt), NULL)\n \n /* This target hook allows the operating system to override the DECL\n    that represents the external variable that contains the stack"}, {"sha": "2c60c1810de941e237456c64b046452700c28594", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -63,7 +63,7 @@ get_real_ref_rhs (tree expr)\n           if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n-              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n               /* We are only interested in an assignment with a single\n                  rhs operand because if it is not, the original assignment\n                  will not possibly be a self-assignment.  */\n@@ -168,7 +168,7 @@ get_non_ssa_expr (tree expr)\n           if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n-              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n               if (gimple_assign_single_p (def_stmt))\n                 vdecl = gimple_assign_rhs1 (def_stmt);\n             }\n@@ -186,7 +186,7 @@ get_non_ssa_expr (tree expr)\n    they are the same. If so, print a warning message about self-assignment.  */\n \n static void\n-compare_and_warn (gimple stmt, tree lhs, tree rhs)\n+compare_and_warn (gimple *stmt, tree lhs, tree rhs)\n {\n   if (operand_equal_p (lhs, rhs, OEP_PURE_SAME))\n     {\n@@ -210,7 +210,7 @@ compare_and_warn (gimple stmt, tree lhs, tree rhs)\n /* Check and warn if STMT is a self-assign statement.  */\n \n static void\n-warn_self_assign (gimple stmt)\n+warn_self_assign (gimple *stmt)\n {\n   tree rhs, lhs;\n "}, {"sha": "2adb6446b1dbadd8e0a81914b5234685e126d0ce", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -63,7 +63,7 @@ get_real_ref_rhs (tree expr)\n           if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n-              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n               /* We are only interested in an assignment with a single\n                  rhs operand because if it is not, the original assignment\n                  will not possibly be a self-assignment.  */\n@@ -168,7 +168,7 @@ get_non_ssa_expr (tree expr)\n           if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n-              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n               if (gimple_assign_single_p (def_stmt))\n                 vdecl = gimple_assign_rhs1 (def_stmt);\n             }\n@@ -186,7 +186,7 @@ get_non_ssa_expr (tree expr)\n    they are the same. If so, print a warning message about self-assignment.  */\n \n static void\n-compare_and_warn (gimple stmt, tree lhs, tree rhs)\n+compare_and_warn (gimple *stmt, tree lhs, tree rhs)\n {\n   if (operand_equal_p (lhs, rhs, OEP_PURE_SAME))\n     {\n@@ -210,7 +210,7 @@ compare_and_warn (gimple stmt, tree lhs, tree rhs)\n /* Check and warn if STMT is a self-assign statement.  */\n \n static void\n-warn_self_assign (gimple stmt)\n+warn_self_assign (gimple *stmt)\n {\n   tree rhs, lhs;\n "}, {"sha": "11d5f94ec6706589964d387e4e7e3688697f2f6c", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -93,7 +93,7 @@ bb_seen_p (basic_block bb)\n static bool\n ignore_bb_p (const_basic_block bb)\n {\n-  gimple g;\n+  gimple *g;\n \n   if (bb->index < NUM_FIXED_BLOCKS)\n     return true;\n@@ -115,7 +115,7 @@ static int\n count_insns (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   int n = 0;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))"}, {"sha": "d9a681f2a34fcf8285df3e70e03dee2463b1a530", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -268,7 +268,7 @@ is_tm_safe (const_tree x)\n /* Return true if CALL is const, or tm_pure.  */\n \n static bool\n-is_tm_pure_call (gimple call)\n+is_tm_pure_call (gimple *call)\n {\n   tree fn = gimple_call_fn (call);\n \n@@ -336,7 +336,7 @@ is_tm_ending_fndecl (tree fndecl)\n    transaction.  */\n \n bool\n-is_tm_ending (gimple stmt)\n+is_tm_ending (gimple *stmt)\n {\n   tree fndecl;\n \n@@ -351,7 +351,7 @@ is_tm_ending (gimple stmt)\n /* Return true if STMT is a TM load.  */\n \n static bool\n-is_tm_load (gimple stmt)\n+is_tm_load (gimple *stmt)\n {\n   tree fndecl;\n \n@@ -367,7 +367,7 @@ is_tm_load (gimple stmt)\n    after-write, after-read, etc optimized variants.  */\n \n static bool\n-is_tm_simple_load (gimple stmt)\n+is_tm_simple_load (gimple *stmt)\n {\n   tree fndecl;\n \n@@ -395,7 +395,7 @@ is_tm_simple_load (gimple stmt)\n /* Return true if STMT is a TM store.  */\n \n static bool\n-is_tm_store (gimple stmt)\n+is_tm_store (gimple *stmt)\n {\n   tree fndecl;\n \n@@ -411,7 +411,7 @@ is_tm_store (gimple stmt)\n    after-write, after-read, etc optimized variants.  */\n \n static bool\n-is_tm_simple_store (gimple stmt)\n+is_tm_simple_store (gimple *stmt)\n {\n   tree fndecl;\n \n@@ -591,7 +591,7 @@ struct diagnose_tm\n   unsigned int block_flags : 8;\n   unsigned int func_flags : 8;\n   unsigned int saw_volatile : 1;\n-  gimple stmt;\n+  gimple *stmt;\n };\n \n /* Return true if T is a volatile variable of some kind.  */\n@@ -635,7 +635,7 @@ static tree\n diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t    struct walk_stmt_info *wi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   struct diagnose_tm *d = (struct diagnose_tm *) wi->info;\n \n   /* Save stmt for use in leaf analysis.  */\n@@ -934,7 +934,7 @@ typedef struct tm_log_entry\n   /* Entry block for the transaction this address occurs in.  */\n   basic_block entry_block;\n   /* Dominating statements the store occurs in.  */\n-  vec<gimple> stmts;\n+  vec<gimple *> stmts;\n   /* Initially, while we are building the log, we place a nonzero\n      value here to mean that this address *will* be saved with a\n      save/restore sequence.  Later, when generating the save sequence\n@@ -1095,7 +1095,7 @@ transaction_invariant_address_p (const_tree mem, basic_block region_entry_block)\n    If known, ENTRY_BLOCK is the entry block for the region, otherwise\n    NULL.  */\n static void\n-tm_log_add (basic_block entry_block, tree addr, gimple stmt)\n+tm_log_add (basic_block entry_block, tree addr, gimple *stmt)\n {\n   tm_log_entry **slot;\n   struct tm_log_entry l, *lp;\n@@ -1140,7 +1140,7 @@ tm_log_add (basic_block entry_block, tree addr, gimple stmt)\n   else\n     {\n       size_t i;\n-      gimple oldstmt;\n+      gimple *oldstmt;\n \n       lp = *slot;\n \n@@ -1184,12 +1184,12 @@ gimplify_addr (gimple_stmt_iterator *gsi, tree x)\n    ADDR is the address to save.\n    STMT is the statement before which to place it.  */\n static void\n-tm_log_emit_stmt (tree addr, gimple stmt)\n+tm_log_emit_stmt (tree addr, gimple *stmt)\n {\n   tree type = TREE_TYPE (addr);\n   tree size = TYPE_SIZE_UNIT (type);\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-  gimple log;\n+  gimple *log;\n   enum built_in_function code = BUILT_IN_TM_LOG;\n \n   if (type == float_type_node)\n@@ -1250,7 +1250,7 @@ tm_log_emit (void)\n   FOR_EACH_HASH_TABLE_ELEMENT (*tm_log, lp, tm_log_entry_t, hi)\n     {\n       size_t i;\n-      gimple stmt;\n+      gimple *stmt;\n \n       if (dump_file)\n \t{\n@@ -1283,7 +1283,7 @@ tm_log_emit_saves (basic_block entry_block, basic_block bb)\n {\n   size_t i;\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  gimple stmt;\n+  gimple *stmt;\n   struct tm_log_entry l, *lp;\n \n   for (i = 0; i < tm_log_save_addresses.length (); ++i)\n@@ -1320,7 +1320,7 @@ tm_log_emit_restores (basic_block entry_block, basic_block bb)\n   int i;\n   struct tm_log_entry l, *lp;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n \n   for (i = tm_log_save_addresses.length () - 1; i >= 0; i--)\n     {\n@@ -1360,7 +1360,7 @@ static tree lower_sequence_no_tm (gimple_stmt_iterator *, bool *,\n static enum thread_memory_type\n thread_private_new_memory (basic_block entry_block, tree x)\n {\n-  gimple stmt = NULL;\n+  gimple *stmt = NULL;\n   enum tree_code code;\n   tm_new_mem_map_t **slot;\n   tm_new_mem_map_t elt, *elt_p;\n@@ -1492,7 +1492,7 @@ thread_private_new_memory (basic_block entry_block, tree x)\n    private memory instrumentation.  If no TPM instrumentation is\n    desired, STMT should be null.  */\n static bool\n-requires_barrier (basic_block entry_block, tree x, gimple stmt)\n+requires_barrier (basic_block entry_block, tree x, gimple *stmt)\n {\n   tree orig = x;\n   while (handled_component_p (x))\n@@ -1577,7 +1577,7 @@ requires_barrier (basic_block entry_block, tree x, gimple stmt)\n static void\n examine_assign_tm (unsigned *state, gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (requires_barrier (/*entry_block=*/NULL, gimple_assign_rhs1 (stmt), NULL))\n     *state |= GTMA_HAVE_LOAD;\n@@ -1590,7 +1590,7 @@ examine_assign_tm (unsigned *state, gimple_stmt_iterator *gsi)\n static void\n examine_call_tm (unsigned *state, gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree fn;\n \n   if (is_tm_pure_call (stmt))\n@@ -1610,7 +1610,7 @@ examine_call_tm (unsigned *state, gimple_stmt_iterator *gsi)\n static void\n lower_transaction (gimple_stmt_iterator *gsi, struct walk_stmt_info *wi)\n {\n-  gimple g;\n+  gimple *g;\n   gtransaction *stmt = as_a <gtransaction *> (gsi_stmt (*gsi));\n   unsigned int *outer_state = (unsigned int *) wi->info;\n   unsigned int this_state = 0;\n@@ -1694,7 +1694,7 @@ lower_sequence_tm (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t   struct walk_stmt_info *wi)\n {\n   unsigned int *state = (unsigned int *) wi->info;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   *handled_ops_p = true;\n   switch (gimple_code (stmt))\n@@ -1732,7 +1732,7 @@ static tree\n lower_sequence_no_tm (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t      struct walk_stmt_info * wi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (gimple_code (stmt) == GIMPLE_TRANSACTION)\n     {\n@@ -1836,7 +1836,7 @@ struct tm_region\n      After TM_MARK, this gets replaced by a call to\n      BUILT_IN_TM_START.\n      Hence this will be either a gtransaction *or a gcall *.  */\n-  gimple transaction_stmt;\n+  gimple *transaction_stmt;\n \n   /* After TM_MARK expands the GIMPLE_TRANSACTION into a call to\n      BUILT_IN_TM_START, this field is true if the transaction is an\n@@ -1923,7 +1923,7 @@ static struct tm_region *\n tm_region_init_1 (struct tm_region *region, basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n-  gimple g;\n+  gimple *g;\n \n   if (!region\n       || (!region->irr_blocks && !region->exit_blocks))\n@@ -1963,7 +1963,7 @@ tm_region_init_1 (struct tm_region *region, basic_block bb)\n static void\n tm_region_init (struct tm_region *region)\n {\n-  gimple g;\n+  gimple *g;\n   edge_iterator ei;\n   edge e;\n   basic_block bb;\n@@ -2171,7 +2171,7 @@ build_tm_load (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n     }\n   else\n     {\n-      gimple g;\n+      gimple *g;\n       tree temp;\n \n       temp = create_tmp_reg (t);\n@@ -2249,7 +2249,7 @@ build_tm_store (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n     }\n   else if (!useless_type_conversion_p (simple_type, type))\n     {\n-      gimple g;\n+      gimple *g;\n       tree temp;\n \n       temp = create_tmp_reg (simple_type);\n@@ -2275,13 +2275,13 @@ build_tm_store (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n static void\n expand_assign_tm (struct tm_region *region, gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   location_t loc = gimple_location (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n   tree rhs = gimple_assign_rhs1 (stmt);\n   bool store_p = requires_barrier (region->entry_block, lhs, NULL);\n   bool load_p = requires_barrier (region->entry_block, rhs, NULL);\n-  gimple gcall = NULL;\n+  gimple *gcall = NULL;\n \n   if (!load_p && !store_p)\n     {\n@@ -2504,7 +2504,7 @@ expand_block_tm (struct tm_region *region, basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_ASSIGN:\n@@ -2786,7 +2786,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n \n       tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_RESTORELIVEVARIABLES);\n-      gimple stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n+      gimple *stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n       gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n@@ -2826,7 +2826,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n \n       tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_ABORTTRANSACTION);\n-      gimple stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n+      gimple *stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n       gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n@@ -2868,7 +2868,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_RUNUNINSTRUMENTEDCODE);\n \n-      gimple stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n+      gimple *stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n       gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n@@ -3072,7 +3072,7 @@ make_pass_tm_mark (gcc::context *ctxt)\n    as necessary.  Adjust *PNEXT as needed for the split block.  */\n \n static inline void\n-split_bb_make_tm_edge (gimple stmt, basic_block dest_bb,\n+split_bb_make_tm_edge (gimple *stmt, basic_block dest_bb,\n                        gimple_stmt_iterator iter, gimple_stmt_iterator *pnext)\n {\n   basic_block bb = gimple_bb (stmt);\n@@ -3119,7 +3119,7 @@ expand_block_edges (struct tm_region *const region, basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi = next_gsi)\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       gcall *call_stmt;\n \n       next_gsi = gsi;\n@@ -3401,7 +3401,7 @@ static hash_table<tm_memop_hasher> *tm_memopt_value_numbers;\n    it accesses.  */\n \n static unsigned int\n-tm_memopt_value_number (gimple stmt, enum insert_option op)\n+tm_memopt_value_number (gimple *stmt, enum insert_option op)\n {\n   struct tm_memop tmpmem, *mem;\n   tm_memop **slot;\n@@ -3432,7 +3432,7 @@ tm_memopt_accumulate_memops (basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       bitmap bits;\n       unsigned int loc;\n \n@@ -3773,7 +3773,7 @@ tm_memopt_compute_antic (struct tm_region *region,\n /* Inform about a load/store optimization.  */\n \n static void\n-dump_tm_memopt_transform (gimple stmt)\n+dump_tm_memopt_transform (gimple *stmt)\n {\n   if (dump_file)\n     {\n@@ -3817,7 +3817,7 @@ tm_memopt_transform_blocks (vec<basic_block> blocks)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  bitmap read_avail = READ_AVAIL_IN (bb);\n \t  bitmap store_avail = STORE_AVAIL_IN (bb);\n \t  bitmap store_antic = STORE_ANTIC_OUT (bb);\n@@ -4123,7 +4123,7 @@ static void\n ipa_uninstrument_transaction (struct tm_region *region,\n \t\t\t      vec<basic_block> queue)\n {\n-  gimple transaction = region->transaction_stmt;\n+  gimple *transaction = region->transaction_stmt;\n   basic_block transaction_bb = gimple_bb (transaction);\n   int n = queue.length ();\n   basic_block *new_bbs = XNEWVEC (basic_block, n);\n@@ -4152,7 +4152,7 @@ ipa_tm_scan_calls_block (cgraph_node_queue *callees_p,\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (is_gimple_call (stmt) && !is_tm_pure_call (stmt))\n \t{\n \t  tree fndecl = gimple_call_fndecl (stmt);\n@@ -4292,7 +4292,7 @@ ipa_tm_scan_irr_block (basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_ASSIGN:\n@@ -4492,7 +4492,7 @@ ipa_tm_decrement_clone_counts (basic_block bb, bool for_clone)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (is_gimple_call (stmt) && !is_tm_pure_call (stmt))\n \t{\n \t  tree fndecl = gimple_call_fndecl (stmt);\n@@ -4723,7 +4723,7 @@ ipa_tm_diagnose_transaction (struct cgraph_node *node,\n \tfor (i = 0; bbs.iterate (i, &bb); ++i)\n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \t      tree fndecl;\n \n \t      if (gimple_code (stmt) == GIMPLE_ASM)\n@@ -5201,7 +5201,7 @@ ipa_tm_transform_calls_1 (struct cgraph_node *node, struct tm_region *region,\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       if (!is_gimple_call (stmt))\n \tcontinue;"}, {"sha": "aba59eacd8ea637f3685fd36535a5d2fda5523ab", "filename": "gcc/trans-mem.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftrans-mem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftrans-mem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -40,7 +40,7 @@\n #define PR_READONLY\t\t0x4000\n \n extern void compute_transaction_bits (void);\n-extern bool is_tm_ending (gimple);\n+extern bool is_tm_ending (gimple *);\n extern tree build_tm_abort_call (location_t, bool);\n extern bool is_tm_safe (const_tree);\n extern bool is_tm_pure (const_tree);"}, {"sha": "3401b3187a30de0181039b20a3902a083fc1e21a", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -634,7 +634,7 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n   unsigned i;\n   aff_tree to_add, current, curre;\n   tree e, rhs;\n-  gimple def;\n+  gimple *def;\n   widest_int scale;\n   struct name_expansion *exp;\n "}, {"sha": "e872eda018937284784fdd226e4cfbd01d804b88", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -211,7 +211,7 @@ check_pow (gcall *pow_call)\n   else if (bc == SSA_NAME)\n     {\n       tree base_val0, type;\n-      gimple base_def;\n+      gimple *base_def;\n       int bit_sz;\n \n       /* Only handles cases where base value is converted\n@@ -325,7 +325,7 @@ gen_one_condition (tree arg, int lbub,\n                    enum tree_code tcode,\n                    const char *temp_name1,\n \t\t   const char *temp_name2,\n-                   vec<gimple> conds,\n+\t\t   vec<gimple *> conds,\n                    unsigned *nconds)\n {\n   tree lbub_real_cst, lbub_cst, float_type;\n@@ -369,7 +369,7 @@ gen_one_condition (tree arg, int lbub,\n \n static void\n gen_conditions_for_domain (tree arg, inp_domain domain,\n-                           vec<gimple> conds,\n+\t\t\t   vec<gimple *> conds,\n                            unsigned *nconds)\n {\n   if (domain.has_lb)\n@@ -412,7 +412,7 @@ gen_conditions_for_domain (tree arg, inp_domain domain,\n \n static void\n gen_conditions_for_pow_cst_base (tree base, tree expn,\n-                                 vec<gimple> conds,\n+\t\t\t\t vec<gimple *> conds,\n                                  unsigned *nconds)\n {\n   inp_domain exp_domain;\n@@ -448,15 +448,15 @@ gen_conditions_for_pow_cst_base (tree base, tree expn,\n \n static void\n gen_conditions_for_pow_int_base (tree base, tree expn,\n-                                 vec<gimple> conds,\n+\t\t\t\t vec<gimple *> conds,\n                                  unsigned *nconds)\n {\n-  gimple base_def;\n+  gimple *base_def;\n   tree base_val0;\n   tree int_type;\n   tree temp, tempn;\n   tree cst0;\n-  gimple stmt1, stmt2;\n+  gimple *stmt1, *stmt2;\n   int bit_sz, max_exp;\n   inp_domain exp_domain;\n \n@@ -537,7 +537,7 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n    and *NCONDS is the number of logical conditions.  */\n \n static void\n-gen_conditions_for_pow (gcall *pow_call, vec<gimple> conds,\n+gen_conditions_for_pow (gcall *pow_call, vec<gimple *> conds,\n                         unsigned *nconds)\n {\n   tree base, expn;\n@@ -673,7 +673,7 @@ get_no_error_domain (enum built_in_function fnc)\n    condition are separated by NULL tree in the vector.  */\n \n static void\n-gen_shrink_wrap_conditions (gcall *bi_call, vec<gimple> conds,\n+gen_shrink_wrap_conditions (gcall *bi_call, vec<gimple *> conds,\n                             unsigned int *nconds)\n {\n   gcall *call;\n@@ -722,12 +722,12 @@ shrink_wrap_one_built_in_call (gcall *bi_call)\n   edge bi_call_in_edge0, guard_bb_in_edge;\n   unsigned tn_cond_stmts, nconds;\n   unsigned ci;\n-  gimple cond_expr = NULL;\n-  gimple cond_expr_start;\n+  gimple *cond_expr = NULL;\n+  gimple *cond_expr_start;\n   tree bi_call_label_decl;\n-  gimple bi_call_label;\n+  gimple *bi_call_label;\n \n-  auto_vec<gimple, 12> conds;\n+  auto_vec<gimple *, 12> conds;\n   gen_shrink_wrap_conditions (bi_call, conds, &nconds);\n \n   /* This can happen if the condition generator decides\n@@ -763,7 +763,7 @@ shrink_wrap_one_built_in_call (gcall *bi_call)\n   cond_expr_start = conds[0];\n   for (ci = 0; ci < tn_cond_stmts; ci++)\n     {\n-      gimple c = conds[ci];\n+      gimple *c = conds[ci];\n       gcc_assert (c || ci != 0);\n       if (!c)\n         break;\n@@ -807,7 +807,7 @@ shrink_wrap_one_built_in_call (gcall *bi_call)\n       cond_expr_start = conds[ci0];\n       for (; ci < tn_cond_stmts; ci++)\n         {\n-          gimple c = conds[ci];\n+\t  gimple *c = conds[ci];\n           gcc_assert (c || ci != ci0);\n           if (!c)\n             break;"}, {"sha": "807d96f8f760e2dcfb13512d6a0ee55c9c0f3419", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -168,12 +168,12 @@ static edge gimple_redirect_edge_and_branch (edge, basic_block);\n static edge gimple_try_redirect_by_replacing_jump (edge, basic_block);\n \n /* Various helpers.  */\n-static inline bool stmt_starts_bb_p (gimple, gimple);\n+static inline bool stmt_starts_bb_p (gimple *, gimple *);\n static int gimple_verify_flow_info (void);\n static void gimple_make_forwarder_block (edge);\n-static gimple first_non_label_stmt (basic_block);\n+static gimple *first_non_label_stmt (basic_block);\n static bool verify_gimple_transaction (gtransaction *);\n-static bool call_can_make_abnormal_goto (gimple);\n+static bool call_can_make_abnormal_goto (gimple *);\n \n /* Flowgraph optimization and cleanup.  */\n static void gimple_merge_blocks (basic_block, basic_block);\n@@ -270,7 +270,7 @@ static void\n replace_loop_annotate_in_block (basic_block bb, struct loop *loop)\n {\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  gimple stmt = gsi_stmt (gsi);\n+  gimple *stmt = gsi_stmt (gsi);\n \n   if (!(stmt && gimple_code (stmt) == GIMPLE_COND))\n     return;\n@@ -316,7 +316,7 @@ replace_loop_annotate (void)\n   struct loop *loop;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n \n   FOR_EACH_LOOP (loop, 0)\n     {\n@@ -416,7 +416,7 @@ make_pass_build_cfg (gcc::context *ctxt)\n /* Return true if T is a computed goto.  */\n \n bool\n-computed_goto_p (gimple t)\n+computed_goto_p (gimple *t)\n {\n   return (gimple_code (t) == GIMPLE_GOTO\n \t  && TREE_CODE (gimple_goto_dest (t)) != LABEL_DECL);\n@@ -439,7 +439,7 @@ bool\n assert_unreachable_fallthru_edge_p (edge e)\n {\n   basic_block pred_bb = e->src;\n-  gimple last = last_stmt (pred_bb);\n+  gimple *last = last_stmt (pred_bb);\n   if (last && gimple_code (last) == GIMPLE_COND)\n     {\n       basic_block other_bb = EDGE_SUCC (pred_bb, 0)->dest;\n@@ -448,7 +448,7 @@ assert_unreachable_fallthru_edge_p (edge e)\n       if (EDGE_COUNT (other_bb->succs) == 0)\n \t{\n \t  gimple_stmt_iterator gsi = gsi_after_labels (other_bb);\n-\t  gimple stmt;\n+\t  gimple *stmt;\n \n \t  if (gsi_end_p (gsi))\n \t    return false;\n@@ -472,7 +472,7 @@ assert_unreachable_fallthru_edge_p (edge e)\n    CFG build time and only ever clear it later.  */\n \n static void\n-gimple_call_initialize_ctrl_altering (gimple stmt)\n+gimple_call_initialize_ctrl_altering (gimple *stmt)\n {\n   int flags = gimple_call_flags (stmt);\n \n@@ -499,13 +499,13 @@ static basic_block\n make_blocks_1 (gimple_seq seq, basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start (seq);\n-  gimple stmt = NULL;\n+  gimple *stmt = NULL;\n   bool start_new_block = true;\n   bool first_stmt_of_seq = true;\n \n   while (!gsi_end_p (i))\n     {\n-      gimple prev_stmt;\n+      gimple *prev_stmt;\n \n       prev_stmt = stmt;\n       stmt = gsi_stmt (i);\n@@ -543,7 +543,7 @@ make_blocks_1 (gimple_seq seq, basic_block bb)\n \t    {\n \t      tree lhs = gimple_get_lhs (stmt);\n \t      tree tmp = create_tmp_var (TREE_TYPE (lhs));\n-\t      gimple s = gimple_build_assign (lhs, tmp);\n+\t      gimple *s = gimple_build_assign (lhs, tmp);\n \t      gimple_set_location (s, gimple_location (stmt));\n \t      gimple_set_block (s, gimple_block (stmt));\n \t      gimple_set_lhs (stmt, tmp);\n@@ -629,7 +629,7 @@ get_abnormal_succ_dispatcher (basic_block bb)\n       {\n \tgimple_stmt_iterator gsi\n \t  = gsi_start_nondebug_after_labels_bb (e->dest);\n-\tgimple g = gsi_stmt (gsi);\n+\tgimple *g = gsi_stmt (gsi);\n \tif (g\n \t    && is_gimple_call (g)\n \t    && gimple_call_internal_p (g)\n@@ -701,12 +701,12 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n \t     factored computed goto.  */\n \t  tree factored_label_decl\n \t    = create_artificial_label (UNKNOWN_LOCATION);\n-\t  gimple factored_computed_goto_label\n+\t  gimple *factored_computed_goto_label\n \t    = gimple_build_label (factored_label_decl);\n \t  gsi_insert_after (&gsi, factored_computed_goto_label, GSI_NEW_STMT);\n \n \t  /* Build our new computed goto.  */\n-\t  gimple factored_computed_goto = gimple_build_goto (var);\n+\t  gimple *factored_computed_goto = gimple_build_goto (var);\n \t  gsi_insert_after (&gsi, factored_computed_goto, GSI_NEW_STMT);\n \n \t  FOR_EACH_VEC_ELT (*bbs, idx, bb)\n@@ -716,12 +716,12 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n \t\tcontinue;\n \n \t      gsi = gsi_last_bb (bb);\n-\t      gimple last = gsi_stmt (gsi);\n+\t      gimple *last = gsi_stmt (gsi);\n \n \t      gcc_assert (computed_goto_p (last));\n \n \t      /* Copy the original computed goto's destination into VAR.  */\n-\t      gimple assignment\n+\t      gimple *assignment\n \t\t= gimple_build_assign (var, gimple_goto_dest (last));\n \t      gsi_insert_before (&gsi, assignment, GSI_SAME_STMT);\n \n@@ -733,7 +733,7 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n       else\n \t{\n \t  tree arg = inner ? boolean_true_node : boolean_false_node;\n-\t  gimple g = gimple_build_call_internal (IFN_ABNORMAL_DISPATCHER,\n+\t  gimple *g = gimple_build_call_internal (IFN_ABNORMAL_DISPATCHER,\n \t\t\t\t\t\t 1, arg);\n \t  gimple_stmt_iterator gsi = gsi_after_labels (*dispatcher);\n \t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n@@ -760,7 +760,7 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n static int\n make_edges_bb (basic_block bb, struct omp_region **pcur_region, int *pomp_index)\n {\n-  gimple last = last_stmt (bb);\n+  gimple *last = last_stmt (bb);\n   bool fallthru = false;\n   int ret = 0;\n \n@@ -949,7 +949,7 @@ make_edges (void)\n \t  if (!gsi_end_p (gsi))\n \t    {\n \t      /* Make an edge to every setjmp-like call.  */\n-\t      gimple call_stmt = gsi_stmt (gsi);\n+\t      gimple *call_stmt = gsi_stmt (gsi);\n \t      if (is_gimple_call (call_stmt)\n \t\t  && ((gimple_call_flags (call_stmt) & ECF_RETURNS_TWICE)\n \t\t      || gimple_call_builtin_p (call_stmt,\n@@ -978,7 +978,7 @@ make_edges (void)\n bool\n gimple_find_sub_bbs (gimple_seq seq, gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   basic_block bb = gimple_bb (stmt);\n   basic_block lastbb, afterbb;\n   int old_num_bbs = n_basic_blocks_for_fn (cfun);\n@@ -1065,16 +1065,16 @@ assign_discriminators (void)\n     {\n       edge e;\n       edge_iterator ei;\n-      gimple last = last_stmt (bb);\n+      gimple *last = last_stmt (bb);\n       location_t locus = last ? gimple_location (last) : UNKNOWN_LOCATION;\n \n       if (locus == UNKNOWN_LOCATION)\n \tcontinue;\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  gimple first = first_non_label_stmt (e->dest);\n-\t  gimple last = last_stmt (e->dest);\n+\t  gimple *first = first_non_label_stmt (e->dest);\n+\t  gimple *last = last_stmt (e->dest);\n \t  if ((first && same_line_p (locus, gimple_location (first)))\n \t      || (last && same_line_p (locus, gimple_location (last))))\n \t    {\n@@ -1093,7 +1093,7 @@ static void\n make_cond_expr_edges (basic_block bb)\n {\n   gcond *entry = as_a <gcond *> (last_stmt (bb));\n-  gimple then_stmt, else_stmt;\n+  gimple *then_stmt, *else_stmt;\n   basic_block then_bb, else_bb;\n   tree then_label, else_label;\n   edge e;\n@@ -1175,7 +1175,7 @@ end_recording_case_labels (void)\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       if (bb)\n \t{\n-\t  gimple stmt = last_stmt (bb);\n+\t  gimple *stmt = last_stmt (bb);\n \t  if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n \t    group_case_labels_stmt (as_a <gswitch *> (stmt));\n \t}\n@@ -1257,7 +1257,7 @@ label_to_block_fn (struct function *ifun, tree dest)\n     {\n       gimple_stmt_iterator gsi =\n \tgsi_start_bb (BASIC_BLOCK_FOR_FN (cfun, NUM_FIXED_BLOCKS));\n-      gimple stmt;\n+      gimple *stmt;\n \n       stmt = gimple_build_label (dest);\n       gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n@@ -1275,7 +1275,7 @@ static bool\n make_goto_expr_edges (basic_block bb)\n {\n   gimple_stmt_iterator last = gsi_last_bb (bb);\n-  gimple goto_t = gsi_stmt (last);\n+  gimple *goto_t = gsi_stmt (last);\n \n   /* A simple GOTO creates normal edges.  */\n   if (simple_goto_p (goto_t))\n@@ -1452,7 +1452,7 @@ cleanup_dead_labels (void)\n      First do so for each block ending in a control statement.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple stmt = last_stmt (bb);\n+      gimple *stmt = last_stmt (bb);\n       tree label, new_label;\n \n       if (!stmt)\n@@ -1675,7 +1675,7 @@ group_case_labels (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      gimple stmt = last_stmt (bb);\n+      gimple *stmt = last_stmt (bb);\n       if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n \tgroup_case_labels_stmt (as_a <gswitch *> (stmt));\n     }\n@@ -1686,7 +1686,7 @@ group_case_labels (void)\n static bool\n gimple_can_merge_blocks_p (basic_block a, basic_block b)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (!single_succ_p (a))\n     return false;\n@@ -1780,7 +1780,7 @@ replace_uses_by (tree name, tree val)\n {\n   imm_use_iterator imm_iter;\n   use_operand_p use;\n-  gimple stmt;\n+  gimple *stmt;\n   edge e;\n \n   FOR_EACH_IMM_USE_STMT (stmt, imm_iter, name)\n@@ -1813,7 +1813,7 @@ replace_uses_by (tree name, tree val)\n       if (gimple_code (stmt) != GIMPLE_PHI)\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\t  gimple orig_stmt = stmt;\n+\t  gimple *orig_stmt = stmt;\n \t  size_t i;\n \n \t  /* FIXME.  It shouldn't be required to keep TREE_CONSTANT\n@@ -1871,9 +1871,9 @@ gimple_merge_blocks (basic_block a, basic_block b)\n   gsi = gsi_last_bb (a);\n   for (psi = gsi_start_phis (b); !gsi_end_p (psi); )\n     {\n-      gimple phi = gsi_stmt (psi);\n+      gimple *phi = gsi_stmt (psi);\n       tree def = gimple_phi_result (phi), use = gimple_phi_arg_def (phi, 0);\n-      gimple copy;\n+      gimple *copy;\n       bool may_replace_uses = (virtual_operand_p (def)\n \t\t\t       || may_propagate_copy (def, use));\n \n@@ -1907,7 +1907,7 @@ gimple_merge_blocks (basic_block a, basic_block b)\n \t    {\n \t      imm_use_iterator iter;\n \t      use_operand_p use_p;\n-\t      gimple stmt;\n+\t      gimple *stmt;\n \n \t      FOR_EACH_IMM_USE_STMT (stmt, iter, def)\n \t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n@@ -1932,7 +1932,7 @@ gimple_merge_blocks (basic_block a, basic_block b)\n   /* Remove labels from B and set gimple_bb to A for other statements.  */\n   for (gsi = gsi_start_bb (b); !gsi_end_p (gsi);)\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n \t{\n \t  tree label = gimple_label_label (label_stmt);\n@@ -1954,9 +1954,9 @@ gimple_merge_blocks (basic_block a, basic_block b)\n \t  /* Other user labels keep around in a form of a debug stmt.  */\n \t  else if (!DECL_ARTIFICIAL (label) && MAY_HAVE_DEBUG_STMTS)\n \t    {\n-\t      gimple dbg = gimple_build_debug_bind (label,\n-\t\t\t\t\t\t    integer_zero_node,\n-\t\t\t\t\t\t    stmt);\n+\t      gimple *dbg = gimple_build_debug_bind (label,\n+\t\t\t\t\t\t     integer_zero_node,\n+\t\t\t\t\t\t     stmt);\n \t      gimple_debug_bind_reset_value (dbg);\n \t      gsi_insert_before (&gsi, dbg, GSI_SAME_STMT);\n \t    }\n@@ -2092,7 +2092,7 @@ remove_bb (basic_block bb)\n \t details.  */\n       for (i = gsi_last_bb (bb); !gsi_end_p (i);)\n \t{\n-\t  gimple stmt = gsi_stmt (i);\n+\t  gimple *stmt = gsi_stmt (i);\n \t  glabel *label_stmt = dyn_cast <glabel *> (stmt);\n \t  if (label_stmt\n \t      && (FORCED_LABEL (gimple_label_label (label_stmt))\n@@ -2147,7 +2147,7 @@ remove_bb (basic_block bb)\n edge\n find_taken_edge (basic_block bb, tree val)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   stmt = last_stmt (bb);\n \n@@ -2405,7 +2405,7 @@ debug_cfg_stats (void)\n    flow.  Transfers of control flow associated with EH are excluded.  */\n \n static bool\n-call_can_make_abnormal_goto (gimple t)\n+call_can_make_abnormal_goto (gimple *t)\n {\n   /* If the function has no non-local labels, then a call cannot make an\n      abnormal transfer of control.  */\n@@ -2429,7 +2429,7 @@ call_can_make_abnormal_goto (gimple t)\n    Transfers of control flow associated with EH are excluded.  */\n \n bool\n-stmt_can_make_abnormal_goto (gimple t)\n+stmt_can_make_abnormal_goto (gimple *t)\n {\n   if (computed_goto_p (t))\n     return true;\n@@ -2442,7 +2442,7 @@ stmt_can_make_abnormal_goto (gimple t)\n /* Return true if T represents a stmt that always transfers control.  */\n \n bool\n-is_ctrl_stmt (gimple t)\n+is_ctrl_stmt (gimple *t)\n {\n   switch (gimple_code (t))\n     {\n@@ -2462,7 +2462,7 @@ is_ctrl_stmt (gimple t)\n    (e.g., a call to a non-returning function).  */\n \n bool\n-is_ctrl_altering_stmt (gimple t)\n+is_ctrl_altering_stmt (gimple *t)\n {\n   gcc_assert (t);\n \n@@ -2506,7 +2506,7 @@ is_ctrl_altering_stmt (gimple t)\n /* Return true if T is a simple local goto.  */\n \n bool\n-simple_goto_p (gimple t)\n+simple_goto_p (gimple *t)\n {\n   return (gimple_code (t) == GIMPLE_GOTO\n \t  && TREE_CODE (gimple_goto_dest (t)) == LABEL_DECL);\n@@ -2521,7 +2521,7 @@ simple_goto_p (gimple t)\n    label.  */\n \n static inline bool\n-stmt_starts_bb_p (gimple stmt, gimple prev_stmt)\n+stmt_starts_bb_p (gimple *stmt, gimple *prev_stmt)\n {\n   if (stmt == NULL)\n     return false;\n@@ -2561,7 +2561,7 @@ stmt_starts_bb_p (gimple stmt, gimple prev_stmt)\n /* Return true if T should end a basic block.  */\n \n bool\n-stmt_ends_bb_p (gimple t)\n+stmt_ends_bb_p (gimple *t)\n {\n   return is_ctrl_stmt (t) || is_ctrl_altering_stmt (t);\n }\n@@ -2594,11 +2594,11 @@ get_virtual_phi (basic_block bb)\n \n /* Return the first statement in basic block BB.  */\n \n-gimple\n+gimple *\n first_stmt (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start_bb (bb);\n-  gimple stmt = NULL;\n+  gimple *stmt = NULL;\n \n   while (!gsi_end_p (i) && is_gimple_debug ((stmt = gsi_stmt (i))))\n     {\n@@ -2610,7 +2610,7 @@ first_stmt (basic_block bb)\n \n /* Return the first non-label statement in basic block BB.  */\n \n-static gimple\n+static gimple *\n first_non_label_stmt (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start_bb (bb);\n@@ -2621,11 +2621,11 @@ first_non_label_stmt (basic_block bb)\n \n /* Return the last statement in basic block BB.  */\n \n-gimple\n+gimple *\n last_stmt (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_last_bb (bb);\n-  gimple stmt = NULL;\n+  gimple *stmt = NULL;\n \n   while (!gsi_end_p (i) && is_gimple_debug ((stmt = gsi_stmt (i))))\n     {\n@@ -2639,11 +2639,11 @@ last_stmt (basic_block bb)\n    if the block is totally empty, or if it contains more than one\n    statement.  */\n \n-gimple\n+gimple *\n last_and_only_stmt (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_last_nondebug_bb (bb);\n-  gimple last, prev;\n+  gimple *last, *prev;\n \n   if (gsi_end_p (i))\n     return NULL;\n@@ -4483,7 +4483,7 @@ verify_gimple_switch (gswitch *stmt)\n    Returns true if anything is wrong.  */\n \n static bool\n-verify_gimple_debug (gimple stmt ATTRIBUTE_UNUSED)\n+verify_gimple_debug (gimple *stmt ATTRIBUTE_UNUSED)\n {\n   /* There isn't much that could be wrong in a gimple debug stmt.  A\n      gimple debug bind stmt, for example, maps a tree, that's usually\n@@ -4565,7 +4565,7 @@ verify_gimple_cond (gcond *stmt)\n    error, otherwise false.  */\n \n static bool\n-verify_gimple_stmt (gimple stmt)\n+verify_gimple_stmt (gimple *stmt)\n {\n   switch (gimple_code (stmt))\n     {\n@@ -4625,7 +4625,7 @@ verify_gimple_stmt (gimple stmt)\n    and false otherwise.  */\n \n static bool\n-verify_gimple_phi (gimple phi)\n+verify_gimple_phi (gimple *phi)\n {\n   bool err = false;\n   unsigned i;\n@@ -4695,7 +4695,7 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n \n   for (ittr = gsi_start (stmts); !gsi_end_p (ittr); gsi_next (&ittr))\n     {\n-      gimple stmt = gsi_stmt (ittr);\n+      gimple *stmt = gsi_stmt (ittr);\n \n       switch (gimple_code (stmt))\n         {\n@@ -4818,8 +4818,8 @@ verify_node_sharing (tree *tp, int *walk_subtrees, void *data)\n \n static bool eh_error_found;\n bool\n-verify_eh_throw_stmt_node (const gimple &stmt, const int &,\n-\t\t\t   hash_set<gimple> *visited)\n+verify_eh_throw_stmt_node (gimple *const &stmt, const int &,\n+\t\t\t   hash_set<gimple *> *visited)\n {\n   if (!visited->contains (stmt))\n     {\n@@ -4936,7 +4936,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \n   timevar_push (TV_TREE_STMT_VERIFY);\n   hash_set<void *> visited;\n-  hash_set<gimple> visited_stmts;\n+  hash_set<gimple *> visited_stmts;\n \n   /* Collect all BLOCKs referenced by the BLOCK tree of FN.  */\n   hash_set<tree> blocks;\n@@ -5009,7 +5009,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  bool err2 = false;\n \t  struct walk_stmt_info wi;\n \t  tree addr;\n@@ -5090,9 +5090,9 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n     }\n \n   eh_error_found = false;\n-  hash_map<gimple, int> *eh_table = get_eh_throw_stmt_table (cfun);\n+  hash_map<gimple *, int> *eh_table = get_eh_throw_stmt_table (cfun);\n   if (eh_table)\n-    eh_table->traverse<hash_set<gimple> *, verify_eh_throw_stmt_node>\n+    eh_table->traverse<hash_set<gimple *> *, verify_eh_throw_stmt_node>\n       (&visited_stmts);\n \n   if (err || eh_error_found)\n@@ -5111,7 +5111,7 @@ gimple_verify_flow_info (void)\n   int err = 0;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   edge e;\n   edge_iterator ei;\n \n@@ -5146,7 +5146,7 @@ gimple_verify_flow_info (void)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  tree label;\n-\t  gimple prev_stmt = stmt;\n+\t  gimple *prev_stmt = stmt;\n \n \t  stmt = gsi_stmt (gsi);\n \n@@ -5194,7 +5194,7 @@ gimple_verify_flow_info (void)\n       /* Verify that body of basic block BB is free of control flow.  */\n       for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  if (found_ctrl_stmt)\n \t    {\n@@ -5502,7 +5502,7 @@ gimple_try_redirect_by_replacing_jump (edge e, basic_block target)\n {\n   basic_block src = e->src;\n   gimple_stmt_iterator i;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* We can replace or remove a complex jump only when we have exactly\n      two edges.  */\n@@ -5539,7 +5539,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n   basic_block bb = e->src;\n   gimple_stmt_iterator gsi;\n   edge ret;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (e->flags & EDGE_ABNORMAL)\n     return NULL;\n@@ -5727,11 +5727,11 @@ gimple_split_block (basic_block bb, void *stmt)\n     e->src = new_bb;\n \n   /* Get a stmt iterator pointing to the first stmt to move.  */\n-  if (!stmt || gimple_code ((gimple) stmt) == GIMPLE_LABEL)\n+  if (!stmt || gimple_code ((gimple *) stmt) == GIMPLE_LABEL)\n     gsi = gsi_after_labels (bb);\n   else\n     {\n-      gsi = gsi_for_stmt ((gimple) stmt);\n+      gsi = gsi_for_stmt ((gimple *) stmt);\n       gsi_next (&gsi);\n     }\n  \n@@ -5792,7 +5792,7 @@ gimple_empty_block_p (basic_block bb)\n static basic_block\n gimple_split_block_before_cond_jump (basic_block bb)\n {\n-  gimple last, split_point;\n+  gimple *last, *split_point;\n   gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n   if (gsi_end_p (gsi))\n     return NULL;\n@@ -5847,7 +5847,7 @@ gimple_duplicate_bb (basic_block bb)\n       def_operand_p def_p;\n       ssa_op_iter op_iter;\n       tree lhs;\n-      gimple stmt, copy;\n+      gimple *stmt, *copy;\n \n       stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) == GIMPLE_LABEL)\n@@ -6197,7 +6197,7 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   gcov_type total_count = 0, exit_count = 0;\n   edge exits[2], nexits[2], e;\n   gimple_stmt_iterator gsi;\n-  gimple cond_stmt;\n+  gimple *cond_stmt;\n   edge sorig, snew;\n   basic_block exit_bb;\n   gphi_iterator psi;\n@@ -6561,7 +6561,7 @@ move_stmt_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t     struct walk_stmt_info *wi)\n {\n   struct move_stmt_d *p = (struct move_stmt_d *) wi->info;\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   tree block = gimple_block (stmt);\n \n   if (block == p->orig_block\n@@ -6751,7 +6751,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n-      gimple stmt = gsi_stmt (si);\n+      gimple *stmt = gsi_stmt (si);\n       struct walk_stmt_info wi;\n \n       memset (&wi, 0, sizeof (wi));\n@@ -6818,7 +6818,7 @@ find_outermost_region_in_block (struct function *src_cfun,\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n-      gimple stmt = gsi_stmt (si);\n+      gimple *stmt = gsi_stmt (si);\n       eh_region stmt_region;\n       int lp_nr;\n \n@@ -7728,7 +7728,7 @@ gimple_block_ends_with_call_p (basic_block bb)\n static bool\n gimple_block_ends_with_condjump_p (const_basic_block bb)\n {\n-  gimple stmt = last_stmt (CONST_CAST_BB (bb));\n+  gimple *stmt = last_stmt (CONST_CAST_BB (bb));\n   return (stmt && gimple_code (stmt) == GIMPLE_COND);\n }\n \n@@ -7737,7 +7737,7 @@ gimple_block_ends_with_condjump_p (const_basic_block bb)\n    Helper function for gimple_flow_call_edges_add.  */\n \n static bool\n-need_fake_edge_p (gimple t)\n+need_fake_edge_p (gimple *t)\n {\n   tree fndecl = NULL_TREE;\n   int call_flags = 0;\n@@ -7833,7 +7833,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n     {\n       basic_block bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n       gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n-      gimple t = NULL;\n+      gimple *t = NULL;\n \n       if (!gsi_end_p (gsi))\n \tt = gsi_stmt (gsi);\n@@ -7858,7 +7858,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       gimple_stmt_iterator gsi;\n-      gimple stmt, last_stmt;\n+      gimple *stmt, *last_stmt;\n \n       if (!bb)\n \tcontinue;\n@@ -8053,7 +8053,7 @@ gimple_purge_dead_eh_edges (basic_block bb)\n   bool changed = false;\n   edge e;\n   edge_iterator ei;\n-  gimple stmt = last_stmt (bb);\n+  gimple *stmt = last_stmt (bb);\n \n   if (stmt && stmt_can_throw_internal (stmt))\n     return false;\n@@ -8103,7 +8103,7 @@ gimple_purge_dead_abnormal_call_edges (basic_block bb)\n   bool changed = false;\n   edge e;\n   edge_iterator ei;\n-  gimple stmt = last_stmt (bb);\n+  gimple *stmt = last_stmt (bb);\n \n   if (!cfun->has_nonlocal_label\n       && !cfun->calls_setjmp)\n@@ -8225,7 +8225,7 @@ gimple_lv_add_condition_to_bb (basic_block first_head ATTRIBUTE_UNUSED,\n \t\t\t       basic_block cond_bb, void *cond_e)\n {\n   gimple_stmt_iterator gsi;\n-  gimple new_cond_expr;\n+  gimple *new_cond_expr;\n   tree cond_expr = (tree) cond_e;\n   edge e0;\n \n@@ -8396,7 +8396,7 @@ make_pass_split_crit_edges (gcc::context *ctxt)\n    and creation of a new conditionally executed basic block.\n    Return created basic block.  */\n basic_block\n-insert_cond_bb (basic_block bb, gimple stmt, gimple cond)\n+insert_cond_bb (basic_block bb, gimple *stmt, gimple *cond)\n {\n   edge fall = split_block (bb, stmt);\n   gimple_stmt_iterator iter = gsi_last_bb (bb);\n@@ -8539,7 +8539,7 @@ unsigned int\n pass_warn_function_return::execute (function *fun)\n {\n   source_location location;\n-  gimple last;\n+  gimple *last;\n   edge e;\n   edge_iterator ei;\n \n@@ -8573,7 +8573,7 @@ pass_warn_function_return::execute (function *fun)\n     {\n       FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (fun)->preds)\n \t{\n-\t  gimple last = last_stmt (e->src);\n+\t  gimple *last = last_stmt (e->src);\n \t  greturn *return_stmt = dyn_cast <greturn *> (last);\n \t  if (return_stmt\n \t      && gimple_return_retval (return_stmt) == NULL\n@@ -8611,7 +8611,7 @@ do_warn_unused_result (gimple_seq seq)\n \n   for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple g = gsi_stmt (i);\n+      gimple *g = gsi_stmt (i);\n \n       switch (gimple_code (g))\n \t{\n@@ -8741,7 +8741,7 @@ execute_fixup_cfg (void)\n       bb->count = apply_scale (bb->count, count_scale);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree decl = is_gimple_call (stmt)\n \t\t      ? gimple_call_fndecl (stmt)\n \t\t      : NULL;\n@@ -8816,7 +8816,7 @@ execute_fixup_cfg (void)\n \t when inlining a noreturn call that does in fact return.  */\n       if (EDGE_COUNT (bb->succs) == 0)\n \t{\n-\t  gimple stmt = last_stmt (bb);\n+\t  gimple *stmt = last_stmt (bb);\n \t  if (!stmt\n \t      || (!is_ctrl_stmt (stmt)\n \t\t  && (!is_gimple_call (stmt)\n@@ -8880,7 +8880,7 @@ make_pass_fixup_cfg (gcc::context *ctxt)\n /* Garbage collection support for edge_def.  */\n \n extern void gt_ggc_mx (tree&);\n-extern void gt_ggc_mx (gimple&);\n+extern void gt_ggc_mx (gimple *&);\n extern void gt_ggc_mx (rtx&);\n extern void gt_ggc_mx (basic_block&);\n \n@@ -8907,7 +8907,7 @@ gt_ggc_mx (edge_def *e)\n /* PCH support for edge_def.  */\n \n extern void gt_pch_nx (tree&);\n-extern void gt_pch_nx (gimple&);\n+extern void gt_pch_nx (gimple *&);\n extern void gt_pch_nx (rtx&);\n extern void gt_pch_nx (basic_block&);\n "}, {"sha": "855077a8d7623fbbaa0a3749bea8f848e8901a4f", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -49,19 +49,19 @@ extern void gimple_debug_cfg (int);\n extern void gimple_dump_cfg (FILE *, int);\n extern void dump_cfg_stats (FILE *);\n extern void debug_cfg_stats (void);\n-extern bool computed_goto_p (gimple);\n-extern bool stmt_can_make_abnormal_goto (gimple);\n+extern bool computed_goto_p (gimple *);\n+extern bool stmt_can_make_abnormal_goto (gimple *);\n extern basic_block get_abnormal_succ_dispatcher (basic_block);\n-extern bool is_ctrl_stmt (gimple);\n-extern bool is_ctrl_altering_stmt (gimple);\n-extern bool simple_goto_p (gimple);\n-extern bool stmt_ends_bb_p (gimple);\n+extern bool is_ctrl_stmt (gimple *);\n+extern bool is_ctrl_altering_stmt (gimple *);\n+extern bool simple_goto_p (gimple *);\n+extern bool stmt_ends_bb_p (gimple *);\n extern bool assert_unreachable_fallthru_edge_p (edge);\n extern void delete_tree_cfg_annotations (void);\n extern gphi *get_virtual_phi (basic_block);\n-extern gimple first_stmt (basic_block);\n-extern gimple last_stmt (basic_block);\n-extern gimple last_and_only_stmt (basic_block);\n+extern gimple *first_stmt (basic_block);\n+extern gimple *last_stmt (basic_block);\n+extern gimple *last_and_only_stmt (basic_block);\n extern void verify_gimple_in_seq (gimple_seq);\n extern void verify_gimple_in_cfg (struct function *, bool);\n extern tree gimple_block_label (basic_block);\n@@ -103,7 +103,7 @@ extern tree gimplify_build1 (gimple_stmt_iterator *, enum tree_code,\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern unsigned int execute_fixup_cfg (void);\n extern unsigned int split_critical_edges (void);\n-extern basic_block insert_cond_bb (basic_block, gimple, gimple);\n+extern basic_block insert_cond_bb (basic_block, gimple *, gimple *);\n extern bool gimple_find_sub_bbs (gimple_seq, gimple_stmt_iterator *);\n \n #endif /* _TREE_CFG_H  */"}, {"sha": "40e14566ed1a3553bc7e8fa172f4e589246b8303", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -95,7 +95,7 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi)\n {\n   edge taken_edge;\n   bool retval = false;\n-  gimple stmt = gsi_stmt (gsi);\n+  gimple *stmt = gsi_stmt (gsi);\n   tree val;\n \n   if (!single_succ_p (bb))\n@@ -170,7 +170,7 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi)\n    to updated gimple_call_flags.  */\n \n static void\n-cleanup_call_ctrl_altering_flag (gimple bb_end)\n+cleanup_call_ctrl_altering_flag (gimple *bb_end)\n {\n   if (!is_gimple_call (bb_end)\n       || !gimple_call_ctrl_altering_p (bb_end))\n@@ -191,7 +191,7 @@ cleanup_control_flow_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   bool retval = false;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* If the last statement of the block could throw and now cannot,\n      we need to prune cfg.  */\n@@ -308,7 +308,7 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n      anything else means this is not a forwarder block.  */\n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       switch (gimple_code (stmt))\n \t{\n@@ -396,7 +396,7 @@ remove_forwarder_block (basic_block bb)\n {\n   edge succ = single_succ_edge (bb), e, s;\n   basic_block dest = succ->dest;\n-  gimple label;\n+  gimple *label;\n   edge_iterator ei;\n   gimple_stmt_iterator gsi, gsi_to;\n   bool can_move_debug_stmts;\n@@ -515,7 +515,7 @@ remove_forwarder_block (basic_block bb)\n       gsi_to = gsi_after_labels (dest);\n       for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); )\n \t{\n-\t  gimple debug = gsi_stmt (gsi);\n+\t  gimple *debug = gsi_stmt (gsi);\n \t  if (!is_gimple_debug (debug))\n \t    break;\n \t  gsi_remove (&gsi, false);\n@@ -560,7 +560,7 @@ remove_forwarder_block (basic_block bb)\n    Return true if cleanup-cfg needs to run.  */\n \n bool\n-fixup_noreturn_call (gimple stmt)\n+fixup_noreturn_call (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   bool changed = false;\n@@ -802,7 +802,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n {\n   edge succ = single_succ_edge (bb);\n   basic_block dest = succ->dest;\n-  gimple label;\n+  gimple *label;\n   basic_block dombb, domdest, dom;\n \n   /* We check for infinite loops already in tree_forwarder_block_p.\n@@ -1023,7 +1023,7 @@ pass_merge_phi::execute (function *fun)\n \t      gphi *phi = gsi.phi ();\n \t      tree result = gimple_phi_result (phi);\n \t      use_operand_p imm_use;\n-\t      gimple use_stmt;\n+\t      gimple *use_stmt;\n \n \t      /* If the PHI's result is never used, then we can just\n \t\t ignore it.  */"}, {"sha": "6a951eda82a4385b3af98b8b38c8aaf093a893e7", "filename": "gcc/tree-cfgcleanup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfgcleanup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-cfgcleanup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -23,6 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n /* In tree-cfgcleanup.c  */\n extern bitmap cfgcleanup_altered_bbs;\n extern bool cleanup_tree_cfg (void);\n-extern bool fixup_noreturn_call (gimple stmt);\n+extern bool fixup_noreturn_call (gimple *stmt);\n \n #endif /* GCC_TREE_CFGCLEANUP_H */"}, {"sha": "528dfa16e947383bbb63ffb4a4674eb9897390ff", "filename": "gcc/tree-chkp-opt.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chkp-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chkp-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp-opt.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -81,7 +81,7 @@ struct check_info\n   /* Bounds used for the check.  */\n   tree bounds;\n   /* Check statement.  Can be NULL for removed checks.  */\n-  gimple stmt;\n+  gimple *stmt;\n };\n \n /* Structure to hold checks information for BB.  */\n@@ -354,7 +354,7 @@ chkp_collect_addr_value (tree ptr, address_t &res)\n static void\n chkp_collect_value (tree ptr, address_t &res)\n {\n-  gimple def_stmt;\n+  gimple *def_stmt;\n   enum gimple_code code;\n   enum tree_code rhs_code;\n   address_t addr;\n@@ -443,7 +443,7 @@ chkp_collect_value (tree ptr, address_t &res)\n /* Fill check_info structure *CI with information about\n    check STMT.  */\n static void\n-chkp_fill_check_info (gimple stmt, struct check_info *ci)\n+chkp_fill_check_info (gimple *stmt, struct check_info *ci)\n {\n   ci->addr.pol.create (0);\n   ci->bounds = gimple_call_arg (stmt, 1);\n@@ -516,7 +516,7 @@ chkp_gather_checks_info (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n-\t  gimple stmt = gsi_stmt (i);\n+\t  gimple *stmt = gsi_stmt (i);\n \n \t  if (gimple_code (stmt) != GIMPLE_CALL)\n \t    continue;\n@@ -550,7 +550,7 @@ chkp_gather_checks_info (void)\n static int\n chkp_get_check_result (struct check_info *ci, tree bounds)\n {\n-  gimple bnd_def;\n+  gimple *bnd_def;\n   address_t bound_val;\n   int sign, res = 0;\n \n@@ -748,7 +748,7 @@ chkp_remove_check_if_pass (struct check_info *ci)\n static void\n chkp_use_outer_bounds_if_possible (struct check_info *ci)\n {\n-  gimple bnd_def;\n+  gimple *bnd_def;\n   tree bnd1, bnd2, bnd_res = NULL;\n   int check_res1, check_res2;\n \n@@ -978,7 +978,7 @@ chkp_optimize_string_function_calls (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n-\t  gimple stmt = gsi_stmt (i);\n+\t  gimple *stmt = gsi_stmt (i);\n \t  tree fndecl;\n \n \t  if (gimple_code (stmt) != GIMPLE_CALL\n@@ -1062,11 +1062,11 @@ chkp_optimize_string_function_calls (void)\n \t\t checks only when size is not zero.  */\n \t      if (!known)\n \t\t{\n-\t\t  gimple check = gimple_build_cond (NE_EXPR,\n-\t\t\t\t\t\t    size,\n-\t\t\t\t\t\t    size_zero_node,\n-\t\t\t\t\t\t    NULL_TREE,\n-\t\t\t\t\t\t    NULL_TREE);\n+\t\t  gimple *check = gimple_build_cond (NE_EXPR,\n+\t\t\t\t\t\t     size,\n+\t\t\t\t\t\t     size_zero_node,\n+\t\t\t\t\t\t     NULL_TREE,\n+\t\t\t\t\t\t     NULL_TREE);\n \n \t\t  /* Split block before string function call.  */\n \t\t  gsi_prev (&i);\n@@ -1119,7 +1119,7 @@ chkp_reduce_bounds_lifetime (void)\n \n   for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n     {\n-      gimple dom_use, use_stmt, stmt = gsi_stmt (i);\n+      gimple *dom_use, *use_stmt, *stmt = gsi_stmt (i);\n       basic_block dom_bb;\n       ssa_op_iter iter;\n       imm_use_iterator use_iter;"}, {"sha": "190916d5ce87ba67e6ee139fa0d7965c4a124538", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -439,7 +439,7 @@ chkp_function_mark_instrumented (tree fndecl)\n    corresponding to CODE.  */\n \n bool\n-chkp_gimple_call_builtin_p (gimple call,\n+chkp_gimple_call_builtin_p (gimple *call,\n \t\t\t    enum built_in_function code)\n {\n   tree fndecl;\n@@ -503,7 +503,7 @@ tree\n chkp_insert_retbnd_call (tree bndval, tree retval,\n \t\t\t gimple_stmt_iterator *gsi)\n {\n-  gimple call;\n+  gimple *call;\n \n   if (!bndval)\n     bndval = create_tmp_reg (pointer_bounds_type_node, \"retbnd\");\n@@ -582,21 +582,21 @@ chkp_redirect_edge (cgraph_edge *e)\n \n /* Mark statement S to not be instrumented.  */\n static void\n-chkp_mark_stmt (gimple s)\n+chkp_mark_stmt (gimple *s)\n {\n   gimple_set_plf (s, GF_PLF_1, true);\n }\n \n /* Mark statement S to be instrumented.  */\n static void\n-chkp_unmark_stmt (gimple s)\n+chkp_unmark_stmt (gimple *s)\n {\n   gimple_set_plf (s, GF_PLF_1, false);\n }\n \n /* Return 1 if statement S should not be instrumented.  */\n static bool\n-chkp_marked_stmt_p (gimple s)\n+chkp_marked_stmt_p (gimple *s)\n {\n   return gimple_plf (s, GF_PLF_1);\n }\n@@ -613,7 +613,7 @@ chkp_get_tmp_var (void)\n \n /* Get SSA_NAME to be used as temp.  */\n static tree\n-chkp_get_tmp_reg (gimple stmt)\n+chkp_get_tmp_reg (gimple *stmt)\n {\n   if (in_chkp_pass)\n     return make_ssa_name (chkp_get_tmp_var (), stmt);\n@@ -752,7 +752,7 @@ bool\n chkp_may_complete_phi_bounds (tree const &bounds, tree *slot ATTRIBUTE_UNUSED,\n \t\t\t      bool *res)\n {\n-  gimple phi;\n+  gimple *phi;\n   unsigned i;\n \n   gcc_assert (TREE_CODE (bounds) == SSA_NAME);\n@@ -851,7 +851,7 @@ chkp_valid_bounds (tree bounds)\n bool\n chkp_find_valid_phi_bounds (tree const &bounds, tree *slot, bool *res)\n {\n-  gimple phi;\n+  gimple *phi;\n   unsigned i;\n \n   gcc_assert (TREE_CODE (bounds) == SSA_NAME);\n@@ -1155,7 +1155,7 @@ chkp_get_orginal_bounds_for_abnormal_copy (tree bnd)\n {\n   if (bitmap_bit_p (chkp_abnormal_copies, SSA_NAME_VERSION (bnd)))\n     {\n-      gimple bnd_def = SSA_NAME_DEF_STMT (bnd);\n+      gimple *bnd_def = SSA_NAME_DEF_STMT (bnd);\n       gcc_checking_assert (gimple_code (bnd_def) == GIMPLE_ASSIGN);\n       bnd = gimple_assign_rhs1 (bnd_def);\n     }\n@@ -1227,8 +1227,8 @@ chkp_maybe_copy_and_register_bounds (tree ptr, tree bnd)\n       else\n \t{\n \t  tree copy;\n-\t  gimple def = SSA_NAME_DEF_STMT (ptr);\n-\t  gimple assign;\n+\t  gimple *def = SSA_NAME_DEF_STMT (ptr);\n+\t  gimple *assign;\n \t  gimple_stmt_iterator gsi;\n \n \t  if (bnd_var)\n@@ -1259,7 +1259,7 @@ chkp_maybe_copy_and_register_bounds (tree ptr, tree bnd)\n \t    }\n \t  else\n \t    {\n-\t      gimple bnd_def = SSA_NAME_DEF_STMT (bnd);\n+\t      gimple *bnd_def = SSA_NAME_DEF_STMT (bnd);\n \t      /* Sometimes (e.g. when we load a pointer from a\n \t\t memory) bounds are produced later than a pointer.\n \t\t We need to insert bounds copy appropriately.  */\n@@ -1356,7 +1356,7 @@ chkp_check_lower (tree addr, tree bounds,\n \t\t  tree dirflag)\n {\n   gimple_seq seq;\n-  gimple check;\n+  gimple *check;\n   tree node;\n \n   if (!chkp_function_instrumented_p (current_function_decl)\n@@ -1385,7 +1385,7 @@ chkp_check_lower (tree addr, tree bounds,\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      gimple before = gsi_stmt (iter);\n+      gimple *before = gsi_stmt (iter);\n       fprintf (dump_file, \"Generated lower bound check for statement \");\n       print_gimple_stmt (dump_file, before, 0, TDF_VOPS|TDF_MEMSYMS);\n       fprintf (dump_file, \"  \");\n@@ -1403,7 +1403,7 @@ chkp_check_upper (tree addr, tree bounds,\n \t\t  tree dirflag)\n {\n   gimple_seq seq;\n-  gimple check;\n+  gimple *check;\n   tree node;\n \n   if (!chkp_function_instrumented_p (current_function_decl)\n@@ -1432,7 +1432,7 @@ chkp_check_upper (tree addr, tree bounds,\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      gimple before = gsi_stmt (iter);\n+      gimple *before = gsi_stmt (iter);\n       fprintf (dump_file, \"Generated upper bound check for statement \");\n       print_gimple_stmt (dump_file, before, 0, TDF_VOPS|TDF_MEMSYMS);\n       fprintf (dump_file, \"  \");\n@@ -1463,7 +1463,7 @@ chkp_replace_address_check_builtin (gimple_stmt_iterator *gsi,\n \t\t\t\t    tree dirflag)\n {\n   gimple_stmt_iterator call_iter = *gsi;\n-  gimple call = gsi_stmt (*gsi);\n+  gimple *call = gsi_stmt (*gsi);\n   tree fndecl = gimple_call_fndecl (call);\n   tree addr = gimple_call_arg (call, 0);\n   tree bounds = chkp_find_bounds (addr, gsi);\n@@ -1492,11 +1492,11 @@ chkp_replace_address_check_builtin (gimple_stmt_iterator *gsi,\n void\n chkp_replace_extract_builtin (gimple_stmt_iterator *gsi)\n {\n-  gimple call = gsi_stmt (*gsi);\n+  gimple *call = gsi_stmt (*gsi);\n   tree fndecl = gimple_call_fndecl (call);\n   tree addr = gimple_call_arg (call, 0);\n   tree bounds = chkp_find_bounds (addr, gsi);\n-  gimple extract;\n+  gimple *extract;\n \n   if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CHKP_GET_PTR_LBOUND)\n     fndecl = chkp_extract_lower_fndecl;\n@@ -1596,7 +1596,7 @@ chkp_find_bounds_for_elem (tree elem, tree *all_bounds,\n       if (!all_bounds[offs / POINTER_SIZE])\n \t{\n \t  tree temp = make_temp_ssa_name (type, NULL, \"\");\n-\t  gimple assign = gimple_build_assign (temp, elem);\n+\t  gimple *assign = gimple_build_assign (temp, elem);\n \t  gimple_stmt_iterator gsi;\n \n \t  gsi_insert_before (iter, assign, GSI_SAME_STMT);\n@@ -2023,7 +2023,7 @@ chkp_make_bounds (tree lb, tree size, gimple_stmt_iterator *iter, bool after)\n {\n   gimple_seq seq;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   tree bounds;\n \n   if (iter)\n@@ -2103,7 +2103,7 @@ chkp_get_zero_bounds (void)\n       || flag_chkp_use_static_const_bounds > 0)\n     {\n       gimple_stmt_iterator gsi = gsi_start_bb (chkp_get_entry_block ());\n-      gimple stmt;\n+      gimple *stmt;\n \n       zero_bounds = chkp_get_tmp_reg (NULL);\n       stmt = gimple_build_assign (zero_bounds, chkp_get_zero_bounds_var ());\n@@ -2133,7 +2133,7 @@ chkp_get_none_bounds (void)\n       || flag_chkp_use_static_const_bounds > 0)\n     {\n       gimple_stmt_iterator gsi = gsi_start_bb (chkp_get_entry_block ());\n-      gimple stmt;\n+      gimple *stmt;\n \n       none_bounds = chkp_get_tmp_reg (NULL);\n       stmt = gimple_build_assign (none_bounds, chkp_get_none_bounds_var ());\n@@ -2207,7 +2207,7 @@ chkp_build_returned_bound (gcall *call)\n {\n   gimple_stmt_iterator gsi;\n   tree bounds;\n-  gimple stmt;\n+  gimple *stmt;\n   tree fndecl = gimple_call_fndecl (call);\n   unsigned int retflags;\n \n@@ -2429,7 +2429,7 @@ static tree\n chkp_build_bndldx (tree addr, tree ptr, gimple_stmt_iterator *gsi)\n {\n   gimple_seq seq;\n-  gimple stmt;\n+  gimple *stmt;\n   tree bounds;\n \n   seq = NULL;\n@@ -2479,7 +2479,7 @@ chkp_build_bndstx (tree addr, tree ptr, tree bounds,\n \t\t   gimple_stmt_iterator *gsi)\n {\n   gimple_seq seq;\n-  gimple stmt;\n+  gimple *stmt;\n \n   seq = NULL;\n \n@@ -2505,7 +2505,7 @@ chkp_build_bndstx (tree addr, tree ptr, tree bounds,\n /* Compute bounds for pointer NODE which was assigned in\n    assignment statement ASSIGN.  Return computed bounds.  */\n static tree\n-chkp_compute_bounds_for_assignment (tree node, gimple assign)\n+chkp_compute_bounds_for_assignment (tree node, gimple *assign)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (assign);\n   tree rhs1 = gimple_assign_rhs1 (assign);\n@@ -2651,7 +2651,7 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n \ttree val2 = gimple_assign_rhs3 (assign);\n \ttree bnd1 = chkp_find_bounds (val1, &iter);\n \ttree bnd2 = chkp_find_bounds (val2, &iter);\n-\tgimple stmt;\n+\tgimple *stmt;\n \n \tif (chkp_incomplete_bounds (bnd1) || chkp_incomplete_bounds (bnd2))\n \t  bounds = incomplete_bounds;\n@@ -2684,7 +2684,7 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n \t  bounds = bnd1;\n \telse\n \t  {\n-\t    gimple stmt;\n+\t    gimple *stmt;\n \t    tree cond = build2 (rhs_code == MAX_EXPR ? GT_EXPR : LT_EXPR,\n \t\t\t\tboolean_type_node, rhs1, rhs2);\n \t    bounds = chkp_get_tmp_reg (assign);\n@@ -2714,7 +2714,7 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n       && TREE_CODE (base) == SSA_NAME\n       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (base))\n     {\n-      gimple stmt = gimple_build_assign (chkp_get_tmp_reg (NULL), bounds);\n+      gimple *stmt = gimple_build_assign (chkp_get_tmp_reg (NULL), bounds);\n       gsi_insert_after (&iter, stmt, GSI_SAME_STMT);\n       bounds = gimple_assign_lhs (stmt);\n     }\n@@ -2732,7 +2732,7 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n \n    Return computed bounds.  */\n static tree\n-chkp_get_bounds_by_definition (tree node, gimple def_stmt,\n+chkp_get_bounds_by_definition (tree node, gimple *def_stmt,\n \t\t\t       gphi_iterator *iter)\n {\n   tree var, bounds;\n@@ -2964,7 +2964,7 @@ chkp_generate_extern_var_bounds (tree var)\n   tree bounds, size_reloc, lb, size, max_size, cond;\n   gimple_stmt_iterator gsi;\n   gimple_seq seq = NULL;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* If instrumentation is not enabled for vars having\n      incomplete type then just return zero bounds to avoid\n@@ -3082,7 +3082,7 @@ chkp_get_bounds_for_decl_addr (tree decl)\n     {\n       tree bnd_var = chkp_make_static_bounds (decl);\n       gimple_stmt_iterator gsi = gsi_start_bb (chkp_get_entry_block ());\n-      gimple stmt;\n+      gimple *stmt;\n \n       bounds = chkp_get_tmp_reg (NULL);\n       stmt = gimple_build_assign (bounds, bnd_var);\n@@ -3126,7 +3126,7 @@ chkp_get_bounds_for_string_cst (tree cst)\n     {\n       tree bnd_var = chkp_make_static_bounds (cst);\n       gimple_stmt_iterator gsi = gsi_start_bb (chkp_get_entry_block ());\n-      gimple stmt;\n+      gimple *stmt;\n \n       bounds = chkp_get_tmp_reg (NULL);\n       stmt = gimple_build_assign (bounds, bnd_var);\n@@ -3158,7 +3158,7 @@ chkp_intersect_bounds (tree bounds1, tree bounds2, gimple_stmt_iterator *iter)\n   else\n     {\n       gimple_seq seq;\n-      gimple stmt;\n+      gimple *stmt;\n       tree bounds;\n \n       seq = NULL;\n@@ -3542,7 +3542,7 @@ chkp_find_bounds_1 (tree ptr, tree ptr_src, gimple_stmt_iterator *iter)\n       bounds = chkp_get_registered_bounds (ptr_src);\n       if (!bounds)\n \t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (ptr_src);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (ptr_src);\n \t  gphi_iterator phi_iter;\n \n \t  bounds = chkp_get_bounds_by_definition (ptr_src, def_stmt, &phi_iter);\n@@ -3985,7 +3985,7 @@ chkp_process_stmt (gimple_stmt_iterator *iter, tree node,\n       && chkp_type_has_pointer (node_type)\n       && flag_chkp_store_bounds)\n     {\n-      gimple stmt = gsi_stmt (*iter);\n+      gimple *stmt = gsi_stmt (*iter);\n       tree rhs1 = gimple_assign_rhs1 (stmt);\n       enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n \n@@ -4003,7 +4003,7 @@ chkp_process_stmt (gimple_stmt_iterator *iter, tree node,\n /* Add code to copy bounds for all pointers copied\n    in ASSIGN created during inline of EDGE.  */\n void\n-chkp_copy_bounds_for_assign (gimple assign, struct cgraph_edge *edge)\n+chkp_copy_bounds_for_assign (gimple *assign, struct cgraph_edge *edge)\n {\n   tree lhs = gimple_assign_lhs (assign);\n   tree rhs = gimple_assign_rhs1 (assign);\n@@ -4017,7 +4017,7 @@ chkp_copy_bounds_for_assign (gimple assign, struct cgraph_edge *edge)\n   /* We should create edges for all created calls to bndldx and bndstx.  */\n   while (gsi_stmt (iter) != assign)\n     {\n-      gimple stmt = gsi_stmt (iter);\n+      gimple *stmt = gsi_stmt (iter);\n       if (gimple_code (stmt) == GIMPLE_CALL)\n \t{\n \t  tree fndecl = gimple_call_fndecl (stmt);\n@@ -4056,7 +4056,7 @@ chkp_fix_cfg ()\n   FOR_ALL_BB_FN (bb, cfun)\n     for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n       {\n-\tgimple stmt = gsi_stmt (i);\n+\tgimple *stmt = gsi_stmt (i);\n \tgimple_stmt_iterator next = i;\n \n \tgsi_next (&next);\n@@ -4083,7 +4083,7 @@ chkp_fix_cfg ()\n \n \t    while (!gsi_end_p (next))\n \t      {\n-\t\tgimple next_stmt = gsi_stmt (next);\n+\t\tgimple *next_stmt = gsi_stmt (next);\n \t\tgsi_remove (&next, false);\n \t\tgsi_insert_on_edge (fall, next_stmt);\n \t      }\n@@ -4133,7 +4133,7 @@ chkp_replace_function_pointer (tree *op, int *walk_subtrees,\n static void\n chkp_replace_function_pointers (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   /* For calls we want to walk call args only.  */\n   if (gimple_code (stmt) == GIMPLE_CALL)\n     {\n@@ -4164,7 +4164,7 @@ chkp_instrument_function (void)\n       next = bb->next_bb;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n         {\n-          gimple s = gsi_stmt (i);\n+\t  gimple *s = gsi_stmt (i);\n \n \t  /* Skip statement marked to not be instrumented.  */\n \t  if (chkp_marked_stmt_p (s))\n@@ -4296,7 +4296,7 @@ chkp_remove_useless_builtins ()\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree fndecl;\n \t  enum built_in_function fcode;\n "}, {"sha": "cc248584d2853c2c1d7e877090f935b42b9d5ec9", "filename": "gcc/tree-chkp.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chkp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chkp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -49,9 +49,9 @@ extern void chkp_build_bndstx (tree addr, tree ptr, tree bounds,\n extern gcall *chkp_retbnd_call_by_val (tree val);\n extern bool chkp_function_instrumented_p (tree fndecl);\n extern void chkp_function_mark_instrumented (tree fndecl);\n-extern void chkp_copy_bounds_for_assign (gimple assign,\n+extern void chkp_copy_bounds_for_assign (gimple *assign,\n \t\t\t\t\t struct cgraph_edge *edge);\n-extern bool chkp_gimple_call_builtin_p (gimple call,\n+extern bool chkp_gimple_call_builtin_p (gimple *call,\n \t\t\t\t\tenum built_in_function code);\n extern rtx chkp_expand_zero_bounds (void);\n extern void chkp_expand_bounds_reset_for_mem (tree mem, tree ptr);"}, {"sha": "649c9fe61a7902b8fa90511fc35729e85d23c4f1", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1173,7 +1173,7 @@ nb_vars_in_chrec (tree chrec)\n \n bool\n convert_affine_scev (struct loop *loop, tree type,\n-\t\t     tree *base, tree *step, gimple at_stmt,\n+\t\t     tree *base, tree *step, gimple *at_stmt,\n \t\t     bool use_overflow_semantics)\n {\n   tree ct = TREE_TYPE (*step);\n@@ -1274,7 +1274,7 @@ convert_affine_scev (struct loop *loop, tree type,\n    The increment for a pointer type is always sizetype.  */\n \n tree\n-chrec_convert_rhs (tree type, tree chrec, gimple at_stmt)\n+chrec_convert_rhs (tree type, tree chrec, gimple *at_stmt)\n {\n   if (POINTER_TYPE_P (type))\n     type = sizetype;\n@@ -1295,7 +1295,7 @@ chrec_convert_rhs (tree type, tree chrec, gimple at_stmt)\n    tests, but also to enforce that the result follows them.  */\n \n static tree\n-chrec_convert_1 (tree type, tree chrec, gimple at_stmt,\n+chrec_convert_1 (tree type, tree chrec, gimple *at_stmt,\n \t\t bool use_overflow_semantics)\n {\n   tree ct, res;\n@@ -1402,7 +1402,7 @@ chrec_convert_1 (tree type, tree chrec, gimple at_stmt,\n    tests, but also to enforce that the result follows them.  */\n \n tree\n-chrec_convert (tree type, tree chrec, gimple at_stmt,\n+chrec_convert (tree type, tree chrec, gimple *at_stmt,\n \t       bool use_overflow_semantics)\n {\n   return chrec_convert_1 (type, chrec, at_stmt, use_overflow_semantics);"}, {"sha": "ab6d7f29b92e9902d86e4d5d1ca9a8f08845271d", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -59,8 +59,8 @@ enum ev_direction scev_direction (const_tree);\n extern tree chrec_fold_plus (tree, tree, tree);\n extern tree chrec_fold_minus (tree, tree, tree);\n extern tree chrec_fold_multiply (tree, tree, tree);\n-extern tree chrec_convert (tree, tree, gimple, bool = true);\n-extern tree chrec_convert_rhs (tree, tree, gimple);\n+extern tree chrec_convert (tree, tree, gimple *, bool = true);\n+extern tree chrec_convert_rhs (tree, tree, gimple *);\n extern tree chrec_convert_aggressive (tree, tree, bool *);\n \n /* Operations.  */\n@@ -74,7 +74,7 @@ extern tree hide_evolution_in_other_loops_than_loop (tree, unsigned);\n extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n extern void for_each_scev_op (tree *, bool (*) (tree *, void *), void *);\n-extern bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple,\n+extern bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple *,\n \t\t\t\t bool);\n \n /* Observers.  */"}, {"sha": "b0ffc00bb8fe5d0e21a1ccd3fb7c209327734972", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -220,7 +220,7 @@ init_dont_simulate_again (void)\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  gimple stmt;\n+\t  gimple *stmt;\n \t  tree op0, op1;\n \t  bool sim_again_p;\n \n@@ -308,7 +308,7 @@ init_dont_simulate_again (void)\n /* Evaluate statement STMT against the complex lattice defined above.  */\n \n static enum ssa_prop_result\n-complex_visit_stmt (gimple stmt, edge *taken_edge_p ATTRIBUTE_UNUSED,\n+complex_visit_stmt (gimple *stmt, edge *taken_edge_p ATTRIBUTE_UNUSED,\n \t\t    tree *result_p)\n {\n   complex_lattice_t new_l, old_l, op1_l, op2_l;\n@@ -536,7 +536,7 @@ set_component_ssa_name (tree ssa_name, bool imag_p, tree value)\n   complex_lattice_t lattice = find_lattice_value (ssa_name);\n   size_t ssa_name_index;\n   tree comp;\n-  gimple last;\n+  gimple *last;\n   gimple_seq list;\n \n   /* We know the value must be zero, else there's a bug in our lattice\n@@ -642,7 +642,7 @@ extract_component (gimple_stmt_iterator *gsi, tree t, bool imagpart_p,\n /* Update the complex components of the ssa name on the lhs of STMT.  */\n \n static void\n-update_complex_components (gimple_stmt_iterator *gsi, gimple stmt, tree r,\n+update_complex_components (gimple_stmt_iterator *gsi, gimple *stmt, tree r,\n \t\t\t   tree i)\n {\n   tree lhs;\n@@ -679,7 +679,7 @@ update_complex_components_on_edge (edge e, tree lhs, tree r, tree i)\n static void\n update_complex_assignment (gimple_stmt_iterator *gsi, tree r, tree i)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   gimple_assign_set_rhs_with_ops (gsi, COMPLEX_EXPR, r, i);\n   stmt = gsi_stmt (*gsi);\n@@ -735,7 +735,7 @@ update_phi_components (basic_block bb)\n       if (is_complex_reg (gimple_phi_result (phi)))\n \t{\n \t  tree lr, li;\n-\t  gimple pr = NULL, pi = NULL;\n+\t  gimple *pr = NULL, *pi = NULL;\n \t  unsigned int i, n;\n \n \t  lr = get_component_ssa_name (gimple_phi_result (phi), false);\n@@ -771,7 +771,7 @@ expand_complex_move (gimple_stmt_iterator *gsi, tree type)\n {\n   tree inner_type = TREE_TYPE (type);\n   tree r, i, lhs, rhs;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (is_gimple_assign (stmt))\n     {\n@@ -832,7 +832,7 @@ expand_complex_move (gimple_stmt_iterator *gsi, tree type)\n   else if (rhs && TREE_CODE (rhs) == SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n     {\n       tree x;\n-      gimple t;\n+      gimple *t;\n       location_t loc;\n \n       loc = gimple_location (stmt);\n@@ -954,7 +954,7 @@ expand_complex_libcall (gimple_stmt_iterator *gsi, tree ar, tree ai,\n   machine_mode mode;\n   enum built_in_function bcode;\n   tree fn, type, lhs;\n-  gimple old_stmt;\n+  gimple *old_stmt;\n   gcall *stmt;\n \n   old_stmt = gsi_stmt (*gsi);\n@@ -1120,7 +1120,7 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n {\n   tree rr, ri, ratio, div, t1, t2, tr, ti, compare;\n   basic_block bb_cond, bb_true, bb_false, bb_join;\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Examine |br| < |bi|, and branch.  */\n   t1 = gimplify_build1 (gsi, ABS_EXPR, inner_type, br);\n@@ -1134,7 +1134,7 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n   if (TREE_CODE (compare) != INTEGER_CST)\n     {\n       edge e;\n-      gimple stmt;\n+      gimple *stmt;\n       tree cond, tmp;\n \n       tmp = create_tmp_var (boolean_type_node);\n@@ -1382,7 +1382,7 @@ expand_complex_comparison (gimple_stmt_iterator *gsi, tree ar, tree ai,\n \t\t\t   tree br, tree bi, enum tree_code code)\n {\n   tree cr, ci, cc, type;\n-  gimple stmt;\n+  gimple *stmt;\n \n   cr = gimplify_build2 (gsi, code, boolean_type_node, ar, br);\n   ci = gimplify_build2 (gsi, code, boolean_type_node, ai, bi);\n@@ -1460,7 +1460,7 @@ expand_complex_asm (gimple_stmt_iterator *gsi)\n static void\n expand_complex_operations_1 (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree type, inner_type, lhs;\n   tree ac, ar, ai, bc, br, bi;\n   complex_lattice_t al, bl;"}, {"sha": "1883fd7234f22246c0aadb3eb8dbac2f8a9d88ad", "filename": "gcc/tree-core.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1250,7 +1250,7 @@ struct GTY(()) ssa_use_operand_t {\n      needs to point to the original SSA name.  Since statements and\n      SSA names are of different data types, we need this union.  See\n      the explanation in struct imm_use_iterator.  */\n-  union { gimple stmt; tree ssa_name; } GTY((skip(\"\"))) loc;\n+  union { gimple *stmt; tree ssa_name; } GTY((skip(\"\"))) loc;\n   tree *GTY((skip(\"\"))) use;\n };\n \n@@ -1261,7 +1261,7 @@ struct GTY(()) tree_ssa_name {\n   tree var;\n \n   /* Statement that defines this SSA name.  */\n-  gimple def_stmt;\n+  gimple *def_stmt;\n \n   /* Value range information.  */\n   union ssa_name_info_type {"}, {"sha": "e7087d7ebec94322a95d9ab3ce4cfb5d01762507", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -676,7 +676,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \tif (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n \t  return false;\n \n-\tgimple def_stmt = SSA_NAME_DEF_STMT (op0);\n+\tgimple *def_stmt = SSA_NAME_DEF_STMT (op0);\n \tenum tree_code subcode;\n \n \tif (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n@@ -767,7 +767,7 @@ canonicalize_base_object_address (tree addr)\n bool\n dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n {\n-  gimple stmt = DR_STMT (dr);\n+  gimple *stmt = DR_STMT (dr);\n   struct loop *loop = loop_containing_stmt (stmt);\n   tree ref = DR_REF (dr);\n   HOST_WIDE_INT pbitsize, pbitpos;\n@@ -1064,7 +1064,7 @@ free_data_ref (data_reference_p dr)\n    which the data reference should be analyzed.  */\n \n struct data_reference *\n-create_data_ref (loop_p nest, loop_p loop, tree memref, gimple stmt,\n+create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n \t\t bool is_read)\n {\n   struct data_reference *dr;\n@@ -3812,7 +3812,7 @@ struct data_ref_loc\n    true if STMT clobbers memory, false otherwise.  */\n \n static bool\n-get_references_in_stmt (gimple stmt, vec<data_ref_loc, va_heap> *references)\n+get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n {\n   bool clobbers_memory = false;\n   data_ref_loc ref;\n@@ -3944,7 +3944,7 @@ loop_nest_has_data_refs (loop_p loop)\n \n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  get_references_in_stmt (stmt, &references);\n \t  if (references.length ())\n \t    {\n@@ -3975,7 +3975,7 @@ loop_nest_has_data_refs (loop_p loop)\n    loop of the loop nest in which the references should be analyzed.  */\n \n bool\n-find_data_references_in_stmt (struct loop *nest, gimple stmt,\n+find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n@@ -4005,7 +4005,7 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n    should be analyzed.  */\n \n bool\n-graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple stmt,\n+graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple *stmt,\n \t\t\t\t       vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n@@ -4040,7 +4040,7 @@ find_data_references_in_bb (struct loop *loop, basic_block bb,\n \n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n \n       if (!find_data_references_in_stmt (loop, stmt, datarefs))\n         {"}, {"sha": "4c9e3574d1d4de4a8d26916670b16915d5d4fb65", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -108,7 +108,7 @@ typedef lambda_vector *lambda_matrix;\n struct data_reference\n {\n   /* A pointer to the statement that contains this DR.  */\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* A pointer to the memory reference.  */\n   tree ref;\n@@ -317,13 +317,13 @@ extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (vec<ddr_p> );\n extern void free_data_ref (data_reference_p);\n extern void free_data_refs (vec<data_reference_p> );\n-extern bool find_data_references_in_stmt (struct loop *, gimple,\n+extern bool find_data_references_in_stmt (struct loop *, gimple *,\n \t\t\t\t\t  vec<data_reference_p> *);\n-extern bool graphite_find_data_references_in_stmt (loop_p, loop_p, gimple,\n+extern bool graphite_find_data_references_in_stmt (loop_p, loop_p, gimple *,\n \t\t\t\t\t\t   vec<data_reference_p> *);\n tree find_data_references_in_loop (struct loop *, vec<data_reference_p> *);\n bool loop_nest_has_data_refs (loop_p loop);\n-struct data_reference *create_data_ref (loop_p, loop_p, tree, gimple, bool);\n+struct data_reference *create_data_ref (loop_p, loop_p, tree, gimple *, bool);\n extern bool find_loop_nest (struct loop *, vec<loop_p> *);\n extern struct data_dependence_relation *initialize_data_dependence_relation\n      (struct data_reference *, struct data_reference *, vec<loop_p>);"}, {"sha": "df43a4e166b1928531f96d967241cbf72b7854e9", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -86,12 +86,12 @@ renumber_gimple_stmt_uids (void)\n       gimple_stmt_iterator bsi;\n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t}\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t}\n     }\n@@ -112,12 +112,12 @@ renumber_gimple_stmt_uids_in_blocks (basic_block *blocks, int n_blocks)\n       gimple_stmt_iterator bsi;\n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t}\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n \t}\n     }\n@@ -295,7 +295,7 @@ collect_dfa_stats (struct dfa_stats_d *dfa_stats_p ATTRIBUTE_UNUSED)\n       for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n \t{\n-\t  gimple stmt = gsi_stmt (si);\n+\t  gimple *stmt = gsi_stmt (si);\n \t  dfa_stats_p->num_defs += NUM_SSA_OPERANDS (stmt, SSA_OP_DEF);\n \t  dfa_stats_p->num_uses += NUM_SSA_OPERANDS (stmt, SSA_OP_USE);\n \t  dfa_stats_p->num_vdefs += gimple_vdef (stmt) ? 1 : 0;\n@@ -815,7 +815,7 @@ get_addr_base_and_unit_offset (tree exp, HOST_WIDE_INT *poffset)\n    SSA_NAME_OCCURS_IN_ABNORMAL_PHI set, otherwise false.  */\n \n bool\n-stmt_references_abnormal_ssa_name (gimple stmt)\n+stmt_references_abnormal_ssa_name (gimple *stmt)\n {\n   ssa_op_iter oi;\n   use_operand_p use_p;"}, {"sha": "c4f95eebe7a08d672986c08f0da365a57cd7c98c", "filename": "gcc/tree-dfa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -34,7 +34,7 @@ extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n extern tree get_addr_base_and_unit_offset_1 (tree, HOST_WIDE_INT *,\n \t\t\t\t\t     tree (*) (tree));\n extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n-extern bool stmt_references_abnormal_ssa_name (gimple);\n+extern bool stmt_references_abnormal_ssa_name (gimple *);\n extern void dump_enumerated_decls (FILE *, int);\n \n "}, {"sha": "c19d2bea748944d872d1e0844fdd7807207e7080", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -58,7 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* In some instances a tree and a gimple need to be stored in a same table,\n    i.e. in hash tables. This is a structure to do this. */\n-typedef union {tree *tp; tree t; gimple g;} treemple;\n+typedef union {tree *tp; tree t; gimple *g;} treemple;\n \n /* Misc functions used in this file.  */\n \n@@ -77,28 +77,28 @@ typedef union {tree *tp; tree t; gimple g;} treemple;\n /* Add statement T in function IFUN to landing pad NUM.  */\n \n static void\n-add_stmt_to_eh_lp_fn (struct function *ifun, gimple t, int num)\n+add_stmt_to_eh_lp_fn (struct function *ifun, gimple *t, int num)\n {\n   gcc_assert (num != 0);\n \n   if (!get_eh_throw_stmt_table (ifun))\n-    set_eh_throw_stmt_table (ifun, hash_map<gimple, int>::create_ggc (31));\n+    set_eh_throw_stmt_table (ifun, hash_map<gimple *, int>::create_ggc (31));\n \n   gcc_assert (!get_eh_throw_stmt_table (ifun)->put (t, num));\n }\n \n /* Add statement T in the current function (cfun) to EH landing pad NUM.  */\n \n void\n-add_stmt_to_eh_lp (gimple t, int num)\n+add_stmt_to_eh_lp (gimple *t, int num)\n {\n   add_stmt_to_eh_lp_fn (cfun, t, num);\n }\n \n /* Add statement T to the single EH landing pad in REGION.  */\n \n static void\n-record_stmt_eh_region (eh_region region, gimple t)\n+record_stmt_eh_region (eh_region region, gimple *t)\n {\n   if (region == NULL)\n     return;\n@@ -119,7 +119,7 @@ record_stmt_eh_region (eh_region region, gimple t)\n /* Remove statement T in function IFUN from its EH landing pad.  */\n \n bool\n-remove_stmt_from_eh_lp_fn (struct function *ifun, gimple t)\n+remove_stmt_from_eh_lp_fn (struct function *ifun, gimple *t)\n {\n   if (!get_eh_throw_stmt_table (ifun))\n     return false;\n@@ -136,7 +136,7 @@ remove_stmt_from_eh_lp_fn (struct function *ifun, gimple t)\n    EH landing pad.  */\n \n bool\n-remove_stmt_from_eh_lp (gimple t)\n+remove_stmt_from_eh_lp (gimple *t)\n {\n   return remove_stmt_from_eh_lp_fn (cfun, t);\n }\n@@ -147,7 +147,7 @@ remove_stmt_from_eh_lp (gimple t)\n    statement is not recorded in the region table.  */\n \n int\n-lookup_stmt_eh_lp_fn (struct function *ifun, gimple t)\n+lookup_stmt_eh_lp_fn (struct function *ifun, gimple *t)\n {\n   if (ifun->eh->throw_stmt_table == NULL)\n     return 0;\n@@ -159,7 +159,7 @@ lookup_stmt_eh_lp_fn (struct function *ifun, gimple t)\n /* Likewise, but always use the current function.  */\n \n int\n-lookup_stmt_eh_lp (gimple t)\n+lookup_stmt_eh_lp (gimple *t)\n {\n   /* We can get called from initialized data when -fnon-call-exceptions\n      is on; prevent crash.  */\n@@ -223,7 +223,7 @@ record_in_finally_tree (treemple child, gtry *parent)\n }\n \n static void\n-collect_finally_tree (gimple stmt, gtry *region);\n+collect_finally_tree (gimple *stmt, gtry *region);\n \n /* Go through the gimple sequence.  Works with collect_finally_tree to\n    record all GIMPLE_LABEL and GIMPLE_TRY statements. */\n@@ -238,7 +238,7 @@ collect_finally_tree_1 (gimple_seq seq, gtry *region)\n }\n \n static void\n-collect_finally_tree (gimple stmt, gtry *region)\n+collect_finally_tree (gimple *stmt, gtry *region)\n {\n   treemple temp;\n \n@@ -295,7 +295,7 @@ collect_finally_tree (gimple stmt, gtry *region)\n    would leave the try_finally node that START lives in.  */\n \n static bool\n-outside_finally_tree (treemple start, gimple target)\n+outside_finally_tree (treemple start, gimple *target)\n {\n   struct finally_tree_node n, *p;\n \n@@ -339,7 +339,7 @@ struct goto_queue_node\n   treemple stmt;\n   location_t location;\n   gimple_seq repl_stmt;\n-  gimple cont_stmt;\n+  gimple *cont_stmt;\n   int index;\n   /* This is used when index >= 0 to indicate that stmt is a label (as\n      opposed to a goto stmt).  */\n@@ -391,7 +391,7 @@ struct leh_tf_state\n   size_t goto_queue_active;\n \n   /* Pointer map to help in searching goto_queue when it is large.  */\n-  hash_map<gimple, goto_queue_node *> *goto_queue_map;\n+  hash_map<gimple *, goto_queue_node *> *goto_queue_map;\n \n   /* The set of unique labels seen as entries in the goto queue.  */\n   vec<tree> dest_array;\n@@ -440,7 +440,7 @@ find_goto_replacement (struct leh_tf_state *tf, treemple stmt)\n \n   if (!tf->goto_queue_map)\n     {\n-      tf->goto_queue_map = new hash_map<gimple, goto_queue_node *>;\n+      tf->goto_queue_map = new hash_map<gimple *, goto_queue_node *>;\n       for (i = 0; i < tf->goto_queue_active; i++)\n \t{\n \t  bool existed = tf->goto_queue_map->put (tf->goto_queue[i].stmt.g,\n@@ -496,7 +496,7 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n static void replace_goto_queue_stmt_list (gimple_seq *, struct leh_tf_state *);\n \n static void\n-replace_goto_queue_1 (gimple stmt, struct leh_tf_state *tf,\n+replace_goto_queue_1 (gimple *stmt, struct leh_tf_state *tf,\n \t\t      gimple_stmt_iterator *gsi)\n {\n   gimple_seq seq;\n@@ -662,7 +662,7 @@ record_in_goto_queue_label (struct leh_tf_state *tf, treemple stmt, tree label,\n    try_finally node.  */\n \n static void\n-maybe_record_in_goto_queue (struct leh_state *state, gimple stmt)\n+maybe_record_in_goto_queue (struct leh_state *state, gimple *stmt)\n {\n   struct leh_tf_state *tf = state->tf;\n   treemple new_stmt;\n@@ -738,7 +738,7 @@ verify_norecord_switch_expr (struct leh_state *state,\n static void\n do_return_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod)\n {\n-  gimple x;\n+  gimple *x;\n \n   /* In the case of a return, the queue node must be a gimple statement.  */\n   gcc_assert (!q->is_label);\n@@ -871,7 +871,7 @@ eh_region_may_contain_throw (eh_region r)\n static gimple_seq\n frob_into_branch_around (gtry *tp, eh_region region, tree over)\n {\n-  gimple x;\n+  gimple *x;\n   gimple_seq cleanup, result;\n   location_t loc = gimple_location (tp);\n \n@@ -914,7 +914,7 @@ lower_try_finally_dup_block (gimple_seq seq, struct leh_state *outer_state,\n \n   for (gsi = gsi_start (new_seq); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       /* We duplicate __builtin_stack_restore at -O0 in the hope of eliminating\n \t it on the EH paths.  When it is not eliminated, make it transparent in\n \t the debug info.  */\n@@ -964,7 +964,7 @@ lower_try_finally_fallthru_label (struct leh_tf_state *tf)\n static inline geh_else *\n get_eh_else (gimple_seq finally)\n {\n-  gimple x = gimple_seq_first_stmt (finally);\n+  gimple *x = gimple_seq_first_stmt (finally);\n   if (gimple_code (x) == GIMPLE_EH_ELSE)\n     {\n       gcc_assert (gimple_seq_singleton_p (finally));\n@@ -1002,7 +1002,7 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n   gimple_stmt_iterator gsi;\n   bool finally_may_fallthru;\n   gimple_seq finally;\n-  gimple x;\n+  gimple *x;\n   geh_mnt *eh_mnt;\n   gtry *try_stmt;\n   geh_else *eh_else;\n@@ -1073,7 +1073,7 @@ lower_try_finally_nofallthru (struct leh_state *state,\n \t\t\t      struct leh_tf_state *tf)\n {\n   tree lab;\n-  gimple x;\n+  gimple *x;\n   geh_else *eh_else;\n   gimple_seq finally;\n   struct goto_queue_node *q, *qe;\n@@ -1140,7 +1140,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n   struct goto_queue_node *q, *qe;\n   geh_else *eh_else;\n   glabel *label_stmt;\n-  gimple x;\n+  gimple *x;\n   gimple_seq finally;\n   gimple_stmt_iterator gsi;\n   tree finally_label;\n@@ -1165,7 +1165,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n \n   for (gsi = gsi_start (finally); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (LOCATION_LOCUS (gimple_location (stmt)) == UNKNOWN_LOCATION)\n \t{\n \t  tree block = gimple_block (stmt);\n@@ -1242,7 +1242,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n   gimple_seq finally;\n   gimple_seq new_stmt;\n   gimple_seq seq;\n-  gimple x;\n+  gimple *x;\n   geh_else *eh_else;\n   tree tmp;\n   location_t tf_loc = gimple_location (tf->try_finally_expr);\n@@ -1376,12 +1376,12 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   tree last_case;\n   vec<tree> case_label_vec;\n   gimple_seq switch_body = NULL;\n-  gimple x;\n+  gimple *x;\n   geh_else *eh_else;\n   tree tmp;\n-  gimple switch_stmt;\n+  gimple *switch_stmt;\n   gimple_seq finally;\n-  hash_map<tree, gimple> *cont_map = NULL;\n+  hash_map<tree, gimple *> *cont_map = NULL;\n   /* The location of the TRY_FINALLY stmt.  */\n   location_t tf_loc = gimple_location (tf->try_finally_expr);\n   /* The location of the finally block.  */\n@@ -1526,14 +1526,14 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n           /* We store the cont_stmt in the pointer map, so that we can recover\n              it in the loop below.  */\n           if (!cont_map)\n-            cont_map = new hash_map<tree, gimple>;\n+\t    cont_map = new hash_map<tree, gimple *>;\n           cont_map->put (case_lab, q->cont_stmt);\n           case_label_vec.quick_push (case_lab);\n         }\n     }\n   for (j = last_case_index; j < last_case_index + nlabels; j++)\n     {\n-      gimple cont_stmt;\n+      gimple *cont_stmt;\n \n       last_case = case_label_vec[j];\n \n@@ -1611,7 +1611,7 @@ decide_copy_try_finally (int ndests, bool may_throw, gimple_seq finally)\n \t{\n \t  /* Duplicate __builtin_stack_restore in the hope of eliminating it\n \t     on the EH paths and, consequently, useless cleanups.  */\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  if (!is_gimple_debug (stmt)\n \t      && !gimple_clobber_p (stmt)\n \t      && !gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))\n@@ -1735,7 +1735,7 @@ lower_try_finally (struct leh_state *state, gtry *tp)\n   if (this_tf.fallthru_label)\n     {\n       /* This must be reached only if ndests == 0. */\n-      gimple x = gimple_build_label (this_tf.fallthru_label);\n+      gimple *x = gimple_build_label (this_tf.fallthru_label);\n       gimple_seq_add_stmt (&this_tf.top_p_seq, x);\n     }\n \n@@ -1773,7 +1773,7 @@ lower_catch (struct leh_state *state, gtry *tp)\n   gimple_stmt_iterator gsi;\n   tree out_label;\n   gimple_seq new_seq, cleanup;\n-  gimple x;\n+  gimple *x;\n   location_t try_catch_loc = gimple_location (tp);\n \n   if (flag_exceptions)\n@@ -1852,7 +1852,7 @@ lower_eh_filter (struct leh_state *state, gtry *tp)\n {\n   struct leh_state this_state = *state;\n   eh_region this_region = NULL;\n-  gimple inner, x;\n+  gimple *inner, *x;\n   gimple_seq new_seq;\n \n   inner = gimple_seq_first_stmt (gimple_try_cleanup (tp));\n@@ -1899,7 +1899,7 @@ lower_eh_must_not_throw (struct leh_state *state, gtry *tp)\n \n   if (flag_exceptions)\n     {\n-      gimple inner = gimple_seq_first_stmt (gimple_try_cleanup (tp));\n+      gimple *inner = gimple_seq_first_stmt (gimple_try_cleanup (tp));\n       eh_region this_region;\n \n       this_region = gen_eh_region_must_not_throw (state->cur_region);\n@@ -1972,7 +1972,7 @@ lower_cleanup (struct leh_state *state, gtry *tp)\n       result = gimple_try_eval (tp);\n       if (fake_tf.fallthru_label)\n \t{\n-\t  gimple x = gimple_build_label (fake_tf.fallthru_label);\n+\t  gimple *x = gimple_build_label (fake_tf.fallthru_label);\n \t  gimple_seq_add_stmt (&result, x);\n \t}\n     }\n@@ -1986,8 +1986,8 @@ static void\n lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n {\n   gimple_seq replace;\n-  gimple x;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *x;\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -2053,7 +2053,7 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n \t{\n \t  tree lhs = gimple_get_lhs (stmt);\n \t  tree tmp = create_tmp_var (TREE_TYPE (lhs));\n-\t  gimple s = gimple_build_assign (lhs, tmp);\n+\t  gimple *s = gimple_build_assign (lhs, tmp);\n \t  gimple_set_location (s, gimple_location (stmt));\n \t  gimple_set_block (s, gimple_block (stmt));\n \t  gimple_set_lhs (stmt, tmp);\n@@ -2268,7 +2268,7 @@ make_eh_dispatch_edges (geh_dispatch *stmt)\n    if there is such a landing pad within the current function.  */\n \n void\n-make_eh_edges (gimple stmt)\n+make_eh_edges (gimple *stmt)\n {\n   basic_block src, dst;\n   eh_landing_pad lp;\n@@ -2300,7 +2300,7 @@ redirect_eh_edge_1 (edge edge_in, basic_block new_bb, bool change_region)\n {\n   eh_landing_pad old_lp, new_lp;\n   basic_block old_bb;\n-  gimple throw_stmt;\n+  gimple *throw_stmt;\n   int old_lp_nr, new_lp_nr;\n   tree old_label, new_label;\n   edge_iterator ei;\n@@ -2736,7 +2736,7 @@ tree_could_trap_p (tree expr)\n    an assignment or a conditional) may throw.  */\n \n static bool\n-stmt_could_throw_1_p (gimple stmt)\n+stmt_could_throw_1_p (gimple *stmt)\n {\n   enum tree_code code = gimple_expr_code (stmt);\n   bool honor_nans = false;\n@@ -2789,7 +2789,7 @@ stmt_could_throw_1_p (gimple stmt)\n /* Return true if statement STMT could throw an exception.  */\n \n bool\n-stmt_could_throw_p (gimple stmt)\n+stmt_could_throw_p (gimple *stmt)\n {\n   if (!flag_exceptions)\n     return false;\n@@ -2849,7 +2849,7 @@ tree_could_throw_p (tree t)\n    the current function (CFUN).  */\n \n bool\n-stmt_can_throw_external (gimple stmt)\n+stmt_can_throw_external (gimple *stmt)\n {\n   int lp_nr;\n \n@@ -2864,7 +2864,7 @@ stmt_can_throw_external (gimple stmt)\n    the current function (CFUN).  */\n \n bool\n-stmt_can_throw_internal (gimple stmt)\n+stmt_can_throw_internal (gimple *stmt)\n {\n   int lp_nr;\n \n@@ -2880,7 +2880,7 @@ stmt_can_throw_internal (gimple stmt)\n    any change was made.  */\n \n bool\n-maybe_clean_eh_stmt_fn (struct function *ifun, gimple stmt)\n+maybe_clean_eh_stmt_fn (struct function *ifun, gimple *stmt)\n {\n   if (stmt_could_throw_p (stmt))\n     return false;\n@@ -2890,7 +2890,7 @@ maybe_clean_eh_stmt_fn (struct function *ifun, gimple stmt)\n /* Likewise, but always use the current function.  */\n \n bool\n-maybe_clean_eh_stmt (gimple stmt)\n+maybe_clean_eh_stmt (gimple *stmt)\n {\n   return maybe_clean_eh_stmt_fn (cfun, stmt);\n }\n@@ -2901,7 +2901,7 @@ maybe_clean_eh_stmt (gimple stmt)\n    done that my require an EH edge purge.  */\n \n bool\n-maybe_clean_or_replace_eh_stmt (gimple old_stmt, gimple new_stmt)\n+maybe_clean_or_replace_eh_stmt (gimple *old_stmt, gimple *new_stmt)\n {\n   int lp_nr = lookup_stmt_eh_lp (old_stmt);\n \n@@ -2930,8 +2930,8 @@ maybe_clean_or_replace_eh_stmt (gimple old_stmt, gimple new_stmt)\n    operand is the return value of duplicate_eh_regions.  */\n \n bool\n-maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple new_stmt,\n-\t\t\t    struct function *old_fun, gimple old_stmt,\n+maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple *new_stmt,\n+\t\t\t    struct function *old_fun, gimple *old_stmt,\n \t\t\t    hash_map<void *, void *> *map,\n \t\t\t    int default_lp_nr)\n {\n@@ -2972,7 +2972,7 @@ maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple new_stmt,\n    and thus no remapping is required.  */\n \n bool\n-maybe_duplicate_eh_stmt (gimple new_stmt, gimple old_stmt)\n+maybe_duplicate_eh_stmt (gimple *new_stmt, gimple *old_stmt)\n {\n   int lp_nr;\n \n@@ -2997,7 +2997,7 @@ static bool\n same_handler_p (gimple_seq oneh, gimple_seq twoh)\n {\n   gimple_stmt_iterator gsi;\n-  gimple ones, twos;\n+  gimple *ones, *twos;\n   unsigned int ai;\n \n   gsi = gsi_start (oneh);\n@@ -3041,7 +3041,7 @@ same_handler_p (gimple_seq oneh, gimple_seq twoh)\n static void\n optimize_double_finally (gtry *one, gtry *two)\n {\n-  gimple oneh;\n+  gimple *oneh;\n   gimple_stmt_iterator gsi;\n   gimple_seq cleanup;\n \n@@ -3074,7 +3074,7 @@ static void\n refactor_eh_r (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi;\n-  gimple one, two;\n+  gimple *one, *two;\n \n   one = NULL;\n   two = NULL;\n@@ -3171,7 +3171,7 @@ lower_resx (basic_block bb, gresx *stmt,\n   int lp_nr;\n   eh_region src_r, dst_r;\n   gimple_stmt_iterator gsi;\n-  gimple x;\n+  gimple *x;\n   tree fn, src_nr;\n   bool ret = false;\n \n@@ -3351,7 +3351,7 @@ pass_lower_resx::execute (function *fun)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      gimple last = last_stmt (bb);\n+      gimple *last = last_stmt (bb);\n       if (last && is_gimple_resx (last))\n \t{\n \t  dominance_invalidated |=\n@@ -3395,7 +3395,7 @@ optimize_clobbers (basic_block bb)\n      call, and has an incoming EH edge.  */\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (is_gimple_debug (stmt))\n \tcontinue;\n       if (gimple_clobber_p (stmt))\n@@ -3423,7 +3423,7 @@ optimize_clobbers (basic_block bb)\n   gsi = gsi_last_bb (bb);\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (!gimple_clobber_p (stmt))\n \tcontinue;\n       unlink_stmt_vdef (stmt);\n@@ -3462,7 +3462,7 @@ sink_clobbers (basic_block bb)\n   gsi = gsi_last_bb (bb);\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (is_gimple_debug (stmt))\n \tcontinue;\n       if (gimple_code (stmt) == GIMPLE_LABEL)\n@@ -3497,7 +3497,7 @@ sink_clobbers (basic_block bb)\n   gsi = gsi_last_bb (bb);\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       tree lhs;\n       if (is_gimple_debug (stmt))\n \tcontinue;\n@@ -3528,7 +3528,7 @@ sink_clobbers (basic_block bb)\n       /* But adjust virtual operands if we sunk across a PHI node.  */\n       if (vuse)\n \t{\n-\t  gimple use_stmt;\n+\t  gimple *use_stmt;\n \t  imm_use_iterator iter;\n \t  use_operand_p use_p;\n \t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, vuse)\n@@ -3571,7 +3571,7 @@ lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n   int region_nr;\n   eh_region r;\n   tree filter, fn;\n-  gimple x;\n+  gimple *x;\n   bool redirected = false;\n \n   region_nr = gimple_eh_dispatch_region (stmt);\n@@ -3748,7 +3748,7 @@ pass_lower_eh_dispatch::execute (function *fun)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      gimple last = last_stmt (bb);\n+      gimple *last = last_stmt (bb);\n       if (last == NULL)\n \tcontinue;\n       if (gimple_code (last) == GIMPLE_EH_DISPATCH)\n@@ -3817,7 +3817,7 @@ mark_reachable_handlers (sbitmap *r_reachablep, sbitmap *lp_reachablep)\n \n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  if (mark_landing_pads)\n \t    {\n@@ -4055,7 +4055,7 @@ unsplit_eh (eh_landing_pad lp)\n     {\n       for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi); )\n \t{\n-\t  gimple use_stmt;\n+\t  gimple *use_stmt;\n \t  gphi *phi = gpi.phi ();\n \t  tree lhs = gimple_phi_result (phi);\n \t  tree rhs = gimple_phi_arg_def (phi, 0);\n@@ -4373,7 +4373,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n {\n   basic_block bb = label_to_block (lp->post_landing_pad);\n   gimple_stmt_iterator gsi;\n-  gimple resx;\n+  gimple *resx;\n   eh_region new_region;\n   edge_iterator ei;\n   edge e, e_out;\n@@ -4456,7 +4456,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n       for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n \tif (e->flags & EDGE_EH)\n \t  {\n-\t    gimple stmt = last_stmt (e->src);\n+\t    gimple *stmt = last_stmt (e->src);\n \t    remove_stmt_from_eh_lp (stmt);\n \t    remove_edge (e);\n \t  }\n@@ -4472,7 +4472,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n       for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n \tif (e->flags & EDGE_EH)\n \t  {\n-\t    gimple stmt = last_stmt (e->src);\n+\t    gimple *stmt = last_stmt (e->src);\n \t    remove_stmt_from_eh_lp (stmt);\n \t    add_stmt_to_eh_lp (stmt, new_lp_nr);\n \t    remove_edge (e);\n@@ -4641,7 +4641,7 @@ make_pass_cleanup_eh (gcc::context *ctxt)\n    edge that make_eh_edges would create.  */\n \n DEBUG_FUNCTION bool\n-verify_eh_edges (gimple stmt)\n+verify_eh_edges (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   eh_landing_pad lp = NULL;"}, {"sha": "c499ae274341ad96ecaf1a16c366782cab37e9bd", "filename": "gcc/tree-eh.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-eh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-eh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -24,32 +24,32 @@ along with GCC; see the file COPYING3.  If not see\n typedef struct eh_region_d *eh_region;\n \n extern void using_eh_for_cleanups (void);\n-extern void add_stmt_to_eh_lp (gimple, int);\n-extern bool remove_stmt_from_eh_lp_fn (struct function *, gimple);\n-extern bool remove_stmt_from_eh_lp (gimple);\n-extern int lookup_stmt_eh_lp_fn (struct function *, gimple);\n-extern int lookup_stmt_eh_lp (gimple);\n+extern void add_stmt_to_eh_lp (gimple *, int);\n+extern bool remove_stmt_from_eh_lp_fn (struct function *, gimple *);\n+extern bool remove_stmt_from_eh_lp (gimple *);\n+extern int lookup_stmt_eh_lp_fn (struct function *, gimple *);\n+extern int lookup_stmt_eh_lp (gimple *);\n extern bool make_eh_dispatch_edges (geh_dispatch *);\n-extern void make_eh_edges (gimple);\n+extern void make_eh_edges (gimple *);\n extern edge redirect_eh_edge (edge, basic_block);\n extern void redirect_eh_dispatch_edge (geh_dispatch *, edge, basic_block);\n extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,\n \t\t\t\t\t   bool, tree, bool *);\n extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);\n extern bool tree_could_trap_p (tree);\n-extern bool stmt_could_throw_p (gimple);\n+extern bool stmt_could_throw_p (gimple *);\n extern bool tree_could_throw_p (tree);\n-extern bool stmt_can_throw_external (gimple);\n-extern bool stmt_can_throw_internal (gimple);\n-extern bool maybe_clean_eh_stmt_fn (struct function *, gimple);\n-extern bool maybe_clean_eh_stmt (gimple);\n-extern bool maybe_clean_or_replace_eh_stmt (gimple, gimple);\n-extern bool maybe_duplicate_eh_stmt_fn (struct function *, gimple,\n-\t\t\t\t\tstruct function *, gimple,\n+extern bool stmt_can_throw_external (gimple *);\n+extern bool stmt_can_throw_internal (gimple *);\n+extern bool maybe_clean_eh_stmt_fn (struct function *, gimple *);\n+extern bool maybe_clean_eh_stmt (gimple *);\n+extern bool maybe_clean_or_replace_eh_stmt (gimple *, gimple *);\n+extern bool maybe_duplicate_eh_stmt_fn (struct function *, gimple *,\n+\t\t\t\t\tstruct function *, gimple *,\n \t\t\t\t\thash_map<void *, void *> *, int);\n-extern bool maybe_duplicate_eh_stmt (gimple, gimple);\n+extern bool maybe_duplicate_eh_stmt (gimple *, gimple *);\n extern void maybe_remove_unreachable_handlers (void);\n-extern bool verify_eh_edges (gimple);\n+extern bool verify_eh_edges (gimple *);\n extern bool verify_eh_dispatch_edge (geh_dispatch *);\n \n #endif /* GCC_TREE_EH_H */"}, {"sha": "71e2cbb93fdccd57ba42a56b7316add7b9895e3b", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -479,7 +479,7 @@ lower_emutls_1 (tree *ptr, int *walk_subtrees, void *cb_data)\n \t     new assignment statement, and substitute yet another SSA_NAME.  */\n \t  if (wi->changed)\n \t    {\n-\t      gimple x;\n+\t      gimple *x;\n \n \t      addr = create_tmp_var (TREE_TYPE (t));\n \t      x = gimple_build_assign (addr, t);\n@@ -539,7 +539,7 @@ lower_emutls_1 (tree *ptr, int *walk_subtrees, void *cb_data)\n /* Lower all of the operands of STMT.  */\n \n static void\n-lower_emutls_stmt (gimple stmt, struct lower_emutls_data *d)\n+lower_emutls_stmt (gimple *stmt, struct lower_emutls_data *d)\n {\n   struct walk_stmt_info wi;\n "}, {"sha": "25c9599566b0b23e0c36aaca70a6593cdf81cf76", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -260,7 +260,7 @@ static tree\n ifc_temp_var (tree type, tree expr, gimple_stmt_iterator *gsi)\n {\n   tree new_name = make_temp_ssa_name (type, NULL, \"_ifc_\");\n-  gimple stmt = gimple_build_assign (new_name, expr);\n+  gimple *stmt = gimple_build_assign (new_name, expr);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return new_name;\n }\n@@ -290,7 +290,7 @@ is_predicated (basic_block bb)\n static enum tree_code\n parse_predicate (tree cond, tree *op0, tree *op1)\n {\n-  gimple s;\n+  gimple *s;\n \n   if (TREE_CODE (cond) == SSA_NAME\n       && is_gimple_assign (s = SSA_NAME_DEF_STMT (cond)))\n@@ -571,7 +571,7 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi,\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_phi_result (phi))\n \t{\n \t  if (gimple_code (USE_STMT (use_p)) == GIMPLE_PHI\n-\t      && USE_STMT (use_p) != (gimple) phi)\n+\t      && USE_STMT (use_p) != phi)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"Difficult to handle this virtual phi.\\n\");\n@@ -606,7 +606,7 @@ struct ifc_dr {\n    (read or written) on every iteration of the if-converted loop.  */\n \n static bool\n-memrefs_read_or_written_unconditionally (gimple stmt,\n+memrefs_read_or_written_unconditionally (gimple *stmt,\n \t\t\t\t\t vec<data_reference_p> drs)\n {\n   int i, j;\n@@ -678,7 +678,7 @@ memrefs_read_or_written_unconditionally (gimple stmt,\n    every iteration of the if-converted loop.  */\n \n static bool\n-write_memrefs_written_at_least_once (gimple stmt,\n+write_memrefs_written_at_least_once (gimple *stmt,\n \t\t\t\t     vec<data_reference_p> drs)\n {\n   int i, j;\n@@ -746,7 +746,7 @@ write_memrefs_written_at_least_once (gimple stmt,\n    iteration unconditionally.  */\n \n static bool\n-ifcvt_memrefs_wont_trap (gimple stmt, vec<data_reference_p> refs)\n+ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> refs)\n {\n   return write_memrefs_written_at_least_once (stmt, refs)\n     && memrefs_read_or_written_unconditionally (stmt, refs);\n@@ -757,7 +757,7 @@ ifcvt_memrefs_wont_trap (gimple stmt, vec<data_reference_p> refs)\n    not trap in the innermost loop containing STMT.  */\n \n static bool\n-ifcvt_could_trap_p (gimple stmt, vec<data_reference_p> refs)\n+ifcvt_could_trap_p (gimple *stmt, vec<data_reference_p> refs)\n {\n   if (gimple_vuse (stmt)\n       && !gimple_could_trap_p_1 (stmt, false, false)\n@@ -771,7 +771,7 @@ ifcvt_could_trap_p (gimple stmt, vec<data_reference_p> refs)\n    (conditional load or store based on a mask computed from bb predicate).  */\n \n static bool\n-ifcvt_can_use_mask_load_store (gimple stmt)\n+ifcvt_can_use_mask_load_store (gimple *stmt)\n {\n   tree lhs, ref;\n   machine_mode mode;\n@@ -825,7 +825,7 @@ ifcvt_can_use_mask_load_store (gimple stmt)\n    - LHS is not var decl.  */\n \n static bool\n-if_convertible_gimple_assign_stmt_p (gimple stmt,\n+if_convertible_gimple_assign_stmt_p (gimple *stmt,\n \t\t\t\t     vec<data_reference_p> refs,\n \t\t\t\t     bool *any_mask_load_store)\n {\n@@ -919,7 +919,7 @@ if_convertible_gimple_assign_stmt_p (gimple stmt,\n    - it is builtins call.  */\n \n static bool\n-if_convertible_stmt_p (gimple stmt, vec<data_reference_p> refs,\n+if_convertible_stmt_p (gimple *stmt, vec<data_reference_p> refs,\n \t\t       bool *any_mask_load_store)\n {\n   switch (gimple_code (stmt))\n@@ -1174,7 +1174,7 @@ predicate_bbs (loop_p loop)\n     {\n       basic_block bb = ifc_bbs[i];\n       tree cond;\n-      gimple stmt;\n+      gimple *stmt;\n \n       /* The loop latch and loop exit block are always executed and\n \t have no extra conditions to be processed: skip them.  */\n@@ -1421,12 +1421,12 @@ if_convertible_loop_p (struct loop *loop, bool *any_mask_load_store)\n    EXTENDED is true if PHI has > 2 arguments.  */\n \n static bool\n-is_cond_scalar_reduction (gimple phi, gimple *reduc, tree arg_0, tree arg_1,\n+is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n \t\t\t  tree *op0, tree *op1, bool extended)\n {\n   tree lhs, r_op1, r_op2;\n-  gimple stmt;\n-  gimple header_phi = NULL;\n+  gimple *stmt;\n+  gimple *header_phi = NULL;\n   enum tree_code reduction_op;\n   basic_block bb = gimple_bb (phi);\n   struct loop *loop = bb->loop_father;\n@@ -1498,7 +1498,7 @@ is_cond_scalar_reduction (gimple phi, gimple *reduc, tree arg_0, tree arg_1,\n   /* Check that R_OP1 is used in reduction stmt or in PHI only.  */\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, r_op1)\n     {\n-      gimple use_stmt = USE_STMT (use_p);\n+      gimple *use_stmt = USE_STMT (use_p);\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n       if (use_stmt == stmt)\n@@ -1531,11 +1531,11 @@ is_cond_scalar_reduction (gimple phi, gimple *reduc, tree arg_0, tree arg_1,\n   Returns rhs of resulting PHI assignment.  */\n \n static tree\n-convert_scalar_cond_reduction (gimple reduc, gimple_stmt_iterator *gsi,\n+convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n \t\t\t       tree cond, tree op0, tree op1, bool swap)\n {\n   gimple_stmt_iterator stmt_it;\n-  gimple new_assign;\n+  gimple *new_assign;\n   tree rhs;\n   tree rhs1 = gimple_assign_rhs1 (reduc);\n   tree tmp = make_temp_ssa_name (TREE_TYPE (rhs1), NULL, \"_ifc_\");\n@@ -1624,7 +1624,7 @@ gen_phi_arg_condition (gphi *phi, vec<int> *occur,\n static void\n predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n {\n-  gimple new_stmt = NULL, reduc;\n+  gimple *new_stmt = NULL, *reduc;\n   tree rhs, res, arg0, arg1, op0, op1, scev;\n   tree cond;\n   unsigned int index0;\n@@ -2045,7 +2045,7 @@ predicate_mem_writes (loop_p loop)\n       basic_block bb = ifc_bbs[i];\n       tree cond = bb_predicate (bb);\n       bool swap;\n-      gimple stmt;\n+      gimple *stmt;\n       int index;\n \n       if (is_true_predicate (cond))\n@@ -2069,7 +2069,7 @@ predicate_mem_writes (loop_p loop)\n \t    tree lhs = gimple_assign_lhs (stmt);\n \t    tree rhs = gimple_assign_rhs1 (stmt);\n \t    tree ref, addr, ptr, masktype, mask_op0, mask_op1, mask;\n-\t    gimple new_stmt;\n+\t    gimple *new_stmt;\n \t    int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n \t    ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n \t    mark_addressable (ref);\n@@ -2266,7 +2266,7 @@ combine_blocks (struct loop *loop, bool any_mask_load_store)\n \t could have derived it from.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  gimple_set_bb (stmt, merge_target_bb);\n \t  if (predicated[i])\n \t    {\n@@ -2310,7 +2310,7 @@ version_loop_for_if_conversion (struct loop *loop)\n   basic_block cond_bb;\n   tree cond = make_ssa_name (boolean_type_node);\n   struct loop *new_loop;\n-  gimple g;\n+  gimple *g;\n   gimple_stmt_iterator gsi;\n \n   g = gimple_build_call_internal (IFN_LOOP_VECTORIZED, 2,\n@@ -2344,7 +2344,7 @@ ifcvt_split_critical_edges (struct loop *loop)\n   basic_block bb;\n   unsigned int num = loop->num_nodes;\n   unsigned int i;\n-  gimple stmt;\n+  gimple *stmt;\n   edge e;\n   edge_iterator ei;\n \n@@ -2380,11 +2380,11 @@ ifcvt_split_critical_edges (struct loop *loop)\n    use statement with newly created lhs.  */\n \n static void\n-ifcvt_split_def_stmt (gimple def_stmt, gimple use_stmt)\n+ifcvt_split_def_stmt (gimple *def_stmt, gimple *use_stmt)\n {\n   tree var;\n   tree lhs;\n-  gimple copy_stmt;\n+  gimple *copy_stmt;\n   gimple_stmt_iterator gsi;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n@@ -2420,12 +2420,12 @@ ifcvt_split_def_stmt (gimple def_stmt, gimple use_stmt)\n    not have single use.  */\n \n static void\n-ifcvt_walk_pattern_tree (tree var, vec<gimple> *defuse_list,\n-\t\t\t gimple use_stmt)\n+ifcvt_walk_pattern_tree (tree var, vec<gimple *> *defuse_list,\n+\t\t\t gimple *use_stmt)\n {\n   tree rhs1, rhs2;\n   enum tree_code code;\n-  gimple def_stmt;\n+  gimple *def_stmt;\n \n   def_stmt = SSA_NAME_DEF_STMT (var);\n   if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n@@ -2475,7 +2475,7 @@ ifcvt_walk_pattern_tree (tree var, vec<gimple> *defuse_list,\n    by vectorizer.  */\n \n static bool\n-stmt_is_root_of_bool_pattern (gimple stmt)\n+stmt_is_root_of_bool_pattern (gimple *stmt)\n {\n   enum tree_code code;\n   tree lhs, rhs;\n@@ -2511,10 +2511,10 @@ static void\n ifcvt_repair_bool_pattern (basic_block bb)\n {\n   tree rhs;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n-  vec<gimple> defuse_list = vNULL;\n-  vec<gimple> pattern_roots = vNULL;\n+  vec<gimple *> defuse_list = vNULL;\n+  vec<gimple *> pattern_roots = vNULL;\n   bool repeat = true;\n   int niter = 0;\n   unsigned int ix;\n@@ -2546,7 +2546,7 @@ ifcvt_repair_bool_pattern (basic_block bb)\n \t  while (defuse_list.length () > 0)\n \t    {\n \t      repeat = true;\n-\t      gimple def_stmt, use_stmt;\n+\t      gimple *def_stmt, *use_stmt;\n \t      use_stmt = defuse_list.pop ();\n \t      def_stmt = defuse_list.pop ();\n \t      ifcvt_split_def_stmt (def_stmt, use_stmt);\n@@ -2565,11 +2565,11 @@ ifcvt_repair_bool_pattern (basic_block bb)\n static void\n ifcvt_local_dce (basic_block bb)\n {\n-  gimple stmt;\n-  gimple stmt1;\n-  gimple phi;\n+  gimple *stmt;\n+  gimple *stmt1;\n+  gimple *phi;\n   gimple_stmt_iterator gsi;\n-  vec<gimple> worklist;\n+  vec<gimple *> worklist;\n   enum gimple_code code;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;"}, {"sha": "abaea3f64d9d9fbb68c2cf3ac6455dde3bcebb98", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -144,9 +144,9 @@ static void prepend_lexical_block (tree current_block, tree new_block);\n static tree copy_decl_to_var (tree, copy_body_data *);\n static tree copy_result_decl_to_var (tree, copy_body_data *);\n static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n-static gimple_seq remap_gimple_stmt (gimple, copy_body_data *);\n+static gimple_seq remap_gimple_stmt (gimple *, copy_body_data *);\n static bool delete_unreachable_blocks_update_callgraph (copy_body_data *id);\n-static void insert_init_stmt (copy_body_data *, basic_block, gimple);\n+static void insert_init_stmt (copy_body_data *, basic_block, gimple *);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n    that the trees should be variables, it is used for more than that.  */\n@@ -214,7 +214,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n \t{\n \t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n-\t  gimple def_temp;\n+\t  gimple *def_temp;\n \t  gimple_stmt_iterator gsi;\n \t  tree val = SSA_NAME_VAR (name);\n \n@@ -317,7 +317,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t\t  || EDGE_COUNT (id->entry_bb->preds) != 1))\n \t    {\n \t      gimple_stmt_iterator gsi = gsi_last_bb (id->entry_bb);\n-\t      gimple init_stmt;\n+\t      gimple *init_stmt;\n \t      tree zero = build_zero_cst (TREE_TYPE (new_tree));\n \n \t      init_stmt = gimple_build_assign (new_tree, zero);\n@@ -797,10 +797,10 @@ remap_gimple_seq (gimple_seq body, copy_body_data *id)\n /* Copy a GIMPLE_BIND statement STMT, remapping all the symbols in its\n    block using the mapping information in ID.  */\n \n-static gimple\n+static gimple *\n copy_gimple_bind (gbind *stmt, copy_body_data *id)\n {\n-  gimple new_bind;\n+  gimple *new_bind;\n   tree new_block, new_vars;\n   gimple_seq body, new_body;\n \n@@ -1319,9 +1319,9 @@ remap_eh_region_tree_nr (tree old_t_nr, copy_body_data *id)\n    information in ID.  Return the new statement copy.  */\n \n static gimple_seq\n-remap_gimple_stmt (gimple stmt, copy_body_data *id)\n+remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n {\n-  gimple copy = NULL;\n+  gimple *copy = NULL;\n   struct walk_stmt_info wi;\n   bool skip_first = false;\n   gimple_seq stmts = NULL;\n@@ -1348,7 +1348,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \n       if (retbnd && bndslot)\n \t{\n-\t  gimple bndcopy = gimple_build_assign (bndslot, retbnd);\n+\t  gimple *bndcopy = gimple_build_assign (bndslot, retbnd);\n \t  memset (&wi, 0, sizeof (wi));\n \t  wi.info = id;\n \t  walk_gimple_op (bndcopy, remap_gimple_op_r, &wi);\n@@ -1576,7 +1576,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t  if (TREE_CODE (lhs) == MEM_REF\n \t      && TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME)\n \t    {\n-\t      gimple def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (lhs, 0));\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (lhs, 0));\n \t      if (gimple_bb (def_stmt)\n \t\t  && !bitmap_bit_p (id->blocks_to_copy,\n \t\t\t\t    gimple_bb (def_stmt)->index))\n@@ -1750,8 +1750,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple_seq stmts;\n-      gimple stmt = gsi_stmt (gsi);\n-      gimple orig_stmt = stmt;\n+      gimple *stmt = gsi_stmt (gsi);\n+      gimple *orig_stmt = stmt;\n       gimple_stmt_iterator stmts_gsi;\n       bool stmt_added = false;\n \n@@ -1908,7 +1908,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t the number of anonymous arguments.  */\n \t      size_t nargs = gimple_call_num_args (id->call_stmt), i;\n \t      tree count, p;\n-\t      gimple new_stmt;\n+\t      gimple *new_stmt;\n \n \t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n \t\tnargs--;\n@@ -2204,7 +2204,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \n   for (si = gsi_start_bb (new_bb); !gsi_end_p (si);)\n     {\n-      gimple copy_stmt;\n+      gimple *copy_stmt;\n       bool can_throw, nonlocal_goto;\n \n       copy_stmt = gsi_stmt (si);\n@@ -2479,7 +2479,7 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n       gimple_stmt_iterator dsi = gsi_after_labels (e->dest);\n       while (is_gimple_debug (gsi_stmt (ssi)))\n \t{\n-\t  gimple stmt = gsi_stmt (ssi);\n+\t  gimple *stmt = gsi_stmt (ssi);\n \t  gdebug *new_stmt;\n \t  tree var;\n \t  tree value;\n@@ -2582,10 +2582,10 @@ void\n redirect_all_calls (copy_body_data * id, basic_block bb)\n {\n   gimple_stmt_iterator si;\n-  gimple last = last_stmt (bb);\n+  gimple *last = last_stmt (bb);\n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n-      gimple stmt = gsi_stmt (si);\n+      gimple *stmt = gsi_stmt (si);\n       if (is_gimple_call (stmt))\n \t{\n \t  struct cgraph_edge *edge = id->dst_node->get_edge (stmt);\n@@ -2978,12 +2978,12 @@ self_inlining_addr_expr (tree value, tree fn)\n    lexical block and line number information from base_stmt, if given,\n    or from the last stmt of the block otherwise.  */\n \n-static gimple\n+static gimple *\n insert_init_debug_bind (copy_body_data *id,\n \t\t\tbasic_block bb, tree var, tree value,\n-\t\t\tgimple base_stmt)\n+\t\t\tgimple *base_stmt)\n {\n-  gimple note;\n+  gimple *note;\n   gimple_stmt_iterator gsi;\n   tree tracked_var;\n \n@@ -3018,7 +3018,7 @@ insert_init_debug_bind (copy_body_data *id,\n }\n \n static void\n-insert_init_stmt (copy_body_data *id, basic_block bb, gimple init_stmt)\n+insert_init_stmt (copy_body_data *id, basic_block bb, gimple *init_stmt)\n {\n   /* If VAR represents a zero-sized variable, it's possible that the\n      assignment statement may result in no gimple statements.  */\n@@ -3057,11 +3057,11 @@ insert_init_stmt (copy_body_data *id, basic_block bb, gimple init_stmt)\n /* Initialize parameter P with VALUE.  If needed, produce init statement\n    at the end of BB.  When BB is NULL, we return init statement to be\n    output later.  */\n-static gimple\n+static gimple *\n setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t\t     basic_block bb, tree *vars)\n {\n-  gimple init_stmt = NULL;\n+  gimple *init_stmt = NULL;\n   tree var;\n   tree rhs = value;\n   tree def = (gimple_in_ssa_p (cfun)\n@@ -3219,7 +3219,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n    top of the stack in ID from the GIMPLE_CALL STMT.  */\n \n static void\n-initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n+initialize_inlined_parameters (copy_body_data *id, gimple *stmt,\n \t\t\t       tree fn, basic_block bb)\n {\n   tree parms;\n@@ -3571,7 +3571,7 @@ inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n {\n   tree fn = (tree) wip->info;\n   tree t;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -3708,7 +3708,7 @@ inline_forbidden_p (tree fndecl)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      gimple ret;\n+      gimple *ret;\n       gimple_seq seq = bb_seq (bb);\n       ret = walk_gimple_seq (seq, inline_forbidden_p_stmt, NULL, &wi);\n       forbidden_p = (ret != NULL);\n@@ -3990,7 +3990,7 @@ int estimate_num_insns_seq (gimple_seq stmts, eni_weights *weights)\n    WEIGHTS contains weights attributed to various constructs.  */\n \n int\n-estimate_num_insns (gimple stmt, eni_weights *weights)\n+estimate_num_insns (gimple *stmt, eni_weights *weights)\n {\n   unsigned cost, i;\n   enum gimple_code code = gimple_code (stmt);\n@@ -4375,7 +4375,7 @@ reset_debug_bindings (copy_body_data *id, gimple_stmt_iterator gsi)\n /* If STMT is a GIMPLE_CALL, replace it with its inline expansion.  */\n \n static bool\n-expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n+expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n {\n   tree use_retvar;\n   tree fn;\n@@ -4712,7 +4712,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      'a = foo (...)', substitute the call with 'a = USE_RETVAR'.  */\n   if (use_retvar && gimple_call_lhs (stmt))\n     {\n-      gimple old_stmt = stmt;\n+      gimple *old_stmt = stmt;\n       stmt = gimple_build_assign (gimple_call_lhs (stmt), use_retvar);\n       gsi_replace (&stmt_gsi, stmt, false);\n       maybe_clean_or_replace_eh_stmt (old_stmt, stmt);\n@@ -4756,8 +4756,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   /* Put returned bounds into the correct place if required.  */\n   if (return_bounds)\n     {\n-      gimple old_stmt = SSA_NAME_DEF_STMT (return_bounds);\n-      gimple new_stmt = gimple_build_assign (return_bounds, id->retbnd);\n+      gimple *old_stmt = SSA_NAME_DEF_STMT (return_bounds);\n+      gimple *new_stmt = gimple_build_assign (return_bounds, id->retbnd);\n       gimple_stmt_iterator bnd_gsi = gsi_for_stmt (old_stmt);\n       unlink_stmt_vdef (old_stmt);\n       gsi_replace (&bnd_gsi, new_stmt, false);\n@@ -4818,7 +4818,7 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n \n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       gsi_prev (&gsi);\n \n       if (is_gimple_call (stmt)\n@@ -4834,7 +4834,7 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n    in the STATEMENTS pointer set.  */\n \n static void\n-fold_marked_statements (int first, hash_set<gimple> *statements)\n+fold_marked_statements (int first, hash_set<gimple *> *statements)\n {\n   for (; first < n_basic_blocks_for_fn (cfun); first++)\n     if (BASIC_BLOCK_FOR_FN (cfun, first))\n@@ -4846,7 +4846,7 @@ fold_marked_statements (int first, hash_set<gimple> *statements)\n \t     gsi_next (&gsi))\n \t  if (statements->contains (gsi_stmt (gsi)))\n \t    {\n-\t      gimple old_stmt = gsi_stmt (gsi);\n+\t      gimple *old_stmt = gsi_stmt (gsi);\n \t      tree old_decl = is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;\n \n \t      if (old_decl && DECL_BUILT_IN (old_decl))\n@@ -4857,7 +4857,7 @@ fold_marked_statements (int first, hash_set<gimple> *statements)\n \t\t  gsi_prev (&i2);\n \t\t  if (fold_stmt (&gsi))\n \t\t    {\n-\t\t      gimple new_stmt;\n+\t\t      gimple *new_stmt;\n \t\t      /* If a builtin at the end of a bb folded into nothing,\n \t\t\t the following loop won't work.  */\n \t\t      if (gsi_end_p (gsi))\n@@ -4903,7 +4903,7 @@ fold_marked_statements (int first, hash_set<gimple> *statements)\n \t\t{\n \t\t  /* Re-read the statement from GSI as fold_stmt() may\n \t\t     have changed it.  */\n-\t\t  gimple new_stmt = gsi_stmt (gsi);\n+\t\t  gimple *new_stmt = gsi_stmt (gsi);\n \t\t  update_stmt (new_stmt);\n \n \t\t  if (is_gimple_call (old_stmt)\n@@ -4945,7 +4945,7 @@ optimize_inline_calls (tree fn)\n   id.transform_return_to_modify = true;\n   id.transform_parameter = true;\n   id.transform_lang_insert_block = NULL;\n-  id.statements_to_fold = new hash_set<gimple>;\n+  id.statements_to_fold = new hash_set<gimple *>;\n \n   push_gimplify_context ();\n \n@@ -5190,7 +5190,7 @@ replace_locals_stmt (gimple_stmt_iterator *gsip,\n \t\t     struct walk_stmt_info *wi)\n {\n   copy_body_data *id = (copy_body_data *) wi->info;\n-  gimple gs = gsi_stmt (*gsip);\n+  gimple *gs = gsi_stmt (*gsip);\n \n   if (gbind *stmt = dyn_cast <gbind *> (gs))\n     {\n@@ -5633,7 +5633,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   unsigned i;\n   struct ipa_replace_map *replace_info;\n   basic_block old_entry_block, bb;\n-  auto_vec<gimple, 10> init_stmts;\n+  auto_vec<gimple *, 10> init_stmts;\n   tree vars = NULL_TREE;\n \n   gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL\n@@ -5675,7 +5675,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   memset (&id, 0, sizeof (id));\n \n   /* Generate a new name for the new version. */\n-  id.statements_to_fold = new hash_set<gimple>;\n+  id.statements_to_fold = new hash_set<gimple *>;\n \n   id.decl_map = new hash_map<tree, tree>;\n   id.debug_map = NULL;\n@@ -5715,7 +5715,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   if (tree_map)\n     for (i = 0; i < tree_map->length (); i++)\n       {\n-\tgimple init;\n+\tgimple *init;\n \treplace_info = (*tree_map)[i];\n \tif (replace_info->replace_p)\n \t  {"}, {"sha": "f0e5436dd4e8689545aa582335858bd551a70753", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -67,7 +67,7 @@ struct copy_body_data\n   tree retbnd;\n \n   /* Assign statements that need bounds copy.  */\n-  vec<gimple> assign_stmts;\n+  vec<gimple *> assign_stmts;\n \n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n@@ -81,7 +81,7 @@ struct copy_body_data\n \n   /* GIMPLE_CALL if va arg parameter packs should be expanded or NULL\n      is not.  */\n-  gimple call_stmt;\n+  gimple *call_stmt;\n \n   /* Exception landing pad the inlined call lies in.  */\n   int eh_lp_nr;\n@@ -123,7 +123,7 @@ struct copy_body_data\n   void (*transform_lang_insert_block) (tree);\n \n   /* Statements that might be possibly folded.  */\n-  hash_set<gimple> *statements_to_fold;\n+  hash_set<gimple *> *statements_to_fold;\n \n   /* Entry basic block to currently copied body.  */\n   basic_block entry_bb;\n@@ -205,7 +205,7 @@ bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n tree copy_decl_no_change (tree decl, copy_body_data *id);\n int estimate_move_cost (tree type, bool);\n-int estimate_num_insns (gimple, eni_weights *);\n+int estimate_num_insns (gimple *, eni_weights *);\n int estimate_num_insns_fn (tree, eni_weights *);\n int count_insns_seq (gimple_seq, eni_weights *);\n bool tree_versionable_function_p (tree);"}, {"sha": "a19f4e385f2bd44c24789d44e9f6d980262dd54f", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -298,7 +298,7 @@ marked_for_renaming (tree sym)\n    decided in mark_def_sites.  */\n \n static inline bool\n-rewrite_uses_p (gimple stmt)\n+rewrite_uses_p (gimple *stmt)\n {\n   return gimple_visited_p (stmt);\n }\n@@ -307,7 +307,7 @@ rewrite_uses_p (gimple stmt)\n /* Set the rewrite marker on STMT to the value given by REWRITE_P.  */\n \n static inline void\n-set_rewrite_uses (gimple stmt, bool rewrite_p)\n+set_rewrite_uses (gimple *stmt, bool rewrite_p)\n {\n   gimple_set_visited (stmt, rewrite_p);\n }\n@@ -322,7 +322,7 @@ set_rewrite_uses (gimple stmt, bool rewrite_p)\n    registered, but they don't need to have their uses renamed.  */\n \n static inline bool\n-register_defs_p (gimple stmt)\n+register_defs_p (gimple *stmt)\n {\n   return gimple_plf (stmt, GF_PLF_1) != 0;\n }\n@@ -331,7 +331,7 @@ register_defs_p (gimple stmt)\n /* If REGISTER_DEFS_P is true, mark STMT to have its DEFs registered.  */\n \n static inline void\n-set_register_defs (gimple stmt, bool register_defs_p)\n+set_register_defs (gimple *stmt, bool register_defs_p)\n {\n   gimple_set_plf (stmt, GF_PLF_1, register_defs_p);\n }\n@@ -442,12 +442,12 @@ set_current_def (tree var, tree def)\n static void\n initialize_flags_in_bb (basic_block bb)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple phi = gsi_stmt (gsi);\n+      gimple *phi = gsi_stmt (gsi);\n       set_rewrite_uses (phi, false);\n       set_register_defs (phi, false);\n     }\n@@ -663,7 +663,7 @@ add_new_name_mapping (tree new_tree, tree old)\n    we create.  */\n \n static void\n-mark_def_sites (basic_block bb, gimple stmt, bitmap kills)\n+mark_def_sites (basic_block bb, gimple *stmt, bitmap kills)\n {\n   tree def;\n   use_operand_p use_p;\n@@ -1049,8 +1049,8 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n \t  tracked_var = target_for_debug_bind (var);\n \t  if (tracked_var)\n \t    {\n-\t      gimple note = gimple_build_debug_bind (tracked_var,\n-\t\t\t\t\t\t     PHI_RESULT (phi),\n+\t      gimple *note = gimple_build_debug_bind (tracked_var,\n+\t\t\t\t\t\t      PHI_RESULT (phi),\n \t\t\t\t\t\t     phi);\n \t      gimple_stmt_iterator si = gsi_after_labels (bb);\n \t      gsi_insert_before (&si, note, GSI_SAME_STMT);\n@@ -1206,7 +1206,7 @@ get_reaching_def (tree var)\n /* Helper function for rewrite_stmt.  Rewrite uses in a debug stmt.  */\n \n static void\n-rewrite_debug_stmt_uses (gimple stmt)\n+rewrite_debug_stmt_uses (gimple *stmt)\n {\n   use_operand_p use_p;\n   ssa_op_iter iter;\n@@ -1233,7 +1233,7 @@ rewrite_debug_stmt_uses (gimple stmt)\n \t\t   !gsi_end_p (gsi) && lim > 0;\n \t\t   gsi_next (&gsi), lim--)\n \t\t{\n-\t\t  gimple gstmt = gsi_stmt (gsi);\n+\t\t  gimple *gstmt = gsi_stmt (gsi);\n \t\t  if (!gimple_debug_source_bind_p (gstmt))\n \t\t    break;\n \t\t  if (gimple_debug_source_bind_get_value (gstmt) == var)\n@@ -1248,7 +1248,7 @@ rewrite_debug_stmt_uses (gimple stmt)\n \t      /* If not, add a new source bind stmt.  */\n \t      if (def == NULL_TREE)\n \t\t{\n-\t\t  gimple def_temp;\n+\t\t  gimple *def_temp;\n \t\t  def = make_node (DEBUG_EXPR_DECL);\n \t\t  def_temp = gimple_build_debug_source_bind (def, var, NULL);\n \t\t  DECL_ARTIFICIAL (def) = 1;\n@@ -1315,7 +1315,7 @@ rewrite_stmt (gimple_stmt_iterator *si)\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n-  gimple stmt = gsi_stmt (*si);\n+  gimple *stmt = gsi_stmt (*si);\n \n   /* If mark_def_sites decided that we don't need to rewrite this\n      statement, ignore it.  */\n@@ -1373,7 +1373,7 @@ rewrite_stmt (gimple_stmt_iterator *si)\n \ttracked_var = target_for_debug_bind (var);\n \tif (tracked_var)\n \t  {\n-\t    gimple note = gimple_build_debug_bind (tracked_var, name, stmt);\n+\t    gimple *note = gimple_build_debug_bind (tracked_var, name, stmt);\n \t    gsi_insert_after (si, note, GSI_SAME_STMT);\n \t  }\n       }\n@@ -1824,7 +1824,7 @@ maybe_replace_use_in_debug_stmt (use_operand_p use_p)\n    DEF_P.  Returns whether the statement should be removed.  */\n \n static inline bool\n-maybe_register_def (def_operand_p def_p, gimple stmt,\n+maybe_register_def (def_operand_p def_p, gimple *stmt,\n \t\t    gimple_stmt_iterator gsi)\n {\n   tree def = DEF_FROM_PTR (def_p);\n@@ -1854,7 +1854,7 @@ maybe_register_def (def_operand_p def_p, gimple stmt,\n \t  tree tracked_var = target_for_debug_bind (sym);\n \t  if (tracked_var)\n \t    {\n-\t      gimple note = gimple_build_debug_bind (tracked_var, def, stmt);\n+\t      gimple *note = gimple_build_debug_bind (tracked_var, def, stmt);\n \t      /* If stmt ends the bb, insert the debug stmt on the single\n \t\t non-EH edge from the stmt.  */\n \t      if (gsi_one_before_end_p (gsi) && stmt_ends_bb_p (stmt))\n@@ -1922,7 +1922,7 @@ maybe_register_def (def_operand_p def_p, gimple stmt,\n    in OLD_SSA_NAMES.  Returns whether STMT should be removed.  */\n \n static bool\n-rewrite_update_stmt (gimple stmt, gimple_stmt_iterator gsi)\n+rewrite_update_stmt (gimple *stmt, gimple_stmt_iterator gsi)\n {\n   use_operand_p use_p;\n   def_operand_p def_p;\n@@ -2057,7 +2057,7 @@ rewrite_update_phi_arguments (basic_block bb)\n \t\tlocus = UNKNOWN_LOCATION;\n \t      else\n \t\t{\n-\t\t  gimple stmt = SSA_NAME_DEF_STMT (reaching_def);\n+\t\t  gimple *stmt = SSA_NAME_DEF_STMT (reaching_def);\n \t\t  gphi *other_phi = dyn_cast <gphi *> (stmt);\n \n \t\t  /* Single element PHI nodes  behave like copies, so get the\n@@ -2430,7 +2430,8 @@ make_pass_build_ssa (gcc::context *ctxt)\n    renamer.  BLOCKS is the set of blocks that need updating.  */\n \n static void\n-mark_def_interesting (tree var, gimple stmt, basic_block bb, bool insert_phi_p)\n+mark_def_interesting (tree var, gimple *stmt, basic_block bb,\n+\t\t      bool insert_phi_p)\n {\n   gcc_checking_assert (bitmap_bit_p (blocks_to_update, bb->index));\n   set_register_defs (stmt, true);\n@@ -2461,7 +2462,8 @@ mark_def_interesting (tree var, gimple stmt, basic_block bb, bool insert_phi_p)\n    nodes.  */\n \n static inline void\n-mark_use_interesting (tree var, gimple stmt, basic_block bb, bool insert_phi_p)\n+mark_use_interesting (tree var, gimple *stmt, basic_block bb,\n+\t\t      bool insert_phi_p)\n {\n   basic_block def_bb = gimple_bb (stmt);\n \n@@ -2548,7 +2550,7 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p)\n   for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n        gsi_next (&si))\n     {\n-      gimple stmt;\n+      gimple *stmt;\n       ssa_op_iter i;\n       use_operand_p use_p;\n       def_operand_p def_p;\n@@ -2612,7 +2614,7 @@ prepare_use_sites_for (tree name, bool insert_phi_p)\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n     {\n-      gimple stmt = USE_STMT (use_p);\n+      gimple *stmt = USE_STMT (use_p);\n       basic_block bb = gimple_bb (stmt);\n \n       if (gimple_code (stmt) == GIMPLE_PHI)\n@@ -2638,7 +2640,7 @@ prepare_use_sites_for (tree name, bool insert_phi_p)\n static void\n prepare_def_site_for (tree name, bool insert_phi_p)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   basic_block bb;\n \n   gcc_checking_assert (names_to_release == NULL\n@@ -2849,7 +2851,7 @@ delete_update_ssa (void)\n    update_ssa's tables.  */\n \n tree\n-create_new_def_for (tree old_name, gimple stmt, def_operand_p def)\n+create_new_def_for (tree old_name, gimple *stmt, def_operand_p def)\n {\n   tree new_name;\n \n@@ -2907,7 +2909,7 @@ mark_virtual_operand_for_renaming (tree name)\n   bool used = false;\n   imm_use_iterator iter;\n   use_operand_p use_p;\n-  gimple stmt;\n+  gimple *stmt;\n \n   gcc_assert (VAR_DECL_IS_VIRTUAL_OPERAND (name_var));\n   FOR_EACH_IMM_USE_STMT (stmt, iter, name)\n@@ -3189,7 +3191,7 @@ update_ssa (unsigned update_flags)\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  ssa_op_iter i;\n \t  use_operand_p use_p;"}, {"sha": "c053f7852003597b25ddf8dc94f283ac0d7d5c2a", "filename": "gcc/tree-into-ssa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-into-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-into-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n extern tree get_current_def (tree);\n extern void set_current_def (tree, tree);\n void delete_update_ssa (void);\n-tree create_new_def_for (tree, gimple, def_operand_p);\n+tree create_new_def_for (tree, gimple *, def_operand_p);\n void mark_virtual_operands_for_renaming (struct function *);\n void mark_virtual_operand_for_renaming (tree);\n void mark_virtual_phi_result_for_renaming (gphi *);"}, {"sha": "d9380fd786ad013c466f0914686d18103922f3ea", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -76,7 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n typedef struct rdg_vertex\n {\n   /* The statement represented by this vertex.  */\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Vector of data-references in this statement.  */\n   vec<data_reference_p> datarefs;\n@@ -243,7 +243,7 @@ dot_rdg (struct graph *rdg)\n /* Returns the index of STMT in RDG.  */\n \n static int\n-rdg_vertex_for_stmt (struct graph *rdg ATTRIBUTE_UNUSED, gimple stmt)\n+rdg_vertex_for_stmt (struct graph *rdg ATTRIBUTE_UNUSED, gimple *stmt)\n {\n   int index = gimple_uid (stmt);\n   gcc_checking_assert (index == -1 || RDG_STMT (rdg, index) == stmt);\n@@ -285,7 +285,7 @@ create_edge_for_control_dependence (struct graph *rdg, basic_block bb,\n \t\t\t    0, edge_n, bi)\n     {\n       basic_block cond_bb = cd->get_edge (edge_n)->src;\n-      gimple stmt = last_stmt (cond_bb);\n+      gimple *stmt = last_stmt (cond_bb);\n       if (stmt && is_ctrl_stmt (stmt))\n \t{\n \t  struct graph_edge *e;\n@@ -324,7 +324,7 @@ create_rdg_cd_edges (struct graph *rdg, control_dependences *cd)\n \n   for (i = 0; i < rdg->n_vertices; i++)\n     {\n-      gimple stmt = RDG_STMT (rdg, i);\n+      gimple *stmt = RDG_STMT (rdg, i);\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n \t  edge_iterator ei;\n@@ -341,11 +341,11 @@ create_rdg_cd_edges (struct graph *rdg, control_dependences *cd)\n    if that failed.  */\n \n static bool\n-create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop,\n+create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop,\n \t\t     vec<data_reference_p> *datarefs)\n {\n   int i;\n-  gimple stmt;\n+  gimple *stmt;\n \n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n@@ -384,7 +384,7 @@ create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop,\n    identifying statements in loop copies.  */\n \n static void\n-stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n+stmts_from_loop (struct loop *loop, vec<gimple *> *stmts)\n {\n   unsigned int i;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n@@ -401,7 +401,7 @@ stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n       for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n \t   gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  if (gimple_code (stmt) != GIMPLE_LABEL && !is_gimple_debug (stmt))\n \t    stmts->safe_push (stmt);\n \t}\n@@ -447,7 +447,7 @@ build_rdg (vec<loop_p> loop_nest, control_dependences *cd)\n   vec<data_reference_p> datarefs;\n \n   /* Create the RDG vertices from the stmts of the loop nest.  */\n-  auto_vec<gimple, 10> stmts;\n+  auto_vec<gimple *, 10> stmts;\n   stmts_from_loop (loop_nest[0], &stmts);\n   rdg = new_graph (stmts.length ());\n   datarefs.create (10);\n@@ -550,7 +550,7 @@ ssa_name_has_uses_outside_loop_p (tree def, loop_p loop)\n \n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n     {\n-      gimple use_stmt = USE_STMT (use_p);\n+      gimple *use_stmt = USE_STMT (use_p);\n       if (!is_gimple_debug (use_stmt)\n \t  && loop != loop_containing_stmt (use_stmt))\n \treturn true;\n@@ -563,7 +563,7 @@ ssa_name_has_uses_outside_loop_p (tree def, loop_p loop)\n    loop LOOP.  */\n \n static bool\n-stmt_has_scalar_dependences_outside_loop (loop_p loop, gimple stmt)\n+stmt_has_scalar_dependences_outside_loop (loop_p loop, gimple *stmt)\n {\n   def_operand_p def_p;\n   ssa_op_iter op_iter;\n@@ -648,7 +648,7 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n \n \tfor (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t  {\n-\t    gimple stmt = gsi_stmt (bsi);\n+\t    gimple *stmt = gsi_stmt (bsi);\n \t    if (gimple_code (stmt) != GIMPLE_LABEL\n \t\t&& !is_gimple_debug (stmt)\n \t\t&& !bitmap_bit_p (partition->stmts, gimple_uid (stmt)))\n@@ -672,7 +672,7 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n \n       for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);)\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  if (gimple_code (stmt) != GIMPLE_LABEL\n \t      && !is_gimple_debug (stmt)\n \t      && !bitmap_bit_p (partition->stmts, gimple_uid (stmt)))\n@@ -779,7 +779,7 @@ static void\n generate_memset_builtin (struct loop *loop, partition_t partition)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt, fn_call;\n+  gimple *stmt, *fn_call;\n   tree mem, fn, nb_bytes;\n   location_t loc;\n   tree val;\n@@ -810,7 +810,7 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n   else if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (val)))\n     {\n       tree tem = make_ssa_name (integer_type_node);\n-      gimple cstmt = gimple_build_assign (tem, NOP_EXPR, val);\n+      gimple *cstmt = gimple_build_assign (tem, NOP_EXPR, val);\n       gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n       val = tem;\n     }\n@@ -835,7 +835,7 @@ static void\n generate_memcpy_builtin (struct loop *loop, partition_t partition)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt, fn_call;\n+  gimple *stmt, *fn_call;\n   tree dest, src, fn, nb_bytes;\n   location_t loc;\n   enum built_in_function kind;\n@@ -910,7 +910,7 @@ destroy_loop (struct loop *loop)\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree vdef = gimple_vdef (stmt);\n \t  if (vdef && TREE_CODE (vdef) == SSA_NAME)\n \t    mark_virtual_operand_for_renaming (vdef);\n@@ -1001,7 +1001,7 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n \n   EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n     {\n-      gimple stmt = RDG_STMT (rdg, i);\n+      gimple *stmt = RDG_STMT (rdg, i);\n \n       if (gimple_has_volatile_ops (stmt))\n \tvolatiles_p = true;\n@@ -1024,7 +1024,7 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n   single_store = NULL;\n   EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n     {\n-      gimple stmt = RDG_STMT (rdg, i);\n+      gimple *stmt = RDG_STMT (rdg, i);\n       data_reference_p dr;\n       unsigned j;\n \n@@ -1069,7 +1069,7 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n \n   if (single_store && !single_load)\n     {\n-      gimple stmt = DR_STMT (single_store);\n+      gimple *stmt = DR_STMT (single_store);\n       tree rhs = gimple_assign_rhs1 (stmt);\n       if (const_with_all_bytes_same (rhs) == -1\n \t  && (!INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n@@ -1091,8 +1091,8 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n     }\n   else if (single_store && single_load)\n     {\n-      gimple store = DR_STMT (single_store);\n-      gimple load = DR_STMT (single_load);\n+      gimple *store = DR_STMT (single_store);\n+      gimple *load = DR_STMT (single_load);\n       /* Direct aggregate copy or via an SSA name temporary.  */\n       if (load != store\n \t  && gimple_assign_lhs (load) != gimple_assign_rhs1 (store))\n@@ -1209,12 +1209,12 @@ similar_memory_accesses (struct graph *rdg, partition_t partition1,\n \n static void\n rdg_build_partitions (struct graph *rdg,\n-\t\t      vec<gimple> starting_stmts,\n+\t\t      vec<gimple *> starting_stmts,\n \t\t      vec<partition_t> *partitions)\n {\n   bitmap processed = BITMAP_ALLOC (NULL);\n   int i;\n-  gimple stmt;\n+  gimple *stmt;\n \n   FOR_EACH_VEC_ELT (starting_stmts, i, stmt)\n     {\n@@ -1406,7 +1406,7 @@ pgcmp (const void *v1_, const void *v2_)\n    Returns the number of distributed loops.  */\n \n static int\n-distribute_loop (struct loop *loop, vec<gimple> stmts,\n+distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \t\t control_dependences *cd, int *nb_calls)\n {\n   struct graph *rdg;\n@@ -1722,7 +1722,7 @@ pass_loop_distribution::execute (function *fun)\n      walking to innermost loops.  */\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n-      auto_vec<gimple> work_list;\n+      auto_vec<gimple *> work_list;\n       basic_block *bbs;\n       int num = loop->num;\n       unsigned int i;\n@@ -1757,7 +1757,7 @@ pass_loop_distribution::execute (function *fun)\n \t       !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \n \t      /* If there is a stmt with side-effects bail out - we\n \t\t cannot and should not distribute this loop.  */"}, {"sha": "4af70e9647511fd6d4d4ff158523a32124970439", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -436,7 +436,7 @@ static tree\n init_tmp_var (struct nesting_info *info, tree exp, gimple_stmt_iterator *gsi)\n {\n   tree t;\n-  gimple stmt;\n+  gimple *stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n   stmt = gimple_build_assign (t, exp);\n@@ -467,7 +467,7 @@ static tree\n save_tmp_var (struct nesting_info *info, tree exp, gimple_stmt_iterator *gsi)\n {\n   tree t;\n-  gimple stmt;\n+  gimple *stmt;\n \n   t = create_tmp_var_for (info, TREE_TYPE (exp), NULL);\n   stmt = gimple_build_assign (exp, t);\n@@ -1311,7 +1311,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   struct nesting_info *info = (struct nesting_info *) wi->info;\n   tree save_local_var_chain;\n   bitmap save_suppress;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -1892,7 +1892,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   struct nesting_info *info = (struct nesting_info *) wi->info;\n   tree save_local_var_chain;\n   bitmap save_suppress;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -2079,7 +2079,7 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree label, new_label, target_context, x, field;\n   gcall *call;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (gimple_code (stmt) != GIMPLE_GOTO)\n     {\n@@ -2172,7 +2172,7 @@ convert_nl_goto_receiver (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   gsi_prev (&tmp_gsi);\n   if (gsi_end_p (tmp_gsi) || gimple_stmt_may_fallthru (gsi_stmt (tmp_gsi)))\n     {\n-      gimple stmt = gimple_build_goto (label);\n+      gimple *stmt = gimple_build_goto (label);\n       gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n     }\n \n@@ -2269,7 +2269,7 @@ convert_tramp_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t\t      struct walk_stmt_info *wi)\n {\n   struct nesting_info *info = (struct nesting_info *) wi->info;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -2369,7 +2369,7 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   tree decl, target_context;\n   char save_static_chain_added;\n   int i;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -2721,7 +2721,7 @@ static void\n finalize_nesting_tree_1 (struct nesting_info *root)\n {\n   gimple_seq stmt_list;\n-  gimple stmt;\n+  gimple *stmt;\n   tree context = root->context;\n   struct function *sf;\n "}, {"sha": "61a1363dcc416b3553c8677697e8831d18eaf52b", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -173,7 +173,7 @@ pass_nrv::execute (function *fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree ret_val;\n \n \t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n@@ -266,7 +266,7 @@ pass_nrv::execute (function *fun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  /* If this is a copy from VAR to RESULT, remove it.  */\n \t  if (gimple_assign_copy_p (stmt)\n \t      && gimple_assign_lhs (stmt) == result"}, {"sha": "f76f160f4a4a6c1abfa46f18e9f4ef4865dc20ec", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -770,7 +770,7 @@ merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n    need reexamination  later.  */\n \n static bool\n-plus_stmt_object_size (struct object_size_info *osi, tree var, gimple stmt)\n+plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (var);\n@@ -842,7 +842,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple stmt)\n    later.  */\n \n static bool\n-cond_expr_object_size (struct object_size_info *osi, tree var, gimple stmt)\n+cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n {\n   tree then_, else_;\n   int object_size_type = osi->object_size_type;\n@@ -895,7 +895,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (var);\n-  gimple stmt;\n+  gimple *stmt;\n   bool reexamine;\n \n   if (bitmap_bit_p (computed[object_size_type], varno))\n@@ -1039,7 +1039,7 @@ static void\n check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n \t\t\t   unsigned int depth)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n   unsigned int varno = SSA_NAME_VERSION (var);\n \n   if (osi->depths[varno])\n@@ -1139,7 +1139,7 @@ check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n static void\n check_for_plus_in_loops (struct object_size_info *osi, tree var)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n \n   /* NOTE: In the pre-tuples code, we handled a CALL_EXPR here,\n      and looked for a POINTER_PLUS_EXPR in the pass-through\n@@ -1241,7 +1241,7 @@ pass_object_sizes::execute (function *fun)\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n \t{\n \t  tree result;\n-\t  gimple call = gsi_stmt (i);\n+\t  gimple *call = gsi_stmt (i);\n \t  if (!gimple_call_builtin_p (call, BUILT_IN_OBJECT_SIZE))\n \t    continue;\n \n@@ -1277,7 +1277,8 @@ pass_object_sizes::execute (function *fun)\n \t\t\t  enum tree_code code\n \t\t\t    = object_size_type == 1 ? MIN_EXPR : MAX_EXPR;\n \t\t\t  tree cst = build_int_cstu (type, bytes);\n-\t\t\t  gimple g = gimple_build_assign (lhs, code, tem, cst);\n+\t\t\t  gimple *g\n+\t\t\t    = gimple_build_assign (lhs, code, tem, cst);\n \t\t\t  gsi_insert_after (&i, g, GSI_NEW_STMT);\n \t\t\t  update_stmt (call);\n \t\t\t}\n@@ -1322,7 +1323,7 @@ pass_object_sizes::execute (function *fun)\n \t    continue;\n \n \t  /* Propagate into all uses and fold those stmts.  */\n-\t  gimple use_stmt;\n+\t  gimple *use_stmt;\n \t  imm_use_iterator iter;\n \t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n \t    {"}, {"sha": "fd00883474be22cd50d86c6fafccf368a5a3296a", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -60,11 +60,11 @@ along with GCC; see the file COPYING3.  If not see\n /* Return TRUE if expression STMT is suitable for replacement.  */\n \n bool\n-ssa_is_replaceable_p (gimple stmt)\n+ssa_is_replaceable_p (gimple *stmt)\n {\n   use_operand_p use_p;\n   tree def;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n \n   /* Only consider modify stmts.  */\n   if (!is_gimple_assign (stmt))\n@@ -192,7 +192,7 @@ set_location_for_edge (edge e)\n \t{\n \t  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \t      if (is_gimple_debug (stmt))\n \t\tcontinue;\n \t      if (gimple_has_location (stmt) || gimple_block (stmt))\n@@ -806,7 +806,7 @@ remove_gimple_phi_args (gphi *phi)\n \t  SET_USE (arg_p, NULL_TREE);\n \t  if (has_zero_uses (arg))\n \t    {\n-\t      gimple stmt;\n+\t      gimple *stmt;\n \t      gimple_stmt_iterator gsi;\n \n \t      stmt = SSA_NAME_DEF_STMT (arg);\n@@ -1033,7 +1033,7 @@ maybe_renumber_stmts_bb (basic_block bb)\n   bb->aux = NULL;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       gimple_set_uid (stmt, i);\n       i++;\n     }\n@@ -1049,7 +1049,7 @@ trivially_conflicts_p (basic_block bb, tree result, tree arg)\n {\n   use_operand_p use;\n   imm_use_iterator imm_iter;\n-  gimple defa = SSA_NAME_DEF_STMT (arg);\n+  gimple *defa = SSA_NAME_DEF_STMT (arg);\n \n   /* If ARG isn't defined in the same block it's too complicated for\n      our little mind.  */\n@@ -1058,7 +1058,7 @@ trivially_conflicts_p (basic_block bb, tree result, tree arg)\n \n   FOR_EACH_IMM_USE_FAST (use, imm_iter, result)\n     {\n-      gimple use_stmt = USE_STMT (use);\n+      gimple *use_stmt = USE_STMT (use);\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n       /* Now, if there's a use of RESULT that lies outside this basic block,\n@@ -1129,7 +1129,7 @@ insert_backedge_copies (void)\n \t\t{\n \t\t  tree name;\n \t\t  gassign *stmt;\n-\t\t  gimple last = NULL;\n+\t\t  gimple *last = NULL;\n \t\t  gimple_stmt_iterator gsi2;\n \n \t\t  gsi2 = gsi_last_bb (gimple_phi_arg_edge (phi, i)->src);"}, {"sha": "687e5a5a74f32fdaf7c40b43b34e4f810388e409", "filename": "gcc/tree-outof-ssa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-outof-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-outof-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -61,7 +61,7 @@ get_rtx_for_ssa_name (tree exp)\n \n /* If TER decided to forward the definition of SSA name EXP this function\n    returns the defining statement, otherwise NULL.  */\n-static inline gimple\n+static inline gimple *\n get_gimple_for_ssa_name (tree exp)\n {\n   int v = SSA_NAME_VERSION (exp);\n@@ -70,7 +70,7 @@ get_gimple_for_ssa_name (tree exp)\n   return NULL;\n }\n \n-extern bool ssa_is_replaceable_p (gimple stmt);\n+extern bool ssa_is_replaceable_p (gimple *stmt);\n extern void finish_out_of_ssa (struct ssaexpand *sa);\n extern unsigned int rewrite_out_of_ssa (struct ssaexpand *sa);\n extern void expand_phi_nodes (struct ssaexpand *sa);"}, {"sha": "8deddb1d775169b7d1dc26362903a7f2f35c02cc", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -188,8 +188,8 @@ parloop\n    reduction in the current loop.  */\n struct reduction_info\n {\n-  gimple reduc_stmt;\t\t/* reduction statement.  */\n-  gimple reduc_phi;\t\t/* The phi node defining the reduction.  */\n+  gimple *reduc_stmt;\t\t/* reduction statement.  */\n+  gimple *reduc_phi;\t\t/* The phi node defining the reduction.  */\n   enum tree_code reduction_code;/* code for the reduction operation.  */\n   unsigned reduc_version;\t/* SSA_NAME_VERSION of original reduc_phi\n \t\t\t\t   result.  */\n@@ -230,7 +230,7 @@ typedef hash_table<reduction_hasher> reduction_info_table_type;\n \n \n static struct reduction_info *\n-reduction_phi (reduction_info_table_type *reduction_list, gimple phi)\n+reduction_phi (reduction_info_table_type *reduction_list, gimple *phi)\n {\n   struct reduction_info tmpred, *red;\n \n@@ -551,7 +551,7 @@ take_address_of (tree obj, tree type, edge entry,\n }\n \n static tree\n-reduc_stmt_res (gimple stmt)\n+reduc_stmt_res (gimple *stmt)\n {\n   return (gimple_code (stmt) == GIMPLE_PHI\n \t  ? gimple_phi_result (stmt)\n@@ -704,7 +704,7 @@ eliminate_local_variables_stmt (edge entry, gimple_stmt_iterator *gsi,\n \t\t\t\tint_tree_htab_type *decl_address)\n {\n   struct elv_data dta;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   memset (&dta.info, '\\0', sizeof (dta.info));\n   dta.entry = entry;\n@@ -892,7 +892,7 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type *name_copies,\n    replacement decls are stored in DECL_COPIES.  */\n \n static void\n-separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n+separate_decls_in_region_stmt (edge entry, edge exit, gimple *stmt,\n \t\t\t       name_to_copy_table_type *name_copies,\n \t\t\t       int_tree_htab_type *decl_copies)\n {\n@@ -932,7 +932,7 @@ separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n    replacement decls are stored in DECL_COPIES.  */\n \n static bool\n-separate_decls_in_region_debug (gimple stmt,\n+separate_decls_in_region_debug (gimple *stmt,\n \t\t\t\tname_to_copy_table_type *name_copies,\n \t\t\t\tint_tree_htab_type *decl_copies)\n {\n@@ -1089,7 +1089,7 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n   edge e;\n   tree t, addr, ref, x;\n   tree tmp_load, name;\n-  gimple load;\n+  gimple *load;\n \n   load_struct = build_simple_mem_ref (clsn_data->load);\n   t = build3 (COMPONENT_REF, type, load_struct, reduc->field, NULL_TREE);\n@@ -1149,7 +1149,7 @@ int\n create_loads_for_reductions (reduction_info **slot, struct clsn_data *clsn_data)\n {\n   struct reduction_info *const red = *slot;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (reduc_stmt_res (red->reduc_stmt));\n   tree load_struct;\n@@ -1190,7 +1190,7 @@ create_final_loads_for_reduction (reduction_info_table_type *reduction_list,\n {\n   gimple_stmt_iterator gsi;\n   tree t;\n-  gimple stmt;\n+  gimple *stmt;\n \n   gsi = gsi_after_labels (ld_st_data->load_bb);\n   t = build_fold_addr_expr (ld_st_data->store);\n@@ -1214,7 +1214,7 @@ create_stores_for_reduction (reduction_info **slot, struct clsn_data *clsn_data)\n {\n   struct reduction_info *const red = *slot;\n   tree t;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (reduc_stmt_res (red->reduc_stmt));\n \n@@ -1236,7 +1236,7 @@ create_loads_and_stores_for_name (name_to_copy_elt **slot,\n {\n   struct name_to_copy_elt *const elt = *slot;\n   tree t;\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (elt->new_name);\n   tree load_struct;\n@@ -1323,7 +1323,7 @@ separate_decls_in_region (edge entry, edge exit,\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \n \t      if (is_gimple_debug (stmt))\n \t\thas_debug_stmt = true;\n@@ -1346,7 +1346,7 @@ separate_decls_in_region (edge entry, edge exit,\n \t{\n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \n \t      if (is_gimple_debug (stmt))\n \t\t{\n@@ -1482,7 +1482,7 @@ create_loop_fn (location_t loc)\n static void\n replace_uses_in_bb_by (tree name, tree val, basic_block bb)\n {\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   imm_use_iterator imm_iter;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, name)\n@@ -1727,7 +1727,7 @@ transform_to_exit_first_loop_alt (struct loop *loop,\n       if (virtual_operand_p (res_z))\n \tcontinue;\n \n-      gimple reduc_phi = SSA_NAME_DEF_STMT (res_c);\n+      gimple *reduc_phi = SSA_NAME_DEF_STMT (res_c);\n       struct reduction_info *red = reduction_phi (reduction_list, reduc_phi);\n       if (red != NULL)\n \tred->keep_res = nphi;\n@@ -1829,7 +1829,7 @@ try_transform_to_exit_first_loop_alt (struct loop *loop,\n   if (!wi::lts_p (nit_max, type_max))\n     return false;\n \n-  gimple def = SSA_NAME_DEF_STMT (nit);\n+  gimple *def = SSA_NAME_DEF_STMT (nit);\n \n   /* Try to find nit + 1, in the form of n in an assignment nit = n - 1.  */\n   if (def\n@@ -1987,8 +1987,8 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   basic_block bb, paral_bb, for_bb, ex_bb, continue_bb;\n   tree t, param;\n   gomp_parallel *omp_par_stmt;\n-  gimple omp_return_stmt1, omp_return_stmt2;\n-  gimple phi;\n+  gimple *omp_return_stmt1, *omp_return_stmt2;\n+  gimple *phi;\n   gcond *cond_stmt;\n   gomp_for *for_stmt;\n   gomp_continue *omp_cont_stmt;\n@@ -2067,7 +2067,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n       source_location locus;\n       gphi *phi = gpi.phi ();\n       tree def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-      gimple def_stmt = SSA_NAME_DEF_STMT (def);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (def);\n \n       /* If the exit phi is not connected to a header phi in the same loop, this\n \t value is not modified in the loop, and we're done with this phi.  */\n@@ -2151,7 +2151,7 @@ gen_parallel_loop (struct loop *loop,\n   struct clsn_data clsn_data;\n   unsigned prob;\n   location_t loc;\n-  gimple cond_stmt;\n+  gimple *cond_stmt;\n   unsigned int m_p_thread=2;\n \n   /* From\n@@ -2342,7 +2342,7 @@ loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n \n static void\n build_new_reduction (reduction_info_table_type *reduction_list,\n-\t\t     gimple reduc_stmt, gphi *phi)\n+\t\t     gimple *reduc_stmt, gphi *phi)\n {\n   reduction_info **slot;\n   struct reduction_info *new_reduction;\n@@ -2361,7 +2361,7 @@ build_new_reduction (reduction_info_table_type *reduction_list,\n   if (gimple_code (reduc_stmt) == GIMPLE_PHI)\n     {\n       tree op1 = PHI_ARG_DEF (reduc_stmt, 0);\n-      gimple def1 = SSA_NAME_DEF_STMT (op1);\n+      gimple *def1 = SSA_NAME_DEF_STMT (op1);\n       reduction_code = gimple_assign_rhs_code (def1);\n     }\n \n@@ -2415,7 +2415,7 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n       if (simple_iv (loop, loop, res, &iv, true))\n \tcontinue;\n \n-      gimple reduc_stmt\n+      gimple *reduc_stmt\n \t= vect_force_simple_reduction (simple_loop_info, phi, true,\n \t\t\t\t       &double_reduc, true);\n       if (!reduc_stmt)\n@@ -2438,15 +2438,15 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \t    }\n \n \t  use_operand_p use_p;\n-\t  gimple inner_stmt;\n+\t  gimple *inner_stmt;\n \t  bool single_use_p = single_imm_use (res, &use_p, &inner_stmt);\n \t  gcc_assert (single_use_p);\n \t  gphi *inner_phi = as_a <gphi *> (inner_stmt);\n \t  if (simple_iv (loop->inner, loop->inner, PHI_RESULT (inner_phi),\n \t\t\t &iv, true))\n \t    continue;\n \n-\t  gimple inner_reduc_stmt\n+\t  gimple *inner_reduc_stmt\n \t    = vect_force_simple_reduction (simple_inner_loop_info, inner_phi,\n \t\t\t\t\t   true, &double_reduc, true);\n \t  gcc_assert (!double_reduc);\n@@ -2508,7 +2508,7 @@ try_create_reduction_list (loop_p loop,\n       struct reduction_info *red;\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n-      gimple reduc_phi;\n+      gimple *reduc_phi;\n       tree val = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n \n       if (!virtual_operand_p (val))"}, {"sha": "3c913ea909ded4111ceeeca1de531b478ab42188", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -163,7 +163,7 @@ class ipa_opt_pass_d : public opt_pass\n \n   /* Hook to convert gimple stmt uids into true gimple statements.  The second\n      parameter is an array of statements indexed by their uid. */\n-  void (*stmt_fixup) (struct cgraph_node *, gimple *);\n+  void (*stmt_fixup) (struct cgraph_node *, gimple **);\n \n   /* Results of interprocedural propagation of an IPA pass is applied to\n      function body via this hook.  */\n@@ -178,7 +178,7 @@ class ipa_opt_pass_d : public opt_pass\n \t\t  void (*read_summary) (void),\n \t\t  void (*write_optimization_summary) (void),\n \t\t  void (*read_optimization_summary) (void),\n-\t\t  void (*stmt_fixup) (struct cgraph_node *, gimple *),\n+\t\t  void (*stmt_fixup) (struct cgraph_node *, gimple **),\n \t\t  unsigned int function_transform_todo_flags_start,\n \t\t  unsigned int (*function_transform) (struct cgraph_node *),\n \t\t  void (*variable_transform) (varpool_node *))\n@@ -603,7 +603,7 @@ extern void execute_pass_list (function *, opt_pass *);\n extern void execute_ipa_pass_list (opt_pass *);\n extern void execute_ipa_summary_passes (ipa_opt_pass_d *);\n extern void execute_all_ipa_transforms (void);\n-extern void execute_all_ipa_stmt_fixups (struct cgraph_node *, gimple *);\n+extern void execute_all_ipa_stmt_fixups (struct cgraph_node *, gimple **);\n extern bool pass_init_dump_file (opt_pass *);\n extern void pass_fini_dump_file (opt_pass *);\n "}, {"sha": "9b3e513a7e4fb10f4836145571c7037d992e3ee0", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -71,7 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n    the -2 on all the calculations below.  */\n \n #define NUM_BUCKETS 10\n-static GTY ((deletable (\"\"))) vec<gimple, va_gc> *free_phinodes[NUM_BUCKETS - 2];\n+static GTY ((deletable (\"\"))) vec<gimple *, va_gc> *free_phinodes[NUM_BUCKETS - 2];\n static unsigned long free_phinode_count;\n \n static int ideal_phi_node_len (int);\n@@ -212,7 +212,7 @@ make_phi_node (tree var, int len)\n /* We no longer need PHI, release it so that it may be reused.  */\n \n void\n-release_phi_node (gimple phi)\n+release_phi_node (gimple *phi)\n {\n   size_t bucket;\n   size_t len = gimple_phi_capacity (phi);\n@@ -442,7 +442,7 @@ remove_phi_args (edge e)\n void\n remove_phi_node (gimple_stmt_iterator *gsi, bool release_lhs_p)\n {\n-  gimple phi = gsi_stmt (*gsi);\n+  gimple *phi = gsi_stmt (*gsi);\n \n   if (release_lhs_p)\n     insert_debug_temps_for_defs (gsi);"}, {"sha": "9487c6ab9208f0eba16a2ae052c6dc39b897f9bb", "filename": "gcc/tree-phinodes.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-phinodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-phinodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_PHINODES_H\n \n extern void phinodes_print_statistics (void);\n-extern void release_phi_node (gimple);\n+extern void release_phi_node (gimple *);\n extern void reserve_phi_args_for_new_edge (basic_block);\n extern void add_phi_node_to_bb (gphi *phi, basic_block bb);\n extern gphi *create_phi_node (tree, basic_block);\n@@ -33,7 +33,7 @@ extern tree degenerate_phi_result (gphi *);\n extern void set_phi_nodes (basic_block, gimple_seq);\n \n static inline use_operand_p\n-gimple_phi_arg_imm_use_ptr (gimple gs, int i)\n+gimple_phi_arg_imm_use_ptr (gimple *gs, int i)\n {\n   return &gimple_phi_arg (gs, i)->imm_use;\n }\n@@ -45,7 +45,7 @@ phi_arg_index_from_use (use_operand_p use)\n {\n   struct phi_arg_d *element, *root;\n   size_t index;\n-  gimple phi;\n+  gimple *phi;\n \n   /* Since the use is the first thing in a PHI argument element, we can\n      calculate its index based on casting it to an argument, and performing"}, {"sha": "4abac137cf338c7df027d1936cb14c20aeb737b5", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -243,7 +243,7 @@ typedef struct dref_d\n   struct data_reference *ref;\n \n   /* The statement in that the reference appears.  */\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* In case that STMT is a phi node, this field is set to the SSA name\n      defined by it in replace_phis_by_defined_names (in order to avoid\n@@ -1122,7 +1122,7 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n {\n   tree name, init, init_ref;\n   gphi *phi = NULL;\n-  gimple init_stmt;\n+  gimple *init_stmt;\n   edge latch = loop_latch_edge (loop);\n   struct data_reference init_dr;\n   gphi_iterator psi;\n@@ -1295,7 +1295,7 @@ determine_roots (struct loop *loop,\n    is in the lhs of STMT, false if it is in rhs.  */\n \n static void\n-replace_ref_with (gimple stmt, tree new_tree, bool set, bool in_lhs)\n+replace_ref_with (gimple *stmt, tree new_tree, bool set, bool in_lhs)\n {\n   tree val;\n   gassign *new_stmt;\n@@ -1624,12 +1624,12 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n    the looparound phi nodes contained in one of the chains.  If there is no\n    such statement, or more statements, NULL is returned.  */\n \n-static gimple\n+static gimple *\n single_nonlooparound_use (tree name)\n {\n   use_operand_p use;\n   imm_use_iterator it;\n-  gimple stmt, ret = NULL;\n+  gimple *stmt, *ret = NULL;\n \n   FOR_EACH_IMM_USE_FAST (use, it, name)\n     {\n@@ -1660,10 +1660,10 @@ single_nonlooparound_use (tree name)\n    used.  */\n \n static void\n-remove_stmt (gimple stmt)\n+remove_stmt (gimple *stmt)\n {\n   tree name;\n-  gimple next;\n+  gimple *next;\n   gimple_stmt_iterator psi;\n \n   if (gimple_code (stmt) == GIMPLE_PHI)\n@@ -1885,7 +1885,7 @@ execute_pred_commoning_cbck (struct loop *loop, void *data)\n static void\n base_names_in_chain_on (struct loop *loop, tree name, tree var)\n {\n-  gimple stmt, phi;\n+  gimple *stmt, *phi;\n   imm_use_iterator iter;\n \n   replace_ssa_name_symbol (name, var);\n@@ -1920,7 +1920,7 @@ eliminate_temp_copies (struct loop *loop, bitmap tmp_vars)\n {\n   edge e;\n   gphi *phi;\n-  gimple stmt;\n+  gimple *stmt;\n   tree name, use, var;\n   gphi_iterator psi;\n \n@@ -1967,10 +1967,10 @@ chain_can_be_combined_p (chain_p chain)\n    statements, NAME is replaced with the actual name used in the returned\n    statement.  */\n \n-static gimple\n+static gimple *\n find_use_stmt (tree *name)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   tree rhs, lhs;\n \n   /* Skip over assignments.  */\n@@ -2020,11 +2020,11 @@ may_reassociate_p (tree type, enum tree_code code)\n    tree of the same operations and returns its root.  Distance to the root\n    is stored in DISTANCE.  */\n \n-static gimple\n-find_associative_operation_root (gimple stmt, unsigned *distance)\n+static gimple *\n+find_associative_operation_root (gimple *stmt, unsigned *distance)\n {\n   tree lhs;\n-  gimple next;\n+  gimple *next;\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n   unsigned dist = 0;\n@@ -2057,10 +2057,10 @@ find_associative_operation_root (gimple stmt, unsigned *distance)\n    tree formed by this operation instead of the statement that uses NAME1 or\n    NAME2.  */\n \n-static gimple\n+static gimple *\n find_common_use_stmt (tree *name1, tree *name2)\n {\n-  gimple stmt1, stmt2;\n+  gimple *stmt1, *stmt2;\n \n   stmt1 = find_use_stmt (name1);\n   if (!stmt1)\n@@ -2095,7 +2095,7 @@ combinable_refs_p (dref r1, dref r2,\n   bool aswap;\n   tree atype;\n   tree name1, name2;\n-  gimple stmt;\n+  gimple *stmt;\n \n   name1 = name_for_ref (r1);\n   name2 = name_for_ref (r2);\n@@ -2132,7 +2132,7 @@ combinable_refs_p (dref r1, dref r2,\n    an assignment of the remaining operand.  */\n \n static void\n-remove_name_from_operation (gimple stmt, tree op)\n+remove_name_from_operation (gimple *stmt, tree op)\n {\n   tree other_op;\n   gimple_stmt_iterator si;\n@@ -2156,10 +2156,10 @@ remove_name_from_operation (gimple stmt, tree op)\n /* Reassociates the expression in that NAME1 and NAME2 are used so that they\n    are combined in a single statement, and returns this statement.  */\n \n-static gimple\n+static gimple *\n reassociate_to_the_same_stmt (tree name1, tree name2)\n {\n-  gimple stmt1, stmt2, root1, root2, s1, s2;\n+  gimple *stmt1, *stmt2, *root1, *root2, *s1, *s2;\n   gassign *new_stmt, *tmp_stmt;\n   tree new_name, tmp_name, var, r1, r2;\n   unsigned dist1, dist2;\n@@ -2241,10 +2241,10 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n    associative and commutative operation in the same expression, reassociate\n    the expression so that they are used in the same statement.  */\n \n-static gimple\n+static gimple *\n stmt_combining_refs (dref r1, dref r2)\n {\n-  gimple stmt1, stmt2;\n+  gimple *stmt1, *stmt2;\n   tree name1 = name_for_ref (r1);\n   tree name2 = name_for_ref (r2);\n \n@@ -2267,7 +2267,7 @@ combine_chains (chain_p ch1, chain_p ch2)\n   bool swap = false;\n   chain_p new_chain;\n   unsigned i;\n-  gimple root_stmt;\n+  gimple *root_stmt;\n   tree rslt_type = NULL_TREE;\n \n   if (ch1 == ch2)"}, {"sha": "b4b3ae19c99b04331858d62fe2c13dd6e5cb84fc", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -285,7 +285,7 @@ prepare_instrumented_value (gimple_stmt_iterator *gsi, histogram_value value)\n void\n gimple_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  gimple stmt = value->hvalue.stmt;\n+  gimple *stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n   gcall *call;\n@@ -311,7 +311,7 @@ gimple_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base\n void\n gimple_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  gimple stmt = value->hvalue.stmt;\n+  gimple *stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n   gcall *call;\n@@ -331,7 +331,7 @@ gimple_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n void\n gimple_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  gimple stmt = value->hvalue.stmt;\n+  gimple *stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n   gcall *call;\n@@ -356,7 +356,7 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n   tree tmp1;\n   gassign *stmt1, *stmt2, *stmt3;\n-  gimple stmt = value->hvalue.stmt;\n+  gimple *stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n \n@@ -475,7 +475,7 @@ gimple_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED,\n void\n gimple_gen_average_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  gimple stmt = value->hvalue.stmt;\n+  gimple *stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n   gcall *call;\n@@ -496,7 +496,7 @@ gimple_gen_average_profiler (histogram_value value, unsigned tag, unsigned base)\n void\n gimple_gen_ior_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  gimple stmt = value->hvalue.stmt;\n+  gimple *stmt = value->hvalue.stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n   gcall *call;\n@@ -600,7 +600,7 @@ tree_profiling (void)\n \t  gimple_stmt_iterator gsi;\n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \t      if (is_gimple_call (stmt))\n \t\tupdate_stmt (stmt);\n \t    }"}, {"sha": "0753bf3122ef8f6690f34b63075c8d4d35d235bb", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -404,7 +404,7 @@ chrec_contains_symbols_defined_in_loop (const_tree chrec, unsigned loop_nb)\n \n   if (TREE_CODE (chrec) == SSA_NAME)\n     {\n-      gimple def;\n+      gimple *def;\n       loop_p def_loop, loop;\n \n       if (SSA_NAME_IS_DEFAULT_DEF (chrec))\n@@ -434,7 +434,7 @@ chrec_contains_symbols_defined_in_loop (const_tree chrec, unsigned loop_nb)\n /* Return true when PHI is a loop-phi-node.  */\n \n static bool\n-loop_phi_node_p (gimple phi)\n+loop_phi_node_p (gimple *phi)\n {\n   /* The implementation of this function is based on the following\n      property: \"all the loop-phi-nodes of a loop are contained in the\n@@ -616,7 +616,7 @@ get_scalar_evolution (basic_block instantiated_below, tree scalar)\n \n static tree\n add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n-\t\t    gimple at_stmt)\n+\t\t    gimple *at_stmt)\n {\n   tree type, left, right;\n   struct loop *loop = get_loop (cfun, loop_nb), *chloop;\n@@ -813,7 +813,7 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \n static tree\n add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n-\t\t  tree to_add, gimple at_stmt)\n+\t\t  tree to_add, gimple *at_stmt)\n {\n   tree type = chrec_type (to_add);\n   tree res = NULL_TREE;\n@@ -876,7 +876,7 @@ get_loop_exit_condition (const struct loop *loop)\n \n   if (exit_edge)\n     {\n-      gimple stmt;\n+      gimple *stmt;\n \n       stmt = last_stmt (exit_edge->src);\n       if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n@@ -902,14 +902,14 @@ enum t_bool {\n };\n \n \n-static t_bool follow_ssa_edge (struct loop *loop, gimple, gphi *,\n+static t_bool follow_ssa_edge (struct loop *loop, gimple *, gphi *,\n \t\t\t       tree *, int);\n \n /* Follow the ssa edge into the binary expression RHS0 CODE RHS1.\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge_binary (struct loop *loop, gimple at_stmt,\n+follow_ssa_edge_binary (struct loop *loop, gimple *at_stmt,\n \t\t\ttree type, tree rhs0, enum tree_code code, tree rhs1,\n \t\t\tgphi *halting_phi, tree *evolution_of_loop,\n \t\t\tint limit)\n@@ -1044,7 +1044,7 @@ follow_ssa_edge_binary (struct loop *loop, gimple at_stmt,\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge_expr (struct loop *loop, gimple at_stmt, tree expr,\n+follow_ssa_edge_expr (struct loop *loop, gimple *at_stmt, tree expr,\n \t\t      gphi *halting_phi, tree *evolution_of_loop,\n \t\t      int limit)\n {\n@@ -1135,7 +1135,7 @@ follow_ssa_edge_expr (struct loop *loop, gimple at_stmt, tree expr,\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge_in_rhs (struct loop *loop, gimple stmt,\n+follow_ssa_edge_in_rhs (struct loop *loop, gimple *stmt,\n \t\t\tgphi *halting_phi, tree *evolution_of_loop,\n \t\t\tint limit)\n {\n@@ -1325,7 +1325,7 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n    path that is analyzed on the return walk.  */\n \n static t_bool\n-follow_ssa_edge (struct loop *loop, gimple def, gphi *halting_phi,\n+follow_ssa_edge (struct loop *loop, gimple *def, gphi *halting_phi,\n \t\t tree *evolution_of_loop, int limit)\n {\n   struct loop *def_loop;\n@@ -1468,7 +1468,7 @@ analyze_evolution_in_loop (gphi *loop_phi_node,\n   for (i = 0; i < n; i++)\n     {\n       tree arg = PHI_ARG_DEF (loop_phi_node, i);\n-      gimple ssa_chain;\n+      gimple *ssa_chain;\n       tree ev_fn;\n       t_bool res;\n \n@@ -1591,7 +1591,7 @@ analyze_initial_condition (gphi *loop_phi_node)\n      Handle degenerate PHIs here to not miss important unrollings.  */\n   if (TREE_CODE (init_cond) == SSA_NAME)\n     {\n-      gimple def = SSA_NAME_DEF_STMT (init_cond);\n+      gimple *def = SSA_NAME_DEF_STMT (init_cond);\n       if (gphi *phi = dyn_cast <gphi *> (def))\n \t{\n \t  tree res = degenerate_phi_result (phi);\n@@ -1697,11 +1697,11 @@ interpret_condition_phi (struct loop *loop, gphi *condition_phi)\n    analyze the effect of an inner loop: see interpret_loop_phi.  */\n \n static tree\n-interpret_rhs_expr (struct loop *loop, gimple at_stmt,\n+interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n \t\t    tree type, tree rhs1, enum tree_code code, tree rhs2)\n {\n   tree res, chrec1, chrec2;\n-  gimple def;\n+  gimple *def;\n \n   if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n     {\n@@ -1878,7 +1878,7 @@ interpret_rhs_expr (struct loop *loop, gimple at_stmt,\n /* Interpret the expression EXPR.  */\n \n static tree\n-interpret_expr (struct loop *loop, gimple at_stmt, tree expr)\n+interpret_expr (struct loop *loop, gimple *at_stmt, tree expr)\n {\n   enum tree_code code;\n   tree type = TREE_TYPE (expr), op0, op1;\n@@ -1899,7 +1899,7 @@ interpret_expr (struct loop *loop, gimple at_stmt, tree expr)\n /* Interpret the rhs of the assignment STMT.  */\n \n static tree\n-interpret_gimple_assign (struct loop *loop, gimple stmt)\n+interpret_gimple_assign (struct loop *loop, gimple *stmt)\n {\n   tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n@@ -1946,7 +1946,7 @@ static tree\n analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n {\n   tree type = TREE_TYPE (var);\n-  gimple def;\n+  gimple *def;\n   basic_block bb;\n   struct loop *def_loop;\n \n@@ -3585,7 +3585,7 @@ scev_const_prop (void)\n \t      gsi2 = gsi_start (stmts);\n \t      while (!gsi_end_p (gsi2))\n \t\t{\n-\t\t  gimple stmt = gsi_stmt (gsi2);\n+\t\t  gimple *stmt = gsi_stmt (gsi2);\n \t\t  gimple_stmt_iterator gsi3 = gsi2;\n \t\t  gsi_next (&gsi2);\n \t\t  gsi_remove (&gsi3, false);"}, {"sha": "43279902cb6f888102539406fa3a5df051ea2271", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -160,7 +160,7 @@ struct access\n   tree type;\n \n   /* The statement this access belongs to.  */\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Next group representative for this aggregate. */\n   struct access *next_grp;\n@@ -801,7 +801,7 @@ get_ssa_base_param (tree t)\n    final.  */\n \n static void\n-mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple stmt)\n+mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   int idx, parm_index = 0;\n@@ -845,7 +845,7 @@ create_access_1 (tree base, HOST_WIDE_INT offset, HOST_WIDE_INT size)\n    not possible.  */\n \n static struct access *\n-create_access (tree expr, gimple stmt, bool write)\n+create_access (tree expr, gimple *stmt, bool write)\n {\n   struct access *access;\n   HOST_WIDE_INT offset, size, max_size;\n@@ -1099,7 +1099,7 @@ disqualify_base_of_expr (tree t, const char *reason)\n    created.  */\n \n static struct access *\n-build_access_from_expr_1 (tree expr, gimple stmt, bool write)\n+build_access_from_expr_1 (tree expr, gimple *stmt, bool write)\n {\n   struct access *ret = NULL;\n   bool partial_ref;\n@@ -1165,7 +1165,7 @@ build_access_from_expr_1 (tree expr, gimple stmt, bool write)\n    true if the expression is a store and false otherwise. */\n \n static bool\n-build_access_from_expr (tree expr, gimple stmt, bool write)\n+build_access_from_expr (tree expr, gimple *stmt, bool write)\n {\n   struct access *access;\n \n@@ -1209,7 +1209,7 @@ single_non_eh_succ (basic_block bb)\n    NULL, in that case ignore it.  */\n \n static bool\n-disqualify_if_bad_bb_terminating_stmt (gimple stmt, tree lhs, tree rhs)\n+disqualify_if_bad_bb_terminating_stmt (gimple *stmt, tree lhs, tree rhs)\n {\n   if ((sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n       && stmt_ends_bb_p (stmt))\n@@ -1231,7 +1231,7 @@ disqualify_if_bad_bb_terminating_stmt (gimple stmt, tree lhs, tree rhs)\n    true if any access has been inserted.  */\n \n static bool\n-build_accesses_from_assign (gimple stmt)\n+build_accesses_from_assign (gimple *stmt)\n {\n   tree lhs, rhs;\n   struct access *lacc, *racc;\n@@ -1287,7 +1287,7 @@ build_accesses_from_assign (gimple stmt)\n    GIMPLE_ASM operands with memory constrains which cannot be scalarized.  */\n \n static bool\n-asm_visit_addr (gimple, tree op, tree, void *)\n+asm_visit_addr (gimple *, tree op, tree, void *)\n {\n   op = get_base_address (op);\n   if (op\n@@ -1302,7 +1302,7 @@ asm_visit_addr (gimple, tree op, tree, void *)\n    that their types match.  */\n \n static inline bool\n-callsite_arguments_match_p (gimple call)\n+callsite_arguments_match_p (gimple *call)\n {\n   if (gimple_call_num_args (call) < (unsigned) func_param_count)\n     return false;\n@@ -1334,7 +1334,7 @@ scan_function (void)\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree t;\n \t  unsigned i;\n \n@@ -2809,7 +2809,7 @@ clobber_subtree (struct access *access, gimple_stmt_iterator *gsi,\n       tree rep = get_access_replacement (access);\n       tree clobber = build_constructor (access->type, NULL);\n       TREE_THIS_VOLATILE (clobber) = 1;\n-      gimple stmt = gimple_build_assign (rep, clobber);\n+      gimple *stmt = gimple_build_assign (rep, clobber);\n \n       if (insert_after)\n \tgsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n@@ -3132,7 +3132,7 @@ enum assignment_mod_result { SRA_AM_NONE,       /* nothing done for the stmt */\n    the same values as sra_modify_assign.  */\n \n static enum assignment_mod_result\n-sra_modify_constructor_assign (gimple stmt, gimple_stmt_iterator *gsi)\n+sra_modify_constructor_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n   struct access *acc = get_access_for_expr (lhs);\n@@ -3220,7 +3220,7 @@ contains_vce_or_bfcref_p (const_tree ref)\n    copying.  */\n \n static enum assignment_mod_result\n-sra_modify_assign (gimple stmt, gimple_stmt_iterator *gsi)\n+sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   struct access *lacc, *racc;\n   tree lhs, rhs;\n@@ -3486,7 +3486,7 @@ sra_modify_function_body (void)\n       gimple_stmt_iterator gsi = gsi_start_bb (bb);\n       while (!gsi_end_p (gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  enum assignment_mod_result assign_result;\n \t  bool modified = false, deleted = false;\n \t  tree *t;\n@@ -3751,7 +3751,7 @@ static bool\n ptr_parm_has_direct_uses (tree parm)\n {\n   imm_use_iterator ui;\n-  gimple stmt;\n+  gimple *stmt;\n   tree name = ssa_default_def (cfun, parm);\n   bool ret = false;\n \n@@ -4618,7 +4618,7 @@ get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)\n    ADJUSTMENTS is a pointer to an adjustments vector.  */\n \n static bool\n-replace_removed_params_ssa_names (gimple stmt,\n+replace_removed_params_ssa_names (gimple *stmt,\n \t\t\t\t  ipa_parm_adjustment_vec adjustments)\n {\n   struct ipa_parm_adjustment *adj;\n@@ -4675,7 +4675,7 @@ replace_removed_params_ssa_names (gimple stmt,\n    point to the statement).  Return true iff the statement was modified.  */\n \n static bool\n-sra_ipa_modify_assign (gimple stmt, gimple_stmt_iterator *gsi,\n+sra_ipa_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t       ipa_parm_adjustment_vec adjustments)\n {\n   tree *lhs_p, *rhs_p;\n@@ -4750,7 +4750,7 @@ ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n       gsi = gsi_start_bb (bb);\n       while (!gsi_end_p (gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  bool modified = false;\n \t  tree *t;\n \t  unsigned i;\n@@ -4838,7 +4838,7 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n     {\n       struct ipa_parm_adjustment *adj;\n       imm_use_iterator ui;\n-      gimple stmt;\n+      gimple *stmt;\n       gdebug *def_temp;\n       tree name, vexpr, copy = NULL_TREE;\n       use_operand_p use_p;\n@@ -5086,7 +5086,7 @@ ipa_sra_check_caller (struct cgraph_node *node, void *data)\n \t  iscc->has_thunk = true;\n \t  return true;\n \t}\n-      gimple call_stmt = cs->call_stmt;\n+      gimple *call_stmt = cs->call_stmt;\n       unsigned count = gimple_call_num_args (call_stmt);\n       for (unsigned i = 0; i < count; i++)\n \t{"}, {"sha": "f3674ae5eee094a70478c290cedc3346c10aa617", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -367,7 +367,7 @@ ref_may_alias_global_p (tree ref)\n /* Return true whether STMT may clobber global memory.  */\n \n bool\n-stmt_may_clobber_global_p (gimple stmt)\n+stmt_may_clobber_global_p (gimple *stmt)\n {\n   tree lhs;\n \n@@ -604,7 +604,7 @@ ao_ref_init_from_ptr_and_size (ao_ref *ref, tree ptr, tree size)\n   ref->ref = NULL_TREE;\n   if (TREE_CODE (ptr) == SSA_NAME)\n     {\n-      gimple stmt = SSA_NAME_DEF_STMT (ptr);\n+      gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n       if (gimple_assign_single_p (stmt)\n \t  && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n \tptr = gimple_assign_rhs1 (stmt);\n@@ -1830,7 +1830,7 @@ ref_maybe_used_by_call_p (gcall *call, ao_ref *ref)\n    true, otherwise return false.  */\n \n bool\n-ref_maybe_used_by_stmt_p (gimple stmt, ao_ref *ref)\n+ref_maybe_used_by_stmt_p (gimple *stmt, ao_ref *ref)\n {\n   if (is_gimple_assign (stmt))\n     {\n@@ -1874,7 +1874,7 @@ ref_maybe_used_by_stmt_p (gimple stmt, ao_ref *ref)\n }\n \n bool\n-ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n+ref_maybe_used_by_stmt_p (gimple *stmt, tree ref)\n {\n   ao_ref r;\n   ao_ref_init (&r, ref);\n@@ -2192,7 +2192,7 @@ call_may_clobber_ref_p (gcall *call, tree ref)\n    otherwise return false.  */\n \n bool\n-stmt_may_clobber_ref_p_1 (gimple stmt, ao_ref *ref)\n+stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref)\n {\n   if (is_gimple_call (stmt))\n     {\n@@ -2225,7 +2225,7 @@ stmt_may_clobber_ref_p_1 (gimple stmt, ao_ref *ref)\n }\n \n bool\n-stmt_may_clobber_ref_p (gimple stmt, tree ref)\n+stmt_may_clobber_ref_p (gimple *stmt, tree ref)\n {\n   ao_ref r;\n   ao_ref_init (&r, ref);\n@@ -2236,7 +2236,7 @@ stmt_may_clobber_ref_p (gimple stmt, tree ref)\n    return false.  */\n \n bool\n-stmt_kills_ref_p (gimple stmt, ao_ref *ref)\n+stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n {\n   if (!ao_ref_base (ref))\n     return false;\n@@ -2426,7 +2426,7 @@ stmt_kills_ref_p (gimple stmt, ao_ref *ref)\n }\n \n bool\n-stmt_kills_ref_p (gimple stmt, tree ref)\n+stmt_kills_ref_p (gimple *stmt, tree ref)\n {\n   ao_ref r;\n   ao_ref_init (&r, ref);\n@@ -2439,7 +2439,7 @@ stmt_kills_ref_p (gimple stmt, tree ref)\n    case false is returned.  The walk starts with VUSE, one argument of PHI.  */\n \n static bool\n-maybe_skip_until (gimple phi, tree target, ao_ref *ref,\n+maybe_skip_until (gimple *phi, tree target, ao_ref *ref,\n \t\t  tree vuse, unsigned int *cnt, bitmap *visited,\n \t\t  bool abort_on_visited,\n \t\t  void *(*translate)(ao_ref *, tree, void *, bool),\n@@ -2455,7 +2455,7 @@ maybe_skip_until (gimple phi, tree target, ao_ref *ref,\n   /* Walk until we hit the target.  */\n   while (vuse != target)\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (vuse);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (vuse);\n       /* Recurse for PHI nodes.  */\n       if (gimple_code (def_stmt) == GIMPLE_PHI)\n \t{\n@@ -2502,14 +2502,14 @@ maybe_skip_until (gimple phi, tree target, ao_ref *ref,\n    Return that, or NULL_TREE if there is no such definition.  */\n \n static tree\n-get_continuation_for_phi_1 (gimple phi, tree arg0, tree arg1,\n+get_continuation_for_phi_1 (gimple *phi, tree arg0, tree arg1,\n \t\t\t    ao_ref *ref, unsigned int *cnt,\n \t\t\t    bitmap *visited, bool abort_on_visited,\n \t\t\t    void *(*translate)(ao_ref *, tree, void *, bool),\n \t\t\t    void *data)\n {\n-  gimple def0 = SSA_NAME_DEF_STMT (arg0);\n-  gimple def1 = SSA_NAME_DEF_STMT (arg1);\n+  gimple *def0 = SSA_NAME_DEF_STMT (arg0);\n+  gimple *def1 = SSA_NAME_DEF_STMT (arg1);\n   tree common_vuse;\n \n   if (arg0 == arg1)\n@@ -2568,7 +2568,7 @@ get_continuation_for_phi_1 (gimple phi, tree arg0, tree arg1,\n    Returns NULL_TREE if no suitable virtual operand can be found.  */\n \n tree\n-get_continuation_for_phi (gimple phi, ao_ref *ref,\n+get_continuation_for_phi (gimple *phi, ao_ref *ref,\n \t\t\t  unsigned int *cnt, bitmap *visited,\n \t\t\t  bool abort_on_visited,\n \t\t\t  void *(*translate)(ao_ref *, tree, void *, bool),\n@@ -2661,7 +2661,7 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n \n   do\n     {\n-      gimple def_stmt;\n+      gimple *def_stmt;\n \n       /* ???  Do we want to account this to TV_ALIAS_STMT_WALK?  */\n       res = (*walker) (ref, vuse, cnt, data);\n@@ -2741,7 +2741,7 @@ walk_aliased_vdefs_1 (ao_ref *ref, tree vdef,\n {\n   do\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (vdef);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (vdef);\n \n       if (*visited\n \t  && !bitmap_set_bit (*visited, SSA_NAME_VERSION (vdef)))"}, {"sha": "67d9bcb17509dea5655848418a60fba01c147f4f", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -107,16 +107,16 @@ extern bool refs_may_alias_p (tree, tree);\n extern bool refs_may_alias_p_1 (ao_ref *, ao_ref *, bool);\n extern bool refs_anti_dependent_p (tree, tree);\n extern bool refs_output_dependent_p (tree, tree);\n-extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n-extern bool ref_maybe_used_by_stmt_p (gimple, ao_ref *);\n-extern bool stmt_may_clobber_global_p (gimple);\n-extern bool stmt_may_clobber_ref_p (gimple, tree);\n-extern bool stmt_may_clobber_ref_p_1 (gimple, ao_ref *);\n+extern bool ref_maybe_used_by_stmt_p (gimple *, tree);\n+extern bool ref_maybe_used_by_stmt_p (gimple *, ao_ref *);\n+extern bool stmt_may_clobber_global_p (gimple *);\n+extern bool stmt_may_clobber_ref_p (gimple *, tree);\n+extern bool stmt_may_clobber_ref_p_1 (gimple *, ao_ref *);\n extern bool call_may_clobber_ref_p (gcall *, tree);\n extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);\n-extern bool stmt_kills_ref_p (gimple, tree);\n-extern bool stmt_kills_ref_p (gimple, ao_ref *);\n-extern tree get_continuation_for_phi (gimple, ao_ref *,\n+extern bool stmt_kills_ref_p (gimple *, tree);\n+extern bool stmt_kills_ref_p (gimple *, ao_ref *);\n+extern tree get_continuation_for_phi (gimple *, ao_ref *,\n \t\t\t\t      unsigned int *, bitmap *, bool,\n \t\t\t\t      void *(*)(ao_ref *, tree, void *, bool),\n \t\t\t\t      void *);"}, {"sha": "ed5fe1e3cea52189fd52d118e0d9f91cb3476c3c", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -269,7 +269,7 @@ static ccp_prop_value_t\n get_default_value (tree var)\n {\n   ccp_prop_value_t val = { UNINITIALIZED, NULL_TREE, 0 };\n-  gimple stmt;\n+  gimple *stmt;\n \n   stmt = SSA_NAME_DEF_STMT (var);\n \n@@ -644,7 +644,7 @@ get_value_for_expr (tree expr, bool for_bits_p)\n    Else return VARYING.  */\n \n static ccp_lattice_t\n-likely_value (gimple stmt)\n+likely_value (gimple *stmt)\n {\n   bool has_constant_operand, has_undefined_operand, all_undefined_operands;\n   bool has_nsa_operand;\n@@ -771,7 +771,7 @@ likely_value (gimple stmt)\n /* Returns true if STMT cannot be constant.  */\n \n static bool\n-surely_varying_stmt_p (gimple stmt)\n+surely_varying_stmt_p (gimple *stmt)\n {\n   /* If the statement has operands that we cannot handle, it cannot be\n      constant.  */\n@@ -826,7 +826,7 @@ ccp_initialize (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n-\t  gimple stmt = gsi_stmt (i);\n+\t  gimple *stmt = gsi_stmt (i);\n \t  bool is_varying;\n \n \t  /* If the statement is a control insn, then we do not\n@@ -1171,7 +1171,7 @@ valueize_op_1 (tree op)\n       /* If the definition may be simulated again we cannot follow\n          this SSA edge as the SSA propagator does not necessarily\n \t re-visit the use.  */\n-      gimple def_stmt = SSA_NAME_DEF_STMT (op);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (op);\n       if (!gimple_nop_p (def_stmt)\n \t  && prop_simulate_again_p (def_stmt))\n \treturn NULL_TREE;\n@@ -1192,7 +1192,7 @@ valueize_op_1 (tree op)\n    otherwise return the original RHS or NULL_TREE.  */\n \n static tree\n-ccp_fold (gimple stmt)\n+ccp_fold (gimple *stmt)\n {\n   location_t loc = gimple_location (stmt);\n   switch (gimple_code (stmt))\n@@ -1600,7 +1600,7 @@ bit_value_binop (enum tree_code code, tree type, tree rhs1, tree rhs2)\n    ALLOC_ALIGNED is true.  */\n \n static ccp_prop_value_t\n-bit_value_assume_aligned (gimple stmt, tree attr, ccp_prop_value_t ptrval,\n+bit_value_assume_aligned (gimple *stmt, tree attr, ccp_prop_value_t ptrval,\n \t\t\t  bool alloc_aligned)\n {\n   tree align, misalign = NULL_TREE, type;\n@@ -1700,7 +1700,7 @@ bit_value_assume_aligned (gimple stmt, tree attr, ccp_prop_value_t ptrval,\n    Valid only for assignments, calls, conditionals, and switches. */\n \n static ccp_prop_value_t\n-evaluate_stmt (gimple stmt)\n+evaluate_stmt (gimple *stmt)\n {\n   ccp_prop_value_t val;\n   tree simplified = NULL_TREE;\n@@ -1977,7 +1977,7 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n-typedef hash_table<nofree_ptr_hash<gimple_statement_base> > gimple_htab;\n+typedef hash_table<nofree_ptr_hash<gimple> > gimple_htab;\n \n /* Given a BUILT_IN_STACK_SAVE value SAVED_VAL, insert a clobber of VAR before\n    each matching BUILT_IN_STACK_RESTORE.  Mark visited phis in VISITED.  */\n@@ -1986,12 +1986,12 @@ static void\n insert_clobber_before_stack_restore (tree saved_val, tree var,\n \t\t\t\t     gimple_htab **visited)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   gassign *clobber_stmt;\n   tree clobber;\n   imm_use_iterator iter;\n   gimple_stmt_iterator i;\n-  gimple *slot;\n+  gimple **slot;\n \n   FOR_EACH_IMM_USE_STMT (stmt, iter, saved_val)\n     if (gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))\n@@ -2055,7 +2055,7 @@ gsi_prev_dom_bb_nondebug (gimple_stmt_iterator *i)\n static void\n insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   tree saved_val;\n   gimple_htab *visited = NULL;\n \n@@ -2082,7 +2082,7 @@ insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n    NULL_TREE.  */\n \n static tree\n-fold_builtin_alloca_with_align (gimple stmt)\n+fold_builtin_alloca_with_align (gimple *stmt)\n {\n   unsigned HOST_WIDE_INT size, threshold, n_elem;\n   tree lhs, arg, block, var, elem_type, array_type;\n@@ -2141,7 +2141,7 @@ fold_builtin_alloca_with_align (gimple stmt)\n static bool\n ccp_fold_stmt (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   switch (gimple_code (stmt))\n     {\n@@ -2281,7 +2281,7 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n    are handled here.  */\n \n static enum ssa_prop_result\n-visit_assignment (gimple stmt, tree *output_p)\n+visit_assignment (gimple *stmt, tree *output_p)\n {\n   ccp_prop_value_t val;\n   enum ssa_prop_result retval = SSA_PROP_NOT_INTERESTING;\n@@ -2314,7 +2314,7 @@ visit_assignment (gimple stmt, tree *output_p)\n    SSA_PROP_VARYING.  */\n \n static enum ssa_prop_result\n-visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n+visit_cond_stmt (gimple *stmt, edge *taken_edge_p)\n {\n   ccp_prop_value_t val;\n   basic_block block;\n@@ -2347,7 +2347,7 @@ visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n    value, return SSA_PROP_VARYING.  */\n \n static enum ssa_prop_result\n-ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n+ccp_visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n {\n   tree def;\n   ssa_op_iter iter;\n@@ -2464,10 +2464,10 @@ static tree\n optimize_stack_restore (gimple_stmt_iterator i)\n {\n   tree callee;\n-  gimple stmt;\n+  gimple *stmt;\n \n   basic_block bb = gsi_bb (i);\n-  gimple call = gsi_stmt (i);\n+  gimple *call = gsi_stmt (i);\n \n   if (gimple_code (call) != GIMPLE_CALL\n       || gimple_call_num_args (call) != 1\n@@ -2518,7 +2518,7 @@ optimize_stack_restore (gimple_stmt_iterator i)\n      or not is irrelevant to removing the call to __builtin_stack_restore.  */\n   if (has_single_use (gimple_call_arg (call, 0)))\n     {\n-      gimple stack_save = SSA_NAME_DEF_STMT (gimple_call_arg (call, 0));\n+      gimple *stack_save = SSA_NAME_DEF_STMT (gimple_call_arg (call, 0));\n       if (is_gimple_call (stack_save))\n \t{\n \t  callee = gimple_call_fndecl (stack_save);\n@@ -2546,7 +2546,7 @@ optimize_stack_restore (gimple_stmt_iterator i)\n    pointer assignment.  */\n \n static tree\n-optimize_stdarg_builtin (gimple call)\n+optimize_stdarg_builtin (gimple *call)\n {\n   tree callee, lhs, rhs, cfun_va_list;\n   bool va_list_simple_ptr;\n@@ -2624,7 +2624,7 @@ optimize_unreachable (gimple_stmt_iterator i)\n {\n   basic_block bb = gsi_bb (i);\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   edge_iterator ei;\n   edge e;\n   bool ret;\n@@ -2728,7 +2728,7 @@ pass_fold_builtins::execute (function *fun)\n       gimple_stmt_iterator i;\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n \t{\n-          gimple stmt, old_stmt;\n+\t  gimple *stmt, *old_stmt;\n \t  tree callee;\n \t  enum built_in_function fcode;\n "}, {"sha": "8af65839ecfd2764eb52657bb1c05283c5eb86e9", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -833,7 +833,7 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \t   gsi_prev (&gsi))\n         {\n \t  tree var;\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  /* A copy between 2 partitions does not introduce an interference\n \t     by itself.  If they did, you would never be able to coalesce\n@@ -947,7 +947,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n   tree var;\n-  gimple stmt;\n+  gimple *stmt;\n   tree first;\n   var_map map;\n   ssa_op_iter iter;"}, {"sha": "8e137bd73e989f5da589354eee024e637881e4f8", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -82,7 +82,7 @@ static unsigned n_copy_of;\n /* Return true if this statement may generate a useful copy.  */\n \n static bool\n-stmt_may_generate_copy (gimple stmt)\n+stmt_may_generate_copy (gimple *stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     return !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_phi_result (stmt));\n@@ -195,7 +195,7 @@ dump_copy_of (FILE *file, tree var)\n    value and store the LHS into *RESULT_P.  */\n \n static enum ssa_prop_result\n-copy_prop_visit_assignment (gimple stmt, tree *result_p)\n+copy_prop_visit_assignment (gimple *stmt, tree *result_p)\n {\n   tree lhs, rhs;\n \n@@ -225,7 +225,7 @@ copy_prop_visit_assignment (gimple stmt, tree *result_p)\n    SSA_PROP_VARYING.  */\n \n static enum ssa_prop_result\n-copy_prop_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n+copy_prop_visit_cond_stmt (gimple *stmt, edge *taken_edge_p)\n {\n   enum ssa_prop_result retval = SSA_PROP_VARYING;\n   location_t loc = gimple_location (stmt);\n@@ -271,7 +271,7 @@ copy_prop_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n    SSA_PROP_VARYING.  */\n \n static enum ssa_prop_result\n-copy_prop_visit_stmt (gimple stmt, edge *taken_edge_p, tree *result_p)\n+copy_prop_visit_stmt (gimple *stmt, edge *taken_edge_p, tree *result_p)\n {\n   enum ssa_prop_result retval;\n \n@@ -449,7 +449,7 @@ init_copy_prop (void)\n       for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n \t{\n-\t  gimple stmt = gsi_stmt (si);\n+\t  gimple *stmt = gsi_stmt (si);\n \t  ssa_op_iter iter;\n           tree def;\n "}, {"sha": "727b5f0261bd8af9b178fdbb5fdc1e1c64adadb8", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -90,7 +90,7 @@ static struct stmt_stats\n \n #define STMT_NECESSARY GF_PLF_1\n \n-static vec<gimple> worklist;\n+static vec<gimple *> worklist;\n \n /* Vector indicating an SSA name has already been processed and marked\n    as necessary.  */\n@@ -128,7 +128,7 @@ static bool cfg_altered;\n    worklist if ADD_TO_WORKLIST is true.  */\n \n static inline void\n-mark_stmt_necessary (gimple stmt, bool add_to_worklist)\n+mark_stmt_necessary (gimple *stmt, bool add_to_worklist)\n {\n   gcc_assert (stmt);\n \n@@ -155,7 +155,7 @@ mark_stmt_necessary (gimple stmt, bool add_to_worklist)\n static inline void\n mark_operand_necessary (tree op)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   int ver;\n \n   gcc_assert (op);\n@@ -198,7 +198,7 @@ mark_operand_necessary (tree op)\n    necessary.  */\n \n static void\n-mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n+mark_stmt_if_obviously_necessary (gimple *stmt, bool aggressive)\n {\n   /* With non-call exceptions, we have to assume that all statements could\n      throw.  If a statement could throw, it can be deemed necessary.  */\n@@ -316,7 +316,7 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n static void\n mark_last_stmt_necessary (basic_block bb)\n {\n-  gimple stmt = last_stmt (bb);\n+  gimple *stmt = last_stmt (bb);\n \n   bitmap_set_bit (last_stmt_necessary, bb->index);\n   bitmap_set_bit (bb_contains_live_stmts, bb->index);\n@@ -377,7 +377,7 @@ find_obviously_necessary_stmts (bool aggressive)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   edge e;\n-  gimple phi, stmt;\n+  gimple *phi, *stmt;\n   int flags;\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -467,7 +467,7 @@ static bool chain_ovfl = false;\n static bool\n mark_aliased_reaching_defs_necessary_1 (ao_ref *ref, tree vdef, void *data)\n {\n-  gimple def_stmt = SSA_NAME_DEF_STMT (vdef);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (vdef);\n \n   /* All stmts we visit are necessary.  */\n   mark_operand_necessary (vdef);\n@@ -523,7 +523,7 @@ mark_aliased_reaching_defs_necessary_1 (ao_ref *ref, tree vdef, void *data)\n }\n \n static void\n-mark_aliased_reaching_defs_necessary (gimple stmt, tree ref)\n+mark_aliased_reaching_defs_necessary (gimple *stmt, tree ref)\n {\n   unsigned int chain;\n   ao_ref refd;\n@@ -548,7 +548,7 @@ static bool\n mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n \t\t\t\t    tree vdef, void *data ATTRIBUTE_UNUSED)\n {\n-  gimple def_stmt = SSA_NAME_DEF_STMT (vdef);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (vdef);\n \n   /* We have to skip already visited (and thus necessary) statements\n      to make the chaining work after we dropped back to simple mode.  */\n@@ -596,7 +596,7 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n }\n \n static void\n-mark_all_reaching_defs_necessary (gimple stmt)\n+mark_all_reaching_defs_necessary (gimple *stmt)\n {\n   walk_aliased_vdefs (NULL, gimple_vuse (stmt),\n \t\t      mark_all_reaching_defs_necessary_1, NULL, &visited);\n@@ -605,7 +605,7 @@ mark_all_reaching_defs_necessary (gimple stmt)\n /* Return true for PHI nodes with one or identical arguments\n    can be removed.  */\n static bool\n-degenerate_phi_p (gimple phi)\n+degenerate_phi_p (gimple *phi)\n {\n   unsigned int i;\n   tree op = gimple_phi_arg_def (phi, 0);\n@@ -625,7 +625,7 @@ degenerate_phi_p (gimple phi)\n static void\n propagate_necessity (bool aggressive)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nProcessing worklist:\\n\");\n@@ -776,7 +776,7 @@ propagate_necessity (bool aggressive)\n \t  if (gimple_call_builtin_p (stmt, BUILT_IN_FREE))\n \t    {\n \t      tree ptr = gimple_call_arg (stmt, 0);\n-\t      gimple def_stmt;\n+\t      gimple *def_stmt;\n \t      tree def_callee;\n \t      /* If the pointer we free is defined by an allocation\n \t\t function do not add the call to the worklist.  */\n@@ -788,7 +788,7 @@ propagate_necessity (bool aggressive)\n \t\t      || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_MALLOC\n \t\t      || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))\n \t\t{\n-\t\t  gimple bounds_def_stmt;\n+\t\t  gimple *bounds_def_stmt;\n \t\t  tree bounds;\n \n \t\t  /* For instrumented calls we should also check used\n@@ -974,7 +974,7 @@ remove_dead_phis (basic_block bb)\n \n \t      use_operand_p use_p;\n \t      imm_use_iterator iter;\n-\t      gimple use_stmt;\n+\t      gimple *use_stmt;\n \t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, vdef)\n \t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n \t\t  SET_USE (use_p, vuse);\n@@ -1072,7 +1072,7 @@ forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n static void\n remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n {\n-  gimple stmt = gsi_stmt (*i);\n+  gimple *stmt = gsi_stmt (*i);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1184,7 +1184,7 @@ static void\n maybe_optimize_arith_overflow (gimple_stmt_iterator *gsi,\n \t\t\t       enum tree_code subcode)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n \n   if (lhs == NULL || TREE_CODE (lhs) != SSA_NAME)\n@@ -1197,7 +1197,7 @@ maybe_optimize_arith_overflow (gimple_stmt_iterator *gsi,\n   bool has_other_uses = false;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n     {\n-      gimple use_stmt = USE_STMT (use_p);\n+      gimple *use_stmt = USE_STMT (use_p);\n       if (is_gimple_debug (use_stmt))\n \thas_debug_uses = true;\n       else if (is_gimple_assign (use_stmt)\n@@ -1228,7 +1228,7 @@ maybe_optimize_arith_overflow (gimple_stmt_iterator *gsi,\n \n   if (has_debug_uses)\n     {\n-      gimple use_stmt;\n+      gimple *use_stmt;\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n \t{\n \t  if (!gimple_debug_bind_p (use_stmt))\n@@ -1274,7 +1274,7 @@ eliminate_unnecessary_stmts (void)\n   bool something_changed = false;\n   basic_block bb;\n   gimple_stmt_iterator gsi, psi;\n-  gimple stmt;\n+  gimple *stmt;\n   tree call;\n   vec<basic_block> h;\n \n@@ -1332,7 +1332,7 @@ eliminate_unnecessary_stmts (void)\n \t      tree ptr = gimple_call_arg (stmt, 0);\n \t      if (TREE_CODE (ptr) == SSA_NAME)\n \t\t{\n-\t\t  gimple def_stmt = SSA_NAME_DEF_STMT (ptr);\n+\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (ptr);\n \t\t  if (!gimple_nop_p (def_stmt)\n \t\t      && !gimple_plf (def_stmt, STMT_NECESSARY))\n \t\t    gimple_set_plf (stmt, STMT_NECESSARY, false);\n@@ -1345,7 +1345,7 @@ eliminate_unnecessary_stmts (void)\n \t\t call is not removed.  */\n \t      if (gimple_call_with_bounds_p (stmt))\n \t\t{\n-\t\t  gimple bounds_def_stmt;\n+\t\t  gimple *bounds_def_stmt;\n \t\t  tree bounds = gimple_call_arg (stmt, 1);\n \t\t  gcc_assert (TREE_CODE (bounds) == SSA_NAME);\n \t\t  bounds_def_stmt = SSA_NAME_DEF_STMT (bounds);"}, {"sha": "135eb0e619cb27f001bfad9fe0c86403401c623e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -84,7 +84,7 @@ static bool cfg_altered;\n /* Bitmap of blocks that have had EH statements cleaned.  We should\n    remove their dead edges eventually.  */\n static bitmap need_eh_cleanup;\n-static vec<gimple> need_noreturn_fixup;\n+static vec<gimple *> need_noreturn_fixup;\n \n /* Statistics for dominator optimizations.  */\n struct opt_stats_d\n@@ -102,7 +102,7 @@ static struct opt_stats_d opt_stats;\n static void optimize_stmt (basic_block, gimple_stmt_iterator,\n \t\t\t   class const_and_copies *,\n \t\t\t   class avail_exprs_stack *);\n-static tree lookup_avail_expr (gimple, bool, class avail_exprs_stack *);\n+static tree lookup_avail_expr (gimple *, bool, class avail_exprs_stack *);\n static void record_cond (cond_equivalence *, class avail_exprs_stack *);\n static void record_equality (tree, tree, class const_and_copies *);\n static void record_equivalences_from_phis (basic_block);\n@@ -112,7 +112,7 @@ static void record_equivalences_from_incoming_edge (basic_block,\n static void eliminate_redundant_computations (gimple_stmt_iterator *,\n \t\t\t\t\t      class const_and_copies *,\n \t\t\t\t\t      class avail_exprs_stack *);\n-static void record_equivalences_from_stmt (gimple, int,\n+static void record_equivalences_from_stmt (gimple *, int,\n \t\t\t\t\t   class avail_exprs_stack *);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void dump_dominator_optimization_stats (FILE *file,\n@@ -326,7 +326,7 @@ record_edge_info (basic_block bb)\n \n   if (! gsi_end_p (gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       location_t loc = gimple_location (stmt);\n \n       if (gimple_code (stmt) == GIMPLE_SWITCH)\n@@ -661,7 +661,7 @@ pass_dominator::execute (function *fun)\n      now noreturn call first.  */\n   while (!need_noreturn_fixup.is_empty ())\n     {\n-      gimple stmt = need_noreturn_fixup.pop ();\n+      gimple *stmt = need_noreturn_fixup.pop ();\n       if (dump_file && dump_flags & TDF_DETAILS)\n \t{\n \t  fprintf (dump_file, \"Fixing up noreturn call \");\n@@ -755,8 +755,8 @@ canonicalize_comparison (gcond *condstmt)\n /* A trivial wrapper so that we can present the generic jump\n    threading code with a simple API for simplifying statements.  */\n static tree\n-simplify_stmt_for_jump_threading (gimple stmt,\n-\t\t\t\t  gimple within_stmt ATTRIBUTE_UNUSED,\n+simplify_stmt_for_jump_threading (gimple *stmt,\n+\t\t\t\t  gimple *within_stmt ATTRIBUTE_UNUSED,\n \t\t\t\t  class avail_exprs_stack *avail_exprs_stack)\n {\n   return lookup_avail_expr (stmt, false, avail_exprs_stack);\n@@ -807,7 +807,7 @@ record_temporary_equivalences (edge e,\n \t  && TREE_CODE (lhs) == SSA_NAME\n \t  && TREE_CODE (rhs) == INTEGER_CST)\n \t{\n-\t  gimple defstmt = SSA_NAME_DEF_STMT (lhs);\n+\t  gimple *defstmt = SSA_NAME_DEF_STMT (lhs);\n \n \t  if (defstmt\n \t      && is_gimple_assign (defstmt)\n@@ -841,7 +841,7 @@ record_temporary_equivalences (edge e,\n \t  imm_use_iterator iter;\n \t  FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n \t    {\n-\t      gimple use_stmt = USE_STMT (use_p);\n+\t      gimple *use_stmt = USE_STMT (use_p);\n \n \t      /* Only bother to record more equivalences for lhs that\n \t         can be directly used by e->dest.\n@@ -1084,7 +1084,7 @@ record_cond (cond_equivalence *p,\n static int\n loop_depth_of_name (tree x)\n {\n-  gimple defstmt;\n+  gimple *defstmt;\n   basic_block defbb;\n \n   /* If it's not an SSA_NAME, we have no clue where the definition is.  */\n@@ -1171,11 +1171,11 @@ record_equality (tree x, tree y, class const_and_copies *const_and_copies)\n    i_2 = i_1 +/- ...  */\n \n bool\n-simple_iv_increment_p (gimple stmt)\n+simple_iv_increment_p (gimple *stmt)\n {\n   enum tree_code code;\n   tree lhs, preinc;\n-  gimple phi;\n+  gimple *phi;\n   size_t i;\n \n   if (gimple_code (stmt) != GIMPLE_ASSIGN)\n@@ -1325,7 +1325,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n void\n dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n-  gimple last;\n+  gimple *last;\n \n   /* If we have an outgoing edge to a block with multiple incoming and\n      outgoing edges, then we may be able to thread the edge, i.e., we\n@@ -1380,7 +1380,7 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n   bool insert = true;\n   bool assigns_var_p = false;\n \n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (gimple_code (stmt) == GIMPLE_PHI)\n     def = gimple_phi_result (stmt);\n@@ -1480,7 +1480,7 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n    lifing is done by eliminate_redundant_computations.  */\n \n static void\n-record_equivalences_from_stmt (gimple stmt, int may_optimize_p,\n+record_equivalences_from_stmt (gimple *stmt, int may_optimize_p,\n \t\t\t       class avail_exprs_stack *avail_exprs_stack)\n {\n   tree lhs;\n@@ -1573,7 +1573,7 @@ record_equivalences_from_stmt (gimple stmt, int may_optimize_p,\n              generate here may in fact be ill-formed, but it is simply\n              used as an internal device in this pass, and never becomes\n              part of the CFG.  */\n-          gimple defstmt = SSA_NAME_DEF_STMT (rhs);\n+\t  gimple *defstmt = SSA_NAME_DEF_STMT (rhs);\n           new_stmt = gimple_build_assign (rhs, lhs);\n           SSA_NAME_DEF_STMT (rhs) = defstmt;\n         }\n@@ -1592,7 +1592,7 @@ record_equivalences_from_stmt (gimple stmt, int may_optimize_p,\n    CONST_AND_COPIES.  */\n \n static void\n-cprop_operand (gimple stmt, use_operand_p op_p)\n+cprop_operand (gimple *stmt, use_operand_p op_p)\n {\n   tree val;\n   tree op = USE_FROM_PTR (op_p);\n@@ -1619,7 +1619,7 @@ cprop_operand (gimple stmt, use_operand_p op_p)\n \t number of iteration analysis.  */\n       if (TREE_CODE (val) != INTEGER_CST)\n \t{\n-\t  gimple def = SSA_NAME_DEF_STMT (op);\n+\t  gimple *def = SSA_NAME_DEF_STMT (op);\n \t  if (gimple_code (def) == GIMPLE_PHI\n \t      && gimple_bb (def)->loop_father->header == gimple_bb (def))\n \t    return;\n@@ -1657,7 +1657,7 @@ cprop_operand (gimple stmt, use_operand_p op_p)\n    vdef_ops of STMT.  */\n \n static void\n-cprop_into_stmt (gimple stmt)\n+cprop_into_stmt (gimple *stmt)\n {\n   use_operand_p op_p;\n   ssa_op_iter iter;\n@@ -1687,7 +1687,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t       class const_and_copies *const_and_copies,\n \t       class avail_exprs_stack *avail_exprs_stack)\n {\n-  gimple stmt, old_stmt;\n+  gimple *stmt, *old_stmt;\n   bool may_optimize_p;\n   bool modified_p = false;\n   bool was_noreturn;\n@@ -1791,7 +1791,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n \t  if (TREE_CODE (rhs) == SSA_NAME)\n \t    {\n-\t      gimple defstmt = SSA_NAME_DEF_STMT (rhs);\n+\t      gimple *defstmt = SSA_NAME_DEF_STMT (rhs);\n \t      new_stmt = gimple_build_assign (rhs, lhs);\n \t      SSA_NAME_DEF_STMT (rhs) = defstmt;\n \t    }\n@@ -1905,7 +1905,7 @@ vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n    we finish processing this block and its children.  */\n \n static tree\n-lookup_avail_expr (gimple stmt, bool insert,\n+lookup_avail_expr (gimple *stmt, bool insert,\n \t\t   class avail_exprs_stack *avail_exprs_stack)\n {\n   expr_hash_elt **slot;"}, {"sha": "f1004db792b6c20fa537210122e8a4e156806fbd", "filename": "gcc/tree-ssa-dom.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -20,6 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_DOM_H\n #define GCC_TREE_SSA_DOM_H\n \n-extern bool simple_iv_increment_p (gimple);\n+extern bool simple_iv_increment_p (gimple *);\n \n #endif /* GCC_TREE_SSA_DOM_H */"}, {"sha": "ac9c05a4e7b6f5980741bbdcc8f3cd556d6060eb", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -89,9 +89,9 @@ static bitmap need_eh_cleanup;\n    Return TRUE if the above conditions are met, otherwise FALSE.  */\n \n static bool\n-dse_possible_dead_store_p (ao_ref *ref, gimple stmt, gimple *use_stmt)\n+dse_possible_dead_store_p (ao_ref *ref, gimple *stmt, gimple **use_stmt)\n {\n-  gimple temp;\n+  gimple *temp;\n   unsigned cnt = 0;\n \n   *use_stmt = NULL;\n@@ -103,7 +103,7 @@ dse_possible_dead_store_p (ao_ref *ref, gimple stmt, gimple *use_stmt)\n   temp = stmt;\n   do\n     {\n-      gimple use_stmt, defvar_def;\n+      gimple *use_stmt, *defvar_def;\n       imm_use_iterator ui;\n       bool fail = false;\n       tree defvar;\n@@ -215,7 +215,7 @@ dse_possible_dead_store_p (ao_ref *ref, gimple stmt, gimple *use_stmt)\n static void\n dse_optimize_stmt (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   /* If this statement has no virtual defs, then there is nothing\n      to do.  */\n@@ -238,7 +238,7 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  case BUILT_IN_MEMMOVE:\n \t  case BUILT_IN_MEMSET:\n \t    {\n-\t      gimple use_stmt;\n+\t      gimple *use_stmt;\n \t      ao_ref ref;\n \t      tree size = NULL_TREE;\n \t      if (gimple_call_num_args (stmt) == 3)\n@@ -258,7 +258,7 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t      tree lhs = gimple_call_lhs (stmt);\n \t      if (lhs)\n \t\t{\n-\t\t  gimple new_stmt = gimple_build_assign (lhs, ptr);\n+\t\t  gimple *new_stmt = gimple_build_assign (lhs, ptr);\n \t\t  unlink_stmt_vdef (stmt);\n \t\t  if (gsi_replace (gsi, new_stmt, true))\n \t\t    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n@@ -281,7 +281,7 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \n   if (is_gimple_assign (stmt))\n     {\n-      gimple use_stmt;\n+      gimple *use_stmt;\n \n       /* Self-assignments are zombies.  */\n       if (operand_equal_p (gimple_assign_rhs1 (stmt),"}, {"sha": "917320a82ab35dbb2c464d37e48d31996bf0b6f0", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -193,7 +193,7 @@ static bool forward_propagate_addr_expr (tree, tree, bool);\n /* Set to true if we delete dead edges during the optimization.  */\n static bool cfg_changed;\n \n-static tree rhs_to_tree (tree type, gimple stmt);\n+static tree rhs_to_tree (tree type, gimple *stmt);\n \n static bitmap to_purge;\n \n@@ -234,13 +234,13 @@ fwprop_invalidate_lattice (tree name)\n    it is set to whether the chain to NAME is a single use chain\n    or not.  SINGLE_USE_P is not written to if SINGLE_USE_ONLY is set.  */\n \n-static gimple\n+static gimple *\n get_prop_source_stmt (tree name, bool single_use_only, bool *single_use_p)\n {\n   bool single_use = true;\n \n   do {\n-    gimple def_stmt = SSA_NAME_DEF_STMT (name);\n+    gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n \n     if (!has_single_use (name))\n       {\n@@ -270,7 +270,7 @@ get_prop_source_stmt (tree name, bool single_use_only, bool *single_use_p)\n    propagation source.  Returns true if so, otherwise false.  */\n \n static bool\n-can_propagate_from (gimple def_stmt)\n+can_propagate_from (gimple *def_stmt)\n {\n   gcc_assert (is_gimple_assign (def_stmt));\n \n@@ -318,7 +318,7 @@ static bool\n remove_prop_source_from_use (tree name)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   bool cfg_changed = false;\n \n   do {\n@@ -356,7 +356,7 @@ remove_prop_source_from_use (tree name)\n    routines that deal with gimple exclusively . */\n \n static tree\n-rhs_to_tree (tree type, gimple stmt)\n+rhs_to_tree (tree type, gimple *stmt)\n {\n   location_t loc = gimple_location (stmt);\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n@@ -382,7 +382,7 @@ rhs_to_tree (tree type, gimple stmt)\n    considered simplified.  */\n \n static tree\n-combine_cond_expr_cond (gimple stmt, enum tree_code code, tree type,\n+combine_cond_expr_cond (gimple *stmt, enum tree_code code, tree type,\n \t\t\ttree op0, tree op1, bool invariant_only)\n {\n   tree t;\n@@ -420,7 +420,7 @@ combine_cond_expr_cond (gimple stmt, enum tree_code code, tree type,\n    were no simplifying combines.  */\n \n static tree\n-forward_propagate_into_comparison_1 (gimple stmt,\n+forward_propagate_into_comparison_1 (gimple *stmt,\n \t\t\t\t     enum tree_code code, tree type,\n \t\t\t\t     tree op0, tree op1)\n {\n@@ -432,7 +432,7 @@ forward_propagate_into_comparison_1 (gimple stmt,\n      simplify comparisons against constants.  */\n   if (TREE_CODE (op0) == SSA_NAME)\n     {\n-      gimple def_stmt = get_prop_source_stmt (op0, false, &single_use0_p);\n+      gimple *def_stmt = get_prop_source_stmt (op0, false, &single_use0_p);\n       if (def_stmt && can_propagate_from (def_stmt))\n \t{\n \t  enum tree_code def_code = gimple_assign_rhs_code (def_stmt);\n@@ -458,7 +458,7 @@ forward_propagate_into_comparison_1 (gimple stmt,\n   /* If that wasn't successful, try the second operand.  */\n   if (TREE_CODE (op1) == SSA_NAME)\n     {\n-      gimple def_stmt = get_prop_source_stmt (op1, false, &single_use1_p);\n+      gimple *def_stmt = get_prop_source_stmt (op1, false, &single_use1_p);\n       if (def_stmt && can_propagate_from (def_stmt))\n \t{\n \t  rhs1 = rhs_to_tree (TREE_TYPE (op0), def_stmt);\n@@ -487,7 +487,7 @@ forward_propagate_into_comparison_1 (gimple stmt,\n static int \n forward_propagate_into_comparison (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree tmp;\n   bool cfg_changed = false;\n   tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n@@ -586,7 +586,7 @@ forward_propagate_into_gimple_cond (gcond *stmt)\n static bool\n forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n {\n-  gimple stmt = gsi_stmt (*gsi_p);\n+  gimple *stmt = gsi_stmt (*gsi_p);\n   tree tmp = NULL_TREE;\n   tree cond = gimple_assign_rhs1 (stmt);\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n@@ -601,7 +601,7 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n     {\n       enum tree_code def_code;\n       tree name = cond;\n-      gimple def_stmt = get_prop_source_stmt (name, true, NULL);\n+      gimple *def_stmt = get_prop_source_stmt (name, true, NULL);\n       if (!def_stmt || !can_propagate_from (def_stmt))\n \treturn 0;\n \n@@ -646,7 +646,7 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n    relevant data structures to match.  */\n \n static void\n-tidy_after_forward_propagate_addr (gimple stmt)\n+tidy_after_forward_propagate_addr (gimple *stmt)\n {\n   /* We may have turned a trapping insn into a non-trapping insn.  */\n   if (maybe_clean_or_replace_eh_stmt (stmt, stmt))\n@@ -672,7 +672,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n \t\t\t       bool single_use_p)\n {\n   tree lhs, rhs, rhs2, array_ref;\n-  gimple use_stmt = gsi_stmt (*use_stmt_gsi);\n+  gimple *use_stmt = gsi_stmt (*use_stmt_gsi);\n   enum tree_code rhs_code;\n   bool res = true;\n \n@@ -983,7 +983,7 @@ static bool\n forward_propagate_addr_expr (tree name, tree rhs, bool parent_single_use_p)\n {\n   imm_use_iterator iter;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   bool all = true;\n   bool single_use_p = parent_single_use_p && has_single_use (name);\n \n@@ -1114,7 +1114,7 @@ simplify_gimple_switch (gswitch *stmt)\n   tree cond = gimple_switch_index (stmt);\n   if (TREE_CODE (cond) == SSA_NAME)\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (cond);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (cond);\n       if (gimple_assign_cast_p (def_stmt))\n \t{\n \t  tree def = gimple_assign_rhs1 (def_stmt);\n@@ -1169,7 +1169,7 @@ constant_pointer_difference (tree p1, tree p2)\n     {\n       tree p = i ? p1 : p2;\n       tree off = size_zero_node;\n-      gimple stmt;\n+      gimple *stmt;\n       enum tree_code code;\n \n       /* For each of p1 and p2 we need to iterate at least\n@@ -1252,7 +1252,7 @@ constant_pointer_difference (tree p1, tree p2)\n static bool\n simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n {\n-  gimple stmt1, stmt2 = gsi_stmt (*gsi_p);\n+  gimple *stmt1, *stmt2 = gsi_stmt (*gsi_p);\n   tree vuse = gimple_vuse (stmt2);\n   if (vuse == NULL)\n     return false;\n@@ -1274,7 +1274,7 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n \t  tree val2 = gimple_call_arg (stmt2, 1);\n \t  tree len2 = gimple_call_arg (stmt2, 2);\n \t  tree diff, vdef, new_str_cst;\n-\t  gimple use_stmt;\n+\t  gimple *use_stmt;\n \t  unsigned int ptr1_align;\n \t  unsigned HOST_WIDE_INT src_len;\n \t  char *src_buf;\n@@ -1464,7 +1464,7 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n static inline void\n defcodefor_name (tree name, enum tree_code *code, tree *arg1, tree *arg2)\n {\n-  gimple def;\n+  gimple *def;\n   enum tree_code code1;\n   tree arg11;\n   tree arg21;\n@@ -1529,14 +1529,14 @@ defcodefor_name (tree name, enum tree_code *code, tree *arg1, tree *arg2)\n static bool\n simplify_rotate (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree arg[2], rtype, rotcnt = NULL_TREE;\n   tree def_arg1[2], def_arg2[2];\n   enum tree_code def_code[2];\n   tree lhs;\n   int i;\n   bool swapped_p = false;\n-  gimple g;\n+  gimple *g;\n \n   arg[0] = gimple_assign_rhs1 (stmt);\n   arg[1] = gimple_assign_rhs2 (stmt);\n@@ -1743,8 +1743,8 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n static bool\n simplify_bitfield_ref (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n-  gimple def_stmt;\n+  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *def_stmt;\n   tree op, op0, op1, op2;\n   tree elem_type;\n   unsigned idx, n, size;\n@@ -1856,8 +1856,8 @@ is_combined_permutation_identity (tree mask1, tree mask2)\n static int\n simplify_permutation (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n-  gimple def_stmt;\n+  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *def_stmt;\n   tree op0, op1, op2, op3, arg0, arg1;\n   enum tree_code code;\n   bool single_use_op0 = false;\n@@ -1927,7 +1927,7 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n \t    {\n \t      enum tree_code code2;\n \n-\t      gimple def_stmt2 = get_prop_source_stmt (op1, true, NULL);\n+\t      gimple *def_stmt2 = get_prop_source_stmt (op1, true, NULL);\n \t      if (!def_stmt2 || !can_propagate_from (def_stmt2))\n \t\treturn 0;\n \n@@ -1967,8 +1967,8 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n static bool\n simplify_vector_constructor (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n-  gimple def_stmt;\n+  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *def_stmt;\n   tree op, op2, orig, type, elem_type;\n   unsigned elem_size, nelts, i;\n   enum tree_code code;\n@@ -2117,7 +2117,7 @@ pass_forwprop::execute (function *fun)\n   lattice.quick_grow_cleared (num_ssa_names);\n   int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int postorder_num = inverted_post_order_compute (postorder);\n-  auto_vec<gimple, 4> to_fixup;\n+  auto_vec<gimple *, 4> to_fixup;\n   to_purge = BITMAP_ALLOC (NULL);\n   for (int i = 0; i < postorder_num; ++i)\n     {\n@@ -2128,7 +2128,7 @@ pass_forwprop::execute (function *fun)\n \t Note we update GSI within the loop as necessary.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree lhs, rhs;\n \t  enum tree_code code;\n \n@@ -2218,7 +2218,7 @@ pass_forwprop::execute (function *fun)\n \t      bool rewrite = true;\n \t      FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n \t\t{\n-\t\t  gimple use_stmt = USE_STMT (use_p);\n+\t\t  gimple *use_stmt = USE_STMT (use_p);\n \t\t  if (is_gimple_debug (use_stmt))\n \t\t    continue;\n \t\t  if (!is_gimple_assign (use_stmt)\n@@ -2231,7 +2231,7 @@ pass_forwprop::execute (function *fun)\n \t\t}\n \t      if (rewrite)\n \t\t{\n-\t\t  gimple use_stmt;\n+\t\t  gimple *use_stmt;\n \t\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n \t\t    {\n \t\t      if (is_gimple_debug (use_stmt))\n@@ -2247,7 +2247,7 @@ pass_forwprop::execute (function *fun)\n \t\t      tree new_rhs = build1 (gimple_assign_rhs_code (use_stmt),\n \t\t\t\t\t     TREE_TYPE (TREE_TYPE (rhs)),\n \t\t\t\t\t     unshare_expr (rhs));\n-\t\t      gimple new_stmt\n+\t\t      gimple *new_stmt\n \t\t\t= gimple_build_assign (gimple_assign_lhs (use_stmt),\n \t\t\t\t\t       new_rhs);\n \n@@ -2271,7 +2271,7 @@ pass_forwprop::execute (function *fun)\n \t      /* Rewrite stores of a single-use complex build expression\n \t         to component-wise stores.  */\n \t      use_operand_p use_p;\n-\t      gimple use_stmt;\n+\t      gimple *use_stmt;\n \t      if (single_imm_use (lhs, &use_p, &use_stmt)\n \t\t  && gimple_store_p (use_stmt)\n \t\t  && !gimple_has_volatile_ops (use_stmt)\n@@ -2283,7 +2283,7 @@ pass_forwprop::execute (function *fun)\n \t\t  tree new_lhs = build1 (REALPART_EXPR,\n \t\t\t\t\t TREE_TYPE (TREE_TYPE (use_lhs)),\n \t\t\t\t\t unshare_expr (use_lhs));\n-\t\t  gimple new_stmt = gimple_build_assign (new_lhs, rhs);\n+\t\t  gimple *new_stmt = gimple_build_assign (new_lhs, rhs);\n \t\t  location_t loc = gimple_location (use_stmt);\n \t\t  gimple_set_location (new_stmt, loc);\n \t\t  gimple_set_vuse (new_stmt, gimple_vuse (use_stmt));\n@@ -2314,8 +2314,8 @@ pass_forwprop::execute (function *fun)\n \t Note we update GSI within the loop as necessary.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  gimple orig_stmt = stmt;\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple *orig_stmt = stmt;\n \t  bool changed = false;\n \t  bool was_noreturn = (is_gimple_call (stmt)\n \t\t\t       && gimple_call_noreturn_p (stmt));\n@@ -2458,7 +2458,7 @@ pass_forwprop::execute (function *fun)\n      fixup by visiting a dominating now noreturn call first.  */\n   while (!to_fixup.is_empty ())\n     {\n-      gimple stmt = to_fixup.pop ();\n+      gimple *stmt = to_fixup.pop ();\n       if (dump_file && dump_flags & TDF_DETAILS)\n \t{\n \t  fprintf (dump_file, \"Fixing up noreturn call \");"}, {"sha": "9f041748fc25f321e4f9eaf34d91c1a21cfafc80", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -119,7 +119,7 @@ bb_no_side_effects_p (basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       if (is_gimple_debug (stmt))\n \tcontinue;\n@@ -177,7 +177,7 @@ get_name_for_bit_test (tree candidate)\n   if (TREE_CODE (candidate) == SSA_NAME\n       && has_single_use (candidate))\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (candidate);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (candidate);\n       if (is_gimple_assign (def_stmt)\n \t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt)))\n \t{\n@@ -198,7 +198,7 @@ get_name_for_bit_test (tree candidate)\n static bool\n recognize_single_bit_test (gcond *cond, tree *name, tree *bit, bool inv)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Get at the definition of the result of the bit test.  */\n   if (gimple_cond_code (cond) != (inv ? EQ_EXPR : NE_EXPR)\n@@ -271,7 +271,7 @@ recognize_single_bit_test (gcond *cond, tree *name, tree *bit, bool inv)\n       && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n       && TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME)\n     {\n-      gimple tmp;\n+      gimple *tmp;\n \n       /* Both arguments of the BIT_AND_EXPR can be the single-bit\n \t specifying expression.  */\n@@ -307,7 +307,7 @@ recognize_single_bit_test (gcond *cond, tree *name, tree *bit, bool inv)\n static bool\n recognize_bits_test (gcond *cond, tree *name, tree *bits, bool inv)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   /* Get at the definition of the result of the bit test.  */\n   if (gimple_cond_code (cond) != (inv ? EQ_EXPR : NE_EXPR)\n@@ -336,7 +336,7 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n \t\t   basic_block outer_cond_bb, bool outer_inv, bool result_inv)\n {\n   gimple_stmt_iterator gsi;\n-  gimple inner_stmt, outer_stmt;\n+  gimple *inner_stmt, *outer_stmt;\n   gcond *inner_cond, *outer_cond;\n   tree name1, name2, bit1, bit2, bits1, bits2;\n \n@@ -761,7 +761,7 @@ pass_tree_ifcombine::execute (function *fun)\n   for (i = n_basic_blocks_for_fn (fun) - NUM_FIXED_BLOCKS - 1; i >= 0; i--)\n     {\n       basic_block bb = bbs[i];\n-      gimple stmt = last_stmt (bb);\n+      gimple *stmt = last_stmt (bb);\n \n       if (stmt\n \t  && gimple_code (stmt) == GIMPLE_COND)\n@@ -772,7 +772,7 @@ pass_tree_ifcombine::execute (function *fun)\n \t    for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n \t\t !gsi_end_p (gsi); gsi_next (&gsi))\n \t      {\n-\t\tgimple stmt = gsi_stmt (gsi);\n+\t\tgimple *stmt = gsi_stmt (gsi);\n \t\tssa_op_iter i;\n \t\ttree op;\n \t\tFOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF)"}, {"sha": "e0317259b6dfa0676a83a411247cab96b8e2b0ed", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -607,7 +607,7 @@ clear_unused_block_pointer (void)\n       {\n \tunsigned i;\n \ttree b;\n-\tgimple stmt = gsi_stmt (gsi);\n+\tgimple *stmt = gsi_stmt (gsi);\n \n \tif (!is_gimple_debug (stmt) && !gimple_clobber_p (stmt))\n \t  continue;\n@@ -730,7 +730,7 @@ remove_unused_locals (void)\n       /* Walk the statements.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree b = gimple_block (stmt);\n \n \t  if (is_gimple_debug (stmt))\n@@ -793,7 +793,7 @@ remove_unused_locals (void)\n \n \tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t  {\n-\t    gimple stmt = gsi_stmt (gsi);\n+\t    gimple *stmt = gsi_stmt (gsi);\n \t    tree b = gimple_block (stmt);\n \n \t    if (gimple_clobber_p (stmt))\n@@ -1012,7 +1012,7 @@ static void\n set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n {\n   int p;\n-  gimple stmt;\n+  gimple *stmt;\n   use_operand_p use;\n   basic_block def_bb = NULL;\n   imm_use_iterator imm_iter;\n@@ -1041,7 +1041,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n      add it to the list of live on entry blocks.  */\n   FOR_EACH_IMM_USE_FAST (use, imm_iter, ssa_name)\n     {\n-      gimple use_stmt = USE_STMT (use);\n+      gimple *use_stmt = USE_STMT (use);\n       basic_block add_block = NULL;\n \n       if (gimple_code (use_stmt) == GIMPLE_PHI)\n@@ -1314,7 +1314,7 @@ verify_live_on_entry (tree_live_info_p live)\n {\n   unsigned i;\n   tree var;\n-  gimple stmt;\n+  gimple *stmt;\n   basic_block bb;\n   edge e;\n   int num;"}, {"sha": "90dad9fd48f5330a7c594ebc66b2cf4c9f0972c7", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -54,7 +54,7 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n \t\t\t\tint *limit)\n {\n   gimple_stmt_iterator bsi;\n-  gimple last;\n+  gimple *last;\n \n   /* Do not copy one block more than once (we do not really want to do\n      loop peeling here).  */\n@@ -112,7 +112,7 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n static bool\n do_while_loop_p (struct loop *loop)\n {\n-  gimple stmt = last_stmt (loop->latch);\n+  gimple *stmt = last_stmt (loop->latch);\n \n   /* If the latch of the loop is not empty, it is not a do-while loop.  */\n   if (stmt\n@@ -313,7 +313,7 @@ ch_base::copy_headers (function *fun)\n \t\t   !gsi_end_p (bsi);\n \t\t   gsi_next (&bsi))\n \t\t{\n-\t\t  gimple stmt = gsi_stmt (bsi);\n+\t\t  gimple *stmt = gsi_stmt (bsi);\n \t\t  if (gimple_code (stmt) == GIMPLE_COND)\n \t\t    gimple_set_no_warning (stmt, true);\n \t\t  else if (is_gimple_assign (stmt))"}, {"sha": "f3389a0623b63f9b64e89070fee56b50422d3393", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -89,7 +89,7 @@ struct lim_aux_data\n   unsigned cost;\t\t/* Cost of the computation performed by the\n \t\t\t\t   statement.  */\n \n-  vec<gimple> depends;\t\t/* Vector of statements that must be also\n+  vec<gimple *> depends;\t\t/* Vector of statements that must be also\n \t\t\t\t   hoisted out of the loop when this statement\n \t\t\t\t   is hoisted; i.e. those that define the\n \t\t\t\t   operands of the statement and are inside of\n@@ -98,14 +98,14 @@ struct lim_aux_data\n \n /* Maps statements to their lim_aux_data.  */\n \n-static hash_map<gimple, lim_aux_data *> *lim_aux_data_map;\n+static hash_map<gimple *, lim_aux_data *> *lim_aux_data_map;\n \n /* Description of a memory reference location.  */\n \n struct mem_ref_loc\n {\n   tree *ref;\t\t\t/* The reference itself.  */\n-  gimple stmt;\t\t\t/* The statement in that it occurs.  */\n+  gimple *stmt;\t\t\t/* The statement in that it occurs.  */\n };\n \n \n@@ -217,7 +217,7 @@ static bool ref_indep_loop_p (struct loop *, im_mem_ref *);\n #define MEM_ANALYZABLE(REF) ((REF)->id != UNANALYZABLE_MEM_ID)\n \n static struct lim_aux_data *\n-init_lim_data (gimple stmt)\n+init_lim_data (gimple *stmt)\n {\n   lim_aux_data *p = XCNEW (struct lim_aux_data);\n   lim_aux_data_map->put (stmt, p);\n@@ -226,7 +226,7 @@ init_lim_data (gimple stmt)\n }\n \n static struct lim_aux_data *\n-get_lim_data (gimple stmt)\n+get_lim_data (gimple *stmt)\n {\n   lim_aux_data **p = lim_aux_data_map->get (stmt);\n   if (!p)\n@@ -245,7 +245,7 @@ free_lim_aux_data (struct lim_aux_data *data)\n }\n \n static void\n-clear_lim_data (gimple stmt)\n+clear_lim_data (gimple *stmt)\n {\n   lim_aux_data **p = lim_aux_data_map->get (stmt);\n   if (!p)\n@@ -274,7 +274,7 @@ enum move_pos\n    Otherwise return MOVE_IMPOSSIBLE.  */\n \n enum move_pos\n-movement_possibility (gimple stmt)\n+movement_possibility (gimple *stmt)\n {\n   tree lhs;\n   enum move_pos ret = MOVE_POSSIBLE;\n@@ -372,7 +372,7 @@ movement_possibility (gimple stmt)\n static struct loop *\n outermost_invariant_loop (tree def, struct loop *loop)\n {\n-  gimple def_stmt;\n+  gimple *def_stmt;\n   basic_block def_bb;\n   struct loop *max_loop;\n   struct lim_aux_data *lim_data;\n@@ -420,7 +420,7 @@ static bool\n add_dependency (tree def, struct lim_aux_data *data, struct loop *loop,\n \t\tbool add_cost)\n {\n-  gimple def_stmt = SSA_NAME_DEF_STMT (def);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (def);\n   basic_block def_bb = gimple_bb (def_stmt);\n   struct loop *max_loop;\n   struct lim_aux_data *def_data;\n@@ -456,7 +456,7 @@ add_dependency (tree def, struct lim_aux_data *data, struct loop *loop,\n    are just ad-hoc constants, similar to costs for inlining.  */\n \n static unsigned\n-stmt_cost (gimple stmt)\n+stmt_cost (gimple *stmt)\n {\n   /* Always try to create possibilities for unswitching.  */\n   if (gimple_code (stmt) == GIMPLE_COND\n@@ -562,7 +562,7 @@ outermost_indep_loop (struct loop *outer, struct loop *loop, im_mem_ref *ref)\n    it is a store or load.  Otherwise, returns NULL.  */\n \n static tree *\n-simple_mem_ref_in_stmt (gimple stmt, bool *is_store)\n+simple_mem_ref_in_stmt (gimple *stmt, bool *is_store)\n {\n   tree *lhs, *rhs;\n \n@@ -591,7 +591,7 @@ simple_mem_ref_in_stmt (gimple stmt, bool *is_store)\n /* Returns the memory reference contained in STMT.  */\n \n static im_mem_ref *\n-mem_ref_in_stmt (gimple stmt)\n+mem_ref_in_stmt (gimple *stmt)\n {\n   bool store;\n   tree *mem = simple_mem_ref_in_stmt (stmt, &store);\n@@ -684,7 +684,7 @@ extract_true_false_args_from_phi (basic_block dom, gphi *phi,\n    is defined in, and true otherwise.  */\n \n static bool\n-determine_max_movement (gimple stmt, bool must_preserve_exec)\n+determine_max_movement (gimple *stmt, bool must_preserve_exec)\n {\n   basic_block bb = gimple_bb (stmt);\n   struct loop *loop = bb->loop_father;\n@@ -724,7 +724,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n \t  if (!add_dependency (val, lim_data, loop, false))\n \t    return false;\n \n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (val);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (val);\n \t  if (gimple_bb (def_stmt)\n \t      && gimple_bb (def_stmt)->loop_father == loop)\n \t    {\n@@ -743,7 +743,7 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n       if (gimple_phi_num_args (phi) > 1)\n \t{\n \t  basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb);\n-\t  gimple cond;\n+\t  gimple *cond;\n \t  if (gsi_end_p (gsi_last_bb (dom)))\n \t    return false;\n \t  cond = gsi_stmt (gsi_last_bb (dom));\n@@ -820,11 +820,11 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n    operands) is hoisted at least out of the loop LEVEL.  */\n \n static void\n-set_level (gimple stmt, struct loop *orig_loop, struct loop *level)\n+set_level (gimple *stmt, struct loop *orig_loop, struct loop *level)\n {\n   struct loop *stmt_loop = gimple_bb (stmt)->loop_father;\n   struct lim_aux_data *lim_data;\n-  gimple dep_stmt;\n+  gimple *dep_stmt;\n   unsigned i;\n \n   stmt_loop = find_common_loop (orig_loop, stmt_loop);\n@@ -848,15 +848,15 @@ set_level (gimple stmt, struct loop *orig_loop, struct loop *level)\n    information to set it more sanely.  */\n \n static void\n-set_profitable_level (gimple stmt)\n+set_profitable_level (gimple *stmt)\n {\n   set_level (stmt, gimple_bb (stmt)->loop_father, get_lim_data (stmt)->max_loop);\n }\n \n /* Returns true if STMT is a call that has side effects.  */\n \n static bool\n-nonpure_call_p (gimple stmt)\n+nonpure_call_p (gimple *stmt)\n {\n   if (gimple_code (stmt) != GIMPLE_CALL)\n     return false;\n@@ -866,7 +866,7 @@ nonpure_call_p (gimple stmt)\n \n /* Rewrite a/b to a*(1/b).  Return the invariant stmt to process.  */\n \n-static gimple\n+static gimple *\n rewrite_reciprocal (gimple_stmt_iterator *bsi)\n {\n   gassign *stmt, *stmt1, *stmt2;\n@@ -900,13 +900,13 @@ rewrite_reciprocal (gimple_stmt_iterator *bsi)\n /* Check if the pattern at *BSI is a bittest of the form\n    (A >> B) & 1 != 0 and in this case rewrite it to A & (1 << B) != 0.  */\n \n-static gimple\n+static gimple *\n rewrite_bittest (gimple_stmt_iterator *bsi)\n {\n   gassign *stmt;\n-  gimple stmt1;\n+  gimple *stmt1;\n   gassign *stmt2;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   gcond *cond_stmt;\n   tree lhs, name, t, a, b;\n   use_operand_p use;\n@@ -1013,7 +1013,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n {\n   enum move_pos pos;\n   gimple_stmt_iterator bsi;\n-  gimple stmt;\n+  gimple *stmt;\n   bool maybe_never = ALWAYS_EXECUTED_IN (bb) == NULL;\n   struct loop *outermost = ALWAYS_EXECUTED_IN (bb);\n   struct lim_aux_data *lim_data;\n@@ -1203,7 +1203,7 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n       else\n \t{\n \t  basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb);\n-\t  gimple cond = gsi_stmt (gsi_last_bb (dom));\n+\t  gimple *cond = gsi_stmt (gsi_last_bb (dom));\n \t  tree arg0 = NULL_TREE, arg1 = NULL_TREE, t;\n \t  /* Get the PHI arguments corresponding to the true and false\n \t     edges of COND.  */\n@@ -1232,7 +1232,7 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n     {\n       edge e;\n \n-      gimple stmt = gsi_stmt (bsi);\n+      gimple *stmt = gsi_stmt (bsi);\n \n       lim_data = get_lim_data (stmt);\n       if (lim_data == NULL)\n@@ -1365,7 +1365,7 @@ may_move_till (tree ref, tree *index, void *data)\n static void\n force_move_till_op (tree op, struct loop *orig_loop, struct loop *loop)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (!op\n       || is_gimple_min_invariant (op))\n@@ -1439,7 +1439,7 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n    description REF.  The reference occurs in statement STMT.  */\n \n static void\n-record_mem_ref_loc (im_mem_ref *ref, gimple stmt, tree *loc)\n+record_mem_ref_loc (im_mem_ref *ref, gimple *stmt, tree *loc)\n {\n   mem_ref_loc aref;\n   aref.stmt = stmt;\n@@ -1474,7 +1474,7 @@ mark_ref_stored (im_mem_ref *ref, struct loop *loop)\n    well.  */\n \n static void\n-gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n+gather_mem_refs_stmt (struct loop *loop, gimple *stmt)\n {\n   tree *mem = NULL;\n   hashval_t hash;\n@@ -1826,7 +1826,7 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n   bool loop_has_only_one_exit;\n   edge then_old_edge, orig_ex = ex;\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n   struct prev_flag_edges *prev_edges = (struct prev_flag_edges *) ex->aux;\n   bool irr = ex->flags & EDGE_IRREDUCIBLE_LOOP;\n \n@@ -1945,7 +1945,7 @@ sm_set_flag_if_changed::operator () (mem_ref_loc *loc)\n       && gimple_assign_lhs_ptr (loc->stmt) == loc->ref)\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (loc->stmt);\n-      gimple stmt = gimple_build_assign (flag, boolean_true_node);\n+      gimple *stmt = gimple_build_assign (flag, boolean_true_node);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n     }\n   return false;\n@@ -2464,7 +2464,7 @@ tree_ssa_lim_initialize (void)\n \n   bitmap_obstack_initialize (&lim_bitmap_obstack);\n   gcc_obstack_init (&mem_ref_obstack);\n-  lim_aux_data_map = new hash_map<gimple, lim_aux_data *>;\n+  lim_aux_data_map = new hash_map<gimple *, lim_aux_data *>;\n \n   if (flag_tm)\n     compute_transaction_bits ();"}, {"sha": "6599ffc743ebf118957235107d5bdf9d4203ffec", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -161,7 +161,7 @@ struct loop_size\n /* Return true if OP in STMT will be constant after peeling LOOP.  */\n \n static bool\n-constant_after_peeling (tree op, gimple stmt, struct loop *loop)\n+constant_after_peeling (tree op, gimple *stmt, struct loop *loop)\n {\n   affine_iv iv;\n \n@@ -246,7 +246,7 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \n       for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  int num = estimate_num_insns (stmt, &eni_size_weights);\n \t  bool likely_eliminated = false;\n \t  bool likely_eliminated_last = false;\n@@ -338,7 +338,7 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n       basic_block bb = path.pop ();\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  if (gimple_code (stmt) == GIMPLE_CALL)\n \t    {\n \t      int flags = gimple_call_flags (stmt);\n@@ -1176,7 +1176,7 @@ static void\n propagate_into_all_uses (tree ssa_name, tree val)\n {\n   imm_use_iterator iter;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, iter, ssa_name)\n     {\n@@ -1227,7 +1227,7 @@ propagate_constants_for_unrolling (basic_block bb)\n   /* Look for assignments to SSA names with constant RHS.  */\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       tree lhs;\n \n       if (is_gimple_assign (stmt)"}, {"sha": "1ddd8bdfd21b9501b1677a155c4fee52db943aea", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -204,7 +204,7 @@ struct iv_use\n   unsigned sub_id;\t/* The id of the sub use.  */\n   enum use_type type;\t/* Type of the use.  */\n   struct iv *iv;\t/* The induction variable it is based on.  */\n-  gimple stmt;\t\t/* Statement in that it occurs.  */\n+  gimple *stmt;\t\t/* Statement in that it occurs.  */\n   tree *op_p;\t\t/* The place where it occurs.  */\n   bitmap related_cands;\t/* The set of \"related\" iv candidates, plus the common\n \t\t\t   important ones.  */\n@@ -239,7 +239,7 @@ struct iv_cand\n   bool important;\t/* Whether this is an \"important\" candidate, i.e. such\n \t\t\t   that it should be considered by all uses.  */\n   ENUM_BITFIELD(iv_position) pos : 8;\t/* Where it is computed.  */\n-  gimple incremented_at;/* For original biv, the statement where it is\n+  gimple *incremented_at;/* For original biv, the statement where it is\n \t\t\t   incremented.  */\n   tree var_before;\t/* The variable used for it before increment.  */\n   tree var_after;\t/* The variable used for it after increment.  */\n@@ -690,7 +690,7 @@ name_info (struct ivopts_data *data, tree name)\n    emitted in LOOP.  */\n \n static bool\n-stmt_after_ip_normal_pos (struct loop *loop, gimple stmt)\n+stmt_after_ip_normal_pos (struct loop *loop, gimple *stmt)\n {\n   basic_block bb = ip_normal_pos (loop), sbb = gimple_bb (stmt);\n \n@@ -710,7 +710,7 @@ stmt_after_ip_normal_pos (struct loop *loop, gimple stmt)\n    if the positions are identical.  */\n \n static bool\n-stmt_after_inc_pos (struct iv_cand *cand, gimple stmt, bool true_if_equal)\n+stmt_after_inc_pos (struct iv_cand *cand, gimple *stmt, bool true_if_equal)\n {\n   basic_block cand_bb = gimple_bb (cand->incremented_at);\n   basic_block stmt_bb = gimple_bb (stmt);\n@@ -731,7 +731,7 @@ stmt_after_inc_pos (struct iv_cand *cand, gimple stmt, bool true_if_equal)\n    CAND is incremented in LOOP.  */\n \n static bool\n-stmt_after_increment (struct loop *loop, struct iv_cand *cand, gimple stmt)\n+stmt_after_increment (struct loop *loop, struct iv_cand *cand, gimple *stmt)\n {\n   switch (cand->pos)\n     {\n@@ -1159,7 +1159,7 @@ static void\n mark_bivs (struct ivopts_data *data)\n {\n   gphi *phi;\n-  gimple def;\n+  gimple *def;\n   tree var;\n   struct iv *iv, *incr_iv;\n   struct loop *loop = data->current_loop;\n@@ -1206,7 +1206,7 @@ mark_bivs (struct ivopts_data *data)\n    parameters to IV.  */\n \n static bool\n-find_givs_in_stmt_scev (struct ivopts_data *data, gimple stmt, affine_iv *iv)\n+find_givs_in_stmt_scev (struct ivopts_data *data, gimple *stmt, affine_iv *iv)\n {\n   tree lhs, stop;\n   struct loop *loop = data->current_loop;\n@@ -1247,7 +1247,7 @@ find_givs_in_stmt_scev (struct ivopts_data *data, gimple stmt, affine_iv *iv)\n /* Finds general ivs in statement STMT.  */\n \n static void\n-find_givs_in_stmt (struct ivopts_data *data, gimple stmt)\n+find_givs_in_stmt (struct ivopts_data *data, gimple *stmt)\n {\n   affine_iv iv;\n \n@@ -1332,7 +1332,7 @@ find_induction_variables (struct ivopts_data *data)\n \n static struct iv_use *\n record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,\n-\t    gimple stmt, enum use_type use_type, tree addr_base = NULL,\n+\t    gimple *stmt, enum use_type use_type, tree addr_base = NULL,\n \t    unsigned HOST_WIDE_INT addr_offset = 0)\n {\n   struct iv_use *use = XCNEW (struct iv_use);\n@@ -1358,7 +1358,7 @@ record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,\n \n static struct iv_use *\n record_sub_use (struct ivopts_data *data, tree *use_p,\n-\t\t    struct iv *iv, gimple stmt, enum use_type use_type,\n+\t\t    struct iv *iv, gimple *stmt, enum use_type use_type,\n \t\t    tree addr_base, unsigned HOST_WIDE_INT addr_offset,\n \t\t    unsigned int id_group)\n {\n@@ -1432,7 +1432,7 @@ static struct iv_use *\n find_interesting_uses_op (struct ivopts_data *data, tree op)\n {\n   struct iv *iv;\n-  gimple stmt;\n+  gimple *stmt;\n   struct iv_use *use;\n \n   if (TREE_CODE (op) != SSA_NAME)\n@@ -1476,7 +1476,7 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n    condition and false is returned.  */\n \n static bool\n-extract_cond_operands (struct ivopts_data *data, gimple stmt,\n+extract_cond_operands (struct ivopts_data *data, gimple *stmt,\n \t\t       tree **control_var, tree **bound,\n \t\t       struct iv **iv_var, struct iv **iv_bound)\n {\n@@ -1537,7 +1537,7 @@ extract_cond_operands (struct ivopts_data *data, gimple stmt,\n    records it.  */\n \n static void\n-find_interesting_uses_cond (struct ivopts_data *data, gimple stmt)\n+find_interesting_uses_cond (struct ivopts_data *data, gimple *stmt)\n {\n   tree *var_p, *bound_p;\n   struct iv *var_iv;\n@@ -1648,7 +1648,7 @@ find_deriving_biv_for_expr (struct ivopts_data *data, tree expr)\n   unsigned i, n;\n   tree e2, e1;\n   enum tree_code code;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (expr == NULL_TREE)\n     return NULL;\n@@ -1782,7 +1782,7 @@ record_biv_for_address_use (struct ivopts_data *data, struct iv *biv)\n struct ifs_ivopts_data\n {\n   struct ivopts_data *ivopts_data;\n-  gimple stmt;\n+  gimple *stmt;\n   tree step;\n };\n \n@@ -2036,7 +2036,7 @@ strip_offset (tree expr, unsigned HOST_WIDE_INT *offset);\n \n static struct iv_use *\n record_group_use (struct ivopts_data *data, tree *use_p,\n-\t\t  struct iv *iv, gimple stmt, enum use_type use_type)\n+\t\t  struct iv *iv, gimple *stmt, enum use_type use_type)\n {\n   unsigned int i;\n   struct iv_use *use;\n@@ -2073,7 +2073,8 @@ record_group_use (struct ivopts_data *data, tree *use_p,\n /* Finds addresses in *OP_P inside STMT.  */\n \n static void\n-find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p)\n+find_interesting_uses_address (struct ivopts_data *data, gimple *stmt,\n+\t\t\t       tree *op_p)\n {\n   tree base = *op_p, step = size_zero_node;\n   struct iv *civ;\n@@ -2190,7 +2191,7 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n /* Finds and records invariants used in STMT.  */\n \n static void\n-find_invariants_stmt (struct ivopts_data *data, gimple stmt)\n+find_invariants_stmt (struct ivopts_data *data, gimple *stmt)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n@@ -2206,7 +2207,7 @@ find_invariants_stmt (struct ivopts_data *data, gimple stmt)\n /* Finds interesting uses of induction variables in the statement STMT.  */\n \n static void\n-find_interesting_uses_stmt (struct ivopts_data *data, gimple stmt)\n+find_interesting_uses_stmt (struct ivopts_data *data, gimple *stmt)\n {\n   struct iv *iv;\n   tree op, *lhs, *rhs;\n@@ -2764,7 +2765,7 @@ find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n static struct iv_cand *\n add_candidate_1 (struct ivopts_data *data,\n \t\t tree base, tree step, bool important, enum iv_position pos,\n-\t\t struct iv_use *use, gimple incremented_at,\n+\t\t struct iv_use *use, gimple *incremented_at,\n \t\t struct iv *orig_iv = NULL)\n {\n   unsigned i;\n@@ -2997,7 +2998,7 @@ add_standard_iv_candidates (struct ivopts_data *data)\n static void\n add_iv_candidate_for_biv (struct ivopts_data *data, struct iv *iv)\n {\n-  gimple phi;\n+  gimple *phi;\n   tree def;\n   struct iv_cand *cand;\n \n@@ -3463,7 +3464,7 @@ computation_cost (tree expr, bool speed)\n /* Returns variable containing the value of candidate CAND at statement AT.  */\n \n static tree\n-var_at_stmt (struct loop *loop, struct iv_cand *cand, gimple stmt)\n+var_at_stmt (struct loop *loop, struct iv_cand *cand, gimple *stmt)\n {\n   if (stmt_after_increment (loop, cand, stmt))\n     return cand->var_after;\n@@ -3513,7 +3514,7 @@ determine_common_wider_type (tree *a, tree *b)\n \n static bool\n get_computation_aff (struct loop *loop,\n-\t\t     struct iv_use *use, struct iv_cand *cand, gimple at,\n+\t\t     struct iv_use *use, struct iv_cand *cand, gimple *at,\n \t\t     struct aff_tree *aff)\n {\n   tree ubase = use->iv->base;\n@@ -3632,7 +3633,7 @@ get_use_type (struct iv_use *use)\n \n static tree\n get_computation_at (struct loop *loop,\n-\t\t    struct iv_use *use, struct iv_cand *cand, gimple at)\n+\t\t    struct iv_use *use, struct iv_cand *cand, gimple *at)\n {\n   aff_tree aff;\n   tree type = get_use_type (use);\n@@ -4602,7 +4603,7 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n static comp_cost\n get_computation_cost_at (struct ivopts_data *data,\n \t\t\t struct iv_use *use, struct iv_cand *cand,\n-\t\t\t bool address_p, bitmap *depends_on, gimple at,\n+\t\t\t bool address_p, bitmap *depends_on, gimple *at,\n \t\t\t bool *can_autoinc,\n                          int *inv_expr_id)\n {\n@@ -4926,7 +4927,7 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n    stores it to VAL.  */\n \n static void\n-cand_value_at (struct loop *loop, struct iv_cand *cand, gimple at, tree niter,\n+cand_value_at (struct loop *loop, struct iv_cand *cand, gimple *at, tree niter,\n \t       aff_tree *val)\n {\n   aff_tree step, delta, nit;\n@@ -5018,7 +5019,7 @@ difference_cannot_overflow_p (struct ivopts_data *data, tree base, tree offset)\n \n   if (TREE_CODE (base) == SSA_NAME)\n     {\n-      gimple stmt = SSA_NAME_DEF_STMT (base);\n+      gimple *stmt = SSA_NAME_DEF_STMT (base);\n \n       if (gimple_code (stmt) != GIMPLE_ASSIGN)\n \treturn false;\n@@ -7003,7 +7004,7 @@ static void\n adjust_iv_update_pos (struct iv_cand *cand, struct iv_use *use)\n {\n   tree var_after;\n-  gimple iv_update, stmt;\n+  gimple *iv_update, *stmt;\n   basic_block bb;\n   gimple_stmt_iterator gsi, gsi_iv;\n \n@@ -7245,7 +7246,7 @@ remove_unused_ivs (struct ivopts_data *data)\n \t    {\n \t      imm_use_iterator imm_iter;\n \t      use_operand_p use_p;\n-\t      gimple stmt;\n+\t      gimple *stmt;\n \t      int count = 0;\n \n \t      FOR_EACH_IMM_USE_STMT (stmt, imm_iter, def)\n@@ -7471,7 +7472,7 @@ loop_body_includes_call (basic_block *body, unsigned num_nodes)\n   for (i = 0; i < num_nodes; i++)\n     for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tgimple stmt = gsi_stmt (gsi);\n+\tgimple *stmt = gsi_stmt (gsi);\n \tif (is_gimple_call (stmt)\n \t    && !is_inexpensive_builtin (gimple_call_fndecl (stmt)))\n \t  return true;"}, {"sha": "27ba2755685896bd335c43a81311ae4adc0cdd6f", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -281,7 +281,7 @@ add_exit_phi (basic_block exit, tree var)\n #ifdef ENABLE_CHECKING\n   /* Check that at least one of the edges entering the EXIT block exits\n      the loop, or a superloop of that loop, that VAR is defined in.  */\n-  gimple def_stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n   basic_block def_bb = gimple_bb (def_stmt);\n   FOR_EACH_EDGE (e, ei, exit->preds)\n     {\n@@ -408,7 +408,7 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks,\n    names are used to USE_BLOCKS, and the ssa names themselves to NEED_PHIS.  */\n \n static void\n-find_uses_to_rename_stmt (gimple stmt, bitmap *use_blocks, bitmap need_phis,\n+find_uses_to_rename_stmt (gimple *stmt, bitmap *use_blocks, bitmap need_phis,\n \t\t\t  int use_flags)\n {\n   ssa_op_iter iter;\n@@ -492,7 +492,7 @@ find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis,\n static void\n find_uses_to_rename_def (tree def, bitmap *use_blocks, bitmap need_phis)\n {\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   imm_use_iterator imm_iter;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n@@ -548,7 +548,7 @@ find_uses_to_rename_in_loop (struct loop *loop, bitmap *use_blocks,\n       for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);\n \t   gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \t  /* FOR_EACH_SSA_TREE_OPERAND iterator does not allows\n \t     SSA_OP_VIRTUAL_DEFS only.  */\n \t  if (def_flags == SSA_OP_VIRTUAL_DEFS)\n@@ -699,7 +699,7 @@ rewrite_virtuals_into_loop_closed_ssa (struct loop *loop)\n static void\n check_loop_closed_ssa_use (basic_block bb, tree use)\n {\n-  gimple def;\n+  gimple *def;\n   basic_block def_bb;\n \n   if (TREE_CODE (use) != SSA_NAME || virtual_operand_p (use))\n@@ -714,7 +714,7 @@ check_loop_closed_ssa_use (basic_block bb, tree use)\n /* Checks invariants of loop closed ssa form in statement STMT in BB.  */\n \n static void\n-check_loop_closed_ssa_stmt (basic_block bb, gimple stmt)\n+check_loop_closed_ssa_stmt (basic_block bb, gimple *stmt)\n {\n   ssa_op_iter iter;\n   tree var;\n@@ -816,7 +816,7 @@ ip_end_pos (struct loop *loop)\n basic_block\n ip_normal_pos (struct loop *loop)\n {\n-  gimple last;\n+  gimple *last;\n   basic_block bb;\n   edge exit;\n \n@@ -849,7 +849,7 @@ standard_iv_increment_position (struct loop *loop, gimple_stmt_iterator *bsi,\n \t\t\t\tbool *insert_after)\n {\n   basic_block bb = ip_normal_pos (loop), latch = ip_end_pos (loop);\n-  gimple last = last_stmt (latch);\n+  gimple *last = last_stmt (latch);\n \n   if (!bb\n       || (last && gimple_code (last) != GIMPLE_LABEL))"}, {"sha": "70bdb841245e43839eaff2d03ed10b67e0ba4719", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -438,7 +438,7 @@ determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n \t{\n \t  edge e;\n \t  tree c0, c1;\n-\t  gimple cond;\n+\t  gimple *cond;\n \t  enum tree_code cmp;\n \n \t  if (!single_pred_p (bb))\n@@ -725,7 +725,7 @@ bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n   edge e;\n   basic_block bb;\n   tree c0, c1;\n-  gimple cond;\n+  gimple *cond;\n   enum tree_code cmp;\n \n   /* Get rid of unnecessary casts, but preserve the value of\n@@ -1815,7 +1815,7 @@ expand_simple_operations (tree expr, tree stop)\n   unsigned i, n;\n   tree ret = NULL_TREE, e, ee, e1;\n   enum tree_code code;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (expr == NULL_TREE)\n     return expr;\n@@ -2054,7 +2054,7 @@ simplify_using_initial_conditions (struct loop *loop, tree expr, tree stop)\n {\n   edge e;\n   basic_block bb;\n-  gimple stmt;\n+  gimple *stmt;\n   tree cond;\n   int cnt = 0;\n \n@@ -2156,7 +2156,7 @@ loop_only_exit_p (const struct loop *loop, const_edge exit)\n   basic_block *body;\n   gimple_stmt_iterator bsi;\n   unsigned i;\n-  gimple call;\n+  gimple *call;\n \n   if (exit != single_exit (loop))\n     return false;\n@@ -2198,7 +2198,7 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \t\t\t   struct tree_niter_desc *niter,\n \t\t\t   bool warn, bool every_iteration)\n {\n-  gimple last;\n+  gimple *last;\n   gcond *stmt;\n   tree type;\n   tree op0, op1;\n@@ -2441,7 +2441,7 @@ finite_loop_p (struct loop *loop)\n static gphi *\n chain_of_csts_start (struct loop *loop, tree x)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (x);\n+  gimple *stmt = SSA_NAME_DEF_STMT (x);\n   tree use;\n   basic_block bb = gimple_bb (stmt);\n   enum tree_code code;\n@@ -2525,7 +2525,7 @@ get_base_for (struct loop *loop, tree x)\n static tree\n get_val_for (tree x, tree base)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   gcc_checking_assert (is_gimple_min_invariant (base));\n \n@@ -2581,7 +2581,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n   tree acnd;\n   tree op[2], val[2], next[2], aval[2];\n   gphi *phi;\n-  gimple cond;\n+  gimple *cond;\n   unsigned i, j;\n   enum tree_code cmp;\n \n@@ -2721,7 +2721,7 @@ static widest_int derive_constant_upper_bound_ops (tree, tree,\n    an assignment statement STMT.  */\n \n static widest_int\n-derive_constant_upper_bound_assign (gimple stmt)\n+derive_constant_upper_bound_assign (gimple *stmt)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree op0 = gimple_assign_rhs1 (stmt);\n@@ -2755,7 +2755,7 @@ derive_constant_upper_bound_ops (tree type, tree op0,\n {\n   tree subtype, maxt;\n   widest_int bnd, max, mmax, cst;\n-  gimple stmt;\n+  gimple *stmt;\n \n   if (INTEGRAL_TYPE_P (type))\n     maxt = TYPE_MAX_VALUE (type);\n@@ -2888,7 +2888,7 @@ derive_constant_upper_bound_ops (tree type, tree op0,\n \n static void\n do_warn_aggressive_loop_optimizations (struct loop *loop,\n-\t\t\t\t       widest_int i_bound, gimple stmt)\n+\t\t\t\t       widest_int i_bound, gimple *stmt)\n {\n   /* Don't warn if the loop doesn't have known constant bound.  */\n   if (!loop->nb_iterations\n@@ -2910,7 +2910,7 @@ do_warn_aggressive_loop_optimizations (struct loop *loop,\n   if (e == NULL)\n     return;\n \n-  gimple estmt = last_stmt (e->src);\n+  gimple *estmt = last_stmt (e->src);\n   if (warning_at (gimple_location (stmt), OPT_Waggressive_loop_optimizations,\n \t\t  \"iteration %E invokes undefined behavior\",\n \t\t  wide_int_to_tree (TREE_TYPE (loop->nb_iterations),\n@@ -2928,7 +2928,7 @@ do_warn_aggressive_loop_optimizations (struct loop *loop,\n \n static void\n record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n-\t\t gimple at_stmt, bool is_exit, bool realistic, bool upper)\n+\t\t gimple *at_stmt, bool is_exit, bool realistic, bool upper)\n {\n   widest_int delta;\n \n@@ -3024,7 +3024,7 @@ record_control_iv (struct loop *loop, struct tree_niter_desc *niter)\n    UPPER is true if we are sure the induction variable does not wrap.  */\n \n static void\n-record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple stmt,\n+record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple *stmt,\n \t\t       tree low, tree high, bool realistic, bool upper)\n {\n   tree niter_bound, extreme, delta;\n@@ -3096,7 +3096,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple stmt,\n struct ilb_data\n {\n   struct loop *loop;\n-  gimple stmt;\n+  gimple *stmt;\n };\n \n static bool\n@@ -3195,7 +3195,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n    STMT is guaranteed to be executed in every iteration of LOOP.*/\n \n static void\n-infer_loop_bounds_from_ref (struct loop *loop, gimple stmt, tree ref)\n+infer_loop_bounds_from_ref (struct loop *loop, gimple *stmt, tree ref)\n {\n   struct ilb_data data;\n \n@@ -3209,7 +3209,7 @@ infer_loop_bounds_from_ref (struct loop *loop, gimple stmt, tree ref)\n    executed in every iteration of LOOP.  */\n \n static void\n-infer_loop_bounds_from_array (struct loop *loop, gimple stmt)\n+infer_loop_bounds_from_array (struct loop *loop, gimple *stmt)\n {\n   if (is_gimple_assign (stmt))\n     {\n@@ -3246,7 +3246,7 @@ infer_loop_bounds_from_array (struct loop *loop, gimple stmt)\n    that pointer arithmetics in STMT does not overflow.  */\n \n static void\n-infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple stmt)\n+infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple *stmt)\n {\n   tree def, base, step, scev, type, low, high;\n   tree var, ptr;\n@@ -3304,7 +3304,7 @@ infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple stmt)\n    that signed arithmetics in STMT does not overflow.  */\n \n static void\n-infer_loop_bounds_from_signedness (struct loop *loop, gimple stmt)\n+infer_loop_bounds_from_signedness (struct loop *loop, gimple *stmt)\n {\n   tree def, base, step, scev, type, low, high;\n \n@@ -3372,7 +3372,7 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n \n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple *stmt = gsi_stmt (bsi);\n \n \t  infer_loop_bounds_from_array (loop, stmt);\n \n@@ -3598,7 +3598,7 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n static void\n maybe_lower_iteration_bound (struct loop *loop)\n {\n-  hash_set<gimple> *not_executed_last_iteration = NULL;\n+  hash_set<gimple *> *not_executed_last_iteration = NULL;\n   struct nb_iter_bound *elt;\n   bool found_exit = false;\n   vec<basic_block> queue = vNULL;\n@@ -3617,7 +3617,7 @@ maybe_lower_iteration_bound (struct loop *loop)\n \t  && wi::ltu_p (elt->bound, loop->nb_iterations_upper_bound))\n \t{\n \t  if (!not_executed_last_iteration)\n-\t    not_executed_last_iteration = new hash_set<gimple>;\n+\t    not_executed_last_iteration = new hash_set<gimple *>;\n \t  not_executed_last_iteration->add (elt->stmt);\n \t}\n     }\n@@ -3643,7 +3643,7 @@ maybe_lower_iteration_bound (struct loop *loop)\n       /* Loop for possible exits and statements bounding the execution.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  if (not_executed_last_iteration->contains (stmt))\n \t    {\n \t      stmt_found = true;\n@@ -3922,7 +3922,7 @@ estimate_numbers_of_iterations (void)\n /* Returns true if statement S1 dominates statement S2.  */\n \n bool\n-stmt_dominates_stmt_p (gimple s1, gimple s2)\n+stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n {\n   basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);\n \n@@ -3964,7 +3964,7 @@ stmt_dominates_stmt_p (gimple s1, gimple s2)\n    bounds computed by discover_iteration_bound_by_body_walk.  */\n \n static bool\n-n_of_executions_at_most (gimple stmt,\n+n_of_executions_at_most (gimple *stmt,\n \t\t\t struct nb_iter_bound *niter_bound,\n \t\t\t tree niter)\n {\n@@ -4052,7 +4052,7 @@ nowrap_type_p (tree type)\n \n static bool\n loop_exits_before_overflow (tree base, tree step,\n-\t\t\t    gimple at_stmt, struct loop *loop)\n+\t\t\t    gimple *at_stmt, struct loop *loop)\n {\n   widest_int niter;\n   struct control_iv *civ;\n@@ -4192,7 +4192,7 @@ loop_exits_before_overflow (tree base, tree step,\n \n bool\n scev_probably_wraps_p (tree base, tree step,\n-\t\t       gimple at_stmt, struct loop *loop,\n+\t\t       gimple *at_stmt, struct loop *loop,\n \t\t       bool use_overflow_semantics)\n {\n   /* FIXME: We really need something like"}, {"sha": "6140e3df6e4871ab7458cfa12383314b8d6328f3", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -40,9 +40,9 @@ extern HOST_WIDE_INT estimated_stmt_executions_int (struct loop *);\n extern bool max_stmt_executions (struct loop *, widest_int *);\n extern bool estimated_stmt_executions (struct loop *, widest_int *);\n extern void estimate_numbers_of_iterations (void);\n-extern bool stmt_dominates_stmt_p (gimple, gimple);\n+extern bool stmt_dominates_stmt_p (gimple *, gimple *);\n extern bool nowrap_type_p (tree);\n-extern bool scev_probably_wraps_p (tree, tree, gimple, struct loop *, bool);\n+extern bool scev_probably_wraps_p (tree, tree, gimple *, struct loop *, bool);\n extern void free_loop_control_ivs (struct loop *);\n extern void free_numbers_of_iterations_estimates_loop (struct loop *);\n extern void free_numbers_of_iterations_estimates (void);"}, {"sha": "f020ea341bcdd0d99d39d223b28cbc08e9124261", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -275,7 +275,7 @@ struct mem_ref_group\n \n struct mem_ref\n {\n-  gimple stmt;\t\t\t/* Statement in that the reference appears.  */\n+  gimple *stmt;\t\t\t/* Statement in that the reference appears.  */\n   tree mem;\t\t\t/* The reference.  */\n   HOST_WIDE_INT delta;\t\t/* Constant offset of the reference.  */\n   struct mem_ref_group *group;\t/* The group of references it belongs to.  */\n@@ -364,7 +364,7 @@ find_or_create_group (struct mem_ref_group **groups, tree base, tree step)\n    WRITE_P.  The reference occurs in statement STMT.  */\n \n static void\n-record_ref (struct mem_ref_group *group, gimple stmt, tree mem,\n+record_ref (struct mem_ref_group *group, gimple *stmt, tree mem,\n \t    HOST_WIDE_INT delta, bool write_p)\n {\n   struct mem_ref **aref;\n@@ -430,7 +430,7 @@ release_mem_refs (struct mem_ref_group *groups)\n struct ar_data\n {\n   struct loop *loop;\t\t\t/* Loop of the reference.  */\n-  gimple stmt;\t\t\t\t/* Statement of the reference.  */\n+  gimple *stmt;\t\t\t\t/* Statement of the reference.  */\n   tree *step;\t\t\t\t/* Step of the memory reference.  */\n   HOST_WIDE_INT *delta;\t\t\t/* Offset of the memory reference.  */\n };\n@@ -496,7 +496,7 @@ idx_analyze_ref (tree base, tree *index, void *data)\n static bool\n analyze_ref (struct loop *loop, tree *ref_p, tree *base,\n \t     tree *step, HOST_WIDE_INT *delta,\n-\t     gimple stmt)\n+\t     gimple *stmt)\n {\n   struct ar_data ar_data;\n   tree off;\n@@ -544,7 +544,7 @@ analyze_ref (struct loop *loop, tree *ref_p, tree *base,\n \n static bool\n gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n-\t\t\t      tree ref, bool write_p, gimple stmt)\n+\t\t\t      tree ref, bool write_p, gimple *stmt)\n {\n   tree base, step;\n   HOST_WIDE_INT delta;\n@@ -620,7 +620,7 @@ gather_memory_references (struct loop *loop, bool *no_other_refs, unsigned *ref_\n   basic_block bb;\n   unsigned i;\n   gimple_stmt_iterator bsi;\n-  gimple stmt;\n+  gimple *stmt;\n   tree lhs, rhs;\n   struct mem_ref_group *refs = NULL;\n "}, {"sha": "0b546122cb67907146e556e80d805068389d4e96", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -136,7 +136,7 @@ tree_ssa_unswitch_loops (void)\n static tree\n tree_may_unswitch_on (basic_block bb, struct loop *loop)\n {\n-  gimple last, def;\n+  gimple *last, *def;\n   gcond *stmt;\n   tree cond, use;\n   basic_block def_bb;\n@@ -178,7 +178,7 @@ static tree\n simplify_using_entry_checks (struct loop *loop, tree cond)\n {\n   edge e = loop_preheader_edge (loop);\n-  gimple stmt;\n+  gimple *stmt;\n \n   while (1)\n     {\n@@ -214,7 +214,7 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n   struct loop *nloop;\n   unsigned i, found;\n   tree cond = NULL_TREE;\n-  gimple stmt;\n+  gimple *stmt;\n   bool changed = false;\n \n   i = 0;\n@@ -314,7 +314,7 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n \n \t  if (EDGE_COUNT (b->succs) == 2)\n \t    {\n-\t      gimple stmt = last_stmt (b);\n+\t      gimple *stmt = last_stmt (b);\n \t      if (stmt\n \t\t  && gimple_code (stmt) == GIMPLE_COND)\n \t\t{"}, {"sha": "48c7b6740eda701529a459fc5f1962e983bba896", "filename": "gcc/tree-ssa-loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -70,7 +70,7 @@ extern unsigned tree_num_loop_insns (struct loop *, struct eni_weights *);\n /* Returns the loop of the statement STMT.  */\n \n static inline struct loop *\n-loop_containing_stmt (gimple stmt)\n+loop_containing_stmt (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   if (!bb)"}, {"sha": "42708ee6ad1b711be0d72f570224628645bb8ec2", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -127,7 +127,7 @@ struct occurrence {\n \n   /* If non-NULL, the GIMPLE_ASSIGN for a reciprocal computation that\n      was inserted in BB.  */\n-  gimple recip_def_stmt;\n+  gimple *recip_def_stmt;\n \n   /* Pointer to a list of \"struct occurrence\"s for blocks dominated\n      by BB.  */\n@@ -324,7 +324,7 @@ compute_merit (struct occurrence *occ)\n \n /* Return whether USE_STMT is a floating-point division by DEF.  */\n static inline bool\n-is_division_by (gimple use_stmt, tree def)\n+is_division_by (gimple *use_stmt, tree def)\n {\n   return is_gimple_assign (use_stmt)\n \t && gimple_assign_rhs_code (use_stmt) == RDIV_EXPR\n@@ -404,7 +404,7 @@ insert_reciprocals (gimple_stmt_iterator *def_gsi, struct occurrence *occ,\n static inline void\n replace_reciprocal (use_operand_p use_p)\n {\n-  gimple use_stmt = USE_STMT (use_p);\n+  gimple *use_stmt = USE_STMT (use_p);\n   basic_block bb = gimple_bb (use_stmt);\n   struct occurrence *occ = (struct occurrence *) bb->aux;\n \n@@ -464,7 +464,7 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)\n \n   FOR_EACH_IMM_USE_FAST (use_p, use_iter, def)\n     {\n-      gimple use_stmt = USE_STMT (use_p);\n+      gimple *use_stmt = USE_STMT (use_p);\n       if (is_division_by (use_stmt, def))\n \t{\n \t  register_division_in (gimple_bb (use_stmt));\n@@ -476,7 +476,7 @@ execute_cse_reciprocals_1 (gimple_stmt_iterator *def_gsi, tree def)\n   threshold = targetm.min_divisions_for_recip_mul (TYPE_MODE (TREE_TYPE (def)));\n   if (count >= threshold)\n     {\n-      gimple use_stmt;\n+      gimple *use_stmt;\n       for (occ = occ_head; occ; occ = occ->next)\n \t{\n \t  compute_merit (occ);\n@@ -572,7 +572,7 @@ pass_cse_reciprocals::execute (function *fun)\n       for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  if (gimple_has_lhs (stmt)\n \t      && (def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF)) != NULL\n@@ -588,14 +588,14 @@ pass_cse_reciprocals::execute (function *fun)\n       for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree fndecl;\n \n \t  if (is_gimple_assign (stmt)\n \t      && gimple_assign_rhs_code (stmt) == RDIV_EXPR)\n \t    {\n \t      tree arg1 = gimple_assign_rhs2 (stmt);\n-\t      gimple stmt1;\n+\t      gimple *stmt1;\n \n \t      if (TREE_CODE (arg1) != SSA_NAME)\n \t\tcontinue;\n@@ -626,7 +626,7 @@ pass_cse_reciprocals::execute (function *fun)\n \t\t  fail = false;\n \t\t  FOR_EACH_IMM_USE_FAST (use_p, ui, arg1)\n \t\t    {\n-\t\t      gimple stmt2 = USE_STMT (use_p);\n+\t\t      gimple *stmt2 = USE_STMT (use_p);\n \t\t      if (is_gimple_debug (stmt2))\n \t\t\tcontinue;\n \t\t      if (!is_gimple_assign (stmt2)\n@@ -684,8 +684,8 @@ make_pass_cse_reciprocals (gcc::context *ctxt)\n    statements in the vector.  */\n \n static bool\n-maybe_record_sincos (vec<gimple> *stmts,\n-\t\t     basic_block *top_bb, gimple use_stmt)\n+maybe_record_sincos (vec<gimple *> *stmts,\n+\t\t     basic_block *top_bb, gimple *use_stmt)\n {\n   basic_block use_bb = gimple_bb (use_stmt);\n   if (*top_bb\n@@ -718,9 +718,9 @@ execute_cse_sincos_1 (tree name)\n   gimple_stmt_iterator gsi;\n   imm_use_iterator use_iter;\n   tree fndecl, res, type;\n-  gimple def_stmt, use_stmt, stmt;\n+  gimple *def_stmt, *use_stmt, *stmt;\n   int seen_cos = 0, seen_sin = 0, seen_cexpi = 0;\n-  auto_vec<gimple> stmts;\n+  auto_vec<gimple *> stmts;\n   basic_block top_bb = NULL;\n   int i;\n   bool cfg_changed = false;\n@@ -1090,7 +1090,7 @@ build_and_insert_ref (gimple_stmt_iterator *gsi, location_t loc, tree type,\n \t\t      const char *name, enum tree_code code, tree arg0)\n {\n   tree result = make_temp_ssa_name (type, NULL, name);\n-  gimple stmt = gimple_build_assign (result, build1 (code, type, arg0));\n+  gimple *stmt = gimple_build_assign (result, build1 (code, type, arg0));\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n@@ -1730,7 +1730,7 @@ pass_cse_sincos::execute (function *fun)\n \n       for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree fndecl;\n \n \t  /* Only the last stmt in a bb could throw, no need to call\n@@ -1975,7 +1975,7 @@ do_shift_rotate (enum tree_code code,\n    statement STMT.  */\n \n static inline bool\n-verify_symbolic_number_p (struct symbolic_number *n, gimple stmt)\n+verify_symbolic_number_p (struct symbolic_number *n, gimple *stmt)\n {\n   tree lhs_type;\n \n@@ -2024,7 +2024,7 @@ init_symbolic_number (struct symbolic_number *n, tree src)\n    accessed and the offset of the access from that base are recorded in N.  */\n \n bool\n-find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n+find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n {\n   /* Leaf node is an array or component ref. Memorize its base and\n      offset from base to compare to other such leaf node.  */\n@@ -2095,14 +2095,14 @@ find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n    symbolic number N1 and N2 whose source statements are respectively\n    SOURCE_STMT1 and SOURCE_STMT2.  */\n \n-static gimple\n-perform_symbolic_merge (gimple source_stmt1, struct symbolic_number *n1,\n-\t\t\tgimple source_stmt2, struct symbolic_number *n2,\n+static gimple *\n+perform_symbolic_merge (gimple *source_stmt1, struct symbolic_number *n1,\n+\t\t\tgimple *source_stmt2, struct symbolic_number *n2,\n \t\t\tstruct symbolic_number *n)\n {\n   int i, size;\n   uint64_t mask;\n-  gimple source_stmt;\n+  gimple *source_stmt;\n   struct symbolic_number *n_start;\n \n   /* Sources are different, cancel bswap if they are not memory location with\n@@ -2214,12 +2214,12 @@ perform_symbolic_merge (gimple source_stmt1, struct symbolic_number *n1,\n    rhs's first tree is the expression of the source operand and NULL\n    otherwise.  */\n \n-static gimple\n-find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n+static gimple *\n+find_bswap_or_nop_1 (gimple *stmt, struct symbolic_number *n, int limit)\n {\n   enum tree_code code;\n   tree rhs1, rhs2 = NULL;\n-  gimple rhs1_stmt, rhs2_stmt, source_stmt1;\n+  gimple *rhs1_stmt, *rhs2_stmt, *source_stmt1;\n   enum gimple_rhs_class rhs_class;\n \n   if (!limit || !is_gimple_assign (stmt))\n@@ -2335,7 +2335,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n   if (rhs_class == GIMPLE_BINARY_RHS)\n     {\n       struct symbolic_number n1, n2;\n-      gimple source_stmt, source_stmt2;\n+      gimple *source_stmt, *source_stmt2;\n \n       if (code != BIT_IOR_EXPR)\n \treturn NULL;\n@@ -2391,16 +2391,16 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n    function returns a stmt whose rhs's first tree is the source\n    expression.  */\n \n-static gimple\n-find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n+static gimple *\n+find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n {\n /* The number which the find_bswap_or_nop_1 result should match in order\n    to have a full byte swap.  The number is shifted to the right\n    according to the size of the symbolic number before using it.  */\n   uint64_t cmpxchg = CMPXCHG;\n   uint64_t cmpnop = CMPNOP;\n \n-  gimple source_stmt;\n+  gimple *source_stmt;\n   int limit;\n \n   /* The last parameter determines the depth search limit.  It usually\n@@ -2499,12 +2499,13 @@ class pass_optimize_bswap : public gimple_opt_pass\n    changing of basic block.  */\n \n static bool\n-bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n-\t       tree load_type, struct symbolic_number *n, bool bswap)\n+bswap_replace (gimple *cur_stmt, gimple *src_stmt, tree fndecl,\n+\t       tree bswap_type, tree load_type, struct symbolic_number *n,\n+\t       bool bswap)\n {\n   gimple_stmt_iterator gsi;\n   tree src, tmp, tgt;\n-  gimple bswap_stmt;\n+  gimple *bswap_stmt;\n \n   gsi = gsi_for_stmt (cur_stmt);\n   src = gimple_assign_rhs1 (src_stmt);\n@@ -2516,7 +2517,7 @@ bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n       gimple_stmt_iterator gsi_ins = gsi_for_stmt (src_stmt);\n       tree addr_expr, addr_tmp, val_expr, val_tmp;\n       tree load_offset_ptr, aligned_load_type;\n-      gimple addr_stmt, load_stmt;\n+      gimple *addr_stmt, *load_stmt;\n       unsigned align;\n       HOST_WIDE_INT load_offset = 0;\n \n@@ -2637,7 +2638,7 @@ bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n   /* Convert the src expression if necessary.  */\n   if (!useless_type_conversion_p (TREE_TYPE (tmp), bswap_type))\n     {\n-      gimple convert_stmt;\n+      gimple *convert_stmt;\n \n       tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapsrc\");\n       convert_stmt = gimple_build_assign (tmp, NOP_EXPR, src);\n@@ -2662,7 +2663,7 @@ bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n   /* Convert the result if necessary.  */\n   if (!useless_type_conversion_p (TREE_TYPE (tgt), bswap_type))\n     {\n-      gimple convert_stmt;\n+      gimple *convert_stmt;\n \n       tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n       convert_stmt = gimple_build_assign (tgt, NOP_EXPR, tmp);\n@@ -2732,7 +2733,7 @@ pass_optimize_bswap::execute (function *fun)\n \t variant wouldn't be detected.  */\n       for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n         {\n-\t  gimple src_stmt, cur_stmt = gsi_stmt (gsi);\n+\t  gimple *src_stmt, *cur_stmt = gsi_stmt (gsi);\n \t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE, load_type;\n \t  enum tree_code code;\n \t  struct symbolic_number n;\n@@ -2834,7 +2835,7 @@ make_pass_optimize_bswap (gcc::context *ctxt)\n /* Return true if stmt is a type conversion operation that can be stripped\n    when used in a widening multiply operation.  */\n static bool\n-widening_mult_conversion_strippable_p (tree result_type, gimple stmt)\n+widening_mult_conversion_strippable_p (tree result_type, gimple *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n \n@@ -2886,7 +2887,7 @@ static bool\n is_widening_mult_rhs_p (tree type, tree rhs, tree *type_out,\n \t\t\ttree *new_rhs_out)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   tree type1, rhs1;\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n@@ -2939,7 +2940,7 @@ is_widening_mult_rhs_p (tree type, tree rhs, tree *type_out,\n    and *TYPE2_OUT would give the operands of the multiplication.  */\n \n static bool\n-is_widening_mult_p (gimple stmt,\n+is_widening_mult_p (gimple *stmt,\n \t\t    tree *type1_out, tree *rhs1_out,\n \t\t    tree *type2_out, tree *rhs2_out)\n {\n@@ -2986,7 +2987,7 @@ is_widening_mult_p (gimple stmt,\n    value is true iff we converted the statement.  */\n \n static bool\n-convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n+convert_mult_to_widen (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   tree lhs, rhs1, rhs2, type, type1, type2;\n   enum insn_code handler;\n@@ -3087,11 +3088,11 @@ convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n    is true iff we converted the statement.  */\n \n static bool\n-convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n+convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple *stmt,\n \t\t\t    enum tree_code code)\n {\n-  gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n-  gimple conv1_stmt = NULL, conv2_stmt = NULL, conv_stmt;\n+  gimple *rhs1_stmt = NULL, *rhs2_stmt = NULL;\n+  gimple *conv1_stmt = NULL, *conv2_stmt = NULL, *conv_stmt;\n   tree type, type1, type2, optype;\n   tree lhs, rhs1, rhs2, mult_rhs1, mult_rhs2, add_rhs;\n   enum tree_code rhs1_code = ERROR_MARK, rhs2_code = ERROR_MARK;\n@@ -3298,11 +3299,11 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n    operations.  Returns true if successful and MUL_STMT should be removed.  */\n \n static bool\n-convert_mult_to_fma (gimple mul_stmt, tree op1, tree op2)\n+convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2)\n {\n   tree mul_result = gimple_get_lhs (mul_stmt);\n   tree type = TREE_TYPE (mul_result);\n-  gimple use_stmt, neguse_stmt;\n+  gimple *use_stmt, *neguse_stmt;\n   gassign *fma_stmt;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n@@ -3417,7 +3418,7 @@ convert_mult_to_fma (gimple mul_stmt, tree op1, tree op2)\n \n \t  if (TREE_CODE (rhs2) == SSA_NAME)\n \t    {\n-\t      gimple stmt2 = SSA_NAME_DEF_STMT (rhs2);\n+\t      gimple *stmt2 = SSA_NAME_DEF_STMT (rhs2);\n \t      if (has_single_use (rhs2)\n \t\t  && is_gimple_assign (stmt2)\n \t\t  && gimple_assign_rhs_code (stmt2) == MULT_EXPR)\n@@ -3548,7 +3549,7 @@ pass_optimize_widening_mul::execute (function *fun)\n \n       for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n         {\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  enum tree_code code;\n \n \t  if (is_gimple_assign (stmt))"}, {"sha": "85f9cca296debb40b43a078958673d84e26f8d9b", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -120,7 +120,7 @@ static tree build_vuse;\n    compilations of multiple functions.  */\n static bitmap_obstack operands_bitmap_obstack;\n \n-static void get_expr_operands (struct function *, gimple, tree *, int);\n+static void get_expr_operands (struct function *, gimple *, tree *, int);\n \n /* Number of functions with initialized ssa_operands.  */\n static int n_initialized = 0;\n@@ -306,7 +306,7 @@ alloc_use (struct function *fn)\n /* Adds OP to the list of uses of statement STMT after LAST.  */\n \n static inline use_optype_p\n-add_use_op (struct function *fn, gimple stmt, tree *op, use_optype_p last)\n+add_use_op (struct function *fn, gimple *stmt, tree *op, use_optype_p last)\n {\n   use_optype_p new_use;\n \n@@ -324,7 +324,7 @@ add_use_op (struct function *fn, gimple stmt, tree *op, use_optype_p last)\n    TODO -- Make build_defs vec of tree *.  */\n \n static inline void\n-finalize_ssa_defs (struct function *fn, gimple stmt)\n+finalize_ssa_defs (struct function *fn, gimple *stmt)\n {\n   /* Pre-pend the vdef we may have built.  */\n   if (build_vdef != NULL_TREE)\n@@ -363,7 +363,7 @@ finalize_ssa_defs (struct function *fn, gimple stmt)\n    TODO -- Make build_uses vec of tree *.  */\n \n static inline void\n-finalize_ssa_uses (struct function *fn, gimple stmt)\n+finalize_ssa_uses (struct function *fn, gimple *stmt)\n {\n   unsigned new_i;\n   struct use_optype_d new_list;\n@@ -439,7 +439,7 @@ cleanup_build_arrays (void)\n /* Finalize all the build vectors, fill the new ones into INFO.  */\n \n static inline void\n-finalize_ssa_stmt_operands (struct function *fn, gimple stmt)\n+finalize_ssa_stmt_operands (struct function *fn, gimple *stmt)\n {\n   finalize_ssa_defs (fn, stmt);\n   finalize_ssa_uses (fn, stmt);\n@@ -497,7 +497,7 @@ append_vuse (tree var)\n \n static void\n add_virtual_operand (struct function *fn,\n-\t\t     gimple stmt ATTRIBUTE_UNUSED, int flags)\n+\t\t     gimple *stmt ATTRIBUTE_UNUSED, int flags)\n {\n   /* Add virtual operands to the stmt, unless the caller has specifically\n      requested not to do that (used when adding operands inside an\n@@ -520,7 +520,7 @@ add_virtual_operand (struct function *fn,\n    added to virtual operands.  */\n \n static void\n-add_stmt_operand (struct function *fn, tree *var_p, gimple stmt, int flags)\n+add_stmt_operand (struct function *fn, tree *var_p, gimple *stmt, int flags)\n {\n   tree var = *var_p;\n \n@@ -585,7 +585,7 @@ mark_address_taken (tree ref)\n \n static void\n get_mem_ref_operands (struct function *fn,\n-\t\t      gimple stmt, tree expr, int flags)\n+\t\t      gimple *stmt, tree expr, int flags)\n {\n   tree *pptr = &TREE_OPERAND (expr, 0);\n \n@@ -606,7 +606,7 @@ get_mem_ref_operands (struct function *fn,\n /* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n \n static void\n-get_tmr_operands (struct function *fn, gimple stmt, tree expr, int flags)\n+get_tmr_operands (struct function *fn, gimple *stmt, tree expr, int flags)\n {\n   if (!(flags & opf_no_vops)\n       && TREE_THIS_VOLATILE (expr))\n@@ -707,7 +707,7 @@ get_asm_stmt_operands (struct function *fn, gasm *stmt)\n    interpret the operands found.  */\n \n static void\n-get_expr_operands (struct function *fn, gimple stmt, tree *expr_p, int flags)\n+get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n {\n   enum tree_code code;\n   enum tree_code_class codeclass;\n@@ -895,7 +895,7 @@ get_expr_operands (struct function *fn, gimple stmt, tree *expr_p, int flags)\n    build_* operand vectors will have potential operands in them.  */\n \n static void\n-parse_ssa_operands (struct function *fn, gimple stmt)\n+parse_ssa_operands (struct function *fn, gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   size_t i, n, start = 0;\n@@ -945,7 +945,7 @@ parse_ssa_operands (struct function *fn, gimple stmt)\n /* Create an operands cache for STMT.  */\n \n static void\n-build_ssa_operands (struct function *fn, gimple stmt)\n+build_ssa_operands (struct function *fn, gimple *stmt)\n {\n   /* Initially assume that the statement has no volatile operands.  */\n   gimple_set_has_volatile_ops (stmt, false);\n@@ -958,7 +958,7 @@ build_ssa_operands (struct function *fn, gimple stmt)\n /* Verifies SSA statement operands.  */\n \n DEBUG_FUNCTION bool\n-verify_ssa_operands (struct function *fn, gimple stmt)\n+verify_ssa_operands (struct function *fn, gimple *stmt)\n {\n   use_operand_p use_p;\n   def_operand_p def_p;\n@@ -1047,7 +1047,7 @@ verify_ssa_operands (struct function *fn, gimple stmt)\n    the stmt operand lists.  */\n \n void\n-free_stmt_operands (struct function *fn, gimple stmt)\n+free_stmt_operands (struct function *fn, gimple *stmt)\n {\n   use_optype_p uses = gimple_use_ops (stmt), last_use;\n \n@@ -1072,7 +1072,7 @@ free_stmt_operands (struct function *fn, gimple stmt)\n /* Get the operands of statement STMT.  */\n \n void\n-update_stmt_operands (struct function *fn, gimple stmt)\n+update_stmt_operands (struct function *fn, gimple *stmt)\n {\n   /* If update_stmt_operands is called before SSA is initialized, do\n      nothing.  */\n@@ -1093,7 +1093,7 @@ update_stmt_operands (struct function *fn, gimple stmt)\n    to test the validity of the swap operation.  */\n \n void\n-swap_ssa_operands (gimple stmt, tree *exp0, tree *exp1)\n+swap_ssa_operands (gimple *stmt, tree *exp0, tree *exp1)\n {\n   tree op0, op1;\n   op0 = *exp0;\n@@ -1282,11 +1282,11 @@ debug_immediate_uses_for (tree var)\n /* Unlink STMTs virtual definition from the IL by propagating its use.  */\n \n void\n-unlink_stmt_vdef (gimple stmt)\n+unlink_stmt_vdef (gimple *stmt)\n {\n   use_operand_p use_p;\n   imm_use_iterator iter;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   tree vdef = gimple_vdef (stmt);\n   tree vuse = gimple_vuse (stmt);\n \n@@ -1309,7 +1309,7 @@ unlink_stmt_vdef (gimple stmt)\n    use, if so, or to NULL otherwise.  */\n bool\n single_imm_use_1 (const ssa_use_operand_t *head,\n-\t\t  use_operand_p *use_p, gimple *stmt)\n+\t\t  use_operand_p *use_p, gimple **stmt)\n {\n   ssa_use_operand_t *ptr, *single_use = 0;\n "}, {"sha": "0381c6afc8abb0ac44a3c52785b7a95fdb5d6882", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -92,18 +92,18 @@ struct GTY(()) ssa_operands {\n extern bool ssa_operands_active (struct function *);\n extern void init_ssa_operands (struct function *fn);\n extern void fini_ssa_operands (struct function *);\n-extern bool verify_ssa_operands (struct function *, gimple stmt);\n-extern void free_stmt_operands (struct function *, gimple);\n-extern void update_stmt_operands (struct function *, gimple);\n-extern void swap_ssa_operands (gimple, tree *, tree *);\n+extern bool verify_ssa_operands (struct function *, gimple *stmt);\n+extern void free_stmt_operands (struct function *, gimple *);\n+extern void update_stmt_operands (struct function *, gimple *);\n+extern void swap_ssa_operands (gimple *, tree *, tree *);\n extern bool verify_imm_links (FILE *f, tree var);\n \n extern void dump_immediate_uses_for (FILE *file, tree var);\n extern void dump_immediate_uses (FILE *file);\n extern void debug_immediate_uses (void);\n extern void debug_immediate_uses_for (tree var);\n \n-extern void unlink_stmt_vdef (gimple);\n+extern void unlink_stmt_vdef (gimple *);\n \n /* Return the tree pointed-to by USE.  */\n static inline tree"}, {"sha": "332e8aaf59ab1b43561b21cfb067e8da0d158d78", "filename": "gcc/tree-ssa-phionlycprop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-phionlycprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-phionlycprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phionlycprop.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n    remove it from the IL.  */\n \n static void\n-remove_stmt_or_phi (gimple stmt)\n+remove_stmt_or_phi (gimple *stmt)\n {\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n \n@@ -61,7 +61,7 @@ remove_stmt_or_phi (gimple stmt)\n    phi, NULL is returned.  */\n \n static tree\n-get_rhs_or_phi_arg (gimple stmt)\n+get_rhs_or_phi_arg (gimple *stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     return degenerate_phi_result (as_a <gphi *> (stmt));\n@@ -76,7 +76,7 @@ get_rhs_or_phi_arg (gimple stmt)\n    return the \"lhs\" of the node.  */\n \n static tree\n-get_lhs_or_phi_result (gimple stmt)\n+get_lhs_or_phi_result (gimple *stmt)\n {\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     return gimple_phi_result (stmt);\n@@ -101,7 +101,7 @@ get_lhs_or_phi_result (gimple stmt)\n    cleaned up after changing EH information on a statement.  */\n \n static bool\n-propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs,\n+propagate_rhs_into_lhs (gimple *stmt, tree lhs, tree rhs,\n \t\t\tbitmap interesting_names, bitmap need_eh_cleanup)\n {\n   bool cfg_altered = false;\n@@ -111,7 +111,7 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs,\n     {\n       use_operand_p use_p;\n       imm_use_iterator iter;\n-      gimple use_stmt;\n+      gimple *use_stmt;\n       bool all = true;\n \n       /* Dump details.  */\n@@ -345,7 +345,7 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs,\n    not set or queried here, but passed along to children.  */\n \n static bool\n-eliminate_const_or_copy (gimple stmt, bitmap interesting_names,\n+eliminate_const_or_copy (gimple *stmt, bitmap interesting_names,\n \t\t\t bitmap need_eh_cleanup)\n {\n   tree lhs = get_lhs_or_phi_result (stmt);\n@@ -379,7 +379,7 @@ eliminate_const_or_copy (gimple stmt, bitmap interesting_names,\n \t\t\t\t\t  interesting_names, need_eh_cleanup);\n   else\n     {\n-      gimple use_stmt;\n+      gimple *use_stmt;\n       imm_use_iterator iter;\n       use_operand_p use_p;\n       /* For virtual operands we have to propagate into all uses as"}, {"sha": "37fdf28d31b98c0368776b71a1173ff277ee5870", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -56,16 +56,16 @@ static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, gphi *, tree, tree);\n static bool factor_out_conditional_conversion (edge, edge, gphi *, tree, tree);\n static int value_replacement (basic_block, basic_block,\n-\t\t\t      edge, edge, gimple, tree, tree);\n+\t\t\t      edge, edge, gimple *, tree, tree);\n static bool minmax_replacement (basic_block, basic_block,\n-\t\t\t\tedge, edge, gimple, tree, tree);\n+\t\t\t\tedge, edge, gimple *, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n-\t\t\t     edge, edge, gimple, tree, tree);\n+\t\t\t     edge, edge, gimple *, tree, tree);\n static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n \t\t\t\t    hash_set<tree> *);\n static bool cond_if_else_store_replacement (basic_block, basic_block, basic_block);\n static hash_set<tree> * get_non_trapping ();\n-static void replace_phi_edge_with_variable (basic_block, edge, gimple, tree);\n+static void replace_phi_edge_with_variable (basic_block, edge, gimple *, tree);\n static void hoist_adjacent_loads (basic_block, basic_block,\n \t\t\t\t  basic_block, basic_block);\n static bool gate_hoist_loads (void);\n@@ -184,7 +184,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \n   for (i = 0; i < n; i++)\n     {\n-      gimple cond_stmt;\n+      gimple *cond_stmt;\n       gphi *phi;\n       basic_block bb1, bb2;\n       edge e1, e2;\n@@ -363,7 +363,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \n static void\n replace_phi_edge_with_variable (basic_block cond_block,\n-\t\t\t\tedge e, gimple phi, tree new_tree)\n+\t\t\t\tedge e, gimple *phi, tree new_tree)\n {\n   basic_block bb = gimple_bb (phi);\n   basic_block block_to_remove;\n@@ -413,7 +413,7 @@ static bool\n factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,\n \t\t\t\t   tree arg0, tree arg1)\n {\n-  gimple arg0_def_stmt = NULL, arg1_def_stmt = NULL, new_stmt;\n+  gimple *arg0_def_stmt = NULL, *arg1_def_stmt = NULL, *new_stmt;\n   tree new_arg0 = NULL_TREE, new_arg1 = NULL_TREE;\n   tree temp, result;\n   gphi *newphi;\n@@ -545,7 +545,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t\t tree arg0, tree arg1)\n {\n   tree result;\n-  gimple stmt;\n+  gimple *stmt;\n   gassign *new_stmt;\n   tree cond;\n   gimple_stmt_iterator gsi;\n@@ -656,7 +656,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n    statement is made dead by that rewriting.  */\n \n static bool\n-jump_function_from_stmt (tree *arg, gimple stmt)\n+jump_function_from_stmt (tree *arg, gimple *stmt)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   if (code == ADDR_EXPR)\n@@ -697,7 +697,7 @@ rhs_is_fed_for_value_replacement (const_tree arg0, const_tree arg1,\n      statement.  */\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n-      gimple def1 = SSA_NAME_DEF_STMT (rhs);\n+      gimple *def1 = SSA_NAME_DEF_STMT (rhs);\n \n       /* Verify the defining statement has an EQ_EXPR on the RHS.  */\n       if (is_gimple_assign (def1) && gimple_assign_rhs_code (def1) == EQ_EXPR)\n@@ -729,9 +729,9 @@ rhs_is_fed_for_value_replacement (const_tree arg0, const_tree arg1,\n \n static bool\n operand_equal_for_value_replacement (const_tree arg0, const_tree arg1,\n-\t\t\t\t     enum tree_code *code, gimple cond)\n+\t\t\t\t     enum tree_code *code, gimple *cond)\n {\n-  gimple def;\n+  gimple *def;\n   tree lhs = gimple_cond_lhs (cond);\n   tree rhs = gimple_cond_rhs (cond);\n \n@@ -834,11 +834,11 @@ absorbing_element_p (tree_code code, tree arg)\n \n static int\n value_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t   edge e0, edge e1, gimple phi,\n+\t\t   edge e0, edge e1, gimple *phi,\n \t\t   tree arg0, tree arg1)\n {\n   gimple_stmt_iterator gsi;\n-  gimple cond;\n+  gimple *cond;\n   edge true_edge, false_edge;\n   enum tree_code code;\n   bool emtpy_or_with_defined_p = true;\n@@ -853,7 +853,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   gsi = gsi_start_nondebug_after_labels_bb (middle_bb);\n   while (!gsi_end_p (gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       tree lhs;\n       gsi_next_nondebug (&gsi);\n       if (!is_gimple_assign (stmt))\n@@ -950,7 +950,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   /* Now optimize (x != 0) ? x + y : y to just y.\n      The following condition is too restrictive, there can easily be another\n      stmt in middle_bb, for instance a CONVERT_EXPR for the second argument.  */\n-  gimple assign = last_and_only_stmt (middle_bb);\n+  gimple *assign = last_and_only_stmt (middle_bb);\n   if (!assign || gimple_code (assign) != GIMPLE_ASSIGN\n       || gimple_assign_rhs_class (assign) != GIMPLE_BINARY_RHS\n       || (!INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n@@ -1039,7 +1039,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \n static bool\n minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t    edge e0, edge e1, gimple phi,\n+\t\t    edge e0, edge e1, gimple *phi,\n \t\t    tree arg0, tree arg1)\n {\n   tree result, type;\n@@ -1130,7 +1130,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t b = MAX (a, d);\n \t x = MIN (b, u);  */\n \n-      gimple assign = last_and_only_stmt (middle_bb);\n+      gimple *assign = last_and_only_stmt (middle_bb);\n       tree lhs, op0, op1, bound;\n \n       if (!assign\n@@ -1296,14 +1296,14 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n static bool\n abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t edge e0 ATTRIBUTE_UNUSED, edge e1,\n-\t\t gimple phi, tree arg0, tree arg1)\n+\t\t gimple *phi, tree arg0, tree arg1)\n {\n   tree result;\n   gassign *new_stmt;\n-  gimple cond;\n+  gimple *cond;\n   gimple_stmt_iterator gsi;\n   edge true_edge, false_edge;\n-  gimple assign;\n+  gimple *assign;\n   edge e;\n   tree rhs, lhs;\n   bool negate;\n@@ -1516,7 +1516,7 @@ nontrapping_dom_walker::before_dom_children (basic_block bb)\n   /* And walk the statements in order.  */\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n \n       if (is_gimple_call (stmt) && !nonfreeing_call_p (stmt))\n \tnt_call_phase++;\n@@ -1640,7 +1640,7 @@ static bool\n cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n \t\t\tedge e0, edge e1, hash_set<tree> *nontrap)\n {\n-  gimple assign = last_and_only_stmt (middle_bb);\n+  gimple *assign = last_and_only_stmt (middle_bb);\n   tree lhs, rhs, name, name2;\n   gphi *newphi;\n   gassign *new_stmt;\n@@ -1710,8 +1710,8 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n \n static bool\n cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n-\t\t\t\t  basic_block join_bb, gimple then_assign,\n-\t\t\t\t  gimple else_assign)\n+\t\t\t\t  basic_block join_bb, gimple *then_assign,\n+\t\t\t\t  gimple *else_assign)\n {\n   tree lhs_base, lhs, then_rhs, else_rhs, name;\n   source_location then_locus, else_locus;\n@@ -1805,11 +1805,11 @@ static bool\n cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n                                 basic_block join_bb)\n {\n-  gimple then_assign = last_and_only_stmt (then_bb);\n-  gimple else_assign = last_and_only_stmt (else_bb);\n+  gimple *then_assign = last_and_only_stmt (then_bb);\n+  gimple *else_assign = last_and_only_stmt (else_bb);\n   vec<data_reference_p> then_datarefs, else_datarefs;\n   vec<ddr_p> then_ddrs, else_ddrs;\n-  gimple then_store, else_store;\n+  gimple *then_store, *else_store;\n   bool found, ok = false, res;\n   struct data_dependence_relation *ddr;\n   data_reference_p then_dr, else_dr;\n@@ -1841,7 +1841,7 @@ cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n     }\n \n   /* Find pairs of stores with equal LHS.  */\n-  auto_vec<gimple, 1> then_stores, else_stores;\n+  auto_vec<gimple *, 1> then_stores, else_stores;\n   FOR_EACH_VEC_ELT (then_datarefs, i, then_dr)\n     {\n       if (DR_IS_READ (then_dr))\n@@ -1969,10 +1969,10 @@ cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n /* Return TRUE if STMT has a VUSE whose corresponding VDEF is in BB.  */\n \n static bool\n-local_mem_dependence (gimple stmt, basic_block bb)\n+local_mem_dependence (gimple *stmt, basic_block bb)\n {\n   tree vuse = gimple_vuse (stmt);\n-  gimple def;\n+  gimple *def;\n \n   if (!vuse)\n     return false;\n@@ -2019,7 +2019,7 @@ hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n   for (gsi = gsi_start_phis (bb3); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi_stmt = gsi.phi ();\n-      gimple def1, def2;\n+      gimple *def1, *def2;\n       tree arg1, arg2, ref1, ref2, field1, field2;\n       tree tree_offset1, tree_offset2, tree_size2, next;\n       int offset1, offset2, size2;"}, {"sha": "9a818c7c81d5a02953bd4e580ebca0272dbb9438", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -108,7 +108,7 @@ static bool\n phivn_valid_p (struct phiprop_d *phivn, tree name, basic_block bb)\n {\n   tree vuse = phivn[SSA_NAME_VERSION (name)].vuse;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   imm_use_iterator ui2;\n   bool ok = true;\n \n@@ -134,7 +134,7 @@ phivn_valid_p (struct phiprop_d *phivn, tree name, basic_block bb)\n    BB with the virtual operands from USE_STMT.  */\n \n static tree\n-phiprop_insert_phi (basic_block bb, gphi *phi, gimple use_stmt,\n+phiprop_insert_phi (basic_block bb, gphi *phi, gimple *use_stmt,\n \t\t    struct phiprop_d *phivn, size_t n)\n {\n   tree res;\n@@ -170,7 +170,7 @@ phiprop_insert_phi (basic_block bb, gphi *phi, gimple use_stmt,\n \t     && (SSA_NAME_VERSION (old_arg) >= n\n \t         || phivn[SSA_NAME_VERSION (old_arg)].value == NULL_TREE))\n \t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (old_arg);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (old_arg);\n \t  old_arg = gimple_assign_rhs1 (def_stmt);\n \t  locus = gimple_location (def_stmt);\n \t}\n@@ -246,7 +246,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,\n \t\t    size_t n)\n {\n   tree ptr = PHI_RESULT (phi);\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   tree res = NULL_TREE;\n   gimple_stmt_iterator gsi;\n   imm_use_iterator ui;\n@@ -271,7 +271,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,\n \t     && (SSA_NAME_VERSION (arg) >= n\n \t         || phivn[SSA_NAME_VERSION (arg)].value == NULL_TREE))\n \t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n \t  if (!gimple_assign_single_p (def_stmt))\n \t    return false;\n \t  arg = gimple_assign_rhs1 (def_stmt);\n@@ -301,7 +301,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,\n   phi_inserted = false;\n   FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)\n     {\n-      gimple def_stmt;\n+      gimple *def_stmt;\n       tree vuse;\n \n       /* Only replace loads in blocks that post-dominate the PHI node.  That"}, {"sha": "56bc7bf1492ff3a4a77b0df3fb52b1a23a262834", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -1268,7 +1268,7 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n \t\t\t      basic_block phiblock,\n \t\t\t      basic_block block, bool *same_valid)\n {\n-  gimple phi = SSA_NAME_DEF_STMT (vuse);\n+  gimple *phi = SSA_NAME_DEF_STMT (vuse);\n   ao_ref ref;\n   edge e = NULL;\n   bool use_oracle;\n@@ -1702,7 +1702,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n     case NAME:\n       {\n \ttree name = PRE_EXPR_NAME (expr);\n-\tgimple def_stmt = SSA_NAME_DEF_STMT (name);\n+\tgimple *def_stmt = SSA_NAME_DEF_STMT (name);\n \t/* If the SSA name is defined by a PHI node in this block,\n \t   translate it.  */\n \tif (gimple_code (def_stmt) == GIMPLE_PHI\n@@ -1867,7 +1867,7 @@ value_dies_in_block_x (pre_expr expr, basic_block block)\n {\n   tree vuse = PRE_EXPR_REFERENCE (expr)->vuse;\n   vn_reference_t refx = PRE_EXPR_REFERENCE (expr);\n-  gimple def;\n+  gimple *def;\n   gimple_stmt_iterator gsi;\n   unsigned id = get_expression_id (expr);\n   bool res = false;\n@@ -2053,7 +2053,7 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n \t  vn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n \t  if (ref->vuse)\n \t    {\n-\t      gimple def_stmt = SSA_NAME_DEF_STMT (ref->vuse);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (ref->vuse);\n \t      if (!gimple_nop_p (def_stmt)\n \t\t  && ((gimple_bb (def_stmt) != block\n \t\t       && !dominated_by_p (CDI_DOMINATORS,\n@@ -2884,7 +2884,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n       gsi = gsi_start (forced_stmts);\n       for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \t  tree forcedname = gimple_get_lhs (stmt);\n \t  pre_expr nameexpr;\n \n@@ -3040,7 +3040,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t  gsi = gsi_start (stmts);\n \t\t\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t\t    {\n-\t\t\t      gimple stmt = gsi_stmt (gsi);\n+\t\t\t      gimple *stmt = gsi_stmt (gsi);\n \t\t\t      tree lhs = gimple_get_lhs (stmt);\n \t\t\t      if (TREE_CODE (lhs) == SSA_NAME)\n \t\t\t\tbitmap_set_bit (inserted_exprs,\n@@ -3086,7 +3086,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t  gsi = gsi_start (stmts);\n \t\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t    {\n-\t\t      gimple stmt = gsi_stmt (gsi);\n+\t\t      gimple *stmt = gsi_stmt (gsi);\n \t\t      tree lhs = gimple_get_lhs (stmt);\n \t\t      if (TREE_CODE (lhs) == SSA_NAME)\n \t\t\tbitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n@@ -3646,7 +3646,7 @@ compute_avail (void)\n   /* Loop until the worklist is empty.  */\n   while (sp)\n     {\n-      gimple stmt;\n+      gimple *stmt;\n       basic_block dom;\n \n       /* Pick a block from the worklist.  */\n@@ -3823,7 +3823,7 @@ compute_avail (void)\n \t\t\t to EXP_GEN.  */\n \t\t      if (gimple_vuse (stmt))\n \t\t\t{\n-\t\t\t  gimple def_stmt;\n+\t\t\t  gimple *def_stmt;\n \t\t\t  bool ok = true;\n \t\t\t  def_stmt = SSA_NAME_DEF_STMT (gimple_vuse (stmt));\n \t\t\t  while (!gimple_nop_p (def_stmt)\n@@ -3889,8 +3889,8 @@ compute_avail (void)\n \n \n /* Local state for the eliminate domwalk.  */\n-static vec<gimple> el_to_remove;\n-static vec<gimple> el_to_fixup;\n+static vec<gimple *> el_to_remove;\n+static vec<gimple *> el_to_fixup;\n static unsigned int el_todo;\n static vec<tree> el_avail;\n static vec<tree> el_avail_stack;\n@@ -4042,7 +4042,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \n \t  if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n \t    sprime = fold_convert (TREE_TYPE (res), sprime);\n-\t  gimple stmt = gimple_build_assign (res, sprime);\n+\t  gimple *stmt = gimple_build_assign (res, sprime);\n \t  /* ???  It cannot yet be necessary (DOM walk).  */\n \t  gimple_set_plf (stmt, NECESSARY, gimple_plf (phi, NECESSARY));\n \n@@ -4060,7 +4060,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n        gsi_next (&gsi))\n     {\n       tree sprime = NULL_TREE;\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       tree lhs = gimple_get_lhs (stmt);\n       if (lhs && TREE_CODE (lhs) == SSA_NAME\n \t  && !gimple_has_volatile_ops (stmt)\n@@ -4132,7 +4132,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))\n \t      && gimple_assign_load_p (stmt))\n \t    {\n-\t      gimple def_stmt = SSA_NAME_DEF_STMT (sprime);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (sprime);\n \t      basic_block def_bb = gimple_bb (def_stmt);\n \t      if (gimple_code (def_stmt) == GIMPLE_PHI\n \t\t  && b->loop_father->header == def_bb)\n@@ -4227,7 +4227,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t\t\tNECESSARY, true);\n \n \t      pre_stats.eliminations++;\n-\t      gimple orig_stmt = stmt;\n+\t      gimple *orig_stmt = stmt;\n \t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t      TREE_TYPE (sprime)))\n \t\tsprime = fold_convert (TREE_TYPE (lhs), sprime);\n@@ -4412,7 +4412,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t  if (gimple_assign_single_p (stmt)\n \t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)\n \t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n-\t  gimple old_stmt = stmt;\n+\t  gimple *old_stmt = stmt;\n \t  if (is_gimple_call (stmt))\n \t    {\n \t      /* ???  Only fold calls inplace for now, this may create new\n@@ -4516,7 +4516,7 @@ static unsigned int\n eliminate (bool do_pre)\n {\n   gimple_stmt_iterator gsi;\n-  gimple stmt;\n+  gimple *stmt;\n \n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_ab_cleanup = BITMAP_ALLOC (NULL);\n@@ -4626,10 +4626,10 @@ fini_eliminate (void)\n    mark that statement necessary. Return the stmt, if it is newly\n    necessary.  */\n \n-static inline gimple\n+static inline gimple *\n mark_operand_necessary (tree op)\n {\n-  gimple stmt;\n+  gimple *stmt;\n \n   gcc_assert (op);\n \n@@ -4658,7 +4658,7 @@ remove_dead_inserted_code (void)\n   bitmap worklist;\n   unsigned i;\n   bitmap_iterator bi;\n-  gimple t;\n+  gimple *t;\n \n   worklist = BITMAP_ALLOC (NULL);\n   EXECUTE_IF_SET_IN_BITMAP (inserted_exprs, 0, i, bi)\n@@ -4685,7 +4685,7 @@ remove_dead_inserted_code (void)\n \t      tree arg = PHI_ARG_DEF (t, k);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n \t\t{\n-\t\t  gimple n = mark_operand_necessary (arg);\n+\t\t  gimple *n = mark_operand_necessary (arg);\n \t\t  if (n)\n \t\t    bitmap_set_bit (worklist, SSA_NAME_VERSION (arg));\n \t\t}\n@@ -4706,7 +4706,7 @@ remove_dead_inserted_code (void)\n \n \t  FOR_EACH_SSA_TREE_OPERAND (use, t, iter, SSA_OP_ALL_USES)\n \t    {\n-\t      gimple n = mark_operand_necessary (use);\n+\t      gimple *n = mark_operand_necessary (use);\n \t      if (n)\n \t\tbitmap_set_bit (worklist, SSA_NAME_VERSION (use));\n \t    }"}, {"sha": "fbe41f9a03c173b9e9b90b1f0a01bb9b2d0968d6", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -149,7 +149,7 @@ static sbitmap bb_in_list;\n    definition has changed.  SSA edges are def-use edges in the SSA\n    web.  For each D-U edge, we store the target statement or PHI node\n    U.  */\n-static vec<gimple> interesting_ssa_edges;\n+static vec<gimple *> interesting_ssa_edges;\n \n /* Identical to INTERESTING_SSA_EDGES.  For performance reasons, the\n    list of SSA edges is split into two.  One contains all SSA edges\n@@ -165,7 +165,7 @@ static vec<gimple> interesting_ssa_edges;\n    don't use a separate worklist for VARYING edges, we end up with\n    situations where lattice values move from\n    UNDEFINED->INTERESTING->VARYING instead of UNDEFINED->VARYING.  */\n-static vec<gimple> varying_ssa_edges;\n+static vec<gimple *> varying_ssa_edges;\n \n \n /* Return true if the block worklist empty.  */\n@@ -260,7 +260,7 @@ add_ssa_edge (tree var, bool is_varying)\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n     {\n-      gimple use_stmt = USE_STMT (use_p);\n+      gimple *use_stmt = USE_STMT (use_p);\n \n       if (prop_simulate_again_p (use_stmt)\n \t  && !gimple_plf (use_stmt, STMT_IN_SSA_EDGE_WORKLIST))\n@@ -319,7 +319,7 @@ add_control_edge (edge e)\n /* Simulate the execution of STMT and update the work lists accordingly.  */\n \n static void\n-simulate_stmt (gimple stmt)\n+simulate_stmt (gimple *stmt)\n {\n   enum ssa_prop_result val = SSA_PROP_NOT_INTERESTING;\n   edge taken_edge = NULL;\n@@ -396,7 +396,7 @@ simulate_stmt (gimple stmt)\n   else\n     FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n       {\n-\tgimple def_stmt = SSA_NAME_DEF_STMT (USE_FROM_PTR (use_p));\n+\tgimple *def_stmt = SSA_NAME_DEF_STMT (USE_FROM_PTR (use_p));\n \tif (!gimple_nop_p (def_stmt)\n \t    && prop_simulate_again_p (def_stmt))\n \t  {\n@@ -420,15 +420,15 @@ simulate_stmt (gimple stmt)\n    was simulated.  */\n \n static bool \n-process_ssa_edge_worklist (vec<gimple> *worklist, const char *edge_list_name)\n+process_ssa_edge_worklist (vec<gimple *> *worklist, const char *edge_list_name)\n {\n   /* Process the next entry from the worklist.  */\n   while (worklist->length () > 0)\n     {\n       basic_block bb;\n \n       /* Pull the statement to simulate off the worklist.  */\n-      gimple stmt = worklist->pop ();\n+      gimple *stmt = worklist->pop ();\n \n       /* If this statement was already visited by simulate_block, then\n \t we don't need to visit it again here.  */\n@@ -504,7 +504,7 @@ simulate_block (basic_block block)\n \n       for (j = gsi_start_bb (block); !gsi_end_p (j); gsi_next (&j))\n \t{\n-\t  gimple stmt = gsi_stmt (j);\n+\t  gimple *stmt = gsi_stmt (j);\n \n \t  /* If this statement is already in the worklist then\n \t     \"cancel\" it.  The reevaluation implied by the worklist\n@@ -760,7 +760,7 @@ valid_gimple_call_p (tree expr)\n    as their defining statement.  */\n \n void\n-move_ssa_defining_stmt_for_defs (gimple new_stmt, gimple old_stmt)\n+move_ssa_defining_stmt_for_defs (gimple *new_stmt, gimple *old_stmt)\n {\n   tree var;\n   ssa_op_iter iter;\n@@ -781,8 +781,8 @@ move_ssa_defining_stmt_for_defs (gimple new_stmt, gimple old_stmt)\n    A GIMPLE_CALL STMT is being replaced with GIMPLE_CALL NEW_STMT.  */\n \n static void\n-finish_update_gimple_call (gimple_stmt_iterator *si_p, gimple new_stmt,\n-\t\t\t   gimple stmt)\n+finish_update_gimple_call (gimple_stmt_iterator *si_p, gimple *new_stmt,\n+\t\t\t   gimple *stmt)\n {\n   gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n   move_ssa_defining_stmt_for_defs (new_stmt, stmt);\n@@ -827,7 +827,7 @@ update_gimple_call (gimple_stmt_iterator *si_p, tree fn, int nargs, ...)\n bool\n update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n {\n-  gimple stmt = gsi_stmt (*si_p);\n+  gimple *stmt = gsi_stmt (*si_p);\n \n   if (valid_gimple_call_p (expr))\n     {\n@@ -856,7 +856,7 @@ update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n   else if (valid_gimple_rhs_p (expr))\n     {\n       tree lhs = gimple_call_lhs (stmt);\n-      gimple new_stmt;\n+      gimple *new_stmt;\n \n       /* The call has simplified to an expression\n          that cannot be represented as a GIMPLE_CALL. */\n@@ -955,7 +955,7 @@ ssa_propagate (ssa_prop_visit_stmt_fn visit_stmt,\n    because they are not interesting for the optimizers.  */\n \n bool\n-stmt_makes_single_store (gimple stmt)\n+stmt_makes_single_store (gimple *stmt)\n {\n   tree lhs;\n \n@@ -993,7 +993,7 @@ static struct prop_stats_d prop_stats;\n    PROP_VALUE. Return true if at least one reference was replaced.  */\n \n static bool\n-replace_uses_in (gimple stmt, ssa_prop_get_value_fn get_value)\n+replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value)\n {\n   bool replaced = false;\n   use_operand_p use;\n@@ -1138,8 +1138,8 @@ class substitute_and_fold_dom_walker : public dom_walker\n     ssa_prop_fold_stmt_fn fold_fn;\n     bool do_dce;\n     bool something_changed;\n-    vec<gimple> stmts_to_remove;\n-    vec<gimple> stmts_to_fixup;\n+    vec<gimple *> stmts_to_remove;\n+    vec<gimple *> stmts_to_fixup;\n     bitmap need_eh_cleanup;\n };\n \n@@ -1177,7 +1177,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n        gsi_next (&i))\n     {\n       bool did_replace;\n-      gimple stmt = gsi_stmt (i);\n+      gimple *stmt = gsi_stmt (i);\n       enum gimple_code code = gimple_code (stmt);\n \n       /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n@@ -1215,7 +1215,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t}\n \n-      gimple old_stmt = stmt;\n+      gimple *old_stmt = stmt;\n       bool was_noreturn = (is_gimple_call (stmt)\n \t\t\t   && gimple_call_noreturn_p (stmt));\n \n@@ -1343,7 +1343,7 @@ substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n      Remove stmts in reverse order to make debug stmt creation possible.  */\n   while (!walker.stmts_to_remove.is_empty ())\n     {\n-      gimple stmt = walker.stmts_to_remove.pop ();\n+      gimple *stmt = walker.stmts_to_remove.pop ();\n       if (dump_file && dump_flags & TDF_DETAILS)\n \t{\n \t  fprintf (dump_file, \"Removing dead stmt \");\n@@ -1371,7 +1371,7 @@ substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n      fixup by visiting a dominating now noreturn call first.  */\n   while (!walker.stmts_to_fixup.is_empty ())\n     {\n-      gimple stmt = walker.stmts_to_fixup.pop ();\n+      gimple *stmt = walker.stmts_to_fixup.pop ();\n       if (dump_file && dump_flags & TDF_DETAILS)\n \t{\n \t  fprintf (dump_file, \"Fixing up noreturn call \");\n@@ -1441,7 +1441,7 @@ may_propagate_copy (tree dest, tree orig)\n    gimple tuples representation.  */\n \n bool\n-may_propagate_copy_into_stmt (gimple dest, tree orig)\n+may_propagate_copy_into_stmt (gimple *dest, tree orig)\n {\n   tree type_d;\n   tree type_o;\n@@ -1572,7 +1572,7 @@ propagate_tree_value (tree *op_p, tree val)\n void\n propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (is_gimple_assign (stmt))\n     {"}, {"sha": "c57b1284325185c2890775d715637245e168cce1", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -25,15 +25,15 @@ along with GCC; see the file COPYING3.  If not see\n /* If SIM_P is true, statement S will be simulated again.  */\n \n static inline void\n-prop_set_simulate_again (gimple s, bool visit_p)\n+prop_set_simulate_again (gimple *s, bool visit_p)\n {\n   gimple_set_visited (s, visit_p);\n }\n \n /* Return true if statement T should be simulated again.  */\n \n static inline bool\n-prop_simulate_again_p (gimple s)\n+prop_simulate_again_p (gimple *s)\n {\n   return gimple_visited_p (s);\n }\n@@ -62,22 +62,23 @@ enum ssa_prop_result {\n \n \n /* Call-back functions used by the value propagation engine.  */\n-typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (gimple, edge *, tree *);\n+typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (gimple *, edge *,\n+\t\t\t\t\t\t\ttree *);\n typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (gphi *);\n typedef bool (*ssa_prop_fold_stmt_fn) (gimple_stmt_iterator *gsi);\n typedef tree (*ssa_prop_get_value_fn) (tree);\n \n \n extern bool valid_gimple_rhs_p (tree);\n-extern void move_ssa_defining_stmt_for_defs (gimple, gimple);\n+extern void move_ssa_defining_stmt_for_defs (gimple *, gimple *);\n extern bool update_gimple_call (gimple_stmt_iterator *, tree, int, ...);\n extern bool update_call_from_tree (gimple_stmt_iterator *, tree);\n extern void ssa_propagate (ssa_prop_visit_stmt_fn, ssa_prop_visit_phi_fn);\n-extern bool stmt_makes_single_store (gimple);\n+extern bool stmt_makes_single_store (gimple *);\n extern bool substitute_and_fold (ssa_prop_get_value_fn, ssa_prop_fold_stmt_fn,\n \t\t\t\t bool);\n extern bool may_propagate_copy (tree, tree);\n-extern bool may_propagate_copy_into_stmt (gimple, tree);\n+extern bool may_propagate_copy_into_stmt (gimple *, tree);\n extern bool may_propagate_copy_into_asm (tree);\n extern void propagate_value (use_operand_p, tree);\n extern void replace_exp (use_operand_p, tree);"}, {"sha": "34f3d649b9aed1b06c2e433a31f589c68d264905", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 91, "deletions": 90, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -223,15 +223,15 @@ static vec<tree> reassoc_branch_fixups;\n \n /* Forward decls.  */\n static long get_rank (tree);\n-static bool reassoc_stmt_dominates_stmt_p (gimple, gimple);\n+static bool reassoc_stmt_dominates_stmt_p (gimple *, gimple *);\n \n /* Wrapper around gsi_remove, which adjusts gimple_uid of debug stmts\n    possibly added by gsi_remove.  */\n \n bool\n reassoc_remove_stmt (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (!MAY_HAVE_DEBUG_STMTS || gimple_code (stmt) == GIMPLE_PHI)\n     return gsi_remove (gsi, true);\n@@ -245,7 +245,7 @@ reassoc_remove_stmt (gimple_stmt_iterator *gsi)\n     gsi_next (&prev);\n   else\n     prev = gsi_start_bb (bb);\n-  gimple end_stmt = gsi_stmt (*gsi);\n+  gimple *end_stmt = gsi_stmt (*gsi);\n   while ((stmt = gsi_stmt (prev)) != end_stmt)\n     {\n       gcc_assert (stmt && is_gimple_debug (stmt) && gimple_uid (stmt) == 0);\n@@ -268,14 +268,14 @@ reassoc_remove_stmt (gimple_stmt_iterator *gsi)\n    iteration of the loop.  If STMT is some other phi, the rank is the\n    block rank of its containing block.  */\n static long\n-phi_rank (gimple stmt)\n+phi_rank (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   struct loop *father = bb->loop_father;\n   tree res;\n   unsigned i;\n   use_operand_p use;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n \n   /* We only care about real loops (those with a latch).  */\n   if (!father->latch)\n@@ -304,7 +304,7 @@ phi_rank (gimple stmt)\n       if (TREE_CODE (arg) == SSA_NAME\n \t  && !SSA_NAME_IS_DEFAULT_DEF (arg))\n \t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n \t  if (gimple_bb (def_stmt)->loop_father == father)\n \t    return bb_rank[father->latch->index] + PHI_LOOP_BIAS;\n \t}\n@@ -320,7 +320,7 @@ phi_rank (gimple stmt)\n static bool\n loop_carried_phi (tree exp)\n {\n-  gimple phi_stmt;\n+  gimple *phi_stmt;\n   long block_rank;\n \n   if (TREE_CODE (exp) != SSA_NAME\n@@ -423,7 +423,7 @@ get_rank (tree e)\n   if (TREE_CODE (e) == SSA_NAME)\n     {\n       ssa_op_iter iter;\n-      gimple stmt;\n+      gimple *stmt;\n       long rank;\n       tree op;\n \n@@ -523,8 +523,8 @@ sort_by_operand_rank (const void *pa, const void *pb)\n \t  && !SSA_NAME_IS_DEFAULT_DEF (oeb->op)\n \t  && SSA_NAME_VERSION (oeb->op) != SSA_NAME_VERSION (oea->op))\n \t{\n-\t  gimple stmta = SSA_NAME_DEF_STMT (oea->op);\n-\t  gimple stmtb = SSA_NAME_DEF_STMT (oeb->op);\n+\t  gimple *stmta = SSA_NAME_DEF_STMT (oea->op);\n+\t  gimple *stmtb = SSA_NAME_DEF_STMT (oeb->op);\n \t  basic_block bba = gimple_bb (stmta);\n \t  basic_block bbb = gimple_bb (stmtb);\n \t  if (bbb != bba)\n@@ -589,7 +589,7 @@ add_repeat_to_ops_vec (vec<operand_entry_t> *ops, tree op,\n    operation with tree code CODE, and is inside LOOP.  */\n \n static bool\n-is_reassociable_op (gimple stmt, enum tree_code code, struct loop *loop)\n+is_reassociable_op (gimple *stmt, enum tree_code code, struct loop *loop)\n {\n   basic_block bb = gimple_bb (stmt);\n \n@@ -614,7 +614,7 @@ is_reassociable_op (gimple stmt, enum tree_code code, struct loop *loop)\n static tree\n get_unary_op (tree name, enum tree_code opcode)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (name);\n+  gimple *stmt = SSA_NAME_DEF_STMT (name);\n \n   if (!is_gimple_assign (stmt))\n     return NULL_TREE;\n@@ -978,7 +978,7 @@ eliminate_using_constants (enum tree_code opcode,\n }\n \n \n-static void linearize_expr_tree (vec<operand_entry_t> *, gimple,\n+static void linearize_expr_tree (vec<operand_entry_t> *, gimple *,\n \t\t\t\t bool, bool);\n \n /* Structure for tracking and counting operands.  */\n@@ -1040,7 +1040,7 @@ oecount_cmp (const void *p1, const void *p2)\n    to some exponent.  */\n \n static bool\n-stmt_is_power_of_op (gimple stmt, tree op)\n+stmt_is_power_of_op (gimple *stmt, tree op)\n {\n   tree fndecl;\n \n@@ -1069,7 +1069,7 @@ stmt_is_power_of_op (gimple stmt, tree op)\n    was previously called for STMT and returned TRUE.  */\n \n static HOST_WIDE_INT\n-decrement_power (gimple stmt)\n+decrement_power (gimple *stmt)\n {\n   REAL_VALUE_TYPE c, cint;\n   HOST_WIDE_INT power;\n@@ -1101,10 +1101,10 @@ decrement_power (gimple stmt)\n    replace *DEF with OP as well.  */\n \n static void\n-propagate_op_to_single_use (tree op, gimple stmt, tree *def)\n+propagate_op_to_single_use (tree op, gimple *stmt, tree *def)\n {\n   tree lhs;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n   use_operand_p use;\n   gimple_stmt_iterator gsi;\n \n@@ -1133,7 +1133,7 @@ propagate_op_to_single_use (tree op, gimple stmt, tree *def)\n static void\n zero_one_operation (tree *def, enum tree_code opcode, tree op)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (*def);\n+  gimple *stmt = SSA_NAME_DEF_STMT (*def);\n \n   do\n     {\n@@ -1169,7 +1169,7 @@ zero_one_operation (tree *def, enum tree_code opcode, tree op)\n \t  && TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n \t  && has_single_use (gimple_assign_rhs2 (stmt)))\n \t{\n-\t  gimple stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n+\t  gimple *stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n \t  if (stmt_is_power_of_op (stmt2, op))\n \t    {\n \t      if (decrement_power (stmt2) == 1)\n@@ -1190,7 +1190,7 @@ zero_one_operation (tree *def, enum tree_code opcode, tree op)\n    stmt_dominates_stmt_p, but uses stmt UIDs to optimize.  */\n \n static bool\n-reassoc_stmt_dominates_stmt_p (gimple s1, gimple s2)\n+reassoc_stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n {\n   basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);\n \n@@ -1227,7 +1227,7 @@ reassoc_stmt_dominates_stmt_p (gimple s1, gimple s2)\n       unsigned int uid = gimple_uid (s1);\n       for (gsi_next (&gsi); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  gimple s = gsi_stmt (gsi);\n+\t  gimple *s = gsi_stmt (gsi);\n \t  if (gimple_uid (s) != uid)\n \t    break;\n \t  if (s == s2)\n@@ -1243,7 +1243,7 @@ reassoc_stmt_dominates_stmt_p (gimple s1, gimple s2)\n /* Insert STMT after INSERT_POINT.  */\n \n static void\n-insert_stmt_after (gimple stmt, gimple insert_point)\n+insert_stmt_after (gimple *stmt, gimple *insert_point)\n {\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n@@ -1280,10 +1280,10 @@ insert_stmt_after (gimple stmt, gimple insert_point)\n    the result.  Places the statement after the definition of either\n    OP1 or OP2.  Returns the new statement.  */\n \n-static gimple\n+static gimple *\n build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n {\n-  gimple op1def = NULL, op2def = NULL;\n+  gimple *op1def = NULL, *op2def = NULL;\n   gimple_stmt_iterator gsi;\n   tree op;\n   gassign *sum;\n@@ -1314,7 +1314,7 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n     }\n   else\n     {\n-      gimple insert_point;\n+      gimple *insert_point;\n       if ((!op1def || gimple_nop_p (op1def))\n \t   || (op2def && !gimple_nop_p (op2def)\n \t       && reassoc_stmt_dominates_stmt_p (op1def, op2def)))\n@@ -1388,7 +1388,7 @@ undistribute_ops_list (enum tree_code opcode,\n   FOR_EACH_VEC_ELT (*ops, i, oe1)\n     {\n       enum tree_code dcode;\n-      gimple oe1def;\n+      gimple *oe1def;\n \n       if (TREE_CODE (oe1->op) != SSA_NAME)\n \tcontinue;\n@@ -1430,7 +1430,7 @@ undistribute_ops_list (enum tree_code opcode,\n   subops = XCNEWVEC (vec_operand_entry_t_heap, ops->length ());\n   EXECUTE_IF_SET_IN_BITMAP (candidates, 0, i, sbi0)\n     {\n-      gimple oedef;\n+      gimple *oedef;\n       enum tree_code oecode;\n       unsigned j;\n \n@@ -1494,7 +1494,7 @@ undistribute_ops_list (enum tree_code opcode,\n       nr_candidates2 = 0;\n       EXECUTE_IF_SET_IN_BITMAP (candidates, 0, i, sbi0)\n \t{\n-\t  gimple oedef;\n+\t  gimple *oedef;\n \t  enum tree_code oecode;\n \t  unsigned j;\n \t  tree op = (*ops)[i]->op;\n@@ -1523,7 +1523,7 @@ undistribute_ops_list (enum tree_code opcode,\n       if (nr_candidates2 >= 2)\n \t{\n \t  operand_entry_t oe1, oe2;\n-\t  gimple prod;\n+\t  gimple *prod;\n \t  int first = bitmap_first_set_bit (candidates2);\n \n \t  /* Build the new addition chain.  */\n@@ -1536,7 +1536,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t  zero_one_operation (&oe1->op, c->oecode, c->op);\n \t  EXECUTE_IF_SET_IN_BITMAP (candidates2, first+1, i, sbi0)\n \t    {\n-\t      gimple sum;\n+\t      gimple *sum;\n \t      oe2 = (*ops)[i];\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -1596,7 +1596,7 @@ eliminate_redundant_comparison (enum tree_code opcode,\n {\n   tree op1, op2;\n   enum tree_code lcode, rcode;\n-  gimple def1, def2;\n+  gimple *def1, *def2;\n   int i;\n   operand_entry_t oe;\n \n@@ -1690,7 +1690,7 @@ eliminate_redundant_comparison (enum tree_code opcode,\n \t}\n       else if (!operand_equal_p (t, curr->op, 0))\n \t{\n-\t  gimple sum;\n+\t  gimple *sum;\n \t  enum tree_code subcode;\n \t  tree newop1;\n \t  tree newop2;\n@@ -1819,7 +1819,7 @@ struct range_entry\n    argument should be a GIMPLE_COND.  */\n \n static void\n-init_range_entry (struct range_entry *r, tree exp, gimple stmt)\n+init_range_entry (struct range_entry *r, tree exp, gimple *stmt)\n {\n   int in_p;\n   tree low, high;\n@@ -2057,7 +2057,7 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n {\n   operand_entry_t oe = (*ops)[range->idx];\n   tree op = oe->op;\n-  gimple stmt = op ? SSA_NAME_DEF_STMT (op) :\n+  gimple *stmt = op ? SSA_NAME_DEF_STMT (op) :\n     last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe->id));\n   location_t loc = gimple_location (stmt);\n   tree optype = op ? TREE_TYPE (op) : boolean_type_node;\n@@ -2499,7 +2499,7 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t\t\t\t\t+ prec - 1 - wi::clz (mask));\n \t  operand_entry_t oe = (*ops)[ranges[i].idx];\n \t  tree op = oe->op;\n-\t  gimple stmt = op ? SSA_NAME_DEF_STMT (op)\n+\t  gimple *stmt = op ? SSA_NAME_DEF_STMT (op)\n \t\t\t   : last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe->id));\n \t  location_t loc = gimple_location (stmt);\n \t  tree optype = op ? TREE_TYPE (op) : boolean_type_node;\n@@ -2563,7 +2563,7 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t  gimple_seq_add_seq_without_update (&seq, seq2);\n \t  gcc_assert (TREE_CODE (exp) == SSA_NAME);\n \t  gimple_set_visited (SSA_NAME_DEF_STMT (exp), true);\n-\t  gimple g = gimple_build_assign (make_ssa_name (optype),\n+\t  gimple *g = gimple_build_assign (make_ssa_name (optype),\n \t\t\t\t\t  BIT_IOR_EXPR, tem, exp);\n \t  gimple_set_location (g, loc);\n \t  gimple_seq_add_stmt_without_update (&seq, g);\n@@ -2701,13 +2701,13 @@ optimize_range_tests (enum tree_code opcode,\n    the last block of a range test.  */\n \n static bool\n-final_range_test_p (gimple stmt)\n+final_range_test_p (gimple *stmt)\n {\n   basic_block bb, rhs_bb;\n   edge e;\n   tree lhs, rhs;\n   use_operand_p use_p;\n-  gimple use_stmt;\n+  gimple *use_stmt;\n \n   if (!gimple_assign_cast_p (stmt))\n     return false;\n@@ -2755,7 +2755,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n {\n   edge_iterator ei, ei2;\n   edge e, e2;\n-  gimple stmt;\n+  gimple *stmt;\n   gphi_iterator gsi;\n   bool other_edge_seen = false;\n   bool is_cond;\n@@ -2840,7 +2840,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n \t    }\n \t  else\n \t    {\n-\t      gimple test_last = last_stmt (test_bb);\n+\t      gimple *test_last = last_stmt (test_bb);\n \t      if (gimple_code (test_last) != GIMPLE_COND\n \t\t  && gimple_phi_arg_def (phi, e2->dest_idx)\n \t\t     == gimple_assign_lhs (test_last)\n@@ -2863,14 +2863,14 @@ static bool\n no_side_effect_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n-  gimple last;\n+  gimple *last;\n \n   if (!gimple_seq_empty_p (phi_nodes (bb)))\n     return false;\n   last = last_stmt (bb);\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       tree lhs;\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n@@ -2890,7 +2890,7 @@ no_side_effect_bb (basic_block bb)\n \treturn false;\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n \t{\n-\t  gimple use_stmt = USE_STMT (use_p);\n+\t  gimple *use_stmt = USE_STMT (use_p);\n \t  if (is_gimple_debug (use_stmt))\n \t    continue;\n \t  if (gimple_bb (use_stmt) != bb)\n@@ -2907,7 +2907,7 @@ static bool\n get_ops (tree var, enum tree_code code, vec<operand_entry_t> *ops,\n \t struct loop *loop)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n   tree rhs[2];\n   int i;\n \n@@ -2941,7 +2941,7 @@ static tree\n update_ops (tree var, enum tree_code code, vec<operand_entry_t> ops,\n \t    unsigned int *pidx, struct loop *loop)\n {\n-  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n   tree rhs[4];\n   int i;\n \n@@ -2990,7 +2990,7 @@ struct inter_bb_range_test_entry\n /* Inter-bb range test optimization.  */\n \n static void\n-maybe_optimize_range_tests (gimple stmt)\n+maybe_optimize_range_tests (gimple *stmt)\n {\n   basic_block first_bb = gimple_bb (stmt);\n   basic_block last_bb = first_bb;\n@@ -3113,7 +3113,7 @@ maybe_optimize_range_tests (gimple stmt)\n       if (gimple_code (stmt) != GIMPLE_COND)\n \t{\n \t  use_operand_p use_p;\n-\t  gimple phi;\n+\t  gimple *phi;\n \t  edge e2;\n \t  unsigned int d;\n \n@@ -3246,7 +3246,7 @@ maybe_optimize_range_tests (gimple stmt)\n \t\t{\n \t\t  imm_use_iterator iter;\n \t\t  use_operand_p use_p;\n-\t\t  gimple use_stmt, cast_stmt = NULL;\n+\t\t  gimple *use_stmt, *cast_stmt = NULL;\n \n \t\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, bbinfo[idx].op)\n \t\t    if (is_gimple_debug (use_stmt))\n@@ -3324,9 +3324,9 @@ maybe_optimize_range_tests (gimple stmt)\n    update\" operation.  */\n \n static bool\n-is_phi_for_stmt (gimple stmt, tree operand)\n+is_phi_for_stmt (gimple *stmt, tree operand)\n {\n-  gimple def_stmt;\n+  gimple *def_stmt;\n   gphi *def_phi;\n   tree lhs;\n   use_operand_p arg_p;\n@@ -3354,7 +3354,7 @@ is_phi_for_stmt (gimple stmt, tree operand)\n static void\n remove_visited_stmt_chain (tree var)\n {\n-  gimple stmt;\n+  gimple *stmt;\n   gimple_stmt_iterator gsi;\n \n   while (1)\n@@ -3396,7 +3396,7 @@ remove_visited_stmt_chain (tree var)\n \n static void\n swap_ops_for_binary_stmt (vec<operand_entry_t> ops,\n-\t\t\t  unsigned int opindex, gimple stmt)\n+\t\t\t  unsigned int opindex, gimple *stmt)\n {\n   operand_entry_t oe1, oe2, oe3;\n \n@@ -3433,8 +3433,8 @@ swap_ops_for_binary_stmt (vec<operand_entry_t> ops,\n /* If definition of RHS1 or RHS2 dominates STMT, return the later of those\n    two definitions, otherwise return STMT.  */\n \n-static inline gimple\n-find_insert_point (gimple stmt, tree rhs1, tree rhs2)\n+static inline gimple *\n+find_insert_point (gimple *stmt, tree rhs1, tree rhs2)\n {\n   if (TREE_CODE (rhs1) == SSA_NAME\n       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs1)))\n@@ -3450,7 +3450,7 @@ find_insert_point (gimple stmt, tree rhs1, tree rhs2)\n    order.  Return new lhs.  */\n \n static tree\n-rewrite_expr_tree (gimple stmt, unsigned int opindex,\n+rewrite_expr_tree (gimple *stmt, unsigned int opindex,\n \t\t   vec<operand_entry_t> ops, bool changed)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n@@ -3487,7 +3487,8 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t     return lhs), force creation of a new SSA_NAME.  */\n \t  if (changed || ((rhs1 != oe2->op || rhs2 != oe1->op) && opindex))\n \t    {\n-\t      gimple insert_point = find_insert_point (stmt, oe1->op, oe2->op);\n+\t      gimple *insert_point\n+\t\t= find_insert_point (stmt, oe1->op, oe2->op);\n \t      lhs = make_ssa_name (TREE_TYPE (lhs));\n \t      stmt\n \t\t= gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),\n@@ -3551,7 +3552,7 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n \t  unsigned int uid = gimple_uid (stmt);\n-\t  gimple insert_point = find_insert_point (stmt, new_rhs1, oe->op);\n+\t  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op);\n \n \t  lhs = make_ssa_name (TREE_TYPE (lhs));\n \t  stmt = gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),\n@@ -3665,7 +3666,7 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n   enum tree_code opcode = gimple_assign_rhs_code (stmt);\n   int op_num = ops.length ();\n   int stmt_num = op_num - 1;\n-  gimple *stmts = XALLOCAVEC (gimple, stmt_num);\n+  gimple **stmts = XALLOCAVEC (gimple *, stmt_num);\n   int op_index = op_num - 1;\n   int stmt_index = 0;\n   int ready_stmts_end = 0;\n@@ -3754,14 +3755,14 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n    Recurse on D if necessary.  */\n \n static void\n-linearize_expr (gimple stmt)\n+linearize_expr (gimple *stmt)\n {\n   gimple_stmt_iterator gsi;\n-  gimple binlhs = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n-  gimple binrhs = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n-  gimple oldbinrhs = binrhs;\n+  gimple *binlhs = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n+  gimple *binrhs = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n+  gimple *oldbinrhs = binrhs;\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n-  gimple newbinrhs = NULL;\n+  gimple *newbinrhs = NULL;\n   struct loop *loop = loop_containing_stmt (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n \n@@ -3809,11 +3810,11 @@ linearize_expr (gimple stmt)\n /* If LHS has a single immediate use that is a GIMPLE_ASSIGN statement, return\n    it.  Otherwise, return NULL.  */\n \n-static gimple\n+static gimple *\n get_single_immediate_use (tree lhs)\n {\n   use_operand_p immuse;\n-  gimple immusestmt;\n+  gimple *immusestmt;\n \n   if (TREE_CODE (lhs) == SSA_NAME\n       && single_imm_use (lhs, &immuse, &immusestmt)\n@@ -3833,7 +3834,7 @@ get_single_immediate_use (tree lhs)\n static tree\n negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n {\n-  gimple negatedefstmt = NULL;\n+  gimple *negatedefstmt = NULL;\n   tree resultofnegate;\n   gimple_stmt_iterator gsi;\n   unsigned int uid;\n@@ -3851,7 +3852,7 @@ negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n       tree rhs1 = gimple_assign_rhs1 (negatedefstmt);\n       tree rhs2 = gimple_assign_rhs2 (negatedefstmt);\n       tree lhs = gimple_assign_lhs (negatedefstmt);\n-      gimple g;\n+      gimple *g;\n \n       gsi = gsi_for_stmt (negatedefstmt);\n       rhs1 = negate_value (rhs1, &gsi);\n@@ -3875,7 +3876,7 @@ negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n   uid = gimple_uid (gsi_stmt (gsi));\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       if (gimple_uid (stmt) != 0)\n \tbreak;\n       gimple_set_uid (stmt, uid);\n@@ -3890,12 +3891,12 @@ negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n    exposes the adds to reassociation.  */\n \n static bool\n-should_break_up_subtract (gimple stmt)\n+should_break_up_subtract (gimple *stmt)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n   tree binlhs = gimple_assign_rhs1 (stmt);\n   tree binrhs = gimple_assign_rhs2 (stmt);\n-  gimple immusestmt;\n+  gimple *immusestmt;\n   struct loop *loop = loop_containing_stmt (stmt);\n \n   if (TREE_CODE (binlhs) == SSA_NAME\n@@ -3918,7 +3919,7 @@ should_break_up_subtract (gimple stmt)\n /* Transform STMT from A - B into A + -B.  */\n \n static void\n-break_up_subtract (gimple stmt, gimple_stmt_iterator *gsip)\n+break_up_subtract (gimple *stmt, gimple_stmt_iterator *gsip)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n   tree rhs2 = gimple_assign_rhs2 (stmt);\n@@ -3941,7 +3942,7 @@ break_up_subtract (gimple stmt, gimple_stmt_iterator *gsip)\n    If any of these conditions does not hold, return FALSE.  */\n \n static bool\n-acceptable_pow_call (gimple stmt, tree *base, HOST_WIDE_INT *exponent)\n+acceptable_pow_call (gimple *stmt, tree *base, HOST_WIDE_INT *exponent)\n {\n   tree fndecl, arg1;\n   REAL_VALUE_TYPE c, cint;\n@@ -4009,12 +4010,12 @@ acceptable_pow_call (gimple stmt, tree *base, HOST_WIDE_INT *exponent)\n    Place the operands of the expression tree in the vector named OPS.  */\n \n static void\n-linearize_expr_tree (vec<operand_entry_t> *ops, gimple stmt,\n+linearize_expr_tree (vec<operand_entry_t> *ops, gimple *stmt,\n \t\t     bool is_associative, bool set_visited)\n {\n   tree binlhs = gimple_assign_rhs1 (stmt);\n   tree binrhs = gimple_assign_rhs2 (stmt);\n-  gimple binlhsdef = NULL, binrhsdef = NULL;\n+  gimple *binlhsdef = NULL, *binrhsdef = NULL;\n   bool binlhsisreassoc = false;\n   bool binrhsisreassoc = false;\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n@@ -4135,7 +4136,7 @@ repropagate_negates (void)\n \n   FOR_EACH_VEC_ELT (plus_negates, i, negate)\n     {\n-      gimple user = get_single_immediate_use (negate);\n+      gimple *user = get_single_immediate_use (negate);\n \n       if (!user || !is_gimple_assign (user))\n \tcontinue;\n@@ -4181,13 +4182,13 @@ repropagate_negates (void)\n \t\t This pushes down the negate which we possibly can merge\n \t\t into some other operation, hence insert it into the\n \t\t plus_negates vector.  */\n-\t      gimple feed = SSA_NAME_DEF_STMT (negate);\n+\t      gimple *feed = SSA_NAME_DEF_STMT (negate);\n \t      tree a = gimple_assign_rhs1 (feed);\n \t      tree b = gimple_assign_rhs2 (user);\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (feed);\n \t      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);\n \t      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));\n-\t      gimple g = gimple_build_assign (x, PLUS_EXPR, a, b);\n+\t      gimple *g = gimple_build_assign (x, PLUS_EXPR, a, b);\n \t      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n \t      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x);\n \t      user = gsi_stmt (gsi2);\n@@ -4200,7 +4201,7 @@ repropagate_negates (void)\n \t    {\n \t      /* Transform \"x = -a; y = b - x\" into \"y = b + a\", getting\n \t         rid of one operation.  */\n-\t      gimple feed = SSA_NAME_DEF_STMT (negate);\n+\t      gimple *feed = SSA_NAME_DEF_STMT (negate);\n \t      tree a = gimple_assign_rhs1 (feed);\n \t      tree rhs1 = gimple_assign_rhs1 (user);\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (user);\n@@ -4253,7 +4254,7 @@ break_up_subtract_bb (basic_block bb)\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       gimple_set_visited (stmt, false);\n       gimple_set_uid (stmt, uid++);\n \n@@ -4329,7 +4330,7 @@ compare_repeat_factors (const void *x1, const void *x2)\n    SSA name representing the value of the replacement sequence.  */\n \n static tree\n-attempt_builtin_powi (gimple stmt, vec<operand_entry_t> *ops)\n+attempt_builtin_powi (gimple *stmt, vec<operand_entry_t> *ops)\n {\n   unsigned i, j, vec_len;\n   int ii;\n@@ -4341,7 +4342,7 @@ attempt_builtin_powi (gimple stmt, vec<operand_entry_t> *ops)\n   tree type = TREE_TYPE (gimple_get_lhs (stmt));\n   tree powi_fndecl = mathfn_built_in (type, BUILT_IN_POWI);\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-  gimple mul_stmt, pow_stmt;\n+  gimple *mul_stmt, *pow_stmt;\n \n   /* Nothing to do if BUILT_IN_POWI doesn't exist for this type and\n      target.  */\n@@ -4627,7 +4628,7 @@ attempt_builtin_powi (gimple stmt, vec<operand_entry_t> *ops)\n /* Transform STMT at *GSI into a copy by replacing its rhs with NEW_RHS.  */\n \n static void\n-transform_stmt_to_copy (gimple_stmt_iterator *gsi, gimple stmt, tree new_rhs)\n+transform_stmt_to_copy (gimple_stmt_iterator *gsi, gimple *stmt, tree new_rhs)\n {\n   tree rhs1;\n \n@@ -4652,7 +4653,7 @@ transform_stmt_to_copy (gimple_stmt_iterator *gsi, gimple stmt, tree new_rhs)\n /* Transform STMT at *GSI into a multiply of RHS1 and RHS2.  */\n \n static void\n-transform_stmt_to_multiply (gimple_stmt_iterator *gsi, gimple stmt,\n+transform_stmt_to_multiply (gimple_stmt_iterator *gsi, gimple *stmt,\n \t\t\t    tree rhs1, tree rhs2)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4680,7 +4681,7 @@ reassociate_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block son;\n-  gimple stmt = last_stmt (bb);\n+  gimple *stmt = last_stmt (bb);\n \n   if (stmt && !gimple_visited_p (stmt))\n     maybe_optimize_range_tests (stmt);\n@@ -4818,7 +4819,7 @@ reassociate_bb (basic_block bb)\n \t\t     reassociated operands.  */\n \t\t  if (powi_result)\n \t\t    {\n-\t\t      gimple mul_stmt, lhs_stmt = SSA_NAME_DEF_STMT (lhs);\n+\t\t      gimple *mul_stmt, *lhs_stmt = SSA_NAME_DEF_STMT (lhs);\n \t\t      tree type = TREE_TYPE (lhs);\n \t\t      tree target_ssa = make_temp_ssa_name (type, NULL,\n \t\t\t\t\t\t\t    \"reassocpow\");\n@@ -4867,8 +4868,8 @@ branch_fixup (void)\n \n   FOR_EACH_VEC_ELT (reassoc_branch_fixups, i, var)\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (var);\n-      gimple use_stmt;\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+      gimple *use_stmt;\n       use_operand_p use;\n       bool ok = single_imm_use (var, &use, &use_stmt);\n       gcc_assert (ok\n@@ -4881,9 +4882,9 @@ branch_fixup (void)\n       basic_block merge_bb = split_block (then_bb, use_stmt)->dest;\n \n       gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);\n-      gimple g = gimple_build_cond (NE_EXPR, var,\n-\t\t\t\t    build_zero_cst (TREE_TYPE (var)),\n-\t\t\t\t    NULL_TREE, NULL_TREE);\n+      gimple *g = gimple_build_cond (NE_EXPR, var,\n+\t\t\t\t     build_zero_cst (TREE_TYPE (var)),\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n       location_t loc = gimple_location (use_stmt);\n       gimple_set_location (g, loc);\n       gsi_insert_after (&gsi, g, GSI_NEW_STMT);"}, {"sha": "18529aca432aec490812e446204ac36533954d7b", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -406,7 +406,7 @@ tree\n vn_get_expr_for (tree name)\n {\n   vn_ssa_aux_t vn = VN_INFO (name);\n-  gimple def_stmt;\n+  gimple *def_stmt;\n   tree expr = NULL_TREE;\n   enum tree_code code;\n \n@@ -489,7 +489,7 @@ vn_get_expr_for (tree name)\n    associated with.  */\n \n enum vn_kind\n-vn_get_stmt_kind (gimple stmt)\n+vn_get_stmt_kind (gimple *stmt)\n {\n   switch (gimple_code (stmt))\n     {\n@@ -1224,7 +1224,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n   unsigned int i = *i_p;\n   vn_reference_op_t op = &(*ops)[i];\n   vn_reference_op_t mem_op = &(*ops)[i - 1];\n-  gimple def_stmt;\n+  gimple *def_stmt;\n   enum tree_code code;\n   offset_int off;\n \n@@ -1651,7 +1651,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t\t       bool disambiguate_only)\n {\n   vn_reference_t vr = (vn_reference_t)vr_;\n-  gimple def_stmt = SSA_NAME_DEF_STMT (vuse);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (vuse);\n   tree base;\n   HOST_WIDE_INT offset, maxsize;\n   static vec<vn_reference_op_s>\n@@ -1830,7 +1830,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n     {\n       tree rhs1 = gimple_assign_rhs1 (def_stmt);\n-      gimple def_stmt2 = SSA_NAME_DEF_STMT (rhs1);\n+      gimple *def_stmt2 = SSA_NAME_DEF_STMT (rhs1);\n       if (is_gimple_assign (def_stmt2)\n \t  && (gimple_assign_rhs_code (def_stmt2) == COMPLEX_EXPR\n \t      || gimple_assign_rhs_code (def_stmt2) == CONSTRUCTOR)\n@@ -2039,7 +2039,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t  lhs = SSA_VAL (lhs);\n \t  if (TREE_CODE (lhs) == SSA_NAME)\n \t    {\n-\t      gimple def_stmt = SSA_NAME_DEF_STMT (lhs);\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (lhs);\n \t      if (gimple_assign_single_p (def_stmt)\n \t\t  && gimple_assign_rhs_code (def_stmt) == ADDR_EXPR)\n \t\tlhs = gimple_assign_rhs1 (def_stmt);\n@@ -2464,7 +2464,7 @@ init_vn_nary_op_from_op (vn_nary_op_t vno, tree op)\n /* Return the number of operands for a vn_nary ops structure from STMT.  */\n \n static unsigned int\n-vn_nary_length_from_stmt (gimple stmt)\n+vn_nary_length_from_stmt (gimple *stmt)\n {\n   switch (gimple_assign_rhs_code (stmt))\n     {\n@@ -2487,7 +2487,7 @@ vn_nary_length_from_stmt (gimple stmt)\n /* Initialize VNO from STMT.  */\n \n static void\n-init_vn_nary_op_from_stmt (vn_nary_op_t vno, gimple stmt)\n+init_vn_nary_op_from_stmt (vn_nary_op_t vno, gimple *stmt)\n {\n   unsigned i;\n \n@@ -2588,7 +2588,7 @@ vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)\n    vn_nary_op_t from the hashtable if it exists.  */\n \n tree\n-vn_nary_op_lookup_stmt (gimple stmt, vn_nary_op_t *vnresult)\n+vn_nary_op_lookup_stmt (gimple *stmt, vn_nary_op_t *vnresult)\n {\n   vn_nary_op_t vno1\n     = XALLOCAVAR (struct vn_nary_op_s,\n@@ -2673,7 +2673,7 @@ vn_nary_op_insert (tree op, tree result)\n    RESULT.  */\n \n vn_nary_op_t\n-vn_nary_op_insert_stmt (gimple stmt, tree result)\n+vn_nary_op_insert_stmt (gimple *stmt, tree result)\n {\n   vn_nary_op_t vno1\n     = alloc_vn_nary_op (vn_nary_length_from_stmt (stmt),\n@@ -2754,7 +2754,7 @@ static vec<tree> shared_lookup_phiargs;\n    it does not exist in the hash table. */\n \n static tree\n-vn_phi_lookup (gimple phi)\n+vn_phi_lookup (gimple *phi)\n {\n   vn_phi_s **slot;\n   struct vn_phi_s vp1;\n@@ -2789,7 +2789,7 @@ vn_phi_lookup (gimple phi)\n    RESULT.  */\n \n static vn_phi_t\n-vn_phi_insert (gimple phi, tree result)\n+vn_phi_insert (gimple *phi, tree result)\n {\n   vn_phi_s **slot;\n   vn_phi_t vp1 = current_info->phis_pool->allocate ();\n@@ -2925,7 +2925,7 @@ mark_use_processed (tree use)\n {\n   ssa_op_iter iter;\n   def_operand_p defp;\n-  gimple stmt = SSA_NAME_DEF_STMT (use);\n+  gimple *stmt = SSA_NAME_DEF_STMT (use);\n \n   if (SSA_NAME_IS_DEFAULT_DEF (use) || gimple_code (stmt) == GIMPLE_PHI)\n     {\n@@ -2945,7 +2945,7 @@ mark_use_processed (tree use)\n    Return true if a value number changed. */\n \n static bool\n-defs_to_varying (gimple stmt)\n+defs_to_varying (gimple *stmt)\n {\n   bool changed = false;\n   ssa_op_iter iter;\n@@ -2982,7 +2982,7 @@ visit_copy (tree lhs, tree rhs)\n    value number of LHS has changed as a result.  */\n \n static bool\n-visit_nary_op (tree lhs, gimple stmt)\n+visit_nary_op (tree lhs, gimple *stmt)\n {\n   bool changed = false;\n   tree result = vn_nary_op_lookup_stmt (stmt, NULL);\n@@ -3062,7 +3062,7 @@ visit_reference_op_call (tree lhs, gcall *stmt)\n    and return true if the value number of the LHS has changed as a result.  */\n \n static bool\n-visit_reference_op_load (tree lhs, tree op, gimple stmt)\n+visit_reference_op_load (tree lhs, tree op, gimple *stmt)\n {\n   bool changed = false;\n   tree last_vuse;\n@@ -3162,7 +3162,7 @@ visit_reference_op_load (tree lhs, tree op, gimple stmt)\n    and return true if the value number of the LHS has changed as a result.  */\n \n static bool\n-visit_reference_op_store (tree lhs, tree op, gimple stmt)\n+visit_reference_op_store (tree lhs, tree op, gimple *stmt)\n {\n   bool changed = false;\n   vn_reference_t vnresult = NULL;\n@@ -3263,7 +3263,7 @@ visit_reference_op_store (tree lhs, tree op, gimple stmt)\n    changed.  */\n \n static bool\n-visit_phi (gimple phi)\n+visit_phi (gimple *phi)\n {\n   bool changed = false;\n   tree result;\n@@ -3349,7 +3349,7 @@ expr_has_constants (tree expr)\n /* Return true if STMT contains constants.  */\n \n static bool\n-stmt_has_constants (gimple stmt)\n+stmt_has_constants (gimple *stmt)\n {\n   tree tem;\n \n@@ -3393,7 +3393,7 @@ stmt_has_constants (gimple stmt)\n    simplified. */\n \n static tree\n-simplify_binary_expression (gimple stmt)\n+simplify_binary_expression (gimple *stmt)\n {\n   tree result = NULL_TREE;\n   tree op0 = gimple_assign_rhs1 (stmt);\n@@ -3569,7 +3569,7 @@ static bool\n visit_use (tree use)\n {\n   bool changed = false;\n-  gimple stmt = SSA_NAME_DEF_STMT (use);\n+  gimple *stmt = SSA_NAME_DEF_STMT (use);\n \n   mark_use_processed (use);\n \n@@ -3845,8 +3845,8 @@ compare_ops (const void *pa, const void *pb)\n {\n   const tree opa = *((const tree *)pa);\n   const tree opb = *((const tree *)pb);\n-  gimple opstmta = SSA_NAME_DEF_STMT (opa);\n-  gimple opstmtb = SSA_NAME_DEF_STMT (opb);\n+  gimple *opstmta = SSA_NAME_DEF_STMT (opa);\n+  gimple *opstmtb = SSA_NAME_DEF_STMT (opb);\n   basic_block bba;\n   basic_block bbb;\n \n@@ -4072,7 +4072,7 @@ DFS (tree name)\n   vec<ssa_op_iter> itervec = vNULL;\n   vec<tree> namevec = vNULL;\n   use_operand_p usep = NULL;\n-  gimple defstmt;\n+  gimple *defstmt;\n   tree use;\n   ssa_op_iter iter;\n \n@@ -4535,7 +4535,7 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n \t  break;\n       if (e2 && (e2->flags & EDGE_EXECUTABLE))\n \t{\n-\t  gimple stmt = last_stmt (e->src);\n+\t  gimple *stmt = last_stmt (e->src);\n \t  if (stmt\n \t      && gimple_code (stmt) == GIMPLE_COND)\n \t    {\n@@ -4580,7 +4580,7 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n     }\n \n   /* Finally look at the last stmt.  */\n-  gimple stmt = last_stmt (bb);\n+  gimple *stmt = last_stmt (bb);\n   if (!stmt)\n     return;\n "}, {"sha": "e3dddee0df1a1b5ae6ace8453a23f248edbd77d9", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -123,7 +123,7 @@ typedef struct vn_constant_s\n } *vn_constant_t;\n \n enum vn_kind { VN_NONE, VN_CONSTANT, VN_NARY, VN_REFERENCE, VN_PHI };\n-enum vn_kind vn_get_stmt_kind (gimple);\n+enum vn_kind vn_get_stmt_kind (gimple *);\n \n /* Hash the type TYPE using bits that distinguishes it in the\n    types_compatible_p sense.  */\n@@ -197,7 +197,7 @@ tree vn_get_expr_for (tree);\n bool run_scc_vn (vn_lookup_kind);\n void free_scc_vn (void);\n tree vn_nary_op_lookup (tree, vn_nary_op_t *);\n-tree vn_nary_op_lookup_stmt (gimple, vn_nary_op_t *);\n+tree vn_nary_op_lookup_stmt (gimple *, vn_nary_op_t *);\n tree vn_nary_op_lookup_pieces (unsigned int, enum tree_code,\n \t\t\t       tree, tree *, vn_nary_op_t *);\n vn_nary_op_t vn_nary_op_insert (tree, tree);"}, {"sha": "7be4848967cf02b23e133c99a4fec9bcc23dfd99", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -355,7 +355,7 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n \n /* Given a statement STMT, construct a hash table element.  */\n \n-expr_hash_elt::expr_hash_elt (gimple stmt, tree orig_lhs)\n+expr_hash_elt::expr_hash_elt (gimple *stmt, tree orig_lhs)\n {\n   enum gimple_code code = gimple_code (stmt);\n   struct hashable_expr *expr = this->expr ();"}, {"sha": "52bcb6ff951d87e3c25ce2e5ef7e8f1cbc17447c", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -54,7 +54,7 @@ typedef class expr_hash_elt * expr_hash_elt_t;\n class expr_hash_elt\n {\n  public:\n-  expr_hash_elt (gimple, tree);\n+  expr_hash_elt (gimple *, tree);\n   expr_hash_elt (tree);\n   expr_hash_elt (struct hashable_expr *, tree);\n   expr_hash_elt (class expr_hash_elt &);"}, {"sha": "fda7bf277f0144d06507a88c37a5760388f5fa82", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -114,7 +114,7 @@ all_immediate_uses_same_place (def_operand_p def_p)\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n \n-  gimple firstuse = NULL;\n+  gimple *firstuse = NULL;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n     {\n       if (is_gimple_debug (USE_STMT (use_p)))\n@@ -144,7 +144,7 @@ nearest_common_dominator_of_uses (def_operand_p def_p, bool *debug_stmts)\n \n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n     {\n-      gimple usestmt = USE_STMT (use_p);\n+      gimple *usestmt = USE_STMT (use_p);\n       basic_block useblock;\n \n       if (gphi *phi = dyn_cast <gphi *> (usestmt))\n@@ -198,7 +198,7 @@ nearest_common_dominator_of_uses (def_operand_p def_p, bool *debug_stmts)\n static basic_block\n select_best_block (basic_block early_bb,\n \t\t   basic_block late_bb,\n-\t\t   gimple stmt)\n+\t\t   gimple *stmt)\n {\n   basic_block best_bb = late_bb;\n   basic_block temp_bb = late_bb;\n@@ -250,10 +250,10 @@ select_best_block (basic_block early_bb,\n    statement before that STMT should be moved.  */\n \n static bool\n-statement_sink_location (gimple stmt, basic_block frombb,\n+statement_sink_location (gimple *stmt, basic_block frombb,\n \t\t\t gimple_stmt_iterator *togsi)\n {\n-  gimple use;\n+  gimple *use;\n   use_operand_p one_use = NULL_USE_OPERAND_P;\n   basic_block sinkbb;\n   use_operand_p use_p;\n@@ -322,7 +322,7 @@ statement_sink_location (gimple stmt, basic_block frombb,\n     {\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, DEF_FROM_PTR (def_p))\n \t{\n-\t  gimple use_stmt = USE_STMT (use_p);\n+\t  gimple *use_stmt = USE_STMT (use_p);\n \n \t  /* A killing definition is not a use.  */\n \t  if ((gimple_has_lhs (use_stmt)\n@@ -383,7 +383,7 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \t  basic_block found = NULL;\n \t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_vuse (stmt))\n \t    {\n-\t      gimple use_stmt = USE_STMT (use_p);\n+\t      gimple *use_stmt = USE_STMT (use_p);\n \t      basic_block bb = gimple_bb (use_stmt);\n \t      /* For PHI nodes the block we know sth about\n \t\t is the incoming block with the use.  */\n@@ -488,7 +488,7 @@ sink_code_in_bb (basic_block bb)\n \n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (gsi);\n       gimple_stmt_iterator togsi;\n \n       if (!statement_sink_location (stmt, bb, &togsi))\n@@ -512,7 +512,7 @@ sink_code_in_bb (basic_block bb)\n \t{\n \t  imm_use_iterator iter;\n \t  use_operand_p use_p;\n-\t  gimple vuse_stmt;\n+\t  gimple *vuse_stmt;\n \n \t  FOR_EACH_IMM_USE_STMT (vuse_stmt, iter, gimple_vdef (stmt))\n \t    if (gimple_code (vuse_stmt) != GIMPLE_PHI)"}, {"sha": "874d8c3e2a5103f4f89eb208a6778c3c210a51e1", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -73,7 +73,7 @@ typedef struct strinfo_struct\n   /* Any of the corresponding pointers for querying alias oracle.  */\n   tree ptr;\n   /* Statement for delayed length computation.  */\n-  gimple stmt;\n+  gimple *stmt;\n   /* Pointer to '\\0' if known, if NULL, it can be computed as\n      ptr + length.  */\n   tree endptr;\n@@ -150,7 +150,7 @@ static struct obstack stridx_obstack;\n    *x = '\\0' store that could be removed if it is immediately overwritten.  */\n struct laststmt_struct\n {\n-  gimple stmt;\n+  gimple *stmt;\n   tree len;\n   int stridx;\n } laststmt;\n@@ -213,7 +213,7 @@ get_stridx (tree exp)\n       HOST_WIDE_INT off = 0;\n       for (i = 0; i < 5; i++)\n \t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (e);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (e);\n \t  if (!is_gimple_assign (def_stmt)\n \t      || gimple_assign_rhs_code (def_stmt) != POINTER_PLUS_EXPR)\n \t    return 0;\n@@ -432,7 +432,7 @@ get_string_length (strinfo si)\n \n   if (si->stmt)\n     {\n-      gimple stmt = si->stmt, lenstmt;\n+      gimple *stmt = si->stmt, *lenstmt;\n       bool with_bounds = gimple_call_with_bounds_p (stmt);\n       tree callee, lhs, fn, tem;\n       location_t loc;\n@@ -540,7 +540,7 @@ get_string_length (strinfo si)\n    might change due to stores in stmt.  */\n \n static bool\n-maybe_invalidate (gimple stmt)\n+maybe_invalidate (gimple *stmt)\n {\n   strinfo si;\n   unsigned int i;\n@@ -833,7 +833,7 @@ find_equal_ptrs (tree ptr, int idx)\n     return;\n   while (1)\n     {\n-      gimple stmt = SSA_NAME_DEF_STMT (ptr);\n+      gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n       if (!is_gimple_assign (stmt))\n \treturn;\n       ptr = gimple_assign_rhs1 (stmt);\n@@ -878,7 +878,7 @@ find_equal_ptrs (tree ptr, int idx)\n    strinfo.  */\n \n static void\n-adjust_last_stmt (strinfo si, gimple stmt, bool is_strcat)\n+adjust_last_stmt (strinfo si, gimple *stmt, bool is_strcat)\n {\n   tree vuse, callee, len;\n   struct laststmt_struct last = laststmt;\n@@ -977,7 +977,7 @@ adjust_last_stmt (strinfo si, gimple stmt, bool is_strcat)\n     }\n   else if (TREE_CODE (len) == SSA_NAME)\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (len);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (len);\n       if (!is_gimple_assign (def_stmt)\n \t  || gimple_assign_rhs_code (def_stmt) != PLUS_EXPR\n \t  || gimple_assign_rhs1 (def_stmt) != last.len\n@@ -1000,7 +1000,7 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n {\n   int idx;\n   tree src;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n \n   if (lhs == NULL_TREE)\n@@ -1076,7 +1076,7 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n {\n   int idx;\n   tree src;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n \n@@ -1187,7 +1187,7 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   int idx, didx;\n   tree src, dst, srclen, len, lhs, args, type, fn, oldlen;\n   bool success;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   strinfo si, dsi, olddsi, zsi;\n   location_t loc;\n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n@@ -1438,7 +1438,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n {\n   int idx, didx;\n   tree src, dst, len, lhs, oldlen, newlen;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   strinfo si, dsi, olddsi;\n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n \n@@ -1463,7 +1463,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n   if (idx > 0)\n     {\n-      gimple def_stmt;\n+      gimple *def_stmt;\n \n       /* Handle memcpy (x, y, l) where l is strlen (y) + 1.  */\n       si = get_strinfo (idx);\n@@ -1581,7 +1581,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   int idx, didx;\n   tree src, dst, srclen, dstlen, len, lhs, args, type, fn, objsz, endptr;\n   bool success;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   strinfo si, dsi;\n   location_t loc;\n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n@@ -1785,7 +1785,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n static void\n handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n   gcc_assert (get_stridx (lhs) == 0);\n   int idx = new_stridx (lhs);\n@@ -1808,7 +1808,7 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n static bool\n handle_builtin_memset (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt2 = gsi_stmt (*gsi);\n+  gimple *stmt2 = gsi_stmt (*gsi);\n   if (!integer_zerop (gimple_call_arg (stmt2, 1)))\n     return true;\n   tree ptr = gimple_call_arg (stmt2, 0);\n@@ -1818,7 +1818,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n   strinfo si1 = get_strinfo (idx1);\n   if (!si1)\n     return true;\n-  gimple stmt1 = si1->stmt;\n+  gimple *stmt1 = si1->stmt;\n   if (!stmt1 || !is_gimple_call (stmt1))\n     return true;\n   tree callee1 = gimple_call_fndecl (stmt1);\n@@ -1843,7 +1843,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n   unlink_stmt_vdef (stmt2);\n   if (lhs)\n     {\n-      gimple assign = gimple_build_assign (lhs, ptr);\n+      gimple *assign = gimple_build_assign (lhs, ptr);\n       gsi_replace (gsi, assign, false);\n     }\n   else\n@@ -1863,7 +1863,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n static void\n handle_pointer_plus (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_assign_lhs (stmt), off;\n   int idx = get_stridx (gimple_assign_rhs1 (stmt));\n   strinfo si, zsi;\n@@ -1891,7 +1891,7 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n     zsi = zero_length_string (lhs, si);\n   else if (TREE_CODE (off) == SSA_NAME)\n     {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (off);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (off);\n       if (gimple_assign_single_p (def_stmt)\n \t  && operand_equal_p (si->length, gimple_assign_rhs1 (def_stmt), 0))\n \tzsi = zero_length_string (lhs, si);\n@@ -1917,7 +1917,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n {\n   int idx = -1;\n   strinfo si = NULL;\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n   tree ssaname = NULL_TREE, lhs = gimple_assign_lhs (stmt);\n \n   if (TREE_CODE (lhs) == MEM_REF\n@@ -2062,7 +2062,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n static bool\n strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n {\n-  gimple stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (*gsi);\n \n   if (is_gimple_call (stmt))\n     {\n@@ -2158,14 +2158,14 @@ strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n    been invalidated.  */\n \n static void\n-do_invalidate (basic_block dombb, gimple phi, bitmap visited, int *count)\n+do_invalidate (basic_block dombb, gimple *phi, bitmap visited, int *count)\n {\n   unsigned int i, n = gimple_phi_num_args (phi);\n \n   for (i = 0; i < n; i++)\n     {\n       tree vuse = gimple_phi_arg_def (phi, i);\n-      gimple stmt = SSA_NAME_DEF_STMT (vuse);\n+      gimple *stmt = SSA_NAME_DEF_STMT (vuse);\n       basic_block bb = gimple_bb (stmt);\n       if (bb == NULL\n \t  || bb == dombb"}, {"sha": "cf2b2f45de53062c72a76bdb28273205d0a3f40f", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26", "patch": "@@ -402,7 +402,7 @@ new_var_info (tree t, const char *name)\n \n /* A map mapping call statements to per-stmt variables for uses\n    and clobbers specific to the call.  */\n-static hash_map<gimple, varinfo_t> *call_stmt_vars;\n+static hash_map<gimple *, varinfo_t> *call_stmt_vars;\n \n /* Lookup or create the variable for the call statement CALL.  */\n \n@@ -4617,9 +4617,9 @@ find_func_aliases_for_call (struct function *fn, gcall *t)\n    when building alias sets and computing alias grouping heuristics.  */\n \n static void\n-find_func_aliases (struct function *fn, gimple origt)\n+find_func_aliases (struct function *fn, gimple *origt)\n {\n-  gimple t = origt;\n+  gimple *t = origt;\n   auto_vec<ce_s, 16> lhsc;\n   auto_vec<ce_s, 16> rhsc;\n   struct constraint_expr *c;\n@@ -4846,9 +4846,9 @@ process_ipa_clobber (varinfo_t fi, tree ptr)\n    IPA constraint builder.  */\n \n static void\n-find_func_clobbers (struct function *fn, gimple origt)\n+find_func_clobbers (struct function *fn, gimple *origt)\n {\n-  gimple t = origt;\n+  gimple *t = origt;\n   auto_vec<ce_s, 16> lhsc;\n   auto_vec<ce_s, 16> rhsc;\n   varinfo_t fi;\n@@ -6646,7 +6646,7 @@ init_alias_vars (void)\n   constraints.create (8);\n   varmap.create (8);\n   vi_for_tree = new hash_map<tree, varinfo_t>;\n-  call_stmt_vars = new hash_map<gimple, varinfo_t>;\n+  call_stmt_vars = new hash_map<gimple *, varinfo_t>;\n \n   memset (&stats, 0, sizeof (stats));\n   shared_bitmap_table = new hash_table<shared_bitmap_hasher> (511);\n@@ -6798,7 +6798,7 @@ compute_points_to_sets (void)\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n+\t  gimple *stmt = gsi_stmt (gsi);\n \n \t  find_func_aliases (cfun, stmt);\n \t}\n@@ -6935,7 +6935,7 @@ delete_points_to_sets (void)\n    base zero.  */\n \n static bool\n-visit_loadstore (gimple, tree base, tree ref, void *clique_)\n+visit_loadstore (gimple *, tree base, tree ref, void *clique_)\n {\n   unsigned short clique = (uintptr_t)clique_;\n   if (TREE_CODE (base) == MEM_REF\n@@ -7077,7 +7077,7 @@ compute_dependence_clique (void)\n \t{\n \t  /* Now look at possible dereferences of ptr.  */\n \t  imm_use_iterator ui;\n-\t  gimple use_stmt;\n+\t  gimple *use_stmt;\n \t  FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)\n \t    {\n \t      /* ???  Calls and asms.  */\n@@ -7106,7 +7106,7 @@ compute_dependence_clique (void)\n     for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n \t !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tgimple stmt = gsi_stmt (gsi);\n+\tgimple *stmt = gsi_stmt (gsi);\n \twalk_stmt_load_store_ops (stmt, (void *)(uintptr_t)clique,\n \t\t\t\t  visit_loadstore, visit_loadstore);\n       }\n@@ -7372,7 +7372,7 @@ ipa_pta_execute (void)\n \t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t       gsi_next (&gsi))\n \t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple *stmt = gsi_stmt (gsi);\n \n \t      find_func_aliases (func, stmt);\n \t      find_func_clobbers (func, stmt);"}, {"sha": "0ce59e8051a8ea7ccf8e8ce40cbe5080c43174d7", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "7a7bcc940f975871c6849915ed7d8c899052e86e", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "b28fff3dc19114896302bc7d1628ab89682cf964", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "6e97d25b0efac8589db16e006dea0dd883036701", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "6f215293a7ba7f87d7af999a40b0e4b8a664f18a", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "d045341ebc36a662f9a881eb7107b942dcbf4636", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "3f7dbcf9228b8b7229caee227174cfb990bcf046", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "4b869be8da5b07d2207a8ba64b230b8e0ea36555", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "a3b9bedb37028df256c8695c3d10a2844139d350", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "41992905fbb1340a7347fe4cbd13ad477830578a", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "22ff6094a0b9ca7fed3d6acaa960c13296749328", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "d69fa06049706d5ea9eb84a6a47324a865fe29c2", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "69998e3b88318025b4224c18c27af92ad615d6ae", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "e97f6db89d8ee054cb1dc372687bfe8cafe67293", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "3befa38788d6167510cdbd46377601c8c479dc5f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "dad38a2247a9bc715c62ae3f1e482cafc30185ba", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "11c3ae28cceaadd5767b27638e2240739a1e9352", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "63e29aa7e1443c6733e665b4f8bc4dd0a203075a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 86, "deletions": 84, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "830801a0224c31c346c0392779104d706b1cae9d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 113, "deletions": 112, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "7a2d62380946ea6c97f291bf376d6a80e5e09f6c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "cb9e7e835e7a3829db617bbea7b8356966903cf4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "675f2351fefa36e2e9ac938e4d0abf94d5794fb5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "e4d1feb1fc30a47d569dbad75332ce0dab0b259b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "2cd71a2eab5abb2d227a74f6ba05c9d19018ed50", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "84fd34deb7ac19cf86086daebd1bcedbb9fc360e", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "f35ef27030b74f711bc2de609652dd3b82df9989", "filename": "gcc/tsan.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "af586e395a4e56720c633e71e5eed1aa5a4f87b5", "filename": "gcc/ubsan.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "90211ef379551a1ef379254f951e6afec5f1f76f", "filename": "gcc/value-prof.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "6dadb0cc97cf6d85987eda6f217668e9e59a3bf7", "filename": "gcc/value-prof.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}, {"sha": "3242dd4c4a029670750ac14fcee9d2ecc370b170", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355fe0884b8097c32e859f0df57c83bde0c6bd26/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=355fe0884b8097c32e859f0df57c83bde0c6bd26"}]}