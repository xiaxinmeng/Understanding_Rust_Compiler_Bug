{"sha": "0e0eecec3087d3d639c77814a3ed4b1dc0434cfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwZWVjZWMzMDg3ZDNkNjM5Yzc3ODE0YTNlZDRiMWRjMDQzNGNmYg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-12-09T17:21:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:21:19Z"}, "message": "sem_ch4.adb (Remove_Abstract_Operations): Do not apply preference rule prematurely when operands are universal...\n\n2005-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Remove_Abstract_Operations): Do not apply preference\n\trule prematurely when operands are universal, remaining ambiguities\n\twill be removed during resolution.\n\tCode cleanup.\n\n\t* sem_type.adb (Disambiguate): In Ada95 mode, discard interpretations\n\tthat are Ada 2005 functions.\n\t(Has_Abstract_Interpretation): Subsidiary to\n\tRemove_Conversions, to remove ambiguities caused by abstract operations\n\ton numeric types when operands are universal.\n\nFrom-SVN: r108302", "tree": {"sha": "23ddc8663a59b1e79ef4abc43299d6f2168f83b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23ddc8663a59b1e79ef4abc43299d6f2168f83b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5bd964f4a698b0c69a6767a35be9df22f1257a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5bd964f4a698b0c69a6767a35be9df22f1257a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5bd964f4a698b0c69a6767a35be9df22f1257a5"}], "stats": {"total": 130, "additions": 97, "deletions": 33}, "files": [{"sha": "c35b3a7431346e9c6c4ad9bcefc4d10dbe10ca69", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0e0eecec3087d3d639c77814a3ed4b1dc0434cfb", "patch": "@@ -4379,20 +4379,20 @@ package body Sem_Ch4 is\n             --  If either operand is a junk operand (e.g. package name), then\n             --  post appropriate error messages, but do not complain further.\n \n-            --  Note that the use of OR in this test instead of OR ELSE\n-            --  is quite deliberate, we may as well check both operands\n-            --  in the binary operator case.\n+            --  Note that the use of OR in this test instead of OR ELSE is\n+            --  quite deliberate, we may as well check both operands in the\n+            --  binary operator case.\n \n             elsif Junk_Operand (R)\n               or (Nkind (N) in N_Binary_Op and then Junk_Operand (L))\n             then\n                return;\n \n             --  If we have a logical operator, one of whose operands is\n-            --  Boolean, then we know that the other operand cannot resolve\n-            --  to Boolean (since we got no interpretations), but in that\n-            --  case we pretty much know that the other operand should be\n-            --  Boolean, so resolve it that way (generating an error)\n+            --  Boolean, then we know that the other operand cannot resolve to\n+            --  Boolean (since we got no interpretations), but in that case we\n+            --  pretty much know that the other operand should be Boolean, so\n+            --  resolve it that way (generating an error)\n \n             elsif Nkind (N) = N_Op_And\n                     or else\n@@ -4476,10 +4476,10 @@ package body Sem_Ch4 is\n                return;\n             end if;\n \n-            --  If we fall through then just give general message. Note\n-            --  that in the following messages, if the operand is overloaded\n-            --  we choose an arbitrary type to complain about, but that is\n-            --  probably more useful than not giving a type at all.\n+            --  If we fall through then just give general message. Note that in\n+            --  the following messages, if the operand is overloaded we choose\n+            --  an arbitrary type to complain about, but that is probably more\n+            --  useful than not giving a type at all.\n \n             if Nkind (N) in N_Unary_Op then\n                Error_Msg_Node_2 := Etype (R);\n@@ -4543,23 +4543,21 @@ package body Sem_Ch4 is\n       It           : Interp;\n       Abstract_Op  : Entity_Id := Empty;\n \n-      --  AI-310: If overloaded, remove abstract non-dispatching\n-      --  operations. We activate this if either extensions are\n-      --  enabled, or if the abstract operation in question comes\n-      --  from a predefined file. This latter test allows us to\n-      --  use abstract to make operations invisible to users. In\n-      --  particular, if type Address is non-private and abstract\n-      --  subprograms are used to hide its operators, they will be\n-      --  truly hidden.\n+      --  AI-310: If overloaded, remove abstract non-dispatching operations. We\n+      --  activate this if either extensions are enabled, or if the abstract\n+      --  operation in question comes from a predefined file. This latter test\n+      --  allows us to use abstract to make operations invisible to users. In\n+      --  particular, if type Address is non-private and abstract subprograms\n+      --  are used to hide its operators, they will be truly hidden.\n \n       type Operand_Position is (First_Op, Second_Op);\n       Univ_Type : constant Entity_Id := Universal_Interpretation (N);\n \n       procedure Remove_Address_Interpretations (Op : Operand_Position);\n-      --  Ambiguities may arise when the operands are literal and the\n-      --  address operations in s-auxdec are visible. In that case, remove\n-      --  the interpretation of a literal as Address, to retain the semantics\n-      --  of Address as a private type.\n+      --  Ambiguities may arise when the operands are literal and the address\n+      --  operations in s-auxdec are visible. In that case, remove the\n+      --  interpretation of a literal as Address, to retain the semantics of\n+      --  Address as a private type.\n \n       ------------------------------------\n       -- Remove_Address_Interpretations --\n@@ -4627,10 +4625,11 @@ package body Sem_Ch4 is\n                      Present (Universal_Interpretation (Left_Opnd (N)));\n \n                begin\n-                  if U1 and then not U2 then\n+                  if U1 then\n                      Remove_Address_Interpretations (Second_Op);\n+                  end if;\n \n-                  elsif U2 and then not U1 then\n+                  if U2 then\n                      Remove_Address_Interpretations (First_Op);\n                   end if;\n \n@@ -4655,15 +4654,17 @@ package body Sem_Ch4 is\n                     and then Present (Univ_Type)\n                   then\n                      --  If both operands have a universal interpretation,\n-                     --  select the predefined operator and discard others.\n+                     --  it is still necessary to remove interpretations that\n+                     --  yield Address. Any remaining ambiguities will be\n+                     --  removed in Disambiguate.\n \n                      Get_First_Interp (N, I, It);\n                      while Present (It.Nam) loop\n-                        if Scope (It.Nam) = Standard_Standard then\n-                           Set_Etype (N, Univ_Type);\n+                        if Is_Descendent_Of_Address (It.Typ) then\n+                           Remove_Interp (I);\n+\n+                        elsif not Is_Type (It.Nam) then\n                            Set_Entity (N, It.Nam);\n-                           Set_Is_Overloaded (N, False);\n-                           exit;\n                         end if;\n \n                         Get_Next_Interp (I, It);\n@@ -4690,10 +4691,11 @@ package body Sem_Ch4 is\n                         Present (Universal_Interpretation (Next (Arg1)));\n \n             begin\n-               if U1 and then not U2 then\n+               if U1 then\n                   Remove_Address_Interpretations (First_Op);\n+               end if;\n \n-               elsif U2 and then not U1 then\n+               if U2 then\n                   Remove_Address_Interpretations (Second_Op);\n                end if;\n "}, {"sha": "b4218db925ed5c00c3b233df1c102cf972fef9dd", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0eecec3087d3d639c77814a3ed4b1dc0434cfb/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=0e0eecec3087d3d639c77814a3ed4b1dc0434cfb", "patch": "@@ -1019,6 +1019,10 @@ package body Sem_Type is\n       --  pathology in the other direction with calls whose multiple overloaded\n       --  actuals make them truly unresolvable.\n \n+      --  The new rules concerning abstract operations create additional\n+      --  for special handling of expressions with universal operands, See\n+      --  comments to Has_Abstract_Interpretation below.\n+\n       ------------------------\n       --  In_Generic_Actual --\n       ------------------------\n@@ -1105,12 +1109,43 @@ package body Sem_Type is\n          Act1 : Node_Id;\n          Act2 : Node_Id;\n \n+         function Has_Abstract_Interpretation (N : Node_Id) return Boolean;\n+         --  If an operation has universal operands the universal operation\n+         --  is present among its interpretations. If there is an abstract\n+         --  interpretation for the operator, with a numeric result, this\n+         --  interpretation was already removed in sem_ch4, but the universal\n+         --  one is still visible. We must rescan the list of operators and\n+         --  remove the universal interpretation to resolve the ambiguity.\n+\n+         ---------------------------------\n+         -- Has_Abstract_Interpretation --\n+         ---------------------------------\n+\n+         function Has_Abstract_Interpretation (N : Node_Id) return Boolean is\n+            E : Entity_Id;\n+\n+         begin\n+            E := Current_Entity (N);\n+            while Present (E) loop\n+               if Is_Abstract (E)\n+                 and then Is_Numeric_Type (Etype (E))\n+               then\n+                  return True;\n+               else\n+                  E := Homonym (E);\n+               end if;\n+            end loop;\n+\n+            return False;\n+         end Has_Abstract_Interpretation;\n+\n+      --  Start of processing for Remove_ConversionsMino\n+\n       begin\n          It1 := No_Interp;\n \n          Get_First_Interp (N, I, It);\n          while Present (It.Typ) loop\n-\n             if not Is_Overloadable (It.Nam) then\n                return No_Interp;\n             end if;\n@@ -1185,6 +1220,19 @@ package body Sem_Type is\n                   else\n                      It1 := It;\n                   end if;\n+\n+               elsif Nkind (Act1) in N_Op\n+                 and then Is_Overloaded (Act1)\n+                 and then Present (Universal_Interpretation (Act1))\n+                 and then Is_Numeric_Type (Etype (F1))\n+                 and then Ada_Version >= Ada_05\n+                 and then Has_Abstract_Interpretation (Act1)\n+               then\n+                  if It = Disambiguate.It1 then\n+                     return Disambiguate.It2;\n+                  elsif It = Disambiguate.It2 then\n+                     return Disambiguate.It1;\n+                  end if;\n                end if;\n             end if;\n \n@@ -1267,6 +1315,19 @@ package body Sem_Type is\n       It2  := It;\n       Nam2 := It.Nam;\n \n+      if Ada_Version < Ada_05 then\n+\n+         --  Check whether one of the entities is an Ada 2005 entity and we are\n+         --  operating in an earlier mode, in which case we discard the Ada\n+         --  2005 entity, so that we get proper Ada 95 overload resolution.\n+\n+         if Is_Ada_2005 (Nam1) then\n+            return It2;\n+         elsif Is_Ada_2005 (Nam2) then\n+            return It1;\n+         end if;\n+      end if;\n+\n       --  If the context is universal, the predefined operator is preferred.\n       --  This includes bounds in numeric type declarations, and expressions\n       --  in type conversions. If no interpretation yields a universal type,\n@@ -1912,6 +1973,7 @@ package body Sem_Type is\n          if Present (Interface_List (Parent (Target_Typ))) then\n             declare\n                AI : Node_Id;\n+\n             begin\n                AI := First (Interface_List (Parent (Target_Typ)));\n                while Present (AI) loop"}]}