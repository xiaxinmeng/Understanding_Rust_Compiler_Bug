{"sha": "9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMyYjNkZjEwYTU0N2YzNjBmN2VlOGIwMzkzZjRiN2ZhM2U1MDE0Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-09-26T20:59:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-09-26T20:59:03Z"}, "message": "re PR middle-end/37275 (ICE when compile libgomp/task.c)\n\n\tPR middle-end/37275\n\t* dwarf2out.c (tls_mem_loc_descriptor): New function.\n\t(mem_loc_descriptor): Use it for MEM.  For PLUS fail if second\n\tmem_loc_descriptor failed.  Accept UNSPEC.\n\t(loc_descriptor): Use tls_mem_loc_descriptor for MEM.  For PARALLEL\n\tfail if one of the loc_descriptor calls for pieces failed.\n\t(loc_descriptor_from_tree_1): Handle even DECL_EXTERNAL __thread vars,\n\tas long as they bind locally.  For COMPONENT_REF, ARRAY_REF etc. fail\n\tif loc_descriptor_from_tree_1 on offset failed.\n\n\t* gcc.target/i386/pr37275.c: New test.\n\nFrom-SVN: r140712", "tree": {"sha": "b364d416e69c31df3bbb3c47c5f77ad3f3b4c57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b364d416e69c31df3bbb3c47c5f77ad3f3b4c57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb3da4f27b9d7241a626695e80edc285561f2506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3da4f27b9d7241a626695e80edc285561f2506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb3da4f27b9d7241a626695e80edc285561f2506"}], "stats": {"total": 224, "additions": 219, "deletions": 5}, "files": [{"sha": "740a943fbae246befb55752fd4500ae797a9a523", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "patch": "@@ -1,5 +1,15 @@\n 2008-09-26  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/37275\n+\t* dwarf2out.c (tls_mem_loc_descriptor): New function.\n+\t(mem_loc_descriptor): Use it for MEM.  For PLUS fail if second\n+\tmem_loc_descriptor failed.  Accept UNSPEC.\n+\t(loc_descriptor): Use tls_mem_loc_descriptor for MEM.  For PARALLEL\n+\tfail if one of the loc_descriptor calls for pieces failed.\n+\t(loc_descriptor_from_tree_1): Handle even DECL_EXTERNAL __thread vars,\n+\tas long as they bind locally.  For COMPONENT_REF, ARRAY_REF etc. fail\n+\tif loc_descriptor_from_tree_1 on offset failed.\n+\n \tPR middle-end/37576\n \t* opts.c (common_handle_option): Don't call print_specific_help with\n \tCL_SAVE as first argument."}, {"sha": "98b98a808027764152b5eda5cb732c69544932d5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "patch": "@@ -9890,6 +9890,48 @@ concatn_mem_loc_descriptor (rtx concatn, enum machine_mode mode,\n   return cc_loc_result;\n }\n \n+/* Try to handle TLS MEMs, for which mem_loc_descriptor on XEXP (mem, 0)\n+   failed.  */\n+\n+static dw_loc_descr_ref\n+tls_mem_loc_descriptor (rtx mem)\n+{\n+  tree base;\n+  dw_loc_descr_ref loc_result, loc_result2;\n+\n+  if (MEM_EXPR (mem) == NULL_TREE || MEM_OFFSET (mem) == NULL_RTX)\n+    return NULL;\n+\n+  base = get_base_address (MEM_EXPR (mem));\n+  if (base == NULL\n+      || TREE_CODE (base) != VAR_DECL\n+      || !DECL_THREAD_LOCAL_P (base))\n+    return NULL;\n+\n+  loc_result = loc_descriptor_from_tree_1 (MEM_EXPR (mem), 2);\n+  if (loc_result == NULL)\n+    return NULL;\n+\n+  if (INTVAL (MEM_OFFSET (mem)))\n+    {\n+      if (INTVAL (MEM_OFFSET (mem)) >= 0)\n+\tadd_loc_descr (&loc_result,\n+\t\t       new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t      INTVAL (MEM_OFFSET (mem)), 0));\n+      else\n+\t{\n+\t  loc_result2 = mem_loc_descriptor (MEM_OFFSET (mem), GET_MODE (mem),\n+\t\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (loc_result2 == 0)\n+\t    return NULL;\n+\t  add_loc_descr (&loc_result, loc_result2);\n+\t  add_loc_descr (&loc_result, new_loc_descr (DW_OP_plus, 0, 0));\n+\t}\n+    }\n+\n+  return loc_result;\n+}\n+\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a\n@@ -9963,6 +10005,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case MEM:\n       mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n \t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n+      if (mem_loc_result == NULL)\n+\tmem_loc_result = tls_mem_loc_descriptor (rtl);\n       if (mem_loc_result != 0)\n \tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n       break;\n@@ -10045,9 +10089,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\t\t  INTVAL (XEXP (rtl, 1)), 0));\n \t  else\n \t    {\n-\t      add_loc_descr (&mem_loc_result,\n-\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode,\n-\t\t\t\t\t\t VAR_INIT_STATUS_INITIALIZED));\n+\t      dw_loc_descr_ref mem_loc_result2\n+\t\t= mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n+\t      if (mem_loc_result2 == 0)\n+\t\tbreak;\n+\t      add_loc_descr (&mem_loc_result, mem_loc_result2);\n \t      add_loc_descr (&mem_loc_result,\n \t\t\t     new_loc_descr (DW_OP_plus, 0, 0));\n \t    }\n@@ -10097,6 +10144,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n       break;\n \n+    case UNSPEC:\n+      /* If delegitimize_address couldn't do anything with the UNSPEC, we\n+\t can't express it in the debug info.  This can happen e.g. with some\n+\t TLS UNSPECs.  */\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -10193,6 +10246,8 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n     case MEM:\n       loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n \t\t\t\t       initialized);\n+      if (loc_result == NULL)\n+\tloc_result = tls_mem_loc_descriptor (rtl);\n       break;\n \n     case CONCAT:\n@@ -10225,6 +10280,8 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n \t/* Create the first one, so we have something to add to.  */\n \tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n \t\t\t\t     initialized);\n+\tif (loc_result == NULL)\n+\t  return NULL;\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n \tadd_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n \tfor (i = 1; i < num_elem; i++)\n@@ -10233,6 +10290,8 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n \n \t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n \t\t\t\t   initialized);\n+\t    if (temp == NULL)\n+\t      return NULL;\n \t    add_loc_descr (&loc_result, temp);\n \t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n \t    add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n@@ -10311,7 +10370,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t       /* The way DW_OP_GNU_push_tls_address is specified, we\n \t     \t  can only look up addresses of objects in the current\n \t     \t  module.  */\n-\t      if (DECL_EXTERNAL (loc))\n+\t      if (DECL_EXTERNAL (loc) && !targetm.binds_local_p (loc))\n \t\treturn 0;\n \t      first_op = INTERNAL_DW_OP_tls_addr;\n \t      second_op = DW_OP_GNU_push_tls_address;\n@@ -10433,7 +10492,10 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \tif (offset != NULL_TREE)\n \t  {\n \t    /* Variable offset.  */\n-\t    add_loc_descr (&ret, loc_descriptor_from_tree_1 (offset, 0));\n+\t    ret1 = loc_descriptor_from_tree_1 (offset, 0);\n+\t    if (ret1 == 0)\n+\t      return 0;\n+\t    add_loc_descr (&ret, ret1);\n \t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n \t  }\n "}, {"sha": "cc430ac855968532fe07a55dc0ba740d5b39945c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "patch": "@@ -1,3 +1,8 @@\n+2008-09-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/37275\n+\t* gcc.target/i386/pr37275.c: New test.\n+\n 2008-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/static_initializer4.ads: New test."}, {"sha": "ca9612bba30478e4cebf1e0b71bc269796e1cf63", "filename": "gcc/testsuite/gcc.target/i386/pr37275.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37275.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37275.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37275.c?ref=9c2b3df10a547f360f7ee8b0393f4b7fa3e5014b", "patch": "@@ -0,0 +1,137 @@\n+/* PR middle-end/37275 */\n+/* { dg-do compile { target ilp32 } } */\n+/* { dg-options \"-g -dA -O2 -march=i686 -fstack-protector\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *malloc (size_t);\n+\n+typedef int A;\n+\n+struct B\n+{\n+  int x;\n+};\n+\n+struct C\n+{\n+  struct F *c1;\n+  void *c2;\n+};\n+\n+enum D\n+{\n+  D0,\n+  D1\n+};\n+\n+struct E\n+{\n+  struct E *e1;\n+  struct E *e2;\n+  struct B e3;\n+  void (*fn) (void *);\n+  void *fn_data;\n+  enum D e4;\n+  _Bool e5;\n+  _Bool e6;\n+};\n+\n+struct F\n+{\n+  unsigned f1;\n+  A f2;\n+  int f3;\n+};\n+\n+struct G\n+{\n+  void (*fn) (void *data);\n+  void *data;\n+  struct C g1;\n+  struct E *t;\n+};\n+\n+extern void fn1 (A * m);\n+static inline void\n+fn2 (A *x)\n+{\n+  if (!__sync_bool_compare_and_swap (x, 0, 1))\n+    fn1 (x);\n+}\n+\n+extern __thread struct G thr __attribute__ ((visibility (\"hidden\")));\n+static inline struct G *\n+fn3 (void)\n+{\n+  return &thr;\n+}\n+\n+extern struct B *fn4 (void);\n+extern struct B a;\n+\n+static inline struct B *\n+fn5 (_Bool x)\n+{\n+  struct E *t = fn3 ()->t;\n+  if (t)\n+    return &t->e3;\n+  else if (x)\n+    return fn4 ();\n+  else\n+    return &a;\n+}\n+\n+void\n+fn6 (struct E *t, struct E *e1_t,\n+\t\tstruct B *prev_e3)\n+{\n+  t->e1 = e1_t;\n+  t->e3 = *prev_e3;\n+  t->e4 = D0;\n+  t->e5 = 0;\n+  t->e6 = 0;\n+  t->e2 = ((void *) 0);\n+}\n+\n+void\n+test (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *), long x, long y, _Bool z)\n+{\n+  struct G *thr = fn3 ();\n+  struct F *c1 = thr->g1.c1;\n+  if (!z || c1 == 0 || (unsigned) c1->f3 > 64 * c1->f1)\n+    {\n+      struct E t;\n+\n+      fn6 (&t, thr->t, fn5 (0));\n+      if (thr->t)\n+\tt.e6 = thr->t->e6;\n+      thr->t = &t;\n+      if (__builtin_expect (cpyfn != ((void *) 0), 0))\n+\t{\n+\t  char buf[x + y - 1];\n+\t  char *arg = (char *) (((unsigned long) buf + y - 1)\n+\t\t\t\t& ~(unsigned long) (y - 1));\n+\t  cpyfn (arg, data);\n+\t  fn (arg);\n+\t}\n+    }\n+  else\n+    {\n+      struct E *t;\n+      struct E *e1 = thr->t;\n+      char *arg;\n+\n+      t = malloc (sizeof (*t) + x + y - 1);\n+      arg = (char *) (((unsigned long) (t + 1) + y - 1)\n+\t\t      & ~(unsigned long) (y - 1));\n+      fn6 (t, e1, fn5 (0));\n+      thr->t = t;\n+      if (cpyfn)\n+\tcpyfn (arg, data);\n+      else\n+\tmemcpy (arg, data, x);\n+      thr->t = e1;\n+      fn2 (&c1->f2);\n+    }\n+}"}]}