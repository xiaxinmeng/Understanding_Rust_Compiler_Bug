{"sha": "036165d8116610b18861941fed4080a93783f954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2MTY1ZDgxMTY2MTBiMTg4NjE5NDFmZWQ0MDgwYTkzNzgzZjk1NA==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-04-26T03:38:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-04-26T03:38:34Z"}, "message": "compiler: Use backend interface for defining global declarations.\n\n\t* go-gcc.cc: Include \"cgraph.h\" and \"gimplify.h\".\n\t(Gcc_backend::return_statement): Push and pop function.\n\t(Gcc_backend::label): Likewise.\n\t(Gcc_backend::function_defer_statement): Likewise.\n\t(Gcc_backend::switch_statement): Add function parameter.\n\t(Gcc_backend::block): Don't permit function to be NULL.\n\t(Gcc_backend::temporary_variable): Change go_assert to\n\tgcc_assert.\n\t(Gcc_backend::gc_root_variable): New function.\n\t(Gcc_backend::write_global_definitions): New function.\n\nFrom-SVN: r209819", "tree": {"sha": "93a36b3f34bf901b1b63907441f2986c34fe7d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a36b3f34bf901b1b63907441f2986c34fe7d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/036165d8116610b18861941fed4080a93783f954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036165d8116610b18861941fed4080a93783f954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036165d8116610b18861941fed4080a93783f954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036165d8116610b18861941fed4080a93783f954/comments", "author": null, "committer": null, "parents": [{"sha": "10695c6a1da3fef02b6842f10b8586ad38a94763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10695c6a1da3fef02b6842f10b8586ad38a94763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10695c6a1da3fef02b6842f10b8586ad38a94763"}], "stats": {"total": 2223, "additions": 1161, "deletions": 1062}, "files": [{"sha": "1a863b04dbce60eb6179f748f9fd319541f342f1", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -1,3 +1,16 @@\n+2014-04-25  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc: Include \"cgraph.h\" and \"gimplify.h\".\n+\t(Gcc_backend::return_statement): Push and pop function.\n+\t(Gcc_backend::label): Likewise.\n+\t(Gcc_backend::function_defer_statement): Likewise.\n+\t(Gcc_backend::switch_statement): Add function parameter.\n+\t(Gcc_backend::block): Don't permit function to be NULL.\n+\t(Gcc_backend::temporary_variable): Change go_assert to\n+\tgcc_assert.\n+\t(Gcc_backend::gc_root_variable): New function.\n+\t(Gcc_backend::write_global_definitions): New function.\n+\n 2014-04-22  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Gcc_backend::temporary_variable): Push cfun around"}, {"sha": "499b6702303202df1d393b08542752b8215300f8", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 155, "deletions": 13, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -29,9 +29,11 @@\n #include \"stor-layout.h\"\n #include \"varasm.h\"\n #include \"tree-iterator.h\"\n+#include \"cgraph.h\"\n #include \"convert.h\"\n #include \"basic-block.h\"\n #include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"real.h\"\n@@ -317,7 +319,7 @@ class Gcc_backend : public Backend\n \t       Location);\n \n   Bstatement*\n-  switch_statement(Bexpression* value,\n+  switch_statement(Bfunction* function, Bexpression* value,\n \t\t   const std::vector<std::vector<Bexpression*> >& cases,\n \t\t   const std::vector<Bstatement*>& statements,\n \t\t   Location);\n@@ -375,6 +377,9 @@ class Gcc_backend : public Backend\n   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, bool,\n \t\t     Location, Bstatement**);\n \n+  Bvariable*\n+  gc_root_variable(Btype*, Bexpression*);\n+\n   Bvariable*\n   immutable_struct(const std::string&, bool, bool, Btype*, Location);\n \n@@ -420,6 +425,12 @@ class Gcc_backend : public Backend\n   bool\n   function_set_body(Bfunction* function, Bstatement* code_stmt);\n \n+  void\n+  write_global_definitions(const std::vector<Btype*>&,\n+                           const std::vector<Bexpression*>&,\n+                           const std::vector<Bfunction*>&,\n+                           const std::vector<Bvariable*>&);\n+\n  private:\n   // Make a Bexpression from a tree.\n   Bexpression*\n@@ -1709,6 +1720,7 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n   tree result = DECL_RESULT(fntree);\n   if (result == error_mark_node)\n     return this->error_statement();\n+\n   tree ret;\n   if (vals.empty())\n     ret = fold_build1_loc(location.gcc_location(), RETURN_EXPR, void_type_node,\n@@ -1732,7 +1744,14 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n       // statement.\n       tree stmt_list = NULL_TREE;\n       tree rettype = TREE_TYPE(result);\n+\n+      if (DECL_STRUCT_FUNCTION(fntree) == NULL)\n+\tpush_struct_function(fntree);\n+      else\n+\tpush_cfun(DECL_STRUCT_FUNCTION(fntree));\n       tree rettmp = create_tmp_var(rettype, \"RESULT\");\n+      pop_cfun();\n+\n       tree field = TYPE_FIELDS(rettype);\n       for (std::vector<Bexpression*>::const_iterator p = vals.begin();\n \t   p != vals.end();\n@@ -1818,13 +1837,20 @@ Gcc_backend::if_statement(Bexpression* condition, Bblock* then_block,\n \n Bstatement*\n Gcc_backend::switch_statement(\n+    Bfunction* function,\n     Bexpression* value,\n     const std::vector<std::vector<Bexpression*> >& cases,\n     const std::vector<Bstatement*>& statements,\n     Location switch_location)\n {\n   gcc_assert(cases.size() == statements.size());\n \n+  tree decl = function->get_tree();\n+  if (DECL_STRUCT_FUNCTION(decl) == NULL)\n+    push_struct_function(decl);\n+  else\n+    push_cfun(DECL_STRUCT_FUNCTION(decl));\n+\n   tree stmt_list = NULL_TREE;\n   std::vector<std::vector<Bexpression*> >::const_iterator pc = cases.begin();\n   for (std::vector<Bstatement*>::const_iterator ps = statements.begin();\n@@ -1864,6 +1890,7 @@ Gcc_backend::switch_statement(\n \t  append_to_statement_list(t, &stmt_list);\n \t}\n     }\n+  pop_cfun();\n \n   tree tv = value->get_tree();\n   if (tv == error_mark_node)\n@@ -1922,13 +1949,7 @@ Gcc_backend::block(Bfunction* function, Bblock* enclosing,\n   tree block_tree = make_node(BLOCK);\n   if (enclosing == NULL)\n     {\n-      // FIXME: Permitting FUNCTION to be NULL is a temporary measure\n-      // until we have a proper representation of the init function.\n-      tree fndecl;\n-      if (function == NULL)\n-\tfndecl = current_function_decl;\n-      else\n-\tfndecl = function->get_tree();\n+      tree fndecl = function->get_tree();\n       gcc_assert(fndecl != NULL_TREE);\n \n       // We may have already created a block for local variables when\n@@ -1982,7 +2003,6 @@ Gcc_backend::block(Bfunction* function, Bblock* enclosing,\n                               void_type_node, BLOCK_VARS(block_tree),\n                               NULL_TREE, block_tree);\n   TREE_SIDE_EFFECTS(bind_tree) = 1;\n-\n   return new Bblock(bind_tree);\n }\n \n@@ -2214,7 +2234,7 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n       return this->error_variable();\n     }\n \n-  go_assert(function != NULL);\n+  gcc_assert(function != NULL);\n   tree decl = function->get_tree();\n \n   tree var;\n@@ -2263,6 +2283,28 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n   return new Bvariable(var);\n }\n \n+// Make a GC root variable.\n+\n+Bvariable*\n+Gcc_backend::gc_root_variable(Btype* type, Bexpression* init)\n+{\n+  tree type_tree = type->get_tree();\n+  tree init_tree = init->get_tree();\n+  if (type_tree == error_mark_node || init_tree == error_mark_node)\n+    return this->error_variable();\n+\n+  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n+                         create_tmp_var_name(\"gc\"), type_tree);\n+  DECL_EXTERNAL(decl) = 0;\n+  TREE_PUBLIC(decl) = 0;\n+  TREE_STATIC(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+  DECL_INITIAL(decl) = init_tree;\n+  rest_of_decl_compilation(decl, 1, 0);\n+\n+  return new Bvariable(decl);\n+}\n+\n // Create a named immutable initialized data structure.\n \n Bvariable*\n@@ -2277,9 +2319,9 @@ Gcc_backend::immutable_struct(const std::string& name, bool is_hidden,\n \t\t\t get_identifier_from_string(name),\n \t\t\t build_qualified_type(type_tree, TYPE_QUAL_CONST));\n   TREE_STATIC(decl) = 1;\n+  TREE_USED(decl) = 1;\n   TREE_READONLY(decl) = 1;\n   TREE_CONSTANT(decl) = 1;\n-  TREE_USED(decl) = 1;\n   DECL_ARTIFICIAL(decl) = 1;\n   if (!is_hidden)\n     TREE_PUBLIC(decl) = 1;\n@@ -2369,7 +2411,17 @@ Gcc_backend::label(Bfunction* function, const std::string& name,\n {\n   tree decl;\n   if (name.empty())\n-    decl = create_artificial_label(location.gcc_location());\n+    {\n+      tree func_tree = function->get_tree();\n+      if (DECL_STRUCT_FUNCTION(func_tree) == NULL)\n+\tpush_struct_function(func_tree);\n+      else\n+\tpush_cfun(DECL_STRUCT_FUNCTION(func_tree));\n+\n+      decl = create_artificial_label(location.gcc_location());\n+\n+      pop_cfun();\n+    }\n   else\n     {\n       tree id = get_identifier_from_string(name);\n@@ -2477,11 +2529,18 @@ Gcc_backend::function_defer_statement(Bfunction* function, Bexpression* undefer,\n {\n   tree undefer_tree = undefer->get_tree();\n   tree defer_tree = defer->get_tree();\n+  tree fntree = function->get_tree();\n \n   if (undefer_tree == error_mark_node\n-      || defer_tree == error_mark_node)\n+      || defer_tree == error_mark_node\n+      || fntree == error_mark_node)\n     return this->error_statement();\n \n+  if (DECL_STRUCT_FUNCTION(fntree) == NULL)\n+    push_struct_function(fntree);\n+  else\n+    push_cfun(DECL_STRUCT_FUNCTION(fntree));\n+\n   tree stmt_list = NULL;\n   Blabel* blabel = this->label(function, \"\", location);\n   Bstatement* label_def = this->label_definition_statement(blabel);\n@@ -2494,6 +2553,7 @@ Gcc_backend::function_defer_statement(Bfunction* function, Bexpression* undefer,\n   tree try_catch =\n       build2(TRY_CATCH_EXPR, void_type_node, undefer_tree, catch_body);\n   append_to_statement_list(try_catch, &stmt_list);\n+  pop_cfun();\n \n   return this->make_statement(stmt_list);\n }\n@@ -2538,6 +2598,88 @@ Gcc_backend::function_set_body(Bfunction* function, Bstatement* code_stmt)\n   return true;\n }\n \n+// Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n+// FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n+\n+void\n+Gcc_backend::write_global_definitions(\n+    const std::vector<Btype*>& type_decls,\n+    const std::vector<Bexpression*>& constant_decls,\n+    const std::vector<Bfunction*>& function_decls,\n+    const std::vector<Bvariable*>& variable_decls)\n+{\n+  size_t count_definitions = type_decls.size() + constant_decls.size()\n+      + function_decls.size() + variable_decls.size();\n+\n+  tree* defs = new tree[count_definitions];\n+\n+  // Convert all non-erroneous declarations into Gimple form.\n+  size_t i = 0;\n+  for (std::vector<Bvariable*>::const_iterator p = variable_decls.begin();\n+       p != variable_decls.end();\n+       ++p)\n+    {\n+      if ((*p)->get_tree() != error_mark_node)\n+        {\n+          defs[i] = (*p)->get_tree();\n+          go_preserve_from_gc(defs[i]);\n+          ++i;\n+        }\n+    }\n+\n+  for (std::vector<Btype*>::const_iterator p = type_decls.begin();\n+       p != type_decls.end();\n+       ++p)\n+    {\n+      tree type_tree = (*p)->get_tree();\n+      if (type_tree != error_mark_node\n+          && IS_TYPE_OR_DECL_P(type_tree))\n+        {\n+          defs[i] = TYPE_NAME(type_tree);\n+          gcc_assert(defs[i] != NULL);\n+          go_preserve_from_gc(defs[i]);\n+          ++i;\n+        }\n+    }\n+  for (std::vector<Bexpression*>::const_iterator p = constant_decls.begin();\n+       p != constant_decls.end();\n+       ++p)\n+    {\n+      if ((*p)->get_tree() != error_mark_node)\n+        {\n+          defs[i] = (*p)->get_tree();\n+          go_preserve_from_gc(defs[i]);\n+          ++i;\n+        }\n+    }\n+  for (std::vector<Bfunction*>::const_iterator p = function_decls.begin();\n+       p != function_decls.end();\n+       ++p)\n+    {\n+      tree decl = (*p)->get_tree();\n+      if (decl != error_mark_node)\n+        {\n+          go_preserve_from_gc(decl);\n+          gimplify_function_tree(decl);\n+          cgraph_finalize_function(decl, true);\n+\n+          defs[i] = decl;\n+          ++i;\n+        }\n+    }\n+\n+  // Pass everything back to the middle-end.\n+\n+  wrapup_global_declarations(defs, i);\n+\n+  finalize_compilation_unit();\n+\n+  check_global_declarations(defs, i);\n+  emit_debug_global_declarations(defs, i);\n+\n+  delete[] defs;\n+}\n+\n // The single backend.\n \n static Gcc_backend gcc_backend;"}, {"sha": "aca3dc6f90eb410e374c524fa5322111330eb938", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -406,9 +406,9 @@ class Backend\n   // integers, then STATEMENTS[i] is executed.  STATEMENTS[i] will\n   // either end with a goto statement or will fall through into\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n-  // which need not be last.\n+  // which need not be last.  FUNCTION is the current function.\n   virtual Bstatement*\n-  switch_statement(Bexpression* value,\n+  switch_statement(Bfunction* function, Bexpression* value,\n \t\t   const std::vector<std::vector<Bexpression*> >& cases,\n \t\t   const std::vector<Bstatement*>& statements,\n \t\t   Location) = 0;\n@@ -534,6 +534,12 @@ class Backend\n \t\t     bool address_is_taken, Location location,\n \t\t     Bstatement** pstatement) = 0;\n \n+  // Create a GC root variable. TYPE is the __go_gc_root_list struct described\n+  // in Gogo::register_gc_vars.  INIT is the composite literal consisting of a\n+  // pointer to the next GC root and the global variables registered.\n+  virtual Bvariable*\n+  gc_root_variable(Btype* type, Bexpression* init) = 0;\n+\n   // Create a named immutable initialized data structure.  This is\n   // used for type descriptors, map descriptors, and function\n   // descriptors.  This returns a Bvariable because it corresponds to\n@@ -653,6 +659,16 @@ class Backend\n   // true on success, false on failure.\n   virtual bool\n   function_set_body(Bfunction* function, Bstatement* code_stmt) = 0;\n+\n+  // Utility.\n+\n+  // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n+  // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n+  virtual void\n+  write_global_definitions(const std::vector<Btype*>& type_decls,\n+                           const std::vector<Bexpression*>& constant_decls,\n+                           const std::vector<Bfunction*>& function_decls,\n+                           const std::vector<Bvariable*>& variable_decls) = 0;\n };\n \n // The backend interface has to define this function."}, {"sha": "275626391767ebf0db179c8d18816f7d01b6ccef", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 123, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -3578,127 +3578,7 @@ Expression::make_unsafe_cast(Type* type, Expression* expr,\n   return new Unsafe_type_conversion_expression(type, expr, location);\n }\n \n-// Unary expressions.\n-\n-class Unary_expression : public Expression\n-{\n- public:\n-  Unary_expression(Operator op, Expression* expr, Location location)\n-    : Expression(EXPRESSION_UNARY, location),\n-      op_(op), escapes_(true), create_temp_(false), expr_(expr),\n-      issue_nil_check_(false)\n-  { }\n-\n-  // Return the operator.\n-  Operator\n-  op() const\n-  { return this->op_; }\n-\n-  // Return the operand.\n-  Expression*\n-  operand() const\n-  { return this->expr_; }\n-\n-  // Record that an address expression does not escape.\n-  void\n-  set_does_not_escape()\n-  {\n-    go_assert(this->op_ == OPERATOR_AND);\n-    this->escapes_ = false;\n-  }\n-\n-  // Record that this is an address expression which should create a\n-  // temporary variable if necessary.  This is used for method calls.\n-  void\n-  set_create_temp()\n-  {\n-    go_assert(this->op_ == OPERATOR_AND);\n-    this->create_temp_ = true;\n-  }\n-\n-  // Apply unary opcode OP to UNC, setting NC.  Return true if this\n-  // could be done, false if not.  Issue errors for overflow.\n-  static bool\n-  eval_constant(Operator op, const Numeric_constant* unc,\n-\t\tLocation, Numeric_constant* nc);\n-\n-  static Expression*\n-  do_import(Import*);\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse)\n-  { return Expression::traverse(&this->expr_, traverse); }\n-\n-  Expression*\n-  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  bool\n-  do_is_constant() const;\n-\n-  bool\n-  do_is_immutable() const\n-  { return this->expr_->is_immutable()\n-      || (this->op_ == OPERATOR_AND && this->expr_->is_variable()); }\n-\n-  bool\n-  do_numeric_constant_value(Numeric_constant*) const;\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return Expression::make_unary(this->op_, this->expr_->copy(),\n-\t\t\t\t  this->location());\n-  }\n-\n-  bool\n-  do_must_eval_subexpressions_in_order(int*) const\n-  { return this->op_ == OPERATOR_MULT; }\n-\n-  bool\n-  do_is_addressable() const\n-  { return this->op_ == OPERATOR_MULT; }\n-\n-  tree\n-  do_get_tree(Translate_context*);\n-\n-  void\n-  do_export(Export*) const;\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n-  void\n-  do_issue_nil_check()\n-  { this->issue_nil_check_ = (this->op_ == OPERATOR_MULT); }\n-\n- private:\n-  // The unary operator to apply.\n-  Operator op_;\n-  // Normally true.  False if this is an address expression which does\n-  // not escape the current function.\n-  bool escapes_;\n-  // True if this is an address expression which should create a\n-  // temporary variable if necessary.\n-  bool create_temp_;\n-  // The operand.\n-  Expression* expr_;\n-  // Whether or not to issue a nil check for this expression if its address\n-  // is being taken.\n-  bool issue_nil_check_;\n-};\n+// Class Unary_expression.\n \n // If we are taking the address of a composite literal, and the\n // contents are not constant, then we want to make a heap expression\n@@ -4214,11 +4094,18 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t    }\n \t}\n \n-      // Build a decl for a constant constructor.\n-      if ((this->expr_->is_composite_literal()\n+      if (this->is_gc_root_)\n+\t{\n+\t  // Build a decl for a GC root variable.  GC roots are mutable, so they\n+\t  // cannot be represented as an immutable_struct in the backend.\n+\t  Bvariable* gc_root = gogo->backend()->gc_root_variable(btype, bexpr);\n+\t  bexpr = gogo->backend()->var_expression(gc_root, loc);\n+\t}\n+      else if ((this->expr_->is_composite_literal()\n            || this->expr_->string_expression() != NULL)\n           && this->expr_->is_immutable())\n         {\n+\t  // Build a decl for a constant constructor.\n           static unsigned int counter;\n           char buf[100];\n           snprintf(buf, sizeof buf, \"C%u\", counter);\n@@ -12508,6 +12395,14 @@ Fixed_array_construction_expression::do_get_tree(Translate_context* context)\n   return expr_to_tree(this->get_constructor(context, btype));\n }\n \n+Expression*\n+Expression::make_array_composite_literal(Type* type, Expression_list* vals,\n+                                         Location location)\n+{\n+  go_assert(type->array_type() != NULL && !type->is_slice_type());\n+  return new Fixed_array_construction_expression(type, NULL, vals, location);\n+}\n+\n // Construct a slice.\n \n class Slice_construction_expression : public Array_construction_expression"}, {"sha": "0936e00bae0eae4ea75fd9fbd87c622104f30980", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -30,6 +30,7 @@ class Var_expression;\n class Temporary_reference_expression;\n class Set_and_use_temporary_expression;\n class String_expression;\n+class Unary_expression;\n class Binary_expression;\n class Call_expression;\n class Func_expression;\n@@ -327,6 +328,10 @@ class Expression\n   static Expression*\n   make_struct_composite_literal(Type*, Expression_list*, Location);\n \n+  // Make an array composite literal.\n+  static Expression*\n+  make_array_composite_literal(Type*, Expression_list*, Location);\n+\n   // Make a slice composite literal.\n   static Expression*\n   make_slice_composite_literal(Type*, Expression_list*, Location);\n@@ -533,6 +538,12 @@ class Expression\n   Expression*\n   deref();\n \n+  // If this is a unary expression, return the Unary_expression\n+  // structure.  Otherwise return NULL.\n+  Unary_expression*\n+  unary_expression()\n+  { return this->convert<Unary_expression, EXPRESSION_UNARY>(); }\n+\n   // If this is a binary expression, return the Binary_expression\n   // structure.  Otherwise return NULL.\n   Binary_expression*\n@@ -1286,6 +1297,143 @@ class String_expression : public Expression\n   Type* type_;\n };\n \n+// A Unary expression.\n+\n+class Unary_expression : public Expression\n+{\n+ public:\n+  Unary_expression(Operator op, Expression* expr, Location location)\n+    : Expression(EXPRESSION_UNARY, location),\n+      op_(op), escapes_(true), create_temp_(false), is_gc_root_(false),\n+      expr_(expr), issue_nil_check_(false)\n+  { }\n+\n+  // Return the operator.\n+  Operator\n+  op() const\n+  { return this->op_; }\n+\n+  // Return the operand.\n+  Expression*\n+  operand() const\n+  { return this->expr_; }\n+\n+  // Record that an address expression does not escape.\n+  void\n+  set_does_not_escape()\n+  {\n+    go_assert(this->op_ == OPERATOR_AND);\n+    this->escapes_ = false;\n+  }\n+\n+  // Record that this is an address expression which should create a\n+  // temporary variable if necessary.  This is used for method calls.\n+  void\n+  set_create_temp()\n+  {\n+    go_assert(this->op_ == OPERATOR_AND);\n+    this->create_temp_ = true;\n+  }\n+\n+  // Record that this is an address expression of a GC root, which is a\n+  // mutable composite literal.  This used for registering GC variables.\n+  void\n+  set_is_gc_root()\n+  {\n+    go_assert(this->op_ == OPERATOR_AND);\n+    this->is_gc_root_ = true;\n+  }\n+\n+  // Apply unary opcode OP to UNC, setting NC.  Return true if this\n+  // could be done, false if not.  Issue errors for overflow.\n+  static bool\n+  eval_constant(Operator op, const Numeric_constant* unc,\n+\t\tLocation, Numeric_constant* nc);\n+\n+  static Expression*\n+  do_import(Import*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return Expression::traverse(&this->expr_, traverse); }\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  bool\n+  do_is_constant() const;\n+\n+  bool\n+  do_is_immutable() const\n+  {\n+    return (this->expr_->is_immutable()\n+\t    || (this->op_ == OPERATOR_AND && this->expr_->is_variable()));\n+  }\n+\n+  bool\n+  do_numeric_constant_value(Numeric_constant*) const;\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_unary(this->op_, this->expr_->copy(),\n+\t\t\t\t  this->location());\n+  }\n+\n+  bool\n+  do_must_eval_subexpressions_in_order(int*) const\n+  { return this->op_ == OPERATOR_MULT; }\n+\n+  bool\n+  do_is_addressable() const\n+  { return this->op_ == OPERATOR_MULT; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+  void\n+  do_issue_nil_check()\n+  { this->issue_nil_check_ = (this->op_ == OPERATOR_MULT); }\n+\n+ private:\n+  // The unary operator to apply.\n+  Operator op_;\n+  // Normally true.  False if this is an address expression which does\n+  // not escape the current function.\n+  bool escapes_;\n+  // True if this is an address expression which should create a\n+  // temporary variable if necessary.\n+  bool create_temp_;\n+  // True if this is an address expression for a GC root.  A GC root is a\n+  // special struct composite literal that is mutable when addressed, meaning\n+  // it cannot be represented as an immutable_struct in the backend.\n+  bool is_gc_root_;\n+  // The operand.\n+  Expression* expr_;\n+  // Whether or not to issue a nil check for this expression if its address\n+  // is being taken.\n+  bool issue_nil_check_;\n+};\n+\n // A binary expression.\n \n class Binary_expression : public Expression"}, {"sha": "6b19a1d82e1bd8cd0b91c2aa5f64bf4f921ccc08", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 0, "deletions": 882, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -236,830 +236,6 @@ Gogo::define_builtin_function_trees()\n \t\t false);\n }\n \n-// Add statements to INIT_STMT_LIST which run the initialization\n-// functions for imported packages.  This is only used for the \"main\"\n-// package.\n-\n-void\n-Gogo::init_imports(tree* init_stmt_list)\n-{\n-  go_assert(this->is_main_package());\n-\n-  if (this->imported_init_fns_.empty())\n-    return;\n-\n-  tree fntype = build_function_type(void_type_node, void_list_node);\n-\n-  // We must call them in increasing priority order.\n-  std::vector<Import_init> v;\n-  for (std::set<Import_init>::const_iterator p =\n-\t this->imported_init_fns_.begin();\n-       p != this->imported_init_fns_.end();\n-       ++p)\n-    v.push_back(*p);\n-  std::sort(v.begin(), v.end());\n-\n-  for (std::vector<Import_init>::const_iterator p = v.begin();\n-       p != v.end();\n-       ++p)\n-    {\n-      std::string user_name = p->package_name() + \".init\";\n-      tree decl = build_decl(UNKNOWN_LOCATION, FUNCTION_DECL,\n-\t\t\t     get_identifier_from_string(user_name),\n-\t\t\t     fntype);\n-      const std::string& init_name(p->init_name());\n-      SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(init_name));\n-      TREE_PUBLIC(decl) = 1;\n-      DECL_EXTERNAL(decl) = 1;\n-      append_to_statement_list(build_call_expr(decl, 0), init_stmt_list);\n-    }\n-}\n-\n-// Register global variables with the garbage collector.  We need to\n-// register all variables which can hold a pointer value.  They become\n-// roots during the mark phase.  We build a struct that is easy to\n-// hook into a list of roots.\n-\n-// struct __go_gc_root_list\n-// {\n-//   struct __go_gc_root_list* __next;\n-//   struct __go_gc_root\n-//   {\n-//     void* __decl;\n-//     size_t __size;\n-//   } __roots[];\n-// };\n-\n-// The last entry in the roots array has a NULL decl field.\n-\n-void\n-Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n-\t\t       tree* init_stmt_list)\n-{\n-  if (var_gc.empty())\n-    return;\n-\n-  size_t count = var_gc.size();\n-\n-  tree root_type = Gogo::builtin_struct(NULL, \"__go_gc_root\", NULL_TREE, 2,\n-\t\t\t\t\t\"__next\",\n-\t\t\t\t\tptr_type_node,\n-\t\t\t\t\t\"__size\",\n-\t\t\t\t\tsizetype);\n-\n-  tree index_type = build_index_type(size_int(count));\n-  tree array_type = build_array_type(root_type, index_type);\n-\n-  tree root_list_type = make_node(RECORD_TYPE);\n-  root_list_type = Gogo::builtin_struct(NULL, \"__go_gc_root_list\",\n-\t\t\t\t\troot_list_type, 2,\n-\t\t\t\t\t\"__next\",\n-\t\t\t\t\tbuild_pointer_type(root_list_type),\n-\t\t\t\t\t\"__roots\",\n-\t\t\t\t\tarray_type);\n-\n-  // Build an initialier for the __roots array.\n-\n-  vec<constructor_elt, va_gc> *roots_init;\n-  vec_alloc(roots_init, count + 1);\n-\n-  size_t i = 0;\n-  for (std::vector<Named_object*>::const_iterator p = var_gc.begin();\n-       p != var_gc.end();\n-       ++p, ++i)\n-    {\n-      vec<constructor_elt, va_gc> *init;\n-      vec_alloc(init, 2);\n-\n-      constructor_elt empty = {NULL, NULL};\n-      constructor_elt* elt = init->quick_push(empty);\n-      tree field = TYPE_FIELDS(root_type);\n-      elt->index = field;\n-      Bvariable* bvar = (*p)->get_backend_variable(this, NULL);\n-      tree decl = var_to_tree(bvar);\n-      go_assert(TREE_CODE(decl) == VAR_DECL);\n-      elt->value = build_fold_addr_expr(decl);\n-\n-      elt = init->quick_push(empty);\n-      field = DECL_CHAIN(field);\n-      elt->index = field;\n-      elt->value = DECL_SIZE_UNIT(decl);\n-\n-      elt = roots_init->quick_push(empty);\n-      elt->index = size_int(i);\n-      elt->value = build_constructor(root_type, init);\n-    }\n-\n-  // The list ends with a NULL entry.\n-\n-  vec<constructor_elt, va_gc> *init;\n-  vec_alloc(init, 2);\n-\n-  constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = init->quick_push(empty);\n-  tree field = TYPE_FIELDS(root_type);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n-\n-  elt = init->quick_push(empty);\n-  field = DECL_CHAIN(field);\n-  elt->index = field;\n-  elt->value = size_zero_node;\n-\n-  elt = roots_init->quick_push(empty);\n-  elt->index = size_int(i);\n-  elt->value = build_constructor(root_type, init);\n-\n-  // Build a constructor for the struct.\n-\n-  vec<constructor_elt, va_gc> *root_list_init;\n-  vec_alloc(root_list_init, 2);\n-\n-  elt = root_list_init->quick_push(empty);\n-  field = TYPE_FIELDS(root_list_type);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n-\n-  elt = root_list_init->quick_push(empty);\n-  field = DECL_CHAIN(field);\n-  elt->index = field;\n-  elt->value = build_constructor(array_type, roots_init);\n-\n-  // Build a decl to register.\n-\n-  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n-\t\t\t create_tmp_var_name(\"gc\"), root_list_type);\n-  DECL_EXTERNAL(decl) = 0;\n-  TREE_PUBLIC(decl) = 0;\n-  TREE_STATIC(decl) = 1;\n-  DECL_ARTIFICIAL(decl) = 1;\n-  DECL_INITIAL(decl) = build_constructor(root_list_type, root_list_init);\n-  rest_of_decl_compilation(decl, 1, 0);\n-\n-  static tree register_gc_fndecl;\n-  tree call = Gogo::call_builtin(&register_gc_fndecl,\n-                                 Linemap::predeclared_location(),\n-                                 \"__go_register_gc_roots\",\n-\t\t\t\t 1,\n-\t\t\t\t void_type_node,\n-\t\t\t\t build_pointer_type(root_list_type),\n-\t\t\t\t build_fold_addr_expr(decl));\n-  if (call != error_mark_node)\n-    append_to_statement_list(call, init_stmt_list);\n-}\n-\n-// Create the magic initialization function.  INIT_STMT_LIST is the\n-// code that it needs to run.\n-\n-void\n-Gogo::write_initialization_function(Named_object* initfn, tree init_stmt_list)\n-{\n-  // Make sure that we thought we needed an initialization function,\n-  // as otherwise we will not have reported it in the export data.\n-  go_assert(this->is_main_package() || this->need_init_fn_);\n-\n-  if (initfn == NULL)\n-    initfn = this->initialization_function_decl();\n-\n-  Bfunction* fndecl = initfn->func_value()->get_or_make_decl(this, initfn);\n-  Location loc = this->package_->location();\n-  std::vector<Bvariable*> vars;\n-  this->backend()->block(fndecl, NULL, vars, loc, loc);\n-\n-  if (!this->backend()->function_set_body(fndecl, tree_to_stat(init_stmt_list)))\n-    {\n-      go_assert(saw_errors());\n-      return;\n-    }\n-  gimplify_function_tree(function_to_tree(fndecl));\n-  cgraph_add_new_function(function_to_tree(fndecl), false);\n-}\n-\n-// Search for references to VAR in any statements or called functions.\n-\n-class Find_var : public Traverse\n-{\n- public:\n-  // A hash table we use to avoid looping.  The index is the name of a\n-  // named object.  We only look through objects defined in this\n-  // package.\n-  typedef Unordered_set(const void*) Seen_objects;\n-\n-  Find_var(Named_object* var, Seen_objects* seen_objects)\n-    : Traverse(traverse_expressions),\n-      var_(var), seen_objects_(seen_objects), found_(false)\n-  { }\n-\n-  // Whether the variable was found.\n-  bool\n-  found() const\n-  { return this->found_; }\n-\n-  int\n-  expression(Expression**);\n-\n- private:\n-  // The variable we are looking for.\n-  Named_object* var_;\n-  // Names of objects we have already seen.\n-  Seen_objects* seen_objects_;\n-  // True if the variable was found.\n-  bool found_;\n-};\n-\n-// See if EXPR refers to VAR, looking through function calls and\n-// variable initializations.\n-\n-int\n-Find_var::expression(Expression** pexpr)\n-{\n-  Expression* e = *pexpr;\n-\n-  Var_expression* ve = e->var_expression();\n-  if (ve != NULL)\n-    {\n-      Named_object* v = ve->named_object();\n-      if (v == this->var_)\n-\t{\n-\t  this->found_ = true;\n-\t  return TRAVERSE_EXIT;\n-\t}\n-\n-      if (v->is_variable() && v->package() == NULL)\n-\t{\n-\t  Expression* init = v->var_value()->init();\n-\t  if (init != NULL)\n-\t    {\n-\t      std::pair<Seen_objects::iterator, bool> ins =\n-\t\tthis->seen_objects_->insert(v);\n-\t      if (ins.second)\n-\t\t{\n-\t\t  // This is the first time we have seen this name.\n-\t\t  if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  // We traverse the code of any function we see.  Note that this\n-  // means that we will traverse the code of a function whose address\n-  // is taken even if it is not called.\n-  Func_expression* fe = e->func_expression();\n-  if (fe != NULL)\n-    {\n-      const Named_object* f = fe->named_object();\n-      if (f->is_function() && f->package() == NULL)\n-\t{\n-\t  std::pair<Seen_objects::iterator, bool> ins =\n-\t    this->seen_objects_->insert(f);\n-\t  if (ins.second)\n-\t    {\n-\t      // This is the first time we have seen this name.\n-\t      if (f->func_value()->block()->traverse(this) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n-\t}\n-    }\n-\n-  Temporary_reference_expression* tre = e->temporary_reference_expression();\n-  if (tre != NULL)\n-    {\n-      Temporary_statement* ts = tre->statement();\n-      Expression* init = ts->init();\n-      if (init != NULL)\n-\t{\n-\t  std::pair<Seen_objects::iterator, bool> ins =\n-\t    this->seen_objects_->insert(ts);\n-\t  if (ins.second)\n-\t    {\n-\t      // This is the first time we have seen this temporary\n-\t      // statement.\n-\t      if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n-\t}\n-    }\n-\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Return true if EXPR, PREINIT, or DEP refers to VAR.\n-\n-static bool\n-expression_requires(Expression* expr, Block* preinit, Named_object* dep,\n-\t\t    Named_object* var)\n-{\n-  Find_var::Seen_objects seen_objects;\n-  Find_var find_var(var, &seen_objects);\n-  if (expr != NULL)\n-    Expression::traverse(&expr, &find_var);\n-  if (preinit != NULL)\n-    preinit->traverse(&find_var);\n-  if (dep != NULL)\n-    {\n-      Expression* init = dep->var_value()->init();\n-      if (init != NULL)\n-\tExpression::traverse(&init, &find_var);\n-      if (dep->var_value()->has_pre_init())\n-\tdep->var_value()->preinit()->traverse(&find_var);\n-    }\n-\n-  return find_var.found();\n-}\n-\n-// Sort variable initializations.  If the initialization expression\n-// for variable A refers directly or indirectly to the initialization\n-// expression for variable B, then we must initialize B before A.\n-\n-class Var_init\n-{\n- public:\n-  Var_init()\n-    : var_(NULL), init_(NULL)\n-  { }\n-\n-  Var_init(Named_object* var, Bstatement* init)\n-    : var_(var), init_(init)\n-  { }\n-\n-  // Return the variable.\n-  Named_object*\n-  var() const\n-  { return this->var_; }\n-\n-  // Return the initialization expression.\n-  Bstatement*\n-  init() const\n-  { return this->init_; }\n-\n- private:\n-  // The variable being initialized.\n-  Named_object* var_;\n-  // The initialization statement.\n-  Bstatement* init_;\n-};\n-\n-typedef std::list<Var_init> Var_inits;\n-\n-// Sort the variable initializations.  The rule we follow is that we\n-// emit them in the order they appear in the array, except that if the\n-// initialization expression for a variable V1 depends upon another\n-// variable V2 then we initialize V1 after V2.\n-\n-static void\n-sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n-{\n-  typedef std::pair<Named_object*, Named_object*> No_no;\n-  typedef std::map<No_no, bool> Cache;\n-  Cache cache;\n-\n-  Var_inits ready;\n-  while (!var_inits->empty())\n-    {\n-      Var_inits::iterator p1 = var_inits->begin();\n-      Named_object* var = p1->var();\n-      Expression* init = var->var_value()->init();\n-      Block* preinit = var->var_value()->preinit();\n-      Named_object* dep = gogo->var_depends_on(var->var_value());\n-\n-      // Start walking through the list to see which variables VAR\n-      // needs to wait for.\n-      Var_inits::iterator p2 = p1;\n-      ++p2;\n-\n-      for (; p2 != var_inits->end(); ++p2)\n-\t{\n-\t  Named_object* p2var = p2->var();\n-\t  No_no key(var, p2var);\n-\t  std::pair<Cache::iterator, bool> ins =\n-\t    cache.insert(std::make_pair(key, false));\n-\t  if (ins.second)\n-\t    ins.first->second = expression_requires(init, preinit, dep, p2var);\n-\t  if (ins.first->second)\n-\t    {\n-\t      // Check for cycles.\n-\t      key = std::make_pair(p2var, var);\n-\t      ins = cache.insert(std::make_pair(key, false));\n-\t      if (ins.second)\n-\t\tins.first->second =\n-\t\t  expression_requires(p2var->var_value()->init(),\n-\t\t\t\t      p2var->var_value()->preinit(),\n-\t\t\t\t      gogo->var_depends_on(p2var->var_value()),\n-\t\t\t\t      var);\n-\t      if (ins.first->second)\n-\t\t{\n-\t\t  error_at(var->location(),\n-\t\t\t   (\"initialization expressions for %qs and \"\n-\t\t\t    \"%qs depend upon each other\"),\n-\t\t\t   var->message_name().c_str(),\n-\t\t\t   p2var->message_name().c_str());\n-\t\t  inform(p2->var()->location(), \"%qs defined here\",\n-\t\t\t p2var->message_name().c_str());\n-\t\t  p2 = var_inits->end();\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // We can't emit P1 until P2 is emitted.  Move P1.\n-\t\t  Var_inits::iterator p3 = p2;\n-\t\t  ++p3;\n-\t\t  var_inits->splice(p3, *var_inits, p1);\n-\t\t}\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (p2 == var_inits->end())\n-\t{\n-\t  // VAR does not depends upon any other initialization expressions.\n-\n-\t  // Check for a loop of VAR on itself.  We only do this if\n-\t  // INIT is not NULL and there is no dependency; when INIT is\n-\t  // NULL, it means that PREINIT sets VAR, which we will\n-\t  // interpret as a loop.\n-\t  if (init != NULL && dep == NULL\n-\t      && expression_requires(init, preinit, NULL, var))\n-\t    error_at(var->location(),\n-\t\t     \"initialization expression for %qs depends upon itself\",\n-\t\t     var->message_name().c_str());\n-\t  ready.splice(ready.end(), *var_inits, p1);\n-\t}\n-    }\n-\n-  // Now READY is the list in the desired initialization order.\n-  var_inits->swap(ready);\n-}\n-\n-// Write out the global definitions.\n-\n-void\n-Gogo::write_globals()\n-{\n-  this->build_interface_method_tables();\n-\n-  Bindings* bindings = this->current_bindings();\n-\n-  for (Bindings::const_declarations_iterator p = bindings->begin_declarations();\n-       p != bindings->end_declarations();\n-       ++p)\n-    {\n-      // If any function declarations needed a descriptor, make sure\n-      // we build it.\n-      Named_object* no = p->second;\n-      if (no->is_function_declaration())\n-\tno->func_declaration_value()->build_backend_descriptor(this);\n-    }\n-\n-  size_t count_definitions = bindings->size_definitions();\n-  size_t count = count_definitions;\n-\n-  tree* vec = new tree[count];\n-\n-  Named_object* init_fndecl = NULL;\n-  tree init_stmt_list = NULL_TREE;\n-\n-  if (this->is_main_package())\n-    this->init_imports(&init_stmt_list);\n-\n-  // A list of variable initializations.\n-  Var_inits var_inits;\n-\n-  // A list of variables which need to be registered with the garbage\n-  // collector.\n-  std::vector<Named_object*> var_gc;\n-  var_gc.reserve(count);\n-\n-  tree var_init_stmt_list = NULL_TREE;\n-  size_t i = 0;\n-  for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n-       p != bindings->end_definitions();\n-       ++p, ++i)\n-    {\n-      Named_object* no = *p;\n-\n-      go_assert(i < count);\n-\n-      go_assert(!no->is_type_declaration() && !no->is_function_declaration());\n-      // There is nothing to do for a package.\n-      if (no->is_package())\n-\t{\n-\t  --i;\n-\t  --count;\n-\t  continue;\n-\t}\n-\n-      // There is nothing to do for an object which was imported from\n-      // a different package into the global scope.\n-      if (no->package() != NULL)\n-\t{\n-\t  --i;\n-\t  --count;\n-\t  continue;\n-\t}\n-\n-      // Skip blank named functions and constants.\n-      if ((no->is_function() && no->func_value()->is_sink())\n-\t  || (no->is_const() && no->const_value()->is_sink()))\n-        {\n-          --i;\n-          --count;\n-          continue;\n-        }\n-\n-      // There is nothing useful we can output for constants which\n-      // have ideal or non-integral type.\n-      if (no->is_const())\n-\t{\n-\t  Type* type = no->const_value()->type();\n-\t  if (type == NULL)\n-\t    type = no->const_value()->expr()->type();\n-\t  if (type->is_abstract() || type->integer_type() == NULL)\n-\t    {\n-\t      --i;\n-\t      --count;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (!no->is_variable())\n-\t{\n-\t  vec[i] = no->get_tree(this, NULL);\n-\t  if (vec[i] == error_mark_node)\n-\t    {\n-\t      go_assert(saw_errors());\n-\t      --i;\n-\t      --count;\n-\t      continue;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  Bvariable* var = no->get_backend_variable(this, NULL);\n-\t  vec[i] = var_to_tree(var);\n-\t  if (vec[i] == error_mark_node)\n-\t    {\n-\t      go_assert(saw_errors());\n-\t      --i;\n-\t      --count;\n-\t      continue;\n-\t    }\n-\n-\t  // Check for a sink variable, which may be used to run an\n-\t  // initializer purely for its side effects.\n-\t  bool is_sink = no->name()[0] == '_' && no->name()[1] == '.';\n-\n-          Bstatement* var_init_stmt = NULL;\n-\t  if (!no->var_value()->has_pre_init())\n-\t    {\n-              Bexpression* var_binit = no->var_value()->get_init(this, NULL);\n-              if (var_binit == NULL)\n-\t\t;\n-\t      else if (TREE_CONSTANT(expr_to_tree(var_binit)))\n-\t\t{\n-\t\t  if (expression_requires(no->var_value()->init(), NULL,\n-\t\t\t\t\t  this->var_depends_on(no->var_value()),\n-\t\t\t\t\t  no))\n-\t\t    error_at(no->location(),\n-\t\t\t     \"initialization expression for %qs depends \"\n-\t\t\t     \"upon itself\",\n-\t\t\t     no->message_name().c_str());\n-\t\t  this->backend()->global_variable_set_init(var, var_binit);\n-\t\t}\n-\t      else if (is_sink)\n-\t\tvar_init_stmt =\n-                    this->backend()->expression_statement(var_binit);\n-\t      else\n-                {\n-                  Location loc = no->var_value()->location();\n-                  Bexpression* var_expr =\n-                      this->backend()->var_expression(var, loc);\n-                  var_init_stmt =\n-                      this->backend()->assignment_statement(var_expr, var_binit,\n-                                                            loc);\n-                }\n-\t    }\n-\t  else\n-\t    {\n-\t      // We are going to create temporary variables which\n-\t      // means that we need an fndecl.\n-\t      if (init_fndecl == NULL)\n-\t\tinit_fndecl = this->initialization_function_decl();\n-\n-\t      Bvariable* var_decl = is_sink ? NULL : var;\n-              var_init_stmt =\n-                  no->var_value()->get_init_block(this, init_fndecl, var_decl);\n-\t    }\n-\n-\t  if (var_init_stmt != NULL)\n-\t    {\n-\t      if (no->var_value()->init() == NULL\n-\t\t  && !no->var_value()->has_pre_init())\n-\t\tappend_to_statement_list(stat_to_tree(var_init_stmt),\n-                                         &var_init_stmt_list);\n-\t      else\n-\t\tvar_inits.push_back(Var_init(no, var_init_stmt));\n-\t    }\n-\t  else if (this->var_depends_on(no->var_value()) != NULL)\n-\t    {\n-\t      // This variable is initialized from something that is\n-\t      // not in its init or preinit.  This variable needs to\n-\t      // participate in dependency analysis sorting, in case\n-\t      // some other variable depends on this one.\n-              Btype* int_btype =\n-                  Type::lookup_integer_type(\"int\")->get_backend(this);\n-              Bexpression* zero = this->backend()->zero_expression(int_btype);\n-              Bstatement* zero_stmt =\n-                  this->backend()->expression_statement(zero);\n-\t      var_inits.push_back(Var_init(no, zero_stmt));\n-\t    }\n-\n-\t  if (!is_sink && no->var_value()->type()->has_pointer())\n-\t    var_gc.push_back(no);\n-\t}\n-    }\n-\n-  // Register global variables with the garbage collector.\n-  this->register_gc_vars(var_gc, &init_stmt_list);\n-\n-  // Simple variable initializations, after all variables are\n-  // registered.\n-  append_to_statement_list(var_init_stmt_list, &init_stmt_list);\n-\n-  // Complex variable initializations, first sorting them into a\n-  // workable order.\n-  if (!var_inits.empty())\n-    {\n-      sort_var_inits(this, &var_inits);\n-      for (Var_inits::const_iterator p = var_inits.begin();\n-\t   p != var_inits.end();\n-\t   ++p)\n-\tappend_to_statement_list(stat_to_tree(p->init()), &init_stmt_list);\n-    }\n-\n-  // After all the variables are initialized, call the \"init\"\n-  // functions if there are any.\n-  for (std::vector<Named_object*>::const_iterator p =\n-\t this->init_functions_.begin();\n-       p != this->init_functions_.end();\n-       ++p)\n-    {\n-      tree decl = (*p)->get_tree(this, NULL);\n-      tree call = build_call_expr(decl, 0);\n-      append_to_statement_list(call, &init_stmt_list);\n-    }\n-\n-  // Set up a magic function to do all the initialization actions.\n-  // This will be called if this package is imported.\n-  if (init_stmt_list != NULL\n-      || this->need_init_fn_\n-      || this->is_main_package())\n-    this->write_initialization_function(init_fndecl, init_stmt_list);\n-\n-  // We should not have seen any new bindings created during the\n-  // conversion.\n-  go_assert(count_definitions == this->current_bindings()->size_definitions());\n-\n-  // Pass everything back to the middle-end.\n-\n-  wrapup_global_declarations(vec, count);\n-\n-  finalize_compilation_unit();\n-\n-  check_global_declarations(vec, count);\n-  emit_debug_global_declarations(vec, count);\n-\n-  delete[] vec;\n-}\n-\n-// Get a tree for a named object.\n-\n-tree\n-Named_object::get_tree(Gogo* gogo, Named_object* function)\n-{\n-  if (this->tree_ != NULL_TREE)\n-    return this->tree_;\n-\n-  if (Gogo::is_erroneous_name(this->name_))\n-    {\n-      this->tree_ = error_mark_node;\n-      return error_mark_node;\n-    }\n-\n-  tree decl;\n-  switch (this->classification_)\n-    {\n-    case NAMED_OBJECT_CONST:\n-      {\n-\tTranslate_context subcontext(gogo, function, NULL, NULL);\n-\tType* type = this->u_.const_value->type();\n-\tLocation loc = this->location();\n-\n-\tExpression* const_ref = Expression::make_const_reference(this, loc);\n-        Bexpression* const_decl =\n-\t  tree_to_expr(const_ref->get_tree(&subcontext));\n-\tif (type != NULL && type->is_numeric_type())\n-\t  {\n-\t    Btype* btype = type->get_backend(gogo);\n-\t    std::string name = this->get_id(gogo);\n-            const_decl =\n-\t      gogo->backend()->named_constant_expression(btype, name,\n-\t\t\t\t\t\t\t const_decl, loc);\n-\t  }\n-\tdecl = expr_to_tree(const_decl);\n-      }\n-      break;\n-\n-    case NAMED_OBJECT_TYPE:\n-      {\n-\tNamed_type* named_type = this->u_.type_value;\n-\ttree type_tree = type_to_tree(named_type->get_backend(gogo));\n-\tif (type_tree == error_mark_node)\n-\t  decl = error_mark_node;\n-\telse\n-\t  {\n-\t    decl = TYPE_NAME(type_tree);\n-\t    go_assert(decl != NULL_TREE);\n-\n-\t    // We need to produce a type descriptor for every named\n-\t    // type, and for a pointer to every named type, since\n-\t    // other files or packages might refer to them.  We need\n-\t    // to do this even for hidden types, because they might\n-\t    // still be returned by some function.  Simply calling the\n-\t    // type_descriptor method is enough to create the type\n-\t    // descriptor, even though we don't do anything with it.\n-\t    if (this->package_ == NULL)\n-\t      {\n-\t\tnamed_type->\n-                  type_descriptor_pointer(gogo,\n-\t\t\t\t\t  Linemap::predeclared_location());\n-\t\tType* pn = Type::make_pointer_type(named_type);\n-\t\tpn->type_descriptor_pointer(gogo,\n-\t\t\t\t\t    Linemap::predeclared_location());\n-\t      }\n-\t  }\n-      }\n-      break;\n-\n-    case NAMED_OBJECT_TYPE_DECLARATION:\n-      error(\"reference to undefined type %qs\",\n-\t    this->message_name().c_str());\n-      return error_mark_node;\n-\n-    case NAMED_OBJECT_VAR:\n-    case NAMED_OBJECT_RESULT_VAR:\n-    case NAMED_OBJECT_SINK:\n-      go_unreachable();\n-\n-    case NAMED_OBJECT_FUNC:\n-      {\n-\tFunction* func = this->u_.func_value;\n-\tdecl = function_to_tree(func->get_or_make_decl(gogo, this));\n-\tif (decl != error_mark_node)\n-\t  {\n-\t    if (func->block() != NULL)\n-\t      {\n-\t\tif (DECL_STRUCT_FUNCTION(decl) == NULL)\n-\t\t  push_struct_function(decl);\n-\t\telse\n-\t\t  push_cfun(DECL_STRUCT_FUNCTION(decl));\n-\n-\t\tcfun->function_start_locus = func->location().gcc_location();\n-\t\tcfun->function_end_locus =\n-                  func->block()->end_location().gcc_location();\n-\n-\t\tfunc->build(gogo, this);\n-\n-\t\tgimplify_function_tree(decl);\n-\n-\t\tcgraph_finalize_function(decl, true);\n-\n-\t\tpop_cfun();\n-\t      }\n-\t  }\n-      }\n-      break;\n-\n-    case NAMED_OBJECT_ERRONEOUS:\n-      decl = error_mark_node;\n-      break;\n-\n-    default:\n-      go_unreachable();\n-    }\n-\n-  if (TREE_TYPE(decl) == error_mark_node)\n-    decl = error_mark_node;\n-\n-  tree ret = decl;\n-\n-  this->tree_ = ret;\n-\n-  if (ret != error_mark_node)\n-    go_preserve_from_gc(ret);\n-\n-  return ret;\n-}\n-\n // Get the backend representation.\n \n Bfunction*\n@@ -1106,15 +282,6 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n   return this->fndecl_;\n }\n \n-// Return the function's decl after it has been built.\n-\n-tree\n-Function::get_decl() const\n-{\n-  go_assert(this->fndecl_ != NULL);\n-  return function_to_tree(this->fndecl_);\n-}\n-\n // Build the descriptor for a function declaration.  This won't\n // necessarily happen if the package has just a declaration for the\n // function and no other reference to it, but we may still need the\n@@ -1214,55 +381,6 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n     return NULL_TREE;\n }\n \n-// Build a builtin struct with a list of fields.  The name is\n-// STRUCT_NAME.  STRUCT_TYPE is NULL_TREE or an empty RECORD_TYPE\n-// node; this exists so that the struct can have fields which point to\n-// itself.  If PTYPE is not NULL, store the result in *PTYPE.  There\n-// are NFIELDS fields.  Each field is a name (a const char*) followed\n-// by a type (a tree).\n-\n-tree\n-Gogo::builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n-\t\t     int nfields, ...)\n-{\n-  if (ptype != NULL && *ptype != NULL_TREE)\n-    return *ptype;\n-\n-  va_list ap;\n-  va_start(ap, nfields);\n-\n-  tree fields = NULL_TREE;\n-  for (int i = 0; i < nfields; ++i)\n-    {\n-      const char* field_name = va_arg(ap, const char*);\n-      tree type = va_arg(ap, tree);\n-      if (type == error_mark_node)\n-\t{\n-\t  if (ptype != NULL)\n-\t    *ptype = error_mark_node;\n-\t  return error_mark_node;\n-\t}\n-      tree field = build_decl(BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t      get_identifier(field_name), type);\n-      DECL_CHAIN(field) = fields;\n-      fields = field;\n-    }\n-\n-  va_end(ap);\n-\n-  if (struct_type == NULL_TREE)\n-    struct_type = make_node(RECORD_TYPE);\n-  finish_builtin_struct(struct_type, struct_name, fields, NULL_TREE);\n-\n-  if (ptype != NULL)\n-    {\n-      go_preserve_from_gc(struct_type);\n-      *ptype = struct_type;\n-    }\n-\n-  return struct_type;\n-}\n-\n // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n // the slice.  VALUES is the value pointer and COUNT is the number of\n // entries.  If CAPACITY is not NULL, it is the capacity; otherwise"}, {"sha": "c6ff9886090fb77dbf1d52893f1123aaf10bbd12", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 781, "deletions": 12, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -575,6 +575,164 @@ Gogo::current_bindings() const\n     return this->globals_;\n }\n \n+// Add statements to INIT_STMTS which run the initialization\n+// functions for imported packages.  This is only used for the \"main\"\n+// package.\n+\n+void\n+Gogo::init_imports(std::vector<Bstatement*>& init_stmts)\n+{\n+  go_assert(this->is_main_package());\n+\n+  if (this->imported_init_fns_.empty())\n+    return;\n+\n+  Location unknown_loc = Linemap::unknown_location();\n+  Function_type* func_type =\n+      Type::make_function_type(NULL, NULL, NULL, unknown_loc);\n+  Btype* fntype = func_type->get_backend_fntype(this);\n+\n+  // We must call them in increasing priority order.\n+  std::vector<Import_init> v;\n+  for (std::set<Import_init>::const_iterator p =\n+\t this->imported_init_fns_.begin();\n+       p != this->imported_init_fns_.end();\n+       ++p)\n+    v.push_back(*p);\n+  std::sort(v.begin(), v.end());\n+\n+  // We build calls to the init functions, which take no arguments.\n+  std::vector<Bexpression*> empty_args;\n+  for (std::vector<Import_init>::const_iterator p = v.begin();\n+       p != v.end();\n+       ++p)\n+    {\n+      std::string user_name = p->package_name() + \".init\";\n+      const std::string& init_name(p->init_name());\n+\n+      Bfunction* pfunc = this->backend()->function(fntype, user_name, init_name,\n+                                                   true, true, true, false,\n+                                                   false, unknown_loc);\n+      Bexpression* pfunc_code =\n+          this->backend()->function_code_expression(pfunc, unknown_loc);\n+      Bexpression* pfunc_call =\n+          this->backend()->call_expression(pfunc_code, empty_args, unknown_loc);\n+      init_stmts.push_back(this->backend()->expression_statement(pfunc_call));\n+    }\n+}\n+\n+// Register global variables with the garbage collector.  We need to\n+// register all variables which can hold a pointer value.  They become\n+// roots during the mark phase.  We build a struct that is easy to\n+// hook into a list of roots.\n+\n+// struct __go_gc_root_list\n+// {\n+//   struct __go_gc_root_list* __next;\n+//   struct __go_gc_root\n+//   {\n+//     void* __decl;\n+//     size_t __size;\n+//   } __roots[];\n+// };\n+\n+// The last entry in the roots array has a NULL decl field.\n+\n+void\n+Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n+\t\t       std::vector<Bstatement*>& init_stmts)\n+{\n+  if (var_gc.empty())\n+    return;\n+\n+  Type* pvt = Type::make_pointer_type(Type::make_void_type());\n+  Type* uint_type = Type::lookup_integer_type(\"uint\");\n+  Struct_type* root_type = Type::make_builtin_struct_type(2,\n+                                                          \"__decl\", pvt,\n+                                                          \"__size\", uint_type);\n+\n+  Location builtin_loc = Linemap::predeclared_location();\n+  size_t count = var_gc.size();\n+  mpz_t lenval;\n+  mpz_init_set_ui(lenval, count);\n+  Expression* length = Expression::make_integer(&lenval, NULL, builtin_loc);\n+  mpz_clear(lenval);\n+\n+  Array_type* root_array_type = Type::make_array_type(root_type, length);\n+  Type* ptdt = Type::make_type_descriptor_ptr_type();\n+  Struct_type* root_list_type =\n+      Type::make_builtin_struct_type(2,\n+                                     \"__next\", ptdt,\n+                                     \"__roots\", root_array_type);\n+\n+  // Build an initializer for the __roots array.\n+\n+  Expression_list* roots_init = new Expression_list();\n+\n+  size_t i = 0;\n+  for (std::vector<Named_object*>::const_iterator p = var_gc.begin();\n+       p != var_gc.end();\n+       ++p, ++i)\n+    {\n+      Expression_list* init = new Expression_list();\n+\n+      Location no_loc = (*p)->location();\n+      Expression* decl = Expression::make_var_reference(*p, no_loc);\n+      Expression* decl_addr =\n+          Expression::make_unary(OPERATOR_AND, decl, no_loc);\n+      init->push_back(decl_addr);\n+\n+      Expression* decl_size =\n+          Expression::make_type_info(decl->type(), Expression::TYPE_INFO_SIZE);\n+      init->push_back(decl_size);\n+\n+      Expression* root_ctor =\n+          Expression::make_struct_composite_literal(root_type, init, no_loc);\n+      roots_init->push_back(root_ctor);\n+    }\n+\n+  // The list ends with a NULL entry.\n+\n+  Expression_list* null_init = new Expression_list();\n+  Expression* nil = Expression::make_nil(builtin_loc);\n+  null_init->push_back(nil);\n+\n+  mpz_t zval;\n+  mpz_init_set_ui(zval, 0UL);\n+  Expression* zero = Expression::make_integer(&zval, NULL, builtin_loc);\n+  mpz_clear(zval);\n+  null_init->push_back(zero);\n+\n+  Expression* null_root_ctor =\n+      Expression::make_struct_composite_literal(root_type, null_init,\n+                                                builtin_loc);\n+  roots_init->push_back(null_root_ctor);\n+\n+  // Build a constructor for the struct.\n+\n+  Expression_list* root_list_init = new Expression_list();\n+  root_list_init->push_back(nil);\n+\n+  Expression* roots_ctor =\n+      Expression::make_array_composite_literal(root_array_type, roots_init,\n+                                               builtin_loc);\n+  root_list_init->push_back(roots_ctor);\n+\n+  Expression* root_list_ctor =\n+      Expression::make_struct_composite_literal(root_list_type, root_list_init,\n+                                                builtin_loc);\n+\n+  Expression* root_addr = Expression::make_unary(OPERATOR_AND, root_list_ctor,\n+                                                 builtin_loc);\n+  root_addr->unary_expression()->set_is_gc_root();\n+  Expression* register_roots = Runtime::make_call(Runtime::REGISTER_GC_ROOTS,\n+                                                  builtin_loc, 1, root_addr);\n+\n+  Translate_context context(this, NULL, NULL, NULL);\n+  Bexpression* bcall = tree_to_expr(register_roots->get_tree(&context));\n+  init_stmts.push_back(this->backend()->expression_statement(bcall));\n+}\n+\n // Get the name to use for the import control function.  If there is a\n // global function or variable, then we know that that name must be\n // unique in the link, and we use it as the basis for our name.\n@@ -614,6 +772,521 @@ Gogo::initialization_function_decl()\n   return Named_object::make_function(name, NULL, initfn);\n }\n \n+// Create the magic initialization function.  CODE_STMT is the\n+// code that it needs to run.\n+\n+Named_object*\n+Gogo::create_initialization_function(Named_object* initfn,\n+\t\t\t\t     Bstatement* code_stmt)\n+{\n+  // Make sure that we thought we needed an initialization function,\n+  // as otherwise we will not have reported it in the export data.\n+  go_assert(this->is_main_package() || this->need_init_fn_);\n+\n+  if (initfn == NULL)\n+    initfn = this->initialization_function_decl();\n+\n+  // Bind the initialization function code to a block.\n+  Bfunction* fndecl = initfn->func_value()->get_or_make_decl(this, initfn);\n+  Location pkg_loc = this->package_->location();\n+  std::vector<Bvariable*> vars;\n+  this->backend()->block(fndecl, NULL, vars, pkg_loc, pkg_loc);\n+\n+  if (!this->backend()->function_set_body(fndecl, code_stmt))\n+    {\n+      go_assert(saw_errors());\n+      return NULL;\n+    }\n+  return initfn;\n+}\n+\n+// Search for references to VAR in any statements or called functions.\n+\n+class Find_var : public Traverse\n+{\n+ public:\n+  // A hash table we use to avoid looping.  The index is the name of a\n+  // named object.  We only look through objects defined in this\n+  // package.\n+  typedef Unordered_set(const void*) Seen_objects;\n+\n+  Find_var(Named_object* var, Seen_objects* seen_objects)\n+    : Traverse(traverse_expressions),\n+      var_(var), seen_objects_(seen_objects), found_(false)\n+  { }\n+\n+  // Whether the variable was found.\n+  bool\n+  found() const\n+  { return this->found_; }\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The variable we are looking for.\n+  Named_object* var_;\n+  // Names of objects we have already seen.\n+  Seen_objects* seen_objects_;\n+  // True if the variable was found.\n+  bool found_;\n+};\n+\n+// See if EXPR refers to VAR, looking through function calls and\n+// variable initializations.\n+\n+int\n+Find_var::expression(Expression** pexpr)\n+{\n+  Expression* e = *pexpr;\n+\n+  Var_expression* ve = e->var_expression();\n+  if (ve != NULL)\n+    {\n+      Named_object* v = ve->named_object();\n+      if (v == this->var_)\n+\t{\n+\t  this->found_ = true;\n+\t  return TRAVERSE_EXIT;\n+\t}\n+\n+      if (v->is_variable() && v->package() == NULL)\n+\t{\n+\t  Expression* init = v->var_value()->init();\n+\t  if (init != NULL)\n+\t    {\n+\t      std::pair<Seen_objects::iterator, bool> ins =\n+\t\tthis->seen_objects_->insert(v);\n+\t      if (ins.second)\n+\t\t{\n+\t\t  // This is the first time we have seen this name.\n+\t\t  if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n+\t\t    return TRAVERSE_EXIT;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // We traverse the code of any function we see.  Note that this\n+  // means that we will traverse the code of a function whose address\n+  // is taken even if it is not called.\n+  Func_expression* fe = e->func_expression();\n+  if (fe != NULL)\n+    {\n+      const Named_object* f = fe->named_object();\n+      if (f->is_function() && f->package() == NULL)\n+\t{\n+\t  std::pair<Seen_objects::iterator, bool> ins =\n+\t    this->seen_objects_->insert(f);\n+\t  if (ins.second)\n+\t    {\n+\t      // This is the first time we have seen this name.\n+\t      if (f->func_value()->block()->traverse(this) == TRAVERSE_EXIT)\n+\t\treturn TRAVERSE_EXIT;\n+\t    }\n+\t}\n+    }\n+\n+  Temporary_reference_expression* tre = e->temporary_reference_expression();\n+  if (tre != NULL)\n+    {\n+      Temporary_statement* ts = tre->statement();\n+      Expression* init = ts->init();\n+      if (init != NULL)\n+\t{\n+\t  std::pair<Seen_objects::iterator, bool> ins =\n+\t    this->seen_objects_->insert(ts);\n+\t  if (ins.second)\n+\t    {\n+\t      // This is the first time we have seen this temporary\n+\t      // statement.\n+\t      if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n+\t\treturn TRAVERSE_EXIT;\n+\t    }\n+\t}\n+    }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Return true if EXPR, PREINIT, or DEP refers to VAR.\n+\n+static bool\n+expression_requires(Expression* expr, Block* preinit, Named_object* dep,\n+\t\t    Named_object* var)\n+{\n+  Find_var::Seen_objects seen_objects;\n+  Find_var find_var(var, &seen_objects);\n+  if (expr != NULL)\n+    Expression::traverse(&expr, &find_var);\n+  if (preinit != NULL)\n+    preinit->traverse(&find_var);\n+  if (dep != NULL)\n+    {\n+      Expression* init = dep->var_value()->init();\n+      if (init != NULL)\n+\tExpression::traverse(&init, &find_var);\n+      if (dep->var_value()->has_pre_init())\n+\tdep->var_value()->preinit()->traverse(&find_var);\n+    }\n+\n+  return find_var.found();\n+}\n+\n+// Sort variable initializations.  If the initialization expression\n+// for variable A refers directly or indirectly to the initialization\n+// expression for variable B, then we must initialize B before A.\n+\n+class Var_init\n+{\n+ public:\n+  Var_init()\n+    : var_(NULL), init_(NULL)\n+  { }\n+\n+  Var_init(Named_object* var, Bstatement* init)\n+    : var_(var), init_(init)\n+  { }\n+\n+  // Return the variable.\n+  Named_object*\n+  var() const\n+  { return this->var_; }\n+\n+  // Return the initialization expression.\n+  Bstatement*\n+  init() const\n+  { return this->init_; }\n+\n+ private:\n+  // The variable being initialized.\n+  Named_object* var_;\n+  // The initialization statement.\n+  Bstatement* init_;\n+};\n+\n+typedef std::list<Var_init> Var_inits;\n+\n+// Sort the variable initializations.  The rule we follow is that we\n+// emit them in the order they appear in the array, except that if the\n+// initialization expression for a variable V1 depends upon another\n+// variable V2 then we initialize V1 after V2.\n+\n+static void\n+sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n+{\n+  typedef std::pair<Named_object*, Named_object*> No_no;\n+  typedef std::map<No_no, bool> Cache;\n+  Cache cache;\n+\n+  Var_inits ready;\n+  while (!var_inits->empty())\n+    {\n+      Var_inits::iterator p1 = var_inits->begin();\n+      Named_object* var = p1->var();\n+      Expression* init = var->var_value()->init();\n+      Block* preinit = var->var_value()->preinit();\n+      Named_object* dep = gogo->var_depends_on(var->var_value());\n+\n+      // Start walking through the list to see which variables VAR\n+      // needs to wait for.\n+      Var_inits::iterator p2 = p1;\n+      ++p2;\n+\n+      for (; p2 != var_inits->end(); ++p2)\n+\t{\n+\t  Named_object* p2var = p2->var();\n+\t  No_no key(var, p2var);\n+\t  std::pair<Cache::iterator, bool> ins =\n+\t    cache.insert(std::make_pair(key, false));\n+\t  if (ins.second)\n+\t    ins.first->second = expression_requires(init, preinit, dep, p2var);\n+\t  if (ins.first->second)\n+\t    {\n+\t      // Check for cycles.\n+\t      key = std::make_pair(p2var, var);\n+\t      ins = cache.insert(std::make_pair(key, false));\n+\t      if (ins.second)\n+\t\tins.first->second =\n+\t\t  expression_requires(p2var->var_value()->init(),\n+\t\t\t\t      p2var->var_value()->preinit(),\n+\t\t\t\t      gogo->var_depends_on(p2var->var_value()),\n+\t\t\t\t      var);\n+\t      if (ins.first->second)\n+\t\t{\n+\t\t  error_at(var->location(),\n+\t\t\t   (\"initialization expressions for %qs and \"\n+\t\t\t    \"%qs depend upon each other\"),\n+\t\t\t   var->message_name().c_str(),\n+\t\t\t   p2var->message_name().c_str());\n+\t\t  inform(p2->var()->location(), \"%qs defined here\",\n+\t\t\t p2var->message_name().c_str());\n+\t\t  p2 = var_inits->end();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // We can't emit P1 until P2 is emitted.  Move P1.\n+\t\t  Var_inits::iterator p3 = p2;\n+\t\t  ++p3;\n+\t\t  var_inits->splice(p3, *var_inits, p1);\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (p2 == var_inits->end())\n+\t{\n+\t  // VAR does not depends upon any other initialization expressions.\n+\n+\t  // Check for a loop of VAR on itself.  We only do this if\n+\t  // INIT is not NULL and there is no dependency; when INIT is\n+\t  // NULL, it means that PREINIT sets VAR, which we will\n+\t  // interpret as a loop.\n+\t  if (init != NULL && dep == NULL\n+\t      && expression_requires(init, preinit, NULL, var))\n+\t    error_at(var->location(),\n+\t\t     \"initialization expression for %qs depends upon itself\",\n+\t\t     var->message_name().c_str());\n+\t  ready.splice(ready.end(), *var_inits, p1);\n+\t}\n+    }\n+\n+  // Now READY is the list in the desired initialization order.\n+  var_inits->swap(ready);\n+}\n+\n+// Write out the global definitions.\n+\n+void\n+Gogo::write_globals()\n+{\n+  this->build_interface_method_tables();\n+\n+  Bindings* bindings = this->current_bindings();\n+\n+  for (Bindings::const_declarations_iterator p = bindings->begin_declarations();\n+       p != bindings->end_declarations();\n+       ++p)\n+    {\n+      // If any function declarations needed a descriptor, make sure\n+      // we build it.\n+      Named_object* no = p->second;\n+      if (no->is_function_declaration())\n+\tno->func_declaration_value()->build_backend_descriptor(this);\n+    }\n+\n+  // Lists of globally declared types, variables, constants, and functions\n+  // that must be defined.\n+  std::vector<Btype*> type_decls;\n+  std::vector<Bvariable*> var_decls;\n+  std::vector<Bexpression*> const_decls;\n+  std::vector<Bfunction*> func_decls;\n+\n+  // The init function declaration, if necessary.\n+  Named_object* init_fndecl = NULL;\n+\n+  std::vector<Bstatement*> init_stmts;\n+  std::vector<Bstatement*> var_init_stmts;\n+\n+  if (this->is_main_package())\n+    this->init_imports(init_stmts);\n+\n+  // A list of variable initializations.\n+  Var_inits var_inits;\n+\n+  // A list of variables which need to be registered with the garbage\n+  // collector.\n+  size_t count_definitions = bindings->size_definitions();\n+  std::vector<Named_object*> var_gc;\n+  var_gc.reserve(count_definitions);\n+\n+  for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n+       p != bindings->end_definitions();\n+       ++p)\n+    {\n+      Named_object* no = *p;\n+      go_assert(!no->is_type_declaration() && !no->is_function_declaration());\n+\n+      // There is nothing to do for a package.\n+      if (no->is_package())\n+        continue;\n+\n+      // There is nothing to do for an object which was imported from\n+      // a different package into the global scope.\n+      if (no->package() != NULL)\n+        continue;\n+\n+      // Skip blank named functions and constants.\n+      if ((no->is_function() && no->func_value()->is_sink())\n+\t  || (no->is_const() && no->const_value()->is_sink()))\n+        continue;\n+\n+      // There is nothing useful we can output for constants which\n+      // have ideal or non-integral type.\n+      if (no->is_const())\n+        {\n+          Type* type = no->const_value()->type();\n+          if (type == NULL)\n+            type = no->const_value()->expr()->type();\n+          if (type->is_abstract() || !type->is_numeric_type())\n+            continue;\n+        }\n+\n+      if (!no->is_variable())\n+        no->get_backend(this, const_decls, type_decls, func_decls);\n+      else\n+\t{\n+          Variable* var = no->var_value();\n+\t  Bvariable* bvar = no->get_backend_variable(this, NULL);\n+          var_decls.push_back(bvar);\n+\n+\t  // Check for a sink variable, which may be used to run an\n+\t  // initializer purely for its side effects.\n+\t  bool is_sink = no->name()[0] == '_' && no->name()[1] == '.';\n+\n+          Bstatement* var_init_stmt = NULL;\n+\t  if (!var->has_pre_init())\n+\t    {\n+              Bexpression* var_binit = var->get_init(this, NULL);\n+\n+              // If the backend representation of the variable initializer is\n+              // constant, we can just set the initial value using\n+              // global_var_set_init instead of during the init() function.\n+              // The initializer is constant if it is the zero-value of the\n+              // variable's type or if the initial value is an immutable value\n+              // that is not copied to the heap.\n+              bool is_constant_initializer = false;\n+              if (var->init() == NULL)\n+                is_constant_initializer = true;\n+              else\n+                {\n+                  Type* var_type = var->type();\n+                  Expression* init = var->init();\n+                  Expression* init_cast =\n+                      Expression::make_cast(var_type, init, var->location());\n+                  is_constant_initializer =\n+                      init_cast->is_immutable() && !var_type->has_pointer();\n+                }\n+\n+              if (var_binit == NULL)\n+\t\t;\n+\t      else if (is_constant_initializer)\n+\t\t{\n+\t\t  if (expression_requires(var->init(), NULL,\n+\t\t\t\t\t  this->var_depends_on(var), no))\n+\t\t    error_at(no->location(),\n+\t\t\t     \"initialization expression for %qs depends \"\n+\t\t\t     \"upon itself\",\n+\t\t\t     no->message_name().c_str());\n+\t\t  this->backend()->global_variable_set_init(bvar, var_binit);\n+\t\t}\n+\t      else if (is_sink)\n+\t        var_init_stmt =\n+                    this->backend()->expression_statement(var_binit);\n+\t      else\n+                {\n+                  Location loc = var->location();\n+                  Bexpression* var_expr =\n+                      this->backend()->var_expression(bvar, loc);\n+                  var_init_stmt =\n+                      this->backend()->assignment_statement(var_expr, var_binit,\n+                                                            loc);\n+                }\n+\t    }\n+\t  else\n+\t    {\n+\t      // We are going to create temporary variables which\n+\t      // means that we need an fndecl.\n+              if (init_fndecl == NULL)\n+\t\tinit_fndecl = this->initialization_function_decl();\n+\n+\t      Bvariable* var_decl = is_sink ? NULL : bvar;\n+\t      var_init_stmt = var->get_init_block(this, init_fndecl, var_decl);\n+\t    }\n+\n+\t  if (var_init_stmt != NULL)\n+\t    {\n+\t      if (var->init() == NULL && !var->has_pre_init())\n+                var_init_stmts.push_back(var_init_stmt);\n+\t      else\n+                var_inits.push_back(Var_init(no, var_init_stmt));\n+\t    }\n+\t  else if (this->var_depends_on(var) != NULL)\n+\t    {\n+\t      // This variable is initialized from something that is\n+\t      // not in its init or preinit.  This variable needs to\n+\t      // participate in dependency analysis sorting, in case\n+\t      // some other variable depends on this one.\n+              Btype* btype = no->var_value()->type()->get_backend(this);\n+              Bexpression* zero = this->backend()->zero_expression(btype);\n+              Bstatement* zero_stmt =\n+                  this->backend()->expression_statement(zero);\n+\t      var_inits.push_back(Var_init(no, zero_stmt));\n+\t    }\n+\n+\t  if (!is_sink && var->type()->has_pointer())\n+\t    var_gc.push_back(no);\n+\t}\n+    }\n+\n+  // Register global variables with the garbage collector.\n+  this->register_gc_vars(var_gc, init_stmts);\n+\n+  // Simple variable initializations, after all variables are\n+  // registered.\n+  init_stmts.push_back(this->backend()->statement_list(var_init_stmts));\n+\n+  // Complete variable initializations, first sorting them into a\n+  // workable order.\n+  if (!var_inits.empty())\n+    {\n+      sort_var_inits(this, &var_inits);\n+      for (Var_inits::const_iterator p = var_inits.begin();\n+           p != var_inits.end();\n+           ++p)\n+        init_stmts.push_back(p->init());\n+    }\n+\n+  // After all the variables are initialized, call the init\n+  // functions if there are any.  Init functions take no arguments, so\n+  // we pass in EMPTY_ARGS to call them.\n+  std::vector<Bexpression*> empty_args;\n+  for (std::vector<Named_object*>::const_iterator p =\n+           this->init_functions_.begin();\n+       p != this->init_functions_.end();\n+       ++p)\n+    {\n+      Location func_loc = (*p)->location();\n+      Function* func = (*p)->func_value();\n+      Bfunction* initfn = func->get_or_make_decl(this, *p);\n+      Bexpression* func_code =\n+          this->backend()->function_code_expression(initfn, func_loc);\n+      Bexpression* call = this->backend()->call_expression(func_code,\n+                                                           empty_args,\n+                                                           func_loc);\n+      init_stmts.push_back(this->backend()->expression_statement(call));\n+    }\n+\n+  // Set up a magic function to do all the initialization actions.\n+  // This will be called if this package is imported.\n+  Bstatement* init_fncode = this->backend()->statement_list(init_stmts);\n+  if (this->need_init_fn_ || this->is_main_package())\n+    {\n+      init_fndecl =\n+\tthis->create_initialization_function(init_fndecl, init_fncode);\n+      if (init_fndecl != NULL)\n+\tfunc_decls.push_back(init_fndecl->func_value()->get_decl());\n+    }\n+\n+  // We should not have seen any new bindings created during the conversion.\n+  go_assert(count_definitions == this->current_bindings()->size_definitions());\n+\n+  // Define all globally declared values.\n+  if (!saw_errors())\n+    this->backend()->write_global_definitions(type_decls, const_decls,\n+\t\t\t\t\t      func_decls, var_decls);\n+}\n+\n // Return the current block.\n \n Block*\n@@ -4182,6 +4855,15 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n   return this->fndecl_;\n }\n \n+// Return the function's decl after it has been built.\n+\n+Bfunction*\n+Function::get_decl() const\n+{\n+  go_assert(this->fndecl_ != NULL);\n+  return this->fndecl_;\n+}\n+\n // Build the backend representation for the function code.\n \n void\n@@ -5266,8 +5948,7 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n \t{\n           Location loc = this->location();\n           Expression* val_expr =\n-              Expression::convert_for_assignment(gogo, this->type(),\n-                                                 this->init_, this->location());\n+              Expression::make_cast(this->type(), this->init_, loc);\n           Bexpression* val = tree_to_expr(val_expr->get_tree(&context));\n           Bexpression* var_ref = gogo->backend()->var_expression(var_decl, loc);\n           decl_init = gogo->backend()->assignment_statement(var_ref, val, loc);\n@@ -5353,8 +6034,7 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t    }\n \t  else\n \t    {\n-\t      tree fndecl = function->func_value()->get_decl();\n-\t      Bfunction* bfunction = tree_to_function(fndecl);\n+\t      Bfunction* bfunction = function->func_value()->get_decl();\n \t      bool is_address_taken = (this->is_non_escaping_address_taken_\n \t\t\t\t       && !this->is_in_heap());\n \t      if (is_parameter)\n@@ -5391,8 +6071,7 @@ Result_variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t  if (this->is_in_heap())\n \t    type = Type::make_pointer_type(type);\n \t  Btype* btype = type->get_backend(gogo);\n-\t  tree fndecl = function->func_value()->get_decl();\n-\t  Bfunction* bfunction = tree_to_function(fndecl);\n+\t  Bfunction* bfunction = function->func_value()->get_decl();\n \t  std::string n = Gogo::unpack_hidden_name(name);\n \t  bool is_address_taken = (this->is_non_escaping_address_taken_\n \t\t\t\t   && !this->is_in_heap());\n@@ -5482,6 +6161,33 @@ Named_constant::import_const(Import* imp, std::string* pname, Type** ptype,\n   imp->require_c_string(\";\\n\");\n }\n \n+// Get the backend representation.\n+\n+Bexpression*\n+Named_constant::get_backend(Gogo* gogo, Named_object* const_no)\n+{\n+  if (this->bconst_ == NULL)\n+    {\n+      Translate_context subcontext(gogo, NULL, NULL, NULL);\n+      Type* type = this->type();\n+      Location loc = this->location();\n+\n+      Expression* const_ref = Expression::make_const_reference(const_no, loc);\n+      Bexpression* const_decl =\n+\ttree_to_expr(const_ref->get_tree(&subcontext));\n+      if (type != NULL && type->is_numeric_type())\n+\t{\n+\t  Btype* btype = type->get_backend(gogo);\n+\t  std::string name = const_no->get_id(gogo);\n+\t  const_decl =\n+\t    gogo->backend()->named_constant_expression(btype, name,\n+\t\t\t\t\t\t       const_decl, loc);\n+\t}\n+      this->bconst_ = const_decl;\n+    }\n+  return this->bconst_;\n+}\n+\n // Add a method.\n \n Named_object*\n@@ -5552,8 +6258,7 @@ Unknown_name::set_real_named_object(Named_object* no)\n Named_object::Named_object(const std::string& name,\n \t\t\t   const Package* package,\n \t\t\t   Classification classification)\n-  : name_(name), package_(package), classification_(classification),\n-    tree_(NULL)\n+  : name_(name), package_(package), classification_(classification)\n {\n   if (Gogo::is_sink_name(name))\n     go_assert(classification == NAMED_OBJECT_SINK);\n@@ -5928,6 +6633,72 @@ Named_object::get_id(Gogo* gogo)\n   return decl_name;\n }\n \n+// Get the backend representation for this named object.\n+\n+void\n+Named_object::get_backend(Gogo* gogo, std::vector<Bexpression*>& const_decls,\n+                          std::vector<Btype*>& type_decls,\n+                          std::vector<Bfunction*>& func_decls)\n+{\n+  switch (this->classification_)\n+    {\n+    case NAMED_OBJECT_CONST:\n+      if (!Gogo::is_erroneous_name(this->name_))\n+\tconst_decls.push_back(this->u_.const_value->get_backend(gogo, this));\n+      break;\n+\n+    case NAMED_OBJECT_TYPE:\n+      {\n+        Named_type* named_type = this->u_.type_value;\n+\tif (!Gogo::is_erroneous_name(this->name_))\n+\t  type_decls.push_back(named_type->get_backend(gogo));\n+\n+        // We need to produce a type descriptor for every named\n+        // type, and for a pointer to every named type, since\n+        // other files or packages might refer to them.  We need\n+        // to do this even for hidden types, because they might\n+        // still be returned by some function.  Simply calling the\n+        // type_descriptor method is enough to create the type\n+        // descriptor, even though we don't do anything with it.\n+        if (this->package_ == NULL)\n+          {\n+            named_type->\n+                type_descriptor_pointer(gogo, Linemap::predeclared_location());\n+            Type* pn = Type::make_pointer_type(named_type);\n+            pn->type_descriptor_pointer(gogo, Linemap::predeclared_location());\n+          }\n+      }\n+      break;\n+\n+    case NAMED_OBJECT_TYPE_DECLARATION:\n+      error(\"reference to undefined type %qs\",\n+\t    this->message_name().c_str());\n+      return;\n+\n+    case NAMED_OBJECT_VAR:\n+    case NAMED_OBJECT_RESULT_VAR:\n+    case NAMED_OBJECT_SINK:\n+      go_unreachable();\n+\n+    case NAMED_OBJECT_FUNC:\n+      {\n+\tFunction* func = this->u_.func_value;\n+\tif (!Gogo::is_erroneous_name(this->name_))\n+\t  func_decls.push_back(func->get_or_make_decl(gogo, this));\n+\n+\tif (func->block() != NULL)\n+\t  func->build(gogo, this);\n+      }\n+      break;\n+\n+    case NAMED_OBJECT_ERRONEOUS:\n+      break;\n+\n+    default:\n+      go_unreachable();\n+    }\n+}\n+\n // Class Bindings.\n \n Bindings::Bindings(Bindings* enclosing)\n@@ -6400,8 +7171,7 @@ Label::get_backend_label(Translate_context* context)\n   if (this->blabel_ == NULL)\n     {\n       Function* function = context->function()->func_value();\n-      tree fndecl = function->get_decl();\n-      Bfunction* bfunction = tree_to_function(fndecl);\n+      Bfunction* bfunction = function->get_decl();\n       this->blabel_ = context->backend()->label(bfunction, this->name_,\n \t\t\t\t\t\tthis->location_);\n     }\n@@ -6427,8 +7197,7 @@ Unnamed_label::get_blabel(Translate_context* context)\n   if (this->blabel_ == NULL)\n     {\n       Function* function = context->function()->func_value();\n-      tree fndecl = function->get_decl();\n-      Bfunction* bfunction = tree_to_function(fndecl);\n+      Bfunction* bfunction = function->get_decl();\n       this->blabel_ = context->backend()->label(bfunction, \"\",\n \t\t\t\t\t\tthis->location_);\n     }"}, {"sha": "0be81b2aafe41fd6f51283b94ff502ed606ada83", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -44,6 +44,7 @@ class Backend;\n class Export;\n class Import;\n class Bexpression;\n+class Btype;\n class Bstatement;\n class Bblock;\n class Bvariable;\n@@ -591,11 +592,6 @@ class Gogo\n   Expression*\n   runtime_error(int code, Location);\n \n-  // Build a builtin struct with a list of fields.\n-  static tree\n-  builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n-\t\t int nfields, ...);\n-\n   // Mark a function declaration as a builtin library function.\n   static void\n   mark_fndecl_as_builtin_library(tree fndecl);\n@@ -650,17 +646,18 @@ class Gogo\n   Named_object*\n   initialization_function_decl();\n \n-  // Write the magic initialization function.\n-  void\n-  write_initialization_function(Named_object* fndecl, tree init_stmt_list);\n+  // Create the magic initialization function.\n+  Named_object*\n+  create_initialization_function(Named_object* fndecl, Bstatement* code_stmt);\n \n   // Initialize imported packages.\n   void\n-  init_imports(tree*);\n+  init_imports(std::vector<Bstatement*>&);\n \n   // Register variables with the garbage collector.\n   void\n-  register_gc_vars(const std::vector<Named_object*>&, tree*);\n+  register_gc_vars(const std::vector<Named_object*>&,\n+                   std::vector<Bstatement*>&);\n \n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;\n@@ -1086,7 +1083,7 @@ class Function\n   get_or_make_decl(Gogo*, Named_object*);\n \n   // Return the function's decl after it has been built.\n-  tree\n+  Bfunction*\n   get_decl() const;\n \n   // Set the function decl to hold a backend representation of the function\n@@ -1675,7 +1672,7 @@ class Named_constant\n   Named_constant(Type* type, Expression* expr, int iota_value,\n \t\t Location location)\n     : type_(type), expr_(expr), iota_value_(iota_value), location_(location),\n-      lowering_(false), is_sink_(false)\n+      lowering_(false), is_sink_(false), bconst_(NULL)\n   { }\n \n   Type*\n@@ -1737,6 +1734,10 @@ class Named_constant\n   static void\n   import_const(Import*, std::string*, Type**, Expression**);\n \n+  // Get the backend representation of the constant value.\n+  Bexpression*\n+  get_backend(Gogo*, Named_object*);\n+\n  private:\n   // The type of the constant.\n   Type* type_;\n@@ -1754,6 +1755,8 @@ class Named_constant\n   bool lowering_;\n   // Whether this constant is blank named and needs only type checking.\n   bool is_sink_;\n+  // The backend representation of the constant value.\n+  Bexpression* bconst_;\n };\n \n // A type declaration.\n@@ -2176,9 +2179,10 @@ class Named_object\n   std::string\n   get_id(Gogo*);\n \n-  // Return a tree representing this object.\n-  tree\n-  get_tree(Gogo*, Named_object* function);\n+  // Get the backend representation of this object.\n+  void\n+  get_backend(Gogo*, std::vector<Bexpression*>&, std::vector<Btype*>&,\n+              std::vector<Bfunction*>&);\n \n   // Define a type declaration.\n   void\n@@ -2219,8 +2223,6 @@ class Named_object\n     Function_declaration* func_declaration_value;\n     Package* package_value;\n   } u_;\n-  // The DECL tree for this object if we have already converted it.\n-  tree tree_;\n };\n \n // A binding contour.  This binds names to objects."}, {"sha": "dabf1a83af66e3310e7c3d0c4a8e8a95796ee960", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036165d8116610b18861941fed4080a93783f954/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=036165d8116610b18861941fed4080a93783f954", "patch": "@@ -434,15 +434,9 @@ Temporary_statement::do_get_backend(Translate_context* context)\n {\n   go_assert(this->bvariable_ == NULL);\n \n-  // FIXME: Permitting FUNCTION to be NULL here is a temporary measure\n-  // until we have a better representation of the init function.\n   Named_object* function = context->function();\n-  Bfunction* bfunction;\n-  if (function == NULL)\n-    bfunction = NULL;\n-  else\n-    bfunction = tree_to_function(function->func_value()->get_decl());\n-\n+  go_assert(function != NULL);\n+  Bfunction* bfunction = function->func_value()->get_decl();\n   Btype* btype = this->type()->get_backend(context->gogo());\n \n   Bexpression* binit;\n@@ -2781,8 +2775,6 @@ Return_statement::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n \n   Function* function = context->function()->func_value();\n-  tree fndecl = function->get_decl();\n-\n   Function::Results* results = function->result_variables();\n   std::vector<Bexpression*> retvals;\n   if (results != NULL && !results->empty())\n@@ -2797,7 +2789,7 @@ Return_statement::do_get_backend(Translate_context* context)\n \t}\n     }\n \n-  return context->backend()->return_statement(tree_to_function(fndecl),\n+  return context->backend()->return_statement(function->get_decl(),\n \t\t\t\t\t      retvals, loc);\n }\n \n@@ -3803,8 +3795,10 @@ Constant_switch_statement::do_get_backend(Translate_context* context)\n   this->clauses_->get_backend(context, break_label, &all_cases,\n \t\t\t      &all_statements);\n \n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n   Bstatement* switch_statement;\n-  switch_statement = context->backend()->switch_statement(switch_val_expr,\n+  switch_statement = context->backend()->switch_statement(bfunction,\n+\t\t\t\t\t\t\t  switch_val_expr,\n \t\t\t\t\t\t\t  all_cases,\n \t\t\t\t\t\t\t  all_statements,\n \t\t\t\t\t\t\t  this->location());\n@@ -4980,7 +4974,9 @@ Select_clauses::get_backend(Translate_context* context,\n   std::vector<Bstatement*> statements;\n   statements.reserve(2);\n \n-  Bstatement* switch_stmt = context->backend()->switch_statement(bcall,\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  Bstatement* switch_stmt = context->backend()->switch_statement(bfunction,\n+\t\t\t\t\t\t\t\t bcall,\n \t\t\t\t\t\t\t\t cases,\n \t\t\t\t\t\t\t\t clauses,\n \t\t\t\t\t\t\t\t location);"}]}