{"sha": "7fb1c86d07111ef6c504d09f3b2a8936449bca11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZiMWM4NmQwNzExMWVmNmM1MDRkMDlmM2IyYTg5MzY0NDliY2ExMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-02-21T16:36:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-02-21T16:36:41Z"}, "message": "search.c (bfs_walk_grow): Remove.\n\n\t* search.c (bfs_walk_grow): Remove. Fold into ...\n\t(bfs_walk): ... here, fix fencepost error. Fix merge lossage\n\tin previous patch.\n\nFrom-SVN: r63226", "tree": {"sha": "1aaa0b4304c7edc4edd8a01c0db8631381656a14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aaa0b4304c7edc4edd8a01c0db8631381656a14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fb1c86d07111ef6c504d09f3b2a8936449bca11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb1c86d07111ef6c504d09f3b2a8936449bca11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb1c86d07111ef6c504d09f3b2a8936449bca11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb1c86d07111ef6c504d09f3b2a8936449bca11/comments", "author": null, "committer": null, "parents": [{"sha": "902ac71956ccaacd88bbf9fbe229a4bf4dbcddd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902ac71956ccaacd88bbf9fbe229a4bf4dbcddd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/902ac71956ccaacd88bbf9fbe229a4bf4dbcddd9"}], "stats": {"total": 119, "additions": 43, "deletions": 76}, "files": [{"sha": "960c36dada614f4752f4f04ad1d499a5a67e28f8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb1c86d07111ef6c504d09f3b2a8936449bca11/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb1c86d07111ef6c504d09f3b2a8936449bca11/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7fb1c86d07111ef6c504d09f3b2a8936449bca11", "patch": "@@ -1,3 +1,9 @@\n+2003-02-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* search.c (bfs_walk_grow): Remove. Fold into ...\n+\t(bfs_walk): ... here, fix fencepost error. Fix merge lossage\n+\tin previous patch.\n+\n 2003-02-20  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9729"}, {"sha": "f97cb743d2d33da9592cd475d3ce65ed0cea9206", "filename": "gcc/cp/search.c", "status": "modified", "additions": 37, "deletions": 76, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb1c86d07111ef6c504d09f3b2a8936449bca11/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb1c86d07111ef6c504d09f3b2a8936449bca11/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=7fb1c86d07111ef6c504d09f3b2a8936449bca11", "patch": "@@ -99,7 +99,6 @@ static int look_for_overrides_r (tree, tree);\n static struct search_level *push_search_level (struct stack_level *,\n \t\t\t\t\t       struct obstack *);\n static struct search_level *pop_search_level (struct stack_level *);\n-static void grow_bfs_bases (tree **, size_t *, size_t *);\n static tree bfs_walk (tree, tree (*) (tree, void *),\n \t\t      tree (*) (tree, int, void *), void *);\n static tree lookup_field_queue_p (tree, int, void *);\n@@ -1458,43 +1457,6 @@ adjust_result_of_qualified_name_lookup (tree decl,\n }\n \n \f\n-/* Start with enough room for ten concurrent base classes.  That\n-   will be enough for most hierarchies.  */\n-#define BFS_WALK_INITIAL_QUEUE_SIZE 10\n-\n-/* Subroutine of bfs_walk; enlarges the buffer it uses for its\n-   circular queue.  */\n-static void\n-grow_bfs_bases (tree **basep, size_t *sizep, size_t *headp)\n-{\n-  tree *base;\n-  size_t size = *sizep;\n-  size_t head = *headp;\n-\n-  /* If the size is BFS_WALK_INITIAL_QUEUE_SIZE, the old array is on\n-     the stack.  */\n-  if (size == BFS_WALK_INITIAL_QUEUE_SIZE)\n-    {\n-      base = xmalloc (size * 2 * sizeof(tree));\n-      memcpy (base, *basep, size * sizeof(tree));\n-    }\n-  else\n-    base = xrealloc (*basep, size * 2 * sizeof(tree));\n-\n-  *basep = base;\n-  *sizep = size * 2;\n-\n-  /* Shift all the elements between head and the former end of the\n-     array, opening up a gap between tail and head.  If head==0 we\n-     don't need to do anything to achieve this.  */\n-  if (head != 0)\n-    {\n-      memmove (&base[head + size], &base[head],\n-\t       (size - head) * sizeof (tree));\n-      *headp = head + size;\n-    }\n-}\n-\n /* Walk the class hierarchy dominated by TYPE.  FN is called for each\n    type in the hierarchy, in a breadth-first preorder traversal.\n    If it ever returns a non-NULL value, that value is immediately\n@@ -1511,9 +1473,10 @@ grow_bfs_bases (tree **basep, size_t *sizep, size_t *headp)\n    enlarged.  The underflow and overflow conditions are\n    indistinguishable except by context: if head == tail and we just\n    moved the head pointer, the queue is empty, but if we just moved\n-   the tail pointer, the queue is full.  Base class vectors are only\n-   put on the queue if they are nonempty, which is why it's safe to\n-   use do-while for the inner loop.  */\n+   the tail pointer, the queue is full.  \n+   Start with enough room for ten concurrent base classes.  That\n+   will be enough for most hierarchies.  */\n+#define BFS_WALK_INITIAL_QUEUE_SIZE 10\n \n static tree\n bfs_walk (tree binfo,\n@@ -1523,34 +1486,22 @@ bfs_walk (tree binfo,\n {\n   tree rval = NULL_TREE;\n \n-  tree bfs_bases_initial[BFS_WALK_INITIAL_QUEUE_SIZE];\n+  tree bases_initial[BFS_WALK_INITIAL_QUEUE_SIZE];\n   /* A circular queue of the base classes of BINFO.  These will be\n      built up in breadth-first order, except where QFN prunes the\n      search.  */\n   size_t head, tail;\n-  size_t bfs_bases_size = BFS_WALK_INITIAL_QUEUE_SIZE;\n-  tree *bfs_bases = bfs_bases_initial;\n-\n-  /* Is the first one what we're looking for?  If so, we're done.  */\n-  rval = fn (binfo, data);\n-  if (rval)\n-    return rval;\n-\n-  /* If it has no base types, we are also done.  */\n-  if (!BINFO_BASETYPES (binfo))\n-    return 0;\n-\n-  /* Otherwise, initialize the queue with its basetypes vector\n-     and proceed.  */\n+  size_t base_buffer_size = BFS_WALK_INITIAL_QUEUE_SIZE;\n+  tree *base_buffer = bases_initial;\n \n   head = tail = 0;\n-  bfs_bases[tail++] = binfo;\n+  base_buffer[tail++] = binfo;\n \n   while (head != tail)\n     {\n       int n_bases, ix;\n-      tree binfo = bfs_bases[head++];\n-      if (head == bfs_bases_size)\n+      tree binfo = base_buffer[head++];\n+      if (head == base_buffer_size)\n \thead = 0;\n \n       /* Is this the one we're looking for?  If so, we're done.  */\n@@ -1559,32 +1510,42 @@ bfs_walk (tree binfo,\n \tgoto done;\n \n       n_bases = BINFO_N_BASETYPES (binfo);\n-      if (n_bases)\n+      for (ix = 0; ix != n_bases; ix++)\n \t{\n-\t  for (ix = 0; ix != n_bases; ix++)\n+\t  tree base_binfo;\n+\t  \n+\t  if (qfn)\n+\t    base_binfo = (*qfn) (binfo, ix, data);\n+\t  else\n+\t    base_binfo = BINFO_BASETYPE (binfo, ix);\n+\t  \n+ \t  if (base_binfo)\n \t    {\n-\t      tree base_binfo;\n-\n-\t      if (qfn)\n-\t\tbase_binfo = (*qfn) (binfo, ix, data);\n- \t      else\n- \t\tbase_binfo = BINFO_BASETYPE (binfo, ix);\n-\n-\t      if (base_binfo)\n+\t      base_buffer[tail++] = base_binfo;\n+\t      if (tail == base_buffer_size)\n+\t\ttail = 0;\n+\t      if (tail == head)\n \t\t{\n-\t\t  bfs_bases[tail++] = base_binfo;\n-\t\t  if (tail == bfs_bases_size)\n-\t\t    tail = 0;\n-\t\t  if (tail == head)\n-\t\t    grow_bfs_bases (&bfs_bases, &bfs_bases_size, &head);\n+\t\t  tree *new_buffer = xmalloc (2 * base_buffer_size\n+\t\t\t\t\t      * sizeof (tree));\n+\t\t  memcpy (&new_buffer[0], &base_buffer[0],\n+\t\t\t  tail * sizeof (tree));\n+\t\t  memcpy (&new_buffer[head + base_buffer_size],\n+\t\t\t  &base_buffer[head],\n+\t\t\t  (base_buffer_size - head) * sizeof (tree));\n+\t\t  if (base_buffer_size != BFS_WALK_INITIAL_QUEUE_SIZE)\n+\t\t    free (base_buffer);\n+\t\t  base_buffer = new_buffer;\n+\t\t  head += base_buffer_size;\n+\t\t  base_buffer_size *= 2;\n \t\t}\n \t    }\n \t}\n     }\n \n  done:\n-  if (bfs_bases != bfs_bases_initial)\n-    free (bfs_bases);\n+  if (base_buffer_size != BFS_WALK_INITIAL_QUEUE_SIZE)\n+    free (base_buffer);\n   return rval;\n }\n "}]}