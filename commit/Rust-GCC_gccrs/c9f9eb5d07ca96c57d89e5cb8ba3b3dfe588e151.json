{"sha": "c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlmOWViNWQwN2NhOTZjNTdkODllNWNiOGJhM2IzZGZlNTg4ZTE1MQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2008-10-06T21:35:02Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2008-10-06T21:35:02Z"}, "message": "c-decl.c (finish_decl): Pass input_location to build_unary_op.\n\n\t* c-decl.c (finish_decl): Pass input_location to build_unary_op.\n\t* c-typeck.c (array_to_pointer_conversion): Pass location to\n\tbuild_unary_op.\n\t(function_to_pointer_conversion): Use error_at and warning_at.\n\t(build_indirect_ref): Same.\n\t(build_array_ref): Pass location to build_binary_op.\n\t(parser_build_unary_op): Do not set location after calling\n\tbuild_unary_op.\n\t(build_unary_op): Add location argument.  Use it throughout.  Set\n\tEXPR_LOCATION before returning new tree.\n\t(build_modify_expr): Same.\n\t(build_binary_op): Use location throughout.  Set EXPR_LOCATION before\n\treturning node.\n\t* c-omp.c (c_finish_omp_atomic): Pass location to build_unary_op,\n\tbuild_indirect_ref, build_modify_expr.\n\t(c_finish_omp_for): Same.  Use error_at instead of error.\n\t* c-common.c (c_common_truthvalue_conversion): Pass location to\n\tbuild_unary_op.\n\t(warn_for_div_by_zero): Add location argument.\n\t* c-common.h: Add argument to build_modify_expr, build_indirect_ref,\n\tbuild_unary_op, warn_for_div_by_zero.\n\t* c-parser.c (c_parser_typeof_specifier): Use\n\tprotected_set_expr_location.\n\t(c_parser_statement_after_labels): Same.\n\t(c_parser_condition): Same.\n\t(c_parser_expr_no_commas): Pass correct location to build_modify_expr.\n\t(c_parser_conditional_expression): Use protected_set_expr_location.\n\t(c_parser_unary_expression): Pass location to build_indirect_ref.\n\t(c_parser_postfix_expression_after_primary): Pass location to\n\tbuild_indirect_ref, build_unary_op.\n\t(c_parser_omp_for_loop): Set the increment expression's EXPR_LOCATION.\nobjc/\n\t* objc-act.c (objc_build_string_object): Pass location to\n\tbuild_unary_op.\n\t(init_def_list): Same.\n\t(init_objc_symtab): Same.\n\t(init_module_descriptor): Same.\n\t(build_module_initializer_routine): Same.\n\t(generate_static_references): Same.\n\t(build_typed_selector_reference): Same.\n\t(add_objc_string): Same.\n\t(objc_substitute_decl): Same.\n\t(objc_build_ivar_assignment): Same.\n\t(objc_build_global_assignment): Same.\n\t(objc_build_strong_cast_assignment): Same.\n\t(generate_protocols): Same.\n\t(build_protocol_initializer): Same.\n\t(build_dispatch_table_initializer): Same.\n\t(generate_protocol_list): Same.\n\t(build_category_initializer): Same.\n\t(build_shared_structure_initializer): Same.\n\t(generate_shared_structures): Same.\n\t(objc_build_protocol_expr): Same.\n\t(build_ivar_reference): Same.\n\t(get_super_receiver): Same.\n\tbuild_modify_expr.\ntestsuite/\n\t* gcc.dg/gomp/for-1.c: Test column.\n\t* gcc.dg/misc-column.c: Add column tests for unary arguments.\ncp/\n\t* typeck.c (build_x_indirect_ref): Add location argument.\n\t(cp_build_binary_op): Pass location to warn_for_div_by_zero.\n\t(cp_build_unary_op): Add location argument.\n\t(cp_build_modify_expr): Same.\n\t* class.c (build_base_path): Pass location to build_indirect_ref.\n\t* semantics.c (handle_omp_for_class_iterator): Pass elocus to\n\tbuild_modify_expr.\n\nFrom-SVN: r140914", "tree": {"sha": "1143aed4f086c080db0a92f3dcf75640658aa713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1143aed4f086c080db0a92f3dcf75640658aa713"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a3446ec7cdc75bedc1e0b47daea93146c5f8a78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a3446ec7cdc75bedc1e0b47daea93146c5f8a78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a3446ec7cdc75bedc1e0b47daea93146c5f8a78"}], "stats": {"total": 502, "additions": 338, "deletions": 164}, "files": [{"sha": "a3cec0635e968044ec60cb117d356082f6fc174e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1,3 +1,38 @@\n+2008-10-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tbuild_modify_expr.\n+\t* c-decl.c (finish_decl): Pass input_location to build_unary_op.\n+\t* c-typeck.c (array_to_pointer_conversion): Pass location to\n+\tbuild_unary_op.\n+\t(function_to_pointer_conversion): Use error_at and warning_at.\n+\t(build_indirect_ref): Same.\n+\t(build_array_ref): Pass location to build_binary_op.\n+\t(parser_build_unary_op): Do not set location after calling\n+\tbuild_unary_op.\n+\t(build_unary_op): Add location argument.  Use it throughout.  Set\n+\tEXPR_LOCATION before returning new tree.\n+\t(build_modify_expr): Same.\n+\t(build_binary_op): Use location throughout.  Set EXPR_LOCATION before\n+\treturning node.\n+\t* c-omp.c (c_finish_omp_atomic): Pass location to build_unary_op,\n+\tbuild_indirect_ref, build_modify_expr.\n+\t(c_finish_omp_for): Same.  Use error_at instead of error.\n+\t* c-common.c (c_common_truthvalue_conversion): Pass location to\n+\tbuild_unary_op.\n+\t(warn_for_div_by_zero): Add location argument.\n+\t* c-common.h: Add argument to build_modify_expr, build_indirect_ref,\n+\tbuild_unary_op, warn_for_div_by_zero.\n+\t* c-parser.c (c_parser_typeof_specifier): Use\n+\tprotected_set_expr_location.\n+\t(c_parser_statement_after_labels): Same.\n+\t(c_parser_condition): Same.\n+\t(c_parser_expr_no_commas): Pass correct location to build_modify_expr.\n+\t(c_parser_conditional_expression): Use protected_set_expr_location.\n+\t(c_parser_unary_expression): Pass location to build_indirect_ref.\n+\t(c_parser_postfix_expression_after_primary): Pass location to\n+\tbuild_indirect_ref, build_unary_op.\n+\t(c_parser_omp_for_loop): Set the increment expression's EXPR_LOCATION.\n+\n 2008-10-06  Joshua Kinard  <kumba@gentoo.org>\n \n \t* doc/invoke.texi: List r1x000 family under the -march MIPS option."}, {"sha": "6b37c343ae7e21a4e379eea6852ffba19e856ee2", "filename": "gcc/c-common.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -3411,7 +3411,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t     : truthvalue_false_node;\n \n     case FUNCTION_DECL:\n-      expr = build_unary_op (ADDR_EXPR, expr, 0);\n+      expr = build_unary_op (location, ADDR_EXPR, expr, 0);\n       /* Fall through.  */\n \n     case ADDR_EXPR:\n@@ -3514,10 +3514,12 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t      (EXPR_LOCATION (expr),\n \t       (TREE_SIDE_EFFECTS (expr)\n \t\t? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n-\tc_common_truthvalue_conversion (location,\n-\t\t\t\t\tbuild_unary_op (REALPART_EXPR, t, 0)),\n-\tc_common_truthvalue_conversion (location,\n-\t\t\t\t\tbuild_unary_op (IMAGPART_EXPR, t, 0)),\n+\tc_common_truthvalue_conversion\n+\t       (location,\n+\t\tbuild_unary_op (location, REALPART_EXPR, t, 0)),\n+\tc_common_truthvalue_conversion\n+\t       (location,\n+\t\tbuild_unary_op (location, IMAGPART_EXPR, t, 0)),\n \t       0));\n     }\n \n@@ -8182,18 +8184,19 @@ warn_for_unused_label (tree label)\n struct gcc_targetcm targetcm = TARGETCM_INITIALIZER;\n #endif\n \n-/* Warn for division by zero according to the value of DIVISOR.  */\n+/* Warn for division by zero according to the value of DIVISOR.  LOC\n+   is the location of the division operator.  */\n \n void\n-warn_for_div_by_zero (tree divisor)\n+warn_for_div_by_zero (location_t loc, tree divisor)\n {\n   /* If DIVISOR is zero, and has integral or fixed-point type, issue a warning\n      about division by zero.  Do not issue a warning if DIVISOR has a\n      floating-point type, since we consider 0.0/0.0 a valid way of\n      generating a NaN.  */\n   if (skip_evaluation == 0\n       && (integer_zerop (divisor) || fixed_zerop (divisor)))\n-    warning (OPT_Wdiv_by_zero, \"division by zero\");\n+    warning_at (loc, OPT_Wdiv_by_zero, \"division by zero\");\n }\n \n /* Subroutine of build_binary_op. Give warnings for comparisons"}, {"sha": "cd4eb3138b761efb32d33c514d035165bd8ba40c", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -356,8 +356,8 @@ extern tree add_stmt (tree);\n extern void push_cleanup (tree, tree, bool);\n extern tree pushdecl_top_level (tree);\n extern tree pushdecl (tree);\n-extern tree build_modify_expr (tree, enum tree_code, tree);\n-extern tree build_indirect_ref (tree, const char *, location_t);\n+extern tree build_modify_expr (location_t, tree, enum tree_code, tree);\n+extern tree build_indirect_ref (location_t, tree, const char *);\n \n extern int c_expand_decl (tree);\n \n@@ -815,7 +815,7 @@ extern tree build_case_label (tree, tree, tree);\n /* These functions must be defined by each front-end which implements\n    a variant of the C language.  They are used in c-common.c.  */\n \n-extern tree build_unary_op (enum tree_code, tree, int);\n+extern tree build_unary_op (location_t, enum tree_code, tree, int);\n extern tree build_binary_op (location_t, enum tree_code, tree, tree, int);\n extern tree perform_integral_promotions (tree);\n \n@@ -915,7 +915,7 @@ extern void warn_array_subscript_with_type_char (tree);\n extern void warn_about_parentheses (enum tree_code, enum tree_code,\n \t\t\t\t    enum tree_code);\n extern void warn_for_unused_label (tree label);\n-extern void warn_for_div_by_zero (tree divisor);\n+extern void warn_for_div_by_zero (location_t, tree divisor);\n extern void warn_for_sign_compare (location_t,\n \t\t\t\t   tree orig_op0, tree orig_op1, \n \t\t\t\t   tree op0, tree op1, "}, {"sha": "2a6dcf2361ce8b655094e0c10f7cc72fac866f1c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -3650,7 +3650,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  tree cleanup;\n \n \t  /* Build \"cleanup(&decl)\" for the destructor.  */\n-\t  cleanup = build_unary_op (ADDR_EXPR, decl, 0);\n+\t  cleanup = build_unary_op (input_location, ADDR_EXPR, decl, 0);\n \t  cleanup = build_tree_list (NULL_TREE, cleanup);\n \t  cleanup = build_function_call (cleanup_decl, cleanup);\n "}, {"sha": "b06c83039b9687cd21c8bdccc483b19e767129c0", "filename": "gcc/c-omp.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -124,7 +124,7 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n \n   /* Take and save the address of the lhs.  From then on we'll reference it\n      via indirection.  */\n-  addr = build_unary_op (ADDR_EXPR, lhs, 0);\n+  addr = build_unary_op (input_location, ADDR_EXPR, lhs, 0);\n   if (addr == error_mark_node)\n     return error_mark_node;\n   addr = save_expr (addr);\n@@ -137,12 +137,12 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n       tree var = create_tmp_var_raw (TREE_TYPE (addr), NULL);\n       addr = build4 (TARGET_EXPR, TREE_TYPE (addr), var, addr, NULL, NULL);\n     }\n-  lhs = build_indirect_ref (addr, NULL, EXPR_LOCATION (addr));\n+  lhs = build_indirect_ref (input_location, addr, NULL);\n \n   /* There are lots of warnings, errors, and conversions that need to happen\n      in the course of interpreting a statement.  Use the normal mechanisms\n      to do this, and then take it apart again.  */\n-  x = build_modify_expr (lhs, code, rhs);\n+  x = build_modify_expr (input_location, lhs, code, rhs);\n   if (x == error_mark_node)\n     return error_mark_node;\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);  \n@@ -242,7 +242,7 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n       if (!INTEGRAL_TYPE_P (TREE_TYPE (decl))\n \t  && TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE)\n \t{\n-\t  error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n+\t  error_at (elocus, \"invalid type for iteration variable %qE\", decl);\n \t  fail = true;\n \t}\n \n@@ -255,20 +255,19 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t  init = DECL_INITIAL (decl);\n \t  if (init == NULL)\n \t    {\n-\t      error (\"%H%qE is not initialized\", &elocus, decl);\n+\t      error_at (elocus, \"%qE is not initialized\", decl);\n \t      init = integer_zero_node;\n \t      fail = true;\n \t    }\n \n-\t  init = build_modify_expr (decl, NOP_EXPR, init);\n-\t  SET_EXPR_LOCATION (init, elocus);\n+\t  init = build_modify_expr (elocus, decl, NOP_EXPR, init);\n \t}\n       gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n       gcc_assert (TREE_OPERAND (init, 0) == decl);\n \n       if (cond == NULL_TREE)\n \t{\n-\t  error (\"%Hmissing controlling predicate\", &elocus);\n+\t  error_at (elocus, \"missing controlling predicate\");\n \t  fail = true;\n \t}\n       else\n@@ -329,14 +328,14 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \n \t  if (!cond_ok)\n \t    {\n-\t      error (\"%Hinvalid controlling predicate\", &elocus);\n+\t      error_at (elocus, \"invalid controlling predicate\");\n \t      fail = true;\n \t    }\n \t}\n \n       if (incr == NULL_TREE)\n \t{\n-\t  error (\"%Hmissing increment expression\", &elocus);\n+\t  error_at (elocus, \"missing increment expression\");\n \t  fail = true;\n \t}\n       else\n@@ -402,7 +401,7 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t    }\n \t  if (!incr_ok)\n \t    {\n-\t      error (\"%Hinvalid increment expression\", &elocus);\n+\t      error_at (elocus, \"invalid increment expression\");\n \t      fail = true;\n \t    }\n \t}"}, {"sha": "f08b2813010335e16e4c232ecac0ef260ff9fdda", "filename": "gcc/c-parser.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -2098,8 +2098,7 @@ c_parser_typeof_specifier (c_parser *parser)\n \t  if (DECL_P (e) || CONSTANT_CLASS_P (e))\n \t    e = build1 (NOP_EXPR, void_type_node, e);\n \n-\t  if (CAN_HAVE_LOCATION_P (e))\n-\t    SET_EXPR_LOCATION (e, here);\n+\t  protected_set_expr_location (e, here);\n \n \t  add_stmt (e);\n \t}\n@@ -3789,8 +3788,7 @@ c_parser_statement_after_labels (c_parser *parser)\n      (recursively) all of the component statements should already have\n      line numbers assigned.  ??? Can we discard no-op statements\n      earlier?  */\n-  if (stmt && CAN_HAVE_LOCATION_P (stmt))\n-    SET_EXPR_LOCATION (stmt, loc);\n+  protected_set_expr_location (stmt, loc);\n \n   parser->in_if_block = in_if_block;\n }\n@@ -3805,8 +3803,7 @@ c_parser_condition (c_parser *parser)\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_objc_common_truthvalue_conversion \n     (loc, c_parser_expression_conv (parser).value);\n-  if (CAN_HAVE_LOCATION_P (cond))\n-    SET_EXPR_LOCATION (cond, loc);\n+  protected_set_expr_location (cond, loc);\n   if (warn_sequence_point)\n     verify_sequence_points (cond);\n   return cond;\n@@ -4361,8 +4358,10 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n {\n   struct c_expr lhs, rhs, ret;\n   enum tree_code code;\n+  location_t op_location;\n   gcc_assert (!after || c_dialect_objc ());\n   lhs = c_parser_conditional_expression (parser, after);\n+  op_location = c_parser_peek_token (parser)->location;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_EQ:\n@@ -4404,7 +4403,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n   c_parser_consume_token (parser);\n   rhs = c_parser_expr_no_commas (parser, NULL);\n   rhs = default_function_array_conversion (rhs);\n-  ret.value = build_modify_expr (lhs.value, code, rhs.value);\n+  ret.value = build_modify_expr (op_location, lhs.value, code, rhs.value);\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n   else\n@@ -4439,6 +4438,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \n   cond_loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_binary_expression (parser, after);\n+  protected_set_expr_location (cond.value, cond_loc);\n \n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n@@ -4836,7 +4836,7 @@ c_parser_unary_expression (c_parser *parser)\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n       op = default_function_array_conversion (op);\n-      ret.value = build_indirect_ref (op.value, \"unary *\", loc);\n+      ret.value = build_indirect_ref (loc, op.value, \"unary *\");\n       ret.original_code = ERROR_MARK;\n       return ret;\n     case CPP_PLUS:\n@@ -5594,23 +5594,26 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      return expr;\n \t    }\n \t  c_parser_consume_token (parser);\n-\t  expr.value = build_component_ref (build_indirect_ref (expr.value,\n-\t\t\t\t\t\t\t\t\"->\", loc),\n+\t  expr.value = build_component_ref (build_indirect_ref (loc,\n+\t\t\t\t\t\t\t\texpr.value,\n+\t\t\t\t\t\t\t\t\"->\"),\n \t\t\t\t\t    ident);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n \t  c_parser_consume_token (parser);\n \t  expr = default_function_array_conversion (expr);\n-\t  expr.value = build_unary_op (POSTINCREMENT_EXPR, expr.value, 0);\n+\t  expr.value = build_unary_op (loc,\n+\t\t\t\t       POSTINCREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n \t  c_parser_consume_token (parser);\n \t  expr = default_function_array_conversion (expr);\n-\t  expr.value = build_unary_op (POSTDECREMENT_EXPR, expr.value, 0);\n+\t  expr.value = build_unary_op (loc,\n+\t\t\t\t       POSTDECREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n \tdefault:\n@@ -7594,14 +7597,17 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t       && c_parser_peek_2nd_token (parser)->type == CPP_EQ)\n \t{\n \t  struct c_expr init_exp;\n+\t  location_t init_loc;\n \n \t  decl = c_parser_postfix_expression (parser).value;\n \n \t  c_parser_require (parser, CPP_EQ, \"expected %<=%>\");\n+\t  init_loc = c_parser_peek_token (parser)->location;\n \n \t  init_exp = c_parser_expr_no_commas (parser, NULL);\n \t  init_exp = default_function_array_conversion (init_exp);\n-\t  init = build_modify_expr (decl, NOP_EXPR, init_exp.value);\n+\t  init = build_modify_expr (init_loc,\n+\t\t\t\t    decl, NOP_EXPR, init_exp.value);\n \t  init = c_process_expr_stmt (init);\n \n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n@@ -7625,15 +7631,19 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \n \t  cond = c_parser_expression_conv (parser).value;\n \t  cond = c_objc_common_truthvalue_conversion (cond_loc, cond);\n-\t  if (CAN_HAVE_LOCATION_P (cond))\n-\t    SET_EXPR_LOCATION (cond, cond_loc);\n+\t  protected_set_expr_location (cond, cond_loc);\n \t}\n       c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \n       /* Parse the increment expression.  */\n       incr = NULL_TREE;\n       if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n-\tincr = c_process_expr_stmt (c_parser_expression (parser).value);\n+\t{\n+\t  location_t incr_loc = c_parser_peek_token (parser)->location;\n+\n+\t  incr = c_process_expr_stmt (c_parser_expression (parser).value);\n+\t  protected_set_expr_location (incr, incr_loc);\n+\t}\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n \n       if (decl == NULL || decl == error_mark_node || init == error_mark_node)"}, {"sha": "ab8df375448c41790ca284ca47c74f59233163be", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 118, "deletions": 72, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1618,7 +1618,7 @@ array_to_pointer_conversion (tree exp)\n \n   /* This way is better for a COMPONENT_REF since it can\n      simplify the offset for a component.  */\n-  adr = build_unary_op (ADDR_EXPR, exp, 1);\n+  adr = build_unary_op (EXPR_LOCATION (exp), ADDR_EXPR, exp, 1);\n   return convert (ptrtype, adr);\n }\n \n@@ -1635,7 +1635,7 @@ function_to_pointer_conversion (tree exp)\n   if (TREE_NO_WARNING (orig_exp))\n     TREE_NO_WARNING (exp) = 1;\n \n-  return build_unary_op (ADDR_EXPR, exp, 0);\n+  return build_unary_op (EXPR_LOCATION (exp), ADDR_EXPR, exp, 0);\n }\n \n /* Perform the default conversion of arrays and functions to pointers.\n@@ -1972,7 +1972,7 @@ build_component_ref (tree datum, tree component)\n    LOC is the location to use for the generated tree.  */\n \n tree\n-build_indirect_ref (tree ptr, const char *errorstring, location_t loc)\n+build_indirect_ref (location_t loc, tree ptr, const char *errorstring)\n {\n   tree pointer = default_conversion (ptr);\n   tree type = TREE_TYPE (pointer);\n@@ -2008,11 +2008,11 @@ build_indirect_ref (tree ptr, const char *errorstring, location_t loc)\n \n \t  if (!COMPLETE_OR_VOID_TYPE_P (t) && TREE_CODE (t) != ARRAY_TYPE)\n \t    {\n-\t      error (\"dereferencing pointer to incomplete type\");\n+\t      error_at (loc, \"dereferencing pointer to incomplete type\");\n \t      return error_mark_node;\n \t    }\n \t  if (VOID_TYPE_P (t) && skip_evaluation == 0)\n-\t    warning (0, \"dereferencing %<void *%> pointer\");\n+\t    warning_at (loc, 0, \"dereferencing %<void *%> pointer\");\n \n \t  /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n \t     so that we get the proper error message if the result is used\n@@ -2030,7 +2030,8 @@ build_indirect_ref (tree ptr, const char *errorstring, location_t loc)\n \t}\n     }\n   else if (TREE_CODE (pointer) != ERROR_MARK)\n-    error (\"invalid type argument of %qs (have %qT)\", errorstring, type);\n+    error_at (loc,\n+\t      \"invalid type argument of %qs (have %qT)\", errorstring, type);\n   return error_mark_node;\n }\n \n@@ -2164,8 +2165,8 @@ build_array_ref (tree array, tree index, location_t loc)\n       gcc_assert (TREE_CODE (TREE_TYPE (TREE_TYPE (ar))) != FUNCTION_TYPE);\n \n       return build_indirect_ref\n-\t(build_binary_op (loc, PLUS_EXPR, ar, index, 0),\n-\t \"array indexing\", loc);\n+\t(loc, build_binary_op (loc, PLUS_EXPR, ar, index, 0),\n+\t \"array indexing\");\n     }\n }\n \f\n@@ -2748,8 +2749,7 @@ parser_build_unary_op (enum tree_code code, struct c_expr arg, location_t loc)\n   struct c_expr result;\n \n   result.original_code = ERROR_MARK;\n-  result.value = build_unary_op (code, arg.value, 0);\n-  protected_set_expr_location (result.value, loc);\n+  result.value = build_unary_op (loc, code, arg.value, 0);\n \n   if (TREE_OVERFLOW_P (result.value) && !TREE_OVERFLOW_P (arg.value))\n     overflow_warning (result.value);\n@@ -2901,16 +2901,20 @@ pointer_diff (tree op0, tree op1)\n    the default promotions (such as from short to int).\n    For ADDR_EXPR, the default promotions are not applied; FLAG nonzero\n    allows non-lvalues; this is only used to handle conversion of non-lvalue\n-   arrays to pointers in C99.  */\n+   arrays to pointers in C99.\n+\n+   LOCATION is the location of the operator.  */\n \n tree\n-build_unary_op (enum tree_code code, tree xarg, int flag)\n+build_unary_op (location_t location,\n+\t\tenum tree_code code, tree xarg, int flag)\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n   tree argtype = 0;\n   enum tree_code typecode;\n   tree val;\n+  tree ret = error_mark_node;\n   int noconvert = flag;\n   const char *invalid_op_diag;\n \n@@ -2926,7 +2930,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n   if ((invalid_op_diag\n        = targetm.invalid_unary_op (code, TREE_TYPE (xarg))))\n     {\n-      error (invalid_op_diag);\n+      error_at (location, invalid_op_diag);\n       return error_mark_node;\n     }\n \n@@ -2940,7 +2944,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t    || typecode == FIXED_POINT_TYPE || typecode == COMPLEX_TYPE\n \t    || typecode == VECTOR_TYPE))\n \t{\n-\t  error (\"wrong type argument to unary plus\");\n+\t  error_at (location, \"wrong type argument to unary plus\");\n \t  return error_mark_node;\n \t}\n       else if (!noconvert)\n@@ -2953,7 +2957,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t    || typecode == FIXED_POINT_TYPE || typecode == COMPLEX_TYPE\n \t    || typecode == VECTOR_TYPE))\n \t{\n-\t  error (\"wrong type argument to unary minus\");\n+\t  error_at (location, \"wrong type argument to unary minus\");\n \t  return error_mark_node;\n \t}\n       else if (!noconvert)\n@@ -2972,22 +2976,22 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       else if (typecode == COMPLEX_TYPE)\n \t{\n \t  code = CONJ_EXPR;\n-\t  pedwarn (input_location, OPT_pedantic, \n+\t  pedwarn (location, OPT_pedantic, \n \t\t   \"ISO C does not support %<~%> for complex conjugation\");\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n \t}\n       else\n \t{\n-\t  error (\"wrong type argument to bit-complement\");\n+\t  error_at (location, \"wrong type argument to bit-complement\");\n \t  return error_mark_node;\n \t}\n       break;\n \n     case ABS_EXPR:\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n \t{\n-\t  error (\"wrong type argument to abs\");\n+\t  error_at (location, \"wrong type argument to abs\");\n \t  return error_mark_node;\n \t}\n       else if (!noconvert)\n@@ -2999,7 +3003,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == COMPLEX_TYPE))\n \t{\n-\t  error (\"wrong type argument to conjugation\");\n+\t  error_at (location, \"wrong type argument to conjugation\");\n \t  return error_mark_node;\n \t}\n       else if (!noconvert)\n@@ -3011,27 +3015,31 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  && typecode != REAL_TYPE && typecode != POINTER_TYPE\n \t  && typecode != COMPLEX_TYPE)\n \t{\n-\t  error (\"wrong type argument to unary exclamation mark\");\n+\t  error_at (location,\n+\t\t    \"wrong type argument to unary exclamation mark\");\n \t  return error_mark_node;\n \t}\n-      arg = c_objc_common_truthvalue_conversion (input_location, arg);\n-      return invert_truthvalue (arg);\n+      arg = c_objc_common_truthvalue_conversion (location, arg);\n+      ret = invert_truthvalue (arg);\n+      goto return_build_unary_op;\n \n     case REALPART_EXPR:\n       if (TREE_CODE (arg) == COMPLEX_CST)\n-\treturn TREE_REALPART (arg);\n+\tret = TREE_REALPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\treturn fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+\tret = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n-\treturn arg;\n+\tret = arg;\n+      goto return_build_unary_op;\n \n     case IMAGPART_EXPR:\n       if (TREE_CODE (arg) == COMPLEX_CST)\n-\treturn TREE_IMAGPART (arg);\n+\tret = TREE_IMAGPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\treturn fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+\tret = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n-\treturn convert (TREE_TYPE (arg), integer_zero_node);\n+\tret = convert (TREE_TYPE (arg), integer_zero_node);\n+      goto return_build_unary_op;\n \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n@@ -3044,17 +3052,18 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t{\n \t  tree real, imag;\n \n-\t  pedwarn (input_location, OPT_pedantic, \n+\t  pedwarn (location, OPT_pedantic, \n \t\t   \"ISO C does not support %<++%> and %<--%> on complex types\");\n \n \t  arg = stabilize_reference (arg);\n-\t  real = build_unary_op (REALPART_EXPR, arg, 1);\n-\t  imag = build_unary_op (IMAGPART_EXPR, arg, 1);\n-\t  real = build_unary_op (code, real, 1);\n+\t  real = build_unary_op (EXPR_LOCATION (arg), REALPART_EXPR, arg, 1);\n+\t  imag = build_unary_op (EXPR_LOCATION (arg), IMAGPART_EXPR, arg, 1);\n+\t  real = build_unary_op (EXPR_LOCATION (arg), code, real, 1);\n \t  if (real == error_mark_node || imag == error_mark_node)\n \t    return error_mark_node;\n-\t  return build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n-\t\t\t real, imag);\n+\t  ret = build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n+\t\t\treal, imag);\n+\t  goto return_build_unary_op;\n \t}\n \n       /* Report invalid types.  */\n@@ -3063,9 +3072,9 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE)\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t    error (\"wrong type argument to increment\");\n+\t    error_at (location, \"wrong type argument to increment\");\n \t  else\n-\t    error (\"wrong type argument to decrement\");\n+\t    error_at (location, \"wrong type argument to decrement\");\n \n \t  return error_mark_node;\n \t}\n@@ -3086,18 +3095,20 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t    if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (result_type)))\n \t      {\n \t\tif (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t\t  error (\"increment of pointer to unknown structure\");\n+\t\t  error_at (location,\n+\t\t\t    \"increment of pointer to unknown structure\");\n \t\telse\n-\t\t  error (\"decrement of pointer to unknown structure\");\n+\t\t  error_at (location,\n+\t\t\t    \"decrement of pointer to unknown structure\");\n \t      }\n \t    else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE\n \t\t     || TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n \t      {\n \t\tif (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t\t  pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t  pedwarn (location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t\t   \"wrong type argument to increment\");\n \t\telse\n-\t\t  pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t  pedwarn (location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t\t   \"wrong type argument to decrement\");\n \t      }\n \n@@ -3154,7 +3165,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \tval = convert (result_type, val);\n \tif (TREE_CODE (val) != code)\n \t  TREE_NO_WARNING (val) = 1;\n-\treturn val;\n+\tret = val;\n+\tgoto return_build_unary_op;\n       }\n \n     case ADDR_EXPR:\n@@ -3166,7 +3178,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  /* Don't let this be an lvalue.  */\n \t  if (lvalue_p (TREE_OPERAND (arg, 0)))\n \t    return non_lvalue (TREE_OPERAND (arg, 0));\n-\t  return TREE_OPERAND (arg, 0);\n+\t  ret = TREE_OPERAND (arg, 0);\n+\t  goto return_build_unary_op;\n \t}\n \n       /* For &x[y], return x+y */\n@@ -3175,7 +3188,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  tree op0 = TREE_OPERAND (arg, 0);\n \t  if (!c_mark_addressable (op0))\n \t    return error_mark_node;\n-\t  return build_binary_op (EXPR_LOCATION (xarg), PLUS_EXPR,\n+\t  return build_binary_op (location, PLUS_EXPR,\n \t\t\t\t  (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE\n \t\t\t\t   ? array_to_pointer_conversion (op0)\n \t\t\t\t   : op0),\n@@ -3218,21 +3231,27 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  tree op0 = fold_convert (sizetype, fold_offsetof (arg, val)), op1;\n \n \t  op1 = fold_convert (argtype, TREE_OPERAND (val, 0));\n-\t  return fold_build2 (POINTER_PLUS_EXPR, argtype, op1, op0);\n+\t  ret = fold_build2 (POINTER_PLUS_EXPR, argtype, op1, op0);\n+\t  goto return_build_unary_op;\n \t}\n \n       val = build1 (ADDR_EXPR, argtype, arg);\n \n-      return val;\n+      ret = val;\n+      goto return_build_unary_op;\n \n     default:\n       gcc_unreachable ();\n     }\n \n   if (argtype == 0)\n     argtype = TREE_TYPE (arg);\n-  return require_constant_value ? fold_build1_initializer (code, argtype, arg)\n-\t\t\t\t: fold_build1 (code, argtype, arg);\n+  ret = require_constant_value ? fold_build1_initializer (code, argtype, arg)\n+\t\t\t       : fold_build1 (code, argtype, arg);\n+ return_build_unary_op:\n+  gcc_assert (ret != error_mark_node);\n+  protected_set_expr_location (ret, location);\n+  return ret;\n }\n \n /* Return nonzero if REF is an lvalue valid for this language.\n@@ -3837,10 +3856,13 @@ c_cast_expr (struct c_type_name *type_name, tree expr)\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n    to combine the old value of LHS with RHS to get the new value.\n-   Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */\n+   Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.\n+\n+   LOCATION is the location of the MODIFYCODE operator.  */\n \n tree\n-build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n+build_modify_expr (location_t location,\n+\t\t   tree lhs, enum tree_code modifycode, tree rhs)\n {\n   tree result;\n   tree newrhs;\n@@ -3867,7 +3889,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   if (modifycode != NOP_EXPR)\n     {\n       lhs = stabilize_reference (lhs);\n-      newrhs = build_binary_op (EXPR_LOCATION (lhs),\n+      newrhs = build_binary_op (location,\n \t\t\t\tmodifycode, lhs, rhs, 1);\n     }\n \n@@ -3915,13 +3937,17 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     {\n       result = objc_generate_write_barrier (lhs, modifycode, newrhs);\n       if (result)\n-\treturn result;\n+\t{\n+\t  protected_set_expr_location (result, location);\n+\t  return result;\n+\t}\n     }\n \n   /* Scan operands.  */\n \n   result = build2 (MODIFY_EXPR, lhstype, lhs, newrhs);\n   TREE_SIDE_EFFECTS (result) = 1;\n+  protected_set_expr_location (result, location);\n \n   /* If we got the LHS in a different type for storing in,\n      convert the result back to the nominal type of LHS\n@@ -3930,8 +3956,11 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n   if (olhstype == TREE_TYPE (result))\n     return result;\n-  return convert_for_assignment (olhstype, result, ic_assign,\n-\t\t\t\t NULL_TREE, NULL_TREE, 0);\n+\n+  result = convert_for_assignment (olhstype, result, ic_assign,\n+\t\t\t\t   NULL_TREE, NULL_TREE, 0);\n+  protected_set_expr_location (result, location);\n+  return result;\n }\n \f\n /* Convert value RHS to type TYPE as preparation for an assignment\n@@ -7942,6 +7971,7 @@ build_binary_op (location_t location, enum tree_code code,\n   tree type0, type1;\n   enum tree_code code0, code1;\n   tree op0, op1;\n+  tree ret = error_mark_node;\n   const char *invalid_op_diag;\n \n   /* Expression code to give to the expression when it is built.\n@@ -8035,9 +8065,15 @@ build_binary_op (location_t location, enum tree_code code,\n     case PLUS_EXPR:\n       /* Handle the pointer + int case.  */\n       if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n-\treturn pointer_int_sum (PLUS_EXPR, op0, op1);\n+\t{\n+\t  ret = pointer_int_sum (PLUS_EXPR, op0, op1);\n+\t  goto return_build_binary_op;\n+\t}\n       else if (code1 == POINTER_TYPE && code0 == INTEGER_TYPE)\n-\treturn pointer_int_sum (PLUS_EXPR, op1, op0);\n+\t{\n+\t  ret = pointer_int_sum (PLUS_EXPR, op1, op0);\n+\t  goto return_build_binary_op;\n+\t}\n       else\n \tcommon = 1;\n       break;\n@@ -8047,10 +8083,16 @@ build_binary_op (location_t location, enum tree_code code,\n \t We must subtract them as integers, then divide by object size.  */\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n \t  && comp_target_types (type0, type1))\n-\treturn pointer_diff (op0, op1);\n+\t{\n+\t  ret = pointer_diff (op0, op1);\n+\t  goto return_build_binary_op;\n+\t}\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n-\treturn pointer_int_sum (MINUS_EXPR, op0, op1);\n+\t{\n+\t  ret = pointer_int_sum (MINUS_EXPR, op0, op1);\n+\t  goto return_build_binary_op;\n+\t}\n       else\n \tcommon = 1;\n       break;\n@@ -8064,7 +8106,7 @@ build_binary_op (location_t location, enum tree_code code,\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      warn_for_div_by_zero (op1);\n+      warn_for_div_by_zero (location, op1);\n \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n \t   || code0 == FIXED_POINT_TYPE\n@@ -8111,7 +8153,7 @@ build_binary_op (location_t location, enum tree_code code,\n \n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n-      warn_for_div_by_zero (op1);\n+      warn_for_div_by_zero (location, op1);\n \n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -8435,7 +8477,10 @@ build_binary_op (location_t location, enum tree_code code,\n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \n \t  if (val != 0)\n-\t    return val;\n+\t    {\n+\t      ret = val;\n+\t      goto return_build_binary_op;\n+\t    }\n \n \t  op0 = xop0, op1 = xop1;\n \t  converted = 1;\n@@ -8477,18 +8522,19 @@ build_binary_op (location_t location, enum tree_code code,\n   if (build_type == NULL_TREE)\n     build_type = result_type;\n \n-  {\n-    /* Treat expressions in initializers specially as they can't trap.  */\n-    tree result = require_constant_value ? fold_build2_initializer (resultcode,\n-\t\t\t\t\t\t\t\t    build_type,\n-\t\t\t\t\t\t\t\t    op0, op1)\n-\t\t\t\t\t : fold_build2 (resultcode, build_type,\n-\t\t\t\t\t\t\top0, op1);\n-\n-    if (final_type != 0)\n-      result = convert (final_type, result);\n-    return result;\n-  }\n+  /* Treat expressions in initializers specially as they can't trap.  */\n+  ret = require_constant_value ? fold_build2_initializer (resultcode,\n+\t\t\t\t\t\t\t  build_type,\n+\t\t\t\t\t\t\t  op0, op1)\n+\t\t\t       : fold_build2 (resultcode, build_type,\n+\t\t\t\t\t      op0, op1);\n+  if (final_type != 0)\n+    ret = convert (final_type, ret);\n+\n+ return_build_binary_op:\n+  gcc_assert (ret != error_mark_node);\n+  protected_set_expr_location (ret, location);\n+  return ret;\n }\n \n "}, {"sha": "dc18acc4fb0d9b5851561c515876cff6ddaf52b9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1,3 +1,13 @@\n+2008-10-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* typeck.c (build_x_indirect_ref): Add location argument.\n+\t(cp_build_binary_op): Pass location to warn_for_div_by_zero.\n+\t(cp_build_unary_op): Add location argument.\n+\t(cp_build_modify_expr): Same.\n+\t* class.c (build_base_path): Pass location to build_indirect_ref.\n+\t* semantics.c (handle_omp_for_class_iterator): Pass elocus to\n+\tbuild_modify_expr.\n+\n 2008-10-05  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/37410"}, {"sha": "910dc291f8ebad0c8576c4b4bd41d1d8c80942d8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -299,7 +299,7 @@ build_base_path (enum tree_code code,\n     {\n       expr = build_nop (build_pointer_type (target_type), expr);\n       if (!want_pointer)\n-\texpr = build_indirect_ref (expr, NULL, EXPR_LOCATION (expr));\n+\texpr = build_indirect_ref (EXPR_LOCATION (expr), expr, NULL);\n       return expr;\n     }\n "}, {"sha": "b1bbb38dfa8e32e074f166c8fc48b9f7524f082d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -4109,7 +4109,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n   cond = cp_build_binary_op (elocus,\n \t\t\t     TREE_CODE (cond), decl, diff,\n \t\t\t     tf_warning_or_error);\n-  incr = build_modify_expr (decl, PLUS_EXPR, incr);\n+  incr = build_modify_expr (elocus, decl, PLUS_EXPR, incr);\n \n   orig_body = *body;\n   *body = push_stmt_list ();"}, {"sha": "b115e2871d851e1250fccf953b0c903a15d71ab8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -2405,8 +2405,8 @@ build_x_indirect_ref (tree expr, const char *errorstring,\n \n /* Helper function called from c-common.  */\n tree\n-build_indirect_ref (tree ptr, const char *errorstring, \n-\t\t    location_t loc __attribute__ ((__unused__)))\n+build_indirect_ref (location_t loc __attribute__ ((__unused__)),\n+\t\t    tree ptr, const char *errorstring)\n {\n   return cp_build_indirect_ref (ptr, errorstring, tf_warning_or_error);\n }\n@@ -3349,7 +3349,7 @@ cp_build_binary_op (location_t location,\n \t{\n \t  enum tree_code tcode0 = code0, tcode1 = code1;\n \n-\t  warn_for_div_by_zero (op1);\n+\t  warn_for_div_by_zero (location, op1);\n \n \t  if (tcode0 == COMPLEX_TYPE || tcode0 == VECTOR_TYPE)\n \t    tcode0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));\n@@ -3385,7 +3385,7 @@ cp_build_binary_op (location_t location,\n \n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n-      warn_for_div_by_zero (op1);\n+      warn_for_div_by_zero (location, op1);\n \n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -4642,7 +4642,8 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \n /* Hook for the c-common bits that build a unary op.  */\n tree\n-build_unary_op (enum tree_code code, tree xarg, int noconvert)\n+build_unary_op (location_t location ATTRIBUTE_UNUSED,\n+\t\tenum tree_code code, tree xarg, int noconvert)\n {\n   return cp_build_unary_op (code, xarg, noconvert, tf_warning_or_error);\n }\n@@ -5757,7 +5758,8 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n \f\n /* For use from the C common bits.  */\n tree\n-build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n+build_modify_expr (location_t location ATTRIBUTE_UNUSED,\n+\t\t   tree lhs, enum tree_code modifycode, tree rhs)\n {\n   return cp_build_modify_expr (lhs, modifycode, rhs, tf_warning_or_error);\n }\n@@ -5940,7 +5942,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t\t\t|| MAYBE_CLASS_TYPE_P (lhstype)));\n \n \t  lhs = stabilize_reference (lhs);\n-\t  newrhs = cp_build_binary_op (EXPR_LOCATION (lhs),\n+\t  newrhs = cp_build_binary_op (input_location,\n \t\t\t\t       modifycode, lhs, rhs,\n \t\t\t\t       complain);\n \t  if (newrhs == error_mark_node)"}, {"sha": "f980814c07bd1c78e3a21fd15cf69a3b232d224c", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1,3 +1,29 @@\n+2008-10-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* objc-act.c (objc_build_string_object): Pass location to\n+\tbuild_unary_op.\n+\t(init_def_list): Same.\n+\t(init_objc_symtab): Same.\n+\t(init_module_descriptor): Same.\n+\t(build_module_initializer_routine): Same.\n+\t(generate_static_references): Same.\n+\t(build_typed_selector_reference): Same.\n+\t(add_objc_string): Same.\n+\t(objc_substitute_decl): Same.\n+\t(objc_build_ivar_assignment): Same.\n+\t(objc_build_global_assignment): Same.\n+\t(objc_build_strong_cast_assignment): Same.\n+\t(generate_protocols): Same.\n+\t(build_protocol_initializer): Same.\n+\t(build_dispatch_table_initializer): Same.\n+\t(generate_protocol_list): Same.\n+\t(build_category_initializer): Same.\n+\t(build_shared_structure_initializer): Same.\n+\t(generate_shared_structures): Same.\n+\t(objc_build_protocol_expr): Same.\n+\t(build_ivar_reference): Same.\n+\t(get_super_receiver): Same.\n+\n 2008-09-23  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* objc-act.c (next_sjlj_build_enter_and_setjmp): Call"}, {"sha": "c23fb9ecba247722987a888d54a099e5c12d89c4", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 69, "deletions": 42, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1940,10 +1940,12 @@ objc_build_string_object (tree string)\n       initlist\n \t= build_tree_list (fields,\n \t\t\t   flag_next_runtime\n-\t\t\t   ? build_unary_op (ADDR_EXPR, string_class_decl, 0)\n+\t\t\t   ? build_unary_op (input_location,\n+\t\t\t\t\t     ADDR_EXPR, string_class_decl, 0)\n \t\t\t   : build_int_cst (NULL_TREE, 0));\n       fields = TREE_CHAIN (fields);\n-      initlist = tree_cons (fields, build_unary_op (ADDR_EXPR, string, 1),\n+      initlist = tree_cons (fields, build_unary_op (input_location,\n+\t\t\t\t\t\t    ADDR_EXPR, string, 1),\n \t\t\t    initlist);\n       fields = TREE_CHAIN (fields);\n       initlist = tree_cons (fields, build_int_cst (NULL_TREE, length),\n@@ -1966,7 +1968,8 @@ objc_build_string_object (tree string)\n     }\n \n   addr = convert (build_pointer_type (constant_string_type),\n-\t\t  build_unary_op (ADDR_EXPR, desc->constructor, 1));\n+\t\t  build_unary_op (input_location,\n+\t\t\t\t  ADDR_EXPR, desc->constructor, 1));\n \n   return addr;\n }\n@@ -2104,7 +2107,8 @@ init_def_list (tree type)\n       {\n \tif (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n \t  {\n-\t    expr = build_unary_op (ADDR_EXPR, impent->class_decl, 0);\n+\t    expr = build_unary_op (input_location,\n+\t\t\t\t   ADDR_EXPR, impent->class_decl, 0);\n \t    initlist = tree_cons (NULL_TREE, expr, initlist);\n \t  }\n       }\n@@ -2114,7 +2118,8 @@ init_def_list (tree type)\n       {\n \tif (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)\n \t  {\n-\t    expr = build_unary_op (ADDR_EXPR, impent->class_decl, 0);\n+\t    expr = build_unary_op (input_location,\n+\t\t\t\t   ADDR_EXPR, impent->class_decl, 0);\n \t    initlist = tree_cons (NULL_TREE, expr, initlist);\n \t  }\n       }\n@@ -2125,7 +2130,8 @@ init_def_list (tree type)\n       tree expr;\n \n       if (static_instances_decl)\n-\texpr = build_unary_op (ADDR_EXPR, static_instances_decl, 0);\n+\texpr = build_unary_op (input_location,\n+\t\t\t       ADDR_EXPR, static_instances_decl, 0);\n       else\n \texpr = build_int_cst (NULL_TREE, 0);\n \n@@ -2155,7 +2161,7 @@ init_objc_symtab (tree type)\n     initlist\n       = tree_cons (NULL_TREE,\n \t\t   convert (build_pointer_type (objc_selector_type),\n-\t\t\t    build_unary_op (ADDR_EXPR,\n+\t\t\t    build_unary_op (input_location, ADDR_EXPR,\n \t\t\t\t\t    UOBJC_SELECTOR_TABLE_decl, 1)),\n \t\t   initlist);\n \n@@ -2262,7 +2268,8 @@ init_module_descriptor (tree type)\n   /* symtab = { ..., _OBJC_SYMBOLS, ... } */\n \n   if (UOBJC_SYMBOLS_decl)\n-    expr = build_unary_op (ADDR_EXPR, UOBJC_SYMBOLS_decl, 0);\n+    expr = build_unary_op (input_location,\n+\t\t\t   ADDR_EXPR, UOBJC_SYMBOLS_decl, 0);\n   else\n     expr = build_int_cst (NULL_TREE, 0);\n   initlist = tree_cons (NULL_TREE, expr, initlist);\n@@ -2345,7 +2352,7 @@ build_module_initializer_routine (void)\n \t    (execclass_decl,\n \t     build_tree_list\n \t     (NULL_TREE,\n-\t      build_unary_op (ADDR_EXPR,\n+\t      build_unary_op (input_location, ADDR_EXPR,\n \t\t\t      UOBJC_MODULES_decl, 0))));\n   add_stmt (c_end_compound_stmt (body, true));\n \n@@ -2440,13 +2447,15 @@ generate_static_references (void)\n       klass = TREE_VALUE (cl_chain);\n       class_name = get_objc_string_decl (OBJC_TYPE_NAME (klass), class_names);\n       initlist = build_tree_list (NULL_TREE,\n-\t\t\t\t  build_unary_op (ADDR_EXPR, class_name, 1));\n+\t\t\t\t  build_unary_op (input_location, \n+\t\t\t\t\t\t  ADDR_EXPR, class_name, 1));\n \n       /* Output {..., instance, ...}.  */\n       for (in_chain = TREE_PURPOSE (cl_chain);\n \t   in_chain; in_chain = TREE_CHAIN (in_chain))\n \t{\n-\t  expr = build_unary_op (ADDR_EXPR, TREE_VALUE (in_chain), 1);\n+\t  expr = build_unary_op (input_location,\n+\t\t\t\t ADDR_EXPR, TREE_VALUE (in_chain), 1);\n \t  initlist = tree_cons (NULL_TREE, expr, initlist);\n \t}\n \n@@ -2456,7 +2465,8 @@ generate_static_references (void)\n       expr = objc_build_constructor (TREE_TYPE (decl), nreverse (initlist));\n       finish_var_decl (decl, expr);\n       decls\n-\t= tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, decl, 1), decls);\n+\t= tree_cons (NULL_TREE, build_unary_op (input_location,\n+\t\t\t\t\t\tADDR_EXPR, decl, 1), decls);\n     }\n \n   decls = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), decls);\n@@ -2628,7 +2638,7 @@ build_typed_selector_reference (tree ident, tree prototype)\n   *chain = tree_cons (prototype, ident, NULL_TREE);\n \n  return_at_index:\n-  expr = build_unary_op (ADDR_EXPR,\n+  expr = build_unary_op (input_location, ADDR_EXPR,\n \t\t\t build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n \t\t\t\t\t  build_int_cst (NULL_TREE, index),\n \t\t\t\t\t  input_location),\n@@ -2801,7 +2811,8 @@ add_objc_string (tree ident, enum string_section section)\n     {\n       if (TREE_VALUE (*chain) == ident)\n \treturn convert (string_type_node,\n-\t\t\tbuild_unary_op (ADDR_EXPR, TREE_PURPOSE (*chain), 1));\n+\t\t\tbuild_unary_op (input_location,\n+\t\t\t\t\tADDR_EXPR, TREE_PURPOSE (*chain), 1));\n \n       chain = &TREE_CHAIN (*chain);\n     }\n@@ -2820,7 +2831,8 @@ add_objc_string (tree ident, enum string_section section)\n \n   *chain = tree_cons (decl, ident, NULL_TREE);\n \n-  return convert (string_type_node, build_unary_op (ADDR_EXPR, decl, 1));\n+  return convert (string_type_node, build_unary_op (input_location,\n+\t\t\t\t\t\t    ADDR_EXPR, decl, 1));\n }\n \n static GTY(()) int class_names_idx;\n@@ -3052,10 +3064,10 @@ objc_substitute_decl (tree expr, tree oldexpr, tree newexpr)\n \t\t\t      TREE_OPERAND (expr, 1),\n \t\t\t      input_location);\n     case INDIRECT_REF:\n-      return build_indirect_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n+      return build_indirect_ref (input_location,\n+\t\t\t\t objc_substitute_decl (TREE_OPERAND (expr, 0),\n \t\t\t\t\t\t       oldexpr,\n-\t\t\t\t\t\t       newexpr), \"->\",\n-\t\t\t\t input_location);\n+\t\t\t\t\t\t       newexpr), \"->\");\n     default:\n       return expr;\n     }\n@@ -3077,7 +3089,8 @@ objc_build_ivar_assignment (tree outervar, tree lhs, tree rhs)\n        ? objc_assign_ivar_fast_decl\n        : objc_assign_ivar_decl);\n \n-  offs = convert (integer_type_node, build_unary_op (ADDR_EXPR, offs, 0));\n+  offs = convert (integer_type_node, build_unary_op (input_location,\n+\t\t\t\t\t\t     ADDR_EXPR, offs, 0));\n   offs = fold (offs);\n   func_params = tree_cons (NULL_TREE,\n \tconvert (objc_object_type, rhs),\n@@ -3095,7 +3108,7 @@ objc_build_global_assignment (tree lhs, tree rhs)\n   tree func_params = tree_cons (NULL_TREE,\n \tconvert (objc_object_type, rhs),\n \t    tree_cons (NULL_TREE, convert (build_pointer_type (objc_object_type),\n-\t\t      build_unary_op (ADDR_EXPR, lhs, 0)),\n+\t\t      build_unary_op (input_location, ADDR_EXPR, lhs, 0)),\n \t\t    NULL_TREE));\n \n   assemble_external (objc_assign_global_decl);\n@@ -3108,7 +3121,7 @@ objc_build_strong_cast_assignment (tree lhs, tree rhs)\n   tree func_params = tree_cons (NULL_TREE,\n \tconvert (objc_object_type, rhs),\n \t    tree_cons (NULL_TREE, convert (build_pointer_type (objc_object_type),\n-\t\t      build_unary_op (ADDR_EXPR, lhs, 0)),\n+\t\t      build_unary_op (input_location, ADDR_EXPR, lhs, 0)),\n \t\t    NULL_TREE));\n \n   assemble_external (objc_assign_strong_cast_decl);\n@@ -4672,7 +4685,8 @@ generate_protocols (void)\n       if (refs_decl)\n \trefs_expr = convert (build_pointer_type (build_pointer_type\n \t\t\t\t\t\t (objc_protocol_template)),\n-\t\t\t     build_unary_op (ADDR_EXPR, refs_decl, 0));\n+\t\t\t     build_unary_op (input_location,\n+\t\t\t\t\t     ADDR_EXPR, refs_decl, 0));\n       else\n \trefs_expr = build_int_cst (NULL_TREE, 0);\n \n@@ -4709,7 +4723,8 @@ build_protocol_initializer (tree type, tree protocol_name,\n   else\n     {\n       expr = convert (objc_method_proto_list_ptr,\n-\t\t      build_unary_op (ADDR_EXPR, instance_methods, 0));\n+\t\t      build_unary_op (input_location, \n+\t\t\t\t      ADDR_EXPR, instance_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -4718,7 +4733,8 @@ build_protocol_initializer (tree type, tree protocol_name,\n   else\n     {\n       expr = convert (objc_method_proto_list_ptr,\n-\t\t      build_unary_op (ADDR_EXPR, class_methods, 0));\n+\t\t      build_unary_op (input_location, \n+\t\t\t\t      ADDR_EXPR, class_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5287,7 +5303,7 @@ build_dispatch_table_initializer (tree type, tree entries)\n       elemlist\n \t= tree_cons (NULL_TREE,\n \t\t     convert (ptr_type_node,\n-\t\t\t      build_unary_op (ADDR_EXPR,\n+\t\t\t      build_unary_op (input_location, ADDR_EXPR,\n \t\t\t\t\t      METHOD_DEFINITION (entries), 1)),\n \t\t     elemlist);\n \n@@ -5471,7 +5487,8 @@ generate_protocol_list (tree i_or_p)\n       if (TREE_CODE (pval) == PROTOCOL_INTERFACE_TYPE\n \t  && PROTOCOL_FORWARD_DECL (pval))\n \t{\n-\t  e = build_unary_op (ADDR_EXPR, PROTOCOL_FORWARD_DECL (pval), 0);\n+\t  e = build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t      PROTOCOL_FORWARD_DECL (pval), 0);\n \t  initlist = tree_cons (NULL_TREE, e, initlist);\n \t}\n     }\n@@ -5514,15 +5531,17 @@ build_category_initializer (tree type, tree cat_name, tree class_name,\n   else\n     {\n       expr = convert (objc_method_list_ptr,\n-\t\t      build_unary_op (ADDR_EXPR, instance_methods, 0));\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      instance_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n   if (!class_methods)\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n       expr = convert (objc_method_list_ptr,\n-\t\t      build_unary_op (ADDR_EXPR, class_methods, 0));\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      class_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5534,7 +5553,8 @@ build_category_initializer (tree type, tree cat_name, tree class_name,\n       expr = convert (build_pointer_type\n \t\t      (build_pointer_type\n \t\t       (objc_protocol_template)),\n-\t\t      build_unary_op (ADDR_EXPR, protocol_list, 0));\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      protocol_list, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5599,7 +5619,8 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n   else\n     {\n       expr = convert (objc_ivar_list_ptr,\n-\t\t      build_unary_op (ADDR_EXPR, ivar_list, 0));\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      ivar_list, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5609,7 +5630,8 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n   else\n     {\n       expr = convert (objc_method_list_ptr,\n-\t\t      build_unary_op (ADDR_EXPR, dispatch_table, 0));\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      dispatch_table, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5636,7 +5658,8 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n       expr = convert (build_pointer_type\n \t\t      (build_pointer_type\n \t\t       (objc_protocol_template)),\n-\t\t      build_unary_op (ADDR_EXPR, protocol_list, 0));\n+\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t\t\t      protocol_list, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5790,7 +5813,7 @@ generate_shared_structures (int cls_flags)\n   initlist\n     = build_shared_structure_initializer\n       (TREE_TYPE (decl),\n-       build_unary_op (ADDR_EXPR, UOBJC_METACLASS_decl, 0),\n+       build_unary_op (input_location, ADDR_EXPR, UOBJC_METACLASS_decl, 0),\n        super_expr, name_expr,\n        convert (integer_type_node,\n \t\tTYPE_SIZE_UNIT (CLASS_STATIC_TEMPLATE\n@@ -6582,7 +6605,8 @@ objc_build_protocol_expr (tree protoname)\n   if (!PROTOCOL_FORWARD_DECL (p))\n     build_protocol_reference (p);\n \n-  expr = build_unary_op (ADDR_EXPR, PROTOCOL_FORWARD_DECL (p), 0);\n+  expr = build_unary_op (input_location, \n+\t\t\t ADDR_EXPR, PROTOCOL_FORWARD_DECL (p), 0);\n \n   /* ??? Ideally we'd build the reference with objc_protocol_type directly,\n      if we have it, rather than converting it here.  */\n@@ -6720,8 +6744,8 @@ build_ivar_reference (tree id)\n       self_decl = convert (objc_instance_type, self_decl); /* cast */\n     }\n \n-  return objc_build_component_ref (build_indirect_ref (self_decl, \"->\",\n-  \t\t\t\t\t\t       input_location), id);\n+  return objc_build_component_ref (build_indirect_ref (input_location,\n+\t\t\t\t\t\t       self_decl, \"->\"), id);\n }\n \f\n /* Compute a hash value for a given method SEL_NAME.  */\n@@ -8701,7 +8725,8 @@ get_super_receiver (void)\n \n       /* Set receiver to self.  */\n       super_expr = objc_build_component_ref (UOBJC_SUPER_decl, self_id);\n-      super_expr = build_modify_expr (super_expr, NOP_EXPR, self_decl);\n+      super_expr = build_modify_expr (input_location, \n+\t\t\t\t      super_expr, NOP_EXPR, self_decl);\n       super_expr_list = super_expr;\n \n       /* Set class to begin searching.  */\n@@ -8713,7 +8738,7 @@ get_super_receiver (void)\n \t  /* [_cls, __cls]Super are \"pre-built\" in\n \t     synth_forward_declarations.  */\n \n-\t  super_expr = build_modify_expr (super_expr, NOP_EXPR,\n+\t  super_expr = build_modify_expr (input_location, super_expr, NOP_EXPR,\n \t\t\t\t\t  ((TREE_CODE (objc_method_context)\n \t\t\t\t\t    == INSTANCE_METHOD_DECL)\n \t\t\t\t\t   ? ucls_super_ref\n@@ -8744,8 +8769,9 @@ get_super_receiver (void)\n \t\t   \"isa\" is the first ivar in a class (which it must be).  */\n \t\tsuper_class\n \t\t  = build_indirect_ref\n-\t\t    (build_c_cast (build_pointer_type (objc_class_type),\n-\t\t\t\t   super_class), \"unary *\", input_location);\n+\t\t      (input_location,\n+\t\t       build_c_cast (build_pointer_type (objc_class_type),\n+\t\t\t\t     super_class), \"unary *\");\n \t    }\n \t  else\n \t    {\n@@ -8764,14 +8790,15 @@ get_super_receiver (void)\n \t    }\n \n \t  super_expr\n-\t    = build_modify_expr (super_expr, NOP_EXPR,\n+\t    = build_modify_expr (input_location, super_expr, NOP_EXPR,\n \t\t\t\t build_c_cast (TREE_TYPE (super_expr),\n \t\t\t\t\t       super_class));\n \t}\n \n       super_expr_list = build_compound_expr (super_expr_list, super_expr);\n \n-      super_expr = build_unary_op (ADDR_EXPR, UOBJC_SUPER_decl, 0);\n+      super_expr = build_unary_op (input_location, \n+\t\t\t\t   ADDR_EXPR, UOBJC_SUPER_decl, 0);\n       super_expr_list = build_compound_expr (super_expr_list, super_expr);\n \n       return super_expr_list;"}, {"sha": "0391f3deff6cc4a0b167e33f8358f310da982e75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1,3 +1,8 @@\n+2008-10-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gcc.dg/gomp/for-1.c: Test column.\n+\t* gcc.dg/misc-column.c: Add column tests for unary arguments.\n+\n 2008-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/unchecked_convert2.adb: New test."}, {"sha": "840f94784997cf963d2d3c86ba76a6e72ccefbe1", "filename": "gcc/testsuite/gcc.dg/gomp/for-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -44,6 +44,6 @@ void foo (int j, int k)\n     baz (i);\n \n   #pragma omp for\n-  for (i = 0; i < 10; i-=3, j+=2)\t/* { dg-error \"invalid increment expression\" } */\n+  for (i = 0; i < 10; i-=3, j+=2)\t/* { dg-error \"23:invalid increment expression\" } */\n     baz (i);\n }"}, {"sha": "a24427e4baa4689800ca134f7fa71f31b6da3c1b", "filename": "gcc/testsuite/gcc.dg/misc-column.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Ftestsuite%2Fgcc.dg%2Fmisc-column.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151/gcc%2Ftestsuite%2Fgcc.dg%2Fmisc-column.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmisc-column.c?ref=c9f9eb5d07ca96c57d89e5cb8ba3b3dfe588e151", "patch": "@@ -1,5 +1,6 @@\n /* { dg-options \"-fshow-column -Wall -Wfloat-equal -pedantic\" } */\n \n+int i, j;\n float a, b;\n \n int *p;\n@@ -26,4 +27,14 @@ void foo (void)\n \n   if (p < 0) /* { dg-warning \"9:ordered comparison of pointer with\" } */\n     bar();\n+\n+  -q;\t /* { dg-error \"3:wrong type argument to unary\" } */\n+\n+  ~q;    /* { dg-error \"3:wrong type argument to bit\" } */\n+\n+  ++*q; /* { dg-error \"3:wrong type argument to increment\" } */\n+\n+  i = j / 0;  /* { dg-warning \"9:division by zero\" } */\n+\n+  i /= 0; /* { dg-warning \"5:division by zero\" } */\n }"}]}