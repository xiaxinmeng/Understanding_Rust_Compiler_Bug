{"sha": "33c45e51b4914008064d9b77f2c1fc0eea1ad060", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNjNDVlNTFiNDkxNDAwODA2NGQ5Yjc3ZjJjMWZjMGVlYTFhZDA2MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-04-09T19:21:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-04-09T19:21:24Z"}, "message": "cselib, var-tracking: Improve debug info after the cselib sp tracking changes [PR94495]\n\nOn the https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94495#c5\ntestcase GCC emits worse debug info after the PR92264 cselib.c\nchanges.\nThe difference at -O2 -g -dA in the assembly is (when ignoring debug info):\n        # DEBUG g => [argp]\n        # DEBUG k => [argp+0x20]\n        # DEBUG j => [argp+0x18]\n        # DEBUG a => di\n        # DEBUG b => si\n        # DEBUG c => dx\n        # DEBUG d => cx\n        # DEBUG h => [argp+0x8]\n        # DEBUG e => r8\n        # DEBUG i => [argp+0x10]\n        # DEBUG f => r9\n...\n .LVL4:\n+       # DEBUG h => [sp+0x10]\n+       # DEBUG i => [sp+0x18]\n+       # DEBUG j => [sp+0x20]\n+       # DEBUG k => [sp+0x28]\n        # DEBUG c => entry_value\n # SUCC: EXIT [always]  count:1073741824 (estimated locally)\n        ret\n .LVL5:\n+       # DEBUG k => [argp+0x20]\n        # DEBUG a => bx\n        # DEBUG b => si\n        # DEBUG c => dx\n        # DEBUG d => cx\n        # DEBUG e => r8\n        # DEBUG f => r9\n+       # DEBUG h => [argp+0x8]\n+       # DEBUG i => [argp+0x10]\n+       # DEBUG j => [argp+0x18]\nThis means that before the changes, h, i, j, k could be all expressed\nin DW_AT_location directly with DW_OP_fbreg <some_offset>, but now we need\nto use a location list, where in the first part of the function and last\npart of the function (everything except the ret instruction) we use that\nDW_OP_fbreg <some_offset>, but for the single ret instruction we instead\nsay those values live in something pointed by stack pointer + offset.\nIt is true, but only because stack pointer + offset is equal to DW_OP_fbreg\n<some_offset> at that point.\n\nThe var-tracking pass has for !frame_pointer_needed functions code to\ncanonicalize stack pointer uses in the insns before it hands it over\nto cselib to cfa_base_rtx + offset depending on the stack depth at each\npoint.  The problem is that on the last epilogue pop insn (the one right\nbefore ret) the canonicalization is sp = argp - 8 and add_stores records\na MO_VAL_SET operation for that argp - 8 value (which is the\nSP_DERIVED_VALUE_P VALUE the cselib changes canonicalize sp based accesses\non) and thus var-tracking from that point onwards tracks that that VALUE\n(2:2) now lives in sp.  At the end of function it of course needs to forget\nit again (or it would need on any changes to sp).  But when processing\nthat uop, we note that the VALUE has changed and anything based on it\nchanged too, so emit changes for everything.  Before that var-tracking\nitself doesn't track it in any register, so uses cselib and cselib knows\nthrough the permanent equivs how to compute it using argp (i.e. what\nwill be DW_OP_fbreg).\n\nThe following fix has two parts.  One is it detects if cselib can compute\na certain VALUE using the cfa_base_rtx and for such VALUEs doesn't add\nthe MO_VAL_SET operation, as it is better to express them using cfa_base_rtx\nrather than temporarily through something else.  And the other is make sure\nwe reuse in !frame_pointer_needed the single SP_DERIVED_VALUE_P VALUE in\nother extended basic blocks too (and other VALUEs) too.  This can be done\nbecause we have computed the stack depths at the start of each basic block\nin vt_stack_adjustments and while cselib_reset_table is called at the end\nof each extended bb, which throws away all hard registers (but the magic\ncfa_base_rtx) and so can hint cselib.c at the start of the ebb what VALUE\nthe sp hard reg has.  That means fewer VALUEs during var-tracking and more\nimportantly that they will all have the cfa_base_rtx + offset equivalency.\n\nI have performed 4 bootstraps+regtests (x86_64-linux and i686-linux,\neach with this patch (that is the new cselib + var-tracking variant) and\nonce with that patch reverted as well as all other cselib.c changes from\nthis month; once that bootstrapped, I've reapplied the cselib.c changes and\nthis patch and rebuilt cc1plus, so that the content is comparable, but built\nwith the pre-Apr 2 cselib.c+var-tracking.c (that is the old cselib one)).\n\nBelow are readelf -WS cc1plus | grep debug_ filtered to only have debug\nsections whose size actually changed, followed by dwlocstat results on\ncc1plus.  This shows that there was about 3% shrink in those .debug*\nsections for 32-bit and 1% shrink for 64-bit, with minor variable coverage\nchanges one or the other way that are IMHO insignificant.\n\n32-bit old cselib\n  [33] .debug_info       PROGBITS        00000000 29139c0 710e5fa 00      0   0  1\n  [34] .debug_abbrev     PROGBITS        00000000 9a21fba 21ad6d 00      0   0  1\n  [35] .debug_line       PROGBITS        00000000 9c3cd27 1a05e56 00      0   0  1\n  [36] .debug_str        PROGBITS        00000000 b642b7d 7cad09 01  MS  0   0  1\n  [37] .debug_loc        PROGBITS        00000000 be0d886 5792627 00      0   0  1\n  [38] .debug_ranges     PROGBITS        00000000 1159fead e57218 00      0   0  1\nsum 263075589B\n32-bit new cselib + var-tracking\n  [33] .debug_info       PROGBITS        00000000 29129c0 71065d1 00      0   0  1\n  [34] .debug_abbrev     PROGBITS        00000000 9a18f91 21af28 00      0   0  1\n  [35] .debug_line       PROGBITS        00000000 9c33eb9 195dffc 00      0   0  1\n  [36] .debug_str        PROGBITS        00000000 b591eb5 7cace0 01  MS  0   0  1\n  [37] .debug_loc        PROGBITS        00000000 bd5cb95 50185bf 00      0   0  1\n  [38] .debug_ranges     PROGBITS        00000000 10d75154 e57068 00      0   0  1\nsum 254515196B (8560393B smaller)\n64-bit old cselib\n  [33] .debug_info       PROGBITS        0000000000000000 25e64b0 84d7cc9 00      0   0  1\n  [34] .debug_abbrev     PROGBITS        0000000000000000 aabe179 225e2d 00      0   0  1\n  [35] .debug_line       PROGBITS        0000000000000000 ace3fa6 19a3505 00      0   0  1\n  [37] .debug_loc        PROGBITS        0000000000000000 ce6e960 89707bc 00      0   0  1\n  [38] .debug_ranges     PROGBITS        0000000000000000 157df11c 1c59a70 00      0   0  1\nsum 342274599B\n64-bit new cselib + var-tracking\n  [33] .debug_info       PROGBITS        0000000000000000 25e64b0 84d8e86 00      0   0  1\n  [34] .debug_abbrev     PROGBITS        0000000000000000 aabf336 225e8d 00      0   0  1\n  [35] .debug_line       PROGBITS        0000000000000000 ace51c3 199ded5 00      0   0  1\n  [37] .debug_loc        PROGBITS        0000000000000000 ce6a54d 85f62da 00      0   0  1\n  [38] .debug_ranges     PROGBITS        0000000000000000 15460827 1c59a20 00      0   0  1\nsum 338610402B (3664197B smaller)\n32-bit old cselib\ncov%\tsamples\tcumul\n0..10\t1231599/48%\t1231599/48%\n11..20\t31017/1%\t1262616/49%\n21..30\t36495/1%\t1299111/51%\n31..40\t35846/1%\t1334957/52%\n41..50\t47179/1%\t1382136/54%\n51..60\t41203/1%\t1423339/56%\n61..70\t65504/2%\t1488843/58%\n71..80\t59656/2%\t1548499/61%\n81..90\t104399/4%\t1652898/65%\n91..100\t882231/34%\t2535129/100%\n32-bit new cselib + var-tracking\ncov%\tsamples\tcumul\n0..10\t1230542/48%\t1230542/48%\n11..20\t30385/1%\t1260927/49%\n21..30\t36393/1%\t1297320/51%\n31..40\t36053/1%\t1333373/52%\n41..50\t47670/1%\t1381043/54%\n51..60\t41599/1%\t1422642/56%\n61..70\t65902/2%\t1488544/58%\n71..80\t59911/2%\t1548455/61%\n81..90\t104607/4%\t1653062/65%\n91..100\t882067/34%\t2535129/100%\n64-bit old cselib\ncov%\tsamples\tcumul\n0..10\t1233211/48%\t1233211/48%\n11..20\t31120/1%\t1264331/49%\n21..30\t39230/1%\t1303561/51%\n31..40\t38887/1%\t1342448/52%\n41..50\t47519/1%\t1389967/54%\n51..60\t45264/1%\t1435231/56%\n61..70\t69431/2%\t1504662/59%\n71..80\t62114/2%\t1566776/61%\n81..90\t104587/4%\t1671363/65%\n91..100\t876085/34%\t2547448/100%\n64-bit new cselib + var-tracking\ncov%\tsamples\tcumul\n0..10\t1233471/48%\t1233471/48%\n11..20\t31093/1%\t1264564/49%\n21..30\t39217/1%\t1303781/51%\n31..40\t38851/1%\t1342632/52%\n41..50\t47488/1%\t1390120/54%\n51..60\t45224/1%\t1435344/56%\n61..70\t69409/2%\t1504753/59%\n71..80\t62140/2%\t1566893/61%\n81..90\t104616/4%\t1671509/65%\n91..100\t875939/34%\t2547448/100%\n\n2020-04-09  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/94495\n\t* cselib.h (cselib_record_sp_cfa_base_equiv,\n\tcselib_sp_derived_value_p): Declare.\n\t* cselib.c (cselib_record_sp_cfa_base_equiv,\n\tcselib_sp_derived_value_p): New functions.\n\t* var-tracking.c (add_stores): Don't record MO_VAL_SET for\n\tcselib_sp_derived_value_p values.\n\t(vt_initialize): Call cselib_record_sp_cfa_base_equiv at the\n\tstart of extended basic blocks other than the first one\n\tfor !frame_pointer_needed functions.", "tree": {"sha": "08843d7014ff5cc8a2c54a78c87f6f7809d23db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08843d7014ff5cc8a2c54a78c87f6f7809d23db3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33c45e51b4914008064d9b77f2c1fc0eea1ad060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c45e51b4914008064d9b77f2c1fc0eea1ad060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c45e51b4914008064d9b77f2c1fc0eea1ad060", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c45e51b4914008064d9b77f2c1fc0eea1ad060/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "e5e2290ab1a3641c4103dd01390080e14ede0b02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33c45e51b4914008064d9b77f2c1fc0eea1ad060", "patch": "@@ -1,3 +1,16 @@\n+2020-04-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/94495\n+\t* cselib.h (cselib_record_sp_cfa_base_equiv,\n+\tcselib_sp_derived_value_p): Declare.\n+\t* cselib.c (cselib_record_sp_cfa_base_equiv,\n+\tcselib_sp_derived_value_p): New functions.\n+\t* var-tracking.c (add_stores): Don't record MO_VAL_SET for\n+\tcselib_sp_derived_value_p values.\n+\t(vt_initialize): Call cselib_record_sp_cfa_base_equiv at the\n+\tstart of extended basic blocks other than the first one\n+\tfor !frame_pointer_needed functions.\n+\n 2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* doc/sourcebuild.texi (aarch64_sve_hw, aarch64_sve128_hw)"}, {"sha": "3692feb13a2d2f1829773ad03c9ffffdf4552bdf", "filename": "gcc/cselib.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=33c45e51b4914008064d9b77f2c1fc0eea1ad060", "patch": "@@ -2665,6 +2665,64 @@ cselib_have_permanent_equivalences (void)\n   return cselib_any_perm_equivs;\n }\n \n+/* Record stack_pointer_rtx to be equal to\n+   (plus:P cfa_base_preserved_val offset).  Used by var-tracking\n+   at the start of basic blocks for !frame_pointer_needed functions.  */\n+\n+void\n+cselib_record_sp_cfa_base_equiv (HOST_WIDE_INT offset, rtx_insn *insn)\n+{\n+  rtx sp_derived_value = NULL_RTX;\n+  for (struct elt_loc_list *l = cfa_base_preserved_val->locs; l; l = l->next)\n+    if (GET_CODE (l->loc) == VALUE\n+\t&& SP_DERIVED_VALUE_P (l->loc))\n+      {\n+\tsp_derived_value = l->loc;\n+\tbreak;\n+      }\n+    else if (GET_CODE (l->loc) == PLUS\n+\t     && GET_CODE (XEXP (l->loc, 0)) == VALUE\n+\t     && SP_DERIVED_VALUE_P (XEXP (l->loc, 0))\n+\t     && CONST_INT_P (XEXP (l->loc, 1)))\n+      {\n+\tsp_derived_value = XEXP (l->loc, 0);\n+\toffset = offset + UINTVAL (XEXP (l->loc, 1));\n+\tbreak;\n+      }\n+  if (sp_derived_value == NULL_RTX)\n+    return;\n+  cselib_val *val\n+    = cselib_lookup_from_insn (plus_constant (Pmode, sp_derived_value, offset),\n+\t\t\t       Pmode, 1, VOIDmode, insn);\n+  if (val != NULL)\n+    cselib_record_set (stack_pointer_rtx, val, NULL);\n+}\n+\n+/* Return true if V is SP_DERIVED_VALUE_P (or SP_DERIVED_VALUE_P + CONST_INT)\n+   that can be expressed using cfa_base_preserved_val + CONST_INT.  */\n+\n+bool\n+cselib_sp_derived_value_p (cselib_val *v)\n+{\n+  if (!SP_DERIVED_VALUE_P (v->val_rtx))\n+    for (struct elt_loc_list *l = v->locs; l; l = l->next)\n+      if (GET_CODE (l->loc) == PLUS\n+\t  && GET_CODE (XEXP (l->loc, 0)) == VALUE\n+\t  && SP_DERIVED_VALUE_P (XEXP (l->loc, 0))\n+\t  && CONST_INT_P (XEXP (l->loc, 1)))\n+\tv = CSELIB_VAL_PTR (XEXP (l->loc, 0));\n+  if (!SP_DERIVED_VALUE_P (v->val_rtx))\n+    return false;\n+  for (struct elt_loc_list *l = v->locs; l; l = l->next)\n+    if (l->loc == cfa_base_preserved_val->val_rtx)\n+      return true;\n+    else if (GET_CODE (l->loc) == PLUS\n+\t     && XEXP (l->loc, 0) == cfa_base_preserved_val->val_rtx\n+\t     && CONST_INT_P (XEXP (l->loc, 1)))\n+      return true;\n+  return false;\n+}\n+\n /* There is no good way to determine how many elements there can be\n    in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n #define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)"}, {"sha": "adc6cc0b1bce5c99092fe34c1bdb64a894627470", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=33c45e51b4914008064d9b77f2c1fc0eea1ad060", "patch": "@@ -104,6 +104,8 @@ extern void cselib_add_permanent_equiv (cselib_val *, rtx, rtx_insn *);\n extern bool cselib_have_permanent_equivalences (void);\n extern void cselib_set_value_sp_based (cselib_val *);\n extern bool cselib_sp_based_value_p (cselib_val *);\n+extern void cselib_record_sp_cfa_base_equiv (HOST_WIDE_INT, rtx_insn *);\n+extern bool cselib_sp_derived_value_p (cselib_val *);\n \n extern void dump_cselib_table (FILE *);\n "}, {"sha": "0d39326aa6378ec8bf02f8063b5733848a870783", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c45e51b4914008064d9b77f2c1fc0eea1ad060/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=33c45e51b4914008064d9b77f2c1fc0eea1ad060", "patch": "@@ -6117,6 +6117,19 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       && preserve)\n     cselib_set_value_sp_based (v);\n \n+  /* Don't record MO_VAL_SET for VALUEs that can be described using\n+     cfa_base_rtx or cfa_base_rtx + CONST_INT, cselib already knows\n+     all the needed equivalences and they shouldn't change depending\n+     on which register holds that VALUE in some instruction.  */\n+  if (!frame_pointer_needed\n+      && cfa_base_rtx\n+      && cselib_sp_derived_value_p (v))\n+    {\n+      if (preserve)\n+\tpreserve_value (v);\n+      return;\n+    }\n+\n   nloc = replace_expr_with_values (oloc);\n   if (nloc)\n     oloc = nloc;\n@@ -10154,6 +10167,7 @@ vt_initialize (void)\n \n   vt_add_function_parameters ();\n \n+  bool record_sp_value = false;\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       rtx_insn *insn;\n@@ -10168,6 +10182,15 @@ vt_initialize (void)\n \t\t     cselib_get_next_uid ());\n \t}\n \n+      if (MAY_HAVE_DEBUG_BIND_INSNS\n+\t  && cfa_base_rtx\n+\t  && !frame_pointer_needed\n+\t  && record_sp_value)\n+\tcselib_record_sp_cfa_base_equiv (-cfa_base_offset\n+\t\t\t\t\t - VTI (bb)->in.stack_adjust,\n+\t\t\t\t\t BB_HEAD (bb));\n+      record_sp_value = true;\n+\n       first_bb = bb;\n       for (;;)\n \t{"}]}