{"sha": "c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhNzM1ZmE5ZGY3ZWNhNDY2NmM4ZGE1ZTUxZWQ5YzVhYjdjYzgxYQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-07-07T19:01:54Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-09-14T15:55:37Z"}, "message": "coroutines: Expose implementation state to the debugger.\n\nIn the process of transforming a coroutine into the separate representation\nas the ramp function and a state machine, we generate some variables that\nare of interest to a user during debugging.  Any variable that is persistent\nfor the execution of the coroutine is placed into the coroutine frame.\n\nIn particular:\n  The promise object.\n  The function pointers for the resumer and destroyer.\n  The current resume index (suspend point).\n  The handle that represents this coroutine 'self handle'.\n  Any handle provided for a continuation coroutine.\n  Whether the coroutine frame is allocated and needs to be freed.\n\nVisibility of some of these has already been requested by end users.\n\nThis patch ensures that such variables have names that are usable in a\ndebugger, but are in the reserved namespace for the implementation (they\nall begin with _Coro_).  The identifiers are generated lazily when the\nfirst coroutine is encountered.\n\nWe place the variables into the outermost bind expression and then add a\nDECL_VALUE_EXPR to each that points to the frame entry.\n\nThese changes simplify the handling of the variables in the body of the\nfunction (in particular, the use of the DECL_VALUE_EXPR means that we now\nno longer need to rewrite proxies for the promise and coroutine handles into\nthe frame->offset form).\n\nPartial improvement to debugging (PR c++/99215).\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (coro_resume_fn_id, coro_destroy_fn_id,\n\tcoro_promise_id, coro_frame_needs_free_id, coro_resume_index_id,\n\tcoro_self_handle_id, coro_actor_continue_id,\n\tcoro_frame_i_a_r_c_id): New.\n\t(coro_init_identifiers): Initialize new name identifiers.\n\t(coro_promise_type_found_p): Use pre-built identifiers.\n\t(struct await_xform_data): Remove unused fields.\n\t(transform_await_expr): Delete code that is now unused.\n\t(build_actor_fn): Simplify interface, use pre-built identifiers and\n\tremove transforms that are no longer needed.\n\t(build_destroy_fn): Use revised field names.\n\t(register_local_var_uses): Use pre-built identifiers.\n\t(coro_rewrite_function_body): Simplify interface, use pre-built\n\tidentifiers.  Generate proxy vars in the outer bind expr scope for the\n\timplementation state that we wish to expose.\n\t(morph_fn_to_coro): Adjust comments for new variable names, use pre-\n\tbuilt identifiers.  Remove unused code to generate frame entries for\n\tthe implementation state.  Adjust call for build_actor_fn.", "tree": {"sha": "87ad38cdd386dfe7e74c9ee171f0bbf21f8cc6a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87ad38cdd386dfe7e74c9ee171f0bbf21f8cc6a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de07cff96abd43f6f65dcf333958899c2ec42598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de07cff96abd43f6f65dcf333958899c2ec42598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de07cff96abd43f6f65dcf333958899c2ec42598"}], "stats": {"total": 285, "additions": 137, "deletions": 148}, "files": [{"sha": "cd774b78ae0fae408d22d8dcbd7d3002a3d7675e", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 137, "deletions": 148, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=c5a735fa9df7eca4666c8da5e51ed9c5ab7cc81a", "patch": "@@ -215,7 +215,19 @@ static GTY(()) tree coro_await_ready_identifier;\n static GTY(()) tree coro_await_suspend_identifier;\n static GTY(()) tree coro_await_resume_identifier;\n \n-/* Create the identifiers used by the coroutines library interfaces.  */\n+/* Accessors for the coroutine frame state used by the implementation.  */\n+\n+static GTY(()) tree coro_resume_fn_id;\n+static GTY(()) tree coro_destroy_fn_id;\n+static GTY(()) tree coro_promise_id;\n+static GTY(()) tree coro_frame_needs_free_id;\n+static GTY(()) tree coro_resume_index_id;\n+static GTY(()) tree coro_self_handle_id;\n+static GTY(()) tree coro_actor_continue_id;\n+static GTY(()) tree coro_frame_i_a_r_c_id;\n+\n+/* Create the identifiers used by the coroutines library interfaces and\n+   the implementation frame state.  */\n \n static void\n coro_init_identifiers ()\n@@ -241,6 +253,16 @@ coro_init_identifiers ()\n   coro_await_ready_identifier = get_identifier (\"await_ready\");\n   coro_await_suspend_identifier = get_identifier (\"await_suspend\");\n   coro_await_resume_identifier = get_identifier (\"await_resume\");\n+\n+  /* Coroutine state frame field accessors.  */\n+  coro_resume_fn_id = get_identifier (\"_Coro_resume_fn\");\n+  coro_destroy_fn_id = get_identifier (\"_Coro_destroy_fn\");\n+  coro_promise_id = get_identifier (\"_Coro_promise\");\n+  coro_frame_needs_free_id = get_identifier (\"_Coro_frame_needs_free\");\n+  coro_frame_i_a_r_c_id = get_identifier (\"_Coro_initial_await_resume_called\");\n+  coro_resume_index_id = get_identifier (\"_Coro_resume_index\");\n+  coro_self_handle_id = get_identifier (\"_Coro_self_handle\");\n+  coro_actor_continue_id = get_identifier (\"_Coro_actor_continue\");\n }\n \n /* Trees we only need to set up once.  */\n@@ -513,12 +535,12 @@ coro_promise_type_found_p (tree fndecl, location_t loc)\n       /* Build a proxy for a handle to \"self\" as the param to\n \t await_suspend() calls.  */\n       coro_info->self_h_proxy\n-\t= build_lang_decl (VAR_DECL, get_identifier (\"self_h.proxy\"),\n+\t= build_lang_decl (VAR_DECL, coro_self_handle_id,\n \t\t\t   coro_info->handle_type);\n \n       /* Build a proxy for the promise so that we can perform lookups.  */\n       coro_info->promise_proxy\n-\t= build_lang_decl (VAR_DECL, get_identifier (\"promise.proxy\"),\n+\t= build_lang_decl (VAR_DECL, coro_promise_id,\n \t\t\t   coro_info->promise_type);\n \n       /* Note where we first saw a coroutine keyword.  */\n@@ -1864,10 +1886,6 @@ struct await_xform_data\n {\n   tree actor_fn;   /* Decl for context.  */\n   tree actor_frame;\n-  tree promise_proxy;\n-  tree real_promise;\n-  tree self_h_proxy;\n-  tree real_self_h;\n };\n \n /* When we built the await expressions, we didn't know the coro frame\n@@ -1888,7 +1906,6 @@ transform_await_expr (tree await_expr, await_xform_data *xform)\n   /* So, on entry, we have:\n      in : CO_AWAIT_EXPR (a, e_proxy, o, awr_call_vector, mode)\n \t  We no longer need a [it had diagnostic value, maybe?]\n-\t  We need to replace the promise proxy in all elements\n \t  We need to replace the e_proxy in the awr_call.  */\n \n   tree coro_frame_type = TREE_TYPE (xform->actor_frame);\n@@ -1914,16 +1931,6 @@ transform_await_expr (tree await_expr, await_xform_data *xform)\n       TREE_OPERAND (await_expr, 1) = as;\n     }\n \n-  /* Now do the self_handle.  */\n-  data.from = xform->self_h_proxy;\n-  data.to = xform->real_self_h;\n-  cp_walk_tree (&await_expr, replace_proxy, &data, NULL);\n-\n-  /* Now do the promise.  */\n-  data.from = xform->promise_proxy;\n-  data.to = xform->real_promise;\n-  cp_walk_tree (&await_expr, replace_proxy, &data, NULL);\n-\n   return await_expr;\n }\n \n@@ -2110,15 +2117,13 @@ coro_get_frame_dtor (tree coro_fp, tree orig, tree frame_size,\n \n static void\n build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n-\t\ttree orig, hash_map<tree, param_info> *param_uses,\n-\t\thash_map<tree, local_var_info> *local_var_uses,\n-\t\tvec<tree, va_gc> *param_dtor_list, tree resume_fn_field,\n-\t\ttree resume_idx_field, unsigned body_count, tree frame_size)\n+\t\ttree orig, hash_map<tree, local_var_info> *local_var_uses,\n+\t\tvec<tree, va_gc> *param_dtor_list,\n+\t\ttree resume_idx_var, unsigned body_count, tree frame_size)\n {\n   verify_stmt_tree (fnbody);\n   /* Some things we inherit from the original function.  */\n   tree handle_type = get_coroutine_handle_type (orig);\n-  tree self_h_proxy = get_coroutine_self_handle_proxy (orig);\n   tree promise_type = get_coroutine_promise_type (orig);\n   tree promise_proxy = get_coroutine_promise_proxy (orig);\n \n@@ -2136,11 +2141,12 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree top_block = make_node (BLOCK);\n   BIND_EXPR_BLOCK (actor_bind) = top_block;\n \n-  tree continuation = coro_build_artificial_var (loc, \"_Coro_actor_continue\",\n+  tree continuation = coro_build_artificial_var (loc, coro_actor_continue_id,\n \t\t\t\t\t\t void_coro_handle_type, actor,\n \t\t\t\t\t\t NULL_TREE);\n \n   BIND_EXPR_VARS (actor_bind) = continuation;\n+  BLOCK_VARS (top_block) = BIND_EXPR_VARS (actor_bind) ;\n \n   /* Link in the block associated with the outer scope of the re-written\n      function body.  */\n@@ -2198,9 +2204,8 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n     = {actor, actor_frame, coro_frame_type, loc, local_var_uses};\n   cp_walk_tree (&fnbody, transform_local_var_uses, &xform_vars_data, NULL);\n \n-  tree resume_idx_name = get_identifier (\"__resume_at\");\n-  tree rat_field = lookup_member (coro_frame_type, resume_idx_name, 1, 0,\n-\t\t\t\t  tf_warning_or_error);\n+  tree rat_field = lookup_member (coro_frame_type, coro_resume_index_id,\n+\t\t\t\t  1, 0, tf_warning_or_error);\n   tree rat = build3 (COMPONENT_REF, short_unsigned_type_node, actor_frame,\n \t\t     rat_field, NULL_TREE);\n \n@@ -2302,14 +2307,8 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree r = build_stmt (loc, LABEL_EXPR, actor_begin_label);\n   add_stmt (r);\n \n-  /* actor's version of the promise.  */\n-  tree ap_m = lookup_member (coro_frame_type, get_identifier (\"__p\"), 1, 0,\n-\t\t\t     tf_warning_or_error);\n-  tree ap = build_class_member_access_expr (actor_frame, ap_m, NULL_TREE, false,\n-\t\t\t\t\t    tf_warning_or_error);\n-\n   /* actor's coroutine 'self handle'.  */\n-  tree ash_m = lookup_member (coro_frame_type, get_identifier (\"__self_h\"), 1,\n+  tree ash_m = lookup_member (coro_frame_type, coro_self_handle_id, 1,\n \t\t\t      0, tf_warning_or_error);\n   tree ash = build_class_member_access_expr (actor_frame, ash_m, NULL_TREE,\n \t\t\t\t\t     false, tf_warning_or_error);\n@@ -2329,37 +2328,13 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   /* Now we know the real promise, and enough about the frame layout to\n      decide where to put things.  */\n \n-  await_xform_data xform\n-    = {actor, actor_frame, promise_proxy, ap, self_h_proxy, ash};\n+  await_xform_data xform = {actor, actor_frame};\n \n   /* Transform the await expressions in the function body.  Only do each\n      await tree once!  */\n   hash_set<tree> pset;\n   cp_walk_tree (&fnbody, transform_await_wrapper, &xform, &pset);\n \n-  /* Now replace the promise proxy with its real value.  */\n-  proxy_replace p_data;\n-  p_data.from = promise_proxy;\n-  p_data.to = ap;\n-  cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n-\n-  /* The rewrite of the function adds code to set the __resume field to\n-     nullptr when the coroutine is done and also the index to zero when\n-     calling an unhandled exception.  These are represented by two proxies\n-     in the function, so rewrite them to the proper frame access.  */\n-  tree resume_m\n-    = lookup_member (coro_frame_type, get_identifier (\"__resume\"),\n-\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n-  tree res_x = build_class_member_access_expr (actor_frame, resume_m, NULL_TREE,\n-\t\t\t\t\t       false, tf_warning_or_error);\n-  p_data.from = resume_fn_field;\n-  p_data.to = res_x;\n-  cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n-\n-  p_data.from = resume_idx_field;\n-  p_data.to = rat;\n-  cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n-\n   /* Add in our function body with the co_returns rewritten to final form.  */\n   add_stmt (fnbody);\n \n@@ -2368,7 +2343,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   add_stmt (r);\n \n   /* Destructors for the things we built explicitly.  */\n-  r = build_special_member_call (ap, complete_dtor_identifier, NULL,\n+  r = build_special_member_call (promise_proxy, complete_dtor_identifier, NULL,\n \t\t\t\t promise_type, LOOKUP_NORMAL,\n \t\t\t\t tf_warning_or_error);\n   add_stmt (r);\n@@ -2381,7 +2356,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   /* Here deallocate the frame (if we allocated it), which we will have at\n      present.  */\n   tree fnf_m\n-    = lookup_member (coro_frame_type, get_identifier (\"__frame_needs_free\"), 1,\n+    = lookup_member (coro_frame_type, coro_frame_needs_free_id, 1,\n \t\t     0, tf_warning_or_error);\n   tree fnf2_x = build_class_member_access_expr (actor_frame, fnf_m, NULL_TREE,\n \t\t\t\t\t\tfalse, tf_warning_or_error);\n@@ -2460,18 +2435,10 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   gcc_checking_assert (maybe_cleanup_point_expr_void (r) == r);\n   add_stmt (r);\n \n-  /* We will need to know which resume point number should be encoded.  */\n-  tree res_idx_m\n-    = lookup_member (coro_frame_type, resume_idx_name,\n-\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n-  tree resume_pt_number\n-    = build_class_member_access_expr (actor_frame, res_idx_m, NULL_TREE, false,\n-\t\t\t\t      tf_warning_or_error);\n-\n   /* We've now rewritten the tree and added the initial and final\n      co_awaits.  Now pass over the tree and expand the co_awaits.  */\n \n-  coro_aw_data data = {actor, actor_fp, resume_pt_number, NULL_TREE,\n+  coro_aw_data data = {actor, actor_fp, resume_idx_var, NULL_TREE,\n \t\t       ash, del_promise_label, ret_label,\n \t\t       continue_label, continuation, 2};\n   cp_walk_tree (&actor_body, await_statement_expander, &data, NULL);\n@@ -2485,7 +2452,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n }\n \n /* The prototype 'destroy' function :\n-   frame->__resume_at |= 1;\n+   frame->__Coro_resume_index |= 1;\n    actor (frame);  */\n \n static void\n@@ -2504,11 +2471,10 @@ build_destroy_fn (location_t loc, tree coro_frame_type, tree destroy,\n \n   tree destr_frame = build1 (INDIRECT_REF, coro_frame_type, destr_fp);\n \n-  tree resume_idx_name = get_identifier (\"__resume_at\");\n-  tree rat_field = lookup_member (coro_frame_type, resume_idx_name, 1, 0,\n-\t\t\t\t  tf_warning_or_error);\n-  tree rat = build3 (COMPONENT_REF, short_unsigned_type_node, destr_frame,\n-\t\t     rat_field, NULL_TREE);\n+  tree rat_field = lookup_member (coro_frame_type, coro_resume_index_id,\n+\t\t\t\t  1, 0, tf_warning_or_error);\n+  tree rat = build3 (COMPONENT_REF, short_unsigned_type_node,\n+\t\t\t destr_frame, rat_field, NULL_TREE);\n \n   /* _resume_at |= 1 */\n   tree dstr_idx = build2 (BIT_IOR_EXPR, short_unsigned_type_node, rat,\n@@ -3927,6 +3893,7 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t     identify them in the coroutine frame.  */\n \t  tree lvname = DECL_NAME (lvar);\n \t  char *buf;\n+\n \t  /* The outermost bind scope contains the artificial variables that\n \t     we inject to implement the coro state machine.  We want to be able\n \t     to inspect these in debugging.  */\n@@ -3936,7 +3903,7 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t    buf = xasprintf (\"%s_%u_%u\", IDENTIFIER_POINTER (lvname),\n \t\t\t     lvd->nest_depth, lvd->bind_indx);\n \t  else\n-\t    buf = xasprintf (\"_D%u.%u.%u\", DECL_UID (lvar), lvd->nest_depth,\n+\t    buf = xasprintf (\"_D%u_%u_%u\", DECL_UID (lvar), lvd->nest_depth,\n \t\t\t     lvd->bind_indx);\n \t  /* TODO: Figure out if we should build a local type that has any\n \t     excess alignment or size from the original decl.  */\n@@ -4023,8 +3990,8 @@ coro_build_actor_or_destroy_function (tree orig, tree fn_type,\n \n static tree\n coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n-\t\t\t    tree resume_fn_ptr_type, tree& resume_fn_field,\n-\t\t\t    tree& resume_idx_field, tree& fs_label)\n+\t\t\t    tree resume_fn_ptr_type,\n+\t\t\t    tree& resume_idx_var, tree& fs_label)\n {\n   /* This will be our new outer scope.  */\n   tree update_body = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n@@ -4057,7 +4024,6 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n \n   /* Wrap the function body in a try {} catch (...) {} block, if exceptions\n      are enabled.  */\n-  tree promise = get_coroutine_promise_proxy (orig);\n   tree var_list = NULL_TREE;\n   tree initial_await = build_init_or_final_await (fn_start, false);\n \n@@ -4068,24 +4034,61 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n   tree return_void\n     = get_coroutine_return_void_expr (current_function_decl, fn_start, false);\n \n+  /* The pointer to the resume function.  */\n+  tree resume_fn_ptr\n+    = coro_build_artificial_var (fn_start, coro_resume_fn_id,\n+\t\t\t\t resume_fn_ptr_type, orig, NULL_TREE);\n+  DECL_CHAIN (resume_fn_ptr) = var_list;\n+  var_list = resume_fn_ptr;\n+  add_decl_expr (resume_fn_ptr);\n+\n   /* We will need to be able to set the resume function pointer to nullptr\n      to signal that the coroutine is 'done'.  */\n-  resume_fn_field\n-    = build_lang_decl (VAR_DECL, get_identifier (\"resume.fn.ptr.proxy\"),\n-\t\t       resume_fn_ptr_type);\n-  DECL_ARTIFICIAL (resume_fn_field) = true;\n   tree zero_resume\n     = build1 (CONVERT_EXPR, resume_fn_ptr_type, integer_zero_node);\n-  zero_resume\n-    = build2 (INIT_EXPR, resume_fn_ptr_type, resume_fn_field, zero_resume);\n-  /* Likewise, the resume index needs to be reset.  */\n-  resume_idx_field\n-    = build_lang_decl (VAR_DECL, get_identifier (\"resume.index.proxy\"),\n-\t\t       short_unsigned_type_node);\n-  DECL_ARTIFICIAL (resume_idx_field) = true;\n-  tree zero_resume_idx = build_int_cst (short_unsigned_type_node, 0);\n-  zero_resume_idx = build2 (INIT_EXPR, short_unsigned_type_node,\n-\t\t\t    resume_idx_field, zero_resume_idx);\n+\n+  /* The pointer to the destroy function.  */\n+  tree var = coro_build_artificial_var (fn_start, coro_destroy_fn_id,\n+\t\t\t\t\tresume_fn_ptr_type, orig, NULL_TREE);\n+  DECL_CHAIN (var) = var_list;\n+  var_list = var;\n+  add_decl_expr (var);\n+\n+  /* The promise was created on demand when parsing we now link it into\n+      our scope.  */\n+  tree promise = get_coroutine_promise_proxy (orig);\n+  DECL_CONTEXT (promise) = orig;\n+  DECL_SOURCE_LOCATION (promise) = fn_start;\n+  DECL_CHAIN (promise) = var_list;\n+  var_list = promise;\n+  add_decl_expr (promise);\n+\n+  /* We need a handle to this coroutine, which is passed to every\n+     await_suspend().  This was created on demand when parsing we now link it\n+     into our scope.  */\n+  var = get_coroutine_self_handle_proxy (orig);\n+  DECL_CONTEXT (var) = orig;\n+  DECL_SOURCE_LOCATION (var) = fn_start;\n+  DECL_CHAIN (var) = var_list;\n+  var_list = var;\n+  add_decl_expr (var);\n+\n+\n+  /* We create a resume index, this is initialized in the ramp.  */\n+  resume_idx_var\n+    = coro_build_artificial_var (fn_start, coro_resume_index_id,\n+\t\t\t\t short_unsigned_type_node, orig, NULL_TREE);\n+  DECL_CHAIN (resume_idx_var) = var_list;\n+  var_list = resume_idx_var;\n+  add_decl_expr (resume_idx_var);\n+\n+  /* If the coroutine has a frame that needs to be freed, this will be set by\n+     the ramp.  */\n+  var = coro_build_artificial_var (fn_start, coro_frame_needs_free_id,\n+\t\t\t\t   boolean_type_node, orig, NULL_TREE);\n+  DECL_CHAIN (var) = var_list;\n+  var_list = var;\n+  add_decl_expr (var);\n \n   if (flag_exceptions)\n     {\n@@ -4097,8 +4100,7 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n       /* Create and initialize the initial-await-resume-called variable per\n \t [dcl.fct.def.coroutine] / 5.3.  */\n       tree i_a_r_c\n-\t= coro_build_artificial_var (fn_start,\n-\t\t\t\t     \"_Coro_initial_await_resume_called\",\n+\t= coro_build_artificial_var (fn_start, coro_frame_i_a_r_c_id,\n \t\t\t\t     boolean_type_node, orig,\n \t\t\t\t     boolean_false_node);\n       DECL_CHAIN (i_a_r_c) = var_list;\n@@ -4151,10 +4153,14 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n \t If the unhandled exception method returns, then we continue\n \t to the final await expression (which duplicates the clearing of\n \t the field). */\n-      finish_expr_stmt (zero_resume);\n-      finish_expr_stmt (zero_resume_idx);\n-      ueh = maybe_cleanup_point_expr_void (ueh);\n-      add_stmt (ueh);\n+      tree r = build2 (MODIFY_EXPR, resume_fn_ptr_type, resume_fn_ptr,\n+\t\t       zero_resume);\n+      finish_expr_stmt (r);\n+      tree short_zero = build_int_cst (short_unsigned_type_node, 0);\n+      r = build2 (MODIFY_EXPR, short_unsigned_type_node, resume_idx_var,\n+\t\t  short_zero);\n+      finish_expr_stmt (r);\n+      finish_expr_stmt (ueh);\n       finish_handler (handler);\n       TRY_HANDLERS (tcb) = pop_stmt_list (TRY_HANDLERS (tcb));\n     }\n@@ -4189,6 +4195,8 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n   /* Before entering the final suspend point, we signal that this point has\n      been reached by setting the resume function pointer to zero (this is\n      what the 'done()' builtin tests) as per the current ABI.  */\n+  zero_resume = build2 (MODIFY_EXPR, resume_fn_ptr_type, resume_fn_ptr,\n+\t\t\tzero_resume);\n   finish_expr_stmt (zero_resume);\n   finish_expr_stmt (build_init_or_final_await (fn_start, true));\n   BIND_EXPR_BODY (update_body) = pop_stmt_list (BIND_EXPR_BODY (update_body));\n@@ -4216,15 +4224,15 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n  declare a dummy coro frame.\n  struct _R_frame {\n   using handle_type = coro::coroutine_handle<coro1::promise_type>;\n-  void (*__resume)(_R_frame *);\n-  void (*__destroy)(_R_frame *);\n-  coro1::promise_type __p;\n-  bool frame_needs_free; free the coro frame mem if set.\n-  bool i_a_r_c; [dcl.fct.def.coroutine] / 5.3\n-  short __resume_at;\n-  handle_type self_handle;\n-  (maybe) parameter copies.\n-  (maybe) local variables saved (including awaitables)\n+  void (*_Coro_resume_fn)(_R_frame *);\n+  void (*_Coro_destroy_fn)(_R_frame *);\n+  coro1::promise_type _Coro_promise;\n+  bool _Coro_frame_needs_free; free the coro frame mem if set.\n+  bool _Coro_i_a_r_c; [dcl.fct.def.coroutine] / 5.3\n+  short _Coro_resume_index;\n+  handle_type _Coro_self_handle;\n+  parameter copies (were required).\n+  local variables saved (including awaitables)\n   (maybe) trailing space.\n  };  */\n \n@@ -4316,7 +4324,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   /* 2. Types we need to define or look up.  */\n \n-  tree fr_name = get_fn_local_identifier (orig, \"frame\");\n+  tree fr_name = get_fn_local_identifier (orig, \"Frame\");\n   tree coro_frame_type = xref_tag (record_type, fr_name);\n   DECL_CONTEXT (TYPE_NAME (coro_frame_type)) = current_scope ();\n   tree coro_frame_ptr = build_pointer_type (coro_frame_type);\n@@ -4333,33 +4341,16 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* Construct the wrapped function body; we will analyze this to determine\n      the requirements for the coroutine frame.  */\n \n-  tree resume_fn_field = NULL_TREE;\n-  tree resume_idx_field = NULL_TREE;\n+  tree resume_idx_var = NULL_TREE;\n   tree fs_label = NULL_TREE;\n   fnbody = coro_rewrite_function_body (fn_start, fnbody, orig,\n-\t\t\t\t       act_des_fn_ptr, resume_fn_field,\n-\t\t\t\t       resume_idx_field, fs_label);\n+\t\t\t\t       act_des_fn_ptr,\n+\t\t\t\t       resume_idx_var, fs_label);\n   /* Build our dummy coro frame layout.  */\n   coro_frame_type = begin_class_definition (coro_frame_type);\n \n+  /* The fields for the coro frame.  */\n   tree field_list = NULL_TREE;\n-  tree resume_name\n-    = coro_make_frame_entry (&field_list, \"__resume\",\n-\t\t\t     act_des_fn_ptr, fn_start);\n-  tree destroy_name\n-    = coro_make_frame_entry (&field_list, \"__destroy\",\n-\t\t\t     act_des_fn_ptr, fn_start);\n-  tree promise_name\n-    = coro_make_frame_entry (&field_list, \"__p\", promise_type, fn_start);\n-  tree fnf_name = coro_make_frame_entry (&field_list, \"__frame_needs_free\",\n-\t\t\t\t\t boolean_type_node, fn_start);\n-  tree resume_idx_name\n-    = coro_make_frame_entry (&field_list, \"__resume_at\",\n-\t\t\t     short_unsigned_type_node, fn_start);\n-\n-  /* We need a handle to this coroutine, which is passed to every\n-     await_suspend().  There's no point in creating it over and over.  */\n-  (void) coro_make_frame_entry (&field_list, \"__self_h\", handle_type, fn_start);\n \n   /* Now add in fields for function params (if there are any).\n      We do not attempt elision of copies at this stage, we do analyze the\n@@ -4417,14 +4408,14 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  if (DECL_NAME (arg))\n \t    {\n \t      tree pname = DECL_NAME (arg);\n-\t      buf = xasprintf (\"__parm.%s\", IDENTIFIER_POINTER (pname));\n+\t      buf = xasprintf (\"_P_%s\", IDENTIFIER_POINTER (pname));\n \t    }\n \t  else\n-\t    buf = xasprintf (\"__unnamed_parm.%d\", no_name_parm++);\n+\t    buf = xasprintf (\"_P_unnamed_%d\", no_name_parm++);\n \n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (parm.frame_type))\n \t    {\n-\t      char *gbuf = xasprintf (\"%s.live\", buf);\n+\t      char *gbuf = xasprintf (\"%s_live\", buf);\n \t      parm.guard_var\n \t\t= build_lang_decl (VAR_DECL, get_identifier (gbuf),\n \t\t\t\t   boolean_type_node);\n@@ -4761,8 +4752,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   /* For now, once allocation has succeeded we always assume that this needs\n      destruction, there's no impl. for frame allocation elision.  */\n-  tree fnf_m\n-    = lookup_member (coro_frame_type, fnf_name, 1, 0, tf_warning_or_error);\n+  tree fnf_m = lookup_member (coro_frame_type, coro_frame_needs_free_id,\n+\t\t\t      1, 0,tf_warning_or_error);\n   tree fnf_x = build_class_member_access_expr (deref_fp, fnf_m, NULL_TREE,\n \t\t\t\t\t       false, tf_warning_or_error);\n   r = build2 (INIT_EXPR, boolean_type_node, fnf_x, boolean_true_node);\n@@ -4773,24 +4764,22 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   tree actor_addr = build1 (ADDR_EXPR, act_des_fn_ptr, actor);\n   tree resume_m\n-    = lookup_member (coro_frame_type, resume_name,\n+    = lookup_member (coro_frame_type, coro_resume_fn_id,\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree resume_x = build_class_member_access_expr (deref_fp, resume_m, NULL_TREE,\n \t\t\t\t\t\t  false, tf_warning_or_error);\n   r = build2_loc (fn_start, INIT_EXPR, act_des_fn_ptr, resume_x, actor_addr);\n-  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-  add_stmt (r);\n+  finish_expr_stmt (r);\n \n   tree destroy_addr = build1 (ADDR_EXPR, act_des_fn_ptr, destroy);\n   tree destroy_m\n-    = lookup_member (coro_frame_type, destroy_name,\n+    = lookup_member (coro_frame_type, coro_destroy_fn_id,\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree destroy_x\n     = build_class_member_access_expr (deref_fp, destroy_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n   r = build2_loc (fn_start, INIT_EXPR, act_des_fn_ptr, destroy_x, destroy_addr);\n-  r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-  add_stmt (r);\n+  finish_expr_stmt (r);\n \n   /* [dcl.fct.def.coroutine] /13\n      When a coroutine is invoked, a copy is created for each coroutine\n@@ -4881,7 +4870,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   /* Set up the promise.  */\n   tree promise_m\n-    = lookup_member (coro_frame_type, promise_name,\n+    = lookup_member (coro_frame_type, coro_promise_id,\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n \n   tree p = build_class_member_access_expr (deref_fp, promise_m, NULL_TREE,\n@@ -5027,9 +5016,9 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t\t\t      boolean_type_node);\n       finish_expr_stmt (r);\n     }\n-  /* Initialize the resume_idx_name to 0, meaning \"not started\".  */\n+  /* Initialize the resume_idx_var to 0, meaning \"not started\".  */\n   tree resume_idx_m\n-    = lookup_member (coro_frame_type, resume_idx_name,\n+    = lookup_member (coro_frame_type, coro_resume_index_id,\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n   tree resume_idx\n     = build_class_member_access_expr (deref_fp, resume_idx_m, NULL_TREE, false,\n@@ -5172,9 +5161,9 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   push_deferring_access_checks (dk_no_check);\n \n   /* Build the actor...  */\n-  build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n-\t\t  &local_var_uses, param_dtor_list, resume_fn_field,\n-\t\t  resume_idx_field, body_aw_points.await_number, frame_size);\n+  build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig,\n+\t\t  &local_var_uses, param_dtor_list,\n+\t\t  resume_idx_var, body_aw_points.await_number, frame_size);\n \n   /* Destroyer ... */\n   build_destroy_fn (fn_start, coro_frame_type, destroy, actor);"}]}