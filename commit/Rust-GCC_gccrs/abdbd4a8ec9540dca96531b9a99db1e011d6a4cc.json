{"sha": "abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkYmQ0YThlYzk1NDBkY2E5NjUzMWI5YTk5ZGIxZTAxMWQ2YTRjYw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-05-21T06:39:25Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-05-21T06:39:25Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r42373,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r42374", "tree": {"sha": "5049e5152a8f83009f083e416b2049c79cdd67da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5049e5152a8f83009f083e416b2049c79cdd67da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/comments", "author": null, "committer": null, "parents": [{"sha": "f54d42879f9f2e50f38c703064db6e3d6e91a568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54d42879f9f2e50f38c703064db6e3d6e91a568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54d42879f9f2e50f38c703064db6e3d6e91a568"}], "stats": {"total": 2982, "additions": 1852, "deletions": 1130}, "files": [{"sha": "c90584ec9a003dee8bfacdd99c1772d3948a16a2", "filename": "boehm-gc/NT_THREADS_MAKEFILE", "status": "modified", "additions": 286, "deletions": 215, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2FNT_THREADS_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2FNT_THREADS_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_THREADS_MAKEFILE?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -1,5 +1,6 @@\n # Microsoft Developer Studio Generated NMAKE File, Format Version 4.10\n-# ** DO NOT EDIT **\n+# This has been hand-edited way too many times.\n+# A clean, manually generated makefile would be an improvement.\n \n # TARGTYPE \"Win32 (x86) Application\" 0x0101\n # TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n@@ -72,6 +73,8 @@ CLEAN :\n \t-@erase \".\\Release\\finalize.obj\"\n \t-@erase \".\\Release\\finalize.sbr\"\n \t-@erase \".\\Release\\gc.bsc\"\n+\t-@erase \".\\Release\\gc_cpp.obj\"\n+\t-@erase \".\\Release\\gc_cpp.sbr\"\n \t-@erase \".\\Release\\gc.dll\"\n \t-@erase \".\\Release\\gc.exp\"\n \t-@erase \".\\Release\\gc.lib\"\n@@ -111,8 +114,8 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n  \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n  \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\Release/\n@@ -155,6 +158,7 @@ BSC32_SBRS= \\\n \t\".\\Release\\dbg_mlc.sbr\" \\\n \t\".\\Release\\dyn_load.sbr\" \\\n \t\".\\Release\\finalize.sbr\" \\\n+\t\".\\Release\\gc_cpp.sbr\" \\\n \t\".\\Release\\headers.sbr\" \\\n \t\".\\Release\\mach_dep.sbr\" \\\n \t\".\\Release\\malloc.sbr\" \\\n@@ -192,6 +196,7 @@ LINK32_OBJS= \\\n \t\".\\Release\\dbg_mlc.obj\" \\\n \t\".\\Release\\dyn_load.obj\" \\\n \t\".\\Release\\finalize.obj\" \\\n+\t\".\\Release\\gc_cpp.obj\" \\\n \t\".\\Release\\headers.obj\" \\\n \t\".\\Release\\mach_dep.obj\" \\\n \t\".\\Release\\malloc.obj\" \\\n@@ -245,6 +250,8 @@ CLEAN :\n \t-@erase \".\\Debug\\dyn_load.sbr\"\n \t-@erase \".\\Debug\\finalize.obj\"\n \t-@erase \".\\Debug\\finalize.sbr\"\n+\t-@erase \".\\Debug\\gc_cpp.obj\"\n+\t-@erase \".\\Debug\\gc_cpp.sbr\"\n \t-@erase \".\\Debug\\gc.bsc\"\n \t-@erase \".\\Debug\\gc.dll\"\n \t-@erase \".\\Debug\\gc.exp\"\n@@ -289,8 +296,8 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n  /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n  \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n  /Fd\"$(INTDIR)/\" /c \n@@ -334,6 +341,7 @@ BSC32_SBRS= \\\n \t\".\\Debug\\dbg_mlc.sbr\" \\\n \t\".\\Debug\\dyn_load.sbr\" \\\n \t\".\\Debug\\finalize.sbr\" \\\n+\t\".\\Debug\\gc_cpp.sbr\" \\\n \t\".\\Debug\\headers.sbr\" \\\n \t\".\\Debug\\mach_dep.sbr\" \\\n \t\".\\Debug\\malloc.sbr\" \\\n@@ -371,6 +379,7 @@ LINK32_OBJS= \\\n \t\".\\Debug\\dbg_mlc.obj\" \\\n \t\".\\Debug\\dyn_load.obj\" \\\n \t\".\\Debug\\finalize.obj\" \\\n+\t\".\\Debug\\gc_cpp.obj\" \\\n \t\".\\Debug\\headers.obj\" \\\n \t\".\\Debug\\mach_dep.obj\" \\\n \t\".\\Debug\\malloc.obj\" \\\n@@ -416,10 +425,13 @@ CLEAN :\n \"$(OUTDIR)\" :\n     if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n \n+test.c : tests\\test.c\n+\tcopy tests\\test.c test.c\n+\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n  \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Release/\n@@ -505,7 +517,7 @@ CLEAN :\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n # ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n  /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Debug/\n@@ -596,7 +608,7 @@ CLEAN :\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n # ADD CPP /nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n  \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\cord\\Release/\n CPP_SBRS=.\\.\n@@ -688,7 +700,7 @@ CLEAN :\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n # ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D\\\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /I include /D \"_DEBUG\" /D \"WIN32\" /D\\\n  \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX\\\n  /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\cord\\Debug/\n@@ -763,15 +775,65 @@ LINK32_OBJS= \\\n ################################################################################\n # Begin Source File\n \n+SOURCE=.\\gc_cpp.cpp\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_cpp.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\gc_cpp.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Release\\gc_cpp.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_cpp.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\gc_cpp.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Debug\\gc_cpp.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n SOURCE=.\\reclaim.c\n \n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_RECLA=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_RECLA=\\\n@@ -788,10 +850,10 @@ NODEP_CPP_RECLA=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_RECLA=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_RECLA=\\\n@@ -808,6 +870,7 @@ NODEP_CPP_RECLA=\\\n !ENDIF \n \n # End Source File\n+\n ################################################################################\n # Begin Source File\n \n@@ -816,10 +879,10 @@ SOURCE=.\\os_dep.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_OS_DE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -840,10 +903,10 @@ NODEP_CPP_OS_DE=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_OS_DE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -872,10 +935,10 @@ SOURCE=.\\misc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MISC_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MISC_=\\\n@@ -893,10 +956,10 @@ NODEP_CPP_MISC_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MISC_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MISC_=\\\n@@ -922,10 +985,10 @@ SOURCE=.\\mark_rts.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MARK_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_=\\\n@@ -942,10 +1005,10 @@ NODEP_CPP_MARK_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MARK_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_=\\\n@@ -970,10 +1033,10 @@ SOURCE=.\\mach_dep.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MACH_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MACH_=\\\n@@ -990,10 +1053,10 @@ NODEP_CPP_MACH_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MACH_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MACH_=\\\n@@ -1018,10 +1081,10 @@ SOURCE=.\\headers.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_HEADE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_HEADE=\\\n@@ -1038,10 +1101,10 @@ NODEP_CPP_HEADE=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_HEADE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_HEADE=\\\n@@ -1066,10 +1129,10 @@ SOURCE=.\\alloc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_ALLOC=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLOC=\\\n@@ -1086,10 +1149,10 @@ NODEP_CPP_ALLOC=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_ALLOC=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLOC=\\\n@@ -1114,10 +1177,10 @@ SOURCE=.\\allchblk.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_ALLCH=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLCH=\\\n@@ -1134,10 +1197,10 @@ NODEP_CPP_ALLCH=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_ALLCH=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLCH=\\\n@@ -1162,10 +1225,10 @@ SOURCE=.\\stubborn.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_STUBB=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_STUBB=\\\n@@ -1182,10 +1245,10 @@ NODEP_CPP_STUBB=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_STUBB=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_STUBB=\\\n@@ -1210,10 +1273,10 @@ SOURCE=.\\obj_map.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_OBJ_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_OBJ_M=\\\n@@ -1230,10 +1293,10 @@ NODEP_CPP_OBJ_M=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_OBJ_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_OBJ_M=\\\n@@ -1258,10 +1321,10 @@ SOURCE=.\\new_hblk.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_NEW_H=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_NEW_H=\\\n@@ -1278,10 +1341,10 @@ NODEP_CPP_NEW_H=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_NEW_H=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_NEW_H=\\\n@@ -1306,11 +1369,12 @@ SOURCE=.\\mark.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MARK_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_C=\\\n@@ -1327,11 +1391,12 @@ NODEP_CPP_MARK_C=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MARK_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_C=\\\n@@ -1356,10 +1421,10 @@ SOURCE=.\\malloc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MALLO=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLO=\\\n@@ -1376,10 +1441,10 @@ NODEP_CPP_MALLO=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MALLO=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLO=\\\n@@ -1404,10 +1469,10 @@ SOURCE=.\\mallocx.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MALLX=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLX=\\\n@@ -1424,10 +1489,10 @@ NODEP_CPP_MALLX=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MALLX=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLX=\\\n@@ -1452,11 +1517,12 @@ SOURCE=.\\finalize.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_FINAL=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_FINAL=\\\n@@ -1473,11 +1539,12 @@ NODEP_CPP_FINAL=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_FINAL=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_FINAL=\\\n@@ -1502,10 +1569,10 @@ SOURCE=.\\dbg_mlc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_DBG_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_DBG_M=\\\n@@ -1522,10 +1589,10 @@ NODEP_CPP_DBG_M=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_DBG_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_DBG_M=\\\n@@ -1550,10 +1617,10 @@ SOURCE=.\\blacklst.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_BLACK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_BLACK=\\\n@@ -1570,10 +1637,10 @@ NODEP_CPP_BLACK=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_BLACK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_BLACK=\\\n@@ -1598,12 +1665,13 @@ SOURCE=.\\typd_mlc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_TYPD_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n-\t\".\\gc_typed.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_typed.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_TYPD_=\\\n@@ -1620,12 +1688,13 @@ NODEP_CPP_TYPD_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_TYPD_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n-\t\".\\gc_typed.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_typed.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_TYPD_=\\\n@@ -1650,11 +1719,12 @@ SOURCE=.\\ptr_chck.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_PTR_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_PTR_C=\\\n@@ -1671,11 +1741,12 @@ NODEP_CPP_PTR_C=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_PTR_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_PTR_C=\\\n@@ -1700,10 +1771,10 @@ SOURCE=.\\dyn_load.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_DYN_L=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -1723,10 +1794,10 @@ NODEP_CPP_DYN_L=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_DYN_L=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -1754,10 +1825,10 @@ SOURCE=.\\win32_threads.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_WIN32=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_WIN32=\\\n@@ -1774,10 +1845,10 @@ NODEP_CPP_WIN32=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_WIN32=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_WIN32=\\\n@@ -1802,10 +1873,10 @@ SOURCE=.\\checksums.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_CHECK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_CHECK=\\\n@@ -1822,10 +1893,10 @@ NODEP_CPP_CHECK=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_CHECK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_CHECK=\\\n@@ -1876,13 +1947,13 @@ NODEP_CPP_CHECK=\\\n ################################################################################\n # Begin Source File\n \n-SOURCE=.\\test.c\n+SOURCE=.\\tests\\test.c\n DEP_CPP_TEST_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n-\t\".\\gc_typed.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_typed.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_TEST_=\\\n@@ -1944,13 +2015,13 @@ NODEP_CPP_TEST_=\\\n \n SOURCE=.\\cord\\de_win.c\n DEP_CPP_DE_WI=\\\n-\t\".\\cord\\cord.h\"\\\n+\t\".\\include\\cord.h\"\\\n \t\".\\cord\\de_cmds.h\"\\\n \t\".\\cord\\de_win.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_DE_WI=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\"\n@@ -1975,13 +2046,13 @@ NODEP_CPP_DE_WI=\\\n \n SOURCE=.\\cord\\de.c\n DEP_CPP_DE_C2e=\\\n-\t\".\\cord\\cord.h\"\\\n+\t\".\\include\\cord.h\"\\\n \t\".\\cord\\de_cmds.h\"\\\n \t\".\\cord\\de_win.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_DE_C2e=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\"\n@@ -2006,12 +2077,12 @@ NODEP_CPP_DE_C2e=\\\n \n SOURCE=.\\cord\\cordxtra.c\n DEP_CPP_CORDX=\\\n-\t\".\\cord\\cord.h\"\\\n-\t\".\\cord\\ec.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\cord.h\"\\\n+\t\".\\include\\ec.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_CORDX=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\"\n@@ -2036,11 +2107,11 @@ NODEP_CPP_CORDX=\\\n \n SOURCE=.\\cord\\cordbscs.c\n DEP_CPP_CORDB=\\\n-\t\".\\cord\\cord.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\cord.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_CORDB=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\""}, {"sha": "d54c65fe0d72426e2757ce2dfa39c9b9f2679195", "filename": "boehm-gc/cord/cordtest.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Fcord%2Fcordtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Fcord%2Fcordtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordtest.c?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -14,6 +14,7 @@\n # include \"cord.h\"\n # include <string.h>\n # include <stdio.h>\n+# include <stdlib.h>\n /* This is a very incomplete test of the cord package.  It knows about\t*/\n /* a few internals of the package (e.g. when C strings are returned)\t*/\n /* that real clients shouldn't rely on.\t\t\t\t\t*/"}, {"sha": "b1449f5dc8a138c1c6760d1971573f2eb2d1bc85", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 180, "deletions": 73, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -29,8 +29,56 @@\n #ifndef _GC_H\n \n # define _GC_H\n+\n+#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n+#   define SOLARIS_THREADS\n+#endif\n+\n+/*\n+ * Some tests for old macros.  These violate our namespace rules and will\n+ * disappear shortly.\n+ */\n+#if defined(SOLARIS_THREADS) || defined(_SOLARIS_THREADS)\n+# define GC_SOLARIS_THREADS\n+#endif\n+#if defined(_SOLARIS_PTHREADS)\n+# define GC_SOLARIS_PTHREADS\n+#endif\n+#if defined(IRIX_THREADS)\n+# define GC_IRIX_THREADS\n+#endif\n+#if defined(HPUX_THREADS)\n+# define GC_HPUX_THREADS\n+#endif\n+#if defined(OSF1_THREADS)\n+# define GC_OSF1_THREADS\n+#endif\n+#if defined(LINUX_THREADS)\n+# define GC_LINUX_THREADS\n+#endif\n+#if defined(WIN32_THREADS)\n+# define GC_WIN32_THREADS\n+#endif\n+#if defined(USE_LD_WRAP)\n+# define GC_USE_LD_WRAP\n+#endif\n+\n+#if !defined(_REENTRANT) && (defined(GC_SOLARIS_THREADS) \\\n+\t\t             || defined(GC_SOLARIS_PTHREADS) \\\n+\t\t\t     || defined(GC_HPUX_THREADS) \\\n+\t\t\t     || defined(GC_LINUX_THREADS))\n+# define _REENTRANT\n+\t/* Better late than never.  This fails if system headers that\t*/\n+\t/* depend on this were previously included.\t\t\t*/\n+#endif\n+\n # define __GC\n # include <stddef.h>\n+# ifdef _WIN32_WCE\n+/* Yet more kluges for WinCE */\n+#   include <stdlib.h>\t\t/* size_t is defined here */\n+    typedef long ptrdiff_t;\t/* ptrdiff_t is not defined */\n+# endif\n \n #if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n #include \"libgc_globals.h\"\n@@ -44,9 +92,10 @@\n # endif\n #endif\n \n-#if defined(_MSC_VER) && defined(_DLL)\n+#if defined(_MSC_VER) && (defined(_DLL) && !defined(NOT_GC_DLL) \\\n+\t                  || defined(GC_DLL))\n # ifdef GC_BUILD\n-#   define GC_API __declspec(dllexport)\n+#   define GC_API extern __declspec(dllexport)\n # else\n #   define GC_API __declspec(dllimport)\n # endif\n@@ -94,6 +143,16 @@ typedef long GC_signed_word;\n \n GC_API GC_word GC_gc_no;/* Counter incremented per collection.  \t*/\n \t\t\t/* Includes empty GCs at startup.\t\t*/\n+\n+GC_API int GC_parallel;\t/* GC is parallelized for performance on\t*/\n+\t\t\t/* multiprocessors.  Currently set only\t\t*/\n+\t\t\t/* implicitly if collector is built with\t*/\n+\t\t\t/* -DPARALLEL_MARK and if either:\t\t*/\n+\t\t\t/*  Env variable GC_NPROC is set to > 1, or\t*/\n+\t\t\t/*  GC_NPROC is not set and this is an MP.\t*/\n+\t\t\t/* If GC_parallel is set, incremental\t\t*/\n+\t\t\t/* collection is aonly partially functional,\t*/\n+\t\t\t/* and may not be desirable.\t\t\t*/\n \t\t\t\n \n /* Public R/W variables */\n@@ -113,14 +172,26 @@ GC_API int GC_find_leak;\n \t\t\t/* deallocated with GC_free.  Initial value\t*/\n \t\t\t/* is determined by FIND_LEAK macro.\t\t*/\n \n+GC_API int GC_all_interior_pointers;\n+\t\t\t/* Arrange for pointers to object interiors to\t*/\n+\t\t\t/* be recognized as valid.  May not be changed\t*/\n+\t\t\t/* after GC initialization.\t\t\t*/\n+\t\t\t/* Initial value is determined by \t\t*/\n+\t\t\t/* -DALL_INTERIOR_POINTERS.\t\t\t*/\n+\t\t\t/* Unless DONT_ADD_BYTE_AT_END is defined, this\t*/\n+\t\t\t/* also affects whether sizes are increased by\t*/\n+\t\t\t/* at least a byte to allow \"off the end\"\t*/\n+\t\t\t/* pointer recognition.\t\t\t\t*/\n+\t\t\t/* MUST BE 0 or 1.\t\t\t\t*/\n+\n GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n \t\t\t/* collector has been compiled with statistics\t*/\n \t\t\t/* enabled.  This involves a performance cost,\t*/\n \t\t\t/* and is thus not the default.\t\t\t*/\n \n GC_API int GC_finalize_on_demand;\n \t\t\t/* If nonzero, finalizers will only be run in \t*/\n-\t\t\t/* response to an eplit GC_invoke_finalizers\t*/\n+\t\t\t/* response to an explicit GC_invoke_finalizers\t*/\n \t\t\t/* call.  The default is determined by whether\t*/\n \t\t\t/* the FINALIZE_ON_DEMAND macro is defined\t*/\n \t\t\t/* when the collector is built.\t\t\t*/\n@@ -132,6 +203,15 @@ GC_API int GC_java_finalization;\n \t\t\t/* ordered finalization.  Default value is\t*/\n \t\t\t/* determined by JAVA_FINALIZATION macro.\t*/\n \n+GC_API void (* GC_finalizer_notifier)();\n+\t\t\t/* Invoked by the collector when there are \t*/\n+\t\t\t/* objects to be finalized.  Invoked at most\t*/\n+\t\t\t/* once per GC cycle.  Never invoked unless \t*/\n+\t\t\t/* GC_finalize_on_demand is set.\t\t*/\n+\t\t\t/* Typically this will notify a finalization\t*/\n+\t\t\t/* thread, which will call GC_invoke_finalizers */\n+\t\t\t/* in response.\t\t\t\t\t*/\n+\n GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n \t\t\t/* because it's not safe.\t\t\t  */\n \n@@ -163,6 +243,16 @@ GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n GC_API GC_word GC_non_gc_bytes;\n \t\t\t/* Bytes not considered candidates for collection. */\n \t\t\t/* Used only to control scheduling of collections. */\n+\t\t\t/* Updated by GC_malloc_uncollectable and GC_free. */\n+\t\t\t/* Wizards only.\t\t\t\t   */\n+\n+GC_API int GC_no_dls;\n+\t\t\t/* Don't register dynamic library data segments. */\n+\t\t\t/* Wizards only.  Should be used only if the\t */\n+\t\t\t/* application explicitly registers all roots.\t */\n+\t\t\t/* In Microsoft Windows environments, this will\t */\n+\t\t\t/* usually also prevent registration of the\t */\n+\t\t\t/* main data segment as part of the root set.\t */\n \n GC_API GC_word GC_free_space_divisor;\n \t\t\t/* We try to make sure that we allocate at \t*/\n@@ -193,8 +283,16 @@ GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n \t\t\t\t/* automatically.\t\t\t*/\n \t\t\t\t/* For multithreaded code, this is the\t*/\n \t\t\t\t/* cold end of the stack for the\t*/\n-\t\t\t\t/* primordial thread.\t\t\t*/\n+\t\t\t\t/* primordial thread.\t\t\t*/\t\n \t\t\t\t\n+GC_API int GC_dont_precollect;  /* Don't collect as part of \t\t*/\n+\t\t\t\t/* initialization.  Should be set only\t*/\n+\t\t\t\t/* if the client wants a chance to\t*/\n+\t\t\t\t/* manually initialize the root set\t*/\n+\t\t\t\t/* before the first collection.\t\t*/\n+\t\t\t\t/* Interferes with blacklisting.\t*/\n+\t\t\t\t/* Wizards only.\t\t\t*/\n+\n /* Public procedures */\n /*\n  * general purpose allocation routines, with roughly malloc calling conv.\n@@ -204,8 +302,13 @@ GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n  * will occur after GC_end_stubborn_change has been called on the\n  * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object\n  * that is scanned for pointers to collectable objects, but is not itself\n- * collectable.  GC_malloc_uncollectable and GC_free called on the resulting\n+ * collectable.  The object is scanned even if it does not appear to\n+ * be reachable.  GC_malloc_uncollectable and GC_free called on the resulting\n  * object implicitly update GC_non_gc_bytes appropriately.\n+ *\n+ * Note that the GC_malloc_stubborn support is stubbed out by default\n+ * starting in 6.0.  GC_malloc_stubborn is an alias for GC_malloc unless\n+ * the collector is built with STUBBORN_ALLOC defined.\n  */\n GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));\n GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));\n@@ -331,12 +434,18 @@ GC_API size_t GC_get_free_bytes GC_PROTO((void));\n /* Return the number of bytes allocated since the last collection.\t*/\n GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n \n+/* Return the total number of bytes allocated in this process.\t\t*/\n+/* Never decreases.\t\t\t\t\t\t\t*/\n+GC_API size_t GC_get_total_bytes GC_PROTO((void));\n+\n /* Enable incremental/generational collection.\t*/\n /* Not advisable unless dirty bits are \t\t*/\n /* available or most heap objects are\t\t*/\n /* pointerfree(atomic) or immutable.\t\t*/\n /* Don't use in leak finding mode.\t\t*/\n /* Ignored if GC_dont_gc is true.\t\t*/\n+/* Only the generational piece of this is\t*/\n+/* functional if GC_parallel is TRUE.\t\t*/\n GC_API void GC_enable_incremental GC_PROTO((void));\n \n /* Perform some garbage collection work, if appropriate.\t*/\n@@ -497,6 +606,8 @@ GC_API void GC_debug_register_finalizer\n /* but it's unavoidable for C++, since the compiler may\t\t*/\n /* silently introduce these.  It's also benign in that specific\t*/\n /* case.\t\t\t\t\t\t\t*/\n+/* Note that cd will still be viewed as accessible, even if it\t*/\n+/* refers to the object itself.\t\t\t\t\t*/\n GC_API void GC_register_finalizer_ignore_self\n \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n@@ -505,7 +616,9 @@ GC_API void GC_debug_register_finalizer_ignore_self\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n /* Another version of the above.  It ignores all cycles.        */\n-/* It should probably only be used by Java implementations.      */\n+/* It should probably only be used by Java implementations.     */\n+/* Note that cd will still be viewed as accessible, even if it\t*/\n+/* refers to the object itself.\t\t\t\t\t*/\n GC_API void GC_register_finalizer_no_order\n \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n@@ -608,6 +721,9 @@ typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));\n GC_API GC_PTR GC_call_with_alloc_lock\n         \tGC_PROTO((GC_fn_type fn, GC_PTR client_data));\n \n+/* The following routines are primarily intended for use with a \t*/\n+/* preprocessor which inserts calls to check C pointer arithmetic.\t*/\n+\n /* Check that p and q point to the same object.  \t\t*/\n /* Fail conspicuously if they don't.\t\t\t\t*/\n /* Returns the first argument.  \t\t\t\t*/\n@@ -635,7 +751,7 @@ GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));\n /* Check that if p is a pointer to a heap page, then it points to\t*/\n /* a valid displacement within a heap object.\t\t\t\t*/\n /* Fail conspicuously if this property does not hold.\t\t\t*/\n-/* Uninteresting with ALL_INTERIOR_POINTERS.\t\t\t\t*/\n+/* Uninteresting with GC_all_interior_pointers.\t\t\t\t*/\n /* Always returns its argument.\t\t\t\t\t\t*/\n GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n \n@@ -651,9 +767,9 @@ GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n #   ifdef __GNUC__\n #       define GC_PTR_ADD(x, n) \\\n \t    GC_PTR_ADD3(x, n, typeof(x))\n-#   define GC_PRE_INCR(x, n) \\\n+#       define GC_PRE_INCR(x, n) \\\n \t    GC_PRE_INCR3(x, n, typeof(x))\n-#   define GC_POST_INCR(x, n) \\\n+#       define GC_POST_INCR(x, n) \\\n \t    GC_POST_INCR3(x, typeof(x))\n #   else\n \t/* We can't do this right without typeof, which ANSI\t*/\n@@ -693,83 +809,64 @@ GC_API void (*GC_is_valid_displacement_print_proc)\n GC_API void (*GC_is_visible_print_proc)\n \tGC_PROTO((GC_PTR p));\n \n-#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n-#   define SOLARIS_THREADS\n-#endif\n-\n-#ifdef SOLARIS_THREADS\n-/* We need to intercept calls to many of the threads primitives, so \t*/\n-/* that we can locate thread stacks and stop the world.\t\t\t*/\n-/* Note also that the collector cannot see thread specific data.\t*/\n-/* Thread specific data should generally consist of pointers to\t\t*/\n-/* uncollectable objects, which are deallocated using the destructor\t*/\n-/* facility in thr_keycreate.\t\t\t\t\t\t*/\n-# include <thread.h>\n-# include <signal.h>\n-  int GC_thr_create(void *stack_base, size_t stack_size,\n-                    void *(*start_routine)(void *), void *arg, long flags,\n-                    thread_t *new_thread);\n-  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n-  int GC_thr_suspend(thread_t target_thread);\n-  int GC_thr_continue(thread_t target_thread);\n-  void * GC_dlopen(const char *path, int mode);\n-\n-# ifdef _SOLARIS_PTHREADS\n-#   include <pthread.h>\n-    extern int GC_pthread_create(pthread_t *new_thread,\n-    \t\t\t         const pthread_attr_t *attr,\n-          \t\t\t void * (*thread_execp)(void *), void *arg);\n-    extern int GC_pthread_join(pthread_t wait_for, void **status);\n-\n-#   undef thread_t\n-\n-#   define pthread_join GC_pthread_join\n-#   define pthread_create GC_pthread_create\n-#endif\n-\n-# define thr_create GC_thr_create\n-# define thr_join GC_thr_join\n-# define thr_suspend GC_thr_suspend\n-# define thr_continue GC_thr_continue\n-# define dlopen GC_dlopen\n-\n-# endif /* SOLARIS_THREADS */\n \n+/* For pthread support, we generally need to intercept a number of \t*/\n+/* thread library calls.  We do that here by macro defining them.\t*/\n \n-#if !defined(USE_LD_WRAP) && \\\n-    (defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS))\n-/* We treat these similarly. */\n-# include <pthread.h>\n-# include <signal.h>\n-\n-  int GC_pthread_create(pthread_t *new_thread,\n-                        const pthread_attr_t *attr,\n-\t\t        void *(*start_routine)(void *), void *arg);\n-  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n-  int GC_pthread_join(pthread_t thread, void **retval);\n-\n-# define pthread_create GC_pthread_create\n-# define pthread_sigmask GC_pthread_sigmask\n-# define pthread_join GC_pthread_join\n-# define dlopen GC_dlopen\n-\n-#endif /* xxxxx_THREADS */\n+#if !defined(GC_USE_LD_WRAP) && \\\n+    (defined(GC_LINUX_THREADS) || defined(GC_HPUX_THREADS) || \\\n+     defined(GC_IRIX_THREADS) || defined(GC_SOLARIS_PTHREADS) || \\\n+     defined(GC_SOLARIS_THREADS) || defined(GC_OSF1_THREADS))\n+# include \"gc_pthread_redirects.h\"\n+#endif\n \n-# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n-\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n+# if defined(PCR) || defined(GC_SOLARIS_THREADS) || \\\n+     defined(GC_SOLARIS_PTHREADS) || defined(GC_WIN32_THREADS) || \\\n+     defined(GC_IRIX_THREADS) || defined(GC_LINUX_THREADS) || \\\n+     defined(GC_HPUX_THREADS)\n    \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/\n /* lb must be large enough to hold the pointer field.\t\t\t*/\n+/* It is used internally by gc_local_alloc.h, which provides a simpler\t*/\n+/* programming interface on Linux.\t\t\t\t\t*/\n GC_PTR GC_malloc_many(size_t lb);\n #define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n \t\t\t\t\t/* in returned list.\t\t*/\n extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n \n #endif /* THREADS && !SRC_M3 */\n \n+#if defined(WIN32_THREADS) && defined(_WIN32_WCE)\n+# include <windows.h>\n+\n+  /*\n+   * win32_threads.c implements the real WinMain, which will start a new thread\n+   * to call GC_WinMain after initializing the garbage collector.\n+   */\n+  int WINAPI GC_WinMain(\n+      HINSTANCE hInstance,\n+      HINSTANCE hPrevInstance,\n+      LPWSTR lpCmdLine,\n+      int nCmdShow );\n+\n+  /*\n+   * All threads must be created using GC_CreateThread, so that they will be\n+   * recorded in the thread table.\n+   */\n+  HANDLE WINAPI GC_CreateThread(\n+      LPSECURITY_ATTRIBUTES lpThreadAttributes, \n+      DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, \n+      LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );\n+\n+# ifndef GC_BUILD\n+#   define WinMain GC_WinMain\n+#   define CreateThread GC_CreateThread\n+# endif\n+\n+#endif\n+\n /*\n  * If you are planning on putting\n  * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n@@ -790,13 +887,23 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n # endif\n #endif\n \n-#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n-     || defined(_WIN32)\n+#if !defined(_WIN32_WCE) \\\n+    && ((defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+        || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__))\n   /* win32S may not free all resources on process exit.  */\n   /* This explicitly deallocates the heap.\t\t */\n     GC_API void GC_win32_free_heap ();\n #endif\n \n+#if ( defined(_AMIGA) && !defined(GC_AMIGA_MAKINGLIB) )\n+  /* Allocation really goes through GC_amiga_allocwrapper_do */\n+# include \"gc_amiga_redirects.h\"\n+#endif\n+\n+#if defined(GC_REDIRECT_TO_LOCAL) && !defined(GC_LOCAL_ALLOC_H)\n+#  include  \"gc_local_alloc.h\"\n+#endif\n+\n #ifdef __cplusplus\n     }  /* end of extern \"C\" */\n #endif"}, {"sha": "c50a758964606169f3aab1486d4d193af41dc682", "filename": "boehm-gc/include/gc_alloc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_alloc.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -25,6 +25,9 @@\n // This uses template classes with static members, and hence does not work\n // with g++ 2.7.2 and earlier.\n //\n+// This code assumes that the collector itself has been compiled with a\n+// compiler that defines __STDC__ .\n+//\n \n #include \"gc.h\"\n "}, {"sha": "6aacd0aea043f4b0fb089a497ebea85ab71aa7b9", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -139,7 +139,7 @@ by UseGC.  GC is an alias for UseGC, unless GC_NAME_CONFLICT is defined.\n \n #if ! defined( OPERATOR_NEW_ARRAY ) \\\n     && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6) \\\n-        || __WATCOMC__ >= 1050)\n+\t|| __WATCOMC__ >= 1050 || _MSC_VER >= 1100)\n #   define OPERATOR_NEW_ARRAY\n #endif\n \n@@ -179,6 +179,12 @@ class gc_cleanup: virtual public gc {public:\n \n extern \"C\" {typedef void (*GCCleanUpFunc)( void* obj, void* clientData );}\n \n+#ifdef _MSC_VER\n+  // Disable warning that \"no matching operator delete found; memory will\n+  // not be freed if initialization throws an exception\"\n+# pragma warning(disable:4291)\n+#endif\n+\n inline void* operator new( \n     size_t size, \n     GCPlacement gcp,\n@@ -200,6 +206,49 @@ inline void* operator new(\n \n #ifdef OPERATOR_NEW_ARRAY\n \n+#ifdef _MSC_VER\n+ /** This ensures that the system default operator new[] doesn't get\n+  *  undefined, which is what seems to happen on VC++ 6 for some reason\n+  *  if we define a multi-argument operator new[].\n+  *  There seems to be really redirect new in this environment without\n+  *  including this everywhere. \n+  */\n+ inline void *operator new[]( size_t size )\n+ {\n+    return GC_MALLOC_UNCOLLECTABLE( size );\n+ }\n+\n+ inline void operator delete[](void* obj)\n+ {\n+    GC_FREE(obj);\n+ };\n+\n+ inline void* operator new( size_t size)\n+ {\n+    return GC_MALLOC_UNCOLLECTABLE( size);\n+ };   \n+\n+ inline void operator delete(void* obj)\n+ {\n+    GC_FREE(obj);\n+ };\n+\n+\n+// This new operator is used by VC++ in case of Debug builds !\n+  inline void* operator new( size_t size,\n+\t\t      int ,//nBlockUse,\n+\t\t      const char * szFileName,\n+\t\t      int nLine\n+\t\t      ) {\n+# ifndef GC_DEBUG\n+     return GC_malloc_uncollectable( size );\n+# else\n+     return GC_debug_malloc_uncollectable(size, szFileName, nLine);\n+# endif\n+  }\n+\n+#endif /* _MSC_VER */\n+\n inline void* operator new[](\n     size_t size, \n     GCPlacement gcp,"}, {"sha": "9123a28bb493962bc0320e8d3b84d751ab96839b", "filename": "boehm-gc/include/gc_gcj.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_gcj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_gcj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_gcj.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -24,6 +24,10 @@\n  * may be marked by the mark procedure passed to GC_init_gcj_malloc.\n  */\n \n+#ifndef GC_GCJ_H\n+\n+#define GC_GCJ_H\n+\n #ifndef MARK_DESCR_OFFSET\n #  define MARK_DESCR_OFFSET\tsizeof(word)\n #endif\n@@ -41,10 +45,7 @@\n #endif\n \n /* The following allocators signal an out of memory condition with\t*/\n-/* return GC_oom_action();\t\t\t\t\t\t*/\n-/* The default GC_oom_action returns 0.\t\t\t\t\t*/\n-/* This functionality is currently restricted to the gcj allocators.\t*/\n-/* We may want to extend it to the others.\t\t\t\t*/\n+/* return GC_oom_fn(bytes);\t\t\t\t\t\t*/\n \n extern void * (*GC_oom_action)(void);\n \n@@ -58,8 +59,6 @@ extern void * (*GC_oom_action)(void);\n /* to use the same mark_proc for some of its generated mark descriptors.*/\n /* In that case, it should use a different \"environment\" value to\t*/\n /* detect the presence or absence of the debug header.\t\t\t*/\n-\n-/* the debugging interface.\t\t\t\t\t\t*/\n /* Mp is really of type mark_proc, as defined in gc_mark.h.  We don't \t*/\n /* want to include that here for namespace pollution reasons.\t\t*/\n extern void GC_init_gcj_malloc(int mp_index, void * /* really mark_proc */mp);\n@@ -77,6 +76,9 @@ extern void * GC_debug_gcj_malloc(size_t lb,\n /* Similar to the above, but the size is in words, and we don't\t*/\n /* adjust it.  The size is assumed to be such that it can be \t*/\n /* allocated as a small object.\t\t\t\t\t*/\n+/* Unless it is known that the collector is not configured \t*/\n+/* with USE_MARK_BYTES and unless it is known that the object\t*/\n+/* has weak alignment requirements, lw must be even.\t\t*/\n extern void * GC_gcj_fast_malloc(size_t lw,\n \t\t\t\t void * ptr_to_struct_containing_descr);\n extern void * GC_debug_gcj_fast_malloc(size_t lw,\n@@ -91,11 +93,12 @@ extern void * GC_gcj_malloc_ignore_off_page(size_t lb,\n # ifdef GC_DEBUG\n #   define GC_GCJ_MALLOC(s,d) GC_debug_gcj_malloc(s,d,GC_EXTRAS)\n #   define GC_GCJ_FAST_MALLOC(s,d) GC_debug_gcj_fast_malloc(s,d,GC_EXTRAS)\n-#   define GC_GCJ_MALLOC_IGNORE_OFF_PAGE(s,d) GC_gcj_debug_malloc(s,d,GC_EXTRAS)\n+#   define GC_GCJ_MALLOC_IGNORE_OFF_PAGE(s,d) GC_debug_gcj_malloc(s,d,GC_EXTRAS)\n # else\n #   define GC_GCJ_MALLOC(s,d) GC_gcj_malloc(s,d)\n #   define GC_GCJ_FAST_MALLOC(s,d) GC_gcj_fast_malloc(s,d)\n #   define GC_GCJ_MALLOC_IGNORE_OFF_PAGE(s,d) \\\n-\tGC_gcj_debug_malloc_ignore_off_page(s,d)\n+\tGC_gcj_malloc_ignore_off_page(s,d)\n # endif\n \n+#endif /* GC_GCJ_H */"}, {"sha": "c535cfd73fcf9e782fdc02cf96f9f13298d28f60", "filename": "boehm-gc/include/gc_inl.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fgc_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_inl.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -17,18 +17,22 @@\n #   include \"private/gc_priv.h\"\n # endif\n \n-/* USE OF THIS FILE IS NOT RECOMMENDED unless the collector has been\t*/\n-/* compiled without -DALL_INTERIOR_POINTERS or with\t\t\t*/\n+/* USE OF THIS FILE IS NOT RECOMMENDED unless GC_all_interior_pointers\t*/\n+/* is always set, or the collector has been built with\t\t\t*/\n /* -DDONT_ADD_BYTE_AT_END, or the specified size includes a pointerfree\t*/\n /* word at the end.  In the standard collector configuration,\t\t*/\n /* the final word of each object may not be scanned.\t\t\t*/\n-/* This is most useful for compilers that generate C.\t\t\t*/\n+/* This iinterface is most useful for compilers that generate C.\t*/\n /* Manual use is hereby discouraged.\t\t\t\t\t*/\n \n /* Allocate n words (NOT BYTES).  X is made to point to the result.\t*/\n /* It is assumed that n < MAXOBJSZ, and\t\t\t\t\t*/\n /* that n > 0.  On machines requiring double word alignment of some\t*/\n-/* data, we also assume that n is 1 or even.  This bypasses the\t\t*/\n+/* data, we also assume that n is 1 or even.\t\t\t\t*/\n+/* If the collector is built with -DUSE_MARK_BYTES or -DPARALLEL_MARK,\t*/\n+/* the n = 1 case is also disallowed.\t\t\t\t\t*/\n+/* Effectively this means that portable code should make sure n is even.*/\n+/* This bypasses the\t\t\t\t\t\t\t*/\n /* MERGE_SIZES mechanism.  In order to minimize the number of distinct\t*/\n /* free lists that are maintained, the caller should ensure that a \t*/\n /* small number of distinct values of n are used.  (The MERGE_SIZES\t*/"}, {"sha": "1187f0b69f7130ca214cddad556bea1d3553035c", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -20,9 +20,9 @@\n // It also doesn't yet understand the new header file names or\n // namespaces.\n //\n-// This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n-// and -DALL_INTERIOR_POINTERS.  We also recommend\n-// -DREDIRECT_MALLOC=GC_uncollectable_malloc.\n+// This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE.\n+// The user should also consider -DREDIRECT_MALLOC=GC_uncollectable_malloc,\n+// to ensure that object allocated through malloc are traced.\n //\n // Some of this could be faster in the explicit deallocation case.\n // In particular, we spend too much time clearing objects on the\n@@ -43,11 +43,14 @@\n // problems.  The argument for changing it is that the usual default\n // allocator is usually a very bad choice for a garbage collected environment.)\n //\n+// This code assumes that the collector itself has been compiled with a\n+// compiler that defines __STDC__ .\n+//\n \n #ifndef GC_ALLOC_H\n \n #include \"gc.h\"\n-#include <alloc.h>\n+#include <stack>  // A more portable way to get stl_alloc.h .\n \n #define GC_ALLOC_H\n \n@@ -337,6 +340,8 @@ public: \\\n \t{ alloc::ptr_free_deallocate(p, sizeof (T)); } \\\n };\n \n+__STL_BEGIN_NAMESPACE\n+\n __GC_SPECIALIZE(char, gc_alloc)\n __GC_SPECIALIZE(int, gc_alloc)\n __GC_SPECIALIZE(unsigned, gc_alloc)\n@@ -361,6 +366,8 @@ __GC_SPECIALIZE(unsigned, single_client_traceable_alloc)\n __GC_SPECIALIZE(float, single_client_traceable_alloc)\n __GC_SPECIALIZE(double, single_client_traceable_alloc)\n \n+__STL_END_NAMESPACE\n+\n #ifdef __STL_USE_STD_ALLOCATORS\n \n __STL_BEGIN_NAMESPACE"}, {"sha": "6966a9a1a879fda70f0a946d1a9dd42fc1e00db5", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "modified", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -24,6 +24,17 @@ typedef struct hblkhdr hdr;\n  * The 2 level tree data structure that is used to find block headers.\n  * If there are more than 32 bits in a pointer, the top level is a hash\n  * table.\n+ *\n+ * This defines HDR, GET_HDR, and SET_HDR, the main macros used to\n+ * retrieve and set object headers.  We also define some variants to\n+ * retrieve 2 unrelated headers in interleaved fashion.  This\n+ * slightly improves scheduling.\n+ *\n+ * Since 5.0 alpha 5, we can also take advantage of a header lookup\n+ * cache.  This is a locally declared direct mapped cache, used inside\n+ * the marker.  The HC_GET_HDR and HC_GET_HDR2 macros use and maintain this\n+ * cache.  Assuming we get reasonable hit rates, this shaves a few\n+ * memory references from each pointer validation.\n  */\n \n # if CPP_WORDSZ > 32\n@@ -45,6 +56,127 @@ typedef struct hblkhdr hdr;\n # define TOP_SZ (1 << LOG_TOP_SZ)\n # define BOTTOM_SZ (1 << LOG_BOTTOM_SZ)\n \n+#ifndef SMALL_CONFIG\n+# define USE_HDR_CACHE\n+#endif\n+\n+/* #define COUNT_HDR_CACHE_HITS  */\n+\n+extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n+\t\t\t\t/* containing no objects.\t\t*/\n+\n+\n+/* Check whether p and corresponding hhdr point to long or invalid\t*/\n+/* object.  If so, advance them\tto\t\t\t\t\t*/\n+/* beginning of\tblock, or set hhdr to GC_invalid_header.\t\t*/\n+#define ADVANCE(p, hhdr, source) \\\n+            if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) { \\\n+              p = GC_FIND_START(p, hhdr, (word)source); \\\n+              if (p == 0) { \\\n+\t\thhdr = GC_invalid_header; \\\n+\t      } else { \\\n+                hhdr = GC_find_header(p); \\\n+\t      } \\\n+    \t    }\n+\n+#ifdef USE_HDR_CACHE\n+\n+# ifdef COUNT_HDR_CACHE_HITS\n+    extern word GC_hdr_cache_hits;\n+    extern word GC_hdr_cache_misses;\n+#   define HC_HIT() ++GC_hdr_cache_hits\n+#   define HC_MISS() ++GC_hdr_cache_misses\n+# else\n+#   define HC_HIT()\n+#   define HC_MISS()\n+# endif\n+\n+  typedef struct hce {\n+    word block_addr;  \t/* right shifted by LOG_HBLKSIZE */\n+    hdr * hce_hdr;\n+  } hdr_cache_entry;\n+\n+# define HDR_CACHE_SIZE 8  /* power of 2 */\n+\n+# define DECLARE_HDR_CACHE \\\n+\thdr_cache_entry hdr_cache[HDR_CACHE_SIZE]\n+\n+# define INIT_HDR_CACHE BZERO(hdr_cache, sizeof(hdr_cache));\n+\n+# define HCE(h) hdr_cache + (((word)(h) >> LOG_HBLKSIZE) & (HDR_CACHE_SIZE-1))\n+\n+# define HCE_VALID_FOR(hce,h) ((hce) -> block_addr == \\\n+\t\t\t\t((word)(h) >> LOG_HBLKSIZE))\n+\n+# define HCE_HDR(h) ((hce) -> hce_hdr)\n+\n+\n+/* Analogous to GET_HDR, except that in the case of large objects, it\t*/\n+/* Returns the header for the object beginning, and updates p.\t\t*/\n+/* Returns &GC_bad_header instead of 0.  All of this saves a branch\t*/\n+/* in the fast path.\t\t\t\t\t\t\t*/\n+# define HC_GET_HDR(p, hhdr, source) \\\n+\t{ \\\n+\t  hdr_cache_entry * hce = HCE(p); \\\n+\t  if (HCE_VALID_FOR(hce, p)) { \\\n+\t    HC_HIT(); \\\n+\t    hhdr = hce -> hce_hdr; \\\n+\t  } else { \\\n+\t    HC_MISS(); \\\n+\t    GET_HDR(p, hhdr); \\\n+\t    ADVANCE(p, hhdr, source); \\\n+\t    hce -> block_addr = (word)(p) >> LOG_HBLKSIZE; \\\n+\t    hce -> hce_hdr = hhdr; \\\n+\t  } \\\n+\t}\n+\n+# define HC_GET_HDR2(p1, hhdr1, source1, p2, hhdr2, source2) \\\n+\t{ \\\n+\t  hdr_cache_entry * hce1 = HCE(p1); \\\n+\t  hdr_cache_entry * hce2 = HCE(p2); \\\n+\t  if (HCE_VALID_FOR(hce1, p1)) { \\\n+\t    HC_HIT(); \\\n+\t    hhdr1 = hce1 -> hce_hdr; \\\n+\t  } else { \\\n+\t    HC_MISS(); \\\n+\t    GET_HDR(p1, hhdr1); \\\n+\t    ADVANCE(p1, hhdr1, source1); \\\n+\t    hce1 -> block_addr = (word)(p1) >> LOG_HBLKSIZE; \\\n+\t    hce1 -> hce_hdr = hhdr1; \\\n+\t  } \\\n+\t  if (HCE_VALID_FOR(hce2, p2)) { \\\n+\t    HC_HIT(); \\\n+\t    hhdr2 = hce2 -> hce_hdr; \\\n+\t  } else { \\\n+\t    HC_MISS(); \\\n+\t    GET_HDR(p2, hhdr2); \\\n+\t    ADVANCE(p2, hhdr2, source2); \\\n+\t    hce2 -> block_addr = (word)(p2) >> LOG_HBLKSIZE; \\\n+\t    hce2 -> hce_hdr = hhdr2; \\\n+\t  } \\\n+\t}\n+\n+#else /* !USE_HDR_CACHE */\n+\n+# define DECLARE_HDR_CACHE\n+\n+# define INIT_HDR_CACHE\n+\n+# define HC_GET_HDR(p, hhdr, source) \\\n+\t{ \\\n+\t  GET_HDR(p, hhdr); \\\n+\t  ADVANCE(p, hhdr, source); \\\n+\t}\n+\n+# define HC_GET_HDR2(p1, hhdr1, source1, p2, hhdr2, source2) \\\n+\t{ \\\n+\t  GET_HDR2(p1, hhdr1, p2, hhdr2); \\\n+\t  ADVANCE(p1, hhdr1, source1); \\\n+\t  ADVANCE(p2, hhdr2, source2); \\\n+\t}\n+\n+#endif\n+\n typedef struct bi {\n     hdr * index[BOTTOM_SZ];\n \t/*\n@@ -97,6 +229,8 @@ typedef struct bi {\n #   define GET_HDR(p, hhdr) (hhdr) = HDR(p)\n #   define SET_HDR(p, hhdr) HDR_INNER(p) = (hhdr)\n #   define GET_HDR_ADDR(p, ha) (ha) = &(HDR_INNER(p))\n+#   define GET_HDR2(p1, hhdr1, p2, hhdr2) \\\n+\t{ GET_HDR(p1, hhdr1); GET_HDR(p2, hhdr2); }\n # else /* hash */\n /*  Hash function for tree top level */\n #   define TL_HASH(hi) ((hi) & (TOP_SZ - 1))\n@@ -123,6 +257,40 @@ typedef struct bi {\n #   define SET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n \t\t\t      *_ha = (hhdr); }\n #   define HDR(p) GC_find_header((ptr_t)(p))\n+    /* And some interleaved versions for two pointers at once.  \t*/\n+    /* This hopefully helps scheduling on processors like IA64.\t\t*/\n+#   define GET_BI2(p1, bottom_indx1, p2, bottom_indx2) \\\n+\t{ \\\n+\t    register word hi1 = \\\n+\t        (word)(p1) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n+\t    register word hi2 = \\\n+\t        (word)(p2) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n+\t    register bottom_index * _bi1 = GC_top_index[TL_HASH(hi1)]; \\\n+\t    register bottom_index * _bi2 = GC_top_index[TL_HASH(hi2)]; \\\n+\t    \\\n+\t    while (_bi1 -> key != hi1 && _bi1 != GC_all_nils) \\\n+\t    \t_bi1 = _bi1 -> hash_link; \\\n+\t    while (_bi2 -> key != hi2 && _bi2 != GC_all_nils) \\\n+\t    \t_bi2 = _bi2 -> hash_link; \\\n+\t    (bottom_indx1) = _bi1; \\\n+\t    (bottom_indx2) = _bi2; \\\n+\t}\n+#   define GET_HDR_ADDR2(p1, ha1, p2, ha2) \\\n+\t{ \\\n+\t    register bottom_index * bi1; \\\n+\t    register bottom_index * bi2; \\\n+\t    \\\n+\t    GET_BI2(p1, bi1, p2, bi2);\t\\\n+\t    (ha1) = &(HDR_FROM_BI(bi1, p1)); \\\n+\t    (ha2) = &(HDR_FROM_BI(bi2, p2)); \\\n+\t}\n+#   define GET_HDR2(p1, hhdr1, p2, hhdr2) \\\n+\t{ register hdr ** _ha1;  \\\n+\t  register hdr ** _ha2;  \\\n+\t  GET_HDR_ADDR2(p1, _ha1, p2, _ha2); \\\n+\t  (hhdr1) = *_ha1;  \\\n+\t  (hhdr2) = *_ha2;  \\\n+\t}\n # endif\n \t\t\t    \n /* Is the result a forwarding address to someplace closer to the\t*/"}, {"sha": "d06cd8b872c0516883cf880fd8d4314dcd69528f", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 746, "deletions": 733, "changes": 1479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -2,7 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n+ * Copyright (c) 1999-2001 by Hewlett-Packard Company. All rights reserved.\n  *\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n@@ -14,7 +14,6 @@\n  * provided the above notices are retained, and a notice that the code was\n  * modified is included with the above copyright notice.\n  */\n-/* Boehm, February 16, 1996 2:30 pm PST */\n  \n \n # ifndef GC_PRIVATE_H\n@@ -41,16 +40,16 @@\n #   include \"gc.h\"\n # endif\n \n-typedef GC_word word;\n-typedef GC_signed_word signed_word;\n+# ifndef GC_MARK_H\n+#   include \"../gc_mark.h\"\n+# endif\n \n # ifndef GCCONFIG_H\n #   include \"gcconfig.h\"\n # endif\n \n-# ifndef HEADERS_H\n-#   include \"gc_hdrs.h\"\n-# endif\n+typedef GC_word word;\n+typedef GC_signed_word signed_word;\n \n typedef int GC_bool;\n # define TRUE 1\n@@ -61,6 +60,10 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n \t\t\t/* Preferably identical to caddr_t, if it \t*/\n \t\t\t/* exists.\t\t\t\t\t*/\n \t\t\t\n+# ifndef HEADERS_H\n+#   include \"gc_hdrs.h\"\n+# endif\n+\n #if defined(__STDC__)\n #   include <stdlib.h>\n #   if !(defined( sony_news ) )\n@@ -74,9 +77,31 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n #   define VOLATILE\n #endif\n \n-#define CONST GC_CONST\n+#if 0 /* defined(__GNUC__) doesn't work yet */\n+# define EXPECT(expr, outcome) __builtin_expect(expr,outcome)\n+  /* Equivalent to (expr), but predict that usually (expr)==outcome. */\n+#else\n+# define EXPECT(expr, outcome) (expr)\n+#endif /* __GNUC__ */\n+\n+# ifndef GC_LOCKS_H\n+#   include \"gc_locks.h\"\n+# endif\n \n-#if 0 /* was once defined for AMIGA */\n+# ifdef STACK_GROWS_DOWN\n+#   define COOLER_THAN >\n+#   define HOTTER_THAN <\n+#   define MAKE_COOLER(x,y) if ((word)(x)+(y) > (word)(x)) {(x) += (y);} \\\n+\t\t\t    else {(x) = (word)ONES;}\n+#   define MAKE_HOTTER(x,y) (x) -= (y)\n+# else\n+#   define COOLER_THAN <\n+#   define HOTTER_THAN >\n+#   define MAKE_COOLER(x,y) if ((word)(x)-(y) < (word)(x)) {(x) -= (y);} else {(x) = 0;}\n+#   define MAKE_HOTTER(x,y) (x) += (y)\n+# endif\n+\n+#if defined(AMIGA) && defined(__SASC)\n #   define GC_FAR __far\n #else\n #   define GC_FAR\n@@ -96,11 +121,9 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n /*                               */\n /*********************************/\n \n-#define STUBBORN_ALLOC\t/* Define stubborn allocation primitives\t*/\n-#if defined(SRC_M3) || defined(SMALL_CONFIG)\n-# undef STUBBORN_ALLOC\n-#endif\n-\n+/* #define STUBBORN_ALLOC */\n+\t\t    /* Enable stubborm allocation, and thus a limited\t*/\n+\t\t    /* form of incremental collection w/o dirty bits.\t*/\n \n /* #define ALL_INTERIOR_POINTERS */\n \t\t    /* Forces all pointers into the interior of an \t*/\n@@ -127,6 +150,8 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n \t\t    /*    touched.\t\t\t\t\t*/\n \t\t    /* If you can easily avoid using this option, do.\t*/\n \t\t    /* If not, try to keep individual objects small.\t*/\n+\t\t    /* This is now really controlled at startup,\t*/\n+\t\t    /* through GC_all_interior_pointers.\t\t*/\n \t\t    \n #define PRINTSTATS  /* Print garbage collection statistics          \t*/\n \t\t    /* For less verbose output, undefine in reclaim.c \t*/\n@@ -157,12 +182,12 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n #   define GATHERSTATS\n #endif\n \n-#ifdef FINALIZE_ON_DEMAND\n-#   define GC_INVOKE_FINALIZERS()\n-#else\n-#   define GC_INVOKE_FINALIZERS() (void)GC_invoke_finalizers()\n+#if defined(PRINTSTATS) || !defined(SMALL_CONFIG)\n+#   define CONDPRINT  /* Print some things if GC_print_stats is set */\n #endif\n \n+#define GC_INVOKE_FINALIZERS() GC_notify_or_invoke_finalizers()\n+\n #define MERGE_SIZES /* Round up some object sizes, so that fewer distinct */\n \t\t    /* free lists are actually maintained.  This applies  */\n \t\t    /* only to the top level routines in misc.c, not to   */\n@@ -174,20 +199,28 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n \t\t    /* May save significant amounts of space for obj_map  */\n \t\t    /* entries.\t\t\t\t\t\t  */\n \n+#if defined(USE_MARK_BYTES) && !defined(ALIGN_DOUBLE)\n+#  define ALIGN_DOUBLE\n+   /* We use one byte for every 2 words, which doesn't allow for\t*/\n+   /* odd numbered words to have mark bits.\t\t\t\t*/\n+#endif\n+\n /* ALIGN_DOUBLE requires MERGE_SIZES at present. */\n # if defined(ALIGN_DOUBLE) && !defined(MERGE_SIZES)\n #   define MERGE_SIZES\n # endif\n \n-#if defined(ALL_INTERIOR_POINTERS) && !defined(DONT_ADD_BYTE_AT_END)\n-# define ADD_BYTE_AT_END\n+#if !defined(DONT_ADD_BYTE_AT_END)\n+# define EXTRA_BYTES GC_all_interior_pointers\n+#else\n+# define EXTRA_BYTES 0\n #endif\n \n \n # ifndef LARGE_CONFIG\n-#   define MINHINCR 16\t/* Minimum heap increment, in blocks of HBLKSIZE  */\n-\t\t\t/* Must be multiple of largest page size.\t  */\n-#   define MAXHINCR 512\t/* Maximum heap increment, in blocks              */\n+#   define MINHINCR 16\t /* Minimum heap increment, in blocks of HBLKSIZE  */\n+\t\t\t /* Must be multiple of largest page size.\t   */\n+#   define MAXHINCR 2048 /* Maximum heap increment, in blocks              */\n # else\n #   define MINHINCR 64\n #   define MAXHINCR 4096\n@@ -220,17 +253,22 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n  * Number of frames and arguments to save in objects allocated by\n  * debugging allocator.\n  */\n-#   define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n+#   ifndef SAVE_CALL_COUNT\n+#     define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n \t\t\t/* alignment reasons.\t\t\t\t*/\n+#   else\n+#     define NFRAMES ((SAVE_CALL_COUNT + 1) & ~1)\n+#   endif\n #   define NARGS 2\t/* Mumber of arguments to save for each call.\t*/\n \n #   define NEED_CALLINFO\n \n /* Fill in the pc and argument information for up to NFRAMES of my\t*/\n /* callers.  Ignore my frame and my callers frame.\t\t\t*/\n-void GC_save_callers (/* struct callinfo info[NFRAMES] */);\n-\n-void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n+struct callinfo;\n+void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));\n+  \n+void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n \n #else\n \n@@ -244,7 +282,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \n #ifdef NEED_CALLINFO\n     struct callinfo {\n-\tword ci_pc;\n+\tword ci_pc;  \t/* Caller, not callee, pc\t*/\n #\tif NARGS > 0\n \t    word ci_arg[NARGS];\t/* bit-wise complement to avoid retention */\n #\tendif\n@@ -273,13 +311,13 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #   define MS_TIME_DIFF(a,b) ((double) (a.tv_sec - b.tv_sec) * 1000.0 \\\n                                + (double) (a.tv_usec - b.tv_usec) / 1000.0)\n #else /* !BSD_TIME */\n-# ifdef MSWIN32\n+# if defined(MSWIN32) || defined(MSWINCE)\n #   include <windows.h>\n #   include <winbase.h>\n #   define CLOCK_TYPE DWORD\n #   define GET_TIME(x) x = GetTickCount()\n #   define MS_TIME_DIFF(a,b) ((long)((a)-(b)))\n-# else /* !MSWIN32, !BSD_TIME */\n+# else /* !MSWIN32, !MSWINCE, !BSD_TIME */\n #   include <time.h>\n #   if !defined(__STDC__) && defined(SPARC) && defined(SUNOS4)\n       clock_t clock();\t/* Not in time.h, where it belongs\t*/\n@@ -325,6 +363,9 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #   include <string.h>\n #   define BCOPY_EXISTS\n # endif\n+# if defined(MACOSX)\n+#   define BCOPY_EXISTS\n+# endif\n \n # ifndef BCOPY_EXISTS\n #   include <string.h>\n@@ -342,6 +383,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n /* GET_MEM is currently not assumed to retrieve 0 filled space, */\n /* though we should perhaps take advantage of the case in which */\n /* does.\t\t\t\t\t\t\t*/\n+struct hblk;\t/* See below.\t*/\n # ifdef PCR\n     char * real_malloc();\n #   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n@@ -353,7 +395,8 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t\t\t    + GC_page_size) \\\n                                     + GC_page_size-1)\n #   else\n-#     if defined(AMIGA) || defined(NEXT) || defined(MACOSX) || defined(DOS4GW)\n+#     if defined(NEXT) || defined(MACOSX) || defined(DOS4GW) || \\\n+\t (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC))\n #       define GET_MEM(bytes) HBLKPTR((size_t) \\\n \t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n                                       + GC_page_size-1)\n@@ -374,312 +417,26 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t\tNewPtrClear(bytes + GC_page_size) + GC_page_size-1)\n #\t    endif\n #\t  else\n-              extern ptr_t GC_unix_get_mem();\n-#             define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)\n+#\t    ifdef MSWINCE\n+\t      extern ptr_t GC_wince_get_mem();\n+#\t      define GET_MEM(bytes) (struct hblk *)GC_wince_get_mem(bytes)\n+#\t    else\n+#\t      if defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)\n+\t        extern void *GC_amiga_get_mem(size_t size);\n+\t\tdefine GET_MEM(bytes) HBLKPTR((size_t) \\\n+                  GC_amiga_get_mem((size_t)bytes + GC_page_size) \\\n+\t\t  + GC_page_size-1)\n+#\t      else\n+                extern ptr_t GC_unix_get_mem();\n+#               define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)\n+#\t      endif\n+#\t    endif\n #\t  endif\n #\tendif\n #     endif\n #   endif\n # endif\n \n-/*\n- * Mutual exclusion between allocator/collector routines.\n- * Needed if there is more than one allocator thread.\n- * FASTLOCK() is assumed to try to acquire the lock in a cheap and\n- * dirty way that is acceptable for a few instructions, e.g. by\n- * inhibiting preemption.  This is assumed to have succeeded only\n- * if a subsequent call to FASTLOCK_SUCCEEDED() returns TRUE.\n- * FASTUNLOCK() is called whether or not FASTLOCK_SUCCEEDED().\n- * If signals cannot be tolerated with the FASTLOCK held, then\n- * FASTLOCK should disable signals.  The code executed under\n- * FASTLOCK is otherwise immune to interruption, provided it is\n- * not restarted.\n- * DCL_LOCK_STATE declares any local variables needed by LOCK and UNLOCK\n- * and/or DISABLE_SIGNALS and ENABLE_SIGNALS and/or FASTLOCK.\n- * (There is currently no equivalent for FASTLOCK.)\n- */  \n-# ifdef THREADS\n-#  ifdef PCR_OBSOLETE\t/* Faster, but broken with multiple lwp's\t*/\n-#    include  \"th/PCR_Th.h\"\n-#    include  \"th/PCR_ThCrSec.h\"\n-     extern struct PCR_Th_MLRep GC_allocate_ml;\n-#    define DCL_LOCK_STATE  PCR_sigset_t GC_old_sig_mask\n-#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml) \n-#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n-#    define FASTLOCK() PCR_ThCrSec_EnterSys()\n-     /* Here we cheat (a lot): */\n-#        define FASTLOCK_SUCCEEDED() (*(int *)(&GC_allocate_ml) == 0)\n-\t\t/* TRUE if nobody currently holds the lock */\n-#    define FASTUNLOCK() PCR_ThCrSec_ExitSys()\n-#  endif\n-#  ifdef PCR\n-#    include <base/PCR_Base.h>\n-#    include <th/PCR_Th.h>\n-     extern PCR_Th_ML GC_allocate_ml;\n-#    define DCL_LOCK_STATE \\\n-\t PCR_ERes GC_fastLockRes; PCR_sigset_t GC_old_sig_mask\n-#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml)\n-#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n-#    define FASTLOCK() (GC_fastLockRes = PCR_Th_ML_Try(&GC_allocate_ml))\n-#    define FASTLOCK_SUCCEEDED() (GC_fastLockRes == PCR_ERes_okay)\n-#    define FASTUNLOCK()  {\\\n-        if( FASTLOCK_SUCCEEDED() ) PCR_Th_ML_Release(&GC_allocate_ml); }\n-#  endif\n-#  ifdef SRC_M3\n-     extern word RT0u__inCritical;\n-#    define LOCK() RT0u__inCritical++\n-#    define UNLOCK() RT0u__inCritical--\n-#  endif\n-#  ifdef SOLARIS_THREADS\n-#    include <thread.h>\n-#    include <signal.h>\n-     extern mutex_t GC_allocate_ml;\n-#    define LOCK() mutex_lock(&GC_allocate_ml);\n-#    define UNLOCK() mutex_unlock(&GC_allocate_ml);\n-#  endif\n-#  if defined(LINUX_THREADS) \n-#   if defined(I386)|| defined(POWERPC) || defined(ALPHA) || defined(IA64) \\\n-    || defined(M68K)\n-#    include <pthread.h>\n-#    define USE_SPIN_LOCK\n-#    if defined(I386)\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t  int oldval;\n-\t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n-\t  __asm__ __volatile__(\"xchgl %0, %1\"\n-\t\t: \"=r\"(oldval), \"=m\"(*(addr))\n-\t\t: \"0\"(1), \"m\"(*(addr)));\n-\t  return oldval;\n-       }\n-#    endif\n-#    if defined(IA64)\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t  int oldval;\n-\t  __asm__ __volatile__(\"xchg4 %0=%1,%2\"\n-\t\t: \"=r\"(oldval), \"=m\"(*addr)\n-\t\t: \"r\"(1), \"1\"(*addr));\n-\t  return oldval;\n-       }\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-\t __asm__ __volatile__(\"st4.rel %0=r0\" : \"=m\" (*addr));\n-       }\n-#      define GC_CLEAR_DEFINED\n-#    endif\n-#    ifdef M68K\n-       /* Contributed by Tony Mantler.  I'm not sure how well it was\t*/\n-       /* tested.\t\t\t\t\t\t\t*/\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-          char oldval; /* this must be no longer than 8 bits */\n-\n-          /* The return value is semi-phony. */\n-          /* 'tas' sets bit 7 while the return */\n-          /* value pretends bit 0 was set */\n-          __asm__ __volatile__(\n-                 \"tas %1@; sne %0; negb %0\"\n-                 : \"=d\" (oldval)\n-                 : \"a\" (addr));\n-          return oldval;\n-       }\n-#    endif\n-#    if defined(POWERPC)\n-      inline static int GC_test_and_set(volatile unsigned int *addr) {\n-        int oldval;\n-        int temp = 1; // locked value\n-\n-        __asm__ __volatile__(\n-               \"1:\\tlwarx %0,0,%3\\n\"   // load and reserve\n-               \"\\tcmpwi %0, 0\\n\"       // if load is\n-               \"\\tbne 2f\\n\"            //   non-zero, return already set\n-               \"\\tstwcx. %2,0,%1\\n\"    // else store conditional\n-               \"\\tbne- 1b\\n\"           // retry if lost reservation\n-               \"2:\\t\\n\"                // oldval is zero if we set\n-              : \"=&r\"(oldval), \"=p\"(addr)\n-              : \"r\"(temp), \"1\"(addr)\n-              : \"memory\");\n-        return (int)oldval;\n-      }\n-      inline static void GC_clear(volatile unsigned int *addr) {\n-\t __asm__ __volatile__(\"eieio\");\n-         *(addr) = 0;\n-      }\n-#     define GC_CLEAR_DEFINED\n-#    endif\n-#    ifdef ALPHA\n-      inline static int GC_test_and_set(volatile unsigned int * addr)\n-      {\n-        unsigned long oldvalue;\n-        unsigned long temp;\n-\n-        __asm__ __volatile__(\n-                             \"1:     ldl_l %0,%1\\n\"\n-                             \"       and %0,%3,%2\\n\"\n-                             \"       bne %2,2f\\n\"\n-                             \"       xor %0,%3,%0\\n\"\n-                             \"       stl_c %0,%1\\n\"\n-                             \"       beq %0,3f\\n\"\n-                             \"       mb\\n\"\n-                             \"2:\\n\"\n-                             \".section .text2,\\\"ax\\\"\\n\"\n-                             \"3:     br 1b\\n\"\n-                             \".previous\"\n-                             :\"=&r\" (temp), \"=m\" (*addr), \"=&r\" (oldvalue)\n-                             :\"Ir\" (1), \"m\" (*addr));\n-\n-        return oldvalue;\n-      }\n-      /* Should probably also define GC_clear, since it needs\t*/\n-      /* a memory barrier ??\t\t\t\t\t*/\n-#    endif /* ALPHA */\n-#    ifdef ARM32\n-      inline static int GC_test_and_set(volatile unsigned int *addr) {\n-        int oldval;\n-        /* SWP on ARM is very similar to XCHG on x86.  Doesn't lock the\n-         * bus because there are no SMP ARM machines.  If/when there are,\n-         * this code will likely need to be updated. */\n-        /* See linuxthreads/sysdeps/arm/pt-machine.h in glibc-2.1 */\n-        __asm__ __volatile__(\"swp %0, %1, [%2]\"\n-      \t\t\t     : \"=r\"(oldval)\n-      \t\t\t     : \"r\"(1), \"r\"(addr));\n-        return oldval;\n-      }\n-#    endif\n-#    ifndef GC_CLEAR_DEFINED\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-\t  /* Try to discourage gcc from moving anything past this. */\n-\t  __asm__ __volatile__(\" \");\n-          *(addr) = 0;\n-       }\n-#    endif\n-\n-     extern volatile unsigned int GC_allocate_lock;\n-     extern pthread_t GC_lock_holder;\n-     extern void GC_lock(void);\n-\t/* Allocation lock holder.  Only set if acquired by client through */\n-\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n-#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n-#    define NO_THREAD (pthread_t)(-1)\n-#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n-#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    define LOCK() \\\n-\t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n-#    define UNLOCK() \\\n-\t\tGC_clear(&GC_allocate_lock)\n-     extern VOLATILE GC_bool GC_collecting;\n-#    define ENTER_GC() \\\n-\t\t{ \\\n-\t\t    GC_collecting = 1; \\\n-\t\t}\n-#    define EXIT_GC() GC_collecting = 0;\n-#   else /* LINUX_THREADS on hardware for which we don't know how\t*/\n-\t /* to do test and set.\t\t\t\t\t\t*/\n-#    include <pthread.h>\n-     extern pthread_mutex_t GC_allocate_ml;\n-#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n-#   endif\n-#  endif /* LINUX_THREADS */\n-#  if defined(HPUX_THREADS)\n-#    include <pthread.h>\n-     extern pthread_mutex_t GC_allocate_ml;\n-#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n-#  endif\n-#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS) \n-     /* This may also eventually be appropriate for HPUX_THREADS */\n-#    include <pthread.h>\n-#    ifndef HPUX_THREADS\n-\t/* This probably should never be included, but I can't test\t*/\n-\t/* on Irix anymore.\t\t\t\t\t\t*/\n-#       include <mutex.h>\n-#    endif\n-\n-#    ifndef HPUX_THREADS\n-#      if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n-\t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n-#        define GC_test_and_set(addr, v) test_and_set(addr,v)\n-#      else\n-#\t define GC_test_and_set(addr, v) __test_and_set(addr,v)\n-#      endif\n-#    else\n-       /* I couldn't find a way to do this inline on HP/UX\t*/\n-#    endif\n-     extern unsigned long GC_allocate_lock;\n-\t/* This is not a mutex because mutexes that obey the (optional) \t*/\n-\t/* POSIX scheduling rules are subject to convoys in high contention\t*/\n-\t/* applications.  This is basically a spin lock.\t\t\t*/\n-     extern pthread_t GC_lock_holder;\n-     extern void GC_lock(void);\n-\t/* Allocation lock holder.  Only set if acquired by client through */\n-\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n-#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n-#    define NO_THREAD (pthread_t)(-1)\n-#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n-#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    ifdef HPUX_THREADS\n-#      define LOCK() { if (!GC_test_and_clear(&GC_allocate_lock)) GC_lock(); }\n-       /* The following is INCORRECT, since the memory model is too weak. */\n-#      define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n-\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 1; }\n-#    else\n-#      define LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n-#      if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n-\t   && defined(_COMPILER_VERSION) && _COMPILER_VERSION >= 700\n-#\t    define UNLOCK() __lock_release(&GC_allocate_lock)\n-#      else\n-\t    /* The function call in the following should prevent the\t*/\n-\t    /* compiler from moving assignments to below the UNLOCK.\t*/\n-\t    /* This is probably not necessary for ucode or gcc 2.8.\t*/\n-\t    /* It may be necessary for Ragnarok and future gcc\t\t*/\n-\t    /* versions.\t\t\t\t\t\t*/\n-#           define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n-\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 0; }\n-#      endif\n-#    endif\n-     extern VOLATILE GC_bool GC_collecting;\n-#    define ENTER_GC() \\\n-\t\t{ \\\n-\t\t    GC_collecting = 1; \\\n-\t\t}\n-#    define EXIT_GC() GC_collecting = 0;\n-#  endif /* IRIX_THREADS || IRIX_JDK_THREADS */\n-#  ifdef WIN32_THREADS\n-#    include <windows.h>\n-     GC_API CRITICAL_SECTION GC_allocate_ml;\n-#    define LOCK() EnterCriticalSection(&GC_allocate_ml);\n-#    define UNLOCK() LeaveCriticalSection(&GC_allocate_ml);\n-#  endif\n-#  ifndef SET_LOCK_HOLDER\n-#      define SET_LOCK_HOLDER()\n-#      define UNSET_LOCK_HOLDER()\n-#      define I_HOLD_LOCK() FALSE\n-\t\t/* Used on platforms were locks can be reacquired,\t*/\n-\t\t/* so it doesn't matter if we lie.\t\t\t*/\n-#  endif\n-# else\n-#    define LOCK()\n-#    define UNLOCK()\n-# endif\n-# ifndef SET_LOCK_HOLDER\n-#   define SET_LOCK_HOLDER()\n-#   define UNSET_LOCK_HOLDER()\n-#   define I_HOLD_LOCK() FALSE\n-\t\t/* Used on platforms were locks can be reacquired,\t*/\n-\t\t/* so it doesn't matter if we lie.\t\t\t*/\n-# endif\n-# ifndef ENTER_GC\n-#   define ENTER_GC()\n-#   define EXIT_GC()\n-# endif\n-\n-# ifndef DCL_LOCK_STATE\n-#   define DCL_LOCK_STATE\n-# endif\n-# ifndef FASTLOCK\n-#   define FASTLOCK() LOCK()\n-#   define FASTLOCK_SUCCEEDED() TRUE\n-#   define FASTUNLOCK() UNLOCK()\n-# endif\n-\n /* Delay any interrupts or signals that may abort this thread.  Data\t*/\n /* structures are in a consistent state outside this pair of calls.\t*/\n /* ANSI C allows both to be empty (though the standard isn't very\t*/\n@@ -693,9 +450,9 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\tPCR_Th_SetSigMask(&GC_old_sig_mask, NIL)\n # else\n #   if defined(SRC_M3) || defined(AMIGA) || defined(SOLARIS_THREADS) \\\n-\t|| defined(MSWIN32) || defined(MACOS) || defined(DJGPP) \\\n-\t|| defined(NO_SIGNALS) || defined(IRIX_THREADS) \\\n-\t|| defined(IRIX_JDK_THREADS) || defined(LINUX_THREADS) \n+\t|| defined(MSWIN32) || defined(MSWINCE) || defined(MACOS) \\\n+\t|| defined(DJGPP) || defined(NO_SIGNALS) || defined(IRIX_THREADS) \\\n+\t|| defined(LINUX_THREADS) \n \t\t\t/* Also useful for debugging.\t\t*/\n \t/* Should probably use thr_sigsetmask for SOLARIS_THREADS. */\n #     define DISABLE_SIGNALS()\n@@ -724,7 +481,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n # else\n #   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n \t|| defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t|| defined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n+\t|| defined(HPUX_THREADS)\n       void GC_stop_world();\n       void GC_start_world();\n #     define STOP_WORLD() GC_stop_world()\n@@ -758,6 +515,13 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n # define WARN(msg,arg) (*GC_current_warn_proc)(msg, (GC_word)(arg))\n extern GC_warn_proc GC_current_warn_proc;\n \n+/* Get environment entry */\n+#if !defined(NO_GETENV)\n+#   define GETENV(name) getenv(name)\n+#else\n+#   define GETENV(name) 0\n+#endif\n+\n /*********************************/\n /*                               */\n /* Word-size-dependent defines   */\n@@ -787,7 +551,7 @@ extern GC_warn_proc GC_current_warn_proc;\n #define WORDSZ ((word)CPP_WORDSZ)\n #define SIGNB  ((word)1 << (WORDSZ-1))\n #define BYTES_PER_WORD      ((word)(sizeof (word)))\n-#define ONES                ((word)(-1))\n+#define ONES                ((word)(signed_word)(-1))\n #define divWORDSZ(n) ((n) >> LOGWL)\t   /* divide n by size of word      */\n \n /*********************/\n@@ -840,6 +604,8 @@ extern GC_warn_proc GC_current_warn_proc;\n /*  max size objects supported by freelist (larger objects may be   */\n /*  allocated, but less efficiently)                                */\n \n+#define CPP_MAXOBJBYTES (CPP_HBLKSIZE/2)\n+#define MAXOBJBYTES ((word)CPP_MAXOBJBYTES)\n #define CPP_MAXOBJSZ    BYTES_TO_WORDS(CPP_HBLKSIZE/2)\n #define MAXOBJSZ ((word)CPP_MAXOBJSZ)\n \t\t\n@@ -860,25 +626,28 @@ extern GC_warn_proc GC_current_warn_proc;\n # define HBLKDISPL(objptr) (((word) (objptr)) & (HBLKSIZE-1))\n \n /* Round up byte allocation requests to integral number of words, etc. */\n-# ifdef ADD_BYTE_AT_END\n-#   define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1))\n-#   ifdef ALIGN_DOUBLE\n-#       define ALIGNED_WORDS(n) (BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2)) & ~1)\n-#   else\n-#       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n-#   endif\n-#   define SMALL_OBJ(bytes) ((bytes) < WORDS_TO_BYTES(MAXOBJSZ))\n-#   define ADD_SLOP(bytes) ((bytes)+1)\n-# else\n-#   define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + (WORDS_TO_BYTES(1) - 1))\n-#   ifdef ALIGN_DOUBLE\n+# define ROUNDED_UP_WORDS(n) \\\n+\tBYTES_TO_WORDS((n) + (WORDS_TO_BYTES(1) - 1 + EXTRA_BYTES))\n+# ifdef ALIGN_DOUBLE\n #       define ALIGNED_WORDS(n) \\\n-\t\t\t(BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2) - 1) & ~1)\n-#   else\n+\t    (BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2) - 1 + EXTRA_BYTES) & ~1)\n+# else\n #       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n+# endif\n+# define SMALL_OBJ(bytes) ((bytes) < (MAXOBJBYTES -EXTRA_BYTES))\n+# define ADD_SLOP(bytes) ((bytes) + EXTRA_BYTES)\n+# ifndef MIN_WORDS\n+    /* MIN_WORDS is the size of the smallest allocated object.\t*/\n+    /* 1 and 2 are the only valid values.\t\t\t*/\n+    /* 2 must be used if:\t\t\t\t\t*/\n+    /* - GC_gcj_malloc can be used for objects of requested \t*/\n+    /*   size  smaller than 2 words, or\t\t\t\t*/\n+    /* - USE_MARK_BYTES is defined.\t\t\t\t*/\n+#   if defined(USE_MARK_BYTES) || defined(GC_GCJ_SUPPORT)\n+#     define MIN_WORDS 2   \t/* Smallest allocated object.\t*/\n+#   else\n+#     define MIN_WORDS 1\n #   endif\n-#   define SMALL_OBJ(bytes) ((bytes) <= WORDS_TO_BYTES(MAXOBJSZ))\n-#   define ADD_SLOP(bytes) (bytes)\n # endif\n \n \n@@ -889,11 +658,19 @@ extern GC_warn_proc GC_current_warn_proc;\n  */\n  \n # ifdef LARGE_CONFIG\n-#   define LOG_PHT_ENTRIES  17\n+#   define LOG_PHT_ENTRIES  19  /* Collisions likely at 512K blocks,\t*/\n+\t\t\t\t/* which is >= 2GB.  Each table takes\t*/\n+\t\t\t\t/* 64KB.\t\t\t\t*/\n # else\n-#   define LOG_PHT_ENTRIES  14\t/* Collisions are likely if heap grows\t*/\n-\t\t\t\t/* to more than 16K hblks = 64MB.\t*/\n-\t\t\t\t/* Each hash table occupies 2K bytes.   */\n+#   ifdef SMALL_CONFIG\n+#     define LOG_PHT_ENTRIES  14 /* Collisions are likely if heap grows\t*/\n+\t\t\t\t /* to more than 16K hblks = 64MB.\t*/\n+\t\t\t\t /* Each hash table occupies 2K bytes.   */\n+#   else /* default \"medium\" configuration */\n+#     define LOG_PHT_ENTRIES  16 /* Collisions are likely if heap grows\t*/\n+\t\t\t\t /* to more than 16K hblks >= 256MB.\t*/\n+\t\t\t\t /* Each hash table occupies 8K bytes.  */\n+#   endif\n # endif\n # define PHT_ENTRIES ((word)1 << LOG_PHT_ENTRIES)\n # define PHT_SIZE (PHT_ENTRIES >> LOGWL)\n@@ -907,6 +684,10 @@ typedef word page_hash_table[PHT_SIZE];\n \t\t(bl)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n # define clear_pht_entry_from_index(bl, index) \\\n \t\t(bl)[divWORDSZ(index)] &= ~((word)1 << modWORDSZ(index))\n+/* And a dumb but thread-safe version of set_pht_entry_from_index.\t*/\n+/* This sets (many) extra bits.\t\t\t\t\t\t*/\n+# define set_pht_entry_from_index_safe(bl, index) \\\n+\t\t(bl)[divWORDSZ(index)] = ONES\n \t\n \n \n@@ -919,20 +700,28 @@ typedef word page_hash_table[PHT_SIZE];\n /*  heap block header */\n #define HBLKMASK   (HBLKSIZE-1)\n \n-#define BITS_PER_HBLK (HBLKSIZE * 8)\n+#define BITS_PER_HBLK (CPP_HBLKSIZE * 8)\n \n #define MARK_BITS_PER_HBLK (BITS_PER_HBLK/CPP_WORDSZ)\n \t   /* upper bound                                    */\n-\t   /* We allocate 1 bit/word.  Only the first word   */\n+\t   /* We allocate 1 bit/word, unless USE_MARK_BYTES  */\n+\t   /* is defined.  Only the first word   \t     */\n \t   /* in each object is actually marked.             */\n \n-# ifdef ALIGN_DOUBLE\n-#   define MARK_BITS_SZ (((MARK_BITS_PER_HBLK + 2*CPP_WORDSZ - 1) \\\n-\t\t\t  / (2*CPP_WORDSZ))*2)\n+# ifdef USE_MARK_BYTES\n+#   define MARK_BITS_SZ (MARK_BITS_PER_HBLK/2)\n+\t/* Unlike the other case, this is in units of bytes.\t\t*/\n+\t/* We actually allocate only every second mark bit, since we\t*/\n+\t/* force all objects to be doubleword aligned.\t\t\t*/\n+\t/* However, each mark bit is allocated as a byte.\t\t*/\n # else\n-#   define MARK_BITS_SZ ((MARK_BITS_PER_HBLK + CPP_WORDSZ - 1)/CPP_WORDSZ)\n+#   define MARK_BITS_SZ (MARK_BITS_PER_HBLK/CPP_WORDSZ)\n # endif\n-\t   /* Upper bound on number of mark words per heap block  */\n+\n+/* We maintain layout maps for heap blocks containing objects of a given */\n+/* size.  Each entry in this map describes a byte offset and has the\t */\n+/* following type.\t\t\t\t\t\t\t */\n+typedef unsigned char map_entry_type;\n \n struct hblkhdr {\n     word hb_sz;  /* If in use, size in words, of objects in the block. */\n@@ -943,7 +732,8 @@ struct hblkhdr {\n     struct hblk * hb_prev;\t/* Backwards link for free list.\t*/\n     word hb_descr;   \t\t/* object descriptor for marking.  See\t*/\n     \t\t\t\t/* mark.h.\t\t\t\t*/\n-    char* hb_map;\t/* A pointer to a pointer validity map of the block. */\n+    map_entry_type * hb_map;\t\n+    \t\t\t/* A pointer to a pointer validity map of the block. */\n     \t\t      \t/* See GC_obj_map.\t\t\t\t     */\n     \t\t     \t/* Valid for all blocks with headers.\t\t     */\n     \t\t     \t/* Free blocks point to GC_invalid_map.\t\t     */\n@@ -965,56 +755,49 @@ struct hblkhdr {\n     \t\t\t\t/* Value of GC_gc_no when block was\t*/\n     \t\t\t\t/* last allocated or swept. May wrap.   */\n \t\t\t\t/* For a free block, this is maintained */\n-\t\t\t\t/* unly for USE_MUNMAP, and indicates\t*/\n+\t\t\t\t/* only for USE_MUNMAP, and indicates\t*/\n \t\t\t\t/* when the header was allocated, or\t*/\n \t\t\t\t/* when the size of the block last\t*/\n \t\t\t\t/* changed.\t\t\t\t*/\n-    word hb_marks[MARK_BITS_SZ];\n+#   ifdef USE_MARK_BYTES\n+      union {\n+        char _hb_marks[MARK_BITS_SZ];\n+\t\t\t    /* The i'th byte is 1 if the object \t*/\n+\t\t\t    /* starting at word 2i is marked, 0 o.w.\t*/\n+\tword dummy;\t/* Force word alignment of mark bytes. */\n+      } _mark_byte_union;\n+#     define hb_marks _mark_byte_union._hb_marks\n+#   else\n+      word hb_marks[MARK_BITS_SZ];\n \t\t\t    /* Bit i in the array refers to the             */\n \t\t\t    /* object starting at the ith word (header      */\n \t\t\t    /* INCLUDED) in the heap block.                 */\n \t\t\t    /* The lsb of word 0 is numbered 0.\t\t    */\n \t\t\t    /* Unused bits are invalid, and are \t    */\n \t\t\t    /* occasionally set, e.g for uncollectable\t    */\n \t\t\t    /* objects.\t\t\t\t\t    */\n+#   endif /* !USE_MARK_BYTES */\n };\n \n /*  heap block body */\n \n-# define DISCARD_WORDS 0\n-\t/* Number of words to be dropped at the beginning of each block\t*/\n-\t/* Must be a multiple of WORDSZ.  May reasonably be nonzero\t*/\n-\t/* on machines that don't guarantee longword alignment of\t*/\n-\t/* pointers, so that the number of false hits is minimized.\t*/\n-\t/* 0 and WORDSZ are probably the only reasonable values.\t*/\n-\n-# define BODY_SZ ((HBLKSIZE-WORDS_TO_BYTES(DISCARD_WORDS))/sizeof(word))\n+# define BODY_SZ (HBLKSIZE/sizeof(word))\n \n struct hblk {\n-#   if (DISCARD_WORDS != 0)\n+#   if 0  /* DISCARDWORDS no longer supported */\n         word garbage[DISCARD_WORDS];\n #   endif\n     word hb_body[BODY_SZ];\n };\n \n-# define HDR_WORDS ((word)DISCARD_WORDS)\n-# define HDR_BYTES ((word)WORDS_TO_BYTES(DISCARD_WORDS))\n-\n # define OBJ_SZ_TO_BLOCKS(sz) \\\n-    divHBLKSZ(HDR_BYTES + WORDS_TO_BYTES(sz) + HBLKSIZE-1)\n+    divHBLKSZ(WORDS_TO_BYTES(sz) + HBLKSIZE-1)\n     /* Size of block (in units of HBLKSIZE) needed to hold objects of\t*/\n     /* given sz (in words).\t\t\t\t\t\t*/\n \n /* Object free list link */\n # define obj_link(p) (*(ptr_t *)(p))\n \n-/* The type of mark procedures.  This really belongs in gc_mark.h.\t*/\n-/* But we put it here, so that we can avoid scanning the mark proc\t*/\n-/* table.\t\t\t\t\t\t\t\t*/\n-typedef struct ms_entry * (*mark_proc)(/* word * addr,\n-\t\t\t\t\t  struct ms_entry *mark_stack_ptr,\n-\t\t\t\t\t  struct ms_entry *mark_stack_limit,\n-\t\t\t\t\t  word env */);\n # define LOG_MAX_MARK_PROCS 6\n # define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n \n@@ -1028,12 +811,12 @@ typedef struct ms_entry * (*mark_proc)(/* word * addr,\n #   ifdef PCR\n #     define MAX_ROOT_SETS 1024\n #   else\n-#     ifdef MSWIN32\n-#\tdefine MAX_ROOT_SETS 512\n+#     if defined(MSWIN32) || defined(MSWINCE)\n+#\tdefine MAX_ROOT_SETS 1024\n \t    /* Under NT, we add only written pages, which can result \t*/\n \t    /* in many small root sets.\t\t\t\t\t*/\n #     else\n-#       define MAX_ROOT_SETS 64\n+#       define MAX_ROOT_SETS 256\n #     endif\n #   endif\n # endif\n@@ -1056,14 +839,14 @@ struct exclusion {\n struct roots {\n \tptr_t r_start;\n \tptr_t r_end;\n-#\tifndef MSWIN32\n+#\tif !defined(MSWIN32) && !defined(MSWINCE)\n \t  struct roots * r_next;\n #\tendif\n \tGC_bool r_tmp;\n \t  \t/* Delete before registering new dynamic libraries */\n };\n \n-#ifndef MSWIN32\n+#if !defined(MSWIN32) && !defined(MSWINCE)\n     /* Size of hash table index to roots.\t*/\n #   define LOG_RT_SIZE 6\n #   define RT_SIZE (1 << LOG_RT_SIZE) /* Power of 2, may be != MAX_ROOT_SETS */\n@@ -1097,11 +880,22 @@ struct _GC_arrays {\n   word _large_free_bytes;\n \t/* Total bytes contained in blocks on large object free */\n \t/* list.\t\t\t\t\t\t*/\n+  word _large_allocd_bytes;\n+  \t/* Total number of bytes in allocated large objects blocks.\t*/\n+  \t/* For the purposes of this counter and the next one only, a \t*/\n+  \t/* large object is one that occupies a block of at least\t*/\n+  \t/* 2*HBLKSIZE.\t\t\t\t\t\t\t*/\n+  word _max_large_allocd_bytes;\n+  \t/* Maximum number of bytes that were ever allocated in\t\t*/\n+  \t/* large object blocks.  This is used to help decide when it\t*/\n+  \t/* is safe to split up a large block.\t\t\t\t*/\n   word _words_allocd_before_gc;\n \t\t/* Number of words allocated before this\t*/\n \t\t/* collection cycle.\t\t\t\t*/\n-  word _words_allocd;\n+# ifndef SEPARATE_GLOBALS\n+    word _words_allocd;\n   \t/* Number of words allocated during this collection cycle */\n+# endif\n   word _words_wasted;\n   \t/* Number of words wasted due to internal fragmentation\t*/\n   \t/* in large objects, or due to dropping blacklisted     */\n@@ -1120,14 +914,17 @@ struct _GC_arrays {\n   ptr_t _scratch_last_end_ptr;\n \t/* Used by headers.c, and can easily appear to point to\t*/\n \t/* heap.\t\t\t\t\t\t*/\n-  mark_proc _mark_procs[MAX_MARK_PROCS];\n+  GC_mark_proc _mark_procs[MAX_MARK_PROCS];\n   \t/* Table of user-defined mark procedures.  There is\t*/\n \t/* a small number of these, which can be referenced\t*/\n \t/* by DS_PROC mark descriptors.  See gc_mark.h.\t\t*/\n-  ptr_t _objfreelist[MAXOBJSZ+1];\n+\n+# ifndef SEPARATE_GLOBALS\n+    ptr_t _objfreelist[MAXOBJSZ+1];\n \t\t\t  /* free list for objects */\n-  ptr_t _aobjfreelist[MAXOBJSZ+1];\n+    ptr_t _aobjfreelist[MAXOBJSZ+1];\n \t\t\t  /* free list for atomic objs \t*/\n+# endif\n \n   ptr_t _uobjfreelist[MAXOBJSZ+1];\n \t\t\t  /* uncollectable but traced objs \t*/\n@@ -1160,53 +957,40 @@ struct _GC_arrays {\n     ptr_t _sobjfreelist[MAXOBJSZ+1];\n # endif\n   \t\t\t  /* free list for immutable objects\t*/\n-  ptr_t _obj_map[MAXOBJSZ+1];\n+  map_entry_type * _obj_map[MAXOBJSZ+1];\n                        /* If not NIL, then a pointer to a map of valid  */\n     \t\t       /* object addresses. _obj_map[sz][i] is j if the\t*/\n     \t\t       /* address block_start+i is a valid pointer      */\n-    \t\t       /* to an object at\t\t\t\t*/\n-    \t\t       /* block_start+i&~3 - WORDS_TO_BYTES(j).\t\t*/\n-    \t\t       /* (If ALL_INTERIOR_POINTERS is defined, then\t*/\n-    \t\t       /* instead ((short *)(hb_map[sz])[i] is j if\t*/\n-    \t\t       /* block_start+WORDS_TO_BYTES(i) is in the\t*/\n-    \t\t       /* interior of an object starting at\t\t*/\n-    \t\t       /* block_start+WORDS_TO_BYTES(i-j)).\t\t*/\n-    \t\t       /* It is OBJ_INVALID if\t\t\t\t*/\n-    \t\t       /* block_start+WORDS_TO_BYTES(i) is not\t\t*/\n-    \t\t       /* valid as a pointer to an object.              */\n-    \t\t       /* We assume all values of j <= OBJ_INVALID.\t*/\n-    \t\t       /* The zeroth entry corresponds to large objects.*/\n-#   ifdef ALL_INTERIOR_POINTERS\n-#\tdefine map_entry_type short\n-#       define OBJ_INVALID 0x7fff\n-#\tdefine MAP_ENTRY(map, bytes) \\\n-\t\t(((map_entry_type *)(map))[BYTES_TO_WORDS(bytes)])\n-#\tdefine MAP_ENTRIES BYTES_TO_WORDS(HBLKSIZE)\n-#\tdefine MAP_SIZE (MAP_ENTRIES * sizeof(map_entry_type))\n-#\tdefine OFFSET_VALID(displ) TRUE\n-#\tdefine CPP_MAX_OFFSET (HBLKSIZE - HDR_BYTES - 1)\n-#\tdefine MAX_OFFSET ((word)CPP_MAX_OFFSET)\n-#   else\n-#\tdefine map_entry_type char\n-#       define OBJ_INVALID 0x7f\n-#\tdefine MAP_ENTRY(map, bytes) \\\n-\t\t(map)[bytes]\n-#\tdefine MAP_ENTRIES HBLKSIZE\n-#\tdefine MAP_SIZE MAP_ENTRIES\n-#\tdefine CPP_MAX_OFFSET (WORDS_TO_BYTES(OBJ_INVALID) - 1)\t\n-#\tdefine MAX_OFFSET ((word)CPP_MAX_OFFSET)\n+    \t\t       /* to an object at block_start +\t\t\t*/\n+ \t\t       /* WORDS_TO_BYTES(BYTES_TO_WORDS(i) - j)\t\t*/\n+  \t\t       /* I.e. j is a word displacement from the\t*/\n+  \t\t       /* object beginning.\t\t\t\t*/\n+  \t\t       /* The entry is OBJ_INVALID if the corresponding\t*/\n+  \t\t       /* address is not a valid pointer.  It is \t*/\n+  \t\t       /* OFFSET_TOO_BIG if the value j would be too \t*/\n+  \t\t       /* large to fit in the entry.  (Note that the\t*/\n+  \t\t       /* size of these entries matters, both for \t*/\n+  \t\t       /* space consumption and for cache utilization.\t*/\n+#   define OFFSET_TOO_BIG 0xfe\n+#   define OBJ_INVALID 0xff\n+#   define MAP_ENTRY(map, bytes) (map)[bytes]\n+#   define MAP_ENTRIES HBLKSIZE\n+#   define MAP_SIZE MAP_ENTRIES\n+#   define CPP_MAX_OFFSET (OFFSET_TOO_BIG - 1)\t\n+#   define MAX_OFFSET ((word)CPP_MAX_OFFSET)\n+    /* The following are used only if GC_all_interior_ptrs != 0 */\n # \tdefine VALID_OFFSET_SZ \\\n \t  (CPP_MAX_OFFSET > WORDS_TO_BYTES(CPP_MAXOBJSZ)? \\\n \t   CPP_MAX_OFFSET+1 \\\n \t   : WORDS_TO_BYTES(CPP_MAXOBJSZ)+1)\n   \tchar _valid_offsets[VALID_OFFSET_SZ];\n \t\t\t\t/* GC_valid_offsets[i] == TRUE ==> i \t*/\n \t\t\t\t/* is registered as a displacement.\t*/\n-#\tdefine OFFSET_VALID(displ) GC_valid_offsets[displ]\n+#\tdefine OFFSET_VALID(displ) \\\n+\t  (GC_all_interior_pointers || GC_valid_offsets[displ])\n   \tchar _modws_valid_offsets[sizeof(word)];\n \t\t\t\t/* GC_valid_offsets[i] ==>\t\t  */\n \t\t\t\t/* GC_modws_valid_offsets[i%sizeof(word)] */\n-#   endif\n # ifdef STUBBORN_ALLOC\n     page_hash_table _changed_pages;\n         /* Stubborn object pages that were changes since last call to\t*/\n@@ -1233,17 +1017,25 @@ struct _GC_arrays {\n #     define MAX_HEAP_SECTS 768\t\t/* Separately added heap sections. */\n #   endif\n # else\n-#   define MAX_HEAP_SECTS 256\n+#   ifdef SMALL_CONFIG\n+#     define MAX_HEAP_SECTS 128\t\t/* Roughly 1GB\t\t\t*/\n+#   else\n+#     define MAX_HEAP_SECTS 384\t\t/* Roughly 3GB\t\t\t*/\n+#   endif\n # endif\n   struct HeapSect {\n       ptr_t hs_start; word hs_bytes;\n   } _heap_sects[MAX_HEAP_SECTS];\n-# ifdef MSWIN32\n+# if defined(MSWIN32) || defined(MSWINCE)\n     ptr_t _heap_bases[MAX_HEAP_SECTS];\n     \t\t/* Start address of memory regions obtained from kernel. */\n+# endif\n+# ifdef MSWINCE\n+    word _heap_lengths[MAX_HEAP_SECTS];\n+    \t\t/* Commited lengths of memory regions obtained from kernel. */\n # endif\n   struct roots _static_roots[MAX_ROOT_SETS];\n-# ifndef MSWIN32\n+# if !defined(MSWIN32) && !defined(MSWINCE)\n     struct roots * _root_index[RT_SIZE];\n # endif\n   struct exclusion _excl_table[MAX_EXCLUSIONS];\n@@ -1262,8 +1054,11 @@ struct _GC_arrays {\n \n GC_API GC_FAR struct _GC_arrays GC_arrays; \n \n-# define GC_objfreelist GC_arrays._objfreelist\n-# define GC_aobjfreelist GC_arrays._aobjfreelist\n+# ifndef SEPARATE_GLOBALS\n+#   define GC_objfreelist GC_arrays._objfreelist\n+#   define GC_aobjfreelist GC_arrays._aobjfreelist\n+#   define GC_words_allocd GC_arrays._words_allocd\n+# endif\n # define GC_uobjfreelist GC_arrays._uobjfreelist\n # ifdef ATOMIC_UNCOLLECTABLE\n #   define GC_auobjfreelist GC_arrays._auobjfreelist\n@@ -1278,9 +1073,10 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_obj_map GC_arrays._obj_map\n # define GC_last_heap_addr GC_arrays._last_heap_addr\n # define GC_prev_heap_addr GC_arrays._prev_heap_addr\n-# define GC_words_allocd GC_arrays._words_allocd\n # define GC_words_wasted GC_arrays._words_wasted\n # define GC_large_free_bytes GC_arrays._large_free_bytes\n+# define GC_large_allocd_bytes GC_arrays._large_allocd_bytes\n+# define GC_max_large_allocd_bytes GC_arrays._max_large_allocd_bytes\n # define GC_words_finalized GC_arrays._words_finalized\n # define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n # define GC_mem_freed GC_arrays._mem_freed\n@@ -1296,9 +1092,12 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # ifdef USE_MUNMAP\n #   define GC_unmapped_bytes GC_arrays._unmapped_bytes\n # endif\n-# ifdef MSWIN32\n+# if defined(MSWIN32) || defined(MSWINCE)\n #   define GC_heap_bases GC_arrays._heap_bases\n # endif\n+# ifdef MSWINCE\n+#   define GC_heap_lengths GC_arrays._heap_lengths\n+# endif\n # define GC_static_roots GC_arrays._static_roots\n # define GC_root_index GC_arrays._root_index\n # define GC_excl_table GC_arrays._excl_table\n@@ -1345,10 +1144,27 @@ extern struct obj_kind {\n    GC_bool ok_init;   /* Clear objects before putting them on the free list. */\n } GC_obj_kinds[MAXOBJKINDS];\n \n-# define endGC_obj_kinds (((ptr_t)(&GC_obj_kinds)) + (sizeof GC_obj_kinds))\n+# define beginGC_obj_kinds ((ptr_t)(&GC_obj_kinds))\n+# define endGC_obj_kinds (beginGC_obj_kinds + (sizeof GC_obj_kinds))\n \n-# define end_gc_area ((ptr_t)endGC_arrays == (ptr_t)(&GC_obj_kinds) ? \\\n-\t\t\tendGC_obj_kinds : endGC_arrays)\n+/* Variables that used to be in GC_arrays, but need to be accessed by \t*/\n+/* inline allocation code.  If they were in GC_arrays, the inlined \t*/\n+/* allocation code would include GC_arrays offsets (as it did), which\t*/\n+/* introduce maintenance problems.\t\t\t\t\t*/\n+\n+#ifdef SEPARATE_GLOBALS\n+  word GC_words_allocd;\n+  \t/* Number of words allocated during this collection cycle */\n+  ptr_t GC_objfreelist[MAXOBJSZ+1];\n+\t\t\t  /* free list for NORMAL objects */\n+# define beginGC_objfreelist ((ptr_t)(&GC_objfreelist))\n+# define endGC_objfreelist (beginGC_objfreelist + sizeof(GC_objfreelist))\n+\n+  ptr_t GC_aobjfreelist[MAXOBJSZ+1];\n+\t\t\t  /* free list for atomic (PTRFREE) objs \t*/\n+# define beginGC_aobjfreelist ((ptr_t)(&GC_aobjfreelist))\n+# define endGC_aobjfreelist (beginGC_aobjfreelist + sizeof(GC_aobjfreelist))\n+#endif\n \n /* Predefined kinds: */\n # define PTRFREE 0\n@@ -1372,8 +1188,10 @@ extern word GC_n_heap_sects;\t/* Number of separately added heap\t*/\n \n extern word GC_page_size;\n \n-# ifdef MSWIN32\n-extern word GC_n_heap_bases;\t/* See GC_heap_bases.\t*/\n+# if defined(MSWIN32) || defined(MSWINCE)\n+  struct _SYSTEM_INFO;\n+  extern struct _SYSTEM_INFO GC_sysinfo;\n+  extern word GC_n_heap_bases;\t/* See GC_heap_bases.\t*/\n # endif\n \n extern word GC_total_stack_black_listed;\n@@ -1386,7 +1204,7 @@ extern word GC_black_list_spacing;\n \t\t\t/* \"stack-blacklisted\", i.e. that are \t\t*/\n \t\t\t/* problematic in the interior of an object.\t*/\n \n-extern char * GC_invalid_map;\n+extern map_entry_type * GC_invalid_map;\n \t\t\t/* Pointer to the nowhere valid hblk map */\n \t\t\t/* Blocks pointing to this map are free. */\n \n@@ -1418,10 +1236,6 @@ extern word GC_root_size;\t/* Total size of registered root sections */\n \n extern GC_bool GC_debugging_started;\t/* GC_debug_malloc has been called. */ \n \n-extern ptr_t GC_least_plausible_heap_addr;\n-extern ptr_t GC_greatest_plausible_heap_addr;\n-\t\t\t/* Bounds on the heap.  Guaranteed valid\t*/\n-\t\t\t/* Likely to include future heap expansion.\t*/\n \t\t\t\n /* Operations */\n # ifndef abs\n@@ -1434,6 +1248,33 @@ extern ptr_t GC_greatest_plausible_heap_addr;\n /*  with it. Only those corresponding to the beginning of an */\n /*  object are used.                                         */\n \n+/* Set mark bit correctly, even if mark bits may be concurrently \t*/\n+/* accessed.\t\t\t\t\t\t\t\t*/\n+#ifdef PARALLEL_MARK\n+# define OR_WORD(addr, bits) \\\n+\t{ word old; \\\n+\t  do { \\\n+\t    old = *((volatile word *)addr); \\\n+\t  } while (!GC_compare_and_exchange((addr), old, old | (bits))); \\\n+\t}\n+# define OR_WORD_EXIT_IF_SET(addr, bits, exit_label) \\\n+\t{ word old; \\\n+\t  word my_bits = (bits); \\\n+\t  do { \\\n+\t    old = *((volatile word *)addr); \\\n+\t    if (old & my_bits) goto exit_label; \\\n+\t  } while (!GC_compare_and_exchange((addr), old, old | my_bits)); \\\n+\t}\n+#else\n+# define OR_WORD(addr, bits) *(addr) |= (bits)\n+# define OR_WORD_EXIT_IF_SET(addr, bits, exit_label) \\\n+\t{ \\\n+\t  word old = *(addr); \\\n+\t  word my_bits = (bits); \\\n+\t  if (old & my_bits) goto exit_label; \\\n+\t  *(addr) = (old | my_bits); \\\n+\t}\n+#endif\n \n /* Mark bit operations */\n \n@@ -1445,72 +1286,87 @@ extern ptr_t GC_greatest_plausible_heap_addr;\n  * relative to the beginning of the block, including unused words)\n  */\n \n+#ifdef USE_MARK_BYTES\n+# define mark_bit_from_hdr(hhdr,n) ((hhdr)->hb_marks[(n) >> 1])\n+# define set_mark_bit_from_hdr(hhdr,n) ((hhdr)->hb_marks[(n)>>1]) = 1\n+# define clear_mark_bit_from_hdr(hhdr,n) ((hhdr)->hb_marks[(n)>>1]) = 0\n+#else /* !USE_MARK_BYTES */\n # define mark_bit_from_hdr(hhdr,n) (((hhdr)->hb_marks[divWORDSZ(n)] \\\n \t\t\t    >> (modWORDSZ(n))) & (word)1)\n-# define set_mark_bit_from_hdr(hhdr,n) (hhdr)->hb_marks[divWORDSZ(n)] \\\n-\t\t\t\t|= (word)1 << modWORDSZ(n)\n-\n+# define set_mark_bit_from_hdr(hhdr,n) \\\n+\t\t\t    OR_WORD((hhdr)->hb_marks+divWORDSZ(n), \\\n+\t\t\t\t    (word)1 << modWORDSZ(n))\n # define clear_mark_bit_from_hdr(hhdr,n) (hhdr)->hb_marks[divWORDSZ(n)] \\\n \t\t\t\t&= ~((word)1 << modWORDSZ(n))\n+#endif /* !USE_MARK_BYTES */\n \n /* Important internal collector routines */\n \n-ptr_t GC_approx_sp();\n-\n-GC_bool GC_should_collect();\n-\n-void GC_apply_to_all_blocks(/*fn, client_data*/);\n-\t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n-\t\t\t/* allocated heap block.\t\t\t*/\n-struct hblk * GC_next_used_block(/* struct hblk * h */);\n-\t\t\t/* Return first in-use block >= h\t*/\n-struct hblk * GC_prev_block(/* struct hblk * h */);\n-\t\t\t/* Return last block <= h.  Returned block\t*/\n-\t\t\t/* is managed by GC, but may or may not be in\t*/\n+ptr_t GC_approx_sp GC_PROTO((void));\n+  \n+GC_bool GC_should_collect GC_PROTO((void));\n+  \n+void GC_apply_to_all_blocks GC_PROTO(( \\\n+    void (*fn) GC_PROTO((struct hblk *h, word client_data)), \\\n+    word client_data));\n+  \t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n+  \t\t\t/* allocated heap block.\t\t\t*/\n+struct hblk * GC_next_used_block GC_PROTO((struct hblk * h));\n+  \t\t\t/* Return first in-use block >= h\t*/\n+struct hblk * GC_prev_block GC_PROTO((struct hblk * h));\n+  \t\t\t/* Return last block <= h.  Returned block\t*/\n+  \t\t\t/* is managed by GC, but may or may not be in\t*/\n \t\t\t/* use.\t\t\t\t\t\t*/\n-void GC_mark_init();\n-void GC_clear_marks();\t/* Clear mark bits for all heap objects. */\n-void GC_invalidate_mark_state();\t/* Tell the marker that\tmarked \t   */\n-\t\t\t\t\t/* objects may point to\tunmarked   */\n-\t\t\t\t\t/* ones, and roots may point to\t   */\n-\t\t\t\t\t/* unmarked objects.\t\t   */\n-\t\t\t\t\t/* Reset mark stack.\t\t   */\n-void GC_mark_from_mark_stack(); /* Mark from everything on the mark stack. */\n-\t\t\t\t/* Return after about one pages worth of   */\n-\t\t\t\t/* work.\t\t\t\t   */\n-GC_bool GC_mark_stack_empty();\n-GC_bool GC_mark_some(/* cold_gc_frame */);\n-\t\t\t/* Perform about one pages worth of marking\t*/\n-\t\t\t/* work of whatever kind is needed.  Returns\t*/\n-\t\t\t/* quickly if no collection is in progress.\t*/\n-\t\t\t/* Return TRUE if mark phase finished.\t\t*/\n-void GC_initiate_gc();\t\t/* initiate collection.\t\t\t*/\n-\t\t\t\t/* If the mark state is invalid, this\t*/\n-\t\t\t\t/* becomes full colleection.  Otherwise */\n-\t\t\t\t/* it's partial.\t\t\t*/\n-void GC_push_all(/*b,t*/);\t/* Push everything in a range \t\t*/\n-\t\t\t\t/* onto mark stack.\t\t\t*/\n-void GC_push_dirty(/*b,t*/);      /* Push all possibly changed\t \t*/\n-\t\t\t\t  /* subintervals of [b,t) onto\t\t*/\n-\t\t\t\t  /* mark stack.\t\t\t*/\n+void GC_mark_init GC_PROTO((void));\n+void GC_clear_marks GC_PROTO((void));\t/* Clear mark bits for all heap objects. */\n+void GC_invalidate_mark_state GC_PROTO((void));\n+\t\t\t\t\t/* Tell the marker that\tmarked \t   */\n+  \t\t\t\t\t/* objects may point to\tunmarked   */\n+  \t\t\t\t\t/* ones, and roots may point to\t   */\n+  \t\t\t\t\t/* unmarked objects.\t\t   */\n+  \t\t\t\t\t/* Reset mark stack.\t\t   */\n+GC_bool GC_mark_stack_empty GC_PROTO((void));\n+GC_bool GC_mark_some GC_PROTO((ptr_t cold_gc_frame));\n+  \t\t\t/* Perform about one pages worth of marking\t*/\n+  \t\t\t/* work of whatever kind is needed.  Returns\t*/\n+  \t\t\t/* quickly if no collection is in progress.\t*/\n+  \t\t\t/* Return TRUE if mark phase finished.\t\t*/\n+void GC_initiate_gc GC_PROTO((void));\n+\t\t\t\t/* initiate collection.\t\t\t*/\n+  \t\t\t\t/* If the mark state is invalid, this\t*/\n+  \t\t\t\t/* becomes full colleection.  Otherwise */\n+  \t\t\t\t/* it's partial.\t\t\t*/\n+void GC_push_all GC_PROTO((ptr_t bottom, ptr_t top));\n+\t\t\t\t/* Push everything in a range \t\t*/\n+  \t\t\t\t/* onto mark stack.\t\t\t*/\n+void GC_push_selected GC_PROTO(( \\\n+    ptr_t bottom, \\\n+    ptr_t top, \\\n+    int (*dirty_fn) GC_PROTO((struct hblk *h)), \\\n+    void (*push_fn) GC_PROTO((ptr_t bottom, ptr_t top)) ));\n+\t\t\t\t  /* Push all pages h in [b,t) s.t. \t*/\n+\t\t\t\t  /* select_fn(h) != 0 onto mark stack. */\n #ifndef SMALL_CONFIG\n-  void GC_push_conditional(/* ptr_t b, ptr_t t, GC_bool all*/);\n+  void GC_push_conditional GC_PROTO((ptr_t b, ptr_t t, GC_bool all));\n #else\n # define GC_push_conditional(b, t, all) GC_push_all(b, t)\n #endif\n                                 /* Do either of the above, depending\t*/\n \t\t\t\t/* on the third arg.\t\t\t*/\n-void GC_push_all_stack(/*b,t*/);    /* As above, but consider\t\t*/\n+void GC_push_all_stack GC_PROTO((ptr_t b, ptr_t t));\n+\t\t\t\t    /* As above, but consider\t\t*/\n \t\t\t\t    /*  interior pointers as valid  \t*/\n-void GC_push_all_eager(/*b,t*/);    /* Same as GC_push_all_stack, but   */\n+void GC_push_all_eager GC_PROTO((ptr_t b, ptr_t t));\n+\t\t\t\t    /* Same as GC_push_all_stack, but   */\n \t\t\t\t    /* ensures that stack is scanned\t*/\n \t\t\t\t    /* immediately, not just scheduled  */\n \t\t\t\t    /* for scanning.\t\t\t*/\n #ifndef THREADS\n-  void GC_push_all_stack_partially_eager(/* bottom, top, cold_gc_frame */);\n+  void GC_push_all_stack_partially_eager GC_PROTO(( \\\n+      ptr_t bottom, ptr_t top, ptr_t cold_gc_frame ));\n \t\t\t/* Similar to GC_push_all_eager, but only the\t*/\n \t\t\t/* part hotter than cold_gc_frame is scanned\t*/\n-\t\t\t/* immediately.  Needed to endure that callee-\t*/\n+\t\t\t/* immediately.  Needed to ensure that callee-\t*/\n \t\t\t/* save registers are not missed.\t\t*/\n #else\n   /* In the threads case, we push part of the current thread stack\t*/\n@@ -1519,258 +1375,371 @@ void GC_push_all_eager(/*b,t*/);    /* Same as GC_push_all_stack, but   */\n   /* stacks are scheduled for scanning in *GC_push_other_roots, which\t*/\n   /* is thread-package-specific.\t\t\t\t\t*/\n #endif\n-void GC_push_current_stack(/* ptr_t cold_gc_frame */);\n-\t\t\t/* Push enough of the current stack eagerly to\t*/\n-\t\t\t/* ensure that callee-save registers saved in\t*/\n-\t\t\t/* GC frames are scanned.\t\t\t*/\n-\t\t\t/* In the non-threads case, schedule entire\t*/\n-\t\t\t/* stack for scanning.\t\t\t\t*/\n-void GC_push_roots(/* GC_bool all, ptr_t cold_gc_frame */);\n-\t\t\t/* Push all or dirty roots.\t*/\n-extern void (*GC_push_other_roots)();\n-\t\t\t/* Push system or application specific roots\t*/\n-\t\t\t/* onto the mark stack.  In some environments\t*/\n-\t\t\t/* (e.g. threads environments) this is\t\t*/\n-\t\t\t/* predfined to be non-zero.  A client supplied */\n-\t\t\t/* replacement should also call the original\t*/\n-\t\t\t/* function.\t\t\t\t\t*/\n-extern void (*GC_start_call_back)(/* void */);\n-\t\t\t/* Called at start of full collections.\t\t*/\n-\t\t\t/* Not called if 0.  Called with allocation \t*/\n-\t\t\t/* lock held.\t\t\t\t\t*/\n-\t\t\t/* 0 by default.\t\t\t\t*/\n-void GC_push_regs();\t/* Push register contents onto mark stack.\t*/\n-\t\t\t/* If NURSERY is defined, the default push\t*/\n-\t\t\t/* action can be overridden with GC_push_proc\t*/\n-void GC_remark();\t/* Mark from all marked objects.  Used\t*/\n-\t\t \t/* only if we had to drop something.\t*/\n+void GC_push_current_stack GC_PROTO((ptr_t cold_gc_frame));\n+  \t\t\t/* Push enough of the current stack eagerly to\t*/\n+  \t\t\t/* ensure that callee-save registers saved in\t*/\n+  \t\t\t/* GC frames are scanned.\t\t\t*/\n+  \t\t\t/* In the non-threads case, schedule entire\t*/\n+  \t\t\t/* stack for scanning.\t\t\t\t*/\n+void GC_push_roots GC_PROTO((GC_bool all, ptr_t cold_gc_frame));\n+  \t\t\t/* Push all or dirty roots.\t*/\n+extern void (*GC_push_other_roots) GC_PROTO((void));\n+  \t\t\t/* Push system or application specific roots\t*/\n+  \t\t\t/* onto the mark stack.  In some environments\t*/\n+  \t\t\t/* (e.g. threads environments) this is\t\t*/\n+  \t\t\t/* predfined to be non-zero.  A client supplied */\n+  \t\t\t/* replacement should also call the original\t*/\n+  \t\t\t/* function.\t\t\t\t\t*/\n+extern void GC_push_gc_structures GC_PROTO((void));\n+\t\t\t/* Push GC internal roots.  These are normally\t*/\n+\t\t\t/* included in the static data segment, and \t*/\n+\t\t\t/* Thus implicitly pushed.  But we must do this\t*/\n+\t\t\t/* explicitly if normal root processing is \t*/\n+\t\t\t/* disabled.  Calls the following:\t\t*/\n+\textern void GC_push_finalizer_structures GC_PROTO((void));\n+\textern void GC_push_stubborn_structures GC_PROTO((void));\n+#\tifdef THREADS\n+\t  extern void GC_push_thread_structures GC_PROTO((void));\n+#\tendif\n+extern void (*GC_start_call_back) GC_PROTO((void));\n+  \t\t\t/* Called at start of full collections.\t\t*/\n+  \t\t\t/* Not called if 0.  Called with allocation \t*/\n+  \t\t\t/* lock held.\t\t\t\t\t*/\n+  \t\t\t/* 0 by default.\t\t\t\t*/\n+# if defined(USE_GENERIC_PUSH_REGS)\n+  void GC_generic_push_regs GC_PROTO((ptr_t cold_gc_frame));\n+# else\n+  void GC_push_regs GC_PROTO((void));\n+# endif\n+\t\t\t/* Push register contents onto mark stack.\t*/\n+  \t\t\t/* If NURSERY is defined, the default push\t*/\n+  \t\t\t/* action can be overridden with GC_push_proc\t*/\n \n # ifdef NURSERY\n     extern void (*GC_push_proc)(ptr_t);\n # endif\n-# if defined(MSWIN32)\n-  void __cdecl GC_push_one();\n+# if defined(MSWIN32) || defined(MSWINCE)\n+  void __cdecl GC_push_one GC_PROTO((word p));\n # else\n-  void GC_push_one(/*p*/);    /* If p points to an object, mark it    */\n+  void GC_push_one GC_PROTO((word p));\n+\t\t\t      /* If p points to an object, mark it    */\n                               /* and push contents on the mark stack  */\n+  \t\t\t      /* Pointer recognition test always      */\n+  \t\t\t      /* accepts interior pointers, i.e. this */\n+  \t\t\t      /* is appropriate for pointers found on */\n+  \t\t\t      /* stack.\t\t\t\t      */\n+# endif\n+# if defined(PRINT_BLACK_LIST) || defined(KEEP_BACK_PTRS)\n+  void GC_mark_and_push_stack GC_PROTO((word p, ptr_t source));\n+\t\t\t\t/* Ditto, omits plausibility test\t*/\n+# else\n+  void GC_mark_and_push_stack GC_PROTO((word p));\n # endif\n-void GC_push_one_checked(/*p*/); /* Ditto, omits plausibility test\t*/\n-void GC_push_marked(/* struct hblk h, hdr * hhdr */);\n+void GC_push_marked GC_PROTO((struct hblk * h, hdr * hhdr));\n \t\t/* Push contents of all marked objects in h onto\t*/\n \t\t/* mark stack.\t\t\t\t\t\t*/\n #ifdef SMALL_CONFIG\n # define GC_push_next_marked_dirty(h) GC_push_next_marked(h)\n #else\n-  struct hblk * GC_push_next_marked_dirty(/* h */);\n+  struct hblk * GC_push_next_marked_dirty GC_PROTO((struct hblk * h));\n \t\t/* Invoke GC_push_marked on next dirty block above h.\t*/\n \t\t/* Return a pointer just past the end of this block.\t*/\n #endif /* !SMALL_CONFIG */\n-struct hblk * GC_push_next_marked(/* h */);\n-\t\t/* Ditto, but also mark from clean pages.\t*/\n-struct hblk * GC_push_next_marked_uncollectable(/* h */);\n-\t\t/* Ditto, but mark only from uncollectable pages.\t*/\n-GC_bool GC_stopped_mark(); /* Stop world and mark from all roots\t*/\n-\t\t\t/* and rescuers.\t\t\t*/\n-void GC_clear_hdr_marks(/* hhdr */);  /* Clear the mark bits in a header */\n-void GC_set_hdr_marks(/* hhdr */);  /* Set the mark bits in a header */\n-void GC_add_roots_inner();\n-GC_bool GC_is_static_root(/* ptr_t p */);\n-\t\t/* Is the address p in one of the registered static\t*/\n+struct hblk * GC_push_next_marked GC_PROTO((struct hblk * h));\n+  \t\t/* Ditto, but also mark from clean pages.\t*/\n+struct hblk * GC_push_next_marked_uncollectable GC_PROTO((struct hblk * h));\n+  \t\t/* Ditto, but mark only from uncollectable pages.\t*/\n+GC_bool GC_stopped_mark GC_PROTO((GC_stop_func stop_func));\n+ \t\t\t/* Stop world and mark from all roots\t*/\n+  \t\t\t/* and rescuers.\t\t\t*/\n+void GC_clear_hdr_marks GC_PROTO((hdr * hhdr));\n+\t\t\t\t    /* Clear the mark bits in a header */\n+void GC_set_hdr_marks GC_PROTO((hdr * hhdr));\n+ \t\t\t\t    /* Set the mark bits in a header */\n+void GC_add_roots_inner GC_PROTO((char * b, char * e, GC_bool tmp));\n+GC_bool GC_is_static_root GC_PROTO((ptr_t p));\n+  \t\t/* Is the address p in one of the registered static\t*/\n+  \t\t/* root sections?\t\t\t\t\t*/\n+# if defined(MSWIN32) || defined(_WIN32_WCE_EMULATION)\n+GC_bool GC_is_tmp_root GC_PROTO((ptr_t p));\n+\t\t/* Is the address p in one of the temporary static\t*/\n \t\t/* root sections?\t\t\t\t\t*/\n-void GC_register_dynamic_libraries();\n-\t\t/* Add dynamic library data sections to the root set. */\n-\n+# endif\n+void GC_register_dynamic_libraries GC_PROTO((void));\n+  \t\t/* Add dynamic library data sections to the root set. */\n+  \n /* Machine dependent startup routines */\n-ptr_t GC_get_stack_base();\n-void GC_register_data_segments();\n-\n+ptr_t GC_get_stack_base GC_PROTO((void));\t/* Cold end of stack */\n+#ifdef IA64\n+  ptr_t GC_get_register_stack_base GC_PROTO((void));\n+  \t\t\t\t\t/* Cold end of register stack.\t*/\n+#endif\n+void GC_register_data_segments GC_PROTO((void));\n+  \n /* Black listing: */\n-void GC_bl_init(); \t\n-# ifndef ALL_INTERIOR_POINTERS\n-    void GC_add_to_black_list_normal(/* bits, maybe source */);\n+void GC_bl_init GC_PROTO((void));\n+# ifdef PRINT_BLACK_LIST\n+      void GC_add_to_black_list_normal GC_PROTO((word p, ptr_t source));\n \t\t\t/* Register bits as a possible future false\t*/\n \t\t\t/* reference from the heap or static data\t*/\n-#   ifdef PRINT_BLACK_LIST\n #     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_normal(bits, source)\n-#   else\n-#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_normal(bits)\n-#   endif\n+      \t\tif (GC_all_interior_pointers) { \\\n+\t\t  GC_add_to_black_list_stack(bits, source); \\\n+\t\t} else { \\\n+  \t\t  GC_add_to_black_list_normal(bits, source); \\\n+\t\t}\n # else\n-#   ifdef PRINT_BLACK_LIST\n-#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_stack(bits, source)\n-#   else\n+      void GC_add_to_black_list_normal GC_PROTO((word p));\n #     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_stack(bits)\n-#   endif\n+      \t\tif (GC_all_interior_pointers) { \\\n+\t\t  GC_add_to_black_list_stack(bits); \\\n+\t\t} else { \\\n+  \t\t  GC_add_to_black_list_normal(bits); \\\n+\t\t}\n # endif\n \n-void GC_add_to_black_list_stack(/* bits, maybe source */);\n-struct hblk * GC_is_black_listed(/* h, len */);\n-\t\t\t/* If there are likely to be false references\t*/\n-\t\t\t/* to a block starting at h of the indicated    */\n-\t\t\t/* length, then return the next plausible\t*/\n-\t\t\t/* starting location for h that might avoid\t*/\n-\t\t\t/* these false references.\t\t\t*/\n-void GC_promote_black_lists();\n-\t\t\t/* Declare an end to a black listing phase.\t*/\n-void GC_unpromote_black_lists();\n-\t\t\t/* Approximately undo the effect of the above.\t*/\n-\t\t\t/* This actually loses some information, but\t*/\n-\t\t\t/* only in a reasonably safe way.\t\t*/\n-word GC_number_stack_black_listed(/*struct hblk *start, struct hblk *endp1 */);\n-\t\t\t/* Return the number of (stack) blacklisted\t*/\n-\t\t\t/* blocks in the range for statistical\t\t*/\n-\t\t\t/* purposes.\t\t\t\t\t*/\n-\t\t \t\n-ptr_t GC_scratch_alloc(/*bytes*/);\n-\t\t\t\t/* GC internal memory allocation for\t*/\n-\t\t\t\t/* small objects.  Deallocation is not  */\n-\t\t\t\t/* possible.\t\t\t\t*/\n-\t\n+# ifdef PRINT_BLACK_LIST\n+    void GC_add_to_black_list_stack GC_PROTO((word p, ptr_t source));\n+# else\n+    void GC_add_to_black_list_stack GC_PROTO((word p));\n+# endif\n+struct hblk * GC_is_black_listed GC_PROTO((struct hblk * h, word len));\n+  \t\t\t/* If there are likely to be false references\t*/\n+  \t\t\t/* to a block starting at h of the indicated    */\n+  \t\t\t/* length, then return the next plausible\t*/\n+  \t\t\t/* starting location for h that might avoid\t*/\n+  \t\t\t/* these false references.\t\t\t*/\n+void GC_promote_black_lists GC_PROTO((void));\n+  \t\t\t/* Declare an end to a black listing phase.\t*/\n+void GC_unpromote_black_lists GC_PROTO((void));\n+  \t\t\t/* Approximately undo the effect of the above.\t*/\n+  \t\t\t/* This actually loses some information, but\t*/\n+  \t\t\t/* only in a reasonably safe way.\t\t*/\n+word GC_number_stack_black_listed GC_PROTO(( \\\n+\tstruct hblk *start, struct hblk *endp1));\n+  \t\t\t/* Return the number of (stack) blacklisted\t*/\n+  \t\t\t/* blocks in the range for statistical\t\t*/\n+  \t\t\t/* purposes.\t\t\t\t\t*/\n+  \t\t \t\n+ptr_t GC_scratch_alloc GC_PROTO((word bytes));\n+  \t\t\t\t/* GC internal memory allocation for\t*/\n+  \t\t\t\t/* small objects.  Deallocation is not  */\n+  \t\t\t\t/* possible.\t\t\t\t*/\n+  \t\n /* Heap block layout maps: */\t\t\t\n-void GC_invalidate_map(/* hdr */);\n-\t\t\t\t/* Remove the object map associated\t*/\n-\t\t\t\t/* with the block.  This identifies\t*/\n-\t\t\t\t/* the block as invalid to the mark\t*/\n-\t\t\t\t/* routines.\t\t\t\t*/\n-GC_bool GC_add_map_entry(/*sz*/);\n-\t\t\t\t/* Add a heap block map for objects of\t*/\n-\t\t\t\t/* size sz to obj_map.\t\t\t*/\n-\t\t\t\t/* Return FALSE on failure.\t\t*/\n-void GC_register_displacement_inner(/*offset*/);\n-\t\t\t\t/* Version of GC_register_displacement\t*/\n-\t\t\t\t/* that assumes lock is already held\t*/\n-\t\t\t\t/* and signals are already disabled.\t*/\n-\n+void GC_invalidate_map GC_PROTO((hdr * hhdr));\n+  \t\t\t\t/* Remove the object map associated\t*/\n+  \t\t\t\t/* with the block.  This identifies\t*/\n+  \t\t\t\t/* the block as invalid to the mark\t*/\n+  \t\t\t\t/* routines.\t\t\t\t*/\n+GC_bool GC_add_map_entry GC_PROTO((word sz));\n+  \t\t\t\t/* Add a heap block map for objects of\t*/\n+  \t\t\t\t/* size sz to obj_map.\t\t\t*/\n+  \t\t\t\t/* Return FALSE on failure.\t\t*/\n+void GC_register_displacement_inner GC_PROTO((word offset));\n+  \t\t\t\t/* Version of GC_register_displacement\t*/\n+  \t\t\t\t/* that assumes lock is already held\t*/\n+  \t\t\t\t/* and signals are already disabled.\t*/\n+  \n /*  hblk allocation: */\t\t\n-void GC_new_hblk(/*size_in_words, kind*/);\n-\t\t\t\t/* Allocate a new heap block, and build */\n-\t\t\t\t/* a free list in it.\t\t\t*/\t\t\t\t\n-struct hblk * GC_allochblk(/*size_in_words, kind*/);\n-\t\t\t\t/* Allocate a heap block, clear it if\t*/\n-\t\t\t\t/* for composite objects, inform\t*/\n+void GC_new_hblk GC_PROTO((word size_in_words, int kind));\n+  \t\t\t\t/* Allocate a new heap block, and build */\n+  \t\t\t\t/* a free list in it.\t\t\t*/\t\t\t\t\n+\n+ptr_t GC_build_fl GC_PROTO((struct hblk *h, word sz,\n+\t\t\t   GC_bool clear,  ptr_t list));\n+\t\t\t\t/* Build a free list for objects of \t*/\n+\t\t\t\t/* size sz in block h.  Append list to\t*/\n+\t\t\t\t/* end of the free lists.  Possibly\t*/\n+\t\t\t\t/* clear objects on the list.  Normally\t*/\n+\t\t\t\t/* called by GC_new_hblk, but also\t*/\n+\t\t\t\t/* called explicitly without GC lock.\t*/\n+\n+struct hblk * GC_allochblk GC_PROTO(( \\\n+\tword size_in_words, int kind, unsigned flags));\n+\t\t\t\t/* Allocate a heap block, inform\t*/\n \t\t\t\t/* the marker that block is valid\t*/\n \t\t\t\t/* for objects of indicated size.\t*/\n-\t\t\t\t/* sz < 0 ==> atomic.\t\t\t*/ \n-void GC_freehblk();\t\t/* Deallocate a heap block and mark it  */\n-\t\t\t\t/* as invalid.\t\t\t\t*/\n-\t\t\t\t\n+\n+ptr_t GC_alloc_large GC_PROTO((word lw, int k, unsigned flags));\n+\t\t\t/* Allocate a large block of size lw words.\t*/\n+\t\t\t/* The block is not cleared.\t\t\t*/\n+\t\t\t/* Flags is 0 or IGNORE_OFF_PAGE.\t\t*/\n+\t\t\t/* Calls GC_allchblk to do the actual \t\t*/\n+\t\t\t/* allocation, but also triggers GC and/or\t*/\n+\t\t\t/* heap expansion as appropriate.\t\t*/\n+\t\t\t/* Does not update GC_words_allocd, but does\t*/\n+\t\t\t/* other accounting.\t\t\t\t*/\n+\n+ptr_t GC_alloc_large_and_clear GC_PROTO((word lw, int k, unsigned flags));\n+\t\t\t/* As above, but clear block if appropriate\t*/\n+\t\t\t/* for kind k.\t\t\t\t\t*/\n+\n+void GC_freehblk GC_PROTO((struct hblk * p));\n+\t\t\t\t/* Deallocate a heap block and mark it  */\n+  \t\t\t\t/* as invalid.\t\t\t\t*/\n+  \t\t\t\t\n /*  Misc GC: */\n-void GC_init_inner();\n-GC_bool GC_expand_hp_inner();\n-void GC_start_reclaim(/*abort_if_found*/);\n-\t\t\t\t/* Restore unmarked objects to free\t*/\n-\t\t\t\t/* lists, or (if abort_if_found is\t*/\n-\t\t\t\t/* TRUE) report them.\t\t\t*/\n-\t\t\t\t/* Sweeping of small object pages is\t*/\n-\t\t\t\t/* largely deferred.\t\t\t*/\n-void GC_continue_reclaim(/*size, kind*/);\n-\t\t\t\t/* Sweep pages of the given size and\t*/\n-\t\t\t\t/* kind, as long as possible, and\t*/\n-\t\t\t\t/* as long as the corr. free list is    */\n-\t\t\t\t/* empty.\t\t\t\t*/\n-void GC_reclaim_or_delete_all();\n-\t\t\t\t/* Arrange for all reclaim lists to be\t*/\n-\t\t\t\t/* empty.  Judiciously choose between\t*/\n-\t\t\t\t/* sweeping and discarding each page.\t*/\n-GC_bool GC_reclaim_all(/* GC_stop_func f*/);\n-\t\t\t\t/* Reclaim all blocks.  Abort (in a\t*/\n-\t\t\t\t/* consistent state) if f returns TRUE. */\n-GC_bool GC_block_empty(/* hhdr */); /* Block completely unmarked? \t*/\n-GC_bool GC_never_stop_func();\t/* Returns FALSE.\t\t*/\n-GC_bool GC_try_to_collect_inner(/* GC_stop_func f */);\n+void GC_init_inner GC_PROTO((void));\n+GC_bool GC_expand_hp_inner GC_PROTO((word n));\n+void GC_start_reclaim GC_PROTO((int abort_if_found));\n+  \t\t\t\t/* Restore unmarked objects to free\t*/\n+  \t\t\t\t/* lists, or (if abort_if_found is\t*/\n+  \t\t\t\t/* TRUE) report them.\t\t\t*/\n+  \t\t\t\t/* Sweeping of small object pages is\t*/\n+  \t\t\t\t/* largely deferred.\t\t\t*/\n+void GC_continue_reclaim GC_PROTO((word sz, int kind));\n+  \t\t\t\t/* Sweep pages of the given size and\t*/\n+  \t\t\t\t/* kind, as long as possible, and\t*/\n+  \t\t\t\t/* as long as the corr. free list is    */\n+  \t\t\t\t/* empty.\t\t\t\t*/\n+void GC_reclaim_or_delete_all GC_PROTO((void));\n+  \t\t\t\t/* Arrange for all reclaim lists to be\t*/\n+  \t\t\t\t/* empty.  Judiciously choose between\t*/\n+  \t\t\t\t/* sweeping and discarding each page.\t*/\n+GC_bool GC_reclaim_all GC_PROTO((GC_stop_func stop_func, GC_bool ignore_old));\n+  \t\t\t\t/* Reclaim all blocks.  Abort (in a\t*/\n+  \t\t\t\t/* consistent state) if f returns TRUE. */\n+GC_bool GC_block_empty GC_PROTO((hdr * hhdr));\n+ \t\t\t\t/* Block completely unmarked? \t*/\n+GC_bool GC_never_stop_func GC_PROTO((void));\n+\t\t\t\t/* Returns FALSE.\t\t*/\n+GC_bool GC_try_to_collect_inner GC_PROTO((GC_stop_func f));\n+\n \t\t\t\t/* Collect; caller must have acquired\t*/\n \t\t\t\t/* lock and disabled signals.\t\t*/\n \t\t\t\t/* Collection is aborted if f returns\t*/\n \t\t\t\t/* TRUE.  Returns TRUE if it completes\t*/\n \t\t\t\t/* successfully.\t\t\t*/\n # define GC_gcollect_inner() \\\n \t(void) GC_try_to_collect_inner(GC_never_stop_func)\n-void GC_finish_collection();\t/* Finish collection.  Mark bits are\t*/\n-\t\t\t\t/* consistent and lock is still held.\t*/\n-GC_bool GC_collect_or_expand(/* needed_blocks */);\n-\t\t\t\t/* Collect or expand heap in an attempt */\n-\t\t\t\t/* make the indicated number of free\t*/\n-\t\t\t\t/* blocks available.  Should be called\t*/\n-\t\t\t\t/* until the blocks are available or\t*/\n-\t\t\t\t/* until it fails by returning FALSE.\t*/\n-GC_API void GC_init();\t\t/* Initialize collector.\t\t*/\n-void GC_collect_a_little_inner(/* int n */);\n-\t\t\t\t/* Do n units worth of garbage \t\t*/\n-\t\t\t\t/* collection work, if appropriate.\t*/\n-\t\t\t\t/* A unit is an amount appropriate for  */\n-\t\t\t\t/* HBLKSIZE bytes of allocation.\t*/\n-ptr_t GC_generic_malloc(/* bytes, kind */);\n-\t\t\t\t/* Allocate an object of the given\t*/\n-\t\t\t\t/* kind.  By default, there are only\t*/\n-\t\t\t\t/* a few kinds: composite(pointerfree), */\n+void GC_finish_collection GC_PROTO((void));\n+ \t\t\t\t/* Finish collection.  Mark bits are\t*/\n+  \t\t\t\t/* consistent and lock is still held.\t*/\n+GC_bool GC_collect_or_expand GC_PROTO(( \\\n+\tword needed_blocks, GC_bool ignore_off_page));\n+  \t\t\t\t/* Collect or expand heap in an attempt */\n+  \t\t\t\t/* make the indicated number of free\t*/\n+  \t\t\t\t/* blocks available.  Should be called\t*/\n+  \t\t\t\t/* until the blocks are available or\t*/\n+  \t\t\t\t/* until it fails by returning FALSE.\t*/\n+GC_API void GC_init GC_PROTO((void)); /* Initialize collector.\t\t*/\n+\n+#if defined(MSWIN32) || defined(MSWINCE)\n+  void GC_deinit GC_PROTO((void));\n+                                /* Free any resources allocated by      */\n+                                /* GC_init                              */\n+#endif\n+\n+void GC_collect_a_little_inner GC_PROTO((int n));\n+  \t\t\t\t/* Do n units worth of garbage \t\t*/\n+  \t\t\t\t/* collection work, if appropriate.\t*/\n+  \t\t\t\t/* A unit is an amount appropriate for  */\n+  \t\t\t\t/* HBLKSIZE bytes of allocation.\t*/\n+ptr_t GC_generic_malloc GC_PROTO((word lb, int k));\n+  \t\t\t\t/* Allocate an object of the given\t*/\n+  \t\t\t\t/* kind.  By default, there are only\t*/\n+  \t\t\t\t/* a few kinds: composite(pointerfree), */\n \t\t\t\t/* atomic, uncollectable, etc.\t\t*/\n \t\t\t\t/* We claim it's possible for clever\t*/\n \t\t\t\t/* client code that understands GC\t*/\n \t\t\t\t/* internals to add more, e.g. to\t*/\n \t\t\t\t/* communicate object layout info\t*/\n \t\t\t\t/* to the collector.\t\t\t*/\n-ptr_t GC_generic_malloc_ignore_off_page(/* bytes, kind */);\n-\t\t\t\t/* As above, but pointers past the \t*/\n-\t\t\t\t/* first page of the resulting object\t*/\n-\t\t\t\t/* are ignored.\t\t\t\t*/\n-ptr_t GC_generic_malloc_inner(/* bytes, kind */);\n-\t\t\t\t/* Ditto, but I already hold lock, etc.\t*/\n-ptr_t GC_generic_malloc_words_small GC_PROTO((size_t words, int kind));\n-\t\t\t\t/* As above, but size in units of words */\n-\t\t\t\t/* Bypasses MERGE_SIZES.  Assumes\t*/\n-\t\t\t\t/* words <= MAXOBJSZ.\t\t\t*/\n-ptr_t GC_generic_malloc_inner_ignore_off_page(/* bytes, kind */);\n-\t\t\t\t/* Allocate an object, where\t\t*/\n-\t\t\t\t/* the client guarantees that there\t*/\n-\t\t\t\t/* will always be a pointer to the \t*/\n-\t\t\t\t/* beginning of the object while the\t*/\n-\t\t\t\t/* object is live.\t\t\t*/\n-ptr_t GC_allocobj(/* sz_inn_words, kind */);\n-\t\t\t\t/* Make the indicated \t\t\t*/\n-\t\t\t\t/* free list nonempty, and return its\t*/\n-\t\t\t\t/* head.\t\t\t\t*/\n-\n-void GC_init_headers();\n-struct hblkhdr * GC_install_header(/*h*/);\n-\t\t\t\t/* Install a header for block h.\t*/\n-\t\t\t\t/* Return 0 on failure, or the header\t*/\n-\t\t\t\t/* otherwise.\t\t\t\t*/\n-GC_bool GC_install_counts(/*h, sz*/);\n-\t\t\t\t/* Set up forwarding counts for block\t*/\n-\t\t\t\t/* h of size sz.\t\t\t*/\n-\t\t\t\t/* Return FALSE on failure.\t\t*/\n-void GC_remove_header(/*h*/);\n-\t\t\t\t/* Remove the header for block h.\t*/\n-void GC_remove_counts(/*h, sz*/);\n-\t\t\t\t/* Remove forwarding counts for h.\t*/\n-hdr * GC_find_header(/*p*/);\t/* Debugging only.\t\t\t*/\n-\n-void GC_finalize();\t/* Perform all indicated finalization actions\t*/\n-\t\t\t/* on unmarked objects.\t\t\t\t*/\n-\t\t\t/* Unreachable finalizable objects are enqueued\t*/\n-\t\t\t/* for processing by GC_invoke_finalizers.\t*/\n-\t\t\t/* Invoked with lock.\t\t\t\t*/\n-\t\t\t\n-void GC_add_to_heap(/*p, bytes*/);\n-\t\t\t/* Add a HBLKSIZE aligned chunk to the heap.\t*/\n-\n-void GC_print_obj(/* ptr_t p */);\n-\t\t\t/* P points to somewhere inside an object with\t*/\n-\t\t\t/* debugging info.  Print a human readable\t*/\n-\t\t\t/* description of the object to stderr.\t\t*/\n-extern void (*GC_check_heap)();\n-\t\t\t/* Check that all objects in the heap with \t*/\n-\t\t\t/* debugging info are intact.  Print \t\t*/\n-\t\t\t/* descriptions of any that are not.\t\t*/\n-extern void (*GC_print_heap_obj)(/* ptr_t p */);\n-\t\t\t/* If possible print s followed by a more\t*/\n-\t\t\t/* detailed description of the object \t\t*/\n-\t\t\t/* referred to by p.\t\t\t\t*/\n-\t\t\t\n+ptr_t GC_generic_malloc_ignore_off_page GC_PROTO((size_t b, int k));\n+  \t\t\t\t/* As above, but pointers past the \t*/\n+  \t\t\t\t/* first page of the resulting object\t*/\n+  \t\t\t\t/* are ignored.\t\t\t\t*/\n+ptr_t GC_generic_malloc_inner GC_PROTO((word lb, int k));\n+  \t\t\t\t/* Ditto, but I already hold lock, etc.\t*/\n+ptr_t GC_generic_malloc_words_small GC_PROTO((size_t lw, int k));\n+  \t\t\t\t/* As above, but size in units of words */\n+  \t\t\t\t/* Bypasses MERGE_SIZES.  Assumes\t*/\n+  \t\t\t\t/* words <= MAXOBJSZ.\t\t\t*/\n+ptr_t GC_generic_malloc_inner_ignore_off_page GC_PROTO((size_t lb, int k));\n+  \t\t\t\t/* Allocate an object, where\t\t*/\n+  \t\t\t\t/* the client guarantees that there\t*/\n+  \t\t\t\t/* will always be a pointer to the \t*/\n+  \t\t\t\t/* beginning of the object while the\t*/\n+  \t\t\t\t/* object is live.\t\t\t*/\n+ptr_t GC_allocobj GC_PROTO((word sz, int kind));\n+  \t\t\t\t/* Make the indicated \t\t\t*/\n+  \t\t\t\t/* free list nonempty, and return its\t*/\n+  \t\t\t\t/* head.\t\t\t\t*/\n+  \n+void GC_init_headers GC_PROTO((void));\n+struct hblkhdr * GC_install_header GC_PROTO((struct hblk *h));\n+  \t\t\t\t/* Install a header for block h.\t*/\n+  \t\t\t\t/* Return 0 on failure, or the header\t*/\n+  \t\t\t\t/* otherwise.\t\t\t\t*/\n+GC_bool GC_install_counts GC_PROTO((struct hblk * h, word sz));\n+  \t\t\t\t/* Set up forwarding counts for block\t*/\n+  \t\t\t\t/* h of size sz.\t\t\t*/\n+  \t\t\t\t/* Return FALSE on failure.\t\t*/\n+void GC_remove_header GC_PROTO((struct hblk * h));\n+  \t\t\t\t/* Remove the header for block h.\t*/\n+void GC_remove_counts GC_PROTO((struct hblk * h, word sz));\n+  \t\t\t\t/* Remove forwarding counts for h.\t*/\n+hdr * GC_find_header GC_PROTO((ptr_t h)); /* Debugging only.\t\t*/\n+  \n+void GC_finalize GC_PROTO((void));\n+ \t\t\t/* Perform all indicated finalization actions\t*/\n+  \t\t\t/* on unmarked objects.\t\t\t\t*/\n+  \t\t\t/* Unreachable finalizable objects are enqueued\t*/\n+  \t\t\t/* for processing by GC_invoke_finalizers.\t*/\n+  \t\t\t/* Invoked with lock.\t\t\t\t*/\n+\n+void GC_notify_or_invoke_finalizers GC_PROTO((void));\n+\t\t\t/* If GC_finalize_on_demand is not set, invoke\t*/\n+\t\t\t/* eligible finalizers. Otherwise:\t\t*/\n+\t\t\t/* Call *GC_finalizer_notifier if there are\t*/\n+\t\t\t/* finalizers to be run, and we haven't called\t*/\n+\t\t\t/* this procedure yet this GC cycle.\t\t*/\n+  \t\t\t\n+void GC_add_to_heap GC_PROTO((struct hblk *p, word bytes));\n+  \t\t\t/* Add a HBLKSIZE aligned chunk to the heap.\t*/\n+  \n+void GC_print_obj GC_PROTO((ptr_t p));\n+  \t\t\t/* P points to somewhere inside an object with\t*/\n+  \t\t\t/* debugging info.  Print a human readable\t*/\n+  \t\t\t/* description of the object to stderr.\t\t*/\n+extern void (*GC_check_heap) GC_PROTO((void));\n+  \t\t\t/* Check that all objects in the heap with \t*/\n+  \t\t\t/* debugging info are intact.  Print \t\t*/\n+  \t\t\t/* descriptions of any that are not.\t\t*/\n+extern void (*GC_print_heap_obj) GC_PROTO((ptr_t p));\n+  \t\t\t/* If possible print s followed by a more\t*/\n+  \t\t\t/* detailed description of the object \t\t*/\n+  \t\t\t/* referred to by p.\t\t\t\t*/\n+\n+extern GC_bool GC_print_stats;\t/* Produce at least some logging output\t*/\n+\t\t\t\t/* Set from environment variable.\t*/\n+\n+/* Macros used for collector internal allocation.\t*/\n+/* These assume the collector lock is held.\t\t*/\n+#ifdef DBG_HDRS_ALL\n+    extern GC_PTR GC_debug_generic_malloc_inner(size_t lb, int k);\n+    extern GC_PTR GC_debug_generic_malloc_inner_ignore_off_page(size_t lb,\n+\t\t\t\t\t\t\t\tint k);\n+#   define GC_INTERNAL_MALLOC GC_debug_generic_malloc_inner\n+#   define GC_INTERNAL_MALLOC_IGNORE_OFF_PAGE \\\n+\t\t GC_debug_generic_malloc_inner_ignore_off_page\n+#   ifdef THREADS\n+#       define GC_INTERNAL_FREE GC_debug_free_inner\n+#   else\n+#       define GC_INTERNAL_FREE GC_debug_free\n+#   endif\n+#else\n+#   define GC_INTERNAL_MALLOC GC_generic_malloc_inner\n+#   define GC_INTERNAL_MALLOC_IGNORE_OFF_PAGE \\\n+\t\t GC_generic_malloc_inner_ignore_off_page\n+#   ifdef THREADS\n+#       define GC_INTERNAL_FREE GC_free_inner\n+#   else\n+#       define GC_INTERNAL_FREE GC_free\n+#   endif\n+#endif\n+\n /* Memory unmapping: */\n #ifdef USE_MUNMAP\n   void GC_unmap_old(void);\n@@ -1782,35 +1751,38 @@ extern void (*GC_print_heap_obj)(/* ptr_t p */);\n \n /* Virtual dirty bit implementation:\t\t*/\n /* Each implementation exports the following:\t*/\n-void GC_read_dirty();\t/* Retrieve dirty bits.\t*/\n-GC_bool GC_page_was_dirty(/* struct hblk * h  */);\n-\t\t\t/* Read retrieved dirty bits.\t*/\n-GC_bool GC_page_was_ever_dirty(/* struct hblk * h  */);\n-\t\t\t/* Could the page contain valid heap pointers?\t*/\n-void GC_is_fresh(/* struct hblk * h, word number_of_blocks  */);\n-\t\t\t/* Assert the region currently contains no\t*/\n-\t\t\t/* valid pointers.\t\t\t\t*/\n-void GC_write_hint(/* struct hblk * h  */);\n-\t\t\t/* h is about to be written.\t*/\n-void GC_dirty_init();\n-\n+void GC_read_dirty GC_PROTO((void));\n+\t\t\t/* Retrieve dirty bits.\t*/\n+GC_bool GC_page_was_dirty GC_PROTO((struct hblk *h));\n+  \t\t\t/* Read retrieved dirty bits.\t*/\n+GC_bool GC_page_was_ever_dirty GC_PROTO((struct hblk *h));\n+  \t\t\t/* Could the page contain valid heap pointers?\t*/\n+void GC_is_fresh GC_PROTO((struct hblk *h, word n));\n+  \t\t\t/* Assert the region currently contains no\t*/\n+  \t\t\t/* valid pointers.\t\t\t\t*/\n+void GC_write_hint GC_PROTO((struct hblk *h));\n+  \t\t\t/* h is about to be written.\t*/\n+void GC_dirty_init GC_PROTO((void));\n+  \n /* Slow/general mark bit manipulation: */\n-GC_API GC_bool GC_is_marked();\n-void GC_clear_mark_bit();\n-void GC_set_mark_bit();\n-\n+GC_API GC_bool GC_is_marked GC_PROTO((ptr_t p));\n+void GC_clear_mark_bit GC_PROTO((ptr_t p));\n+void GC_set_mark_bit GC_PROTO((ptr_t p));\n+  \n /* Stubborn objects: */\n-void GC_read_changed();\t/* Analogous to GC_read_dirty */\n-GC_bool GC_page_was_changed(/* h */);\t/* Analogous to GC_page_was_dirty */\n-void GC_clean_changing_list();\t/* Collect obsolete changing list entries */\n-void GC_stubborn_init();\n-\n+void GC_read_changed GC_PROTO((void));\t/* Analogous to GC_read_dirty */\n+GC_bool GC_page_was_changed GC_PROTO((struct hblk * h));\n+ \t\t\t\t/* Analogous to GC_page_was_dirty */\n+void GC_clean_changing_list GC_PROTO((void));\n+ \t\t\t\t/* Collect obsolete changing list entries */\n+void GC_stubborn_init GC_PROTO((void));\n+  \n /* Debugging print routines: */\n-void GC_print_block_list();\n-void GC_print_hblkfreelist();\n-void GC_print_heap_sects();\n-void GC_print_static_roots();\n-void GC_dump();\n+void GC_print_block_list GC_PROTO((void));\n+void GC_print_hblkfreelist GC_PROTO((void));\n+void GC_print_heap_sects GC_PROTO((void));\n+void GC_print_static_roots GC_PROTO((void));\n+void GC_dump GC_PROTO((void));\n \n #ifdef KEEP_BACK_PTRS\n    void GC_store_back_pointer(ptr_t source, ptr_t dest);\n@@ -1829,10 +1801,10 @@ void GC_dump();\n   GC_API void GC_noop();\n # endif\n \n-void GC_noop1(/* word arg */);\n+void GC_noop1 GC_PROTO((word arg));\n \n /* Logging and diagnostic output: \t*/\n-GC_API void GC_printf GC_PROTO((char * format, long, long, long, long, long, long));\n+GC_API void GC_printf GC_PROTO((GC_CONST char * format, long, long, long, long, long, long));\n \t\t\t/* A version of printf that doesn't allocate,\t*/\n \t\t\t/* is restricted to long arguments, and\t\t*/\n \t\t\t/* (unfortunately) doesn't use varargs for\t*/\n@@ -1851,7 +1823,7 @@ GC_API void GC_printf GC_PROTO((char * format, long, long, long, long, long, lon\n # define GC_printf6(f,a,b,c,d,e,g) GC_printf(f, (long)a, (long)b, (long)c, \\\n \t\t\t\t\t\t(long)d, (long)e, (long)g)\n \n-void GC_err_printf(/* format, a, b, c, d, e, f */);\n+GC_API void GC_err_printf GC_PROTO((GC_CONST char * format, long, long, long, long, long, long));\n # define GC_err_printf0(f) GC_err_puts(f)\n # define GC_err_printf1(f,a) GC_err_printf(f, (long)a, 0l, 0l, 0l, 0l, 0l)\n # define GC_err_printf2(f,a,b) GC_err_printf(f, (long)a, (long)b, 0l, 0l, 0l, 0l)\n@@ -1867,18 +1839,59 @@ void GC_err_printf(/* format, a, b, c, d, e, f */);\n \t\t\t\t\t\t\t(long)e, (long)g)\n \t\t\t/* Ditto, writes to stderr.\t\t\t*/\n \t\t\t\n-void GC_err_puts(/* char *s */);\n+void GC_err_puts GC_PROTO((GC_CONST char *s));\n \t\t\t/* Write s to stderr, don't buffer, don't add\t*/\n \t\t\t/* newlines, don't ...\t\t\t\t*/\n \n+#if defined(LINUX) && !defined(SMALL_CONFIG)\n+  void GC_err_write GC_PROTO((GC_CONST char *buf, size_t len));\n+ \t\t\t/* Write buf to stderr, don't buffer, don't add\t*/\n+  \t\t\t/* newlines, don't ...\t\t\t\t*/\n+#endif\n+\n \n-#   ifdef GC_ASSERTIONS\n+# ifdef GC_ASSERTIONS\n #\tdefine GC_ASSERT(expr) if(!(expr)) {\\\n \t\tGC_err_printf2(\"Assertion failure: %s:%ld\\n\", \\\n \t\t\t\t__FILE__, (unsigned long)__LINE__); \\\n \t\tABORT(\"assertion failure\"); }\n-#   else \n+# else \n #\tdefine GC_ASSERT(expr)\n-#   endif\n+# endif\n+\n+# ifdef PARALLEL_MARK\n+    /* We need additional synchronization facilities from the thread\t*/\n+    /* support.  We believe these are less performance critical\t\t*/\n+    /* than the main garbage collector lock; standard pthreads-based\t*/\n+    /* implementations should be sufficient.\t\t\t\t*/\n+\n+    /* The mark lock and condition variable.  If the GC lock is also \t*/\n+    /* acquired, the GC lock must be acquired first.  The mark lock is\t*/\n+    /* used to both protect some variables used by the parallel\t\t*/\n+    /* marker, and to protect GC_fl_builder_count, below.\t\t*/\n+    /* GC_notify_all_marker() is called when\t\t\t\t*/ \n+    /* the state of the parallel marker changes\t\t\t\t*/\n+    /* in some significant way (see gc_mark.h for details).  The\t*/\n+    /* latter set of events includes incrementing GC_mark_no.\t\t*/\n+    /* GC_notify_all_builder() is called when GC_fl_builder_count\t*/\n+    /* reaches 0.\t\t\t\t\t\t\t*/\n+\n+     extern void GC_acquire_mark_lock();\n+     extern void GC_release_mark_lock();\n+     extern void GC_notify_all_marker();\n+     extern void GC_notify_all_builder();\n+     extern void GC_wait_marker();\n+     /* extern void GC_wait_builder(); */\n+     extern void GC_wait_for_reclaim();\n+\n+     extern word GC_fl_builder_count;\t/* Protected by mark lock.\t*/\n+     extern word GC_mark_no;\t\t/* Protected by mark lock.\t*/\n+\n+     extern void GC_help_marker(word my_mark_no);\n+\t\t/* Try to help out parallel marker for mark cycle \t*/\n+\t\t/* my_mark_no.  Returns if the mark cycle finishes or\t*/\n+\t\t/* was already done, or there was nothing to do for\t*/\n+\t\t/* some other reason.\t\t\t\t\t*/\n+# endif /* PARALLEL_MARK */\n \n # endif /* GC_PRIVATE_H */"}, {"sha": "cf1b8ebf0307a0e8c8116ff7a1a7e9b032ceb7d4", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 388, "deletions": 92, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdbd4a8ec9540dca96531b9a99db1e011d6a4cc/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=abdbd4a8ec9540dca96531b9a99db1e011d6a4cc", "patch": "@@ -2,6 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -27,6 +28,11 @@\n #    define LINUX\n # endif\n \n+/* And one for NetBSD: */\n+# if defined(__NetBSD__)\n+#    define NETBSD\n+# endif\n+\n /* Determine the machine type: */\n # if defined(sun) && defined(mc68000)\n #    define M68K\n@@ -50,12 +56,14 @@\n # endif\n # if defined(__NetBSD__) && defined(m68k)\n #    define M68K\n-#    define NETBSD\n #    define mach_type_known\n # endif\n-# if defined(__NetBSD__) && defined(arm32)\n+# if defined(__NetBSD__) && defined(__powerpc__)\n+#    define POWERPC\n+#    define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(__arm32__)\n #    define ARM32\n-#    define NETBSD\n #    define mach_type_known\n # endif\n # if defined(vax)\n@@ -81,14 +89,17 @@\n #\t endif\n #      endif\n #    endif /* !LINUX */\n+#    if defined(__NetBSD__) && defined(__MIPSEL__)\n+#      undef ULTRIX\n+#    endif\n #    define mach_type_known\n # endif\n-# if defined(sequent) && defined(i386)\n+# if defined(sequent) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define SEQUENT\n #    define mach_type_known\n # endif\n-# if defined(sun) && defined(i386)\n+# if defined(sun) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define SUNOS5\n #    define mach_type_known\n@@ -114,7 +125,7 @@\n #   define mach_type_known\n # endif\n # if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \\\n-     && !defined(__OpenBSD__)\n+     && !defined(__OpenBSD__) && !(__NetBSD__)\n #   define SPARC\n #   define DRSNX\n #   define mach_type_known\n@@ -123,6 +134,10 @@\n #   define RS6000\n #   define mach_type_known\n # endif\n+# if defined(__NetBSD__) && defined(__sparc__)\n+#   define SPARC\n+#   define mach_type_known\n+# endif\n # if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)\n \t/* The above test may need refinement\t*/\n #   define I386\n@@ -146,6 +161,11 @@\n #   endif\n #   define mach_type_known\n # endif\n+# if defined(__BEOS__) && defined(_X86_)\n+#    define I386\n+#    define BEOS\n+#    define mach_type_known\n+# endif\n # if defined(LINUX) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define mach_type_known\n@@ -166,13 +186,17 @@\n #    define SPARC\n #    define mach_type_known\n # endif\n-# if defined(LINUX) && defined(arm)\n+# if defined(LINUX) && defined(__arm__)\n #    define ARM32\n #    define mach_type_known\n # endif\n+# if defined(LINUX) && defined(__sh__)\n+#    define SH\n+#    define mach_type_known\n+# endif\n # if defined(__alpha) || defined(__alpha__)\n #   define ALPHA\n-#   if !defined(LINUX)\n+#   if !defined(LINUX) && !defined(NETBSD)\n #     define OSF1\t/* a.k.a Digital Unix */\n #   endif\n #   define mach_type_known\n@@ -194,37 +218,42 @@\n #   define MACOS\n #   define mach_type_known\n # endif\n-# if defined(macosx)\n+# if defined(macosx) || \\\n+     defined(__APPLE__) && defined(__MACH__) && defined(__ppc__)\n #    define MACOSX\n #    define POWERPC\n #    define mach_type_known\n # endif\n+# if defined(__APPLE__) && defined(__MACH__) && defined(__i386__)\n+#    define MACOSX\n+#    define I386\n+     --> Not really supported, but at least we recognize it.\n+# endif\n # if defined(NeXT) && defined(mc68000)\n #   define M68K\n #   define NEXT\n #   define mach_type_known\n # endif\n-# if defined(NeXT) && defined(i386)\n+# if defined(NeXT) && (defined(i386) || defined(__i386__))\n #   define I386\n #   define NEXT\n #   define mach_type_known\n # endif\n-# if defined(__OpenBSD__) && defined(i386)\n+# if defined(__OpenBSD__) && (defined(i386) || defined(__i386__))\n #   define I386\n #   define OPENBSD\n #   define mach_type_known\n # endif\n-# if defined(__FreeBSD__) && defined(i386)\n+# if defined(__FreeBSD__) && (defined(i386) || defined(__i386__))\n #   define I386\n #   define FREEBSD\n #   define mach_type_known\n # endif\n-# if defined(__NetBSD__) && defined(i386)\n+# if defined(__NetBSD__) && (defined(i386) || defined(__i386__))\n #   define I386\n-#   define NETBSD\n #   define mach_type_known\n # endif\n-# if defined(bsdi) && defined(i386)\n+# if defined(bsdi) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define BSDI\n #    define mach_type_known\n@@ -244,11 +273,26 @@\n     /* DGUX defined */\n #   define mach_type_known\n # endif\n-# if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n-     || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)\n-#   define I386\n-#   define MSWIN32\t/* or Win32s */\n+# if defined(_WIN32_WCE)\n+    /* SH3, SH4, MIPS already defined for corresponding architectures */\n+#   if defined(SH3) || defined(SH4)\n+#     define SH\n+#   endif\n+#   if defined(x86)\n+#     define I386\n+#   endif\n+#   if defined(ARM)\n+#     define ARM32\n+#   endif\n+#   define MSWINCE\n #   define mach_type_known\n+# else\n+#   if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+        || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)\n+#     define I386\n+#     define MSWIN32\t/* or Win32s */\n+#     define mach_type_known\n+#   endif\n # endif\n # if defined(__DJGPP__)\n #   define I386\n@@ -281,6 +325,11 @@\n #   define PJ\n #   define mach_type_known\n # endif\n+# if defined(__embedded__) && defined(PPC)\n+#   define POWERPC\n+#   define NOSYS\n+#   define mach_type_known\n+# endif\n /* Ivan Demakov */\n # if defined(__WATCOMC__) && defined(__386__)\n #   define I386\n@@ -297,6 +346,10 @@\n #   endif\n #   define mach_type_known\n # endif\n+# if defined(__s390__) && defined(LINUX)\n+#    define S370\n+#    define mach_type_known\n+# endif\n \n /* Feel free to add more clauses here */\n \n@@ -325,19 +378,22 @@\n                     /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n                     /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n                     /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n-                    /*\t\t\t\t  HP/UX\t\t\t*/\n-\t\t    /*\t\t   SPARC      ==> SPARC under SunOS\t*/\n-\t\t    /*\t\t\t(SUNOS4, SUNOS5,\t\t*/\n+                    /*\t\t\t\t  HP/UX, LINUX\t\t\t*/\n+\t\t    /*\t\t   SPARC      ==> SPARC\tv7/v8/v9\t*/\n+\t\t    /*\t\t\t(SUNOS4, SUNOS5, LINUX,\t\t*/\n \t\t    /*\t\t\t DRSNX variants)\t\t*/\n \t\t    /* \t\t   ALPHA      ==> DEC Alpha \t\t*/\n \t\t    /*\t\t\t(OSF1 and LINUX variants)\t*/\n \t\t    /* \t\t   M88K       ==> Motorola 88XX0        */\n \t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n \t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n \t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n+\t\t    /*\t\t\tor a 390 running LINUX\t\t*/\n \t\t    /* \t\t   ARM32      ==> Intel StrongARM\t*/\n \t\t    /* \t\t   IA64\t      ==> Intel IA64\t\t*/\n \t\t    /*\t\t\t\t  (e.g. Itanium)\t*/\n+\t\t    /*\t\t   SH\t      ==> Hitachi SuperH\t*/\n+\t\t    /* \t\t\t(LINUX & MSWINCE)\t\t*/\n \n \n /*\n@@ -389,7 +445,9 @@\n  * Gustavo Rodriguez-Rivera points out that on most (all?) Unix machines,\n  * the value of environ is a pointer that can serve as STACKBOTTOM.\n  * I expect that HEURISTIC2 can be replaced by this approach, which\n- * interferes far less with debugging. \n+ * interferes far less with debugging.  However it has the disadvantage\n+ * that it's confused by a putenv call before the collector is initialized.\n+ * This could be dealt with by intercepting putenv ...\n  *\n  * If no expression for STACKBOTTOM can be found, and neither of the above\n  * heuristics are usable, the collector can still be used with all of the above\n@@ -462,8 +520,12 @@\n #       define MPROTECT_VDB\n #       ifdef __ELF__\n #            define DYNAMIC_LOADING\n-             extern char **__environ;\n-#            define DATASTART ((ptr_t)(&__environ))\n+#\t     include <features.h>\n+#\t     if defined(__GLIBC__)&& __GLIBC__>=2\n+#              define LINUX_DATA_START\n+#\t     else /* !GLIBC2 */\n+               extern char **__environ;\n+#              define DATASTART ((ptr_t)(&__environ))\n                              /* hideous kludge: __environ is the first */\n                              /* word in crt0.o, and delimits the start */\n                              /* of the data segment, no matter which   */\n@@ -472,6 +534,7 @@\n                              /* would include .rodata, which may       */\n                              /* contain large read-only data tables    */\n                              /* that we'd rather not scan.             */\n+#\t     endif /* !GLIBC2 */\n              extern int _end;\n #            define DATAEND (&_end)\n #       else\n@@ -567,11 +630,34 @@\n #     define DATAEND (&_end)\n #   endif\n #   ifdef MACOSX\n+      /* There are reasons to suspect this may not be reliable. \t*/\n #     define ALIGNMENT 4\n #     define OS_TYPE \"MACOSX\"\n #     define DATASTART ((ptr_t) get_etext())\n #     define STACKBOTTOM ((ptr_t) 0xc0000000)\n #     define DATAEND\t/* not needed */\n+#     define MPROTECT_VDB\n+#     include <unistd.h>\n+#     define GETPAGESIZE() getpagesize()\n+#   endif\n+#   ifdef NETBSD\n+#     define ALIGNMENT 4\n+#     define OS_TYPE \"NETBSD\"\n+#     define HEURISTIC2\n+      extern char etext;\n+#     define DATASTART GC_data_start\n+#     define DYNAMIC_LOADING\n+#   endif\n+#   ifdef NOSYS\n+#     define ALIGNMENT 4\n+#     define OS_TYPE \"NOSYS\"\n+      extern void __end, __dso_handle;\n+#     define DATASTART (&__dso_handle)  /* OK, that's ugly.  */\n+#     define DATAEND (&__end)\n+\t/* Stack starts at 0xE0000000 for the simulator.  */\n+#     undef STACK_GRAN\n+#     define STACK_GRAN 0x10000000\n+#     define HEURISTIC1\n #   endif\n # endif\n \n@@ -600,9 +686,12 @@\n \n # ifdef SPARC\n #   define MACH_TYPE \"SPARC\"\n-#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+#   if defined(__arch64__) || defined(__sparcv9)\n+#     define ALIGNMENT 8\n+#   else\n+#     define ALIGNMENT 4\t/* Required by hardware\t*/\n+#   endif\n #   define ALIGN_DOUBLE\n-    extern int etext;\n #   ifdef SUNOS5\n #\tdefine OS_TYPE \"SUNOS5\"\n \textern int _etext;\n@@ -619,10 +708,18 @@\n #\t  define HEAP_START DATAEND\n #       endif\n #\tdefine PROC_VDB\n-/*\tHEURISTIC1 reportedly no longer works under 2.7.  Thus we\t*/\n-/* \tswitched to HEURISTIC2, eventhough it creates some debugging\t*/\n-/*\tissues.\t\t\t\t\t\t\t\t*/\n-#\tdefine HEURISTIC2\n+/*\tHEURISTIC1 reportedly no longer works under 2.7.  \t\t*/\n+/*  \tHEURISTIC2 probably works, but this appears to be preferable.\t*/\n+/*\tApparently USRSTACK is defined to be USERLIMIT, but in some\t*/\n+/* \tinstallations that's undefined.  We work around this with a\t*/\n+/*\tgross hack:\t\t\t\t\t\t\t*/\n+#       include <sys/vmparam.h>\n+#\tifdef USERLIMIT\n+\t  /* This should work everywhere, but doesn't.\t*/\n+#\t  define STACKBOTTOM USRSTACK\n+#       else\n+#\t  define HEURISTIC2\n+#       endif\n #\tinclude <unistd.h>\n #       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n \t\t/* getpagesize() appeared to be missing from at least one */\n@@ -661,21 +758,40 @@\n #   ifdef LINUX\n #     define OS_TYPE \"LINUX\"\n #     ifdef __ELF__\n-#       define LINUX_DATA_START\n #       define DYNAMIC_LOADING\n #     else\n-          Linux Sparc non elf ?\n+          Linux Sparc/a.out not supported\n #     endif\n       extern int _end;\n+      extern int _etext;\n #     define DATAEND (&_end)\n #     define SVR4\n-#     define STACKBOTTOM ((ptr_t) 0xf0000000)\n+#     ifdef __arch64__\n+#       define STACKBOTTOM ((ptr_t) 0x80000000000ULL)\n+#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x100000, &_etext)\n+#\tdefine CPP_WORDSZ 64\n+#     else\n+#       define STACKBOTTOM ((ptr_t) 0xf0000000)\n+#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#     endif\n #   endif\n #   ifdef OPENBSD\n #     define OS_TYPE \"OPENBSD\"\n #     define STACKBOTTOM ((ptr_t) 0xf8000000)\n+      extern int etext;\n #     define DATASTART ((ptr_t)(&etext))\n #   endif\n+#   ifdef NETBSD\n+#     define OS_TYPE \"NETBSD\"\n+#     define HEURISTIC2\n+#     ifdef __ELF__\n+#\tdefine DATASTART GC_data_start\n+#\tdefine DYNAMIC_LOADING\n+#     else\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#     endif\n+#   endif\n # endif\n \n # ifdef I386\n@@ -694,12 +810,25 @@\n #       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n #       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n #   endif\n+#   ifdef BEOS\n+#     define OS_TYPE \"BEOS\"\n+#     include <OS.h>\n+#     define GETPAGESIZE() B_PAGE_SIZE\n+      extern int etext;\n+#     define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#   endif\n #   ifdef SUNOS5\n #\tdefine OS_TYPE \"SUNOS5\"\n   \textern int etext, _start;\n   \textern char * GC_SysVGetDataStart();\n #       define DATASTART GC_SysVGetDataStart(0x1000, &etext)\n-#\tdefine STACKBOTTOM ((ptr_t)(&_start))\n+/*\t# define STACKBOTTOM ((ptr_t)(&_start)) worked through 2.7,  \t*/\n+/*      but reportedly breaks under 2.8.  It appears that the stack\t*/\n+/* \tbase is a property of the executable, so this should not break\t*/\n+/* \told executables.\t\t\t\t\t\t*/\n+/*  \tHEURISTIC2 probably works, but this appears to be preferable.\t*/\n+#       include <sys/vmparam.h>\n+#\tdefine STACKBOTTOM USRSTACK\n /** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n /*#\tdefine PROC_VDB*/\n #\tdefine DYNAMIC_LOADING\n@@ -791,7 +920,7 @@\n #\tifdef USE_3DNOW_PREFETCH\n #\t  define PREFETCH(x) \\\n \t    __asm__ __volatile__ (\"\tprefetch\t%0\": : \"m\"(*(char *)(x)))\n-#\t  define PREFETCH_FOR_WRITE(x) \n+#\t  define PREFETCH_FOR_WRITE(x) \\\n \t    __asm__ __volatile__ (\"\tprefetchw\t%0\": : \"m\"(*(char *)(x)))\n #\tendif\n #   endif\n@@ -823,6 +952,7 @@\n \t\t/* os_dep.c. OS2 actually has the right\t\t\t*/\n \t\t/* system call!\t\t\t\t\t\t*/\n #\tdefine DATAEND\t/* not needed */\n+#\tdefine USE_GENERIC_PUSH_REGS\n #   endif\n #   ifdef MSWIN32\n #\tdefine OS_TYPE \"MSWIN32\"\n@@ -833,6 +963,10 @@\n #\tendif\n #       define DATAEND  /* not needed */\n #   endif\n+#   ifdef MSWINCE\n+#\tdefine OS_TYPE \"MSWINCE\"\n+#       define DATAEND  /* not needed */\n+#   endif\n #   ifdef DJGPP\n #       define OS_TYPE \"DJGPP\"\n #       include \"stubinfo.h\"\n@@ -851,6 +985,7 @@\n #   ifdef FREEBSD\n #\tdefine OS_TYPE \"FREEBSD\"\n #\tdefine MPROTECT_VDB\n+#\tdefine FREEBSD_STACKBOTTOM\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n@@ -861,7 +996,7 @@\n #   ifdef BSDI\n #\tdefine OS_TYPE \"BSDI\"\n #   endif\n-#   if defined(OPENBSD) || defined(FREEBSD) || defined(NETBSD) \\\n+#   if defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \\\n         || defined(THREE86BSD) || defined(BSDI)\n #\tdefine HEURISTIC2\n \textern char etext;\n@@ -960,6 +1095,28 @@\n #\tendif\n #\tdefine DYNAMIC_LOADING\n #   endif\n+#   ifdef MSWINCE\n+#       define OS_TYPE \"MSWINCE\"\n+#       define ALIGNMENT 4\n+#       define DATAEND /* not needed */\n+#   endif\n+#   if defined(NETBSD)\n+      /* This also checked for __MIPSEL__ .  Why?  NETBSD recognition\t*/\n+      /* should be handled at the top of the file.\t\t\t*/\n+#     define ALIGNMENT 4\n+#     define OS_TYPE \"NETBSD\"\n+#     define HEURISTIC2\n+#     define USE_GENERIC_PUSH_REGS 1\n+#     ifdef __ELF__\n+        extern int etext;\n+#       define DATASTART GC_data_start\n+#       define NEED_FIND_LIMIT\n+#       define DYNAMIC_LOADING\n+#     else\n+#       define DATASTART ((ptr_t) 0x10000000)\n+#       define STACKBOTTOM ((ptr_t) 0x7ffff000)\n+#     endif /* _ELF_ */\n+#  endif\n # endif\n \n # ifdef RS6000\n@@ -973,7 +1130,6 @@\n # endif\n \n # ifdef HP_PA\n-    /* OS is assumed to be HP/UX\t*/\n #   define MACH_TYPE \"HP_PA\"\n #   define OS_TYPE \"HPUX\"\n #   ifdef __LP64__\n@@ -984,9 +1140,25 @@\n #     define ALIGNMENT 4\n #     define ALIGN_DOUBLE\n #   endif\n-    extern int __data_start;\n-#   define DATASTART ((ptr_t)(&__data_start))\n-#   if 0\n+#   if !defined(GC_HPUX_THREADS) && !defined(HPUX_THREADS) \\\n+       && !defined(GC_LINUX_THREADS) && !defined(LINUX_THREADS)\n+#     ifndef LINUX /* For now. */\n+#       define MPROTECT_VDB\n+#     endif\n+#   else\n+#     define GENERIC_COMPARE_AND_SWAP\n+\t/* No compare-and-swap instruction.  Use pthread mutexes \t*/\n+\t/* when we absolutely have to.\t\t\t\t\t*/\n+#     ifdef PARALLEL_MARK\n+#\tdefine USE_MARK_BYTES\n+\t\t/* Minimize compare-and-swap usage.\t\t*/\n+#     endif\n+#   endif\n+#   define STACK_GROWS_UP\n+#   ifdef HPUX\n+      extern int __data_start;\n+#     define DATASTART ((ptr_t)(&__data_start))\n+#     if 0\n \t/* The following appears to work for 7xx systems running HP/UX\t*/\n \t/* 9.xx Furthermore, it might result in much faster\t\t*/\n \t/* collections than HEURISTIC2, which may involve scanning\t*/\n@@ -995,39 +1167,66 @@\n \t/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering\t*/\n \t/* this.)\t\t\t\t\t\t\t*/\n #       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */\n-#   else\n+#     else\n \t/* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2\t*/\n-\t/* to this.  We'll probably do this on other platforms, too.\t*/\n-\t/* For now I'll use it where I can test it.\t\t\t*/\n+\t/* to this.  Note that the GC must be initialized before the\t*/\n+    \t/* first putenv call.\t\t\t\t\t\t*/\n \textern char ** environ;\n #       define STACKBOTTOM ((ptr_t)environ)\n-#   endif\n-#   define STACK_GROWS_UP\n-#   define DYNAMIC_LOADING\n-#   ifndef HPUX_THREADS\n-#     define MPROTECT_VDB\n-#   endif\n-#   include <unistd.h>\n-#   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n-# endif\n+#     endif\n+#     define DYNAMIC_LOADING\n+#     include <unistd.h>\n+#     define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+#     ifndef __GNUC__\n+#       define PREFETCH(x)  { \\\n+                              register long addr = (long)(x); \\\n+                              (void) _asm (\"LDW\", 0, 0, addr, 0); \\\n+                            }\n+#     endif\n+#   endif /* HPUX */\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     define LINUX_STACKBOTTOM\n+#     define DYNAMIC_LOADING\n+#     define LINUX_DATA_START\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#   endif /* LINUX */\n+# endif /* HP_PA */\n \n # ifdef ALPHA\n #   define MACH_TYPE \"ALPHA\"\n #   define ALIGNMENT 8\n #   define USE_GENERIC_PUSH_REGS\n-\t/* Gcc and probably the DEC/Compaq compiler spill pointers to preserved\t*/\n-\t/* fp registers in some cases when the target is a 21264.  The assembly\t*/\n-\t/* code doesn't handle that yet, and version dependencies make that a\t*/\n-\t/* bit tricky.  Do the easy thing for now.\t\t\t\t*/\n+    /* Gcc and probably the DEC/Compaq compiler spill pointers to preserved */\n+    /* fp registers in some cases when the target is a 21264.  The assembly */\n+    /* code doesn't handle that yet, and version dependencies make that a   */\n+    /* bit tricky.  Do the easy thing for now.\t\t\t\t    */\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#\tdefine HEURISTIC2\n+#\tdefine DATASTART GC_data_start\n+#\tdefine ELFCLASS32 32\n+#\tdefine ELFCLASS64 64\n+#\tdefine ELF_CLASS ELFCLASS64\n+#   \tdefine CPP_WORDSZ 64\n+#       define DYNAMIC_LOADING\n+#   endif\n #   ifdef OSF1\n #\tdefine OS_TYPE \"OSF1\"\n #   \tdefine DATASTART ((ptr_t) 0x140000000)\n-\textern _end;\n+\textern int _end;\n #   \tdefine DATAEND ((ptr_t) &_end)\n-#   \tdefine HEURISTIC2\n+ \textern char ** environ;\n+\t/* round up from the value of environ to the nearest page boundary */\n+\t/* Probably breaks if putenv is called before collector \t   */\n+\t/* initialization.\t\t\t\t\t\t   */\n+#\tdefine STACKBOTTOM ((ptr_t)(((word)(environ) | (getpagesize()-1))+1))\n+/* #   \tdefine HEURISTIC2 */\n \t/* Normally HEURISTIC2 is too conervative, since\t\t*/\n \t/* the text segment immediately follows the stack.\t\t*/\n \t/* Hence we give an upper pound.\t\t\t\t*/\n+\t/* This is currently unused, since we disabled HEURISTIC2\t*/\n     \textern int __start;\n #   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n #   \tdefine CPP_WORDSZ 64\n@@ -1039,9 +1238,9 @@\n #       define CPP_WORDSZ 64\n #       define STACKBOTTOM ((ptr_t) 0x120000000)\n #       ifdef __ELF__\n-#\t  define LINUX_DATA_START\n+#\t  define SEARCH_FOR_DATA_START\n+#\t  define DATASTART GC_data_start\n #         define DYNAMIC_LOADING\n-\t  /* This doesn't work if the collector is in a dynamic library. */\n #       else\n #           define DATASTART ((ptr_t) 0x140000000)\n #       endif\n@@ -1059,39 +1258,46 @@\n \t/* Requires 16 byte alignment for malloc */\n #   define ALIGNMENT 8\n #   define USE_GENERIC_PUSH_REGS\n-\t/* We need to get preserved registers in addition to register windows.\t*/\n-\t/* That's easiest to do with setjmp.\t\t\t\t\t*/\n+\t/* We need to get preserved registers in addition to register   */\n+\t/* windows.   That's easiest to do with setjmp.\t\t\t*/\n+#   ifdef PARALLEL_MARK\n+#\tdefine USE_MARK_BYTES\n+\t    /* Compare-and-exchange is too expensive to use for \t*/\n+\t    /* setting mark bits.\t\t\t\t\t*/\n+#   endif\n #   ifdef HPUX\n \t--> needs work\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n #       define CPP_WORDSZ 64\n-\t/* This should really be done through /proc, but that\t*/\n-\t/* requires we run on an IA64 kernel.\t\t\t*/\n-#       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\n+\t/* The following works on NUE and older kernels:\t*/\n+/* #       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\t*/\n+\t/* This does not work on NUE:\t\t\t\t*/\n+#       define LINUX_STACKBOTTOM\n \t/* We also need the base address of the register stack\t*/\n-\t/* backing store.  There is probably a better way to\t*/\n-\t/* get that, too ...\t\t\t\t\t*/\n-#\tdefine BACKING_STORE_BASE ((ptr_t) 0x9fffffff80000000l)\n-#\tif 1\n-#\t    define SEARCH_FOR_DATA_START\n-#\t    define DATASTART GC_data_start\n-#\telse\n-\t    extern int data_start;\n-#\t    define DATASTART ((ptr_t)(&data_start))\n-#\tendif\n+\t/* backing store.  This is computed in \t\t\t*/\n+\t/* GC_linux_register_stack_base based on the following\t*/\n+\t/* constants:\t\t\t\t\t\t*/\n+#       define BACKING_STORE_ALIGNMENT 0x100000\n+#       define BACKING_STORE_DISPLACEMENT 0x80000000\n+\textern char * GC_register_stackbottom;\n+#\tdefine BACKING_STORE_BASE ((ptr_t)GC_register_stackbottom)\n+#\tdefine SEARCH_FOR_DATA_START\n+#\tdefine DATASTART GC_data_start\n #       define DYNAMIC_LOADING\n #\tdefine MPROTECT_VDB\n \t\t/* Requires Linux 2.3.47 or later.\t*/\n \textern int _end;\n #\tdefine DATAEND (&_end)\n-#\tdefine PREFETCH(x) \\\n-\t  __asm__ (\"\tlfetch\t[%0]\": : \"r\"((void *)(x)))\n-#\tdefine PREFETCH_FOR_WRITE(x) \\\n-\t  __asm__ (\"\tlfetch.excl\t[%0]\": : \"r\"((void *)(x)))\n-#\tdefine CLEAR_DOUBLE(x) \\\n-\t  __asm__ (\"\tstf.spill\t[%0]=f0\": : \"r\"((void *)(x)))\n+#       ifdef __GNUC__\n+#\t  define PREFETCH(x) \\\n+\t    __asm__ (\"\tlfetch\t[%0]\": : \"r\"((void *)(x)))\n+#\t  define PREFETCH_FOR_WRITE(x) \\\n+\t    __asm__ (\"\tlfetch.excl\t[%0]\": : \"r\"((void *)(x)))\n+#\t  define CLEAR_DOUBLE(x) \\\n+\t    __asm__ (\"\tstf.spill\t[%0]=f0\": : \"r\"((void *)(x)))\n+#       endif\n #   endif\n # endif\n \n@@ -1114,15 +1320,25 @@\n \n # ifdef S370\n #   define MACH_TYPE \"S370\"\n-#   define OS_TYPE \"UTS4\"\n #   define ALIGNMENT 4\t/* Required by hardware\t*/\n-    extern int etext;\n+#   define USE_GENERIC_PUSH_REGS\n+#   ifdef UTS4\n+#       define OS_TYPE \"UTS4\"\n+        extern int etext;\n \textern int _etext;\n \textern int _end;\n \textern char * GC_SysVGetDataStart();\n #       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n #\tdefine DATAEND (&_end)\n #\tdefine HEURISTIC2\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define HEURISTIC1\n+#       define DYNAMIC_LOADING\n+        extern int __data_start;\n+#       define DATASTART ((ptr_t)(&__data_start))\n+#   endif\n # endif\n \n # if defined(PJ)\n@@ -1173,8 +1389,37 @@\n #            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n #       endif\n #   endif\n+#   ifdef MSWINCE\n+#     define OS_TYPE \"MSWINCE\"\n+#     define DATAEND /* not needed */\n+#   endif\n #endif\n \n+# ifdef SH\n+#   define MACH_TYPE \"SH\"\n+#   define ALIGNMENT 4\n+#   ifdef MSWINCE\n+#     define OS_TYPE \"MSWINCE\"\n+#     define DATAEND /* not needed */\n+#   endif\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     define STACKBOTTOM ((ptr_t) 0x7c000000)\n+#     define USE_GENERIC_PUSH_REGS\n+#     define DYNAMIC_LOADING\n+#     define LINUX_DATA_START\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#   endif\n+# endif\n+ \n+# ifdef SH4\n+#   define MACH_TYPE \"SH4\"\n+#   define OS_TYPE \"MSWINCE\"\n+#   define ALIGNMENT 4\n+#   define DATAEND /* not needed */\n+# endif\n+\n #ifdef LINUX_DATA_START\n     /* Some Linux distributions arrange to define __data_start.  Some\t*/\n     /* define data_start as a weak symbol.  The latter is technically\t*/\n@@ -1188,6 +1433,14 @@\n #   define DATASTART ((ptr_t)(&__data_start != 0? &__data_start : &data_start))\n #endif\n \n+#if defined(LINUX) && defined(REDIRECT_MALLOC)\n+    /* Rld appears to allocate some memory with its own allocator, and\t*/\n+    /* some through malloc, which might be redirected.  To make this\t*/\n+    /* work with collectable memory, we have to scan memory allocated\t*/\n+    /* by rld's internal malloc.\t\t\t\t\t*/\n+#   define USE_PROC_FOR_LIBRARIES\n+#endif\n+    \n # ifndef STACK_GROWS_UP\n #   define STACK_GROWS_DOWN\n # endif\n@@ -1234,6 +1487,12 @@\n #   define SUNOS5SIGS\n # endif\n \n+# if defined(SVR4) || defined(LINUX) || defined(IRIX) || defined(HPUX) \\\n+    || defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \\\n+    || defined(BSD) || defined(AIX) || defined(MACOSX) || defined(OSF1)\n+#   define UNIX_LIKE   /* Basic Unix-like system calls work.\t*/\n+# endif\n+\n # if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n    -> bad word size\n # endif\n@@ -1264,6 +1523,10 @@\n #   undef MPROTECT_VDB  /* Can't deal with address space holes. */\n # endif\n \n+# ifdef PARALLEL_MARK\n+#   undef MPROTECT_VDB  /* For now.\t*/\n+# endif\n+\n # if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n #   define DEFAULT_VDB\n # endif\n@@ -1288,15 +1551,38 @@\n \t((word*)x)[1] = 0;\n # endif /* CLEAR_DOUBLE */\n \n+/* Internally to the collector we test only the XXX_THREADS macros\t*/\n+/* not the GC_XXX_THREADS versions.  Here we make sure the latter\t*/\n+/* are treated as equivalent.\t\t\t\t\t\t*/\n+#if defined(GC_SOLARIS_THREADS) && !defined(_SOLARIS_THREADS)\n+#   define _SOLARIS_THREADS\n+#endif\n+#if defined(GC_SOLARIS_THREADS) && !defined(_SOLARIS_PTHREADS)\n+#   define _SOLARIS_PTHREADS\n+#endif\n+#if defined(GC_IRIX_THREADS) && !defined(IRIX_THREADS)\n+#   define IRIX_THREADS\n+#endif\n+#if defined(GC_LINUX_THREADS) && !defined(LINUX_THREADS)\n+#   define LINUX_THREADS\n+#endif\n+#if defined(GC_WIN32_THREADS) && !defined(WIN32_THREADS)\n+#   define WIN32_THREADS\n+#endif\n+#if defined(GC_HPUX_THREADS) && !defined(HPUX_THREADS)\n+#   define HPUX_THREADS\n+#endif\n+#if defined(GC_OSF1_THREADS) && !defined(OSF1_THREADS)\n+#   define OSF1_THREADS\n+#endif\n+\n+/* Internally we use SOLARIS_THREADS to test for either old or pthreads. */\n # if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n #   define SOLARIS_THREADS\n # endif\n # if defined(IRIX_THREADS) && !defined(IRIX5)\n --> inconsistent configuration\n # endif\n-# if defined(IRIX_JDK_THREADS) && !defined(IRIX5)\n---> inconsistent configuration\n-# endif\n # if defined(LINUX_THREADS) && !defined(LINUX)\n --> inconsistent configuration\n # endif\n@@ -1309,16 +1595,26 @@\n # if defined(PCR) || defined(SRC_M3) || \\\n \tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n+\tdefined(HPUX_THREADS) || defined(OSF1_THREADS)\n #   define THREADS\n # endif\n \n-# if defined(HP_PA) || defined(M88K) || defined(POWERPC) \\\n-     || (defined(I386) && defined(OS2)) || defined(UTS4) || defined(LINT)\n-\t/* Use setjmp based hack to mark from callee-save registers. */\n+# if defined(HP_PA) || defined(M88K) || defined(POWERPC) && !defined(MACOSX) \\\n+     || defined(LINT) || defined(MSWINCE) \\\n+     || (defined(I386) && defined(__LCC__))\n+\t/* Use setjmp based hack to mark from callee-save registers.    */\n+\t/* The define should move to the individual platform \t\t*/\n+\t/* descriptions.\t\t\t\t\t\t*/\n #\tdefine USE_GENERIC_PUSH_REGS\n # endif\n-# if defined(SPARC) && !defined(LINUX)\n+# if defined(I386) && defined(LINUX)\n+    /* SAVE_CALL_CHAIN is supported if the code is compiled to save\t*/\n+    /* frame pointers by default, i.e. no -fomit-frame-pointer flag.\t*/\n+# ifdef SAVE_CALL_COUNT\n+#   define SAVE_CALL_CHAIN \n+# endif\n+# endif\n+# if defined(SPARC)\n #   define SAVE_CALL_CHAIN\n #   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n \t\t\t\t/* include assembly code to do it well.\t*/"}]}