{"sha": "ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM4NGUwNWViNmEzY2M2ZjJkYTA4MTY1MzdiNWNiZDVhNWQ1OGYxYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-06T23:11:15Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-06T23:11:15Z"}, "message": "tree-ssa-loop-niter.c (idx_infer_loop_bounds): Add and use argument \"reliable\".\n\n\t* tree-ssa-loop-niter.c (idx_infer_loop_bounds): Add and use\n\targument \"reliable\".\n\t(infer_loop_bounds_from_ref, infer_loop_bounds_from_array):\n\tAdd argument \"reliable\".  Propagate it through calls.\n\t(infer_loop_bounds_from_undefined):  Derive number of iterations\n\testimates from references in blocks that do not dominate loop latch.\n\t(gcov_type_to_double_int): New function.\n\t(estimate_numbers_of_iterations_loop): Use gcov_type_to_double_int\n\tand expected_loop_iterations_unbounded.\n\t* cfgloopanal.c (expected_loop_iterations_unbounded): New function.\n\t(expected_loop_iterations): Use expected_loop_iterations_unbounded.\n\t* tree-data-ref.c (estimated_loop_iterations): Export.\n\t(get_references_in_stmt): Fix -- do not return addresses of local\n\tobjects.\n\t* cfgloop.h (expected_loop_iterations_unbounded,\n\testimated_loop_iterations): Declare.\n\nFrom-SVN: r123630", "tree": {"sha": "6e9884d45709a7814b362ea6e6dbf57ecb1ab63e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e9884d45709a7814b362ea6e6dbf57ecb1ab63e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/comments", "author": null, "committer": null, "parents": [{"sha": "64199a9eedbd34833b7712d6da13d117fa3ef9f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64199a9eedbd34833b7712d6da13d117fa3ef9f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64199a9eedbd34833b7712d6da13d117fa3ef9f4"}], "stats": {"total": 122, "additions": 93, "deletions": 29}, "files": [{"sha": "47a62ad29cf852b64ff14dfd3266599e940a553f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "patch": "@@ -1,3 +1,22 @@\n+2007-04-06  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (idx_infer_loop_bounds): Add and use\n+\targument \"reliable\".\n+\t(infer_loop_bounds_from_ref, infer_loop_bounds_from_array):\n+\tAdd argument \"reliable\".  Propagate it through calls.\n+\t(infer_loop_bounds_from_undefined):  Derive number of iterations\n+\testimates from references in blocks that do not dominate loop latch.\n+\t(gcov_type_to_double_int): New function.\n+\t(estimate_numbers_of_iterations_loop): Use gcov_type_to_double_int\n+\tand expected_loop_iterations_unbounded.\n+\t* cfgloopanal.c (expected_loop_iterations_unbounded): New function.\n+\t(expected_loop_iterations): Use expected_loop_iterations_unbounded.\n+\t* tree-data-ref.c (estimated_loop_iterations): Export.\n+\t(get_references_in_stmt): Fix -- do not return addresses of local\n+\tobjects.\n+\t* cfgloop.h (expected_loop_iterations_unbounded,\n+\testimated_loop_iterations): Declare.\n+\n 2007-04-06  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* tree-sra.c (sra_build_elt_assignment): Initialize min/maxshift."}, {"sha": "cbad81d27f066cbd0871e85553d8ae8c757898ca", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "patch": "@@ -262,11 +262,13 @@ extern void verify_loop_structure (void);\n \n /* Loop analysis.  */\n extern bool just_once_each_iteration_p (const struct loop *, basic_block);\n+gcov_type expected_loop_iterations_unbounded (const struct loop *);\n extern unsigned expected_loop_iterations (const struct loop *);\n extern rtx doloop_condition_get (rtx);\n \n void estimate_numbers_of_iterations_loop (struct loop *);\n HOST_WIDE_INT estimated_loop_iterations_int (struct loop *, bool);\n+bool estimated_loop_iterations (struct loop *, bool, double_int *);\n \n /* Loop manipulation.  */\n extern bool can_duplicate_loop_p (struct loop *loop);"}, {"sha": "4612ab8f1a16a3337c78c02aa352936339c88a0a", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "patch": "@@ -423,11 +423,12 @@ average_num_loop_insns (struct loop *loop)\n   return ninsns;\n }\n \n-/* Returns expected number of LOOP iterations.\n-   Compute upper bound on number of iterations in case they do not fit integer\n-   to help loop peeling heuristics.  Use exact counts if at all possible.  */\n-unsigned\n-expected_loop_iterations (const struct loop *loop)\n+/* Returns expected number of iterations of LOOP, according to\n+   measured or guessed profile.  No bounding is done on the\n+   value.  */\n+\n+gcov_type\n+expected_loop_iterations_unbounded (const struct loop *loop)\n {\n   edge e;\n   edge_iterator ei;\n@@ -450,8 +451,7 @@ expected_loop_iterations (const struct loop *loop)\n       else\n \texpected = (count_latch + count_in - 1) / count_in;\n \n-      /* Avoid overflows.  */\n-      return (expected > REG_BR_PROB_BASE ? REG_BR_PROB_BASE : expected);\n+      return expected;\n     }\n   else\n     {\n@@ -473,6 +473,16 @@ expected_loop_iterations (const struct loop *loop)\n     }\n }\n \n+/* Returns expected number of LOOP iterations.  The returned value is bounded\n+   by REG_BR_PROB_BASE.  */\n+\n+unsigned\n+expected_loop_iterations (const struct loop *loop)\n+{\n+  gcov_type expected = expected_loop_iterations_unbounded (loop);\n+  return (expected > REG_BR_PROB_BASE ? REG_BR_PROB_BASE : expected);\n+}\n+\n /* Returns the maximum level of nesting of subloops of LOOP.  */\n \n unsigned"}, {"sha": "3f24c6a51473dbdea6812554f0493aad719ff1a4", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "patch": "@@ -2553,7 +2553,7 @@ analyze_ziv_subscript (tree chrec_a,\n    large as the number of iterations.  If we have no reliable estimate,\n    the function returns false, otherwise returns true.  */\n \n-static bool\n+bool\n estimated_loop_iterations (struct loop *loop, bool conservative,\n \t\t\t   double_int *nit)\n {\n@@ -4873,8 +4873,7 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n {\n   bool clobbers_memory = false;\n   data_ref_loc *ref;\n-  tree *op0, *op1, arg, call;\n-  call_expr_arg_iterator iter;\n+  tree *op0, *op1, call;\n \n   *references = NULL;\n \n@@ -4915,9 +4914,12 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n \n   if (call)\n     {\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+      unsigned i, n = call_expr_nargs (call);\n+\n+      for (i = 0; i < n; i++)\n \t{\n-\t  op0 = &arg;\n+\t  op0 = &CALL_EXPR_ARG (call, i);\n+\n \t  if (DECL_P (*op0)\n \t      || REFERENCE_CLASS_P (*op0))\n \t    {"}, {"sha": "362be0699d35070bc1a72312705f8b570e3e01e7", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ac84e05eb6a3cc6f2da0816537b5cbd5a5d58f1b", "patch": "@@ -2581,12 +2581,15 @@ array_at_struct_end_p (tree ref)\n }\n \n /* Determine information about number of iterations a LOOP from the index\n-   IDX of a data reference accessed in STMT.  Callback for for_each_index.  */\n+   IDX of a data reference accessed in STMT.  RELIABLE is true if STMT is\n+   guaranteed to be executed in every iteration of LOOP.  Callback for\n+   for_each_index.  */\n \n struct ilb_data\n {\n   struct loop *loop;\n   tree stmt;\n+  bool reliable;\n };\n \n static bool\n@@ -2595,7 +2598,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   struct ilb_data *data = dta;\n   tree ev, init, step;\n   tree low, high, type, next;\n-  bool sign, upper = true;\n+  bool sign, upper = data->reliable, at_end = false;\n   struct loop *loop = data->loop;\n \n   if (TREE_CODE (base) != ARRAY_REF)\n@@ -2605,7 +2608,10 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n      do not really extend over their declared size.  However, for arrays of\n      size greater than one, this is unlikely to be intended.  */\n   if (array_at_struct_end_p (base))\n-    upper = false;\n+    {\n+      at_end = true;\n+      upper = false;\n+    }\n \n   ev = instantiate_parameters (loop, analyze_scalar_evolution (loop, *idx));\n   init = initial_condition (ev);\n@@ -2633,7 +2639,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n \n   /* The array of length 1 at the end of a structure most likely extends\n      beyond its bounds.  */\n-  if (!upper\n+  if (at_end\n       && operand_equal_p (low, high, 0))\n     return true;\n \n@@ -2665,23 +2671,27 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n }\n \n /* Determine information about number of iterations a LOOP from the bounds\n-   of arrays in the data reference REF accessed in STMT.  */\n+   of arrays in the data reference REF accessed in STMT.  RELIABLE is true if\n+   STMT is guaranteed to be executed in every iteration of LOOP.*/\n \n static void\n-infer_loop_bounds_from_ref (struct loop *loop, tree stmt, tree ref)\n+infer_loop_bounds_from_ref (struct loop *loop, tree stmt, tree ref,\n+\t\t\t    bool reliable)\n {\n   struct ilb_data data;\n \n   data.loop = loop;\n   data.stmt = stmt;\n+  data.reliable = reliable;\n   for_each_index (&ref, idx_infer_loop_bounds, &data);\n }\n \n /* Determine information about number of iterations of a LOOP from the way\n-   arrays are used in STMT.  */\n+   arrays are used in STMT.  RELIABLE is true if STMT is guaranteed to be\n+   executed in every iteration of LOOP.  */\n \n static void\n-infer_loop_bounds_from_array (struct loop *loop, tree stmt)\n+infer_loop_bounds_from_array (struct loop *loop, tree stmt, bool reliable)\n {\n   tree call;\n \n@@ -2693,10 +2703,10 @@ infer_loop_bounds_from_array (struct loop *loop, tree stmt)\n       /* For each memory access, analyze its access function\n \t and record a bound on the loop iteration domain.  */\n       if (REFERENCE_CLASS_P (op0))\n-\tinfer_loop_bounds_from_ref (loop, stmt, op0);\n+\tinfer_loop_bounds_from_ref (loop, stmt, op0, reliable);\n \n       if (REFERENCE_CLASS_P (op1))\n-\tinfer_loop_bounds_from_ref (loop, stmt, op1);\n+\tinfer_loop_bounds_from_ref (loop, stmt, op1, reliable);\n     }\n   \n   \n@@ -2708,7 +2718,7 @@ infer_loop_bounds_from_array (struct loop *loop, tree stmt)\n \n       FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n \tif (REFERENCE_CLASS_P (arg))\n-\t  infer_loop_bounds_from_ref (loop, stmt, arg);\n+\t  infer_loop_bounds_from_ref (loop, stmt, arg, reliable);\n     }\n }\n \n@@ -2768,6 +2778,7 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n   basic_block *bbs;\n   block_stmt_iterator bsi;\n   basic_block bb;\n+  bool reliable;\n   \n   bbs = get_loop_body (loop);\n \n@@ -2776,23 +2787,42 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n       bb = bbs[i];\n \n       /* If BB is not executed in each iteration of the loop, we cannot\n-\t use it to infer any information about # of iterations of the loop.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n-\tcontinue;\n+\t use the operations in it to infer reliable upper bound on the\n+\t # of iterations of the loop.  However, we can use it as a guess.  */\n+      reliable = dominated_by_p (CDI_DOMINATORS, loop->latch, bb);\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \n-\t  infer_loop_bounds_from_array (loop, stmt);\n-\t  infer_loop_bounds_from_signedness (loop, stmt);\n+\t  infer_loop_bounds_from_array (loop, stmt, reliable);\n+\n+\t  if (reliable)\n+\t    infer_loop_bounds_from_signedness (loop, stmt);\n   \t}\n \n     }\n \n   free (bbs);\n }\n \n+/* Converts VAL to double_int.  */\n+\n+static double_int\n+gcov_type_to_double_int (gcov_type val)\n+{\n+  double_int ret;\n+\n+  ret.low = (unsigned HOST_WIDE_INT) val;\n+  /* If HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_WIDEST_INT, avoid shifting by\n+     the size of type.  */\n+  val >>= HOST_BITS_PER_WIDE_INT - 1;\n+  val >>= 1;\n+  ret.high = (unsigned HOST_WIDE_INT) val;\n+\n+  return ret;\n+}\n+\n /* Records estimates on numbers of iterations of LOOP.  */\n \n void\n@@ -2836,7 +2866,8 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n      iterations.  */\n   if (loop->header->count != 0)\n     {\n-      bound = uhwi_to_double_int (expected_loop_iterations (loop) + 1);\n+      gcov_type nit = expected_loop_iterations_unbounded (loop) + 1;\n+      bound = gcov_type_to_double_int (nit);\n       record_niter_bound (loop, bound, true, false);\n     }\n "}]}