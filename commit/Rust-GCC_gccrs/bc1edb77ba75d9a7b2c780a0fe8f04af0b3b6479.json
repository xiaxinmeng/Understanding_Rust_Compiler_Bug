{"sha": "bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMxZWRiNzdiYTc1ZDlhN2IyYzc4MGEwZmU4ZjA0YWYwYjNiNjQ3OQ==", "commit": {"author": {"name": "Victor Kaplansky", "email": "victork@il.ibm.com", "date": "2007-08-16T14:20:39Z"}, "committer": {"name": "Victor Kaplansky", "email": "victork@gcc.gnu.org", "date": "2007-08-16T14:20:39Z"}, "message": "tree-vectorizer.c (new_loop_vec_info): Initialize new field.\n\n\ngcc/ChangeLog\n\n\t* tree-vectorizer.c (new_loop_vec_info): Initialize new \n\tfield.\n\t(destroy_loop_vec_info): Add call to VEC_free.\n\t* tree-vectorizer.h (may_alias_ddrs): Define.\n\t(LOOP_VINFO_MAY_ALIAS_DDRS): Define.\n\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence):\n\tChange reporting to dump.\n\t(vect_is_duplicate_ddr): New.\n\t(vect_mark_for_runtime_alias_test): New.\n\t(vect_analyze_data_ref_dependences) Add call to\n\tvect_mark_for_runtime_alias_test.\n\t(vect_enhance_data_refs_alignment): Define local variable\n\tvect_versioning_for_alias_required, don't perform\n\tpeeling for alignment if versioning for alias is\n\trequired.\n\t(vect_enhance_data_refs_alignment): Use\n\tPARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS instead of\n\tPARAM_VECT_MAX_VERSION_CHECKS.\n\t* tree-vect-transform.c\n\t(vect_create_cond_for_alias_checks): New.\n\t(vect_transform_loop): Add call to\n\tvect_create_cond_for_alias_checks.\n\t(vect_vfa_segment_size): New.\n\t* params.def (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS):\n\tRename.\n\t(PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS): Define.\n\t* gcc/doc/invoke.texi\n\t(vect-max-version-for-alignment-checks): Document.\n\t(vect-max-version-for-alias-checks): Document.\n\t(vect-max-version-checks): Remove.\n     \ngcc/testsuite/ChangeLog\n\n\t* gcc.dg/vect/vect-vfa-01.c: New.\n\t* gcc.dg/vect/vect-vfa-02.c: New.\n\t* gcc.dg/vect/vect-vfa-03.c: New.\n\t* gcc.dg/vect/vect-vfa-04.c: New.\n\t* gcc.dg/vect/vect-102a.c, gcc.dg/vect/vect-51.c,\n\tgcc.dg/vect/pr29145.c, gcc.dg/vect/vect-43.c,\n\tgcc.dg/vect/vect-61.c, gcc.dg/vect/vect-53.c,\n\tgcc.dg/vect/vect-45.c, gcc.dg/vect/vect-101.c,\n\tgcc.dg/vect/vect-37.c, gcc.dg/vect/vect-79.c,\n\tgcc.dg/vect/vect-102.c, gcc.dg/vect/vect-dv-2.c,\n\tgcc.dg/vect/vect-57.c, gcc.dg/vect/vect-49.c,\n\tgfortran.dg/vect/pr19049.f90: Rename to start with\n\tprefix no-vfa-.\n\t* gcc.dg/vect/vect.exp: Disable versioning for alias\n\twhen test starts with no-vfa-.\n\t* gfortran.dg/vect/vect.exp: Likewise.\n\nFrom-SVN: r127559", "tree": {"sha": "03bccd8be0266f061712ef717618bb096e583eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03bccd8be0266f061712ef717618bb096e583eab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/comments", "author": null, "committer": null, "parents": [{"sha": "57c2d13fa01341b6b3a843d321b0d8bd2518a4dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c2d13fa01341b6b3a843d321b0d8bd2518a4dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c2d13fa01341b6b3a843d321b0d8bd2518a4dd"}], "stats": {"total": 564, "additions": 538, "deletions": 26}, "files": [{"sha": "db120c094c4c1ee2d70e5a7e4fe0af14d128f85d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -1,3 +1,36 @@\n+2007-08-16  Victor Kaplansky <victork@il.ibm.com>\n+\n+\t* tree-vectorizer.c (new_loop_vec_info): Initialize new \n+\tfield.\n+\t(destroy_loop_vec_info): Add call to VEC_free.\n+\t* tree-vectorizer.h (may_alias_ddrs): Define.\n+\t(LOOP_VINFO_MAY_ALIAS_DDRS): Define.\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence):\n+\tChange reporting to dump.\n+\t(vect_is_duplicate_ddr): New.\n+\t(vect_mark_for_runtime_alias_test): New.\n+\t(vect_analyze_data_ref_dependences) Add call to\n+\tvect_mark_for_runtime_alias_test.\n+\t(vect_enhance_data_refs_alignment): Define local variable\n+\tvect_versioning_for_alias_required, don't perform\n+\tpeeling for alignment if versioning for alias is\n+\trequired.\n+\t(vect_enhance_data_refs_alignment): Use\n+\tPARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS instead of\n+\tPARAM_VECT_MAX_VERSION_CHECKS.\n+\t* tree-vect-transform.c\n+\t(vect_create_cond_for_alias_checks): New.\n+\t(vect_transform_loop): Add call to\n+\tvect_create_cond_for_alias_checks.\n+\t(vect_vfa_segment_size): New.\n+\t* params.def (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS):\n+\tRename.\n+\t(PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS): Define.\n+\t* gcc/doc/invoke.texi\n+\t(vect-max-version-for-alignment-checks): Document.\n+\t(vect-max-version-for-alias-checks): Document.\n+\t(vect-max-version-checks): Remove.\n+     \n 2007-08-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*rep_movdi_rex64): Emit \"rep\" prefix on"}, {"sha": "eed4f10b5067402dc56a980da19c50bb98365ead", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -6741,10 +6741,15 @@ value is 500.\n When set to 1, use expensive methods to eliminate all redundant\n constraints.  The default value is 0.\n \n-@item vect-max-version-checks\n-The maximum number of runtime checks that can be performed when doing\n-loop versioning in the vectorizer.  See option ftree-vect-loop-version\n-for more information.\n+@item vect-max-version-for-alignment-checks\n+The maximum number of runtime checks that can be performed when\n+doing loop versioning for alignment in the vectorizer.  See option\n+ftree-vect-loop-version for more information.\n+\n+@item vect-max-version-for-alias-checks\n+The maximum number of runtime checks that can be performed when\n+doing loop versioning for alias in the vectorizer.  See option\n+ftree-vect-loop-version for more information.\n \n @item max-iterations-to-track\n "}, {"sha": "bcdb4bb2da214de9c52bcfa6f1a823d0cf4f4286", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -485,11 +485,16 @@ DEFPARAM(PARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS,\n \t \"When set to 1, use expensive methods to eliminate all redundant constraints\",\n \t 0, 0, 1)\n \n-DEFPARAM(PARAM_VECT_MAX_VERSION_CHECKS,\n-         \"vect-max-version-checks\",\n-         \"Bound on number of runtime checks inserted by the vectorizer's loop versioning\",\n+DEFPARAM(PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS,\n+         \"vect-max-version-for-alignment-checks\",\n+         \"Bound on number of runtime checks inserted by the vectorizer's loop versioning for alignment check\",\n          6, 0, 0)\n \n+DEFPARAM(PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS,\n+         \"vect-max-version-for-alias-checks\",\n+         \"Bound on number of runtime checks inserted by the vectorizer's loop versioning for alias check\",\n+         10, 0, 0)\n+\n DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,\n \t \"max-cselib-memory-locations\",\n \t \"The maximum memory locations recorded by cselib\","}, {"sha": "387b57919218bc765485e48e7a5ee51daba9ce65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -1,3 +1,22 @@\n+2007-08-16  Victor Kaplansky <victork@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-vfa-01.c: New.\n+\t* gcc.dg/vect/vect-vfa-02.c: New.\n+\t* gcc.dg/vect/vect-vfa-03.c: New.\n+\t* gcc.dg/vect/vect-vfa-04.c: New.\n+\t* gcc.dg/vect/vect-102a.c, gcc.dg/vect/vect-51.c,\n+\tgcc.dg/vect/pr29145.c, gcc.dg/vect/vect-43.c,\n+\tgcc.dg/vect/vect-61.c, gcc.dg/vect/vect-53.c,\n+\tgcc.dg/vect/vect-45.c, gcc.dg/vect/vect-101.c,\n+\tgcc.dg/vect/vect-37.c, gcc.dg/vect/vect-79.c,\n+\tgcc.dg/vect/vect-102.c, gcc.dg/vect/vect-dv-2.c,\n+\tgcc.dg/vect/vect-57.c, gcc.dg/vect/vect-49.c,\n+\tgfortran.dg/vect/pr19049.f90: Rename to start with\n+\tprefix no-vfa-.\n+\t* gcc.dg/vect/vect.exp: Disable versioning for alias\n+\twhen test starts with no-vfa-.\n+\t* gfortran.dg/vect/vect.exp: Likewise.\n+\n 2007-08-16  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.dg/torture/pr32897.c: New test."}, {"sha": "97d190ca2782a6f920d2740313f11112a6612f65", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-pr29145.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-pr29145.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-pr29145.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-pr29145.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/pr29145.c"}, {"sha": "e195a58af5f85de78460762330021406ca3ad6a3", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-101.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-101.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-101.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-101.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-101.c"}, {"sha": "49df4f9bc905a5bcac6a4f8b5f2c80862be1c00f", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-102.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-102.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-102.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-102.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-102.c"}, {"sha": "35023fc65dcc662c69b50cd70ff5439b1badb009", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-102a.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-102a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-102a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-102a.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-102a.c"}, {"sha": "e54e0c5166c3c30224845eace518fec66178cd56", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-37.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-37.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-37.c"}, {"sha": "258da2827f7516ebb1f898589ec516479598c7dd", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-43.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-43.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-43.c"}, {"sha": "8a998564319a33e1ced6f3a8b231fda63a508f2f", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-45.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-45.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-45.c"}, {"sha": "8dfd0e749b53fe040dd2fa49c406fcd22c3444db", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-49.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-49.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-49.c"}, {"sha": "541a5ffef3b0181920fc59d7e1f78e735792f594", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-51.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-51.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-51.c"}, {"sha": "91eaabeb93b2d16d5fd65ad3c954e5c4a024cdb6", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-53.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-53.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-53.c"}, {"sha": "bcac95a03938db2188ac8676c9c20d011969b5e6", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-57.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-57.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-57.c"}, {"sha": "9f4e8e9882b2c41caf0529c371603a1fe0a80fe5", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-61.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-61.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-61.c"}, {"sha": "8e98e4d0ed982da895cd3c3ed446eec5f68e1aee", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-79.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-79.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-79.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-79.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-79.c"}, {"sha": "30d229c1996afbc0426f33201d220530c8afbc0b", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-dv-2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-dv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-dv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-dv-2.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gcc.dg/vect/vect-dv-2.c"}, {"sha": "ea5523ed177966876e7a3c57a295bdedc4057805", "filename": "gcc/testsuite/gcc.dg/vect/vect-vfa-01.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-01.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+int result[N] = {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};\n+int X[N] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};\n+int Y[N] = {};\n+ \n+void\n+foo (int *in, int *out)\n+{  \n+  int i;\n+  \n+  for (i = 0; i < N; i++)\n+    out[i] = in[i] + 2;\n+}\n+\n+int\n+main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  foo (X, Y);\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (Y[i] != result[i])\n+\tabort ();\n+    }\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "80d85a785c67d22c5b47cb0441aa604a3dcec2c0", "filename": "gcc/testsuite/gcc.dg/vect/vect-vfa-02.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-02.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+int resultY[N] = {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};\n+int resultZ[N] = {13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28};\n+int X[N] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};\n+int Y[N] = {};\n+int Z[N] = {};\n+ \n+void\n+foo (int *in, int *out1, int *out2)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out1[i] = in[i] + 2;\n+      out2[i] = in[i] + 3;\n+    }\n+}\n+\n+int\n+main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  foo (X, Y, Z);\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (Y[i] != resultY[i])\n+\tabort ();\n+\n+      if (Z[i] != resultZ[i])\n+\tabort ();\n+    }\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "aa001bf4d6f89347600c93df73f6edc39dfff49f", "filename": "gcc/testsuite/gcc.dg/vect/vect-vfa-03.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-03.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-03.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-03.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+struct S\n+{\n+  unsigned short a;\n+  unsigned short b;\n+};\n+\n+struct S result[N] = {12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18,\n+                      18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24,\n+\t\t      24, 25, 25, 26, 26, 27, 27, 28};\n+struct S X[N] = {10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16,\n+                 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n+\t\t 23, 23, 24, 24, 25, 25};\n+struct S Y[N] = {};\n+ \n+void\n+foo (struct S * in, struct S * out)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i].a = in[i].a + 2;\n+      out[i].b = in[i].b + 3;\n+    }\n+}\n+\n+int\n+main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  foo (X, Y);\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (Y[i].a != result[i].a)\n+\tabort ();\n+\n+      if (Y[i].b != result[i].b)\n+\tabort ();\n+\n+    }\n+  return 0;\n+} \n+\n+/* Needs interleaving support.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { xfail  { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e43df0086c046fc248364c6417e864c3fd3cf39b", "filename": "gcc/testsuite/gcc.dg/vect/vect-vfa-04.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-04.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-04.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-04.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+int result[] = {10, 11, 15, 16, 20, 21, 25, 26, 30, 31, 35, 36, 40, 41, 45, 46, 50, 51};\n+int X[] =      {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0};\n+ \n+void\n+foo (int *in, int *out)\n+{  \n+  int i;\n+  \n+  for (i = 0; i < N; i++)\n+    out[i] = in[i] + 5;\n+}\n+\n+int\n+main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  foo (X, &X[2]);\n+  \n+  /* check results:  */\n+  for (i = 0; i < N+2; i++)\n+    {\n+      if (X[i] != result[i])\n+\tabort ();\n+    }\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "2208f727d1e3c39ca984eb6a1656a9441c421e7a", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -113,6 +113,12 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[cS\\]]]  \\\n global SAVED_DEFAULT_VECTCFLAGS\n set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n \n+# --param vect-max-version-for-alias-checks=0 tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"--param\" \"vect-max-version-for-alias-checks=0\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n # -ffast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ffast-math\""}, {"sha": "07a2b6056fb954a195f0ae5b9c94b36f742a4eaf", "filename": "gcc/testsuite/gfortran.dg/vect/no-vfa-pr32457.f90", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fno-vfa-pr32457.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fno-vfa-pr32457.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fno-vfa-pr32457.f90?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "previous_filename": "gcc/testsuite/gfortran.dg/vect/pr32457.f90"}, {"sha": "3cc41c70482529060ed7f60266d6b13bda673277", "filename": "gcc/testsuite/gfortran.dg/vect/vect.exp", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -90,7 +90,18 @@ proc check_effective_target_lp64_or_vect_no_align { } {\n dg-init\n \n # Main loop.\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[fF\\]{,90,95,03} ]] $DEFAULT_VECTCFLAGS\n+gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[fF\\]{,90,95,03} ]] $DEFAULT_VECTCFLAGS\n+gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr-*.\\[fF\\]{,90,95,03} ]] $DEFAULT_VECTCFLAGS\n+\n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+\n+# --param vect-max-version-for-alias-checks=0 tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"--param\" \"vect-max-version-for-alias-checks=0\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[fF\\]{,90,95,03} ]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n \n # Clean up.\n set dg-do-what-default ${save-dg-do-what-default}"}, {"sha": "cc43ad61aef52a386d329a2c07a20782b0ec2004", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 94, "deletions": 11, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -1039,10 +1039,10 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n         {\n           fprintf (vect_dump,\n-                   \"not vectorized: can't determine dependence between \");\n+                   \"versioning for alias required: can't determine dependence between \");\n           print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n@@ -1052,9 +1052,9 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n         {\n-          fprintf (vect_dump, \"not vectorized: bad dist vector for \");\n+          fprintf (vect_dump, \"versioning for alias required: bad dist vector for \");\n           print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n@@ -1108,10 +1108,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  continue;\n \t}\n \n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n \t{\n \t  fprintf (vect_dump,\n-\t\t   \"not vectorized: possible dependence between data-refs \");\n+\t\t   \"versioning for alias required: possible dependence \"\n+\t\t   \"between data-refs \");\n \t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n \t  fprintf (vect_dump, \" and \");\n \t  print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n@@ -1123,6 +1124,77 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   return false;\n }\n \n+/* Return TRUE if DDR_NEW is already found in MAY_ALIAS_DDRS list.  */\n+\n+static bool\n+vect_is_duplicate_ddr (VEC (ddr_p, heap) * may_alias_ddrs, ddr_p ddr_new)\n+{\n+  unsigned i;\n+  ddr_p ddr;\n+\n+  for (i = 0; VEC_iterate (ddr_p, may_alias_ddrs, i, ddr); i++)\n+    {\n+      tree dref_A_i, dref_B_i, dref_A_j, dref_B_j;\n+\n+      dref_A_i = DR_REF (DDR_A (ddr));\n+      dref_B_i = DR_REF (DDR_B (ddr));\n+      dref_A_j = DR_REF (DDR_A (ddr_new));\n+      dref_B_j = DR_REF (DDR_B (ddr_new));\n+\n+      if ((operand_equal_p (dref_A_i, dref_A_j, 0)\n+\t   && operand_equal_p (dref_B_i, dref_B_j, 0))\n+\t  || (operand_equal_p (dref_A_i, dref_B_j, 0)\n+\t      && operand_equal_p (dref_B_i, dref_A_j, 0)))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"found same pair of data references \");\n+\t      print_generic_expr (vect_dump, dref_A_i, TDF_SLIM);\n+\t      fprintf (vect_dump, \" and \");\n+\t      print_generic_expr (vect_dump, dref_B_i, TDF_SLIM);\n+\t    }\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Save DDR in LOOP_VINFO list of ddrs that may alias and need to be\n+   tested at run-time.  Returns false if number of run-time checks\n+   inserted by vectorizer is greater than maximum defined by\n+   PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS.  */\n+static bool\n+vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n+{\n+  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+    {\n+      fprintf (vect_dump, \"mark for run-time aliasing test between \");\n+      print_generic_expr (vect_dump, DR_REF (DDR_A (ddr)), TDF_SLIM);\n+      fprintf (vect_dump, \" and \");\n+      print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n+    }\n+\n+  /* Do not add to the list duplicate ddrs.  */\n+  if (vect_is_duplicate_ddr (LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr))\n+    return true;\n+\n+  if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo))\n+      >= (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n+    {\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t{\n+\t  fprintf (vect_dump,\n+\t\t   \"disable versioning for alias - max number of generated \"\n+\t\t   \"checks exceeded.\");\n+\t}\n+\n+      VEC_truncate (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), 0);\n+\n+      return false;\n+    }\n+  VEC_safe_push (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr);\n+  return true;\n+}\n \n /* Function vect_analyze_data_ref_dependences.\n           \n@@ -1133,15 +1205,19 @@ static bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n {\n   unsigned int i;\n-  VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+  VEC (ddr_p, heap) * ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n   struct data_dependence_relation *ddr;\n \n   if (vect_print_dump_info (REPORT_DETAILS)) \n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n      \n   for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n     if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n+      {\n+\t/* Add to list of ddrs that need to be tested at run-time.  */\n+\tif (!vect_mark_for_runtime_alias_test (ddr, loop_vinfo))\n       return false;\n+      }\n \n   return true;\n }\n@@ -1554,6 +1630,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   bool stat;\n   tree stmt;\n   stmt_vec_info stmt_info;\n+  int vect_versioning_for_alias_required;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n@@ -1619,9 +1696,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t}\n     }\n \n-  /* Often peeling for alignment will require peeling for loop-bound, which in \n-     turn requires that we know how to adjust the loop ivs after the loop.  */\n-  if (!vect_can_advance_ivs_p (loop_vinfo)\n+  vect_versioning_for_alias_required =\n+    (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)) > 0);\n+\n+  /* Temporarily, if versioning for alias is required, we disable peeling\n+     until we support peeling and versioning.  Often peeling for alignment\n+     will require peeling for loop-bound, which in turn requires that we\n+     know how to adjust the loop ivs after the loop.  */\n+  if (vect_versioning_for_alias_required\n+       || !vect_can_advance_ivs_p (loop_vinfo)\n       || !slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n     do_peeling = false;\n \n@@ -1749,7 +1832,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               if (known_alignment_for_access_p (dr)\n                   || VEC_length (tree,\n                                  LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n-                     >= (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_CHECKS))\n+                     >= (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS))\n                 {\n                   do_versioning = false;\n                   break;"}, {"sha": "16beffceef555c010164c1e18531e22e8c9d8881", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 164, "deletions": 5, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -5805,6 +5805,146 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n                  and_tmp_name, ptrsize_zero);\n }\n \n+/* Function vect_vfa_segment_size.\n+\n+   Create an expression that computes the size of segment\n+   that will be accessed for a data reference.  The functions takes into\n+   account that realignment loads may access one more vector.\n+\n+   Input:\n+     DR: The data reference.\n+     VECT_FACTOR: vectorization factor.\n+\n+   Return an exrpession whose value is the size of segment which will be\n+   accessed by DR.  */\n+\n+static tree\n+vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n+{\n+  tree segment_length;\n+\n+  if (vect_supportable_dr_alignment (dr) == dr_unaligned_software_pipeline)\n+    {\n+      tree vector_size =\n+        build_int_cst (integer_type_node,\n+          GET_MODE_SIZE (TYPE_MODE (STMT_VINFO_VECTYPE\n+\t    (vinfo_for_stmt (DR_STMT (dr))))));\n+\n+      segment_length =\n+\tfold_convert (sizetype,\n+\t  fold_build2 (PLUS_EXPR, integer_type_node,\n+\t    fold_build2 (MULT_EXPR, integer_type_node, DR_STEP (dr),\n+\t\t\t vect_factor),\n+\t    vector_size));\n+\n+\n+    }\n+  else\n+    {\n+      segment_length =\n+\tfold_convert (sizetype,\n+\t  fold_build2 (MULT_EXPR, integer_type_node, DR_STEP (dr),\n+\t\t       vect_factor));\n+    }\n+\n+    return segment_length;\n+}\n+\n+/* Function vect_create_cond_for_alias_checks.\n+\n+   Create a conditional expression that represents the run-time checks for\n+   overlapping of address ranges represented by a list of data references\n+   relations passed as input.\n+\n+   Input:\n+   COND_EXPR  - input conditional expression.  New conditions will be chained\n+                with logical and operation.\n+   LOOP_VINFO - field LOOP_VINFO_MAY_ALIAS_STMTS contains the list of ddrs\n+\t        to be checked.\n+\n+   Output:\n+   COND_EXPR - conditional expression.\n+   COND_EXPR_STMT_LIST - statements needed to construct the conditional\n+                         expression.\n+   The returned value is the conditional expression to be used in the if\n+   statement that controls which version of the loop gets executed at runtime.\n+*/\n+\n+static void\n+vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n+\t\t\t\t   tree * cond_expr,\n+\t\t\t\t   tree * cond_expr_stmt_list)\n+{\n+  VEC (ddr_p, heap) * may_alias_ddrs =\n+    LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n+  tree vect_factor =\n+    build_int_cst (integer_type_node, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+\n+  ddr_p ddr;\n+  unsigned int i;\n+  tree part_cond_expr;\n+\n+  /* Create expression\n+     ((store_ptr_0 + store_segment_length_0) < load_ptr_0)\n+     || (load_ptr_0 + load_segment_length_0) < store_ptr_0))\n+     &&         \n+     ...\n+     &&\n+     ((store_ptr_n + store_segment_length_n) < load_ptr_n)\n+     || (load_ptr_n + load_segment_length_n) < store_ptr_n))  */\n+\n+  if (VEC_empty (ddr_p, may_alias_ddrs))\n+    return;\n+\n+  for (i = 0; VEC_iterate (ddr_p, may_alias_ddrs, i, ddr); i++)\n+    {\n+      tree stmt_a = DR_STMT (DDR_A (ddr));\n+      tree stmt_b = DR_STMT (DDR_B (ddr));\n+\n+      tree addr_base_a =\n+        vect_create_addr_base_for_vector_ref (stmt_a, cond_expr_stmt_list,\n+\t\t\t\t\t      NULL_TREE);\n+      tree addr_base_b =\n+        vect_create_addr_base_for_vector_ref (stmt_b, cond_expr_stmt_list,\n+\t\t\t\t\t      NULL_TREE);\n+\n+      tree segment_length_a = vect_vfa_segment_size (DDR_A (ddr), vect_factor);\n+      tree segment_length_b = vect_vfa_segment_size (DDR_B (ddr), vect_factor);\n+\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t{\n+\t  fprintf (vect_dump,\n+\t\t   \"create runtime check for data references \");\n+\t  print_generic_expr (vect_dump, DR_REF (DDR_A (ddr)), TDF_SLIM);\n+\t  fprintf (vect_dump, \" and \");\n+\t  print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n+\t}\n+\n+\n+      part_cond_expr = \n+      \tfold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t  fold_build2 (LT_EXPR, boolean_type_node,\n+\t    fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr_base_a),\n+\t      addr_base_a,\n+\t      segment_length_a),\n+\t    addr_base_b),\n+\t  fold_build2 (LT_EXPR, boolean_type_node,\n+\t    fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr_base_b),\n+\t      addr_base_b,\n+\t      segment_length_b),\n+\t    addr_base_a));\n+      \n+      if (*cond_expr)\n+\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t          *cond_expr, part_cond_expr);\n+      else\n+\t*cond_expr = part_cond_expr;\n+    }\n+    if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n+      fprintf (vect_dump, \"created %u versioning for alias checks.\\n\",\n+               VEC_length (ddr_p, may_alias_ddrs));\n+\n+}\n \n /* Function vect_transform_loop.\n \n@@ -5827,16 +5967,21 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n-  /* If the loop has data references that may or may not be aligned then\n+  /* If the loop has data references that may or may not be aligned or/and\n+     has data reference relations whose independence was not proven then\n      two versions of the loop need to be generated, one which is vectorized\n      and one which isn't.  A test is then generated to control which of the\n      loops is executed.  The test checks for the alignment of all of the\n-     data references that may or may not be aligned. */\n+     data references that may or may not be aligned.  An additional\n+     sequence of runtime tests is generated for each pairs of DDRs whose\n+     independence was not proven.  The vectorized version of loop is \n+     executed only if both alias and alignment tests are passed.  */\n \n-  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n+  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n     {\n       struct loop *nloop;\n-      tree cond_expr;\n+      tree cond_expr = NULL_TREE;\n       tree cond_expr_stmt_list = NULL_TREE;\n       basic_block condition_bb;\n       block_stmt_iterator cond_exp_bsi;\n@@ -5845,9 +5990,23 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n       edge new_exit_e, e;\n       tree orig_phi, new_phi, arg;\n       unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n+      tree gimplify_stmt_list;\n \n-      cond_expr = vect_create_cond_for_align_checks (loop_vinfo,\n+      if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n+\tcond_expr =\n+\t  vect_create_cond_for_align_checks (loop_vinfo, &cond_expr_stmt_list);\n+\n+      if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+\tvect_create_cond_for_alias_checks (loop_vinfo, &cond_expr,\n                                                      &cond_expr_stmt_list);\n+\n+      cond_expr =\n+        fold_build2 (NE_EXPR, boolean_type_node, cond_expr, integer_zero_node);\n+      cond_expr =\n+        force_gimple_operand (cond_expr, &gimplify_stmt_list, true,\n+                              NULL_TREE);\n+      append_to_statement_list (gimplify_stmt_list, &cond_expr_stmt_list);\n+\n       initialize_original_copy_tables ();\n       nloop = loop_version (loop, cond_expr, &condition_bb,\n \t\t\t    prob, prob, REG_BR_PROB_BASE - prob, true);"}, {"sha": "6dc0c727c0c96410e4feeed29fb47582429b2c87", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -1414,8 +1414,11 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_DATAREFS (res) = VEC_alloc (data_reference_p, heap, 10);\n   LOOP_VINFO_DDRS (res) = VEC_alloc (ddr_p, heap, 10 * 10);\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n-  LOOP_VINFO_MAY_MISALIGN_STMTS (res)\n-    = VEC_alloc (tree, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_CHECKS));\n+  LOOP_VINFO_MAY_MISALIGN_STMTS (res) =\n+    VEC_alloc (tree, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS));\n+  LOOP_VINFO_MAY_ALIAS_DDRS (res) =\n+    VEC_alloc (ddr_p, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n+\n \n   return res;\n }\n@@ -1495,6 +1498,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n   free_data_refs (LOOP_VINFO_DATAREFS (loop_vinfo));\n   free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n   VEC_free (tree, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n+  VEC_free (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n \n   free (loop_vinfo);\n   loop->aux = NULL;"}, {"sha": "d96b9443b9626edcb4c4cb155a5d93a4c075c974", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bc1edb77ba75d9a7b2c780a0fe8f04af0b3b6479", "patch": "@@ -133,6 +133,10 @@ typedef struct _loop_vec_info {\n   /* All data dependences in the loop.  */\n   VEC (ddr_p, heap) *ddrs;\n \n+  /* Data Dependence Relations defining address ranges that are candidates\n+     for a run-time aliasing check.  */\n+  VEC (ddr_p, heap) *may_alias_ddrs;\n+\n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */\n   VEC(tree,heap) *may_misalign_stmts;\n@@ -157,6 +161,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_UNALIGNED_DR(L)    (L)->unaligned_dr\n #define LOOP_VINFO_MAY_MISALIGN_STMTS(L) (L)->may_misalign_stmts\n #define LOOP_VINFO_LOC(L)             (L)->loop_line_number\n+#define LOOP_VINFO_MAY_ALIAS_DDRS(L)  (L)->may_alias_ddrs\n \n #define NITERS_KNOWN_P(n)                     \\\n (host_integerp ((n),0)                        \\"}]}