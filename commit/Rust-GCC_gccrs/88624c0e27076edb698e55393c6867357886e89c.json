{"sha": "88624c0e27076edb698e55393c6867357886e89c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg2MjRjMGUyNzA3NmVkYjY5OGU1NTM5M2M2ODY3MzU3ODg2ZTg5Yw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-03-14T15:47:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-03-14T15:47:24Z"}, "message": "configure.in (hppa configurations): Add pa32-regs.h to the list of tm files as appropriate.\n\n        * configure.in (hppa configurations): Add pa32-regs.h to the\n        list of tm files as appropriate.\n        * configure: Rebuilt.\n        * pa.c (compute_frame_size): Remove explicit knowledge about FP\n        register numbering.\n        (hppa_expand_prologue, hppa_expand_epilogue): Likewise.\n        (fmpyaddoperands, fmpysuboperands): Likewise.\n        * pa.h: Remove various definitions which depend on knowing\n        how registers are numbered.\n        * pa32-regs.h: New file with PA32 register numbering specific\n        definitions.\n\nFrom-SVN: r32527", "tree": {"sha": "f7c90d8e9a308ada720537845ef6c817c2d39cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7c90d8e9a308ada720537845ef6c817c2d39cb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88624c0e27076edb698e55393c6867357886e89c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88624c0e27076edb698e55393c6867357886e89c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88624c0e27076edb698e55393c6867357886e89c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88624c0e27076edb698e55393c6867357886e89c/comments", "author": null, "committer": null, "parents": [{"sha": "1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953"}], "stats": {"total": 764, "additions": 395, "deletions": 369}, "files": [{"sha": "900a0869f61328653bab48acfd937d8d03b8e9e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88624c0e27076edb698e55393c6867357886e89c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88624c0e27076edb698e55393c6867357886e89c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88624c0e27076edb698e55393c6867357886e89c", "patch": "@@ -1,3 +1,17 @@\n+Tue Mar 14 08:42:21 2000  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* configure.in (hppa configurations): Add pa32-regs.h to the\n+\tlist of tm files as appropriate.\n+\t* configure: Rebuilt.\n+\t* pa.c (compute_frame_size): Remove explicit knowledge about FP\n+\tregister numbering.\n+\t(hppa_expand_prologue, hppa_expand_epilogue): Likewise.\n+\t(fmpyaddoperands, fmpysuboperands): Likewise.\n+\t* pa.h: Remove various definitions which depend on knowing\n+\thow registers are numbered.\n+\t* pa32-regs.h: New file with PA32 register numbering specific\n+\tdefinitions.\n+\n 2000-03-14  Richard Henderson  <rth@cygnus.com>\n \n \t* regmove.c (combine_stack_adjustments): New."}, {"sha": "4fc8a0ce43b643cc6c96d7fab8e5a2413f17b115", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=88624c0e27076edb698e55393c6867357886e89c", "patch": "@@ -2675,7 +2675,7 @@ compute_frame_size (size, fregs_live)\n   fsize = (fsize + 7) & ~7;\n \n   /* Account for space used by the callee floating point register saves.  */\n-  for (i = 66; i >= 48; i -= 2)\n+  for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n     if (regs_ever_live[i] || regs_ever_live[i + 1])\n       {\n \tif (fregs_live)\n@@ -2980,7 +2980,7 @@ hppa_expand_prologue()\n \tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n \n       /* Now actually save the FP registers.  */\n-      for (i = 66; i >= 48; i -= 2)\n+      for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n \t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t    {\n@@ -3118,7 +3118,7 @@ hppa_expand_epilogue ()\n \tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n \n       /* Actually do the restores now.  */\n-      for (i = 66; i >= 48; i -= 2)\n+      for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n \t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t    {\n@@ -5698,12 +5698,12 @@ fmpyaddoperands (operands)\n \n   /* SFmode limits the registers to the upper 32 of the 32bit FP regs.  */\n   if (mode == SFmode\n-      && (REGNO (operands[0]) < 57\n-\t  || REGNO (operands[1]) < 57\n-\t  || REGNO (operands[2]) < 57\n-\t  || REGNO (operands[3]) < 57\n-\t  || REGNO (operands[4]) < 57\n-\t  || REGNO (operands[5]) < 57))\n+      && (REGNO_REG_CLASS (REGNO (operands[0])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[1])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[2])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[3])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[4])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[5])) != FPUPPER_REGS))\n     return 0;\n \n   /* Passed.  Operands are suitable for fmpyadd.  */\n@@ -5755,12 +5755,12 @@ fmpysuboperands (operands)\n \n   /* SFmode limits the registers to the upper 32 of the 32bit FP regs.  */\n   if (mode == SFmode\n-      && (REGNO (operands[0]) < 57\n-\t  || REGNO (operands[1]) < 57\n-\t  || REGNO (operands[2]) < 57\n-\t  || REGNO (operands[3]) < 57\n-\t  || REGNO (operands[4]) < 57\n-\t  || REGNO (operands[5]) < 57))\n+      && (REGNO_REG_CLASS (REGNO (operands[0])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[1])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[2])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[3])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[4])) != FPUPPER_REGS\n+\t  || REGNO_REG_CLASS (REGNO (operands[5])) != FPUPPER_REGS))\n     return 0;\n \n   /* Passed.  Operands are suitable for fmpysub.  */"}, {"sha": "1a719f860f6c3ab536adfe8d97ce2bb5a5e0c25e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 10, "deletions": 314, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=88624c0e27076edb698e55393c6867357886e89c", "patch": "@@ -227,18 +227,6 @@ extern int target_flags;\n #define ASM_STABS_OP \"\\t.stabs\"\n #define ASM_STABN_OP \"\\t.stabn\"\n \n-/* How to renumber registers for dbx and gdb.\n-\n-   Registers 0  - 31 remain unchanged.\n-\n-   Registers 32 - 87 are mapped to 72 - 127\n-\n-   Register 88 is mapped to 32.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n-  ((REGNO) <= 31 ? (REGNO) :\t\t\t\t\t\t\\\n-   ((REGNO) > 31 && (REGNO) <= 87 ? (REGNO) + 40 : 32))\n-\n /* GDB always assumes the current function's frame begins at the value\n    of the stack pointer upon entry to the current function.  Accessing\n    local variables and parameters passed on the stack is done using the\n@@ -390,189 +378,6 @@ extern int target_flags;\n \n /* Generate calls to memcpy, memcmp and memset.  */\n #define TARGET_MEM_FUNCTIONS\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   HP-PA 1.0 has 32 fullword registers and 16 floating point\n-   registers. The floating point registers hold either word or double\n-   word values.\n-\n-   16 additional registers are reserved.\n-\n-   HP-PA 1.1 has 32 fullword registers and 32 floating point\n-   registers. However, the floating point registers behave\n-   differently: the left and right halves of registers are addressable\n-   as 32 bit registers. So, we will set things up like the 68k which\n-   has different fp units: define separate register sets for the 1.0\n-   and 1.1 fp units. */\n-\n-#define FIRST_PSEUDO_REGISTER 89  /* 32 general regs + 56 fp regs +\n-\t\t\t\t     + 1 shift reg */\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   On the HP-PA, these are:\n-   Reg 0\t= 0 (hardware). However, 0 is used for condition code,\n-                  so is not fixed.\n-   Reg 1\t= ADDIL target/Temporary (hardware).\n-   Reg 2\t= Return Pointer\n-   Reg 3\t= Frame Pointer\n-   Reg 4\t= Frame Pointer (>8k varying frame with HP compilers only)\n-   Reg 4-18\t= Preserved Registers\n-   Reg 19\t= Linkage Table Register in HPUX 8.0 shared library scheme.\n-   Reg 20-22\t= Temporary Registers\n-   Reg 23-26\t= Temporary/Parameter Registers\n-   Reg 27\t= Global Data Pointer (hp)\n-   Reg 28\t= Temporary/Return Value register\n-   Reg 29\t= Temporary/Static Chain/Return Value register #2\n-   Reg 30\t= stack pointer\n-   Reg 31\t= Temporary/Millicode Return Pointer (hp)\n-\n-   Freg 0-3\t= Status Registers\t -- Not known to the compiler.\n-   Freg 4-7\t= Arguments/Return Value\n-   Freg 8-11\t= Temporary Registers\n-   Freg 12-15\t= Preserved Registers\n-\n-   Freg 16-31\t= Reserved\n-\n-   On the Snake, fp regs are\n-\n-   Freg 0-3\t= Status Registers\t-- Not known to the compiler.\n-   Freg 4L-7R\t= Arguments/Return Value\n-   Freg 8L-11R\t= Temporary Registers\n-   Freg 12L-21R\t= Preserved Registers\n-   Freg 22L-31R = Temporary Registers\n-\n-*/\n-\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 1, 0, 0, 1, 0, \\\n-  /* fp registers */\t  \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n-  /* fp registers */\t  \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1}\n-\n-#define CONDITIONAL_REGISTER_USAGE \\\n-{\t\t\t\t\t\t\\\n-  if (!TARGET_PA_11)\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      for (i = 56; i < 88; i++) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-      for (i = 33; i < 88; i += 2) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    }\t\t\t\t\t\t\\\n-  if (TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\\\n-    {\t\t\t\t\t\t\\\n-      for (i = 32; i < 88; i++) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    }\t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-      fixed_regs[PIC_OFFSET_TABLE_REGNUM_SAVED] = 1;\\\n-    }\t\t\t\t\t\t\\\n-}\n-\n-/* Allocate the call used registers first.  This should minimize\n-   the number of registers that need to be saved (as call used\n-   registers will generally not be allocated across a call).\n-\n-   Experimentation has shown slightly better results by allocating\n-   FP registers first.  \n-\n-   FP registers are ordered so that all L registers are selected before\n-   R registers.  This works around a false dependency interlock on the\n-   PA8000 when accessing the high and low parts of an FP register\n-   independently.  */\n-\n-#define REG_ALLOC_ORDER \\\n- {\t\t\t\t\t\\\n-  /* caller-saved fp regs.  */\t\t\\\n-  68, 70, 72, 74, 76, 78, 80, 82,\t\\\n-  84, 86, 40, 42, 44, 46, 32, 34,\t\\\n-  36, 38,\t\t\t\t\\\n-  69, 71, 73, 75, 77, 79, 81, 83,\t\\\n-  85, 87, 41, 43, 45, 47, 33, 35,\t\\\n-  37, 39,\t\t\t\t\\\n-  /* caller-saved general regs.  */\t\\\n-  19, 20, 21, 22, 23, 24, 25, 26,\t\\\n-  27, 28, 29, 31,  2,\t\t\t\\\n-  /* callee-saved fp regs.  */\t\t\\\n-  48, 50, 52, 54, 56, 58, 60, 62,\t\\\n-  64, 66,\t\t\t\t\\\n-  49, 51, 53, 55, 57, 59, 61, 63,\t\\\n-  65, 67,\t\t\t\t\\\n-  /* callee-saved general regs.  */\t\\\n-   3,  4,  5,  6,  7,  8,  9, 10, \t\\\n-  11, 12, 13, 14, 15, 16, 17, 18,\t\\\n-  /* special registers.  */\t\t\\\n-   1, 30,  0, 88}\n-\n-\n-/* True if register is floating-point.  */\n-#define FP_REGNO_P(N) ((N) >= 32 && (N) <= 87)\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the HP-PA, ordinary registers hold 32 bits worth;\n-   The floating point registers are 64 bits wide. Snake fp regs are 32\n-   bits wide */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n-   ? (!TARGET_PA_11 ? 1 : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the HP-PA, the cpu registers can hold any mode.  We\n-   force this to be an even register is it cannot hold the full mode.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n-   /* On 1.0 machines, don't allow wide non-fp modes in fp regs. */\t\\\n-   : !TARGET_PA_11 && FP_REGNO_P (REGNO)\t\t\t\t\\\n-     ? GET_MODE_SIZE (MODE) <= 4 || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n-   : FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n-     ? GET_MODE_SIZE (MODE) <= 4 || ((REGNO) & 1) == 0\t\t\t\\\n-   /* Make wide modes be in aligned registers. */\t\t\t\\\n-   : GET_MODE_SIZE (MODE) <= UNITS_PER_WORD || ((REGNO) & 1) == 0)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -631,86 +436,6 @@ extern int target_flags;\n    is passed to a function.  */\n #define STRUCT_VALUE_REGNUM 28\n \f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-  /* The HP-PA has four kinds of registers: general regs, 1.0 fp regs,\n-     1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n-     fmpyadd and fmpysub are restricted.  */\n-\n-enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n-  SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n-  {\"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FPUPPER_REGS\", \"FP_REGS\", \\\n-   \"GENERAL_OR_FP_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n-   is in no class. */\n-\n-#define REG_CLASS_CONTENTS\t\\\n- {{0x00000000, 0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n-  {0x00000002, 0x00000000, 0x00000000},\t/* R1_REGS */\t\t\t\\\n-  {0xfffffffe, 0x00000000, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n-  {0x00000000, 0xff000000, 0x00ffffff},\t/* FPUPPER_REGS */\t\t\t\\\n-  {0x00000000, 0xffffffff, 0x00ffffff},\t/* FP_REGS */\t\t\t\\\n-  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n-  {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n-  {0xfffffffe, 0xffffffff, 0x01ffffff}}\t/* ALL_REGS */\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t\\\n-  ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n-   : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n-   : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n-   : (REGNO) < 56 ? FP_REGS\t\t\t\t\t\t\\\n-   : (REGNO) < 88 ? FPUPPER_REGS\t\t\t\t\t\t\\\n-   : SHIFT_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-#define FP_REG_CLASS_P(CLASS) \\\n-  ((CLASS) == FP_REGS || (CLASS) == FPUPPER_REGS)\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-/* Keep 'x' for backward compatibility with user asm.   */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'y' ? FPUPPER_REGS :\t\t\t\t\t\\\n-   (C) == 'x' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n-   (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n-   (C) == 'Z' ? ALL_REGS : NO_REGS)\n-\n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n    This macro defines what the ranges are.\n@@ -747,6 +472,16 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS, GENERAL_\n \t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n    : 0)\n \n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define FP_REG_CLASS_P(CLASS) \\\n+  ((CLASS) == FP_REGS || (CLASS) == FPUPPER_REGS)\n+\n+/* True if register is floating-point.  */\n+#define FP_REGNO_P(N) ((N) >= FP_REG_FIRST && (N) <= FP_REG_LAST)\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -773,13 +508,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS, GENERAL_\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n   gen_rtx_MEM (MODE, gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-16)))\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS || (CLASS) == FPUPPER_REGS\t\t\t\\\n-   ? (!TARGET_PA_11 ? 1 : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -855,7 +583,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS, GENERAL_\n /* On the HP-PA the value is found in register(s) 28(-29), unless\n    the mode is SF or DF. Then the value is returned in fr4 (32, ) */\n \n-\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), ((! TARGET_SOFT_FLOAT\t\t     \\\n \t\t\t\t      && (TYPE_MODE (VALTYPE) == SFmode ||  \\\n@@ -876,10 +603,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS, GENERAL_\n #define FUNCTION_VALUE_REGNO_P(N) \\\n   ((N) == 28 || (! TARGET_SOFT_FLOAT && (N) == 32))\n \n-/* 1 if N is a possible register number for function argument passing.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) \\\n-  (((N) >= 23 && (N) <= 26) || (! TARGET_SOFT_FLOAT && (N) >= 32 && (N) <= 39))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -1897,33 +1620,6 @@ while (0)\n \n #define ASM_APP_OFF \"\"\n \n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"%r0\",   \"%r1\",    \"%r2\",   \"%r3\",    \"%r4\",   \"%r5\",    \"%r6\",   \"%r7\",    \\\n- \"%r8\",   \"%r9\",    \"%r10\",  \"%r11\",   \"%r12\",  \"%r13\",   \"%r14\",  \"%r15\",   \\\n- \"%r16\",  \"%r17\",   \"%r18\",  \"%r19\",   \"%r20\",  \"%r21\",   \"%r22\",  \"%r23\",   \\\n- \"%r24\",  \"%r25\",   \"%r26\",  \"%r27\",   \"%r28\",  \"%r29\",   \"%r30\",  \"%r31\",   \\\n- \"%fr4\",  \"%fr4R\",  \"%fr5\",  \"%fr5R\",  \"%fr6\",  \"%fr6R\",  \"%fr7\",  \"%fr7R\",  \\\n- \"%fr8\",  \"%fr8R\",  \"%fr9\",  \"%fr9R\",  \"%fr10\", \"%fr10R\", \"%fr11\", \"%fr11R\", \\\n- \"%fr12\", \"%fr12R\", \"%fr13\", \"%fr13R\", \"%fr14\", \"%fr14R\", \"%fr15\", \"%fr15R\", \\\n- \"%fr16\", \"%fr16R\", \"%fr17\", \"%fr17R\", \"%fr18\", \"%fr18R\", \"%fr19\", \"%fr19R\", \\\n- \"%fr20\", \"%fr20R\", \"%fr21\", \"%fr21R\", \"%fr22\", \"%fr22R\", \"%fr23\", \"%fr23R\", \\\n- \"%fr24\", \"%fr24R\", \"%fr25\", \"%fr25R\", \"%fr26\", \"%fr26R\", \"%fr27\", \"%fr27R\", \\\n- \"%fr28\", \"%fr28R\", \"%fr29\", \"%fr29R\", \"%fr30\", \"%fr30R\", \"%fr31\", \"%fr31R\", \\\n- \"SAR\"}\n-\n-#define ADDITIONAL_REGISTER_NAMES \\\n-{{\"%fr4L\",32}, {\"%fr5L\",34}, {\"%fr6L\",36}, {\"%fr7L\",38},\t\t\\\n- {\"%fr8L\",40}, {\"%fr9L\",42}, {\"%fr10L\",44}, {\"%fr11L\",46},\t\t\\\n- {\"%fr12L\",48}, {\"%fr13L\",50}, {\"%fr14L\",52}, {\"%fr15L\",54},\t\t\\\n- {\"%fr16L\",56}, {\"%fr17L\",58}, {\"%fr18L\",60}, {\"%fr19L\",62},\t\t\\\n- {\"%fr20L\",64}, {\"%fr21L\",66}, {\"%fr22L\",68}, {\"%fr23L\",70},\t\t\\\n- {\"%fr24L\",72}, {\"%fr25L\",74}, {\"%fr26L\",76}, {\"%fr27L\",78},\t\t\\\n- {\"%fr28L\",80}, {\"%fr29L\",82}, {\"%fr30L\",84}, {\"%fr31R\",86},\t\t\\\n- {\"%cr11\",88}}\n-\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n "}, {"sha": "2f7e9e783c1af2e28454df6507641db5088c8cda", "filename": "gcc/config/pa/pa32-regs.h", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=88624c0e27076edb698e55393c6867357886e89c", "patch": "@@ -0,0 +1,316 @@\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   HP-PA 1.0 has 32 fullword registers and 16 floating point\n+   registers. The floating point registers hold either word or double\n+   word values.\n+\n+   16 additional registers are reserved.\n+\n+   HP-PA 1.1 has 32 fullword registers and 32 floating point\n+   registers. However, the floating point registers behave\n+   differently: the left and right halves of registers are addressable\n+   as 32 bit registers. So, we will set things up like the 68k which\n+   has different fp units: define separate register sets for the 1.0\n+   and 1.1 fp units. */\n+\n+#define FIRST_PSEUDO_REGISTER 89  /* 32 general regs + 56 fp regs +\n+\t\t\t\t     + 1 shift reg */\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On the HP-PA, these are:\n+   Reg 0\t= 0 (hardware). However, 0 is used for condition code,\n+                  so is not fixed.\n+   Reg 1\t= ADDIL target/Temporary (hardware).\n+   Reg 2\t= Return Pointer\n+   Reg 3\t= Frame Pointer\n+   Reg 4\t= Frame Pointer (>8k varying frame with HP compilers only)\n+   Reg 4-18\t= Preserved Registers\n+   Reg 19\t= Linkage Table Register in HPUX 8.0 shared library scheme.\n+   Reg 20-22\t= Temporary Registers\n+   Reg 23-26\t= Temporary/Parameter Registers\n+   Reg 27\t= Global Data Pointer (hp)\n+   Reg 28\t= Temporary/Return Value register\n+   Reg 29\t= Temporary/Static Chain/Return Value register #2\n+   Reg 30\t= stack pointer\n+   Reg 31\t= Temporary/Millicode Return Pointer (hp)\n+\n+   Freg 0-3\t= Status Registers\t -- Not known to the compiler.\n+   Freg 4-7\t= Arguments/Return Value\n+   Freg 8-11\t= Temporary Registers\n+   Freg 12-15\t= Preserved Registers\n+\n+   Freg 16-31\t= Reserved\n+\n+   On the Snake, fp regs are\n+\n+   Freg 0-3\t= Status Registers\t-- Not known to the compiler.\n+   Freg 4L-7R\t= Arguments/Return Value\n+   Freg 8L-11R\t= Temporary Registers\n+   Freg 12L-21R\t= Preserved Registers\n+   Freg 22L-31R = Temporary Registers\n+\n+*/\n+\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 1, 0, 0, 1, 0, \\\n+  /* fp registers */\t  \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  /* fp registers */\t  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1}\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{\t\t\t\t\t\t\\\n+  if (!TARGET_PA_11)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      for (i = 56; i < 88; i++) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+      for (i = 33; i < 88; i += 2) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n+  if (TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\\\n+    {\t\t\t\t\t\t\\\n+      for (i = 32; i < 88; i++) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM_SAVED] = 1;\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+/* Allocate the call used registers first.  This should minimize\n+   the number of registers that need to be saved (as call used\n+   registers will generally not be allocated across a call).\n+\n+   Experimentation has shown slightly better results by allocating\n+   FP registers first.  \n+\n+   FP registers are ordered so that all L registers are selected before\n+   R registers.  This works around a false dependency interlock on the\n+   PA8000 when accessing the high and low parts of an FP register\n+   independently.  */\n+\n+#define REG_ALLOC_ORDER \\\n+ {\t\t\t\t\t\\\n+  /* caller-saved fp regs.  */\t\t\\\n+  68, 70, 72, 74, 76, 78, 80, 82,\t\\\n+  84, 86, 40, 42, 44, 46, 32, 34,\t\\\n+  36, 38,\t\t\t\t\\\n+  69, 71, 73, 75, 77, 79, 81, 83,\t\\\n+  85, 87, 41, 43, 45, 47, 33, 35,\t\\\n+  37, 39,\t\t\t\t\\\n+  /* caller-saved general regs.  */\t\\\n+  19, 20, 21, 22, 23, 24, 25, 26,\t\\\n+  27, 28, 29, 31,  2,\t\t\t\\\n+  /* callee-saved fp regs.  */\t\t\\\n+  48, 50, 52, 54, 56, 58, 60, 62,\t\\\n+  64, 66,\t\t\t\t\\\n+  49, 51, 53, 55, 57, 59, 61, 63,\t\\\n+  65, 67,\t\t\t\t\\\n+  /* callee-saved general regs.  */\t\\\n+   3,  4,  5,  6,  7,  8,  9, 10, \t\\\n+  11, 12, 13, 14, 15, 16, 17, 18,\t\\\n+  /* special registers.  */\t\t\\\n+   1, 30,  0, 88}\n+\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the HP-PA, ordinary registers hold 32 bits worth;\n+   The floating point registers are 64 bits wide. Snake fp regs are 32\n+   bits wide */\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+  (FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n+   ? (!TARGET_PA_11 ? 1 : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the HP-PA, the cpu registers can hold any mode.  We\n+   force this to be an even register is it cannot hold the full mode.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n+   /* On 1.0 machines, don't allow wide non-fp modes in fp regs. */\t\\\n+   : !TARGET_PA_11 && FP_REGNO_P (REGNO)\t\t\t\t\\\n+     ? GET_MODE_SIZE (MODE) <= 4 || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+   : FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n+     ? GET_MODE_SIZE (MODE) <= 4 || ((REGNO) & 1) == 0\t\t\t\\\n+   /* Make wide modes be in aligned registers. */\t\t\t\\\n+   : (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\t\t\\\n+      || GET_MODE_SIZE (MODE) <= 2 * UNITS_PER_WORD && ((REGNO) & 1) == 0))\n+\n+/* How to renumber registers for dbx and gdb.\n+\n+   Registers 0  - 31 remain unchanged.\n+\n+   Registers 32 - 87 are mapped to 72 - 127\n+\n+   Register 88 is mapped to 32.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  ((REGNO) <= 31 ? (REGNO) :\t\t\t\t\t\t\\\n+   ((REGNO) > 31 && (REGNO) <= 87 ? (REGNO) + 40 : 32))\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+  /* The HP-PA has four kinds of registers: general regs, 1.0 fp regs,\n+     1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n+     fmpyadd and fmpysub are restricted.  */\n+\n+enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n+\t\t GENERAL_OR_FP_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+  {\"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FPUPPER_REGS\", \"FP_REGS\", \\\n+   \"GENERAL_OR_FP_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n+   is in no class. */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+ {{0x00000000, 0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n+  {0x00000002, 0x00000000, 0x00000000},\t/* R1_REGS */\t\t\t\\\n+  {0xfffffffe, 0x00000000, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n+  {0x00000000, 0xff000000, 0x00ffffff},\t/* FPUPPER_REGS */\t\t\\\n+  {0x00000000, 0xffffffff, 0x00ffffff},\t/* FP_REGS */\t\t\t\\\n+  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* GENERAL_OR_FP_REGS */\t\\\n+  {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n+  {0xfffffffe, 0xffffffff, 0x01ffffff}}\t/* ALL_REGS */\n+\n+/* This may not actually be necessary anymore.  But until I can prove\n+   otherwise it will stay.  */\n+#define CLASS_CANNOT_CHANGE_SIZE NO_REGS\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t\\\n+  ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n+   : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n+   : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n+   : (REGNO) < 56 ? FP_REGS\t\t\t\t\t\t\\\n+   : (REGNO) < 88 ? FPUPPER_REGS\t\t\t\t\t\\\n+   : (REGNO) < 88 ? FPUPPER_REGS\t\t\t\t\t\\\n+   : SHIFT_REGS)\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+/* Keep 'x' for backward compatibility with user asm.   */\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS :\t\t\t\t\t\\\n+   (C) == 'y' ? FPUPPER_REGS :\t\t\t\t\t\\\n+   (C) == 'y' ? FPUPPER_REGS :\t\t\t\t\t\\\n+   (C) == 'x' ? FP_REGS :\t\t\t\t\t\\\n+   (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n+   (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n+   (C) == 'Z' ? ALL_REGS : NO_REGS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  ((CLASS) == FP_REGS || (CLASS) == FPUPPER_REGS\t\t\t\\\n+   ? (!TARGET_PA_11 ? 1 : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  (((N) >= 23 && (N) <= 26) || (! TARGET_SOFT_FLOAT && (N) >= 32 && (N) <= 39)) \n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"%r0\",   \"%r1\",    \"%r2\",   \"%r3\",    \"%r4\",   \"%r5\",    \"%r6\",   \"%r7\",    \\\n+ \"%r8\",   \"%r9\",    \"%r10\",  \"%r11\",   \"%r12\",  \"%r13\",   \"%r14\",  \"%r15\",   \\\n+ \"%r16\",  \"%r17\",   \"%r18\",  \"%r19\",   \"%r20\",  \"%r21\",   \"%r22\",  \"%r23\",   \\\n+ \"%r24\",  \"%r25\",   \"%r26\",  \"%r27\",   \"%r28\",  \"%r29\",   \"%r30\",  \"%r31\",   \\\n+ \"%fr4\",  \"%fr4R\",  \"%fr5\",  \"%fr5R\",  \"%fr6\",  \"%fr6R\",  \"%fr7\",  \"%fr7R\",  \\\n+ \"%fr8\",  \"%fr8R\",  \"%fr9\",  \"%fr9R\",  \"%fr10\", \"%fr10R\", \"%fr11\", \"%fr11R\", \\\n+ \"%fr12\", \"%fr12R\", \"%fr13\", \"%fr13R\", \"%fr14\", \"%fr14R\", \"%fr15\", \"%fr15R\", \\\n+ \"%fr16\", \"%fr16R\", \"%fr17\", \"%fr17R\", \"%fr18\", \"%fr18R\", \"%fr19\", \"%fr19R\", \\\n+ \"%fr20\", \"%fr20R\", \"%fr21\", \"%fr21R\", \"%fr22\", \"%fr22R\", \"%fr23\", \"%fr23R\", \\\n+ \"%fr24\", \"%fr24R\", \"%fr25\", \"%fr25R\", \"%fr26\", \"%fr26R\", \"%fr27\", \"%fr27R\", \\\n+ \"%fr28\", \"%fr28R\", \"%fr29\", \"%fr29R\", \"%fr30\", \"%fr30R\", \"%fr31\", \"%fr31R\", \\\n+ \"SAR\"}\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{{\"%fr4L\",32}, {\"%fr5L\",34}, {\"%fr6L\",36}, {\"%fr7L\",38},\t\t\\\n+ {\"%fr8L\",40}, {\"%fr9L\",42}, {\"%fr10L\",44}, {\"%fr11L\",46},\t\t\\\n+ {\"%fr12L\",48}, {\"%fr13L\",50}, {\"%fr14L\",52}, {\"%fr15L\",54},\t\t\\\n+ {\"%fr16L\",56}, {\"%fr17L\",58}, {\"%fr18L\",60}, {\"%fr19L\",62},\t\t\\\n+ {\"%fr20L\",64}, {\"%fr21L\",66}, {\"%fr22L\",68}, {\"%fr23L\",70},\t\t\\\n+ {\"%fr24L\",72}, {\"%fr25L\",74}, {\"%fr26L\",76}, {\"%fr27L\",78},\t\t\\\n+ {\"%fr28L\",80}, {\"%fr29L\",82}, {\"%fr30L\",84}, {\"%fr31R\",86},\t\t\\\n+ {\"%cr11\",88}}\n+\n+#define FP_SAVED_REG_LAST 66\n+#define FP_SAVED_REG_FIRST 48\n+#define FP_REG_STEP 2\n+#define FP_REG_FIRST 32\n+#define FP_REG_LAST 87"}, {"sha": "fea9b3f1beebfc8d22390d3f75ebaa4f49a49d7a", "filename": "gcc/configure", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=88624c0e27076edb698e55393c6867357886e89c", "patch": "@@ -3638,36 +3638,36 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-pro*)\n \t\ttarget_cpu_default=\"(MASK_JUMP_IN_DELAY | MASK_PORTABLE_RUNTIME | MASK_GAS | MASK_NO_SPACE_REGS | MASK_SOFT_FLOAT)\"\n-\t\ttm_file=\"${tm_file} elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h\"\n \t\txm_file=pa/xm-papro.h\n \t\ttmake_file=pa/t-pro\n \t\t;;\n \thppa1.1-*-osf*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-osf.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-osf.h\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.1-*-rtems*)\n \t\ttarget_cpu_default=\"(MASK_JUMP_IN_DELAY | MASK_PORTABLE_RUNTIME | MASK_GAS | MASK_NO_SPACE_REGS | MASK_SOFT_FLOAT)\"\n-\t\ttm_file=\"${tm_file} elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h pa/rtems.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h pa/rtems.h\"\n \t\txm_file=pa/xm-papro.h\n \t\ttmake_file=pa/t-pro\n \t\t;;\n \thppa1.0-*-osf*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-osf.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-osf.h\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.1-*-bsd*)\n-\t\ttm_file=\"${tm_file} pa/som.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h\"\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-bsd*)\n-\t\ttm_file=\"${tm_file} pa/som.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux7*)\n-\t\ttm_file=\"pa/pa-oldas.h ${tm_file} pa/som.h pa/pa-hpux7.h\"\n+\t\ttm_file=\"pa/pa-oldas.h ${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux7.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3678,7 +3678,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux8.0[0-2]*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3692,7 +3692,7 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-hpux8.0[0-2]*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3706,7 +3706,7 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-hpux8*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3717,7 +3717,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux8*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3729,7 +3729,7 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-hpux10* | hppa2*-*-hpux10*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -3749,7 +3749,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux10*)\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -3770,7 +3770,7 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-hpux11* | hppa2*-*-hpux11*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -3790,7 +3790,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux11*)\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -3810,7 +3810,7 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-hpux* | hppa2*-*-hpux*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3821,7 +3821,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3833,7 +3833,7 @@ for machine in $build $host $target; do\n \t\t;;\n \thppa1.1-*-hiux* | hppa2*-*-hiux*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3844,7 +3844,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hiux*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -3855,7 +3855,7 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \thppa*-*-lites*)\n-\t\ttm_file=\"${tm_file} elfos.h pa/elf.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h elfos.h pa/elf.h\"\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n \t\tuse_collect2=yes\n \t\t;;"}, {"sha": "4a38a5e0a9ce6ec58faa22f35f2b871688b79d45", "filename": "gcc/configure.in", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88624c0e27076edb698e55393c6867357886e89c/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=88624c0e27076edb698e55393c6867357886e89c", "patch": "@@ -902,36 +902,36 @@ changequote([,])dnl\n \t\t;;\n \thppa1.1-*-pro*)\n \t\ttarget_cpu_default=\"(MASK_JUMP_IN_DELAY | MASK_PORTABLE_RUNTIME | MASK_GAS | MASK_NO_SPACE_REGS | MASK_SOFT_FLOAT)\"\n-\t\ttm_file=\"${tm_file} elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h\"\n \t\txm_file=pa/xm-papro.h\n \t\ttmake_file=pa/t-pro\n \t\t;;\n \thppa1.1-*-osf*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-osf.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-osf.h\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.1-*-rtems*)\n \t\ttarget_cpu_default=\"(MASK_JUMP_IN_DELAY | MASK_PORTABLE_RUNTIME | MASK_GAS | MASK_NO_SPACE_REGS | MASK_SOFT_FLOAT)\"\n-\t\ttm_file=\"${tm_file} elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h pa/rtems.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h elfos.h pa/elf.h pa/pa-pro-end.h libgloss.h pa/rtems.h\"\n \t\txm_file=pa/xm-papro.h\n \t\ttmake_file=pa/t-pro\n \t\t;;\n \thppa1.0-*-osf*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-osf.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-osf.h\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.1-*-bsd*)\n-\t\ttm_file=\"${tm_file} pa/som.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h\"\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-bsd*)\n-\t\ttm_file=\"${tm_file} pa/som.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h\"\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux7*)\n-\t\ttm_file=\"pa/pa-oldas.h ${tm_file} pa/som.h pa/pa-hpux7.h\"\n+\t\ttm_file=\"pa/pa-oldas.h ${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux7.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -944,7 +944,7 @@ changequote([,])dnl\n changequote(,)dnl\n \thppa1.0-*-hpux8.0[0-2]*)\n changequote([,])dnl\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -960,7 +960,7 @@ changequote(,)dnl\n \thppa1.1-*-hpux8.0[0-2]*)\n changequote([,])dnl\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -974,7 +974,7 @@ changequote([,])dnl\n \t\t;;\n \thppa1.1-*-hpux8*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -985,7 +985,7 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux8*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -997,7 +997,7 @@ changequote([,])dnl\n \t\t;;\n \thppa1.1-*-hpux10* | hppa2*-*-hpux10*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -1017,7 +1017,7 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux10*)\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -1038,7 +1038,7 @@ changequote([,])dnl\n \t\t;;\n \thppa1.1-*-hpux11* | hppa2*-*-hpux11*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -1058,7 +1058,7 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux11*)\n-\t\ttm_file=\"${tm_file} pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux11.h\"\n \t\tfloat_format=i128\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n@@ -1078,7 +1078,7 @@ changequote([,])dnl\n \t\t;;\n \thppa1.1-*-hpux* | hppa2*-*-hpux*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -1089,7 +1089,7 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hpux*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -1101,7 +1101,7 @@ changequote([,])dnl\n \t\t;;\n \thppa1.1-*-hiux* | hppa2*-*-hiux*)\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -1112,7 +1112,7 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \thppa1.0-*-hiux*)\n-\t\ttm_file=\"${tm_file} pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n \t\txm_file=pa/xm-pahpux.h\n \t\txmake_file=pa/x-pa-hpux\n \t\tif test x$gas = xyes\n@@ -1123,7 +1123,7 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \thppa*-*-lites*)\n-\t\ttm_file=\"${tm_file} elfos.h pa/elf.h\"\n+\t\ttm_file=\"${tm_file} pa/pa32-regs.h elfos.h pa/elf.h\"\n \t\ttarget_cpu_default=\"MASK_PA_11\"\n \t\tuse_collect2=yes\n \t\t;;"}]}