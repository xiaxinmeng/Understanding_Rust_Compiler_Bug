{"sha": "b7d1d8b460bcc996883f2aa089d49598736620a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkMWQ4YjQ2MGJjYzk5Njg4M2YyYWEwODlkNDk1OTg3MzY2MjBhNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-31T12:05:22Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-31T12:05:22Z"}, "message": "re PR fortran/38324 (Wrong lbound given to allocatable components)\n\n2010-01-31  Paul Thomas  <pault@gcc.gnu.org>\n\n        PR fortran/38324\n\t* expr.c (gfc_get_full_arrayspec_from_expr): New function.\n\t* gfortran.h : Add prototype for above.\n        * trans-expr.c (gfc_trans_alloc_subarray_assign): New function.\n\t(gfc_trans_subcomponent_assign): Call new function to replace\n\tthe code to deal with allocatable components.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Call\n\tgfc_get_full_arrayspec_from_expr to replace existing code.\n\n2010-01-31  Paul Thomas  <pault@gcc.gnu.org>\n\n        PR fortran/38324\n        * gfortran.dg/alloc_comp_basics_1.f90: Remove option -O2.\n        * gfortran.dg/alloc_comp_bounds_1.f90: New test.\n\nFrom-SVN: r156399", "tree": {"sha": "c8dec18636f40d47646ddb667f434ea8cb76305e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8dec18636f40d47646ddb667f434ea8cb76305e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7d1d8b460bcc996883f2aa089d49598736620a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d1d8b460bcc996883f2aa089d49598736620a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d1d8b460bcc996883f2aa089d49598736620a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d1d8b460bcc996883f2aa089d49598736620a5/comments", "author": null, "committer": null, "parents": [{"sha": "9b7b903efdb5a1a1b15c2a5c87618a67c36f82fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7b903efdb5a1a1b15c2a5c87618a67c36f82fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7b903efdb5a1a1b15c2a5c87618a67c36f82fa"}], "stats": {"total": 389, "additions": 267, "deletions": 122}, "files": [{"sha": "f313736ffcbee81c576929a3d0e9d4eee078da95", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -1,3 +1,14 @@\n+2010-01-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+        PR fortran/38324\n+\t* expr.c (gfc_get_full_arrayspec_from_expr): New function.\n+\t* gfortran.h : Add prototype for above.\n+        * trans-expr.c (gfc_trans_alloc_subarray_assign): New function.\n+\t(gfc_trans_subcomponent_assign): Call new function to replace\n+\tthe code to deal with allocatable components.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Call\n+\tgfc_get_full_arrayspec_from_expr to replace existing code.\n+\n 2010-01-25  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/42858"}, {"sha": "6d3ca8476b8b3d2359ff20fb347f21988ff6fc3d", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -3489,6 +3489,58 @@ gfc_get_variable_expr (gfc_symtree *var)\n }\n \n \n+/* Returns the array_spec of a full array expression.  A NULL is\n+   returned otherwise.  */\n+gfc_array_spec *\n+gfc_get_full_arrayspec_from_expr (gfc_expr *expr)\n+{\n+  gfc_array_spec *as;\n+  gfc_ref *ref;\n+\n+  if (expr->rank == 0)\n+    return NULL;\n+\n+  /* Follow any component references.  */\n+  if (expr->expr_type == EXPR_VARIABLE\n+      || expr->expr_type == EXPR_CONSTANT)\n+    {\n+      as = expr->symtree->n.sym->as;\n+      for (ref = expr->ref; ref; ref = ref->next)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_COMPONENT:\n+\t      as = ref->u.c.component->as;\n+\t      continue;\n+\n+\t    case REF_SUBSTRING:\n+\t      continue;\n+\n+\t    case REF_ARRAY:\n+\t      {\n+\t\tswitch (ref->u.ar.type)\n+\t\t  {\n+\t\t  case AR_ELEMENT:\n+\t\t  case AR_SECTION:\n+\t\t  case AR_UNKNOWN:\n+\t\t    as = NULL;\n+\t\t    continue;\n+\n+\t\t  case AR_FULL:\n+\t\t    break;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    }\n+\t}\n+    }\n+  else\n+    as = NULL;\n+\n+  return as;\n+}\n+\n+\n /* General expression traversal function.  */\n \n bool"}, {"sha": "5b8f9c104e5112a64e3cb600f45b0137df7d6d66", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -2616,6 +2616,8 @@ gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n gfc_expr *gfc_default_initializer (gfc_typespec *);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n \n+gfc_array_spec *gfc_get_full_arrayspec_from_expr (gfc_expr *expr);\n+\n bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n \t\t\tbool (*)(gfc_expr *, gfc_symbol *, int*),\n \t\t\tint);"}, {"sha": "95ae8138867b8b56a93d0357b7a79867153cbca6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 144, "deletions": 84, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -4045,6 +4045,149 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n }\n \n \n+static tree\n+gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n+\t\t\t\t gfc_expr * expr)\n+{\n+  gfc_se se;\n+  gfc_ss *rss;\n+  stmtblock_t block;\n+  tree offset;\n+  int n;\n+  tree tmp;\n+  tree tmp2;\n+  gfc_array_spec *as;\n+  gfc_expr *arg = NULL;\n+\n+  gfc_start_block (&block);\n+  gfc_init_se (&se, NULL);\n+\n+  /* Get the descriptor for the expressions.  */ \n+  rss = gfc_walk_expr (expr);\n+  se.want_pointer = 0;\n+  gfc_conv_expr_descriptor (&se, expr, rss);\n+  gfc_add_block_to_block (&block, &se.pre);\n+  gfc_add_modify (&block, dest, se.expr);\n+\n+  /* Deal with arrays of derived types with allocatable components.  */\n+  if (cm->ts.type == BT_DERIVED\n+\t&& cm->ts.u.derived->attr.alloc_comp)\n+    tmp = gfc_copy_alloc_comp (cm->ts.u.derived,\n+\t\t\t       se.expr, dest,\n+\t\t\t       cm->as->rank);\n+  else\n+    tmp = gfc_duplicate_allocatable (dest, se.expr,\n+\t\t\t\t     TREE_TYPE(cm->backend_decl),\n+\t\t\t\t     cm->as->rank);\n+\n+  gfc_add_expr_to_block (&block, tmp);\n+  gfc_add_block_to_block (&block, &se.post);\n+\n+  if (expr->expr_type != EXPR_VARIABLE)\n+    gfc_conv_descriptor_data_set (&block, se.expr,\n+\t\t\t\t  null_pointer_node);\n+\n+  /* We need to know if the argument of a conversion function is a\n+     variable, so that the correct lower bound can be used.  */\n+  if (expr->expr_type == EXPR_FUNCTION\n+\t&& expr->value.function.isym\n+\t&& expr->value.function.isym->conversion\n+\t&& expr->value.function.actual->expr\n+\t&& expr->value.function.actual->expr->expr_type == EXPR_VARIABLE)\n+    arg = expr->value.function.actual->expr;\n+\n+  /* Obtain the array spec of full array references.  */\n+  if (arg)\n+    as = gfc_get_full_arrayspec_from_expr (arg);\n+  else\n+    as = gfc_get_full_arrayspec_from_expr (expr);\n+\n+  /* Shift the lbound and ubound of temporaries to being unity,\n+     rather than zero, based. Always calculate the offset.  */\n+  offset = gfc_conv_descriptor_offset_get (dest);\n+  gfc_add_modify (&block, offset, gfc_index_zero_node);\n+  tmp2 =gfc_create_var (gfc_array_index_type, NULL);\n+\n+  for (n = 0; n < expr->rank; n++)\n+    {\n+      tree span;\n+      tree lbound;\n+\n+      /* Obtain the correct lbound - ISO/IEC TR 15581:2001 page 9.\n+\t TODO It looks as if gfc_conv_expr_descriptor should return\n+\t the correct bounds and that the following should not be\n+\t necessary.  This would simplify gfc_conv_intrinsic_bound\n+\t as well.  */\n+      if (as && as->lower[n])\n+\t{\n+\t  gfc_se lbse;\n+\t  gfc_init_se (&lbse, NULL);\n+\t  gfc_conv_expr (&lbse, as->lower[n]);\n+\t  gfc_add_block_to_block (&block, &lbse.pre);\n+\t  lbound = gfc_evaluate_now (lbse.expr, &block);\n+\t}\n+      else if (as && arg)\n+\t{\n+\t  tmp = gfc_get_symbol_decl (arg->symtree->n.sym);\n+\t  lbound = gfc_conv_descriptor_lbound_get (tmp,\n+\t\t\t\t\tgfc_rank_cst[n]);\n+\t}\n+      else if (as)\n+\tlbound = gfc_conv_descriptor_lbound_get (dest,\n+\t\t\t\t\t\tgfc_rank_cst[n]);\n+      else\n+\tlbound = gfc_index_one_node;\n+\n+      lbound = fold_convert (gfc_array_index_type, lbound);\n+\n+      /* Shift the bounds and set the offset accordingly.  */\n+      tmp = gfc_conv_descriptor_ubound_get (dest, gfc_rank_cst[n]);\n+      span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,\n+\t\tgfc_conv_descriptor_lbound_get (dest, gfc_rank_cst[n]));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, span, lbound);\n+      gfc_conv_descriptor_ubound_set (&block, dest,\n+\t\t\t\t      gfc_rank_cst[n], tmp);\n+      gfc_conv_descriptor_lbound_set (&block, dest,\n+\t\t\t\t      gfc_rank_cst[n], lbound);\n+\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t gfc_conv_descriptor_lbound_get (dest,\n+\t\t\t\t\t\t\t gfc_rank_cst[n]),\n+\t\t\t gfc_conv_descriptor_stride_get (dest,\n+\t\t\t\t\t\t\t gfc_rank_cst[n]));\n+      gfc_add_modify (&block, tmp2, tmp);\n+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n+      gfc_conv_descriptor_offset_set (&block, dest, tmp);\n+    }\n+\n+  if (arg)\n+    {\n+      /* If a conversion expression has a null data pointer\n+\t argument, nullify the allocatable component.  */\n+      tree non_null_expr;\n+      tree null_expr;\n+\n+      if (arg->symtree->n.sym->attr.allocatable\n+\t    || arg->symtree->n.sym->attr.pointer)\n+\t{\n+\t  non_null_expr = gfc_finish_block (&block);\n+\t  gfc_start_block (&block);\n+\t  gfc_conv_descriptor_data_set (&block, dest,\n+\t\t\t\t\tnull_pointer_node);\n+\t  null_expr = gfc_finish_block (&block);\n+\t  tmp = gfc_conv_descriptor_data_get (arg->symtree->n.sym->backend_decl);\n+\t  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,\n+\t\t\tfold_convert (TREE_TYPE (tmp),\n+\t\t\t\t      null_pointer_node));\n+\t  return build3_v (COND_EXPR, tmp,\n+\t\t\t   null_expr, non_null_expr);\n+\t}\n+    }\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Assign a single component of a derived type constructor.  */\n \n static tree\n@@ -4055,8 +4198,6 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n   gfc_ss *rss;\n   stmtblock_t block;\n   tree tmp;\n-  tree offset;\n-  int n;\n \n   gfc_start_block (&block);\n \n@@ -4103,89 +4244,8 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n  \tgfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n       else if (cm->attr.allocatable)\n \t{\n-\t  tree tmp2;\n-\n-          gfc_init_se (&se, NULL);\n- \n-\t  rss = gfc_walk_expr (expr);\n-\t  se.want_pointer = 0;\n-\t  gfc_conv_expr_descriptor (&se, expr, rss);\n-\t  gfc_add_block_to_block (&block, &se.pre);\n-\t  gfc_add_modify (&block, dest, se.expr);\n-\n-\t  if (cm->ts.type == BT_DERIVED && cm->ts.u.derived->attr.alloc_comp)\n-\t    tmp = gfc_copy_alloc_comp (cm->ts.u.derived, se.expr, dest,\n-\t\t\t\t       cm->as->rank);\n-\t  else\n-\t    tmp = gfc_duplicate_allocatable (dest, se.expr,\n-\t\t\t\t\t     TREE_TYPE(cm->backend_decl),\n-\t\t\t\t\t     cm->as->rank);\n-\n+\t  tmp = gfc_trans_alloc_subarray_assign (dest, cm, expr);\n \t  gfc_add_expr_to_block (&block, tmp);\n-\t  gfc_add_block_to_block (&block, &se.post);\n-\n-\t  if (expr->expr_type != EXPR_VARIABLE)\n-\t    gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);\n-\n-\t  /* Shift the lbound and ubound of temporaries to being unity, rather\n-\t     than zero, based.  Calculate the offset for all cases.  */\n-\t  offset = gfc_conv_descriptor_offset_get (dest);\n-\t  gfc_add_modify (&block, offset, gfc_index_zero_node);\n-\t  tmp2 =gfc_create_var (gfc_array_index_type, NULL);\n-\t  for (n = 0; n < expr->rank; n++)\n-\t    {\n-\t      if (expr->expr_type != EXPR_VARIABLE\n-\t\t    && expr->expr_type != EXPR_CONSTANT)\n-\t\t{\n-\t\t  tree span;\n-\t\t  tmp = gfc_conv_descriptor_ubound_get (dest, gfc_rank_cst[n]);\n-\t\t  span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,\n-\t\t\t    gfc_conv_descriptor_lbound_get (dest, gfc_rank_cst[n]));\n-\t\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     span, gfc_index_one_node);\n-\t\t  gfc_conv_descriptor_ubound_set (&block, dest, gfc_rank_cst[n],\n-\t\t\t\t\t\t  tmp);\n-\t\t  gfc_conv_descriptor_lbound_set (&block, dest, gfc_rank_cst[n],\n-\t\t\t\t\t\t  gfc_index_one_node);\n-\t\t}\n-\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t gfc_conv_descriptor_lbound_get (dest,\n-\t\t\t\t\t\t\t     gfc_rank_cst[n]),\n-\t\t\t\t gfc_conv_descriptor_stride_get (dest,\n-\t\t\t\t\t\t\t     gfc_rank_cst[n]));\n-\t      gfc_add_modify (&block, tmp2, tmp);\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n-\t      gfc_conv_descriptor_offset_set (&block, dest, tmp);\n-\t    }\n-\n-\t  if (expr->expr_type == EXPR_FUNCTION\n-\t\t&& expr->value.function.isym\n-\t\t&& expr->value.function.isym->conversion\n-\t\t&& expr->value.function.actual->expr\n-\t\t&& expr->value.function.actual->expr->expr_type\n-\t\t\t\t\t\t== EXPR_VARIABLE)\n-\t    {\n-\t      /* If a conversion expression has a null data pointer\n-\t\t argument, nullify the allocatable component.  */\n-\t      gfc_symbol *s;\n-\t      tree non_null_expr;\n-\t      tree null_expr;\n-\t      s = expr->value.function.actual->expr->symtree->n.sym;\n-\t      if (s->attr.allocatable || s->attr.pointer)\n-\t\t{\n-\t\t  non_null_expr = gfc_finish_block (&block);\n-\t\t  gfc_start_block (&block);\n-\t\t  gfc_conv_descriptor_data_set (&block, dest,\n-\t\t\t\t\t\tnull_pointer_node);\n-\t\t  null_expr = gfc_finish_block (&block);\n-\t\t  tmp = gfc_conv_descriptor_data_get (s->backend_decl);\n-\t\t  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,\n-\t\t\t        fold_convert (TREE_TYPE (tmp),\n-\t\t\t\t\t      null_pointer_node));\n-\t\t  return build3_v (COND_EXPR, tmp, null_expr,\n-\t\t\t\t   non_null_expr);\n-\t\t}\n-\t    }\n \t}\n       else\n \t{"}, {"sha": "62bf146b64d76b9b87edc1023bc6b8f5cf81738b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -838,7 +838,6 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   gfc_se argse;\n   gfc_ss *ss;\n   gfc_array_spec * as;\n-  gfc_ref *ref;\n \n   arg = expr->value.function.actual;\n   arg2 = arg->next;\n@@ -907,42 +906,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   ubound = gfc_conv_descriptor_ubound_get (desc, bound);\n   lbound = gfc_conv_descriptor_lbound_get (desc, bound);\n   \n-  /* Follow any component references.  */\n-  if (arg->expr->expr_type == EXPR_VARIABLE\n-      || arg->expr->expr_type == EXPR_CONSTANT)\n-    {\n-      as = arg->expr->symtree->n.sym->as;\n-      for (ref = arg->expr->ref; ref; ref = ref->next)\n-\t{\n-\t  switch (ref->type)\n-\t    {\n-\t    case REF_COMPONENT:\n-\t      as = ref->u.c.component->as;\n-\t      continue;\n-\n-\t    case REF_SUBSTRING:\n-\t      continue;\n-\n-\t    case REF_ARRAY:\n-\t      {\n-\t\tswitch (ref->u.ar.type)\n-\t\t  {\n-\t\t  case AR_ELEMENT:\n-\t\t  case AR_SECTION:\n-\t\t  case AR_UNKNOWN:\n-\t\t    as = NULL;\n-\t\t    continue;\n-\n-\t\t  case AR_FULL:\n-\t\t    break;\n-\t\t  }\n-\t\tbreak;\n-\t      }\n-\t    }\n-\t}\n-    }\n-  else\n-    as = NULL;\n+  as = gfc_get_full_arrayspec_from_expr (arg->expr);\n \n   /* 13.14.53: Result value for LBOUND\n "}, {"sha": "8257646e9a5b0d357f885e6a2543b8d870cc62bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -1,3 +1,9 @@\n+2010-01-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+        PR fortran/38324\n+        * gfortran.dg/alloc_comp_basics_1.f90: Remove option -O2.\n+        * gfortran.dg/alloc_comp_bounds_1.f90: New test.\n+\n 2010-01-30  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* g++.dg/tree-ssa/inline-1.C: New."}, {"sha": "15cf7cf710fff670bdafc333a2299be57fdcfdaf", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-O2 -fdump-tree-original\" }\n+! { dg-options \"-fdump-tree-original\" }\n !\n ! Check some basic functionality of allocatable components, including that they\n ! are nullified when created and automatically deallocated when"}, {"sha": "28ad177e5a986ab8d1743e8820805f2d75e2b847", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d1d8b460bcc996883f2aa089d49598736620a5/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_bounds_1.f90?ref=b7d1d8b460bcc996883f2aa089d49598736620a5", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+! Test the fix for PR38324, in which the bounds were not set correctly for\n+! constructor assignments with allocatable components.\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!\n+  integer, parameter :: ik4 = 4\n+  integer, parameter :: ik8 = 8\n+  integer, parameter :: from = -1, to = 2\n+  call foo\n+  call bar\n+contains\n+  subroutine foo\n+    type :: struct\n+      integer(4), allocatable :: ib(:)\n+    end type struct\n+    integer(ik4), allocatable :: ia(:)\n+    type(struct) :: x\n+    allocate(ia(from:to))\n+    if (any(lbound(ia) .ne. -1) .or. any(ubound(ia) .ne. 2)) call abort\n+    if (any(lbound(ia(:)) .ne. 1) .or. any(ubound(ia(:)) .ne. 4)) call abort\n+    if (any(lbound(ia(from:to)) .ne. 1) .or. any(ubound(ia(from:to)) .ne. 4)) call abort\n+    x=struct(ia)\n+    if (any(lbound(x%ib) .ne. -1) .or. any(ubound(x%ib) .ne. 2)) call abort\n+    x=struct(ia(:))\n+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort\n+    x=struct(ia(from:to))\n+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort\n+    deallocate(ia)\n+  end subroutine\n+  subroutine bar\n+    type :: struct\n+      integer(4), allocatable :: ib(:)\n+    end type struct\n+    integer(ik8), allocatable :: ia(:)\n+    type(struct) :: x\n+    allocate(ia(from:to))\n+    if (any(lbound(ia) .ne. -1) .or. any(ubound(ia) .ne. 2)) call abort\n+    if (any(lbound(ia(:)) .ne. 1) .or. any(ubound(ia(:)) .ne. 4)) call abort\n+    if (any(lbound(ia(from:to)) .ne. 1) .or. any(ubound(ia(from:to)) .ne. 4)) call abort\n+    x=struct(ia)\n+    if (any(lbound(x%ib) .ne. -1) .or. any(ubound(x%ib) .ne. 2)) call abort\n+    x=struct(ia(:))\n+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort\n+    x=struct(ia(from:to))\n+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort\n+    deallocate(ia)\n+  end subroutine\n+end\n+"}]}