{"sha": "96d22b123242f42c216e90555d07656900e6ae6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZkMjJiMTIzMjQyZjQyYzIxNmU5MDU1NWQwNzY1NjkwMGU2YWU2Yw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-04-21T08:20:31Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-04-21T08:20:31Z"}, "message": "ServiceFactory.java, [...]: New files.\n\n2004-04-21  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/classpath/ServiceFactory.java,\n\tgnu/classpath/ServiceProviderLoadingAction.java,\n\tjavax/imageio/ImageReader.java,\n\tjavax/imageio/ImageTranscoder.java,\n\tjavax/imageio/ImageWriter.java,\n\tjavax/imageio/package.html,\n\tjavax/imageio/spi/IIOServiceProvider.java,\n\tjavax/imageio/spi/ImageInputStreamSpi.java,\n\tjavax/imageio/spi/ImageOutputStreamSpi.java,\n\tjavax/imageio/spi/ImageReaderWriterSpi.java,\n\tjavax/imageio/spi/ImageTranscoderSpi.java,\n\tjavax/imageio/spi/RegisterableService.java,\n\tjavax/imageio/spi/ServiceRegistry.java,\n\tjavax/imageio/spi/package.html,\n\tjavax/imageio/stream/IIOByteBuffer.java,\n\tjavax/imageio/stream/ImageInputStream.java,\n\tjavax/imageio/stream/ImageOutputStream.java,\n\tjavax/imageio/stream/package.html:\n\tNew files.\n\t* Makefile.am\n\t(ordinary_java_source_files): Added\n\tgnu/classpath/ServiceFactory.java and\n\tgnu/classpath/ServiceProviderLoadingAction.java.\n\t(javax_source_files): Added\n\tjavax/imageio/ImageReader.java,\n\tjavax/imageio/ImageTranscoder.java,\n\tjavax/imageio/ImageWriter.java,\n\tjavax/imageio/spi/IIOServiceProvider.java,\n\tjavax/imageio/spi/ImageInputStreamSpi.java,\n\tjavax/imageio/spi/ImageOutputStreamSpi.java,\n\tjavax/imageio/spi/ImageReaderWriterSpi.java,\n\tjavax/imageio/spi/ImageTranscoderSpi.java,\n\tjavax/imageio/spi/RegisterableService.java,\n\tjavax/imageio/spi/ServiceRegistry.java,\n\tjavax/imageio/stream/IIOByteBuffer.java,\n\tjavax/imageio/stream/ImageInputStream.java and\n\tjavax/imageio/stream/ImageOutputStream.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r80951", "tree": {"sha": "25ab5c709d8a8165cfef9f2c9766f785a67a6b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25ab5c709d8a8165cfef9f2c9766f785a67a6b5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96d22b123242f42c216e90555d07656900e6ae6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d22b123242f42c216e90555d07656900e6ae6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d22b123242f42c216e90555d07656900e6ae6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d22b123242f42c216e90555d07656900e6ae6c/comments", "author": null, "committer": null, "parents": [{"sha": "ca17d211e8f6450340aa394e90ecbba4d9bcab03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca17d211e8f6450340aa394e90ecbba4d9bcab03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca17d211e8f6450340aa394e90ecbba4d9bcab03"}], "stats": {"total": 3886, "additions": 3883, "deletions": 3}, "files": [{"sha": "b8bcec2bfabbec92cdf62e1c86b257ccf17bea4c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -1,3 +1,44 @@\n+2004-04-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/classpath/ServiceFactory.java,\n+\tgnu/classpath/ServiceProviderLoadingAction.java,\n+\tjavax/imageio/ImageReader.java,\n+\tjavax/imageio/ImageTranscoder.java,\n+\tjavax/imageio/ImageWriter.java,\n+\tjavax/imageio/package.html,\n+\tjavax/imageio/spi/IIOServiceProvider.java,\n+\tjavax/imageio/spi/ImageInputStreamSpi.java,\n+\tjavax/imageio/spi/ImageOutputStreamSpi.java,\n+\tjavax/imageio/spi/ImageReaderWriterSpi.java,\n+\tjavax/imageio/spi/ImageTranscoderSpi.java,\n+\tjavax/imageio/spi/RegisterableService.java,\n+\tjavax/imageio/spi/ServiceRegistry.java,\n+\tjavax/imageio/spi/package.html,\n+\tjavax/imageio/stream/IIOByteBuffer.java,\n+\tjavax/imageio/stream/ImageInputStream.java,\n+\tjavax/imageio/stream/ImageOutputStream.java,\n+\tjavax/imageio/stream/package.html:\n+\tNew files.\n+\t* Makefile.am\n+\t(ordinary_java_source_files): Added\n+\tgnu/classpath/ServiceFactory.java and\n+\tgnu/classpath/ServiceProviderLoadingAction.java.\n+\t(javax_source_files): Added\n+\tjavax/imageio/ImageReader.java,\n+\tjavax/imageio/ImageTranscoder.java,\n+\tjavax/imageio/ImageWriter.java,\n+\tjavax/imageio/spi/IIOServiceProvider.java,\n+\tjavax/imageio/spi/ImageInputStreamSpi.java,\n+\tjavax/imageio/spi/ImageOutputStreamSpi.java,\n+\tjavax/imageio/spi/ImageReaderWriterSpi.java,\n+\tjavax/imageio/spi/ImageTranscoderSpi.java,\n+\tjavax/imageio/spi/RegisterableService.java,\n+\tjavax/imageio/spi/ServiceRegistry.java,\n+\tjavax/imageio/stream/IIOByteBuffer.java,\n+\tjavax/imageio/stream/ImageInputStream.java and\n+\tjavax/imageio/stream/ImageOutputStream.java.\n+\t* Makefile.in: Regenerated.\n+\n 2004-04-21  Michael Koch  <konqueror@gmx.de>\n \n \t* java/util/Properties.java"}, {"sha": "ff8f36d4a97850553efbe10a66dfd78888c41b58", "filename": "libjava/Makefile.am", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -1748,6 +1748,19 @@ javax/accessibility/AccessibleTable.java \\\n javax/accessibility/AccessibleTableModelChange.java \\\n javax/accessibility/AccessibleText.java \\\n javax/accessibility/AccessibleValue.java \\\n+javax/imageio/ImageReader.java \\\n+javax/imageio/ImageTranscoder.java \\\n+javax/imageio/ImageWriter.java \\\n+javax/imageio/spi/IIOServiceProvider.java \\\n+javax/imageio/spi/ImageInputStreamSpi.java \\\n+javax/imageio/spi/ImageOutputStreamSpi.java \\\n+javax/imageio/spi/ImageReaderWriterSpi.java \\\n+javax/imageio/spi/ImageTranscoderSpi.java \\\n+javax/imageio/spi/RegisterableService.java \\\n+javax/imageio/spi/ServiceRegistry.java \\\n+javax/imageio/stream/IIOByteBuffer.java \\\n+javax/imageio/stream/ImageInputStream.java \\\n+javax/imageio/stream/ImageOutputStream.java \\\n javax/naming/directory/Attribute.java \\\n javax/naming/directory/AttributeInUseException.java \\\n javax/naming/directory/AttributeModificationException.java \\\n@@ -2187,6 +2200,8 @@ java/util/regex/PatternSyntaxException.java\n ## awt_java_source_files.  If the .java file has a hand-maintained\n ## header, please list it in special_java_source_files.\n ordinary_java_source_files = $(core_java_source_files) \\\n+gnu/classpath/ServiceFactory.java \\\n+gnu/classpath/ServiceProviderLoadingAction.java \\\n gnu/gcj/Core.java \\\n gnu/gcj/RawData.java \\\n gnu/gcj/io/DefaultMimeTypes.java \\"}, {"sha": "12dd8283870e931b28d156bd75c1f082eb0ece88", "filename": "libjava/Makefile.in", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -1432,6 +1432,19 @@ javax/accessibility/AccessibleTable.java \\\n javax/accessibility/AccessibleTableModelChange.java \\\n javax/accessibility/AccessibleText.java \\\n javax/accessibility/AccessibleValue.java \\\n+javax/imageio/ImageReader.java \\\n+javax/imageio/ImageTranscoder.java \\\n+javax/imageio/ImageWriter.java \\\n+javax/imageio/spi/IIOServiceProvider.java \\\n+javax/imageio/spi/ImageInputStreamSpi.java \\\n+javax/imageio/spi/ImageOutputStreamSpi.java \\\n+javax/imageio/spi/ImageReaderWriterSpi.java \\\n+javax/imageio/spi/ImageTranscoderSpi.java \\\n+javax/imageio/spi/RegisterableService.java \\\n+javax/imageio/spi/ServiceRegistry.java \\\n+javax/imageio/stream/IIOByteBuffer.java \\\n+javax/imageio/stream/ImageInputStream.java \\\n+javax/imageio/stream/ImageOutputStream.java \\\n javax/naming/directory/Attribute.java \\\n javax/naming/directory/AttributeInUseException.java \\\n javax/naming/directory/AttributeModificationException.java \\\n@@ -1862,6 +1875,8 @@ java/util/regex/PatternSyntaxException.java\n \n \n ordinary_java_source_files = $(core_java_source_files) \\\n+gnu/classpath/ServiceFactory.java \\\n+gnu/classpath/ServiceProviderLoadingAction.java \\\n gnu/gcj/Core.java \\\n gnu/gcj/RawData.java \\\n gnu/gcj/io/DefaultMimeTypes.java \\\n@@ -3010,9 +3025,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/awt/xlib/XGraphicsConfiguration.P \\\n .deps/gnu/awt/xlib/XOffScreenImage.P .deps/gnu/awt/xlib/XPanelPeer.P \\\n .deps/gnu/awt/xlib/XToolkit.P .deps/gnu/classpath/Configuration.P \\\n-.deps/gnu/gcj/Core.P .deps/gnu/gcj/RawData.P \\\n-.deps/gnu/gcj/convert/BytesToUnicode.P .deps/gnu/gcj/convert/Convert.P \\\n-.deps/gnu/gcj/convert/IOConverter.P \\\n+.deps/gnu/classpath/ServiceFactory.P \\\n+.deps/gnu/classpath/ServiceProviderLoadingAction.P .deps/gnu/gcj/Core.P \\\n+.deps/gnu/gcj/RawData.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n+.deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/IOConverter.P \\\n .deps/gnu/gcj/convert/Input_8859_1.P \\\n .deps/gnu/gcj/convert/Input_ASCII.P \\\n .deps/gnu/gcj/convert/Input_EUCJIS.P \\\n@@ -4233,6 +4249,18 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/accessibility/AccessibleTableModelChange.P \\\n .deps/javax/accessibility/AccessibleText.P \\\n .deps/javax/accessibility/AccessibleValue.P \\\n+.deps/javax/imageio/ImageReader.P .deps/javax/imageio/ImageTranscoder.P \\\n+.deps/javax/imageio/ImageWriter.P \\\n+.deps/javax/imageio/spi/IIOServiceProvider.P \\\n+.deps/javax/imageio/spi/ImageInputStreamSpi.P \\\n+.deps/javax/imageio/spi/ImageOutputStreamSpi.P \\\n+.deps/javax/imageio/spi/ImageReaderWriterSpi.P \\\n+.deps/javax/imageio/spi/ImageTranscoderSpi.P \\\n+.deps/javax/imageio/spi/RegisterableService.P \\\n+.deps/javax/imageio/spi/ServiceRegistry.P \\\n+.deps/javax/imageio/stream/IIOByteBuffer.P \\\n+.deps/javax/imageio/stream/ImageInputStream.P \\\n+.deps/javax/imageio/stream/ImageOutputStream.P \\\n .deps/javax/naming/AuthenticationException.P \\\n .deps/javax/naming/AuthenticationNotSupportedException.P \\\n .deps/javax/naming/BinaryRefAddr.P .deps/javax/naming/Binding.P \\"}, {"sha": "0e81cf74b38dce2c5ef40b3fc94a22d68bc021fe", "filename": "libjava/gnu/classpath/ServiceFactory.java", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fgnu%2Fclasspath%2FServiceFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fgnu%2Fclasspath%2FServiceFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2FServiceFactory.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,576 @@\n+/* ServiceFactory.java -- Factory for plug-in services.\n+   Copyright (C) 2004  Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.classpath;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.net.URL;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.logging.LogRecord;\n+\n+\n+/**\n+ * A factory for plug-ins that conform to a service provider\n+ * interface. This is a general mechanism that gets used by a number\n+ * of packages in the Java API. For instance, {@link\n+ * java.nio.charset.spi.CharsetProvider} allows to write custom\n+ * encoders and decoders for character sets, {@link\n+ * javax.imageio.spi.ImageReaderSpi} allows to support custom image\n+ * formats, and {@link javax.print.PrintService} makes it possible to\n+ * write custom printer drivers.\n+ *\n+ * <p>The plug-ins are concrete implementations of the service\n+ * provider interface, which is defined as an interface or an abstract\n+ * class. The implementation classes must be public and have a public\n+ * constructor that takes no arguments.\n+ *\n+ * <p>Plug-ins are usually deployed in JAR files. A JAR that provides\n+ * an implementation of a service must declare this in a resource file\n+ * whose name is the fully qualified service name and whose location\n+ * is the directory <code>META-INF/services</code>. This UTF-8 encoded\n+ * text file lists, on separate lines, the fully qualified names of\n+ * the concrete implementations. Thus, one JAR file can provide an\n+ * arbitrary number of implementations for an arbitrary count of\n+ * service provider interfaces.\n+ *\n+ * <p><b>Example</b>\n+ *\n+ * <p>For example, a JAR might provide two implementations of the\n+ * service provider interface <code>org.foo.ThinkService</code>,\n+ * namely <code>com.acme.QuickThinker</code> and\n+ * <code>com.acme.DeepThinker</code>. The code for <code>QuickThinker</code>\n+ * woud look as follows:\n+ *\n+ * <pre>\n+ * package com.acme;\n+ *\n+ * &#x2f;**\n+ * * Provices a super-quick, but not very deep implementation of ThinkService.\n+ * *&#x2f;\n+ * public class QuickThinker\n+ *   implements org.foo.ThinkService\n+ * {\n+ *   &#x2f;**\n+ *   * Constructs a new QuickThinker. The service factory (which is\n+ *   * part of the Java environment) calls this no-argument constructor\n+ *   * when it looks up the available implementations of ThinkService.\n+ *   *\n+ *   * &lt;p&gt;Note that an application might query all available\n+ *   * ThinkService providers, but use just one of them. Therefore,\n+ *   * constructing an instance should be very inexpensive. For example,\n+ *   * large data structures should only be allocated when the service\n+ *   * actually gets used.\n+ *   *&#x2f;\n+ *   public QuickThinker()\n+ *   {\n+ *   }\n+ *\n+ *   &#x2f;**\n+ *   * Returns the speed of this ThinkService in thoughts per second.\n+ *   * Applications can choose among the available service providers\n+ *   * based on this value.\n+ *   *&#x2f;\n+ *   public double getSpeed()\n+ *   {\n+ *     return 314159.2654;\n+ *   }\n+ *\n+ *   &#x2f;**\n+ *   * Produces a thought. While the returned thoughts are not very\n+ *   * deep, they are generated in very short time.\n+ *   *&#x2f;\n+ *   public Thought think()\n+ *   {\n+ *     return null;\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>The code for <code>com.acme.DeepThinker</code> is left as an\n+ * exercise to the reader.\n+ *\n+ * <p>Acme&#x2019;s <code>ThinkService</code> plug-in gets deployed as\n+ * a JAR file. Besides the bytecode and resources for\n+ * <code>QuickThinker</code> and <code>DeepThinker</code>, it also\n+ * contains the text file\n+ * <code>META-INF/services/org.foo.ThinkService</code>:\n+ *\n+ * <pre>\n+ * # Available implementations of org.foo.ThinkService\n+ * com.acme.QuickThinker\n+ * com.acme.DeepThinker\n+ * </pre>\n+ *\n+ * <p><b>Thread Safety</b>\n+ *\n+ * <p>It is safe to use <code>ServiceFactory</code> from multiple\n+ * concurrent threads without external synchronization.\n+ *\n+ * <p><b>Note for User Applications</b>\n+ *\n+ * <p>User applications that want to load plug-ins should not directly\n+ * use <code>gnu.classpath.ServiceFactory</code>, because this class\n+ * is only available in Java environments that are based on GNU\n+ * Classpath. Instead, it is recommended that user applications call\n+ * {@link\n+ * javax.imageio.spi.ServiceRegistry#lookupProviders(Class)}. This API\n+ * is actually independent of image I/O, and it is available on every\n+ * environment.\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public final class ServiceFactory\n+{\n+  /**\n+   * A logger that gets informed when a service gets loaded, or\n+   * when there is a problem with loading a service.\n+   *\n+   * <p>Because {@link java.util.logging.Logger#getLogger(String)}\n+   * is thread-safe, we do not need to worry about synchronization\n+   * here.\n+   */\n+  private static final Logger LOGGER = Logger.getLogger(\"gnu.classpath\");\n+\n+\n+  /**\n+   * Declared private in order to prevent constructing instances of\n+   * this utility class.\n+   */\n+  private ServiceFactory()\n+  {\n+  }\n+\n+\n+  /**\n+   * Finds service providers that are implementing the specified\n+   * Service Provider Interface.\n+   *\n+   * <p><b>On-demand loading:</b> Loading and initializing service\n+   * providers is delayed as much as possible. The rationale is that\n+   * typical clients will iterate through the set of installed service\n+   * providers until one is found that matches some criteria (like\n+   * supported formats, or quality of service). In such scenarios, it\n+   * might make sense to install only the frequently needed service\n+   * providers on the local machine. More exotic providers can be put\n+   * onto a server; the server will only be contacted when no suitable\n+   * service could be found locally.\n+   *\n+   * <p><b>Security considerations:</b> Any loaded service providers\n+   * are loaded through the specified ClassLoader, or the system\n+   * ClassLoader if <code>classLoader</code> is\n+   * <code>null</code>. When <code>lookupProviders</code> is called,\n+   * the current {@link AccessControlContext} gets recorded. This\n+   * captured security context will determine the permissions when\n+   * services get loaded via the <code>next()</code> method of the\n+   * returned <code>Iterator</code>.\n+   *\n+   * @param spi the service provider interface which must be\n+   * implemented by any loaded service providers.\n+   *\n+   * @param loader the class loader that will be used to load the\n+   * service providers, or <code>null</code> for the system class\n+   * loader. For using the context class loader, see {@link\n+   * #lookupProviders(Class)}.\n+   *\n+   * @return an iterator over instances of <code>spi</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>spi</code> is\n+   * <code>null</code>.\n+   */\n+  public static Iterator lookupProviders(Class spi,\n+                                         ClassLoader loader)\n+  {\n+    InputStream stream;\n+    String resourceName;\n+    Enumeration urls;\n+\n+    if (spi == null)\n+      throw new IllegalArgumentException();\n+\n+    if (loader == null)\n+      loader = ClassLoader.getSystemClassLoader();\n+\n+    resourceName = \"META-INF/services/\" + spi.getName();\n+    try\n+      {\n+        urls = loader.getResources(resourceName);\n+      }\n+    catch (IOException ioex)\n+      {\n+        /* If an I/O error occurs here, we cannot provide any service\n+         * providers. In this case, we simply return an iterator that\n+         * does not return anything (no providers installed).\n+         */\n+        log(Level.WARNING, \"cannot access {0}\", resourceName, ioex);\n+        return Collections.EMPTY_LIST.iterator();\n+      }\n+\n+    return new ServiceIterator(spi, urls, loader,\n+                               AccessController.getContext());\n+  }\n+\n+\n+  /**\n+   * Finds service providers that are implementing the specified\n+   * Service Provider Interface, using the context class loader\n+   * for loading providers.\n+   *\n+   * @param spi the service provider interface which must be\n+   * implemented by any loaded service providers.\n+   *\n+   * @return an iterator over instances of <code>spi</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>spi</code> is\n+   * <code>null</code>.\n+   *\n+   * @see #lookupProviders(Class, ClassLoader)\n+   */\n+  public static Iterator lookupProviders(Class spi)\n+  {\n+    ClassLoader ctxLoader;\n+\n+    ctxLoader = Thread.currentThread().getContextClassLoader();\n+    return lookupProviders(spi, ctxLoader);\n+  }\n+\n+\n+  /**\n+   * An iterator over service providers that are listed in service\n+   * provider configuration files, which get passed as an Enumeration\n+   * of URLs. This is a helper class for {@link\n+   * ServiceFactory#lookupProviders}.\n+   *\n+   * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+   */\n+  private static final class ServiceIterator\n+    implements Iterator\n+  {\n+    /**\n+     * The service provider interface (usually an interface, sometimes\n+     * an abstract class) which the services must implement.\n+     */\n+    private final Class spi;\n+\n+\n+    /**\n+     * An Enumeration<URL> over the URLs that contain a resource\n+     * <code>META-INF/services/&lt;org.foo.SomeService&gt;</code>,\n+     * as returned by {@link ClassLoader#getResources(String)}.\n+     */\n+    private final Enumeration urls;\n+\n+\n+    /**\n+     * The class loader used for loading service providers.\n+     */\n+    private final ClassLoader loader;\n+\n+\n+    /**\n+     * The security context used when loading and initializing service\n+     * providers. We want to load and initialize all plug-in service\n+     * providers under the same security context, namely the one that\n+     * was active when {@link #lookupProviders} has been called.\n+     */\n+    private final AccessControlContext securityContext;\n+\n+\n+    /**\n+     * A reader for the current file listing class names of service\n+     * implementors, or <code>null</code> when the last reader has\n+     * been fetched.\n+     */\n+    private BufferedReader reader;\n+    \n+\n+    /**\n+     * The URL currently being processed. This is only used for\n+     * emitting error messages.\n+     */\n+    private URL currentURL;\n+\n+\n+    /**\n+     * The service provider that will be returned by the next call to\n+     * {@link #next()}, or <code>null</code> if the iterator has\n+     * already returned all service providers.\n+     */\n+    private Object nextProvider;\n+\n+\n+    /**\n+     * Constructs an Iterator that loads and initializes services on\n+     * demand.\n+     *\n+     * @param spi the service provider interface which the services\n+     * must implement. Usually, this is a Java interface type, but it\n+     * might also be an abstract class or even a concrete superclass.\n+     *\n+     * @param urls an Enumeration<URL> over the URLs that contain a\n+     * resource\n+     * <code>META-INF/services/&lt;org.foo.SomeService&gt;</code>, as\n+     * determined by {@link ClassLoader#getResources(String)}.\n+     *\n+     * @param loader the ClassLoader that gets used for loading\n+     * service providers.\n+     *\n+     * @param securityContext the security context to use when loading\n+     * and initializing service providers.\n+     */\n+    ServiceIterator(Class spi, Enumeration urls, ClassLoader loader,\n+                    AccessControlContext securityContext)\n+    {\n+      this.spi = spi;\n+      this.urls = urls;\n+      this.loader = loader;\n+      this.securityContext = securityContext;\n+      this.nextProvider = loadNextServiceProvider();\n+    }\n+\n+\n+    /**\n+     * @throws NoSuchElementException if {@link #hasNext} returns\n+     * <code>false</code>.\n+     */\n+    public Object next()\n+    {\n+      Object result;\n+\n+      if (!hasNext())\n+        throw new NoSuchElementException();\n+\n+      result = nextProvider;\n+      nextProvider = loadNextServiceProvider();\n+      return result;\n+    }\n+\n+\n+    public boolean hasNext()\n+    {\n+      return nextProvider != null;\n+    }\n+\n+\n+    public void remove()\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+\n+    private Object loadNextServiceProvider()\n+    {\n+      String line;\n+      Class klass;\n+      \n+      if (reader == null)\n+        advanceReader();\n+\n+      for (;;)\n+        {\n+          /* If we have reached the last provider list, we cannot\n+           * retrieve any further lines.\n+           */\n+          if (reader == null)\n+            return null;\n+\n+          try\n+            {\n+              line = reader.readLine();\n+            }\n+          catch (IOException readProblem)\n+            {\n+              log(Level.WARNING, \"IOException upon reading {0}\", currentURL,\n+                  readProblem);\n+              line = null;\n+            }\n+\n+          /* When we are at the end of one list of services,\n+           * switch over to the next one.\n+           */\n+          if (line == null)\n+            {\n+              advanceReader();\n+              continue;\n+            }\n+\n+\n+          // Skip whitespace at the beginning and end of each line.\n+          line = line.trim();\n+\n+          // Skip empty lines.\n+          if (line.length() == 0)\n+            continue;\n+\n+          // Skip comment lines.\n+          if (line.charAt(0) == '#')\n+            continue;\n+\n+          try\n+            {\n+              log(Level.FINE,\n+                  \"Loading service provider \\\"{0}\\\", specified\"\n+                  + \" by \\\"META-INF/services/{1}\\\" in {2}.\",\n+                  new Object[] { line, spi.getName(), currentURL },\n+                  null);\n+\n+              /* Load the class in the security context that was\n+               * active when calling lookupProviders.\n+               */\n+              return AccessController.doPrivileged(\n+                new ServiceProviderLoadingAction(spi, line, loader),\n+                securityContext);\n+            }\n+          catch (Exception ex)\n+            {\n+              String msg = \"Cannot load service provider class \\\"{0}\\\",\"\n+                + \" specified by \\\"META-INF/services/{1}\\\" in {2}\";\n+              if (ex instanceof PrivilegedActionException\n+                  && ex.getCause() instanceof ClassCastException)\n+                msg = \"Service provider class \\\"{0}\\\" is not an instance\"\n+                  + \" of \\\"{1}\\\". Specified\"\n+                  + \" by \\\"META-INF/services/{1}\\\" in {2}.\";\n+\n+              log(Level.WARNING, msg,                  \n+                  new Object[] { line, spi.getName(), currentURL },\n+                  ex);\n+              continue;\n+            }\n+        }\n+    }\n+\n+\n+    private void advanceReader()\n+    {\n+      do\n+        {\n+          if (reader != null)\n+            {\n+              try\n+                {\n+                  reader.close();\n+                  log(Level.FINE, \"closed {0}\", currentURL, null);\n+                }\n+              catch (Exception ex)\n+                {\n+                  log(Level.WARNING, \"cannot close {0}\", currentURL, ex);\n+                }\n+              reader = null;\n+              currentURL = null;\n+            }\n+\n+        if (!urls.hasMoreElements())\n+          return;\n+\n+        currentURL = (URL) urls.nextElement();\n+        try\n+          {\n+            reader = new BufferedReader(new InputStreamReader(\n+              currentURL.openStream(), \"UTF-8\"));\n+            log(Level.FINE, \"opened {0}\", currentURL, null);\n+          }\n+        catch (Exception ex)\n+          {\n+            log(Level.WARNING, \"cannot open {0}\", currentURL, ex);\n+          }\n+        }\n+      while (reader == null);\n+    }\n+  }\n+\n+\n+  /**\n+   * Passes a log message to the <code>java.util.logging</code>\n+   * framework. This call returns very quickly if no log message will\n+   * be produced, so there is not much overhead in the standard case.\n+   *\n+   * @param the severity of the message, for instance {@link\n+   * Level#WARNING}.\n+   *\n+   * @param msg the log message, for instance <code>&#x201c;Could not\n+   * load {0}.&#x201d;</code>\n+   *\n+   * @param param the parameter(s) for the log message, or\n+   * <code>null</code> if <code>msg</code> does not specify any\n+   * parameters. If <code>param</code> is not an array, an array with\n+   * <code>param</code> as its single element gets passed to the\n+   * logging framework.\n+   *\n+   * @param t a Throwable that is associated with the log record, or\n+   * <code>null</code> if the log message is not associated with a\n+   * Throwable.\n+   */\n+  private static void log(Level level, String msg, Object param, Throwable t)\n+  {\n+    LogRecord rec;\n+\n+    // Return quickly if no log message will be produced.\n+    if (!LOGGER.isLoggable(level))\n+      return;\n+\n+    rec = new LogRecord(level, msg);\n+    if (param != null && param.getClass().isArray())\n+      rec.setParameters((Object[]) param);\n+    else\n+      rec.setParameters(new Object[] { param });\n+\n+    rec.setThrown(t);\n+\n+    // While java.util.logging can sometimes infer the class and\n+    // method of the caller, this automatic inference is not reliable\n+    // on highly optimizing VMs. Also, log messages make more sense to\n+    // developers when they display a public method in a public class;\n+    // otherwise, they might feel tempted to figure out the internals\n+    // of ServiceFactory in order to understand the problem.\n+    rec.setSourceClassName(ServiceFactory.class.getName());\n+    rec.setSourceMethodName(\"lookupProviders\");\n+\n+    LOGGER.log(rec);\n+  }\n+}"}, {"sha": "4832c9712f3815d4a0b0295444e42ac76da460a9", "filename": "libjava/gnu/classpath/ServiceProviderLoadingAction.java", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fgnu%2Fclasspath%2FServiceProviderLoadingAction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fgnu%2Fclasspath%2FServiceProviderLoadingAction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2FServiceProviderLoadingAction.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,149 @@\n+/* ServiceProviderLoadingAction.java -- Action for loading plug-in services.\n+   Copyright (C) 2004  Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.classpath;\n+\n+import java.security.PrivilegedExceptionAction;\n+\n+/**\n+ * A privileged action for creating a new instance of a service\n+ * provider.\n+ *\n+ * <p>Class loading and instantiation is encapsulated in a\n+ * <code>PriviledgedAction</code> in order to restrict the loaded\n+ * service providers to the {@link java.security.AccessControlContext}\n+ * that was active when {@link\n+ * gnu.classpath.ServiceFactory#lookupProviders} was called, even\n+ * though the actual loading is delayed to the time when the provider\n+ * is actually needed.\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+final class ServiceProviderLoadingAction\n+  implements PrivilegedExceptionAction\n+{\n+  /**\n+   * The interface to which the loaded service provider implementation\n+   * must conform.  Usually, this is a Java interface type, but it\n+   * might also be an abstract class or even a concrete class.\n+   */\n+  private final Class spi;\n+\n+\n+  /**\n+   * The fully qualified name of the class that gets loaded when\n+   * this action is executed.\n+   */\n+  private final String providerName;\n+\n+\n+  /**\n+   * The ClassLoader that gets used for loading the service provider\n+   * class.\n+   */\n+  private final ClassLoader loader;\n+\n+\n+  /**\n+   * Constructs a privileged action for loading a service provider.\n+   *\n+   * @param spi the interface to which the loaded service provider\n+   * implementation must conform. Usually, this is a Java interface\n+   * type, but it might also be an abstract class or even a concrete\n+   * superclass.\n+   *\n+   * @param providerName the fully qualified name of the class that\n+   * gets loaded when this action is executed.\n+   *\n+   * @param loader the ClassLoader that gets used for loading the\n+   * service provider class.\n+   *\n+   * @throws IllegalArgumentException if <code>spi</code>,\n+   * <code>providerName</code> or <code>loader</code> is\n+   * <code>null</code>.\n+   */\n+  ServiceProviderLoadingAction(Class spi, String providerName,\n+                               ClassLoader loader)\n+  {\n+    if (spi == null || providerName == null || loader == null)\n+      throw new IllegalArgumentException();\n+\n+    this.spi = spi;\n+    this.providerName = providerName;\n+    this.loader = loader;\n+  }\n+\n+  \n+  /**\n+   * Loads an implementation class for a service provider, and creates\n+   * a new instance of the loaded class by invoking its public\n+   * no-argument constructor.\n+   *\n+   * @return a new instance of the class whose name was passed as\n+   * <code>providerName</code> to the constructor.\n+   *\n+   * @throws ClassCastException if the service provider does not\n+   * implement the <code>spi</code> interface that was passed to the\n+   * constructor.\n+   *\n+   * @throws IllegalAccessException if the service provider class or\n+   * its no-argument constructor are not <code>public</code>.\n+   *\n+   * @throws InstantiationException if the service provider class is\n+   * <code>abstract</code>, an interface, a primitive type, an array\n+   * class, or void; or if service provider class does not have a\n+   * no-argument constructor; or if there some other problem with\n+   * creating a new instance of the service provider.\n+   */\n+  public Object run()\n+    throws Exception\n+  {\n+    Class loadedClass;\n+    Object serviceProvider;\n+\n+    loadedClass = loader.loadClass(providerName);\n+    serviceProvider = loadedClass.newInstance();\n+\n+    // Ensure that the loaded provider is actually implementing\n+    // the service provider interface.\n+    if (!spi.isInstance(serviceProvider))\n+      throw new ClassCastException(spi.getName());\n+\n+    return serviceProvider;\n+  }\n+}"}, {"sha": "75ae9ad60475dd43c030676f6d10889672aafc9e", "filename": "libjava/javax/imageio/ImageReader.java", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2FImageReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2FImageReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageReader.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,46 @@\n+/* ImageReader.java -- Decodes raster images.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio;\n+\n+public abstract class ImageReader\n+{\n+  // FIXME: Incomplete. This class is merely present in order to allow\n+  // compilation of the javax.imageio.spi package, for which GNU\n+  // Classpath does provide an implementation.\n+}"}, {"sha": "20c6959985e8261e2e8a2b37f3023836b0a5f73c", "filename": "libjava/javax/imageio/ImageTranscoder.java", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2FImageTranscoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2FImageTranscoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageTranscoder.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,46 @@\n+/* ImageTranscoder.java -- Image metadata transcoder.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio;\n+\n+public interface ImageTranscoder\n+{\n+  // FIXME: Incomplete. This interface is merely present in order to\n+  // allow compilation of the javax.imageio.spi package, for which GNU\n+  // Classpath does provide an implementation.\n+}"}, {"sha": "7ef60c365aa0722c760a5b0b1e125a44ad1c13fd", "filename": "libjava/javax/imageio/ImageWriter.java", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2FImageWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2FImageWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2FImageWriter.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,47 @@\n+/* ImageWriter.java -- Encodes raster images.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio;\n+\n+public abstract class ImageWriter\n+  implements ImageTranscoder\n+{\n+  // FIXME: Incomplete. This class is merely present in order to allow\n+  // compilation of the javax.imageio.spi package, for which GNU\n+  // Classpath does provide an implementation.\n+}"}, {"sha": "ed284b93cb0f009d49a730f186a16f8465c7fe48", "filename": "libjava/javax/imageio/package.html", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fpackage.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fpackage.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fpackage.html?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,46 @@\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n+<!-- package.html - describes classes in javax.imageio package.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. -->\n+\n+<html>\n+<head><title>GNU Classpath - javax.imageio</title></head>\n+\n+<body>\n+<p></p>\n+\n+</body>\n+</html>"}, {"sha": "bd0a449331cd1d77d6fb757a14dd50a2ee5bea4b", "filename": "libjava/javax/imageio/spi/IIOServiceProvider.java", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FIIOServiceProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FIIOServiceProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FIIOServiceProvider.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,163 @@\n+/* IIOServiceProvider.java -- General service provider for image I/O.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+import java.util.Locale;\n+\n+\n+/**\n+ * An abstract superclass for service providers that perform image I/O.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public abstract class IIOServiceProvider\n+  implements RegisterableService\n+{\n+  /**\n+   * The vendor of this service provider, or <code>null</code> if the\n+   * subclass constructor did not set this field.\n+   *\n+   * @see #getVendorName()\n+   */\n+  protected String vendorName;\n+\n+\n+  /**\n+   * The version of this service provider, or <code>null</code> if the\n+   * subclass constructor did not set this field.\n+   *\n+   * @see #getVersion()\n+   */\n+  protected String version;\n+\n+\n+  /**\n+   * Constructs a general <code>IIOServiceProvider</code>, given the\n+   * vendor name and a version string.\n+   *\n+   * @throws IllegalArgumentException if <code>vendorName</code>\n+   * or <code>version</code> is <code>null</code>.\n+   */\n+  public IIOServiceProvider(String vendorName, String version)\n+  {\n+    if (vendorName == null || version == null)\n+      throw new IllegalArgumentException();\n+\n+    this.vendorName = vendorName;\n+    this.version = version;\n+  }\n+\n+\n+  /**\n+   * Constructs a general <code>IIOServiceProvider</code> without\n+   * specifying a vendor name and a version string. The subclass\n+   * constructor should set the {@link #vendorName} and {@link\n+   * #version} to non-null values.\n+   */\n+  public IIOServiceProvider()\n+  {\n+  }\n+\n+\n+  /**\n+   * Informs this service provider that it has been registered in a\n+   * {@link ServiceRegistry}. If this provider gets registered as an\n+   * implementor for several service categories, its\n+   * <code>onRegistration</code> method will be called multiple times.\n+   * The default implementation does nothing.\n+   *\n+   * @param registry the registry to which this service provider has\n+   * been added.\n+   *\n+   * @param category the service category for which this provider has\n+   * been registered as an implementor.\n+   */\n+  public void onRegistration(ServiceRegistry registry, Class category)\n+  {\n+  }\n+\n+\n+  /**\n+   * Informs this service provider that it has been de-registered from\n+   * a {@link ServiceRegistry}. If this provider had been registered\n+   * as an implementor for several service categories, its\n+   * <code>onDeregistration</code> method will be called multiple\n+   * times. The default implementation does nothing.\n+   *\n+   * @param registry the registry from which this service provider has\n+   * been removed.\n+   *\n+   * @param category the service category for which this provider has\n+   * been registered as an implementor.\n+   */\n+  public void onDeregistration(ServiceRegistry registry, Class category)\n+  {\n+  }\n+\n+\n+  /**\n+   * Returns the name of the vendor of this service provider.\n+   */\n+  public String getVendorName()\n+  {\n+    return vendorName;\n+  }\n+\n+\n+  /**\n+   * Returns an identifier string for the version of this service\n+   * provider.\n+   */\n+  public String getVersion()\n+  {\n+    return version;\n+  }\n+\n+\n+  /**\n+   * Returns a short description of this service provider that can be\n+   * presented to a human user.\n+   *\n+   * @param locale the locale for which the description string should\n+   * be localized.\n+   */\n+  public abstract String getDescription(Locale locale);\n+}"}, {"sha": "b8d58547da1ab82119fe17a093263ec677bd4ec8", "filename": "libjava/javax/imageio/spi/ImageInputStreamSpi.java", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageInputStreamSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageInputStreamSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FImageInputStreamSpi.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,144 @@\n+/* ImageInputStreamSpi.java -- Service provider for image input streams.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.stream.ImageInputStream;\n+\n+\n+/**\n+ * An abstract superclass for service providers that create\n+ * {@linkplain javax.imageio.stream.ImageInputStream image input\n+ * streams} for a file, URL, byte array or any other source.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public abstract class ImageInputStreamSpi\n+  extends IIOServiceProvider\n+{\n+  /**\n+   * Indicates which kind of input is processable by the streams\n+   * created by {@link #createInputStreamInstance(Object)}.\n+   */\n+  protected Class inputClass;\n+\n+\n+  /**\n+   * Constructs a service provider for image input streams, given no\n+   * parameters. It is up to the sub-class to set {@link #vendorName},\n+   * {@link #version} and {@link #inputClass} to non-null values.\n+   */\n+  protected ImageInputStreamSpi()\n+  {\n+  }\n+\n+\n+  /**\n+   * Constructs a service provider for image input streams, given the\n+   * vendor name and a version string.\n+   *\n+   * @throws IllegalArgumentException if <code>vendorName</code>\n+   * or <code>version</code> is <code>null</code>.\n+   */\n+  public ImageInputStreamSpi(String vendorName, String version,\n+                             Class inputClass)\n+  {\n+    super(vendorName, version);\n+    this.inputClass = inputClass;\n+  }\n+\n+\n+  /**\n+   * Determines which kind of input is processable by the streams\n+   * created by {@link #createInputStreamInstance(Object)}.\n+   */\n+  public Class getInputClass()\n+  {\n+    return inputClass;\n+  }\n+\n+\n+  /**\n+   * Determines whether <code>ImageInputStreams</code> created\n+   * by this service provider benefit from using a cache file.\n+   *\n+   * <p>The default behavior is to return <code>false</code>.\n+   *\n+   * @return <code>true</code> if the created streams are faster or\n+   * need less memory when a cache file is being used;\n+   * <code>false</code> if no positive effect results from the cache\n+   * file.\n+   */\n+  public boolean canUseCacheFile()\n+  {\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Determines whether <code>ImageInputStreams</code> created\n+   * by this service provider require the use of a cache file.\n+   *\n+   * <p>The default behavior is to return <code>false</code>.\n+   *\n+   * @return <code>true</code> if the created streams can only work\n+   * when a cache file is being used; <code>false</code> if no cache\n+   * file is needed.\n+   */\n+  public boolean needsCacheFile()\n+  {\n+    return false;\n+  }\n+\n+\n+  public abstract ImageInputStream createInputStreamInstance(Object input,\n+                                                             boolean useCache,\n+                                                             File cacheDir)\n+    throws IOException;\n+\n+\n+  public ImageInputStream createInputStreamInstance(Object input)\n+    throws IOException\n+  {\n+    return createInputStreamInstance(input, canUseCacheFile(), null);\n+  }\n+}"}, {"sha": "aa287c31378eb22a03ea05852c3204efa02332b6", "filename": "libjava/javax/imageio/spi/ImageOutputStreamSpi.java", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageOutputStreamSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageOutputStreamSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FImageOutputStreamSpi.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,143 @@\n+/* ImageOutputStreamSpi.java -- Service provider for image output streams.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.stream.ImageOutputStream;\n+\n+\n+/**\n+ * An abstract superclass for service providers that create\n+ * {@linkplain javax.imageio.stream.ImageOutputStream image output\n+ * streams} for a file, URL, byte array or any other target.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public abstract class ImageOutputStreamSpi\n+  extends IIOServiceProvider\n+{\n+  /**\n+   * Indicates which kind of output is produced by the streams\n+   * created by {@link #createOutputStreamInstance(Object)}.\n+   */\n+  protected Class outputClass;\n+\n+\n+  /**\n+   * Constructs a service provider for image output streams, given no\n+   * parameters. It is up to the sub-class to set {@link #vendorName},\n+   * {@link #version} and {@link #outputClass} to non-null values.\n+   */\n+  protected ImageOutputStreamSpi()\n+  {\n+  }\n+\n+\n+  /**\n+   * Constructs a service provider for image output streams, given the\n+   * vendor name, a version string and the kind of producable output.\n+   *\n+   * @throws IllegalArgumentException if <code>vendorName</code>\n+   * or <code>version</code> is <code>null</code>.\n+   */\n+  public ImageOutputStreamSpi(String vendorName, String version,\n+                              Class outputClass)\n+  {\n+    super(vendorName, version);\n+    this.outputClass = outputClass;\n+  }\n+\n+\n+  /**\n+   * Determines which kind of output is produced by the streams\n+   * created by {@link #createOutputStreamInstance(Object)}.\n+   */\n+  public Class getOutputClass()\n+  {\n+    return outputClass;\n+  }\n+\n+\n+  /**\n+   * Determines whether <code>ImageOutputStreams</code> created\n+   * by this service provider benefit from using a cache file.\n+   *\n+   * <p>The default behavior is to return <code>false</code>.\n+   *\n+   * @return <code>true</code> if the created streams are faster or\n+   * need less memory when a cache file is being used;\n+   * <code>false</code> if no positive effect results from the cache\n+   * file.\n+   */\n+  public boolean canUseCacheFile()\n+  {\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Determines whether <code>ImageOutputStreams</code> created\n+   * by this service provider require the use of a cache file.\n+   *\n+   * <p>The default behavior is to return <code>false</code>.\n+   *\n+   * @return <code>true</code> if the created streams can only work\n+   * when a cache file is being used; <code>false</code> if no cache\n+   * file is needed.\n+   */\n+  public boolean needsCacheFile()\n+  {\n+    return false;\n+  }\n+\n+\n+  public abstract ImageOutputStream createOutputStreamInstance(\n+    Object output, boolean useCache, File cacheDir)\n+    throws IOException;\n+\n+\n+  public ImageOutputStream createOutputStreamInstance(Object output)\n+    throws IOException\n+  {\n+    return createOutputStreamInstance(output, canUseCacheFile(), null);\n+  }\n+}"}, {"sha": "33de165e35d37302e6008e1c390808c28d61328c", "filename": "libjava/javax/imageio/spi/ImageReaderWriterSpi.java", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageReaderWriterSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageReaderWriterSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FImageReaderWriterSpi.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,425 @@\n+/* ImageReaderWriterSpi.java -- Superclass for image reader and writer spis.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+\n+/**\n+ * An abstract superclass that contains the common parts of {@link\n+ * javax.imageio.spi.ImageReaderSpi} and {@link\n+ * javax.imageio.spi.ImageWriterSpi}.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public abstract class ImageReaderWriterSpi\n+  extends IIOServiceProvider\n+{\n+  /**\n+   * The human-readable, localized names of the supported image\n+   * formats. This value should be non-<code>null</code> after\n+   * construction.\n+   *\n+   * @see #getFormatNames()\n+   */\n+  protected String[] names;\n+\n+\n+  /**\n+   * The file suffixes of the supported image formats. This value\n+   * should be non-<code>null</code> after construction.\n+   *\n+   * @see #getFileSuffixes()\n+   */\n+  protected String[] suffixes;\n+\n+\n+  /**\n+   * The MIME types of the supported image formats.  This value\n+   * should be non-<code>null</code> after construction.\n+   *\n+   * @see #getMIMETypes()\n+   */\n+  protected String[] MIMETypes;\n+\n+\n+  /**\n+   * The fully qualified name of the class that implements the {@link\n+   * javax.imageio.ImageReader} or {@link javax.imageio.ImageWriter}\n+   * interface.  This value should be non-<code>null</code> after\n+   * construction.\n+   *\n+   * @see #getPluginClassName()\n+   */\n+  protected String pluginClassName;\n+\n+\n+  /**\n+   * Indicates whether the per-stream {@linkplain\n+   * javax.imageio.metadata.IIOMetadata metadata objects} associated\n+   * with this plug-in support format\n+   * <code>&#x201c;javax_imageio_1.0&#x201d;</code> in their\n+   * <code>getAsTree</code> and <code>setAsTree</code> methods.\n+   *\n+   * @see #isStandardStreamMetadataFormatSupported()\n+   */\n+  protected boolean supportsStandardStreamMetadataFormat;\n+\n+\n+  /**\n+   * The name of the format that allows encoding all stream metadata\n+   * without loss, or <code>null</code> if this plug-in does not\n+   * provide a format that preserves all stream metadata.\n+   */\n+  protected String nativeStreamMetadataFormatName;\n+\n+  protected String nativeStreamMetadataFormatClassName;\n+\n+\n+  /**\n+   * The names of additional formats for encoding stream metadata,\n+   * other than the {@linkplain\n+   * #isStandardStreamMetadataFormatSupported() standard} and the\n+   * {@linkplain #getNativeStreamMetadataFormatName() native} formats,\n+   * or <code>null</code> if this plug-in does not provide any extra\n+   * formats.\n+   */\n+  protected String[] extraStreamMetadataFormatNames;\n+\n+\n+  protected String[] extraStreamMetadataFormatClassNames;\n+\n+\n+  /**\n+   * Indicates whether the per-image {@linkplain\n+   * javax.imageio.metadata.IIOMetadata metadata objects} associated\n+   * with this plug-in support format\n+   * <code>&#x201c;javax_imageio_1.0&#x201d;</code> in their\n+   * <code>getAsTree</code> and <code>setAsTree</code> methods.\n+   *\n+   * @see #isStandardImageMetadataFormatSupported()\n+   */\n+  protected boolean supportsStandardImageMetadataFormat;\n+\n+\n+  /**\n+   * The name of the format that allows encoding all image metadata\n+   * without loss, or <code>null</code> if this plug-in does not\n+   * provide a format that preserves all image metadata.\n+   */\n+  protected String nativeImageMetadataFormatName;\n+\n+  protected String nativeImageMetadataFormatClassName;\n+\n+\n+  /**\n+   * The names of additional formats for encoding image metadata,\n+   * other than the {@linkplain\n+   * #isStandardImageMetadataFormatSupported() standard} and the\n+   * {@linkplain #getNativeImageMetadataFormatName() native} formats,\n+   * or <code>null</code> if this plug-in does not provide any extra\n+   * formats.\n+   */\n+  protected String[] extraImageMetadataFormatNames;\n+\n+\n+  protected String[] extraImageMetadataFormatClassNames;\n+\n+\n+  /**\n+   * Constructs an <code>ImageReaderWriteSpi</code> instance, without\n+   * specifying a number of parameters. Constructors of concrete\n+   * subclasses must ensure that they set all inherited fields to\n+   * meaningful values.\n+   */\n+  protected ImageReaderWriterSpi()\n+  {\n+  }\n+\n+\n+  /**\n+   * Constructs an <code>ImageReaderWriteSpi</code> instance,\n+   * specifying a number of parameters.\n+   *\n+   * @param names the human-readable, localized names of the supported\n+   * image formats, for example <code>[&#x201c;Tagged Image File\n+   * Format&#x201d;, &#x201c;Portable Network\n+   * Graphics&#x201d;]</code>.\n+   *\n+   * @param suffixes the file suffixes of the supported image formats,\n+   * for example <code>[&#x201c;tiff&#x201d;, &#x201c;tif&#x201d;,\n+   * &#x201c;png&#x201d;]</code>.\n+   *\n+   * @param MIMETypes the MIME types of the supported image formats,\n+   * for example <code>[&#x201c;image/tiff&#x201d;,\n+   * &#x201c;image/png&#x201d;]</code>.\n+   *\n+   * @param pluginClassName the fully qualified name of the class that\n+   * implements the {@link javax.imageio.ImageReader} or {@link\n+   * javax.imageio.ImageWriter} interface.\n+   *\n+   * @param supportsStandardStreamMetadataFormat whether the\n+   * per-stream {@linkplain javax.imageio.metadata.IIOMetadata\n+   * metadata objects} associated with this plug-in support format\n+   * <code>&#x201c;javax_imageio_1.0&#x201d;</code> in their\n+   * <code>getAsTree</code> and <code>setAsTree</code> methods.\n+   *\n+   * @param nativeStreamMetadataFormatName the name of the format that\n+   * allows encoding all stream metadata without loss, or\n+   * <code>null</code> if this plug-in does not provide a format that\n+   * preserves all stream metadata.\n+   *\n+   * @param extraStreamMetadataFormatNames the names of additional\n+   * formats for encoding stream metadata, other than the {@linkplain\n+   * #isStandardStreamMetadataFormatSupported() standard} and the\n+   * {@linkplain #getNativeStreamMetadataFormatName() native} formats,\n+   * or <code>null</code> if this plug-in does not provide any extra\n+   * formats.\n+   *\n+   * @param supportsStandardImageMetadataFormat whether the per-image\n+   * {@linkplain javax.imageio.metadata.IIOMetadata metadata objects}\n+   * associated with this plug-in support format\n+   * <code>&#x201c;javax_imageio_1.0&#x201d;</code> in their\n+   * <code>getAsTree</code> and <code>setAsTree</code> methods.\n+   *\n+   * @param nativeImageMetadataFormatName the name of the format that\n+   * allows encoding all image metadata without loss, or\n+   * <code>null</code> if this plug-in does not provide a format that\n+   * preserves all image metadata.\n+   *\n+   * @param extraImageMetadataFormatNames the names of additional\n+   * formats for encoding image metadata, other than the {@linkplain\n+   * #isStandardImageMetadataFormatSupported() standard} and the\n+   * {@linkplain #getNativeImageMetadataFormatName() native} formats,\n+   * or <code>null</code> if this plug-in does not provide any extra\n+   * formats.\n+   *\n+   * @throws IllegalArgumentException if <code>vendorName</code>\n+   * or <code>version</code> is <code>null</code>.\n+   */\n+  public ImageReaderWriterSpi(String vendorName, String version,\n+                              String[] names, String[] suffixes,\n+                              String[] MIMETypes, String pluginClassName,\n+                              boolean supportsStandardStreamMetadataFormat,\n+                              String nativeStreamMetadataFormatName,\n+                              String nativeStreamMetadataFormatClassName,\n+                              String[] extraStreamMetadataFormatNames,\n+                              String[] extraStreamMetadataFormatClassNames,\n+                              boolean supportsStandardImageMetadataFormat,\n+                              String nativeImageMetadataFormatName,\n+                              String nativeImageMetadataFormatClassName,\n+                              String[] extraImageMetadataFormatNames,\n+                              String[] extraImageMetadataFormatClassNames)\n+  {\n+    /* The inherited constructor will throw IllegalArgumentException\n+     * if one of its arguments is null.\n+     */\n+    super(vendorName, version);\n+\n+    if (names == null || names.length == 0 || pluginClassName == null)\n+      throw new IllegalArgumentException();\n+\n+    this.names = names;\n+    this.suffixes = suffixes;\n+    this.MIMETypes = MIMETypes;\n+    this.pluginClassName = pluginClassName;\n+\n+    this.supportsStandardStreamMetadataFormat\n+      = supportsStandardStreamMetadataFormat;\n+\n+    this.nativeStreamMetadataFormatName\n+      = nativeStreamMetadataFormatName;\n+\n+    this.nativeStreamMetadataFormatClassName\n+      = nativeStreamMetadataFormatClassName;\n+\n+    this.extraStreamMetadataFormatNames\n+      = extraStreamMetadataFormatNames;\n+\n+    this.extraStreamMetadataFormatClassNames\n+      = extraStreamMetadataFormatClassNames;\n+\n+    this.supportsStandardImageMetadataFormat\n+      = supportsStandardImageMetadataFormat;\n+\n+    this.nativeImageMetadataFormatName\n+      = nativeImageMetadataFormatName;\n+\n+    this.nativeImageMetadataFormatClassName\n+      = nativeImageMetadataFormatClassName;\n+\n+    this.extraImageMetadataFormatNames\n+      = extraImageMetadataFormatNames;\n+\n+    this.extraImageMetadataFormatClassNames\n+      = extraImageMetadataFormatClassNames;\n+  }\n+\n+\n+  /**\n+   * Returns the human-readable, localized names of the supported\n+   * image formats. For example, a plug-in might return an array with\n+   * the elements <code>[&#x201c;Tagged Image File Format&#x201d;,\n+   * &#x201c;Portable Network Graphics&#x201d;]</code>.\n+   */\n+  public String[] getFormatNames()\n+  {\n+    return (String[]) names.clone();\n+  }\n+\n+\n+  /**\n+   * Returns the file suffixes of the supported image formats, for\n+   * example <code>[&#x201c;tiff&#x201d;, &#x201c;tif&#x201d;,\n+   * &#x201c;png&#x201d;]</code>.\n+   */\n+  public String[] getFileSuffixes()\n+  {\n+    return suffixes;\n+  }\n+\n+\n+  /**\n+   * Returns the MIME types of the supported image formats, for\n+   * example <code>[&#x201c;image/tiff&#x201d;,\n+   * &#x201c;image/png&#x201d;]</code>.\n+   *\n+   * @return an array of MIME type strings, or <code>null</code> if\n+   * none of the supported formats has an associated MIME type.\n+   */\n+  public String[] getMIMETypes()\n+  {\n+    return MIMETypes;\n+  }\n+\n+\n+  /**\n+   * Returns the fully qualified name of the class that implements the\n+   * {@link javax.imageio.ImageReader} or {@link\n+   * javax.imageio.ImageWriter} interface.\n+   */\n+  public String getPluginClassName()\n+  {\n+    return pluginClassName;\n+  }\n+\n+\n+  /**\n+   * Returns whether the per-stream {@linkplain\n+   * javax.imageio.metadata.IIOMetadata metadata objects} associated\n+   * with this plug-in support format\n+   * <code>&#x201c;javax_imageio_1.0&#x201d;</code> in their\n+   * <code>getAsTree</code> and <code>setAsTree</code> methods.\n+   */\n+  public boolean isStandardStreamMetadataFormatSupported()\n+  {\n+    return supportsStandardStreamMetadataFormat;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the format that allows encoding all stream\n+   * metadata without loss, or <code>null</code> if this plug-in does\n+   * not provide a format that preserves all stream metadata.\n+   *\n+   * @see #getNativeImageMetadataFormatName()\n+   */\n+  public String getNativeStreamMetadataFormatName()\n+  {\n+    return nativeStreamMetadataFormatName;\n+  }\n+\n+\n+  /**\n+   * Returns the names of additional formats for encoding stream\n+   * metadata, other than the {@linkplain\n+   * #isStandardStreamMetadataFormatSupported() standard} and the\n+   * {@linkplain #getNativeStreamMetadataFormatName() native} formats,\n+   * or <code>null</code> if this plug-in does not provide any extra\n+   * formats.\n+   *\n+   * @see #getExtraImageMetadataFormatNames()\n+   */\n+  public String[] getExtraStreamMetadataFormatNames()\n+  {\n+    return extraStreamMetadataFormatNames;\n+  }\n+\n+\n+  /**\n+   * Returns whether the per-image {@linkplain\n+   * javax.imageio.metadata.IIOMetadata metadata objects} associated\n+   * with this plug-in support format\n+   * <code>&#x201c;javax_imageio_1.0&#x201d;</code> in their\n+   * <code>getAsTree</code> and <code>setAsTree</code> methods.\n+   */\n+  public boolean isStandardImageMetadataFormatSupported()\n+  {\n+    return supportsStandardImageMetadataFormat;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the format that allows encoding all image\n+   * metadata without loss, or <code>null</code> if this plug-in does\n+   * not provide a format that preserves all image metadata.\n+   *\n+   * @see #getNativeStreamMetadataFormatName()\n+   */\n+  public String getNativeImageMetadataFormatName()\n+  {\n+    return nativeImageMetadataFormatName;\n+  }\n+\n+\n+  /**\n+   * Returns the names of additional formats for encoding image\n+   * metadata, other than the {@linkplain\n+   * #isStandardImageMetadataFormatSupported() standard} and the\n+   * {@linkplain #getNativeImageMetadataFormatName() native} formats,\n+   * or <code>null</code> if this plug-in does not provide any extra\n+   * formats.\n+   *\n+   * @see #getExtraStreamMetadataFormatNames()\n+   */\n+  public String[] getExtraImageMetadataFormatNames()\n+  {\n+    return extraImageMetadataFormatNames;\n+  }\n+}"}, {"sha": "85ca77d463986374e9736aecc7d5dc59f43b0d76", "filename": "libjava/javax/imageio/spi/ImageTranscoderSpi.java", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageTranscoderSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FImageTranscoderSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FImageTranscoderSpi.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,84 @@\n+/* ImageTranscoderSpi.java -- Factory for image metadata transcoders.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+import javax.imageio.ImageTranscoder;\n+\n+\n+/**\n+ * An abstract superclass for service providers that create\n+ * {@linkplain javax.imageio.ImageTranscoder image metadata\n+ * transcoders}.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public abstract class ImageTranscoderSpi\n+  extends IIOServiceProvider\n+{\n+  /**\n+   * Constructs a service provider for image metadata transcoders,\n+   * given no parameters. It is up to the sub-class to set {@link\n+   * #vendorName} and {@link #version} to non-null values.\n+   */\n+  protected ImageTranscoderSpi()\n+  {\n+  }\n+\n+\n+  /**\n+   * Constructs a service provider for image metadata transcoders,\n+   * given the vendor name and a version string.\n+   *\n+   * @throws IllegalArgumentException if <code>vendorName</code>\n+   * or <code>version</code> is <code>null</code>.\n+   */\n+  public ImageTranscoderSpi(String vendorName, String version)\n+  {\n+    super(vendorName, version);\n+  }\n+\n+\n+  public abstract String getReaderServiceProviderName();\n+\n+  public abstract String getWriterServiceProviderName();\n+\n+  public abstract ImageTranscoder createTranscoderInstance();\n+}"}, {"sha": "40cb05f81acf5cde08e04c5ff4a86d25467f01e8", "filename": "libjava/javax/imageio/spi/RegisterableService.java", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FRegisterableService.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FRegisterableService.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FRegisterableService.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,83 @@\n+/* RegisterableService.java -- An interface for service providers.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+\n+/**\n+ * An interface which service providers may optionally implement in\n+ * order to get notified when they are added or removed from a {@link\n+ * ServiceRegistry}.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public interface RegisterableService\n+{\n+  /**\n+   * Informs this service provider that it has been registered in a\n+   * {@link ServiceRegistry}. If this provider gets registered as an\n+   * implementor for several service categories, its\n+   * <code>onRegistration</code> method will be called multiple times.\n+   *\n+   * @param registry the registry to which this service provider has\n+   * been added.\n+   *\n+   * @param category the service category for which this provider has\n+   * been registered as an implementor.\n+   */\n+  void onRegistration(ServiceRegistry registry, Class category);\n+\n+\n+  /**\n+   * Informs this service provider that it has been de-registered from\n+   * a {@link ServiceRegistry}. If this provider had been registered\n+   * as an implementor for several service categories, its\n+   * <code>onDeregistration</code> method will be called multiple\n+   * times.\n+   *\n+   * @param registry the registry from which this service provider has\n+   * been removed.\n+   *\n+   * @param category the service category for which this provider has\n+   * been registered as an implementor.\n+   */\n+  void onDeregistration(ServiceRegistry registry, Class category);\n+}\n+"}, {"sha": "c41e1b5a75e904f423cbfe9fd32665340461c939", "filename": "libjava/javax/imageio/spi/ServiceRegistry.java", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FServiceRegistry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2FServiceRegistry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2FServiceRegistry.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,948 @@\n+/* ServiceRegistry.java -- A simple registry for service providers.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.spi;\n+\n+import java.util.*;\n+import gnu.classpath.ServiceFactory;\n+\n+\n+/**\n+ * A registry for service providers.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:konqueror@gmx.de\">Michael Koch</a>\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public class ServiceRegistry\n+{\n+  /**\n+   * The service categories of this registry.\n+   *\n+   * <p>Note that we expect that only very few categories will\n+   * typically be used with a registry. The most common case will be\n+   * one, it seems unlikely that any registry would contain more than\n+   * five or six categories. Therefore, we intentionally avoid the\n+   * overhead of a HashMap.\n+   *\n+   * @see #providers\n+   */\n+  private final Class[] categories;\n+\n+\n+  /**\n+   * The registered providers for each service category, indexed by\n+   * the same index as the {@link #categories} array. If no provider\n+   * is registered for a category, the array entry will be\n+   * <code>null</code>.\n+   *\n+   * <p>Note that we expect that only very few providers will\n+   * typically be registered for a category. The most common case will\n+   * be one or two. Therefore, we intentionally avoid the overhead of\n+   * a HashMap.\n+   */\n+  private final LinkedList[] providers;\n+\n+\n+  /**\n+   * The ordring constaints for each service category, indexed by the\n+   * same index as the {@link #categories} array. The constraints for\n+   * a service category are stored as a <code>Map&lt;Object,\n+   * Set&lt;Object&gt;&gt;</code>, where the Map&#x2019;s values are\n+   * those providers that need to come after the key.  If no\n+   * constraints are imposed on the providers of a category, the array\n+   * entry will be <code>null</code>. If no constraints have been set\n+   * whatsoever, <code>constraints</code> will be <code>null</code>.\n+   *\n+   * <p>Note that we expect that only very few constraints will\n+   * typically be imposed on a category. The most common case will\n+   * be zero.\n+   */\n+  private IdentityHashMap[] constraints;\n+\n+  \n+  /**\n+   * Constructs a <code>ServiceRegistry</code> for the specified\n+   * service categories.\n+   *\n+   * @throws IllegalArgumentException if <code>categories</code> is\n+   * <code>null</code>, or if its {@link Iterator#next()} method\n+   * returns <code>null</code>.\n+   *\n+   * @throws ClassCastException if <code>categories</code> does not\n+   * iterate over instances of {@link java.lang.Class}.\n+   */\n+  public ServiceRegistry(Iterator categories)\n+  {\n+    ArrayList cats = new ArrayList(/* expected size */ 10);\n+\n+    if (categories == null)\n+      throw new IllegalArgumentException();\n+\n+    while (categories.hasNext())\n+      {\n+        Class cat = (Class) categories.next();\n+        if (cat == null)\n+          throw new IllegalArgumentException();\n+        cats.add(cat);\n+      }\n+\n+    int numCats = cats.size();\n+    this.categories = (Class[]) cats.toArray(new Class[numCats]);\n+    this.providers = new LinkedList[numCats];\n+  }\n+\n+\n+  /**\n+   * Finds service providers that are implementing the specified\n+   * Service Provider Interface.\n+   *\n+   * <p><b>On-demand loading:</b> Loading and initializing service\n+   * providers is delayed as much as possible. The rationale is that\n+   * typical clients will iterate through the set of installed service\n+   * providers until one is found that matches some criteria (like\n+   * supported formats, or quality of service). In such scenarios, it\n+   * might make sense to install only the frequently needed service\n+   * providers on the local machine. More exotic providers can be put\n+   * onto a server; the server will only be contacted when no suitable\n+   * service could be found locally.\n+   *\n+   * <p><b>Security considerations:</b> Any loaded service providers\n+   * are loaded through the specified ClassLoader, or the system\n+   * ClassLoader if <code>classLoader</code> is\n+   * <code>null</code>. When <code>lookupProviders</code> is called,\n+   * the current {@link java.security.AccessControlContext} gets\n+   * recorded. This captured security context will determine the\n+   * permissions when services get loaded via the <code>next()</code>\n+   * method of the returned <code>Iterator</code>.\n+   *\n+   * @param spi the service provider interface which must be\n+   * implemented by any loaded service providers.\n+   *\n+   * @param loader the class loader that will be used to load the\n+   * service providers, or <code>null</code> for the system class\n+   * loader. For using the context class loader, see {@link\n+   * #lookupProviders(Class)}.\n+   *\n+   * @return an iterator over instances of <code>spi</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>spi</code> is\n+   * <code>null</code>.\n+   */\n+  public static Iterator lookupProviders(Class spi,\n+                                         ClassLoader loader)\n+  {\n+    return ServiceFactory.lookupProviders(spi, loader);\n+  }\n+\n+\n+  /**\n+   * Finds service providers that are implementing the specified\n+   * Service Provider Interface, using the context class loader\n+   * for loading providers.\n+   *\n+   * @param spi the service provider interface which must be\n+   * implemented by any loaded service providers.\n+   *\n+   * @return an iterator over instances of <code>spi</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>spi</code> is\n+   * <code>null</code>.\n+   *\n+   * @see #lookupProviders(Class, ClassLoader)\n+   */\n+  public static Iterator lookupProviders(Class spi)\n+  {\n+    return ServiceFactory.lookupProviders(spi);\n+  }\n+\n+\n+  /**\n+   * Returns an iterator over all service categories.\n+   *\n+   * @return an unmodifiable {@link\n+   * java.util.Iterator}&lt;{@link java.lang.Class}&gt;.\n+   */\n+  public Iterator getCategories()\n+  {\n+    return new Iterator()\n+      {\n+        int index = -1;\n+\n+        public boolean hasNext()\n+        {\n+          return index < categories.length - 1;\n+        }\n+\n+        public Object next()\n+        {\n+          if (!hasNext())\n+            throw new NoSuchElementException();\n+\n+          return categories[++index];\n+        }\n+\n+        public void remove()\n+        {\n+          throw new UnsupportedOperationException();\n+        }\n+      };\n+  }\n+\n+\n+  /**\n+   * Registers a provider for a service category which is specified by\n+   * the class-internal category ID.\n+   *\n+   * @param provider the service provider to be registered.\n+   *\n+   * @param cat the service category, which is identified by an index\n+   * into the {@link #categories} array.\n+   *\n+   * @return <code>true</code> if <code>provider</code> is the first\n+   * provider that gets registered for the specified service category;\n+   * <code>false</code> if other providers have already been\n+   * registered for the same servide category.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws ClassCastException if <code>provider</code> does not\n+   * implement the specified service provider interface.\n+   */\n+  private synchronized boolean registerServiceProvider(Object provider,\n+                                                       int cat)\n+  {\n+    LinkedList provs;\n+    boolean result;\n+    Class category;\n+\n+    if (provider == null)\n+      throw new IllegalArgumentException();\n+\n+    category = categories[cat];\n+    if (!category.isInstance(provider))\n+      throw new ClassCastException(category.getName());\n+\n+    provs = providers[cat];\n+    if (provs == null)\n+    {\n+      result = true;\n+      provs = providers[cat] = new LinkedList();\n+    }\n+    else\n+      result = false;\n+\n+    provs.add(provider);\n+    if (provider instanceof RegisterableService)\n+      ((RegisterableService) provider).onRegistration(this, category);\n+\n+    return result;\n+  }\n+\n+\n+  /**\n+   * Registers a provider for the specified service category.\n+   *\n+   * <p>If <code>provider</code> implements the {@link\n+   * RegisterableService} interface, its {@link\n+   * RegisterableService#onRegistration onRegistration} method is\n+   * invoked in order to inform the provider about the addition to\n+   * this registry.\n+   *\n+   * @param provider the service provider to be registered.\n+   *\n+   * @param category the service category under which\n+   * <code>provider</code> shall be registered.\n+   *\n+   * @return <code>true</code> if <code>provider</code> is the first\n+   * provider that gets registered for the specified service category;\n+   * <code>false</code> if other providers have already been\n+   * registered for the same servide category.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>, or if <code>category</code> is not among the\n+   * categories passed to the {@linkplain #ServiceRegistry(Iterator)\n+   * constructor} of this ServiceRegistry.\n+   *\n+   * @throws ClassCastException if <code>provider</code> does not\n+   * implement <code>category</code>.\n+   */\n+  public synchronized boolean registerServiceProvider(Object provider,\n+                                                      Class category)\n+  {\n+    for (int i = 0; i < categories.length; i++)\n+      if (categories[i] == category)\n+        return registerServiceProvider(provider, i);\n+    throw new IllegalArgumentException();\n+  }\n+\n+\n+  /**\n+   * Registers a provider under all service categories it\n+   * implements.\n+   *\n+   * <p>If <code>provider</code> implements the {@link\n+   * RegisterableService} interface, its {@link\n+   * RegisterableService#onRegistration onRegistration} method is\n+   * invoked in order to inform the provider about the addition to\n+   * this registry. If <code>provider</code> implements several\n+   * service categories, <code>onRegistration</code> gets called\n+   * multiple times.\n+   *\n+   * @param provider the service provider to be registered.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>, or if <code>provider</code> does not implement\n+   * any of the service categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this ServiceRegistry.\n+   */\n+  public synchronized void registerServiceProvider(Object provider)\n+  {\n+    boolean ok = false;\n+\n+    if (provider == null)\n+      throw new IllegalArgumentException();\n+\n+    for (int i = 0; i < categories.length; i++)\n+      if (categories[i].isInstance(provider))\n+        {\n+          ok = true;\n+          registerServiceProvider(provider, i);\n+        }\n+\n+    if (!ok)\n+      throw new IllegalArgumentException();\n+  }\n+\n+\n+  /**\n+   * Registers a number of providers under all service categories they\n+   * implement.\n+   *\n+   * <p>If a provider implements the {@link RegisterableService}\n+   * interface, its {@link RegisterableService#onRegistration\n+   * onRegistration} method is invoked in order to inform the provider\n+   * about the addition to this registry. If <code>provider</code>\n+   * implements several service categories,\n+   * <code>onRegistration</code> gets called multiple times.\n+   *\n+   * @throws IllegalArgumentException if <code>providers</code> is\n+   * <code>null</code>, if any iterated provider is <code>null</code>,\n+   * or if some iterated provider does not implement any of the\n+   * service categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this\n+   * <code>ServiceRegistry</code>.\n+   */\n+  public synchronized void registerServiceProviders(Iterator providers)\n+  {\n+    if (providers == null)\n+      throw new IllegalArgumentException();\n+\n+    while (providers.hasNext())\n+      registerServiceProvider(providers.next());\n+  }\n+\n+\n+  /**\n+   * De-registers a provider for a service category which is specified\n+   * by the class-internal category ID.\n+   *\n+   * @param provider the service provider to be registered.\n+   *\n+   * @param cat the service category, which is identified by an index\n+   * into the {@link #categories} array.\n+   *\n+   * @return <code>true</code> if <code>provider</code> was previously\n+   * registered for the specified service category; <code>false</code>\n+   * if if the provider had not been registered.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws ClassCastException if <code>provider</code> does not\n+   * implement the specified service provider interface.\n+   */\n+  private synchronized boolean deregisterServiceProvider(Object provider,\n+                                                         int cat)\n+  {\n+    LinkedList provs;\n+    boolean result;\n+    Class category;\n+\n+    if (provider == null)\n+      throw new IllegalArgumentException();\n+\n+    category = categories[cat];\n+    if (!category.isInstance(provider))\n+      throw new ClassCastException(category.getName());\n+\n+    provs = providers[cat];\n+    if (provs == null)\n+      return false;\n+\n+    result = provs.remove(provider);\n+    if (provs.isEmpty())\n+      providers[cat] = null;\n+\n+    if (result && (provider instanceof RegisterableService))\n+      ((RegisterableService) provider).onDeregistration(this, category);\n+\n+    return result;\n+  }\n+\n+\n+  /**\n+   * De-registers a provider for the specified service category.\n+   *\n+   * <p>If <code>provider</code> implements the {@link\n+   * RegisterableService} interface, its {@link\n+   * RegisterableService#onDeregistration onDeregistration} method is\n+   * invoked in order to inform the provider about the removal from\n+   * this registry.\n+   *\n+   * @param provider the service provider to be de-registered.\n+   *\n+   * @param category the service category from which\n+   * <code>provider</code> shall be de-registered.\n+   *\n+   * @return <code>true</code> if <code>provider</code> was previously\n+   * registered for the specified service category; <code>false</code>\n+   * if if the provider had not been registered.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>, or if <code>category</code> is not among the\n+   * categories passed to the {@linkplain #ServiceRegistry(Iterator)\n+   * constructor} of this ServiceRegistry.\n+   *\n+   * @throws ClassCastException if <code>provider</code> does not\n+   * implement <code>category</code>.\n+   */\n+  public synchronized boolean deregisterServiceProvider(Object provider,\n+                                                        Class category)\n+  {\n+    for (int i = 0; i < categories.length; i++)\n+      if (categories[i] == category)\n+        return deregisterServiceProvider(provider, i);\n+    throw new IllegalArgumentException();\n+  }\n+  \n+  \n+  /**\n+   * De-registers a provider from all service categories it\n+   * implements.\n+   *\n+   * <p>If <code>provider</code> implements the {@link\n+   * RegisterableService} interface, its {@link\n+   * RegisterableService#onDeregistration onDeregistration} method is\n+   * invoked in order to inform the provider about the removal from\n+   * this registry. If <code>provider</code> implements several\n+   * service categories, <code>onDeregistration</code> gets called\n+   * multiple times.\n+   *\n+   * @param provider the service provider to be de-registered.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>, or if <code>provider</code> does not implement\n+   * any of the service categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this\n+   * <code>ServiceRegistry</code>.\n+   */\n+  public synchronized void deregisterServiceProvider(Object provider)\n+  {\n+    boolean ok = false;\n+\n+    if (provider == null)\n+      throw new IllegalArgumentException();\n+\n+    for (int i = 0; i < categories.length; i++)\n+      if (categories[i].isInstance(provider))\n+        {\n+          ok = true;\n+          deregisterServiceProvider(provider, i);\n+        }\n+\n+    if (!ok)\n+      throw new IllegalArgumentException();\n+  }\n+\n+\n+  /**\n+   * De-registers all providers which have been registered for the\n+   * specified service category.\n+   *\n+   * <p>If a provider implements the {@link RegisterableService}\n+   * interface, its {@link RegisterableService#onDeregistration\n+   * onDeregistration} method is invoked in order to inform the\n+   * provider about the removal from this registry. If the provider\n+   * implements several service categories,\n+   * <code>onDeregistration</code> gets called multiple times.\n+   *\n+   * @param category the category whose registered providers will be\n+   * de-registered.\n+   *\n+   * @throws IllegalArgumentException if <code>category</code> is not\n+   * among the categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this\n+   * <code>ServiceRegistry</code>.\n+   */\n+  public synchronized void deregisterAll(Class category)\n+  {\n+    boolean ok = false;\n+\n+    for (int i = 0; i < categories.length; i++)\n+      {\n+        if (categories[i] != category)\n+          continue;\n+\n+        ok = true;\n+        while (providers[i] != null)\n+          deregisterServiceProvider(providers[i].get(0), i);\n+      }\n+\n+    if (!ok)\n+      throw new IllegalArgumentException();\n+  }\n+\n+\n+  /**\n+   * De-registers all service providers.\n+   *\n+   * <p>If a provider implements the {@link RegisterableService}\n+   * interface, its {@link RegisterableService#onDeregistration\n+   * onDeregistration} method is invoked in order to inform the\n+   * provider about the removal from this registry. If the provider\n+   * implements several service categories,\n+   * <code>onDeregistration</code> gets called multiple times.\n+   */\n+  public synchronized void deregisterAll()\n+  {\n+    for (int i = 0; i < categories.length; i++)\n+      while (providers[i] != null)\n+        deregisterServiceProvider(providers[i].get(0), i);\n+  }\n+\n+\n+  /**\n+   * Called by the Virtual Machine when it detects that this\n+   * <code>ServiceRegistry</code> has become garbage. De-registers all\n+   * service providers, which will cause those that implement {@link\n+   * RegisterableService} to receive a {@link\n+   * RegisterableService#onDeregistration onDeregistration}\n+   * notification.\n+   */\n+  public void finalize()\n+    throws Throwable\n+  {\n+    super.finalize();\n+    deregisterAll();\n+  }\n+\n+\n+  /**\n+   * Determines whether a provider has been registered with this\n+   * registry.\n+   *\n+   * @return <code>true</code> if <code>provider</code> has been\n+   * registered under any service category; <code>false</code> if\n+   * it is not registered.\n+   *\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   * <code>null</code>.\n+   */\n+  public synchronized boolean contains(Object provider)\n+  {\n+    if (provider == null)\n+      throw new IllegalArgumentException();\n+\n+    // Note that contains is rather unlikely to be ever called,\n+    // so it would be wasteful to keep a special data structure\n+    // (such as a HashSet) for making it a fast operation.\n+    for (int i = 0; i < providers.length; i++)\n+      {\n+        // If provider does not implement categories[i],\n+        // it would not have been possible to register it there.\n+        // In that case, it would be pointless to look there.\n+        if (!categories[i].isInstance(provider))\n+          continue;\n+\n+        // But if the list of registered providers contains provider,\n+        // we have found it.\n+        LinkedList p = providers[i];\n+        if (p != null && p.contains(provider))\n+          return true;\n+      }\n+\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Returns the index in {@link #categories} occupied by the\n+   * specified service category.\n+   *\n+   * @throws IllegalArgumentException if <code>category</code> is not\n+   * among the categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this ServiceRegistry.\n+   */\n+  private int getCategoryID(Class category)\n+  {\n+    for (int i = 0; i < categories.length; i++)\n+      if (categories[i] == category)\n+        return i;\n+\n+    throw new IllegalArgumentException();\n+  }\n+\n+\n+  /**\n+   * Retrieves all providers that have been registered for the\n+   * specified service category.\n+   *\n+   * @param category the service category whose providers are\n+   * to be retrieved.\n+   *\n+   * @param useOrdering <code>true</code> in order to retrieve the\n+   * providers in an order imposed by the {@linkplain #setOrdering\n+   * ordering constraints}; <code>false</code> in order to retrieve\n+   * the providers in any order.\n+   *\n+   * @throws IllegalArgumentException if <code>category</code> is not\n+   * among the categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this\n+   * <code>ServiceRegistry</code>.\n+   *\n+   * @see #getServiceProviders(Class, Filter, boolean)\n+   */\n+  public Iterator getServiceProviders(Class category, boolean useOrdering)\n+  {\n+    return getServiceProviders(category, null, useOrdering);\n+  }\n+\n+\n+  /**\n+   * Retrieves all providers that have been registered for the\n+   * specified service category and that satisfy the criteria\n+   * of a custom filter.\n+   *\n+   * @param category the service category whose providers are\n+   * to be retrieved.\n+   *\n+   * @param filter a custom filter, or <code>null</code> to\n+   * retrieve all registered providers for the specified\n+   * category.\n+   *\n+   * @param useOrdering <code>true</code> in order to retrieve the\n+   * providers in an order imposed by the {@linkplain #setOrdering\n+   * ordering constraints}; <code>false</code> in order to retrieve\n+   * the providers in any order.\n+   *\n+   * @throws IllegalArgumentException if <code>category</code> is not\n+   * among the categories passed to the {@linkplain\n+   * #ServiceRegistry(Iterator) constructor} of this\n+   * <code>ServiceRegistry</code>.\n+   */\n+  public synchronized Iterator getServiceProviders(Class category,\n+                                                   Filter filter,\n+                                                   boolean useOrdering)\n+  {\n+    int catid;\n+    LinkedList provs;\n+    ArrayList result;\n+\n+    catid = getCategoryID(category);\n+    provs = providers[catid];\n+    if (provs == null)\n+      return Collections.EMPTY_LIST.iterator();\n+    \n+    result = new ArrayList(provs.size());\n+    for (Iterator iter = provs.iterator(); iter.hasNext();)\n+      {\n+        Object provider = iter.next();\n+        if (filter == null || filter.filter(provider))\n+          result.add(provider);\n+      }\n+\n+    // If we are supposed to obey ordering constraints, and\n+    // if any constraints have been imposed on the specified\n+    // service category, sort the result.\n+    if (useOrdering && constraints != null)\n+      {\n+        final Map cons = constraints[catid];\n+        if (cons != null)\n+          Collections.sort(result, new Comparator()\n+            {\n+              public int compare(Object o1, Object o2)\n+              {\n+                Set s;\n+\n+                if (o1 == o2)\n+                  return 0;\n+                \n+                s = (Set) cons.get(o1);\n+                if (s != null && s.contains(o2))\n+                  return -1;  // o1 < o2\n+\n+                s = (Set) cons.get(o2);\n+                if (s != null && s.contains(o1))\n+                  return 1;  // o1 > o2\n+\n+                return 0; // o1 == o2\n+              }\n+            });\n+      }\n+\n+    return result.iterator();\n+  }\n+\n+\n+  /**\n+   * Returns one of the service providers that is a subclass of the\n+   * specified class.\n+   * \n+   * @param providerClass a class to search for.\n+   */\n+  public synchronized Object getServiceProviderByClass(Class providerClass)\n+  {\n+    if (providerClass == null)\n+      throw new IllegalArgumentException();\n+\n+    // Note that the method getServiceProviderByClass is rather\n+    // unlikely to be ever called, so it would be wasteful to keep a\n+    // special data structure for making it a fast operation.\n+    for (int cat = 0; cat < categories.length; cat++)\n+      {\n+        if (!categories[cat].isAssignableFrom(providerClass))\n+          continue;\n+        \n+        LinkedList provs = providers[cat];\n+        if (provs == null)\n+          continue;\n+\n+        for (Iterator iter = provs.iterator(); iter.hasNext();)\n+          {\n+            Object provider = iter.next();\n+            if (providerClass.isInstance(provider))\n+              return provider;\n+          }\n+      }\n+\n+    return null;\n+  }\n+\n+\n+  /**\n+   * Adds an ordering constraint on service providers.\n+   *\n+   * @param category the service category to which an ordering\n+   * constraint is to be added.\n+   *\n+   * @param first the provider which is supposed to come before\n+   * <code>second</code>.\n+   *\n+   * @param second the provider which is supposed to come after\n+   * <code>first</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>first</code> and\n+   * <code>second</code> are referring to the same object, or if one\n+   * of them is <code>null</code>.\n+   *\n+   * @see #unsetOrdering\n+   * @see #getServiceProviders(Class, Filter, boolean)\n+   */\n+  public synchronized boolean setOrdering(Class category,\n+                                          Object firstProvider,\n+                                          Object secondProvider)\n+  {\n+    return addConstraint(getCategoryID(category), firstProvider,\n+                         secondProvider);\n+  }\n+\n+\n+  /**\n+   * Removes an ordering constraint on service providers.\n+   *\n+   * @param category the service category from which an ordering\n+   * constraint is to be removed.\n+   *\n+   * @param first the provider which is supposed to come before\n+   * <code>second</code>.\n+   *\n+   * @param second the provider which is supposed to come after\n+   * <code>first</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>first</code> and\n+   * <code>second</code> are referring to the same object, or if one\n+   * of them is <code>null</code>.\n+   *\n+   * @see #setOrdering\n+   */\n+  public synchronized boolean unsetOrdering(Class category,\n+                                            Object firstProvider,\n+                                            Object secondProvider)\n+  {\n+    return removeConstraint(getCategoryID(category),\n+                            firstProvider, secondProvider);\n+  }\n+\n+\n+  /**\n+   * Adds an ordering constraint on service providers.\n+   *\n+   * @param catid the service category ID, which is the\n+   * category&#x2019;s index into the {@link #categories} array.\n+   *\n+   * @param first the provider which is supposed to come before\n+   * <code>second</code>.\n+   *\n+   * @param second the provider which is supposed to come after\n+   * <code>first</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>first</code> and\n+   * <code>second</code> are referring to the same object, or if one\n+   * of them is <code>null</code>.\n+   */\n+  private boolean addConstraint(int catid, Object first, Object second)\n+  {\n+    Set s;\n+    IdentityHashMap cons;\n+\n+    // Also checks argument validity.\n+    removeConstraint(catid, second, first);\n+\n+    if (constraints == null)\n+      constraints = new IdentityHashMap[categories.length];\n+    cons = constraints[catid];\n+    if (cons == null)\n+      cons = constraints[catid] = new IdentityHashMap();\n+\n+    s = (Set) cons.get(first);\n+    if (s == null)\n+      cons.put(first, s = new HashSet());\n+    return s.add(second);\n+  }\n+\n+\n+  /**\n+   * Removes an ordering constraint on service providers.\n+   *\n+   * @param catid the service category ID, which is the\n+   * category&#x2019;s index into the {@link #categories} array.\n+   *\n+   * @param first the provider which is supposed to come before\n+   * <code>second</code>.\n+   *\n+   * @param second the provider which is supposed to come after\n+   * <code>first</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>first</code> and\n+   * <code>second</code> are referring to the same object, or if one\n+   * of them is <code>null</code>.\n+   */\n+  private boolean removeConstraint(int catid, Object first, Object second)\n+  {\n+    Collection s;\n+    IdentityHashMap cons;\n+\n+    if (first == null || second == null || first == second)\n+      throw new IllegalArgumentException();\n+\n+    if (constraints == null)\n+      return false;\n+\n+    cons = constraints[catid];\n+    if (cons == null)\n+      return false;\n+\n+    s = (Collection) cons.get(first);\n+    if (s == null)\n+      return false;\n+\n+    if (!s.remove(second))\n+      return false;\n+\n+    // If we removed the last constraint for a service category,\n+    // we can get free some memory.\n+    if (cons.isEmpty())\n+      {\n+        constraints[catid] = null;\n+        boolean anyConstraints = false;\n+        for (int i = 0; i < constraints.length; i++)\n+          {\n+            if (constraints[i] != null)\n+              {\n+                anyConstraints = true;\n+                break;\n+              }\n+          }\n+        if (!anyConstraints)\n+          constraints = null;\n+      }\n+\n+    return true;\n+  }\n+\n+\n+  /**\n+   * A filter for selecting service providers that match custom\n+   * criteria.\n+   *\n+   * @see ServiceRegistry#getServiceProviders(Class, Filter,\n+   * boolean)\n+   *\n+   * @since 1.4\n+   *\n+   * @author <a href=\"mailto:konqueror@gmx.de\">Michael Koch</a>\n+   * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+   */\n+  public static interface Filter\n+  {\n+    /**\n+     * Checks whether the specified service provider matches the\n+     * constraints of this Filter.\n+     *\n+     * @param provider the service provider in question.\n+     *\n+     * @return <code>true</code> if <code>provider</code> matches the\n+     * criteria; <code>false</code> if it does not match.\n+     */\n+    boolean filter(Object provider);\n+  };\n+}\n+"}, {"sha": "5c0779e6876e6c6037d1a34d0f1618d38f669afb", "filename": "libjava/javax/imageio/spi/package.html", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2Fpackage.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fspi%2Fpackage.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fspi%2Fpackage.html?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,46 @@\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n+<!-- package.html - describes classes in javax.imageio.spi package.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. -->\n+\n+<html>\n+<head><title>GNU Classpath - javax.imageio.spi</title></head>\n+\n+<body>\n+<p></p>\n+\n+</body>\n+</html>"}, {"sha": "c9e230f5f792280991e3267d5974c5ef8c4c9098", "filename": "libjava/javax/imageio/stream/IIOByteBuffer.java", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2FIIOByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2FIIOByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FIIOByteBuffer.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,94 @@\n+/* IIOByteBuffer.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.stream;\n+\n+/**\n+ * A data structure for holding a reference to a byte array, an index\n+ * into that array, and a number of bytes, that can be passed to one\n+ * specific variant of the {@link\n+ * javax.imageio.stream.ImageInputStream#readBytes(IIOByteBuffer, int)\n+ * readBytes} method.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public class IIOByteBuffer\n+{\n+  private byte[] data;\n+  private int offset;\n+  private int length;\n+\n+  public IIOByteBuffer(byte[] data, int offset, int length)\n+  {\n+    this.data = data;\n+    this.offset = offset;\n+    this.length = length;\n+  }\n+\n+  public byte[] getData()\n+  {\n+    return data;\n+  }\n+\n+  public void setData(byte[] data)\n+  {\n+    this.data = data;\n+  }\n+\n+  public int getOffset()\n+  {\n+    return offset;\n+  }\n+\n+  public void setOffset(int offset)\n+  {\n+    this.offset = offset;\n+  }\n+\n+  public int getLength()\n+  {\n+    return length;\n+  }\n+\n+  public void setLength(int length)\n+  {\n+    this.length = length;\n+  }\n+}"}, {"sha": "4b509f8579836c21f76ea2d84ce6de2aaacf89fa", "filename": "libjava/javax/imageio/stream/ImageInputStream.java", "status": "added", "additions": 652, "deletions": 0, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2FImageInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2FImageInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FImageInputStream.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,652 @@\n+/* ImageInputStream.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.stream;\n+\n+import java.io.DataInput;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.nio.ByteOrder;\n+\n+\n+/**\n+ * An input stream for use by {@link javax.imageio.ImageReader\n+ * ImageReaders}.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public interface ImageInputStream\n+  extends DataInput\n+{\n+  void setByteOrder(ByteOrder order);\n+\n+  ByteOrder getByteOrder();\n+  \n+  int read()\n+    throws IOException;\n+\n+  int read(byte[] b)\n+    throws IOException;\n+\n+  int read(byte[] b, int offset, int length)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads up to a specified number of bytes, and modifies a\n+   * {@link IIOByteBuffer} to hold the read data.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   *\n+   * @param buf an <code>IIOByteBuffer</code> that will hold the read\n+   * data.\n+   *\n+   * @param numBytes the maximum number of bytes to read.\n+   *\n+   * @throws IndexOutOfBoundsException if <code>numBytes</code> is\n+   * negative.\n+   *\n+   * @throws NullPointerException if <code>buf</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   */\n+  void readBytes(IIOByteBuffer buf, int numBytes)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a byte and checks whether or not its value is zero.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before the byte is read.\n+   *\n+   * @throws EOFException if the input stream is at its end.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readBit()\n+   * @see #readByte()\n+   * @see #readFully(byte[], int, int)\n+   */\n+  boolean readBoolean()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a signed byte.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   *\n+   * @throws EOFException if the input stream is at its end.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readUnsignedByte()\n+   * @see #readFully(byte[], int, int)\n+   */\n+  byte readByte()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an unsigned byte.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   *\n+   * @throws EOFException if the input stream is at its end.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readByte()\n+   * @see #readFully(byte[], int, int)\n+   */\n+  int readUnsignedByte()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an signed 16-bit integer. If necessary, the value gets\n+   * converted from the stream&#x2019;s {@linkplain #getByteOrder()\n+   * current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @throws EOFException if the input stream ends before all two\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readUnsignedShort()\n+   * @see #readChar()\n+   * @see #readFully(short[], int, int)\n+   */\n+  short readShort()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an unsigned 16-bit integer. If necessary, the value gets\n+   * converted from the stream&#x2019;s {@linkplain #getByteOrder()\n+   * current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * <p>This method does the same as {@link #readChar()}.\n+   *\n+   * @throws EOFException if the input stream ends before all two\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readShort()\n+   * @see #readChar()\n+   * @see #readFully(char[], int, int)\n+   */\n+  int readUnsignedShort()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an unsigned 16-bit integer. If necessary, the value gets\n+   * converted from the stream&#x2019;s {@linkplain #getByteOrder()\n+   * current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * <p>This method does the same as {@link #readUnsignedShort()}.\n+   *\n+   * @throws EOFException if the input stream ends before all two\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readFully(char[], int, int)\n+   */\n+  char readChar()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a signed 32-bit integer. If necessary, the value gets\n+   * converted from the stream&#x2019;s {@linkplain #getByteOrder()\n+   * current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @throws EOFException if the input stream ends before all four\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readUnsignedInt()\n+   * @see #readFully(int[], int, int)\n+   */\n+  int readInt()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an unsigned 32-bit integer. If necessary, the value gets\n+   * converted from the stream&#x2019;s {@linkplain #getByteOrder()\n+   * current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @throws EOFException if the input stream ends before all four\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readInt()\n+   * @see #readFully(int[], int, int)\n+   */\n+  long readUnsignedInt()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a signed 64-bit integer. If necessary, the value gets\n+   * converted from the stream&#x2019;s {@linkplain #getByteOrder()\n+   * current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @throws EOFException if the input stream ends before all eight\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readFully(long[], int, int)\n+   */\n+  long readLong()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an IEEE 32-bit single-precision floating point number. If\n+   * necessary, the value gets converted from the stream&#x2019;s\n+   * {@linkplain #getByteOrder() current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @throws EOFException if the input stream ends before all four\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readFully(float[], int, int)\n+   */\n+  float readFloat()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads an IEEE 64-bit double-precision floating point number. If\n+   * necessary, the value gets converted from the stream&#x2019;s\n+   * {@linkplain #getByteOrder() current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @throws EOFException if the input stream ends before all eight\n+   * bytes were read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readFully(double[], int, int)\n+   */\n+  double readDouble()\n+    throws IOException;\n+\n+  String readLine()\n+    throws IOException;\n+\n+  String readUTF()\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of signed 8-bit integers into a\n+   * <code>byte[]</code> array.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param b an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>b</code>\n+   * that will hold read data.\n+   *\n+   * @param numBytes the number of bytes to read.\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numBytes</code> is negative, or if <code>offset +\n+   * numBytes</code> exceeds <code>b.length</code>.\n+   *\n+   * @throws NullPointerException if <code>b</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readByte()\n+   */\n+  void readFully(byte[] b, int offset, int numBytes)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of signed 8-bit integers into a\n+   * <code>byte[]</code> array.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param b an array for storing the read values.\n+   *\n+   * @throws NullPointerException if <code>b</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readByte()\n+   * @see #readFully(byte[], int, int)\n+   */\n+  void readFully(byte[] b)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of signed 16-bit integers into a\n+   * <code>short[]</code> array.  If necessary, values are converted\n+   * from the stream&#x2019;s {@linkplain #getByteOrder() current byte\n+   * order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param s an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>s</code>\n+   * that will hold read data.\n+   *\n+   * @param numShorts the number of signed 16-bit integers to read\n+   * (which is one half of the number of bytes).\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numShorts</code> is negative, or if <code>offset +\n+   * numShorts</code> exceeds <code>s.length</code>.\n+   *\n+   * @throws NullPointerException if <code>s</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readShort()\n+   */\n+  void readFully(short[] s, int offset, int numShorts)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of unsigned 16-bit integers into a\n+   * <code>char[]</code> array.  If necessary, values are converted\n+   * from the stream&#x2019;s {@linkplain #getByteOrder() current byte\n+   * order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param c an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>c</code>\n+   * that will hold read data.\n+   *\n+   * @param numChars the number of unsigned 16-bit integers to read\n+   * (which is one half of the number of bytes).\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numChars</code> is negative, or if <code>offset +\n+   * numChars</code> exceeds <code>c.length</code>.\n+   *\n+   * @throws NullPointerException if <code>c</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readChar()\n+   */\n+  void readFully(char[] c, int offset, int numChars)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of signed 32-bit integers into a\n+   * <code>long[]</code> array.  If necessary, values are converted\n+   * from the stream&#x2019;s {@linkplain #getByteOrder() current byte\n+   * order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param i an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>i</code>\n+   * that will hold read data.\n+   *\n+   * @param numLongs the number of signed 32-bit integers to read\n+   * (which is one fourth of the number of bytes).\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numInts</code> is negative, or if <code>offset +\n+   * numInts</code> exceeds <code>i.length</code>.\n+   *\n+   * @throws NullPointerException if <code>i</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readInt()\n+   */\n+  void readFully(int[] i, int offset, int numInts)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of signed 64-bit integers into a\n+   * <code>long[]</code> array.  If necessary, values are converted\n+   * from the stream&#x2019;s {@linkplain #getByteOrder() current byte\n+   * order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param l an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>l</code>\n+   * that will hold read data.\n+   *\n+   * @param numLongs the number of signed 64-bit integers to read\n+   * (which is one eight of the number of bytes).\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numLongs</code> is negative, or if <code>offset +\n+   * numLongs</code> exceeds <code>l.length</code>.\n+   *\n+   * @throws NullPointerException if <code>l</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readLong()\n+   */\n+  void readFully(long[] l, int offset, int numLongs)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of IEEE 32-bit single-precision floating point\n+   * numbers into a <code>float[]</code> array.  If necessary, values\n+   * are converted from the stream&#x2019;s {@linkplain\n+   * #getByteOrder() current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param d an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>d</code>\n+   * that will hold read data.\n+   *\n+   * @param numFloats the number of IEEE 32-bit single-precision\n+   * floating point numbers to read (which is one fourth of the number\n+   * of bytes).\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numFloats</code> is negative, or if <code>offset +\n+   * numFloats</code> exceeds <code>f.length</code>.\n+   *\n+   * @throws NullPointerException if <code>f</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readFloat()\n+   */\n+  void readFully(float[] f, int offset, int numFloats)\n+    throws IOException;\n+\n+\n+  /**\n+   * Reads a sequence of IEEE 64-bit double-precision floating point\n+   * numbers into a <code>double[]</code> array.  If necessary, values\n+   * are converted from the stream&#x2019;s {@linkplain\n+   * #getByteOrder() current byte order}.\n+   *\n+   * <p>The {@linkplain #getBitOffset() bit offset} is set to zero\n+   * before any data is read.\n+   * \n+   * @param d an array for storing the read values.\n+   *\n+   * @param offset the index of the first element in <code>d</code>\n+   * that will hold read data.\n+   *\n+   * @param numDoubles the number of IEEE 64-bit double-precision\n+   * floating point numbers to read (which is one eight of the number\n+   * of bytes).\n+   *\n+   * @throws IndexOutOfBoundsException if <code>offset</code> or\n+   * <code>numDoubles</code> is negative, or if <code>offset +\n+   * numDoubles</code> exceeds <code>d.length</code>.\n+   *\n+   * @throws NullPointerException if <code>d</code> is\n+   * <code>null</code>.\n+   *\n+   * @throws EOFException if the input stream ends before all content\n+   * was read.\n+   *\n+   * @throws IOException if some general problem happens with\n+   * accessing data.\n+   *\n+   * @see #readDouble()\n+   */\n+  void readFully(double[] d, int offset, int numDoubles)\n+    throws IOException;\n+\n+  long getStreamPosition()\n+    throws IOException;\n+\n+  int getBitOffset()\n+    throws IOException;\n+\n+  void setBitOffset(int bitOffset)\n+    throws IOException;\n+\n+  int readBit()\n+    throws IOException;\n+\n+  long readBits(int numBits)\n+    throws IOException;\n+\n+  long length()\n+    throws IOException;\n+\n+  int skipBytes(int numBytes)\n+    throws IOException;\n+\n+  long skipBytes(long numBytes)\n+    throws IOException;\n+\n+  void seek(long pos)\n+    throws IOException;\n+\n+  void mark()\n+    throws IOException;\n+\n+  void reset()\n+    throws IOException;\n+\n+  void flushBefore(long pos)\n+    throws IOException;\n+\n+  void flush()\n+    throws IOException;\n+\n+  long getFlushedPosition();\n+\n+  boolean isCached();\n+\n+  boolean isCachedMemory();\n+\n+  boolean isCachedFile();\n+\n+  void close()\n+    throws IOException;\n+}"}, {"sha": "58a65944aa36e52f43d9d3b888e2a077b353d3c1", "filename": "libjava/javax/imageio/stream/ImageOutputStream.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2FImageOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2FImageOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2FImageOutputStream.java?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,58 @@\n+/* ImageOutputStream.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.imageio.stream;\n+\n+import java.io.DataOutput;\n+\n+\n+/**\n+ * An output stream for use by {@link javax.imageio.ImageWriter\n+ * ImageWriters}.\n+ *\n+ * @since 1.4\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+ */\n+public interface ImageOutputStream\n+  extends ImageInputStream, DataOutput\n+{\n+  // FIXME: Incomplete. This interface is merely present in order to\n+  // allow compilation of the javax.imageio.spi package, for which GNU\n+  // Classpath does provide an implementation.\n+}"}, {"sha": "5449c1237523c1d392baf2ac35ca4e8436284263", "filename": "libjava/javax/imageio/stream/package.html", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2Fpackage.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d22b123242f42c216e90555d07656900e6ae6c/libjava%2Fjavax%2Fimageio%2Fstream%2Fpackage.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fimageio%2Fstream%2Fpackage.html?ref=96d22b123242f42c216e90555d07656900e6ae6c", "patch": "@@ -0,0 +1,46 @@\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n+<!-- package.html - describes classes in javax.imageio.stream package.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. -->\n+\n+<html>\n+<head><title>GNU Classpath - javax.imageio.stream</title></head>\n+\n+<body>\n+<p></p>\n+\n+</body>\n+</html>"}]}