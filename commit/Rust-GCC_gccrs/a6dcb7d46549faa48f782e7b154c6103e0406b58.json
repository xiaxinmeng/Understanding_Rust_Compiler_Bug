{"sha": "a6dcb7d46549faa48f782e7b154c6103e0406b58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkY2I3ZDQ2NTQ5ZmFhNDhmNzgyZTdiMTU0YzYxMDNlMDQwNmI1OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-21T22:24:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-21T22:24:47Z"}, "message": "runtime: Catch signals on altstack, disable splitstack signal blocking.\n\nFrom-SVN: r182607", "tree": {"sha": "b581b11b17c97821c10249103de061834481481d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b581b11b17c97821c10249103de061834481481d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6dcb7d46549faa48f782e7b154c6103e0406b58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dcb7d46549faa48f782e7b154c6103e0406b58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6dcb7d46549faa48f782e7b154c6103e0406b58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dcb7d46549faa48f782e7b154c6103e0406b58/comments", "author": null, "committer": null, "parents": [{"sha": "e0d2f0301635c6c3165c159e7d18e5bc07dc7325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d2f0301635c6c3165c159e7d18e5bc07dc7325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d2f0301635c6c3165c159e7d18e5bc07dc7325"}], "stats": {"total": 473, "additions": 340, "deletions": 133}, "files": [{"sha": "24dc74bd285f2ca7486e46126e4078002fb56fa8", "filename": "libgo/runtime/go-panic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fgo-panic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fgo-panic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.c?ref=a6dcb7d46549faa48f782e7b154c6103e0406b58", "patch": "@@ -24,13 +24,13 @@ __printpanics (struct __go_panic_stack *p)\n   if (p->__next != NULL)\n     {\n       __printpanics (p->__next);\n-      printf (\"\\t\");\n+      fprintf (stderr, \"\\t\");\n     }\n-  printf (\"panic: \");\n+  fprintf (stderr, \"panic: \");\n   printany (p->__arg);\n   if (p->__was_recovered)\n-    printf (\" [recovered]\");\n-  putchar ('\\n');\n+    fprintf (stderr, \" [recovered]\");\n+  fputc ('\\n', stderr);\n }\n \n /* This implements __go_panic which is used for the panic"}, {"sha": "e5a790aae52e3b49992cea073141418f4bc8288c", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 293, "deletions": 122, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=a6dcb7d46549faa48f782e7b154c6103e0406b58", "patch": "@@ -17,109 +17,133 @@\n   #define SA_RESTART 0\n #endif\n \n-/* What to do for a signal.  */\n+#ifdef USING_SPLIT_STACK\n \n-struct sigtab\n-{\n-  /* Signal number.  */\n-  int sig;\n-  /* Nonzero if the signal should be caught.  */\n-  _Bool catch;\n-  /* Nonzero if the signal should be queued.  */\n-  _Bool queue;\n-  /* Nonzero if the signal should be ignored.  */\n-  _Bool ignore;\n-  /* Nonzero if we should restart system calls.  */\n-  _Bool restart;\n-};\n+extern void __splitstack_getcontext(void *context[10]);\n \n-/* What to do for signals.  */\n+extern void __splitstack_setcontext(void *context[10]);\n \n-static struct sigtab signals[] =\n-{\n-  { SIGHUP, 0, 1, 0, 1 },\n-  { SIGINT, 0, 1, 0, 1 },\n-  { SIGQUIT, 0, 1, 0, 1 },\n-  { SIGALRM, 0, 1, 1, 1 },\n-  { SIGTERM, 0, 1, 0, 1 },\n+#endif\n+\n+#define C SigCatch\n+#define I SigIgnore\n+#define R SigRestart\n+#define Q SigQueue\n+#define P SigPanic\n+\n+/* Signal actions.  This collects the sigtab tables for several\n+   different targets from the master library.  SIGKILL, SIGCONT, and\n+   SIGSTOP are not listed, as we don't want to set signal handlers for\n+   them.  */\n+\n+SigTab runtime_sigtab[] = {\n+#ifdef SIGHUP\n+  { SIGHUP,\tQ + R },\n+#endif\n+#ifdef SIGINT\n+  { SIGINT, \tQ + R },\n+#endif\n+#ifdef SIGQUIT\n+  { SIGQUIT, \tC },\n+#endif\n #ifdef SIGILL\n-  { SIGILL, 1, 0, 0, 0 },\n+  { SIGILL, \tC },\n #endif\n #ifdef SIGTRAP\n-  { SIGTRAP, 1, 0, 0, 0 },\n+  { SIGTRAP, \tC },\n #endif\n #ifdef SIGABRT\n-  { SIGABRT, 1, 0, 0, 0 },\n+  { SIGABRT, \tC },\n #endif\n #ifdef SIGBUS\n-  { SIGBUS, 1, 0, 0, 0 },\n+  { SIGBUS, \tC + P },\n #endif\n #ifdef SIGFPE\n-  { SIGFPE, 1, 0, 0, 0 },\n+  { SIGFPE, \tC + P },\n #endif\n #ifdef SIGUSR1\n-  { SIGUSR1, 0, 1, 1, 1 },\n+  { SIGUSR1, \tQ + I + R },\n #endif\n #ifdef SIGSEGV\n-  { SIGSEGV, 1, 0, 0, 0 },\n+  { SIGSEGV, \tC + P },\n #endif\n #ifdef SIGUSR2\n-  { SIGUSR2, 0, 1, 1, 1 },\n+  { SIGUSR2, \tQ + I + R },\n #endif\n #ifdef SIGPIPE\n-  { SIGPIPE, 0, 0, 1, 0 },\n+  { SIGPIPE, \tI },\n+#endif\n+#ifdef SIGALRM\n+  { SIGALRM, \tQ + I + R },\n+#endif\n+#ifdef SIGTERM\n+  { SIGTERM, \tQ + R },\n #endif\n #ifdef SIGSTKFLT\n-  { SIGSTKFLT, 1, 0, 0, 0 },\n+  { SIGSTKFLT, \tC },\n #endif\n #ifdef SIGCHLD\n-  { SIGCHLD, 0, 1, 1, 1 },\n+  { SIGCHLD, \tQ + I + R },\n #endif\n #ifdef SIGTSTP\n-  { SIGTSTP, 0, 1, 1, 1 },\n+  { SIGTSTP, \tQ + I + R },\n #endif\n #ifdef SIGTTIN\n-  { SIGTTIN, 0, 1, 1, 1 },\n+  { SIGTTIN, \tQ + I + R },\n #endif\n #ifdef SIGTTOU\n-  { SIGTTOU, 0, 1, 1, 1 },\n+  { SIGTTOU, \tQ + I + R },\n #endif\n #ifdef SIGURG\n-  { SIGURG, 0, 1, 1, 1 },\n+  { SIGURG, \tQ + I + R },\n #endif\n #ifdef SIGXCPU\n-  { SIGXCPU, 0, 1, 1, 1 },\n+  { SIGXCPU, \tQ + I + R },\n #endif\n #ifdef SIGXFSZ\n-  { SIGXFSZ, 0, 1, 1, 1 },\n+  { SIGXFSZ, \tQ + I + R },\n #endif\n-#ifdef SIGVTARLM\n-  { SIGVTALRM, 0, 1, 1, 1 },\n+#ifdef SIGVTALRM\n+  { SIGVTALRM, \tQ + I + R },\n #endif\n #ifdef SIGPROF\n-  { SIGPROF, 0, 1, 1, 1 },\n+  { SIGPROF, \tQ + I + R },\n #endif\n #ifdef SIGWINCH\n-  { SIGWINCH, 0, 1, 1, 1 },\n+  { SIGWINCH, \tQ + I + R },\n #endif\n #ifdef SIGIO\n-  { SIGIO, 0, 1, 1, 1 },\n+  { SIGIO, \tQ + I + R },\n #endif\n #ifdef SIGPWR\n-  { SIGPWR, 0, 1, 1, 1 },\n+  { SIGPWR, \tQ + I + R },\n #endif\n #ifdef SIGSYS\n-  { SIGSYS, 1, 0, 0, 0 },\n+  { SIGSYS, \tC },\n #endif\n-  { -1, 0, 0, 0, 0 }\n+#ifdef SIGEMT\n+  { SIGEMT,\tC },\n+#endif\n+#ifdef SIGINFO\n+  { SIGINFO,\tQ + I + R },\n+#endif\n+#ifdef SIGTHR\n+  { SIGTHR,\tQ + I + R },\n+#endif\n+  { -1,\t\t0 }\n };\n+#undef C\n+#undef I\n+#undef R\n+#undef Q\n+#undef P\n \n-/* The Go signal handler.  */\n+/* Handle a signal, for cases where we don't panic.  We can split the\n+   stack here.  */\n \n static void\n-sighandler (int sig)\n+sig_handler (int sig)\n {\n-  const char *msg;\n   int i;\n \n #ifdef SIGPROF\n@@ -131,99 +155,223 @@ sighandler (int sig)\n     }\n #endif\n \n-  /* FIXME: Should check siginfo for more information when\n-     available.  */\n-  msg = NULL;\n-  switch (sig)\n+  for (i = 0; runtime_sigtab[i].sig != -1; ++i)\n     {\n-#ifdef SIGILL\n-    case SIGILL:\n-      msg = \"illegal instruction\";\n-      break;\n-#endif\n+      struct sigaction sa;\n \n-#ifdef SIGBUS\n-    case SIGBUS:\n-      msg = \"invalid memory address or nil pointer dereference\";\n-      break;\n-#endif\n+      if (runtime_sigtab[i].sig != sig)\n+\tcontinue;\n \n-#ifdef SIGFPE\n-    case SIGFPE:\n-      msg = \"integer divide by zero or floating point error\";\n-      break;\n-#endif\n+      if ((runtime_sigtab[i].flags & SigQueue) != 0)\n+\t{\n+\t  if (__go_sigsend (sig)\n+\t      || (runtime_sigtab[sig].flags & SigIgnore) != 0)\n+\t    return;\n+\t  runtime_exit (2);\t\t// SIGINT, SIGTERM, etc\n+\t}\n \n-#ifdef SIGSEGV\n-    case SIGSEGV:\n-      msg = \"invalid memory address or nil pointer dereference\";\n-      break;\n-#endif\n+      if (runtime_panicking)\n+\truntime_exit (2);\n+      runtime_panicking = 1;\n+\n+      /* We should do a stack backtrace here.  Until we can do that,\n+\t we reraise the signal in order to get a slightly better\n+\t report from the shell.  */\n+\n+      memset (&sa, 0, sizeof sa);\n \n-    default:\n-      break;\n+      sa.sa_handler = SIG_DFL;\n+\n+      i = sigemptyset (&sa.sa_mask);\n+      __go_assert (i == 0);\n+\n+      if (sigaction (sig, &sa, NULL) != 0)\n+\tabort ();\n+\n+      raise (sig);\n+\n+      runtime_exit (2);\n     }\n \n-  if (msg != NULL)\n+  __builtin_unreachable ();\n+}\n+\n+/* The start of handling a signal which panics.  */\n+\n+static void\n+sig_panic_leadin (int sig)\n+{\n+  int i;\n+  sigset_t clear;\n+\n+  if (runtime_m ()->mallocing)\n     {\n-      sigset_t clear;\n+      runtime_printf (\"caught signal while mallocing: %d\\n\", sig);\n+      runtime_throw (\"caught signal while mallocing\");\n+    }\n \n-      if (runtime_m()->mallocing)\n-\t{\n-\t  fprintf (stderr, \"caught signal while mallocing: %s\\n\", msg);\n-\t  __go_assert (0);\n-\t}\n+  /* The signal handler blocked signals; unblock them.  */\n+  i = sigfillset (&clear);\n+  __go_assert (i == 0);\n+  i = sigprocmask (SIG_UNBLOCK, &clear, NULL);\n+  __go_assert (i == 0);\n+}\n \n-      /* The signal handler blocked signals; unblock them.  */\n-      i = sigfillset (&clear);\n-      __go_assert (i == 0);\n-      i = sigprocmask (SIG_UNBLOCK, &clear, NULL);\n-      __go_assert (i == 0);\n+#ifdef SA_SIGINFO\n \n-      runtime_panicstring (msg);\n+/* Signal dispatch for signals which panic, on systems which support\n+   SA_SIGINFO.  This is called on the thread stack, and as such it is\n+   permitted to split the stack.  */\n+\n+static void\n+sig_panic_info_handler (int sig, siginfo_t *info,\n+\t\t\tvoid *context __attribute__ ((unused)))\n+{\n+  if (runtime_g () == NULL)\n+    {\n+      sig_handler (sig);\n+      return;\n     }\n \n-  for (i = 0; signals[i].sig != -1; ++i)\n+  sig_panic_leadin (sig);\n+\n+  switch (sig)\n     {\n-      if (signals[i].sig == sig)\n+#ifdef SIGBUS\n+    case SIGBUS:\n+      if (info->si_code == BUS_ADRERR && (uintptr_t) info->si_addr < 0x1000)\n+\truntime_panicstring (\"invalid memory address or \"\n+\t\t\t     \"nil pointer dereference\");\n+      runtime_printf (\"unexpected fault address %p\\n\", info->si_addr);\n+      runtime_throw (\"fault\");\n+#endif\n+\n+#ifdef SIGSEGV\n+    case SIGSEGV:\n+      if ((info->si_code == 0\n+\t   || info->si_code == SEGV_MAPERR\n+\t   || info->si_code == SEGV_ACCERR)\n+\t  && (uintptr_t) info->si_addr < 0x1000)\n+\truntime_panicstring (\"invalid memory address or \"\n+\t\t\t     \"nil pointer dereference\");\n+      runtime_printf (\"unexpected fault address %p\\n\", info->si_addr);\n+      runtime_throw (\"fault\");\n+#endif\n+\n+#ifdef SIGFPE\n+    case SIGFPE:\n+      switch (info->si_code)\n \t{\n-\t  struct sigaction sa;\n+\tcase FPE_INTDIV:\n+\t  runtime_panicstring (\"integer divide by zero\");\n+\tcase FPE_INTOVF:\n+\t  runtime_panicstring (\"integer overflow\");\n+\t}\n+      runtime_panicstring (\"floating point error\");\n+#endif\n+    }\n \n-\t  if (signals[i].queue)\n-\t    {\n-\t      if (__go_sigsend (sig) || signals[i].ignore)\n-\t\treturn;\n-\t      runtime_exit (2);\t\t// SIGINT, SIGTERM, etc\n-\t    }\n+  /* All signals with SigPanic should be in cases above, and this\n+     handler should only be invoked for those signals.  */\n+  __builtin_unreachable ();\n+}\n \n-\t  if (runtime_panicking)\n-\t    runtime_exit (2);\n-\t  runtime_panicking = 1;\n+#else /* !defined (SA_SIGINFO) */\n \n-\t  memset (&sa, 0, sizeof sa);\n+static void\n+sig_panic_handler (int sig)\n+{\n+  if (runtime_g () == NULL)\n+    {\n+      sig_handler (sig);\n+      return;\n+    }\n \n-\t  sa.sa_handler = SIG_DFL;\n+  sig_panic_leadin (sig);\n \n-\t  i = sigemptyset (&sa.sa_mask);\n-\t  __go_assert (i == 0);\n+  switch (sig)\n+    {\n+#ifdef SIGBUS\n+    case SIGBUS:\n+      runtime_panicstring (\"invalid memory address or \"\n+\t\t\t   \"nil pointer dereference\");\n+#endif\n \n-\t  if (sigaction (sig, &sa, NULL) != 0)\n-\t    abort ();\n+#ifdef SIGSEGV\n+    case SIGSEGV:\n+      runtime_panicstring (\"invalid memory address or \"\n+\t\t\t   \"nil pointer dereference\");\n+#endif\n \n-\t  raise (sig);\n-\t  exit (2);\n-\t}\n+#ifdef SIGFPE\n+    case SIGFPE:\n+      runtime_panicstring (\"integer divide by zero or floating point error\");\n+#endif\n     }\n-  abort ();\n+\n+  /* All signals with SigPanic should be in cases above, and this\n+     handler should only be invoked for those signals.  */\n+  __builtin_unreachable ();\n }\n \n-/* Ignore a signal.  */\n+#endif /* !defined (SA_SIGINFO) */\n+\n+/* Ignore a signal.  This is called on the alternate signal stack so\n+   it may not split the stack.  */\n+\n+static void sig_ignore (int) __attribute__ ((no_split_stack));\n \n static void\n sig_ignore (int sig __attribute__ ((unused)))\n {\n }\n \n+/* A signal handler used for signals which are not going to panic.\n+   This is called on the alternate signal stack so it may not split\n+   the stack.  */\n+\n+static void\n+sig_tramp (int) __attribute__ ((no_split_stack));\n+\n+static void\n+sig_tramp (int sig)\n+{\n+  G *gp;\n+  M *mp;\n+\n+  /* We are now running on the stack registered via sigaltstack.\n+     (Actually there is a small span of time between runtime_siginit\n+     and sigaltstack when the program starts.)  */\n+  gp = runtime_g ();\n+  mp = runtime_m ();\n+\n+  if (gp != NULL)\n+    __splitstack_getcontext (&gp->stack_context[0]);\n+\n+  if (gp != NULL && mp->gsignal != NULL)\n+    {\n+      /* We are running on the signal stack.  Set the split stack\n+\t context so that the stack guards are checked correctly.  */\n+#ifdef USING_SPLIT_STACK\n+      __splitstack_setcontext (&mp->gsignal->stack_context[0]);\n+#endif\n+    }\n+\n+  sig_handler (sig);\n+\n+  /* We are going to return back to the signal trampoline and then to\n+     whatever we were doing before we got the signal.  Restore the\n+     split stack context so that stack guards are checked\n+     correctly.  */\n+\n+  if (gp != NULL)\n+    {\n+#ifdef USING_SPLIT_STACK\n+      __splitstack_setcontext (&gp->stack_context[0]);\n+#endif\n+    }\n+}\n+\n /* Initialize signal handling for Go.  This is called when the program\n    starts.  */\n \n@@ -237,21 +385,44 @@ runtime_initsig (int32 queue)\n \n   memset (&sa, 0, sizeof sa);\n \n-  sa.sa_handler = sighandler;\n-\n   i = sigfillset (&sa.sa_mask);\n   __go_assert (i == 0);\n \n-  for (i = 0; signals[i].sig != -1; ++i)\n+  for (i = 0; runtime_sigtab[i].sig != -1; ++i)\n     {\n-      if (signals[i].queue != (queue ? 1 : 0))\n+      if (runtime_sigtab[i].flags == 0)\n+\tcontinue;\n+      if ((runtime_sigtab[i].flags & SigQueue) != queue)\n \tcontinue;\n-      if (signals[i].catch || signals[i].queue)\n-\tsa.sa_handler = sighandler;\n+\n+      if ((runtime_sigtab[i].flags & (SigCatch | SigQueue)) != 0)\n+\t{\n+\t  if ((runtime_sigtab[i].flags & SigPanic) == 0)\n+\t    {\n+\t      sa.sa_flags = SA_ONSTACK;\n+\t      sa.sa_handler = sig_tramp;\n+\t    }\n+\t  else\n+\t    {\n+#ifdef SA_SIGINFO\n+\t      sa.sa_flags = SA_SIGINFO;\n+\t      sa.sa_sigaction = sig_panic_info_handler;\n+#else\n+\t      sa.sa_flags = 0;\n+\t      sa.sa_handler = sig_panic_handler;\n+#endif\n+\t    }\n+\t}\n       else\n-\tsa.sa_handler = sig_ignore;\n-      sa.sa_flags = signals[i].restart ? SA_RESTART : 0;\n-      if (sigaction (signals[i].sig, &sa, NULL) != 0)\n+\t{\n+\t  sa.sa_flags = SA_ONSTACK;\n+\t  sa.sa_handler = sig_ignore;\n+\t}\n+\n+      if ((runtime_sigtab[i].flags & SigRestart) != 0)\n+\tsa.sa_flags |= SA_RESTART;\n+\n+      if (sigaction (runtime_sigtab[i].sig, &sa, NULL) != 0)\n \t__go_assert (0);\n     }\n }\n@@ -281,7 +452,7 @@ runtime_resetcpuprofiler(int32 hz)\n     }\n   else\n     {\n-      sa.sa_handler = sighandler;\n+      sa.sa_handler = sig_handler;\n       sa.sa_flags = SA_RESTART;\n       i = sigaction (SIGPROF, &sa, NULL);\n       __go_assert (i == 0);"}, {"sha": "72ab4d695fa47a19dcab0abe31d5eff7f2d74e34", "filename": "libgo/runtime/mem.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem.c?ref=a6dcb7d46549faa48f782e7b154c6103e0406b58", "patch": "@@ -47,7 +47,7 @@ runtime_SysAlloc(uintptr n)\n \tif (dev_zero == -1) {\n \t\tdev_zero = open(\"/dev/zero\", O_RDONLY);\n \t\tif (dev_zero < 0) {\n-\t\t\tprintf(\"open /dev/zero: errno=%d\\n\", errno);\n+\t\t\truntime_printf(\"open /dev/zero: errno=%d\\n\", errno);\n \t\t\texit(2);\n \t\t}\n \t}\n@@ -57,8 +57,8 @@ runtime_SysAlloc(uintptr n)\n \tp = runtime_mmap(nil, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_PRIVATE, fd, 0);\n \tif (p == MAP_FAILED) {\n \t\tif(errno == EACCES) {\n-\t\t\tprintf(\"runtime: mmap: access denied\\n\");\n-\t\t\tprintf(\"if you're running SELinux, enable execmem for this process.\\n\");\n+\t\t\truntime_printf(\"runtime: mmap: access denied\\n\");\n+\t\t\truntime_printf(\"if you're running SELinux, enable execmem for this process.\\n\");\n \t\t\texit(2);\n \t\t}\n \t\treturn nil;\n@@ -97,7 +97,7 @@ runtime_SysReserve(void *v, uintptr n)\n \tif (dev_zero == -1) {\n \t\tdev_zero = open(\"/dev/zero\", O_RDONLY);\n \t\tif (dev_zero < 0) {\n-\t\t\tprintf(\"open /dev/zero: errno=%d\\n\", errno);\n+\t\t\truntime_printf(\"open /dev/zero: errno=%d\\n\", errno);\n \t\t\texit(2);\n \t\t}\n \t}\n@@ -123,7 +123,7 @@ runtime_SysMap(void *v, uintptr n)\n \tif (dev_zero == -1) {\n \t\tdev_zero = open(\"/dev/zero\", O_RDONLY);\n \t\tif (dev_zero < 0) {\n-\t\t\tprintf(\"open /dev/zero: errno=%d\\n\", errno);\n+\t\t\truntime_printf(\"open /dev/zero: errno=%d\\n\", errno);\n \t\t\texit(2);\n \t\t}\n \t}"}, {"sha": "9225f825b88ef65733f2254d9826eb0c052e57da", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=a6dcb7d46549faa48f782e7b154c6103e0406b58", "patch": "@@ -29,6 +29,11 @@ extern void * __splitstack_resetcontext(void *context[10], size_t *);\n extern void *__splitstack_find(void *, void *, size_t *, void **, void **,\n \t\t\t       void **);\n \n+extern void __splitstack_block_signals (int *, int *);\n+\n+extern void __splitstack_block_signals_context (void *context[10], int *,\n+\t\t\t\t\t\tint *);\n+\n #endif\n \n #if defined(USING_SPLIT_STACK) && defined(LINKER_SUPPORTS_SPLIT_STACK)\n@@ -862,6 +867,14 @@ runtime_mstart(void* mp)\n \t\t*(int*)0x21 = 0x21;\n \t}\n \truntime_minit();\n+\n+#ifdef USING_SPLIT_STACK\n+\t{\n+\t  int dont_block_signals = 0;\n+\t  __splitstack_block_signals(&dont_block_signals, nil);\n+\t}\n+#endif\n+\n \tschedule(nil);\n \treturn nil;\n }\n@@ -1142,9 +1155,13 @@ runtime_malg(int32 stacksize, byte** ret_stack, size_t* ret_stacksize)\n \tnewg = runtime_malloc(sizeof(G));\n \tif(stacksize >= 0) {\n #if USING_SPLIT_STACK\n+\t\tint dont_block_signals = 0;\n+\n \t\t*ret_stack = __splitstack_makecontext(stacksize,\n \t\t\t\t\t\t      &newg->stack_context[0],\n \t\t\t\t\t\t      ret_stacksize);\n+\t\t__splitstack_block_signals_context(&newg->stack_context[0],\n+\t\t\t\t\t\t   &dont_block_signals, nil);\n #else\n \t\t*ret_stack = runtime_mallocgc(stacksize, FlagNoProfiling|FlagNoGC, 0, 0);\n \t\t*ret_stacksize = stacksize;\n@@ -1186,8 +1203,12 @@ __go_go(void (*fn)(void*), void* arg)\n \n \tif((newg = gfget()) != nil){\n #ifdef USING_SPLIT_STACK\n+\t\tint dont_block_signals = 0;\n+\n \t\tsp = __splitstack_resetcontext(&newg->stack_context[0],\n \t\t\t\t\t       &spsize);\n+\t\t__splitstack_block_signals_context(&newg->stack_context[0],\n+\t\t\t\t\t\t   &dont_block_signals, nil);\n #else\n \t\tsp = newg->gcinitial_sp;\n \t\tspsize = newg->gcstack_size;"}, {"sha": "ed626efe8a23449b197d014dc6507cdfb226fed1", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=a6dcb7d46549faa48f782e7b154c6103e0406b58", "patch": "@@ -52,6 +52,7 @@ typedef\tstruct\tG\t\tG;\n typedef\tunion\tLock\t\tLock;\n typedef\tstruct\tM\t\tM;\n typedef\tunion\tNote\t\tNote;\n+typedef\tstruct\tSigTab\t\tSigTab;\n typedef\tstruct\tMCache\t\tMCache;\n typedef struct\tFixAlloc\tFixAlloc;\n typedef\tstruct\tHchan\t\tHchan;\n@@ -179,6 +180,20 @@ struct\tM\n \tuint32\twaitsemalock;\n };\n \n+struct\tSigTab\n+{\n+\tint32\tsig;\n+\tint32\tflags;\n+};\n+enum\n+{\n+\tSigCatch = 1<<0,\n+\tSigIgnore = 1<<1,\n+\tSigRestart = 1<<2,\n+\tSigQueue = 1<<3,\n+\tSigPanic = 1<<4,\n+};\n+\n /* Macros.  */\n \n #ifdef __WINDOWS__\n@@ -251,7 +266,7 @@ void\truntime_args(int32, byte**);\n void\truntime_osinit();\n void\truntime_goargs(void);\n void\truntime_goenvs(void);\n-void\truntime_throw(const char*);\n+void\truntime_throw(const char*) __attribute__ ((noreturn));\n void\truntime_panicstring(const char*) __attribute__ ((noreturn));\n void*\truntime_mal(uintptr);\n void\truntime_schedinit(void);"}, {"sha": "e91571902c09e373e15a9380dea865bf3b42e8bc", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dcb7d46549faa48f782e7b154c6103e0406b58/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=a6dcb7d46549faa48f782e7b154c6103e0406b58", "patch": "@@ -110,6 +110,6 @@ func Signame(sig int32) (name String) {\n }\n \n func Siginit() {\n-\truntime_initsig(1);\n+\truntime_initsig(SigQueue);\n \tsig.inuse = true;\t// enable reception of signals; cannot disable\n }"}]}