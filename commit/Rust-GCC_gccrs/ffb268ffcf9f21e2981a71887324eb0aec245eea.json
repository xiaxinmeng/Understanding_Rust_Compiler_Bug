{"sha": "ffb268ffcf9f21e2981a71887324eb0aec245eea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZiMjY4ZmZjZjlmMjFlMjk4MWE3MTg4NzMyNGViMGFlYzI0NWVlYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-07T16:47:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-07T16:49:33Z"}, "message": "c++: Adjust array type construction\n\nThis restores the dependent array changes I reverted, now that pr98116\nappears fixed.  As mentioned before, when deserializing a module we\nneed to construct arrays without using the dependent-type predicates\nthemselves.\n\n\tgcc/cp/\n\t* cp-tree.h (build_cplus_array_type): Add defaulted DEP parm.\n\t* tree.c (set_array_type_common): Add DEP parm.\n\t(build_cplus_array_type): Add DEP parm, determine dependency if\n\tneeded.  Mark dependency of new types.\n\t(cp_build_qualified_type_real): Adjust array-building call, assert\n\tno surprising dependency.\n\t(strip_typedefs): Likewise.", "tree": {"sha": "86e1b2e47bd1b755259525bbfe19e3be2b1ef20d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86e1b2e47bd1b755259525bbfe19e3be2b1ef20d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffb268ffcf9f21e2981a71887324eb0aec245eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb268ffcf9f21e2981a71887324eb0aec245eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb268ffcf9f21e2981a71887324eb0aec245eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb268ffcf9f21e2981a71887324eb0aec245eea/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d0eb0ae948f0fbee208cfb9a86133abea650f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d0eb0ae948f0fbee208cfb9a86133abea650f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d0eb0ae948f0fbee208cfb9a86133abea650f81"}], "stats": {"total": 42, "additions": 30, "deletions": 12}, "files": [{"sha": "b72069eecdafa9aff1479a197c5eb4158dd57733", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb268ffcf9f21e2981a71887324eb0aec245eea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb268ffcf9f21e2981a71887324eb0aec245eea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ffb268ffcf9f21e2981a71887324eb0aec245eea", "patch": "@@ -7559,7 +7559,7 @@ extern bool is_local_temp\t\t\t(tree);\n extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree get_target_expr_sfinae\t\t(tree, tsubst_flags_t);\n-extern tree build_cplus_array_type\t\t(tree, tree);\n+extern tree build_cplus_array_type\t\t(tree, tree, int is_dep = -1);\n extern tree build_array_of_n_type\t\t(tree, int);\n extern bool array_of_runtime_bound_p\t\t(tree);\n extern bool vla_type_p\t\t\t\t(tree);"}, {"sha": "d9fa505041f5495cd59e28458bb64b16b17bc16c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb268ffcf9f21e2981a71887324eb0aec245eea/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb268ffcf9f21e2981a71887324eb0aec245eea/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ffb268ffcf9f21e2981a71887324eb0aec245eea", "patch": "@@ -998,7 +998,7 @@ build_min_array_type (tree elt_type, tree index_type)\n    build_cplus_array_type.  */\n \n static void\n-set_array_type_canon (tree t, tree elt_type, tree index_type)\n+set_array_type_canon (tree t, tree elt_type, tree index_type, bool dep)\n {\n   /* Set the canonical type for this new node.  */\n   if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n@@ -1009,30 +1009,33 @@ set_array_type_canon (tree t, tree elt_type, tree index_type)\n     TYPE_CANONICAL (t)\n       = build_cplus_array_type (TYPE_CANONICAL (elt_type),\n \t\t\t\tindex_type\n-\t\t\t\t? TYPE_CANONICAL (index_type) : index_type);\n+\t\t\t\t? TYPE_CANONICAL (index_type) : index_type,\n+\t\t\t\tdep);\n   else\n     TYPE_CANONICAL (t) = t;\n }\n \n /* Like build_array_type, but handle special C++ semantics: an array of a\n    variant element type is a variant of the array of the main variant of\n-   the element type.  */\n+   the element type.  IS_DEPENDENT is -ve if we should determine the\n+   dependency.  Otherwise its bool value indicates dependency.  */\n \n tree\n-build_cplus_array_type (tree elt_type, tree index_type)\n+build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n {\n   tree t;\n \n   if (elt_type == error_mark_node || index_type == error_mark_node)\n     return error_mark_node;\n \n-  bool dependent = (uses_template_parms (elt_type)\n-\t\t    || (index_type && uses_template_parms (index_type)));\n+  if (dependent < 0)\n+    dependent = (uses_template_parms (elt_type)\n+\t\t || (index_type && uses_template_parms (index_type)));\n \n   if (elt_type != TYPE_MAIN_VARIANT (elt_type))\n     /* Start with an array of the TYPE_MAIN_VARIANT.  */\n     t = build_cplus_array_type (TYPE_MAIN_VARIANT (elt_type),\n-\t\t\t\tindex_type);\n+\t\t\t\tindex_type, dependent);\n   else if (dependent)\n     {\n       /* Since type_hash_canon calls layout_type, we need to use our own\n@@ -1062,13 +1065,20 @@ build_cplus_array_type (tree elt_type, tree index_type)\n \t  *e = t;\n \n \t  /* Set the canonical type for this new node.  */\n-\t  set_array_type_canon (t, elt_type, index_type);\n+\t  set_array_type_canon (t, elt_type, index_type, dependent);\n+\n+\t  /* Mark it as dependent now, this saves time later.  */\n+\t  TYPE_DEPENDENT_P_VALID (t) = true;\n+\t  TYPE_DEPENDENT_P (t) = true;\n \t}\n     }\n   else\n     {\n       bool typeless_storage = is_byte_access_type (elt_type);\n       t = build_array_type (elt_type, index_type, typeless_storage);\n+\n+      /* Mark as non-dependenty now, this will save time later.  */\n+      TYPE_DEPENDENT_P_VALID (t) = true;\n     }\n \n   /* Now check whether we already have this array variant.  */\n@@ -1083,7 +1093,10 @@ build_cplus_array_type (tree elt_type, tree index_type)\n       if (!t)\n \t{\n \t  t = build_min_array_type (elt_type, index_type);\n-\t  set_array_type_canon (t, elt_type, index_type);\n+\t  /* Mark dependency now, this saves time later.  */\n+\t  TYPE_DEPENDENT_P_VALID (t) = true;\n+\t  TYPE_DEPENDENT_P (t) = dependent;\n+\t  set_array_type_canon (t, elt_type, index_type, dependent);\n \t  if (!dependent)\n \t    {\n \t      layout_type (t);\n@@ -1319,7 +1332,10 @@ cp_build_qualified_type_real (tree type,\n \n       if (!t)\n \t{\n-\t  t = build_cplus_array_type (element_type, TYPE_DOMAIN (type));\n+\t  gcc_checking_assert (TYPE_DEPENDENT_P_VALID (type)\n+\t\t\t       || !dependent_type_p (type));\n+\t  t = build_cplus_array_type (element_type, TYPE_DOMAIN (type),\n+\t\t\t\t      TYPE_DEPENDENT_P (type));\n \n \t  /* Keep the typedef name.  */\n \t  if (TYPE_NAME (t) != TYPE_NAME (type))\n@@ -1555,7 +1571,9 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n     case ARRAY_TYPE:\n       type = strip_typedefs (TREE_TYPE (t), remove_attributes, flags);\n       t0  = strip_typedefs (TYPE_DOMAIN (t), remove_attributes, flags);\n-      result = build_cplus_array_type (type, t0);\n+      gcc_checking_assert (TYPE_DEPENDENT_P_VALID (t)\n+\t\t\t   || !dependent_type_p (t));\n+      result = build_cplus_array_type (type, t0, TYPE_DEPENDENT_P (t));\n       break;\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:"}]}