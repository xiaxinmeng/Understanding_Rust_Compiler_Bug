{"sha": "98f705b937992d93e48c6085b45630d57122a99f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThmNzA1YjkzNzk5MmQ5M2U0OGM2MDg1YjQ1NjMwZDU3MTIyYTk5Zg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@redhat.com", "date": "2001-10-25T21:37:44Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-10-25T21:37:44Z"}, "message": "mangle.c (static tree compression_table): Fixed leading comment.\n\n2001-10-24  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* mangle.c (static tree compression_table): Fixed leading comment.\n\t* parse.h (struct parser_ctxt): Fixed field comment.\n\t* parse.y (check_pkg_class_access): New prototype, fixed leading\n\tcomment, new parameter used to emit error only if passed as true.\n\t(parse_check_super): Pass extra argument to check_pkg_class_access.\n\t(do_resolve_class): Likewise.\n\t(process_imports): Likewise.\n\t(read_import_dir): Fixed indentation.\n\t(find_in_imports_on_demand): New local class_type_name. Local\n\tnode_to_use deleted. while loop changed into for loop. Report\n\tmultiple definition only for accessible classes. Improved error\n\tmessage.\n\t(start_complete_expand_method): Local `ptr' removed. DECL_ARGUMENTS\n\tassigned to parameter list, fixed indentation. while loop changed\n\tinto for loop, restore TREE_CHAIN on local `tem' before the next\n\titeration.\n\n( http://gcc.gnu.org/ml/gcc-patches/2001-10/msg01323.html )\n\nFrom-SVN: r46498", "tree": {"sha": "83882e57b42e1141120cdba59d61fa37cdcfa1c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83882e57b42e1141120cdba59d61fa37cdcfa1c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98f705b937992d93e48c6085b45630d57122a99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f705b937992d93e48c6085b45630d57122a99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f705b937992d93e48c6085b45630d57122a99f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f705b937992d93e48c6085b45630d57122a99f/comments", "author": null, "committer": null, "parents": [{"sha": "f456d345280c60102db9a7e00453b70d592e7f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f456d345280c60102db9a7e00453b70d592e7f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f456d345280c60102db9a7e00453b70d592e7f66"}], "stats": {"total": 168, "additions": 107, "deletions": 61}, "files": [{"sha": "7e05cc20d9e687b93995e1f3d6ea680603d6b0f8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=98f705b937992d93e48c6085b45630d57122a99f", "patch": "@@ -1,3 +1,22 @@\n+2001-10-24  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* mangle.c (static tree compression_table): Fixed leading comment.\n+\t* parse.h (struct parser_ctxt): Fixed field comment.\n+\t* parse.y (check_pkg_class_access): New prototype, fixed leading\n+\tcomment, new parameter used to emit error only if passed as true.\n+\t(parse_check_super): Pass extra argument to check_pkg_class_access.\n+\t(do_resolve_class): Likewise.\n+\t(process_imports): Likewise.\n+\t(read_import_dir): Fixed indentation.\n+\t(find_in_imports_on_demand): New local class_type_name. Local\n+\tnode_to_use deleted. while loop changed into for loop. Report\n+\tmultiple definition only for accessible classes. Improved error\n+\tmessage.\n+\t(start_complete_expand_method): Local `ptr' removed. DECL_ARGUMENTS\n+\tassigned to parameter list, fixed indentation. while loop changed\n+\tinto for loop, restore TREE_CHAIN on local `tem' before the next\n+\titeration.\n+\n Tue Oct 23 14:02:17 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* lang.c (lang_get_alias_set): Deleted."}, {"sha": "f0bda0eaa77b50a9fd0aff4585ff35b60444f6ba", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=98f705b937992d93e48c6085b45630d57122a99f", "patch": "@@ -255,7 +255,7 @@ mangle_type (type)\n \n /* The compression table is a vector that keeps track of things we've\n    already seen, so they can be reused. For example, java.lang.Object\n-   Would generate three entries: two package names and a type. If\n+   would generate three entries: two package names and a type. If\n    java.lang.String is presented next, the java.lang will be matched\n    against the first two entries (and kept for compression as S_0), and\n    type String would be added to the table. See mangle_record_type."}, {"sha": "220567157d013309d37ef6e6cc22876c79701028", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=98f705b937992d93e48c6085b45630d57122a99f", "patch": "@@ -785,7 +785,7 @@ struct parser_ctxt {\n \n   tree non_static_initialized;\t    /* List of non static initialized fields */\n   tree static_initialized;\t    /* List of static non final initialized */\n-  tree instance_initializers;\t    /* List of instancei initializers stmts */\n+  tree instance_initializers;\t    /* List of instance initializers stmts */\n \n   tree import_list;\t\t    /* List of import */\n   tree import_demand_list;\t    /* List of import on demand */"}, {"sha": "0fed076b5a3f1fa654132866294d0acb20d1ed85", "filename": "gcc/java/parse.y", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f705b937992d93e48c6085b45630d57122a99f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=98f705b937992d93e48c6085b45630d57122a99f", "patch": "@@ -108,7 +108,7 @@ static void reset_final_variable_local_assignment_flag PARAMS ((tree));\n static int  check_final_variable_indirect_assignment PARAMS ((tree));\n static void check_final_variable_global_assignment_flag PARAMS ((tree));\n static void check_inner_class_access PARAMS ((tree, tree, tree));\n-static int check_pkg_class_access PARAMS ((tree, tree));\n+static int check_pkg_class_access PARAMS ((tree, tree, bool));\n static void register_package PARAMS ((tree));\n static tree resolve_package PARAMS ((tree, tree *));\n static tree lookup_package_type PARAMS ((const char *, int));\n@@ -5079,7 +5079,8 @@ parser_check_super_interface (super_decl, this_decl, this_wfl)\n   /* Check top-level interface access. Inner classes are subject to member \n      access rules (6.6.1). */\n   if (! INNER_CLASS_P (super_type)\n-      && check_pkg_class_access (DECL_NAME (super_decl), lookup_cl (this_decl)))\n+      && check_pkg_class_access (DECL_NAME (super_decl),\n+\t\t\t\t lookup_cl (this_decl), true))\n     return 1;\n \n   SOURCE_FRONTEND_DEBUG ((\"Completing interface %s with %s\",\n@@ -5118,7 +5119,7 @@ parser_check_super (super_decl, this_decl, wfl)\n   /* Check top-level class scope. Inner classes are subject to member access\n      rules (6.6.1). */\n   if (! INNER_CLASS_P (super_type)\n-      && (check_pkg_class_access (DECL_NAME (super_decl), wfl)))\n+      && (check_pkg_class_access (DECL_NAME (super_decl), wfl, true)))\n     return 1;\n   \n   SOURCE_FRONTEND_DEBUG ((\"Completing class %s with %s\",\n@@ -5834,7 +5835,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n      by the caller. */\n   if (cl)\n     {\n-      if (check_pkg_class_access (TYPE_NAME (class_type), cl))\n+      if (check_pkg_class_access (TYPE_NAME (class_type), cl, true))\n         return NULL_TREE;\n     }\n   \n@@ -6676,7 +6677,7 @@ process_imports ()\n \t  QUALIFIED_P (to_be_found) = 1;\n \t  load_class (to_be_found, 0);\n \t  error_found =\n-\t    check_pkg_class_access (to_be_found, TREE_PURPOSE (import));\n+\t    check_pkg_class_access (to_be_found, TREE_PURPOSE (import), true);\n \t  \n \t  /* We found it, we can bail out */\n \t  if (IDENTIFIER_CLASS_VALUE (to_be_found))\n@@ -6765,7 +6766,6 @@ read_import_dir (wfl)\n   void *entry;\n   struct buffer filename[1];\n \n-\n   if (IS_AN_IMPORT_ON_DEMAND_P (package_id))\n     return;\n   IS_AN_IMPORT_ON_DEMAND_P (package_id) = 1;\n@@ -6878,71 +6878,95 @@ find_in_imports_on_demand (enclosing_type, class_type)\n      tree enclosing_type;\n      tree class_type;\n {\n+  tree class_type_name = TYPE_NAME (class_type);\n   tree import = (enclosing_type ? TYPE_IMPORT_DEMAND_LIST (enclosing_type) :\n \t\t  ctxp->import_demand_list);\n-  tree node_to_use = NULL_TREE, cl = NULL_TREE;\n+  tree cl = NULL_TREE;\n+  int seen_once = -1;\t/* -1 when not set, 1 if seen once, >1 otherwise. */\n+  int to_return = -1;\t/* -1 when not set, 0 or 1 otherwise */\n   tree node;\n-  int seen_once = -1;\n \n-  while (import)\n+  for (; import; import = TREE_CHAIN (import))\n     {\n+      int saved_lineno = lineno;\n+      int access_check;\n       const char *id_name;\n+      tree decl, type_name_copy;\n+\n       obstack_grow (&temporary_obstack, \n \t\t    IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))),\n \t\t    IDENTIFIER_LENGTH (EXPR_WFL_NODE (TREE_PURPOSE (import))));\n       obstack_1grow (&temporary_obstack, '.');\n       obstack_grow0 (&temporary_obstack, \n-\t\t     IDENTIFIER_POINTER (TYPE_NAME (class_type)),\n-\t\t     IDENTIFIER_LENGTH (TYPE_NAME (class_type)));\n+\t\t     IDENTIFIER_POINTER (class_type_name),\n+\t\t     IDENTIFIER_LENGTH (class_type_name));\n       id_name = obstack_finish (&temporary_obstack);\n \t      \n-      node = maybe_get_identifier (id_name);\n-      if (node && IS_A_CLASSFILE_NAME (node))\n+      if (! (node = maybe_get_identifier (id_name)))\n+\tcontinue;\n+\n+      /* Setup lineno so that it refers to the line of the import (in\n+\t case we parse a class file and encounter errors */\n+      lineno = EXPR_WFL_LINENO (TREE_PURPOSE (import));\n+\n+      type_name_copy = TYPE_NAME (class_type);\n+      TYPE_NAME (class_type) = node;\n+      QUALIFIED_P (node) = 1;\n+      decl = IDENTIFIER_CLASS_VALUE (node);\n+      access_check = -1;\n+      /* If there is no DECL set for the class or if the class isn't\n+\t loaded and not seen in source yet, then load */\n+      if (!decl || (!CLASS_LOADED_P (TREE_TYPE (decl))\n+\t\t    && !CLASS_FROM_SOURCE_P (TREE_TYPE (decl))))\n+\t{\n+\t  load_class (node, 0);\n+\t  decl = IDENTIFIER_CLASS_VALUE (node);\n+\t}\n+      if (decl && ! INNER_CLASS_P (TREE_TYPE (decl)))\n+\taccess_check = check_pkg_class_access (node, TREE_PURPOSE (import),\n+\t\t\t\t\t       false);\n+      else\n+\t/* 6.6.1: Inner classes are subject to member access rules. */\n+\taccess_check = 0;\n+\n+      lineno = saved_lineno;\n+\n+      /* If the loaded class is not accessible or couldn't be loaded,\n+\t we restore the original TYPE_NAME and process the next\n+\t import. */\n+      if (access_check || !decl)\n+\t{\n+\t  TYPE_NAME (class_type) = type_name_copy;\n+\t  continue;\n+\t}\n+      \n+      /* If the loaded class is accessible, we keep a tab on it to\n+\t detect and report multiple inclusions. */\n+      if (IS_A_CLASSFILE_NAME (node))\n \t{\n \t  if (seen_once < 0)\n \t    {\n \t      cl = TREE_PURPOSE (import);\n \t      seen_once = 1;\n-\t      node_to_use = node;\n \t    }\n-\t  else\n+\t  else if (seen_once >= 0)\n \t    {\n+\t      tree location = (cl ? cl : TREE_PURPOSE (import));\n+\t      tree package = (cl ? EXPR_WFL_NODE (cl) : \n+\t\t\t      EXPR_WFL_NODE (TREE_PURPOSE (import)));\n \t      seen_once++;\n \t      parse_error_context \n-\t\t(TREE_PURPOSE (import), \n+\t\t(location,\n \t\t \"Type `%s' also potentially defined in package `%s'\",\n-\t\t IDENTIFIER_POINTER (TYPE_NAME (class_type)),\n-\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))));\n+\t\t IDENTIFIER_POINTER (TYPE_NAME (class_type)), \n+\t\t IDENTIFIER_POINTER (package));\n \t    }\n \t}\n-      import = TREE_CHAIN (import);\n+      to_return = access_check;\n     }\n \n   if (seen_once == 1)\n-    {\n-      /* Setup lineno so that it refers to the line of the import (in\n-\t case we parse a class file and encounter errors */\n-      tree decl;\n-      int saved_lineno = lineno;\n-      lineno = EXPR_WFL_LINENO (cl);\n-      TYPE_NAME (class_type) = node_to_use;\n-      QUALIFIED_P (TYPE_NAME (class_type)) = 1;\n-      decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n-      /* If there is no DECL set for the class or if the class isn't\n-\t loaded and not seen in source yet, the load */\n-      if (!decl || (!CLASS_LOADED_P (TREE_TYPE (decl))\n-\t\t    && !CLASS_FROM_SOURCE_P (TREE_TYPE (decl))))\n-\t{\n-\t  load_class (node_to_use, 0);\n-\t  decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n-\t}\n-      lineno = saved_lineno;\n-      if (! INNER_CLASS_P (TREE_TYPE (decl)))\n-\treturn check_pkg_class_access (TYPE_NAME (class_type), cl);\n-      else\n-        /* 6.6.1: Inner classes are subject to member access rules. */\n-        return 0;\n-    }\n+    return to_return;\n   else\n     return (seen_once < 0 ? 0 : seen_once); /* It's ok not to have found */\n }\n@@ -7118,14 +7142,16 @@ check_inner_class_access (decl, enclosing_decl, cl)\n \t\t       lang_printable_name (decl, 0), access);\n }\n \n-/* Accessibility check for top-level classes. If CLASS_NAME is in a foreign \n-   package, it must be PUBLIC. Return 0 if no access violations were found, \n-   1 otherwise.  */\n+/* Accessibility check for top-level classes. If CLASS_NAME is in a\n+   foreign package, it must be PUBLIC. Return 0 if no access\n+   violations were found, 1 otherwise. If VERBOSE is true and an error\n+   was found, it is reported and accounted for.  */\n \n static int\n-check_pkg_class_access (class_name, cl)\n+check_pkg_class_access (class_name, cl, verbose)\n      tree class_name;\n      tree cl;\n+     bool verbose;\n {\n   tree type;\n \n@@ -7148,10 +7174,11 @@ check_pkg_class_access (class_name, cl)\n \t/* Both in the same package. */\n \treturn 0;\n \n-      parse_error_context \n-\t(cl, \"Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed\",\n-\t (CLASS_INTERFACE (TYPE_NAME (type)) ? \"interface\" : \"class\"),\n-\t IDENTIFIER_POINTER (class_name));\n+      if (verbose)\n+\tparse_error_context \n+\t  (cl, \"Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed\",\n+\t   (CLASS_INTERFACE (TYPE_NAME (type)) ? \"interface\" : \"class\"),\n+\t   IDENTIFIER_POINTER (class_name));\n       return 1;\n     }\n   return 0;\n@@ -7926,14 +7953,15 @@ static void\n start_complete_expand_method (mdecl)\n      tree mdecl;\n {\n-  tree tem, *ptr;\n+  tree tem;\n \n   pushlevel (1);\t\t/* Prepare for a parameter push */\n-  ptr = &DECL_ARGUMENTS (mdecl);\n-  tem  = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));\n+  tem = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));\n+  DECL_ARGUMENTS (mdecl) = tem;\n \n-  while (tem)\n+  for (; tem; tem = TREE_CHAIN (tem))\n     {\n+      /* TREE_CHAIN (tem) will change after pushdecl. */ \n       tree next = TREE_CHAIN (tem);\n       tree type = TREE_TYPE (tem);\n       if (PROMOTE_PROTOTYPES\n@@ -7943,11 +7971,10 @@ start_complete_expand_method (mdecl)\n       DECL_ARG_TYPE (tem) = type;\n       layout_decl (tem, 0);\n       pushdecl (tem);\n-      *ptr = tem;\n-      ptr = &TREE_CHAIN (tem);\n-      tem = next;\n+      /* Re-install the next so that the list is kept and the loop\n+\t advances. */\n+      TREE_CHAIN (tem) = next;\n     }\n-  *ptr = NULL_TREE;\n   pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n   lineno = DECL_SOURCE_LINE_FIRST (mdecl);\n   build_result_decl (mdecl);"}]}