{"sha": "a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhOTYwNmQ0YjViNzU0NWI2ZGNhYmFhOWE4YTkxNWFiOTZiZDE2Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-01T20:21:13Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-01T20:21:13Z"}, "message": "cpplib.c (run_directive): Use correct line number for output of _Pragma.\n\n        * cpplib.c (run_directive): Use correct line number for output\n        of _Pragma.  Remember any in-progress directive.\n\n        * gcc.dg/cpp/vararg2.c, gcc.dg/cpp/_Pragm1.c: New tests.\n\nFrom-SVN: r37194", "tree": {"sha": "ad692a7f6210d539ee8ff1304361b204914f4b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad692a7f6210d539ee8ff1304361b204914f4b9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/comments", "author": null, "committer": null, "parents": [{"sha": "fc05d51600acbf3cc72646e985db62b45b6f377f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc05d51600acbf3cc72646e985db62b45b6f377f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc05d51600acbf3cc72646e985db62b45b6f377f"}], "stats": {"total": 194, "additions": 190, "deletions": 4}, "files": [{"sha": "e04fef7f36885a169ec5feadc6a99537dd3c4254", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "patch": "@@ -1,3 +1,10 @@\n+2000-11-01  Neil Booth  <neilb@earthling.net>\n+\n+        * cpplib.c (run_directive): Use correct line number for output\n+        of _Pragma.  Remember any in-progress directive. \n+  \n+        * gcc.dg/cpp/vararg2.c, gcc.dg/cpp/_Pragm1.c: New tests.\n+\n 2000-11-01  Richard Henderson  <rth@redhat.com>\n \n \t* stmt.c (expand_start_null_loop): Set continue_label."}, {"sha": "738b1ba2d3bdec5ddb350126bae9044ef2163396", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "patch": "@@ -349,9 +349,12 @@ run_directive (pfile, dir_no, buf, count, name)\n      size_t count;\n      const char *name;\n {\n+  unsigned int output_line = pfile->lexer_pos.output_line;\n+\n   if (cpp_push_buffer (pfile, (const U_CHAR *) buf, count) != NULL)\n     {\n-      const struct directive *dir = &dtable[dir_no];\n+      const struct directive *dir = &dtable[dir_no], *orig_dir;\n+      unsigned char orig_in_directive;\n \n       if (name)\n \tCPP_BUFFER (pfile)->nominal_fname = name;\n@@ -360,7 +363,11 @@ run_directive (pfile, dir_no, buf, count, name)\n \n       /* A kludge to avoid line markers for _Pragma.  */\n       if (dir_no == T_PRAGMA)\n-\tpfile->lexer_pos.output_line = CPP_BUFFER (pfile)->prev->lineno;\n+\tpfile->lexer_pos.output_line = output_line;\n+\n+      /* Save any in-process directive; _Pragma can appear in one.  */\n+      orig_dir = pfile->directive;\n+      orig_in_directive = pfile->state.in_directive;\n \n       /* For _Pragma, the text is passed through preprocessing stage 3\n \t only, i.e. no trigraphs, no escaped newline removal, and no\n@@ -371,8 +378,8 @@ run_directive (pfile, dir_no, buf, count, name)\n       pfile->state.prevent_expansion++;\n       (void) (*dir->handler) (pfile);\n       pfile->state.prevent_expansion--;\n-      pfile->directive = 0;\n-      pfile->state.in_directive = 0;\n+      pfile->directive = orig_dir;\n+      pfile->state.in_directive = orig_in_directive;\n \n       skip_rest_of_line (pfile);\n       if (pfile->buffer->cur != pfile->buffer->rlimit)"}, {"sha": "8759b0a08245c98b680c89857f2d833c0e1d82c1", "filename": "gcc/testsuite/gcc.dg/cpp/_Pragma1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F_Pragma1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F_Pragma1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F_Pragma1.c?ref=a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Tests the _Pragma operator.  Contributed by Neil Booth 1 Nov 2000.  */\n+\n+/* Within the preprocessor, the easy pragma to test is \"poison\".  */\n+\n+#pragma GCC poison p1\n+p1\t\t\t\t/* { dg-error \"poisoned\" } */\n+\n+/* Standard use of _Pragma.  */\n+_Pragma (\"GCC poison p2\")\n+p2\t\t\t\t/* { dg-error \"poisoned\" } */\n+\n+/* I can see no reason it cannot appear in a directive.  Check we\n+   enter the conditional.  Putting the _Pragma at EOL also catches\n+   nasties like not saving current lexer state properly.  Also test\n+   that wide strings are OK.  */\n+#if 1 _Pragma (L\"GCC poison p3\")\n+p3\t\t\t\t/* { dg-error \"poisoned\" } */\n+#endif\n+\n+#define M1 _Pragma (\"GCC poison p4\")\n+p4\t\t\t\t/* No problem; not yet poisoned.  */\n+#define M2(x) _Pragma (#x)\n+\n+/* Now test macro expansion with embedded _Pragmas.  */\n+M1 p4\t\t\t\t/* { dg-error \"poisoned\" } */\n+M2 (GCC poison p5) p5\t\t/* { dg-error \"poisoned\" } */\n+\n+/* Look, ma!  These things even nest.  */\n+_Pragma (\"_Pragma (\\\"GCC poison p6\\\") GCC poison p7\")\n+p6\t\t\t\t/* { dg-error \"poisoned\" } */\n+p7\t\t\t\t/* { dg-error \"poisoned\" } */\n+\n+/* Check we ignore them in false conditionals.  */\n+#if 0\n+_Pragma (\"GCC poison p8\")\n+#endif\n+p8\t\t\t\t/* No problem.  */"}, {"sha": "2b2b0335c790709a5c85c4143c62e27da8f6faac", "filename": "gcc/testsuite/gcc.dg/cpp/vararg2.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg2.c?ref=a0a9606d4b5b7545b6dcabaa9a8a915ab96bd166", "patch": "@@ -0,0 +1,131 @@\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* Jamie's varargs macros from hell.  Not for the faint of heart.\n+   Great tests that C99 and GNU varargs give identical results.\n+   Adapted to the testsuite by Neil Booth, 1 Nov 2000.  */\n+\n+/* Permission is granted to use, copy, modify and distribute this file\n+   freely for any purpose whatsoever.  This file is free software, and\n+   there's no warranty.\n+\n+   -- Jamie Lokier <jamie.lokier@cern.ch>, 25/Sep/2000.  */\n+\n+#define dup3(x)            x,x,x\n+\n+/* Count elements in a list (0 to 10 max). */\n+#define gnu_count(y...)   _gnu_count1 ( , ##y)\n+#define _gnu_count1(y...) _gnu_count2 (y,10,9,8,7,6,5,4,3,2,1,0)\n+#define _gnu_count2(_,x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,n,ys...) n\n+\n+/* Tail of a list. */\n+#define gnu_tail(y...)    _gnu_tail (y)\n+#define _gnu_tail(x,y...) y\n+\n+/* Repeat N times. */\n+#define gnu_repeat(n, x) gnu_tail (_gnu_repeat (n, x))\n+#define _gnu_repeat(n, x) _gnu_repeat_##n (x)\n+#define _gnu_repeat_0(x)\n+#define _gnu_repeat_1(x) ,x\n+#define _gnu_repeat_2(x) ,x,x\n+#define _gnu_repeat_3(x) ,x,x,x\n+#define _gnu_repeat_4(x) ,x,x,x,x\n+#define _gnu_repeat_5(x) ,x,x,x,x,x\n+\n+#define _gnu_keep(xs...) xs\n+#define _gnu_discard(xs...)\n+#define _gnu_split_r(n,xs...) _gnu_split_rd (n,_gnu_keep,_gnu_discard xs)\n+#define _gnu_split_d(n,xs...) _gnu_split_rd (n,_gnu_discard,_gnu_keep xs)\n+#define _gnu_split_rd(n,xs...) _gnu_split_##n (xs)\n+#define _gnu_split_0(a,b,xs...) a() b(xs)\n+#define _gnu_split_1(a,b,x0,xs...) a(x0) b(xs)\n+#define _gnu_split_2(a,b,x0,x1,xs...) a(x0,x1) b(xs)\n+#define _gnu_split_3(a,b,x0,x1,x2,xs...) a(x0,x1,x2) b(xs)\n+#define _gnu_split_4(a,b,x0,x1,x2,x3,xs...) a(x0,x1,x2,x3) b(xs)\n+#define _gnu_split_5(a,b,x0,x1,x2,x3,x4,xs...) a(x0,x1,x2,x3,x4) b(xs)\n+\n+/* List manipulations.  Surprise: index zero is the rightmost element. */\n+#define gnu_take(n, xs...) \\\n+  _gnu_split_d (_gnu_count1 ( , ## xs), _gnu_repeat (n, _gnu_error) , ## xs)\n+#define gnu_drop(n, xs...) \\\n+  _gnu_split_d (n,,_gnu_split_r  (_gnu_count1 ( , ## xs), _gnu_repeat (n, _gnu_error) , ## xs))\n+#define gnu_index(pos, xs...) gnu_take (1, gnu_drop (pos , ## xs))\n+\n+/* C99 __VA_ARGS__ versions */\n+#define c99_count(...)    _c99_count1 ( , ##__VA_ARGS__)/* If only ## worked.*/\n+#define _c99_count1(...)  _c99_count2 (__VA_ARGS__,10,9,8,7,6,5,4,3,2,1,0)\n+#define _c99_count2(_,x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,n,...) n\n+\n+#define c99_tail(...)     _c99_tail (__VA_ARGS__)\n+#define _c99_tail(x,...)  __VA_ARGS__\n+\n+/* Repeat N times. */\n+#define c99_repeat(n, x) c99_tail (_c99_repeat (n, x))\n+#define _c99_repeat(n, x) _c99_repeat_##n (x)\n+#define _c99_repeat_0(x)\n+#define _c99_repeat_1(x) ,x\n+#define _c99_repeat_2(x) ,x,x\n+#define _c99_repeat_3(x) ,x,x,x\n+#define _c99_repeat_4(x) ,x,x,x,x\n+#define _c99_repeat_5(x) ,x,x,x,x,x\n+\n+#define _c99_keep(...)    __VA_ARGS__\n+#define _c99_discard(...)\n+#define _c99_split_r(n,...) _c99_split_rd(n,_c99_keep,_c99_discard __VA_ARGS__)\n+#define _c99_split_d(n,...) _c99_split_rd(n,_c99_discard,_c99_keep __VA_ARGS__)\n+#define _c99_split_rd(n,...) _c99_split_##n (__VA_ARGS__)\n+#define _c99_split_0(a,b,...) a() b(__VA_ARGS__)\n+#define _c99_split_1(a,b,x0,...) a(x0) b(__VA_ARGS__)\n+#define _c99_split_2(a,b,x0,x1,...) a(x0,x1) b(__VA_ARGS__)\n+#define _c99_split_3(a,b,x0,x1,x2,...) a(x0,x1,x2) b(__VA_ARGS__)\n+#define _c99_split_4(a,b,x0,x1,x2,x3,...) a(x0,x1,x2,x3) b(__VA_ARGS__)\n+#define _c99_split_5(a,b,x0,x1,x2,x3,x4,...) a(x0,x1,x2,x3,x4) b(__VA_ARGS__)\n+\n+/* List manipulations.  Surprise: index zero is the rightmost element. */\n+#define c99_take(n, ...) \\\n+  _c99_split_d (_c99_count1 ( , ## __VA_ARGS__), _c99_repeat (n, _c99_error) , ## __VA_ARGS__)\n+#define c99_drop(n, ...) \\\n+  _c99_split_d (n,,_c99_split_r  (_c99_count1 ( , ## __VA_ARGS__), _c99_repeat (n, _c99_error) , ## __VA_ARGS__))\n+#define c99_index(pos, ...) c99_take (1, c99_drop (pos , ## __VA_ARGS__))\n+\n+/************** Expansions **************/\n+\n+/* Correct answers are 0, 0, 1, 2, 10.  */\n+#if _gnu_count1 () != 0 || gnu_count () != 0 || gnu_count (A) != 1 \\\n+    || gnu_count (,) != 2 || gnu_count (A, B, C, D, E, F, G, H, I, J) != 10\n+#error gnu_count\n+#endif\n+\n+/* Correct answers are empty, 'x'.  */\n+#if gnu_repeat (0, 'x') gnu_repeat (1, 'x') != 'x'\n+#error gnu_repeat\n+#endif\n+\n+/* Correct answers are \"e\", \"b\", \"a\", empty.  */\n+#if gnu_index (0, 'a', 'b', 'c', 'd', 'e') != 'e' \\\n+ || gnu_index (3, 'a', 'b', 'c', 'd', 'e') != 'b' \\\n+ || gnu_index (4, 'a', 'b', 'c', 'd', 'e') != 'a' \\\n+    gnu_index (5, 'a', 'b', 'c', 'd', 'e')\n+#error gnu_index\n+#endif\n+\n+/************* C99 tests *************/\n+\n+/* The answers are 0, 0, 1, 2, 10 as for the non-C99 version.  */\n+#if _c99_count1 () != 0 || c99_count () != 0 || c99_count (A) != 1 \\\n+    || c99_count (,) != 2 || c99_count (A, B, C, D, E, F, G, H, I, J) != 10\n+#error c99_count\n+#endif\n+\n+/* Correct answers are empty, 'x'.  */\n+#if c99_repeat (0, 'x') c99_repeat (1, 'x') != 'x'\n+#error c99_repeat\n+#endif\n+\n+/* Correct answers are \"e\", \"b\", \"a\", empty.  */\n+#if c99_index (0, 'a', 'b', 'c', 'd', 'e') != 'e' \\\n+ || c99_index (3, 'a', 'b', 'c', 'd', 'e') != 'b' \\\n+ || c99_index (4, 'a', 'b', 'c', 'd', 'e') != 'a' \\\n+    c99_index (5, 'a', 'b', 'c', 'd', 'e')\n+#error gnu_index\n+#endif"}]}