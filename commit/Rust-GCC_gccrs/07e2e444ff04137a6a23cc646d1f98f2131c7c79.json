{"sha": "07e2e444ff04137a6a23cc646d1f98f2131c7c79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdlMmU0NDRmZjA0MTM3YTZhMjNjYzY0NmQxZjk4ZjIxMzFjN2M3OQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-03-18T19:12:50Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-03-18T19:12:50Z"}, "message": "mips.h (ELIMINABLE_REGS): Can't eliminate RETURN_ADDRESS_POINTER_REGNUM to $ra.\n\n* config/mips/mips.h (ELIMINABLE_REGS): Can't eliminate\nRETURN_ADDRESS_POINTER_REGNUM to $ra.\n(CAN_ELIMINATE): Only eliminate it to $sp if a frame pointer is\nnot needed.  Disregard leaf_function_p().\n(INITIAL_ELIMINATION_OFFSET): Adjust for elimination of rap to\nmips16 frame pointer.\n* config/mips/mips.md (store ra): Only to small SP offsets.\n2001-08-22  Graham Stott  <grahams@redhat.com>\n* config/mips/mips.h (RETURN_ADDR_RTX): For a leaf function\nreturn a REG rtx for the return address register.\n\nFrom-SVN: r50985", "tree": {"sha": "4e4b9698d928cf6d504ebd00c1f28d4105e3e52f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e4b9698d928cf6d504ebd00c1f28d4105e3e52f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07e2e444ff04137a6a23cc646d1f98f2131c7c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e2e444ff04137a6a23cc646d1f98f2131c7c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e2e444ff04137a6a23cc646d1f98f2131c7c79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e2e444ff04137a6a23cc646d1f98f2131c7c79/comments", "author": null, "committer": null, "parents": [{"sha": "eb8e00ea233bb1c028719a1f1c1b7c574e13e0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8e00ea233bb1c028719a1f1c1b7c574e13e0d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8e00ea233bb1c028719a1f1c1b7c574e13e0d8"}], "stats": {"total": 64, "additions": 40, "deletions": 24}, "files": [{"sha": "429a2ff3ff21394ee503bb4fc9053b3630c61fcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e2e444ff04137a6a23cc646d1f98f2131c7c79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e2e444ff04137a6a23cc646d1f98f2131c7c79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07e2e444ff04137a6a23cc646d1f98f2131c7c79", "patch": "@@ -1,3 +1,16 @@\n+2002-03-18  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/mips/mips.h (ELIMINABLE_REGS): Can't eliminate\n+\tRETURN_ADDRESS_POINTER_REGNUM to $ra.\n+\t(CAN_ELIMINATE): Only eliminate it to $sp if a frame pointer is\n+\tnot needed.  Disregard leaf_function_p().\n+\t(INITIAL_ELIMINATION_OFFSET): Adjust for elimination of rap to\n+\tmips16 frame pointer.\n+\t* config/mips/mips.md (store ra): Only to small SP offsets.\n+\t2001-08-22  Graham Stott  <grahams@redhat.com>\n+\t* config/mips/mips.h (RETURN_ADDR_RTX): For a leaf function\n+\treturn a REG rtx for the return address register.\n+\n 2002-03-18  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.h (GO_IF_MODE_DEPENDENT_ADDRESS): Treat"}, {"sha": "bc09632e73fe70cf63e23c2632482bfb39e998b5", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e2e444ff04137a6a23cc646d1f98f2131c7c79/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e2e444ff04137a6a23cc646d1f98f2131c7c79/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=07e2e444ff04137a6a23cc646d1f98f2131c7c79", "patch": "@@ -2417,9 +2417,12 @@ extern enum reg_class mips_char_to_class[256];\n    frame except by disassembling instructions in the prologue/epilogue.\n    So currently we support only the current frame.  */\n \n-#define RETURN_ADDR_RTX(count, frame)\t\t\t\\\n-  ((count == 0)\t\t\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM))\\\n+#define RETURN_ADDR_RTX(count, frame)\t\t\t\t\t\\\n+  (((count) == 0)\t\t\t\t\t\t\t\\\n+   ? (leaf_function_p ()\t\t\t\t\t\t\\\n+      ? gen_rtx_REG (Pmode, GP_REG_FIRST + 31)\t\t\t\t\\\n+      : gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode,\t\t\t\t\\\n+\t\t\t\t\t RETURN_ADDRESS_POINTER_REGNUM))) \\\n    : (rtx) 0)\n \n /* Structure to be filled in by compute_frame_size with register\n@@ -2483,7 +2486,6 @@ extern struct mips_frame_info current_frame_info;\n  { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n  { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\\\n  { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 17},\t\t\t\\\n- { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 31},\t\t\t\\\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 17}}\n@@ -2510,10 +2512,8 @@ extern struct mips_frame_info current_frame_info;\n \n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n   (((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n-    && ((! leaf_function_p ()\t\t\t\t\t\t\\\n-\t && ((TO) == STACK_POINTER_REGNUM\t\t\t\t\\\n- \t     || (TO) == HARD_FRAME_POINTER_REGNUM))\t\t\t\\\n-\t|| ((TO) == GP_REG_FIRST + 31 && leaf_function_p ())))  \t\\\n+    && (((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed)\t\\\n+ \t|| (TO) == HARD_FRAME_POINTER_REGNUM))\t\t\t\t\\\n    || ((FROM) != RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n       && ((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t\\\n \t  || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed\t\\\n@@ -2553,11 +2553,11 @@ extern struct mips_frame_info current_frame_info;\n      so we must add 4 bytes to the offset to get the right value.  */\t \\\n   else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM)\t\t\t \\\n   {\t\t\t\t\t\t\t\t\t \\\n-   if (leaf_function_p ()) \t\t\t\t\t\t \\\n-      (OFFSET) = 0;\t\t\t\t \t\t\t \\\n-   else (OFFSET) = current_frame_info.gp_sp_offset\t\t\t \\\n-\t       + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT))\t \\\n-\t\t  * (BYTES_BIG_ENDIAN != 0));\t\t\t\t \\\n+    (OFFSET) = current_frame_info.gp_sp_offset\t\t\t \t \\\n+      + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT))\t\t \\\n+\t * (BYTES_BIG_ENDIAN != 0));\t\t\t\t\t \\\n+    if (TARGET_MIPS16 && (TO) != STACK_POINTER_REGNUM)\t\t\t \\\n+      (OFFSET) -= current_function_outgoing_args_size;\t\t\t \\\n   }\t\t\t\t\t\t\t\t\t \\\n   else\t\t\t\t\t\t\t\t\t \\\n     abort();\t\t\t\t\t\t\t\t \\\n@@ -4153,7 +4153,7 @@ while (0)\n   \"$0\",   \"at\",   \"v0\",   \"v1\",   \"a0\",   \"a1\",   \"a2\",   \"a3\",\t\t\\\n   \"t0\",   \"t1\",   \"t2\",   \"t3\",   \"t4\",   \"t5\",   \"t6\",   \"t7\",\t\t\\\n   \"s0\",   \"s1\",   \"s2\",   \"s3\",   \"s4\",   \"s5\",   \"s6\",   \"s7\",\t\t\\\n-  \"t8\",   \"t9\",   \"k0\",   \"k1\",   \"gp\",   \"sp\",   \"$fp\",   \"ra\",\t\\\n+  \"t8\",   \"t9\",   \"k0\",   \"k1\",   \"gp\",   \"sp\",   \"$fp\",  \"ra\",\t\t\\\n   \"$f0\",  \"$f1\",  \"$f2\",  \"$f3\",  \"$f4\",  \"$f5\",  \"$f6\",  \"$f7\",\t\\\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\\\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\"}, {"sha": "60d560b686896f0b6eca06dbdbb678bb54f0f5a5", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e2e444ff04137a6a23cc646d1f98f2131c7c79/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e2e444ff04137a6a23cc646d1f98f2131c7c79/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=07e2e444ff04137a6a23cc646d1f98f2131c7c79", "patch": "@@ -5489,22 +5489,25 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-;; For mips16, we need a special case to handle storing $31 into\n-;; memory, since we don't have a constraint to match $31.  This\n-;; instruction can be generated by save_restore_insns.\n+;; We can only store $ra directly into a small sp offset.  Should the\n+;; offset be too wide, non-constant or not sp-based, leave it up to\n+;; reload to choose a scratch register.\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=R,m\")\n+  [(set (mem:SI (plus:SI (reg:SI 29)\n+\t\t\t (match_operand:SI 0 \"small_int\" \"n\")))\n \t(reg:SI 31))]\n   \"TARGET_MIPS16\"\n-  \"*\n-{\n-  operands[1] = gen_rtx (REG, SImode, 31);\n-  return mips_move_1word (operands, insn, FALSE);\n-}\"\n+  \"sw\\\\t$31,%0($sp)\"\n   [(set_attr \"type\"\t\"store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,8\")])\n+   (set_attr_alternative\n+    \"length\"\n+    [(if_then_else \n+      (lt (symbol_ref \"(unsigned HOST_WIDE_INT) INTVAL (operands[0])\")\n+\t  (const_int 1024))\n+      (const_int 4)\n+      (const_int 8))])])\n \n ;; The difference between these two is whether or not ints are allowed\n ;; in FP registers (off by default, use -mdebugh to enable)."}]}