{"sha": "41077ce4b37a093155987bdf671bdf91510f9067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEwNzdjZTRiMzdhMDkzMTU1OTg3YmRmNjcxYmRmOTE1MTBmOTA2Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-31T22:15:42Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-31T22:15:42Z"}, "message": "target.h: Fix formatting.\n\n\t* target.h: Fix formatting.\n\t* timevar.h: Likewise.\n\t* tlink.c: Likewise.\n\t* toplev.c: Likewise.\n\t* toplev.h: Likewise.\n\t* tree.c: Likewise.\n\t* tree-dump.h: Likewise.\n\t* tree.h: Likewise.\n\t* tree-inline.h: Likewise.\n\t* unroll.c: Likewise.\n\t* unwind-dw2.c: Likewise.\n\t* unwind-dw2-fde.c: Likewise.\n\t* unwind-dw2-fde-glibc.c: Likewise.\n\t* unwind-dw2-fde.h: Likewise.\n\t* unwind.h: Likewise.\n\t* unwind-sjlj.c: Likewise.\n\t* varasm.c: Likewise.\n\t* varray.h: Likewise.\n\t* vmsdbg.h: Likewise.\n\t* vmsdbgout.c: Likewise.\n\t* xcoffout.h: Likewise.\n\nFrom-SVN: r54123", "tree": {"sha": "5e8831114d6a8c6a8fbf6e52bd8fbb15155c9a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e8831114d6a8c6a8fbf6e52bd8fbb15155c9a23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41077ce4b37a093155987bdf671bdf91510f9067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41077ce4b37a093155987bdf671bdf91510f9067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41077ce4b37a093155987bdf671bdf91510f9067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41077ce4b37a093155987bdf671bdf91510f9067/comments", "author": null, "committer": null, "parents": [{"sha": "b2e426a0cc27661b3c296f9cb6d3cd37930f55cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e426a0cc27661b3c296f9cb6d3cd37930f55cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e426a0cc27661b3c296f9cb6d3cd37930f55cc"}], "stats": {"total": 416, "additions": 220, "deletions": 196}, "files": [{"sha": "5524591c4eba3ff00951544a1b7200f6f211d29b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -1,3 +1,27 @@\n+2002-05-31  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* target.h: Fix formatting.\n+\t* timevar.h: Likewise.\n+\t* tlink.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* toplev.h: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree-dump.h: Likewise.\n+\t* tree.h: Likewise.\n+\t* tree-inline.h: Likewise.\n+\t* unroll.c: Likewise.\n+\t* unwind-dw2.c: Likewise.\n+\t* unwind-dw2-fde.c: Likewise.\n+\t* unwind-dw2-fde-glibc.c: Likewise.\n+\t* unwind-dw2-fde.h: Likewise.\n+\t* unwind.h: Likewise.\n+\t* unwind-sjlj.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varray.h: Likewise.\n+\t* vmsdbg.h: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\t* xcoffout.h: Likewise.\n+\n 2002-05-31  Igor Shevlyakov <igor@microunity.com>\n \n \t* expr.c (compare_from_rtx): Generate comparison between op0 and op1 "}, {"sha": "7496fbbedf16bda72838b796de9306287081bbfb", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -134,7 +134,7 @@ struct gcc_target\n     /* Calculate how much this insn affects how many more insns we\n        can emit this cycle.  Default is they all cost the same.  */\n     int (* variable_issue) PARAMS ((FILE *, int, rtx, int));\n-    \n+\n     /* Initialize machine-dependent scheduling code.  */\n     void (* md_init) PARAMS ((FILE *, int, int));\n "}, {"sha": "149751c3467a686e2b854a8cea7d8661ba434a94", "filename": "gcc/timevar.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -41,9 +41,9 @@\n \n      - As a standalone timer, using timevar_start and timevar_stop.\n        All time elapsed between the two calls is attributed to the\n-       variable.  \n+       variable.\n */\n-   \n+\n /* This structure stores the various varieties of time that can be\n    measured.  Times are stored in seconds.  The time may be an\n    absolute time or a time difference; in the former case, the time\n@@ -67,7 +67,7 @@ struct timevar_time_def\n    the contents of timevar.def.  */\n \n #define DEFTIMEVAR(identifier__, name__) \\\n-    identifier__, \n+    identifier__,\n typedef enum\n {\n #include \"timevar.def\""}, {"sha": "fe06eba0f9bccdedd3641febc60e9ddecf413532", "filename": "gcc/tlink.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -588,7 +588,7 @@ demangle_new_symbols ()\n     {\n       demangled *dem;\n       const char *p = cplus_demangle ((char*) sym->root.key,\n-\t\t\t\tDMGL_PARAMS | DMGL_ANSI);\n+\t\t\t\t      DMGL_PARAMS | DMGL_ANSI);\n \n       if (! p)\n \tcontinue;"}, {"sha": "a3d0dfd08e0a08360139df0afe064cdfdef29329", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -1673,7 +1673,7 @@ strip_off_ending (name, len)\n      int len;\n {\n   int i;\n-  for (i = 2; i < 6 && len > i;  i++)\n+  for (i = 2; i < 6 && len > i; i++)\n     {\n       if (name[len - i] == '.')\n \t{\n@@ -1715,15 +1715,15 @@ output_quoted_string (asm_file, string)\n    usable as an identifier in a target's assembly file.  */\n void\n output_clean_symbol_name (file, name)\n-    FILE *file;\n-    const char *name;\n+     FILE *file;\n+     const char *name;\n {\n   /* Make a copy of NAME.  */\n   char *id = xstrdup (name);\n \n   /* Make it look like a valid identifier for an assembler.  */\n   clean_symbol_name (id);\n-  \n+\n   fputs (id, file);\n   free (id);\n }"}, {"sha": "c61fa7487790d5166cde0d3f9d958cdcd3cc984b", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -116,7 +116,7 @@ extern struct ht *ident_hash;\n \n /* This function can be used by targets to set the flags originally\n     implied by -ffast-math and -fno-fast-math.  */\n- \n+\n extern void set_fast_math_flags         PARAMS ((int));\n \n /* Return true iff flags are set as if -ffast-math.  */"}, {"sha": "d4951d9f5054207574b4d4a41ba5446c9ef33edd", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -46,7 +46,7 @@ typedef struct dump_queue\n   struct dump_queue *next;\n } *dump_queue_p;\n \n-/* A dump_info gives information about how we should perform the dump \n+/* A dump_info gives information about how we should perform the dump\n    and about the current state of the dump.  */\n \n struct dump_info\n@@ -67,7 +67,7 @@ struct dump_info\n   dump_queue_p queue_end;\n   /* Free queue nodes.  */\n   dump_queue_p free_list;\n-  /* The tree nodes which we have already written out.  The \n+  /* The tree nodes which we have already written out.  The\n      keys are the addresses of the nodes; the values are the integer\n      indices we assigned them.  */\n   splay_tree nodes;\n@@ -79,17 +79,17 @@ struct dump_info\n \n extern void dump_pointer\n   PARAMS ((dump_info_p, const char *, void *));\n-extern void dump_int \n+extern void dump_int\n   PARAMS ((dump_info_p, const char *, int));\n-extern void dump_string \n+extern void dump_string\n   PARAMS ((dump_info_p, const char *));\n-extern void dump_stmt \n+extern void dump_stmt\n   PARAMS ((dump_info_p, tree));\n-extern void dump_next_stmt \n+extern void dump_next_stmt\n   PARAMS ((dump_info_p, tree));\n-extern void queue_and_dump_index \n+extern void queue_and_dump_index\n   PARAMS ((dump_info_p, const char *, tree, int));\n-extern void queue_and_dump_type \n+extern void queue_and_dump_type\n   PARAMS ((dump_info_p, tree));\n \n #endif /* ! GCC_TREE_DUMP_H */"}, {"sha": "9c11436f39995bd99728ae9546d6c6a1405a1be5", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -33,8 +33,8 @@ void clone_body PARAMS ((tree, tree, void*));\n void remap_save_expr PARAMS ((tree*, void*, tree, int*));\n \n /* 0 if we should not perform inlining.\n-   1 if we should expand functions calls inline at the tree level.  \n-   2 if we should consider *all* functions to be inline \n+   1 if we should expand functions calls inline at the tree level.\n+   2 if we should consider *all* functions to be inline\n    candidates.  */\n \n extern int flag_inline_trees;"}, {"sha": "15f156aea0a511c8dc8ebe3f4d060b0cf691654a", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -522,7 +522,7 @@ build_real (type, d)\n   v = make_node (REAL_CST);\n   dp = ggc_alloc (sizeof (REAL_VALUE_TYPE));\n   memcpy (dp, &d, sizeof (REAL_VALUE_TYPE));\n-  \n+\n   TREE_TYPE (v) = type;\n   TREE_REAL_CST_PTR (v) = dp;\n   TREE_OVERFLOW (v) = TREE_CONSTANT_OVERFLOW (v) = overflow;\n@@ -4209,7 +4209,7 @@ decl_type_context (decl)\n   while (context)\n     {\n       if (TREE_CODE (context) == NAMESPACE_DECL)\n-        return NULL_TREE;\n+\treturn NULL_TREE;\n \n       if (TREE_CODE (context) == RECORD_TYPE\n \t  || TREE_CODE (context) == UNION_TYPE"}, {"sha": "fffad7a4bb0940518914867e21836fa9d69924fd", "filename": "gcc/tree.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -492,7 +492,7 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    construct the address of this field.  This is used for aliasing\n    purposes: see record_component_aliases.\n    In CONSTRUCTOR nodes, it means object constructed must be in memory.\n-   In LABEL_DECL nodes, it means a goto for this label has been seen \n+   In LABEL_DECL nodes, it means a goto for this label has been seen\n    from a place outside all binding contours that restore stack levels.\n    In ..._TYPE nodes, it means that objects of this type must\n    be fully addressable.  This means that pieces of this\n@@ -699,9 +699,9 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n   (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n     < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\t\\\n    || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n-        == (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n+\t== (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n        && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n- \n+\n struct tree_int_cst\n {\n   struct tree_common common;\n@@ -926,7 +926,7 @@ struct tree_exp\n    One of the logical block fragments is arbitrarily chosen to be\n    the ORIGIN.  The other fragments will point to the origin via\n    BLOCK_FRAGMENT_ORIGIN; the origin itself will have this pointer\n-   be null.  The list of fragments will be chained through \n+   be null.  The list of fragments will be chained through\n    BLOCK_FRAGMENT_CHAIN from the origin.  */\n \n #define BLOCK_FRAGMENT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_origin)\n@@ -1277,7 +1277,7 @@ struct tree_type\n    from the base of the complete object to the base of the part of the\n    object that is allocated on behalf of this `type'.\n    This is always 0 except when there is multiple inheritance.  */\n-   \n+\n #define BINFO_OFFSET(NODE) TREE_VEC_ELT ((NODE), 1)\n #define TYPE_BINFO_OFFSET(NODE) BINFO_OFFSET (TYPE_BINFO (NODE))\n #define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))\n@@ -1375,15 +1375,15 @@ struct tree_type\n    DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n    the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n    semantics of using this macro, are different than saying:\n-     \n+\n      SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n \n    which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n \n #define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n   (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n-   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2, \t\t\t\t\\\n-                                     DECL_ASSEMBLER_NAME (DECL1))\t\\\n+   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2,\t\t\t\t\\\n+\t\t\t\t     DECL_ASSEMBLER_NAME (DECL1))\t\\\n    : (void) 0)\n \n /* Records the section name in a section attribute.  Used to pass\n@@ -1470,7 +1470,7 @@ struct tree_type\n    PROMOTED_MODE is defined, the mode of this expression may not be same\n    as DECL_MODE.  In that case, DECL_MODE contains the mode corresponding\n    to the variable's data type, while the mode\n-   of DECL_RTL is the mode actually used to contain the data.  \n+   of DECL_RTL is the mode actually used to contain the data.\n \n    This value can be evaluated lazily for functions, variables with\n    static storage duration, and labels.  */\n@@ -1578,7 +1578,7 @@ struct tree_type\n \n /* In a TYPE_DECL\n    nonzero means the detail info about this type is not dumped into stabs.\n-   Instead it will generate cross reference ('x') of names. \n+   Instead it will generate cross reference ('x') of names.\n    This uses the same flag as DECL_EXTERNAL.  */\n #define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n   (TYPE_DECL_CHECK (NODE)->decl.external_flag)\n@@ -1614,7 +1614,7 @@ struct tree_type\n /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n #define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n \n-/* In a VAR_DECL, nonzero if the data should be allocated from \n+/* In a VAR_DECL, nonzero if the data should be allocated from\n    thread-local storage.  */\n #define DECL_THREAD_LOCAL(NODE) (VAR_DECL_CHECK (NODE)->decl.thread_local_flag)\n \n@@ -1895,7 +1895,7 @@ enum tree_index\n   TI_UINTSI_TYPE,\n   TI_UINTDI_TYPE,\n   TI_UINTTI_TYPE,\n-    \n+\n   TI_INTEGER_ZERO,\n   TI_INTEGER_ONE,\n   TI_INTEGER_MINUS_ONE,\n@@ -1955,7 +1955,7 @@ enum tree_index\n extern tree global_trees[TI_MAX];\n \n #define error_mark_node\t\t\tglobal_trees[TI_ERROR_MARK]\n- \n+\n #define intQI_type_node\t\t\tglobal_trees[TI_INTQI_TYPE]\n #define intHI_type_node\t\t\tglobal_trees[TI_INTHI_TYPE]\n #define intSI_type_node\t\t\tglobal_trees[TI_INTSI_TYPE]\n@@ -2028,7 +2028,7 @@ extern tree global_trees[TI_MAX];\n \n /* An enumeration of the standard C integer types.  These must be\n    ordered so that shorter types appear before longer ones.  */\n-enum integer_type_kind \n+enum integer_type_kind\n {\n   itk_char,\n   itk_signed_char,"}, {"sha": "ceec66ee0d3ce1af3808d5e4af6b933b32c60193", "filename": "gcc/unroll.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -1635,7 +1635,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n \t  rtx second_part = XEXP (increment, 1);\n \t  enum rtx_code code = GET_CODE (increment);\n \n-\t  increment = find_last_value (XEXP (increment, 0), \n+\t  increment = find_last_value (XEXP (increment, 0),\n \t\t\t\t       &src_insn, NULL_RTX, 0);\n \t  /* Don't need the last insn anymore.  */\n \t  delete_related_insns (get_last_insn ());\n@@ -1732,7 +1732,7 @@ final_reg_note_copy (notesp, map)\n   while (*notesp)\n     {\n       rtx note = *notesp;\n-      \n+\n       if (GET_CODE (note) == INSN_LIST)\n \t{\n \t  /* Sometimes, we have a REG_WAS_0 note that points to a\n@@ -2579,7 +2579,7 @@ find_splittable_regs (loop, unroll_type, unroll_number)\n \t\t  rtx tem = gen_reg_rtx (bl->biv->mode);\n \n \t\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n-\t\t  loop_insn_hoist (loop, \n+\t\t  loop_insn_hoist (loop,\n \t\t\t\t   gen_move_insn (tem, bl->biv->src_reg));\n \n \t\t  if (loop_dump_stream)\n@@ -3594,7 +3594,7 @@ loop_iterations (loop)\n \t\t  && INSN_LUID (JUMP_LABEL (temp)) < INSN_LUID (loop->cont))\n \t\t{\n \t\t  if (loop_dump_stream)\n-\t\t    fprintf \n+\t\t    fprintf\n \t\t      (loop_dump_stream,\n \t\t       \"Loop iterations: Loop has multiple back edges.\\n\");\n \t\t  return 0;"}, {"sha": "463e32044831f344afa9f36c5a51803173496f4e", "filename": "gcc/unwind-dw2-fde-glibc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2-fde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2-fde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde-glibc.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -81,7 +81,7 @@ struct unw_eh_frame_hdr\n \n /* Like base_of_encoded_value, but take the base from a struct object\n    instead of an _Unwind_Context.  */\n-   \n+\n static _Unwind_Ptr\n base_from_cb_data (unsigned char encoding, struct unw_eh_callback_data *data)\n {\n@@ -94,7 +94,7 @@ base_from_cb_data (unsigned char encoding, struct unw_eh_callback_data *data)\n     case DW_EH_PE_pcrel:\n     case DW_EH_PE_aligned:\n       return 0;\n-                                 \n+\n     case DW_EH_PE_textrel:\n       return (_Unwind_Ptr) data->tbase;\n     case DW_EH_PE_datarel:"}, {"sha": "a06a5bed87b38345cedb82d56da8ab02080667b2", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -53,7 +53,7 @@ static __gthread_mutex_t object_mutex;\n #endif\n \n #ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n-static void \n+static void\n init_object_mutex (void)\n {\n   __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n@@ -111,7 +111,7 @@ __register_frame (void *begin)\n     return;\n \n   ob = (struct object *) malloc (sizeof (struct object));\n-  __register_frame_info (begin, ob);                       \n+  __register_frame_info (begin, ob);\n }\n \n /* Similar, but BEGIN is actually a pointer to a table of unwind entries\n@@ -161,7 +161,7 @@ __register_frame_table (void *begin)\n    Since the registration did not happen there, we'll abort.\n \n    Therefore, declare a new deregistration entry point that does the\n-   exact same thing, but will resolve to the same library as \n+   exact same thing, but will resolve to the same library as\n    implements __register_frame_info_bases.  */\n \n void *\n@@ -398,7 +398,7 @@ start_fde_sort (struct fde_accumulator *accu, size_t count)\n       return 1;\n     }\n   else\n-    return 0;  \n+    return 0;\n }\n \n static inline void\n@@ -411,7 +411,7 @@ fde_insert (struct fde_accumulator *accu, fde *this_fde)\n /* Split LINEAR into a linear sequence with low values and an erratic\n    sequence with high values, put the linear one (of longest possible\n    length) into LINEAR and the erratic one into ERRATIC. This is O(N).\n-   \n+\n    Because the longest linear sequence we are trying to locate within the\n    incoming LINEAR array can be interspersed with (high valued) erratic\n    entries.  We construct a chain indicating the sequenced entries.\n@@ -434,18 +434,18 @@ fde_split (struct object *ob, fde_compare_t fde_compare,\n      them and the overlaying onto ERRATIC will not work.  */\n   if (sizeof (fde *) != sizeof (fde **))\n     abort ();\n-  \n+\n   for (i = 0; i < count; i++)\n     {\n       fde **probe;\n-      \n+\n       for (probe = chain_end;\n-           probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;\n-           probe = chain_end)\n-        {\n-          chain_end = (fde **) erratic->array[probe - linear->array];\n-          erratic->array[probe - linear->array] = NULL;\n-        }\n+\t   probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;\n+\t   probe = chain_end)\n+\t{\n+\t  chain_end = (fde **) erratic->array[probe - linear->array];\n+\t  erratic->array[probe - linear->array] = NULL;\n+\t}\n       erratic->array[i] = (fde *) chain_end;\n       chain_end = &linear->array[i];\n     }\n@@ -486,45 +486,45 @@ frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n       /* Invariant: a[m..n-1] is a heap.  */\n       m--;\n       for (i = m; 2*i+1 < n; )\n-        {\n-          if (2*i+2 < n\n-              && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0\n-              && fde_compare (ob, a[2*i+2], a[i]) > 0)\n-            {\n-              SWAP (a[i], a[2*i+2]);\n-              i = 2*i+2;\n-            }\n-          else if (fde_compare (ob, a[2*i+1], a[i]) > 0)\n-            {\n-              SWAP (a[i], a[2*i+1]);\n-              i = 2*i+1;\n-            }\n-          else\n-            break;\n-        }\n+\t{\n+\t  if (2*i+2 < n\n+\t      && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0\n+\t      && fde_compare (ob, a[2*i+2], a[i]) > 0)\n+\t    {\n+\t      SWAP (a[i], a[2*i+2]);\n+\t      i = 2*i+2;\n+\t    }\n+\t  else if (fde_compare (ob, a[2*i+1], a[i]) > 0)\n+\t    {\n+\t      SWAP (a[i], a[2*i+1]);\n+\t      i = 2*i+1;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n     }\n   while (n > 1)\n     {\n       /* Invariant: a[0..n-1] is a heap.  */\n       n--;\n       SWAP (a[0], a[n]);\n       for (i = 0; 2*i+1 < n; )\n-        {\n-          if (2*i+2 < n\n-              && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0\n-              && fde_compare (ob, a[2*i+2], a[i]) > 0)\n-            {\n-              SWAP (a[i], a[2*i+2]);\n-              i = 2*i+2;\n-            }\n-          else if (fde_compare (ob, a[2*i+1], a[i]) > 0)\n-            {\n-              SWAP (a[i], a[2*i+1]);\n-              i = 2*i+1;\n-            }\n-          else\n-            break;\n-        }\n+\t{\n+\t  if (2*i+2 < n\n+\t      && fde_compare (ob, a[2*i+2], a[2*i+1]) > 0\n+\t      && fde_compare (ob, a[2*i+2], a[i]) > 0)\n+\t    {\n+\t      SWAP (a[i], a[2*i+2]);\n+\t      i = 2*i+2;\n+\t    }\n+\t  else if (fde_compare (ob, a[2*i+1], a[i]) > 0)\n+\t    {\n+\t      SWAP (a[i], a[2*i+1]);\n+\t      i = 2*i+1;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n     }\n #undef SWAP\n }\n@@ -550,7 +550,7 @@ fde_merge (struct object *ob, fde_compare_t fde_compare,\n \t      v1->array[i1+i2] = v1->array[i1-1];\n \t      i1--;\n \t    }\n-        v1->array[i1+i2] = fde2;\n+\t  v1->array[i1+i2] = fde2;\n \t}\n       while (i2 > 0);\n       v1->count += v2->count;\n@@ -590,7 +590,7 @@ end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)\n }\n \n \f\n-/* Update encoding, mixed_encoding, and pc_begin for OB for the \n+/* Update encoding, mixed_encoding, and pc_begin for OB for the\n    fde array beginning at THIS_FDE.  Return the number of fdes\n    encountered along the way.  */\n \n@@ -747,7 +747,7 @@ init_object (struct object* ob)\n     {\n       fde **p;\n       for (p = ob->u.array; *p; ++p)\n-        add_fdes (ob, &accu, *p);\n+\tadd_fdes (ob, &accu, *p);\n     }\n   else\n     add_fdes (ob, &accu, ob->u.single);\n@@ -826,7 +826,7 @@ linear_search_fdes (struct object *ob, fde *this_fde, void *pc)\n \t}\n \n       if ((_Unwind_Ptr) pc - pc_begin < pc_range)\n-        return this_fde;\n+\treturn this_fde;\n     }\n \n   return NULL;\n@@ -840,7 +840,7 @@ binary_search_unencoded_fdes (struct object *ob, void *pc)\n {\n   struct fde_vector *vec = ob->u.sort;\n   size_t lo, hi;\n-      \n+\n   for (lo = 0, hi = vec->count; lo < hi; )\n     {\n       size_t i = (lo + hi) / 2;\n@@ -869,7 +869,7 @@ binary_search_single_encoding_fdes (struct object *ob, void *pc)\n   int encoding = ob->s.b.encoding;\n   _Unwind_Ptr base = base_from_object (encoding, ob);\n   size_t lo, hi;\n-      \n+\n   for (lo = 0, hi = vec->count; lo < hi; )\n     {\n       size_t i = (lo + hi) / 2;\n@@ -897,7 +897,7 @@ binary_search_mixed_encoding_fdes (struct object *ob, void *pc)\n {\n   struct fde_vector *vec = ob->u.sort;\n   size_t lo, hi;\n-      \n+\n   for (lo = 0, hi = vec->count; lo < hi; )\n     {\n       size_t i = (lo + hi) / 2;\n@@ -952,14 +952,14 @@ search_object (struct object* ob, void *pc)\n     {\n       /* Long slow labourious linear search, cos we've no memory.  */\n       if (ob->s.b.from_array)\n-        {\n-          fde **p;\n+\t{\n+\t  fde **p;\n \t  for (p = ob->u.array; *p ; p++)\n \t    {\n \t      fde *f = linear_search_fdes (ob, *p, pc);\n-              if (f)\n+\t      if (f)\n \t\treturn f;\n-            }\n+\t    }\n \t  return NULL;\n \t}\n       else"}, {"sha": "23f6f7e6ca93603129d684abbefd51bfca269234", "filename": "gcc/unwind-dw2-fde.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2-fde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2-fde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -122,7 +122,7 @@ typedef unsigned char ubyte;\n    a) in a linear search, find the shared image (i.e. DLL) containing\n       the PC\n    b) using the FDE table for that shared object, locate the FDE using\n-      binary search (which requires the sorting).  */   \n+      binary search (which requires the sorting).  */\n \n /* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n    to distinguish it from a valid FDE.  FDEs are aligned to an addressing"}, {"sha": "fd7db6adc6722e062945981d080199ec88e33f88", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -591,68 +591,68 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  {\n \t    /* Binary operations.  */\n \t    _Unwind_Word first, second;\n-\t  if ((stack_elt -= 2) < 0)\n-\t    abort ();\n-\t  second = stack[stack_elt];\n-\t  first = stack[stack_elt + 1];\n-\n-\t  switch (op)\n-\t    {\n-\t    case DW_OP_and:\n-\t      result = second & first;\n-\t      break;\n-\t    case DW_OP_div:\n-\t      result = (_Unwind_Sword) second / (_Unwind_Sword) first;\n-\t      break;\n-\t    case DW_OP_minus:\n-\t      result = second - first;\n-\t      break;\n-\t    case DW_OP_mod:\n-\t      result = (_Unwind_Sword) second % (_Unwind_Sword) first;\n-\t      break;\n-\t    case DW_OP_mul:\n-\t      result = second * first;\n-\t      break;\n-\t    case DW_OP_or:\n-\t      result = second | first;\n-\t      break;\n-\t    case DW_OP_plus:\n-\t      result = second + first;\n-\t      break;\n-\t    case DW_OP_shl:\n-\t      result = second << first;\n-\t      break;\n-\t    case DW_OP_shr:\n-\t      result = second >> first;\n-\t      break;\n-\t    case DW_OP_shra:\n-\t      result = (_Unwind_Sword) second >> first;\n-\t      break;\n-\t    case DW_OP_xor:\n-\t      result = second ^ first;\n-\t      break;\n-\t    case DW_OP_le:\n-\t      result = (_Unwind_Sword) first <= (_Unwind_Sword) second;\n-\t      break;\n-\t    case DW_OP_ge:\n-\t      result = (_Unwind_Sword) first >= (_Unwind_Sword) second;\n-\t      break;\n-\t    case DW_OP_eq:\n-\t      result = (_Unwind_Sword) first == (_Unwind_Sword) second;\n-\t      break;\n-\t    case DW_OP_lt:\n-\t      result = (_Unwind_Sword) first < (_Unwind_Sword) second;\n-\t      break;\n-\t    case DW_OP_gt:\n-\t      result = (_Unwind_Sword) first > (_Unwind_Sword) second;\n-\t      break;\n-\t    case DW_OP_ne:\n-\t      result = (_Unwind_Sword) first != (_Unwind_Sword) second;\n-\t      break;\n-\n-\t    default:\n+\t    if ((stack_elt -= 2) < 0)\n \t      abort ();\n-\t    }\n+\t    second = stack[stack_elt];\n+\t    first = stack[stack_elt + 1];\n+\n+\t    switch (op)\n+\t      {\n+\t      case DW_OP_and:\n+\t\tresult = second & first;\n+\t\tbreak;\n+\t      case DW_OP_div:\n+\t\tresult = (_Unwind_Sword) second / (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_minus:\n+\t\tresult = second - first;\n+\t\tbreak;\n+\t      case DW_OP_mod:\n+\t\tresult = (_Unwind_Sword) second % (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_mul:\n+\t\tresult = second * first;\n+\t\tbreak;\n+\t      case DW_OP_or:\n+\t\tresult = second | first;\n+\t\tbreak;\n+\t      case DW_OP_plus:\n+\t\tresult = second + first;\n+\t\tbreak;\n+\t      case DW_OP_shl:\n+\t\tresult = second << first;\n+\t\tbreak;\n+\t      case DW_OP_shr:\n+\t\tresult = second >> first;\n+\t\tbreak;\n+\t      case DW_OP_shra:\n+\t\tresult = (_Unwind_Sword) second >> first;\n+\t\tbreak;\n+\t      case DW_OP_xor:\n+\t\tresult = second ^ first;\n+\t\tbreak;\n+\t      case DW_OP_le:\n+\t\tresult = (_Unwind_Sword) first <= (_Unwind_Sword) second;\n+\t\tbreak;\n+\t      case DW_OP_ge:\n+\t\tresult = (_Unwind_Sword) first >= (_Unwind_Sword) second;\n+\t\tbreak;\n+\t      case DW_OP_eq:\n+\t\tresult = (_Unwind_Sword) first == (_Unwind_Sword) second;\n+\t\tbreak;\n+\t      case DW_OP_lt:\n+\t\tresult = (_Unwind_Sword) first < (_Unwind_Sword) second;\n+\t\tbreak;\n+\t      case DW_OP_gt:\n+\t\tresult = (_Unwind_Sword) first > (_Unwind_Sword) second;\n+\t\tbreak;\n+\t      case DW_OP_ne:\n+\t\tresult = (_Unwind_Sword) first != (_Unwind_Sword) second;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tabort ();\n+\t      }\n \t  }\n \t  break;\n \n@@ -783,7 +783,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t    fs->regs.reg[reg].loc.reg = reg2;\n \t  }\n \t  break;\n-      \n+\n \tcase DW_CFA_remember_state:\n \t  {\n \t    struct frame_state_reg_info *new_rs;\n@@ -850,7 +850,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = offset;\n \t  break;\n-\t  \n+\n \tcase DW_CFA_def_cfa_sf:\n \t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n \t  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);\n@@ -1034,7 +1034,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n       /* Special handling here: Many machines do not use a frame pointer,\n \t and track the CFA only through offsets from the stack pointer from\n \t one frame to the next.  In this case, the stack pointer is never\n-\t stored, so it has no saved address in the context.  What we do \n+\t stored, so it has no saved address in the context.  What we do\n \t have is the CFA from the previous stack frame.  */\n       if (context->reg[fs->cfa_reg] == NULL)\n \tcfa = context->cfa;\n@@ -1108,7 +1108,7 @@ uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \f\n /* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n    level will be the return address and the CFA.  */\n-   \n+\n #define uw_init_context(CONTEXT)\t\t\t\t\t   \\\n   do\t\t\t\t\t\t\t\t\t   \\\n     {\t\t\t\t\t\t\t\t\t   \\"}, {"sha": "fc22911768b2e8009e9e2c861e079d5c8d11bbc6", "filename": "gcc/unwind-sjlj.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-sjlj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind-sjlj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-sjlj.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -63,7 +63,7 @@ struct SjLj_Function_Context\n #ifdef DONT_USE_BUILTIN_SETJMP\n   /* We don't know what sort of alignment requirements the system\n      jmp_buf has.  We over estimated in except.c, and now we have\n-     to match that here just in case the system *didn't* have more \n+     to match that here just in case the system *didn't* have more\n      restrictive requirements.  */\n   jmp_buf jbuf __attribute__((aligned));\n #else\n@@ -76,7 +76,7 @@ struct _Unwind_Context\n   struct SjLj_Function_Context *fc;\n };\n \n-typedef struct \n+typedef struct\n {\n   _Unwind_Personality_Fn personality;\n } _Unwind_FrameState;\n@@ -244,7 +244,7 @@ uw_update_context (struct _Unwind_Context *context,\n   context->fc = context->fc->prev;\n }\n \n-static inline void \n+static inline void\n uw_init_context (struct _Unwind_Context *context)\n {\n   context->fc = _Unwind_SjLj_GetContext ();"}, {"sha": "765ffb2197b27fafe3603d7a293a6d7992585581", "filename": "gcc/unwind.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Funwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -136,15 +136,15 @@ extern _Unwind_Ptr _Unwind_GetRegionStart (struct _Unwind_Context *);\n    library and language-specific exception handling semantics.  It is\n    specific to the code fragment described by an unwind info block, and\n    it is always referenced via the pointer in the unwind info block, and\n-   hence it has no ABI-specified name. \n+   hence it has no ABI-specified name.\n \n    Note that this implies that two different C++ implementations can\n    use different names, and have different contents in the language\n-   specific data area.  Moreover, that the language specific data \n+   specific data area.  Moreover, that the language specific data\n    area contains no version info because name of the function invoked\n    provides more effective versioning by detecting at link time the\n    lack of code to handle the different data format.  */\n-   \n+\n typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)\n      (int, _Unwind_Action, _Unwind_Exception_Class,\n       struct _Unwind_Exception *, struct _Unwind_Context *);"}, {"sha": "a0b1a3397376ddad7da45ba5aa42679310e2deee", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -1557,7 +1557,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n     {\n       warning_with_decl (decl,\n \t\"alignment of `%s' is greater than maximum object file alignment. Using %d\",\n-                    MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n+\t\t\t MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n       align = MAX_OFILE_ALIGNMENT;\n     }\n \n@@ -1569,7 +1569,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n #endif\n #ifdef CONSTANT_ALIGNMENT\n       if (DECL_INITIAL (decl) != 0 && DECL_INITIAL (decl) != error_mark_node)\n-        align = CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);\n+\talign = CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);\n #endif\n     }\n \n@@ -1610,7 +1610,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n #endif\n   else if (DECL_INITIAL (decl) == 0\n \t   || DECL_INITIAL (decl) == error_mark_node\n-           || (flag_zero_initialized_in_bss\n+\t   || (flag_zero_initialized_in_bss\n \t       && initializer_zerop (DECL_INITIAL (decl))))\n     {\n       unsigned HOST_WIDE_INT size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n@@ -1630,8 +1630,8 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n /* Don't continue this line--convex cc version 4.1 would lose.  */\n #if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n       if ((unsigned HOST_WIDE_INT) DECL_ALIGN (decl) / BITS_PER_UNIT > rounded)\n-         warning_with_decl\n-           (decl, \"requested alignment for %s is greater than implemented alignment of %d\",rounded);\n+\twarning_with_decl\n+\t  (decl, \"requested alignment for %s is greater than implemented alignment of %d\",rounded);\n #endif\n \n       asm_emit_uninitialised (decl, name, size, rounded);\n@@ -4055,8 +4055,8 @@ output_addressed_constants (exp)\n \t;\n \n       if (TREE_CODE_CLASS (TREE_CODE (tem)) == 'c'\n-\t    || TREE_CODE (tem) == CONSTRUCTOR)\n-\t  output_constant_def (tem, 0);\n+\t  || TREE_CODE (tem) == CONSTRUCTOR)\n+\toutput_constant_def (tem, 0);\n \n       if (TREE_PUBLIC (tem))\n \treloc |= 2;\n@@ -4805,7 +4805,7 @@ mark_weak (decl)\n       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == SYMBOL_REF)\n     SYMBOL_REF_WEAK (XEXP (DECL_RTL (decl), 0)) = 1;\n }\n- \n+\n /* Merge weak status between NEWDECL and OLDDECL.  */\n \n void\n@@ -4819,15 +4819,15 @@ merge_weak (newdecl, olddecl)\n   if (DECL_WEAK (newdecl))\n     {\n       tree wd;\n-      \n+\n       /* NEWDECL is weak, but OLDDECL is not.  */\n \n       /* If we already output the OLDDECL, we're in trouble; we can't\n \t go back and make it weak.  This error cannot caught in\n \t declare_weak because the NEWDECL and OLDDECL was not yet\n \t been merged; therefore, TREE_ASM_WRITTEN was not set.  */\n       if (TREE_ASM_WRITTEN (olddecl))\n-\terror_with_decl (newdecl, \n+\terror_with_decl (newdecl,\n \t\t\t \"weak declaration of `%s' must precede definition\");\n \n       /* If we've already generated rtl referencing OLDDECL, we may\n@@ -5469,7 +5469,7 @@ default_elf_select_section (decl, reloc, align)\n     }\n }\n \n-/* Construct a unique section name based on the decl name and the \n+/* Construct a unique section name based on the decl name and the\n    categorization performed above.  */\n \n void"}, {"sha": "630a0a3581abf7e80bcaf51eda80919756a9df35", "filename": "gcc/varray.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -188,8 +188,8 @@ extern void varray_check_failed PARAMS ((varray_type, size_t,\n \n /* Push X onto VA.  T is the name of the field in varray_data\n    corresponding to the type of X.  */\n-#define VARRAY_PUSH(VA, T, X) \t\t\t\t\\\n-  do \t\t\t\t\t\t\t\\\n+#define VARRAY_PUSH(VA, T, X)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       if ((VA)->elements_used >= (VA)->num_elements)\t\\\n         VARRAY_GROW ((VA), 2 * (VA)->num_elements);\t\\"}, {"sha": "bb12bd9c5ed4d0b285aecf7b64dbf1155ca48e9b", "filename": "gcc/vmsdbg.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvmsdbg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvmsdbg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbg.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -190,7 +190,7 @@ typedef struct _DST_SOURCE_CORR\n #define DST_K_SOURCE_CORR_HEADER_SIZE 4\n \n /* Source file correlation codes.  */\n-\t\n+\n #define DST_K_SRC_DECLFILE 1\n #define DST_K_SRC_SETFILE 2\n #define DST_K_SRC_SETREC_L 3\n@@ -251,5 +251,5 @@ typedef struct _DST_PROLOG\n   unsigned int dst_l_prolog_bkpt_addr;\n } DST_PROLOG;\n #define DST_K_PROLOG_SIZE 8\n-\t\n+\n #endif /* GCC_VMSDBG_H */"}, {"sha": "5d19c458f45fdfaecba2b1ce0852809ad25607ce", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -449,7 +449,7 @@ addr_const_to_string (str, x)\n       break;\n \n     case CONST:\n-      /* This used to output parentheses around the expression, but that does \n+      /* This used to output parentheses around the expression, but that does\n          not work on the 386 (either ATT or BSD assembler).  */\n       addr_const_to_string (buf1, XEXP (x, 0));\n       strcat (str, buf1);\n@@ -644,7 +644,7 @@ write_debug_data4 (data4, comment, dosizeonly)\n \tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n       fputc ('\\n', asm_out_file);\n     }\n-  \n+\n   return 4;\n }\n \n@@ -707,7 +707,7 @@ write_debug_string (string, comment, dosizeonly)\n \tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n       fputc ('\\n', asm_out_file);\n     }\n-  \n+\n   return strlen (string);\n }\n \n@@ -829,7 +829,7 @@ write_rtnbeg (rtnnum, dosizeonly)\n       /* header size - 1st byte + flag byte + STO_LW size\n \t + string count byte + string length */\n       header.dst__header_length.dst_w_length\n-        = DST_K_DST_HEADER_SIZE - 1 + 1 + 4 + 1 + strlen (go);\n+\t= DST_K_DST_HEADER_SIZE - 1 + 1 + 4 + 1 + strlen (go);\n       header.dst__header_type.dst_w_type = 0x17;\n \n       totsize += write_debug_header (&header, \"transfer\", dosizeonly);\n@@ -1133,7 +1133,7 @@ write_srccorr (fileid, file_info_entry, dosizeonly)\n     = DST_K_SOURCE;\n \n   src_cmdtrlr.dst_b_src_df_libmodname = 0;\n-  \n+\n   totsize += write_debug_header (&src_header.dst_a_source_corr_header,\n \t\t\t\t \"source corr\", dosizeonly);\n   totsize += write_debug_data1 (src_command.dst_b_src_command,\n@@ -1153,7 +1153,7 @@ write_srccorr (fileid, file_info_entry, dosizeonly)\n   totsize += write_debug_data8\n     (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_q_src_df_rms_cdt,\n      \"source_corr (creation date)\", dosizeonly);\n-  \n+\n   totsize += write_debug_data4\n     (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_l_src_df_rms_ebk,\n      \"source_corr (EOF block number)\", dosizeonly);\n@@ -1273,7 +1273,7 @@ write_srccorrs (dosizeonly)\n     totsize += write_srccorr (i, file_info_table[i], dosizeonly);\n \n   return totsize;\n-}     \n+}\n \f\n /* Output a marker (i.e. a label) for the beginning of a function, before\n    the prologue.  */\n@@ -1508,7 +1508,7 @@ lookup_filename (file_name)\n \t}\n     }\n \n-  /* Prepare to add a new table entry by making sure there is enough space in \n+  /* Prepare to add a new table entry by making sure there is enough space in\n      the table to do so.  If not, expand the current table.  */\n   if (file_info_table_in_use == file_info_table_allocated)\n     {\n@@ -1560,7 +1560,7 @@ vmsdbgout_source_line (line, filename)\n \t    = (dst_line_info_ref) xrealloc (line_info_table,\n \t\t\t\t\t    (line_info_table_allocated\n \t\t\t\t\t     * sizeof (dst_line_info_entry)));\n-\t  }\n+\t}\n \n       /* Add the new entry at the end of the line_info_table.  */\n       line_info = &line_info_table[line_info_table_in_use++];"}, {"sha": "74ddd98a5180494375eb0de84a7c47b3e833dc27", "filename": "gcc/xcoffout.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41077ce4b37a093155987bdf671bdf91510f9067/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=41077ce4b37a093155987bdf671bdf91510f9067", "patch": "@@ -1,5 +1,5 @@\n /* XCOFF definitions.  These are needed in dbxout.c, final.c,\n-   and xcoffout.h. \n+   and xcoffout.h.\n    Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -107,7 +107,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       if (*_p == '*')\t\t\t\t\t\t\\\n \tfprintf (asmfile, \"%s\", _p+1);\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-        for (; *_p != '[' && *_p; _p++)\t\t\t\t\\\n+\tfor (; *_p != '[' && *_p; _p++)\t\t\t\t\\\n \t  fprintf (asmfile, \"%c\", *_p);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else if (current_sym_addr)\t\t\t\t\t\\"}]}