{"sha": "4e6602a879928c2775e2a88204b5567ae3599380", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2NjAyYTg3OTkyOGMyNzc1ZTJhODgyMDRiNTU2N2FlMzU5OTM4MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-26T08:05:31Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-26T08:05:31Z"}, "message": "decl.c (gnat_to_gnu_entity): Pass correct arguments to create_field_decl.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Pass\n\tcorrect arguments to create_field_decl.  Remove redundant iteration.\n\tRewrite computation of the maximum size.\n\t<E_Array_Subtype>: Reorder and simplify handling of special cases.\n\tRewrite computation of the maximum size.  Use consistent naming.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Length>: Swap\n\tcomparison order for consistency.  Use generic integer node to\n\tbuild the operator and fold the result.\n\nFrom-SVN: r148962", "tree": {"sha": "65651737ef319521e89df0373ead4be544dfe775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65651737ef319521e89df0373ead4be544dfe775"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e6602a879928c2775e2a88204b5567ae3599380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6602a879928c2775e2a88204b5567ae3599380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e6602a879928c2775e2a88204b5567ae3599380", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6602a879928c2775e2a88204b5567ae3599380/comments", "author": null, "committer": null, "parents": [{"sha": "b3c54c8f55b487e77f1e2c881f30781cc784b1d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c54c8f55b487e77f1e2c881f30781cc784b1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c54c8f55b487e77f1e2c881f30781cc784b1d8"}], "stats": {"total": 557, "additions": 286, "deletions": 271}, "files": [{"sha": "33de5516cec7efa589ce499c27e800b57d62a7e7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6602a879928c2775e2a88204b5567ae3599380/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6602a879928c2775e2a88204b5567ae3599380/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4e6602a879928c2775e2a88204b5567ae3599380", "patch": "@@ -1,3 +1,14 @@\n+2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Pass\n+\tcorrect arguments to create_field_decl.  Remove redundant iteration.\n+\tRewrite computation of the maximum size.\n+\t<E_Array_Subtype>: Reorder and simplify handling of special cases.\n+\tRewrite computation of the maximum size.  Use consistent naming.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Length>: Swap\n+\tcomparison order for consistency.  Use generic integer node to\n+\tbuild the operator and fold the result.\n+\n 2009-06-25  Vincent Celier  <celier@adacore.com>\n \n \t* vms_data.ads: Minor comment change"}, {"sha": "5f15cd61618d81ce9424808cdb6282e41719d26f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 253, "deletions": 244, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6602a879928c2775e2a88204b5567ae3599380/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6602a879928c2775e2a88204b5567ae3599380/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=4e6602a879928c2775e2a88204b5567ae3599380", "patch": "@@ -1795,14 +1795,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_String_Type:\n     case E_Array_Type:\n       {\n-\tEntity_Id gnat_ind_subtype;\n-\tEntity_Id gnat_ind_base_subtype;\n-\tint ndim = Number_Dimensions (gnat_entity);\n-\tint first_dim\n-\t  = (Convention (gnat_entity) == Convention_Fortran) ? ndim - 1 : 0;\n-\tint next_dim\n-\t  = (Convention (gnat_entity) == Convention_Fortran) ? - 1 : 1;\n-\tint index;\n+\tEntity_Id gnat_index;\n+\tconst bool convention_fortran_p\n+\t  = (Convention (gnat_entity) == Convention_Fortran);\n+\tconst int ndim = Number_Dimensions (gnat_entity);\n \ttree gnu_template_fields = NULL_TREE;\n \ttree gnu_template_type = make_node (RECORD_TYPE);\n \ttree gnu_template_reference;\n@@ -1812,6 +1808,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree *gnu_temp_fields = (tree *) alloca (ndim * sizeof (tree));\n \ttree gnu_max_size = size_one_node, gnu_max_size_unit;\n \ttree gnu_comp_size, tem;\n+\tint index;\n \n \tTYPE_NAME (gnu_template_type)\n \t  = create_concat_name (gnat_entity, \"XUB\");\n@@ -1832,10 +1829,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttem = chainon (chainon (NULL_TREE,\n \t\t\t\tcreate_field_decl (get_identifier (\"P_ARRAY\"),\n \t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t   gnu_fat_type, 0, 0, 0, 0)),\n+\t\t\t\t\t\t   gnu_fat_type, 0,\n+\t\t\t\t\t\t   NULL_TREE, NULL_TREE, 0)),\n \t\t       create_field_decl (get_identifier (\"P_BOUNDS\"),\n \t\t\t\t\t  gnu_ptr_template,\n-\t\t\t\t\t  gnu_fat_type, 0, 0, 0, 0));\n+\t\t\t\t\t  gnu_fat_type, 0,\n+\t\t\t\t\t  NULL_TREE, NULL_TREE, 0));\n \n \t/* Make sure we can put this into a register.  */\n \tTYPE_ALIGN (gnu_fat_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n@@ -1855,69 +1854,81 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = build_unary_op (INDIRECT_REF, gnu_template_type, tem);\n \tTREE_READONLY (gnu_template_reference) = 1;\n \n-\t/* Now create the GCC type for each index and add the fields for\n-\t   that index to the template.  */\n-\tfor (index = first_dim, gnat_ind_subtype = First_Index (gnat_entity),\n-\t     gnat_ind_base_subtype\n-\t       = First_Index (Implementation_Base_Type (gnat_entity));\n-\t     index < ndim && index >= 0;\n-\t     index += next_dim,\n-\t     gnat_ind_subtype = Next_Index (gnat_ind_subtype),\n-\t     gnat_ind_base_subtype = Next_Index (gnat_ind_base_subtype))\n+\t/* Now create the GCC type for each index and add the fields for that\n+\t   index to the template.  */\n+\tfor (index = (convention_fortran_p ? ndim - 1 : 0),\n+\t     gnat_index = First_Index (gnat_entity);\n+\t     0 <= index && index < ndim;\n+\t     index += (convention_fortran_p ? - 1 : 1),\n+\t     gnat_index = Next_Index (gnat_index))\n \t  {\n-\t    char field_name[10];\n-\t    tree gnu_ind_subtype\n-\t      = get_unpadded_type (Base_Type (Etype (gnat_ind_subtype)));\n-\t    tree gnu_base_subtype\n-\t      = get_unpadded_type (Etype (gnat_ind_base_subtype));\n-\t    tree gnu_base_min\n-\t      = convert (sizetype, TYPE_MIN_VALUE (gnu_base_subtype));\n-\t    tree gnu_base_max\n-\t      = convert (sizetype, TYPE_MAX_VALUE (gnu_base_subtype));\n-\t    tree gnu_min_field, gnu_max_field, gnu_min, gnu_max;\n-\n-\t    /* Make the FIELD_DECLs for the minimum and maximum of this\n-\t       type and then make extractions of that field from the\n+\t    char field_name[16];\n+\t    tree gnu_index_base_type\n+\t      = get_unpadded_type (Base_Type (Etype (gnat_index)));\n+\t    tree gnu_low_field, gnu_high_field, gnu_low, gnu_high;\n+\n+\t    /* Make the FIELD_DECLs for the low and high bounds of this\n+\t       type and then make extractions of these fields from the\n \t       template.  */\n \t    sprintf (field_name, \"LB%d\", index);\n-\t    gnu_min_field = create_field_decl (get_identifier (field_name),\n-\t\t\t\t\t       gnu_ind_subtype,\n-\t\t\t\t\t       gnu_template_type, 0, 0, 0, 0);\n-\t    field_name[0] = 'U';\n-\t    gnu_max_field = create_field_decl (get_identifier (field_name),\n-\t\t\t\t\t       gnu_ind_subtype,\n-\t\t\t\t\t       gnu_template_type, 0, 0, 0, 0);\n-\n+\t    gnu_low_field = create_field_decl (get_identifier (field_name),\n+\t\t\t\t\t       gnu_index_base_type,\n+\t\t\t\t\t       gnu_template_type, 0,\n+\t\t\t\t\t       NULL_TREE, NULL_TREE, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n-\t\t\t   &DECL_SOURCE_LOCATION (gnu_min_field));\n+\t\t\t   &DECL_SOURCE_LOCATION (gnu_low_field));\n+\n+\t    field_name[0] = 'U';\n+\t    gnu_high_field = create_field_decl (get_identifier (field_name),\n+\t\t\t\t\t        gnu_index_base_type,\n+\t\t\t\t\t        gnu_template_type, 0,\n+\t\t\t\t\t        NULL_TREE, NULL_TREE, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n-\t\t\t   &DECL_SOURCE_LOCATION (gnu_max_field));\n-\t    gnu_temp_fields[index] = chainon (gnu_min_field, gnu_max_field);\n+\t\t\t   &DECL_SOURCE_LOCATION (gnu_high_field));\n \n-\t    /* We can't use build_component_ref here since the template\n-\t       type isn't complete yet.  */\n-\t    gnu_min = build3 (COMPONENT_REF, gnu_ind_subtype,\n-\t\t\t      gnu_template_reference, gnu_min_field,\n-\t\t\t      NULL_TREE);\n-\t    gnu_max = build3 (COMPONENT_REF, gnu_ind_subtype,\n-\t\t\t      gnu_template_reference, gnu_max_field,\n+\t    gnu_temp_fields[index] = chainon (gnu_low_field, gnu_high_field);\n+\n+\t    /* We can't use build_component_ref here since the template type\n+\t       isn't complete yet.  */\n+\t    gnu_low = build3 (COMPONENT_REF, gnu_index_base_type,\n+\t\t\t      gnu_template_reference, gnu_low_field,\n \t\t\t      NULL_TREE);\n-\t    TREE_READONLY (gnu_min) = TREE_READONLY (gnu_max) = 1;\n+\t    gnu_high = build3 (COMPONENT_REF, gnu_index_base_type,\n+\t\t\t       gnu_template_reference, gnu_high_field,\n+\t\t\t       NULL_TREE);\n+\t    TREE_READONLY (gnu_low) = TREE_READONLY (gnu_high) = 1;\n \n-\t    /* Make a range type with the new ranges, but using\n-\t       the Ada subtype.  Then we convert to sizetype.  */\n+\t    /* Make a range type with the new range in the Ada base type.\n+\t       Then make an index type with the new range in sizetype.  */\n \t    gnu_index_types[index]\n-\t      = create_index_type (convert (sizetype, gnu_min),\n-\t\t\t\t   convert (sizetype, gnu_max),\n-\t\t\t\t   create_range_type (gnu_ind_subtype,\n-\t\t\t\t\t\t      gnu_min, gnu_max),\n+\t      = create_index_type (convert (sizetype, gnu_low),\n+\t\t\t\t   convert (sizetype, gnu_high),\n+\t\t\t\t   create_range_type (gnu_index_base_type,\n+\t\t\t\t\t\t      gnu_low, gnu_high),\n \t\t\t\t   gnat_entity);\n-\t    /* Update the maximum size of the array, in elements.  */\n-\t    gnu_max_size\n-\t      = size_binop (MULT_EXPR, gnu_max_size,\n-\t\t\t    size_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\t\tsize_binop (MINUS_EXPR, gnu_base_max,\n-\t\t\t\t\t\t    gnu_base_min)));\n+\n+\t    /* Update the maximum size of the array in elements.  */\n+\t    if (gnu_max_size)\n+\t      {\n+\t\ttree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n+\t\ttree gnu_min\n+\t\t  = convert (sizetype, TYPE_MIN_VALUE (gnu_index_type));\n+\t\ttree gnu_max\n+\t\t  = convert (sizetype, TYPE_MAX_VALUE (gnu_index_type));\n+\t\ttree gnu_this_max\n+\t\t  = size_binop (MAX_EXPR,\n+\t\t\t\tsize_binop (PLUS_EXPR, size_one_node,\n+\t\t\t\t\t    size_binop (MINUS_EXPR,\n+\t\t\t\t\t\t\tgnu_max, gnu_min)),\n+\t\t\t\tsize_zero_node);\n+\n+\t\tif (TREE_CODE (gnu_this_max) == INTEGER_CST\n+\t\t    && TREE_OVERFLOW (gnu_this_max))\n+\t\t  gnu_max_size = NULL_TREE;\n+\t\telse\n+\t\t  gnu_max_size\n+\t\t    = size_binop (MULT_EXPR, gnu_max_size, gnu_this_max);\n+\t      }\n \n \t    TYPE_NAME (gnu_index_types[index])\n \t      = create_concat_name (gnat_entity, field_name);\n@@ -2006,15 +2017,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Unknown_Component_Size (gnat_entity))\n \t  Set_Component_Size (gnat_entity, annotate_value (TYPE_SIZE (tem)));\n \n-\tgnu_max_size_unit = size_binop (MAX_EXPR, size_zero_node,\n-\t\t\t\t\tsize_binop (MULT_EXPR, gnu_max_size,\n-\t\t\t\t\t\t    TYPE_SIZE_UNIT (tem)));\n-\tgnu_max_size = size_binop (MAX_EXPR, bitsize_zero_node,\n-\t\t\t\t   size_binop (MULT_EXPR,\n-\t\t\t\t\t       convert (bitsizetype,\n-\t\t\t\t\t\t\tgnu_max_size),\n-\t\t\t\t\t       TYPE_SIZE (tem)));\n+\t/* Compute the maximum size of the array in units and bits.  */\n+\tif (gnu_max_size)\n+\t  {\n+\t    gnu_max_size_unit = size_binop (MULT_EXPR, gnu_max_size,\n+\t\t\t\t\t    TYPE_SIZE_UNIT (tem));\n+\t    gnu_max_size = size_binop (MULT_EXPR,\n+\t\t\t\t       convert (bitsizetype, gnu_max_size),\n+\t\t\t\t       TYPE_SIZE (tem));\n+\t  }\n+\telse\n+\t  gnu_max_size_unit = NULL_TREE;\n \n+\t/* Now build the array type.  */\n \tfor (index = ndim - 1; index >= 0; index--)\n \t  {\n \t    tem = build_array_type (tem, gnu_index_types[index]);\n@@ -2036,8 +2051,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_USER_ALIGN (tem) = 1;\n \t  }\n \n-\tTYPE_CONVENTION_FORTRAN_P (tem)\n-\t  = (Convention (gnat_entity) == Convention_Fortran);\n+\tTYPE_CONVENTION_FORTRAN_P (tem) = convention_fortran_p;\n \tTREE_TYPE (TYPE_FIELDS (gnu_fat_type)) = build_pointer_type (tem);\n \n \t/* The result type is an UNCONSTRAINED_ARRAY_TYPE that indicates the\n@@ -2049,15 +2063,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n \n \t/* If the maximum size doesn't overflow, use it.  */\n-\tif (TREE_CODE (gnu_max_size) == INTEGER_CST\n-\t    && !TREE_OVERFLOW (gnu_max_size))\n-\t  TYPE_SIZE (tem)\n-\t    = size_binop (MIN_EXPR, gnu_max_size, TYPE_SIZE (tem));\n-\tif (TREE_CODE (gnu_max_size_unit) == INTEGER_CST\n+        if (gnu_max_size\n+\t    && TREE_CODE (gnu_max_size) == INTEGER_CST\n+\t    && !TREE_OVERFLOW (gnu_max_size)\n+\t    && TREE_CODE (gnu_max_size_unit) == INTEGER_CST\n \t    && !TREE_OVERFLOW (gnu_max_size_unit))\n-\t  TYPE_SIZE_UNIT (tem)\n-\t    = size_binop (MIN_EXPR, gnu_max_size_unit,\n-\t\t\t  TYPE_SIZE_UNIT (tem));\n+\t  {\n+\t    TYPE_SIZE (tem) = size_binop (MIN_EXPR, gnu_max_size,\n+\t\t\t\t\t  TYPE_SIZE (tem));\n+\t    TYPE_SIZE_UNIT (tem) = size_binop (MIN_EXPR, gnu_max_size_unit,\n+\t\t\t\t\t       TYPE_SIZE_UNIT (tem));\n+\t  }\n \n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"),\n \t\t\t  tem, NULL, !Comes_From_Source (gnat_entity),\n@@ -2089,123 +2105,100 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Array_Subtype:\n \n       /* This is the actual data type for array variables.  Multidimensional\n-\t arrays are implemented in the gnu tree as arrays of arrays.  Note\n-\t that for the moment arrays which have sparse enumeration subtypes as\n-\t index components create sparse arrays, which is obviously space\n-\t inefficient but so much easier to code for now.\n+\t arrays are implemented as arrays of arrays.  Note that arrays which\n+ \t have sparse enumeration subtypes as index components create sparse\n+\t arrays, which is obviously space inefficient but so much easier to\n+\t code for now.\n \n-\t Also note that the subtype never refers to the unconstrained\n-\t array type, which is somewhat at variance with Ada semantics.\n+\t Also note that the subtype never refers to the unconstrained array\n+\t type, which is somewhat at variance with Ada semantics.\n \n-\t First check to see if this is simply a renaming of the array\n-\t type.  If so, the result is the array type.  */\n+\t First check to see if this is simply a renaming of the array type.\n+\t If so, the result is the array type.  */\n \n       gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n       if (!Is_Constrained (gnat_entity))\n \tbreak;\n       else\n \t{\n-\t  Entity_Id gnat_ind_subtype;\n-\t  Entity_Id gnat_ind_base_subtype;\n-\t  int dim = Number_Dimensions (gnat_entity);\n-\t  int first_dim\n-\t    = (Convention (gnat_entity) == Convention_Fortran) ? dim - 1 : 0;\n-\t  int next_dim\n-\t    = (Convention (gnat_entity) == Convention_Fortran) ? -1 : 1;\n-\t  int index;\n+\t  Entity_Id gnat_index, gnat_base_index;\n+\t  const bool convention_fortran_p\n+\t    = (Convention (gnat_entity) == Convention_Fortran);\n+\t  const int ndim = Number_Dimensions (gnat_entity);\n \t  tree gnu_base_type = gnu_type;\n-\t  tree *gnu_index_type = (tree *) alloca (dim * sizeof (tree));\n+\t  tree *gnu_index_types = (tree *) alloca (ndim * sizeof (tree));\n \t  tree gnu_max_size = size_one_node, gnu_max_size_unit;\n \t  bool need_index_type_struct = false;\n-\t  bool max_overflow = false;\n-\n-\t  /* First create the gnu types for each index.  Create types for\n-\t     debugging information to point to the index types if the\n-\t     are not integer types, have variable bounds, or are\n-\t     wider than sizetype.  */\n+\t  int index;\n \n-\t  for (index = first_dim, gnat_ind_subtype = First_Index (gnat_entity),\n-\t       gnat_ind_base_subtype\n+\t  /* First create the GCC type for each index and find out whether\n+\t     special types are needed for debugging information.  */\n+\t  for (index = (convention_fortran_p ? ndim - 1 : 0),\n+\t       gnat_index = First_Index (gnat_entity),\n+\t       gnat_base_index\n \t\t = First_Index (Implementation_Base_Type (gnat_entity));\n-\t       index < dim && index >= 0;\n-\t       index += next_dim,\n-\t       gnat_ind_subtype = Next_Index (gnat_ind_subtype),\n-\t       gnat_ind_base_subtype = Next_Index (gnat_ind_base_subtype))\n+\t       0 <= index && index < ndim;\n+\t       index += (convention_fortran_p ? - 1 : 1),\n+\t       gnat_index = Next_Index (gnat_index),\n+\t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n-\t      tree gnu_index_subtype\n-\t\t= get_unpadded_type (Etype (gnat_ind_subtype));\n-\t      tree gnu_min\n-\t\t= convert (sizetype, TYPE_MIN_VALUE (gnu_index_subtype));\n-\t      tree gnu_max\n-\t\t= convert (sizetype, TYPE_MAX_VALUE (gnu_index_subtype));\n-\t      tree gnu_base_subtype\n-\t\t= get_unpadded_type (Etype (gnat_ind_base_subtype));\n-\t      tree gnu_base_min\n-\t\t= convert (sizetype, TYPE_MIN_VALUE (gnu_base_subtype));\n-\t      tree gnu_base_max\n-\t\t= convert (sizetype, TYPE_MAX_VALUE (gnu_base_subtype));\n-\t      tree gnu_base_type = get_base_type (gnu_base_subtype);\n-\t      tree gnu_base_base_min\n-\t\t= convert (sizetype, TYPE_MIN_VALUE (gnu_base_type));\n-\t      tree gnu_base_base_max\n-\t\t= convert (sizetype, TYPE_MAX_VALUE (gnu_base_type));\n+\t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n+\t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n+\t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n+\t      tree gnu_min = convert (sizetype, gnu_orig_min);\n+\t      tree gnu_max = convert (sizetype, gnu_orig_max);\n+\t      tree gnu_base_index_type\n+\t\t= get_unpadded_type (Etype (gnat_base_index));\n+\t      tree gnu_base_orig_min = TYPE_MIN_VALUE (gnu_base_index_type);\n+\t      tree gnu_base_orig_max = TYPE_MAX_VALUE (gnu_base_index_type);\n \t      tree gnu_high;\n-\t      tree gnu_this_max;\n-\n-\t      /* If the minimum and maximum values both overflow in\n-\t\t SIZETYPE, but the difference in the original type\n-\t\t does not overflow in SIZETYPE, ignore the overflow\n-\t\t indications.  */\n-\t      if ((TYPE_PRECISION (gnu_index_subtype)\n-\t\t   > TYPE_PRECISION (sizetype)\n-\t\t   || TYPE_UNSIGNED (gnu_index_subtype)\n-\t\t      != TYPE_UNSIGNED (sizetype))\n-\t\t  && TREE_CODE (gnu_min) == INTEGER_CST\n-\t\t  && TREE_CODE (gnu_max) == INTEGER_CST\n-\t\t  && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n-\t\t  && !TREE_OVERFLOW\n-\t\t      (fold_build2 (MINUS_EXPR, gnu_index_subtype,\n-\t\t\t\t    TYPE_MAX_VALUE (gnu_index_subtype),\n-\t\t\t\t    TYPE_MIN_VALUE (gnu_index_subtype))))\n+\n+\t      /* See if the base array type is already flat.  If it is, we\n+\t\t are probably compiling an ACATS test but it will cause the\n+\t\t code below to malfunction if we don't handle it specially.  */\n+\t      if (TREE_CODE (gnu_base_orig_min) == INTEGER_CST\n+\t\t  && TREE_CODE (gnu_base_orig_max) == INTEGER_CST\n+\t\t  && tree_int_cst_lt (gnu_base_orig_max, gnu_base_orig_min))\n \t\t{\n-\t\t  TREE_OVERFLOW (gnu_min) = 0;\n-\t\t  TREE_OVERFLOW (gnu_max) = 0;\n-\t\t  if (tree_int_cst_lt (gnu_max, gnu_min))\n-\t\t    {\n-\t\t      gnu_min = size_one_node;\n-\t\t      gnu_max = size_zero_node;\n-\t\t    }\n+\t\t  gnu_min = size_one_node;\n+\t\t  gnu_max = size_zero_node;\n \t\t  gnu_high = gnu_max;\n \t\t}\n \n-\t      /* Similarly, if the range is null, use bounds of 1..0 for\n-\t\t the sizetype bounds.  */\n-\t      else if ((TYPE_PRECISION (gnu_index_subtype)\n+\t      /* Similarly, if one of the values overflows in sizetype and the\n+\t\t range is null, use 1..0 for the sizetype bounds.  */\n+\t      else if ((TYPE_PRECISION (gnu_index_type)\n \t\t\t> TYPE_PRECISION (sizetype)\n-\t\t        || TYPE_UNSIGNED (gnu_index_subtype)\n+\t\t        || TYPE_UNSIGNED (gnu_index_type)\n \t\t\t   != TYPE_UNSIGNED (sizetype))\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && (TREE_OVERFLOW (gnu_min) || TREE_OVERFLOW (gnu_max))\n-\t\t       && tree_int_cst_lt (TYPE_MAX_VALUE (gnu_index_subtype),\n-\t\t\t\t\t   TYPE_MIN_VALUE (gnu_index_subtype)))\n+\t\t       && tree_int_cst_lt (gnu_orig_max, gnu_orig_min))\n \t\t{\n \t\t  gnu_min = size_one_node;\n \t\t  gnu_max = size_zero_node;\n \t\t  gnu_high = gnu_max;\n \t\t}\n \n-\t      /* See if the base array type is already flat.  If it is, we\n-\t\t are probably compiling an ACATS test, but it will cause the\n-\t\t code below to malfunction if we don't handle it specially.  */\n-\t      else if (TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t       && TREE_CODE (gnu_base_max) == INTEGER_CST\n-\t\t       && !TREE_OVERFLOW (gnu_base_min)\n-\t\t       && !TREE_OVERFLOW (gnu_base_max)\n-\t\t       && tree_int_cst_lt (gnu_base_max, gnu_base_min))\n+\t      /* If the minimum and maximum values both overflow in sizetype,\n+\t\t but the difference in the original type does not overflow in\n+\t\t sizetype, ignore the overflow indication.  */\n+\t      else if ((TYPE_PRECISION (gnu_index_type)\n+\t\t\t> TYPE_PRECISION (sizetype)\n+\t\t\t|| TYPE_UNSIGNED (gnu_index_type)\n+\t\t\t   != TYPE_UNSIGNED (sizetype))\n+\t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n+\t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n+\t\t       && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n+\t\t       && !TREE_OVERFLOW\n+\t\t\t   (convert (sizetype,\n+\t\t\t\t     fold_build2 (MINUS_EXPR, gnu_index_type,\n+\t\t\t\t\t\t  gnu_orig_max,\n+\t\t\t\t\t\t  gnu_orig_min))))\n \t\t{\n-\t\t  gnu_min = size_one_node;\n-\t\t  gnu_max = size_zero_node;\n+\t\t  TREE_OVERFLOW (gnu_min) = 0;\n+\t\t  TREE_OVERFLOW (gnu_max) = 0;\n \t\t  gnu_high = gnu_max;\n \t\t}\n \n@@ -2221,16 +2214,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     to use the expression hb >= lb ? hb : lb - 1.  */\n \t\t  gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n \n-\t\t  /* If gnu_high is now an integer which overflowed, the array\n+\t\t  /* If gnu_high is a constant that has overflowed, the array\n \t\t     cannot be superflat.  */\n \t\t  if (TREE_CODE (gnu_high) == INTEGER_CST\n \t\t      && TREE_OVERFLOW (gnu_high))\n \t\t    gnu_high = gnu_max;\n \n-\t\t  /* gnu_high cannot overflow if the subtype is unsigned since\n-\t\t     sizetype is signed, or if it is now a constant that hasn't\n+\t\t  /* gnu_high cannot overflow if the subtype is unsigned and\n+\t\t     sizetype is signed, or if it is a constant that hasn't\n \t\t     overflowed.  */\n-\t\t  else if (TYPE_UNSIGNED (gnu_base_subtype)\n+\t\t  else if ((TYPE_UNSIGNED (gnu_index_type)\n+\t\t\t    && !TYPE_UNSIGNED (sizetype))\n \t\t\t   || TREE_CODE (gnu_high) == INTEGER_CST)\n \t\t    gnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n \n@@ -2243,67 +2237,76 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t gnu_max, gnu_high);\n \t\t}\n \n-\t      gnu_index_type[index]\n-\t\t= create_index_type (gnu_min, gnu_high, gnu_index_subtype,\n+\t      gnu_index_types[index]\n+\t\t= create_index_type (gnu_min, gnu_high, gnu_index_type,\n \t\t\t\t     gnat_entity);\n \n-\t      /* Also compute the maximum size of the array.  Here we\n+\t      /* Update the maximum size of the array in elements.  Here we\n \t\t see if any constraint on the index type of the base type\n-\t\t can be used in the case of self-referential bound on\n-\t\t the index type of the subtype.  We look for a non-\"infinite\"\n+\t\t can be used in the case of self-referential bound on the\n+\t\t index type of the subtype.  We look for a non-\"infinite\"\n \t\t and non-self-referential bound from any type involved and\n \t\t handle each bound separately.  */\n+\t      if (gnu_max_size)\n+\t\t{\n+\t\t  tree gnu_base_min = convert (sizetype, gnu_base_orig_min);\n+\t\t  tree gnu_base_max = convert (sizetype, gnu_base_orig_max);\n+\t\t  tree gnu_base_index_base_type\n+\t\t    = get_base_type (gnu_base_index_type);\n+\t\t  tree gnu_base_base_min\n+\t\t    = convert (sizetype,\n+\t\t\t       TYPE_MIN_VALUE (gnu_base_index_base_type));\n+\t\t  tree gnu_base_base_max\n+\t\t    = convert (sizetype,\n+\t\t\t       TYPE_MAX_VALUE (gnu_base_index_base_type));\n+\n+\t\t  if (!CONTAINS_PLACEHOLDER_P (gnu_min)\n+\t\t      || !(TREE_CODE (gnu_base_min) == INTEGER_CST\n+\t\t\t   && !TREE_OVERFLOW (gnu_base_min)))\n+\t\t    gnu_base_min = gnu_min;\n+\n+\t\t  if (!CONTAINS_PLACEHOLDER_P (gnu_max)\n+\t\t      || !(TREE_CODE (gnu_base_max) == INTEGER_CST\n+\t\t\t   && !TREE_OVERFLOW (gnu_base_max)))\n+\t\t    gnu_base_max = gnu_max;\n+\n+\t\t  if ((TREE_CODE (gnu_base_min) == INTEGER_CST\n+\t\t       && TREE_OVERFLOW (gnu_base_min))\n+\t\t      || operand_equal_p (gnu_base_min, gnu_base_base_min, 0)\n+\t\t      || (TREE_CODE (gnu_base_max) == INTEGER_CST\n+\t\t\t  && TREE_OVERFLOW (gnu_base_max))\n+\t\t      || operand_equal_p (gnu_base_max, gnu_base_base_max, 0))\n+\t\t    gnu_max_size = NULL_TREE;\n+\t\t  else\n+\t\t    {\n+\t\t      tree gnu_this_max\n+\t\t\t= size_binop (MAX_EXPR,\n+\t\t\t\t      size_binop (PLUS_EXPR, size_one_node,\n+\t\t\t\t\t\t  size_binop (MINUS_EXPR,\n+\t\t\t\t\t\t\t      gnu_base_max,\n+\t\t\t\t\t\t\t      gnu_base_min)),\n+\t\t\t\t      size_zero_node);\n+\n+\t\t      if (TREE_CODE (gnu_this_max) == INTEGER_CST\n+\t\t\t  && TREE_OVERFLOW (gnu_this_max))\n+\t\t\tgnu_max_size = NULL_TREE;\n+\t\t      else\n+\t\t\tgnu_max_size\n+\t\t\t  = size_binop (MULT_EXPR, gnu_max_size, gnu_this_max);\n+\t\t    }\n+\t\t}\n \n-\t      if ((TREE_CODE (gnu_min) == INTEGER_CST\n-\t\t   && !TREE_OVERFLOW (gnu_min)\n-\t\t   && !operand_equal_p (gnu_min, gnu_base_base_min, 0))\n-\t\t  || !CONTAINS_PLACEHOLDER_P (gnu_min)\n-\t\t  || !(TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t       && !TREE_OVERFLOW (gnu_base_min)))\n-\t\tgnu_base_min = gnu_min;\n-\n-\t      if ((TREE_CODE (gnu_max) == INTEGER_CST\n-\t\t   && !TREE_OVERFLOW (gnu_max)\n-\t\t   && !operand_equal_p (gnu_max, gnu_base_base_max, 0))\n-\t\t  || !CONTAINS_PLACEHOLDER_P (gnu_max)\n-\t\t  || !(TREE_CODE (gnu_base_max) == INTEGER_CST\n-\t\t       && !TREE_OVERFLOW (gnu_base_max)))\n-\t\tgnu_base_max = gnu_max;\n-\n-\t      if ((TREE_CODE (gnu_base_min) == INTEGER_CST\n-\t\t   && TREE_OVERFLOW (gnu_base_min))\n-\t\t  || operand_equal_p (gnu_base_min, gnu_base_base_min, 0)\n-\t\t  || (TREE_CODE (gnu_base_max) == INTEGER_CST\n-\t\t      && TREE_OVERFLOW (gnu_base_max))\n-\t\t  || operand_equal_p (gnu_base_max, gnu_base_base_max, 0))\n-\t\tmax_overflow = true;\n-\n-\t      gnu_base_min = size_binop (MAX_EXPR, gnu_base_min, gnu_min);\n-\t      gnu_base_max = size_binop (MIN_EXPR, gnu_base_max, gnu_max);\n-\n-\t      gnu_this_max\n-\t\t= size_binop (MAX_EXPR,\n-\t\t\t      size_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\t\t  size_binop (MINUS_EXPR, gnu_base_max,\n-\t\t\t\t\t\t      gnu_base_min)),\n-\t\t\t      size_zero_node);\n-\n-\t      if (TREE_CODE (gnu_this_max) == INTEGER_CST\n-\t\t  && TREE_OVERFLOW (gnu_this_max))\n-\t\tmax_overflow = true;\n-\n-\t      gnu_max_size\n-\t\t= size_binop (MULT_EXPR, gnu_max_size, gnu_this_max);\n-\n-\t      if (!integer_onep (TYPE_MIN_VALUE (gnu_index_subtype))\n-\t\t  || (TREE_CODE (TYPE_MAX_VALUE (gnu_index_subtype))\n-\t\t      != INTEGER_CST)\n-\t\t  || TREE_CODE (gnu_index_subtype) != INTEGER_TYPE\n-\t\t  || (TREE_TYPE (gnu_index_subtype)\n-\t\t      && (TREE_CODE (TREE_TYPE (gnu_index_subtype))\n-\t\t\t  != INTEGER_TYPE))\n-\t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_subtype)\n-\t\t  || (TYPE_PRECISION (gnu_index_subtype)\n+\t      /* We need special types for debugging information to point to\n+\t\t the index types if they have variable bounds, are not integer\n+\t\t types, are biased or are wider than sizetype.  */\n+\t      if (!integer_onep (gnu_orig_min)\n+\t\t  || TREE_CODE (gnu_orig_max) != INTEGER_CST\n+\t\t  || TREE_CODE (gnu_index_type) != INTEGER_TYPE\n+\t\t  || (TREE_TYPE (gnu_index_type)\n+\t\t      && TREE_CODE (TREE_TYPE (gnu_index_type))\n+\t\t\t != INTEGER_TYPE)\n+\t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)\n+\t\t  || (TYPE_PRECISION (gnu_index_type)\n \t\t      > TYPE_PRECISION (sizetype)))\n \t\tneed_index_type_struct = true;\n \t    }\n@@ -2316,7 +2319,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      && !Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \t    {\n \t      gnu_type = gnat_to_gnu_type (Original_Array_Type (gnat_entity));\n-\t      for (index = dim - 1; index >= 0; index--)\n+\t      for (index = ndim - 1; index >= 0; index--)\n \t\tgnu_type = TREE_TYPE (gnu_type);\n \n \t      /* One of the above calls might have caused us to be elaborated,\n@@ -2409,15 +2412,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t  | TYPE_QUAL_VOLATILE));\n \t    }\n \n-\t  gnu_max_size_unit = size_binop (MULT_EXPR, gnu_max_size,\n-\t\t\t\t\t  TYPE_SIZE_UNIT (gnu_type));\n-\t  gnu_max_size = size_binop (MULT_EXPR,\n-\t\t\t\t     convert (bitsizetype, gnu_max_size),\n-\t\t\t\t     TYPE_SIZE (gnu_type));\n+\t  /* Compute the maximum size of the array in units and bits.  */\n+\t  if (gnu_max_size)\n+\t    {\n+\t      gnu_max_size_unit = size_binop (MULT_EXPR, gnu_max_size,\n+\t\t\t\t\t      TYPE_SIZE_UNIT (gnu_type));\n+\t      gnu_max_size = size_binop (MULT_EXPR,\n+\t\t\t\t\t convert (bitsizetype, gnu_max_size),\n+\t\t\t\t\t TYPE_SIZE (gnu_type));\n+\t    }\n+\t  else\n+\t    gnu_max_size_unit = NULL_TREE;\n \n-\t  for (index = dim - 1; index >= 0; index --)\n+\t  /* Now build the array type.  */\n+\t  for (index = ndim - 1; index >= 0; index --)\n \t    {\n-\t      gnu_type = build_array_type (gnu_type, gnu_index_type[index]);\n+\t      gnu_type = build_array_type (gnu_type, gnu_index_types[index]);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n \t      if (array_type_has_nonaliased_component (gnat_entity, gnu_type))\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n@@ -2427,10 +2437,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_STUB_DECL (gnu_type)\n \t    = create_type_stub_decl (gnu_entity_name, gnu_type);\n \n-\t  /* If we are at file level and this is a multi-dimensional array, we\n-\t     need to make a variable corresponding to the stride of the\n+\t  /* If we are at file level and this is a multi-dimensional array,\n+\t     we need to make a variable corresponding to the stride of the\n \t     inner dimensions.   */\n-\t  if (global_bindings_p () && dim > 1)\n+\t  if (global_bindings_p () && ndim > 1)\n \t    {\n \t      tree gnu_str_name = get_identifier (\"ST\");\n \t      tree gnu_arr_type;\n@@ -2483,9 +2493,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_NAME (gnu_bound_rec)\n \t\t= create_concat_name (gnat_entity, \"XA\");\n \n-\t      for (index = dim - 1; index >= 0; index--)\n+\t      for (index = ndim - 1; index >= 0; index--)\n \t\t{\n-\t\t  tree gnu_index = TYPE_INDEX_TYPE (gnu_index_type[index]);\n+\t\t  tree gnu_index = TYPE_INDEX_TYPE (gnu_index_types[index]);\n \t\t  tree gnu_index_name = TYPE_NAME (gnu_index);\n \n \t\t  if (TREE_CODE (gnu_index_name) == TYPE_DECL)\n@@ -2513,20 +2523,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       gnat_to_gnu_type\n \t\t\t       (Original_Array_Type (gnat_entity)));\n \n-\t  TYPE_CONVENTION_FORTRAN_P (gnu_type)\n-\t    = (Convention (gnat_entity) == Convention_Fortran);\n+\t  TYPE_CONVENTION_FORTRAN_P (gnu_type) = convention_fortran_p;\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type)\n \t    = (Is_Packed_Array_Type (gnat_entity)\n \t       && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n \n-\t  /* If our size depends on a placeholder and the maximum size doesn't\n+\t  /* If the size is self-referential and the maximum size doesn't\n \t     overflow, use it.  */\n \t  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n+\t      && gnu_max_size\n \t      && !(TREE_CODE (gnu_max_size) == INTEGER_CST\n \t\t   && TREE_OVERFLOW (gnu_max_size))\n \t      && !(TREE_CODE (gnu_max_size_unit) == INTEGER_CST\n-\t\t   && TREE_OVERFLOW (gnu_max_size_unit))\n-\t      && !max_overflow)\n+\t\t   && TREE_OVERFLOW (gnu_max_size_unit)))\n \t    {\n \t      TYPE_SIZE (gnu_type) = size_binop (MIN_EXPR, gnu_max_size,\n \t\t\t\t\t\t TYPE_SIZE (gnu_type));"}, {"sha": "c4b095bf8a6bb5174748d7a4c11e9dcda42d3f1f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6602a879928c2775e2a88204b5567ae3599380/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6602a879928c2775e2a88204b5567ae3599380/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=4e6602a879928c2775e2a88204b5567ae3599380", "patch": "@@ -1552,43 +1552,38 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t/* We used to compute the length as max (hb - lb + 1, 0),\n \t\t   which could overflow for some cases of empty arrays, e.g.\n \t\t   when lb == index_type'first.  We now compute the length as\n-\t\t   (hb < lb) ? 0 : hb - lb + 1, which would only overflow in\n+\t\t   (hb >= lb) ? hb - lb + 1 : 0, which would only overflow in\n \t\t   much rarer cases, for extremely large arrays we expect\n \t\t   never to encounter in practice.  In addition, the former\n \t\t   computation required the use of potentially constraining\n-\t\t   signed arithmetic while the latter doesn't.  Note that the\n-\t\t   comparison must be done in the original index base type,\n-\t\t   otherwise the conversion of either bound to gnu_compute_type\n-\t\t   may overflow.  */\n-\t\t\n-\t\ttree gnu_compute_type = get_base_type (gnu_result_type);\n-\n-\t\ttree index_type\n-\t\t  = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type));\n-\t\ttree lb\n-\t\t  = convert (gnu_compute_type, TYPE_MIN_VALUE (index_type));\n-\t\ttree hb\n-\t\t  = convert (gnu_compute_type, TYPE_MAX_VALUE (index_type));\n-\t\t\n+\t\t   signed arithmetic while the latter doesn't.  Note that\n+\t\t   the comparison must be done in the original index type,\n+\t\t   to avoid any overflow during the conversion.  */\n+\t\ttree comp_type = get_base_type (gnu_result_type);\n+\t\ttree index_type = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type));\n+\t\ttree lb = TYPE_MIN_VALUE (index_type);\n+\t\ttree hb = TYPE_MAX_VALUE (index_type);\n \t\tgnu_result\n-\t\t  = build3\n-\t\t    (COND_EXPR, gnu_compute_type,\n-\t\t     build_binary_op (LT_EXPR, get_base_type (index_type),\n-\t\t\t\t      TYPE_MAX_VALUE (index_type),\n-\t\t\t\t      TYPE_MIN_VALUE (index_type)),\n-\t\t     convert (gnu_compute_type, integer_zero_node),\n-\t\t     build_binary_op\n-\t\t     (PLUS_EXPR, gnu_compute_type,\n-\t\t      build_binary_op (MINUS_EXPR, gnu_compute_type, hb, lb),\n-\t\t      convert (gnu_compute_type, integer_one_node)));\n+\t\t  = build_binary_op (PLUS_EXPR, comp_type,\n+\t\t\t\t     build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t      comp_type,\n+\t\t\t\t\t\t      convert (comp_type, hb),\n+\t\t\t\t\t\t      convert (comp_type, lb)),\n+\t\t\t\t     convert (comp_type, integer_one_node));\n+\t\tgnu_result\n+\t\t  = build_cond_expr (comp_type,\n+\t\t\t\t     build_binary_op (GE_EXPR,\n+\t\t\t\t\t\t      integer_type_node,\n+\t\t\t\t\t\t      hb, lb),\n+\t\t\t\t     gnu_result,\n+\t\t\t\t     convert (comp_type, integer_zero_node));\n \t      }\n \t  }\n \n \t/* If this has a PLACEHOLDER_EXPR, qualify it by the object we are\n \t   handling.  Note that these attributes could not have been used on\n \t   an unconstrained array type.  */\n-\tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result,\n-\t\t\t\t\t\t     gnu_prefix);\n+\tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n \n \t/* Cache the expression we have just computed.  Since we want to do it\n \t   at runtime, we force the use of a SAVE_EXPR and let the gimplifier"}]}