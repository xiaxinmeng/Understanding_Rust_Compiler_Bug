{"sha": "30c3de1ffb2daa8b2b8281bcece806793c4d4803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjM2RlMWZmYjJkYWE4YjJiODI4MWJjZWNlODA2NzkzYzRkNDgwMw==", "commit": {"author": {"name": "Jeff Sturm", "email": "jsturm@one-point.com", "date": "2003-07-28T04:18:23Z"}, "committer": {"name": "Jeff Sturm", "email": "jsturm@gcc.gnu.org", "date": "2003-07-28T04:18:23Z"}, "message": "Import GC 6.3alpha1.\n\n\t* BCC_MAKEFILE: Merge with GC 6.3alpha1 release.\n\t* ChangeLog: Likewise.\n\t* Makefile.am: Likewise.\n\t* Makefile.direct: Likewise.\n\t* Makefile.dj: Likewise.\n\t* allchblk.c: Likewise.\n\t* alloc.c: Likewise.\n\t* backgraph.c: Likewise.\n\t* configure.host: Likewise.\n\t* configure.in: Likewise.\n\t* dbg_mlc.c: Likewise.\n\t* dyn_load.c: Likewise.\n\t* finalize.c: Likewise.\n\t* gc_cpp.cc: Likewise.\n\t* gc_dlopen.c: Likewise.\n\t* gcj_mlc.c: Likewise.\n\t* if_mach.c: Likewise.\n\t* mach_dep.c: Likewise.\n\t* malloc.c: Likewise.\n\t* mallocx.c: Likewise.\n\t* mark.c: Likewise.\n\t* mark_rts.c: Likewise.\n\t* misc.c: Likewise.\n\t* os_dep.c: Likewise.\n\t* ptr_chck.c: Likewise.\n\t* reclaim.c: Likewise.\n\t* solaris_pthreads.c: Likewise.\n\t* solaris_threads.c: Likewise.\n\t* sparc_mach_dep.S: Likewise.\n\t* threadlibs.c: Likewise.\n\t* typd_mlc.c: Likewise.\n\t* version.h: Likewise.\n\t* win32_threads.c: Likewise.\n\t* Mac_files/MacOS_Test_config.h: Likewise.\n\t* Mac_files/MacOS_config.h: Likewise.\n\t* cord/cordbscs.c: Likewise.\n\t* cord/cordprnt.c: Likewise.\n\t* cord/de_win.c: Likewise.\n\t* doc/README: Likewise.\n\t* doc/README.MacOSX: Likewise.\n\t* doc/README.changes: Likewise.\n\t* doc/README.environment: Likewise.\n\t* doc/README.ews4800: Likewise.\n\t* doc/README.linux: Likewise.\n\t* doc/README.macros: Likewise.\n\t* doc/README.win32: Likewise.\n\t* doc/debugging.html: Likewise.\n\t* doc/gcdescr.html: Likewise.\n\t* doc/tree.html: Likewise.\n\t* include/Makefile.in: Likewise.\n\t* include/gc.h: Likewise.\n\t* include/gc_cpp.h: Likewise.\n\t* include/gc_local_alloc.h: Likewise.\n\t* include/gc_mark.h: Likewise.\n\t* include/gc_pthread_redirects.h: Likewise.\n\t* include/gc_typed.h: Likewise.\n\t* include/new_gc_alloc.h: Likewise.\n\t* include/private/dbg_mlc.h: Likewise.\n\t* include/private/gc_hdrs.h: Likewise.\n\t* include/private/gc_locks.h: Likewise.\n\t* include/private/gc_pmark.h: Likewise.\n\t* include/private/gc_priv.h: Likewise.\n\t* include/private/gcconfig.h: Likewise.\n\t* include/private/solaris_threads.h: Likewise.\n\t* include/private/specific.h: Likewise.\n\t* tests/test.c: Likewise.\n\t* tests/test_cpp.cc: Likewise.\n\n\t* configure: Rebuild.\n\t* Makefile.in: Rebuild.\n\n\t* mips_sgi_mach_dep.s: Add.\n\n\t* alpha_mach_dep.s: Remove.\n\t* irix_threads.c: Remove.\n\t* linux_threads.c: Remove.\n\t* mips_sgi_mach_dep.S: Remove.\n\t* missing: Remove.\n\t* powerpc_macosx_mach_dep.s: Remove.\n\t* doc/Makefile.am: Remove.\n\t* doc/Makefile.in: Remove.\n\nFrom-SVN: r69880", "tree": {"sha": "827bf34dcb0c2786d314e5fa136528e5a4feb6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/827bf34dcb0c2786d314e5fa136528e5a4feb6f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c3de1ffb2daa8b2b8281bcece806793c4d4803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c3de1ffb2daa8b2b8281bcece806793c4d4803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c3de1ffb2daa8b2b8281bcece806793c4d4803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c3de1ffb2daa8b2b8281bcece806793c4d4803/comments", "author": null, "committer": null, "parents": [{"sha": "1cb1de7ead03894075ea7392879654d3d968f044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb1de7ead03894075ea7392879654d3d968f044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb1de7ead03894075ea7392879654d3d968f044"}], "stats": {"total": 10048, "additions": 5096, "deletions": 4952}, "files": [{"sha": "3f86ed56fc4fa2308d5c90a838f8533ae0af8ace", "filename": "boehm-gc/BCC_MAKEFILE", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FBCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FBCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FBCC_MAKEFILE?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,29 +1,31 @@\n-# Makefile for Borland C++ 4.5 on NT\r\n-# For Borland 5.0, replace bc45 by bc5.\r\n+# Makefile for Borland C++ 5.5 on NT\r\n # If you have the Borland assembler, remove \"-DUSE_GENERIC\"\r\n #\r\n-bc=        c:\\bc45\r\n-bcbin=     $(bc)\\bin\r\n-bclib=     $(bc)\\lib\r\n+bc=\t   c:\\Borland\\BCC55\r\n+bcbin=\t   $(bc)\\bin\r\n+bclib=\t   $(bc)\\lib\r\n bcinclude= $(bc)\\include\r\n \r\n-cc=      $(bcbin)\\bcc32\r\n-rc=      $(bcbin)\\brc32\r\n-lib=     $(bcbin)\\tlib\r\n-link=    $(bcbin)\\tlink32\r\n-cflags=  -R -v -vi -H -H=gc.csm -I$(bcinclude);cord -L$(bclib) \\\r\n-         -w-pro -w-aus -w-par -w-ccc -w-rch -a4 -D__STDC__=0\r\n+gcinclude1 = $(bc)\\gc6.2\\include\r\n+gcinclude2 = $(bc)\\gc6.2\\cord\r\n+\r\n+cc=\t $(bcbin)\\bcc32\r\n+rc=\t $(bcbin)\\brc32\r\n+lib=\t $(bcbin)\\tlib\r\n+link=\t $(bcbin)\\ilink32\r\n+cflags=  -O2 -R -v- -vi -H -H=gc.csm -I$(bcinclude);$(gcinclude1);$(gcinclude2) -L$(bclib) \\\r\n+\t -w-pro -w-aus -w-par -w-ccc -w-rch -a4 -D__STDC__=0\r\n #defines= -DSILENT\r\n-defines= -DSMALL_CONFIG -DSILENT -DALL_INTERIOR_POINTERS -DUSE_GENERIC\r\n+defines= -DSMALL_CONFIG -DSILENT -DALL_INTERIOR_POINTERS -DUSE_GENERIC -DNO_GETENV -DJAVA_FINALIZATION -DGC_OPERATOR_NEW_ARRAY\r\n \r\n .c.obj:\r\n \t$(cc) @&&|\r\n-        $(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.c\r\n+\t$(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.c\r\n |\r\n \r\n .cpp.obj:\r\n \t$(cc) @&&|\r\n-        $(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.cpp\r\n+\t$(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.cpp\r\n |\r\n \r\n .rc.res:\r\n@@ -39,44 +41,48 @@ OBJS= $(XXXOBJS:XXX=)\n \r\n all: gctest.exe cord\\de.exe test_cpp.exe\r\n \r\n-$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h gcconfig.h MAKEFILE\r\n+$(OBJS) test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h MAKEFILE\r\n \r\n gc.lib: $(OBJS)\r\n-    -del gc.lib\r\n-\ttlib $* @&&|\r\n-        $(XXXOBJS:XXX=+)\r\n+\tdel gc.lib\r\n+\t$(lib) $* @&&|\r\n+\t$(XXXOBJS:XXX=+)\r\n |\r\n \r\n gctest.exe: tests\\test.obj gc.lib\r\n     $(cc) @&&|\r\n-        $(cflags) -W -e$* tests\\test.obj gc.lib\r\n+\t$(cflags) -W -e$* tests\\test.obj gc.lib\r\n |\r\n \r\n-cord\\de.obj cord\\de_win.obj: cord\\cord.h cord\\private\\cord_pos.h cord\\de_win.h \\\r\n+cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h \\\r\n     cord\\de_cmds.h\r\n \r\n cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj \\\r\n-        cord\\de_win.res gc.lib\r\n+\tcord\\de_win.res gc.lib\r\n \t$(cc) @&&|\r\n-        $(cflags) -W -e$* cord\\cordbscs.obj cord\\cordxtra.obj \\\r\n-        cord\\de.obj cord\\de_win.obj gc.lib\r\n+\t$(cflags) -W -e$* cord\\cordbscs.obj cord\\cordxtra.obj \\\r\n+\tcord\\de.obj cord\\de_win.obj gc.lib\r\n |\r\n     $(rc) cord\\de_win.res cord\\de.exe\r\n \r\n-gc_cpp.obj: gc_cpp.h gc.h\r\n+gc_cpp.obj: include\\gc_cpp.h include\\gc.h\r\n \r\n gc_cpp.cpp: gc_cpp.cc\r\n \tcopy gc_cpp.cc gc_cpp.cpp\r\n \r\n test_cpp.cpp: tests\\test_cpp.cc\r\n \tcopy tests\\test_cpp.cc test_cpp.cpp\r\n \r\n-test_cpp.exe: test_cpp.obj gc_cpp.h gc.h gc.lib\r\n+test_cpp.exe: test_cpp.obj include\\gc_cpp.h include\\gc.h gc.lib\r\n     $(cc) @&&|\r\n-        $(cflags) -W -e$* test_cpp.obj gc.lib\r\n+\t$(cflags) -W -e$* test_cpp.obj gc.lib\r\n |\r\n \r\n scratch:\r\n     -del *.obj *.res *.exe *.csm cord\\*.obj cord\\*.res cord\\*.exe cord\\*.csm\r\n \r\n+clean:\r\n+      del gc.lib\r\n+      del *.obj\r\n+      del tests\\test.obj\r\n \r"}, {"sha": "afb1ce9fc0804b3441da4f1b2fab35097bb5c84f", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,3 +1,88 @@\n+2003-07-28  Jeff Sturm  <jsturm@one-point.com>\n+\n+\tImport GC 6.3alpha1.\n+\t* BCC_MAKEFILE: Merge with GC 6.3alpha1 release.\n+\t* ChangeLog: Likewise.\n+\t* Makefile.am: Likewise.\n+\t* Makefile.direct: Likewise.\n+\t* Makefile.dj: Likewise.\n+\t* allchblk.c: Likewise.\n+\t* alloc.c: Likewise.\n+\t* backgraph.c: Likewise.\n+\t* configure.host: Likewise.\n+\t* configure.in: Likewise.\n+\t* dbg_mlc.c: Likewise.\n+\t* dyn_load.c: Likewise.\n+\t* finalize.c: Likewise.\n+\t* gc_cpp.cc: Likewise.\n+\t* gc_dlopen.c: Likewise.\n+\t* gcj_mlc.c: Likewise.\n+\t* if_mach.c: Likewise.\n+\t* mach_dep.c: Likewise.\n+\t* malloc.c: Likewise.\n+\t* mallocx.c: Likewise.\n+\t* mark.c: Likewise.\n+\t* mark_rts.c: Likewise.\n+\t* misc.c: Likewise.\n+\t* os_dep.c: Likewise.\n+\t* ptr_chck.c: Likewise.\n+\t* reclaim.c: Likewise.\n+\t* solaris_pthreads.c: Likewise.\n+\t* solaris_threads.c: Likewise.\n+\t* sparc_mach_dep.S: Likewise.\n+\t* threadlibs.c: Likewise.\n+\t* typd_mlc.c: Likewise.\n+\t* version.h: Likewise.\n+\t* win32_threads.c: Likewise.\n+\t* Mac_files/MacOS_Test_config.h: Likewise.\n+\t* Mac_files/MacOS_config.h: Likewise.\n+\t* cord/cordbscs.c: Likewise.\n+\t* cord/cordprnt.c: Likewise.\n+\t* cord/de_win.c: Likewise.\n+\t* doc/README: Likewise.\n+\t* doc/README.MacOSX: Likewise.\n+\t* doc/README.changes: Likewise.\n+\t* doc/README.environment: Likewise.\n+\t* doc/README.ews4800: Likewise.\n+\t* doc/README.linux: Likewise.\n+\t* doc/README.macros: Likewise.\n+\t* doc/README.win32: Likewise.\n+\t* doc/debugging.html: Likewise.\n+\t* doc/gcdescr.html: Likewise.\n+\t* doc/tree.html: Likewise.\n+\t* include/Makefile.in: Likewise.\n+\t* include/gc.h: Likewise.\n+\t* include/gc_cpp.h: Likewise.\n+\t* include/gc_local_alloc.h: Likewise.\n+\t* include/gc_mark.h: Likewise.\n+\t* include/gc_pthread_redirects.h: Likewise.\n+\t* include/gc_typed.h: Likewise.\n+\t* include/new_gc_alloc.h: Likewise.\n+\t* include/private/dbg_mlc.h: Likewise.\n+\t* include/private/gc_hdrs.h: Likewise.\n+\t* include/private/gc_locks.h: Likewise.\n+\t* include/private/gc_pmark.h: Likewise.\n+\t* include/private/gc_priv.h: Likewise.\n+\t* include/private/gcconfig.h: Likewise.\n+\t* include/private/solaris_threads.h: Likewise.\n+\t* include/private/specific.h: Likewise.\n+\t* tests/test.c: Likewise.\n+\t* tests/test_cpp.cc: Likewise.\n+\t\n+\t* configure: Rebuild.\n+\t* Makefile.in: Rebuild.\n+\t\n+\t* mips_sgi_mach_dep.s: Add.\n+\t\n+\t* alpha_mach_dep.s: Remove.\n+\t* irix_threads.c: Remove.\n+\t* linux_threads.c: Remove.\n+\t* mips_sgi_mach_dep.S: Remove.\n+\t* missing: Remove.\n+\t* powerpc_macosx_mach_dep.s: Remove.\n+\t* doc/Makefile.am: Remove.\n+\t* doc/Makefile.in: Remove.\n+\n 2003-07-25  Roger Sayle  <roger@eyesopen.com>\n \n \t* configure.host: Only use +ESdbgasm when using the HPUX native"}, {"sha": "4e5d25277887c68405027cb48657b7c88ca6d366", "filename": "boehm-gc/Mac_files/MacOS_Test_config.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMac_files%2FMacOS_Test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMac_files%2FMacOS_Test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2FMacOS_Test_config.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -74,7 +74,7 @@\n //   implementations, and it sometimes has a significant performance\n //   impact.  However, it is dangerous for many not-quite-ANSI C\n //   programs that call things like printf in asynchronous signal handlers.\n-// -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n+// -DGC_OPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n //   new syntax \"operator new[]\" for allocating and deleting arrays.\n //   See gc_cpp.h for details.  No effect on the C part of the collector.\n //   This is defined implicitly in a few environments."}, {"sha": "407bdf154a272aa034ad8455f60358ad5bbeacfe", "filename": "boehm-gc/Mac_files/MacOS_config.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMac_files%2FMacOS_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMac_files%2FMacOS_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2FMacOS_config.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -72,7 +72,7 @@\n //   implementations, and it sometimes has a significant performance\n //   impact.  However, it is dangerous for many not-quite-ANSI C\n //   programs that call things like printf in asynchronous signal handlers.\n-// -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n+// -DGC_OPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n //   new syntax \"operator new[]\" for allocating and deleting arrays.\n //   See gc_cpp.h for details.  No effect on the C part of the collector.\n //   This is defined implicitly in a few environments.\n@@ -86,4 +86,4 @@\n //   since some ports use malloc or calloc to obtain system memory.\n //   (Probably works for UNIX, and win32.)\n // -DNO_DEBUG removes GC_dump and the debugging routines it calls.\n-//   Reduces code size slightly at the expense of debuggability.\n\\ No newline at end of file\n+//   Reduces code size slightly at the expense of debuggability."}, {"sha": "717af6e4ac12bc6e0d8e04905d069bdd43084a5e", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -18,15 +18,23 @@ MULTICLEAN = true\n \n noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la\n \n+if POWERPC_DARWIN\n+asm_libgc_sources = powerpc_darwin_mach_dep.s\n+else\n+asm_libgc_sources = \n+endif\n+\n GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c \\\n-linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \\\n+malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n-backgraph.c win32_threads.c\n+backgraph.c win32_threads.c \\\n+pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n+$(asm_libgc_sources)\n \n-EXTRA_GC_SOURCES = alpha_mach_dep.s \\\n-mips_sgi_mach_dep.S mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n+EXTRA_GC_SOURCES = alpha_mach_dep.S \\\n+mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n@@ -63,7 +71,9 @@ TESTS = gctest\n ## FIXME: relies on internal code generated by automake.\n all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)\n $(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\n-include/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n+include/private/gc_hdrs.h include/gc.h include/gc_gcj.h \\\n+include/gc_pthread_redirects.h include/gc_config_macros.h \\\n+include/gc_mark.h @addincludes@\n \n ## FIXME: we shouldn't have to do this, but automake forces us to.\n .s.lo:"}, {"sha": "a884ee5e0bfd7ddb91571f8422d09674550aab88", "filename": "boehm-gc/Makefile.direct", "status": "modified", "additions": 77, "deletions": 30, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.direct", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.direct", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.direct?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -27,8 +27,11 @@ CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_\n \n # To build the parallel collector on Linux, add to the above:\n # -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n-# To build the parallel collector n a static library on HP/UX, add to the above:\n+# To build the parallel collector in a static library on HP/UX,\n+# add to the above:\n # -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -DUSE_HPUX_TLS -D_POSIX_C_SOURCE=199506L\n+# To build the thread-safe collector on Tru64, add to the above:\n+# -pthread -DGC_OSF1_THREADS\n \n # HOSTCC and HOSTCFLAGS are used to build executables that will be run as\n # part of the build process, i.e. on the build machine.  These will usually\n@@ -60,6 +63,16 @@ HOSTCFLAGS=$(CFLAGS)\n #   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n # -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n #   see README.linux.  -D_REENTRANT may also be required.\n+# -DGC_OSF1_THREADS enables support for Tru64 pthreads.  Untested.\n+# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.  Untested.\n+#   Appeared to run into some underlying thread problems.\n+# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.  Untested.\n+# -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.\n+#   See README.DGUX386.\n+# -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense\n+#   for this Makefile only under Cygwin.\n+# -DGC_THREADS should set the appropriate one of the above macros.\n+#   It assumes pthreads for Solaris.\n # -DALL_INTERIOR_POINTERS allows all pointers to the interior\n #   of objects to be recognized.  (See gc_priv.h for consequences.)\n #   Alternatively, GC_all_interior_pointers can be set at process\n@@ -93,13 +106,15 @@ HOSTCFLAGS=$(CFLAGS)\n #   See gc_cpp.h for details.  No effect on the C part of the collector.\n #   This is defined implicitly in a few environments.  Must also be defined\n #   by clients that use gc_cpp.h.\n-# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be\n-#   defined as aliases for X, GC_realloc, and GC_free, respectively.\n+# -DREDIRECT_MALLOC=X causes malloc to be defined as alias for X.\n+#   Unless the following macros are defined, realloc is also redirected\n+#   to GC_realloc, and free is redirected to GC_free.\n #   Calloc and strdup are redefined in terms of the new malloc.  X should\n #   be either GC_malloc or GC_malloc_uncollectable, or\n #   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc\n #   with dummy source location information, but still results in\n-#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.)\n+#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.\n+#   It requires that the following two macros also be used.)\n #   The former is occasionally useful for working around leaks in code\n #   you don't want to (or can't) look at.  It may not work for\n #   existing code, but it often does.  Neither works on all platforms,\n@@ -111,6 +126,9 @@ HOSTCFLAGS=$(CFLAGS)\n #   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,\n #   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to\n #   generate leak reports with call stacks for both malloc and realloc.\n+#   This also requires the following:\n+# -DREDIRECT_FREE=X causes free to be redirected to X.  The\n+#   canonical use is -DREDIRECT_FREE=GC_debug_free.\n # -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n #   -DREDIRECT_MALLOC.\n # -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n@@ -197,8 +215,11 @@ HOSTCFLAGS=$(CFLAGS)\n #   15% or so.\n # -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n #   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n-#   UNTESTED!!\n-# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n+#   Minimally tested.  Didn't appear to be an obvious win on a K6-2/500.\n+# -DUSE_PPC_PREFETCH causes the collector to issue PowerPC style\n+#   prefetch instructions.  No effect except on PowerPC OS X platforms.\n+#   Performance impact untested.\n+# -DGC_USE_LD_WRAP in combination with the old flags listed in README.linux\n #   causes the collector some system and pthread calls in a more transparent\n #   fashion than the usual macro-based approach.  Requires GNU ld, and\n #   currently probably works only with Linux.\n@@ -226,37 +247,58 @@ HOSTCFLAGS=$(CFLAGS)\n # -DSTUBBORN_ALLOC allows allocation of \"hard to change\" objects, and thus\n #   makes incremental collection easier.  Was enabled by default until 6.0.\n #   Rarely used, to my knowledge.\n+# -DHANDLE_FORK attempts to make GC_malloc() work in a child process fork()ed\n+#   from a multithreaded parent.  Currently only supported by pthread_support.c.\n+#   (Similar code should work on Solaris or Irix, but it hasn't been tried.)\n+# -DTEST_WITH_SYSTEM_MALLOC causes gctest to allocate (and leak) large chunks\n+#   of memory with the standard system malloc.  This will cause the root\n+#   set and collected heap to grow significantly if malloced memory is\n+#   somehow getting traced by the collector.  This has no impact on the\n+#   generated library; it only affects the test.\n+# -DPOINTER_MASK=0x... causes candidate pointers to be ANDed with the\n+#   given mask before being considered.  If either this or the following\n+#   macro is defined, it will be assumed that all pointers stored in\n+#   the heap need to be processed this way.  Stack and register pointers\n+#   will be considered both with and without processing.\n+#   These macros are normally needed only to support systems that use\n+#   high-order pointer tags. EXPERIMENTAL.\n+# -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers\n+#   by the indicated amount before trying to interpret them.  Applied\n+#   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.\n #\n \n CXXFLAGS= $(CFLAGS) \n AR= ar\n RANLIB= ranlib\n \n \n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o aix_irix_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c aix_irix_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c\n \n CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n \n CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n \n-SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n+SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.S \\\n     sparc_mach_dep.S include/gc.h include/gc_typed.h \\\n     include/private/gc_hdrs.h include/private/gc_priv.h \\\n     include/private/gcconfig.h include/private/gc_pmark.h \\\n     include/gc_inl.h include/gc_inline.h include/gc_mark.h \\\n     threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n     gcname.c include/weakpointer.h include/private/gc_locks.h \\\n     gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n-    include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n-    sparc_netbsd_mach_dep.s \\\n+    include/new_gc_alloc.h include/gc_allocator.h \\\n+    include/javaxfc.h sparc_sunos4_mach_dep.s sparc_netbsd_mach_dep.s \\\n     include/private/solaris_threads.h include/gc_backptr.h \\\n     hpux_test_and_clear.s include/gc_gcj.h \\\n     include/gc_local_alloc.h include/private/dbg_mlc.h \\\n-    include/private/specific.h powerpc_macosx_mach_dep.s \\\n+    include/private/specific.h powerpc_darwin_mach_dep.s \\\n     include/leak_detector.h include/gc_amiga_redirects.h \\\n-    include/gc_pthread_redirects.h $(CORD_SRCS)\n+    include/gc_pthread_redirects.h ia64_save_regs_in_stack.s \\\n+    include/gc_config_macros.h include/private/pthread_support.h \\\n+    include/private/pthread_stop_world.h include/private/darwin_semaphore.h \\\n+    include/private/darwin_stop_world.h $(CORD_SRCS)\n \n DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n \tdoc/README.amiga doc/README.cords doc/debugging.html \\\n@@ -265,15 +307,19 @@ DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n \tdoc/README.win32 doc/barrett_diagram doc/README \\\n         doc/README.contributors doc/README.changes doc/gc.man \\\n \tdoc/README.environment doc/tree.html doc/gcdescr.html \\\n-\tdoc/README.autoconf doc/README.macros doc/README.ews4800\n+\tdoc/README.autoconf doc/README.macros doc/README.ews4800 \\\n+\tdoc/README.DGUX386 doc/README.arm.cross doc/leak.html \\\n+\tdoc/scale.html doc/gcinterface.html doc/README.darwin\n \n TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n \ttests/leak_test.c tests/thread_leak_test.c\n \n GNU_BUILD_FILES= configure.in Makefile.am configure acinclude.m4 \\\n \t\t libtool.m4 install-sh configure.host Makefile.in \\\n-\t\t aclocal.m4 config.sub config.guess ltconfig \\\n-\t\t ltmain.sh mkinstalldirs\n+\t\t ltconfig aclocal.m4 config.sub config.guess \\\n+\t\t include/Makefile.am include/Makefile.in \\\n+\t\t doc/Makefile.am doc/Makefile.in \\\n+\t\t ltmain.sh mkinstalldirs depcomp missing\n \n OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \\\n \t\t BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \\\n@@ -285,7 +331,7 @@ OTHER_FILES= Makefile setjmp_t.c callprocs pc_excludes \\\n            MacProjects.sit.hqx MacOS.c \\\n            Mac_files/datastart.c Mac_files/dataend.c \\\n            Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n-           add_gc_prefix.c gc_cpp.cpp win32_threads.c \\\n+           add_gc_prefix.c gc_cpp.cpp \\\n \t   version.h AmigaOS.c \\\n \t   $(TESTS) $(GNU_BUILD_FILES) $(OTHER_MAKEFILES)\n \n@@ -330,16 +376,16 @@ mach_dep.o $(SRCS)\n $(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \\\n     $(srcdir)/include/private/gc_priv.h \\\n     $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n-    $(srcdir)/include/gc.h \\\n+    $(srcdir)/include/gc.h $(srcdir)/include/gc_pthread_redirects.h \\\n     $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n-    Makefile\n+    $(srcdir)/include/gc_config_macros.h Makefile\n # The dependency on Makefile is needed.  Changing\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n \n mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n \n-specific.o linux_threads.o: $(srcdir)/include/private/specific.h\n+specific.o pthread_support.o: $(srcdir)/include/private/specific.h\n \n solaris_threads.o solaris_pthreads.o: $(srcdir)/include/private/solaris_threads.h\n \n@@ -434,17 +480,18 @@ liblinuxgc.so: $(OBJS) dyn_load.o\n # \tgcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo\n #\ttouch liblinuxgc.so\n \n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s \\\n-            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_macosx_mach_dep.s $(UTILS)\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s \\\n+\t    $(srcdir)/mips_ultrix_mach_dep.s \\\n+            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_darwin_mach_dep.s \\\n+\t    $(srcdir)/sparc_mach_dep.S $(srcdir)/sparc_sunos4_mach_dep.s \\\n+\t    $(srcdir)/ia64_save_regs_in_stack.s \\\n+\t    $(srcdir)/sparc_netbsd_mach_dep.s $(UTILS)\n \trm -f mach_dep.o\n-\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n+\t./if_mach MIPS IRIX5 $(CC) -c -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n \t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n-\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_macosx_mach_dep.s\n-#\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n-#\talpha_mach_dep.s assumes that pointers are not saved in fp registers.\n-#\tGcc on a 21264 can spill pointers to fp registers.  Oops.\n+\t./if_mach POWERPC DARWIN $(AS) -o mach_dep.o $(srcdir)/powerpc_darwin_mach_dep.s\n+\t./if_mach ALPHA LINUX $(CC) -c -o mach_dep.o $(srcdir)/alpha_mach_dep.S\n \t./if_mach SPARC SUNOS5 $(CC) -c -o mach_dep.o $(srcdir)/sparc_mach_dep.S\n \t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n \t./if_mach SPARC OPENBSD $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n@@ -491,7 +538,7 @@ cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n \t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n \t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`\n \t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_mach POWERPC MACOSX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n+\t./if_mach POWERPC DARWIN $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n \t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n \t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n \t./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n@@ -510,7 +557,7 @@ if_not_there: $(srcdir)/if_not_there.c\n clean: \n \trm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \\\n \t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n-\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de\n+\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de \n \t-rm -f *~\n \n gctest: tests/test.o gc.a $(UTILS)"}, {"sha": "6097293ff0e7966f21482ce16164b7ce87b88824", "filename": "boehm-gc/Makefile.dj", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -152,7 +152,7 @@ CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIO\n #   currently probably works only with Linux.\n \n \n-CXXFLAGS= $(CFLAGS) -DOPERATOR_NEW_ARRAY\n+CXXFLAGS= $(CFLAGS) -DGC_OPERATOR_NEW_ARRAY\n AR= ar\n RANLIB= ranlib\n \n@@ -165,8 +165,8 @@ CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordt\n \n CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n \n-SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n-    sparc_mach_dep.s include/gc.h include/gc_typed.h \\\n+SRCS= $(CSRCS) mips_sgi_mach_dep.S rs6000_mach_dep.s alpha_mach_dep.S \\\n+    sparc_mach_dep.S include/gc.h include/gc_typed.h \\\n     include/private/gc_hdrs.h include/private/gc_priv.h \\\n     include/private/gcconfig.h include/private/gc_mark.h \\\n     include/gc_inl.h include/gc_inline.h gc.man \\\n@@ -177,7 +177,7 @@ SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n     include/private/solaris_threads.h include/gc_backptr.h \\\n     hpux_test_and_clear.s include/gc_gcj.h \\\n     include/gc_local_alloc.h include/private/dbg_mlc.h \\\n-    include/private/specific.h powerpc_macosx_mach_dep.s \\\n+    include/private/specific.h powerpc_darwin_mach_dep.s \\\n     include/leak_detector.h $(CORD_SRCS)\n \n OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n@@ -284,16 +284,16 @@ liblinuxgc.so: $(OBJS) dyn_load.o\n \tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o -lo\n \tln liblinuxgc.so libgc.so\n \n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s \\\n-            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_macosx_mach_dep.s $(UTILS)\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.S $(srcdir)/mips_ultrix_mach_dep.s \\\n+            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_darwin_mach_dep.s $(UTILS)\n \trm -f mach_dep.o\n-\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n+\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.S\n \t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n-\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_macosx_mach_dep.s\n-\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n-\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n+\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_darwin_mach_dep.s\n+\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.S\n+\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.S\n \t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n \t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n "}, {"sha": "4e5bb369e7ae180473f76e502ed9cdff26407062", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -66,9 +66,11 @@ target_triplet = @target@\n AR = @AR@\n AS = @AS@\n CC = @CC@\n+CFLAGS = @CFLAGS@\n CPP = @CPP@\n CXX = @CXX@\n CXXCPP = @CXXCPP@\n+CXXFLAGS = @CXXFLAGS@\n CXXINCLUDES = @CXXINCLUDES@\n DLLTOOL = @DLLTOOL@\n EXEEXT = @EXEEXT@\n@@ -89,7 +91,10 @@ RANLIB = @RANLIB@\n STRIP = @STRIP@\n THREADLIBS = @THREADLIBS@\n VERSION = @VERSION@\n+addincludes = @addincludes@\n+addlibs = @addlibs@\n addobjs = @addobjs@\n+addtests = @addtests@\n gc_basedir = @gc_basedir@\n mkinstalldirs = @mkinstalldirs@\n target_all = @target_all@\n@@ -109,17 +114,21 @@ MULTIDO = true\n MULTICLEAN = true\n \n noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la\n+@POWERPC_DARWIN_TRUE@asm_libgc_sources = @POWERPC_DARWIN_TRUE@powerpc_darwin_mach_dep.s\n+@POWERPC_DARWIN_FALSE@asm_libgc_sources = \n \n GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c \\\n-linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \\\n+malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n-backgraph.c win32_threads.c\n+backgraph.c win32_threads.c \\\n+pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n+$(asm_libgc_sources)\n \n \n-EXTRA_GC_SOURCES = alpha_mach_dep.s \\\n-mips_sgi_mach_dep.S mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n+EXTRA_GC_SOURCES = alpha_mach_dep.S \\\n+mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n@@ -213,24 +222,53 @@ DEFS = @DEFS@ -I. -I$(srcdir)\n CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n-libgcjgc_la_OBJECTS =  allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n-dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo headers.lo \\\n-irix_threads.lo linux_threads.lo malloc.lo mallocx.lo mark.lo \\\n-mark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo \\\n-ptr_chck.lo real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n-solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo backgraph.lo \\\n-win32_threads.lo\n+@POWERPC_DARWIN_FALSE@libgcjgc_la_OBJECTS =  allchblk.lo alloc.lo \\\n+@POWERPC_DARWIN_FALSE@blacklst.lo checksums.lo dbg_mlc.lo dyn_load.lo \\\n+@POWERPC_DARWIN_FALSE@finalize.lo gc_dlopen.lo gcj_mlc.lo headers.lo \\\n+@POWERPC_DARWIN_FALSE@aix_irix_threads.lo malloc.lo mallocx.lo mark.lo \\\n+@POWERPC_DARWIN_FALSE@mark_rts.lo misc.lo new_hblk.lo obj_map.lo \\\n+@POWERPC_DARWIN_FALSE@os_dep.lo pcr_interface.lo ptr_chck.lo \\\n+@POWERPC_DARWIN_FALSE@real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n+@POWERPC_DARWIN_FALSE@solaris_threads.lo specific.lo stubborn.lo \\\n+@POWERPC_DARWIN_FALSE@typd_mlc.lo backgraph.lo win32_threads.lo \\\n+@POWERPC_DARWIN_FALSE@pthread_support.lo pthread_stop_world.lo \\\n+@POWERPC_DARWIN_FALSE@darwin_stop_world.lo\n+@POWERPC_DARWIN_TRUE@libgcjgc_la_OBJECTS =  allchblk.lo alloc.lo \\\n+@POWERPC_DARWIN_TRUE@blacklst.lo checksums.lo dbg_mlc.lo dyn_load.lo \\\n+@POWERPC_DARWIN_TRUE@finalize.lo gc_dlopen.lo gcj_mlc.lo headers.lo \\\n+@POWERPC_DARWIN_TRUE@aix_irix_threads.lo malloc.lo mallocx.lo mark.lo \\\n+@POWERPC_DARWIN_TRUE@mark_rts.lo misc.lo new_hblk.lo obj_map.lo \\\n+@POWERPC_DARWIN_TRUE@os_dep.lo pcr_interface.lo ptr_chck.lo \\\n+@POWERPC_DARWIN_TRUE@real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n+@POWERPC_DARWIN_TRUE@solaris_threads.lo specific.lo stubborn.lo \\\n+@POWERPC_DARWIN_TRUE@typd_mlc.lo backgraph.lo win32_threads.lo \\\n+@POWERPC_DARWIN_TRUE@pthread_support.lo pthread_stop_world.lo \\\n+@POWERPC_DARWIN_TRUE@darwin_stop_world.lo powerpc_darwin_mach_dep.lo\n libgcjgc_convenience_la_LDFLAGS = \n-libgcjgc_convenience_la_OBJECTS =  allchblk.lo alloc.lo blacklst.lo \\\n-checksums.lo dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n-headers.lo irix_threads.lo linux_threads.lo malloc.lo mallocx.lo \\\n-mark.lo mark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo \\\n-pcr_interface.lo ptr_chck.lo real_malloc.lo reclaim.lo \\\n-solaris_pthreads.lo solaris_threads.lo specific.lo stubborn.lo \\\n-typd_mlc.lo backgraph.lo win32_threads.lo\n+@POWERPC_DARWIN_FALSE@libgcjgc_convenience_la_OBJECTS =  allchblk.lo \\\n+@POWERPC_DARWIN_FALSE@alloc.lo blacklst.lo checksums.lo dbg_mlc.lo \\\n+@POWERPC_DARWIN_FALSE@dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n+@POWERPC_DARWIN_FALSE@headers.lo aix_irix_threads.lo malloc.lo \\\n+@POWERPC_DARWIN_FALSE@mallocx.lo mark.lo mark_rts.lo misc.lo \\\n+@POWERPC_DARWIN_FALSE@new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo \\\n+@POWERPC_DARWIN_FALSE@ptr_chck.lo real_malloc.lo reclaim.lo \\\n+@POWERPC_DARWIN_FALSE@solaris_pthreads.lo solaris_threads.lo \\\n+@POWERPC_DARWIN_FALSE@specific.lo stubborn.lo typd_mlc.lo backgraph.lo \\\n+@POWERPC_DARWIN_FALSE@win32_threads.lo pthread_support.lo \\\n+@POWERPC_DARWIN_FALSE@pthread_stop_world.lo darwin_stop_world.lo\n+@POWERPC_DARWIN_TRUE@libgcjgc_convenience_la_OBJECTS =  allchblk.lo \\\n+@POWERPC_DARWIN_TRUE@alloc.lo blacklst.lo checksums.lo dbg_mlc.lo \\\n+@POWERPC_DARWIN_TRUE@dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n+@POWERPC_DARWIN_TRUE@headers.lo aix_irix_threads.lo malloc.lo \\\n+@POWERPC_DARWIN_TRUE@mallocx.lo mark.lo mark_rts.lo misc.lo new_hblk.lo \\\n+@POWERPC_DARWIN_TRUE@obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n+@POWERPC_DARWIN_TRUE@real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n+@POWERPC_DARWIN_TRUE@solaris_threads.lo specific.lo stubborn.lo \\\n+@POWERPC_DARWIN_TRUE@typd_mlc.lo backgraph.lo win32_threads.lo \\\n+@POWERPC_DARWIN_TRUE@pthread_support.lo pthread_stop_world.lo \\\n+@POWERPC_DARWIN_TRUE@darwin_stop_world.lo powerpc_darwin_mach_dep.lo\n check_PROGRAMS =  gctest$(EXEEXT)\n gctest_DEPENDENCIES =  ./libgcjgc.la\n-CFLAGS = @CFLAGS@\n COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n CCLD = $(CC)\n DIST_COMMON =  ChangeLog Makefile.am Makefile.in acinclude.m4 aclocal.m4 \\\n@@ -368,7 +406,7 @@ maintainer-clean-recursive:\n \tdot_seen=no; \\\n \trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n \t  rev=\"$$subdir $$rev\"; \\\n-\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n+\t  test \"$$subdir\" != \".\" || dot_seen=yes; \\\n \tdone; \\\n \ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\\n@@ -598,7 +636,9 @@ mostlyclean distclean maintainer-clean\n test.o:\ttests/test.c\n \t$(COMPILE) -c $(srcdir)/tests/test.c\n $(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\n-include/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n+include/private/gc_hdrs.h include/gc.h include/gc_gcj.h \\\n+include/gc_pthread_redirects.h include/gc_config_macros.h \\\n+include/gc_mark.h @addincludes@\n \n .s.lo:\n \t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<"}, {"sha": "2b039397e1cfa50c46b98626d702f691d9582bcc", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -47,12 +47,16 @@ GC_bool GC_use_entire_heap = 0;\n struct hblk * GC_hblkfreelist[N_HBLK_FLS+1] = { 0 };\n \n #ifndef USE_MUNMAP\n+\n   word GC_free_bytes[N_HBLK_FLS+1] = { 0 };\n \t/* Number of free bytes on each list.\t*/\n \n   /* Is bytes + the number of free bytes on lists n .. N_HBLK_FLS \t*/\n   /* > GC_max_large_allocd_bytes?\t\t\t\t\t*/\n-  GC_bool GC_enough_large_bytes_left(bytes,n)\n+# ifdef __GNUC__\n+  __inline__\n+# endif\n+  static GC_bool GC_enough_large_bytes_left(bytes,n)\n   word bytes;\n   int n;\n   {\n@@ -583,18 +587,24 @@ int n;\n \t    if (!GC_use_entire_heap\n \t\t&& size_avail != size_needed\n \t\t&& USED_HEAP_SIZE >= GC_requested_heapsize\n-\t\t&& !GC_incremental && GC_should_collect()) {\n+\t\t&& !TRUE_INCREMENTAL && GC_should_collect()) {\n #\t\tifdef USE_MUNMAP\n \t\t    continue;\n #\t\telse\n-\t\t    /* If we enough large blocks left to cover any\t*/\n+\t\t    /* If we have enough large blocks left to cover any\t*/\n \t\t    /* previous request for large blocks, we go ahead\t*/\n \t\t    /* and split.  Assuming a steady state, that should\t*/\n \t\t    /* be safe.  It means that we can use the full \t*/\n \t\t    /* heap if we allocate only small objects.\t\t*/\n \t\t    if (!GC_enough_large_bytes_left(GC_large_allocd_bytes, n)) {\n \t\t      continue;\n \t\t    } \n+\t\t    /* If we are deallocating lots of memory from\t*/\n+\t\t    /* finalizers, fail and collect sooner rather\t*/\n+\t\t    /* than later.\t\t\t\t\t*/\n+\t\t    if (GC_finalizer_mem_freed > (GC_heapsize >> 4))  {\n+\t\t      continue;\n+\t\t    }\n #\t\tendif /* !USE_MUNMAP */\n \t    }\n \t    /* If the next heap block is obviously better, go on.\t*/"}, {"sha": "f53061f872d02096dfb19915e4a6f0ed41fcbd1a", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -72,6 +72,13 @@ int GC_full_freq = 19;\t   /* Every 20th collection is a full\t*/\n GC_bool GC_need_full_gc = FALSE;\n \t\t\t   /* Need full GC do to heap growth.\t*/\n \n+#ifdef THREADS\n+  GC_bool GC_world_stopped = FALSE;\n+# define IF_THREADS(x) x\n+#else\n+# define IF_THREADS(x)\n+#endif\n+\n word GC_used_heap_size_after_full = 0;\n \n char * GC_copyright[] =\n@@ -160,7 +167,7 @@ static word min_words_allocd()\n \t\t\t       + (GC_large_free_bytes >> 2)\n \t\t\t\t   /* use a bit more of large empty heap */\n \t\t\t       + total_root_size);\n-    if (GC_incremental) {\n+    if (TRUE_INCREMENTAL) {\n         return scan_size / (2 * GC_free_space_divisor);\n     } else {\n         return scan_size / GC_free_space_divisor;\n@@ -182,7 +189,8 @@ word GC_adj_words_allocd()\n     /* managed object should not alter result, assuming the client\t*/\n     /* is playing by the rules.\t\t\t\t\t\t*/\n     result = (signed_word)GC_words_allocd\n-    \t     - (signed_word)GC_mem_freed - expl_managed;\n+    \t     - (signed_word)GC_mem_freed \n+\t     + (signed_word)GC_finalizer_mem_freed - expl_managed;\n     if (result > (signed_word)GC_words_allocd) {\n         result = GC_words_allocd;\n     \t/* probably client bug or unfortunate scheduling */\n@@ -250,7 +258,6 @@ void GC_maybe_gc()\n \n     if (GC_should_collect()) {\n         if (!GC_incremental) {\n-\t    GC_notify_full_gc();\n             GC_gcollect_inner();\n             n_partial_gcs = 0;\n             return;\n@@ -302,10 +309,14 @@ void GC_maybe_gc()\n /*\n  * Stop the world garbage collection.  Assumes lock held, signals disabled.\n  * If stop_func is not GC_never_stop_func, then abort if stop_func returns TRUE.\n+ * Return TRUE if we successfully completed the collection.\n  */\n GC_bool GC_try_to_collect_inner(stop_func)\n GC_stop_func stop_func;\n {\n+#   ifdef CONDPRINT\n+        CLOCK_TYPE start_time, current_time;\n+#   endif\n     if (GC_dont_gc) return FALSE;\n     if (GC_incremental && GC_collection_in_progress()) {\n #   ifdef CONDPRINT\n@@ -320,8 +331,10 @@ GC_stop_func stop_func;\n     \t    GC_collect_a_little_inner(1);\n     \t}\n     }\n+    if (stop_func == GC_never_stop_func) GC_notify_full_gc();\n #   ifdef CONDPRINT\n       if (GC_print_stats) {\n+        if (GC_print_stats) GET_TIME(start_time);\n \tGC_printf2(\n \t   \"Initiating full world-stop collection %lu after %ld allocd bytes\\n\",\n \t   (unsigned long) GC_gc_no+1,\n@@ -360,6 +373,13 @@ GC_stop_func stop_func;\n       return(FALSE);\n     }\n     GC_finish_collection();\n+#   if defined(CONDPRINT)\n+      if (GC_print_stats) {\n+        GET_TIME(current_time);\n+        GC_printf1(\"Complete collection took %lu msecs\\n\",\n+                   MS_TIME_DIFF(current_time,start_time));\n+      }\n+#   endif\n     return(TRUE);\n }\n \n@@ -430,6 +450,7 @@ int GC_collect_a_little GC_PROTO(())\n     result = (int)GC_collection_in_progress();\n     UNLOCK();\n     ENABLE_SIGNALS();\n+    if (!result && GC_debugging_started) GC_print_all_smashed();\n     return(result);\n }\n \n@@ -448,16 +469,17 @@ GC_stop_func stop_func;\n \tCLOCK_TYPE start_time, current_time;\n #   endif\n \t\n-#   if defined(REGISTER_LIBRARIES_EARLY)\n-        GC_cond_register_dynamic_libraries();\n-#   endif\n-    STOP_WORLD();\n #   ifdef PRINTTIMES\n \tGET_TIME(start_time);\n #   endif\n #   if defined(CONDPRINT) && !defined(PRINTTIMES)\n \tif (GC_print_stats) GET_TIME(start_time);\n #   endif\n+#   if defined(REGISTER_LIBRARIES_EARLY)\n+        GC_cond_register_dynamic_libraries();\n+#   endif\n+    STOP_WORLD();\n+    IF_THREADS(GC_world_stopped = TRUE);\n #   ifdef CONDPRINT\n       if (GC_print_stats) {\n \tGC_printf1(\"--> Marking for collection %lu \",\n@@ -488,6 +510,7 @@ GC_stop_func stop_func;\n \t\t      }\n #\t\t    endif\n \t\t    GC_deficit = i; /* Give the mutator a chance. */\n+                    IF_THREADS(GC_world_stopped = FALSE);\n \t            START_WORLD();\n \t            return(FALSE);\n \t    }\n@@ -521,6 +544,8 @@ GC_stop_func stop_func;\n             (*GC_check_heap)();\n         }\n     \n+    IF_THREADS(GC_world_stopped = FALSE);\n+    START_WORLD();\n #   ifdef PRINTTIMES\n \tGET_TIME(current_time);\n \tGC_printf1(\"World-stopped marking took %lu msecs\\n\",\n@@ -534,7 +559,6 @@ GC_stop_func stop_func;\n \t}\n #     endif\n #   endif\n-    START_WORLD();\n     return(TRUE);\n }\n \n@@ -611,6 +635,7 @@ void GC_finish_collection()\n \t  GC_print_address_map();\n \t}\n #   endif\n+    COND_DUMP;\n     if (GC_find_leak) {\n       /* Mark all objects on the free list.  All objects should be */\n       /* marked when we're done.\t\t\t\t   */\n@@ -707,6 +732,7 @@ void GC_finish_collection()\n       GC_words_allocd = 0;\n       GC_words_wasted = 0;\n       GC_mem_freed = 0;\n+      GC_finalizer_mem_freed = 0;\n       \n #   ifdef USE_MUNMAP\n       GC_unmap_old();\n@@ -730,6 +756,7 @@ void GC_finish_collection()\n     int result;\n     DCL_LOCK_STATE;\n     \n+    if (GC_debugging_started) GC_print_all_smashed();\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n@@ -741,14 +768,17 @@ void GC_finish_collection()\n     EXIT_GC();\n     UNLOCK();\n     ENABLE_SIGNALS();\n-    if(result) GC_INVOKE_FINALIZERS();\n+    if(result) {\n+        if (GC_debugging_started) GC_print_all_smashed();\n+        GC_INVOKE_FINALIZERS();\n+    }\n     return(result);\n }\n \n void GC_gcollect GC_PROTO(())\n {\n-    GC_notify_full_gc();\n     (void)GC_try_to_collect(GC_never_stop_func);\n+    if (GC_have_errors) GC_print_all_errors();\n }\n \n word GC_n_heap_sects = 0;\t/* Number of sections currently in heap. */\n@@ -950,7 +980,6 @@ GC_bool ignore_off_page;\n {\n     if (!GC_incremental && !GC_dont_gc &&\n \t(GC_dont_expand && GC_words_allocd > 0 || GC_should_collect())) {\n-      GC_notify_full_gc();\n       GC_gcollect_inner();\n     } else {\n       word blocks_to_get = GC_heapsize/(HBLKSIZE*GC_free_space_divisor)\n@@ -975,7 +1004,6 @@ GC_bool ignore_off_page;\n         && !GC_expand_hp_inner(needed_blocks)) {\n       \tif (GC_fail_count++ < GC_max_retries) {\n       \t    WARN(\"Out of Memory!  Trying to continue ...\\n\", 0);\n-\t    GC_notify_full_gc();\n \t    GC_gcollect_inner();\n \t} else {\n #\t    if !defined(AMIGA) || !defined(GC_AMIGA_FASTALLOC)\n@@ -1005,29 +1033,38 @@ ptr_t GC_allocobj(sz, kind)\n word sz;\n int kind;\n {\n-    register ptr_t * flh = &(GC_obj_kinds[kind].ok_freelist[sz]);\n+    ptr_t * flh = &(GC_obj_kinds[kind].ok_freelist[sz]);\n+    GC_bool tried_minor = FALSE;\n     \n     if (sz == 0) return(0);\n \n     while (*flh == 0) {\n       ENTER_GC();\n       /* Do our share of marking work */\n-        if(GC_incremental && !GC_dont_gc) GC_collect_a_little_inner(1);\n+        if(TRUE_INCREMENTAL) GC_collect_a_little_inner(1);\n       /* Sweep blocks for objects of this size */\n-          GC_continue_reclaim(sz, kind);\n+        GC_continue_reclaim(sz, kind);\n       EXIT_GC();\n       if (*flh == 0) {\n         GC_new_hblk(sz, kind);\n       }\n       if (*flh == 0) {\n         ENTER_GC();\n-        if (!GC_collect_or_expand((word)1,FALSE)) {\n+\tif (GC_incremental && GC_time_limit == GC_TIME_UNLIMITED\n+\t    && ! tried_minor ) {\n+\t    GC_collect_a_little_inner(1);\n+\t    tried_minor = TRUE;\n+\t} else {\n+          if (!GC_collect_or_expand((word)1,FALSE)) {\n \t    EXIT_GC();\n \t    return(0);\n+\t  }\n \t}\n \tEXIT_GC();\n       }\n     }\n+    /* Successful allocation; reset failure count.\t*/\n+    GC_fail_count = 0;\n     \n     return(*flh);\n }"}, {"sha": "a21f77ad54c6f25fdd871311e49750c19e87a554", "filename": "boehm-gc/alpha_mach_dep.s", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Falpha_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Falpha_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falpha_mach_dep.s?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,86 +0,0 @@\n-\t.arch ev6\n-\n-        .text\n-        .align  4\n-        .globl  GC_push_regs\n-        .ent    GC_push_regs 2\n-GC_push_regs:\n-\tldgp    $gp, 0($27)\n-\tlda     $sp, -16($sp)\n-\tstq     $26, 0($sp)\n-        .mask   0x04000000, 0\n-        .frame  $sp, 16, $26, 0\n-\n- # $0\t\tinteger result\n- # $1-$8\ttemp regs - not preserved cross calls\n- # $9-$15\tcall saved regs\n- # $16-$21\targument regs - not preserved cross calls\n- # $22-$28\ttemp regs - not preserved cross calls\n- # $29\t\tglobal pointer - not preserved cross calls\n- # $30\t\tstack pointer\n-\n-# define call_push(x)\t\t\t\\\n-\tmov   x, $16;\t\t\t\\\n-\tjsr   $26, GC_push_one;\t\t\\\n-\tldgp  $gp, 0($26)\n-\t\n-        call_push($9)\n-        call_push($10)\n-        call_push($11)\n-        call_push($12)\n-        call_push($13)\n-        call_push($14)\n-        call_push($15)\n-\n- # $f0-$f1\tfloating point results\n- # $f2-$f9\tcall saved regs\n- # $f10-$f30\ttemp regs - not preserved cross calls\n-\n-\t# Use the most efficient transfer method for this hardware.\n-\t# Bit 1 detects the FIX extension, which includes ftoit.\n-\tamask\t2, $0\n-\tbne\t$0, $use_stack\n-\n-#undef call_push\n-#define call_push(x)\t\t\t\\\n-\tftoit\tx, $16;\t\t\t\\\n-\tjsr\t$26, GC_push_one;\t\\\n-\tldgp\t$gp, 0($26)\n-\n-\tcall_push($f2)\n-\tcall_push($f3)\n-\tcall_push($f4)\n-\tcall_push($f5)\n-\tcall_push($f6)\n-\tcall_push($f7)\n-\tcall_push($f8)\n-\tcall_push($f9)\n-\n-\tldq     $26, 0($sp)\n-\tlda     $sp, 16($sp)\n-\tret     $31, ($26), 1\n-\n-\t.align\t4\n-$use_stack:\n-\n-#undef call_push\n-#define call_push(x)\t\t\t\\\n-\tstt\tx, 8($sp);\t\t\\\n-\tldq\t$16, 8($sp);\t\t\\\n-\tjsr\t$26, GC_push_one;\t\\\n-\tldgp\t$gp, 0($26)\n-\n-\tcall_push($f2)\n-\tcall_push($f3)\n-\tcall_push($f4)\n-\tcall_push($f5)\n-\tcall_push($f6)\n-\tcall_push($f7)\n-\tcall_push($f8)\n-\tcall_push($f9)\n-\n-\tldq     $26, 0($sp)\n-\tlda     $sp, 16($sp)\n-\tret     $31, ($26), 1\n-\n-\t.end    GC_push_regs"}, {"sha": "e8ca37d9e8af5c927b7666b6d814f0eadcbeb825", "filename": "boehm-gc/configure", "status": "modified", "additions": 468, "deletions": 107, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -41,7 +41,12 @@ ac_help=\"$ac_help\n ac_help=\"$ac_help\n   --with-ecos             enable runtime eCos target support\"\n ac_help=\"$ac_help\n-  --enable-shared[=PKGS]  build shared libraries [default=no]\"\n+  --enable-shared[=PKGS]  build shared libraries [default=yes]\"\n+ac_help=\"$ac_help\n+  --with-target-subdir=SUBDIR\n+                          configuring with a cross compiler\"\n+ac_help=\"$ac_help\n+  --with-cross-host=HOST  configuring with a cross compiler\"\n ac_help=\"$ac_help\n   --enable-full-debug\tinclude full support for pointer backtracing etc.\"\n \n@@ -61,7 +66,6 @@ program_suffix=NONE\n program_transform_name=s,x,x,\n silent=\n site=\n-sitefile=\n srcdir=\n target=NONE\n verbose=\n@@ -176,7 +180,6 @@ Configuration:\n   --help                  print this message\n   --no-create             do not create output files\n   --quiet, --silent       do not print \\`checking...' messages\n-  --site-file=FILE        use FILE as the site file\n   --version               print the version of autoconf that created configure\n Directory and file names:\n   --prefix=PREFIX         install architecture-independent files in PREFIX\n@@ -347,11 +350,6 @@ EOF\n   -site=* | --site=* | --sit=*)\n     site=\"$ac_optarg\" ;;\n \n-  -site-file | --site-file | --site-fil | --site-fi | --site-f)\n-    ac_prev=sitefile ;;\n-  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)\n-    sitefile=\"$ac_optarg\" ;;\n-\n   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n     ac_prev=srcdir ;;\n   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n@@ -517,16 +515,12 @@ fi\n srcdir=`echo \"${srcdir}\" | sed 's%\\([^/]\\)/*$%\\1%'`\n \n # Prefer explicitly selected file to automatically selected ones.\n-if test -z \"$sitefile\"; then\n-  if test -z \"$CONFIG_SITE\"; then\n-    if test \"x$prefix\" != xNONE; then\n-      CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n-    else\n-      CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n-    fi\n+if test -z \"$CONFIG_SITE\"; then\n+  if test \"x$prefix\" != xNONE; then\n+    CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n+  else\n+    CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n   fi\n-else\n-  CONFIG_SITE=\"$sitefile\"\n fi\n for ac_site_file in $CONFIG_SITE; do\n   if test -r \"$ac_site_file\"; then\n@@ -604,7 +598,7 @@ ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:608: checking for a BSD compatible install\" >&5\n+echo \"configure:602: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -657,7 +651,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:661: checking whether build environment is sane\" >&5\n+echo \"configure:655: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -714,7 +708,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:718: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:712: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -747,12 +741,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:751: checking for Cygwin environment\" >&5\n+echo \"configure:745: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 756 \"configure\"\n+#line 750 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -763,7 +757,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:767: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:761: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -780,19 +774,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:784: checking for mingw32 environment\" >&5\n+echo \"configure:778: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 789 \"configure\"\n+#line 783 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:796: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:790: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -903,7 +897,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:907: checking host system type\" >&5\n+echo \"configure:901: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -924,7 +918,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:928: checking target system type\" >&5\n+echo \"configure:922: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -942,7 +936,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:946: checking build system type\" >&5\n+echo \"configure:940: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -982,7 +976,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:986: checking for working aclocal\" >&5\n+echo \"configure:980: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -995,7 +989,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:999: checking for working autoconf\" >&5\n+echo \"configure:993: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1008,7 +1002,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:1012: checking for working automake\" >&5\n+echo \"configure:1006: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1021,7 +1015,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:1025: checking for working autoheader\" >&5\n+echo \"configure:1019: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1034,7 +1028,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1038: checking for working makeinfo\" >&5\n+echo \"configure:1032: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1060,7 +1054,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1064: checking for $ac_word\" >&5\n+echo \"configure:1058: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1090,7 +1084,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1094: checking for $ac_word\" >&5\n+echo \"configure:1088: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1139,7 +1133,7 @@ fi\n fi\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1143: checking whether we are using GNU C\" >&5\n+echo \"configure:1137: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1148,7 +1142,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1152: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1146: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1163,7 +1157,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1167: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1161: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1200,7 +1194,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1204: checking for $ac_word\" >&5\n+echo \"configure:1198: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1233,7 +1227,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n test -z \"$CXX\" && { echo \"configure: error: no acceptable c++ found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1237: checking whether we are using GNU C++\" >&5\n+echo \"configure:1231: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1242,7 +1236,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1246: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1240: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1257,7 +1251,7 @@ if test $ac_cv_prog_gxx = yes; then\n   ac_save_CXXFLAGS=\"$CXXFLAGS\"\n   CXXFLAGS=\n   echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1261: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1255: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1290,7 +1284,7 @@ fi\n # NEWLIB_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1294: checking build system type\" >&5\n+echo \"configure:1288: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1311,7 +1305,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1315: checking for $ac_word\" >&5\n+echo \"configure:1309: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1343,7 +1337,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1347: checking for $ac_word\" >&5\n+echo \"configure:1341: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1375,7 +1369,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1379: checking for $ac_word\" >&5\n+echo \"configure:1373: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1407,7 +1401,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1411: checking for $ac_word\" >&5\n+echo \"configure:1405: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1452,7 +1446,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1456: checking for a BSD compatible install\" >&5\n+echo \"configure:1450: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1506,7 +1500,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1510: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1504: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1544,7 +1538,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1548: checking for executable suffix\" >&5\n+echo \"configure:1542: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1554,10 +1548,10 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1558: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1552: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n-      *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n+      *.c | *.o | *.obj) ;;\n       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n       esac\n     done\n@@ -1676,7 +1670,7 @@ ac_prog=ld\n if test \"$GCC\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1680: checking for ld used by GCC\" >&5\n+echo \"configure:1674: checking for ld used by GCC\" >&5\n   case $host in\n   *-*-mingw*)\n     # gcc leaves a trailing carriage return which upsets mingw\n@@ -1706,10 +1700,10 @@ echo \"configure:1680: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1710: checking for GNU ld\" >&5\n+echo \"configure:1704: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1713: checking for non-GNU ld\" >&5\n+echo \"configure:1707: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'lt_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1744,7 +1738,7 @@ else\n fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1748: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1742: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1761,7 +1755,7 @@ with_gnu_ld=$lt_cv_prog_gnu_ld\n \n \n echo $ac_n \"checking for $LD option to reload object files\"\"... $ac_c\" 1>&6\n-echo \"configure:1765: checking for $LD option to reload object files\" >&5\n+echo \"configure:1759: checking for $LD option to reload object files\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_ld_reload_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1773,7 +1767,7 @@ reload_flag=$lt_cv_ld_reload_flag\n test -n \"$reload_flag\" && reload_flag=\" $reload_flag\"\n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1777: checking for BSD-compatible nm\" >&5\n+echo \"configure:1771: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1811,7 +1805,7 @@ NM=\"$lt_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1815: checking whether ln -s works\" >&5\n+echo \"configure:1809: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1832,7 +1826,7 @@ else\n fi\n \n echo $ac_n \"checking how to recognise dependant libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:1836: checking how to recognise dependant libraries\" >&5\n+echo \"configure:1830: checking how to recognise dependant libraries\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_deplibs_check_method'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2005,13 +1999,13 @@ file_magic_cmd=$lt_cv_file_magic_cmd\n deplibs_check_method=$lt_cv_deplibs_check_method\n \n echo $ac_n \"checking for object suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2009: checking for object suffix\" >&5\n+echo \"configure:2003: checking for object suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_objext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftest*\n echo 'int i = 1;' > conftest.$ac_ext\n-if { (eval echo configure:2015: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2009: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   for ac_file in conftest.*; do\n     case $ac_file in\n     *.c) ;;\n@@ -2035,7 +2029,7 @@ case $deplibs_check_method in\n file_magic*)\n   if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n     echo $ac_n \"checking for ${ac_tool_prefix}file\"\"... $ac_c\" 1>&6\n-echo \"configure:2039: checking for ${ac_tool_prefix}file\" >&5\n+echo \"configure:2033: checking for ${ac_tool_prefix}file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2097,7 +2091,7 @@ fi\n if test -z \"$lt_cv_path_MAGIC_CMD\"; then\n   if test -n \"$ac_tool_prefix\"; then\n     echo $ac_n \"checking for file\"\"... $ac_c\" 1>&6\n-echo \"configure:2101: checking for file\" >&5\n+echo \"configure:2095: checking for file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2168,7 +2162,7 @@ esac\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2172: checking for $ac_word\" >&5\n+echo \"configure:2166: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2200,7 +2194,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2204: checking for $ac_word\" >&5\n+echo \"configure:2198: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2235,7 +2229,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2239: checking for $ac_word\" >&5\n+echo \"configure:2233: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2267,7 +2261,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"strip\", so it can be a program name with args.\n set dummy strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2271: checking for $ac_word\" >&5\n+echo \"configure:2265: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2334,8 +2328,8 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2338 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2339: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 2332 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:2333: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n     case `/usr/bin/file conftest.$ac_objext` in\n     *32-bit*)\n@@ -2368,7 +2362,7 @@ case $host in\n ia64-*-hpux*)\n   # Find out which ABI we are using.\n   echo 'int i;' > conftest.$ac_ext\n-  if { (eval echo configure:2372: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  if { (eval echo configure:2366: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *ELF-32*)\n       HPUX_IA64_MODE=\"32\"\n@@ -2384,7 +2378,7 @@ ia64-*-hpux*)\n x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*|s390*-*linux*|sparc*-*linux*)\n   # Find out which ABI we are using.\n   echo 'int i;' > conftest.$ac_ext\n-  if { (eval echo configure:2388: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  if { (eval echo configure:2382: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *32-bit*)\n       case $host in\n@@ -2428,7 +2422,7 @@ x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*|s390*-*linux*|sparc*-*linux*)\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2432: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:2426: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2441,14 +2435,14 @@ ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$a\n cross_compiling=$ac_cv_prog_cc_cross\n \n      cat > conftest.$ac_ext <<EOF\n-#line 2445 \"configure\"\n+#line 2439 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2452: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2446: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2478,7 +2472,7 @@ echo \"$ac_t\"\"$lt_cv_cc_needs_belf\" 1>&6\n esac\n \n echo $ac_n \"checking how to run the C++ preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2482: checking how to run the C++ preprocessor\" >&5\n+echo \"configure:2476: checking how to run the C++ preprocessor\" >&5\n if test -z \"$CXXCPP\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXXCPP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2491,12 +2485,12 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n   CXXCPP=\"${CXX-g++} -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2495 \"configure\"\n+#line 2489 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2500: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2494: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2643,7 +2637,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:2647: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:2641: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -2676,7 +2670,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2680: checking for executable suffix\" >&5\n+echo \"configure:2674: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2686,10 +2680,10 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:2690: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:2684: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n-      *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n+      *.c | *.o | *.obj) ;;\n       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n       esac\n     done\n@@ -2709,7 +2703,7 @@ ac_exeext=$EXEEXT\n fi\n \n echo $ac_n \"checking for thread model used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:2713: checking for thread model used by GCC\" >&5\n+echo \"configure:2707: checking for thread model used by GCC\" >&5\n THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n if test -z \"$THREADS\"; then\n    THREADS=no\n@@ -2738,7 +2732,7 @@ case \"$THREADS\" in\n     THREADS=posix\n     THREADLIBS=-lpthread\n     case \"$host\" in\n-     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* )\n+     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* | alpha-*-linux*)\n \tcat >> confdefs.h <<\\EOF\n #define GC_LINUX_THREADS 1\n EOF\n@@ -2747,7 +2741,7 @@ EOF\n #define _REENTRANT 1\n EOF\n \n-        if test \"${enable_parallel_mark}\"; then\n+        if test \"${enable_parallel_mark}\" = yes; then\n \t  cat >> confdefs.h <<\\EOF\n #define PARALLEL_MARK 1\n EOF\n@@ -2765,6 +2759,16 @@ EOF\n \n \tcat >> confdefs.h <<\\EOF\n #define _REENTRANT 1\n+EOF\n+\n+\t;;\n+     *-*-aix*)\n+\tcat >> confdefs.h <<\\EOF\n+#define GC_AIX_THREADS 1\n+EOF\n+\n+\tcat >> confdefs.h <<\\EOF\n+#define _REENTRANT 1\n EOF\n \n \t;;\n@@ -2816,7 +2820,46 @@ EOF\n \n \t;;\n      *-*-cygwin*)\n-\tTHREADLIBS=\n+\tcat >> confdefs.h <<\\EOF\n+#define GC_WIN32_THREADS 1\n+EOF\n+\n+\t;;\n+     *-*-darwin*)\n+\tcat >> confdefs.h <<\\EOF\n+#define GC_DARWIN_THREADS 1\n+EOF\n+\n+\tcat >> confdefs.h <<\\EOF\n+#define THREAD_LOCAL_ALLOC 1\n+EOF\n+\n+\tif test \"${enable_parallel_mark}\" = yes; then\n+\t  cat >> confdefs.h <<\\EOF\n+#define PARALLEL_MARK 1\n+EOF\n+\n+\tfi\n+\t;;\n+     *-*-osf*)\n+\tcat >> confdefs.h <<\\EOF\n+#define GC_OSF1_THREADS 1\n+EOF\n+\n+        if test \"${enable_parallel_mark}\" = yes; then\n+\t  cat >> confdefs.h <<\\EOF\n+#define PARALLEL_MARK 1\n+EOF\n+\n+\t  cat >> confdefs.h <<\\EOF\n+#define THREAD_LOCAL_ALLOC 1\n+EOF\n+\n+\t  # May want to enable it in other cases, too.\n+\t  # Measurements havent yet been done.\n+\tfi\n+\tINCLUDES=\"$INCLUDES -pthread\"\n+\tTHREADLIBS=\"-lpthread -lrt\"\n \t;;\n     esac\n     ;;\n@@ -2825,16 +2868,48 @@ EOF\n #define GC_WIN32_THREADS 1\n EOF\n \n-    cat >> confdefs.h <<\\EOF\n+        cat >> confdefs.h <<\\EOF\n #define NO_GETENV 1\n EOF\n \n-    if test $enable_shared = yes; then\n-      cat >> confdefs.h <<\\EOF\n-#define GC_DLL 1\n+    ;;\n+ dgux386)\n+    THREADS=dgux386\n+echo \"$ac_t\"\"$THREADLIBS\" 1>&6\n+    # Use pthread GCC  switch\n+    THREADLIBS=-pthread\n+    if test \"${enable_parallel_mark}\" = yes; then\n+        cat >> confdefs.h <<\\EOF\n+#define PARALLEL_MARK 1\n EOF\n \n     fi\n+    cat >> confdefs.h <<\\EOF\n+#define THREAD_LOCAL_ALLOC 1\n+EOF\n+\n+    cat >> confdefs.h <<\\EOF\n+#define GC_DGUX386_THREADS 1\n+EOF\n+\n+    cat >> confdefs.h <<\\EOF\n+#define DGUX_THREADS 1\n+EOF\n+\n+    # Enable _POSIX4A_DRAFT10_SOURCE with flag -pthread\n+    INCLUDES=\"-pthread $INCLUDES\"\n+    ;;\n+ aix)\n+    THREADS=posix\n+    THREADLIBS=-lpthread\n+    cat >> confdefs.h <<\\EOF\n+#define GC_AIX_THREADS 1\n+EOF\n+\n+    cat >> confdefs.h <<\\EOF\n+#define _REENTRANT 1\n+EOF\n+\n     ;;\n  decosf1 | irix | mach | os2 | solaris | dce | vxworks)\n     { echo \"configure: error: thread package $THREADS not yet supported\" 1>&2; exit 1; }\n@@ -2845,16 +2920,36 @@ EOF\n esac\n \n \n-echo $ac_n \"checking for dlopen in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:2850: checking for dlopen in -ldl\" >&5\n+case \"$host\" in \n+   powerpc-*-darwin*)\n+      powerpc_darwin=true\n+      ;;\n+esac\n+\n+\n+if test x$powerpc_darwin = xtrue; then\n+  POWERPC_DARWIN_TRUE=\n+  POWERPC_DARWIN_FALSE='#'\n+else\n+  POWERPC_DARWIN_TRUE='#'\n+  POWERPC_DARWIN_FALSE=\n+fi\n+\n+# We never want libdl on darwin. It is a fake libdl that just ends up making\n+# dyld calls anyway\n+case \"$host\" in\n+  *-*-darwin*) ;;\n+  *) \n+    echo $ac_n \"checking for dlopen in -ldl\"\"... $ac_c\" 1>&6\n+echo \"configure:2945: checking for dlopen in -ldl\" >&5\n ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 2858 \"configure\"\n+#line 2953 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -2865,7 +2960,7 @@ int main() {\n dlopen()\n ; return 0; }\n EOF\n-if { (eval echo configure:2869: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2964: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -2885,6 +2980,9 @@ else\n   echo \"$ac_t\"\"no\" 1>&6\n fi\n \n+    ;;\n+esac\n+\n \n \n target_all=libgcjgc.la\n@@ -2901,6 +2999,9 @@ fi\n \n \n addobjs=\n+addlibs=\n+addincludes=\n+addtests=\n CXXINCLUDES=\n case \"$TARGET_ECOS\" in\n    no)\n@@ -2915,17 +3016,31 @@ EOF\n       ;;\n esac\n \n+if test \"${enable_cplusplus}\" = yes; then\n+      addincludes=\"$addincludes include/gc_cpp.h include/gc_allocator.h\"\n+      addtests=\"$addtests test_cpp\"\n+fi\n \n \n \n+if test \"${enable_cplusplus}\" = yes; then\n+  CPLUSPLUS_TRUE=\n+  CPLUSPLUS_FALSE='#'\n+else\n+  CPLUSPLUS_TRUE='#'\n+  CPLUSPLUS_FALSE=\n+fi\n \n-machdep=\n-case \"$host\" in\n- alpha*-*-openbsd*)\n-    machdep=\"alpha_mach_dep.lo\"\n-    if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n-       echo \"configure: warning: OpenBSD/Alpha without dlopen(). Shared library support is disabled\" 1>&2\n-       # Check whether --enable-shared or --disable-shared was given.\n+\n+\n+\n+\n+\n+# Configuration of shared libraries\n+#\n+echo $ac_n \"checking whether to build shared libraries\"\"... $ac_c\" 1>&6\n+echo \"configure:3043: checking whether to build shared libraries\" >&5\n+# Check whether --enable-shared or --disable-shared was given.\n if test \"${enable_shared+set}\" = set; then\n   enableval=\"$enable_shared\"\n   p=${PACKAGE-default}\n@@ -2945,12 +3060,33 @@ no) enable_shared=no ;;\n   ;;\n esac\n else\n-  enable_shared=no\n+  enable_shared=yes\n fi\n \n+\n+case \"$host\" in\n+ alpha-*-openbsd*)\n+     enable_shared=no\n+     echo \"$ac_t\"\"no\" 1>&6\n+     ;;\n+ *)\n+     echo \"$ac_t\"\"yes\" 1>&6\n+     ;;\n+esac\n+\n+# Configuration of machine-dependent code\n+#\n+echo $ac_n \"checking which machine-dependent code should be used\"\"... $ac_c\" 1>&6\n+echo \"configure:3081: checking which machine-dependent code should be used\" >&5 \n+machdep=\n+case \"$host\" in\n+ alpha*-*-openbsd*)\n+    machdep=\"alpha_mach_dep.lo\"\n+    if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n+       echo \"configure: warning: OpenBSD/Alpha without dlopen(). Shared library support is disabled\" 1>&2\n     fi\n     ;;\n- alpha*-*-*)\n+ alpha*-*-linux*)\n     machdep=\"alpha_mach_dep.lo\"\n     ;;\n  i?86-*-solaris2.[89]*)\n@@ -2973,14 +3109,19 @@ EOF\n  mips-dec-ultrix*)\n     machdep=\"mips_ultrix_mach-dep.lo\"\n     ;;\n- mips*-*-linux*)\n+ mips-nec-sysv*|mips-unknown-sysv*)\n     ;;\n+ mips*-*-linux*) \n+    ;; \n  mips-*-*)\n     machdep=\"mips_sgi_mach_dep.lo\"\n     cat >> confdefs.h <<\\EOF\n #define NO_EXECUTE_PERMISSION 1\n EOF\n \n+    ;;\n+ sparc-*-netbsd*)\n+    machdep=\"sparc_netbsd_mach_dep.lo\"\n     ;;\n  sparc-sun-solaris2.3*)\n     machdep=\"sparc_mach_dep.lo\"\n@@ -2997,14 +3138,217 @@ EOF\n     ;;\n esac\n if test x\"$machdep\" = x; then\n+echo \"$ac_t\"\"$machdep\" 1>&6\n    machdep=\"mach_dep.lo\"\n fi\n addobjs=\"$addobjs $machdep\"\n \n \n+\n+\n+\n+  \n+\n+  \n+\t \n+\t \n+\n+#\n+# Check for AViiON Machines running DGUX\n+#\n+echo $ac_n \"checking if host is AViiON running DGUX\"\"... $ac_c\" 1>&6\n+echo \"configure:3161: checking if host is AViiON running DGUX\" >&5\n+ac_is_dgux=no\n+echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n+echo \"configure:3164: checking how to run the C preprocessor\" >&5\n+# On Suns, sometimes $CPP names a directory.\n+if test -n \"$CPP\" && test -d \"$CPP\"; then\n+  CPP=\n+fi\n+if test -z \"$CPP\"; then\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_CPP'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+    # This must be in double quotes, not single quotes, because CPP may get\n+  # substituted into the Makefile and \"${CC-cc}\" will confuse make.\n+  CPP=\"${CC-cc} -E\"\n+  # On the NeXT, cc -E runs the code through the compiler's parser,\n+  # not just through cpp.\n+  cat > conftest.$ac_ext <<EOF\n+#line 3179 \"configure\"\n+#include \"confdefs.h\"\n+#include <assert.h>\n+Syntax Error\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:3185: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n+if test -z \"$ac_err\"; then\n+  :\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  CPP=\"${CC-cc} -E -traditional-cpp\"\n+  cat > conftest.$ac_ext <<EOF\n+#line 3196 \"configure\"\n+#include \"confdefs.h\"\n+#include <assert.h>\n+Syntax Error\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:3202: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n+if test -z \"$ac_err\"; then\n+  :\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  CPP=\"${CC-cc} -nologo -E\"\n+  cat > conftest.$ac_ext <<EOF\n+#line 3213 \"configure\"\n+#include \"confdefs.h\"\n+#include <assert.h>\n+Syntax Error\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:3219: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n+if test -z \"$ac_err\"; then\n+  :\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  CPP=/lib/cpp\n+fi\n+rm -f conftest*\n+fi\n+rm -f conftest*\n+fi\n+rm -f conftest*\n+  ac_cv_prog_CPP=\"$CPP\"\n+fi\n+  CPP=\"$ac_cv_prog_CPP\"\n+else\n+  ac_cv_prog_CPP=\"$CPP\"\n+fi\n+echo \"$ac_t\"\"$CPP\" 1>&6\n+\n+ac_safe=`echo \"sys/dg_sys_info.h\" | sed 'y%./+-%__p_%'`\n+echo $ac_n \"checking for sys/dg_sys_info.h\"\"... $ac_c\" 1>&6\n+echo \"configure:3245: checking for sys/dg_sys_info.h\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 3250 \"configure\"\n+#include \"confdefs.h\"\n+#include <sys/dg_sys_info.h>\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:3255: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n+if test -z \"$ac_err\"; then\n+  rm -rf conftest*\n+  eval \"ac_cv_header_$ac_safe=yes\"\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_header_$ac_safe=no\"\n+fi\n+rm -f conftest*\n+fi\n+if eval \"test \\\"`echo '$ac_cv_header_'$ac_safe`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  ac_is_dgux=yes;\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+\n+echo \"$ac_t\"\"$ac_is_dgux\" 1>&6 \n+    ## :GOTCHA: we do not check anything but sys/dg_sys_info.h\n+if test $ac_is_dgux = yes; then\n+    if test \"$enable_full_debug\" = \"yes\"; then\n+      CFLAGS=\"-g -mstandard -DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+      CXXFLAGS=\"-g -mstandard -DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+    else\n+      CFLAGS=\"-DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+      CXXFLAGS=\"-DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+    fi\n+    \n+    \n+fi\n+\n+# Check whether --with-target-subdir or --without-target-subdir was given.\n+if test \"${with_target_subdir+set}\" = set; then\n+  withval=\"$with_target_subdir\"\n+  :\n+fi\n+\n+# Check whether --with-cross-host or --without-cross-host was given.\n+if test \"${with_cross_host+set}\" = set; then\n+  withval=\"$with_cross_host\"\n+  :\n+fi\n+\n+\n+# automake wants to see AC_EXEEXT.  But we don't need it.  And having\n+# it is actually a problem, because the compiler we're passed can't\n+# necessarily do a full link.  So we fool automake here.\n+if false; then\n+  # autoconf 2.50 runs AC_EXEEXT by default, and the macro expands\n+  # to nothing, so nothing would remain between `then' and `fi' if it\n+  # were not for the `:' below.\n+  :\n+  \n+\n+echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n+echo \"configure:3315: checking for executable suffix\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  if test \"$CYGWIN\" = yes || test \"$MINGW32\" = yes; then\n+  ac_cv_exeext=.exe\n+else\n+  rm -f conftest*\n+  echo 'int main () { return 0; }' > conftest.$ac_ext\n+  ac_cv_exeext=\n+  if { (eval echo configure:3325: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+    for file in conftest.*; do\n+      case $file in\n+      *.c | *.o | *.obj) ;;\n+      *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n+      esac\n+    done\n+  else\n+    { echo \"configure: error: installation or configuration problem: compiler cannot create executables.\" 1>&2; exit 1; }\n+  fi\n+  rm -f conftest*\n+  test x\"${ac_cv_exeext}\" = x && ac_cv_exeext=no\n+fi\n+fi\n+\n+EXEEXT=\"\"\n+test x\"${ac_cv_exeext}\" != xno && EXEEXT=${ac_cv_exeext}\n+echo \"$ac_t\"\"${ac_cv_exeext}\" 1>&6\n+ac_exeext=$EXEEXT\n+\n+fi\n+\n+echo $ac_n \"checking whether Solaris gcc optimization fix is necessary\"\"... $ac_c\" 1>&6\n+echo \"configure:3348: checking whether Solaris gcc optimization fix is necessary\" >&5\n case \"$host\" in\n- sparc-sun-solaris2*)\n+ sparc-sun-solaris2*|*aix*)\n     if test \"$GCC\" = yes; then\n+       echo \"$ac_t\"\"yes\" 1>&6\n        new_CFLAGS=\n        for i in $CFLAGS; do\n \t  case \"$i\" in\n@@ -3016,8 +3360,11 @@ case \"$host\" in\n \t  esac\n        done\n        CFLAGS=\"$new_CFLAGS\"\n+    else\n+       echo \"$ac_t\"\"no\" 1>&6\n     fi\n     ;;\n+ *) echo \"$ac_t\"\"no\" 1>&6 ;;\n esac\n \n MY_CFLAGS=\"$CFLAGS\"\n@@ -3092,6 +3439,12 @@ EOF\n \techo \"configure: warning: \"Client must not use -fomit-frame-pointer.\"\" 1>&2\n \tcat >> confdefs.h <<\\EOF\n #define SAVE_CALL_COUNT 8\n+EOF\n+\n+      ;;\n+      i345686-*-dgux*)\n+\tcat >> confdefs.h <<\\EOF\n+#define MAKE_BACK_GRAPH 1\n EOF\n \n       ;;\n@@ -3311,11 +3664,19 @@ s%@STRIP@%$STRIP%g\n s%@LIBTOOL@%$LIBTOOL%g\n s%@CXXCPP@%$CXXCPP%g\n s%@THREADLIBS@%$THREADLIBS%g\n+s%@POWERPC_DARWIN_TRUE@%$POWERPC_DARWIN_TRUE%g\n+s%@POWERPC_DARWIN_FALSE@%$POWERPC_DARWIN_FALSE%g\n s%@EXTRA_TEST_LIBS@%$EXTRA_TEST_LIBS%g\n s%@target_all@%$target_all%g\n+s%@CPLUSPLUS_TRUE@%$CPLUSPLUS_TRUE%g\n+s%@CPLUSPLUS_FALSE@%$CPLUSPLUS_FALSE%g\n s%@INCLUDES@%$INCLUDES%g\n s%@CXXINCLUDES@%$CXXINCLUDES%g\n s%@addobjs@%$addobjs%g\n+s%@addincludes@%$addincludes%g\n+s%@addlibs@%$addlibs%g\n+s%@addtests@%$addtests%g\n+s%@CPP@%$CPP%g\n s%@MY_CFLAGS@%$MY_CFLAGS%g\n s%@toolexecdir@%$toolexecdir%g\n s%@toolexeclibdir@%$toolexeclibdir%g\n@@ -3327,7 +3688,7 @@ cat >> $CONFIG_STATUS <<\\EOF\n \n # Split the substitutions into bite-sized pieces for seds with\n # small command number limits, like on Digital OSF/1 and HP-UX.\n-ac_max_sed_cmds=60 # Maximum number of lines to put in a sed script.\n+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.\n ac_file=1 # Number of current file.\n ac_beg=1 # First line for current file.\n ac_end=$ac_max_sed_cmds # Line after last line for current file."}, {"sha": "a98a0a7cb30cc48a0035ac6b2fa4954b6542cf31", "filename": "boehm-gc/configure.host", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.host?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -14,22 +14,28 @@\n #   host\t\tThe configuration host\n #   host_cpu\t\tThe configuration host CPU\n #   target_optspace\t--enable-target-optspace (\"yes\", \"no\", \"\")\n+#   GCC                 should be \"yes\" if using gcc\n \n # It sets the following shell variables:\n #   gc_cflags\tSpecial CFLAGS to use when building\n \n+gc_cflags=\"\"\n+\n # We should set -fexceptions if we are using gcc and might be used\n # inside something like gcj.  This is the zeroth approximation:\n-case \"$host\" in \n-    *-*-linux* )\n-    gc_cflags=-fexceptions\n-    ;;\n-    hppa*-*-hpux* )\n-    if test $GCC != \"yes\" ; then\n-        gc_cflags=+ESdbgasm\n-    fi\n-    ;;\n-esac\n+if test :\"$GCC\": = :yes: ; then\n+    gc_cflags=\"${gc_cflags} -fexceptions\"\n+else\n+    case \"$host\" in \n+        hppa*-*-hpux* )\n+\tif test :$GCC: != :\"yes\": ; then\n+            gc_cflags=\"${gc_flags} +ESdbgasm\"\n+\tfi\n+        # :TODO: actaully we should check using Autoconf if\n+        #     the compiler supports this option.\n+        ;;\n+    esac\n+fi\n \n case \"${target_optspace}:${host}\" in\n   yes:*)\n@@ -48,7 +54,7 @@ esac\n \n case \"${host}\" in\n   mips-tx39-*|mipstx39-unknown-*)\n-\tboehm_gc_cflags=\"${boehm_gc_cflags} -G 0\"\n+\tgc_cflags=\"${gc_cflags} -G 0\"\n \t;;\n   *)\n \t;;"}, {"sha": "99686242214cf0595237cbe089dde60dc9e31d4a", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 153, "deletions": 10, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -73,10 +73,10 @@ case \"$THREADS\" in\n     THREADS=posix\n     THREADLIBS=-lpthread\n     case \"$host\" in\n-     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* )\n+     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* | alpha-*-linux*)\n \tAC_DEFINE(GC_LINUX_THREADS)\n \tAC_DEFINE(_REENTRANT)\n-        if test \"${enable_parallel_mark}\"; then\n+        if test \"${enable_parallel_mark}\" = yes; then\n \t  AC_DEFINE(PARALLEL_MARK)\n \tfi\n \tAC_DEFINE(THREAD_LOCAL_ALLOC)\n@@ -85,6 +85,10 @@ case \"$THREADS\" in\n \tAC_DEFINE(GC_LINUX_THREADS)\n \tAC_DEFINE(_REENTRANT)\n \t;;\n+     *-*-aix*)\n+\tAC_DEFINE(GC_AIX_THREADS)\n+\tAC_DEFINE(_REENTRANT)\n+\t;;\n      *-*-hpux*)\n \tAC_MSG_WARN(\"Only HP/UX 11 threads are supported.\")\n \tAC_DEFINE(GC_HPUX_THREADS)\n@@ -109,16 +113,52 @@ case \"$THREADS\" in\n \tAC_DEFINE(GC_IRIX_THREADS)\n \t;;\n      *-*-cygwin*)\n-\tTHREADLIBS=\n+\tAC_DEFINE(GC_WIN32_THREADS)\n+\t;;\n+     *-*-darwin*)\n+\tAC_DEFINE(GC_DARWIN_THREADS)\n+\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n+\tif test \"${enable_parallel_mark}\" = yes; then\n+\t  AC_DEFINE(PARALLEL_MARK)\n+\tfi\n+\t;;\n+     *-*-osf*)\n+\tAC_DEFINE(GC_OSF1_THREADS)\n+        if test \"${enable_parallel_mark}\" = yes; then\n+\t  AC_DEFINE(PARALLEL_MARK)\n+\t  AC_DEFINE(THREAD_LOCAL_ALLOC)\n+\t  # May want to enable it in other cases, too.\n+\t  # Measurements havent yet been done.\n+\tfi\n+\tINCLUDES=\"$INCLUDES -pthread\"\n+\tTHREADLIBS=\"-lpthread -lrt\"\n \t;;\n     esac\n     ;;\n  win32)\n     AC_DEFINE(GC_WIN32_THREADS)\n+    dnl Wine getenv may not return NULL for missing entry\n     AC_DEFINE(NO_GETENV)\n-    if test $enable_shared = yes; then\n-      AC_DEFINE(GC_DLL)\n+    ;;\n+ dgux386)\n+    THREADS=dgux386\n+AC_MSG_RESULT($THREADLIBS)\n+    # Use pthread GCC  switch\n+    THREADLIBS=-pthread\n+    if test \"${enable_parallel_mark}\" = yes; then\n+        AC_DEFINE(PARALLEL_MARK)\n     fi\n+    AC_DEFINE(THREAD_LOCAL_ALLOC)\n+    AC_DEFINE(GC_DGUX386_THREADS)\n+    AC_DEFINE(DGUX_THREADS)\n+    # Enable _POSIX4A_DRAFT10_SOURCE with flag -pthread\n+    INCLUDES=\"-pthread $INCLUDES\"\n+    ;;\n+ aix)\n+    THREADS=posix\n+    THREADLIBS=-lpthread\n+    AC_DEFINE(GC_AIX_THREADS)\n+    AC_DEFINE(_REENTRANT)\n     ;;\n  decosf1 | irix | mach | os2 | solaris | dce | vxworks)\n     AC_MSG_ERROR(thread package $THREADS not yet supported)\n@@ -129,7 +169,22 @@ case \"$THREADS\" in\n esac\n AC_SUBST(THREADLIBS)\n \n-AC_CHECK_LIB(dl, dlopen, EXTRA_TEST_LIBS=\"$EXTRA_TEST_LIBS -ldl\")\n+case \"$host\" in \n+   powerpc-*-darwin*)\n+      powerpc_darwin=true\n+      ;;\n+esac\n+AM_CONDITIONAL(POWERPC_DARWIN,test x$powerpc_darwin = xtrue)\n+\n+# We never want libdl on darwin. It is a fake libdl that just ends up making\n+# dyld calls anyway\n+case \"$host\" in\n+  *-*-darwin*) ;;\n+  *) \n+    AC_CHECK_LIB(dl, dlopen, EXTRA_TEST_LIBS=\"$EXTRA_TEST_LIBS -ldl\")\n+    ;;\n+esac\n+\n AC_SUBST(EXTRA_TEST_LIBS)\n \n target_all=libgcjgc.la\n@@ -147,6 +202,9 @@ TARGET_ECOS=\"$with_ecos\"\n )\n \n addobjs=\n+addlibs=\n+addincludes=\n+addtests=\n CXXINCLUDES=\n case \"$TARGET_ECOS\" in\n    no)\n@@ -157,21 +215,46 @@ case \"$TARGET_ECOS\" in\n       addobjs=\"$addobjs ecos.lo\"\n       ;;\n esac\n+\n+if test \"${enable_cplusplus}\" = yes; then\n+      addincludes=\"$addincludes include/gc_cpp.h include/gc_allocator.h\"\n+      addtests=\"$addtests test_cpp\"\n+fi\n+\n+AM_CONDITIONAL(CPLUSPLUS, test \"${enable_cplusplus}\" = yes)\n+\n AC_SUBST(CXX)\n \n AC_SUBST(INCLUDES)\n AC_SUBST(CXXINCLUDES)\n \n+# Configuration of shared libraries\n+#\n+AC_MSG_CHECKING(whether to build shared libraries)\n+AC_ENABLE_SHARED\n+\n+case \"$host\" in\n+ alpha-*-openbsd*)\n+     enable_shared=no\n+     AC_MSG_RESULT(no)\n+     ;;\n+ *)\n+     AC_MSG_RESULT(yes)\n+     ;;\n+esac\n+\n+# Configuration of machine-dependent code\n+#\n+AC_MSG_CHECKING(which machine-dependent code should be used) \n machdep=\n case \"$host\" in\n  alpha*-*-openbsd*)\n     machdep=\"alpha_mach_dep.lo\"\n     if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n        AC_MSG_WARN(OpenBSD/Alpha without dlopen(). Shared library support is disabled)\n-       AM_DISABLE_SHARED\n     fi\n     ;;\n- alpha*-*-*)\n+ alpha*-*-linux*)\n     machdep=\"alpha_mach_dep.lo\"\n     ;;\n  i?86-*-solaris2.[[89]]*)\n@@ -185,12 +268,17 @@ case \"$host\" in\n  mips-dec-ultrix*)\n     machdep=\"mips_ultrix_mach-dep.lo\"\n     ;;\n- mips*-*-linux*)\n+ mips-nec-sysv*|mips-unknown-sysv*)\n     ;;\n+ mips*-*-linux*) \n+    ;; \n  mips-*-*)\n     machdep=\"mips_sgi_mach_dep.lo\"\n     AC_DEFINE(NO_EXECUTE_PERMISSION)\n     ;;\n+ sparc-*-netbsd*)\n+    machdep=\"sparc_netbsd_mach_dep.lo\"\n+    ;;\n  sparc-sun-solaris2.3*)\n     machdep=\"sparc_mach_dep.lo\"\n     AC_DEFINE(SUNOS53_SHARED_LIB)\n@@ -203,16 +291,65 @@ case \"$host\" in\n     ;;\n esac\n if test x\"$machdep\" = x; then\n+AC_MSG_RESULT($machdep)\n    machdep=\"mach_dep.lo\"\n fi\n addobjs=\"$addobjs $machdep\"\n AC_SUBST(addobjs)\n+AC_SUBST(addincludes)\n+AC_SUBST(addlibs)\n+AC_SUBST(addtests)\n+\n+AC_PROG_LIBTOOL\n+\n+#\n+# Check for AViiON Machines running DGUX\n+#\n+AC_MSG_CHECKING(if host is AViiON running DGUX)\n+ac_is_dgux=no\n+AC_CHECK_HEADER(sys/dg_sys_info.h,\n+[ac_is_dgux=yes;])\n+\n+AC_MSG_RESULT($ac_is_dgux) \n+    ## :GOTCHA: we do not check anything but sys/dg_sys_info.h\n+if test $ac_is_dgux = yes; then\n+    if test \"$enable_full_debug\" = \"yes\"; then\n+      CFLAGS=\"-g -mstandard -DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+      CXXFLAGS=\"-g -mstandard -DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+    else\n+      CFLAGS=\"-DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+      CXXFLAGS=\"-DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n+    fi\n+    AC_SUBST(CFLAGS)\n+    AC_SUBST(CXXFLAGS)\n+fi\n+\n+dnl We use these options to decide which functions to include.\n+AC_ARG_WITH(target-subdir,\n+[  --with-target-subdir=SUBDIR\n+                          configuring with a cross compiler])\n+AC_ARG_WITH(cross-host,\n+[  --with-cross-host=HOST  configuring with a cross compiler])\n+\n+# automake wants to see AC_EXEEXT.  But we don't need it.  And having\n+# it is actually a problem, because the compiler we're passed can't\n+# necessarily do a full link.  So we fool automake here.\n+if false; then\n+  # autoconf 2.50 runs AC_EXEEXT by default, and the macro expands\n+  # to nothing, so nothing would remain between `then' and `fi' if it\n+  # were not for the `:' below.\n+  :\n+  AC_EXEEXT\n+fi\n \n dnl As of 4.13a2, the collector will not properly work on Solaris when\n dnl built with gcc and -O.  So we remove -O in the appropriate case.\n+dnl\n+AC_MSG_CHECKING(whether Solaris gcc optimization fix is necessary)\n case \"$host\" in\n- sparc-sun-solaris2*)\n+ sparc-sun-solaris2*|*aix*)\n     if test \"$GCC\" = yes; then\n+       AC_MSG_RESULT(yes)\n        new_CFLAGS=\n        for i in $CFLAGS; do\n \t  case \"$i\" in\n@@ -224,8 +361,11 @@ case \"$host\" in\n \t  esac\n        done\n        CFLAGS=\"$new_CFLAGS\"\n+    else\n+       AC_MSG_RESULT(no)\n     fi\n     ;;\n+ *) AC_MSG_RESULT(no) ;;\n esac\n \n dnl We need to override the top-level CFLAGS.  This is how we do it.\n@@ -267,6 +407,9 @@ AC_ARG_ENABLE(full-debug,\n \tAC_MSG_WARN(\"Client must not use -fomit-frame-pointer.\")\n \tAC_DEFINE(SAVE_CALL_COUNT, 8)\n       ;;\n+      i[3456]86-*-dgux*)\n+\tAC_DEFINE(MAKE_BACK_GRAPH)\n+      ;;\n     esac ]\n   fi)\n "}, {"sha": "d83f4067de76dda23893f0f9575db9f084bb6fea", "filename": "boehm-gc/cord/cordbscs.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fcord%2Fcordbscs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fcord%2Fcordbscs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordbscs.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -219,7 +219,7 @@ CORD CORD_cat_char_star(CORD x, const char * y, size_t leny)\n     \tresult->len = result_len;\n     \tresult->left = x;\n     \tresult->right = y;\n-    \tif (depth > MAX_DEPTH) {\n+    \tif (depth >= MAX_DEPTH) {\n     \t    return(CORD_balance((CORD)result));\n     \t} else {\n     \t    return((CORD) result);\n@@ -260,7 +260,11 @@ CORD CORD_cat(CORD x, CORD y)\n     \tresult->len = result_len;\n     \tresult->left = x;\n     \tresult->right = y;\n-    \treturn((CORD) result);\n+    \tif (depth >= MAX_DEPTH) {\n+    \t    return(CORD_balance((CORD)result));\n+    \t} else {\n+    \t    return((CORD) result);\n+    \t}\n     }\n }\n "}, {"sha": "6ecc00e841076f4d4944cfd482e038481159f658", "filename": "boehm-gc/cord/cordprnt.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -233,7 +233,7 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n \t\t\tif (width == NONE && prec == NONE) {\n \t\t\t    register char c;\n \n-\t\t\t    c = va_arg(args, int);\n+\t\t\t    c = (char)va_arg(args, int);\n \t\t\t    CORD_ec_append(result, c);\n \t\t\t    goto done;\n \t\t\t}\n@@ -255,12 +255,18 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n             \t/* Use standard sprintf to perform conversion */\n             \t{\n             \t    register char * buf;\n-            \t    va_list vsprintf_args = args;\n-            \t    \t/* The above does not appear to be sanctioned\t*/\n-            \t    \t/* by the ANSI C standard.\t\t\t*/\n+            \t    va_list vsprintf_args;\n             \t    int max_size = 0;\n             \t    int res;\n-            \t    \t\n+#\t\t    ifdef __va_copy\n+                      __va_copy(vsprintf_args, args);\n+#\t\t    else\n+#\t\t      if defined(__GNUC__) /* and probably in other cases */\n+                        va_copy(vsprintf_args, args);\n+#\t\t      else\n+\t\t\tvsprintf_args = args;\n+#\t\t      endif\n+#\t\t    endif\n             \t    if (width == VARIABLE) width = va_arg(args, int);\n             \t    if (prec == VARIABLE) prec = va_arg(args, int);\n             \t    if (width != NONE) max_size = width;"}, {"sha": "0bbd676a3355d226eaf9e3d56895c7b9f6c95340", "filename": "boehm-gc/cord/de_win.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fcord%2Fde_win.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fcord%2Fde_win.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -249,7 +249,7 @@ LRESULT CALLBACK WndProc (HWND hwnd, UINT message,\n \n                case IDM_HELPABOUT:\n                   if( DialogBox( hInstance, \"ABOUTBOX\",\n-                                 hwnd, lpfnAboutBox ) );\n+                                 hwnd, lpfnAboutBox ) )\n                      InvalidateRect( hwnd, NULL, TRUE );\n                   return( 0 );\n \t       case IDM_HELPCONTENTS:"}, {"sha": "f640930d90184900b57834afdea257885ad63429", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 130, "deletions": 23, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -60,7 +60,7 @@ ptr_t p;\n # include <stdlib.h>\n \n # if defined(LINUX) || defined(SUNOS4) || defined(SUNOS5) \\\n-     || defined(HPUX) || defined(IRIX) || defined(OSF1)\n+     || defined(HPUX) || defined(IRIX5) || defined(OSF1)\n #   define RANDOM() random()\n # else\n #   define RANDOM() (long)rand()\n@@ -228,6 +228,8 @@ ptr_t p;\n     \n #endif /* KEEP_BACK_PTRS */\n \n+# define CROSSES_HBLK(p, sz) \\\n+\t(((word)(p + sizeof(oh) + sz - 1) ^ (word)p) >= HBLKSIZE)\n /* Store debugging info into p.  Return displaced pointer. */\n /* Assumes we don't hold allocation lock.\t\t   */\n ptr_t GC_store_debug_info(p, sz, string, integer)\n@@ -243,6 +245,8 @@ word integer;\n     /* But that's expensive.  And this way things should only appear\t*/\n     /* inconsistent while we're in the handler.\t\t\t\t*/\n     LOCK();\n+    GC_ASSERT(GC_size(p) >= sizeof(oh) + sz);\n+    GC_ASSERT(!(SMALL_OBJ(sz) && CROSSES_HBLK(p, sz)));\n #   ifdef KEEP_BACK_PTRS\n       ((oh *)p) -> oh_back_ptr = HIDE_BACK_PTR(NOT_MARKED);\n #   endif\n@@ -275,6 +279,8 @@ word integer;\n     /* There is some argument that we should disable signals here.\t*/\n     /* But that's expensive.  And this way things should only appear\t*/\n     /* inconsistent while we're in the handler.\t\t\t\t*/\n+    GC_ASSERT(GC_size(p) >= sizeof(oh) + sz);\n+    GC_ASSERT(!(SMALL_OBJ(sz) && CROSSES_HBLK(p, sz)));\n #   ifdef KEEP_BACK_PTRS\n       ((oh *)p) -> oh_back_ptr = HIDE_BACK_PTR(NOT_MARKED);\n #   endif\n@@ -324,10 +330,11 @@ ptr_t p;\n {\n     register oh * ohdr = (oh *)GC_base(p);\n     \n+    GC_ASSERT(!I_HOLD_LOCK());\n     GC_err_printf1(\"0x%lx (\", ((unsigned long)ohdr + sizeof(oh)));\n     GC_err_puts(ohdr -> oh_string);\n #   ifdef SHORT_DBG_HDRS\n-      GC_err_printf1(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int));\n+      GC_err_printf1(\":%ld)\\n\", (unsigned long)(ohdr -> oh_int));\n #   else\n       GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n           \t\t\t        (unsigned long)(ohdr -> oh_sz));\n@@ -342,6 +349,7 @@ ptr_t p;\n     ptr_t p;\n # endif\n {\n+    GC_ASSERT(!I_HOLD_LOCK());\n     if (GC_HAS_DEBUG_INFO(p)) {\n \tGC_print_obj(p);\n     } else {\n@@ -355,6 +363,7 @@ ptr_t p, clobbered_addr;\n {\n     register oh * ohdr = (oh *)GC_base(p);\n     \n+    GC_ASSERT(!I_HOLD_LOCK());\n     GC_err_printf2(\"0x%lx in object at 0x%lx(\", (unsigned long)clobbered_addr,\n     \t\t\t\t\t        (unsigned long)p);\n     if (clobbered_addr <= (ptr_t)(&(ohdr -> oh_sz))\n@@ -376,14 +385,18 @@ ptr_t p, clobbered_addr;\n \n void GC_check_heap_proc GC_PROTO((void));\n \n+void GC_print_all_smashed_proc GC_PROTO((void));\n+\n void GC_do_nothing() {}\n \n void GC_start_debugging()\n {\n #   ifndef SHORT_DBG_HDRS\n       GC_check_heap = GC_check_heap_proc;\n+      GC_print_all_smashed = GC_print_all_smashed_proc;\n #   else\n       GC_check_heap = GC_do_nothing;\n+      GC_print_all_smashed = GC_do_nothing;\n #   endif\n     GC_print_heap_obj = GC_debug_print_heap_obj_proc;\n     GC_debugging_started = TRUE;\n@@ -429,6 +442,62 @@ void GC_start_debugging()\n     return (GC_store_debug_info(result, (word)lb, s, (word)i));\n }\n \n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc_ignore_off_page(size_t lb, GC_EXTRA_PARAMS)\n+# else\n+    GC_PTR GC_debug_malloc_ignore_off_page(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+#   ifdef GC_ADD_CALLER\n+\t--> GC_ADD_CALLER not implemented for K&R C\n+#   endif\n+# endif\n+{\n+    GC_PTR result = GC_malloc_ignore_off_page(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC_debug_malloc_ignore_off_page(%ld) returning NIL (\",\n+        \t       (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+    \tGC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+# ifdef __STDC__\n+    GC_PTR GC_debug_malloc_atomic_ignore_off_page(size_t lb, GC_EXTRA_PARAMS)\n+# else\n+    GC_PTR GC_debug_malloc_atomic_ignore_off_page(lb, s, i)\n+    size_t lb;\n+    char * s;\n+    int i;\n+#   ifdef GC_ADD_CALLER\n+\t--> GC_ADD_CALLER not implemented for K&R C\n+#   endif\n+# endif\n+{\n+    GC_PTR result = GC_malloc_atomic_ignore_off_page(lb + DEBUG_BYTES);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC_debug_malloc_atomic_ignore_off_page(%ld)\"\n+\t\t       \" returning NIL (\", (unsigned long) lb);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(0);\n+    }\n+    if (!GC_debugging_started) {\n+    \tGC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n # ifdef DBG_HDRS_ALL\n /* \n  * An allocation function for internal use.\n@@ -447,7 +516,7 @@ void GC_start_debugging()\n         \t       (unsigned long) lb);\n         return(0);\n     }\n-    ADD_CALL_CHAIN(result, ra);\n+    ADD_CALL_CHAIN(result, GC_RETURN_ADDR);\n     return (GC_store_debug_info_inner(result, (word)lb, \"INTERNAL\", (word)0));\n   }\n \n@@ -461,7 +530,7 @@ void GC_start_debugging()\n         \t       (unsigned long) lb);\n         return(0);\n     }\n-    ADD_CALL_CHAIN(result, ra);\n+    ADD_CALL_CHAIN(result, GC_RETURN_ADDR);\n     return (GC_store_debug_info_inner(result, (word)lb, \"INTERNAL\", (word)0));\n   }\n # endif\n@@ -592,7 +661,7 @@ GC_PTR p;\n     int i;\n # endif\n {\n-    GC_PTR result = GC_malloc_uncollectable(lb + DEBUG_BYTES);\n+    GC_PTR result = GC_malloc_uncollectable(lb + UNCOLLECTABLE_DEBUG_BYTES);\n     \n     if (result == 0) {\n         GC_err_printf1(\"GC_debug_malloc_uncollectable(%ld) returning NIL (\",\n@@ -618,7 +687,8 @@ GC_PTR p;\n     int i;\n # endif\n {\n-    GC_PTR result = GC_malloc_atomic_uncollectable(lb + DEBUG_BYTES);\n+    GC_PTR result =\n+\tGC_malloc_atomic_uncollectable(lb + UNCOLLECTABLE_DEBUG_BYTES);\n     \n     if (result == 0) {\n         GC_err_printf1(\n@@ -774,6 +844,45 @@ void GC_debug_free_inner(GC_PTR p)\n }\n \n #ifndef SHORT_DBG_HDRS\n+\n+/* List of smashed objects.  We defer printing these, since we can't\t*/\n+/* always print them nicely with the allocation lock held.\t\t*/\n+/* We put them here instead of in GC_arrays, since it may be useful to\t*/\n+/* be able to look at them with the debugger.\t\t\t\t*/\n+#define MAX_SMASHED 20\n+ptr_t GC_smashed[MAX_SMASHED];\n+unsigned GC_n_smashed = 0;\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_add_smashed(ptr_t smashed)\n+# else\n+    void GC_add_smashed(smashed)\n+    ptr_t smashed;\n+#endif\n+{\n+    GC_ASSERT(GC_is_marked(GC_base(smashed)));\n+    GC_smashed[GC_n_smashed] = smashed;\n+    if (GC_n_smashed < MAX_SMASHED - 1) ++GC_n_smashed;\n+      /* In case of overflow, we keep the first MAX_SMASHED-1\t*/\n+      /* entries plus the last one.\t\t\t\t*/\n+    GC_have_errors = TRUE;\n+}\n+\n+/* Print all objects on the list.  Clear the list.\t*/\n+void GC_print_all_smashed_proc ()\n+{\n+    unsigned i;\n+\n+    GC_ASSERT(!I_HOLD_LOCK());\n+    if (GC_n_smashed == 0) return;\n+    GC_err_printf0(\"GC_check_heap_block: found smashed heap objects:\\n\");\n+    for (i = 0; i < GC_n_smashed; ++i) {\n+        GC_print_smashed_obj(GC_base(GC_smashed[i]), GC_smashed[i]);\n+\tGC_smashed[i] = 0;\n+    }\n+    GC_n_smashed = 0;\n+}\n+\n /* Check all marked objects in the given block for validity */\n /*ARGSUSED*/\n # if defined(__STDC__) || defined(__cplusplus)\n@@ -802,11 +911,7 @@ void GC_debug_free_inner(GC_PTR p)\n \t        && GC_HAS_DEBUG_INFO((ptr_t)p)) {\n \t        ptr_t clobbered = GC_check_annotated_obj((oh *)p);\n \t        \n-\t        if (clobbered != 0) {\n-\t            GC_err_printf0(\n-\t                \"GC_check_heap_block: found smashed location at \");\n-        \t    GC_print_smashed_obj((ptr_t)p, clobbered);\n-\t        }\n+\t        if (clobbered != 0) GC_add_smashed(clobbered);\n \t    }\n \t    word_no += sz;\n \t    p += sz;\n@@ -819,9 +924,11 @@ void GC_debug_free_inner(GC_PTR p)\n void GC_check_heap_proc()\n {\n #   ifndef SMALL_CONFIG\n-\tif (sizeof(oh) & (2 * sizeof(word) - 1) != 0) {\n-\t    ABORT(\"Alignment problem: object header has inappropriate size\\n\");\n-\t}\n+#     ifdef ALIGN_DOUBLE\n+        GC_STATIC_ASSERT((sizeof(oh) & (2 * sizeof(word) - 1)) == 0);\n+#     else\n+        GC_STATIC_ASSERT((sizeof(oh) & (sizeof(word) - 1)) == 0);\n+#     endif\n #   endif\n     GC_apply_to_all_blocks(GC_check_heap_block, (word)0);\n }\n@@ -842,12 +949,12 @@ struct closure {\n # endif\n {\n     struct closure * result =\n-#\t\tifdef DBG_HDRS_ALL\n-    \t\t  (struct closure *) GC_debug_malloc(sizeof (struct closure),\n-\t\t\t\t\t\t     GC_EXTRAS);\n-#\t\telse\n-    \t\t  (struct closure *) GC_malloc(sizeof (struct closure));\n-#\t\tendif\n+#   ifdef DBG_HDRS_ALL\n+      (struct closure *) GC_debug_malloc(sizeof (struct closure),\n+\t\t\t\t         GC_EXTRAS);\n+#   else\n+      (struct closure *) GC_malloc(sizeof (struct closure));\n+#   endif\n     \n     result -> cl_fn = fn;\n     result -> cl_data = data;\n@@ -908,7 +1015,7 @@ GC_PTR *ocd;\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n-\t    \"GC_register_finalizer called with non-base-pointer 0x%lx\\n\",\n+\t    \"GC_debug_register_finalizer called with non-base-pointer 0x%lx\\n\",\n \t    obj);\n     }\n     if (0 == fn) {\n@@ -940,7 +1047,7 @@ GC_PTR *ocd;\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n-\t  \"GC_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n+\t  \"GC_debug_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n \t  obj);\n     }\n     if (0 == fn) {\n@@ -973,7 +1080,7 @@ GC_PTR *ocd;\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n-\t    \"GC_register_finalizer_ignore_self called with non-base-pointer 0x%lx\\n\",\n+\t    \"GC_debug_register_finalizer_ignore_self called with non-base-pointer 0x%lx\\n\",\n \t    obj);\n     }\n     if (0 == fn) {"}, {"sha": "91446305581d47665e67c3ae90f4e0cac0c517ea", "filename": "boehm-gc/doc/Makefile.am", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fdoc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fdoc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FMakefile.am?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,27 +0,0 @@\n-# \n-# \n-# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n-# \n-# Permission is hereby granted to use or copy this program\n-# for any purpose,  provided the above notices are retained on all copies.\n-# Permission to modify the code and to distribute modified code is granted,\n-# provided the above notices are retained, and a notice that the code was\n-# modified is included with the above copyright notice.\n-#\n-# Modified by: Grzegorz Jakacki <jakacki at acm dot org>\n-\n-## Process this file with automake to produce Makefile.in.\n-\n-# installed documentation\n-#\n-dist_pkgdata_DATA = barrett_diagram debugging.html gc.man \\\n-    gcdescr.html README README.amiga README.arm.cross \\\n-    README.autoconf README.changes README.contributors \\\n-    README.cords README.DGUX386 README.dj README.environment \\\n-    README.ews4800 README.hp README.linux README.Mac \\\n-    README.MacOSX README.macros README.OS2 README.rs6000 \\\n-    README.sgi README.solaris2 README.uts README.win32 \\\n-    tree.html leak.html gcinterface.html scale.html \\\n-    README.darwin\n-"}, {"sha": "9bf1ff5feadb63c512cd7b5042f6854487b5ccda", "filename": "boehm-gc/doc/Makefile.in", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fdoc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fdoc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FMakefile.in?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,282 +0,0 @@\n-# Makefile.in generated by automake 1.6.3 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n-# Free Software Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-# \n-# \n-# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n-# \n-# Permission is hereby granted to use or copy this program\n-# for any purpose,  provided the above notices are retained on all copies.\n-# Permission to modify the code and to distribute modified code is granted,\n-# provided the above notices are retained, and a notice that the code was\n-# modified is included with the above copyright notice.\n-#\n-# Modified by: Grzegorz Jakacki <jakacki at acm dot org>\n-SHELL = @SHELL@\n-\n-srcdir = @srcdir@\n-top_srcdir = @top_srcdir@\n-VPATH = @srcdir@\n-prefix = @prefix@\n-exec_prefix = @exec_prefix@\n-\n-bindir = @bindir@\n-sbindir = @sbindir@\n-libexecdir = @libexecdir@\n-datadir = @datadir@\n-sysconfdir = @sysconfdir@\n-sharedstatedir = @sharedstatedir@\n-localstatedir = @localstatedir@\n-libdir = @libdir@\n-infodir = @infodir@\n-mandir = @mandir@\n-includedir = @includedir@\n-oldincludedir = /usr/include\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-top_builddir = ..\n-\n-ACLOCAL = @ACLOCAL@\n-AUTOCONF = @AUTOCONF@\n-AUTOMAKE = @AUTOMAKE@\n-AUTOHEADER = @AUTOHEADER@\n-\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-INSTALL = @INSTALL@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_DATA = @INSTALL_DATA@\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = @program_transform_name@\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-host_alias = @host_alias@\n-host_triplet = @host@\n-\n-EXEEXT = @EXEEXT@\n-OBJEXT = @OBJEXT@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-AMTAR = @AMTAR@\n-AR = @AR@\n-AS = @AS@\n-AWK = @AWK@\n-CC = @CC@\n-CCAS = @CCAS@\n-CCASFLAGS = @CCASFLAGS@\n-CFLAGS = @CFLAGS@\n-CXX = @CXX@\n-CXXFLAGS = @CXXFLAGS@\n-CXXINCLUDES = @CXXINCLUDES@\n-DEPDIR = @DEPDIR@\n-DLLTOOL = @DLLTOOL@\n-ECHO = @ECHO@\n-EXTRA_TEST_LIBS = @EXTRA_TEST_LIBS@\n-GC_CFLAGS = @GC_CFLAGS@\n-GC_VERSION = @GC_VERSION@\n-INCLUDES = @INCLUDES@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LIBTOOL = @LIBTOOL@\n-LN_S = @LN_S@\n-MAINT = @MAINT@\n-MY_CFLAGS = @MY_CFLAGS@\n-OBJDUMP = @OBJDUMP@\n-PACKAGE = @PACKAGE@\n-RANLIB = @RANLIB@\n-STRIP = @STRIP@\n-THREADLIBS = @THREADLIBS@\n-VERSION = @VERSION@\n-addincludes = @addincludes@\n-addlibs = @addlibs@\n-addobjs = @addobjs@\n-addtests = @addtests@\n-am__include = @am__include@\n-am__quote = @am__quote@\n-install_sh = @install_sh@\n-target_all = @target_all@\n-\n-# installed documentation\n-#\n-dist_pkgdata_DATA = barrett_diagram debugging.html gc.man \\\n-    gcdescr.html README README.amiga README.arm.cross \\\n-    README.autoconf README.changes README.contributors \\\n-    README.cords README.DGUX386 README.dj README.environment \\\n-    README.ews4800 README.hp README.linux README.Mac \\\n-    README.MacOSX README.macros README.OS2 README.rs6000 \\\n-    README.sgi README.solaris2 README.uts README.win32 \\\n-    tree.html leak.html gcinterface.html scale.html \\\n-    README.darwin\n-\n-subdir = doc\n-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n-CONFIG_CLEAN_FILES =\n-DIST_SOURCES =\n-DATA = $(dist_pkgdata_DATA)\n-\n-DIST_COMMON = README $(dist_pkgdata_DATA) Makefile.am Makefile.in\n-all: all-am\n-\n-.SUFFIXES:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)\n-\tcd $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --gnu  doc/Makefile\n-Makefile: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.in  $(top_builddir)/config.status\n-\tcd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool\n-uninstall-info-am:\n-dist_pkgdataDATA_INSTALL = $(INSTALL_DATA)\n-install-dist_pkgdataDATA: $(dist_pkgdata_DATA)\n-\t@$(NORMAL_INSTALL)\n-\t$(mkinstalldirs) $(DESTDIR)$(pkgdatadir)\n-\t@list='$(dist_pkgdata_DATA)'; for p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  f=\"`echo $$p | sed -e 's|^.*/||'`\"; \\\n-\t  echo \" $(dist_pkgdataDATA_INSTALL) $$d$$p $(DESTDIR)$(pkgdatadir)/$$f\"; \\\n-\t  $(dist_pkgdataDATA_INSTALL) $$d$$p $(DESTDIR)$(pkgdatadir)/$$f; \\\n-\tdone\n-\n-uninstall-dist_pkgdataDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(dist_pkgdata_DATA)'; for p in $$list; do \\\n-\t  f=\"`echo $$p | sed -e 's|^.*/||'`\"; \\\n-\t  echo \" rm -f $(DESTDIR)$(pkgdatadir)/$$f\"; \\\n-\t  rm -f $(DESTDIR)$(pkgdatadir)/$$f; \\\n-\tdone\n-tags: TAGS\n-TAGS:\n-\n-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n-\n-top_distdir = ..\n-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)\n-\n-distdir: $(DISTFILES)\n-\t@list='$(DISTFILES)'; for file in $$list; do \\\n-\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  dir=`echo \"$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n-\t  if test \"$$dir\" != \"$$file\" && test \"$$dir\" != \".\"; then \\\n-\t    dir=\"/$$dir\"; \\\n-\t    $(mkinstalldirs) \"$(distdir)$$dir\"; \\\n-\t  else \\\n-\t    dir=''; \\\n-\t  fi; \\\n-\t  if test -d $$d/$$file; then \\\n-\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n-\t      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \\\n-\t    fi; \\\n-\t    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \\\n-\t  else \\\n-\t    test -f $(distdir)/$$file \\\n-\t    || cp -p $$d/$$file $(distdir)/$$file \\\n-\t    || exit 1; \\\n-\t  fi; \\\n-\tdone\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(DATA)\n-\n-installdirs:\n-\t$(mkinstalldirs) $(DESTDIR)$(pkgdatadir)\n-\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-rm -f Makefile $(CONFIG_CLEAN_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-libtool mostlyclean-am\n-\n-distclean: distclean-am\n-\n-distclean-am: clean-am distclean-generic distclean-libtool\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am: install-dist_pkgdataDATA\n-\n-install-exec-am:\n-\n-install-info: install-info-am\n-\n-install-man:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n-\n-uninstall-am: uninstall-dist_pkgdataDATA uninstall-info-am\n-\n-.PHONY: all all-am check check-am clean clean-generic clean-libtool \\\n-\tdistclean distclean-generic distclean-libtool distdir dvi \\\n-\tdvi-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dist_pkgdataDATA install-exec \\\n-\tinstall-exec-am install-info install-info-am install-man \\\n-\tinstall-strip installcheck installcheck-am installdirs \\\n-\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n-\tmostlyclean-generic mostlyclean-libtool uninstall uninstall-am \\\n-\tuninstall-dist_pkgdataDATA uninstall-info-am\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "29d954f023ee9f2ea6dc14f50c41bd34a33a5a20", "filename": "boehm-gc/doc/README", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,16 +1,17 @@\n Copyright (c) 1988, 1989 Hans-J. Boehm, Alan J. Demers\n Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n-Copyright (c) 1999-2001 by Hewlett-Packard Company. All rights reserved.\n+Copyright (c) 1999-2003 by Hewlett-Packard Company. All rights reserved.\n \n The file linux_threads.c is also\n Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n \n The files Makefile.am, and configure.in are\n Copyright (c) 2001 by Red Hat Inc. All rights reserved.\n \n-The files config.guess and a few others are copyrighted by the Free\n-Software Foundation.\n+Several files supporting GNU-style builds are copyrighted by the Free\n+Software Foundation, and carry a different license from that given\n+below.\n \n THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -27,7 +28,7 @@ are GPL'ed, but with an exception that should cover all uses in the\n collector.  (If you are concerned about such things, I recommend you look\n at the notice in config.guess or ltmain.sh.)\n \n-This is version 6.1alpha3 of a conservative garbage collector for C and C++.\n+This is version 6.3alpha1 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n \n@@ -228,10 +229,12 @@ and several of those are compatible with the collector.\n or equivalent is supplied.  Many of these have separate README.system\n files.\n \n-  Dynamic libraries are completely supported only under SunOS\n+  Dynamic libraries are completely supported only under SunOS/Solaris,\n (and even that support is not functional on the last Sun 3 release),\n-Linux, IRIX 5&6, HP-PA, Win32 (not Win32S) and OSF/1 on DEC AXP machines.\n-On other machines we recommend that you do one of the following:\n+Linux, FreeBSD, NetBSD, IRIX 5&6, HP/UX, Win32 (not Win32S) and OSF/1\n+on DEC AXP machines plus perhaps a few others listed near the top\n+of dyn_load.c.  On other machines we recommend that you do one of\n+the following:\n \n   1) Add dynamic library support (and send us the code).\n   2) Use static versions of the libraries.\n@@ -245,6 +248,8 @@ On other machines we recommend that you do one of the following:\n   In all cases we assume that pointer alignment is consistent with that\n enforced by the standard C compilers.  If you use a nonstandard compiler\n you may have to adjust the alignment parameters defined in gc_priv.h.\n+Note that this may also be an issue with packed records/structs, if those\n+enforce less alignment for pointers.\n \n   A port to a machine that is not byte addressed, or does not use 32 bit\n or 64 bit addresses will require a major effort.  A port to plain MSDOS"}, {"sha": "f5333d51ad6771b17bfe28e6b881583c5ad40f8d", "filename": "boehm-gc/doc/README.MacOSX", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.MacOSX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.MacOSX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.MacOSX?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,27 +1 @@\n-While the GC should work on MacOS X Server, MacOS X and Darwin, I only tested\n-it on MacOS X Server.\n-I've added a PPC assembly version of GC_push_regs(), thus the setjmp() hack is\n-no longer necessary. Incremental collection is supported via mprotect/signal.\n-The current solution isn't really optimal because the signal handler must decode\n-the faulting PPC machine instruction in order to find the correct heap address.\n-Further, it must poke around in the register state which the kernel saved away\n-in some obscure register state structure before it calls the signal handler -\n-needless to say the layout of this structure is no where documented.\n-Threads and dynamic libraries are not yet supported (adding dynamic library\n-support via the low-level dyld API shouldn't be that hard).\n-\n-The original MacOS X port was brought to you by Andrew Stone.\n-\n-\n-June, 1 2000\n-\n-Dietmar Planitzer\n-dave.pl@ping.at\n-\n-Note from Andrew Begel:\n-\n-One more fix to enable gc.a to link successfully into a shared library for\n-MacOS X. You have to add -fno-common to the CFLAGS in the Makefile. MacOSX\n-disallows common symbols in anything that eventually finds its way into a\n-shared library. (I don't completely understand why, but -fno-common seems to\n-work and doesn't mess up the garbage collector's functionality).\n+See README.darwin for the latest Darwin/MacOSX information."}, {"sha": "619ea2e4a4963ffa4536efb014796cd5de2b411f", "filename": "boehm-gc/doc/README.changes", "status": "modified", "additions": 432, "deletions": 4, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1469,8 +1469,439 @@ Since 6.1 alpha2:\n  - Caused the Solaris and Irix thread creation primitives to call\n    GC_init_inner().\n  \n+Since 6.1alpha3:\n+ - Fixed typo in sparc_mach_dep.S, preventing the 64-bit version from\n+   building.  Increased 64-bit heap size limit in test.c slightly, since\n+   a functional SPARC collector seems to slightly exceed the old limits.\n+   (Thanks again to Jeff Sturm.)\n+ - Use NPRGREG in solaris_threads.c, thus printing all registers if things\n+   go wrong.\n+ - Added GC_MARKERS environment variable to allow use of a single marker\n+   thread on an MP without confusing the lock implementation.\n+ - Collect much less aggressively in incremental mode with GC_TIME_UNLIMITED.\n+   This is really a purely generational mode, and we can afford to \n+   postpone the collection until the heap is (nearly) full.\n+ - Remove read() wrapper for MPROTECT_VDB.  It was causing more harm than\n+   good.  It is often no longer needed if system calls avoid writing to\n+   pointerfull heap objects.\n+ - Fix MACOSX test in gcconfig.h. (Thanks to John Clements.)\n+ - Change GC_test_and_set so that it consistently has one argument.\n+   Add spaces to ::: in powerpc assembly code in gc_locks.h.\n+   (Thanks to Ryan Murray.)\n+ - Fixed a formatting error in dbg_mlc.c.  Added prototype to GC_abort()\n+   declaration.   (Thanks to Michael Smith.)\n+ - Removed \"source\" argument to GC_find_start().  Eliminate GC_FIND_START().\n+ - Added win32 recognition code in configure.in.  Changed some of the\n+   dllimport/export defines in gc.h.  (Thanks to Adam Megacz.)\n+ - GC_malloc_many didn't set hb_last_reclaimed when it called \n+   GC_reclaim_generic.  (I'm not sure this matters much, but ...)\n+ - Allocating uncollectable objects with debug information sometimes\n+   allocated objects that were one byte too small, since uncollectable\n+   objects don't have the extra byte added at the end.  (Thanks to\n+   Wink Saville for pointing this out.)\n+ - Added a bit more assertion checking to make sure that gcj objects\n+   on free lists never have a nonzero second word.\n+ - Replaced BCC_MAKEFILE with an up-to-date one.  (Thanks to \n+   Andre Leiradella.)\n+ - Upgraded libtool, cinfigure.in and some related files to hopefully\n+   support NetBSD/SPARC.  (Thanks to Adrian Bunk.)  Unfortunately,\n+   libtool 1.4.2 seemed to be buggy due to missing quotes in several\n+   \"test\" invocations.  Fixed those in the ltmain.sh script.\n+ - Some win32-specific patches, including the introduction of\n+   GC_CreateThread.  (Thanks to Adam Megacz.)\n+ - Merged in gcj changes from Anthony Green to support embedded systems.\n+ - Tried to consistently rename preprocessed assembly files with a capital\n+   .S extension.\n+ - Use alpha_mach_dep.S on ALPHA again.  It doesn't really matter, but this\n+   makes our distribution consistent with the gcc one, avoiding future merge\n+   problems.\n+ - Move GET_MEM definition into gcconfig.h.  Include gcconfig.h slightly\n+   later in gc_priv.h to avoid forward references to ptr_t.\n+ - Add some testing of local allocation to test.c.\n+ - Change definition of INVALID_QTID in specific.h.  The -1 value was used\n+   inconsistently, and too likely to collide with a valid stack address.\n+   Some general clean-up of specific.[ch].  Added assertions.  (Thanks\n+   to Michael Smith for tracking down an intermittent bug to this\n+   general area.  I'm not sure it has been squashed yet, however.)\n+ - On Pthread systems it was not safe to call GC_malloc() between fork()\n+   and exec().  According to the applicable standards, it doesn't appear\n+   to be safe to call malloc() or many other libc functions either, thus\n+   it's not clear this is fixable.  Added experimental support for\n+   -DHANDLE_FORK in linux_threads.c which tries to support it.  It may\n+   succeed if libc does the right thing.  I'm not sure whether it does.\n+   (Thanks to Kenneth Schalk for pointing out this issue.)\n+ - Documented thread local allocation primitives to require an\n+   explicit GC_init call.  GC_init_parallel is no longer declared to\n+   be a constructor function, since that isn't portable and often\n+   seems to lead to initialization order problems.\n+ - Changed gc_cpp.cc and gc_cpp.h in one more attempt to make them\n+   compatible with Visual C++ 6.  (Thanks to Wink Saville for the\n+   patch.)\n+ - Some more patches for Linux on HP PA-RISC.\n+ - Added include/gc_allocator.h.  It implements (hopefully) standard\n+   conforming (as opposed to SGI-style) allocators that allocate\n+   collectable (gc_allocator) or GC-traceable, but not collectable\n+   (traceable_allocator) objects.  This borrows heavily from libstc++,\n+   which borrows heavily from the SGI implementation, this part of\n+   which was written by Matt Austern.  Changed test_cpp.cc to very\n+   minimally test this.\n+ - On Linux/X86, retry mmap with a different start argument.  That should\n+   allow the collector to use more (closer to 3GB) of the address space.\n+   (Thanks to Jeffrey Mark Siskind for tracking this down.)\n+ - Force 64 bit alignment with GCJ support.  (Reflects Bryce McKinley's\n+   patch to the gcc tree.)\n+ - Refined the choice of sa_handler vs. sa_sigaction in GC_dirty_init\n+   to accomodate some glibc5 systems.  (Thanks to Dan Fandrich for the\n+   patch.)\n+ - Compensated for the fact that current versions of glibc set\n+   __libc_stack_end incorrectly on Linux/IA64 while initialization code\n+   is running.  This could cause the collector to miss 16 bytes of\n+   the memory stack if GC_malloc or friends where called before main().\n+ - Mostly integrated Takis Psarogiannakopoulos' port to DG/UX Inix 86.\n+   This will probably take another iteration to work, since his\n+   patch conflicted with the libtool upgrade. \n+ - Added README.arm.cross containing some information about cross-\n+   compiling to an ARM processor from Margaret Fleck.\n+\n+Since 6.1alpha4:\n+ - Added GC_finalizer_mem_freed, and changed some of the code that\n+   decided on heap expansion to look at it.  Memory explicitly\n+   deallocated by finalizers essentially needs to be counted as reclaimed\n+   by the GC.  Otherwise there are cases in which the heap can grow\n+   unboundedly.  (Thanks to Mark Reichert for the test case.)\n+ - Integrated Adam Megacz patches to not scan dynamic libraries if\n+   we are compiling with gcc on win32.  Otherwise we need structured\n+   exception handling to deal with asynchronously unmapped root\n+   segments, and gcc doesn't directly support that.\n+ - Integrated Anthony Green's patch to support Wine.\n+ - GC_OPERATOR_NEW_ARRAY was misspelled OPERATOR_NEW_ARRAY in several\n+   places, including gc_cpp.cc.  (Thanks to Wink Saville for pointing\n+   this out.)\n+ - Integrated Loren James Rittle's Alpha FreeBSD patches.  In\n+   response to Richard Henderson's suggestion, these also\n+   changed the declarations of symbols like _end on many platforms to\n+   that they wouldn't mistakenly be declared as short data symbols.\n+ - Integrated changes from the Debian distribution.  (Thanks to Ryan Murray\n+   for pointing these out.)  Fix C++ comments in POWERPC port.  Add ARM32\n+   incremental GC support.  Get rid of USE_GENERIC_PUSH_REGS for alpha/Linux,\n+   this time for real.  Use va_copy to get rid of cord printf problems\n+   (finally).\n+ - Close file descriptor used to count cpus.  Thanks to Jeff Sturm for\n+   pointing out the omission.\n+ - Don't just drop gcj free lists in GC_start_reclaim, since that can\n+   eventually cause the marker to see a bogus mark descriptor in the \n+   dropped objects.  The usual symptom was a very intermittent segmentation\n+   fault in the marker.  This mattered only if one of the GC_gcj_malloc\n+   variants was used.  (Thanks to Michael Smith, Jeff Sturm, Bryce\n+   McKinley and Tom Tromey for helping to track this down.)\n+ - Fixed Linux and Solaris/64 SPARC configuration.  (Thanks to David Miller,\n+   Jeff Sturm, Tom Tromey, and Christian Joensson.)\n+ - Fixed a typo in strdup definition.  (Thanks to Gerard A Allan.)\n+ - Changed Makefile.direct to invoke $(CC) to assemble alpha_mach_dep.S.\n+   This is needed on Linux.  I'm not sure whether it's better or worse\n+   on Tru64.\n+ - Changed gc_cpp.h once more to declare operator new and friends only in\n+   a Microsoft environment.  This may need further fine tuning.  (Thanks to\n+   Johannes Schmidt for pointing out that the older code breaks on gcc3.0.4.)\n+ - Don't ever override strdup if it's already macro defined.  (Thanks to\n+   Adnan Ali for pointing out the problem.)\n+ - Changed gc_cpp.h yet again to also overload placement new.  Due to the\n+   C++ overloading rules, the other overloaded new operations otherwise hide\n+   placement new, which causes many STL uses to break.  (Thanks to Reza\n+   Shahidi for reporting this, and to Matt Austern for proposing a fix.)\n+ - Integrated cygwin pthreads support from Dan Bonachea.\n+ - Turn on DYNAMIC_LOADING for NetBSD.  (Thanks to Krister Walfridsson.)\n+ - Changed printing code to print more complete GC times.\n+ - Applied Mark Mitchell's Irix patch to correct some bitrot.\n+ - Clarified which object-printing routines in dbg_mlc.c should hold\n+   the allocation lock.  Restructured the code to allow reasonable object\n+   printing with -DREDIRECT_MALLOC.\n+ - Fix the Linux mmap code to always start with 0x1000 as the initial hint.\n+   Minor patches for 64-bit AIX, particularly to STACKBOTTOM.\n+   (Thanks again to Jeffrey Mark Siskind.)\n+ - Renamed \"SUSPENDED\" flag for Solaris threads support to avoid a conflict\n+   with a system header. (Thanks to Philp Brown.)\n+ - Cause win32_threads.c to handle an out of range stack pointer correctly,\n+   though currently with a warning.  (Thanks to Jonathan Clark for\n+   observing that win32 applications may temporarily use the stack\n+   pointer for other purposes, and suggesting a fix.  Unfortunately, it's\n+   not clear that there is a complete solution to this problem.)\n+\n+Since 6.1alpha5:\n+ - Added GC_MAXIMUM_HEAP_SIZE environment variable.\n+ - Fix configure.in for MIPS/LINUX. (Thanks to H.J. Lu.)\n+ - Double page hash table size for -DLARGE_CONFIG.\n+ - Integrated Bo Thorsen's X86-64 support.\n+ - STACKBOTTOM definition for LINUX/MIPS was partially changed back.\n+   (Thanks to H.J. Lu and Hiroshi Kawashima for resolving this.)\n+ - Replaced all occurrences of LINUX_DATA_START in gcconfig.h with\n+   SEARCH_FOR_DATA_START.  It doesn't hurt to falll back to a search.\n+   And __data_start doesn't seem to get defined correctly of the GC\n+   library is loaded with LD_PRELOAD, e.g. for leak detection.\n+ - If the GC_find_leak environment variable is set, do a\n+   atexit(GC_gcollect) to give us at least one chance to detect leaks.\n+   This may report some very benign leaks, but ...\n+ - Addeded REDIRECT_FREE.  It's necessary if we want leak detection with\n+   LD_PRELOAD.\n+ - Defer printing of leaked objects, as for smashed objects.\n+ - Fixed process and descriptor leak in GC_print_callers.  Try for\n+   line number even if we got function name.)\n+ - Ported parallel GC support and thread local allocation to Alpha.\n+   Not yet well-tested.\n+ - Added GC_DUMP_REGULARLY and added finalization statistics to GC_dump().\n+ - Fixed Makefile.am to mention alpha_mach_dep.S instead of the defunct\n+   alpha_mach_dep.s.  (Thanks to Fergus Henderson.)\n+ - Incorporated a change to new_gc_alloc.h, suggested by Johannes Schmidt,\n+   which should make it work with gcc3.1.  (I would still like to encourage\n+   use of gc_allocator.h instead.) \n+ - Use alpha_mach_dep.S only on Linux.  (It's not clear that this is\n+   optimal, but it otherwise didn't build on Tru64.  Thanks to Fergus\n+   Henderson.)\n+ - Added ifdef to guard free() in os_dep.c.  Otherwise we get a\n+   compilation error on Irix.  (Thanks to Dai Sato.)\n+ - Added an experimental version of GC_memalign to mallocx.c.  This can't\n+   always work, since we don't handle alignment requests in the hblk-level\n+   allocator, and we can't handle arbitrary pointer displacements unless\n+   GC_all_interior_pointers is enabled.  But it should work for alignment\n+   requests up to HBLKSIZE.  This is not yet documented in the standard\n+   places.\n+ - Finally debugged the OSF1/Tru64 thread support.  This needs more testing,\n+   since I needed to add a somewhat unconvincing workaround for signal\n+   delivery issues that I don't yet completely understand.  But it does\n+   pass my tests, even in parallel GC mode.  Incremental GC support is\n+   disabled if thread support is enabled, due to the signal issues.\n+ - Eliminated name-space-incorrect definition of _cdecl from gc_cpp.h.\n+ - Added GC_debug_malloc_replacement and GC_debug_realloc_replacement\n+   declarations to gc.h.  On IA64, this is required for REDIRECT_MALLOC\n+   to work correctly with these.\n+ - Fixed Linux USE_PROC_FOR_LIBRARIES to work with a 64-bit /proc format.\n+\n+Since 6.1:\n+ - Guard the test for GC_DUMP_REGULARLY in misc.c with\n+   \"#ifndef NO_DEBUGGING\".  Otherwise it fails to build with NO_DEBUGGING\n+   defined.  (Thanks to Manuel Serrano.)\n+ - Message about retrying suspend signals was incorrectly generated even when\n+   flag was not set.\n+ - Cleaned up MACOSX/NEXT root registration code.  There was apparently a\n+   separate ifdef case in GC_register_data_segments() for no reason.\n+ - Removed MPROTECT_VDB for MACOSX port, based on one negative report.\n+ - Arrange for gc.h and friends to be correctly installed with GNU-style\n+   \"make install\".\n+ - Enable the GNU-style build facility include C++ support in the library\n+   with --enable-cplusplus. (Thanks to Thomas Maier for some of the patch.)\n+ - Mark from GC_thread_key in linux_threads.c, in case that's allocated\n+   from the garbage collected heap, as it is with our own thread-specific\n+   storage implementation.  (Thanks to Jeff Sturm.)\n+ - Mark all free list header blocks if they are heap allocated.  This avoids\n+   some unnecessary tracing.  And it remains correct if we clear the\n+   root set. (Thanks to Jeff Sturm for identifying the bug.)\n+ - Improved S390/Linux support.  Add S390/Linux 64-bit support.  (Thanks\n+   to Ulrich Weigand.)\n+ - Corrected the spelling of GC_{M,C}ALLOC_EXPLICTLY_TYPED to\n+   GC_{M,C}ALLOC_EXPLICITLY_TYPED in gc_typed.h.  This is technically\n+   an interface change.  Based on the fact that nobody reported this,\n+   I suspect/hope there were no clients.\n+ - Cleaned up gc_typed.h so that (1) it adds an extern \"C\" declaration\n+   when appropriate, (2) doesn't generate references to undefined internal\n+   macros, and (3) allows easier manual construction of descriptors.\n+ - Close the file descriptor used by GC_print_address_map().\n+ - Set the \"close-on-exec\" bit for various file descriptors maintained\n+   for the collector's internal use.\n+ - Added a hack to find memory segments owned by the system allocator\n+   under win32.  Based on my tests, this tends to eventually find all\n+   segments, though it may take a while.  There appear to be cleaner,\n+   but slower solutions under NT/XP.  But they rely on an API that's\n+   unsupported under 9X.\n+ - Changed Linux PowerPC stack finding to LINUX_STACKBOTTOM.  (Thanks\n+   to Akira Tagoh for pointing out that HEURISTIC1 doesn't work on\n+   64-bit kernels.)\n+ - Added GC_set_free_space_divisor to avoid some Windows dll issues.\n+ - Added FIXUP_POINTER, POINTER_SHIFT, POINTER_MASK to allow preprocessing\n+   of candidate pointers for tagging, etc.\n+ - Always lock around GC_notify_full_gc().  Simplified code for\n+   invoking GC_notify_full_gc().\n+ - Changed the way DATASTART is defined on FreeBSD to be robust against\n+   an unmapped page after etext.  (Thanks to Hironori Sakamoto for\n+   tracking down the intermittent failure.)\n+ - Made GC_enable() and GC_disable() official.  Deprecated direct update\n+   of GC_dont_gc.  Changed GC_gcollect to be a noop when garbage collection\n+   is disabled.\n+ - Call GC_register_dynamic_libraries before stopping the world on Linux,\n+   in order to avoid a potential deadlock due to the dl_iterate_phdr lock.\n+ - Introduced a more general mechanism for platform-dependent code to\n+   decide whether the main data segment should be handled separately\n+   from dynamic libraries, or registered by GC_register_dynamic_libraries.\n+   The latter is more reliable and easier on Linux with dl_iterate_phdr. \n+\n+Since 6.2alpha1:\n+ - Fixed the completely broken FreeBSD code in 6.2alpha1.  (Thanks to\n+   Hironori Sakamoto for the patch.)\n+ - Changed IRIX reference in dbg_mlc.c to IRIX5. (Thanks to Marcus Herbert.)\n+ - Attempted to work around the problems with .S filenames and the SGI\n+   compiler.  (Reported by several people. Untested.)\n+ - Worked around an HP/UX make issue with the GNU-style build process.\n+ - Fixed the --enable-cplusplus build machinery to allow builds without\n+   a C++ compiler.  (That was always the intent ...)\n+ - Changed the debugging allocation macros to explicitly pass the return\n+   address for Linux and XXXBSD on hardware for which we can't get stack\n+   traces.  Use __builtin_return_address(0) to generate it when possible.\n+   Some of the configuration work was cleaned up (good) and moved to gc.h\n+   (bad, but necessary).  This should make leak detection more useful\n+   on a number of platforms.  (Thanks to Fabian Thylman for the suggestion.)\n+ - Fixed compilation problems in dbg_mlc.c with GC_ADD_CALLER.\n+ - Bumped revision number for dynamic library.\n+\n+Since 6.2alpha2:\n+ - Don't include execinfo.h in os_dep.c when it's not needed, and may not exist.\n+\n+Since 6.2alpha3:\n+ - Use LINUX_STACKBOTTOM for >= glibc2.2 on Linux/MIPS.  (See Debian bug\n+   # 177204)\n+ - Integrated Jeff Sturm and Jesse Rosenstock's MACOSX threads patches.\n+ - Integrated Grzegorz Jakacki's substantial GNU build patch.  \"Make dist\"\n+   should now work for the GNU build process.  Documentation files\n+   are installed under share/gc.\n+ - Tweaked gc_cpp.h to again support the Borland compiler.  (Thanks to\n+   Rene Girard for pointing out the problems.)\n+ - Updated BCC_MAKEFILE (thanks to Rene Girard).\n+ - Added GC_ASSERT check for minimum thread stack size.\n+ - Added --enable-gc-assertions.\n+ - Added some web documentation to the distribution.  Updated it in the\n+   process.\n+ - Separate gc_conf_macros.h from gc.h.\n+ - Added generic GC_THREADS client-defined macro to set the appropriate\n+   GC_XXX_THREADS internal macro.  (gc_config_macros.h.)\n+ - Add debugging versions of _ignore_off_page allocation primitves.\n+ - Moved declarations of GC_make_closure and GC_debug_invoke_finalizer\n+   from gc.h to gc_priv.h.\n+ - Reset GC_fail_count even if only a small allocation succeeds.\n+ - Integrated Brian Alliet's patch for dynamic library support on Darwin.\n+ - gc_cpp.h's gc_cleanup destructor called GC_REGISTER_FINALIZER_IGNORE_SELF\n+   when it should have called the lower case version, since it was\n+   explicitly computing a base pointer.\n+\n+Since 6.2alpha4:\n+ - GC_invoke_finalizers could, under rare conditions, set\n+   GC_finalizer_mem_freed to an essentially random value.  This could\n+   possibly cause unbounded heap growth for long-running applications\n+   under some conditions.  (The bug was introduced in 6.1alpha5, and\n+   is not in gcc3.3.  Thanks to Ben Hutchings for finding it.)\n+ - Attempted to sanitize the various DLL macros.  GC_USE_DLL disappeared.\n+   GC_DLL is used instead.  All internal tests are now on GC_DLL.\n+   README.macros is now more precise about the intended meaning.\n+ - Include DllMain in the multithreaded win32 version only if the\n+   collector is actually built as a dll.  (Thanks to Mohan Embar for\n+   a version of the patch.)\n+ - Hide the cygwin threadAttach/Detach functions.  They were violating our\n+   namespace rules.  \n+ - Fixed an assertion in GC_check_heap_proc.  Added GC_STATIC_ASSERT.\n+   (Thanks again to Ben Hutchings.)\n+ - Removed some obsolete definitions for Linux/PowerPC in gcconfig.h.\n+ - CORD_cat was not rebalancing unbalanced trees in some cases, violating\n+   a CORD invariant.  Also tweaked the rebalancing rule for\n+   CORD_cat_char_star.  (Thanks to Alexandr Petrosian for the bug report\n+   and patch.)\n+ - Added hand-coded structured exception handling support to mark.c.\n+   This should enable support of dynamic libraries under win32 with\n+   gcc-compiled code.  (Thanks to Ranjit Mathew for the patch.)\n+   Turned on dynamic library scanning for win32/gcc.\n+ - Removed some remnants of read wrapping.  (Thanks to Kenneth Schalk.)\n+   GC_USE_LD_WRAP ws probably broken in recent versions.\n+ - The build could fail on some platforms since gcconfig.h could include\n+   declarations mentioning ptr_t, which was not defined, e.g. when if_mach\n+   was built.  (Thanks to Yann Dirson for pointing this out.)  Also\n+   cleaned up tests for GC_PRIVATE_H in gcconfig.h a bit. \n+ - The GC_LOOP_ON_ABORT environment variable interfered with incremental\n+   collection, since the write fault handler was erroneously overridden.\n+   Handlers are now set up in the correct order.\n+ - It used to be possible to call GC_mark_thread_local_free_lists() while\n+   the world was not stopped during an incremental GC.  This was not safe.\n+   Fortunately, it was also unnecessary.  Added GC_world_stopped flag\n+   to avoid it.  (This caused occasional crashes in GC_set_fl_marks\n+   with thread local allocation and incremental GC.  This probably happened\n+   primarily on old, slow multiprocessors.)\n+ - Allowed overriding of MAX_THREADS in win32_threads.c from the build\n+   command line.  (Patch from Yannis Bres.)\n+ - Taught the IA64/linux code to determine the register backing store base from\n+   /proc/self/maps after checking the __libc symbol, but before guessing.\n+   (__libc symbols are on the endangered list, and the guess is likely to not\n+   always be right for 2.6 kernels.)  Restructured the code to read and parse\n+   /proc/self/maps so it only exists in one place (all platforms).\n+ - The -DUSE_PROC_FOR_LIBRARIES code was broken on Linux.  It claimed that it\n+   also registered the main data segment, but didn't actually do so.  (I don't\n+   think anyone actually uses this configuration, but ...)\n+ - Made another attempt to get --enablecplusplus to do the right thing.\n+   Since there are unavoidable problems with C programs linking against a\n+   dynamic library that includes C++ code, I separated out the c++ code into\n+   libgccpp.\n+\n+Since 6.2alpha5:\n+ - There was extra underscore in the name of GC_save_registers_in_stack\n+   for NetBSD/SPARC.  (Thanks to Jaap Boender for the patch.)\n+ - Integrated Brian Alliet's patch for Darwin.  This restructured the\n+   linuxthreads/pthreads support to separate generic pthreads support\n+   from more the system-dependent thread-stopping code.  I believe this\n+   should make it easier to eliminate the code duplication between\n+   pthreads platforms in the future.  The patch included some other\n+   code cleanups.\n+ - Integrated Dan Bonachea's patch to support AIX threads.  This required\n+   substantial manual integration, mostly due to conflicts with other\n+   recent threads changes.  It may take another iteration to\n+   get it to work.\n+ - Removed HPUX/PA-RISC support from aix_irix_threads.c.  It wasn't used\n+   anyway and it cluttered up the code.  And anything we can do to migrate\n+   towards generic pthreads support is a good thing.\n+ - Added a more explicit test for tracing of function arguments to test.c.\n+   (Thanks to Dan Grayson.)\n+ - Added Akira Tagoh's PowerPC64 patch.\n+ - Fixed some bit rot in the Cygwin port.  (Thanks to Dan Bonachea for\n+   pointing it out.)  Gc.h now includes just windows.h, not winbase.h.\n+ - Declared GC_save_regs_in_stack() in gc_priv.h.  Remove other declarations.\n+ - Changed --enable-cplusplus to use automake consitionals.  The old way\n+   confused libtool.  \"Make install\" didn't work correctly for the old version.\n+   Previously --enable-cplusplus was broken on cygwin.\n+ - Changed the C version of GC_push_regs to fail at compile time if it is\n+   generated with an empty body.  This seems to have been the cause of one\n+   or two subtle failures on unusual platforms.  Those failures should\n+   now occur at build time and be easily fixable.\n+\n+Since 6.2alpha6:\n+ - Integrated a second round of Irix/AIX patches from Dan Bonachea.\n+   Renamed mips_sgi_mach_dep.S back to mips_sgi_mach_dep.s, since it requires\n+   the Irix assembler to do the C preprocessing; gcc -E doesn't work.\n+ - Fixed Makefile.direct for DARWIN.  (Thanks to Manuel Serrano.)\n+ - There was a race between GC_pthread_detach and thread exit that could\n+   result in a thread structure being deallocated by GC_pthread_detach\n+   eventhough it was still needed by the thread exit code.  (Thanks to\n+   Dick Porter for the small test case that allowed this to be debugged.)\n+ - Fixed version parsing for non-alpha versions in acinclude.m4 and\n+   version checking in version.h.\n+\n+Since 6.2:\n+ - Integrated some NetBSD patches forwarded to me by Marc Recht.  These\n+   were already in the NetBSD package.    \n+ - GC_pthread_create waited for the semaphore even if pthread_create failed.\n+   Thanks to Dick Porter for the pthread_support.c patch.  Applied the\n+   analogous fix for aix_irix_threads.c.\n+ - Added Rainer Orth's Tru64 fixes.\n+ - The check for exceeding the thread table size in win32 threadDetach\n+   was incorrect.  (Thanks to Alexandr Petrosian for the patch.)\n+ - Applied Andrew Begel's patch to correct some reentrancy issues\n+   with dynamic loading on Darwin.\n+ - GC_CreateThread() was neglecting to duplicate the thread handle in\n+   the table.  (Thanks to Tum Nguyen for the patch.)\n+ - Pass +ESdbgasm only on PA-RISC machines with vendor compiler.\n+   (Thanks to Roger Sayle for the patch.)\n+ - Applied more AIX threads patches from Scott Ananian.\n \n To do:\n+ - A dynamic libgc.so references dlopen unconditionally, but doesn't link\n+   against libdl.\n+ - GC_proc_fd for Solaris is not correctly updated in response to a\n+   fork() call.  Thus incremental collection in the child won't work\n+   correctly.  (Thanks to Ben Cottrell for pointing this out.)\n+ - --enable-redirect-malloc is mostly untested and known not to work\n+   on some platforms. \n  - There seem to be outstanding issues on Solaris/X86, possibly with\n    finding the data segment starting address.  Information/patches would\n    be appreciated.\n@@ -1488,7 +1919,4 @@ To do:\n  - Incremental collector should handle large objects better.  Currently,\n    it looks like the whole object is treated as dirty if any part of it\n    is.\n- - Cord/cordprnt.c doesn't build on a few platforms (notably PowerPC), since\n-   we make some unwarranted assumptions about how varargs are handled.  This\n-   currently makes the cord-aware versions of printf unusable on some platforms.\n-   Fixing this is unfortunately not trivial.\n+ "}, {"sha": "d1f3b5c053b7776fbd820e6c8c2135508a786e1a", "filename": "boehm-gc/doc/README.environment", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -5,6 +5,8 @@ platforms.\n GC_INITIAL_HEAP_SIZE=<bytes> -\tInitial heap size in bytes.  May speed up\n \t\t\t\tprocess start-up.\n \n+GC_MAXIMUM_HEAP_SIZE=<bytes> - Maximum collected heap size.\n+\n GC_LOOP_ON_ABORT - Causes the collector abort routine to enter a tight loop.\n \t\t   This may make it easier to debug, such a process, especially\n \t\t   for multithreaded platforms that don't produce usable core\n@@ -19,6 +21,11 @@ GC_PRINT_STATS - Turn on as much logging as is easily feasible without\n \t\t by setting GC_quiet.  On by default if the collector\n \t\t was built without -DSILENT.\n \n+GC_DUMP_REGULARLY - Generate a GC debugging dump GC_dump() on startup\n+\t\t    and during every collection.  Very verbose.  Useful\n+\t\t    if you have a bug to report, but please include only the\n+\t\t    last complete dump.\n+\n GC_PRINT_ADDRESS_MAP - Linux only.  Dump /proc/self/maps, i.e. various address\n \t\t       maps for the process, to stderr on every GC.  Useful for\n \t\t       mapping root addresses to source for deciphering leak\n@@ -27,7 +34,14 @@ GC_PRINT_ADDRESS_MAP - Linux only.  Dump /proc/self/maps, i.e. various address\n GC_NPROCS=<n> - Linux w/threads only.  Explicitly sets the number of processors\n \t        that the GC should expect to use.  Note that setting this to 1\n \t\twhen multiple processors are available will preserve\n-\t\tcorrectness, but may lead to really horrible performance.\n+\t\tcorrectness, but may lead to really horrible performance,\n+\t\tsince the lock implementation will immediately yield without\n+\t\tfirst spinning.\n+\n+GC_MARKERS=<n> - Linux w/threads and parallel marker only.  Set the number\n+\t\tof marker threads.  This is normaly set to the number of\n+\t\tprocessors.  It is safer to adjust GC_MARKERS than GC_NPROCS,\n+\t\tsince GC_MARKERS has no impact on the lock implementation.\n \n GC_NO_BLACKLIST_WARNING - Prevents the collector from issuing\n \t\twarnings about allocations of very large blocks.\n@@ -62,6 +76,20 @@ GC_PRINT_BACK_HEIGHT - Print max length of chain through unreachable objects\n \t\t     of Conservative Garbage Collectors\", POPL 2001, or\n \t\t     http://lib.hpl.hp.com/techpubs/2001/HPL-2001-251.html .\n \n+GC_RETRY_SIGNALS, GC_NO_RETRY_SIGNALS - Try to compensate for lost\n+\t\t     thread suspend signals in linux_threads.c.  On by\n+\t\t     default for GC_OSF1_THREADS, off otherwise.  Note \n+\t\t     that this does not work around a possible loss of\n+\t\t     thread restart signals.  This seems to be necessary for\n+\t\t     some versions of Tru64.  Since we've previously seen\n+\t\t     similar issues on some other operating systems, it\n+\t\t     was turned into a runtime flag to enable last-minute\n+\t\t     work-arounds.\n+\n+The following turn on runtime flags that are also program settable.  Checked\n+only during initialization.  We expect that they will usually be set through\n+other means, but this may help with debugging and testing:\n+\n GC_ENABLE_INCREMENTAL - Turn on incremental collection at startup.  Note that,\n \t\t     depending on platform and collector configuration, this\n \t\t     may involve write protecting pieces of the heap to\n@@ -71,22 +99,20 @@ GC_ENABLE_INCREMENTAL - Turn on incremental collection at startup.  Note that,\n \t\t     Use with caution.\n \n GC_PAUSE_TIME_TARGET - Set the desired garbage collector pause time in msecs.\n-\t\t     This only has an effect if incremental collection is enabled.\n-\t\t     If a collection requires appreciably more time than this,\n-\t\t     the client will be restarted, and the collector will need\n-\t\t     to do additional work to compensate.  The special value\n-\t\t     \"999999\" indicates that pause time is unlimited, and the\n-\t\t     incremental collector will behave completely like a\n-\t\t     simple generational collector.  If the collector is\n-\t\t     configured for parallel marking, and run on a multiprocessor,\n-\t\t     incremental collection should only be used with unlimited\n-\t\t     pause time.\n-\n-The following turn on runtime flags that are also program settable.  Checked\n-only during initialization.  We expect that they will usually be set through\n-other means, but this may help with debugging and testing:\n+\t\t     This only has an effect if incremental collection is\n+\t\t     enabled.  If a collection requires appreciably more time\n+\t\t     than this, the client will be restarted, and the collector\n+\t\t     will need to do additional work to compensate.  The\n+\t\t     special value \"999999\" indicates that pause time is\n+\t\t     unlimited, and the incremental collector will behave\n+\t\t     completely like a simple generational collector.  If\n+\t\t     the collector is configured for parallel marking, and\n+\t\t     run on a multiprocessor, incremental collection should\n+\t\t     only be used with unlimited pause time.\n \n-GC_FIND_LEAK - Turns on GC_find_leak and thus leak detection.\n+GC_FIND_LEAK - Turns on GC_find_leak and thus leak detection.  Forces a\n+\t       collection at program termination to detect leaks that would\n+\t       otherwise occur after the last GC.\n \n GC_ALL_INTERIOR_POINTERS - Turns on GC_all_interior_pointers and thus interior\n \t\t\t   pointer recognition."}, {"sha": "1d0fd4c3fb68ff02e0f4326eaa2c92ef532d9a59", "filename": "boehm-gc/doc/README.linux", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.linux?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,21 +1,18 @@\n See README.alpha for Linux on DEC AXP info.\n \n-This file applies mostly to Linux/Intel IA32.  Ports to Linux on an M68K\n-and PowerPC are also integrated.  They should behave similarly, except that\n-the PowerPC port lacks incremental GC support, and it is unknown to what\n-extent the Linux threads code is functional.  See below for M68K specific\n-notes.\n+This file applies mostly to Linux/Intel IA32.  Ports to Linux on an M68K, IA64,\n+SPARC, MIPS, Alpha and PowerPC are also integrated.  They should behave\n+similarly, except that the PowerPC port lacks incremental GC support, and\n+it is unknown to what extent the Linux threads code is functional.\n+See below for M68K specific notes.\n \n-Incremental GC is supported on Intel IA32 and M68K.\n+Incremental GC is generally supported.\n \n Dynamic libraries are supported on an ELF system.  A static executable\n should be linked with the gcc option \"-Wl,-defsym,_DYNAMIC=0\".\n \n-The collector appears to work with Linux threads.  We have seen\n-intermittent hangs in sem_wait.  So far we have been unable to reproduce\n-these unless the process was being debugged or traced.  Thus it's\n-possible that the only real issue is that the debugger loses\n-signals on rare occasions.\n+The collector appears to work reliably with Linux threads, but beware \n+of older versions of glibc and gdb.\n \n The garbage collector uses SIGPWR and SIGXCPU if it is used with\n Linux threads.  These should not be touched by the client program."}, {"sha": "a40b375f5509ff9de9fcea2d009fb4c1a15eb93a", "filename": "boehm-gc/doc/README.win32", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.win32?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -21,6 +21,13 @@ registrations are ignored, but not terribly quickly.)\n pointers.  And the VirtualQuery call has different semantics under\n the two systems, and under different versions of win32s.)\n \n+Win32 applications compiled with some flavor of gcc currently behave\n+like win32s applications, in that dynamic library data segments are\n+not scanned.  (Gcc does not directly support Microsoft's \"structured\n+exception handling\".  It turns out that use of this feature is\n+unavoidable if you scan arbitrary memory segments obtained from\n+VirtualQuery.)\n+\n The collector test program \"gctest\" is linked as a GUI application,\n but does not open any windows.  Its output appears in the file\n \"gc.log\".  It may be started from the file manager.  The hour glass\n@@ -50,21 +57,28 @@ This appears to cause problems under Windows NT and Windows 2000 (but\n not Windows 95/98) if the memory is later passed to CreateDIBitmap.\n To work around this problem, build the collector with -DUSE_GLOBAL_ALLOC.\n This is currently incompatible with -DUSE_MUNMAP.  (Thanks to Jonathan\n-Clark for tracking this down.)\n+Clark for tracking this down.  There's some chance this may be fixed\n+in 6.1alpha4, since we now separate heap sections with an unused page.)\n \n For Microsoft development tools, rename NT_MAKEFILE as\n MAKEFILE.  (Make sure that the CPU environment variable is defined\n to be i386.)  In order to use the gc_cpp.h C++ interface, all\n client code should include gc_cpp.h.\n \n+If you would prefer a VC++.NET project file, ask boehm@acm.org.  One has\n+been contributed, but it seems to contain some absolute paths etc., so\n+it can presumably only be a starting point, and is not in the standard\n+distribution.  It is unclear (to me, Hans Boehm) whether it is feasible to\n+change that.\n+\n Clients may need to define GC_NOT_DLL before including gc.h, if the\n collector was built as a static library (as it normally is in the\n absence of thread support).\n \n For GNU-win32, use the regular makefile, possibly after uncommenting\n the line \"include Makefile.DLLs\".  The latter should be necessary only\n if you want to package the collector as a DLL.  The GNU-win32 port is\n-believed to work only for b18, not b19, probably dues to linker changes\n+believed to work only for b18, not b19, probably due to linker changes\n in b19.  This is probably fixable with a different definition of\n DATASTART and DATAEND in gcconfig.h.\n \n@@ -147,7 +161,7 @@ To compile the collector and testing programs use the command:\n All programs using gc should be compiled with 4-byte alignment.\n For further explanations on this see comments about Borland.\n \n-If gc compiled as dll, the macro ``GC_DLL'' should be defined before\n+If the gc is compiled as dll, the macro ``GC_DLL'' should be defined before\n including \"gc.h\" (for example, with -DGC_DLL compiler option). It's\n important, otherwise resulting programs will not run.\n "}, {"sha": "22273fed4bcc42c61104106ee858e1106c5e5a6a", "filename": "boehm-gc/doc/debugging.html", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2Fdebugging.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdoc%2Fdebugging.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fdebugging.html?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -248,8 +248,12 @@ <H2>Prematurely Reclaimed Objects</h2>\n during which its block was last swept.\n <LI> Verify that the offending object still has its correct contents at\n this point.\n-The call <TT>GC_is_marked(p)</tt> from the debugger to verify that the\n-object has not been marked, and is about to be reclaimed.\n+Then call <TT>GC_is_marked(p)</tt> from the debugger to verify that the\n+object has not been marked, and is about to be reclaimed.  Note that\n+<TT>GC_is_marked(p)</tt> expects the real address of an object (the\n+address of the debug header if there is one), and thus it may\n+be more appropriate to call <TT>GC_is_marked(GC_base(p))</tt>\n+instead.\n <LI> Determine a path from a root, i.e. static variable, stack, or\n register variable,\n to the reclaimed object.  Call <TT>GC_is_marked(q)</tt> for each object"}, {"sha": "5ae0e0dcccddf7eab3510ad80ff6eecbbacde1b6", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 163, "deletions": 115, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -55,9 +55,10 @@\n     !defined(MSWIN32) && !defined(MSWINCE) && \\\n     !(defined(ALPHA) && defined(OSF1)) && \\\n     !defined(HPUX) && !(defined(LINUX) && defined(__ELF__)) && \\\n-    !defined(RS6000) && !defined(SCO_ELF) && \\\n+    !defined(RS6000) && !defined(SCO_ELF) && !defined(DGUX) && \\\n     !(defined(FREEBSD) && defined(__ELF__)) && \\\n-    !(defined(NETBSD) && defined(__ELF__)) && !defined(HURD)\n+    !(defined(NETBSD) && defined(__ELF__)) && !defined(HURD) && \\\n+    !defined(DARWIN)\n  --> We only know how to find data segments of dynamic libraries for the\n  --> above.  Additional SVR4 variants might not be too\n  --> hard to add.\n@@ -80,7 +81,7 @@\n #endif\n \n #if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF) || \\\n-    (defined(FREEBSD) && defined(__ELF__)) || \\\n+    (defined(FREEBSD) && defined(__ELF__)) || defined(DGUX) || \\\n     (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n #   include <stddef.h>\n #   include <elf.h>\n@@ -264,7 +265,7 @@ void GC_register_dynamic_libraries()\n # endif /* SUNOS */\n \n #if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF) || \\\n-    (defined(FREEBSD) && defined(__ELF__)) || \\\n+    (defined(FREEBSD) && defined(__ELF__)) || defined(DGUX) || \\\n     (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n \n \n@@ -282,56 +283,23 @@ extern ssize_t GC_repeat_read(int fd, char *buf, size_t count);\n \t/* Repeatedly read until buffer is filled, or EOF is encountered */\n \t/* Defined in os_dep.c.  \t\t\t\t\t */\n \n-static char *parse_map_entry(char *buf_ptr, word *start, word *end,\n-                             char *prot_buf, unsigned int *maj_dev);\n+char *GC_parse_map_entry(char *buf_ptr, word *start, word *end,\n+                         char *prot_buf, unsigned int *maj_dev);\n+word GC_apply_to_maps(word (*fn)(char *));\n+\t/* From os_dep.c\t*/\n \n-void GC_register_dynamic_libraries()\n+word GC_register_map_entries(char *maps)\n {\n-    int f;\n-    int result;\n     char prot_buf[5];\n-    int maps_size;\n-    char maps_temp[32768];\n-    char *maps_buf;\n-    char *buf_ptr;\n+    char *buf_ptr = maps;\n     int count;\n     word start, end;\n-    unsigned int maj_dev, min_dev;\n+    unsigned int maj_dev;\n     word least_ha, greatest_ha;\n     unsigned i;\n     word datastart = (word)(DATASTART);\n \n-    /* Read /proc/self/maps\t*/\n-        /* Note that we may not allocate, and thus can't use stdio.\t*/\n-        f = open(\"/proc/self/maps\", O_RDONLY);\n-        if (-1 == f) ABORT(\"Couldn't open /proc/self/maps\");\n-\t/* stat() doesn't work for /proc/self/maps, so we have to\n-\t   read it to find out how large it is... */\n-\tmaps_size = 0;\n-\tdo {\n-\t    result = GC_repeat_read(f, maps_temp, sizeof(maps_temp));\n-\t    if (result <= 0) ABORT(\"Couldn't read /proc/self/maps\");\n-\t    maps_size += result;\n-\t} while (result == sizeof(maps_temp));\n-\n-\tif (maps_size > sizeof(maps_temp)) {\n-\t    /* If larger than our buffer, close and re-read it. */\n-\t    close(f);\n-\t    f = open(\"/proc/self/maps\", O_RDONLY);\n-\t    if (-1 == f) ABORT(\"Couldn't open /proc/self/maps\");\n-\t    maps_buf = alloca(maps_size);\n-\t    if (NULL == maps_buf) ABORT(\"/proc/self/maps alloca failed\");\n-\t    result = GC_repeat_read(f, maps_buf, maps_size);\n-\t    if (result <= 0) ABORT(\"Couldn't read /proc/self/maps\");\n-\t} else {\n-\t    /* Otherwise use the fixed size buffer */\n-\t    maps_buf = maps_temp;\n-\t}\n-\n-\tclose(f);\n-        maps_buf[result] = '\\0';\n-        buf_ptr = maps_buf;\n-    /* Compute heap bounds. Should be done by add_to_heap?\t*/\n+    /* Compute heap bounds. FIXME: Should be done by add_to_heap?\t*/\n \tleast_ha = (word)(-1);\n \tgreatest_ha = 0;\n \tfor (i = 0; i < GC_n_heap_sects; ++i) {\n@@ -342,11 +310,10 @@ void GC_register_dynamic_libraries()\n         }\n     \tif (greatest_ha < (word)GC_scratch_last_end_ptr)\n \t    greatest_ha = (word)GC_scratch_last_end_ptr; \n-    for (;;) {\n-\n-        buf_ptr = parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n-\tif (buf_ptr == NULL) return;\n \n+    for (;;) {\n+        buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n+\tif (buf_ptr == NULL) return 1;\n \tif (prot_buf[1] == 'w') {\n \t    /* This is a writable mapping.  Add it to\t\t*/\n \t    /* the root set unless it is already otherwise\t*/\n@@ -358,16 +325,7 @@ void GC_register_dynamic_libraries()\n #\t    ifdef THREADS\n \t      if (GC_segment_is_thread_stack(start, end)) continue;\n #\t    endif\n-\t    /* The rest of this assumes that there is no mapping\t*/\n-\t    /* spanning the beginning of the data segment, or extending\t*/\n-\t    /* beyond the entire heap at both ends.  \t\t\t*/\n-\t    /* Empirically these assumptions hold.\t\t\t*/\n-\t    \n-\t    if (start < (word)DATAEND && end > (word)DATAEND) {\n-\t\t/* Rld may use space at the end of the main data \t*/\n-\t\t/* segment.  Thus we add that in.\t\t\t*/\n-\t\tstart = (word)DATAEND;\n-\t    }\n+\t    /* We no longer exclude the main data segment.\t\t*/\n \t    if (start < least_ha && end > least_ha) {\n \t\tend = least_ha;\n \t    }\n@@ -377,7 +335,14 @@ void GC_register_dynamic_libraries()\n \t    if (start >= least_ha && end <= greatest_ha) continue;\n \t    GC_add_roots_inner((char *)start, (char *)end, TRUE);\n \t}\n-     }\n+    }\n+    return 1;\n+}\n+\n+void GC_register_dynamic_libraries()\n+{\n+   if (!GC_apply_to_maps(GC_register_map_entries))\n+       ABORT(\"Failed to read /proc for library registration.\");\n }\n \n /* We now take care of the main data segment ourselves: */\n@@ -387,60 +352,6 @@ GC_bool GC_register_main_static_data()\n }\n   \n # define HAVE_REGISTER_MAIN_STATIC_DATA\n-//\n-//  parse_map_entry parses an entry from /proc/self/maps so we can\n-//  locate all writable data segments that belong to shared libraries.\n-//  The format of one of these entries and the fields we care about\n-//  is as follows:\n-//  XXXXXXXX-XXXXXXXX r-xp 00000000 30:05 260537     name of mapping...\\n\n-//  ^^^^^^^^ ^^^^^^^^ ^^^^          ^^\n-//  start    end      prot          maj_dev\n-//  0        9        18            32\n-//\n-//  The parser is called with a pointer to the entry and the return value\n-//  is either NULL or is advanced to the next entry(the byte after the\n-//  trailing '\\n'.)\n-//\n-#define OFFSET_MAP_START   0\n-#define OFFSET_MAP_END     9\n-#define OFFSET_MAP_PROT   18\n-#define OFFSET_MAP_MAJDEV 32\n-\n-static char *parse_map_entry(char *buf_ptr, word *start, word *end,\n-                             char *prot_buf, unsigned int *maj_dev)\n-{\n-    int i;\n-    unsigned int val;\n-    char *tok;\n-\n-    if (buf_ptr == NULL || *buf_ptr == '\\0') {\n-        return NULL;\n-    }\n-\n-    memcpy(prot_buf, buf_ptr+OFFSET_MAP_PROT, 4); // do the protections first\n-    prot_buf[4] = '\\0';\n-\n-    if (prot_buf[1] == 'w') { // we can skip all of this if it's not writable\n-\n-        tok = buf_ptr;\n-        buf_ptr[OFFSET_MAP_START+8] = '\\0';\n-        *start = strtoul(tok, NULL, 16);\n-\n-        tok = buf_ptr+OFFSET_MAP_END;\n-        buf_ptr[OFFSET_MAP_END+8] = '\\0';\n-        *end = strtoul(tok, NULL, 16);\n-\n-        buf_ptr += OFFSET_MAP_MAJDEV;\n-        tok = buf_ptr;\n-        while (*buf_ptr != ':') buf_ptr++;\n-        *buf_ptr++ = '\\0';\n-        *maj_dev = strtoul(tok, NULL, 16);\n-    }\n-\n-    while (*buf_ptr && *buf_ptr++ != '\\n');\n-\n-    return buf_ptr;\n-}\n \n #endif /* USE_PROC_FOR_LIBRARIES */\n \n@@ -508,6 +419,7 @@ GC_bool GC_register_dynamic_libraries_dl_iterate_phdr()\n           GC_add_roots_inner(DATASTART2, (char *)(DATAEND2), TRUE);\n #       endif\n     }\n+\n     return TRUE;\n   } else {\n     return FALSE;\n@@ -534,6 +446,16 @@ GC_bool GC_register_main_static_data()\n \n #if defined(NETBSD)\n #  include <sys/exec_elf.h>\n+/* for compatibility with 1.4.x */\n+#  ifndef DT_DEBUG\n+#  define DT_DEBUG     21\n+#  endif\n+#  ifndef PT_LOAD\n+#  define PT_LOAD      1\n+#  endif\n+#  ifndef PF_W\n+#  define PF_W         2\n+#  endif\n #else\n #  include <elf.h>\n #endif\n@@ -1048,15 +970,141 @@ void GC_register_dynamic_libraries()\n \t\tlen = ldi->ldinfo_next;\n \t\tGC_add_roots_inner(\n \t\t\t\tldi->ldinfo_dataorg,\n-\t\t\t\t(unsigned long)ldi->ldinfo_dataorg\n+\t\t\t\t(ptr_t)(unsigned long)ldi->ldinfo_dataorg\n \t\t\t        + ldi->ldinfo_datasize,\n \t\t\t\tTRUE);\n \t\tldi = len ? (struct ld_info *)((char *)ldi + len) : 0;\n \t}\n }\n #endif /* RS6000 */\n \n+#ifdef DARWIN\n+\n+#include <mach-o/dyld.h>\n+#include <mach-o/getsect.h>\n+\n+/*#define DARWIN_DEBUG*/\n+\n+const static struct { \n+        const char *seg;\n+        const char *sect;\n+} GC_dyld_sections[] = {\n+        { SEG_DATA, SECT_DATA },\n+        { SEG_DATA, SECT_BSS },\n+        { SEG_DATA, SECT_COMMON }\n+};\n+    \n+#ifdef DARWIN_DEBUG\n+static const char *GC_dyld_name_for_hdr(struct mach_header *hdr) {\n+    unsigned long i,c;\n+    c = _dyld_image_count();\n+    for(i=0;i<c;i++) if(_dyld_get_image_header(i) == hdr)\n+        return _dyld_get_image_name(i);\n+    return NULL;\n+}\n+#endif\n+        \n+/* This should never be called by a thread holding the lock */\n+static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {\n+    unsigned long start,end,i;\n+    const struct section *sec;\n+    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n+        sec = getsectbynamefromheader(\n+            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n+            if(sec == NULL || sec->size == 0) continue;\n+            start = slide + sec->addr;\n+            end = start + sec->size;\n+#\t\tifdef DARWIN_DEBUG\n+                GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n+                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n+#\t\t\tendif\n+        GC_add_roots((char*)start,(char*)end);\n+        }\n+#\tifdef DARWIN_DEBUG\n+    GC_print_static_roots();\n+#\tendif\n+}\n+\n+/* This should never be called by a thread holding the lock */\n+static void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide) {\n+    unsigned long start,end,i;\n+    const struct section *sec;\n+    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n+        sec = getsectbynamefromheader(\n+            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n+        if(sec == NULL || sec->size == 0) continue;\n+        start = slide + sec->addr;\n+        end = start + sec->size;\n+#\t\tifdef DARWIN_DEBUG\n+            GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n+                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n+#\t\tendif\n+        GC_remove_roots((char*)start,(char*)end);\n+    }\n+#\tifdef DARWIN_DEBUG\n+    GC_print_static_roots();\n+#\tendif\n+}\n+\n+void GC_register_dynamic_libraries() {\n+    /* Currently does nothing. The callbacks are setup by GC_init_dyld() \n+    The dyld library takes it from there. */\n+}\n+\n+/* The _dyld_* functions have an internal lock so no _dyld functions\n+   can be called while the world is stopped without the risk of a deadlock.\n+   Because of this we MUST setup callbacks BEFORE we ever stop the world.\n+   This should be called BEFORE any thread in created and WITHOUT the\n+   allocation lock held. */\n+   \n+void GC_init_dyld() {\n+  static GC_bool initialized = FALSE;\n+  char *bind_fully_env = NULL;\n+  \n+  if(initialized) return;\n+  \n+#   ifdef DARWIN_DEBUG\n+  GC_printf0(\"Registering dyld callbacks...\\n\");\n+#   endif\n+  \n+  /* Apple's Documentation:\n+     When you call _dyld_register_func_for_add_image, the dynamic linker runtime\n+     calls the specified callback (func) once for each of the images that is\n+     currently loaded into the program. When a new image is added to the program,\n+     your callback is called again with the mach_header for the new image, and the \t\n+     virtual memory slide amount of the new image. \n+     \n+     This WILL properly register already linked libraries and libraries \n+     linked in the future\n+  */\n+  \n+    _dyld_register_func_for_add_image(GC_dyld_image_add);\n+    _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n+\n+    /* Set this early to avoid reentrancy issues. */\n+    initialized = TRUE;\n+\n+    bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n+    \n+    if (bind_fully_env == NULL) {\n+#   ifdef DARWIN_DEBUG\n+      GC_printf0(\"Forcing full bind of GC code...\\n\");\n+#   endif\n+      \n+      if(!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n+        GC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n+    }\n+\n+}\n+\n+#define HAVE_REGISTER_MAIN_STATIC_DATA\n+GC_bool GC_register_main_static_data()\n+{\n+  /* Already done through dyld callbacks */\n+  return FALSE;\n+}\n \n+#endif /* DARWIN */\n \n #else /* !DYNAMIC_LOADING */\n "}, {"sha": "3b9d9f5ea1ee3804cfbcd17177999c38e6cba500", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -207,7 +207,8 @@ signed_word * log_size_ptr;\n \tUNLOCK();\n     \tENABLE_SIGNALS();\n #     endif\n-      new_dl = GC_oom_fn(sizeof(struct disappearing_link));\n+      new_dl = (struct disappearing_link *)\n+\t      GC_oom_fn(sizeof(struct disappearing_link));\n       if (0 == new_dl) {\n \tGC_finalization_failures++;\n \treturn(0);\n@@ -433,7 +434,8 @@ finalization_mark_proc * mp;\n \tUNLOCK();\n     \tENABLE_SIGNALS();\n #     endif\n-      new_fo = GC_oom_fn(sizeof(struct finalizable_object));\n+      new_fo = (struct finalizable_object *)\n+\t      GC_oom_fn(sizeof(struct finalizable_object));\n       if (0 == new_fo) {\n \tGC_finalization_failures++;\n \treturn;\n@@ -759,15 +761,19 @@ int GC_should_invoke_finalizers GC_PROTO((void))\n /* Should be called without allocation lock.\t\t\t\t*/\n int GC_invoke_finalizers()\n {\n-    register struct finalizable_object * curr_fo;\n-    register int count = 0;\n+    struct finalizable_object * curr_fo;\n+    int count = 0;\n+    word mem_freed_before;\n     DCL_LOCK_STATE;\n     \n     while (GC_finalize_now != 0) {\n #\tifdef THREADS\n \t    DISABLE_SIGNALS();\n \t    LOCK();\n #\tendif\n+\tif (count == 0) {\n+\t    mem_freed_before = GC_mem_freed;\n+\t}\n     \tcurr_fo = GC_finalize_now;\n #\tifdef THREADS\n  \t    if (curr_fo != 0) GC_finalize_now = fo_next(curr_fo);\n@@ -789,6 +795,11 @@ int GC_invoke_finalizers()\n     \t    GC_free((GC_PTR)curr_fo);\n #\tendif\n     }\n+    if (count != 0 && mem_freed_before != GC_mem_freed) {\n+        LOCK();\n+\tGC_finalizer_mem_freed += (GC_mem_freed - mem_freed_before);\n+\tUNLOCK();\n+    }\n     return count;\n }\n \n@@ -801,7 +812,9 @@ void GC_notify_or_invoke_finalizers GC_PROTO((void))\n     if (GC_finalize_now == 0) return;\n     if (!GC_finalize_on_demand) {\n \t(void) GC_invoke_finalizers();\n-\tGC_ASSERT(GC_finalize_now == 0);\n+#\tifndef THREADS\n+\t  GC_ASSERT(GC_finalize_now == 0);\n+#\tendif\t/* Otherwise GC can run concurrently and add more */\n \treturn;\n     }\n     if (GC_finalizer_notifier != (void (*) GC_PROTO((void)))0\n@@ -839,3 +852,17 @@ void GC_notify_or_invoke_finalizers GC_PROTO((void))\n     return(result);\n }\n \n+#if !defined(NO_DEBUGGING)\n+\n+void GC_print_finalization_stats()\n+{\n+    struct finalizable_object *fo = GC_finalize_now;\n+    size_t ready = 0;\n+\n+    GC_printf2(\"%lu finalization table entries; %lu disappearing links\\n\",\n+\t       GC_fo_entries, GC_dl_entries);\n+    for (; 0 != fo; fo = fo_next(fo)) ++ready;\n+    GC_printf1(\"%lu objects are eligible for immediate finalization\\n\", ready);\n+}\n+\n+#endif /* NO_DEBUGGING */"}, {"sha": "f8b803a8baa42a1f59583e48cd7120866be31090", "filename": "boehm-gc/gc_cpp.cc", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fgc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fgc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cc?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -26,24 +26,36 @@ Authors: John R. Ellis and Jesse Hull\n \n #include \"gc_cpp.h\"\n \n-#ifndef _MSC_VER\n-/* In the Visual C++ case, we moved this into the header. */\n void* operator new( size_t size ) {\n     return GC_MALLOC_UNCOLLECTABLE( size );}\n   \n void operator delete( void* obj ) {\n     GC_FREE( obj );}\n   \n-#ifdef OPERATOR_NEW_ARRAY\n+#ifdef GC_OPERATOR_NEW_ARRAY\n \n void* operator new[]( size_t size ) {\n     return GC_MALLOC_UNCOLLECTABLE( size );}\n   \n void operator delete[]( void* obj ) {\n     GC_FREE( obj );}\n \n-#endif /* OPERATOR_NEW_ARRAY */\n+#endif /* GC_OPERATOR_NEW_ARRAY */\n \n-#endif /* _MSC_VER */\n+#ifdef _MSC_VER\n+\n+// This new operator is used by VC++ in case of Debug builds !\n+void* operator new( size_t size,\n+\t\t\t  int ,//nBlockUse,\n+\t\t\t  const char * szFileName,\n+\t\t\t  int nLine )\n+{\n+#ifndef GC_DEBUG\n+\treturn GC_malloc_uncollectable( size );\n+#else\n+\treturn GC_debug_malloc_uncollectable(size, szFileName, nLine);\n+#endif\n+}\n \n+#endif /* _MSC_VER */\n "}, {"sha": "4c690edcfe49c3c923722a34349aba2bb7576978", "filename": "boehm-gc/gc_dlopen.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fgc_dlopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fgc_dlopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_dlopen.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -19,12 +19,14 @@\n /*\n  * This used to be in dyn_load.c.  It was extracted into a separate file\n  * to avoid having to link against libdl.{a,so} if the client doesn't call\n- * dlopen.  -HB\n+ * dlopen.  Of course this fails if the collector is in a dynamic\n+ * library. -HB\n  */\n \n #include \"private/gc_priv.h\"\n \n-# if defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)\n+# if (defined(GC_PTHREADS) && !defined(GC_DARWIN_THREADS)) \\\n+      || defined(GC_SOLARIS_THREADS)\n \n # if defined(dlopen) && !defined(GC_USE_LD_WRAP)\n     /* To support various threads pkgs, gc.h interposes on dlopen by     */\n@@ -44,19 +46,14 @@\n   /* calls in either a multithreaded environment, or if the library\t*/\n   /* initialization code allocates substantial amounts of GC'ed memory.\t*/\n   /* But I don't know of a better solution.\t\t\t\t*/\n-  /* This can still deadlock if the client explicitly starts a GC \t*/\n-  /* during the dlopen.  He shouldn't do that.\t\t\t\t*/\n-  static GC_bool disable_gc_for_dlopen()\n+  static void disable_gc_for_dlopen()\n   {\n-    GC_bool result;\n     LOCK();\n-    result = GC_dont_gc;\n     while (GC_incremental && GC_collection_in_progress()) {\n \tGC_collect_a_little_inner(1000);\n     }\n-    GC_dont_gc = TRUE;\n+    ++GC_dont_gc;\n     UNLOCK();\n-    return(result);\n   }\n \n   /* Redefine dlopen to guarantee mutual exclusion with\t*/\n@@ -74,18 +71,17 @@\n #endif\n {\n     void * result;\n-    GC_bool dont_gc_save;\n     \n #   ifndef USE_PROC_FOR_LIBRARIES\n-      dont_gc_save = disable_gc_for_dlopen();\n+      disable_gc_for_dlopen();\n #   endif\n #   ifdef GC_USE_LD_WRAP\n       result = (void *)__real_dlopen(path, mode);\n #   else\n       result = dlopen(path, mode);\n #   endif\n #   ifndef USE_PROC_FOR_LIBRARIES\n-      GC_dont_gc = dont_gc_save;\n+      GC_enable(); /* undoes disable_gc_for_dlopen */\n #   endif\n     return(result);\n }"}, {"sha": "a10a66f926e4dcaab899574e354898599668e29a", "filename": "boehm-gc/gcj_mlc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -157,6 +157,7 @@ DCL_LOCK_STATE;\n             GC_words_allocd += lw;\n         }\n \t*(void **)op = ptr_to_struct_containing_descr;\n+\tGC_ASSERT(((void **)op)[1] == 0);\n \tUNLOCK();\n     } else {\n \tLOCK();"}, {"sha": "3dcccf21f5a86099e809475d5cd3303c9a61f2b0", "filename": "boehm-gc/if_mach.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fif_mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fif_mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_mach.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -14,7 +14,7 @@ char ** envp;\n     if (strcmp(MACH_TYPE, argv[1]) != 0) return(0);\n     if (strcmp(OS_TYPE, \"\") != 0 && strcmp(argv[2], \"\") != 0\n         && strcmp(OS_TYPE, argv[2]) != 0) return(0);\n-    printf(\"^^^^Starting command^^^^\\n\");\n+    fprintf(stderr, \"^^^^Starting command^^^^\\n\");\n     fflush(stdout);\n     execvp(argv[3], argv+3);\n     perror(\"Couldn't execute\");"}, {"sha": "94ece1a258a4ddab61cdca5dc344e080cf029e56", "filename": "boehm-gc/include/Makefile.in", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.in?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -66,9 +66,11 @@ target_triplet = @target@\n AR = @AR@\n AS = @AS@\n CC = @CC@\n+CFLAGS = @CFLAGS@\n CPP = @CPP@\n CXX = @CXX@\n CXXCPP = @CXXCPP@\n+CXXFLAGS = @CXXFLAGS@\n CXXINCLUDES = @CXXINCLUDES@\n DLLTOOL = @DLLTOOL@\n EXEEXT = @EXEEXT@\n@@ -89,10 +91,15 @@ RANLIB = @RANLIB@\n STRIP = @STRIP@\n THREADLIBS = @THREADLIBS@\n VERSION = @VERSION@\n+addincludes = @addincludes@\n+addlibs = @addlibs@\n addobjs = @addobjs@\n+addtests = @addtests@\n gc_basedir = @gc_basedir@\n mkinstalldirs = @mkinstalldirs@\n target_all = @target_all@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n \n AUTOMAKE_OPTIONS = foreign\n "}, {"sha": "d49cd9d60b1f8575252ecfbebb52ed38a6d4c8b0", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 128, "deletions": 108, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -30,91 +30,7 @@\n \n # define _GC_H\n \n-/*\n- * Some tests for old macros.  These violate our namespace rules and will\n- * disappear shortly.  Use the GC_ names.\n- */\n-#if defined(SOLARIS_THREADS) || defined(_SOLARIS_THREADS)\n-# define GC_SOLARIS_THREADS\n-#endif\n-#if defined(_SOLARIS_PTHREADS)\n-# define GC_SOLARIS_PTHREADS\n-#endif\n-#if defined(IRIX_THREADS)\n-# define GC_IRIX_THREADS\n-#endif\n-#if defined(HPUX_THREADS)\n-# define GC_HPUX_THREADS\n-#endif\n-#if defined(OSF1_THREADS)\n-# define GC_OSF1_THREADS\n-#endif\n-#if defined(LINUX_THREADS)\n-# define GC_LINUX_THREADS\n-#endif\n-#if defined(WIN32_THREADS)\n-# define GC_WIN32_THREADS\n-#endif\n-#if defined(USE_LD_WRAP)\n-# define GC_USE_LD_WRAP\n-#endif\n-\n-#if !defined(_REENTRANT) && (defined(GC_SOLARIS_THREADS) \\\n-\t\t             || defined(GC_SOLARIS_PTHREADS) \\\n-\t\t\t     || defined(GC_HPUX_THREADS) \\\n-\t\t\t     || defined(GC_LINUX_THREADS))\n-# define _REENTRANT\n-\t/* Better late than never.  This fails if system headers that\t*/\n-\t/* depend on this were previously included.\t\t\t*/\n-#endif\n-\n-#if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n-#   define GC_SOLARIS_THREADS\n-#endif\n-\n-# if defined(GC_SOLARIS_PTHREADS) || defined(GC_FREEBSD_THREADS) || \\\n-\tdefined(GC_IRIX_THREADS) || defined(GC_LINUX_THREADS) || \\\n-\tdefined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n-#   define GC_PTHREADS\n-# endif\n-\n-# define __GC\n-# include <stddef.h>\n-# ifdef _WIN32_WCE\n-/* Yet more kluges for WinCE */\n-#   include <stdlib.h>\t\t/* size_t is defined here */\n-    typedef long ptrdiff_t;\t/* ptrdiff_t is not defined */\n-# endif\n-\n-#if defined(__MINGW32__) &&defined(_DLL) && !defined(GC_NOT_DLL)\n-# ifdef GC_BUILD\n-#   define GC_API __declspec(dllexport)\n-# else\n-#   define GC_API __declspec(dllimport)\n-# endif\n-#endif\n-\n-#if (defined(__DMC__) || defined(_MSC_VER)) \\\n-\t\t&& (defined(_DLL) && !defined(GC_NOT_DLL) \\\n-\t            || defined(GC_DLL))\n-# ifdef GC_BUILD\n-#   define GC_API extern __declspec(dllexport)\n-# else\n-#   define GC_API __declspec(dllimport)\n-# endif\n-#endif\n-\n-#if defined(__WATCOMC__) && defined(GC_DLL)\n-# ifdef GC_BUILD\n-#   define GC_API extern __declspec(dllexport)\n-# else\n-#   define GC_API extern __declspec(dllimport)\n-# endif\n-#endif\n-\n-#ifndef GC_API\n-#define GC_API extern\n-#endif\n+# include \"gc_config_macros.h\"\n \n # if defined(__STDC__) || defined(__cplusplus)\n #   define GC_PROTO(args) args\n@@ -154,7 +70,7 @@ GC_API int GC_parallel;\t/* GC is parallelized for performance on\t*/\n \t\t\t/*  Env variable GC_NPROC is set to > 1, or\t*/\n \t\t\t/*  GC_NPROC is not set and this is an MP.\t*/\n \t\t\t/* If GC_parallel is set, incremental\t\t*/\n-\t\t\t/* collection is aonly partially functional,\t*/\n+\t\t\t/* collection is only partially functional,\t*/\n \t\t\t/* and may not be desirable.\t\t\t*/\n \t\t\t\n \n@@ -215,8 +131,14 @@ GC_API void (* GC_finalizer_notifier)();\n \t\t\t/* thread, which will call GC_invoke_finalizers */\n \t\t\t/* in response.\t\t\t\t\t*/\n \n-GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n-\t\t\t/* because it's not safe.\t\t\t  */\n+GC_API int GC_dont_gc;\t/* != 0 ==> Dont collect.  In versions 6.2a1+,\t*/\n+\t\t\t/* this overrides explicit GC_gcollect() calls.\t*/\n+\t\t\t/* Used as a counter, so that nested enabling\t*/\n+\t\t\t/* and disabling work correctly.  Should\t*/\n+\t\t\t/* normally be updated with GC_enable() and\t*/\n+\t\t\t/* GC_disable() calls.\t\t\t\t*/\n+\t\t\t/* Direct assignment to GC_dont_gc is \t\t*/\n+\t\t\t/* deprecated.\t\t\t\t\t*/\n \n GC_API int GC_dont_expand;\n \t\t\t/* Dont expand heap unless explicitly requested */\n@@ -316,9 +238,18 @@ GC_API unsigned long GC_time_limit;\n \t\t\t\t/* enabled.\t \t\t\t */\n #\tdefine GC_TIME_UNLIMITED 999999\n \t\t\t\t/* Setting GC_time_limit to this value\t */\n-\t\t\t\t/* will disable the \"pause time exceeded */\n+\t\t\t\t/* will disable the \"pause time exceeded\"*/\n \t\t\t\t/* tests.\t\t\t\t */\n \n+/* Public procedures */\n+\n+/* Initialize the collector.  This is only required when using thread-local\n+ * allocation, since unlike the regular allocation routines, GC_local_malloc\n+ * is not self-initializing.  If you use GC_local_malloc you should arrange\n+ * to call this somehow (e.g. from a constructor) before doing any allocation.\n+ */\n+GC_API void GC_init GC_PROTO((void));\n+\n /*\n  * general purpose allocation routines, with roughly malloc calling conv.\n  * The atomic versions promise that no relevant pointers are contained\n@@ -419,17 +350,21 @@ GC_API void GC_clear_roots GC_PROTO((void));\n GC_API void GC_add_roots GC_PROTO((char * low_address,\n \t\t\t\t   char * high_address_plus_1));\n \n+/* Remove a root segment.  Wizards only. */\n+GC_API void GC_remove_roots GC_PROTO((char * low_address, \n+    char * high_address_plus_1));\n+\n /* Add a displacement to the set of those considered valid by the\t*/\n /* collector.  GC_register_displacement(n) means that if p was returned */\n /* by GC_malloc, then (char *)p + n will be considered to be a valid\t*/\n-/* pointer to n.  N must be small and less than the size of p.\t\t*/\n+/* pointer to p.  N must be small and less than the size of p.\t\t*/\n /* (All pointers to the interior of objects from the stack are\t\t*/\n /* considered valid in any case.  This applies to heap objects and\t*/\n /* static data.)\t\t\t\t\t\t\t*/\n /* Preferably, this should be called before any other GC procedures.\t*/\n /* Calling it later adds to the probability of excess memory\t\t*/\n /* retention.\t\t\t\t\t\t\t\t*/\n-/* This is a no-op if the collector was compiled with recognition of\t*/\n+/* This is a no-op if the collector has recognition of\t\t\t*/\n /* arbitrary interior pointers enabled, which is now the default.\t*/\n GC_API void GC_register_displacement GC_PROTO((GC_word n));\n \n@@ -464,17 +399,30 @@ GC_API size_t GC_get_free_bytes GC_PROTO((void));\n GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n \n /* Return the total number of bytes allocated in this process.\t\t*/\n-/* Never decreases.\t\t\t\t\t\t\t*/\n+/* Never decreases, except due to wrapping.\t\t\t\t*/\n GC_API size_t GC_get_total_bytes GC_PROTO((void));\n \n+/* Disable garbage collection.  Even GC_gcollect calls will be \t\t*/\n+/* ineffective.\t\t\t\t\t\t\t\t*/\n+GC_API void GC_disable GC_PROTO((void));\n+\n+/* Reenable garbage collection.  GC_disable() and GC_enable() calls \t*/\n+/* nest.  Garbage collection is enabled if the number of calls to both\t*/\n+/* both functions is equal.\t\t\t\t\t\t*/\n+GC_API void GC_enable GC_PROTO((void));\n+\n /* Enable incremental/generational collection.\t*/\n /* Not advisable unless dirty bits are \t\t*/\n /* available or most heap objects are\t\t*/\n /* pointerfree(atomic) or immutable.\t\t*/\n /* Don't use in leak finding mode.\t\t*/\n /* Ignored if GC_dont_gc is true.\t\t*/\n /* Only the generational piece of this is\t*/\n-/* functional if GC_parallel is TRUE.\t\t*/\n+/* functional if GC_parallel is TRUE\t\t*/\n+/* or if GC_time_limit is GC_TIME_UNLIMITED.\t*/\n+/* Causes GC_local_gcj_malloc() to revert to\t*/\n+/* locked allocation.  Must be called \t\t*/\n+/* before any GC_local_gcj_malloc() calls.\t*/\n GC_API void GC_enable_incremental GC_PROTO((void));\n \n /* Does incremental mode write-protect pages?  Returns zero or\t*/\n@@ -518,6 +466,42 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n #   define GC_RETURN_ADDR (GC_word)__return_address\n #endif\n \n+#ifdef __linux__\n+# include <features.h>\n+# if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2) \\\n+     && !defined(__ia64__)\n+#   define GC_HAVE_BUILTIN_BACKTRACE\n+#   define GC_CAN_SAVE_CALL_STACKS\n+# endif\n+# if defined(__i386__) || defined(__x86_64__)\n+#   define GC_CAN_SAVE_CALL_STACKS\n+# endif\n+#endif\n+\n+#if defined(__sparc__)\n+#   define GC_CAN_SAVE_CALL_STACKS\n+#endif\n+\n+/* If we're on an a platform on which we can't save call stacks, but\t*/\n+/* gcc is normally used, we go ahead and define GC_ADD_CALLER.  \t*/\n+/* We make this decision independent of whether gcc is actually being\t*/\n+/* used, in order to keep the interface consistent, and allow mixing\t*/\n+/* of compilers.\t\t\t\t\t\t\t*/\n+/* This may also be desirable if it is possible but expensive to\t*/\n+/* retrieve the call chain.\t\t\t\t\t\t*/\n+#if (defined(__linux__) || defined(__NetBSD__) || defined(__OpenBSD__) \\\n+     || defined(__FreeBSD__)) & !defined(GC_CAN_SAVE_CALL_STACKS)\n+# define GC_ADD_CALLER\n+# if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95) \n+    /* gcc knows how to retrieve return address, but we don't know */\n+    /* how to generate call stacks.\t\t\t\t   */\n+#   define GC_RETURN_ADDR (GC_word)__builtin_return_address(0)\n+# else\n+    /* Just pass 0 for gcc compatibility. */\n+#   define GC_RETURN_ADDR 0\n+# endif\n+#endif\n+\n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n #  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s, int i\n@@ -536,18 +520,42 @@ GC_API GC_PTR GC_debug_malloc_uncollectable\n \tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n GC_API GC_PTR GC_debug_malloc_stubborn\n \tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_ignore_off_page\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_atomic_ignore_off_page\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));\n GC_API GC_PTR GC_debug_realloc\n \tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,\n   \t\t  GC_EXTRA_PARAMS));\n-  \t\t\t \t \n GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));\n GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n+\n+/* Routines that allocate objects with debug information (like the \t*/\n+/* above), but just fill in dummy file and line number information.\t*/\n+/* Thus they can serve as drop-in malloc/realloc replacements.  This\t*/\n+/* can be useful for two reasons:  \t\t\t\t\t*/\n+/* 1) It allows the collector to be built with DBG_HDRS_ALL defined\t*/\n+/*    even if some allocation calls come from 3rd party libraries\t*/\n+/*    that can't be recompiled.\t\t\t\t\t\t*/\n+/* 2) On some platforms, the file and line information is redundant,\t*/\n+/*    since it can be reconstructed from a stack trace.  On such\t*/\n+/*    platforms it may be more convenient not to recompile, e.g. for\t*/\n+/*    leak detection.  This can be accomplished by instructing the\t*/\n+/*    linker to replace malloc/realloc with these.\t\t\t*/\n+GC_API GC_PTR GC_debug_malloc_replacement GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_debug_realloc_replacement\n+\t      GC_PROTO((GC_PTR object_addr, size_t size_in_bytes));\n+  \t\t\t \t \n # ifdef GC_DEBUG\n #   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)\n #   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)\n-#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \\\n-\t\t\t\t\t\t\tGC_EXTRAS)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) \\\n+\t\t\tGC_debug_malloc_uncollectable(sz, GC_EXTRAS)\n+#   define GC_MALLOC_IGNORE_OFF_PAGE(sz) \\\n+\t\t\tGC_debug_malloc_ignore_off_page(sz, GC_EXTRAS)\n+#   define GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE(sz) \\\n+\t\t\tGC_debug_malloc_atomic_ignore_off_page(sz, GC_EXTRAS)\n #   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)\n #   define GC_FREE(p) GC_debug_free(p)\n #   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n@@ -566,6 +574,10 @@ GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n #   define GC_MALLOC(sz) GC_malloc(sz)\n #   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)\n #   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)\n+#   define GC_MALLOC_IGNORE_OFF_PAGE(sz) \\\n+\t\t\tGC_malloc_ignore_off_page(sz)\n+#   define GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE(sz) \\\n+\t\t\tGC_malloc_atomic_ignore_off_page(sz)\n #   define GC_REALLOC(old, sz) GC_realloc(old, sz)\n #   define GC_FREE(p) GC_free(p)\n #   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n@@ -644,7 +656,8 @@ GC_API void GC_debug_register_finalizer\n /* itself.  There is a stylistic argument that this is wrong,\t*/\n /* but it's unavoidable for C++, since the compiler may\t\t*/\n /* silently introduce these.  It's also benign in that specific\t*/\n-/* case.\t\t\t\t\t\t\t*/\n+/* case.  And it helps if finalizable objects are split to\t*/\n+/* avoid cycles.\t\t\t\t\t\t*/\n /* Note that cd will still be viewed as accessible, even if it\t*/\n /* refers to the object itself.\t\t\t\t\t*/\n GC_API void GC_register_finalizer_ignore_self\n@@ -717,11 +730,6 @@ GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n \t/* Undoes a registration by either of the above two\t*/\n \t/* routines.\t\t\t\t\t\t*/\n \n-/* Auxiliary fns to make finalization work correctly with displaced\t*/\n-/* pointers introduced by the debugging allocators.\t\t\t*/\n-GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n-GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n-\n /* Returns !=0  if GC_invoke_finalizers has something to do. \t\t*/\n GC_API int GC_should_invoke_finalizers GC_PROTO((void));\n \n@@ -738,6 +746,10 @@ GC_API int GC_invoke_finalizers GC_PROTO((void));\n typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));\n GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n     /* Returns old warning procedure.\t*/\n+\n+GC_API GC_word GC_set_free_space_divisor GC_PROTO((GC_word value));\n+    /* Set free_space_divisor.  See above for definition.\t*/\n+    /* Returns old value.\t\t\t\t\t*/\n \t\n /* The following is intended to be used by a higher level\t*/\n /* (e.g. Java-like) finalization facility.  It is expected\t*/\n@@ -873,14 +885,17 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n \n #endif /* THREADS && !SRC_M3 */\n \n-#if defined(GC_WIN32_THREADS)\n+#if defined(GC_WIN32_THREADS) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)\n # include <windows.h>\n \n   /*\n    * All threads must be created using GC_CreateThread, so that they will be\n-   * recorded in the thread table.\n+   * recorded in the thread table.  For backwards compatibility, this is not\n+   * technically true if the GC is built as a dynamic library, since it can\n+   * and does then use DllMain to keep track of thread creations.  But new code\n+   * should be built to call GC_CreateThread.\n    */\n-  HANDLE WINAPI GC_CreateThread(\n+  GC_API HANDLE GC_CreateThread(\n       LPSECURITY_ATTRIBUTES lpThreadAttributes,\n       DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress,\n       LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );\n@@ -902,7 +917,7 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n #  endif\n # endif /* defined(_WIN32_WCE) */\n \n-#endif /* defined(GC_WIN32_THREADS) */\n+#endif /* defined(GC_WIN32_THREADS)  && !cygwin */\n \n /*\n  * If you are planning on putting\n@@ -914,13 +929,18 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n #   define GC_INIT() { extern end, etext; \\\n \t\t       GC_noop(&end, &etext); }\n #else\n-# if (defined(__CYGWIN32__) && defined(GC_USE_DLL)) || defined (_AIX)\n+# if defined(__CYGWIN32__) && defined(GC_DLL) || defined (_AIX)\n     /*\n-     * Similarly gnu-win32 DLLs need explicit initialization\n+     * Similarly gnu-win32 DLLs need explicit initialization from\n+     * the main program, as does AIX.\n      */\n #   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n # else\n+#  if defined(__APPLE__) && defined(__MACH__)\n+#   define GC_INIT() { GC_init(); }\n+#  else\n #   define GC_INIT()\n+#  endif\n # endif\n #endif\n "}, {"sha": "d789a3731e33a7ef5b7b1271776ac566c27b6e4b", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -134,7 +134,9 @@ by UseGC.  GC is an alias for UseGC, unless GC_NAME_CONFLICT is defined.\n #include \"gc.h\"\n \n #ifndef THINK_CPLUS\n-#define _cdecl\n+#  define GC_cdecl\n+#else\n+#  define GC_cdecl _cdecl\n #endif\n \n #if ! defined( GC_NO_OPERATOR_NEW_ARRAY ) \\\n@@ -159,12 +161,22 @@ enum GCPlacement {UseGC,\n class gc {public:\n     inline void* operator new( size_t size );\n     inline void* operator new( size_t size, GCPlacement gcp );\n+    inline void* operator new( size_t size, void *p );\n+    \t/* Must be redefined here, since the other overloadings\t*/\n+    \t/* hide the global definition.\t\t\t\t*/\n     inline void operator delete( void* obj );\n+#   ifndef __BORLANDC__  /* Confuses the Borland compiler. */\n+      inline void operator delete( void*, void* );\n+#   endif\n \n #ifdef GC_OPERATOR_NEW_ARRAY\n     inline void* operator new[]( size_t size );\n     inline void* operator new[]( size_t size, GCPlacement gcp );\n+    inline void* operator new[]( size_t size, void *p );\n     inline void operator delete[]( void* obj );\n+#   ifndef __BORLANDC__\n+      inline void gc::operator delete[]( void*, void* );\n+#   endif\n #endif /* GC_OPERATOR_NEW_ARRAY */\n     };    \n     /*\n@@ -176,7 +188,7 @@ class gc_cleanup: virtual public gc {public:\n     inline gc_cleanup();\n     inline virtual ~gc_cleanup();\n private:\n-    inline static void _cdecl cleanup( void* obj, void* clientData );};\n+    inline static void GC_cdecl cleanup( void* obj, void* clientData );};\n     /*\n     Instances of classes derived from \"gc_cleanup\" will be allocated\n     in the collected heap by default.  When the collector discovers an\n@@ -211,7 +223,6 @@ inline void* operator new(\n     classes derived from \"gc_cleanup\" or containing members derived\n     from \"gc_cleanup\". */\n \n-#ifdef GC_OPERATOR_NEW_ARRAY\n \n #ifdef _MSC_VER\n  /** This ensures that the system default operator new[] doesn't get\n@@ -220,42 +231,24 @@ inline void* operator new(\n   *  There seems to be really redirect new in this environment without\n   *  including this everywhere. \n   */\n- inline void *operator new[]( size_t size )\n- {\n-    return GC_MALLOC_UNCOLLECTABLE( size );\n- }\n-\n- inline void operator delete[](void* obj)\n- {\n-    GC_FREE(obj);\n- };\n-\n- inline void* operator new( size_t size)\n- {\n-    return GC_MALLOC_UNCOLLECTABLE( size);\n- };   \n+ void *operator new[]( size_t size );\n+ \n+ void operator delete[](void* obj);\n \n- inline void operator delete(void* obj)\n- {\n-    GC_FREE(obj);\n- };\n+ void* operator new( size_t size);\n \n+ void operator delete(void* obj);\n \n-// This new operator is used by VC++ in case of Debug builds !\n-  inline void* operator new( size_t size,\n+ // This new operator is used by VC++ in case of Debug builds !\n+ void* operator new(  size_t size,\n \t\t      int ,//nBlockUse,\n \t\t      const char * szFileName,\n-\t\t      int nLine\n-\t\t      ) {\n-# ifndef GC_DEBUG\n-     return GC_malloc_uncollectable( size );\n-# else\n-     return GC_debug_malloc_uncollectable(size, szFileName, nLine);\n-# endif\n-  }\n-\n+\t\t      int nLine );\n #endif /* _MSC_VER */\n \n+\n+#ifdef GC_OPERATOR_NEW_ARRAY\n+\n inline void* operator new[](\n     size_t size, \n     GCPlacement gcp,\n@@ -283,9 +276,15 @@ inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n     else\n         return GC_MALLOC_UNCOLLECTABLE( size );}\n \n+inline void* gc::operator new( size_t size, void *p ) {\n+    return p;}\n+\n inline void gc::operator delete( void* obj ) {\n     GC_FREE( obj );}\n     \n+#ifndef __BORLANDC__\n+  inline void gc::operator delete( void*, void* ) {}\n+#endif\n \n #ifdef GC_OPERATOR_NEW_ARRAY\n \n@@ -295,14 +294,21 @@ inline void* gc::operator new[]( size_t size ) {\n inline void* gc::operator new[]( size_t size, GCPlacement gcp ) {\n     return gc::operator new( size, gcp );}\n \n+inline void* gc::operator new[]( size_t size, void *p ) {\n+    return p;}\n+\n inline void gc::operator delete[]( void* obj ) {\n     gc::operator delete( obj );}\n+\n+#ifndef __BORLANDC__\n+  inline void gc::operator delete[]( void*, void* ) {}\n+#endif\n     \n #endif /* GC_OPERATOR_NEW_ARRAY */\n \n \n inline gc_cleanup::~gc_cleanup() {\n-    GC_REGISTER_FINALIZER_IGNORE_SELF( GC_base(this), 0, 0, 0, 0 );}\n+    GC_register_finalizer_ignore_self( GC_base(this), 0, 0, 0, 0 );}\n \n inline void gc_cleanup::cleanup( void* obj, void* displ ) {\n     ((gc_cleanup*) ((char*) obj + (ptrdiff_t) displ))->~gc_cleanup();}"}, {"sha": "88e29e9a11f24d32f5e0356b1ec6a8a7f785239f", "filename": "boehm-gc/include/gc_local_alloc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_local_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_local_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_local_alloc.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -33,6 +33,9 @@\n  * -DTHREAD_LOCAL_ALLOC, which is currently supported only on Linux.\n  *\n  * The debugging allocators use standard, not thread-local allocation.\n+ *\n+ * These routines normally require an explicit call to GC_init(), though\n+ * that may be done from a constructor function.\n  */\n \n #ifndef GC_LOCAL_ALLOC_H"}, {"sha": "9ddba2ca527464f9deb155babb5a73766184f643", "filename": "boehm-gc/include/gc_mark.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_mark.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -129,7 +129,9 @@ extern GC_PTR GC_greatest_plausible_heap_addr;\n /* be reserved for exceptional cases.  That will ensure that \t\t*/\n /* performance of this call is not extremely performance critical.\t*/\n /* (Otherwise we would need to inline GC_mark_and_push completely,\t*/\n-/* which would tie the client code to a fixed colllector version.)\t*/\n+/* which would tie the client code to a fixed collector version.)\t*/\n+/* Note that mark procedures should explicitly call FIXUP_POINTER()\t*/\n+/* if required.\t\t\t\t\t\t\t\t*/\n struct GC_ms_entry *GC_mark_and_push\n \t\tGC_PROTO((GC_PTR obj,\n \t\t\t  struct GC_ms_entry * mark_stack_ptr,"}, {"sha": "842518cfcc48c2a0657b1cc6581994abf5cd8a44", "filename": "boehm-gc/include/gc_pthread_redirects.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_pthread_redirects.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_pthread_redirects.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -52,15 +52,30 @@\n   int GC_pthread_create(pthread_t *new_thread,\n                         const pthread_attr_t *attr,\n \t\t        void *(*start_routine)(void *), void *arg);\n+#ifndef GC_DARWIN_THREADS\n   int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n+#endif\n   int GC_pthread_join(pthread_t thread, void **retval);\n   int GC_pthread_detach(pthread_t thread);\n \n+#if defined(GC_OSF1_THREADS) \\\n+    && defined(_PTHREAD_USE_MANGLED_NAMES_) && !defined(_PTHREAD_USE_PTDNAM_)\n+/* Unless the compiler supports #pragma extern_prefix, the Tru64 UNIX\n+   <pthread.h> redefines some POSIX thread functions to use mangled names.\n+   If so, undef them before redefining. */\n+# undef pthread_create\n+# undef pthread_join\n+# undef pthread_detach\n+#endif\n+\n # define pthread_create GC_pthread_create\n-# define pthread_sigmask GC_pthread_sigmask\n # define pthread_join GC_pthread_join\n # define pthread_detach GC_pthread_detach\n+\n+#ifndef GC_DARWIN_THREADS\n+# define pthread_sigmask GC_pthread_sigmask\n # define dlopen GC_dlopen\n+#endif\n \n #endif /* GC_xxxxx_THREADS */\n "}, {"sha": "905734b8da0f550c3833c8dd21f09b7c23828bb2", "filename": "boehm-gc/include/gc_typed.h", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_typed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fgc_typed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_typed.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -29,14 +29,21 @@\n #   include \"gc.h\"\n # endif\n \n+#ifdef __cplusplus\n+  extern \"C\" {\n+#endif\n typedef GC_word * GC_bitmap;\n \t/* The least significant bit of the first word is one if\t*/\n \t/* the first word in the object may be a pointer.\t\t*/\n \t\n+# define GC_WORDSZ (8*sizeof(GC_word))\n # define GC_get_bit(bm, index) \\\n-\t\t(((bm)[divWORDSZ(index)] >> modWORDSZ(index)) & 1)\n+\t\t(((bm)[index/GC_WORDSZ] >> (index%GC_WORDSZ)) & 1)\n # define GC_set_bit(bm, index) \\\n-\t\t(bm)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n+\t\t(bm)[index/GC_WORDSZ] |= ((GC_word)1 << (index%GC_WORDSZ))\n+# define GC_WORD_OFFSET(t, f) (offsetof(t,f)/sizeof(GC_word))\n+# define GC_WORD_LEN(t) (sizeof(t)/ sizeof(GC_word))\n+# define GC_BITMAP_SIZE(t) ((GC_WORD_LEN(t) + GC_WORDSZ-1)/GC_WORDSZ)\n \n typedef GC_word GC_descr;\n \n@@ -57,6 +64,16 @@ GC_API GC_descr GC_make_descriptor GC_PROTO((GC_bitmap bm, size_t len));\n \t\t/* is intended to be called once per type, not once\t*/\n \t\t/* per allocation.\t\t\t\t\t*/\n \n+/* It is possible to generate a descriptor for a C type T with\t*/\n+/* word aligned pointer fields f1, f2, ... as follows:\t\t\t*/\n+/*\t\t\t\t\t\t\t\t\t*/\n+/* GC_descr T_descr;                                                    */\n+/* GC_word T_bitmap[GC_BITMAP_SIZE(T)] = {0};\t\t\t\t*/\n+/* GC_set_bit(T_bitmap, GC_WORD_OFFSET(T,f1));\t\t\t\t*/\n+/* GC_set_bit(T_bitmap, GC_WORD_OFFSET(T,f2));\t\t\t\t*/\n+/* ...\t\t\t\t\t\t\t\t\t*/\n+/* T_descr = GC_make_descriptor(T_bitmap, GC_WORD_LEN(T));\t\t*/\n+\n GC_API GC_PTR GC_malloc_explicitly_typed\n \t\t\tGC_PROTO((size_t size_in_bytes, GC_descr d));\n \t\t/* Allocate an object whose layout is described by d.\t*/\n@@ -79,15 +96,18 @@ GC_API GC_PTR GC_calloc_explicitly_typed\n \t/* Returned object is cleared.\t\t\t\t*/\n \n #ifdef GC_DEBUG\n-#   define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) GC_MALLOC(bytes)\n-#   define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) GC_MALLOC(n*bytes)\n+#   define GC_MALLOC_EXPLICITLY_TYPED(bytes, d) GC_MALLOC(bytes)\n+#   define GC_CALLOC_EXPLICITLY_TYPED(n, bytes, d) GC_MALLOC(n*bytes)\n #else\n-#  define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) \\\n+#  define GC_MALLOC_EXPLICITLY_TYPED(bytes, d) \\\n \tGC_malloc_explicitly_typed(bytes, d)\n-#  define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) \\\n+#  define GC_CALLOC_EXPLICITLY_TYPED(n, bytes, d) \\\n \tGC_calloc_explicitly_typed(n, bytes, d)\n #endif /* !GC_DEBUG */\n \n+#ifdef __cplusplus\n+  } /* matches extern \"C\" */\n+#endif\n \n #endif /* _GC_TYPED_H */\n "}, {"sha": "20a2fabf83cd636e4c4567f4396892f9f99a59f8", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -64,6 +64,14 @@\n #endif\n #endif\n \n+/* A hack to deal with gcc 3.1.  If you are using gcc3.1 and later,\t*/\n+/* you should probably really use gc_allocator.h instead.\t\t*/\n+#if defined (__GNUC__) && \\\n+    (__GNUC > 3 || (__GNUC__ == 3 && (__GNUC_MINOR__ >= 1)))\n+# define simple_alloc __simple_alloc\n+#endif\n+\n+\n \n #define GC_ALLOC_H\n "}, {"sha": "e2003e6c44f559086c3e0c711c1e96ba1e798ac6", "filename": "boehm-gc/include/private/dbg_mlc.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -115,16 +115,24 @@ typedef struct {\n \n #ifdef SHORT_DBG_HDRS\n #   define DEBUG_BYTES (sizeof (oh))\n+#   define UNCOLLECTABLE_DEBUG_BYTES DEBUG_BYTES\n #else\n     /* Add space for END_FLAG, but use any extra space that was already\t*/\n     /* added to catch off-the-end pointers.\t\t\t\t*/\n-#   define DEBUG_BYTES (sizeof (oh) + sizeof (word) - EXTRA_BYTES)\n+    /* For uncollectable objects, the extra byte is not added.\t\t*/\n+#   define UNCOLLECTABLE_DEBUG_BYTES (sizeof (oh) + sizeof (word))\n+#   define DEBUG_BYTES (UNCOLLECTABLE_DEBUG_BYTES - EXTRA_BYTES)\n #endif\n #define USR_PTR_FROM_BASE(p) ((ptr_t)(p) + sizeof(oh))\n \n /* Round bytes to words without adding extra byte at end.\t*/\n #define SIMPLE_ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n \n+/* ADD_CALL_CHAIN stores a (partial) call chain into an object\t*/\n+/* header.  It may be called with or without the allocation \t*/\n+/* lock.\t\t\t\t\t\t\t*/\n+/* PRINT_CALL_CHAIN prints the call chain stored in an object\t*/\n+/* to stderr.  It requires that we do not hold the lock.\t*/\n #ifdef SAVE_CALL_CHAIN\n #   define ADD_CALL_CHAIN(base, ra) GC_save_callers(((oh *)(base)) -> oh_ci)\n #   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)"}, {"sha": "96749ab1bf02cfd1118dc348d17794c6c20e1bf1", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -70,7 +70,7 @@ extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n #define ADVANCE(p, hhdr, source) \\\n \t    { \\\n \t      hdr * new_hdr = GC_invalid_header; \\\n-              p = GC_FIND_START(p, hhdr, &new_hdr, (word)source); \\\n+              p = GC_find_start(p, hhdr, &new_hdr); \\\n \t      hhdr = new_hdr; \\\n     \t    }\n "}, {"sha": "775176b31519aea4d46e6636cbbfba2d16f4d684", "filename": "boehm-gc/include/private/gc_locks.h", "status": "modified", "additions": 191, "deletions": 54, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -141,23 +141,24 @@\n #    if defined(POWERPC)\n         inline static int GC_test_and_set(volatile unsigned int *addr) {\n           int oldval;\n-          int temp = 1; // locked value\n+          int temp = 1; /* locked value */\n \n           __asm__ __volatile__(\n-               \"1:\\tlwarx %0,0,%3\\n\"   // load and reserve\n-               \"\\tcmpwi %0, 0\\n\"       // if load is\n-               \"\\tbne 2f\\n\"            //   non-zero, return already set\n-               \"\\tstwcx. %2,0,%1\\n\"    // else store conditional\n-               \"\\tbne- 1b\\n\"           // retry if lost reservation\n-               \"2:\\t\\n\"                // oldval is zero if we set\n+               \"1:\\tlwarx %0,0,%3\\n\"   /* load and reserve               */\n+               \"\\tcmpwi %0, 0\\n\"       /* if load is                     */\n+               \"\\tbne 2f\\n\"            /*   non-zero, return already set */\n+               \"\\tstwcx. %2,0,%1\\n\"    /* else store conditional         */\n+               \"\\tbne- 1b\\n\"           /* retry if lost reservation      */\n+               \"\\tsync\\n\"              /* import barrier                 */\n+               \"2:\\t\\n\"                /* oldval is zero if we set       */\n               : \"=&r\"(oldval), \"=p\"(addr)\n               : \"r\"(temp), \"1\"(addr)\n-              : \"memory\");\n-          return (int)oldval;\n+              : \"cr0\",\"memory\");\n+          return oldval;\n         }\n #       define GC_TEST_AND_SET_DEFINED\n         inline static void GC_clear(volatile unsigned int *addr) {\n-\t  __asm__ __volatile__(\"eieio\" ::: \"memory\");\n+\t  __asm__ __volatile__(\"eieio\" : : : \"memory\");\n           *(addr) = 0;\n         }\n #       define GC_CLEAR_DEFINED\n@@ -174,21 +175,30 @@\n                              \"       bne %2,2f\\n\"\n                              \"       xor %0,%3,%0\\n\"\n                              \"       stl_c %0,%1\\n\"\n+#\tifdef __ELF__\n                              \"       beq %0,3f\\n\"\n+#\telse\n+                             \"       beq %0,1b\\n\"\n+#\tendif\n                              \"       mb\\n\"\n                              \"2:\\n\"\n+#\tifdef __ELF__\n                              \".section .text2,\\\"ax\\\"\\n\"\n                              \"3:     br 1b\\n\"\n                              \".previous\"\n+#\tendif\n                              :\"=&r\" (temp), \"=m\" (*addr), \"=&r\" (oldvalue)\n                              :\"Ir\" (1), \"m\" (*addr)\n \t\t\t     :\"memory\");\n \n           return oldvalue;\n         }\n #       define GC_TEST_AND_SET_DEFINED\n-        /* Should probably also define GC_clear, since it needs\t*/\n-        /* a memory barrier ??\t\t\t\t\t*/\n+        inline static void GC_clear(volatile unsigned int *addr) {\n+          __asm__ __volatile__(\"mb\" : : : \"memory\");\n+          *(addr) = 0;\n+        }\n+#       define GC_CLEAR_DEFINED\n #    endif /* ALPHA */\n #    ifdef ARM32\n         inline static int GC_test_and_set(volatile unsigned int *addr) {\n@@ -206,22 +216,30 @@\n #       define GC_TEST_AND_SET_DEFINED\n #    endif /* ARM32 */\n #    ifdef S390\n-\tinline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t int ret;\n-\t __asm__ __volatile__ (\n-\t\t\"\tl\t%0,0(%2)\\n\"\n-\t\t\"0:\tcs\t%0,%1,0(%2)\\n\"\n-\t\t\"\tjl\t0b\"\n-\t\t: \"=&d\" (ret)\n-\t\t: \"d\" (1), \"a\" (addr)\n-\t\t: \"cc\", \"memory\");\n-\t  return ret;\n-\t}\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+         int ret;\n+         __asm__ __volatile__ (\n+          \"     l     %0,0(%2)\\n\"\n+          \"0:   cs    %0,%1,0(%2)\\n\"\n+          \"     jl    0b\"\n+          : \"=&d\" (ret)\n+          : \"d\" (1), \"a\" (addr)\n+          : \"cc\", \"memory\");\n+         return ret;\n+       }\n #    endif\n #  endif /* __GNUC__ */\n #  if (defined(ALPHA) && !defined(__GNUC__))\n-#    define GC_test_and_set(addr) __cxx_test_and_set_atomic(addr, 1)\n+#    ifndef OSF1\n+\t--> We currently assume that if gcc is not used, we are\n+\t--> running under Tru64.\n+#    endif\n+#    include <machine/builtins.h>\n+#    include <c_asm.h>\n+#    define GC_test_and_set(addr) __ATOMIC_EXCH_LONG(addr, 1)\n #    define GC_TEST_AND_SET_DEFINED\n+#    define GC_clear(addr) { asm(\"mb\"); *(volatile unsigned *)addr = 0; }\n+#    define GC_CLEAR_DEFINED\n #  endif\n #  if defined(MSWIN32)\n #    define GC_test_and_set(addr) InterlockedExchange((LPLONG)addr,1)\n@@ -234,14 +252,51 @@\n #      define GC_TEST_AND_SET_DEFINED\n #    elif __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n \t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n-#        define GC_test_and_set(addr) test_and_set(addr, 1)\n+#\t ifdef __GNUC__\n+#          define GC_test_and_set(addr) _test_and_set((void *)addr,1)\n+#\t else\n+#          define GC_test_and_set(addr) test_and_set((void *)addr,1)\n+#\t endif\n #    else\n-#\t define GC_test_and_set(addr) __test_and_set(addr,1)\n+#\t define GC_test_and_set(addr) __test_and_set32((void *)addr,1)\n #\t define GC_clear(addr) __lock_release(addr);\n #\t define GC_CLEAR_DEFINED\n #    endif\n #    define GC_TEST_AND_SET_DEFINED\n #  endif /* MIPS */\n+#  if defined(_AIX)\n+#    include <sys/atomic_op.h>\n+#    if (defined(_POWER) || defined(_POWERPC)) \n+#      if defined(__GNUC__)  \n+         inline static void GC_memsync() {\n+           __asm__ __volatile__ (\"sync\" : : : \"memory\");\n+         }\n+#      else\n+#        ifndef inline\n+#          define inline __inline\n+#        endif\n+#        pragma mc_func GC_memsync { \\\n+           \"7c0004ac\" /* sync (same opcode used for dcs)*/ \\\n+         }\n+#      endif\n+#    else \n+#    error dont know how to memsync\n+#    endif\n+     inline static int GC_test_and_set(volatile unsigned int * addr) {\n+          int oldvalue = 0;\n+          if (compare_and_swap((void *)addr, &oldvalue, 1)) {\n+            GC_memsync();\n+            return 0;\n+          } else return 1;\n+     }\n+#    define GC_TEST_AND_SET_DEFINED\n+     inline static void GC_clear(volatile unsigned int *addr) {\n+          GC_memsync();\n+          *(addr) = 0;\n+     }\n+#    define GC_CLEAR_DEFINED\n+\n+#  endif\n #  if 0 /* defined(HP_PA) */\n      /* The official recommendation seems to be to not use ldcw from\t*/\n      /* user mode.  Since multithreaded incremental collection doesn't\t*/\n@@ -275,7 +330,7 @@\n #  endif\n \n #  if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n-      && !defined(GC_IRIX_THREADS)\n+      && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS)\n #    define NO_THREAD (pthread_t)(-1)\n #    include <pthread.h>\n #    if defined(PARALLEL_MARK) \n@@ -306,19 +361,50 @@\n          {\n \t   char result;\n \t   __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n-\t    \t: \"=m\"(*(addr)), \"=r\"(result)\n-\t\t: \"r\" (new_val), \"0\"(*(addr)), \"a\"(old) : \"memory\");\n+\t    \t: \"+m\"(*(addr)), \"=r\"(result)\n+\t\t: \"r\" (new_val), \"a\"(old) : \"memory\");\n \t   return (GC_bool) result;\n          }\n #      endif /* !GENERIC_COMPARE_AND_SWAP */\n-       inline static void GC_memory_write_barrier()\n+       inline static void GC_memory_barrier()\n        {\n \t /* We believe the processor ensures at least processor\t*/\n \t /* consistent ordering.  Thus a compiler barrier\t*/\n \t /* should suffice.\t\t\t\t\t*/\n          __asm__ __volatile__(\"\" : : : \"memory\");\n        }\n #     endif /* I386 */\n+\n+#     if defined(POWERPC)\n+#      if !defined(GENERIC_COMPARE_AND_SWAP)\n+        /* Returns TRUE if the comparison succeeded. */\n+        inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+            GC_word old, GC_word new_val) \n+        {\n+            int result, dummy;\n+            __asm__ __volatile__(\n+                \"1:\\tlwarx %0,0,%5\\n\"\n+                  \"\\tcmpw %0,%4\\n\"\n+                  \"\\tbne  2f\\n\"\n+                  \"\\tstwcx. %3,0,%2\\n\"\n+                  \"\\tbne- 1b\\n\"\n+                  \"\\tsync\\n\"\n+                  \"\\tli %1, 1\\n\"\n+                  \"\\tb 3f\\n\"\n+                \"2:\\tli %1, 0\\n\"\n+                \"3:\\t\\n\"\n+                :  \"=&r\" (dummy), \"=r\" (result), \"=p\" (addr)\n+                :  \"r\" (new_val), \"r\" (old), \"2\"(addr)\n+                : \"cr0\",\"memory\");\n+            return (GC_bool) result;\n+        }\n+#      endif /* !GENERIC_COMPARE_AND_SWAP */\n+        inline static void GC_memory_barrier()\n+        {\n+            __asm__ __volatile__(\"sync\" : : : \"memory\");\n+        }\n+#     endif /* POWERPC */\n+\n #     if defined(IA64)\n #      if !defined(GENERIC_COMPARE_AND_SWAP)\n          inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n@@ -330,31 +416,71 @@\n #      endif /* !GENERIC_COMPARE_AND_SWAP */\n #      if 0\n \t/* Shouldn't be needed; we use volatile stores instead. */\n-        inline static void GC_memory_write_barrier()\n+        inline static void GC_memory_barrier()\n         {\n           __sync_synchronize ();\n         }\n #      endif /* 0 */\n #     endif /* IA64 */\n+#     if defined(ALPHA)\n+#      if !defined(GENERIC_COMPARE_AND_SWAP)\n+#        if defined(__GNUC__)\n+           inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+\t\t\t\t\t\t         GC_word old, GC_word new_val) \n+\t   {\n+\t     unsigned long was_equal;\n+             unsigned long temp;\n+\n+             __asm__ __volatile__(\n+                             \"1:     ldq_l %0,%1\\n\"\n+                             \"       cmpeq %0,%4,%2\\n\"\n+\t\t\t     \"\t     mov %3,%0\\n\"\n+                             \"       beq %2,2f\\n\"\n+                             \"       stq_c %0,%1\\n\"\n+                             \"       beq %0,1b\\n\"\n+                             \"2:\\n\"\n+                             \"       mb\\n\"\n+                             :\"=&r\" (temp), \"=m\" (*addr), \"=&r\" (was_equal)\n+                             : \"r\" (new_val), \"Ir\" (old)\n+\t\t\t     :\"memory\");\n+             return was_equal;\n+           }\n+#        else /* !__GNUC__ */\n+           inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+\t\t\t\t\t\t         GC_word old, GC_word new_val) \n+\t  {\n+\t    return __CMP_STORE_QUAD(addr, old, new_val, addr);\n+          }\n+#        endif /* !__GNUC__ */\n+#      endif /* !GENERIC_COMPARE_AND_SWAP */\n+#      ifdef __GNUC__\n+         inline static void GC_memory_barrier()\n+         {\n+           __asm__ __volatile__(\"mb\" : : : \"memory\");\n+         }\n+#      else\n+#\t define GC_memory_barrier() asm(\"mb\")\n+#      endif /* !__GNUC__ */\n+#     endif /* ALPHA */\n #     if defined(S390)\n #      if !defined(GENERIC_COMPARE_AND_SWAP)\n-\t inline static GC_bool GC_compare_and_exchange(volatile C_word *addr,\n-\t\t\t\t\t\t       GC_word old, GC_word new_val) \n-\t {\n-\t   int retval;\n-\t   __asm__ __volatile__ (\n-#          ifndef __s390x__\n-\t\t\"\tcs  %1,%2,0(%3)\\n\"\n-#          else\n-\t\t\"\tcsg %1,%2,0(%3)\\n\"\n-#\t   endif\n-\t\t\"\tipm %0\\n\"\n-\t\t\"\tsrl %0,28\\n\"\n-\t\t: \"=&d\" (retval), \"+d\" (old)\n-\t\t: \"d\" (new_val), \"a\" (addr)\n-\t\t: \"cc\", \"memory\");\n-\t   return retval == 0;\n-\t}\n+         inline static GC_bool GC_compare_and_exchange(volatile C_word *addr,\n+                                         GC_word old, GC_word new_val)\n+         {\n+           int retval;\n+           __asm__ __volatile__ (\n+#            ifndef __s390x__\n+               \"     cs  %1,%2,0(%3)\\n\"\n+#            else\n+               \"     csg %1,%2,0(%3)\\n\"\n+#            endif\n+             \"     ipm %0\\n\"\n+             \"     srl %0,28\\n\"\n+             : \"=&d\" (retval), \"+d\" (old)\n+             : \"d\" (new_val), \"a\" (addr)\n+             : \"cc\", \"memory\");\n+           return retval == 0;\n+         }\n #      endif\n #     endif\n #     if !defined(GENERIC_COMPARE_AND_SWAP)\n@@ -427,8 +553,12 @@\n \t\t{ GC_ASSERT(I_HOLD_LOCK()); UNSET_LOCK_HOLDER(); \\\n \t          pthread_mutex_unlock(&GC_allocate_ml); }\n #      else /* !GC_ASSERTIONS */\n+#        if defined(NO_PTHREAD_TRYLOCK)\n+#          define LOCK() GC_lock();\n+#        else /* !defined(NO_PTHREAD_TRYLOCK) */\n #        define LOCK() \\\n \t   { if (0 != pthread_mutex_trylock(&GC_allocate_ml)) GC_lock(); }\n+#        endif\n #        define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n #      endif /* !GC_ASSERTIONS */\n #   endif /* USE_PTHREAD_LOCKS */\n@@ -450,7 +580,7 @@\n      /* on Irix anymore.\t\t\t\t\t\t*/\n #    include <mutex.h>\n \n-     extern unsigned long GC_allocate_lock;\n+     extern volatile unsigned int GC_allocate_lock;\n \t/* This is not a mutex because mutexes that obey the (optional) \t*/\n \t/* POSIX scheduling rules are subject to convoys in high contention\t*/\n \t/* applications.  This is basically a spin lock.\t\t\t*/\n@@ -471,11 +601,18 @@\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n #  endif /* GC_IRIX_THREADS */\n-#  ifdef GC_WIN32_THREADS\n-#    include <windows.h>\n-     GC_API CRITICAL_SECTION GC_allocate_ml;\n-#    define LOCK() EnterCriticalSection(&GC_allocate_ml);\n-#    define UNLOCK() LeaveCriticalSection(&GC_allocate_ml);\n+#  if defined(GC_WIN32_THREADS)\n+#    if defined(GC_PTHREADS)\n+#      include <pthread.h>\n+       extern pthread_mutex_t GC_allocate_ml;\n+#      define LOCK()   pthread_mutex_lock(&GC_allocate_ml)\n+#      define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#    else\n+#      include <windows.h>\n+       GC_API CRITICAL_SECTION GC_allocate_ml;\n+#      define LOCK() EnterCriticalSection(&GC_allocate_ml);\n+#      define UNLOCK() LeaveCriticalSection(&GC_allocate_ml);\n+#    endif\n #  endif\n #  ifndef SET_LOCK_HOLDER\n #      define SET_LOCK_HOLDER()"}, {"sha": "c109738203a2c74e33563d7e1f9a310c7ecfe366", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -137,15 +137,15 @@ extern mse * GC_mark_stack;\n #ifdef __STDC__\n # ifdef PRINT_BLACK_LIST\n     ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p,\n-\t\t    \tptr_t source);\n+\t\t    \tword source);\n # else\n     ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p);\n # endif\n #else\n   ptr_t GC_find_start();\n #endif\n \n-mse *GC_signal_mark_stack_overflow(mse *msp);\n+mse * GC_signal_mark_stack_overflow GC_PROTO((mse *msp));\n \n # ifdef GATHERSTATS\n #   define ADD_TO_ATOMIC(sz) GC_atomic_in_use += (sz)\n@@ -174,14 +174,6 @@ mse *GC_signal_mark_stack_overflow(mse *msp);\n     } \\\n }\n \n-#ifdef PRINT_BLACK_LIST\n-#   define GC_FIND_START(current, hhdr, new_hdr_p, source) \\\n-\tGC_find_start(current, hhdr, new_hdr_p, source)\n-#else\n-#   define GC_FIND_START(current, hhdr, new_hdr_p, source) \\\n-\tGC_find_start(current, hhdr, new_hdr_p)\n-#endif\n-\n /* Push the contents of current onto the mark stack if it is a valid\t*/\n /* ptr to a currently unmarked object.  Mark it.\t\t\t*/\n /* If we assumed a standard-conforming compiler, we could probably\t*/\n@@ -195,8 +187,7 @@ mse *GC_signal_mark_stack_overflow(mse *msp);\n     GET_HDR(my_current, my_hhdr); \\\n     if (IS_FORWARDING_ADDR_OR_NIL(my_hhdr)) { \\\n \t hdr * new_hdr = GC_invalid_header; \\\n-         my_current = GC_FIND_START(my_current, my_hhdr, \\\n-\t\t\t \t    &new_hdr, (word)source); \\\n+         my_current = GC_find_start(my_current, my_hhdr, &new_hdr); \\\n          my_hhdr = new_hdr; \\\n     } \\\n     PUSH_CONTENTS_HDR(my_current, mark_stack_top, mark_stack_limit, \\\n@@ -290,21 +281,39 @@ exit_label: ; \\\n \n /*\n  * Push a single value onto mark stack. Mark from the object pointed to by p.\n+ * Invoke FIXUP_POINTER(p) before any further processing.\n  * P is considered valid even if it is an interior pointer.\n  * Previously marked objects are not pushed.  Hence we make progress even\n  * if the mark stack overflows.\n  */\n-# define GC_PUSH_ONE_STACK(p, source) \\\n-    if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n+\n+# if NEED_FIXUP_POINTER\n+    /* Try both the raw version and the fixed up one.\t*/\n+#   define GC_PUSH_ONE_STACK(p, source) \\\n+      if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n \t && (ptr_t)(p) < (ptr_t)GC_greatest_plausible_heap_addr) {\t\\\n \t PUSH_ONE_CHECKED_STACK(p, source);\t\\\n-    }\n+      } \\\n+      FIXUP_POINTER(p); \\\n+      if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n+\t && (ptr_t)(p) < (ptr_t)GC_greatest_plausible_heap_addr) {\t\\\n+\t PUSH_ONE_CHECKED_STACK(p, source);\t\\\n+      }\n+# else /* !NEED_FIXUP_POINTER */\n+#   define GC_PUSH_ONE_STACK(p, source) \\\n+      if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n+\t && (ptr_t)(p) < (ptr_t)GC_greatest_plausible_heap_addr) {\t\\\n+\t PUSH_ONE_CHECKED_STACK(p, source);\t\\\n+      }\n+# endif\n+\n \n /*\n  * As above, but interior pointer recognition as for\n  * normal for heap pointers.\n  */\n # define GC_PUSH_ONE_HEAP(p,source) \\\n+    FIXUP_POINTER(p); \\\n     if ((ptr_t)(p) >= (ptr_t)GC_least_plausible_heap_addr \t\\\n \t && (ptr_t)(p) < (ptr_t)GC_greatest_plausible_heap_addr) {\t\\\n \t    GC_mark_stack_top = GC_mark_and_push( \\"}, {"sha": "ffa398b308ba56f4a21f291cb2f85da8a8f228b2", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -30,14 +30,20 @@\n #   define BSD_TIME\n #endif\n \n+#ifdef DGUX\n+#   include <sys/types.h>\n+#   include <sys/time.h>\n+#   include <sys/resource.h>\n+#endif /* DGUX */\n+\n #ifdef BSD_TIME\n #   include <sys/types.h>\n #   include <sys/time.h>\n #   include <sys/resource.h>\n #endif /* BSD_TIME */\n \n-# ifndef GC_H\n-#   include \"gc.h\"\n+# ifndef _GC_H\n+#   include \"../gc.h\"\n # endif\n \n # ifndef GC_MARK_H\n@@ -206,11 +212,10 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n #endif\n \n #if defined(GC_GCJ_SUPPORT) && ALIGNMENT < 8 && !defined(ALIGN_DOUBLE)\n-   /* GCJ's Hashtable synchronization code requires 64-bit alignment.\t*/\n+   /* GCJ's Hashtable synchronization code requires 64-bit alignment.  */\n #  define ALIGN_DOUBLE\n #endif\n \n-\n /* ALIGN_DOUBLE requires MERGE_SIZES at present. */\n # if defined(ALIGN_DOUBLE) && !defined(MERGE_SIZES)\n #   define MERGE_SIZES\n@@ -347,7 +352,8 @@ void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n #   include <string.h>\n #   define BCOPY_EXISTS\n # endif\n-# if defined(MACOSX)\n+# if defined(DARWIN)\n+#   include <string.h>\n #   define BCOPY_EXISTS\n # endif\n \n@@ -360,68 +366,6 @@ void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n #   define BZERO(x,n) bzero((char *)(x),(int)(n))\n # endif\n \n-/* HBLKSIZE aligned allocation.  0 is taken to mean failure \t*/\n-/* space is assumed to be cleared.\t\t\t\t*/\n-/* In the case os USE_MMAP, the argument must also be a \t*/\n-/* physical page size.\t\t\t\t\t\t*/\n-/* GET_MEM is currently not assumed to retrieve 0 filled space, */\n-/* though we should perhaps take advantage of the case in which */\n-/* does.\t\t\t\t\t\t\t*/\n-struct hblk;\t/* See below.\t*/\n-# ifdef PCR\n-    char * real_malloc();\n-#   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n-\t\t\t\t  + GC_page_size-1)\n-# else\n-#   ifdef OS2\n-      void * os2_alloc(size_t bytes);\n-#     define GET_MEM(bytes) HBLKPTR((ptr_t)os2_alloc((size_t)bytes \\\n-\t\t\t\t    + GC_page_size) \\\n-                                    + GC_page_size-1)\n-#   else\n-#     if defined(NEXT) || defined(MACOSX) || defined(DOS4GW) || \\\n-\t (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC)) || \\\n-\t (defined(SUNOS5) && !defined(USE_MMAP))\n-#       define GET_MEM(bytes) HBLKPTR((size_t) \\\n-\t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n-                                      + GC_page_size-1)\n-#     else\n-#\tifdef MSWIN32\n-          extern ptr_t GC_win32_get_mem();\n-#         define GET_MEM(bytes) (struct hblk *)GC_win32_get_mem(bytes)\n-#\telse\n-#\t  ifdef MACOS\n-#\t    if defined(USE_TEMPORARY_MEMORY)\n-\t\textern Ptr GC_MacTemporaryNewPtr(size_t size,\n-\t\t\t\t\t\t Boolean clearMemory);\n-#               define GET_MEM(bytes) HBLKPTR( \\\n-\t\t    GC_MacTemporaryNewPtr(bytes + GC_page_size, true) \\\n-\t\t    + GC_page_size-1)\n-#\t    else\n-#         \t    define GET_MEM(bytes) HBLKPTR( \\\n-\t\t\tNewPtrClear(bytes + GC_page_size) + GC_page_size-1)\n-#\t    endif\n-#\t  else\n-#\t    ifdef MSWINCE\n-\t      extern ptr_t GC_wince_get_mem();\n-#\t      define GET_MEM(bytes) (struct hblk *)GC_wince_get_mem(bytes)\n-#\t    else\n-#\t      if defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)\n-\t        extern void *GC_amiga_get_mem(size_t size);\n-\t\tdefine GET_MEM(bytes) HBLKPTR((size_t) \\\n-                  GC_amiga_get_mem((size_t)bytes + GC_page_size) \\\n-\t\t  + GC_page_size-1)\n-#\t      else\n-                extern ptr_t GC_unix_get_mem();\n-#               define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)\n-#\t      endif\n-#\t    endif\n-#\t  endif\n-#\tendif\n-#     endif\n-#   endif\n-# endif\n-\n /* Delay any interrupts or signals that may abort this thread.  Data\t*/\n /* structures are in a consistent state outside this pair of calls.\t*/\n /* ANSI C allows both to be empty (though the standard isn't very\t*/\n@@ -486,7 +430,7 @@ struct hblk;\t/* See below.\t*/\n #   ifdef SMALL_CONFIG\n #\tdefine ABORT(msg) abort();\n #   else\n-\tGC_API void GC_abort();\n+\tGC_API void GC_abort GC_PROTO((GC_CONST char * msg));\n #       define ABORT(msg) GC_abort(msg);\n #   endif\n # endif\n@@ -646,17 +590,18 @@ extern GC_warn_proc GC_current_warn_proc;\n  */\n  \n # ifdef LARGE_CONFIG\n-#   define LOG_PHT_ENTRIES  19  /* Collisions likely at 512K blocks,\t*/\n-\t\t\t\t/* which is >= 2GB.  Each table takes\t*/\n-\t\t\t\t/* 64KB.\t\t\t\t*/\n+#   define LOG_PHT_ENTRIES  20  /* Collisions likely at 1M blocks,\t*/\n+\t\t\t\t/* which is >= 4GB.  Each table takes\t*/\n+\t\t\t\t/* 128KB, some of which may never be\t*/\n+\t\t\t\t/* touched.\t\t\t\t*/\n # else\n #   ifdef SMALL_CONFIG\n #     define LOG_PHT_ENTRIES  14 /* Collisions are likely if heap grows\t*/\n \t\t\t\t /* to more than 16K hblks = 64MB.\t*/\n \t\t\t\t /* Each hash table occupies 2K bytes.   */\n #   else /* default \"medium\" configuration */\n #     define LOG_PHT_ENTRIES  16 /* Collisions are likely if heap grows\t*/\n-\t\t\t\t /* to more than 16K hblks >= 256MB.\t*/\n+\t\t\t\t /* to more than 64K hblks >= 256MB.\t*/\n \t\t\t\t /* Each hash table occupies 8K bytes.  */\n #   endif\n # endif\n@@ -897,6 +842,10 @@ struct _GC_arrays {\n   word _mem_freed;\n   \t/* Number of explicitly deallocated words of memory\t*/\n   \t/* since last collection.\t\t\t\t*/\n+  word _finalizer_mem_freed;\n+  \t/* Words of memory explicitly deallocated while \t*/\n+  \t/* finalizers were running.  Used to approximate mem.\t*/\n+  \t/* explicitly deallocated by finalizers.\t\t*/\n   ptr_t _scratch_end_ptr;\n   ptr_t _scratch_last_end_ptr;\n \t/* Used by headers.c, and can easily appear to point to\t*/\n@@ -957,7 +906,7 @@ struct _GC_arrays {\n   \t\t       /* OFFSET_TOO_BIG if the value j would be too \t*/\n   \t\t       /* large to fit in the entry.  (Note that the\t*/\n   \t\t       /* size of these entries matters, both for \t*/\n-  \t\t       /* space consumption and for cache utilization.\t*/\n+  \t\t       /* space consumption and for cache utilization.)\t*/\n #   define OFFSET_TOO_BIG 0xfe\n #   define OBJ_INVALID 0xff\n #   define MAP_ENTRY(map, bytes) (map)[bytes]\n@@ -1067,6 +1016,7 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_words_finalized GC_arrays._words_finalized\n # define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n # define GC_mem_freed GC_arrays._mem_freed\n+# define GC_finalizer_mem_freed GC_arrays._finalizer_mem_freed\n # define GC_scratch_end_ptr GC_arrays._scratch_end_ptr\n # define GC_scratch_last_end_ptr GC_arrays._scratch_last_end_ptr\n # define GC_mark_procs GC_arrays._mark_procs\n@@ -1201,17 +1151,19 @@ extern struct hblk * GC_hblkfreelist[];\n \t\t\t\t/* header structure associated with\t*/\n \t\t\t\t/* block.\t\t\t\t*/\n \n-extern GC_bool GC_is_initialized;\t/* GC_init() has been run.\t*/\n-\n extern GC_bool GC_objects_are_marked;\t/* There are marked objects in  */\n \t\t\t\t\t/* the heap.\t\t\t*/\n \n #ifndef SMALL_CONFIG\n   extern GC_bool GC_incremental;\n \t\t\t/* Using incremental/generational collection. */\n+# define TRUE_INCREMENTAL \\\n+\t(GC_incremental && GC_time_limit != GC_TIME_UNLIMITED)\n+\t/* True incremental, not just generational, mode */\n #else\n # define GC_incremental FALSE\n \t\t\t/* Hopefully allow optimizer to remove some code. */\n+# define TRUE_INCREMENTAL FALSE\n #endif\n \n extern GC_bool GC_dirty_maintained;\n@@ -1229,6 +1181,10 @@ extern long GC_large_alloc_warn_interval;\n extern long GC_large_alloc_warn_suppressed;\n \t/* Number of warnings suppressed so far.\t*/\n \n+#ifdef THREADS\n+  extern GC_bool GC_world_stopped;\n+#endif\n+\n /* Operations */\n # ifndef abs\n #   define abs(x)  ((x) < 0? (-(x)) : (x))\n@@ -1402,6 +1358,11 @@ extern void (*GC_start_call_back) GC_PROTO((void));\n   void GC_generic_push_regs GC_PROTO((ptr_t cold_gc_frame));\n # else\n   void GC_push_regs GC_PROTO((void));\n+# endif\n+# if defined(SPARC) || defined(IA64)\n+  /* Cause all stacked registers to be saved in memory.  Return a\t*/\n+  /* pointer to the top of the corresponding memory stack.\t\t*/\n+  word GC_save_regs_in_stack GC_PROTO((void));\n # endif\n \t\t\t/* Push register contents onto mark stack.\t*/\n   \t\t\t/* If NURSERY is defined, the default push\t*/\n@@ -1452,6 +1413,7 @@ void GC_set_fl_marks GC_PROTO((ptr_t p));\n \t\t\t\t    /* Set all mark bits associated with */\n \t\t\t\t    /* a free list.\t\t\t */\n void GC_add_roots_inner GC_PROTO((char * b, char * e, GC_bool tmp));\n+void GC_remove_roots_inner GC_PROTO((char * b, char * e));\n GC_bool GC_is_static_root GC_PROTO((ptr_t p));\n   \t\t/* Is the address p in one of the registered static\t*/\n   \t\t/* root sections?\t\t\t\t\t*/\n@@ -1462,11 +1424,10 @@ GC_bool GC_is_tmp_root GC_PROTO((ptr_t p));\n # endif\n void GC_register_dynamic_libraries GC_PROTO((void));\n   \t\t/* Add dynamic library data sections to the root set. */\n-\n GC_bool GC_register_main_static_data GC_PROTO((void));\n-               /* We need to register the main data segment.  Returns  */\n-               /* TRUE unless this is done implicitly as part of       */\n-               /* dynamic library registration.                        */\n+\t\t/* We need to register the main data segment.  Returns\t*/\n+\t\t/* TRUE unless this is done implicitly as part of\t*/\n+\t\t/* dynamic library registration.\t\t\t*/\n   \n /* Machine dependent startup routines */\n ptr_t GC_get_stack_base GC_PROTO((void));\t/* Cold end of stack */\n@@ -1624,6 +1585,8 @@ GC_bool GC_collect_or_expand GC_PROTO(( \\\n   \t\t\t\t/* until the blocks are available or\t*/\n   \t\t\t\t/* until it fails by returning FALSE.\t*/\n \n+extern GC_bool GC_is_initialized;\t/* GC_init() has been run.\t*/\n+\n #if defined(MSWIN32) || defined(MSWINCE)\n   void GC_deinit GC_PROTO((void));\n                                 /* Free any resources allocated by      */\n@@ -1665,6 +1628,8 @@ ptr_t GC_allocobj GC_PROTO((word sz, int kind));\n   \t\t\t\t/* Make the indicated \t\t\t*/\n   \t\t\t\t/* free list nonempty, and return its\t*/\n   \t\t\t\t/* head.\t\t\t\t*/\n+\n+void GC_free_inner(GC_PTR p);\n   \n void GC_init_headers GC_PROTO((void));\n struct hblkhdr * GC_install_header GC_PROTO((struct hblk *h));\n@@ -1694,6 +1659,12 @@ void GC_notify_or_invoke_finalizers GC_PROTO((void));\n \t\t\t/* Call *GC_finalizer_notifier if there are\t*/\n \t\t\t/* finalizers to be run, and we haven't called\t*/\n \t\t\t/* this procedure yet this GC cycle.\t\t*/\n+\n+GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n+GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n+\t\t\t/* Auxiliary fns to make finalization work\t*/\n+\t\t\t/* correctly with displaced pointers introduced\t*/\n+\t\t\t/* by the debugging allocators.\t\t\t*/\n   \t\t\t\n void GC_add_to_heap GC_PROTO((struct hblk *p, word bytes));\n   \t\t\t/* Add a HBLKSIZE aligned chunk to the heap.\t*/\n@@ -1704,16 +1675,36 @@ void GC_print_obj GC_PROTO((ptr_t p));\n   \t\t\t/* description of the object to stderr.\t\t*/\n extern void (*GC_check_heap) GC_PROTO((void));\n   \t\t\t/* Check that all objects in the heap with \t*/\n-  \t\t\t/* debugging info are intact.  Print \t\t*/\n-  \t\t\t/* descriptions of any that are not.\t\t*/\n+  \t\t\t/* debugging info are intact.  \t\t\t*/\n+  \t\t\t/* Add any that are not to GC_smashed list.\t*/\n+extern void (*GC_print_all_smashed) GC_PROTO((void));\n+\t\t\t/* Print GC_smashed if it's not empty.\t\t*/\n+\t\t\t/* Clear GC_smashed list.\t\t\t*/\n+extern void GC_print_all_errors GC_PROTO((void));\n+\t\t\t/* Print smashed and leaked objects, if any.\t*/\n+\t\t\t/* Clear the lists of such objects.\t\t*/\n extern void (*GC_print_heap_obj) GC_PROTO((ptr_t p));\n   \t\t\t/* If possible print s followed by a more\t*/\n   \t\t\t/* detailed description of the object \t\t*/\n   \t\t\t/* referred to by p.\t\t\t\t*/\n+#if defined(LINUX) && defined(__ELF__) && !defined(SMALL_CONFIG)\n+  void GC_print_address_map GC_PROTO((void));\n+  \t\t\t/* Print an address map of the process.\t\t*/\n+#endif\n \n+extern GC_bool GC_have_errors;  /* We saw a smashed or leaked object.\t*/\n+\t\t\t\t/* Call error printing routine \t\t*/\n+\t\t\t\t/* occasionally.\t\t\t*/\n extern GC_bool GC_print_stats;\t/* Produce at least some logging output\t*/\n \t\t\t\t/* Set from environment variable.\t*/\n \n+#ifndef NO_DEBUGGING\n+  extern GC_bool GC_dump_regularly;  /* Generate regular debugging dumps. */\n+# define COND_DUMP if (GC_dump_regularly) GC_dump();\n+#else\n+# define COND_DUMP\n+#endif\n+\n /* Macros used for collector internal allocation.\t*/\n /* These assume the collector lock is held.\t\t*/\n #ifdef DBG_HDRS_ALL\n@@ -1785,6 +1776,7 @@ void GC_print_block_list GC_PROTO((void));\n void GC_print_hblkfreelist GC_PROTO((void));\n void GC_print_heap_sects GC_PROTO((void));\n void GC_print_static_roots GC_PROTO((void));\n+void GC_print_finalization_stats GC_PROTO((void));\n void GC_dump GC_PROTO((void));\n \n #ifdef KEEP_BACK_PTRS\n@@ -1866,6 +1858,16 @@ void GC_err_puts GC_PROTO((GC_CONST char *s));\n #\tdefine GC_ASSERT(expr)\n # endif\n \n+/* Check a compile time assertion at compile time.  The error\t*/\n+/* message for failure is a bit baroque, but ...\t\t*/\n+#if defined(mips) && !defined(__GNUC__)\n+/* DOB: MIPSPro C gets an internal error taking the sizeof an array type. \n+   This code works correctly (ugliness is to avoid \"unused var\" warnings) */\n+# define GC_STATIC_ASSERT(expr) do { if (0) { char j[(expr)? 1 : -1]; j[0]='\\0'; j[0]=j[0]; } } while(0)\n+#else\n+# define GC_STATIC_ASSERT(expr) sizeof(char[(expr)? 1 : -1])\n+#endif\n+\n # if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n     /* We need additional synchronization facilities from the thread\t*/\n     /* support.  We believe these are less performance critical\t\t*/\n@@ -1911,7 +1913,7 @@ void GC_err_puts GC_PROTO((GC_CONST char *s));\n   /* in Linux glibc, but it's not exported.)  Thus we continue to use\t*/\n   /* the same hard-coded signals we've always used.\t\t\t*/\n #  if !defined(SIG_SUSPEND)\n-#   if defined(GC_LINUX_THREADS)\n+#   if defined(GC_LINUX_THREADS) || defined(GC_DGUX386_THREADS)\n #    if defined(SPARC) && !defined(SIGPWR)\n        /* SPARC/Linux doesn't properly define SIGPWR in <signal.h>.\n         * It is aliased to SIGLOST in asm/signal.h, though.\t\t*/"}, {"sha": "29dab213815df104ac680282919e3c6610c0ff6d", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 352, "deletions": 157, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -13,19 +13,35 @@\n  * provided the above notices are retained, and a notice that the code was\n  * modified is included with the above copyright notice.\n  */\n+\n+/*\n+ * This header is private to the gc.  It is almost always included from\n+ * gc_priv.h.  However it is possible to include it by itself if just the\n+ * configuration macros are needed.  In that\n+ * case, a few declarations relying on types declared in gc_priv.h will be\n+ * omitted.\n+ */\n  \n #ifndef GCCONFIG_H\n \n # define GCCONFIG_H\n \n+# ifndef GC_PRIVATE_H\n+    /* Fake ptr_t declaration, just to avoid compilation errors.\t*/\n+    /* This avoids many instances if \"ifndef GC_PRIVATE_H\" below.\t*/\n+    typedef struct GC_undefined_struct * ptr_t;\n+# endif\n+\n /* Machine dependent parameters.  Some tuning parameters can be found\t*/\n /* near the top of gc_private.h.\t\t\t\t\t*/\n \n /* Machine specific parts contributed by various people.  See README file. */\n \n /* First a unified test for Linux: */\n # if defined(linux) || defined(__linux__)\n+#  ifndef LINUX\n #    define LINUX\n+#  endif\n # endif\n \n /* And one for NetBSD: */\n@@ -44,9 +60,9 @@\n # endif\n \n /* Determine the machine type: */\n-# if defined(__arm__) || defined(__thumb__)\n+# if defined(__XSCALE__)\n #    define ARM32\n-#    if !defined(LINUX) && !defined(NETBSD)\n+#    if !defined(LINUX)\n #      define NOSYS\n #      define mach_type_known\n #    endif\n@@ -69,15 +85,15 @@\n #    define SPARC\n #    define mach_type_known\n # endif\n-# if defined(NETBSD) && defined(m68k)\n+# if defined(NETBSD) && (defined(m68k) || defined(__m68k__))\n #    define M68K\n #    define mach_type_known\n # endif\n # if defined(NETBSD) && defined(__powerpc__)\n #    define POWERPC\n #    define mach_type_known\n # endif\n-# if defined(NETBSD) && defined(__arm__)\n+# if defined(NETBSD) && (defined(__arm32__) || defined(__arm__))\n #    define ARM32\n #    define mach_type_known\n # endif\n@@ -90,6 +106,10 @@\n #    endif\n #    define mach_type_known\n # endif\n+# if defined(__NetBSD__) && defined(__vax__)\n+#    define VAX\n+#    define mach_type_known\n+# endif\n # if defined(mips) || defined(__mips) || defined(_mips)\n #    define MIPS\n #    if defined(nec_ews) || defined(_nec_ews)\n@@ -109,6 +129,13 @@\n #    endif /* !LINUX */\n #    define mach_type_known\n # endif\n+# if defined(DGUX) && (defined(i386) || defined(__i386__))\n+#    define I386\n+#    ifndef _USING_DGUX\n+#    define _USING_DGUX\n+#    endif\n+#    define mach_type_known\n+# endif\n # if defined(sequent) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define SEQUENT\n@@ -198,7 +225,11 @@\n #    define IA64\n #    define mach_type_known\n # endif\n-# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__))\n+# if defined(LINUX) && defined(__arm__)\n+#    define ARM32\n+#    define mach_type_known\n+# endif\n+# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || defined(powerpc64) || defined(__powerpc64__))\n #    define POWERPC\n #    define mach_type_known\n # endif\n@@ -237,19 +268,19 @@\n #   define MACOS\n #   define mach_type_known\n # endif\n-# if defined(__MWERKS__) && defined(__powerc)\n+# if defined(__MWERKS__) && defined(__powerc) && !defined(__MACH__)\n #   define POWERPC\n #   define MACOS\n #   define mach_type_known\n # endif\n # if defined(macosx) || \\\n      defined(__APPLE__) && defined(__MACH__) && defined(__ppc__)\n-#    define MACOSX\n+#    define DARWIN\n #    define POWERPC\n #    define mach_type_known\n # endif\n # if defined(__APPLE__) && defined(__MACH__) && defined(__i386__)\n-#    define MACOSX\n+#    define DARWIN\n #    define I386\n      --> Not really supported, but at least we recognize it.\n # endif\n@@ -291,7 +322,7 @@\n #   define CX_UX\n #   define mach_type_known\n # endif\n-# if defined(DGUX)\n+# if defined(DGUX) && defined(m88k)\n #   define M88K\n     /* DGUX defined */\n #   define mach_type_known\n@@ -419,17 +450,18 @@\n \t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n \t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n \t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n-\t\t    /*\t\t   S390       ==> 390-like machine      */\n-\t\t    /*\t\t\trunning LINUX\t\t\t*/\n+                    /*             S390       ==> 390-like machine      */\n+\t\t    /*                  running LINUX                   */\n \t\t    /* \t\t   ARM32      ==> Intel StrongARM\t*/\n \t\t    /* \t\t   IA64\t      ==> Intel IPF\t\t*/\n \t\t    /*\t\t\t\t  (e.g. Itanium)\t*/\n \t\t    /*\t\t\t(LINUX and HPUX)\t        */\n-\t\t    /* \t\t   IA64_32    ==> IA64 w/32 bit ABI\t*/\n-\t\t    /* \t\t\t(HPUX)\t\t\t\t*/\n \t\t    /*\t\t   SH\t      ==> Hitachi SuperH\t*/\n \t\t    /* \t\t\t(LINUX & MSWINCE)\t\t*/\n \t\t    /* \t\t   X86_64     ==> AMD x86-64\t\t*/\n+\t\t    /*\t\t   POWERPC    ==> IBM/Apple PowerPC\t*/\n+\t\t    /*\t\t\t(MACOS(<=9),DARWIN(incl.MACOSX),*/\n+\t\t    /*\t\t\t LINUX, NETBSD, NOSYS variants)\t*/\n \n \n /*\n@@ -450,7 +482,12 @@\n  * defining it to be 1 will always work, but perform poorly.\n  *\n  * DATASTART is the beginning of the data segment.\n- * On UNIX systems, the collector will scan the area between DATASTART\n+ * On some platforms SEARCH_FOR_DATA_START is defined.\n+ * SEARCH_FOR_DATASTART will cause GC_data_start to\n+ * be set to an address determined by accessing data backwards from _end\n+ * until an unmapped page is found.  DATASTART will be defined to be\n+ * GC_data_start.\n+ * On UNIX-like systems, the collector will scan the area between DATASTART\n  * and DATAEND for root pointers.\n  *\n  * DATAEND, if not `end' where `end' is defined as ``extern int end[];''.\n@@ -470,8 +507,13 @@\n  * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and\n  * 2) define exactly one of\n  *\tSTACKBOTTOM (should be defined to be an expression)\n+ *\tLINUX_STACKBOTTOM\n  *\tHEURISTIC1\n  *\tHEURISTIC2\n+ * If STACKBOTTOM is defined, then it's value will be used directly as the\n+ * stack base.  If LINUX_STACKBOTTOM is defined, then it will be determined\n+ * with a method appropriate for most Linux systems.  Currently we look\n+ * first for __libc_stack_end, and if that fails read it from /proc.\n  * If either of the last two macros are defined, then STACKBOTTOM is computed\n  * during collector startup using one of the following two heuristics:\n  * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to\n@@ -536,6 +578,9 @@\n  * An architecture may also define CLEAR_DOUBLE(x) to be a fast way to\n  * clear the two words at GC_malloc-aligned address x.  By default,\n  * word stores of 0 are used instead.\n+ *\n+ * HEAP_START may be defined as the initial address hint for mmap-based\n+ * allocation.\n  */\n \n /* If we are using a recent version of gcc, we can use __builtin_unwind_init()\n@@ -560,18 +605,25 @@\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n #\tdefine HEURISTIC2\n-\textern char etext[];\n-#\tdefine DATASTART ((ptr_t)(etext))\n+#\tifdef __ELF__\n+#\t  define DATASTART GC_data_start\n+#\t  define DYNAMIC_LOADING\n+#\telse\n+\t  extern char etext[];\n+#\t  define DATASTART ((ptr_t)(etext))\n+#       endif\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n #       define STACKBOTTOM ((ptr_t)0xf0000000)\n+#       define USE_GENERIC_PUSH_REGS\n+\t\t/* We never got around to the assembly version. */\n /* #       define MPROTECT_VDB - Reported to not work  9/17/01 */\n #       ifdef __ELF__\n #            define DYNAMIC_LOADING\n #\t     include <features.h>\n #\t     if defined(__GLIBC__)&& __GLIBC__>=2\n-#              define LINUX_DATA_START\n+#              define SEARCH_FOR_DATA_START\n #\t     else /* !GLIBC2 */\n                extern char **__environ;\n #              define DATASTART ((ptr_t)(&__environ))\n@@ -666,26 +718,49 @@\n #     define DATAEND  /* not needed */\n #   endif\n #   ifdef LINUX\n-#     define ALIGNMENT 4\t/* Guess.  Can someone verify?\t*/\n+#     if (defined (powerpc64) || defined(__powerpc64__))\n+#       define ALIGNMENT 8\n+#       define CPP_WORDSZ 64\n+#     else\n+#       define ALIGNMENT 4\t/* Guess.  Can someone verify?\t*/\n \t\t\t\t/* This was 2, but that didn't sound right. */\n+#     endif\n #     define OS_TYPE \"LINUX\"\n-#     define DYNAMIC_LOADING\n+      /* HEURISTIC1 has been reliably reported to fail for a 32-bit\t*/\n+      /* executable on a 64 bit kernel.\t\t\t\t\t*/\n #     define LINUX_STACKBOTTOM\n-\t/* Stack usually starts at 0x80000000 */\n-#     define LINUX_DATA_START\n+#     define DYNAMIC_LOADING\n+#     define SEARCH_FOR_DATA_START\n       extern int _end[];\n #     define DATAEND (_end)\n #   endif\n-#   ifdef MACOSX\n-      /* There are reasons to suspect this may not be reliable. \t*/\n+#   ifdef DARWIN\n #     define ALIGNMENT 4\n-#     define OS_TYPE \"MACOSX\"\n+#     define OS_TYPE \"DARWIN\"\n+#     define DYNAMIC_LOADING\n+      /* XXX: see get_end(3), get_etext() and get_end() should not be used.\n+         These aren't used when dyld support is enabled (it is by default) */\n #     define DATASTART ((ptr_t) get_etext())\n+#     define DATAEND\t((ptr_t) get_end())\n #     define STACKBOTTOM ((ptr_t) 0xc0000000)\n-#     define DATAEND\t/* not needed */\n-#     undef MPROTECT_VDB\n+#     define USE_MMAP\n+#     define USE_MMAP_ANON\n+#     define USE_ASM_PUSH_REGS\n+      /* This is potentially buggy. It needs more testing. See the comments in\n+         os_dep.c */\n+#     define MPROTECT_VDB\n #     include <unistd.h>\n #     define GETPAGESIZE() getpagesize()\n+#     if defined(USE_PPC_PREFETCH) && defined(__GNUC__)\n+\t/* The performance impact of prefetches is untested */\n+#\tdefine PREFETCH(x) \\\n+\t  __asm__ __volatile__ (\"dcbt 0,%0\" : : \"r\" ((const void *) (x)))\n+#\tdefine PREFETCH_FOR_WRITE(x) \\\n+\t  __asm__ __volatile__ (\"dcbtst 0,%0\" : : \"r\" ((const void *) (x)))\n+#     endif\n+      /* There seems to be some issues with trylock hanging on darwin. This\n+         should be looked into some more */\n+#     define NO_PTHREAD_TRYLOCK\n #   endif\n #   ifdef NETBSD\n #     define ALIGNMENT 4\n@@ -746,8 +821,8 @@\n #\tdefine OS_TYPE \"SUNOS5\"\n \textern int _etext[];\n \textern int _end[];\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, _etext)\n+\textern ptr_t GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x10000, _etext)\n #\tdefine DATAEND (_end)\n #\tif !defined(USE_MMAP) && defined(REDIRECT_MALLOC)\n #\t    define USE_MMAP\n@@ -801,9 +876,9 @@\n #   endif\n #   ifdef DRSNX\n #\tdefine OS_TYPE \"DRSNX\"\n-\textern char * GC_SysVGetDataStart();\n+\textern ptr_t GC_SysVGetDataStart();\n \textern int etext[];\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, etext)\n+#       define DATASTART GC_SysVGetDataStart(0x10000, etext)\n #\tdefine MPROTECT_VDB\n #       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n #\tdefine DYNAMIC_LOADING\n@@ -819,13 +894,14 @@\n       extern int _etext[];\n #     define DATAEND (_end)\n #     define SVR4\n+      extern ptr_t GC_SysVGetDataStart();\n #     ifdef __arch64__\n+#\tdefine DATASTART GC_SysVGetDataStart(0x100000, _etext)\n \t/* libc_stack_end is not set reliably for sparc64 */\n-#       define STACKBOTTOM ((ptr_t) 0x80000000000)\n-#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x100000, _etext)\n+#       define STACKBOTTOM ((ptr_t) 0x80000000000ULL)\n #     else\n-#       define LINUX_STACKBOTTOM\n-#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, _etext)\n+#       define DATASTART GC_SysVGetDataStart(0x10000, _etext)\n+#\tdefine LINUX_STACKBOTTOM\n #     endif\n #   endif\n #   ifdef OPENBSD\n@@ -876,7 +952,7 @@\n #   ifdef SUNOS5\n #\tdefine OS_TYPE \"SUNOS5\"\n         extern int _etext[], _end[];\n-  \textern char * GC_SysVGetDataStart();\n+  \textern ptr_t GC_SysVGetDataStart();\n #       define DATASTART GC_SysVGetDataStart(0x1000, _etext)\n #\tdefine DATAEND (_end)\n /*\t# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  \t*/\n@@ -921,6 +997,28 @@\n #       define DYNAMIC_LOADING\n #\tdefine ELF_CLASS ELFCLASS32\n #   endif\n+#   ifdef DGUX\n+#\tdefine OS_TYPE \"DGUX\"\n+\textern int _etext, _end;\n+\textern ptr_t GC_SysVGetDataStart();\n+#\tdefine DATASTART GC_SysVGetDataStart(0x1000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tdefine STACK_GROWS_DOWN\n+#\tdefine HEURISTIC2\n+#\tinclude <unistd.h>\n+#\tdefine GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+#\tdefine DYNAMIC_LOADING\n+#\tifndef USE_MMAP\n+#\t  define USE_MMAP\n+#\tendif /* USE_MMAP */\n+#\tdefine MAP_FAILED (void *) -1\n+#\tifdef USE_MMAP\n+#\t  define HEAP_START (ptr_t)0x40000000\n+#\telse /* USE_MMAP */\n+#\t  define HEAP_START DATAEND\n+#\tendif /* USE_MMAP */\n+#   endif /* DGUX */\n+\n #   ifdef LINUX\n #\tifndef __GNUC__\n \t  /* The Intel compiler doesn't like inline assembly */\n@@ -944,6 +1042,9 @@\n \t    /* possibly because Linux threads is itself a malloc client */\n \t    /* and can't deal with the signals.\t\t\t\t*/\n #\tendif\n+#\tdefine HEAP_START 0x1000\n+\t\t/* This encourages mmap to give us low addresses,\t*/\n+\t\t/* thus allowing the heap to grow to ~3GB\t\t*/\n #       ifdef __ELF__\n #            define DYNAMIC_LOADING\n #\t     ifdef UNDEFINED\t/* includes ro data */\n@@ -952,7 +1053,7 @@\n #\t     endif\n #\t     include <features.h>\n #\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n-#\t\t define LINUX_DATA_START\n+#\t\t define SEARCH_FOR_DATA_START\n #\t     else\n      \t         extern char **__environ;\n #                define DATASTART ((ptr_t)(&__environ))\n@@ -1006,8 +1107,12 @@\n   \t/*\tDATAEND\t    = _data_end__\t\t*/\n   \t/* To get it right for both, we take the\t*/\n   \t/* minumum/maximum of the two.\t\t\t*/\n+#     ifndef MAX\n #   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n+#     endif\n+#     ifndef MIN\n #   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n+#     endif\n #       define DATASTART ((ptr_t) MIN(_data_start__, _bss_start__))\n #       define DATAEND\t ((ptr_t) MAX(_data_end__, _bss_end__))\n #\tundef STACK_GRAN\n@@ -1061,16 +1166,9 @@\n #\tifdef __ELF__\n #\t    define DYNAMIC_LOADING\n #\tendif\n-/* Handle unmapped hole i386*-*-freebsd[45]* may put between etext and edata. */\n \textern char etext[];\n-\textern char edata[];\n-\textern char end[];\n-#\tdefine NEED_FIND_LIMIT\n-#\tdefine DATASTART ((ptr_t)(etext))\n-#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n-#\tdefine DATAEND (MIN (GC_find_limit (DATASTART, TRUE), DATASTART2))\n-#\tdefine DATASTART2 ((ptr_t)(edata))\n-#\tdefine DATAEND2 ((ptr_t)(end))\n+\textern char * GC_FreeBSDGetDataStart();\n+#\tdefine DATASTART GC_FreeBSDGetDataStart(0x1000, &etext)\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n@@ -1149,7 +1247,11 @@\n #     define DATASTART ((ptr_t)(__data_start))\n #     define ALIGNMENT 4\n #     define USE_GENERIC_PUSH_REGS\n-#     define LINUX_STACKBOTTOM\n+#     if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 2 || __GLIBC__ > 2\n+#        define LINUX_STACKBOTTOM\n+#     else\n+#        define STACKBOTTOM 0x80000000\n+#     endif\n #   endif /* Linux */\n #   ifdef EWS4800\n #      define HEURISTIC2\n@@ -1203,7 +1305,8 @@\n \t\t\t      /* heap sections so they're not \t\t*/\n \t\t\t      /* considered as roots.\t\t\t*/\n #\tdefine OS_TYPE \"IRIX5\"\n-#       define MPROTECT_VDB\n+/*#       define MPROTECT_VDB DOB: this should work, but there is evidence */\n+/* \t  \tof recent breakage.\t\t\t\t\t   */\n #       ifdef _MIPS_SZPTR\n #\t  define CPP_WORDSZ _MIPS_SZPTR\n #\t  define ALIGNMENT (_MIPS_SZPTR/8)\n@@ -1226,28 +1329,46 @@\n #     define ALIGNMENT 4\n #     define HEURISTIC2\n #     define USE_GENERIC_PUSH_REGS\n-      extern int _fdata[];\n-#     define DATASTART ((ptr_t)(_fdata))\n-      extern int _end[];\n-#     define DATAEND ((ptr_t)(_end))\n-#     define DYNAMIC_LOADING\n+#     ifdef __ELF__\n+        extern int etext[];\n+#       define DATASTART GC_data_start\n+#       define NEED_FIND_LIMIT\n+#       define DYNAMIC_LOADING\n+#     else\n+#       define DATASTART ((ptr_t) 0x10000000)\n+#       define STACKBOTTOM ((ptr_t) 0x7ffff000)\n+#     endif /* _ELF_ */\n #  endif\n # endif\n \n # ifdef RS6000\n #   define MACH_TYPE \"RS6000\"\n+#   ifdef ALIGNMENT\n+#     undef ALIGNMENT\n+#   endif\n+#   ifdef IA64\n+#     undef IA64 /* DOB: some AIX installs stupidly define IA64 in /usr/include/sys/systemcfg.h */\n+#   endif\n #   ifdef __64BIT__\n #     define ALIGNMENT 8\n #     define CPP_WORDSZ 64\n+#     define STACKBOTTOM ((ptr_t)0x1000000000000000)\n #   else\n #     define ALIGNMENT 4\n #     define CPP_WORDSZ 32\n-#   endif\n+#     define STACKBOTTOM ((ptr_t)((ulong)&errno))\n+#   endif\n+ /* From AIX linker man page:\n+ _text Specifies the first location of the program.\n+ _etext Specifies the first location after the program.\n+ _data Specifies the first location of the data.\n+ _edata Specifies the first location after the initialized data\n+ _end or end Specifies the first location after all data.\n+ */\n     extern int _data[], _end[];\n #   define DATASTART ((ptr_t)((ulong)_data))\n #   define DATAEND ((ptr_t)((ulong)_end))\n     extern int errno;\n-#   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n #   define USE_GENERIC_PUSH_REGS\n #   define DYNAMIC_LOADING\n \t/* For really old versions of AIX, this may have to be removed. */\n@@ -1311,29 +1432,35 @@\n #     define OS_TYPE \"LINUX\"\n #     define LINUX_STACKBOTTOM\n #     define DYNAMIC_LOADING\n-#     define LINUX_DATA_START\n+#     define SEARCH_FOR_DATA_START\n       extern int _end[];\n-#     define DATAEND (_end)\n+#     define DATAEND (&_end)\n #   endif /* LINUX */\n # endif /* HP_PA */\n \n # ifdef ALPHA\n #   define MACH_TYPE \"ALPHA\"\n #   define ALIGNMENT 8\n+#   define CPP_WORDSZ 64\n+#   ifndef LINUX\n+#     define USE_GENERIC_PUSH_REGS\n+      /* Gcc and probably the DEC/Compaq compiler spill pointers to preserved */\n+      /* fp registers in some cases when the target is a 21264.  The assembly */\n+      /* code doesn't handle that yet, and version dependencies make that a   */\n+      /* bit tricky.  Do the easy thing for now.\t\t\t\t    */\n+#   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n #\tdefine HEURISTIC2\n #\tdefine DATASTART GC_data_start\n #\tdefine ELFCLASS32 32\n #\tdefine ELFCLASS64 64\n #\tdefine ELF_CLASS ELFCLASS64\n-#   \tdefine CPP_WORDSZ 64\n #       define DYNAMIC_LOADING\n #   endif\n #   ifdef OPENBSD\n #\tdefine OS_TYPE \"OPENBSD\"\n #\tdefine HEURISTIC2\n-#   \tdefine CPP_WORDSZ 64\n #   \tifdef __ELF__\t/* since OpenBSD/Alpha 2.9 */\n #\t   define DATASTART GC_data_start\n #   \t   define ELFCLASS32 32\n@@ -1357,17 +1484,16 @@\n \textern char edata[];\n \textern char end[];\n #\tdefine NEED_FIND_LIMIT\n-#\tdefine DATASTART ((ptr_t)(etext))\n+#\tdefine DATASTART ((ptr_t)(&etext))\n #\tdefine DATAEND (GC_find_limit (DATASTART, TRUE))\n-#\tdefine DATASTART2 ((ptr_t)(edata))\n-#\tdefine DATAEND2 ((ptr_t)(end))\n-#\tdefine CPP_WORDSZ 64\n+#\tdefine DATASTART2 ((ptr_t)(&edata))\n+#\tdefine DATAEND2 ((ptr_t)(&end))\n #   endif\n #   ifdef OSF1\n #\tdefine OS_TYPE \"OSF1\"\n #   \tdefine DATASTART ((ptr_t) 0x140000000)\n \textern int _end[];\n-#   \tdefine DATAEND ((ptr_t) _end)\n+#   \tdefine DATAEND ((ptr_t) &_end)\n  \textern char ** environ;\n \t/* round up from the value of environ to the nearest page boundary */\n \t/* Probably breaks if putenv is called before collector \t   */\n@@ -1378,19 +1504,19 @@\n \t/* the text segment immediately follows the stack.\t\t*/\n \t/* Hence we give an upper pound.\t\t\t\t*/\n \t/* This is currently unused, since we disabled HEURISTIC2\t*/\n-    \textern int __start[];\n+   \textern int __start[];\n #   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(__start) & ~(getpagesize()-1)))\n-#   \tdefine CPP_WORDSZ 64\n-#   \tdefine MPROTECT_VDB\n+#\tifndef GC_OSF1_THREADS\n+\t  /* Unresolved signal issues with threads.\t*/\n+#   \t  define MPROTECT_VDB\n+#       endif\n #   \tdefine DYNAMIC_LOADING\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n-#       define CPP_WORDSZ 64\n #       define STACKBOTTOM ((ptr_t) 0x120000000)\n #       ifdef __ELF__\n #\t  define SEARCH_FOR_DATA_START\n-#\t  define DATASTART GC_data_start\n #         define DYNAMIC_LOADING\n #       else\n #           define DATASTART ((ptr_t) 0x140000000)\n@@ -1468,7 +1594,6 @@\n \textern char * GC_register_stackbottom;\n #\tdefine BACKING_STORE_BASE ((ptr_t)GC_register_stackbottom)\n #\tdefine SEARCH_FOR_DATA_START\n-#\tdefine DATASTART GC_data_start\n #\tifdef __GNUC__\n #         define DYNAMIC_LOADING\n #\telse\n@@ -1502,23 +1627,25 @@\n #   endif\n #   ifdef  DGUX\n #\tdefine OS_TYPE \"DGUX\"\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, etext)\n+\textern ptr_t GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x10000, etext)\n #   endif\n #   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n # endif\n \n # ifdef S370\n+    /* If this still works, and if anyone cares, this should probably\t*/\n+    /* be moved to the S390 category.\t\t\t\t\t*/\n #   define MACH_TYPE \"S370\"\n #   define ALIGNMENT 4\t/* Required by hardware\t*/\n #   define USE_GENERIC_PUSH_REGS\n #   ifdef UTS4\n #       define OS_TYPE \"UTS4\"\n-        extern int etext[];\n+       extern int etext[];\n \textern int _etext[];\n \textern int _end[];\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, _etext)\n+\textern ptr_t GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x10000, _etext)\n #\tdefine DATAEND (_end)\n #\tdefine HEURISTIC2\n #   endif\n@@ -1528,23 +1655,23 @@\n #   define MACH_TYPE \"S390\"\n #   define USE_GENERIC_PUSH_REGS\n #   ifndef __s390x__\n-#\tdefine ALIGNMENT 4\n-#\tdefine CPP_WORDSZ 32\n+#   define ALIGNMENT 4\n+#   define CPP_WORDSZ 32\n #   else\n-#\tdefine ALIGNMENT 8\n-#\tdefine CPP_WORDSZ 64\n-#\tdefine HBLKSIZE 4096\n+#   define ALIGNMENT 8\n+#   define CPP_WORDSZ 64\n+#   define HBLKSIZE 4096\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n #       define LINUX_STACKBOTTOM\n #       define DYNAMIC_LOADING\n-        extern int __data_start[];\n+       extern int __data_start[];\n #       define DATASTART ((ptr_t)(__data_start))\n-\textern int _end[];\n-#\tdefine DATAEND (_end)\n-#\tdefine CACHE_LINE_SIZE 256\n-#\tdefine GETPAGESIZE() 4096\n+    extern int _end[];\n+#   define DATAEND (_end)\n+#   define CACHE_LINE_SIZE 256\n+#   define GETPAGESIZE() 4096\n #   endif\n # endif\n \n@@ -1562,13 +1689,8 @@\n #   ifdef NETBSD\n #       define OS_TYPE \"NETBSD\"\n #       define HEURISTIC2\n-#\tifdef __ELF__\n-#\t    define DATASTART GC_data_start\n-#\t    define DYNAMIC_LOADING\n-#\telse\n-            extern char etext[];\n-#           define DATASTART ((ptr_t)(etext))\n-#\tendif\n+       extern char etext[];\n+#       define DATASTART ((ptr_t)(etext))\n #       define USE_GENERIC_PUSH_REGS\n #   endif\n #   ifdef LINUX\n@@ -1581,7 +1703,7 @@\n #            define DYNAMIC_LOADING\n #\t     include <features.h>\n #\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n-#\t\t define LINUX_DATA_START\n+#\t\t define SEARCH_FOR_DATA_START\n #\t     else\n      \t         extern char **__environ;\n #                define DATASTART ((ptr_t)(&__environ))\n@@ -1628,7 +1750,7 @@\n #     define STACKBOTTOM ((ptr_t) 0x7c000000)\n #     define USE_GENERIC_PUSH_REGS\n #     define DYNAMIC_LOADING\n-#     define LINUX_DATA_START\n+#     define SEARCH_FOR_DATA_START\n       extern int _end[];\n #     define DATAEND (_end)\n #   endif\n@@ -1645,7 +1767,9 @@\n #   define MACH_TYPE \"X86_64\"\n #   define ALIGNMENT 8\n #   define CPP_WORDSZ 64\n-#   define HBLKSIZE 4096\n+#   ifndef HBLKSIZE\n+#     define HBLKSIZE 4096\n+#   endif\n #   define CACHE_LINE_SIZE 64\n #   define USE_GENERIC_PUSH_REGS\n #   ifdef LINUX\n@@ -1665,7 +1789,7 @@\n #              define DATASTART ((ptr_t)((((word) (_etext)) + 0xfff) & ~0xfff))\n #\t     endif\n #\t     include <features.h>\n-#\t     define LINUX_DATA_START\n+#\t     define SEARCH_FOR_DATA_START\n \t     extern int _end[];\n #\t     define DATAEND (_end)\n #\telse\n@@ -1679,19 +1803,6 @@\n #   endif\n # endif\n \n-#ifdef LINUX_DATA_START\n-    /* Some Linux distributions arrange to define __data_start.  Some\t*/\n-    /* define data_start as a weak symbol.  The latter is technically\t*/\n-    /* broken, since the user program may define data_start, in which\t*/\n-    /* case we lose.  Nonetheless, we try both, prefering __data_start.\t*/\n-    /* We assume gcc.\t*/\n-#   pragma weak __data_start\n-    extern int __data_start[];\n-#   pragma weak data_start\n-    extern int data_start[];\n-#   define DATASTART ((ptr_t)(__data_start != 0? __data_start : data_start))\n-#endif\n-\n #if defined(LINUX) && defined(REDIRECT_MALLOC)\n     /* Rld appears to allocate some memory with its own allocator, and\t*/\n     /* some through malloc, which might be redirected.  To make this\t*/\n@@ -1730,15 +1841,15 @@\n # endif\n \n # if defined(SUNOS5) || defined(DRSNX) || defined(UTS4)\n-    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n+\t    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n #   define SVR4\n # endif\n \n # if defined(SUNOS5) || defined(DRSNX)\n-    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n-    /* loader.\t\t\t\t\t\t\t\t*/\n+\t    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n+\t    /* loader.\t\t\t\t\t\t\t\t*/\n #   define SUNOS5DL\n-    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n+\t    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n #   define SUNOS5SIGS\n # endif\n \n@@ -1747,13 +1858,14 @@\n # endif\n \n # if defined(SVR4) || defined(LINUX) || defined(IRIX) || defined(HPUX) \\\n-    || defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \\\n-    || defined(BSD) || defined(_AIX) || defined(MACOSX) || defined(OSF1)\n+\t    || defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \\\n+\t    || defined(DGUX) || defined(BSD) \\\n+\t    || defined(_AIX) || defined(DARWIN) || defined(OSF1)\n #   define UNIX_LIKE   /* Basic Unix-like system calls work.\t*/\n # endif\n \n # if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n-   -> bad word size\n+\t   -> bad word size\n # endif\n \n # ifdef PCR\n@@ -1767,13 +1879,13 @@\n # endif\n \n # ifdef SRC_M3\n-/* Postponed for now. */\n+\t/* Postponed for now. */\n #   undef PROC_VDB\n #   undef MPROTECT_VDB\n # endif\n \n # ifdef SMALL_CONFIG\n-/* Presumably not worth the space it takes. */\n+\t/* Presumably not worth the space it takes. */\n #   undef PROC_VDB\n #   undef MPROTECT_VDB\n # endif\n@@ -1813,49 +1925,50 @@\n     /* platforms as well, though it should be avoided in win32.\t\t*/\n # endif /* LINUX */\n \n-# if defined(SEARCH_FOR_DATA_START) && defined(GC_PRIVATE_H)\n+# if defined(SEARCH_FOR_DATA_START)\n     extern ptr_t GC_data_start;\n+#   define DATASTART GC_data_start\n # endif\n \n # ifndef CLEAR_DOUBLE\n #   define CLEAR_DOUBLE(x) \\\n-\t((word*)x)[0] = 0; \\\n-\t((word*)x)[1] = 0;\n+\t\t((word*)x)[0] = 0; \\\n+\t\t((word*)x)[1] = 0;\n # endif /* CLEAR_DOUBLE */\n \n-/* Internally we use GC_SOLARIS_THREADS to test for either old or pthreads. */\n+\t/* Internally we use GC_SOLARIS_THREADS to test for either old or pthreads. */\n # if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n #   define GC_SOLARIS_THREADS\n # endif\n \n # if defined(GC_IRIX_THREADS) && !defined(IRIX5)\n---> inconsistent configuration\n+\t--> inconsistent configuration\n # endif\n # if defined(GC_LINUX_THREADS) && !defined(LINUX)\n---> inconsistent configuration\n+\t--> inconsistent configuration\n # endif\n # if defined(GC_SOLARIS_THREADS) && !defined(SUNOS5)\n---> inconsistent configuration\n+\t--> inconsistent configuration\n # endif\n # if defined(GC_HPUX_THREADS) && !defined(HPUX)\n---> inconsistent configuration\n+\t--> inconsistent configuration\n+# endif\n+# if defined(GC_AIX_THREADS) && !defined(_AIX)\n+\t--> inconsistent configuration\n # endif\n-# if defined(GC_WIN32_THREADS) && !defined(MSWIN32)\n-    /* Ideally CYGWIN32 should work, in addition to MSWIN32.  I suspect\t*/\n-    /* the necessary code is mostly there, but nobody has actually made */\n-    /* sure the right combination of pieces is compiled in, etc.\t*/\n---> inconsistent configuration\n+# if defined(GC_WIN32_THREADS) && !defined(MSWIN32) && !defined(CYGWIN32)\n+\t--> inconsistent configuration\n # endif\n \n # if defined(PCR) || defined(SRC_M3) || \\\n-\tdefined(GC_SOLARIS_THREADS) || defined(GC_WIN32_THREADS) || \\\n-\tdefined(GC_PTHREADS)\n+\t\tdefined(GC_SOLARIS_THREADS) || defined(GC_WIN32_THREADS) || \\\n+\t\tdefined(GC_PTHREADS)\n #   define THREADS\n # endif\n \n-# if defined(HP_PA) || defined(M88K) || defined(POWERPC) && !defined(MACOSX) \\\n-     || defined(LINT) || defined(MSWINCE) \\\n-     || (defined(I386) && defined(__LCC__))\n+# if defined(HP_PA) || defined(M88K) || defined(POWERPC) && !defined(DARWIN) \\\n+\t     || defined(LINT) || defined(MSWINCE) || defined(ARM32) \\\n+\t     || (defined(I386) && defined(__LCC__))\n \t/* Use setjmp based hack to mark from callee-save registers.    */\n \t/* The define should move to the individual platform \t\t*/\n \t/* descriptions.\t\t\t\t\t\t*/\n@@ -1867,36 +1980,26 @@\n \t\t\t\t/* include assembly code to do it well.\t*/\n # endif\n \n-/* Can we save call chain in objects for debugging?   \t\t        */\n-/* SET NFRAMES (# of saved frames) and NARGS (#of args for each frame)\t*/\n-/* to reasonable values for the platform.\t\t\t\t*/\n-/* Set SAVE_CALL_CHAIN if we can.  SAVE_CALL_COUNT can be specified at\t*/\n-/* build time, though we feel free to adjust it slightly.\t\t*/\n-/* Define NEED_CALLINFO if we either save the call stack or \t\t*/\n-/* GC_ADD_CALLER is defined.\t\t\t\t\t\t*/\n-#ifdef LINUX\n-# include <features.h>\n-# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2\n-#   define HAVE_BUILTIN_BACKTRACE\n-# endif\n-#endif\n+  /* Can we save call chain in objects for debugging?   \t        */\n+  /* SET NFRAMES (# of saved frames) and NARGS (#of args for each \t*/\n+  /* frame) to reasonable values for the platform.\t\t\t*/\n+  /* Set SAVE_CALL_CHAIN if we can.  SAVE_CALL_COUNT can be specified \t*/\n+  /* at build time, though we feel free to adjust it slightly.\t\t*/\n+  /* Define NEED_CALLINFO if we either save the call stack or \t\t*/\n+  /* GC_ADD_CALLER is defined.\t\t\t\t\t\t*/\n+  /* GC_CAN_SAVE_CALL_STACKS is set in gc.h.\t\t\t\t*/\n \n #if defined(SPARC)\n-# define CAN_SAVE_CALL_STACKS\n # define CAN_SAVE_CALL_ARGS\n #endif\n #if (defined(I386) || defined(X86_64)) && defined(LINUX)\n-    /* SAVE_CALL_CHAIN is supported if the code is compiled to save\t*/\n-    /* frame pointers by default, i.e. no -fomit-frame-pointer flag.\t*/\n-# define CAN_SAVE_CALL_STACKS\n+\t    /* SAVE_CALL_CHAIN is supported if the code is compiled to save\t*/\n+\t    /* frame pointers by default, i.e. no -fomit-frame-pointer flag.\t*/\n # define CAN_SAVE_CALL_ARGS\n #endif\n-#if defined(HAVE_BUILTIN_BACKTRACE) && !defined(CAN_SAVE_CALL_STACKS)\n-# define CAN_SAVE_CALL_STACKS\n-#endif\n \n # if defined(SAVE_CALL_COUNT) && !defined(GC_ADD_CALLER) \\\n-     && defined(CAN_SAVE_CALL_STACKS)\n+\t     && defined(GC_CAN_SAVE_CALL_STACKS)\n #   define SAVE_CALL_CHAIN \n # endif\n # ifdef SAVE_CALL_CHAIN\n@@ -1909,7 +2012,7 @@\n # ifdef SAVE_CALL_CHAIN\n #   ifndef SAVE_CALL_COUNT\n #     define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n-\t\t\t/* alignment reasons.\t\t\t\t*/\n+\t\t\t\t/* alignment reasons.\t\t\t\t*/\n #   else\n #     define NFRAMES ((SAVE_CALL_COUNT + 1) & ~1)\n #   endif\n@@ -1925,4 +2028,96 @@\n #   define DBG_HDRS_ALL\n # endif\n \n+# if defined(POINTER_MASK) && !defined(POINTER_SHIFT)\n+#   define POINTER_SHIFT 0\n+# endif\n+\n+# if defined(POINTER_SHIFT) && !defined(POINTER_MASK)\n+#   define POINTER_MASK ((GC_word)(-1))\n+# endif\n+\n+# if !defined(FIXUP_POINTER) && defined(POINTER_MASK)\n+#   define FIXUP_POINTER(p) (p) = ((p) & (POINTER_MASK) << POINTER_SHIFT)\n+# endif\n+\n+# if defined(FIXUP_POINTER)\n+#   define NEED_FIXUP_POINTER 1\n+# else\n+#   define NEED_FIXUP_POINTER 0\n+#   define FIXUP_POINTER(p)\n+# endif\n+\n+#ifdef GC_PRIVATE_H\n+\t/* This relies on some type definitions from gc_priv.h, from\t*/\n+        /* where it's normally included.\t\t\t\t*/\n+\t/*\t\t\t\t\t\t\t\t*/\n+\t/* How to get heap memory from the OS:\t\t\t\t*/\n+\t/* Note that sbrk()-like allocation is preferred, since it \t*/\n+\t/* usually makes it possible to merge consecutively allocated\t*/\n+\t/* chunks.  It also avoids unintented recursion with\t\t*/\n+\t/* -DREDIRECT_MALLOC.\t\t\t\t\t\t*/\n+\t/* GET_MEM() returns a HLKSIZE aligned chunk.\t\t\t*/\n+\t/* 0 is taken to mean failure. \t\t\t\t\t*/\n+\t/* In the case os USE_MMAP, the argument must also be a \t*/\n+\t/* physical page size.\t\t\t\t\t\t*/\n+\t/* GET_MEM is currently not assumed to retrieve 0 filled space, */\n+\t/* though we should perhaps take advantage of the case in which */\n+\t/* does.\t\t\t\t\t\t\t*/\n+\tstruct hblk;\t/* See gc_priv.h.\t*/\n+# ifdef PCR\n+\t    char * real_malloc();\n+#   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n+\t\t\t\t\t  + GC_page_size-1)\n+# else\n+#   ifdef OS2\n+\t      void * os2_alloc(size_t bytes);\n+#     define GET_MEM(bytes) HBLKPTR((ptr_t)os2_alloc((size_t)bytes \\\n+\t\t\t\t\t    + GC_page_size) \\\n+\t\t\t\t\t    + GC_page_size-1)\n+#   else\n+#     if defined(NEXT) || defined(DOS4GW) || \\\n+\t\t (defined(AMIGA) && !defined(GC_AMIGA_FASTALLOC)) || \\\n+\t\t (defined(SUNOS5) && !defined(USE_MMAP))\n+#       define GET_MEM(bytes) HBLKPTR((size_t) \\\n+\t\t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n+\t\t\t\t\t      + GC_page_size-1)\n+#     else\n+#\tifdef MSWIN32\n+\t  extern ptr_t GC_win32_get_mem();\n+#         define GET_MEM(bytes) (struct hblk *)GC_win32_get_mem(bytes)\n+#\telse\n+#\t  ifdef MACOS\n+#\t    if defined(USE_TEMPORARY_MEMORY)\n+\t\t\textern Ptr GC_MacTemporaryNewPtr(size_t size,\n+\t\t\t\t\t\t\t Boolean clearMemory);\n+#               define GET_MEM(bytes) HBLKPTR( \\\n+\t\t\t    GC_MacTemporaryNewPtr(bytes + GC_page_size, true) \\\n+\t\t\t    + GC_page_size-1)\n+#\t    else\n+#         \t    define GET_MEM(bytes) HBLKPTR( \\\n+\t\t\t\tNewPtrClear(bytes + GC_page_size) + GC_page_size-1)\n+#\t    endif\n+#\t  else\n+#\t    ifdef MSWINCE\n+\t      extern ptr_t GC_wince_get_mem();\n+#\t      define GET_MEM(bytes) (struct hblk *)GC_wince_get_mem(bytes)\n+#\t    else\n+#\t      if defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)\n+\t\t\textern void *GC_amiga_get_mem(size_t size);\n+#\t\t\tdefine GET_MEM(bytes) HBLKPTR((size_t) \\\n+\t\t\t  GC_amiga_get_mem((size_t)bytes + GC_page_size) \\\n+\t\t\t  + GC_page_size-1)\n+#\t      else\n+\t\textern ptr_t GC_unix_get_mem();\n+#               define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)\n+#\t      endif\n+#\t    endif\n+#\t  endif\n+#\tendif\n+#     endif\n+#   endif\n+# endif\n+\n+#endif /* GC_PRIVATE_H */\n+\n # endif /* GCCONFIG_H */"}, {"sha": "7d49c2987e0062dce8fb2c1a302b3770dd32c836", "filename": "boehm-gc/include/private/solaris_threads.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -16,7 +16,8 @@\n #      define DETACHED 2       /* Thread is intended to be detached.   */\n #      define CLIENT_OWNS_STACK        4\n                                /* Stack was supplied by client.        */\n-#      define SUSPENDED 8      /* Currently suspended. */\n+#      define SUSPNDED 8       /* Currently suspended.\t\t\t*/\n+    \t\t\t       /* SUSPENDED is used insystem header.\t*/\n     ptr_t stack;\n     size_t stack_size;\n     cond_t join_cv;"}, {"sha": "a0e6ae0ebc18ff292ae411123ea5841265352458", "filename": "boehm-gc/include/private/specific.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fspecific.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -85,7 +85,7 @@ static __inline__ void * PREFIXED(getspecific) (tsd * key) {\n     unsigned hash_val = CACHE_HASH(qtid);\n     tse * volatile * entry_ptr = key -> cache + hash_val;\n     tse * entry = *entry_ptr;   /* Must be loaded only once.\t*/\n-    if (entry -> qtid == qtid) {\n+   if (EXPECT(entry -> qtid == qtid, 1)) {\n       GC_ASSERT(entry -> thread == pthread_self());\n       return entry -> value;\n     }"}, {"sha": "75b7c63125eb751be7f6db43c1847d4b7c2d6ff4", "filename": "boehm-gc/irix_threads.c", "status": "removed", "additions": 0, "deletions": 726, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,726 +0,0 @@\n-/* \n- * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/*\n- * Support code for Irix (>=6.2) Pthreads.  This relies on properties\n- * not guaranteed by the Pthread standard.  It may or may not be portable\n- * to other implementations.\n- *\n- * This now also includes an initial attempt at thread support for\n- * HP/UX 11.\n- *\n- * Note that there is a lot of code duplication between linux_threads.c\n- * and irix_threads.c; any changes made here may need to be reflected\n- * there too.\n- */\n-\n-# if defined(GC_IRIX_THREADS)\n-\n-# include \"private/gc_priv.h\"\n-# include <pthread.h>\n-# include <semaphore.h>\n-# include <time.h>\n-# include <errno.h>\n-# include <unistd.h>\n-# include <sys/mman.h>\n-# include <sys/time.h>\n-\n-#undef pthread_create\n-#undef pthread_sigmask\n-#undef pthread_join\n-#undef pthread_detach\n-\n-void GC_thr_init();\n-\n-#if 0\n-void GC_print_sig_mask()\n-{\n-    sigset_t blocked;\n-    int i;\n-\n-    if (pthread_sigmask(SIG_BLOCK, NULL, &blocked) != 0)\n-    \tABORT(\"pthread_sigmask\");\n-    GC_printf0(\"Blocked: \");\n-    for (i = 1; i <= MAXSIG; i++) {\n-        if (sigismember(&blocked, i)) { GC_printf1(\"%ld \",(long) i); }\n-    }\n-    GC_printf0(\"\\n\");\n-}\n-#endif\n-\n-/* We use the allocation lock to protect thread-related data structures. */\n-\n-/* The set of all known threads.  We intercept thread creation and \t*/\n-/* joins.  We never actually create detached threads.  We allocate all \t*/\n-/* new thread stacks ourselves.  These allow us to maintain this\t*/\n-/* data structure.\t\t\t\t\t\t\t*/\n-/* Protected by GC_thr_lock.\t\t\t\t\t\t*/\n-/* Some of this should be declared volatile, but that's incosnsistent\t*/\n-/* with some library routine declarations.  \t\t \t\t*/\n-typedef struct GC_Thread_Rep {\n-    struct GC_Thread_Rep * next;  /* More recently allocated threads\t*/\n-\t\t\t\t  /* with a given pthread id come \t*/\n-\t\t\t\t  /* first.  (All but the first are\t*/\n-\t\t\t\t  /* guaranteed to be dead, but we may  */\n-\t\t\t\t  /* not yet have registered the join.) */\n-    pthread_t id;\n-    word stop;\n-#\tdefine NOT_STOPPED 0\n-#\tdefine PLEASE_STOP 1\n-#\tdefine STOPPED 2\n-    word flags;\n-#\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n-#\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n-#\tdefine CLIENT_OWNS_STACK\t4\n-\t\t\t\t/* Stack was supplied by client.\t*/\n-    ptr_t stack;\n-    ptr_t stack_ptr;  \t\t/* Valid only when stopped. */\n-\t\t\t\t/* But must be within stack region at\t*/\n-\t\t\t\t/* all times.\t\t\t\t*/\n-    size_t stack_size;\t\t/* 0 for original thread.\t*/\n-    void * status;\t\t/* Used only to avoid premature \t*/\n-\t\t\t\t/* reclamation of any data it might \t*/\n-\t\t\t\t/* reference.\t\t\t\t*/\n-} * GC_thread;\n-\n-GC_thread GC_lookup_thread(pthread_t id);\n-\n-/*\n- * The only way to suspend threads given the pthread interface is to send\n- * signals.  Unfortunately, this means we have to reserve\n- * a signal, and intercept client calls to change the signal mask.\n- * We use SIG_SUSPEND, defined in gc_priv.h.\n- */\n-\n-pthread_mutex_t GC_suspend_lock = PTHREAD_MUTEX_INITIALIZER;\n-\t\t\t\t/* Number of threads stopped so far\t*/\n-pthread_cond_t GC_suspend_ack_cv = PTHREAD_COND_INITIALIZER;\n-pthread_cond_t GC_continue_cv = PTHREAD_COND_INITIALIZER;\n-\n-void GC_suspend_handler(int sig)\n-{\n-    int dummy;\n-    GC_thread me;\n-    sigset_t all_sigs;\n-    sigset_t old_sigs;\n-    int i;\n-\n-    if (sig != SIG_SUSPEND) ABORT(\"Bad signal in suspend_handler\");\n-    me = GC_lookup_thread(pthread_self());\n-    /* The lookup here is safe, since I'm doing this on behalf  */\n-    /* of a thread which holds the allocation lock in order\t*/\n-    /* to stop the world.  Thus concurrent modification of the\t*/\n-    /* data structure is impossible.\t\t\t\t*/\n-    if (PLEASE_STOP != me -> stop) {\n-\t/* Misdirected signal.\t*/\n-\tpthread_mutex_unlock(&GC_suspend_lock);\n-\treturn;\n-    }\n-    pthread_mutex_lock(&GC_suspend_lock);\n-    me -> stack_ptr = (ptr_t)(&dummy);\n-    me -> stop = STOPPED;\n-    pthread_cond_signal(&GC_suspend_ack_cv);\n-    pthread_cond_wait(&GC_continue_cv, &GC_suspend_lock);\n-    pthread_mutex_unlock(&GC_suspend_lock);\n-    /* GC_printf1(\"Continuing 0x%x\\n\", pthread_self()); */\n-}\n-\n-\n-GC_bool GC_thr_initialized = FALSE;\n-\n-size_t GC_min_stack_sz;\n-\n-# define N_FREE_LISTS 25\n-ptr_t GC_stack_free_lists[N_FREE_LISTS] = { 0 };\n-\t\t/* GC_stack_free_lists[i] is free list for stacks of \t*/\n-\t\t/* size GC_min_stack_sz*2**i.\t\t\t\t*/\n-\t\t/* Free lists are linked through first word.\t\t*/\n-\n-/* Return a stack of size at least *stack_size.  *stack_size is\t*/\n-/* replaced by the actual stack size.\t\t\t\t*/\n-/* Caller holds allocation lock.\t\t\t\t*/\n-ptr_t GC_stack_alloc(size_t * stack_size)\n-{\n-    register size_t requested_sz = *stack_size;\n-    register size_t search_sz = GC_min_stack_sz;\n-    register int index = 0;\t/* = log2(search_sz/GC_min_stack_sz) */\n-    register ptr_t result;\n-    \n-    while (search_sz < requested_sz) {\n-        search_sz *= 2;\n-        index++;\n-    }\n-    if ((result = GC_stack_free_lists[index]) == 0\n-        && (result = GC_stack_free_lists[index+1]) != 0) {\n-        /* Try next size up. */\n-        search_sz *= 2; index++;\n-    }\n-    if (result != 0) {\n-        GC_stack_free_lists[index] = *(ptr_t *)result;\n-    } else {\n-        result = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_size);\n-        result = (ptr_t)(((word)result + GC_page_size) & ~(GC_page_size - 1));\n-        /* Protect hottest page to detect overflow. */\n-#\tifdef STACK_GROWS_UP\n-          /* mprotect(result + search_sz, GC_page_size, PROT_NONE); */\n-#\telse\n-          /* mprotect(result, GC_page_size, PROT_NONE); */\n-          result += GC_page_size;\n-#\tendif\n-    }\n-    *stack_size = search_sz;\n-    return(result);\n-}\n-\n-/* Caller holds allocation lock.\t\t\t\t\t*/\n-void GC_stack_free(ptr_t stack, size_t size)\n-{\n-    register int index = 0;\n-    register size_t search_sz = GC_min_stack_sz;\n-    \n-    while (search_sz < size) {\n-        search_sz *= 2;\n-        index++;\n-    }\n-    if (search_sz != size) ABORT(\"Bad stack size\");\n-    *(ptr_t *)stack = GC_stack_free_lists[index];\n-    GC_stack_free_lists[index] = stack;\n-}\n-\n-\n-\n-# define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n-volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n-\n-void GC_push_thread_structures GC_PROTO((void))\n-{\n-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n-}\n-\n-/* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n-/* Caller holds allocation lock.\t\t\t\t\t*/\n-GC_thread GC_new_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    GC_thread result;\n-    static struct GC_Thread_Rep first_thread;\n-    static GC_bool first_thread_used = FALSE;\n-    \n-    if (!first_thread_used) {\n-    \tresult = &first_thread;\n-    \tfirst_thread_used = TRUE;\n-    \t/* Dont acquire allocation lock, since we may already hold it. */\n-    } else {\n-        result = (struct GC_Thread_Rep *)\n-        \t GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);\n-    }\n-    if (result == 0) return(0);\n-    result -> id = id;\n-    result -> next = GC_threads[hv];\n-    GC_threads[hv] = result;\n-    /* result -> flags = 0;     */\n-    /* result -> stop = 0;\t*/\n-    return(result);\n-}\n-\n-/* Delete a thread from GC_threads.  We assume it is there.\t*/\n-/* (The code intentionally traps if it wasn't.)\t\t\t*/\n-/* Caller holds allocation lock.\t\t\t\t*/\n-void GC_delete_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    register GC_thread prev = 0;\n-    \n-    while (!pthread_equal(p -> id, id)) {\n-        prev = p;\n-        p = p -> next;\n-    }\n-    if (prev == 0) {\n-        GC_threads[hv] = p -> next;\n-    } else {\n-        prev -> next = p -> next;\n-    }\n-}\n-\n-/* If a thread has been joined, but we have not yet\t\t*/\n-/* been notified, then there may be more than one thread \t*/\n-/* in the table with the same pthread id.\t\t\t*/\n-/* This is OK, but we need a way to delete a specific one.\t*/\n-void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    register GC_thread prev = 0;\n-\n-    while (p != gc_id) {\n-        prev = p;\n-        p = p -> next;\n-    }\n-    if (prev == 0) {\n-        GC_threads[hv] = p -> next;\n-    } else {\n-        prev -> next = p -> next;\n-    }\n-}\n-\n-/* Return a GC_thread corresponding to a given thread_t.\t*/\n-/* Returns 0 if it's not there.\t\t\t\t\t*/\n-/* Caller holds  allocation lock or otherwise inhibits \t\t*/\n-/* updates.\t\t\t\t\t\t\t*/\n-/* If there is more than one thread with the given id we \t*/\n-/* return the most recent one.\t\t\t\t\t*/\n-GC_thread GC_lookup_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    \n-    while (p != 0 && !pthread_equal(p -> id, id)) p = p -> next;\n-    return(p);\n-}\n-\n-\n-/* Caller holds allocation lock.\t*/\n-void GC_stop_world()\n-{\n-    pthread_t my_thread = pthread_self();\n-    register int i;\n-    register GC_thread p;\n-    register int result;\n-    struct timespec timeout;\n-    \n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> id != my_thread) {\n-            if (p -> flags & FINISHED) {\n-\t\tp -> stop = STOPPED;\n-\t\tcontinue;\n-\t    }\n-\t    p -> stop = PLEASE_STOP;\n-            result = pthread_kill(p -> id, SIG_SUSPEND);\n-\t    /* GC_printf1(\"Sent signal to 0x%x\\n\", p -> id); */\n-\t    switch(result) {\n-                case ESRCH:\n-                    /* Not really there anymore.  Possible? */\n-                    p -> stop = STOPPED;\n-                    break;\n-                case 0:\n-                    break;\n-                default:\n-                    ABORT(\"pthread_kill failed\");\n-            }\n-        }\n-      }\n-    }\n-    pthread_mutex_lock(&GC_suspend_lock);\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        while (p -> id != my_thread && p -> stop != STOPPED) {\n-\t    clock_gettime(CLOCK_REALTIME, &timeout);\n-            timeout.tv_nsec += 50000000; /* 50 msecs */\n-            if (timeout.tv_nsec >= 1000000000) {\n-                timeout.tv_nsec -= 1000000000;\n-                ++timeout.tv_sec;\n-            }\n-            result = pthread_cond_timedwait(&GC_suspend_ack_cv,\n-\t\t\t\t\t    &GC_suspend_lock,\n-                                            &timeout);\n-            if (result == ETIMEDOUT) {\n-                /* Signal was lost or misdirected.  Try again.      */\n-                /* Duplicate signals should be benign.              */\n-                result = pthread_kill(p -> id, SIG_SUSPEND);\n-\t    }\n-\t}\n-      }\n-    }\n-    pthread_mutex_unlock(&GC_suspend_lock);\n-    /* GC_printf1(\"World stopped 0x%x\\n\", pthread_self()); */\n-}\n-\n-/* Caller holds allocation lock.\t*/\n-void GC_start_world()\n-{\n-    GC_thread p;\n-    unsigned i;\n-\n-    /* GC_printf0(\"World starting\\n\"); */\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-\tp -> stop = NOT_STOPPED;\n-      }\n-    }\n-    pthread_mutex_lock(&GC_suspend_lock);\n-    /* All other threads are at pthread_cond_wait in signal handler.\t*/\n-    /* Otherwise we couldn't have acquired the lock.\t\t\t*/\n-    pthread_mutex_unlock(&GC_suspend_lock);\n-    pthread_cond_broadcast(&GC_continue_cv);\n-}\n-\n-# ifdef MMAP_STACKS\n---> not really supported yet.\n-int GC_is_thread_stack(ptr_t addr)\n-{\n-    register int i;\n-    register GC_thread p;\n-\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> stack_size != 0) {\n-            if (p -> stack <= addr &&\n-                addr < p -> stack + p -> stack_size)\n-                   return 1;\n-       }\n-      }\n-    }\n-    return 0;\n-}\n-# endif\n-\n-/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n-/* world is stopped.  Should not fail if it isn't.\t\t\t*/\n-void GC_push_all_stacks()\n-{\n-    register int i;\n-    register GC_thread p;\n-    register ptr_t sp = GC_approx_sp();\n-    register ptr_t hot, cold;\n-    pthread_t me = pthread_self();\n-    \n-    if (!GC_thr_initialized) GC_thr_init();\n-    /* GC_printf1(\"Pushing stacks from thread 0x%x\\n\", me); */\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> flags & FINISHED) continue;\n-        if (pthread_equal(p -> id, me)) {\n-\t    hot = GC_approx_sp();\n-\t} else {\n-\t    hot = p -> stack_ptr;\n-\t}\n-        if (p -> stack_size != 0) {\n-#\t  ifdef STACK_GROWS_UP\n-\t    cold = p -> stack;\n-#\t  else\n-            cold = p -> stack + p -> stack_size;\n-#\t  endif\n-        } else {\n-            /* The original stack. */\n-            cold = GC_stackbottom;\n-        }\n-#\tifdef STACK_GROWS_UP\n-          GC_push_all_stack(cold, hot);\n-#\telse\n-          GC_push_all_stack(hot, cold);\n-#\tendif\n-      }\n-    }\n-}\n-\n-\n-/* We hold the allocation lock.\t*/\n-void GC_thr_init()\n-{\n-    GC_thread t;\n-    struct sigaction act;\n-\n-    if (GC_thr_initialized) return;\n-    GC_thr_initialized = TRUE;\n-    GC_min_stack_sz = HBLKSIZE;\n-    (void) sigaction(SIG_SUSPEND, 0, &act);\n-    if (act.sa_handler != SIG_DFL)\n-    \tABORT(\"Previously installed SIG_SUSPEND handler\");\n-    /* Install handler.\t*/\n-\tact.sa_handler = GC_suspend_handler;\n-\tact.sa_flags = SA_RESTART;\n-\t(void) sigemptyset(&act.sa_mask);\n-        if (0 != sigaction(SIG_SUSPEND, &act, 0))\n-\t    ABORT(\"Failed to install SIG_SUSPEND handler\");\n-    /* Add the initial thread, so we can stop it.\t*/\n-      t = GC_new_thread(pthread_self());\n-      t -> stack_size = 0;\n-      t -> stack_ptr = (ptr_t)(&t);\n-      t -> flags = DETACHED;\n-}\n-\n-int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)\n-{\n-    sigset_t fudged_set;\n-    \n-    if (set != NULL && (how == SIG_BLOCK || how == SIG_SETMASK)) {\n-        fudged_set = *set;\n-        sigdelset(&fudged_set, SIG_SUSPEND);\n-        set = &fudged_set;\n-    }\n-    return(pthread_sigmask(how, set, oset));\n-}\n-\n-struct start_info {\n-    void *(*start_routine)(void *);\n-    void *arg;\n-    word flags;\n-    ptr_t stack;\n-    size_t stack_size;\n-    sem_t registered;   \t/* 1 ==> in our thread table, but \t*/\n-\t\t\t\t/* parent hasn't yet noticed.\t\t*/\n-};\n-\n-void GC_thread_exit_proc(void *arg)\n-{\n-    GC_thread me;\n-\n-    LOCK();\n-    me = GC_lookup_thread(pthread_self());\n-    if (me -> flags & DETACHED) {\n-    \tGC_delete_thread(pthread_self());\n-    } else {\n-\tme -> flags |= FINISHED;\n-    }\n-    UNLOCK();\n-}\n-\n-int GC_pthread_join(pthread_t thread, void **retval)\n-{\n-    int result;\n-    GC_thread thread_gc_id;\n-    \n-    LOCK();\n-    thread_gc_id = GC_lookup_thread(thread);\n-    /* This is guaranteed to be the intended one, since the thread id\t*/\n-    /* cant have been recycled by pthreads.\t\t\t\t*/\n-    UNLOCK();\n-    result = pthread_join(thread, retval);\n-    /* Some versions of the Irix pthreads library can erroneously \t*/\n-    /* return EINTR when the call succeeds.\t\t\t\t*/\n-\tif (EINTR == result) result = 0;\n-    if (result == 0) {\n-        LOCK();\n-        /* Here the pthread thread id may have been recycled. */\n-        GC_delete_gc_thread(thread, thread_gc_id);\n-        UNLOCK();\n-    }\n-    return result;\n-}\n-\n-int GC_pthread_detach(pthread_t thread)\n-{\n-    int result;\n-    GC_thread thread_gc_id;\n-    \n-    LOCK();\n-    thread_gc_id = GC_lookup_thread(thread);\n-    UNLOCK();\n-    result = pthread_detach(thread);\n-    if (result == 0) {\n-      LOCK();\n-      thread_gc_id -> flags |= DETACHED;\n-      /* Here the pthread thread id may have been recycled. */\n-      if (thread_gc_id -> flags & FINISHED) {\n-        GC_delete_gc_thread(thread, thread_gc_id);\n-      }\n-      UNLOCK();\n-    }\n-    return result;\n-}\n-\n-void * GC_start_routine(void * arg)\n-{\n-    struct start_info * si = arg;\n-    void * result;\n-    GC_thread me;\n-    pthread_t my_pthread;\n-    void *(*start)(void *);\n-    void *start_arg;\n-\n-    my_pthread = pthread_self();\n-    /* If a GC occurs before the thread is registered, that GC will\t*/\n-    /* ignore this thread.  That's fine, since it will block trying to  */\n-    /* acquire the allocation lock, and won't yet hold interesting \t*/\n-    /* pointers.\t\t\t\t\t\t\t*/\n-    LOCK();\n-    /* We register the thread here instead of in the parent, so that\t*/\n-    /* we don't need to hold the allocation lock during pthread_create. */\n-    /* Holding the allocation lock there would make REDIRECT_MALLOC\t*/\n-    /* impossible.  It probably still doesn't work, but we're a little  */\n-    /* closer ...\t\t\t\t\t\t\t*/\n-    /* This unfortunately means that we have to be careful the parent\t*/\n-    /* doesn't try to do a pthread_join before we're registered.\t*/\n-    me = GC_new_thread(my_pthread);\n-    me -> flags = si -> flags;\n-    me -> stack = si -> stack;\n-    me -> stack_size = si -> stack_size;\n-    me -> stack_ptr = (ptr_t)si -> stack + si -> stack_size - sizeof(word);\n-    UNLOCK();\n-    start = si -> start_routine;\n-    start_arg = si -> arg;\n-    sem_post(&(si -> registered));\n-    pthread_cleanup_push(GC_thread_exit_proc, 0);\n-    result = (*start)(start_arg);\n-    me -> status = result;\n-    me -> flags |= FINISHED;\n-    pthread_cleanup_pop(1);\n-\t/* This involves acquiring the lock, ensuring that we can't exit */\n-\t/* while a collection that thinks we're alive is trying to stop  */\n-\t/* us.\t\t\t\t\t\t\t\t */\n-    return(result);\n-}\n-\n-# define copy_attr(pa_ptr, source) *(pa_ptr) = *(source)\n-\n-int\n-GC_pthread_create(pthread_t *new_thread,\n-\t\t  const pthread_attr_t *attr,\n-                  void *(*start_routine)(void *), void *arg)\n-{\n-    int result;\n-    GC_thread t;\n-    void * stack;\n-    size_t stacksize;\n-    pthread_attr_t new_attr;\n-    int detachstate;\n-    word my_flags = 0;\n-    struct start_info * si = GC_malloc(sizeof(struct start_info)); \n-\t/* This is otherwise saved only in an area mmapped by the thread */\n-\t/* library, which isn't visible to the collector.\t\t */\n-\n-    if (0 == si) return(ENOMEM);\n-    if (0 != sem_init(&(si -> registered), 0, 0)) {\n-        ABORT(\"sem_init failed\");\n-    }\n-    si -> start_routine = start_routine;\n-    si -> arg = arg;\n-    LOCK();\n-    if (!GC_is_initialized) GC_init();\n-    if (NULL == attr) {\n-        stack = 0;\n-\t(void) pthread_attr_init(&new_attr);\n-    } else {\n-\tcopy_attr(&new_attr, attr);\n-\tpthread_attr_getstackaddr(&new_attr, &stack);\n-    }\n-    pthread_attr_getstacksize(&new_attr, &stacksize);\n-    pthread_attr_getdetachstate(&new_attr, &detachstate);\n-    if (stacksize < GC_min_stack_sz) ABORT(\"Stack too small\");\n-    if (0 == stack) {\n-     \tstack = (void *)GC_stack_alloc(&stacksize);\n-     \tif (0 == stack) {\n-     \t    UNLOCK();\n-     \t    return(ENOMEM);\n-     \t}\n-\tpthread_attr_setstackaddr(&new_attr, stack);\n-    } else {\n-    \tmy_flags |= CLIENT_OWNS_STACK;\n-    }\n-    if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n-    si -> flags = my_flags;\n-    si -> stack = stack;\n-    si -> stack_size = stacksize;\n-    result = pthread_create(new_thread, &new_attr, GC_start_routine, si);\n-    if (0 == new_thread && !(my_flags & CLIENT_OWNS_STACK)) {\n-      \tGC_stack_free(stack, stacksize);\n-    }        \n-    UNLOCK();  \n-    /* Wait until child has been added to the thread table.\t\t*/\n-    /* This also ensures that we hold onto si until the child is done\t*/\n-    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n-    /* visible to the collector.\t\t\t\t\t*/\n-        while (0 != sem_wait(&(si -> registered))) {\n-\t  if (errno != EINTR) {\n-\t    GC_printf1(\"Sem_wait: errno = %ld\\n\", (unsigned long) errno);\n-\t    ABORT(\"sem_wait failed\");\n-\t  }\n-\t}\n-        sem_destroy(&(si -> registered));\n-    pthread_attr_destroy(&new_attr);  /* Probably unnecessary under Irix */\n-    return(result);\n-}\n-\n-VOLATILE GC_bool GC_collecting = 0;\n-\t\t\t/* A hint that we're in the collector and       */\n-                        /* holding the allocation lock for an           */\n-                        /* extended period.                             */\n-\n-/* Reasonably fast spin locks.  Basically the same implementation */\n-/* as STL alloc.h.\t\t\t\t\t\t  */\n-\n-#define SLEEP_THRESHOLD 3\n-\n-unsigned long GC_allocate_lock = 0;\n-# define GC_TRY_LOCK() !GC_test_and_set(&GC_allocate_lock)\n-# define GC_LOCK_TAKEN GC_allocate_lock\n-\n-void GC_lock()\n-{\n-#   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */\n-#   define high_spin_max 1000 /* spin cycles for multiprocessor */\n-    static unsigned spin_max = low_spin_max;\n-    unsigned my_spin_max;\n-    static unsigned last_spins = 0;\n-    unsigned my_last_spins;\n-    volatile unsigned junk;\n-#   define PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n-    int i;\n-\n-    if (GC_TRY_LOCK()) {\n-        return;\n-    }\n-    junk = 0;\n-    my_spin_max = spin_max;\n-    my_last_spins = last_spins;\n-    for (i = 0; i < my_spin_max; i++) {\n-        if (GC_collecting) goto yield;\n-        if (i < my_last_spins/2 || GC_LOCK_TAKEN) {\n-            PAUSE; \n-            continue;\n-        }\n-        if (GC_TRY_LOCK()) {\n-\t    /*\n-             * got it!\n-             * Spinning worked.  Thus we're probably not being scheduled\n-             * against the other process with which we were contending.\n-             * Thus it makes sense to spin longer the next time.\n-\t     */\n-            last_spins = i;\n-            spin_max = high_spin_max;\n-            return;\n-        }\n-    }\n-    /* We are probably being scheduled against the other process.  Sleep. */\n-    spin_max = low_spin_max;\n-yield:\n-    for (i = 0;; ++i) {\n-        if (GC_TRY_LOCK()) {\n-            return;\n-        }\n-        if (i < SLEEP_THRESHOLD) {\n-            sched_yield();\n-\t} else {\n-\t    struct timespec ts;\n-\t\n-\t    if (i > 26) i = 26;\n-\t\t\t/* Don't wait for more than about 60msecs, even\t*/\n-\t\t\t/* under extreme contention.\t\t\t*/\n-\t    ts.tv_sec = 0;\n-\t    ts.tv_nsec = 1 << i;\n-\t    nanosleep(&ts, 0);\n-\t}\n-    }\n-}\n-\n-# else\n-\n-#ifndef LINT\n-  int GC_no_Irix_threads;\n-#endif\n-\n-# endif /* GC_IRIX_THREADS */\n-"}, {"sha": "c968e7cbfd4a934ff6010287ffce025932ae7f3c", "filename": "boehm-gc/linux_threads.c", "status": "removed", "additions": 0, "deletions": 1735, "changes": 1735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,1735 +0,0 @@\n-/* \n- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n- * Copyright (c) 2000-2001 by Hewlett-Packard Company.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/*\n- * Support code for LinuxThreads, the clone()-based kernel\n- * thread package for Linux which is included in libc6.\n- *\n- * This code relies on implementation details of LinuxThreads,\n- * (i.e. properties not guaranteed by the Pthread standard),\n- * though this version now does less of that than the other Pthreads\n- * support code.\n- *\n- * Note that there is a lot of code duplication between linux_threads.c\n- * and thread support for some of the other Posix platforms; any changes\n- * made here may need to be reflected there too.\n- */\n-/*\n- * Linux_threads.c now also includes some code to support HPUX and\n- * OSF1 (Compaq Tru64 Unix, really).  The OSF1 support is not yet\n- * functional.  The OSF1 code is based on Eric Benson's\n- * patch, though that was originally against hpux_irix_threads.  The code\n- * here is completely untested.  With 0.0000001% probability, it might\n- * actually work.\n- *\n- * Eric also suggested an alternate basis for a lock implementation in\n- * his code:\n- * + #elif defined(OSF1)\n- * +    unsigned long GC_allocate_lock = 0;\n- * +    msemaphore GC_allocate_semaphore;\n- * + #  define GC_TRY_LOCK() \\\n- * +    ((msem_lock(&GC_allocate_semaphore, MSEM_IF_NOWAIT) == 0) \\\n- * +     ? (GC_allocate_lock = 1) \\\n- * +     : 0)\n- * + #  define GC_LOCK_TAKEN GC_allocate_lock\n- */\n-\n-/* #define DEBUG_THREADS 1 */\n-\n-/* ANSI C requires that a compilation unit contains something */\n-\n-# include \"gc.h\"\n-\n-# if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n-     && !defined(GC_IRIX_THREADS)\n-\n-# include \"private/gc_priv.h\"\n-\n-# if defined(GC_HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n-     && !defined(USE_HPUX_TLS)\n-#   define USE_HPUX_TLS\n-# endif\n-\n-# ifdef THREAD_LOCAL_ALLOC\n-#   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_HPUX_TLS)\n-#     include \"private/specific.h\"\n-#   endif\n-#   if defined(USE_PTHREAD_SPECIFIC)\n-#     define GC_getspecific pthread_getspecific\n-#     define GC_setspecific pthread_setspecific\n-#     define GC_key_create pthread_key_create\n-      typedef pthread_key_t GC_key_t;\n-#   endif\n-#   if defined(USE_HPUX_TLS)\n-#     define GC_getspecific(x) (x)\n-#     define GC_setspecific(key, v) ((key) = (v), 0)\n-#     define GC_key_create(key, d) 0\n-      typedef void * GC_key_t;\n-#   endif\n-# endif\n-# include <stdlib.h>\n-# include <pthread.h>\n-# include <sched.h>\n-# include <time.h>\n-# include <errno.h>\n-# include <unistd.h>\n-# include <sys/mman.h>\n-# include <sys/time.h>\n-# include <semaphore.h>\n-# include <signal.h>\n-# include <sys/types.h>\n-# include <sys/stat.h>\n-# include <fcntl.h>\n-\n-#ifndef __GNUC__\n-#   define __inline__\n-#endif\n-\n-#ifdef GC_USE_LD_WRAP\n-#   define WRAP_FUNC(f) __wrap_##f\n-#   define REAL_FUNC(f) __real_##f\n-#else\n-#   define WRAP_FUNC(f) GC_##f\n-#   define REAL_FUNC(f) f\n-#   undef pthread_create\n-#   undef pthread_sigmask\n-#   undef pthread_join\n-#   undef pthread_detach\n-#endif\n-\n-\n-void GC_thr_init();\n-\n-#if 0\n-void GC_print_sig_mask()\n-{\n-    sigset_t blocked;\n-    int i;\n-\n-    if (pthread_sigmask(SIG_BLOCK, NULL, &blocked) != 0)\n-    \tABORT(\"pthread_sigmask\");\n-    GC_printf0(\"Blocked: \");\n-    for (i = 1; i <= MAXSIG; i++) {\n-        if (sigismember(&blocked, i)) { GC_printf1(\"%ld \",(long) i); }\n-    }\n-    GC_printf0(\"\\n\");\n-}\n-#endif\n-\n-\n-/* We use the allocation lock to protect thread-related data structures. */\n-\n-/* The set of all known threads.  We intercept thread creation and \t*/\n-/* joins.\t\t\t\t\t\t\t\t*/\n-/* Protected by allocation/GC lock.\t\t\t\t\t*/\n-/* Some of this should be declared volatile, but that's inconsistent\t*/\n-/* with some library routine declarations.  \t\t \t\t*/\n-typedef struct GC_Thread_Rep {\n-    struct GC_Thread_Rep * next;  /* More recently allocated threads\t*/\n-\t\t\t\t  /* with a given pthread id come \t*/\n-\t\t\t\t  /* first.  (All but the first are\t*/\n-\t\t\t\t  /* guaranteed to be dead, but we may  */\n-\t\t\t\t  /* not yet have registered the join.) */\n-    pthread_t id;\n-    short flags;\n-#\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n-#\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n-#\tdefine MAIN_THREAD 4\t/* True for the original thread only.\t*/\n-    short thread_blocked;\t/* Protected by GC lock.\t\t*/\n-    \t\t\t\t/* Treated as a boolean value.  If set,\t*/\n-    \t\t\t\t/* thread will acquire GC lock before\t*/\n-    \t\t\t\t/* doing any pointer manipulations, and\t*/\n-    \t\t\t\t/* has set its sp value.  Thus it does\t*/\n-    \t\t\t\t/* not need to be sent a signal to stop\t*/\n-    \t\t\t\t/* it.\t\t\t\t\t*/\n-    ptr_t stack_end;\t\t/* Cold end of the stack.\t\t*/\n-    ptr_t stack_ptr;  \t\t/* Valid only when stopped.      \t*/\n-#   ifdef IA64\n-\tptr_t backing_store_end;\n-\tptr_t backing_store_ptr;\n-#   endif\n-    int\tsignal;\n-    void * status;\t\t/* The value returned from the thread.  */\n-    \t\t\t\t/* Used only to avoid premature \t*/\n-\t\t\t\t/* reclamation of any data it might \t*/\n-\t\t\t\t/* reference.\t\t\t\t*/\n-#   ifdef THREAD_LOCAL_ALLOC\n-#\tif CPP_WORDSZ == 64 && defined(ALIGN_DOUBLE)\n-#\t    define GRANULARITY 16\n-#\t    define NFREELISTS 49\n-#\telse\n-#\t    define GRANULARITY 8\n-#\t    define NFREELISTS 65\n-#\tendif\n-\t/* The ith free list corresponds to size i*GRANULARITY */\n-#\tdefine INDEX_FROM_BYTES(n) ((ADD_SLOP(n) + GRANULARITY - 1)/GRANULARITY)\n-#\tdefine BYTES_FROM_INDEX(i) ((i) * GRANULARITY - EXTRA_BYTES)\n-#\tdefine SMALL_ENOUGH(bytes) (ADD_SLOP(bytes) <= \\\n-\t\t\t\t    (NFREELISTS-1)*GRANULARITY)\n-\tptr_t ptrfree_freelists[NFREELISTS];\n-\tptr_t normal_freelists[NFREELISTS];\n-#\tifdef GC_GCJ_SUPPORT\n-\t  ptr_t gcj_freelists[NFREELISTS];\n-#\tendif\n-\t\t/* Free lists contain either a pointer or a small count */\n-\t\t/* reflecting the number of granules allocated at that\t*/\n-\t\t/* size.\t\t\t\t\t\t*/\n-\t\t/* 0 ==> thread-local allocation in use, free list\t*/\n-\t\t/*       empty.\t\t\t\t\t\t*/\n-\t\t/* > 0, <= DIRECT_GRANULES ==> Using global allocation,\t*/\n-\t\t/*       too few objects of this size have been\t\t*/\n-\t\t/* \t allocated by this thread.\t\t\t*/\n-\t\t/* >= HBLKSIZE  => pointer to nonempty free list.\t*/\n-\t\t/* > DIRECT_GRANULES, < HBLKSIZE ==> transition to\t*/\n-\t\t/*    local alloc, equivalent to 0.\t\t\t*/\n-#\tdefine DIRECT_GRANULES (HBLKSIZE/GRANULARITY)\n-\t\t/* Don't use local free lists for up to this much \t*/\n-\t\t/* allocation.\t\t\t\t\t\t*/\n-#   endif\n-} * GC_thread;\n-\n-GC_thread GC_lookup_thread(pthread_t id);\n-\n-static GC_bool parallel_initialized = FALSE;\n-\n-void GC_init_parallel();\n-\n-# if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n-\n-/* We don't really support thread-local allocation with DBG_HDRS_ALL */\n-\n-#ifdef USE_HPUX_TLS\n-  __thread\n-#endif\n-GC_key_t GC_thread_key;\n-\n-static GC_bool keys_initialized;\n-\n-/* Recover the contents of the freelist array fl into the global one gfl.*/\n-/* Note that the indexing scheme differs, in that gfl has finer size\t*/\n-/* resolution, even if not all entries are used.\t\t\t*/\n-/* We hold the allocator lock.\t\t\t\t\t\t*/\n-static void return_freelists(ptr_t *fl, ptr_t *gfl)\n-{\n-    int i;\n-    ptr_t q, *qptr;\n-    size_t nwords;\n-\n-    for (i = 1; i < NFREELISTS; ++i) {\n-\tnwords = i * (GRANULARITY/sizeof(word));\n-        qptr = fl + i;\t\n-\tq = *qptr;\n-\tif ((word)q >= HBLKSIZE) {\n-\t  if (gfl[nwords] == 0) {\n-\t    gfl[nwords] = q;\n-\t  } else {\n-\t    /* Concatenate: */\n-\t    for (; (word)q >= HBLKSIZE; qptr = &(obj_link(q)), q = *qptr);\n-\t    GC_ASSERT(0 == q);\n-\t    *qptr = gfl[nwords];\n-\t    gfl[nwords] = fl[i];\n-\t  }\n-\t}\n-\t/* Clear fl[i], since the thread structure may hang around.\t*/\n-\t/* Do it in a way that is likely to trap if we access it.\t*/\n-\tfl[i] = (ptr_t)HBLKSIZE;\n-    }\n-}\n-\n-/* We statically allocate a single \"size 0\" object. It is linked to\t*/\n-/* itself, and is thus repeatedly reused for all size 0 allocation\t*/\n-/* requests.  (Size 0 gcj allocation requests are incorrect, and\t*/\n-/* we arrange for those to fault asap.)\t\t\t\t\t*/\n-static ptr_t size_zero_object = (ptr_t)(&size_zero_object);\n-\n-/* Each thread structure must be initialized.\t*/\n-/* This call must be made from the new thread.\t*/\n-/* Caller holds allocation lock.\t\t*/\n-void GC_init_thread_local(GC_thread p)\n-{\n-    int i;\n-\n-    if (!keys_initialized) {\n-\tif (0 != GC_key_create(&GC_thread_key, 0)) {\n-\t    ABORT(\"Failed to create key for local allocator\");\n-        }\n-\tkeys_initialized = TRUE;\n-    }\n-    if (0 != GC_setspecific(GC_thread_key, p)) {\n-\tABORT(\"Failed to set thread specific allocation pointers\");\n-    }\n-    for (i = 1; i < NFREELISTS; ++i) {\n-\tp -> ptrfree_freelists[i] = (ptr_t)1;\n-\tp -> normal_freelists[i] = (ptr_t)1;\n-#\tifdef GC_GCJ_SUPPORT\n-\t  p -> gcj_freelists[i] = (ptr_t)1;\n-#\tendif\n-    }   \n-    /* Set up the size 0 free lists.\t*/\n-    p -> ptrfree_freelists[0] = (ptr_t)(&size_zero_object);\n-    p -> normal_freelists[0] = (ptr_t)(&size_zero_object);\n-#   ifdef GC_GCJ_SUPPORT\n-        p -> gcj_freelists[0] = (ptr_t)(-1);\n-#   endif\n-}\n-\n-#ifdef GC_GCJ_SUPPORT\n-  extern ptr_t * GC_gcjobjfreelist;\n-#endif\n-\n-/* We hold the allocator lock.\t*/\n-void GC_destroy_thread_local(GC_thread p)\n-{\n-    /* We currently only do this from the thread itself.\t*/\n-\tGC_ASSERT(GC_getspecific(GC_thread_key) == (void *)p);\n-    return_freelists(p -> ptrfree_freelists, GC_aobjfreelist);\n-    return_freelists(p -> normal_freelists, GC_objfreelist);\n-#   ifdef GC_GCJ_SUPPORT\n-   \treturn_freelists(p -> gcj_freelists, GC_gcjobjfreelist);\n-#   endif\n-}\n-\n-extern GC_PTR GC_generic_malloc_many();\n-\n-GC_PTR GC_local_malloc(size_t bytes)\n-{\n-    if (EXPECT(!SMALL_ENOUGH(bytes),0)) {\n-        return(GC_malloc(bytes));\n-    } else {\n-\tint index = INDEX_FROM_BYTES(bytes);\n-\tptr_t * my_fl;\n-\tptr_t my_entry;\n-\tGC_key_t k = GC_thread_key;\n-\tvoid * tsd;\n-\n-#\tif defined(REDIRECT_MALLOC) && !defined(USE_PTHREAD_SPECIFIC) \\\n-\t   || !defined(__GNUC__)\n-\t    if (EXPECT(0 == k, 0)) {\n-\t\t/* This can happen if we get called when the world is\t*/\n-\t\t/* being initialized.  Whether we can actually complete\t*/\n-\t\t/* the initialization then is unclear.\t\t\t*/\n-\t\tGC_init_parallel();\n-\t\tk = GC_thread_key;\n-\t    }\n-#\tendif\n-\ttsd = GC_getspecific(GC_thread_key);\n-#\tifdef GC_ASSERTIONS\n-\t  LOCK();\n-\t  GC_ASSERT(tsd == (void *)GC_lookup_thread(pthread_self()));\n-\t  UNLOCK();\n-#\tendif\n-\tmy_fl = ((GC_thread)tsd) -> normal_freelists + index;\n-\tmy_entry = *my_fl;\n-\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n-\t    ptr_t next = obj_link(my_entry);\n-\t    GC_PTR result = (GC_PTR)my_entry;\n-\t    *my_fl = next;\n-\t    obj_link(my_entry) = 0;\n-\t    PREFETCH_FOR_WRITE(next);\n-\t    return result;\n-\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n-\t    *my_fl = my_entry + index + 1;\n-            return GC_malloc(bytes);\n-\t} else {\n-\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), NORMAL, my_fl);\n-\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n-\t    return GC_local_malloc(bytes);\n-\t}\n-    }\n-}\n-\n-GC_PTR GC_local_malloc_atomic(size_t bytes)\n-{\n-    if (EXPECT(!SMALL_ENOUGH(bytes), 0)) {\n-        return(GC_malloc_atomic(bytes));\n-    } else {\n-\tint index = INDEX_FROM_BYTES(bytes);\n-\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n-\t\t        -> ptrfree_freelists + index;\n-\tptr_t my_entry = *my_fl;\n-\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n-\t    GC_PTR result = (GC_PTR)my_entry;\n-\t    *my_fl = obj_link(my_entry);\n-\t    return result;\n-\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n-\t    *my_fl = my_entry + index + 1;\n-            return GC_malloc_atomic(bytes);\n-\t} else {\n-\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), PTRFREE, my_fl);\n-\t    /* *my_fl is updated while the collector is excluded;\t*/\n-\t    /* the free list is always visible to the collector as \t*/\n-\t    /* such.\t\t\t\t\t\t\t*/\n-\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n-\t    return GC_local_malloc_atomic(bytes);\n-\t}\n-    }\n-}\n-\n-#ifdef GC_GCJ_SUPPORT\n-\n-#include \"include/gc_gcj.h\"\n-\n-#ifdef GC_ASSERTIONS\n-  extern GC_bool GC_gcj_malloc_initialized;\n-#endif\n-\n-extern int GC_gcj_kind;\n-\n-GC_PTR GC_local_gcj_malloc(size_t bytes,\n-\t\t\t   void * ptr_to_struct_containing_descr)\n-{\n-    GC_ASSERT(GC_gcj_malloc_initialized);\n-    if (EXPECT(!SMALL_ENOUGH(bytes), 0)) {\n-        return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n-    } else {\n-\tint index = INDEX_FROM_BYTES(bytes);\n-\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n-\t                -> gcj_freelists + index;\n-\tptr_t my_entry = *my_fl;\n-\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n-\t    GC_PTR result = (GC_PTR)my_entry;\n-\t    GC_ASSERT(!GC_incremental);\n-\t    /* We assert that any concurrent marker will stop us.\t*/\n-\t    /* Thus it is impossible for a mark procedure to see the \t*/\n-\t    /* allocation of the next object, but to see this object \t*/\n-\t    /* still containing a free list pointer.  Otherwise the \t*/\n-\t    /* marker might find a random \"mark descriptor\".\t\t*/\n-\t    *(volatile ptr_t *)my_fl = obj_link(my_entry);\n-\t    /* We must update the freelist before we store the pointer.\t*/\n-\t    /* Otherwise a GC at this point would see a corrupted\t*/\n-\t    /* free list.\t\t\t\t\t\t*/\n-\t    /* A memory barrier is probably never needed, since the \t*/\n-\t    /* action of stopping this thread will cause prior writes\t*/\n-\t    /* to complete.\t\t\t\t\t\t*/\n-\t    GC_ASSERT(((void * volatile *)result)[1] == 0); \n-\t    *(void * volatile *)result = ptr_to_struct_containing_descr; \n-\t    return result;\n-\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n-\t    *my_fl = my_entry + index + 1;\n-            return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n-\t} else {\n-\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), GC_gcj_kind, my_fl);\n-\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n-\t    return GC_local_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n-\t}\n-    }\n-}\n-\n-#endif /* GC_GCJ_SUPPORT */\n-\n-# else  /* !THREAD_LOCAL_ALLOC  && !DBG_HDRS_ALL */\n-\n-#   define GC_destroy_thread_local(t)\n-\n-# endif /* !THREAD_LOCAL_ALLOC */\n-\n-/*\n- * We use signals to stop threads during GC.\n- * \n- * Suspended threads wait in signal handler for SIG_THR_RESTART.\n- * That's more portable than semaphores or condition variables.\n- * (We do use sem_post from a signal handler, but that should be portable.)\n- *\n- * The thread suspension signal SIG_SUSPEND is now defined in gc_priv.h.\n- * Note that we can't just stop a thread; we need it to save its stack\n- * pointer(s) and acknowledge.\n- */\n-\n-#ifndef SIG_THR_RESTART\n-#  if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n-#   define SIG_THR_RESTART _SIGRTMIN + 5\n-#  else\n-#   define SIG_THR_RESTART SIGXCPU\n-#  endif\n-#endif\n-\n-sem_t GC_suspend_ack_sem;\n-\n-#if 0\n-/*\n-To make sure that we're using LinuxThreads and not some other thread\n-package, we generate a dummy reference to `pthread_kill_other_threads_np'\n-(was `__pthread_initial_thread_bos' but that disappeared),\n-which is a symbol defined in LinuxThreads, but (hopefully) not in other\n-thread packages.\n-\n-We no longer do this, since this code is now portable enough that it might\n-actually work for something else.\n-*/\n-void (*dummy_var_to_force_linux_threads)() = pthread_kill_other_threads_np;\n-#endif /* 0 */\n-\n-#if defined(SPARC) || defined(IA64)\n-  extern word GC_save_regs_in_stack();\n-#endif\n-\n-long GC_nprocs = 1;\t/* Number of processors.  We may not have\t*/\n-\t\t\t/* access to all of them, but this is as good\t*/\n-\t\t\t/* a guess as any ...\t\t\t\t*/\n-\n-#ifdef PARALLEL_MARK\n-\n-# ifndef MAX_MARKERS\n-#   define MAX_MARKERS 16\n-# endif\n-\n-static ptr_t marker_sp[MAX_MARKERS] = {0};\n-\n-void * GC_mark_thread(void * id)\n-{\n-  word my_mark_no = 0;\n-\n-  marker_sp[(word)id] = GC_approx_sp();\n-  for (;; ++my_mark_no) {\n-    /* GC_mark_no is passed only to allow GC_help_marker to terminate\t*/\n-    /* promptly.  This is important if it were called from the signal\t*/\n-    /* handler or from the GC lock acquisition code.  Under Linux, it's\t*/\n-    /* not safe to call it from a signal handler, since it uses mutexes\t*/\n-    /* and condition variables.  Since it is called only here, the \t*/\n-    /* argument is unnecessary.\t\t\t\t\t\t*/\n-    if (my_mark_no < GC_mark_no || my_mark_no > GC_mark_no + 2) {\n-\t/* resynchronize if we get far off, e.g. because GC_mark_no\t*/\n-\t/* wrapped.\t\t\t\t\t\t\t*/\n-\tmy_mark_no = GC_mark_no;\n-    }\n-#   ifdef DEBUG_THREADS\n-\tGC_printf1(\"Starting mark helper for mark number %ld\\n\", my_mark_no);\n-#   endif\n-    GC_help_marker(my_mark_no);\n-  }\n-}\n-\n-extern long GC_markers;\t\t/* Number of mark threads we would\t*/\n-\t\t\t\t/* like to have.  Includes the \t\t*/\n-\t\t\t\t/* initiating thread.\t\t\t*/\n-\n-pthread_t GC_mark_threads[MAX_MARKERS];\n-\n-#define PTHREAD_CREATE REAL_FUNC(pthread_create)\n-\n-static void start_mark_threads()\n-{\n-    unsigned i;\n-    pthread_attr_t attr;\n-\n-    if (GC_markers > MAX_MARKERS) {\n-\tWARN(\"Limiting number of mark threads\\n\", 0);\n-\tGC_markers = MAX_MARKERS;\n-    }\n-    if (0 != pthread_attr_init(&attr)) ABORT(\"pthread_attr_init failed\");\n-\t\n-    if (0 != pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED))\n-\tABORT(\"pthread_attr_setdetachstate failed\");\n-\n-#   ifdef HPUX\n-      /* Default stack size is usually too small: fix it. */\n-      /* Otherwise marker threads or GC may run out of\t  */\n-      /* space.\t\t\t\t\t\t  */\n-#     define MIN_STACK_SIZE (8*HBLKSIZE*sizeof(word))\n-      {\n-\tsize_t old_size;\n-\tint code;\n-\n-        if (pthread_attr_getstacksize(&attr, &old_size) != 0)\n-\t  ABORT(\"pthread_attr_getstacksize failed\\n\");\n-\tif (old_size < MIN_STACK_SIZE) {\n-\t  if (pthread_attr_setstacksize(&attr, MIN_STACK_SIZE) != 0)\n-\t\t  ABORT(\"pthread_attr_setstacksize failed\\n\");\n-\t}\n-      }\n-#   endif /* HPUX */\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-\tGC_printf1(\"Starting %ld marker threads\\n\", GC_markers - 1);\n-      }\n-#   endif\n-    for (i = 0; i < GC_markers - 1; ++i) {\n-      if (0 != PTHREAD_CREATE(GC_mark_threads + i, &attr,\n-\t\t\t      GC_mark_thread, (void *)(word)i)) {\n-\tWARN(\"Marker thread creation failed, errno = %ld.\\n\", errno);\n-      }\n-    }\n-}\n-\n-#else  /* !PARALLEL_MARK */\n-\n-static __inline__ void start_mark_threads()\n-{\n-}\n-\n-#endif /* !PARALLEL_MARK */\n-\n-void GC_suspend_handler(int sig)\n-{\n-    int dummy;\n-    pthread_t my_thread = pthread_self();\n-    GC_thread me;\n-    sigset_t all_sigs;\n-    sigset_t old_sigs;\n-    int i;\n-    sigset_t mask;\n-#   ifdef PARALLEL_MARK\n-\tword my_mark_no = GC_mark_no;\n-\t/* Marker can't proceed until we acknowledge.  Thus this is\t*/\n-\t/* guaranteed to be the mark_no correspending to our \t\t*/\n-\t/* suspension, i.e. the marker can't have incremented it yet.\t*/\n-#   endif\n-\n-    if (sig != SIG_SUSPEND) ABORT(\"Bad signal in suspend_handler\");\n-\n-#if DEBUG_THREADS\n-    GC_printf1(\"Suspending 0x%x\\n\", my_thread);\n-#endif\n-\n-    me = GC_lookup_thread(my_thread);\n-    /* The lookup here is safe, since I'm doing this on behalf  */\n-    /* of a thread which holds the allocation lock in order\t*/\n-    /* to stop the world.  Thus concurrent modification of the\t*/\n-    /* data structure is impossible.\t\t\t\t*/\n-#   ifdef SPARC\n-\tme -> stack_ptr = (ptr_t)GC_save_regs_in_stack();\n-#   else\n-\tme -> stack_ptr = (ptr_t)(&dummy);\n-#   endif\n-#   ifdef IA64\n-\tme -> backing_store_ptr = (ptr_t)GC_save_regs_in_stack();\n-#   endif\n-\n-    /* Tell the thread that wants to stop the world that this   */\n-    /* thread has been stopped.  Note that sem_post() is  \t*/\n-    /* the only async-signal-safe primitive in LinuxThreads.    */\n-    sem_post(&GC_suspend_ack_sem);\n-\n-    /* Wait until that thread tells us to restart by sending    */\n-    /* this thread a SIG_THR_RESTART signal.\t\t\t*/\n-    /* SIG_THR_RESTART should be masked at this point.  Thus there\t*/\n-    /* is no race.\t\t\t\t\t\t*/\n-    if (sigfillset(&mask) != 0) ABORT(\"sigfillset() failed\");\n-    if (sigdelset(&mask, SIG_THR_RESTART) != 0) ABORT(\"sigdelset() failed\");\n-#   ifdef NO_SIGNALS\n-      if (sigdelset(&mask, SIGINT) != 0) ABORT(\"sigdelset() failed\");\n-      if (sigdelset(&mask, SIGQUIT) != 0) ABORT(\"sigdelset() failed\");\n-      if (sigdelset(&mask, SIGTERM) != 0) ABORT(\"sigdelset() failed\");\n-      if (sigdelset(&mask, SIGABRT) != 0) ABORT(\"sigdelset() failed\");\n-#   endif\n-    do {\n-\t    me->signal = 0;\n-\t    sigsuspend(&mask);             /* Wait for signal */\n-    } while (me->signal != SIG_THR_RESTART);\n-\n-#if DEBUG_THREADS\n-    GC_printf1(\"Continuing 0x%x\\n\", my_thread);\n-#endif\n-}\n-\n-void GC_restart_handler(int sig)\n-{\n-    GC_thread me;\n-\n-    if (sig != SIG_THR_RESTART) ABORT(\"Bad signal in suspend_handler\");\n-\n-    /* Let the GC_suspend_handler() know that we got a SIG_THR_RESTART. */\n-    /* The lookup here is safe, since I'm doing this on behalf  */\n-    /* of a thread which holds the allocation lock in order\t*/\n-    /* to stop the world.  Thus concurrent modification of the\t*/\n-    /* data structure is impossible.\t\t\t\t*/\n-    me = GC_lookup_thread(pthread_self());\n-    me->signal = SIG_THR_RESTART;\n-\n-    /*\n-    ** Note: even if we didn't do anything useful here,\n-    ** it would still be necessary to have a signal handler,\n-    ** rather than ignoring the signals, otherwise\n-    ** the signals will not be delivered at all, and\n-    ** will thus not interrupt the sigsuspend() above.\n-    */\n-\n-#if DEBUG_THREADS\n-    GC_printf1(\"In GC_restart_handler for 0x%x\\n\", pthread_self());\n-#endif\n-}\n-\n-/* Defining INSTALL_LOOPING_SEGV_HANDLER causes SIGSEGV and SIGBUS to \t*/\n-/* result in an infinite loop in a signal handler.  This can be very\t*/\n-/* useful for debugging, since (as of RH7) gdb still seems to have\t*/\n-/* serious problems with threads.\t\t\t\t\t*/\n-#ifdef INSTALL_LOOPING_SEGV_HANDLER\n-void GC_looping_handler(int sig)\n-{\n-    GC_printf3(\"Signal %ld in thread %lx, pid %ld\\n\",\n-\t       sig, pthread_self(), getpid());\n-    for (;;);\n-}\n-#endif\n-\n-GC_bool GC_thr_initialized = FALSE;\n-\n-# define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n-volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n-\n-void GC_push_thread_structures GC_PROTO((void))\n-{\n-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n-}\n-\n-#ifdef THREAD_LOCAL_ALLOC\n-/* We must explicitly mark ptrfree and gcj free lists, since the free \t*/\n-/* list links wouldn't otherwise be found.  We also set them in the \t*/\n-/* normal free lists, since that involves touching less memory than if\t*/\n-/* we scanned them normally.\t\t\t\t\t\t*/\n-void GC_mark_thread_local_free_lists(void)\n-{\n-    int i, j;\n-    GC_thread p;\n-    ptr_t q;\n-    \n-    for (i = 0; i < THREAD_TABLE_SZ; ++i) {\n-      for (p = GC_threads[i]; 0 != p; p = p -> next) {\n-\tfor (j = 1; j < NFREELISTS; ++j) {\n-\t  q = p -> ptrfree_freelists[j];\n-\t  if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n-\t  q = p -> normal_freelists[j];\n-\t  if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n-#\t  ifdef GC_GCJ_SUPPORT\n-\t    q = p -> gcj_freelists[j];\n-\t    if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n-#\t  endif /* GC_GCJ_SUPPORT */\n-\t}\n-      }\n-    }\n-}\n-#endif /* THREAD_LOCAL_ALLOC */\n-\n-/* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n-/* Caller holds allocation lock.\t\t\t\t\t*/\n-GC_thread GC_new_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    GC_thread result;\n-    static struct GC_Thread_Rep first_thread;\n-    static GC_bool first_thread_used = FALSE;\n-    \n-    if (!first_thread_used) {\n-    \tresult = &first_thread;\n-    \tfirst_thread_used = TRUE;\n-    } else {\n-        result = (struct GC_Thread_Rep *)\n-        \t GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);\n-    }\n-    if (result == 0) return(0);\n-    result -> id = id;\n-    result -> next = GC_threads[hv];\n-    GC_threads[hv] = result;\n-    GC_ASSERT(result -> flags == 0 && result -> thread_blocked == 0);\n-    return(result);\n-}\n-\n-/* Delete a thread from GC_threads.  We assume it is there.\t*/\n-/* (The code intentionally traps if it wasn't.)\t\t\t*/\n-/* Caller holds allocation lock.\t\t\t\t*/\n-void GC_delete_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    register GC_thread prev = 0;\n-    \n-    while (!pthread_equal(p -> id, id)) {\n-        prev = p;\n-        p = p -> next;\n-    }\n-    if (prev == 0) {\n-        GC_threads[hv] = p -> next;\n-    } else {\n-        prev -> next = p -> next;\n-    }\n-    GC_INTERNAL_FREE(p);\n-}\n-\n-/* If a thread has been joined, but we have not yet\t\t*/\n-/* been notified, then there may be more than one thread \t*/\n-/* in the table with the same pthread id.\t\t\t*/\n-/* This is OK, but we need a way to delete a specific one.\t*/\n-void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    register GC_thread prev = 0;\n-\n-    while (p != gc_id) {\n-        prev = p;\n-        p = p -> next;\n-    }\n-    if (prev == 0) {\n-        GC_threads[hv] = p -> next;\n-    } else {\n-        prev -> next = p -> next;\n-    }\n-    GC_INTERNAL_FREE(p);\n-}\n-\n-/* Return a GC_thread corresponding to a given thread_t.\t*/\n-/* Returns 0 if it's not there.\t\t\t\t\t*/\n-/* Caller holds  allocation lock or otherwise inhibits \t\t*/\n-/* updates.\t\t\t\t\t\t\t*/\n-/* If there is more than one thread with the given id we \t*/\n-/* return the most recent one.\t\t\t\t\t*/\n-GC_thread GC_lookup_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    \n-    while (p != 0 && !pthread_equal(p -> id, id)) p = p -> next;\n-    return(p);\n-}\n-\n-/* There seems to be a very rare thread stopping problem.  To help us  */\n-/* debug that, we save the ids of the stopping thread. */\n-pthread_t GC_stopping_thread;\n-int GC_stopping_pid;\n-\n-/* Caller holds allocation lock.\t*/\n-void GC_stop_world()\n-{\n-    pthread_t my_thread = pthread_self();\n-    register int i;\n-    register GC_thread p;\n-    register int n_live_threads = 0;\n-    register int result;\n-\n-    GC_stopping_thread = my_thread;    /* debugging only.      */\n-    GC_stopping_pid = getpid();                /* debugging only.      */\n-    /* Make sure all free list construction has stopped before we start. */\n-    /* No new construction can start, since free list construction is\t*/\n-    /* required to acquire and release the GC lock before it starts,\t*/\n-    /* and we have the lock.\t\t\t\t\t\t*/\n-#   ifdef PARALLEL_MARK\n-      GC_acquire_mark_lock();\n-      GC_ASSERT(GC_fl_builder_count == 0);\n-      /* We should have previously waited for it to become zero. */\n-#   endif /* PARALLEL_MARK */\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> id != my_thread) {\n-            if (p -> flags & FINISHED) continue;\n-\t    if (p -> thread_blocked) /* Will wait */ continue;\n-            n_live_threads++;\n-\t    #if DEBUG_THREADS\n-\t      GC_printf1(\"Sending suspend signal to 0x%x\\n\", p -> id);\n-\t    #endif\n-            result = pthread_kill(p -> id, SIG_SUSPEND);\n-\t    switch(result) {\n-                case ESRCH:\n-                    /* Not really there anymore.  Possible? */\n-                    n_live_threads--;\n-                    break;\n-                case 0:\n-                    break;\n-                default:\n-                    ABORT(\"pthread_kill failed\");\n-            }\n-        }\n-      }\n-    }\n-    for (i = 0; i < n_live_threads; i++) {\n-    \tif (0 != sem_wait(&GC_suspend_ack_sem))\n-\t    ABORT(\"sem_wait in handler failed\");\n-    }\n-#   ifdef PARALLEL_MARK\n-      GC_release_mark_lock();\n-#   endif\n-    #if DEBUG_THREADS\n-      GC_printf1(\"World stopped 0x%x\\n\", pthread_self());\n-    #endif\n-    GC_stopping_thread = 0;  /* debugging only */\n-}\n-\n-/* Caller holds allocation lock, and has held it continuously since\t*/\n-/* the world stopped.\t\t\t\t\t\t\t*/\n-void GC_start_world()\n-{\n-    pthread_t my_thread = pthread_self();\n-    register int i;\n-    register GC_thread p;\n-    register int n_live_threads = 0;\n-    register int result;\n-    \n-#   if DEBUG_THREADS\n-      GC_printf0(\"World starting\\n\");\n-#   endif\n-\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> id != my_thread) {\n-            if (p -> flags & FINISHED) continue;\n-\t    if (p -> thread_blocked) continue;\n-            n_live_threads++;\n-\t    #if DEBUG_THREADS\n-\t      GC_printf1(\"Sending restart signal to 0x%x\\n\", p -> id);\n-\t    #endif\n-            result = pthread_kill(p -> id, SIG_THR_RESTART);\n-\t    switch(result) {\n-                case ESRCH:\n-                    /* Not really there anymore.  Possible? */\n-                    n_live_threads--;\n-                    break;\n-                case 0:\n-                    break;\n-                default:\n-                    ABORT(\"pthread_kill failed\");\n-            }\n-        }\n-      }\n-    }\n-    #if DEBUG_THREADS\n-      GC_printf0(\"World started\\n\");\n-    #endif\n-    GC_stopping_thread = 0;  /* debugging only */\n-}\n-\n-# ifdef IA64\n-#   define IF_IA64(x) x\n-# else\n-#   define IF_IA64(x)\n-# endif\n-/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n-/* world is stopped.  Should not fail if it isn't.\t\t\t*/\n-void GC_push_all_stacks()\n-{\n-    int i;\n-    GC_thread p;\n-    ptr_t sp = GC_approx_sp();\n-    ptr_t lo, hi;\n-    /* On IA64, we also need to scan the register backing store. */\n-    IF_IA64(ptr_t bs_lo; ptr_t bs_hi;)\n-    pthread_t me = pthread_self();\n-    \n-    if (!GC_thr_initialized) GC_thr_init();\n-    #if DEBUG_THREADS\n-        GC_printf1(\"Pushing stacks from thread 0x%lx\\n\", (unsigned long) me);\n-    #endif\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> flags & FINISHED) continue;\n-        if (pthread_equal(p -> id, me)) {\n-#  \t    ifdef SPARC\n-\t        lo = (ptr_t)GC_save_regs_in_stack();\n-#  \t    else\n- \t        lo = GC_approx_sp();\n-#           endif\n-\t    IF_IA64(bs_hi = (ptr_t)GC_save_regs_in_stack();)\n-\t} else {\n-\t    lo = p -> stack_ptr;\n-\t    IF_IA64(bs_hi = p -> backing_store_ptr;)\n-\t}\n-        if ((p -> flags & MAIN_THREAD) == 0) {\n-\t    hi = p -> stack_end;\n-\t    IF_IA64(bs_lo = p -> backing_store_end);\n-        } else {\n-            /* The original stack. */\n-            hi = GC_stackbottom;\n-\t    IF_IA64(bs_lo = BACKING_STORE_BASE;)\n-        }\n-        #if DEBUG_THREADS\n-            GC_printf3(\"Stack for thread 0x%lx = [%lx,%lx)\\n\",\n-    \t        (unsigned long) p -> id,\n-\t\t(unsigned long) lo, (unsigned long) hi);\n-        #endif\n-\tif (0 == lo) ABORT(\"GC_push_all_stacks: sp not set!\\n\");\n-#       ifdef STACK_GROWS_UP\n-\t  /* We got them backwards! */\n-          GC_push_all_stack(hi, lo);\n-#       else\n-          GC_push_all_stack(lo, hi);\n-#\tendif\n-#\tifdef IA64\n-          if (pthread_equal(p -> id, me)) {\n-\t    GC_push_all_eager(bs_lo, bs_hi);\n-\t  } else {\n-\t    GC_push_all_stack(bs_lo, bs_hi);\n-\t  }\n-#\tendif\n-      }\n-    }\n-}\n-\n-#ifdef USE_PROC_FOR_LIBRARIES\n-int GC_segment_is_thread_stack(ptr_t lo, ptr_t hi)\n-{\n-    int i;\n-    GC_thread p;\n-    \n-#   ifdef PARALLEL_MARK\n-      for (i = 0; i < GC_markers; ++i) {\n-\tif (marker_sp[i] > lo & marker_sp[i] < hi) return 1;\n-      }\n-#   endif\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-\tif (0 != p -> stack_end) {\n-#\t  ifdef STACK_GROWS_UP\n-            if (p -> stack_end >= lo && p -> stack_end < hi) return 1;\n-#\t  else /* STACK_GROWS_DOWN */\n-            if (p -> stack_end > lo && p -> stack_end <= hi) return 1;\n-#\t  endif\n-\t}\n-      }\n-    }\n-    return 0;\n-}\n-#endif /* USE_PROC_FOR_LIBRARIES */\n-\n-#ifdef GC_LINUX_THREADS\n-/* Return the number of processors, or i<= 0 if it can't be determined.\t*/\n-int GC_get_nprocs()\n-{\n-    /* Should be \"return sysconf(_SC_NPROCESSORS_ONLN);\" but that\t*/\n-    /* appears to be buggy in many cases.\t\t\t\t*/\n-    /* We look for lines \"cpu<n>\" in /proc/stat.\t\t\t*/\n-#   define STAT_BUF_SIZE 4096\n-#   if defined(GC_USE_LD_WRAP)\n-#\tdefine STAT_READ __real_read\n-#   else\n-#\tdefine STAT_READ read\n-#   endif    \n-    char stat_buf[STAT_BUF_SIZE];\n-    int f;\n-    char c;\n-    word result = 1;\n-\t/* Some old kernels only have a single \"cpu nnnn ...\"\t*/\n-\t/* entry in /proc/stat.  We identify those as \t\t*/\n-\t/* uniprocessors.\t\t\t\t\t*/\n-    size_t i, len = 0;\n-\n-    f = open(\"/proc/stat\", O_RDONLY);\n-    if (f < 0 || (len = STAT_READ(f, stat_buf, STAT_BUF_SIZE)) < 100) {\n-\tWARN(\"Couldn't read /proc/stat\\n\", 0);\n-\treturn -1;\n-    }\n-    close(f);\n-    for (i = 0; i < len - 100; ++i) {\n-        if (stat_buf[i] == '\\n' && stat_buf[i+1] == 'c'\n-\t    && stat_buf[i+2] == 'p' && stat_buf[i+3] == 'u') {\n-\t    int cpu_no = atoi(stat_buf + i + 4);\n-\t    if (cpu_no >= result) result = cpu_no + 1;\n-\t}\n-    }\n-    return result;\n-}\n-#endif /* GC_LINUX_THREADS */\n-\n-/* We hold the allocation lock.\t*/\n-void GC_thr_init()\n-{\n-    int dummy;\n-    GC_thread t;\n-    struct sigaction act;\n-\n-    if (GC_thr_initialized) return;\n-    GC_thr_initialized = TRUE;\n-\n-    if (sem_init(&GC_suspend_ack_sem, 0, 0) != 0)\n-    \tABORT(\"sem_init failed\");\n-\n-    act.sa_flags = SA_RESTART;\n-    if (sigfillset(&act.sa_mask) != 0) {\n-    \tABORT(\"sigfillset() failed\");\n-    }\n-#   ifdef NO_SIGNALS\n-      if (sigdelset(&act.sa_mask, SIGINT) != 0\n-\t  || sigdelset(&act.sa_mask, SIGQUIT != 0)\n-\t  || sigdelset(&act.sa_mask, SIGABRT != 0)\n-\t  || sigdelset(&act.sa_mask, SIGTERM != 0)) {\n-        ABORT(\"sigdelset() failed\");\n-      }\n-#   endif\n-\n-    /* SIG_THR_RESTART is unmasked by the handler when necessary. \t*/\n-    act.sa_handler = GC_suspend_handler;\n-    if (sigaction(SIG_SUSPEND, &act, NULL) != 0) {\n-    \tABORT(\"Cannot set SIG_SUSPEND handler\");\n-    }\n-\n-    act.sa_handler = GC_restart_handler;\n-    if (sigaction(SIG_THR_RESTART, &act, NULL) != 0) {\n-    \tABORT(\"Cannot set SIG_THR_RESTART handler\");\n-    }\n-#   ifdef INSTALL_LOOPING_SEGV_HANDLER\n-        act.sa_handler = GC_looping_handler;\n-\tif (sigaction(SIGSEGV, &act, NULL) != 0\n-\t    || sigaction(SIGBUS, &act, NULL) != 0) {\n-\t    ABORT(\"Cannot set SIGSEGV or SIGBUS looping handler\");\n-\t}\n-#   endif  /* INSTALL_LOOPING_SEGV_HANDLER */\n-\n-    /* Add the initial thread, so we can stop it.\t*/\n-      t = GC_new_thread(pthread_self());\n-      t -> stack_ptr = (ptr_t)(&dummy);\n-      t -> flags = DETACHED | MAIN_THREAD;\n-\n-    /* Set GC_nprocs.  */\n-      {\n-\tchar * nprocs_string = GETENV(\"GC_NPROCS\");\n-\tGC_nprocs = -1;\n-\tif (nprocs_string != NULL) GC_nprocs = atoi(nprocs_string);\n-      }\n-      if (GC_nprocs <= 0) {\n-#       if defined(GC_HPUX_THREADS)\n-\t  GC_nprocs = pthread_num_processors_np();\n-#       endif\n-#       if defined(GC_OSF1_THREADS) || defined(GC_FREEBSD_THREADS)\n-          GC_nprocs = 1;\n-#       endif\n-#\tif defined(GC_LINUX_THREADS)\n-          GC_nprocs = GC_get_nprocs();\n-#\tendif\n-      }\n-      if (GC_nprocs <= 0) {\n-\tWARN(\"GC_get_nprocs() returned %ld\\n\", GC_nprocs);\n-\tGC_nprocs = 2;\n-#\tifdef PARALLEL_MARK\n-\t  GC_markers = 1;\n-#\tendif\n-      } else {\n-#\tifdef PARALLEL_MARK\n-\t  GC_markers = GC_nprocs;\n-#\tendif\n-      }\n-#   ifdef PARALLEL_MARK\n-#     ifdef CONDPRINT\n-        if (GC_print_stats) {\n-          GC_printf2(\"Number of processors = %ld, \"\n-\t\t \"number of marker threads = %ld\\n\", GC_nprocs, GC_markers);\n-\t}\n-#     endif\n-      if (GC_markers == 1) {\n-\tGC_parallel = FALSE;\n-#\tifdef CONDPRINT\n-\t  if (GC_print_stats) {\n-\t    GC_printf0(\"Single marker thread, turning off parallel marking\\n\");\n-\t  }\n-#\tendif\n-      } else {\n-\tGC_parallel = TRUE;\n-      }\n-#   endif\n-}\n-\n-\n-/* Perform all initializations, including those that\t*/\n-/* may require allocation.\t\t\t\t*/\n-/* Called as constructor without allocation lock.\t*/\n-/* Must be called before a second thread is created.\t*/\n-/* Called without allocation lock.\t\t\t*/\n-void GC_init_parallel()\n-{\n-    if (parallel_initialized) return;\n-    parallel_initialized = TRUE;\n-    \t/* GC_init() calls us back, so set flag first.\t*/\n-    if (!GC_is_initialized) GC_init();\n-    /* If we are using a parallel marker, start the helper threads.  */\n-#     ifdef PARALLEL_MARK\n-        if (GC_parallel) start_mark_threads();\n-#     endif\n-    /* Initialize thread local free lists if used.\t*/\n-#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n-      LOCK();\n-      GC_init_thread_local(GC_lookup_thread(pthread_self()));\n-      UNLOCK();\n-#   endif\n-}\n-\n-\n-int WRAP_FUNC(pthread_sigmask)(int how, const sigset_t *set, sigset_t *oset)\n-{\n-    sigset_t fudged_set;\n-    \n-    if (set != NULL && (how == SIG_BLOCK || how == SIG_SETMASK)) {\n-        fudged_set = *set;\n-        sigdelset(&fudged_set, SIG_SUSPEND);\n-        set = &fudged_set;\n-    }\n-    return(REAL_FUNC(pthread_sigmask)(how, set, oset));\n-}\n-\n-/* Wrappers for functions that are likely to block for an appreciable\t*/\n-/* length of time.  Must be called in pairs, if at all.\t\t\t*/\n-/* Nothing much beyond the system call itself should be executed\t*/\n-/* between these.\t\t\t\t\t\t\t*/\n-\n-void GC_start_blocking(void) {\n-#   define SP_SLOP 128\n-    GC_thread me;\n-    LOCK();\n-    me = GC_lookup_thread(pthread_self());\n-    GC_ASSERT(!(me -> thread_blocked));\n-#   ifdef SPARC\n-\tme -> stack_ptr = (ptr_t)GC_save_regs_in_stack();\n-#   else\n-\tme -> stack_ptr = (ptr_t)GC_approx_sp();\n-#   endif\n-#   ifdef IA64\n-\tme -> backing_store_ptr = (ptr_t)GC_save_regs_in_stack() + SP_SLOP;\n-#   endif\n-    /* Add some slop to the stack pointer, since the wrapped call may \t*/\n-    /* end up pushing more callee-save registers.\t\t\t*/\n-#   ifdef STACK_GROWS_UP\n-\tme -> stack_ptr += SP_SLOP;\n-#   else\n-\tme -> stack_ptr -= SP_SLOP;\n-#   endif\n-    me -> thread_blocked = TRUE;\n-    UNLOCK();\n-}\n-\n-GC_end_blocking(void) {\n-    GC_thread me;\n-    LOCK();   /* This will block if the world is stopped.\t*/\n-    me = GC_lookup_thread(pthread_self());\n-    GC_ASSERT(me -> thread_blocked);\n-    me -> thread_blocked = FALSE;\n-    UNLOCK();\n-}\n-    \n-/* A wrapper for the standard C sleep function\t*/\n-int WRAP_FUNC(sleep) (unsigned int seconds)\n-{\n-    int result;\n-\n-    GC_start_blocking();\n-    result = REAL_FUNC(sleep)(seconds);\n-    GC_end_blocking();\n-    return result;\n-}\n-\n-struct start_info {\n-    void *(*start_routine)(void *);\n-    void *arg;\n-    word flags;\n-    sem_t registered;   \t/* 1 ==> in our thread table, but \t*/\n-\t\t\t\t/* parent hasn't yet noticed.\t\t*/\n-};\n-\n-/* Called at thread exit.\t\t\t\t*/\n-/* Never called for main thread.  That's OK, since it\t*/\n-/* results in at most a tiny one-time leak.  And \t*/\n-/* linuxthreads doesn't reclaim the main threads \t*/\n-/* resources or id anyway.\t\t\t\t*/\n-void GC_thread_exit_proc(void *arg)\n-{\n-    GC_thread me;\n-\n-    LOCK();\n-    me = GC_lookup_thread(pthread_self());\n-    GC_destroy_thread_local(me);\n-    if (me -> flags & DETACHED) {\n-    \tGC_delete_thread(pthread_self());\n-    } else {\n-\tme -> flags |= FINISHED;\n-    }\n-#   if defined(THREAD_LOCAL_ALLOC) && !defined(USE_PTHREAD_SPECIFIC) \\\n-       && !defined(USE_HPUX_TLS) && !defined(DBG_HDRS_ALL)\n-      GC_remove_specific(GC_thread_key);\n-#   endif\n-    if (GC_incremental && GC_collection_in_progress()) {\n-\tint old_gc_no = GC_gc_no;\n-\n-\t/* Make sure that no part of our stack is still on the mark stack, */\n-\t/* since it's about to be unmapped.\t\t\t\t   */\n-\twhile (GC_incremental && GC_collection_in_progress()\n-\t       && old_gc_no == GC_gc_no) {\n-\t    ENTER_GC();\n-            GC_collect_a_little_inner(1);\n-\t    EXIT_GC();\n-\t    UNLOCK();\n-\t    sched_yield();\n-\t    LOCK();\n-\t}\n-    }\n-    UNLOCK();\n-}\n-\n-int WRAP_FUNC(pthread_join)(pthread_t thread, void **retval)\n-{\n-    int result;\n-    GC_thread thread_gc_id;\n-    \n-    LOCK();\n-    thread_gc_id = GC_lookup_thread(thread);\n-    /* This is guaranteed to be the intended one, since the thread id\t*/\n-    /* cant have been recycled by pthreads.\t\t\t\t*/\n-    UNLOCK();\n-    result = REAL_FUNC(pthread_join)(thread, retval);\n-# if defined (GC_FREEBSD_THREADS)\n-    /* On FreeBSD, the wrapped pthread_join() sometimes returns (what\n-       appears to be) a spurious EINTR which caused the test and real code\n-       to gratuitously fail.  Having looked at system pthread library source\n-       code, I see how this return code may be generated.  In one path of\n-       code, pthread_join() just returns the errno setting of the thread\n-       being joined.  This does not match the POSIX specification or the\n-       local man pages thus I have taken the liberty to catch this one\n-       spurious return value properly conditionalized on GC_FREEBSD_THREADS. */\n-    if (result == EINTR) result = 0;\n-# endif\n-    if (result == 0) {\n-        LOCK();\n-        /* Here the pthread thread id may have been recycled. */\n-        GC_delete_gc_thread(thread, thread_gc_id);\n-        UNLOCK();\n-    }\n-    return result;\n-}\n-\n-int\n-WRAP_FUNC(pthread_detach)(pthread_t thread)\n-{\n-    int result;\n-    GC_thread thread_gc_id;\n-    \n-    LOCK();\n-    thread_gc_id = GC_lookup_thread(thread);\n-    UNLOCK();\n-    result = REAL_FUNC(pthread_detach)(thread);\n-    if (result == 0) {\n-      LOCK();\n-      thread_gc_id -> flags |= DETACHED;\n-      /* Here the pthread thread id may have been recycled. */\n-      if (thread_gc_id -> flags & FINISHED) {\n-        GC_delete_gc_thread(thread, thread_gc_id);\n-      }\n-      UNLOCK();\n-    }\n-    return result;\n-}\n-\n-void * GC_start_routine(void * arg)\n-{\n-    int dummy;\n-    struct start_info * si = arg;\n-    void * result;\n-    GC_thread me;\n-    pthread_t my_pthread;\n-    void *(*start)(void *);\n-    void *start_arg;\n-\n-    my_pthread = pthread_self();\n-#   ifdef DEBUG_THREADS\n-        GC_printf1(\"Starting thread 0x%lx\\n\", my_pthread);\n-        GC_printf1(\"pid = %ld\\n\", (long) getpid());\n-        GC_printf1(\"sp = 0x%lx\\n\", (long) &arg);\n-#   endif\n-    LOCK();\n-    me = GC_new_thread(my_pthread);\n-    me -> flags = si -> flags;\n-    me -> stack_ptr = 0;\n-    /* me -> stack_end = GC_linux_stack_base(); -- currently (11/99)\t*/\n-    /* doesn't work because the stack base in /proc/self/stat is the \t*/\n-    /* one for the main thread.  There is a strong argument that that's\t*/\n-    /* a kernel bug, but a pervasive one.\t\t\t\t*/\n-#   ifdef STACK_GROWS_DOWN\n-      me -> stack_end = (ptr_t)(((word)(&dummy) + (GC_page_size - 1))\n-\t\t                & ~(GC_page_size - 1));\n-      me -> stack_ptr = me -> stack_end - 0x10;\n-\t/* Needs to be plausible, since an asynchronous stack mark\t*/\n-\t/* should not crash.\t\t\t\t\t\t*/\n-#   else\n-      me -> stack_end = (ptr_t)((word)(&dummy) & ~(GC_page_size - 1));\n-      me -> stack_ptr = me -> stack_end + 0x10;\n-#   endif\n-    /* This is dubious, since we may be more than a page into the stack, */\n-    /* and hence skip some of it, though it's not clear that matters.\t */\n-#   ifdef IA64\n-      me -> backing_store_end = (ptr_t)\n-\t\t\t(GC_save_regs_in_stack() & ~(GC_page_size - 1));\n-      /* This is also < 100% convincing.  We should also read this \t*/\n-      /* from /proc, but the hook to do so isn't there yet.\t\t*/\n-#   endif /* IA64 */\n-    UNLOCK();\n-    start = si -> start_routine;\n-#   ifdef DEBUG_THREADS\n-\tGC_printf1(\"start_routine = 0x%lx\\n\", start);\n-#   endif\n-    start_arg = si -> arg;\n-#   ifdef DEBUG_THREADS\n-        GC_printf1(\"sem_post from 0x%lx\\n\", my_pthread);\n-#   endif\n-    sem_post(&(si -> registered));\t/* Last action on si.\t*/\n-    \t\t\t\t\t/* OK to deallocate.\t*/\n-    pthread_cleanup_push(GC_thread_exit_proc, 0);\n-#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n- \tLOCK();\n-        GC_init_thread_local(me);\n-\tUNLOCK();\n-#   endif\n-    result = (*start)(start_arg);\n-#if DEBUG_THREADS\n-        GC_printf1(\"Finishing thread 0x%x\\n\", pthread_self());\n-#endif\n-    me -> status = result;\n-    me -> flags |= FINISHED;\n-    pthread_cleanup_pop(1);\n-    /* Cleanup acquires lock, ensuring that we can't exit\t\t*/\n-    /* while a collection that thinks we're alive is trying to stop     */\n-    /* us.\t\t\t\t\t\t\t\t*/\n-    return(result);\n-}\n-\n-int\n-WRAP_FUNC(pthread_create)(pthread_t *new_thread,\n-\t\t  const pthread_attr_t *attr,\n-                  void *(*start_routine)(void *), void *arg)\n-{\n-    int result;\n-    GC_thread t;\n-    pthread_t my_new_thread;\n-    int detachstate;\n-    word my_flags = 0;\n-    struct start_info * si; \n-\t/* This is otherwise saved only in an area mmapped by the thread */\n-\t/* library, which isn't visible to the collector.\t\t */\n- \n-    LOCK();\n-    si = (struct start_info *)GC_INTERNAL_MALLOC(sizeof(struct start_info), NORMAL);\n-    UNLOCK();\n-    if (!parallel_initialized) GC_init_parallel();\n-    if (0 == si) return(ENOMEM);\n-    sem_init(&(si -> registered), 0, 0);\n-    si -> start_routine = start_routine;\n-    si -> arg = arg;\n-    LOCK();\n-    if (!GC_thr_initialized) GC_thr_init();\n-    if (NULL == attr) {\n-\tdetachstate = PTHREAD_CREATE_JOINABLE;\n-    } else {\n-        pthread_attr_getdetachstate(attr, &detachstate);\n-    }\n-    if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n-    si -> flags = my_flags;\n-    UNLOCK();\n-#   ifdef DEBUG_THREADS\n-        GC_printf1(\"About to start new thread from thread 0x%X\\n\",\n-\t\t   pthread_self());\n-#   endif\n-    result = REAL_FUNC(pthread_create)(new_thread, attr, GC_start_routine, si);\n-#   ifdef DEBUG_THREADS\n-        GC_printf1(\"Started thread 0x%X\\n\", *new_thread);\n-#   endif\n-    /* Wait until child has been added to the thread table.\t\t*/\n-    /* This also ensures that we hold onto si until the child is done\t*/\n-    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n-    /* visible to the collector.\t\t\t\t\t*/\n-        while (0 != sem_wait(&(si -> registered))) {\n-\t    if (EINTR != errno) ABORT(\"sem_wait failed\");\n-\t}\n-#   ifdef DEBUG_THREADS\n-        GC_printf1(\"sem_wait complete from thread 0x%X\\n\",\n-\t\t   pthread_self());\n-#   endif\n-        sem_destroy(&(si -> registered));\n-\tLOCK();\n-\tGC_INTERNAL_FREE(si);\n-\tUNLOCK();\n-    return(result);\n-}\n-\n-#ifdef GENERIC_COMPARE_AND_SWAP\n-  pthread_mutex_t GC_compare_and_swap_lock = PTHREAD_MUTEX_INITIALIZER;\n-\n-  GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n-  \t\t\t          GC_word old, GC_word new_val)\n-  {\n-    GC_bool result;\n-    pthread_mutex_lock(&GC_compare_and_swap_lock);\n-    if (*addr == old) {\n-      *addr = new_val;\n-      result = TRUE;\n-    } else {\n-      result = FALSE;\n-    }\n-    pthread_mutex_unlock(&GC_compare_and_swap_lock);\n-    return result;\n-  }\n-  \n-  GC_word GC_atomic_add(volatile GC_word *addr, GC_word how_much)\n-  {\n-    GC_word old;\n-    pthread_mutex_lock(&GC_compare_and_swap_lock);\n-    old = *addr;\n-    *addr = old + how_much;\n-    pthread_mutex_unlock(&GC_compare_and_swap_lock);\n-    return old;\n-  }\n-\n-#endif /* GENERIC_COMPARE_AND_SWAP */\n-/* Spend a few cycles in a way that can't introduce contention with\t*/\n-/* othre threads.\t\t\t\t\t\t\t*/\n-void GC_pause()\n-{\n-    int i;\n-    volatile word dummy = 0;\n-\n-    for (i = 0; i < 10; ++i) { \n-#     ifdef __GNUC__\n-        __asm__ __volatile__ (\" \" : : : \"memory\");\n-#     else\n-\t/* Something that's unlikely to be optimized away. */\n-\tGC_noop(++dummy);\n-#     endif\n-    }\n-}\n-    \n-#define SPIN_MAX 1024\t/* Maximum number of calls to GC_pause before\t*/\n-\t\t\t/* give up.\t\t\t\t\t*/\n-\n-VOLATILE GC_bool GC_collecting = 0;\n-\t\t\t/* A hint that we're in the collector and       */\n-                        /* holding the allocation lock for an           */\n-                        /* extended period.                             */\n-\n-#if !defined(USE_SPIN_LOCK) || defined(PARALLEL_MARK)\n-/* If we don't want to use the below spinlock implementation, either\t*/\n-/* because we don't have a GC_test_and_set implementation, or because \t*/\n-/* we don't want to risk sleeping, we can still try spinning on \t*/\n-/* pthread_mutex_trylock for a while.  This appears to be very\t\t*/\n-/* beneficial in many cases.\t\t\t\t\t\t*/\n-/* I suspect that under high contention this is nearly always better\t*/\n-/* than the spin lock.  But it's a bit slower on a uniprocessor.\t*/\n-/* Hence we still default to the spin lock.\t\t\t\t*/\n-/* This is also used to acquire the mark lock for the parallel\t\t*/\n-/* marker.\t\t\t\t\t\t\t\t*/\n-\n-/* Here we use a strict exponential backoff scheme.  I don't know \t*/\n-/* whether that's better or worse than the above.  We eventually \t*/\n-/* yield by calling pthread_mutex_lock(); it never makes sense to\t*/\n-/* explicitly sleep.\t\t\t\t\t\t\t*/\n-\n-void GC_generic_lock(pthread_mutex_t * lock)\n-{\n-    unsigned pause_length = 1;\n-    unsigned i;\n-    \n-    if (0 == pthread_mutex_trylock(lock)) return;\n-    for (; pause_length <= SPIN_MAX; pause_length <<= 1) {\n-\tfor (i = 0; i < pause_length; ++i) {\n-\t    GC_pause();\n-\t}\n-        switch(pthread_mutex_trylock(lock)) {\n-\t    case 0:\n-\t\treturn;\n-\t    case EBUSY:\n-\t\tbreak;\n-\t    default:\n-\t\tABORT(\"Unexpected error from pthread_mutex_trylock\");\n-        }\n-    }\n-    pthread_mutex_lock(lock);\n-}\n-\n-#endif /* !USE_SPIN_LOCK || PARALLEL_MARK */\n-\n-#if defined(USE_SPIN_LOCK)\n-\n-/* Reasonably fast spin locks.  Basically the same implementation */\n-/* as STL alloc.h.  This isn't really the right way to do this.   */\n-/* but until the POSIX scheduling mess gets straightened out ...  */\n-\n-volatile unsigned int GC_allocate_lock = 0;\n-\n-\n-void GC_lock()\n-{\n-#   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */\n-#   define high_spin_max SPIN_MAX /* spin cycles for multiprocessor */\n-    static unsigned spin_max = low_spin_max;\n-    unsigned my_spin_max;\n-    static unsigned last_spins = 0;\n-    unsigned my_last_spins;\n-    int i;\n-\n-    if (!GC_test_and_set(&GC_allocate_lock)) {\n-        return;\n-    }\n-    my_spin_max = spin_max;\n-    my_last_spins = last_spins;\n-    for (i = 0; i < my_spin_max; i++) {\n-        if (GC_collecting || GC_nprocs == 1) goto yield;\n-        if (i < my_last_spins/2 || GC_allocate_lock) {\n-            GC_pause();\n-            continue;\n-        }\n-        if (!GC_test_and_set(&GC_allocate_lock)) {\n-\t    /*\n-             * got it!\n-             * Spinning worked.  Thus we're probably not being scheduled\n-             * against the other process with which we were contending.\n-             * Thus it makes sense to spin longer the next time.\n-\t     */\n-            last_spins = i;\n-            spin_max = high_spin_max;\n-            return;\n-        }\n-    }\n-    /* We are probably being scheduled against the other process.  Sleep. */\n-    spin_max = low_spin_max;\n-yield:\n-    for (i = 0;; ++i) {\n-        if (!GC_test_and_set(&GC_allocate_lock)) {\n-            return;\n-        }\n-#       define SLEEP_THRESHOLD 12\n-\t\t/* nanosleep(<= 2ms) just spins under Linux.  We\t*/\n-\t\t/* want to be careful to avoid that behavior.\t\t*/\n-        if (i < SLEEP_THRESHOLD) {\n-            sched_yield();\n-\t} else {\n-\t    struct timespec ts;\n-\t\n-\t    if (i > 24) i = 24;\n-\t\t\t/* Don't wait for more than about 15msecs, even\t*/\n-\t\t\t/* under extreme contention.\t\t\t*/\n-\t    ts.tv_sec = 0;\n-\t    ts.tv_nsec = 1 << i;\n-\t    nanosleep(&ts, 0);\n-\t}\n-    }\n-}\n-\n-#else  /* !USE_SPINLOCK */\n-\n-void GC_lock()\n-{\n-    if (1 == GC_nprocs || GC_collecting) {\n-\tpthread_mutex_lock(&GC_allocate_ml);\n-    } else {\n-        GC_generic_lock(&GC_allocate_ml);\n-    }\n-}\n-\n-#endif /* !USE_SPINLOCK */\n-\n-#if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n-\n-#ifdef GC_ASSERTIONS\n-  pthread_t GC_mark_lock_holder = NO_THREAD;\n-#endif\n-\n-#if 0\n-  /* Ugly workaround for a linux threads bug in the final versions      */\n-  /* of glibc2.1.  Pthread_mutex_trylock sets the mutex owner           */\n-  /* field even when it fails to acquire the mutex.  This causes        */\n-  /* pthread_cond_wait to die.  Remove for glibc2.2.                    */\n-  /* According to the man page, we should use                           */\n-  /* PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP, but that isn't actually   */\n-  /* defined.                                                           */\n-  static pthread_mutex_t mark_mutex =\n-        {0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, {0, 0}};\n-#else\n-  static pthread_mutex_t mark_mutex = PTHREAD_MUTEX_INITIALIZER;\n-#endif\n-\n-static pthread_cond_t builder_cv = PTHREAD_COND_INITIALIZER;\n-\n-void GC_acquire_mark_lock()\n-{\n-/*\n-    if (pthread_mutex_lock(&mark_mutex) != 0) {\n-\tABORT(\"pthread_mutex_lock failed\");\n-    }\n-*/\n-    GC_generic_lock(&mark_mutex);\n-#   ifdef GC_ASSERTIONS\n-\tGC_mark_lock_holder = pthread_self();\n-#   endif\n-}\n-\n-void GC_release_mark_lock()\n-{\n-    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n-#   ifdef GC_ASSERTIONS\n-\tGC_mark_lock_holder = NO_THREAD;\n-#   endif\n-    if (pthread_mutex_unlock(&mark_mutex) != 0) {\n-\tABORT(\"pthread_mutex_unlock failed\");\n-    }\n-}\n-\n-/* Collector must wait for a freelist builders for 2 reasons:\t\t*/\n-/* 1) Mark bits may still be getting examined without lock.\t\t*/\n-/* 2) Partial free lists referenced only by locals may not be scanned \t*/\n-/*    correctly, e.g. if they contain \"pointer-free\" objects, since the\t*/\n-/*    free-list link may be ignored.\t\t\t\t\t*/\n-void GC_wait_builder()\n-{\n-    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n-#   ifdef GC_ASSERTIONS\n-\tGC_mark_lock_holder = NO_THREAD;\n-#   endif\n-    if (pthread_cond_wait(&builder_cv, &mark_mutex) != 0) {\n-\tABORT(\"pthread_cond_wait failed\");\n-    }\n-    GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n-#   ifdef GC_ASSERTIONS\n-\tGC_mark_lock_holder = pthread_self();\n-#   endif\n-}\n-\n-void GC_wait_for_reclaim()\n-{\n-    GC_acquire_mark_lock();\n-    while (GC_fl_builder_count > 0) {\n-\tGC_wait_builder();\n-    }\n-    GC_release_mark_lock();\n-}\n-\n-void GC_notify_all_builder()\n-{\n-    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n-    if (pthread_cond_broadcast(&builder_cv) != 0) {\n-\tABORT(\"pthread_cond_broadcast failed\");\n-    }\n-}\n-\n-#endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */\n-\n-#ifdef PARALLEL_MARK\n-\n-static pthread_cond_t mark_cv = PTHREAD_COND_INITIALIZER;\n-\n-void GC_wait_marker()\n-{\n-    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n-#   ifdef GC_ASSERTIONS\n-\tGC_mark_lock_holder = NO_THREAD;\n-#   endif\n-    if (pthread_cond_wait(&mark_cv, &mark_mutex) != 0) {\n-\tABORT(\"pthread_cond_wait failed\");\n-    }\n-    GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n-#   ifdef GC_ASSERTIONS\n-\tGC_mark_lock_holder = pthread_self();\n-#   endif\n-}\n-\n-void GC_notify_all_marker()\n-{\n-    if (pthread_cond_broadcast(&mark_cv) != 0) {\n-\tABORT(\"pthread_cond_broadcast failed\");\n-    }\n-}\n-\n-#endif /* PARALLEL_MARK */\n-\n-# endif /* GC_LINUX_THREADS and friends */\n-"}, {"sha": "3dc5f0b27b9ab556738a3c10d53bf18c839073b0", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -74,7 +74,8 @@ asm static void PushMacRegisters()\n /* on your architecture.  Run the test_setjmp program to see whether    */\n /* there is any chance it will work.                                    */\n \n-#ifndef USE_GENERIC_PUSH_REGS\n+#if !defined(USE_GENERIC_PUSH_REGS) && !defined(USE_ASM_PUSH_REGS)\n+#undef HAVE_PUSH_REGS\n void GC_push_regs()\n {\n #       ifdef RT\n@@ -91,6 +92,7 @@ void GC_push_regs()\n \t  asm(\"pushl r8\");\tasm(\"calls $1,_GC_push_one\");\n \t  asm(\"pushl r7\");\tasm(\"calls $1,_GC_push_one\");\n \t  asm(\"pushl r6\");\tasm(\"calls $1,_GC_push_one\");\n+#\t  define HAVE_PUSH_REGS\n #       endif\n #       if defined(M68K) && (defined(SUNOS4) || defined(NEXT))\n \t/*  M68K SUNOS - could be replaced by generic code */\n@@ -113,6 +115,7 @@ void GC_push_regs()\n \t  asm(\"movl d7,sp@\");\tasm(\"jbsr _GC_push_one\");\n \n \t  asm(\"addqw #0x4,sp\");\t\t/* put stack back where it was\t*/\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #       if defined(M68K) && defined(HP)\n@@ -135,6 +138,7 @@ void GC_push_regs()\n \t  asm(\"mov.l %d7,(%sp)\"); asm(\"jsr _GC_push_one\");\n \n \t  asm(\"addq.w &0x4,%sp\");\t/* put stack back where it was\t*/\n+#\t  define HAVE_PUSH_REGS\n #       endif /* M68K HP */\n \n #\tif defined(M68K) && defined(AMIGA)\n@@ -158,6 +162,7 @@ void GC_push_regs()\n \t  asm(\"mov.l %d7,(%sp)\"); asm(\"jsr _GC_push_one\");\n \n \t  asm(\"addq.w &0x4,%sp\");\t/* put stack back where it was\t*/\n+#\t  define HAVE_PUSH_REGS\n #        else /* !__GNUC__ */\n \t  GC_push_one(getreg(REG_A2));\n \t  GC_push_one(getreg(REG_A3));\n@@ -174,6 +179,7 @@ void GC_push_regs()\n \t  GC_push_one(getreg(REG_D5));\n \t  GC_push_one(getreg(REG_D6));\n \t  GC_push_one(getreg(REG_D7));\n+#\t  define HAVE_PUSH_REGS\n #\t endif /* !__GNUC__ */\n #       endif /* AMIGA */\n \n@@ -196,10 +202,12 @@ void GC_push_regs()\n               PushMacReg(d7);\n               add.w   #4,sp                   ; fix stack.\n \t  }\n+#\t  define HAVE_PUSH_REGS\n #\t  undef PushMacReg\n #\tendif /* THINK_C */\n #\tif defined(__MWERKS__)\n \t  PushMacRegisters();\n+#\t  define HAVE_PUSH_REGS\n #\tendif\t/* __MWERKS__ */\n #   endif\t/* MACOS */\n \n@@ -222,13 +230,15 @@ void GC_push_regs()\n \t  asm(\"pushl %esi\");  asm(\"call _GC_push_one\"); asm(\"addl $4,%esp\");\n \t  asm(\"pushl %edi\");  asm(\"call _GC_push_one\"); asm(\"addl $4,%esp\");\n \t  asm(\"pushl %ebx\");  asm(\"call _GC_push_one\"); asm(\"addl $4,%esp\");\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #\tif ( defined(I386) && defined(LINUX) && defined(__ELF__) ) \\\n \t|| ( defined(I386) && defined(FREEBSD) && defined(__ELF__) ) \\\n \t|| ( defined(I386) && defined(NETBSD) && defined(__ELF__) ) \\\n \t|| ( defined(I386) && defined(OPENBSD) && defined(__ELF__) ) \\\n-\t|| ( defined(I386) && defined(HURD) && defined(__ELF__) )\n+\t|| ( defined(I386) && defined(HURD) && defined(__ELF__) ) \\\n+\t|| ( defined(I386) && defined(DGUX) )\n \n \t/* This is modified for Linux with ELF (Note: _ELF_ only) */\n \t/* This section handles FreeBSD with ELF. */\n@@ -243,6 +253,7 @@ void GC_push_regs()\n \t  asm(\"pushl %esi; call GC_push_one; addl $4,%esp\");\n \t  asm(\"pushl %edi; call GC_push_one; addl $4,%esp\");\n \t  asm(\"pushl %ebx; call GC_push_one; addl $4,%esp\");\n+#\t  define HAVE_PUSH_REGS\n #\tendif\n \n #\tif ( defined(I386) && defined(BEOS) && defined(__ELF__) )\n@@ -254,6 +265,7 @@ void GC_push_regs()\n \t  asm(\"pushl %esi; call GC_push_one; addl $4,%esp\");\n \t  asm(\"pushl %edi; call GC_push_one; addl $4,%esp\");\n \t  asm(\"pushl %ebx; call GC_push_one; addl $4,%esp\");\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #       if defined(I386) && defined(MSWIN32) && !defined(__MINGW32__) \\\n@@ -280,6 +292,7 @@ void GC_push_regs()\n \t  __asm  push edi\n \t  __asm  call GC_push_one\n \t  __asm  add esp,4\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #       if defined(I386) && (defined(SVR4) || defined(SCO) || defined(SCO_ELF))\n@@ -291,6 +304,7 @@ void GC_push_regs()\n \t  asm(\"pushl %ebp\");  asm(\"call GC_push_one\"); asm(\"addl $4,%esp\");\n \t  asm(\"pushl %esi\");  asm(\"call GC_push_one\"); asm(\"addl $4,%esp\");\n \t  asm(\"pushl %edi\");  asm(\"call GC_push_one\"); asm(\"addl $4,%esp\");\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #       ifdef NS32K\n@@ -299,14 +313,12 @@ void GC_push_regs()\n \t  asm (\"movd r5, tos\"); asm (\"bsr ?_GC_push_one\"); asm (\"adjspb $-4\");\n \t  asm (\"movd r6, tos\"); asm (\"bsr ?_GC_push_one\"); asm (\"adjspb $-4\");\n \t  asm (\"movd r7, tos\"); asm (\"bsr ?_GC_push_one\"); asm (\"adjspb $-4\");\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #       if defined(SPARC)\n-\t  {\n-\t      word GC_save_regs_in_stack();\n-\t      \n-\t      GC_save_regs_ret_val = GC_save_regs_in_stack();\n-\t  }\n+\t  GC_save_regs_ret_val = GC_save_regs_in_stack();\n+#\t  define HAVE_PUSH_REGS\n #       endif\n \n #\tifdef RT\n@@ -322,6 +334,7 @@ void GC_push_regs()\n \t    asm(\"cas r11, r13, r0\"); GC_push_one(TMP_SP); /* through */\n \t    asm(\"cas r11, r14, r0\"); GC_push_one(TMP_SP); /* r15 */\n \t    asm(\"cas r11, r15, r0\"); GC_push_one(TMP_SP);\n+#\t    define HAVE_PUSH_REGS\n #       endif\n \n #       if defined(M68K) && defined(SYSV)\n@@ -345,6 +358,7 @@ void GC_push_regs()\n   \t  asm(\"movl %d7,%sp@\");\tasm(\"jbsr GC_push_one\");\n   \n   \t  asm(\"addqw #0x4,%sp\");\t/* put stack back where it was\t*/\n+#\t  define HAVE_PUSH_REGS\n #        else /* !__GNUC__*/\n   \t  asm(\"subq.w &0x4,%sp\");\t/* allocate word on top of stack */\n   \n@@ -362,6 +376,7 @@ void GC_push_regs()\n   \t  asm(\"mov.l %d7,(%sp)\"); asm(\"jsr GC_push_one\");\n   \n   \t  asm(\"addq.w &0x4,%sp\");\t/* put stack back where it was\t*/\n+#\t  define HAVE_PUSH_REGS\n #        endif /* !__GNUC__ */\n #       endif /* M68K/SYSV */\n \n@@ -371,21 +386,19 @@ void GC_push_regs()\n \t    extern int *__libc_stack_end;\n \n \t    GC_push_all_stack (sp, __libc_stack_end);\n+#\t    define HAVE_PUSH_REGS\n+\t    /* Isn't this redundant with the code to push the stack? */\n         }\n #     endif\n \n       /* other machines... */\n-#       if !defined(M68K) && !defined(VAX) && !defined(RT) \n-#\tif !defined(SPARC) && !defined(I386) && !defined(NS32K)\n-#\tif !defined(POWERPC) && !defined(UTS4) \n-#       if !defined(PJ) && !(defined(MIPS) && defined(LINUX))\n-\t    --> bad news <--\n-#\tendif\n-#       endif\n-#       endif\n+#       if !defined(HAVE_PUSH_REGS)\n+\t    --> We just generated an empty GC_push_regs, which\n+\t    --> is almost certainly broken.  Try defining\n+\t    --> USE_GENERIC_PUSH_REGS instead.\n #       endif\n }\n-#endif /* !USE_GENERIC_PUSH_REGS */\n+#endif /* !USE_GENERIC_PUSH_REGS && !USE_ASM_PUSH_REGS */\n \n #if defined(USE_GENERIC_PUSH_REGS)\n void GC_generic_push_regs(cold_gc_frame)\n@@ -427,8 +440,6 @@ ptr_t cold_gc_frame;\n \t      /* needed on IA64, since some non-windowed registers are\t*/\n \t      /* preserved.\t\t\t\t\t\t*/\n \t      {\n-\t        word GC_save_regs_in_stack();\n-\t      \n \t        GC_save_regs_ret_val = GC_save_regs_in_stack();\n \t\t/* On IA64 gcc, could use __builtin_ia64_flushrs() and\t*/\n \t\t/* __builtin_ia64_flushrs().  The latter will be done\t*/\n@@ -445,7 +456,7 @@ ptr_t cold_gc_frame;\n /* the stack.\tReturn sp.\t\t\t\t\t\t*/\n # ifdef SPARC\n     asm(\"\t.seg \t\\\"text\\\"\");\n-#   ifdef SVR4\n+#   if defined(SVR4) || defined(NETBSD)\n       asm(\"\t.globl\tGC_save_regs_in_stack\");\n       asm(\"GC_save_regs_in_stack:\");\n       asm(\"\t.type GC_save_regs_in_stack,#function\");"}, {"sha": "f5c8f06b0dd94267bb1766d83980c1a7a8232644", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -182,6 +182,7 @@ register int k;\n     ptr_t result;\n     DCL_LOCK_STATE;\n \n+    if (GC_have_errors) GC_print_all_errors();\n     GC_INVOKE_FINALIZERS();\n     if (SMALL_OBJ(lb)) {\n     \tDISABLE_SIGNALS();\n@@ -294,6 +295,11 @@ DCL_LOCK_STATE;\n             return(GENERAL_MALLOC((word)lb, NORMAL));\n         }\n         /* See above comment on signals.\t*/\n+\tGC_ASSERT(0 == obj_link(op)\n+\t\t  || (word)obj_link(op)\n+\t\t  \t<= (word)GC_greatest_plausible_heap_addr\n+\t\t     && (word)obj_link(op)\n+\t\t     \t>= (word)GC_least_plausible_heap_addr);\n         *opp = obj_link(op);\n         obj_link(op) = 0;\n         GC_words_allocd += lw;\n@@ -338,6 +344,7 @@ DCL_LOCK_STATE;\n     return((GC_PTR)REDIRECT_MALLOC(n*lb));\n   }\n \n+#ifndef strdup\n # include <string.h>\n # ifdef __STDC__\n     char *strdup(const char *s)\n@@ -346,11 +353,16 @@ DCL_LOCK_STATE;\n     char *s;\n # endif\n   {\n-    size_t len = strlen + 1;\n+    size_t len = strlen(s) + 1;\n     char * result = ((char *)REDIRECT_MALLOC(len+1));\n     BCOPY(s, result, len+1);\n     return result;\n   }\n+#endif /* !defined(strdup) */\n+ /* If strdup is macro defined, we assume that it actually calls malloc, */\n+ /* and thus the right thing will happen even without overriding it.\t */\n+ /* This seems to be true on most Linux systems.\t\t\t */\n+\n # endif /* REDIRECT_MALLOC */\n \n /* Explicitly deallocate an object p.\t\t\t\t*/\n@@ -373,6 +385,7 @@ DCL_LOCK_STATE;\n     \t/* Required by ANSI.  It's not my fault ...\t*/\n     h = HBLKPTR(p);\n     hhdr = HDR(h);\n+    GC_ASSERT(GC_base(p) == p);\n #   if defined(REDIRECT_MALLOC) && \\\n \t(defined(GC_SOLARIS_THREADS) || defined(GC_LINUX_THREADS) \\\n \t || defined(__MINGW32__)) /* Should this be MSWIN32 in general? */\n@@ -454,7 +467,10 @@ void GC_free_inner(GC_PTR p)\n }\n #endif /* THREADS */\n \n-# ifdef REDIRECT_MALLOC\n+# if defined(REDIRECT_MALLOC) && !defined(REDIRECT_FREE)\n+#   define REDIRECT_FREE GC_free\n+# endif\n+# ifdef REDIRECT_FREE\n #   ifdef __STDC__\n       void free(GC_PTR p)\n #   else\n@@ -463,7 +479,7 @@ void GC_free_inner(GC_PTR p)\n #   endif\n   {\n #   ifndef IGNORE_FREE\n-      GC_free(p);\n+      REDIRECT_FREE(p);\n #   endif\n   }\n # endif  /* REDIRECT_MALLOC */"}, {"sha": "06f45622dfbedad71217293861145ab58d6ea483", "filename": "boehm-gc/mallocx.c", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -142,7 +142,11 @@ int obj_kind;\n     }\n }\n \n-# if defined(REDIRECT_MALLOC) || defined(REDIRECT_REALLOC)\n+# if defined(REDIRECT_MALLOC) && !defined(REDIRECT_REALLOC)\n+#   define REDIRECT_REALLOC GC_realloc\n+# endif\n+\n+# ifdef REDIRECT_REALLOC\n # ifdef __STDC__\n     GC_PTR realloc(GC_PTR p, size_t lb)\n # else\n@@ -151,13 +155,9 @@ int obj_kind;\n     size_t lb;\n # endif\n   {\n-#   ifdef REDIRECT_REALLOC\n-      return(REDIRECT_REALLOC(p, lb));\n-#   else\n-      return(GC_realloc(p, lb));\n-#   endif\n+    return(REDIRECT_REALLOC(p, lb));\n   }\n-# endif /* REDIRECT_MALLOC */\n+# endif /* REDIRECT_REALLOC */\n \n \n /* The same thing, except caller does not hold allocation lock.\t*/\n@@ -177,6 +177,7 @@ register int k;\n     lw = ROUNDED_UP_WORDS(lb);\n     n_blocks = OBJ_SZ_TO_BLOCKS(lw);\n     init = GC_obj_kinds[k].ok_init;\n+    if (GC_have_errors) GC_print_all_errors();\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n@@ -286,6 +287,7 @@ register struct obj_kind * kind = GC_obj_kinds + k;\n register ptr_t op;\n DCL_LOCK_STATE;\n \n+    if (GC_have_errors) GC_print_all_errors();\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n@@ -354,6 +356,7 @@ DCL_LOCK_STATE;\n         return;\n     }\n     lw = ALIGNED_WORDS(lb);\n+    if (GC_have_errors) GC_print_all_errors();\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n@@ -375,6 +378,7 @@ DCL_LOCK_STATE;\n     \twhile ((hbp = *rlh) != 0) {\n             hhdr = HDR(hbp);\n             *rlh = hhdr -> hb_next;\n+\t    hhdr -> hb_last_reclaimed = (unsigned short) GC_gc_no;\n #\t    ifdef PARALLEL_MARK\n \t\t{\n \t\t  signed_word my_words_allocd_tmp = GC_words_allocd_tmp;\n@@ -575,6 +579,44 @@ DCL_LOCK_STATE;\n     }\n }\n \n+#ifdef __STDC__\n+/* Not well tested nor integrated.\t*/\n+/* Debug version is tricky and currently missing.\t*/\n+#include <limits.h>\n+\n+GC_PTR GC_memalign(size_t align, size_t lb) \n+{ \n+    size_t new_lb;\n+    size_t offset;\n+    ptr_t result;\n+\n+#   ifdef ALIGN_DOUBLE\n+\tif (align <= WORDS_TO_BYTES(2) && lb > align) return GC_malloc(lb);\n+#   endif\n+    if (align <= WORDS_TO_BYTES(1)) return GC_malloc(lb);\n+    if (align >= HBLKSIZE/2 || lb >= HBLKSIZE/2) {\n+        if (align > HBLKSIZE) return GC_oom_fn(LONG_MAX-1024) /* Fail */;\n+\treturn GC_malloc(lb <= HBLKSIZE? HBLKSIZE : lb);\n+\t    /* Will be HBLKSIZE aligned.\t*/\n+    }\n+    /* We could also try to make sure that the real rounded-up object size */\n+    /* is a multiple of align.  That would be correct up to HBLKSIZE.\t   */\n+    new_lb = lb + align - 1;\n+    result = GC_malloc(new_lb);\n+    offset = (word)result % align;\n+    if (offset != 0) {\n+\toffset = align - offset;\n+        if (!GC_all_interior_pointers) {\n+\t    if (offset >= VALID_OFFSET_SZ) return GC_malloc(HBLKSIZE);\n+\t    GC_register_displacement(offset);\n+\t}\n+    }\n+    result = (GC_PTR) ((ptr_t)result + offset);\n+    GC_ASSERT((word)result % align == 0);\n+    return result;\n+}\n+#endif \n+\n # ifdef ATOMIC_UNCOLLECTABLE\n /* Allocate lb bytes of pointerfree, untraced, uncollectable data \t*/\n /* This is normally roughly equivalent to the system malloc.\t\t*/"}, {"sha": "ca947290291b880de35b19d2ca2a632476fd4322", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 168, "deletions": 48, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -19,6 +19,10 @@\n # include <stdio.h>\n # include \"private/gc_pmark.h\"\n \n+#if defined(MSWIN32) && defined(__GNUC__)\n+# include <excpt.h>\n+#endif\n+\n /* We put this here to minimize the risk of inlining. */\n /*VARARGS*/\n #ifdef __WATCOMC__\n@@ -261,20 +265,20 @@ static void alloc_mark_stack();\n /* remains valid until all marking is complete.\t\t*/\n /* A zero value indicates that it's OK to miss some\t*/\n /* register values.\t\t\t\t\t*/\n-GC_bool GC_mark_some(cold_gc_frame)\n-ptr_t cold_gc_frame;\n+/* We hold the allocation lock.  In the case of \t*/\n+/* incremental collection, the world may not be stopped.*/\n+#ifdef MSWIN32\n+  /* For win32, this is called after we establish a structured\t*/\n+  /* exception handler, in case Windows unmaps one of our root\t*/\n+  /* segments.  See below.  In either case, we acquire the \t*/\n+  /* allocator lock long before we get here.\t\t\t*/\n+  GC_bool GC_mark_some_inner(cold_gc_frame)\n+  ptr_t cold_gc_frame;\n+#else\n+  GC_bool GC_mark_some(cold_gc_frame)\n+  ptr_t cold_gc_frame;\n+#endif\n {\n-#if defined(MSWIN32) && !defined(__GNUC__)\n-  /* Windows 98 appears to asynchronously create and remove writable\t*/\n-  /* memory mappings, for reasons we haven't yet understood.  Since\t*/\n-  /* we look for writable regions to determine the root set, we may\t*/\n-  /* try to mark from an address range that disappeared since we \t*/\n-  /* started the collection.  Thus we have to recover from faults here. */\n-  /* This code does not appear to be necessary for Windows 95/NT/2000.\t*/ \n-  /* Note that this code should never generate an incremental GC write\t*/\n-  /* fault.\t\t\t\t\t\t\t\t*/\n-  __try {\n-#endif /* defined(MSWIN32) && !defined(__GNUC__) */\n     switch(GC_mark_state) {\n     \tcase MS_NONE:\n     \t    return(FALSE);\n@@ -395,23 +399,130 @@ ptr_t cold_gc_frame;\n     \t    ABORT(\"GC_mark_some: bad state\");\n     \t    return(FALSE);\n     }\n-#if defined(MSWIN32) && !defined(__GNUC__)\n-  } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\n-\t    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\n-#   ifdef CONDPRINT\n-      if (GC_print_stats) {\n-\tGC_printf0(\"Caught ACCESS_VIOLATION in marker. \"\n-\t\t   \"Memory mapping disappeared.\\n\");\n+}\n+\n+\n+#ifdef MSWIN32\n+\n+# ifdef __GNUC__\n+\n+    typedef struct {\n+      EXCEPTION_REGISTRATION ex_reg;\n+      void *alt_path;\n+    } ext_ex_regn;\n+\n+\n+    static EXCEPTION_DISPOSITION mark_ex_handler(\n+        struct _EXCEPTION_RECORD *ex_rec, \n+        void *est_frame,\n+        struct _CONTEXT *context,\n+        void *disp_ctxt)\n+    {\n+        if (ex_rec->ExceptionCode == STATUS_ACCESS_VIOLATION) {\n+          ext_ex_regn *xer = (ext_ex_regn *)est_frame;\n+\n+          /* Unwind from the inner function assuming the standard */\n+          /* function prologue.                                   */\n+          /* Assumes code has not been compiled with              */\n+          /* -fomit-frame-pointer.                                */\n+          context->Esp = context->Ebp;\n+          context->Ebp = *((DWORD *)context->Esp);\n+          context->Esp = context->Esp - 8;\n+\n+          /* Resume execution at the \"real\" handler within the    */\n+          /* wrapper function.                                    */\n+          context->Eip = (DWORD )(xer->alt_path);\n+\n+          return ExceptionContinueExecution;\n+\n+        } else {\n+            return ExceptionContinueSearch;\n+        }\n+    }\n+# endif /* __GNUC__ */\n+\n+\n+  GC_bool GC_mark_some(cold_gc_frame)\n+  ptr_t cold_gc_frame;\n+  {\n+      GC_bool ret_val;\n+\n+#   ifndef __GNUC__\n+      /* Windows 98 appears to asynchronously create and remove  */\n+      /* writable memory mappings, for reasons we haven't yet    */\n+      /* understood.  Since we look for writable regions to      */\n+      /* determine the root set, we may try to mark from an      */\n+      /* address range that disappeared since we started the     */\n+      /* collection.  Thus we have to recover from faults here.  */\n+      /* This code does not appear to be necessary for Windows   */\n+      /* 95/NT/2000. Note that this code should never generate   */\n+      /* an incremental GC write fault.                          */\n+\n+      __try {\n+\n+#   else /* __GNUC__ */\n+\n+      /* Manually install an exception handler since GCC does    */\n+      /* not yet support Structured Exception Handling (SEH) on  */\n+      /* Win32.                                                  */\n+\n+      ext_ex_regn er;\n+\n+      er.alt_path = &&handle_ex;\n+      er.ex_reg.handler = mark_ex_handler;\n+      asm volatile (\"movl %%fs:0, %0\" : \"=r\" (er.ex_reg.prev));\n+      asm volatile (\"movl %0, %%fs:0\" : : \"r\" (&er));\n+\n+#   endif /* __GNUC__ */\n+\n+          ret_val = GC_mark_some_inner(cold_gc_frame);\n+\n+#   ifndef __GNUC__\n+\n+      } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\n+                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\n+\n+#   else /* __GNUC__ */\n+\n+          /* Prevent GCC from considering the following code unreachable */\n+          /* and thus eliminating it.                                    */\n+          if (er.alt_path != 0)\n+              goto rm_handler;\n+\n+handle_ex:\n+          /* Execution resumes from here on an access violation. */\n+\n+#   endif /* __GNUC__ */\n+\n+#         ifdef CONDPRINT\n+            if (GC_print_stats) {\n+\t      GC_printf0(\"Caught ACCESS_VIOLATION in marker. \"\n+\t\t         \"Memory mapping disappeared.\\n\");\n+            }\n+#         endif /* CONDPRINT */\n+\n+          /* We have bad roots on the stack.  Discard mark stack.  */\n+          /* Rescan from marked objects.  Redetermine roots.\t */\n+          GC_invalidate_mark_state();\t\n+          scan_ptr = 0;\n+\n+          ret_val = FALSE;\n+\n+#   ifndef __GNUC__\n+\n       }\n-#   endif /* CONDPRINT */\n-    /* We have bad roots on the stack.  Discard mark stack.  \t*/\n-    /* Rescan from marked objects.  Redetermine roots.\t\t*/\n-    GC_invalidate_mark_state();\t\n-    scan_ptr = 0;\n-    return FALSE;\n+\n+#   else /* __GNUC__ */\n+\n+rm_handler:\n+      /* Uninstall the exception handler */\n+      asm volatile (\"mov %0, %%fs:0\" : : \"r\" (er.ex_reg.prev));\n+\n+#   endif /* __GNUC__ */\n+\n+      return ret_val;\n   }\n-#endif /* defined(MSWIN32) && !defined(__GNUC__) */\n-}\n+#endif /* MSWIN32 */\n \n \n GC_bool GC_mark_stack_empty()\n@@ -434,13 +545,7 @@ GC_bool GC_mark_stack_empty()\n /*\t  for the large object.\t\t\t\t\t\t*/\n /*\t- just return current if it does not point to a large object.\t*/\n /*ARGSUSED*/\n-# ifdef PRINT_BLACK_LIST\n-  ptr_t GC_find_start(current, hhdr, new_hdr_p, source)\n-  ptr_t source;\n-# else\n-  ptr_t GC_find_start(current, hhdr, new_hdr_p)\n-# define source 0\n-# endif\n+ptr_t GC_find_start(current, hhdr, new_hdr_p)\n register ptr_t current;\n register hdr *hhdr, **new_hdr_p;\n {\n@@ -468,7 +573,6 @@ register hdr *hhdr, **new_hdr_p;\n     } else {\n         return(current);\n     }\n-#   undef source\n }\n \n void GC_invalidate_mark_state()\n@@ -546,8 +650,8 @@ mse * mark_stack_limit;\n           /* Large length.\t\t\t\t\t        */\n           /* Process part of the range to avoid pushing too much on the\t*/\n           /* stack.\t\t\t\t\t\t\t*/\n-\t  GC_ASSERT(descr < GC_greatest_plausible_heap_addr\n-\t\t\t    - GC_least_plausible_heap_addr);\n+\t  GC_ASSERT(descr < (word)GC_greatest_plausible_heap_addr\n+\t\t\t    - (word)GC_least_plausible_heap_addr);\n #\t  ifdef PARALLEL_MARK\n #\t    define SHARE_BYTES 2048\n \t    if (descr > SHARE_BYTES && GC_parallel\n@@ -578,6 +682,7 @@ mse * mark_stack_limit;\n           while (descr != 0) {\n             if ((signed_word)descr < 0) {\n               current = *current_p;\n+\t      FIXUP_POINTER(current);\n \t      if ((ptr_t)current >= least_ha && (ptr_t)current < greatest_ha) {\n \t\tPREFETCH(current);\n                 HC_PUSH_CONTENTS((ptr_t)current, mark_stack_top,\n@@ -652,6 +757,7 @@ mse * mark_stack_limit;\n \t  PREFETCH((ptr_t)limit - PREF_DIST*CACHE_LINE_SIZE);\n \t  GC_ASSERT(limit >= current_p);\n \t  deferred = *limit;\n+\t  FIXUP_POINTER(deferred);\n \t  limit = (word *)((char *)limit - ALIGNMENT);\n \t  if ((ptr_t)deferred >= least_ha && (ptr_t)deferred <  greatest_ha) {\n \t    PREFETCH(deferred);\n@@ -661,6 +767,7 @@ mse * mark_stack_limit;\n \t  /* Unroll once, so we don't do too many of the prefetches \t*/\n \t  /* based on limit.\t\t\t\t\t\t*/\n \t  deferred = *limit;\n+\t  FIXUP_POINTER(deferred);\n \t  limit = (word *)((char *)limit - ALIGNMENT);\n \t  if ((ptr_t)deferred >= least_ha && (ptr_t)deferred <  greatest_ha) {\n \t    PREFETCH(deferred);\n@@ -675,6 +782,7 @@ mse * mark_stack_limit;\n \t/* Since HC_PUSH_CONTENTS expands to a lot of code,\t*/\n \t/* we don't.\t\t\t\t\t\t*/\n         current = *current_p;\n+\tFIXUP_POINTER(current);\n         PREFETCH((ptr_t)current_p + PREF_DIST*CACHE_LINE_SIZE);\n         if ((ptr_t)current >= least_ha && (ptr_t)current <  greatest_ha) {\n   \t  /* Prefetch the contents of the object we just pushed.  It's\t*/\n@@ -726,22 +834,33 @@ mse * GC_steal_mark_stack(mse * low, mse * high, mse * local,\n     mse *top = local - 1;\n     unsigned i = 0;\n \n+    /* Make sure that prior writes to the mark stack are visible. */\n+    /* On some architectures, the fact that the reads are \t  */\n+    /* volatile should suffice.\t\t\t\t\t  */\n+#   if !defined(IA64) && !defined(HP_PA) && !defined(I386)\n+      GC_memory_barrier();\n+#   endif\n     GC_ASSERT(high >= low-1 && high - low + 1 <= GC_mark_stack_size);\n     for (p = low; p <= high && i <= max; ++p) {\n \tword descr = *(volatile word *) &(p -> mse_descr);\n+\t/* In the IA64 memory model, the following volatile store is\t*/\n+\t/* ordered after this read of descr.  Thus a thread must read \t*/\n+\t/* the original nonzero value.  HP_PA appears to be similar,\t*/\n+\t/* and if I'm reading the P4 spec correctly, X86 is probably \t*/\n+\t/* also OK.  In some other cases we need a barrier.\t\t*/\n+#       if !defined(IA64) && !defined(HP_PA) && !defined(I386)\n+          GC_memory_barrier();\n+#       endif\n \tif (descr != 0) {\n \t    *(volatile word *) &(p -> mse_descr) = 0;\n+\t    /* More than one thread may get this entry, but that's only */\n+\t    /* a minor performance problem.\t\t\t\t*/\n \t    ++top;\n \t    top -> mse_descr = descr;\n \t    top -> mse_start = p -> mse_start;\n \t    GC_ASSERT(  top -> mse_descr & GC_DS_TAGS != GC_DS_LENGTH || \n \t\t\ttop -> mse_descr < GC_greatest_plausible_heap_addr\n \t\t\t                   - GC_least_plausible_heap_addr);\n-\t    /* There is no synchronization here.  We assume that at\t*/\n-\t    /* least one thread will see the original descriptor.\t*/\n-\t    /* Otherwise we need a barrier.\t\t\t\t*/\n-\t    /* More than one thread may get this entry, but that's only */\n-\t    /* a minor performance problem.\t\t\t\t*/\n \t    /* If this is a big object, count it as\t\t\t*/\n \t    /* size/256 + 1 objects.\t\t\t\t\t*/\n \t    ++i;\n@@ -778,7 +897,7 @@ void GC_return_mark_stack(mse * low, mse * high)\n       BCOPY(low, my_start, stack_size * sizeof(mse));\n       GC_ASSERT(GC_mark_stack_top = my_top);\n #     if !defined(IA64) && !defined(HP_PA)\n-        GC_memory_write_barrier();\n+        GC_memory_barrier();\n #     endif\n \t/* On IA64, the volatile write acts as a release barrier. */\n       GC_mark_stack_top = my_top + stack_size;\n@@ -1342,8 +1461,8 @@ ptr_t top;\n #   define GC_least_plausible_heap_addr least_ha\n \n     if (top == 0) return;\n-    /* check all pointers in range and put in push if they appear */\n-    /* to be valid.\t\t\t\t\t\t  */\n+    /* check all pointers in range and push if they appear\t*/\n+    /* to be valid.\t\t\t\t\t\t*/\n       lim = t - 1 /* longword */;\n       for (p = b; p <= lim; p = (word *)(((char *)p) + ALIGNMENT)) {\n \tq = *p;\n@@ -1366,7 +1485,7 @@ ptr_t bottom;\n ptr_t top;\n ptr_t cold_gc_frame;\n {\n-  if (GC_all_interior_pointers) {\n+  if (!NEED_FIXUP_POINTER && GC_all_interior_pointers) {\n #   define EAGER_BYTES 1024\n     /* Push the hot end of the stack eagerly, so that register values   */\n     /* saved inside GC frames are marked before they disappear.\t\t*/\n@@ -1375,6 +1494,7 @@ ptr_t cold_gc_frame;\n \tGC_push_all_stack(bottom, top);\n \treturn;\n     }\n+    GC_ASSERT(bottom <= cold_gc_frame && cold_gc_frame <= top);\n #   ifdef STACK_GROWS_DOWN\n \tGC_push_all(cold_gc_frame - sizeof(ptr_t), top);\n \tGC_push_all_eager(bottom, cold_gc_frame);\n@@ -1395,7 +1515,7 @@ void GC_push_all_stack(bottom, top)\n ptr_t bottom;\n ptr_t top;\n {\n-  if (GC_all_interior_pointers) {\n+  if (!NEED_FIXUP_POINTER && GC_all_interior_pointers) {\n     GC_push_all(bottom, top);\n   } else {\n     GC_push_all_eager(bottom, top);"}, {"sha": "55eb5d5433953dd860281be12e0d9c90205f9ec9", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -274,34 +274,73 @@ void GC_clear_roots GC_PROTO((void))\n     ENABLE_SIGNALS();\n }\n \n+/* Internal use only; lock held.\t*/\n+static void GC_remove_root_at_pos(i) \n+int i;\n+{\n+    GC_root_size -= (GC_static_roots[i].r_end - GC_static_roots[i].r_start);\n+    GC_static_roots[i].r_start = GC_static_roots[n_root_sets-1].r_start;\n+    GC_static_roots[i].r_end = GC_static_roots[n_root_sets-1].r_end;\n+    GC_static_roots[i].r_tmp = GC_static_roots[n_root_sets-1].r_tmp;\n+    n_root_sets--;\n+}\n+\n+#if !defined(MSWIN32) && !defined(MSWINCE)\n+static void GC_rebuild_root_index()\n+{\n+    register int i;\n+    \t\n+    for (i = 0; i < RT_SIZE; i++) GC_root_index[i] = 0;\n+    for (i = 0; i < n_root_sets; i++)\n+\tadd_roots_to_index(GC_static_roots + i);\n+}\n+#endif\n+\n /* Internal use only; lock held.\t*/\n void GC_remove_tmp_roots()\n {\n     register int i;\n     \n     for (i = 0; i < n_root_sets; ) {\n     \tif (GC_static_roots[i].r_tmp) {\n-    \t    GC_root_size -=\n-\t\t(GC_static_roots[i].r_end - GC_static_roots[i].r_start);\n-    \t    GC_static_roots[i].r_start = GC_static_roots[n_root_sets-1].r_start;\n-    \t    GC_static_roots[i].r_end = GC_static_roots[n_root_sets-1].r_end;\n-    \t    GC_static_roots[i].r_tmp = GC_static_roots[n_root_sets-1].r_tmp;\n-    \t    n_root_sets--;\n+            GC_remove_root_at_pos(i);\n     \t} else {\n     \t    i++;\n-    \t}\n     }\n-#   if !defined(MSWIN32) && !defined(MSWINCE)\n-    {\n-    \tregister int i;\n-    \t\n-    \tfor (i = 0; i < RT_SIZE; i++) GC_root_index[i] = 0;\n-    \tfor (i = 0; i < n_root_sets; i++)\n-\t\tadd_roots_to_index(GC_static_roots + i);\n     }\n-#   endif\n+    #if !defined(MSWIN32) && !defined(MSWINCE)\n+    GC_rebuild_root_index();\n+    #endif\n+}\n+\n+#if !defined(MSWIN32) && !defined(MSWINCE)\n+void GC_remove_roots(b, e)\n+char * b; char * e;\n+{\n+    DCL_LOCK_STATE;\n     \n+    DISABLE_SIGNALS();\n+    LOCK();\n+    GC_remove_roots_inner(b, e);\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+}\n+\n+/* Should only be called when the lock is held */\n+void GC_remove_roots_inner(b,e)\n+char * b; char * e;\n+{\n+    int i;\n+    for (i = 0; i < n_root_sets; ) {\n+    \tif (GC_static_roots[i].r_start >= (ptr_t)b && GC_static_roots[i].r_end <= (ptr_t)e) {\n+            GC_remove_root_at_pos(i);\n+    \t} else {\n+    \t    i++;\n+    \t}\n+    }\n+    GC_rebuild_root_index();\n }\n+#endif /* !defined(MSWIN32) && !defined(MSWINCE) */\n \n #if defined(MSWIN32) || defined(_WIN32_WCE_EMULATION)\n /* Workaround for the OS mapping and unmapping behind our back:\t\t*/\n@@ -573,8 +612,11 @@ ptr_t cold_gc_frame;\n \n      /* Mark thread local free lists, even if their mark \t*/\n      /* descriptor excludes the link field.\t\t\t*/\n+     /* If the world is not stopped, this is unsafe.  It is\t*/\n+     /* also unnecessary, since we will do this again with the\t*/\n+     /* world stopped.\t\t\t\t\t\t*/\n #      ifdef THREAD_LOCAL_ALLOC\n-         GC_mark_thread_local_free_lists();\n+         if (GC_world_stopped) GC_mark_thread_local_free_lists();\n #      endif\n \n     /*"}, {"sha": "56390280a718845293455066595083420c477f8f", "filename": "boehm-gc/mips_sgi_mach_dep.s", "status": "renamed", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmips_sgi_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmips_sgi_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmips_sgi_mach_dep.s?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,5 +1,10 @@\n #include <sys/regdef.h>\n #include <sys/asm.h>\n+/* This file must be preprocessed.  But the SGI assembler always does\t*/\n+/* that.  Furthermore, a generic preprocessor won't do, since some of\t*/\n+/* the SGI-supplied include files rely on behavior of the MIPS \t\t*/\n+/* assembler.  Hence we treat and name this file as though it required\t*/\n+/* no preprocessing.\t\t\t\t\t\t\t*/\n \n # define call_push(x)     move    $4,x;    jal     GC_push_one\n ", "previous_filename": "boehm-gc/mips_sgi_mach_dep.S"}, {"sha": "814fa41ab2497189bc801856831b73833eae2313", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 116, "deletions": 130, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -46,8 +46,10 @@\n #\tifdef GC_SOLARIS_THREADS\n \t  mutex_t GC_allocate_ml;\t/* Implicitly initialized.\t*/\n #\telse\n-#          ifdef GC_WIN32_THREADS\n-#\t      if !defined(GC_NOT_DLL) && (defined(_DLL) || defined(GC_DLL))\n+#          if defined(GC_WIN32_THREADS) \n+#             if defined(GC_PTHREADS)\n+\t\t  pthread_mutex_t GC_allocate_ml = PTHREAD_MUTEX_INITIALIZER;\n+#\t      elif defined(GC_DLL)\n \t\t __declspec(dllexport) CRITICAL_SECTION GC_allocate_ml;\n #\t      else\n \t\t CRITICAL_SECTION GC_allocate_ml;\n@@ -75,8 +77,8 @@\n #undef STACKBASE\n #endif\n \n-/* Dont unnecessarily call GC_register_main_static_data() in case      */\n-/* dyn_load.c isn't linked in.                                         */\n+/* Dont unnecessarily call GC_register_main_static_data() in case \t*/\n+/* dyn_load.c isn't linked in.\t\t\t\t\t\t*/\n #ifdef DYNAMIC_LOADING\n # define GC_REGISTER_MAIN_STATIC_DATA() GC_register_main_static_data()\n #else\n@@ -90,6 +92,7 @@ GC_bool GC_debugging_started = FALSE;\n \t/* defined here so we don't have to load debug_malloc.o */\n \n void (*GC_check_heap) GC_PROTO((void)) = (void (*) GC_PROTO((void)))0;\n+void (*GC_print_all_smashed) GC_PROTO((void)) = (void (*) GC_PROTO((void)))0;\n \n void (*GC_start_call_back) GC_PROTO((void)) = (void (*) GC_PROTO((void)))0;\n \n@@ -109,6 +112,10 @@ GC_bool GC_print_stats = 0;\n \n GC_bool GC_print_back_height = 0;\n \n+#ifndef NO_DEBUGGING\n+  GC_bool GC_dump_regularly = 0;  /* Generate regular debugging dumps. */\n+#endif\n+\n #ifdef FIND_LEAK\n   int GC_find_leak = 1;\n #else\n@@ -137,6 +144,13 @@ GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested)) = GC_default_oom_fn;\n \n extern signed_word GC_mem_found;\n \n+void * GC_project2(arg1, arg2)\n+void *arg1;\n+void *arg2;\n+{\n+  return arg2;\n+}\n+\n # ifdef MERGE_SIZES\n     /* Set things up so that GC_size_map[i] >= words(i),\t\t*/\n     /* but not too much bigger\t\t\t\t\t\t*/\n@@ -455,7 +469,7 @@ void GC_init()\n     \n     DISABLE_SIGNALS();\n \n-#ifdef MSWIN32\n+#if defined(GC_WIN32_THREADS) && !defined(GC_PTHREADS)\n     if (!GC_is_initialized) InitializeCriticalSection(&GC_allocate_ml);\n #endif /* MSWIN32 */\n \n@@ -473,6 +487,15 @@ void GC_init()\n \t  GC_init_parallel();\n \t}\n #   endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */\n+\n+#   if defined(DYNAMIC_LOADING) && defined(DARWIN)\n+    {\n+        /* This must be called WITHOUT the allocation lock held\n+        and before any threads are created */\n+        extern void GC_init_dyld();\n+        GC_init_dyld();\n+    }\n+#   endif\n }\n \n #if defined(MSWIN32) || defined(MSWINCE)\n@@ -485,6 +508,22 @@ void GC_init()\n \n extern void GC_setpagesize();\n \n+\n+#ifdef MSWIN32\n+extern GC_bool GC_no_win32_dlls;\n+#else\n+# define GC_no_win32_dlls FALSE\n+#endif\n+\n+void GC_exit_check GC_PROTO((void))\n+{\n+   GC_gcollect();\n+}\n+\n+#ifdef SEARCH_FOR_DATA_START\n+  extern void GC_init_linux_data_start GC_PROTO((void));\n+#endif\n+\n #ifdef UNIX_LIKE\n \n extern void GC_set_and_save_fault_handler GC_PROTO((void (*handler)(int)));\n@@ -495,12 +534,23 @@ int sig;\n     GC_err_printf1(\"Caught signal %d: looping in handler\\n\", sig);\n     for(;;);\n }\n-#endif\n \n-#ifdef MSWIN32\n-extern GC_bool GC_no_win32_dlls;\n-#else\n-# define GC_no_win32_dlls FALSE\n+static GC_bool installed_looping_handler = FALSE;\n+\n+void maybe_install_looping_handler()\n+{\n+    /* Install looping handler before the write fault handler, so we\t*/\n+    /* handle write faults correctly.\t\t\t\t\t*/\n+      if (!installed_looping_handler && 0 != GETENV(\"GC_LOOP_ON_ABORT\")) {\n+        GC_set_and_save_fault_handler(looping_handler);\n+        installed_looping_handler = TRUE;\n+      }\n+}\n+\n+#else /* !UNIX_LIKE */\n+\n+# define maybe_install_looping_handler()\n+\n #endif\n \n void GC_init_inner()\n@@ -515,14 +565,21 @@ void GC_init_inner()\n       GC_print_stats = 1;\n #   endif\n #   if defined(MSWIN32) || defined(MSWINCE)\n-\tInitializeCriticalSection(&GC_write_cs);\n+      InitializeCriticalSection(&GC_write_cs);\n #   endif\n-\n     if (0 != GETENV(\"GC_PRINT_STATS\")) {\n       GC_print_stats = 1;\n     } \n+#   ifndef NO_DEBUGGING\n+      if (0 != GETENV(\"GC_DUMP_REGULARLY\")) {\n+        GC_dump_regularly = 1;\n+      }\n+#   endif\n     if (0 != GETENV(\"GC_FIND_LEAK\")) {\n       GC_find_leak = 1;\n+#     ifdef __STDC__\n+        atexit(GC_exit_check);\n+#     endif\n     }\n     if (0 != GETENV(\"GC_ALL_INTERIOR_POINTERS\")) {\n       GC_all_interior_pointers = 1;\n@@ -560,11 +617,7 @@ void GC_init_inner()\n         }\n       }\n     }\n-#   ifdef UNIX_LIKE\n-      if (0 != GETENV(\"GC_LOOP_ON_ABORT\")) {\n-        GC_set_and_save_fault_handler(looping_handler);\n-      }\n-#   endif\n+    maybe_install_looping_handler();\n     /* Adjust normal object descriptor for extra allocation.\t*/\n     if (ALIGNMENT > GC_DS_TAGS && EXTRA_BYTES != 0) {\n       GC_obj_kinds[NORMAL].ok_descriptor = ((word)(-ALIGNMENT) | GC_DS_LENGTH);\n@@ -599,11 +652,21 @@ void GC_init_inner()\n #       if defined(LINUX) && defined(IA64)\n \t  GC_register_stackbottom = GC_get_register_stack_base();\n #       endif\n+      } else {\n+#       if defined(LINUX) && defined(IA64)\n+\t  if (GC_register_stackbottom == 0) {\n+\t    WARN(\"GC_register_stackbottom should be set with GC_stackbottom\", 0);\n+\t    /* The following is likely to fail, since we rely on \t*/\n+\t    /* alignment properties that may not hold with a user set\t*/\n+\t    /* GC_stackbottom.\t\t\t\t\t\t*/\n+\t    GC_register_stackbottom = GC_get_register_stack_base();\n+\t  }\n+#\tendif\n       }\n #   endif\n-    GC_ASSERT(sizeof (ptr_t) == sizeof(word));\n-    GC_ASSERT(sizeof (signed_word) == sizeof(word));\n-    GC_ASSERT(sizeof (struct hblk) == HBLKSIZE);\n+    GC_STATIC_ASSERT(sizeof (ptr_t) == sizeof(word));\n+    GC_STATIC_ASSERT(sizeof (signed_word) == sizeof(word));\n+    GC_STATIC_ASSERT(sizeof (struct hblk) == HBLKSIZE);\n #   ifndef THREADS\n #     if defined(STACK_GROWS_UP) && defined(STACK_GROWS_DOWN)\n   \tABORT(\n@@ -642,6 +705,18 @@ void GC_init_inner()\n \t  initial_heap_sz = divHBLKSZ(initial_heap_sz);\n \t}\n     }\n+    {\n+\tchar * sz_str = GETENV(\"GC_MAXIMUM_HEAP_SIZE\");\n+\tif (sz_str != NULL) {\n+\t  word max_heap_sz = (word)atol(sz_str);\n+\t  if (max_heap_sz < initial_heap_sz * HBLKSIZE) {\n+\t    WARN(\"Bad maximum heap size %s - ignoring it.\\n\",\n+\t\t sz_str);\n+\t  } \n+\t  if (0 == GC_max_retries) GC_max_retries = 2;\n+\t  GC_set_max_heap_size(max_heap_sz);\n+\t}\n+    }\n     if (!GC_expand_hp_inner(initial_heap_sz)) {\n         GC_err_printf0(\"Can't start up: not enough memory\\n\");\n         EXIT();\n@@ -677,6 +752,7 @@ void GC_init_inner()\n     \tGC_incremental = TRUE;\n       }\n #   endif /* !SMALL_CONFIG */\n+    COND_DUMP;\n     /* Get black list set up and/or incrmental GC started */\n       if (!GC_dont_precollect || GC_incremental) GC_gcollect_inner();\n     GC_is_initialized = TRUE;\n@@ -712,8 +788,9 @@ void GC_enable_incremental GC_PROTO(())\n     if (GC_incremental) goto out;\n     GC_setpagesize();\n     if (GC_no_win32_dlls) goto out;\n-#   ifndef GC_SOLARIS_THREADS\n-        GC_dirty_init();\n+#   ifndef GC_SOLARIS_THREADS \n+      maybe_install_looping_handler();  /* Before write fault handler! */\n+      GC_dirty_init();\n #   endif\n     if (!GC_is_initialized) {\n         GC_init_inner();\n@@ -932,6 +1009,17 @@ GC_warn_proc GC_current_warn_proc = GC_default_warn_proc;\n     return(result);\n }\n \n+# if defined(__STDC__) || defined(__cplusplus)\n+    GC_word GC_set_free_space_divisor (GC_word value)\n+# else\n+    GC_word GC_set_free_space_divisor (value)\n+    GC_word value;\n+# endif\n+{\n+    GC_word old = GC_free_space_divisor;\n+    GC_free_space_divisor = value;\n+    return old;\n+}\n \n #ifndef PCR\n void GC_abort(msg)\n@@ -958,122 +1046,18 @@ GC_CONST char * msg;\n }\n #endif\n \n-#ifdef NEED_CALLINFO\n-\n-#ifdef HAVE_BUILTIN_BACKTRACE\n-# include <execinfo.h>\n-# ifdef LINUX\n-#   include <unistd.h>\n-# endif\n-#endif\n-\n-void GC_print_callers (info)\n-struct callinfo info[NFRAMES];\n-{\n-    register int i;\n-    \n-#   if NFRAMES == 1\n-      GC_err_printf0(\"\\tCaller at allocation:\\n\");\n-#   else\n-      GC_err_printf0(\"\\tCall chain at allocation:\\n\");\n-#   endif\n-    for (i = 0; i < NFRAMES; i++) {\n-     \tif (info[i].ci_pc == 0) break;\n-#\tif NARGS > 0\n-\t{\n-\t  int j;\n-\n-     \t  GC_err_printf0(\"\\t\\targs: \");\n-     \t  for (j = 0; j < NARGS; j++) {\n-     \t    if (j != 0) GC_err_printf0(\", \");\n-     \t    GC_err_printf2(\"%d (0x%X)\", ~(info[i].ci_arg[j]),\n-     \t    \t\t\t\t~(info[i].ci_arg[j]));\n-     \t  }\n-\t  GC_err_printf0(\"\\n\");\n-\t}\n-# \tendif\n-#\tif defined(HAVE_BUILTIN_BACKTRACE) && !defined(REDIRECT_MALLOC)\n-\t  /* Unfortunately backtrace_symbols calls malloc, which makes  */\n-\t  /* it dangersous if that has been redirected.\t\t\t*/\n-\t  {\n-\t    char **sym_name =\n-\t      backtrace_symbols((void **)(&(info[i].ci_pc)), 1);\n-\t    char *name = sym_name[0];\n-\t    GC_bool found_it = (strchr(name, '(') != 0);\n-\t    FILE *pipe;\n-#\t    ifdef LINUX\n-\t      if (!found_it) {\n-#\t        define EXE_SZ 100\n-\t\tstatic char exe_name[EXE_SZ];\n-#\t\tdefine CMD_SZ 200\n-\t\tchar cmd_buf[CMD_SZ];\n-#\t\tdefine RESULT_SZ 200\n-\t\tstatic char result_buf[RESULT_SZ];\n-\t\tsize_t result_len;\n-\t\tstatic GC_bool found_exe_name = FALSE;\n-\t\tstatic GC_bool will_fail = FALSE;\n-\t\tint ret_code;\n-\t\t/* Unfortunately, this is the common case for the \t*/\n-\t\t/* main executable.\t\t\t\t\t*/\n-\t\t/* Try to get it via a hairy and expensive scheme.\t*/\n-\t\t/* First we get the name of the executable:\t\t*/\n-\t\tif (will_fail) goto out;\n-\t\tif (!found_exe_name) { \n-\t\t  ret_code = readlink(\"/proc/self/exe\", exe_name, EXE_SZ);\n-\t\t  if (ret_code < 0 || ret_code >= EXE_SZ || exe_name[0] != '/') {\n-\t\t    will_fail = TRUE;\t/* Dont try again. */\n-\t\t    goto out;\n-\t\t  }\n-\t\t  exe_name[ret_code] = '\\0';\n-\t\t  found_exe_name = TRUE;\n-\t\t}\n-\t\t/* Then we use popen to start addr2line -e <exe> <addr>\t*/\n-\t\t/* There are faster ways to do this, but hopefully this\t*/\n-\t\t/* isn't time critical.\t\t\t\t\t*/\n-\t\tsprintf(cmd_buf, \"/usr/bin/addr2line -e %s 0x%lx\", exe_name,\n-\t\t\t\t (unsigned long)info[i].ci_pc);\n-\t\tpipe = popen(cmd_buf, \"r\");\n-\t\tif (pipe < 0 || fgets(result_buf, RESULT_SZ, pipe) == 0) {\n-\t\t  will_fail = TRUE;\n-\t\t  goto out;\n-\t\t}\n-\t\tresult_len = strlen(result_buf);\n-\t\tif (result_buf[result_len - 1] == '\\n') --result_len;\n-\t\tif (result_buf[0] == '?'\n-\t\t    || result_buf[result_len-2] == ':' \n-\t\t       && result_buf[result_len-1] == '0')\n-\t\t    goto out;\n-\t\tif (result_len < RESULT_SZ - 25) {\n-\t\t  /* Add in hex address\t*/\n-\t\t    sprintf(result_buf + result_len, \" [0x%lx]\",\n-\t\t\t  (unsigned long)info[i].ci_pc);\n-\t\t}\n-\t\tname = result_buf;\n-\t\tpclose(pipe);\n-\t\tout:\n-\t      }\n-#\t    endif\n-\t    GC_err_printf1(\"\\t\\t%s\\n\", name);\n-\t    free(sym_name);\n-\t  }\n-#\telse\n-     \t  GC_err_printf1(\"\\t\\t##PC##= 0x%lx\\n\", info[i].ci_pc);\n-#\tendif\n-    }\n-}\n-\n-#endif /* SAVE_CALL_CHAIN */\n-\n-/* Needed by SRC_M3, gcj, and should perhaps be the official interface\t*/\n-/* to GC_dont_gc.\t\t\t\t\t\t\t*/\n void GC_enable()\n {\n+    LOCK();\n     GC_dont_gc--;\n+    UNLOCK();\n }\n \n void GC_disable()\n {\n+    LOCK();\n     GC_dont_gc++;\n+    UNLOCK();\n }\n \n #if !defined(NO_DEBUGGING)\n@@ -1088,6 +1072,8 @@ void GC_dump()\n     GC_print_hblkfreelist();\n     GC_printf0(\"\\n***Blocks in use:\\n\");\n     GC_print_block_list();\n+    GC_printf0(\"\\n***Finalization statistics:\\n\");\n+    GC_print_finalization_stats();\n }\n \n #endif /* NO_DEBUGGING */"}, {"sha": "dd583709f535918128e0f8d3b6a4fddf64c87cec", "filename": "boehm-gc/missing", "status": "removed", "additions": 0, "deletions": 336, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fmissing", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fmissing", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmissing?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,336 +0,0 @@\n-#! /bin/sh\n-# Common stub for a few missing GNU programs while installing.\n-# Copyright 1996, 1997, 1999, 2000 Free Software Foundation, Inc.\n-# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# As a special exception to the GNU General Public License, if you\n-# distribute this file as part of a program that contains a\n-# configuration script generated by Autoconf, you may include it under\n-# the same distribution terms that you use for the rest of that program.\n-\n-if test $# -eq 0; then\n-  echo 1>&2 \"Try \\`$0 --help' for more information\"\n-  exit 1\n-fi\n-\n-run=:\n-\n-# In the cases where this matters, `missing' is being run in the\n-# srcdir already.\n-if test -f configure.ac; then\n-  configure_ac=configure.ac\n-else\n-  configure_ac=configure.in\n-fi\n-\n-case \"$1\" in\n---run)\n-  # Try to run requested program, and just exit if it succeeds.\n-  run=\n-  shift\n-  \"$@\" && exit 0\n-  ;;\n-esac\n-\n-# If it does not exist, or fails to run (possibly an outdated version),\n-# try to emulate it.\n-case \"$1\" in\n-\n-  -h|--h|--he|--hel|--help)\n-    echo \"\\\n-$0 [OPTION]... PROGRAM [ARGUMENT]...\n-\n-Handle \\`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an\n-error status if there is no known handling for PROGRAM.\n-\n-Options:\n-  -h, --help      display this help and exit\n-  -v, --version   output version information and exit\n-  --run           try to run the given command, and emulate it if it fails\n-\n-Supported PROGRAM values:\n-  aclocal      touch file \\`aclocal.m4'\n-  autoconf     touch file \\`configure'\n-  autoheader   touch file \\`config.h.in'\n-  automake     touch all \\`Makefile.in' files\n-  bison        create \\`y.tab.[ch]', if possible, from existing .[ch]\n-  flex         create \\`lex.yy.c', if possible, from existing .c\n-  help2man     touch the output file\n-  lex          create \\`lex.yy.c', if possible, from existing .c\n-  makeinfo     touch the output file\n-  tar          try tar, gnutar, gtar, then tar without non-portable flags\n-  yacc         create \\`y.tab.[ch]', if possible, from existing .[ch]\"\n-    ;;\n-\n-  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)\n-    echo \"missing 0.4 - GNU automake\"\n-    ;;\n-\n-  -*)\n-    echo 1>&2 \"$0: Unknown \\`$1' option\"\n-    echo 1>&2 \"Try \\`$0 --help' for more information\"\n-    exit 1\n-    ;;\n-\n-  aclocal*)\n-    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n-       # We have it, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified \\`acinclude.m4' or \\`${configure_ac}'.  You might want\n-         to install the \\`Automake' and \\`Perl' packages.  Grab them from\n-         any GNU archive site.\"\n-    touch aclocal.m4\n-    ;;\n-\n-  autoconf)\n-    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n-       # We have it, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified \\`${configure_ac}'.  You might want to install the\n-         \\`Autoconf' and \\`GNU m4' packages.  Grab them from any GNU\n-         archive site.\"\n-    touch configure\n-    ;;\n-\n-  autoheader)\n-    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n-       # We have it, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified \\`acconfig.h' or \\`${configure_ac}'.  You might want\n-         to install the \\`Autoconf' and \\`GNU m4' packages.  Grab them\n-         from any GNU archive site.\"\n-    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\\([^)]*\\)).*/\\1/p' ${configure_ac}`\n-    test -z \"$files\" && files=\"config.h\"\n-    touch_files=\n-    for f in $files; do\n-      case \"$f\" in\n-      *:*) touch_files=\"$touch_files \"`echo \"$f\" |\n-\t\t\t\t       sed -e 's/^[^:]*://' -e 's/:.*//'`;;\n-      *) touch_files=\"$touch_files $f.in\";;\n-      esac\n-    done\n-    touch $touch_files\n-    ;;\n-\n-  automake*)\n-    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n-       # We have it, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified \\`Makefile.am', \\`acinclude.m4' or \\`${configure_ac}'.\n-         You might want to install the \\`Automake' and \\`Perl' packages.\n-         Grab them from any GNU archive site.\"\n-    find . -type f -name Makefile.am -print |\n-\t   sed 's/\\.am$/.in/' |\n-\t   while read f; do touch \"$f\"; done\n-    ;;\n-\n-  autom4te)\n-    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n-       # We have it, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is needed, and you do not seem to have it handy on your\n-         system.  You might have modified some files without having the\n-         proper tools for further handling them.\n-         You can get \\`$1Help2man' as part of \\`Autoconf' from any GNU\n-         archive site.\"\n-\n-    file=`echo \"$*\" | sed -n 's/.*--output[ =]*\\([^ ]*\\).*/\\1/p'`\n-    test -z \"$file\" && file=`echo \"$*\" | sed -n 's/.*-o[ ]*\\([^ ]*\\).*/\\1/p'`\n-    if test -f \"$file\"; then\n-\ttouch $file\n-    else\n-\ttest -z \"$file\" || exec >$file\n-\techo \"#! /bin/sh\"\n-\techo \"# Created by GNU Automake missing as a replacement of\"\n-\techo \"#  $ $@\"\n-\techo \"exit 0\"\n-\tchmod +x $file\n-\texit 1\n-    fi\n-    ;;\n-\n-  bison|yacc)\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified a \\`.y' file.  You may need the \\`Bison' package\n-         in order for those modifications to take effect.  You can get\n-         \\`Bison' from any GNU archive site.\"\n-    rm -f y.tab.c y.tab.h\n-    if [ $# -ne 1 ]; then\n-        eval LASTARG=\"\\${$#}\"\n-\tcase \"$LASTARG\" in\n-\t*.y)\n-\t    SRCFILE=`echo \"$LASTARG\" | sed 's/y$/c/'`\n-\t    if [ -f \"$SRCFILE\" ]; then\n-\t         cp \"$SRCFILE\" y.tab.c\n-\t    fi\n-\t    SRCFILE=`echo \"$LASTARG\" | sed 's/y$/h/'`\n-\t    if [ -f \"$SRCFILE\" ]; then\n-\t         cp \"$SRCFILE\" y.tab.h\n-\t    fi\n-\t  ;;\n-\tesac\n-    fi\n-    if [ ! -f y.tab.h ]; then\n-\techo >y.tab.h\n-    fi\n-    if [ ! -f y.tab.c ]; then\n-\techo 'main() { return 0; }' >y.tab.c\n-    fi\n-    ;;\n-\n-  lex|flex)\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified a \\`.l' file.  You may need the \\`Flex' package\n-         in order for those modifications to take effect.  You can get\n-         \\`Flex' from any GNU archive site.\"\n-    rm -f lex.yy.c\n-    if [ $# -ne 1 ]; then\n-        eval LASTARG=\"\\${$#}\"\n-\tcase \"$LASTARG\" in\n-\t*.l)\n-\t    SRCFILE=`echo \"$LASTARG\" | sed 's/l$/c/'`\n-\t    if [ -f \"$SRCFILE\" ]; then\n-\t         cp \"$SRCFILE\" lex.yy.c\n-\t    fi\n-\t  ;;\n-\tesac\n-    fi\n-    if [ ! -f lex.yy.c ]; then\n-\techo 'main() { return 0; }' >lex.yy.c\n-    fi\n-    ;;\n-\n-  help2man)\n-    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n-       # We have it, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-\t you modified a dependency of a manual page.  You may need the\n-\t \\`Help2man' package in order for those modifications to take\n-\t effect.  You can get \\`Help2man' from any GNU archive site.\"\n-\n-    file=`echo \"$*\" | sed -n 's/.*-o \\([^ ]*\\).*/\\1/p'`\n-    if test -z \"$file\"; then\n-\tfile=`echo \"$*\" | sed -n 's/.*--output=\\([^ ]*\\).*/\\1/p'`\n-    fi\n-    if [ -f \"$file\" ]; then\n-\ttouch $file\n-    else\n-\ttest -z \"$file\" || exec >$file\n-\techo \".ab help2man is required to generate this page\"\n-\texit 1\n-    fi\n-    ;;\n-\n-  makeinfo)\n-    if test -z \"$run\" && (makeinfo --version) > /dev/null 2>&1; then\n-       # We have makeinfo, but it failed.\n-       exit 1\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is missing on your system.  You should only need it if\n-         you modified a \\`.texi' or \\`.texinfo' file, or any other file\n-         indirectly affecting the aspect of the manual.  The spurious\n-         call might also be the consequence of using a buggy \\`make' (AIX,\n-         DU, IRIX).  You might want to install the \\`Texinfo' package or\n-         the \\`GNU make' package.  Grab either from any GNU archive site.\"\n-    file=`echo \"$*\" | sed -n 's/.*-o \\([^ ]*\\).*/\\1/p'`\n-    if test -z \"$file\"; then\n-      file=`echo \"$*\" | sed 's/.* \\([^ ]*\\) *$/\\1/'`\n-      file=`sed -n '/^@setfilename/ { s/.* \\([^ ]*\\) *$/\\1/; p; q; }' $file`\n-    fi\n-    touch $file\n-    ;;\n-\n-  tar)\n-    shift\n-    if test -n \"$run\"; then\n-      echo 1>&2 \"ERROR: \\`tar' requires --run\"\n-      exit 1\n-    fi\n-\n-    # We have already tried tar in the generic part.\n-    # Look for gnutar/gtar before invocation to avoid ugly error\n-    # messages.\n-    if (gnutar --version > /dev/null 2>&1); then\n-       gnutar ${1+\"$@\"} && exit 0\n-    fi\n-    if (gtar --version > /dev/null 2>&1); then\n-       gtar ${1+\"$@\"} && exit 0\n-    fi\n-    firstarg=\"$1\"\n-    if shift; then\n-\tcase \"$firstarg\" in\n-\t*o*)\n-\t    firstarg=`echo \"$firstarg\" | sed s/o//`\n-\t    tar \"$firstarg\" ${1+\"$@\"} && exit 0\n-\t    ;;\n-\tesac\n-\tcase \"$firstarg\" in\n-\t*h*)\n-\t    firstarg=`echo \"$firstarg\" | sed s/h//`\n-\t    tar \"$firstarg\" ${1+\"$@\"} && exit 0\n-\t    ;;\n-\tesac\n-    fi\n-\n-    echo 1>&2 \"\\\n-WARNING: I can't seem to be able to run \\`tar' with the given arguments.\n-         You may want to install GNU tar or Free paxutils, or check the\n-         command line arguments.\"\n-    exit 1\n-    ;;\n-\n-  *)\n-    echo 1>&2 \"\\\n-WARNING: \\`$1' is needed, and you do not seem to have it handy on your\n-         system.  You might have modified some files without having the\n-         proper tools for further handling them.  Check the \\`README' file,\n-         it often tells you about the needed prerequirements for installing\n-         this package.  You may also peek at any GNU archive site, in case\n-         some other package would contain this missing \\`$1' program.\"\n-    exit 1\n-    ;;\n-esac\n-\n-exit 0"}, {"sha": "fecda89db777ee72302dc5cdd1f1f91b15cfd637", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 1176, "deletions": 296, "changes": 1472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -80,6 +80,13 @@\n #   define NEED_FIND_LIMIT\n # endif\n \n+#if defined(FREEBSD) && defined(I386)\n+#  include <machine/trap.h>\n+#  if !defined(PCR)\n+#    define NEED_FIND_LIMIT\n+#  endif\n+#endif\n+\n #ifdef NEED_FIND_LIMIT\n #   include <setjmp.h>\n #endif\n@@ -129,6 +136,11 @@\n # define jmp_buf sigjmp_buf\n #endif\n \n+#ifdef DARWIN\n+/* for get_etext and friends */\n+#include <mach-o/getsect.h>\n+#endif\n+\n #ifdef DJGPP\n   /* Apparently necessary for djgpp 2.01.  May cause problems with\t*/\n   /* other versions.\t\t\t\t\t\t\t*/\n@@ -147,13 +159,168 @@\n # define OPT_PROT_EXEC 0\n #endif\n \n+#if defined(LINUX) && \\\n+    (defined(USE_PROC_FOR_LIBRARIES) || defined(IA64) || !defined(SMALL_CONFIG))\n+\n+/* We need to parse /proc/self/maps, either to find dynamic libraries,\t*/\n+/* and/or to find the register backing store base (IA64).  Do it once\t*/\n+/* here.\t\t\t\t\t\t\t\t*/\n+\n+#define READ read\n+\n+/* Repeatedly perform a read call until the buffer is filled or\t*/\n+/* we encounter EOF.\t\t\t\t\t\t*/\n+ssize_t GC_repeat_read(int fd, char *buf, size_t count)\n+{\n+    ssize_t num_read = 0;\n+    ssize_t result;\n+    \n+    while (num_read < count) {\n+\tresult = READ(fd, buf + num_read, count - num_read);\n+\tif (result < 0) return result;\n+\tif (result == 0) break;\n+\tnum_read += result;\n+    }\n+    return num_read;\n+}\n+\n+/*\n+ * Apply fn to a buffer containing the contents of /proc/self/maps.\n+ * Return the result of fn or, if we failed, 0.\n+ */\n+\n+word GC_apply_to_maps(word (*fn)(char *))\n+{\n+    int f;\n+    int result;\n+    int maps_size;\n+    char maps_temp[32768];\n+    char *maps_buf;\n+\n+    /* Read /proc/self/maps\t*/\n+        /* Note that we may not allocate, and thus can't use stdio.\t*/\n+        f = open(\"/proc/self/maps\", O_RDONLY);\n+        if (-1 == f) return 0;\n+\t/* stat() doesn't work for /proc/self/maps, so we have to\n+\t   read it to find out how large it is... */\n+\tmaps_size = 0;\n+\tdo {\n+\t    result = GC_repeat_read(f, maps_temp, sizeof(maps_temp));\n+\t    if (result <= 0) return 0;\n+\t    maps_size += result;\n+\t} while (result == sizeof(maps_temp));\n+\n+\tif (maps_size > sizeof(maps_temp)) {\n+\t    /* If larger than our buffer, close and re-read it. */\n+\t    close(f);\n+\t    f = open(\"/proc/self/maps\", O_RDONLY);\n+\t    if (-1 == f) return 0;\n+\t    maps_buf = alloca(maps_size);\n+\t    if (NULL == maps_buf) return 0;\n+\t    result = GC_repeat_read(f, maps_buf, maps_size);\n+\t    if (result <= 0) return 0;\n+\t} else {\n+\t    /* Otherwise use the fixed size buffer */\n+\t    maps_buf = maps_temp;\n+\t}\n+\n+\tclose(f);\n+        maps_buf[result] = '\\0';\n+\t\n+    /* Apply fn to result. */\n+\treturn fn(maps_buf);\n+}\n+\n+#endif /* Need GC_apply_to_maps */\n+\n+#if defined(LINUX) && (defined(USE_PROC_FOR_LIBRARIES) || defined(IA64))\n+//\n+//  GC_parse_map_entry parses an entry from /proc/self/maps so we can\n+//  locate all writable data segments that belong to shared libraries.\n+//  The format of one of these entries and the fields we care about\n+//  is as follows:\n+//  XXXXXXXX-XXXXXXXX r-xp 00000000 30:05 260537     name of mapping...\\n\n+//  ^^^^^^^^ ^^^^^^^^ ^^^^          ^^\n+//  start    end      prot          maj_dev\n+//  0        9        18            32\n+//  \n+//  For 64 bit ABIs:\n+//  0\t     17\t      34\t    56\n+//\n+//  The parser is called with a pointer to the entry and the return value\n+//  is either NULL or is advanced to the next entry(the byte after the\n+//  trailing '\\n'.)\n+//\n+#if CPP_WORDSZ == 32\n+# define OFFSET_MAP_START   0\n+# define OFFSET_MAP_END     9\n+# define OFFSET_MAP_PROT   18\n+# define OFFSET_MAP_MAJDEV 32\n+# define ADDR_WIDTH \t    8\n+#endif\n+\n+#if CPP_WORDSZ == 64\n+# define OFFSET_MAP_START   0\n+# define OFFSET_MAP_END    17\n+# define OFFSET_MAP_PROT   34\n+# define OFFSET_MAP_MAJDEV 56\n+# define ADDR_WIDTH \t   16\n+#endif\n+\n+/*\n+ * Assign various fields of the first line in buf_ptr to *start, *end,\n+ * *prot_buf and *maj_dev.  Only *prot_buf may be set for unwritable maps.\n+ */\n+char *GC_parse_map_entry(char *buf_ptr, word *start, word *end,\n+                                char *prot_buf, unsigned int *maj_dev)\n+{\n+    int i;\n+    char *tok;\n+\n+    if (buf_ptr == NULL || *buf_ptr == '\\0') {\n+        return NULL;\n+    }\n+\n+    memcpy(prot_buf, buf_ptr+OFFSET_MAP_PROT, 4);\n+    \t\t\t\t/* do the protections first. */\n+    prot_buf[4] = '\\0';\n+\n+    if (prot_buf[1] == 'w') {/* we can skip all of this if it's not writable. */\n+\n+        tok = buf_ptr;\n+        buf_ptr[OFFSET_MAP_START+ADDR_WIDTH] = '\\0';\n+        *start = strtoul(tok, NULL, 16);\n+\n+        tok = buf_ptr+OFFSET_MAP_END;\n+        buf_ptr[OFFSET_MAP_END+ADDR_WIDTH] = '\\0';\n+        *end = strtoul(tok, NULL, 16);\n+\n+        buf_ptr += OFFSET_MAP_MAJDEV;\n+        tok = buf_ptr;\n+        while (*buf_ptr != ':') buf_ptr++;\n+        *buf_ptr++ = '\\0';\n+        *maj_dev = strtoul(tok, NULL, 16);\n+    }\n+\n+    while (*buf_ptr && *buf_ptr++ != '\\n');\n+\n+    return buf_ptr;\n+}\n+\n+#endif /* Need to parse /proc/self/maps. */\t\n+\n #if defined(SEARCH_FOR_DATA_START)\n   /* The I386 case can be handled without a search.  The Alpha case\t*/\n   /* used to be handled differently as well, but the rules changed\t*/\n   /* for recent Linux versions.  This seems to be the easiest way to\t*/\n   /* cover all versions.\t\t\t\t\t\t*/\n \n # ifdef LINUX\n+    /* Some Linux distributions arrange to define __data_start.  Some\t*/\n+    /* define data_start as a weak symbol.  The latter is technically\t*/\n+    /* broken, since the user program may define data_start, in which\t*/\n+    /* case we lose.  Nonetheless, we try both, prefering __data_start.\t*/\n+    /* We assume gcc-compatible pragmas.\t*/\n #   pragma weak __data_start\n     extern int __data_start[];\n #   pragma weak data_start\n@@ -169,16 +336,16 @@\n \n #   ifdef LINUX\n       /* Try the easy approaches first:\t*/\n-      if (__data_start != 0) {\n-\t  GC_data_start = (ptr_t)__data_start;\n+      if ((ptr_t)__data_start != 0) {\n+\t  GC_data_start = (ptr_t)(__data_start);\n \t  return;\n       }\n-      if (data_start != 0) {\n-\t  GC_data_start = (ptr_t)data_start;\n+      if ((ptr_t)data_start != 0) {\n+\t  GC_data_start = (ptr_t)(data_start);\n \t  return;\n       }\n #   endif /* LINUX */\n-    GC_data_start = GC_find_limit((ptr_t)_end, FALSE);\n+    GC_data_start = GC_find_limit((ptr_t)(_end), FALSE);\n   }\n #endif\n \n@@ -617,7 +784,8 @@ ptr_t GC_get_stack_base()\n     }\n \n     /* Return the first nonaddressible location > p (up) or \t*/\n-    /* the smallest location q s.t. [q,p] is addressible (!up).\t*/\n+    /* the smallest location q s.t. [q,p) is addressable (!up).\t*/\n+    /* We assume that p (up) or p-1 (!up) is addressable.\t*/\n     ptr_t GC_find_limit(p, up)\n     ptr_t p;\n     GC_bool up;\n@@ -650,18 +818,18 @@ ptr_t GC_get_stack_base()\n     }\n # endif\n \n-# if defined(ECOS) || defined(NOSYS)\n-ptr_t GC_get_stack_base()\n-{\n-  return STACKBOTTOM;\n-}\n-\n-#else\n+#if defined(ECOS) || defined(NOSYS)\n+  ptr_t GC_get_stack_base()\n+  {\n+    return STACKBOTTOM;\n+  }\n+#endif\n \n #ifdef LINUX_STACKBOTTOM\n \n #include <sys/types.h>\n #include <sys/stat.h>\n+#include <ctype.h>\n \n # define STAT_SKIP 27   /* Number of fields preceding startstack\t*/\n \t\t\t/* field in /proc/self/stat\t\t\t*/\n@@ -670,6 +838,33 @@ ptr_t GC_get_stack_base()\n   extern ptr_t __libc_stack_end;\n \n # ifdef IA64\n+    /* Try to read the backing store base from /proc/self/maps.\t*/\n+    /* We look for the writable mapping with a 0 major device,  */\n+    /* which is\tas close to our frame as possible, but below it.*/\n+    static word backing_store_base_from_maps(char *maps)\n+    {\n+      char prot_buf[5];\n+      char *buf_ptr = maps;\n+      word start, end;\n+      unsigned int maj_dev;\n+      word current_best = 0;\n+      word dummy;\n+  \n+      for (;;) {\n+        buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n+\tif (buf_ptr == NULL) return current_best;\n+\tif (prot_buf[1] == 'w' && maj_dev == 0) {\n+\t    if (end < (word)(&dummy) && start > current_best) current_best = start;\n+\t}\n+      }\n+      return current_best;\n+    }\n+\n+    static word backing_store_base_from_proc(void)\n+    {\n+        return GC_apply_to_maps(backing_store_base_from_maps);\n+    }\n+\n #   pragma weak __libc_ia64_register_backing_store_base\n     extern ptr_t __libc_ia64_register_backing_store_base;\n \n@@ -679,13 +874,19 @@ ptr_t GC_get_stack_base()\n \t  && 0 != __libc_ia64_register_backing_store_base) {\n \t/* Glibc 2.2.4 has a bug such that for dynamically linked\t*/\n \t/* executables __libc_ia64_register_backing_store_base is \t*/\n-\t/* defined but ininitialized during constructor calls.  \t*/\n+\t/* defined but uninitialized during constructor calls.  \t*/\n \t/* Hence we check for both nonzero address and value.\t\t*/\n \treturn __libc_ia64_register_backing_store_base;\n       } else {\n-\tword result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;\n-\tresult += BACKING_STORE_ALIGNMENT - 1;\n-\tresult &= ~(BACKING_STORE_ALIGNMENT - 1);\n+\tword result = backing_store_base_from_proc();\n+\tif (0 == result) {\n+\t  /* Use dumb heuristics.  Works only for default configuration. */\n+\t  result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;\n+\t  result += BACKING_STORE_ALIGNMENT - 1;\n+\t  result &= ~(BACKING_STORE_ALIGNMENT - 1);\n+\t  /* Verify that it's at least readable.  If not, we goofed. */\n+\t  GC_noop1(*(word *)result); \n+\t}\n \treturn (ptr_t)result;\n       }\n     }\n@@ -697,11 +898,8 @@ ptr_t GC_get_stack_base()\n     /* using direct I/O system calls in order to avoid calling malloc   */\n     /* in case REDIRECT_MALLOC is defined.\t\t\t\t*/ \n #   define STAT_BUF_SIZE 4096\n-#   if defined(GC_USE_LD_WRAP)\n-#\tdefine STAT_READ __real_read\n-#   else\n-#\tdefine STAT_READ read\n-#   endif    \n+#   define STAT_READ read\n+\t  /* Should probably call the real read, if read is wrapped.\t*/\n     char stat_buf[STAT_BUF_SIZE];\n     int f;\n     char c;\n@@ -710,7 +908,16 @@ ptr_t GC_get_stack_base()\n \n     /* First try the easy way.  This should work for glibc 2.2\t*/\n       if (0 != &__libc_stack_end) {\n-\treturn __libc_stack_end;\n+#       ifdef IA64\n+\t  /* Some versions of glibc set the address 16 bytes too\t*/\n+\t  /* low while the initialization code is running.\t\t*/\n+\t  if (((word)__libc_stack_end & 0xfff) + 0x10 < 0x1000) {\n+\t    return __libc_stack_end + 0x10;\n+\t  } /* Otherwise it's not safe to add 16 bytes and we fall\t*/\n+\t    /* back to using /proc.\t\t\t\t\t*/\n+#\telse \n+\t  return __libc_stack_end;\n+#\tendif\n       }\n     f = open(\"/proc/self/stat\", O_RDONLY);\n     if (f < 0 || STAT_READ(f, stat_buf, STAT_BUF_SIZE) < 2 * STAT_SKIP) {\n@@ -764,8 +971,11 @@ ptr_t GC_get_stack_base()\n \n ptr_t GC_get_stack_base()\n {\n+#   if defined(HEURISTIC1) || defined(HEURISTIC2) || \\\n+       defined(LINUX_STACKBOTTOM) || defined(FREEBSD_STACKBOTTOM)\n     word dummy;\n     ptr_t result;\n+#   endif\n \n #   define STACKBOTTOM_ALIGNMENT_M1 ((word)STACK_GRAN - 1)\n \n@@ -814,7 +1024,6 @@ ptr_t GC_get_stack_base()\n     \treturn(result);\n #   endif /* STACKBOTTOM */\n }\n-# endif /* NOSYS ECOS */\n \n # endif /* ! AMIGA, !OS 2, ! MS Windows, !BEOS */\n \n@@ -924,15 +1133,14 @@ void GC_register_data_segments()\n   /* Unfortunately, we have to handle win32s very differently from NT, \t*/\n   /* Since VirtualQuery has very different semantics.  In particular,\t*/\n   /* under win32s a VirtualQuery call on an unmapped page returns an\t*/\n-  /* invalid result.  Under GC_register_data_segments is a noop and\t*/\n+  /* invalid result.  Under NT, GC_register_data_segments is a noop and\t*/\n   /* all real work is done by GC_register_dynamic_libraries.  Under\t*/\n   /* win32s, we cannot find the data segments associated with dll's.\t*/\n-  /* We rgister the main data segment here.\t\t\t\t*/\n-#  ifdef __GCC__\n-  GC_bool GC_no_win32_dlls = TRUE;\t /* GCC can't do SEH, so we can't use VirtualQuery */\n-#  else\n+  /* We register the main data segment here.\t\t\t\t*/\n   GC_bool GC_no_win32_dlls = FALSE;\t \n-#  endif\n+  \t/* This used to be set for gcc, to avoid dealing with\t\t*/\n+  \t/* the structured exception handling issues.  But we now have\t*/\n+  \t/* assembly code to do that right.\t\t\t\t*/\n   \n   void GC_init_win32()\n   {\n@@ -964,36 +1172,102 @@ void GC_register_data_segments()\n     return(p);\n   }\n # endif\n+\n+# ifndef REDIRECT_MALLOC\n+  /* We maintain a linked list of AllocationBase values that we know\t*/\n+  /* correspond to malloc heap sections.  Currently this is only called */\n+  /* during a GC.  But there is some hope that for long running\t\t*/\n+  /* programs we will eventually see most heap sections.\t\t*/\n+\n+  /* In the long run, it would be more reliable to occasionally walk \t*/\n+  /* the malloc heap with HeapWalk on the default heap.  But that\t*/\n+  /* apparently works only for NT-based Windows. \t\t\t*/ \n+\n+  /* In the long run, a better data structure would also be nice ...\t*/\n+  struct GC_malloc_heap_list {\n+    void * allocation_base;\n+    struct GC_malloc_heap_list *next;\n+  } *GC_malloc_heap_l = 0;\n+\n+  /* Is p the base of one of the malloc heap sections we already know\t*/\n+  /* about?\t\t\t\t\t\t\t\t*/\n+  GC_bool GC_is_malloc_heap_base(ptr_t p)\n+  {\n+    struct GC_malloc_heap_list *q = GC_malloc_heap_l;\n+\n+    while (0 != q) {\n+      if (q -> allocation_base == p) return TRUE;\n+      q = q -> next;\n+    }\n+    return FALSE;\n+  }\n+\n+  void *GC_get_allocation_base(void *p)\n+  {\n+    MEMORY_BASIC_INFORMATION buf;\n+    DWORD result = VirtualQuery(p, &buf, sizeof(buf));\n+    if (result != sizeof(buf)) {\n+      ABORT(\"Weird VirtualQuery result\");\n+    }\n+    return buf.AllocationBase;\n+  }\n+\n+  size_t GC_max_root_size = 100000;\t/* Appr. largest root size.\t*/\n+\n+  void GC_add_current_malloc_heap()\n+  {\n+    struct GC_malloc_heap_list *new_l =\n+                 malloc(sizeof(struct GC_malloc_heap_list));\n+    void * candidate = GC_get_allocation_base(new_l);\n+\n+    if (new_l == 0) return;\n+    if (GC_is_malloc_heap_base(candidate)) {\n+      /* Try a little harder to find malloc heap.\t\t\t*/\n+\tsize_t req_size = 10000;\n+\tdo {\n+\t  void *p = malloc(req_size);\n+\t  if (0 == p) { free(new_l); return; }\n+ \t  candidate = GC_get_allocation_base(p);\n+\t  free(p);\n+\t  req_size *= 2;\n+\t} while (GC_is_malloc_heap_base(candidate)\n+\t         && req_size < GC_max_root_size/10 && req_size < 500000);\n+\tif (GC_is_malloc_heap_base(candidate)) {\n+\t  free(new_l); return;\n+\t}\n+    }\n+#   ifdef CONDPRINT\n+      if (GC_print_stats)\n+\t  GC_printf1(\"Found new system malloc AllocationBase at 0x%lx\\n\",\n+                     candidate);\n+#   endif\n+    new_l -> allocation_base = candidate;\n+    new_l -> next = GC_malloc_heap_l;\n+    GC_malloc_heap_l = new_l;\n+  }\n+# endif /* REDIRECT_MALLOC */\n   \n   /* Is p the start of either the malloc heap, or of one of our */\n   /* heap sections?\t\t\t\t\t\t*/\n   GC_bool GC_is_heap_base (ptr_t p)\n   {\n      \n-     register unsigned i;\n+     unsigned i;\n      \n #    ifndef REDIRECT_MALLOC\n-       static ptr_t malloc_heap_pointer = 0;\n+       static word last_gc_no = -1;\n      \n-       if (0 == malloc_heap_pointer) {\n-         MEMORY_BASIC_INFORMATION buf;\n-         void *pTemp = malloc( 1 );\n-         register DWORD result = VirtualQuery(pTemp, &buf, sizeof(buf));\n-           \n-         free( pTemp );\n-\n-         \n-         if (result != sizeof(buf)) {\n-             ABORT(\"Weird VirtualQuery result\");\n-         }\n-         malloc_heap_pointer = (ptr_t)(buf.AllocationBase);\n+       if (last_gc_no != GC_gc_no) {\n+\t GC_add_current_malloc_heap();\n+\t last_gc_no = GC_gc_no;\n        }\n-       if (p == malloc_heap_pointer) return(TRUE);\n+       if (GC_root_size > GC_max_root_size) GC_max_root_size = GC_root_size;\n+       if (GC_is_malloc_heap_base(p)) return TRUE;\n #    endif\n      for (i = 0; i < GC_n_heap_bases; i++) {\n-         if (GC_heap_bases[i] == p) return(TRUE);\n+         if (GC_heap_bases[i] == p) return TRUE;\n      }\n-     return(FALSE);\n+     return FALSE ;\n   }\n \n # ifdef MSWIN32\n@@ -1043,7 +1317,7 @@ void GC_register_data_segments()\n \n # if (defined(SVR4) || defined(AUX) || defined(DGUX) \\\n       || (defined(LINUX) && defined(SPARC))) && !defined(PCR)\n-char * GC_SysVGetDataStart(max_page_size, etext_addr)\n+ptr_t GC_SysVGetDataStart(max_page_size, etext_addr)\n int max_page_size;\n int * etext_addr;\n {\n@@ -1069,12 +1343,45 @@ int * etext_addr;\n     \t/* string constants in the text segment, but after etext.\t*/\n     \t/* Use plan B.  Note that we now know there is a gap between\t*/\n     \t/* text and data segments, so plan A bought us something.\t*/\n-    \tresult = (char *)GC_find_limit((ptr_t)(DATAEND) - MIN_PAGE_SIZE, FALSE);\n+    \tresult = (char *)GC_find_limit((ptr_t)(DATAEND), FALSE);\n     }\n-    return((char *)result);\n+    return((ptr_t)result);\n }\n # endif\n \n+# if defined(FREEBSD) && defined(I386) && !defined(PCR)\n+/* Its unclear whether this should be identical to the above, or \t*/\n+/* whether it should apply to non-X86 architectures.\t\t\t*/\n+/* For now we don't assume that there is always an empty page after\t*/\n+/* etext.  But in some cases there actually seems to be slightly more.  */\n+/* This also deals with holes between read-only data and writable data.\t*/\n+ptr_t GC_FreeBSDGetDataStart(max_page_size, etext_addr)\n+int max_page_size;\n+int * etext_addr;\n+{\n+    word text_end = ((word)(etext_addr) + sizeof(word) - 1)\n+\t\t     & ~(sizeof(word) - 1);\n+\t/* etext rounded to word boundary\t*/\n+    VOLATILE word next_page = (text_end + (word)max_page_size - 1)\n+\t\t\t      & ~((word)max_page_size - 1);\n+    VOLATILE ptr_t result = (ptr_t)text_end;\n+    GC_setup_temporary_fault_handler();\n+    if (setjmp(GC_jmp_buf) == 0) {\n+\t/* Try reading at the address.\t\t\t\t*/\n+\t/* This should happen before there is another thread.\t*/\n+\tfor (; next_page < (word)(DATAEND); next_page += (word)max_page_size)\n+\t    *(VOLATILE char *)next_page;\n+\tGC_reset_fault_handler();\n+    } else {\n+\tGC_reset_fault_handler();\n+\t/* As above, we go to plan B\t*/\n+\tresult = GC_find_limit((ptr_t)(DATAEND), FALSE);\n+    }\n+    return(result);\n+}\n+\n+# endif\n+\n \n #ifdef AMIGA\n \n@@ -1086,8 +1393,7 @@ int * etext_addr;\n \n void GC_register_data_segments()\n {\n-#   if !defined(PCR) && !defined(SRC_M3) && !defined(NEXT) && !defined(MACOS) \\\n-       && !defined(MACOSX)\n+#   if !defined(PCR) && !defined(SRC_M3) && !defined(MACOS)\n #     if defined(REDIRECT_MALLOC) && defined(GC_SOLARIS_THREADS)\n \t/* As of Solaris 2.3, the Solaris threads implementation\t*/\n \t/* allocates the data structure for the initial thread with\t*/\n@@ -1104,9 +1410,6 @@ void GC_register_data_segments()\n #       endif\n #     endif\n #   endif\n-#   if !defined(PCR) && (defined(NEXT) || defined(MACOSX))\n-      GC_add_roots_inner(DATASTART, (char *) get_end(), FALSE);\n-#   endif\n #   if defined(MACOS)\n     {\n #   if defined(THINK_C)\n@@ -1216,18 +1519,28 @@ word bytes;\n ptr_t GC_unix_get_mem(bytes)\n word bytes;\n {\n-    static GC_bool initialized = FALSE;\n-    static int fd;\n     void *result;\n     static ptr_t last_addr = HEAP_START;\n \n-    if (!initialized) {\n-\tfd = open(\"/dev/zero\", O_RDONLY);\n-\tinitialized = TRUE;\n-    }\n+#   ifndef USE_MMAP_ANON\n+      static GC_bool initialized = FALSE;\n+      static int fd;\n+\n+      if (!initialized) {\n+\t  fd = open(\"/dev/zero\", O_RDONLY);\n+\t  fcntl(fd, F_SETFD, FD_CLOEXEC);\n+\t  initialized = TRUE;\n+      }\n+#   endif\n+\n     if (bytes & (GC_page_size -1)) ABORT(\"Bad GET_MEM arg\");\n-    result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n-\t\t  GC_MMAP_FLAGS, fd, 0/* offset */);\n+#   ifdef USE_MMAP_ANON\n+      result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n+\t\t    GC_MMAP_FLAGS | MAP_ANON, -1, 0/* offset */);\n+#   else\n+      result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n+\t\t    GC_MMAP_FLAGS, fd, 0/* offset */);\n+#   endif\n     if (result == MAP_FAILED) return(0);\n     last_addr = (ptr_t)result + bytes + GC_page_size - 1;\n     last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));\n@@ -1322,7 +1635,15 @@ word bytes;\n         result = (ptr_t) GlobalAlloc(0, bytes + HBLKSIZE);\n         result = (ptr_t)(((word)result + HBLKSIZE) & ~(HBLKSIZE-1));\n     } else {\n-        result = (ptr_t) VirtualAlloc(NULL, bytes,\n+\t/* VirtualProtect only works on regions returned by a\t*/\n+\t/* single VirtualAlloc call.  Thus we allocate one \t*/\n+\t/* extra page, which will prevent merging of blocks\t*/\n+\t/* in separate regions, and eliminate any temptation\t*/\n+\t/* to call VirtualProtect on a range spanning regions.\t*/\n+\t/* This wastes a small amount of memory, and risks\t*/\n+\t/* increased fragmentation.  But better alternatives\t*/\n+\t/* would require effort.\t\t\t\t*/\n+        result = (ptr_t) VirtualAlloc(NULL, bytes + 1,\n     \t\t\t\t      MEM_COMMIT | MEM_RESERVE,\n     \t\t\t\t      PAGE_EXECUTE_READWRITE);\n     }\n@@ -1378,6 +1699,10 @@ word bytes;\n \t/* Reserve more pages */\n \tword res_bytes = (bytes + GC_sysinfo.dwAllocationGranularity-1)\n \t\t\t & ~(GC_sysinfo.dwAllocationGranularity-1);\n+\t/* If we ever support MPROTECT_VDB here, we will probably need to\t*/\n+\t/* ensure that res_bytes is strictly > bytes, so that VirtualProtect\t*/\n+\t/* never spans regions.  It seems to be OK for a VirtualFree argument\t*/\n+\t/* to span regions, so we should be OK for now.\t\t\t\t*/\n \tresult = (ptr_t) VirtualAlloc(NULL, res_bytes,\n     \t\t\t\t      MEM_RESERVE | MEM_TOP_DOWN,\n     \t\t\t\t      PAGE_EXECUTE_READWRITE);\n@@ -1508,6 +1833,7 @@ void GC_remap(ptr_t start, word bytes)\n       }\n #   else\n       if (-1 == zero_descr) zero_descr = open(\"/dev/zero\", O_RDWR);\n+      fcntl(zero_descr, F_SETFD, FD_CLOEXEC);\n       if (0 == start_addr) return;\n       result = mmap(start_addr, len, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n \t\t    MAP_FIXED | MAP_PRIVATE, zero_descr, 0);\n@@ -1694,7 +2020,6 @@ void (*GC_push_other_roots) GC_PROTO((void)) = GC_default_push_other_roots;\n  *\t\tmake sure that other system calls are similarly protected\n  *\t\tor write only to the stack.\n  */\n- \n GC_bool GC_dirty_maintained = FALSE;\n \n # ifdef DEFAULT_VDB\n@@ -1708,6 +2033,9 @@ GC_bool GC_dirty_maintained = FALSE;\n /* Initialize virtual dirty bit implementation.\t\t\t*/\n void GC_dirty_init()\n {\n+#   ifdef PRINTSTATS\n+      GC_printf0(\"Initializing DEFAULT_VDB...\\n\");\n+#   endif\n     GC_dirty_maintained = TRUE;\n }\n \n@@ -1776,17 +2104,21 @@ GC_bool is_ptrfree;\n /*\n  * This implementation maintains dirty bits itself by catching write\n  * faults and keeping track of them.  We assume nobody else catches\n- * SIGBUS or SIGSEGV.  We assume no write faults occur in system calls\n- * except as a result of a read system call.  This means clients must\n- * either ensure that system calls do not touch the heap, or must\n- * provide their own wrappers analogous to the one for read.\n+ * SIGBUS or SIGSEGV.  We assume no write faults occur in system calls.\n+ * This means that clients must ensure that system calls don't write\n+ * to the write-protected heap.  Probably the best way to do this is to\n+ * ensure that system calls write at most to POINTERFREE objects in the\n+ * heap, and do even that only if we are on a platform on which those\n+ * are not protected.  Another alternative is to wrap system calls\n+ * (see example for read below), but the current implementation holds\n+ * a lock across blocking calls, making it problematic for multithreaded\n+ * applications. \n  * We assume the page size is a multiple of HBLKSIZE.\n- * This implementation is currently SunOS 4.X and IRIX 5.X specific, though we\n- * tried to use portable code where easily possible.  It is known\n- * not to work under a number of other systems.\n+ * We prefer them to be the same.  We avoid protecting POINTERFREE\n+ * objects only if they are the same.\n  */\n \n-# if !defined(MSWIN32) && !defined(MSWINCE)\n+# if !defined(MSWIN32) && !defined(MSWINCE) && !defined(DARWIN)\n \n #   include <sys/mman.h>\n #   include <signal.h>\n@@ -1805,6 +2137,23 @@ GC_bool is_ptrfree;\n     \t  \n # else\n \n+# ifdef DARWIN\n+    /* Using vm_protect (mach syscall) over mprotect (BSD syscall) seems to\n+       decrease the likelihood of some of the problems described below. */\n+    #include <mach/vm_map.h>\n+    extern mach_port_t GC_task_self;\n+    #define PROTECT(addr,len) \\\n+        if(vm_protect(GC_task_self,(vm_address_t)(addr),(vm_size_t)(len), \\\n+                FALSE,VM_PROT_READ) != KERN_SUCCESS) { \\\n+            ABORT(\"vm_portect failed\"); \\\n+        }\n+    #define UNPROTECT(addr,len) \\\n+        if(vm_protect(GC_task_self,(vm_address_t)(addr),(vm_size_t)(len), \\\n+                FALSE,VM_PROT_READ|VM_PROT_WRITE) != KERN_SUCCESS) { \\\n+            ABORT(\"vm_portect failed\"); \\\n+        }\n+# else\n+    \n #   ifndef MSWINCE\n #     include <signal.h>\n #   endif\n@@ -1822,20 +2171,22 @@ GC_bool is_ptrfree;\n \t  \t\t      &protect_junk)) { \\\n \t    ABORT(\"un-VirtualProtect failed\"); \\\n \t  }\n-\t  \n-# endif\n+# endif /* !DARWIN */\n+# endif /* MSWIN32 || MSWINCE || DARWIN */\n \n #if defined(SUNOS4) || defined(FREEBSD)\n     typedef void (* SIG_PF)();\n-#endif\n+#endif /* SUNOS4 || FREEBSD */\n+\n #if defined(SUNOS5SIGS) || defined(OSF1) || defined(LINUX) \\\n-    || defined(MACOSX) || defined(HURD)\n+    || defined(HURD)\n # ifdef __STDC__\n     typedef void (* SIG_PF)(int);\n # else\n     typedef void (* SIG_PF)();\n # endif\n-#endif\n+#endif /* SUNOS5SIGS || OSF1 || LINUX || HURD */\n+\n #if defined(MSWIN32)\n     typedef LPTOP_LEVEL_EXCEPTION_FILTER SIG_PF;\n #   undef SIG_DFL\n@@ -1849,7 +2200,8 @@ GC_bool is_ptrfree;\n \n #if defined(IRIX5) || defined(OSF1) || defined(HURD)\n     typedef void (* REAL_SIG_PF)(int, int, struct sigcontext *);\n-#endif\n+#endif /* IRIX5 || OSF1 || HURD */\n+\n #if defined(SUNOS5SIGS)\n # ifdef HPUX\n #   define SIGINFO __siginfo\n@@ -1861,13 +2213,14 @@ GC_bool is_ptrfree;\n # else\n     typedef void (* REAL_SIG_PF)();\n # endif\n-#endif\n+#endif /* SUNOS5SIGS */\n+\n #if defined(LINUX)\n #   if __GLIBC__ > 2 || __GLIBC__ == 2 && __GLIBC_MINOR__ >= 2\n       typedef struct sigcontext s_c;\n #   else  /* glibc < 2.2 */\n #     include <linux/version.h>\n-#     if (LINUX_VERSION_CODE >= 0x20100) && !defined(M68K) || defined(ALPHA)\n+#     if (LINUX_VERSION_CODE >= 0x20100) && !defined(M68K) || defined(ALPHA) || defined(ARM32)\n         typedef struct sigcontext s_c;\n #     else\n         typedef struct sigcontext_struct s_c;\n@@ -1895,139 +2248,14 @@ GC_bool is_ptrfree;\n \treturn (char *)faultaddr;\n     }\n #   endif /* !ALPHA */\n-# endif\n-\n-# if defined(MACOSX) /* Should also test for PowerPC? */\n-    typedef void (* REAL_SIG_PF)(int, int, struct sigcontext *);\n-\n-/* Decodes the machine instruction which was responsible for the sending of the\n-   SIGBUS signal. Sadly this is the only way to find the faulting address because\n-   the signal handler doesn't get it directly from the kernel (although it is\n-   available on the Mach level, but droppped by the BSD personality before it\n-   calls our signal handler...)\n-   This code should be able to deal correctly with all PPCs starting from the\n-   601 up to and including the G4s (including Velocity Engine). */\n-#define EXTRACT_OP1(iw)     (((iw) & 0xFC000000) >> 26)\n-#define EXTRACT_OP2(iw)     (((iw) & 0x000007FE) >> 1)\n-#define EXTRACT_REGA(iw)    (((iw) & 0x001F0000) >> 16)\n-#define EXTRACT_REGB(iw)    (((iw) & 0x03E00000) >> 21)\n-#define EXTRACT_REGC(iw)    (((iw) & 0x0000F800) >> 11)\n-#define EXTRACT_DISP(iw)    ((short *) &(iw))[1]\n-\n-static char *get_fault_addr(struct sigcontext *scp)\n-{\n-   unsigned int   instr = *((unsigned int *) scp->sc_ir);\n-   unsigned int * regs = &((unsigned int *) scp->sc_regs)[2];\n-   int            disp = 0, tmp;\n-   unsigned int   baseA = 0, baseB = 0;\n-   unsigned int   addr, alignmask = 0xFFFFFFFF;\n-\n-#ifdef GC_DEBUG_DECODER\n-   GC_err_printf1(\"Instruction: 0x%lx\\n\", instr);\n-   GC_err_printf1(\"Opcode 1: d\\n\", (int)EXTRACT_OP1(instr));\n-#endif\n-   switch(EXTRACT_OP1(instr)) {\n-      case 38:   /* stb */\n-      case 39:   /* stbu */\n-      case 54:   /* stfd */\n-      case 55:   /* stfdu */\n-      case 52:   /* stfs */\n-      case 53:   /* stfsu */\n-      case 44:   /* sth */\n-      case 45:   /* sthu */\n-      case 47:   /* stmw */\n-      case 36:   /* stw */\n-      case 37:   /* stwu */\n-            tmp = EXTRACT_REGA(instr);\n-            if(tmp > 0)\n-               baseA = regs[tmp];\n-            disp = EXTRACT_DISP(instr);\n-            break;\n-      case 31:\n-#ifdef GC_DEBUG_DECODER\n-            GC_err_printf1(\"Opcode 2: %d\\n\", (int)EXTRACT_OP2(instr));\n-#endif\n-            switch(EXTRACT_OP2(instr)) {\n-               case 86:    /* dcbf */\n-               case 54:    /* dcbst */\n-               case 1014:  /* dcbz */\n-               case 247:   /* stbux */\n-               case 215:   /* stbx */\n-               case 759:   /* stfdux */\n-               case 727:   /* stfdx */\n-               case 983:   /* stfiwx */\n-               case 695:   /* stfsux */\n-               case 663:   /* stfsx */\n-               case 918:   /* sthbrx */\n-               case 439:   /* sthux */\n-               case 407:   /* sthx */\n-               case 661:   /* stswx */\n-               case 662:   /* stwbrx */\n-               case 150:   /* stwcx. */\n-               case 183:   /* stwux */\n-               case 151:   /* stwx */\n-               case 135:   /* stvebx */\n-               case 167:   /* stvehx */\n-               case 199:   /* stvewx */\n-               case 231:   /* stvx */\n-               case 487:   /* stvxl */\n-                     tmp = EXTRACT_REGA(instr);\n-                     if(tmp > 0)\n-                        baseA = regs[tmp];\n-                        baseB = regs[EXTRACT_REGC(instr)];\n-                        /* determine Altivec alignment mask */\n-                        switch(EXTRACT_OP2(instr)) {\n-                           case 167:   /* stvehx */\n-                                 alignmask = 0xFFFFFFFE;\n-                                 break;\n-                           case 199:   /* stvewx */\n-                                 alignmask = 0xFFFFFFFC;\n-                                 break;\n-                           case 231:   /* stvx */\n-                                 alignmask = 0xFFFFFFF0;\n-                                 break;\n-                           case 487:  /* stvxl */\n-                                 alignmask = 0xFFFFFFF0;\n-                                 break;\n-                        }\n-                        break;\n-               case 725:   /* stswi */\n-                     tmp = EXTRACT_REGA(instr);\n-                     if(tmp > 0)\n-                        baseA = regs[tmp];\n-                        break;\n-               default:   /* ignore instruction */\n-#ifdef GC_DEBUG_DECODER\n-                     GC_err_printf(\"Ignored by inner handler\\n\");\n-#endif\n-                     return NULL;\n-                    break;\n-            }\n-            break;\n-      default:   /* ignore instruction */\n-#ifdef GC_DEBUG_DECODER\n-            GC_err_printf(\"Ignored by main handler\\n\");\n-#endif\n-            return NULL;\n-            break;\n-   }\n-\t\n-   addr = (baseA + baseB) + disp;\n-  addr &= alignmask;\n-#ifdef GC_DEBUG_DECODER\n-   GC_err_printf1(\"BaseA: %d\\n\", baseA);\n-   GC_err_printf1(\"BaseB: %d\\n\", baseB);\n-   GC_err_printf1(\"Disp:  %d\\n\", disp);\n-   GC_err_printf1(\"Address: %d\\n\", addr);\n-#endif\n-   return (char *)addr;\n-}\n-#endif /* MACOSX */\n+# endif /* LINUX */\n \n+#ifndef DARWIN\n SIG_PF GC_old_bus_handler;\n SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n+#endif /* !DARWIN */\n \n-#ifdef THREADS\n+#if defined(THREADS)\n /* We need to lock around the bitmap update in the write fault handler\t*/\n /* in order to avoid the risk of losing a bit.  We do this with a \t*/\n /* test-and-set spin lock if we know how to do that.  Otherwise we\t*/\n@@ -2076,6 +2304,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #endif /* !THREADS */\n \n /*ARGSUSED*/\n+#if !defined(DARWIN)\n # if defined (SUNOS4) || defined(FREEBSD)\n     void GC_write_fault_handler(sig, code, scp, addr)\n     int sig, code;\n@@ -2091,7 +2320,8 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #     define SIG_OK (sig == SIGBUS)\n #     define CODE_OK (code == BUS_PAGE_FAULT)\n #   endif\n-# endif\n+# endif /* SUNOS4 || FREEBSD */\n+\n # if defined(IRIX5) || defined(OSF1) || defined(HURD)\n #   include <errno.h>\n     void GC_write_fault_handler(int sig, int code, struct sigcontext *scp)\n@@ -2107,23 +2337,29 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #     define SIG_OK (sig == SIGBUS || sig == SIGSEGV) \t\n #     define CODE_OK  TRUE\n #   endif\n-# endif\n+# endif /* IRIX5 || OSF1 || HURD */\n+\n # if defined(LINUX)\n #   if defined(ALPHA) || defined(M68K)\n       void GC_write_fault_handler(int sig, int code, s_c * sc)\n #   else\n #     if defined(IA64) || defined(HP_PA)\n         void GC_write_fault_handler(int sig, siginfo_t * si, s_c * scp)\n #     else\n-        void GC_write_fault_handler(int sig, s_c sc)\n+#       if defined(ARM32)\n+          void GC_write_fault_handler(int sig, int a2, int a3, int a4, s_c sc)\n+#       else\n+          void GC_write_fault_handler(int sig, s_c sc)\n+#       endif\n #     endif\n #   endif\n #   define SIG_OK (sig == SIGSEGV)\n #   define CODE_OK TRUE\n \t/* Empirically c.trapno == 14, on IA32, but is that useful?     */\n \t/* Should probably consider alignment issues on other \t\t*/\n \t/* architectures.\t\t\t\t\t\t*/\n-# endif\n+# endif /* LINUX */\n+\n # if defined(SUNOS5SIGS)\n #  ifdef __STDC__\n     void GC_write_fault_handler(int sig, struct SIGINFO *scp, void * context)\n@@ -2144,21 +2380,15 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #     define SIG_OK (sig == SIGSEGV)\n #     define CODE_OK (scp -> si_code == SEGV_ACCERR)\n #   endif\n-# endif\n-\n-# if defined(MACOSX)\n-    void GC_write_fault_handler(int sig, int code, struct sigcontext *scp)\n-#   define SIG_OK (sig == SIGBUS)\n-#   define CODE_OK (code == 0 /* experimentally determined */)\n-# endif\n+# endif /* SUNOS5SIGS */\n \n # if defined(MSWIN32) || defined(MSWINCE)\n     LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info)\n #   define SIG_OK (exc_info -> ExceptionRecord -> ExceptionCode == \\\n \t\t\tSTATUS_ACCESS_VIOLATION)\n #   define CODE_OK (exc_info -> ExceptionRecord -> ExceptionInformation[0] == 1)\n \t\t\t/* Write fault */\n-# endif\n+# endif /* MSWIN32 || MSWINCE */\n {\n     register unsigned i;\n #   if defined(HURD) \n@@ -2218,16 +2448,17 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #             if defined(POWERPC)\n                 char * addr = (char *) (sc.regs->dar);\n #\t      else\n-\t\t--> architecture not supported\n+#               if defined(ARM32)\n+                  char * addr = (char *)sc.fault_address;\n+#               else\n+\t\t  --> architecture not supported\n+#               endif\n #\t      endif\n #\t    endif\n #\t  endif\n #\tendif\n #     endif\n #   endif\n-#   if defined(MACOSX)\n-        char * addr = get_fault_addr(scp);\n-#   endif\n #   if defined(MSWIN32) || defined(MSWINCE)\n \tchar * addr = (char *) (exc_info -> ExceptionRecord\n \t\t\t\t-> ExceptionInformation[1]);\n@@ -2291,9 +2522,6 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \t\t    (*(REAL_SIG_PF)old_handler) (sig, code, scp);\n \t\t    return;\n #\t\tendif\n-#\t\tifdef MACOSX\n-\t\t    (*(REAL_SIG_PF)old_handler) (sig, code, scp);\n-#\t\tendif\n #\t\tifdef MSWIN32\n \t\t    return((*old_handler)(exc_info));\n #\t\tendif\n@@ -2335,10 +2563,11 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n     ABORT(\"Unexpected bus error or segmentation fault\");\n #endif\n }\n+#endif /* !DARWIN */\n \n /*\n  * We hold the allocation lock.  We expect block h to be written\n- * shortly.  Ensure that all pages cvontaining any part of the n hblks\n+ * shortly.  Ensure that all pages containing any part of the n hblks\n  * starting at h are no longer protected.  If is_ptrfree is false,\n  * also ensure that they will subsequently appear to be dirty.\n  */\n@@ -2367,6 +2596,7 @@ GC_bool is_ptrfree;\n     UNPROTECT(h_trunc, (ptr_t)h_end - (ptr_t)h_trunc);\n }\n \n+#if !defined(DARWIN)\n void GC_dirty_init()\n {\n #   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(LINUX) || \\\n@@ -2389,13 +2619,6 @@ void GC_dirty_init()\n         (void)sigaddset(&act.sa_mask, SIG_SUSPEND);\n #     endif /* SIG_SUSPEND */\n #    endif\n-#   if defined(MACOSX)\n-      struct sigaction act, oldact;\n-\n-      act.sa_flags = SA_RESTART;\n-      act.sa_handler = GC_write_fault_handler;\n-      sigemptyset(&act.sa_mask);\n-#   endif\n #   ifdef PRINTSTATS\n \tGC_printf0(\"Inititalizing mprotect virtual dirty bit implementation\\n\");\n #   endif\n@@ -2435,9 +2658,12 @@ void GC_dirty_init()\n       \tsigaction(SIGSEGV, 0, &oldact);\n       \tsigaction(SIGSEGV, &act, 0);\n #     else\n-      \tsigaction(SIGSEGV, &act, &oldact);\n+\t{\n+\t  int res = sigaction(SIGSEGV, &act, &oldact);\n+\t  if (res != 0) ABORT(\"Sigaction failed\");\n+ \t}\n #     endif\n-#     if defined(_sigargs) || defined(HURD)\n+#     if defined(_sigargs) || defined(HURD) || !defined(SA_SIGINFO)\n \t/* This is Irix 5.x, not 6.x.  Irix 5.x does not have\t*/\n \t/* sa_sigaction.\t\t\t\t\t*/\n \tGC_old_segv_handler = oldact.sa_handler;\n@@ -2458,7 +2684,7 @@ void GC_dirty_init()\n #       endif\n       }\n #   endif\n-#   if defined(MACOSX) || defined(HPUX) || defined(LINUX) || defined(HURD)\n+#   if defined(HPUX) || defined(LINUX) || defined(HURD)\n       sigaction(SIGBUS, &act, &oldact);\n       GC_old_bus_handler = oldact.sa_handler;\n       if (GC_old_bus_handler == SIG_IGN) {\n@@ -2470,7 +2696,7 @@ void GC_dirty_init()\n \t  GC_err_printf0(\"Replaced other SIGBUS handler\\n\");\n #       endif\n       }\n-#   endif /* MACOS || HPUX || LINUX */\n+#   endif /* HPUX || LINUX || HURD */\n #   if defined(MSWIN32)\n       GC_old_segv_handler = SetUnhandledExceptionFilter(GC_write_fault_handler);\n       if (GC_old_segv_handler != NULL) {\n@@ -2482,6 +2708,7 @@ void GC_dirty_init()\n       }\n #   endif\n }\n+#endif /* !DARWIN */\n \n int GC_incremental_protection_needs()\n {\n@@ -2628,15 +2855,23 @@ word len;\n     \t      ((ptr_t)end_block - (ptr_t)start_block) + HBLKSIZE);\n }\n \n-#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(THREADS) \\\n-    && !defined(GC_USE_LD_WRAP)\n-/* Replacement for UNIX system call.\t\t\t\t\t */\n-/* Other calls that write to the heap should be handled similarly.\t */\n-/* Note that this doesn't work well for blocking reads:  It will hold\t */\n-/* tha allocation lock for the entur duration of the call. Multithreaded */\n-/* clients should really ensure that it won't block, either by setting \t */\n-/* the descriptor nonblocking, or by calling select or poll first, to\t */\n-/* make sure that input is available.\t\t\t\t\t */\n+#if 0\n+\n+/* We no longer wrap read by default, since that was causing too many\t*/\n+/* problems.  It is preferred that the client instead avoids writing\t*/\n+/* to the write-protected heap with a system call.\t\t\t*/\n+/* This still serves as sample code if you do want to wrap system calls.*/\n+\n+#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(GC_USE_LD_WRAP)\n+/* Replacement for UNIX system call.\t\t\t\t\t  */\n+/* Other calls that write to the heap should be handled similarly.\t  */\n+/* Note that this doesn't work well for blocking reads:  It will hold\t  */\n+/* the allocation lock for the entire duration of the call. Multithreaded */\n+/* clients should really ensure that it won't block, either by setting \t  */\n+/* the descriptor nonblocking, or by calling select or poll first, to\t  */\n+/* make sure that input is available.\t\t\t\t\t  */\n+/* Another, preferred alternative is to ensure that system calls never \t  */\n+/* write to the protected heap (see above).\t\t\t\t  */\n # if defined(__STDC__) && !defined(SUNOS4)\n #   include <unistd.h>\n #   include <sys/uio.h>\n@@ -2706,6 +2941,8 @@ word len;\n     /* actually calls.\t\t\t\t\t\t\t*/\n #endif\n \n+#endif /* 0 */\n+\n /*ARGSUSED*/\n GC_bool GC_page_was_ever_dirty(h)\n struct hblk *h;\n@@ -2721,13 +2958,6 @@ word n;\n {\n }\n \n-# else /* !MPROTECT_VDB */\n-\n-#   ifdef GC_USE_LD_WRAP\n-      ssize_t __wrap_read(int fd, void *buf, size_t nbyte)\n-      { return __real_read(fd, buf, nbyte); }\n-#   endif\n-\n # endif /* MPROTECT_VDB */\n \n # ifdef PROC_VDB\n@@ -2806,6 +3036,7 @@ void GC_dirty_init()\n     }\n     GC_proc_fd = syscall(SYS_ioctl, fd, PIOCOPENPD, 0);\n     close(fd);\n+    syscall(SYS_fcntl, GC_proc_fd, F_SETFD, FD_CLOEXEC);\n     if (GC_proc_fd < 0) {\n     \tABORT(\"/proc ioctl failed\");\n     }\n@@ -3045,6 +3276,552 @@ GC_bool is_ptrfree;\n \n # endif /* PCR_VDB */\n \n+#if defined(MPROTECT_VDB) && defined(DARWIN)\n+/* The following sources were used as a *reference* for this exception handling\n+   code:\n+      1. Apple's mach/xnu documentation\n+      2. Timothy J. Wood's \"Mach Exception Handlers 101\" post to the\n+         omnigroup's macosx-dev list. \n+         www.omnigroup.com/mailman/archive/macosx-dev/2000-June/002030.html\n+      3. macosx-nat.c from Apple's GDB source code.\n+*/\n+   \n+/* The bug that caused all this trouble should now be fixed. This should\n+   eventually be removed if all goes well. */\n+/* define BROKEN_EXCEPTION_HANDLING */\n+    \n+#include <mach/mach.h>\n+#include <mach/mach_error.h>\n+#include <mach/thread_status.h>\n+#include <mach/exception.h>\n+#include <mach/task.h>\n+#include <pthread.h>\n+\n+/* These are not defined in any header, although they are documented */\n+extern boolean_t exc_server(mach_msg_header_t *,mach_msg_header_t *);\n+extern kern_return_t exception_raise(\n+    mach_port_t,mach_port_t,mach_port_t,\n+    exception_type_t,exception_data_t,mach_msg_type_number_t);\n+extern kern_return_t exception_raise_state(\n+    mach_port_t,mach_port_t,mach_port_t,\n+    exception_type_t,exception_data_t,mach_msg_type_number_t,\n+    thread_state_flavor_t*,thread_state_t,mach_msg_type_number_t,\n+    thread_state_t,mach_msg_type_number_t*);\n+extern kern_return_t exception_raise_state_identity(\n+    mach_port_t,mach_port_t,mach_port_t,\n+    exception_type_t,exception_data_t,mach_msg_type_number_t,\n+    thread_state_flavor_t*,thread_state_t,mach_msg_type_number_t,\n+    thread_state_t,mach_msg_type_number_t*);\n+\n+\n+#define MAX_EXCEPTION_PORTS 16\n+\n+static mach_port_t GC_task_self;\n+\n+static struct {\n+    mach_msg_type_number_t count;\n+    exception_mask_t      masks[MAX_EXCEPTION_PORTS];\n+    exception_handler_t   ports[MAX_EXCEPTION_PORTS];\n+    exception_behavior_t  behaviors[MAX_EXCEPTION_PORTS];\n+    thread_state_flavor_t flavors[MAX_EXCEPTION_PORTS];\n+} GC_old_exc_ports;\n+\n+static struct {\n+    mach_port_t exception;\n+#if defined(THREADS)\n+    mach_port_t reply;\n+#endif\n+} GC_ports;\n+\n+typedef struct {\n+    mach_msg_header_t head;\n+} GC_msg_t;\n+\n+typedef enum {\n+    GC_MP_NORMAL, GC_MP_DISCARDING, GC_MP_STOPPED\n+} GC_mprotect_state_t;\n+\n+/* FIXME: 1 and 2 seem to be safe to use in the msgh_id field,\n+   but it isn't  documented. Use the source and see if they\n+   should be ok. */\n+#define ID_STOP 1\n+#define ID_RESUME 2\n+\n+/* These values are only used on the reply port */\n+#define ID_ACK 3\n+\n+#if defined(THREADS)\n+\n+GC_mprotect_state_t GC_mprotect_state;\n+\n+/* The following should ONLY be called when the world is stopped  */\n+static void GC_mprotect_thread_notify(mach_msg_id_t id) {\n+    struct {\n+        GC_msg_t msg;\n+        mach_msg_trailer_t trailer;\n+    } buf;\n+    mach_msg_return_t r;\n+    /* remote, local */\n+    buf.msg.head.msgh_bits = \n+        MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND,0);\n+    buf.msg.head.msgh_size = sizeof(buf.msg);\n+    buf.msg.head.msgh_remote_port = GC_ports.exception;\n+    buf.msg.head.msgh_local_port = MACH_PORT_NULL;\n+    buf.msg.head.msgh_id = id;\n+            \n+    r = mach_msg(\n+        &buf.msg.head,\n+        MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_LARGE,\n+        sizeof(buf.msg),\n+        sizeof(buf),\n+        GC_ports.reply,\n+        MACH_MSG_TIMEOUT_NONE,\n+        MACH_PORT_NULL);\n+    if(r != MACH_MSG_SUCCESS)\n+\tABORT(\"mach_msg failed in GC_mprotect_thread_notify\");\n+    if(buf.msg.head.msgh_id != ID_ACK)\n+        ABORT(\"invalid ack in GC_mprotect_thread_notify\");\n+}\n+\n+/* Should only be called by the mprotect thread */\n+static void GC_mprotect_thread_reply() {\n+    GC_msg_t msg;\n+    mach_msg_return_t r;\n+    /* remote, local */\n+    msg.head.msgh_bits = \n+        MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND,0);\n+    msg.head.msgh_size = sizeof(msg);\n+    msg.head.msgh_remote_port = GC_ports.reply;\n+    msg.head.msgh_local_port = MACH_PORT_NULL;\n+    msg.head.msgh_id = ID_ACK;\n+            \n+    r = mach_msg(\n+        &msg.head,\n+        MACH_SEND_MSG,\n+        sizeof(msg),\n+        0,\n+        MACH_PORT_NULL,\n+        MACH_MSG_TIMEOUT_NONE,\n+        MACH_PORT_NULL);\n+    if(r != MACH_MSG_SUCCESS)\n+\tABORT(\"mach_msg failed in GC_mprotect_thread_reply\");\n+}\n+\n+void GC_mprotect_stop() {\n+    GC_mprotect_thread_notify(ID_STOP);\n+}\n+void GC_mprotect_resume() {\n+    GC_mprotect_thread_notify(ID_RESUME);\n+}\n+\n+#else /* !THREADS */\n+/* The compiler should optimize away any GC_mprotect_state computations */\n+#define GC_mprotect_state GC_MP_NORMAL\n+#endif\n+\n+static void *GC_mprotect_thread(void *arg) {\n+    mach_msg_return_t r;\n+    /* These two structures contain some private kernel data. We don't need to\n+       access any of it so we don't bother defining a proper struct. The\n+       correct definitions are in the xnu source code. */\n+    struct {\n+        mach_msg_header_t head;\n+        char data[256];\n+    } reply;\n+    struct {\n+        mach_msg_header_t head;\n+        mach_msg_body_t msgh_body;\n+        char data[1024];\n+    } msg;\n+\n+    mach_msg_id_t id;\n+    \n+    for(;;) {\n+        r = mach_msg(\n+            &msg.head,\n+            MACH_RCV_MSG|MACH_RCV_LARGE|\n+                (GC_mprotect_state == GC_MP_DISCARDING ? MACH_RCV_TIMEOUT : 0),\n+            0,\n+            sizeof(msg),\n+            GC_ports.exception,\n+            GC_mprotect_state == GC_MP_DISCARDING ? 0 : MACH_MSG_TIMEOUT_NONE,\n+            MACH_PORT_NULL);\n+        \n+        id = r == MACH_MSG_SUCCESS ? msg.head.msgh_id : -1;\n+        \n+#if defined(THREADS)\n+        if(GC_mprotect_state == GC_MP_DISCARDING) {\n+            if(r == MACH_RCV_TIMED_OUT) {\n+                GC_mprotect_state = GC_MP_STOPPED;\n+                GC_mprotect_thread_reply();\n+                continue;\n+            }\n+            if(r == MACH_MSG_SUCCESS && (id == ID_STOP || id == ID_RESUME))\n+                ABORT(\"out of order mprotect thread request\");\n+        }\n+#endif\n+        \n+        if(r != MACH_MSG_SUCCESS) {\n+            GC_err_printf2(\"mach_msg failed with %d %s\\n\", \n+                (int)r,mach_error_string(r));\n+            ABORT(\"mach_msg failed\");\n+        }\n+        \n+        switch(id) {\n+#if defined(THREADS)\n+            case ID_STOP:\n+                if(GC_mprotect_state != GC_MP_NORMAL)\n+                    ABORT(\"Called mprotect_stop when state wasn't normal\");\n+                GC_mprotect_state = GC_MP_DISCARDING;\n+                break;\n+            case ID_RESUME:\n+                if(GC_mprotect_state != GC_MP_STOPPED)\n+                    ABORT(\"Called mprotect_resume when state wasn't stopped\");\n+                GC_mprotect_state = GC_MP_NORMAL;\n+                GC_mprotect_thread_reply();\n+                break;\n+#endif /* THREADS */\n+            default:\n+\t            /* Handle the message (calls catch_exception_raise) */\n+    \t        if(!exc_server(&msg.head,&reply.head))\n+                    ABORT(\"exc_server failed\");\n+                /* Send the reply */\n+                r = mach_msg(\n+                    &reply.head,\n+                    MACH_SEND_MSG,\n+                    reply.head.msgh_size,\n+                    0,\n+                    MACH_PORT_NULL,\n+                    MACH_MSG_TIMEOUT_NONE,\n+                    MACH_PORT_NULL);\n+\t        if(r != MACH_MSG_SUCCESS) {\n+\t        \t/* This will fail if the thread dies, but the thread shouldn't\n+\t        \t   die... */\n+\t        \t#ifdef BROKEN_EXCEPTION_HANDLING\n+    \t        \tGC_err_printf2(\n+                        \"mach_msg failed with %d %s while sending exc reply\\n\",\n+                        (int)r,mach_error_string(r));\n+    \t        #else\n+    \t        \tABORT(\"mach_msg failed while sending exception reply\");\n+    \t        #endif\n+        \t}\n+        } /* switch */\n+    } /* for(;;) */\n+    /* NOT REACHED */\n+    return NULL;\n+}\n+\n+/* All this SIGBUS code shouldn't be necessary. All protection faults should\n+   be going throught the mach exception handler. However, it seems a SIGBUS is\n+   occasionally sent for some unknown reason. Even more odd, it seems to be\n+   meaningless and safe to ignore. */\n+#ifdef BROKEN_EXCEPTION_HANDLING\n+\n+typedef void (* SIG_PF)();\n+static SIG_PF GC_old_bus_handler;\n+\n+/* Updates to this aren't atomic, but the SIGBUSs seem pretty rare.\n+   Even if this doesn't get updated property, it isn't really a problem */\n+static int GC_sigbus_count;\n+\n+static void GC_darwin_sigbus(int num,siginfo_t *sip,void *context) {\n+    if(num != SIGBUS) ABORT(\"Got a non-sigbus signal in the sigbus handler\");\n+    \n+    /* Ugh... some seem safe to ignore, but too many in a row probably means\n+       trouble. GC_sigbus_count is reset for each mach exception that is\n+       handled */\n+    if(GC_sigbus_count >= 8) {\n+        ABORT(\"Got more than 8 SIGBUSs in a row!\");\n+    } else {\n+        GC_sigbus_count++;\n+        GC_err_printf0(\"GC: WARNING: Ignoring SIGBUS.\\n\");\n+    }\n+}\n+#endif /* BROKEN_EXCEPTION_HANDLING */\n+\n+void GC_dirty_init() {\n+    kern_return_t r;\n+    mach_port_t me;\n+    pthread_t thread;\n+    pthread_attr_t attr;\n+    exception_mask_t mask;\n+    \n+#   ifdef PRINTSTATS\n+        GC_printf0(\"Inititalizing mach/darwin mprotect virtual dirty bit \"\n+            \"implementation\\n\");\n+#   endif  \n+#\tifdef BROKEN_EXCEPTION_HANDLING\n+        GC_err_printf0(\"GC: WARNING: Enabling workarounds for various darwin \"\n+            \"exception handling bugs.\\n\");\n+#\tendif\n+    GC_dirty_maintained = TRUE;\n+    if (GC_page_size % HBLKSIZE != 0) {\n+        GC_err_printf0(\"Page size not multiple of HBLKSIZE\\n\");\n+        ABORT(\"Page size not multiple of HBLKSIZE\");\n+    }\n+    \n+    GC_task_self = me = mach_task_self();\n+    \n+    r = mach_port_allocate(me,MACH_PORT_RIGHT_RECEIVE,&GC_ports.exception);\n+    if(r != KERN_SUCCESS) ABORT(\"mach_port_allocate failed (exception port)\");\n+    \n+    r = mach_port_insert_right(me,GC_ports.exception,GC_ports.exception,\n+    \tMACH_MSG_TYPE_MAKE_SEND);\n+    if(r != KERN_SUCCESS)\n+    \tABORT(\"mach_port_insert_right failed (exception port)\");\n+\n+    #if defined(THREADS)\n+        r = mach_port_allocate(me,MACH_PORT_RIGHT_RECEIVE,&GC_ports.reply);\n+        if(r != KERN_SUCCESS) ABORT(\"mach_port_allocate failed (reply port)\");\n+    #endif\n+\n+    /* The exceptions we want to catch */  \n+    mask = EXC_MASK_BAD_ACCESS;\n+\n+    r = task_get_exception_ports(\n+        me,\n+        mask,\n+        GC_old_exc_ports.masks,\n+        &GC_old_exc_ports.count,\n+        GC_old_exc_ports.ports,\n+        GC_old_exc_ports.behaviors,\n+        GC_old_exc_ports.flavors\n+    );\n+    if(r != KERN_SUCCESS) ABORT(\"task_get_exception_ports failed\");\n+        \n+    r = task_set_exception_ports(\n+        me,\n+        mask,\n+        GC_ports.exception,\n+        EXCEPTION_DEFAULT,\n+        MACHINE_THREAD_STATE\n+    );\n+    if(r != KERN_SUCCESS) ABORT(\"task_set_exception_ports failed\");\n+\n+    if(pthread_attr_init(&attr) != 0) ABORT(\"pthread_attr_init failed\");\n+    if(pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED) != 0) \n+        ABORT(\"pthread_attr_setdetachedstate failed\");\n+\n+#\tundef pthread_create\n+    /* This will call the real pthread function, not our wrapper */\n+    if(pthread_create(&thread,&attr,GC_mprotect_thread,NULL) != 0)\n+        ABORT(\"pthread_create failed\");\n+    pthread_attr_destroy(&attr);\n+    \n+    /* Setup the sigbus handler for ignoring the meaningless SIGBUSs */\n+    #ifdef BROKEN_EXCEPTION_HANDLING \n+    {\n+        struct sigaction sa, oldsa;\n+        sa.sa_handler = (SIG_PF)GC_darwin_sigbus;\n+        sigemptyset(&sa.sa_mask);\n+        sa.sa_flags = SA_RESTART|SA_SIGINFO;\n+        if(sigaction(SIGBUS,&sa,&oldsa) < 0) ABORT(\"sigaction\");\n+        GC_old_bus_handler = (SIG_PF)oldsa.sa_handler;\n+        if (GC_old_bus_handler != SIG_DFL) {\n+#       \tifdef PRINTSTATS\n+                GC_err_printf0(\"Replaced other SIGBUS handler\\n\");\n+#       \tendif\n+        }\n+    }\n+    #endif /* BROKEN_EXCEPTION_HANDLING  */\n+}\n+ \n+/* The source code for Apple's GDB was used as a reference for the exception\n+   forwarding code. This code is similar to be GDB code only because there is \n+   only one way to do it. */\n+static kern_return_t GC_forward_exception(\n+        mach_port_t thread,\n+        mach_port_t task,\n+        exception_type_t exception,\n+        exception_data_t data,\n+        mach_msg_type_number_t data_count\n+) {\n+    int i;\n+    kern_return_t r;\n+    mach_port_t port;\n+    exception_behavior_t behavior;\n+    thread_state_flavor_t flavor;\n+    \n+    thread_state_data_t thread_state;\n+    mach_msg_type_number_t thread_state_count = THREAD_STATE_MAX;\n+        \n+    for(i=0;i<GC_old_exc_ports.count;i++)\n+        if(GC_old_exc_ports.masks[i] & (1 << exception))\n+            break;\n+    if(i==GC_old_exc_ports.count) ABORT(\"No handler for exception!\");\n+    \n+    port = GC_old_exc_ports.ports[i];\n+    behavior = GC_old_exc_ports.behaviors[i];\n+    flavor = GC_old_exc_ports.flavors[i];\n+\n+    if(behavior != EXCEPTION_DEFAULT) {\n+        r = thread_get_state(thread,flavor,thread_state,&thread_state_count);\n+        if(r != KERN_SUCCESS)\n+            ABORT(\"thread_get_state failed in forward_exception\");\n+    }\n+    \n+    switch(behavior) {\n+        case EXCEPTION_DEFAULT:\n+            r = exception_raise(port,thread,task,exception,data,data_count);\n+            break;\n+        case EXCEPTION_STATE:\n+            r = exception_raise_state(port,thread,task,exception,data,\n+                data_count,&flavor,thread_state,thread_state_count,\n+                thread_state,&thread_state_count);\n+            break;\n+        case EXCEPTION_STATE_IDENTITY:\n+            r = exception_raise_state_identity(port,thread,task,exception,data,\n+                data_count,&flavor,thread_state,thread_state_count,\n+                thread_state,&thread_state_count);\n+            break;\n+        default:\n+            r = KERN_FAILURE; /* make gcc happy */\n+            ABORT(\"forward_exception: unknown behavior\");\n+            break;\n+    }\n+    \n+    if(behavior != EXCEPTION_DEFAULT) {\n+        r = thread_set_state(thread,flavor,thread_state,thread_state_count);\n+        if(r != KERN_SUCCESS)\n+            ABORT(\"thread_set_state failed in forward_exception\");\n+    }\n+    \n+    return r;\n+}\n+\n+#define FWD() GC_forward_exception(thread,task,exception,code,code_count)\n+\n+/* This violates the namespace rules but there isn't anything that can be done\n+   about it. The exception handling stuff is hard coded to call this */\n+kern_return_t\n+catch_exception_raise(\n+   mach_port_t exception_port,mach_port_t thread,mach_port_t task,\n+   exception_type_t exception,exception_data_t code,\n+   mach_msg_type_number_t code_count\n+) {\n+    kern_return_t r;\n+    char *addr;\n+    struct hblk *h;\n+    int i;\n+#ifdef POWERPC\n+    thread_state_flavor_t flavor = PPC_EXCEPTION_STATE;\n+    mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE_COUNT;\n+    ppc_exception_state_t exc_state;\n+#else\n+#\terror FIXME for non-ppc darwin\n+#endif\n+\n+    \n+    if(exception != EXC_BAD_ACCESS || code[0] != KERN_PROTECTION_FAILURE) {\n+        #ifdef DEBUG_EXCEPTION_HANDLING\n+        /* We aren't interested, pass it on to the old handler */\n+        GC_printf3(\"Exception: 0x%x Code: 0x%x 0x%x in catch....\\n\",\n+            exception,\n+            code_count > 0 ? code[0] : -1,\n+            code_count > 1 ? code[1] : -1); \n+        #endif\n+        return FWD();\n+    }\n+\n+    r = thread_get_state(thread,flavor,\n+        (natural_t*)&exc_state,&exc_state_count);\n+    if(r != KERN_SUCCESS) {\n+        /* The thread is supposed to be suspended while the exception handler\n+           is called. This shouldn't fail. */\n+        #ifdef BROKEN_EXCEPTION_HANDLING\n+            GC_err_printf0(\"thread_get_state failed in \"\n+                \"catch_exception_raise\\n\");\n+            return KERN_SUCCESS;\n+        #else\n+            ABORT(\"thread_get_state failed in catch_exception_raise\");\n+        #endif\n+    }\n+    \n+    /* This is the address that caused the fault */\n+    addr = (char*) exc_state.dar;\n+        \n+    if((HDR(addr)) == 0) {\n+        /* Ugh... just like the SIGBUS problem above, it seems we get a bogus \n+           KERN_PROTECTION_FAILURE every once and a while. We wait till we get\n+           a bunch in a row before doing anything about it. If a \"real\" fault \n+           ever occurres it'll just keep faulting over and over and we'll hit\n+           the limit pretty quickly. */\n+        #ifdef BROKEN_EXCEPTION_HANDLING\n+            static char *last_fault;\n+            static int last_fault_count;\n+            \n+            if(addr != last_fault) {\n+                last_fault = addr;\n+                last_fault_count = 0;\n+            }\n+            if(++last_fault_count < 32) {\n+                if(last_fault_count == 1)\n+                    GC_err_printf1(\n+                        \"GC: WARNING: Ignoring KERN_PROTECTION_FAILURE at %p\\n\",\n+                        addr);\n+                return KERN_SUCCESS;\n+            }\n+            \n+            GC_err_printf1(\"Unexpected KERN_PROTECTION_FAILURE at %p\\n\",addr);\n+            /* Can't pass it along to the signal handler because that is\n+               ignoring SIGBUS signals. We also shouldn't call ABORT here as\n+               signals don't always work too well from the exception handler. */\n+            GC_err_printf0(\"Aborting\\n\");\n+            exit(EXIT_FAILURE);\n+        #else /* BROKEN_EXCEPTION_HANDLING */\n+            /* Pass it along to the next exception handler \n+               (which should call SIGBUS/SIGSEGV) */\n+            return FWD();\n+        #endif /* !BROKEN_EXCEPTION_HANDLING */\n+    }\n+\n+    #ifdef BROKEN_EXCEPTION_HANDLING\n+        /* Reset the number of consecutive SIGBUSs */\n+        GC_sigbus_count = 0;\n+    #endif\n+    \n+    if(GC_mprotect_state == GC_MP_NORMAL) { /* common case */\n+        h = (struct hblk*)((word)addr & ~(GC_page_size-1));\n+        UNPROTECT(h, GC_page_size);\t\n+        for (i = 0; i < divHBLKSZ(GC_page_size); i++) {\n+            register int index = PHT_HASH(h+i);\n+            async_set_pht_entry_from_index(GC_dirty_pages, index);\n+        }\n+    } else if(GC_mprotect_state == GC_MP_DISCARDING) {\n+        /* Lie to the thread for now. No sense UNPROTECT()ing the memory\n+           when we're just going to PROTECT() it again later. The thread\n+           will just fault again once it resumes */\n+    } else {\n+        /* Shouldn't happen, i don't think */\n+        GC_printf0(\"KERN_PROTECTION_FAILURE while world is stopped\\n\");\n+        return FWD();\n+    }\n+    return KERN_SUCCESS;\n+}\n+#undef FWD\n+\n+/* These should never be called, but just in case...  */\n+kern_return_t catch_exception_raise_state(mach_port_name_t exception_port,\n+    int exception, exception_data_t code, mach_msg_type_number_t codeCnt,\n+    int flavor, thread_state_t old_state, int old_stateCnt,\n+    thread_state_t new_state, int new_stateCnt)\n+{\n+    ABORT(\"catch_exception_raise_state\");\n+    return(KERN_INVALID_ARGUMENT);\n+}\n+kern_return_t catch_exception_raise_state_identity(\n+    mach_port_name_t exception_port, mach_port_t thread, mach_port_t task,\n+    int exception, exception_data_t code, mach_msg_type_number_t codeCnt,\n+    int flavor, thread_state_t old_state, int old_stateCnt, \n+    thread_state_t new_state, int new_stateCnt)\n+{\n+    ABORT(\"catch_exception_raise_state_identity\");\n+    return(KERN_INVALID_ARGUMENT);\n+}\n+\n+\n+#endif /* DARWIN && MPROTECT_VDB */\n+\n # ifndef HAVE_INCREMENTAL_PROTECTION_NEEDS\n   int GC_incremental_protection_needs()\n   {\n@@ -3105,19 +3882,20 @@ GC_bool is_ptrfree;\n #  endif\n #endif /* SPARC */\n \n-#ifdef SAVE_CALL_CHAIN\n+#ifdef  NEED_CALLINFO\n /* Fill in the pc and argument information for up to NFRAMES of my\t*/\n /* callers.  Ignore my frame and my callers frame.\t\t\t*/\n \n #ifdef LINUX\n-# include <features.h>\n-# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2\n-#   define HAVE_BUILTIN_BACKTRACE\n-# endif\n+#   include <unistd.h>\n #endif\n \n+#endif /* NEED_CALLINFO */\n+\n+#ifdef SAVE_CALL_CHAIN\n+\n #if NARGS == 0 && NFRAMES % 2 == 0 /* No padding */ \\\n-    && defined(HAVE_BUILTIN_BACKTRACE)\n+    && defined(GC_HAVE_BUILTIN_BACKTRACE)\n \n #include <execinfo.h>\n \n@@ -3163,8 +3941,6 @@ struct callinfo info[NFRAMES];\n     asm(\"movl %%ebp,%0\" : \"=r\"(frame));\n     fp = frame;\n # else\n-    word GC_save_regs_in_stack();\n-\n     frame = (struct frame *) GC_save_regs_in_stack ();\n     fp = (struct frame *)((long) frame -> FR_SAVFP + BIAS);\n #endif\n@@ -3188,52 +3964,156 @@ struct callinfo info[NFRAMES];\n \n #endif /* SAVE_CALL_CHAIN */\n \n-#if defined(LINUX) && defined(__ELF__) && \\\n-    (!defined(SMALL_CONFIG) || defined(USE_PROC_FOR_LIBRARIES))\n-#ifdef GC_USE_LD_WRAP\n-#   define READ __real_read\n-#else\n-#   define READ read\n-#endif\n-\n+#ifdef NEED_CALLINFO\n \n-/* Repeatedly perform a read call until the buffer is filled or\t*/\n-/* we encounter EOF.\t\t\t\t\t\t*/\n-ssize_t GC_repeat_read(int fd, char *buf, size_t count)\n+/* Print info to stderr.  We do NOT hold the allocation lock */\n+void GC_print_callers (info)\n+struct callinfo info[NFRAMES];\n {\n-    ssize_t num_read = 0;\n-    ssize_t result;\n+    register int i;\n+    static int reentry_count = 0;\n+    GC_bool stop = FALSE;\n+\n+    LOCK();\n+      ++reentry_count;\n+    UNLOCK();\n     \n-    while (num_read < count) {\n-\tresult = READ(fd, buf + num_read, count - num_read);\n-\tif (result < 0) return result;\n-\tif (result == 0) break;\n-\tnum_read += result;\n+#   if NFRAMES == 1\n+      GC_err_printf0(\"\\tCaller at allocation:\\n\");\n+#   else\n+      GC_err_printf0(\"\\tCall chain at allocation:\\n\");\n+#   endif\n+    for (i = 0; i < NFRAMES && !stop ; i++) {\n+     \tif (info[i].ci_pc == 0) break;\n+#\tif NARGS > 0\n+\t{\n+\t  int j;\n+\n+     \t  GC_err_printf0(\"\\t\\targs: \");\n+     \t  for (j = 0; j < NARGS; j++) {\n+     \t    if (j != 0) GC_err_printf0(\", \");\n+     \t    GC_err_printf2(\"%d (0x%X)\", ~(info[i].ci_arg[j]),\n+     \t    \t\t\t\t~(info[i].ci_arg[j]));\n+     \t  }\n+\t  GC_err_printf0(\"\\n\");\n+\t}\n+# \tendif\n+        if (reentry_count > 1) {\n+\t    /* We were called during an allocation during\t*/\n+\t    /* a previous GC_print_callers call; punt.\t\t*/\n+     \t    GC_err_printf1(\"\\t\\t##PC##= 0x%lx\\n\", info[i].ci_pc);\n+\t    continue;\n+\t}\n+\t{\n+#\t  ifdef LINUX\n+\t    FILE *pipe;\n+#\t  endif\n+#\t  if defined(GC_HAVE_BUILTIN_BACKTRACE)\n+\t    char **sym_name =\n+\t      backtrace_symbols((void **)(&(info[i].ci_pc)), 1);\n+\t    char *name = sym_name[0];\n+#\t  else\n+\t    char buf[40];\n+\t    char *name = buf;\n+     \t    sprintf(buf, \"##PC##= 0x%lx\", info[i].ci_pc);\n+#\t  endif\n+#\t  if defined(LINUX) && !defined(SMALL_CONFIG)\n+\t    /* Try for a line number. */\n+\t    {\n+#\t        define EXE_SZ 100\n+\t\tstatic char exe_name[EXE_SZ];\n+#\t\tdefine CMD_SZ 200\n+\t\tchar cmd_buf[CMD_SZ];\n+#\t\tdefine RESULT_SZ 200\n+\t\tstatic char result_buf[RESULT_SZ];\n+\t\tsize_t result_len;\n+\t\tstatic GC_bool found_exe_name = FALSE;\n+\t\tstatic GC_bool will_fail = FALSE;\n+\t\tint ret_code;\n+\t\t/* Try to get it via a hairy and expensive scheme.\t*/\n+\t\t/* First we get the name of the executable:\t\t*/\n+\t\tif (will_fail) goto out;\n+\t\tif (!found_exe_name) { \n+\t\t  ret_code = readlink(\"/proc/self/exe\", exe_name, EXE_SZ);\n+\t\t  if (ret_code < 0 || ret_code >= EXE_SZ\n+\t\t      || exe_name[0] != '/') {\n+\t\t    will_fail = TRUE;\t/* Dont try again. */\n+\t\t    goto out;\n+\t\t  }\n+\t\t  exe_name[ret_code] = '\\0';\n+\t\t  found_exe_name = TRUE;\n+\t\t}\n+\t\t/* Then we use popen to start addr2line -e <exe> <addr>\t*/\n+\t\t/* There are faster ways to do this, but hopefully this\t*/\n+\t\t/* isn't time critical.\t\t\t\t\t*/\n+\t\tsprintf(cmd_buf, \"/usr/bin/addr2line -f -e %s 0x%lx\", exe_name,\n+\t\t\t\t (unsigned long)info[i].ci_pc);\n+\t\tpipe = popen(cmd_buf, \"r\");\n+\t\tif (pipe == NULL\n+\t\t    || (result_len = fread(result_buf, 1, RESULT_SZ - 1, pipe))\n+\t\t       == 0) {\n+\t\t  if (pipe != NULL) pclose(pipe);\n+\t\t  will_fail = TRUE;\n+\t\t  goto out;\n+\t\t}\n+\t\tif (result_buf[result_len - 1] == '\\n') --result_len;\n+\t\tresult_buf[result_len] = 0;\n+\t\tif (result_buf[0] == '?'\n+\t\t    || result_buf[result_len-2] == ':' \n+\t\t       && result_buf[result_len-1] == '0') {\n+\t\t    pclose(pipe);\n+\t\t    goto out;\n+\t\t}\n+\t\t/* Get rid of embedded newline, if any.  Test for \"main\" */\n+\t\t{\n+\t\t   char * nl = strchr(result_buf, '\\n');\n+\t\t   if (nl != NULL && nl < result_buf + result_len) {\n+\t\t     *nl = ':';\n+\t\t   }\n+\t\t   if (strncmp(result_buf, \"main\", nl - result_buf) == 0) {\n+\t\t     stop = TRUE;\n+\t\t   }\n+\t\t}\n+\t\tif (result_len < RESULT_SZ - 25) {\n+\t\t  /* Add in hex address\t*/\n+\t\t    sprintf(result_buf + result_len, \" [0x%lx]\",\n+\t\t\t  (unsigned long)info[i].ci_pc);\n+\t\t}\n+\t\tname = result_buf;\n+\t\tpclose(pipe);\n+\t\tout:;\n+\t    }\n+#\t  endif /* LINUX */\n+\t  GC_err_printf1(\"\\t\\t%s\\n\", name);\n+#\t  if defined(GC_HAVE_BUILTIN_BACKTRACE)\n+\t    free(sym_name);  /* May call GC_free; that's OK */\n+#         endif\n+\t}\n     }\n-    return num_read;\n+    LOCK();\n+      --reentry_count;\n+    UNLOCK();\n }\n-#endif /* LINUX && ... */\n+\n+#endif /* NEED_CALLINFO */\n+\n \n \n #if defined(LINUX) && defined(__ELF__) && !defined(SMALL_CONFIG)\n \n /* Dump /proc/self/maps to GC_stderr, to enable looking up names for\n    addresses in FIND_LEAK output. */\n \n+static word dump_maps(char *maps)\n+{\n+    GC_err_write(maps, strlen(maps));\n+    return 1;\n+}\n+\n void GC_print_address_map()\n {\n-    int f;\n-    int result;\n-    char maps_temp[32768];\n     GC_err_printf0(\"---------- Begin address map ----------\\n\");\n-        f = open(\"/proc/self/maps\", O_RDONLY);\n-        if (-1 == f) ABORT(\"Couldn't open /proc/self/maps\");\n-\tdo {\n-\t    result = GC_repeat_read(f, maps_temp, sizeof(maps_temp));\n-\t    if (result <= 0) ABORT(\"Couldn't read /proc/self/maps\");\n- \t    GC_err_write(maps_temp, result);\n-\t} while (result == sizeof(maps_temp));\n-     \n+    GC_apply_to_maps(dump_maps);\n     GC_err_printf0(\"---------- End address map ----------\\n\");\n }\n "}, {"sha": "92f06286e73edab1a276862110d5b90766754033", "filename": "boehm-gc/powerpc_macosx_mach_dep.s", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fpowerpc_macosx_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1de7ead03894075ea7392879654d3d968f044/boehm-gc%2Fpowerpc_macosx_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpowerpc_macosx_mach_dep.s?ref=1cb1de7ead03894075ea7392879654d3d968f044", "patch": "@@ -1,95 +0,0 @@\n-\t\n-.text\n-    \n-    .set   linkageArea,24\n-    .set   params,4\n-    .set   alignment,4\n-\n-    .set   spaceToSave,linkageArea+params+alignment\n-    .set   spaceToSave8,spaceToSave+8\n-\n-; Mark from machine registers that are saved by C compiler\n-    .globl  _GC_push_regs\n-_GC_push_regs:\n-    ; PROLOG\n-    mflr    r0          ; get return address\n-    stw     r0,8(r1)    ; save return address\n-    stwu    r1,-spaceToSave(r1)   ; skip over caller save area\n-    ;\n-    mr      r3,r2         ; mark from r2. Well Im not really sure\n-                          ; that this is necessary or even the right\n-                          ; thing to do - at least it doesnt harm...\n-                          ; According to Apples docs it points to\n-                          ; the direct data area, whatever that is...\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r13        ; mark from r13-r31\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r14\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r15\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r16\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r17\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r18\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r19\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r20\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r21\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r22\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r23\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r24\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r25\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r26\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r27\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r28\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r29\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r30\n-    bl \t    L_GC_push_one$stub\n-    mr      r3,r31\n-    bl \t    L_GC_push_one$stub\n-    ; EPILOG\n-    lwz     r0,spaceToSave8(r1)   ; get return address back\n-    mtlr    r0    ; reset link register\n-    addic   r1,r1,spaceToSave   ; restore stack pointer\n-    blr\n-\n-.data\n-.picsymbol_stub\n-L_GC_push_one$stub:\n-\t.indirect_symbol _GC_push_one\n-\tmflr r0\n-\tbcl 20,31,L0$_GC_push_one\n-L0$_GC_push_one:\n-\tmflr r11\n-\taddis r11,r11,ha16(L_GC_push_one$lazy_ptr-L0$_GC_push_one)\n-\tmtlr r0\n-\tlwz r12,lo16(L_GC_push_one$lazy_ptr-L0$_GC_push_one)(r11)\n-\tmtctr r12\n-\taddi r11,r11,lo16(L_GC_push_one$lazy_ptr-L0$_GC_push_one)\n-\tbctr\n-.data\n-.lazy_symbol_pointer\n-L_GC_push_one$lazy_ptr:\n-\t.indirect_symbol _GC_push_one\n-\t.long dyld_stub_binding_helper\n-.non_lazy_symbol_pointer\n-L_GC_push_one$non_lazy_ptr:\n-\t.indirect_symbol _GC_push_one\n-\t.long 0\n-\t\n-\n-\n-"}, {"sha": "d83d730d3433f5f29b2da36e1c97013869b92394", "filename": "boehm-gc/ptr_chck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fptr_chck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fptr_chck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fptr_chck.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -79,7 +79,7 @@ void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR, GC_PTR))\n \treturn(p);\n     }\n     sz = WORDS_TO_BYTES(hhdr -> hb_sz);\n-    if (sz > WORDS_TO_BYTES(MAXOBJSZ)) {\n+    if (sz > MAXOBJBYTES) {\n       base = (ptr_t)HBLKPTR(p);\n       limit = base + sz;\n       if ((ptr_t)p >= limit) {\n@@ -165,7 +165,7 @@ void (*GC_is_valid_displacement_print_proc) GC_PROTO((GC_PTR)) =\n     pdispl = HBLKDISPL(p);\n     map_entry = MAP_ENTRY((hhdr -> hb_map), pdispl);\n     if (map_entry == OBJ_INVALID\n-    \t|| sz > MAXOBJSZ && (ptr_t)p >= (ptr_t)h + sz) {\n+    \t|| sz > MAXOBJBYTES && (ptr_t)p >= (ptr_t)h + sz) {\n     \tgoto fail;\n     }\n     return(p);"}, {"sha": "323d420fa40accbcac558207a8468ed13939d754", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -27,23 +27,61 @@ signed_word GC_mem_found = 0;\n \t/* nonzero.\t\t\t\t\t\t\t*/\n #endif /* PARALLEL_MARK */\n \n-static void report_leak(p, sz)\n-ptr_t p;\n-word sz;\n+/* We defer printing of leaked objects until we're done with the GC\t*/\n+/* cycle, since the routine for printing objects needs to run outside\t*/\n+/* the collector, e.g. without the allocation lock.\t\t\t*/\n+#define MAX_LEAKED 40\n+ptr_t GC_leaked[MAX_LEAKED];\n+unsigned GC_n_leaked = 0;\n+\n+GC_bool GC_have_errors = FALSE;\n+\n+void GC_add_leaked(leaked)\n+ptr_t leaked;\n {\n-    if (HDR(p) -> hb_obj_kind == PTRFREE) {\n-        GC_err_printf0(\"Leaked atomic object at \");\n-    } else {\n-        GC_err_printf0(\"Leaked composite object at \");\n+    if (GC_n_leaked < MAX_LEAKED) {\n+      GC_have_errors = TRUE;\n+      GC_leaked[GC_n_leaked++] = leaked;\n+      /* Make sure it's not reclaimed this cycle */\n+        GC_set_mark_bit(leaked);\n     }\n-    GC_print_heap_obj(p);\n-    GC_err_printf0(\"\\n\");\n }\n \n+static GC_bool printing_errors = FALSE;\n+/* Print all objects on the list after printing any smashed objs. \t*/\n+/* Clear both lists.\t\t\t\t\t\t\t*/\n+void GC_print_all_errors ()\n+{\n+    unsigned i;\n+\n+    LOCK();\n+    if (printing_errors) {\n+\tUNLOCK();\n+\treturn;\n+    }\n+    printing_errors = TRUE;\n+    UNLOCK();\n+    if (GC_debugging_started) GC_print_all_smashed();\n+    for (i = 0; i < GC_n_leaked; ++i) {\n+\tptr_t p = GC_leaked[i];\n+\tif (HDR(p) -> hb_obj_kind == PTRFREE) {\n+\t    GC_err_printf0(\"Leaked atomic object at \");\n+\t} else {\n+\t    GC_err_printf0(\"Leaked composite object at \");\n+\t}\n+\tGC_print_heap_obj(p);\n+\tGC_err_printf0(\"\\n\");\n+\tGC_free(p);\n+\tGC_leaked[i] = 0;\n+    }\n+    GC_n_leaked = 0;\n+    printing_errors = FALSE;\n+}\n+\n+\n #   define FOUND_FREE(hblk, word_no) \\\n       { \\\n-         report_leak((ptr_t)hblk + WORDS_TO_BYTES(word_no), \\\n-         \t     HDR(hblk) -> hb_sz); \\\n+         GC_add_leaked((ptr_t)hblk + WORDS_TO_BYTES(word_no)); \\\n       }\n \n /*\n@@ -866,7 +904,7 @@ void GC_print_block_list()\n  * Clear *flp.\n  * This must be done before dropping a list of free gcj-style objects,\n  * since may otherwise end up with dangling \"descriptor\" pointers.\n- * It may help for other pointer-containg objects.\n+ * It may help for other pointer-containing objects.\n  */\n void GC_clear_fl_links(flp)\n ptr_t *flp;"}, {"sha": "bae77193593f5e963ccd7b1531f3bb774840a802", "filename": "boehm-gc/solaris_pthreads.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -13,9 +13,8 @@\n /*\n  * Support code for Solaris threads.  Provides functionality we wish Sun\n  * had provided.  Relies on some information we probably shouldn't rely on.\n- * Modified Peter C. for Solaris Posix Threads.\n+ * Modified by Peter C. for Solaris Posix Threads.\n  */\n-/* Boehm, September 14, 1994 4:44 pm PDT */\n \n # if defined(GC_SOLARIS_PTHREADS)\n # include \"private/gc_priv.h\""}, {"sha": "5f05b19e008040b208a691864ad3e31c6125e047", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -37,6 +37,10 @@\n # include <unistd.h>\n # include <errno.h>\n \n+#ifdef HANDLE_FORK\n+  --> Not yet supported.  Try porting the code from linux_threads.c.\n+#endif\n+\n /*\n  * This is the default size of the LWP arrays. If there are more LWPs\n  * than this when a stop-the-world GC happens, set_max_lwps will be\n@@ -361,7 +365,7 @@ static void restart_all_lwps()\n \t\t       sizeof (prgregset_t)) != 0) {\n \t\t    int j;\n \n-\t\t    for(j = 0; j < NGREG; j++)\n+\t\t    for(j = 0; j < NPRGREG; j++)\n \t\t    {\n \t\t\t    GC_printf3(\"%i: %x -> %x\\n\", j,\n \t\t\t\t       GC_lwp_registers[i][j],\n@@ -821,7 +825,7 @@ int GC_thr_suspend(thread_t target_thread)\n     if (result == 0) {\n     \tt = GC_lookup_thread(target_thread);\n     \tif (t == 0) ABORT(\"thread unknown to GC\");\n-        t -> flags |= SUSPENDED;\n+        t -> flags |= SUSPNDED;\n     }\n     UNLOCK();\n     return(result);\n@@ -837,7 +841,7 @@ int GC_thr_continue(thread_t target_thread)\n     if (result == 0) {\n     \tt = GC_lookup_thread(target_thread);\n     \tif (t == 0) ABORT(\"thread unknown to GC\");\n-        t -> flags &= ~SUSPENDED;\n+        t -> flags &= ~SUSPNDED;\n     }\n     UNLOCK();\n     return(result);\n@@ -923,7 +927,7 @@ GC_thr_create(void *stack_base, size_t stack_size,\n     \tmy_flags |= CLIENT_OWNS_STACK;\n     }\n     if (flags & THR_DETACHED) my_flags |= DETACHED;\n-    if (flags & THR_SUSPENDED) my_flags |= SUSPENDED;\n+    if (flags & THR_SUSPENDED) my_flags |= SUSPNDED;\n     result = thr_create(stack, stack_size, start_routine,\n    \t\t        arg, flags & ~THR_DETACHED, &my_new_thread);\n     if (result == 0) {"}, {"sha": "06a0f3b4673a01a91cf1a4c4c3a49e032c6088dd", "filename": "boehm-gc/sparc_mach_dep.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fsparc_mach_dep.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fsparc_mach_dep.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_mach_dep.S?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -37,7 +37,7 @@ loop:\n \tstx %g0,[%o3]\t\t! *(long *)p = 0\n \tcmp %o3,%o1\n \tbgu,pt %xcc, loop\t! if (p > limit) goto loop\n-        add %o3,-8,%o3\t\t! p -= 8 (delay slot)\n+          add %o3,-8,%o3\t! p -= 8 (delay slot)\n \tretl\n     \t  mov %o2,%sp\t\t! Restore sp., delay slot\t\n #else  /* 32 bit SPARC */"}, {"sha": "cfe23c0efdee3df9fc1c69553cadd6a4bded798d", "filename": "boehm-gc/tests/test.c", "status": "modified", "additions": 258, "deletions": 74, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -43,7 +43,7 @@\n #   include \"gc_local_alloc.h\"\n # endif\n # include \"private/gc_priv.h\"\t/* For output, locking, MIN_WORDS, \t*/\n-\t\t\t/* and some statistics.\t\t\t*/\n+\t\t\t\t/* and some statistics.\t\t\t*/\n # include \"private/gcconfig.h\"\n \n # if defined(MSWIN32) || defined(MSWINCE)\n@@ -68,14 +68,14 @@\n #   include <pthread.h>\n # endif\n \n-# ifdef GC_WIN32_THREADS\n-#   ifndef MSWINCE\n-#     include <process.h>\n-#     define GC_CreateThread(a,b,c,d,e,f) ((HANDLE) _beginthreadex(a,b,c,d,e,f))\n-#   endif\n+# if defined(GC_WIN32_THREADS) && !defined(GC_PTHREADS)\n     static CRITICAL_SECTION incr_cs;\n # endif\n \n+#ifdef __STDC__\n+# include <stdarg.h>\n+#endif\n+\n \n /* Allocation Statistics */\n int stubborn_count = 0;\n@@ -205,40 +205,6 @@ sexpr y;\n }\n # endif\n \n-sexpr small_cons (x, y)\n-sexpr x;\n-sexpr y;\n-{\n-    register sexpr r;\n-    \n-    collectable_count++;\n-    r = (sexpr) GC_MALLOC(sizeof(struct SEXPR));\n-    if (r == 0) {\n-        (void)GC_printf0(\"Out of memory\\n\");\n-        exit(1);\n-    }\n-    r -> sexpr_car = x;\n-    r -> sexpr_cdr = y;\n-    return(r);\n-}\n-\n-sexpr small_cons_uncollectable (x, y)\n-sexpr x;\n-sexpr y;\n-{\n-    register sexpr r;\n-    \n-    uncollectable_count++;\n-    r = (sexpr) GC_MALLOC_UNCOLLECTABLE(sizeof(struct SEXPR));\n-    if (r == 0) {\n-        (void)GC_printf0(\"Out of memory\\n\");\n-        exit(1);\n-    }\n-    r -> sexpr_car = x;\n-    r -> sexpr_cdr = (sexpr)(~(unsigned long)y);\n-    return(r);\n-}\n-\n #ifdef GC_GCJ_SUPPORT\n \n #include \"gc_mark.h\"\n@@ -279,6 +245,93 @@ struct GC_ms_entry * fake_gcj_mark_proc(word * addr,\n     return(mark_stack_ptr);\n }\n \n+#endif /* GC_GCJ_SUPPORT */\n+\n+#ifdef THREAD_LOCAL_ALLOC\n+\n+#undef GC_REDIRECT_TO_LOCAL\n+#include \"gc_local_alloc.h\"\n+\n+sexpr local_cons (x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    register sexpr r;\n+    register int *p;\n+    register int my_extra = extra_count;\n+    static int my_random = 0;\n+    \n+    collectable_count++;\n+    r = (sexpr) GC_LOCAL_MALLOC(sizeof(struct SEXPR) + my_extra);\n+#   ifdef GC_GCJ_SUPPORT\n+      if (collectable_count % 2 == 0) {\n+        r = (sexpr) GC_LOCAL_GCJ_MALLOC(sizeof(struct SEXPR) + sizeof(GC_word) + my_extra,\n+\t\t\t\t\t&gcj_class_struct1);\n+        r = (sexpr) ((GC_word *)r + 1);\n+      }\n+#   endif\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    for (p = (int *)r;\n+         ((char *)p) < ((char *)r) + my_extra + sizeof(struct SEXPR); p++) {\n+\tif (*p) {\n+\t    (void)GC_printf1(\"Found nonzero at 0x%lx (local) - allocator is broken\\n\",\n+\t    \t\t     (unsigned long)p);\n+\t    FAIL;\n+        }\n+        *p = 13;\n+    }\n+    r -> sexpr_car = x;\n+    r -> sexpr_cdr = y;\n+    my_extra++;\n+    if ( my_extra >= 5000 || my_extra == 200 && ++my_random % 37 != 0) {\n+        extra_count = 0;\n+    } else {\n+        extra_count = my_extra;\n+    }\n+    return(r);\n+}\n+#endif /* THREAD_LOCAL_ALLOC */\n+\n+sexpr small_cons (x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    register sexpr r;\n+    \n+    collectable_count++;\n+    r = (sexpr) GC_MALLOC(sizeof(struct SEXPR));\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    r -> sexpr_car = x;\n+    r -> sexpr_cdr = y;\n+    return(r);\n+}\n+\n+sexpr small_cons_uncollectable (x, y)\n+sexpr x;\n+sexpr y;\n+{\n+    register sexpr r;\n+    \n+    uncollectable_count++;\n+    r = (sexpr) GC_MALLOC_UNCOLLECTABLE(sizeof(struct SEXPR));\n+    if (r == 0) {\n+        (void)GC_printf0(\"Out of memory\\n\");\n+        exit(1);\n+    }\n+    r -> sexpr_car = x;\n+    r -> sexpr_cdr = (sexpr)(~(unsigned long)y);\n+    return(r);\n+}\n+\n+#ifdef GC_GCJ_SUPPORT\n+\n+\n sexpr gcj_cons(x, y)\n sexpr x;\n sexpr y;\n@@ -323,6 +376,9 @@ sexpr x, y;\n sexpr reverse(x)\n sexpr x;\n {\n+#   ifdef TEST_WITH_SYSTEM_MALLOC\n+      malloc(100000);\n+#   endif\n     return( reverse1(x, nil) );\n }\n \n@@ -365,6 +421,35 @@ int low, up;\n }\n #endif /* GC_GCJ_SUPPORT */\n \n+#ifdef THREAD_LOCAL_ALLOC\n+/* Return reverse(x) concatenated with y */\n+sexpr local_reverse1(x, y)\n+sexpr x, y;\n+{\n+    if (is_nil(x)) {\n+        return(y);\n+    } else {\n+        return( local_reverse1(cdr(x), local_cons(car(x), y)) );\n+    }\n+}\n+\n+sexpr local_reverse(x)\n+sexpr x;\n+{\n+    return( local_reverse1(x, nil) );\n+}\n+\n+sexpr local_ints(low, up)\n+int low, up;\n+{\n+    if (low > up) {\n+\treturn(nil);\n+    } else {\n+        return(local_cons(local_cons(INT_TO_SEXPR(low), nil), local_ints(low+1, up)));\n+    }\n+}\n+#endif /* THREAD_LOCAL_ALLOC */\n+\n /* To check uncollectable allocation we build lists with disguised cdr\t*/\n /* pointers, and make sure they don't go away.\t\t\t\t*/\n sexpr uncollectable_ints(low, up)\n@@ -435,25 +520,24 @@ sexpr x;\n     }\n }\n \n-/* Try to force a to be strangely aligned */\n-struct {\n-  char dummy;\n-  sexpr aa;\n-} A;\n-#define a A.aa\n-\n /*\n  * A tiny list reversal test to check thread creation.\n  */\n #ifdef THREADS\n \n-# ifdef GC_WIN32_THREADS\n-    unsigned __stdcall tiny_reverse_test(void * arg)\n+# if defined(GC_WIN32_THREADS) && !defined(CYGWIN32)\n+    DWORD  __stdcall tiny_reverse_test(void * arg)\n # else\n     void * tiny_reverse_test(void * arg)\n # endif\n {\n-    check_ints(reverse(reverse(ints(1,10))), 1, 10);\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+      check_ints(reverse(reverse(ints(1,10))), 1, 10);\n+#     ifdef THREAD_LOCAL_ALLOC\n+        check_ints(local_reverse(local_reverse(local_ints(1,10))), 1, 10);\n+#     endif\n+    }\n     return 0;\n }\n \n@@ -477,7 +561,7 @@ struct {\n # elif defined(GC_WIN32_THREADS)\n     void fork_a_thread()\n     {\n-  \tunsigned thread_id;\n+  \tDWORD thread_id;\n \tHANDLE h;\n     \th = GC_CreateThread(NULL, 0, tiny_reverse_test, 0, 0, &thread_id);\n         if (h == (HANDLE)NULL) {\n@@ -506,6 +590,13 @@ struct {\n \n #endif \n \n+/* Try to force a to be strangely aligned */\n+struct {\n+  char dummy;\n+  sexpr aa;\n+} A;\n+#define a A.aa\n+\n /*\n  * Repeatedly reverse lists built out of very different sized cons cells.\n  * Check that we didn't lose anything.\n@@ -563,7 +654,9 @@ void reverse_test()\n     h = (sexpr *)GC_REALLOC((GC_PTR)h, 2000 * sizeof(sexpr));\n #   ifdef GC_GCJ_SUPPORT\n       h[1999] = gcj_ints(1,200);\n-      h[1999] = gcj_reverse(h[1999]);\n+      for (i = 0; i < 51; ++i) \n+        h[1999] = gcj_reverse(h[1999]);\n+      /* Leave it as the reveresed list for now. */\n #   else\n       h[1999] = ints(1,200);\n #   endif\n@@ -594,6 +687,9 @@ void reverse_test()\n     \t/* 49 integers.  Thus this is thread safe without locks,\t  */\n     \t/* assuming atomic pointer assignments.\t\t\t\t  */\n         a = reverse(reverse(a));\n+#       ifdef THREAD_LOCAL_ALLOC\n+\t  a = local_reverse(local_reverse(a));\n+#\tendif\n #\tif !defined(AT_END) && !defined(THREADS)\n \t  /* This is not thread safe, since realloc explicitly deallocates */\n           if (i & 1) {\n@@ -621,6 +717,8 @@ void reverse_test()\n     b = c = 0;\n }\n \n+#undef a\n+\n /*\n  * The rest of this builds balanced binary trees, checks that they don't\n  * disappear, and tests finalization.\n@@ -655,15 +753,17 @@ VOLATILE int dropped_something = 0;\n # if  defined(GC_PTHREADS)\n     static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n     pthread_mutex_lock(&incr_lock);\n-# endif\n-# ifdef GC_WIN32_THREADS\n-    EnterCriticalSection(&incr_cs);\n+# else\n+#   ifdef GC_WIN32_THREADS\n+      EnterCriticalSection(&incr_cs);\n+#   endif\n # endif\n   if ((int)(GC_word)client_data != t -> level) {\n      (void)GC_printf0(\"Wrong finalization data - collector is broken\\n\");\n      FAIL;\n   }\n   finalized_count++;\n+  t -> level = -1;\t/* detect duplicate finalization immediately */\n # ifdef PCR\n     PCR_ThCrSec_ExitSys();\n # endif\n@@ -672,9 +772,10 @@ VOLATILE int dropped_something = 0;\n # endif\n # if defined(GC_PTHREADS)\n     pthread_mutex_unlock(&incr_lock);\n-# endif\n-# ifdef GC_WIN32_THREADS\n-    LeaveCriticalSection(&incr_cs);\n+# else\n+#   ifdef GC_WIN32_THREADS\n+      LeaveCriticalSection(&incr_cs);\n+#   endif\n # endif\n }\n \n@@ -746,9 +847,10 @@ int n;\n #         if defined(GC_PTHREADS)\n             static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n             pthread_mutex_lock(&incr_lock);\n-#         endif\n-#         ifdef GC_WIN32_THREADS\n-            EnterCriticalSection(&incr_cs);\n+#         else\n+#           ifdef GC_WIN32_THREADS\n+              EnterCriticalSection(&incr_cs);\n+#           endif\n #         endif\n \t\t/* Losing a count here causes erroneous report of failure. */\n           finalizable_count++;\n@@ -761,9 +863,10 @@ int n;\n #\t  endif\n #\t  if defined(GC_PTHREADS)\n \t    pthread_mutex_unlock(&incr_lock);\n-#\t  endif\n-#         ifdef GC_WIN32_THREADS\n-            LeaveCriticalSection(&incr_cs);\n+#\t  else\n+#           ifdef GC_WIN32_THREADS\n+              LeaveCriticalSection(&incr_cs);\n+#           endif\n #         endif\n \t}\n \n@@ -1068,6 +1171,25 @@ void fail_proc1(GC_PTR x)\n     fail_count++;\n }   \n \n+static void uniq(void *p, ...) {\n+  va_list a;\n+  void *q[100];\n+  int n = 0, i, j;\n+  q[n++] = p;\n+  va_start(a,p);\n+  for (;(q[n] = va_arg(a,void *));n++) ;\n+  va_end(a);\n+  for (i=0; i<n; i++)\n+    for (j=0; j<i; j++)\n+      if (q[i] == q[j]) {\n+        GC_printf0(\n+              \"Apparently failed to mark form some function arguments.\\n\"\n+              \"Perhaps GC_push_regs was configured incorrectly?\\n\"\n+        );\n+\tFAIL;\n+      }\n+}\n+\n #endif /* __STDC__ */\n \n #ifdef THREADS\n@@ -1148,6 +1270,19 @@ void run_one_test()\n     \t\t\"GC_is_valid_displacement produced incorrect result\\n\");\n \tFAIL;\n       }\n+#     if defined(__STDC__) && !defined(MSWIN32) && !defined(MSWINCE)\n+        /* Harder to test under Windows without a gc.h declaration.  */\n+        {\n+\t  size_t i;\n+\t  extern void *GC_memalign();\n+\n+\t  GC_malloc(17);\n+\t  for (i = sizeof(GC_word); i < 512; i *= 2) {\n+\t    GC_word result = (GC_word) GC_memalign(i, 17);\n+\t    if (result % i != 0 || result == 0 || *(int *)result != 0) FAIL;\n+\t  } \n+\t}\n+#     endif\n #     ifndef ALL_INTERIOR_POINTERS\n #      if defined(RS6000) || defined(POWERPC)\n         if (!TEST_FAIL_COUNT(1)) {\n@@ -1167,6 +1302,21 @@ void run_one_test()\n #   ifdef GC_GCJ_SUPPORT\n       GC_REGISTER_DISPLACEMENT(sizeof(struct fake_vtable *));\n       GC_init_gcj_malloc(0, (void *)fake_gcj_mark_proc);\n+#   endif\n+    /* Make sure that fn arguments are visible to the collector.\t*/\n+#   ifdef __STDC__\n+      uniq(\n+        GC_malloc(12), GC_malloc(12), GC_malloc(12),\n+        (GC_gcollect(),GC_malloc(12)),\n+        GC_malloc(12), GC_malloc(12), GC_malloc(12),\n+\t(GC_gcollect(),GC_malloc(12)),\n+        GC_malloc(12), GC_malloc(12), GC_malloc(12),\n+\t(GC_gcollect(),GC_malloc(12)),\n+        GC_malloc(12), GC_malloc(12), GC_malloc(12),\n+\t(GC_gcollect(),GC_malloc(12)),\n+        GC_malloc(12), GC_malloc(12), GC_malloc(12),\n+\t(GC_gcollect(),GC_malloc(12)),\n+        (void *)0);\n #   endif\n     /* Repeated list reversal test. */\n \treverse_test();\n@@ -1183,6 +1333,15 @@ void run_one_test()\n     LOCK();\n     n_tests++;\n     UNLOCK();\n+#   if defined(THREADS) && defined(HANDLE_FORK)\n+      if (fork() == 0) {\n+\tGC_gcollect();\n+\ttiny_reverse_test(0);\n+\tGC_gcollect();\n+\tGC_printf0(\"Finished a child process\\n\");\n+\texit(0);\n+      }\n+#   endif\n     /* GC_printf1(\"Finished %x\\n\", pthread_self()); */\n }\n \n@@ -1202,7 +1361,7 @@ void check_heap_stats()\n     }\n #   else\n     if (sizeof(char *) > 4) {\n-        max_heap_sz = 15000000;\n+        max_heap_sz = 19000000;\n     } else {\n     \tmax_heap_sz = 11000000;\n     }\n@@ -1212,7 +1371,7 @@ void check_heap_stats()\n #       ifdef SAVE_CALL_CHAIN\n \t    max_heap_sz *= 3;\n #           ifdef SAVE_CALL_COUNT\n-\t\tmax_heap_sz *= SAVE_CALL_COUNT/4;\n+\t\tmax_heap_sz += max_heap_sz * SAVE_CALL_COUNT/4;\n #\t    endif\n #       endif\n #   endif\n@@ -1327,6 +1486,10 @@ void SetMinimumStack(long minSize)\n #   endif\n     n_tests = 0;\n     \n+#if defined(__APPLE__) && defined(__MACH__)\n+\tGC_INIT();\n+#endif\n+    \n #   if defined(DJGPP)\n \t/* No good way to determine stack base from library; do it */\n \t/* manually on this platform.\t\t\t\t   */\n@@ -1340,13 +1503,18 @@ void SetMinimumStack(long minSize)\n #   endif\n     GC_INIT();\t/* Only needed if gc is dynamic library.\t*/\n     (void) GC_set_warn_proc(warn_proc);\n-#   if (defined(MPROTECT_VDB) || defined(PROC_VDB)) && !defined(MAKE_BACK_GRAPH)\n+#   if (defined(MPROTECT_VDB) || defined(PROC_VDB)) \\\n+          && !defined(MAKE_BACK_GRAPH)\n       GC_enable_incremental();\n       (void) GC_printf0(\"Switched to incremental mode\\n\");\n #     if defined(MPROTECT_VDB)\n \t(void)GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");\n #     else\n+#       ifdef PROC_VDB\n \t(void)GC_printf0(\"Reading dirty bits from /proc\\n\");\n+#       else\n+    (void)GC_printf0(\"Using DEFAULT_VDB dirty bit implementation\\n\");\n+#       endif\n #      endif\n #   endif\n     run_one_test();\n@@ -1378,9 +1546,9 @@ void SetMinimumStack(long minSize)\n }\n # endif\n \n-#ifdef GC_WIN32_THREADS\n+#if defined(GC_WIN32_THREADS) && !defined(CYGWIN32)\n \n-unsigned __stdcall thr_run_one_test(void *arg)\n+DWORD __stdcall thr_run_one_test(void *arg)\n {\n   run_one_test();\n   return 0;\n@@ -1412,7 +1580,7 @@ LRESULT CALLBACK window_proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n   return ret;\n }\n \n-unsigned __stdcall thr_window(void *arg)\n+DWORD __stdcall thr_window(void *arg)\n {\n   WNDCLASS win_class = {\n     CS_NOCLOSE,\n@@ -1474,10 +1642,11 @@ int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prev, LPSTR cmd, int n)\n # ifdef MSWINCE\n     HANDLE win_thr_h;\n # endif\n-  unsigned thread_id;\n+  DWORD thread_id;\n # if 0\n     GC_enable_incremental();\n # endif\n+  GC_init();\n   InitializeCriticalSection(&incr_cs);\n   (void) GC_set_warn_proc(warn_proc);\n # ifdef MSWINCE\n@@ -1625,15 +1794,30 @@ main()\n           (void)GC_printf0(\"pthread_default_stacksize_np failed.\\n\");\n \t}\n #   endif\t/* GC_HPUX_THREADS */\n+# \tif defined(__APPLE__) && defined(__MACH__)\n+\t\tGC_INIT();\n+#\tendif\n+\n     pthread_attr_init(&attr);\n-#   if defined(GC_IRIX_THREADS) || defined(GC_FREEBSD_THREADS)\n+#   if defined(GC_IRIX_THREADS) || defined(GC_FREEBSD_THREADS) \\\n+    \t|| defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)\n     \tpthread_attr_setstacksize(&attr, 1000000);\n #   endif\n     n_tests = 0;\n-#   if  defined(MPROTECT_VDB) && !defined(PARALLEL_MARK) &&!defined(REDIRECT_MALLOC) && !defined(MAKE_BACK_GRAPH)\n+#   if (defined(MPROTECT_VDB)) \\\n+            && !defined(PARALLEL_MARK) &&!defined(REDIRECT_MALLOC) \\\n+            && !defined(MAKE_BACK_GRAPH)\n     \tGC_enable_incremental();\n         (void) GC_printf0(\"Switched to incremental mode\\n\");\n-\t(void) GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");\n+#     if defined(MPROTECT_VDB)\n+        (void)GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");\n+#     else\n+#       ifdef PROC_VDB\n+            (void)GC_printf0(\"Reading dirty bits from /proc\\n\");\n+#       else\n+            (void)GC_printf0(\"Using DEFAULT_VDB dirty bit implementation\\n\");\n+#       endif\n+#     endif\n #   endif\n     (void) GC_set_warn_proc(warn_proc);\n     if ((code = pthread_key_create(&fl_key, 0)) != 0) {"}, {"sha": "7e50e8aa0fdd0ba20c7e4ce7e5c054ee328d0e74", "filename": "boehm-gc/tests/test_cpp.cc", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ftests%2Ftest_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ftests%2Ftest_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest_cpp.cc?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -28,7 +28,10 @@ few minutes to complete.\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n-#ifdef __GNUC__\n+#define USE_STD_ALLOCATOR\n+#ifdef USE_STD_ALLOCATOR\n+#   include \"gc_allocator.h\"\n+#elif __GNUC__\n #   include \"new_gc_alloc.h\"\n #else\n #   include \"gc_alloc.h\"\n@@ -189,25 +192,32 @@ int APIENTRY WinMain(\n # endif\n #endif\n \n+   GC_init();\n+\n #  if defined(MACOS)                        // MacOS\n     char* argv_[] = {\"test_cpp\", \"10\"};     //   doesn't\n     argv = argv_;                           //     have a\n     argc = sizeof(argv_)/sizeof(argv_[0]);  //       commandline\n #  endif \n     int i, iters, n;\n-#   if !defined(MACOS)\n+#   ifdef USE_STD_ALLOCATOR\n+      int *x = gc_allocator<int>().allocate(1);\n+      int **xptr = traceable_allocator<int *>().allocate(1);\n+#   else \n #     ifdef __GNUC__\n-        int *x = (int *)gc_alloc::allocate(sizeof(int));\n+          int *x = (int *)gc_alloc::allocate(sizeof(int));\n #     else\n-        int *x = (int *)alloc::allocate(sizeof(int));\n+          int *x = (int *)alloc::allocate(sizeof(int));\n #     endif\n-\n-      *x = 29;\n-      x -= 3;\n+#   endif\n+    *x = 29;\n+#   ifdef USE_STD_ALLOCATOR\n+      *xptr = x;\n+      x = 0;\n #   endif\n     if (argc != 2 || (0 >= (n = atoi( argv[ 1 ] )))) {\n-        GC_printf0( \"usage: test_cpp number-of-iterations\\n\" );\n-        exit( 1 );}\n+        GC_printf0( \"usage: test_cpp number-of-iterations\\nAssuming 10 iters\\n\" );\n+        n = 10;}\n         \n     for (iters = 1; iters <= n; iters++) {\n         GC_printf1( \"Starting iteration %d\\n\", iters );\n@@ -268,9 +278,10 @@ int APIENTRY WinMain(\n         D::Test();\n         F::Test();}\n \n-#   if !defined(__GNUC__) && !defined(MACOS)\n-      my_assert (29 == x[3]);\n+#   ifdef USE_STD_ALLOCATOR\n+      x = *xptr;\n #   endif\n+    my_assert (29 == x[0]);\n     GC_printf0( \"The test appears to have succeeded.\\n\" );\n     return( 0 );}\n     "}, {"sha": "247d3c652ec3a71c834879a1c2989de5778308cf", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -4,20 +4,32 @@\n int main()\n {\n #   if defined(GC_USE_LD_WRAP)\n-\tprintf(\"-Wl,--wrap -Wl,read -Wl,--wrap -Wl,dlopen \"\n+\tprintf(\"-Wl,--wrap -Wl,dlopen \"\n \t       \"-Wl,--wrap -Wl,pthread_create -Wl,--wrap -Wl,pthread_join \"\n \t       \"-Wl,--wrap -Wl,pthread_detach \"\n \t       \"-Wl,--wrap -Wl,pthread_sigmask -Wl,--wrap -Wl,sleep\\n\");\n #   endif\n #   if defined(GC_LINUX_THREADS) || defined(GC_IRIX_THREADS) \\\n-\t|| defined(GC_FREEBSD_THREADS) || defined(GC_SOLARIS_PTHREADS)\n+\t|| defined(GC_FREEBSD_THREADS) || defined(GC_SOLARIS_PTHREADS) \\\n+\t|| defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)\n         printf(\"-lpthread\\n\");\n #   endif\n #   if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n \tprintf(\"-lpthread -lrt\\n\");\n #   endif\n #   if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n         printf(\"-lthread -ldl\\n\");\n+#   endif\n+#   if defined(GC_WIN32_THREADS) && defined(CYGWIN32)\n+        printf(\"-lpthread\\n\");\n+#   endif\n+#   if defined(GC_OSF1_THREADS)\n+\tprintf(\"-pthread -lrt\"); /* DOB: must be -pthread, not -lpthread */\n+#   endif\n+    /* You need GCC 3.0.3 to build this one!           */  \n+    /* DG/UX native gcc doesnt know what \"-pthread\" is */\n+#   if defined(GC_DGUX386_THREADS)\n+        printf(\"-ldl -pthread\\n\");\n #   endif\n     return 0;\n }"}, {"sha": "a081c9797c30248a95c58ee829b9913c76a51887", "filename": "boehm-gc/typd_mlc.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ftypd_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Ftypd_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftypd_mlc.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -437,6 +437,7 @@ void GC_init_explicit_typing()\n     for (; bm != 0; bm >>= 1, current_p++) {\n     \tif (bm & 1) {\n     \t    current = *current_p;\n+\t    FIXUP_POINTER(current);\n     \t    if ((ptr_t)current >= least_ha && (ptr_t)current <= greatest_ha) {\n     \t        PUSH_CONTENTS((ptr_t)current, mark_stack_ptr,\n \t\t\t      mark_stack_limit, current_p, exit1);\n@@ -674,9 +675,9 @@ DCL_LOCK_STATE;\n         if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\n             FASTUNLOCK();\n             op = (ptr_t)GENERAL_MALLOC((word)lb, GC_explicit_kind);\n-\t    if (0 == op) return(0);\n+\t    if (0 == op) return 0;\n #\t    ifdef MERGE_SIZES\n-\t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/            \n+\t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/\n #\t    endif\n         } else {\n             *opp = obj_link(op);\n@@ -720,7 +721,7 @@ DCL_LOCK_STATE;\n             FASTUNLOCK();\n             op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_explicit_kind);\n #\t    ifdef MERGE_SIZES\n-\t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/            \n+\t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/\n #\t    endif\n         } else {\n             *opp = obj_link(op);"}, {"sha": "9d858b2aaa6798dcc23016a9788c13497aeab3d3", "filename": "boehm-gc/version.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,11 +1,30 @@\n-#define GC_VERSION_MAJOR 6\n-#define GC_VERSION_MINOR 1\n-#define GC_ALPHA_VERSION 3\n+/* The version here should match that in configure/configure.in\t*/\n+/* Eventually this one may become unnecessary.  For now we need\t*/\n+/* it to keep the old-style build process working.\t\t*/\n+#define GC_TMP_VERSION_MAJOR 6\n+#define GC_TMP_VERSION_MINOR 3\n+#define GC_TMP_ALPHA_VERSION 1\n \n+#ifndef GC_NOT_ALPHA\n #   define GC_NOT_ALPHA 0xff\n+#endif\n+\n+#if defined(GC_VERSION_MAJOR)\n+# if GC_TMP_VERSION_MAJOR != GC_VERSION_MAJOR || \\\n+     GC_TMP_VERSION_MINOR != GC_VERSION_MINOR || \\\n+     defined(GC_ALPHA_VERSION) != (GC_TMP_ALPHA_VERSION != GC_NOT_ALPHA) || \\\n+     defined(GC_ALPHA_VERSION) && GC_TMP_ALPHA_VERSION != GC_ALPHA_VERSION\n+#   error Inconsistent version info.  Check version.h and configure.in.\n+# endif\n+#else\n+# define GC_VERSION_MAJOR GC_TMP_VERSION_MAJOR\n+# define GC_VERSION_MINOR GC_TMP_VERSION_MINOR\n+# define GC_ALPHA_VERSION GC_TMP_ALPHA_VERSION\n+#endif\n+\n \n #ifndef GC_NO_VERSION_VAR\n \n-unsigned GC_version = ((GC_VERSION_MAJOR << 16) | (GC_VERSION_MINOR << 8) | GC_ALPHA_VERSION);\n+unsigned GC_version = ((GC_VERSION_MAJOR << 16) | (GC_VERSION_MINOR << 8) | GC_TMP_ALPHA_VERSION);\n \n #endif /* GC_NO_VERSION_VAR */ "}, {"sha": "ff1d06625f86d3de60aa5f216066974e27607f0f", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 317, "deletions": 83, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c3de1ffb2daa8b2b8281bcece806793c4d4803/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=30c3de1ffb2daa8b2b8281bcece806793c4d4803", "patch": "@@ -1,13 +1,28 @@\n-#if defined(GC_WIN32_THREADS)\n+#if defined(GC_WIN32_THREADS) \n \n #include \"private/gc_priv.h\"\n-\n-#if 0\n-#define STRICT\n #include <windows.h>\n+\n+#ifdef CYGWIN32\n+# include <errno.h>\n+\n+ /* Cygwin-specific forward decls */\n+# undef pthread_create \n+# undef pthread_sigmask \n+# undef pthread_join \n+# undef dlopen \n+\n+# define DEBUG_CYGWIN_THREADS 0\n+\n+  GC_bool GC_thr_initialized = FALSE;\n+  void * GC_start_routine(void * arg);\n+  void GC_thread_exit_proc(void *arg);\n+\n #endif\n \n-#define MAX_THREADS 64\n+#ifndef MAX_THREADS\n+# define MAX_THREADS 64\n+#endif\n \n struct thread_entry {\n   LONG in_use;\n@@ -18,6 +33,12 @@ struct thread_entry {\n \t\t\t/* !in_use ==> stack == 0\t*/\n   CONTEXT context;\n   GC_bool suspended;\n+\n+# ifdef CYGWIN32\n+    void *status; /* hold exit value until join in case it's a pointer */\n+    pthread_t pthread_id;\n+# endif\n+\n };\n \n volatile GC_bool GC_please_stop = FALSE;\n@@ -29,13 +50,23 @@ void GC_push_thread_structures GC_PROTO((void))\n     /* Unlike the other threads implementations, the thread table here\t*/\n     /* contains no pointers to the collectable heap.  Thus we have\t*/\n     /* no private structures we need to preserve.\t\t\t*/\n+# ifdef CYGWIN32\n+  { int i; /* pthreads may keep a pointer in the thread exit value */\n+    for (i = 0; i < MAX_THREADS; i++)\n+      if (thread_table[i].in_use) GC_push_all((ptr_t)&(thread_table[i].status),(ptr_t)(&(thread_table[i].status)+1));\n+  }\n+# endif\n }\n \n void GC_stop_world()\n {\n   DWORD thread_id = GetCurrentThreadId();\n   int i;\n \n+#ifdef CYGWIN32\n+  if (!GC_thr_initialized) ABORT(\"GC_stop_world() called before GC_thr_init()\");\n+#endif\n+\n   GC_please_stop = TRUE;\n   for (i = 0; i < MAX_THREADS; i++)\n     if (thread_table[i].stack != 0\n@@ -53,11 +84,15 @@ void GC_stop_world()\n \tDWORD exitCode; \n \tif (GetExitCodeThread(thread_table[i].handle,&exitCode) &&\n             exitCode != STILL_ACTIVE) {\n-            thread_table[i].stack = 0;\n+          thread_table[i].stack = 0; /* prevent stack from being pushed */\n+#         ifndef CYGWIN32\n+            /* this breaks pthread_join on Cygwin, which is guaranteed to  */\n+\t    /* only see user pthreads \t\t\t\t\t   */\n \t    thread_table[i].in_use = FALSE;\n \t    CloseHandle(thread_table[i].handle);\n \t    BZERO((void *)(&thread_table[i].context), sizeof(CONTEXT));\n-\t    continue;\n+#         endif\n+\t  continue;\n \t}\n \tif (SuspendThread(thread_table[i].handle) == (DWORD)-1)\n \t  ABORT(\"SuspendThread failed\");\n@@ -335,9 +370,13 @@ void GC_get_next_stack(char *start, char **lo, char **hi)\n     if (*lo < start) *lo = start;\n }\n \n-#if !defined(MSWINCE) && !(defined(__MINGW32__) && !defined(_DLL))\n+#if !defined(CYGWIN32)\n \n-HANDLE WINAPI GC_CreateThread(\n+#if !defined(MSWINCE) && defined(GC_DLL)\n+\n+/* We register threads from DllMain */\n+\n+GC_API HANDLE GC_CreateThread(\n     LPSECURITY_ATTRIBUTES lpThreadAttributes, \n     DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, \n     LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId )\n@@ -346,7 +385,10 @@ HANDLE WINAPI GC_CreateThread(\n                         lpParameter, dwCreationFlags, lpThreadId);\n }\n \n-#else /* !defined(MSWINCE) && !(defined(__MINGW32__) && !defined(_DLL)) */\n+#else /* defined(MSWINCE) || !defined(GC_DLL))  */\n+\n+/* We have no DllMain to take care of new threads.  Thus we\t*/\n+/* must properly intercept thread creation.\t\t\t*/\n \n typedef struct {\n     HANDLE child_ready_h, parent_ready_h;\n@@ -400,7 +442,17 @@ HANDLE WINAPI GC_CreateThread(\n \n \t\t    /* fill in ID and handle; tell child this is done */\n \t\t    thread_table[i].id = *lpThreadId;\n-\t\t    thread_table[i].handle = thread_h;\n+\t\t    if (!DuplicateHandle(GetCurrentProcess(),\n+\t\t\t\t \t thread_h,\n+\t\t\t\t\t GetCurrentProcess(),\n+\t\t\t \t\t &thread_table[i].handle,\n+\t\t\t  \t\t 0,\n+\t\t\t\t\t 0,\n+\t\t\t\t\t DUPLICATE_SAME_ACCESS)) {\n+\t\t\tDWORD last_error = GetLastError();\n+\t\t\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n+\t\t\tABORT(\"DuplicateHandle failed\");\n+\t\t    }\n \t\t    SetEvent (parent_ready_h);\n \n \t\t    /* wait for child to fill in stack and copy args */\n@@ -470,7 +522,9 @@ static DWORD WINAPI thread_start(LPVOID arg)\n \n     return ret;\n }\n-#endif /* !defined(MSWINCE) && !(defined(__MINGW32__) && !defined(_DLL)) */\n+#endif /* !defined(MSWINCE) && !(defined(__MINGW32__) && !defined(_DLL))  */\n+\n+#endif /* !CYGWIN32 */\n \n #ifdef MSWINCE\n \n@@ -527,13 +581,255 @@ DWORD WINAPI main_thread_start(LPVOID arg)\n \n LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info);\n \n-#ifdef GC_DLL\n+/* threadAttach/threadDetach routines used by both CYGWIN and DLL\n+ * implementation, since both recieve explicit notification on thread\n+ * creation/destruction.\n+ */\n+static void threadAttach() {\n+  int i;\n+  /* It appears to be unsafe to acquire a lock here, since this\t*/\n+  /* code is apparently not preeemptible on some systems.\t*/\n+  /* (This is based on complaints, not on Microsoft's official\t*/\n+  /* documentation, which says this should perform \"only simple\t*/\n+  /* inititalization tasks\".)\t\t\t\t\t*/\n+  /* Hence we make do with nonblocking synchronization.\t\t*/\n+\n+  /* The following should be a noop according to the win32\t*/\n+  /* documentation.  There is empirical evidence that it\t*/\n+  /* isn't.\t\t- HB\t\t\t\t\t*/\n+# if defined(MPROTECT_VDB)\n+   if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n+# endif\n+                /* cast away volatile qualifier */\n+  for (i = 0; InterlockedExchange((LONG*)&thread_table[i].in_use,1) != 0; i++) {\n+    /* Compare-and-swap would make this cleaner, but that's not \t*/\n+    /* supported before Windows 98 and NT 4.0.  In Windows 2000,\t*/\n+    /* InterlockedExchange is supposed to be replaced by\t\t*/\n+    /* InterlockedExchangePointer, but that's not really what I\t*/\n+    /* want here.\t\t\t\t\t\t\t*/\n+    if (i == MAX_THREADS - 1)\n+      ABORT(\"too many threads\");\n+  }\n+  thread_table[i].id = GetCurrentThreadId();\n+# ifdef CYGWIN32\n+    thread_table[i].pthread_id = pthread_self();\n+# endif\n+  if (!DuplicateHandle(GetCurrentProcess(),\n+\t               GetCurrentThread(),\n+\t\t       GetCurrentProcess(),\n+\t\t       (HANDLE*)&thread_table[i].handle,\n+\t\t       0,\n+\t\t       0,\n+\t\t       DUPLICATE_SAME_ACCESS)) {\n+\tDWORD last_error = GetLastError();\n+\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n+\tABORT(\"DuplicateHandle failed\");\n+  }\n+  thread_table[i].stack = GC_get_stack_base();\n+  if (thread_table[i].stack == NULL) \n+    ABORT(\"Failed to find stack base in threadAttach\");\n+  /* If this thread is being created while we are trying to stop\t*/\n+  /* the world, wait here.  Hopefully this can't happen on any\t*/\n+  /* systems that don't allow us to block here.\t\t\t*/\n+  while (GC_please_stop) Sleep(20);\n+}\n+\n+static void threadDetach(DWORD thread_id) {\n+  int i;\n+\n+  LOCK();\n+  for (i = 0;\n+       i < MAX_THREADS &&\n+       (!thread_table[i].in_use || thread_table[i].id != thread_id);\n+       i++) {}\n+  if (i >= MAX_THREADS ) {\n+    WARN(\"thread %ld not found on detach\", (GC_word)thread_id);\n+  } else {\n+    thread_table[i].stack = 0;\n+    thread_table[i].in_use = FALSE;\n+    CloseHandle(thread_table[i].handle);\n+      /* cast away volatile qualifier */\n+    BZERO((void *)&thread_table[i].context, sizeof(CONTEXT));\n+  }\n+  UNLOCK();\n+}\n+\n+#ifdef CYGWIN32\n+\n+/* Called by GC_init() - we hold the allocation lock.\t*/\n+void GC_thr_init() {\n+    if (GC_thr_initialized) return;\n+    GC_thr_initialized = TRUE;\n+\n+#if 0\n+    /* this might already be handled in GC_init... */\n+    InitializeCriticalSection(&GC_allocate_ml);\n+#endif\n+\n+    /* Add the initial thread, so we can stop it.\t*/\n+    threadAttach();\n+}\n+\n+struct start_info {\n+    void *(*start_routine)(void *);\n+    void *arg;\n+};\n+\n+int GC_pthread_join(pthread_t pthread_id, void **retval) {\n+    int result;\n+    int i;\n+\n+#   if DEBUG_CYGWIN_THREADS\n+      GC_printf3(\"thread 0x%x(0x%x) is joining thread 0x%x.\\n\",(int)pthread_self(),\n+\t\t GetCurrentThreadId(), (int)pthread_id);\n+#   endif\n+\n+    /* Can't do any table lookups here, because thread being joined \n+       might not have registered itself yet */\n+\n+    result = pthread_join(pthread_id, retval);\n+\n+    LOCK();\n+    for (i = 0; !thread_table[i].in_use || thread_table[i].pthread_id != pthread_id;\n+         i++) {\n+      if (i == MAX_THREADS - 1) {\n+        GC_printf1(\"Failed to find thread 0x%x in pthread_join()\\n\", pthread_id);\n+        ABORT(\"thread not found on detach\");\n+      }\n+    }\n+    UNLOCK();\n+    threadDetach(thread_table[i].id);\n+\n+#   if DEBUG_CYGWIN_THREADS\n+      GC_printf3(\"thread 0x%x(0x%x) completed join with thread 0x%x.\\n\",\n+\t\t (int)pthread_self(), GetCurrentThreadId(), (int)pthread_id);\n+#   endif\n+\n+    return result;\n+}\n+\n+/* Cygwin-pthreads calls CreateThread internally, but it's not\n+ * easily interceptible by us..\n+ *   so intercept pthread_create instead\n+ */\n+int\n+GC_pthread_create(pthread_t *new_thread,\n+\t\t  const pthread_attr_t *attr,\n+                  void *(*start_routine)(void *), void *arg) {\n+    int result;\n+    struct start_info * si;\n+\n+    if (!GC_is_initialized) GC_init();\n+    \t\t/* make sure GC is initialized (i.e. main thread is attached) */\n+    \n+    /* This is otherwise saved only in an area mmapped by the thread */\n+    /* library, which isn't visible to the collector.\t\t */\n+    si = GC_malloc_uncollectable(sizeof(struct start_info)); \n+    if (0 == si) return(EAGAIN);\n+\n+    si -> start_routine = start_routine;\n+    si -> arg = arg;\n+\n+#   if DEBUG_CYGWIN_THREADS\n+      GC_printf2(\"About to create a thread from 0x%x(0x%x)\\n\",(int)pthread_self(),\n+\t\t      \t\t\t\t\t      GetCurrentThreadId);\n+#   endif\n+    result = pthread_create(new_thread, attr, GC_start_routine, si); \n+\n+    if (result) { /* failure */\n+      \tGC_free(si);\n+    } \n+\n+    return(result);\n+}\n+\n+void * GC_start_routine(void * arg)\n+{\n+    struct start_info * si = arg;\n+    void * result;\n+    void *(*start)(void *);\n+    void *start_arg;\n+    pthread_t pthread_id;\n+    int i;\n+\n+#   if DEBUG_CYGWIN_THREADS\n+      GC_printf2(\"thread 0x%x(0x%x) starting...\\n\",(int)pthread_self(),\n+\t\t      \t\t\t\t   GetCurrentThreadId());\n+#   endif\n+\n+    /* If a GC occurs before the thread is registered, that GC will\t*/\n+    /* ignore this thread.  That's fine, since it will block trying to  */\n+    /* acquire the allocation lock, and won't yet hold interesting \t*/\n+    /* pointers.\t\t\t\t\t\t\t*/\n+    LOCK();\n+    /* We register the thread here instead of in the parent, so that\t*/\n+    /* we don't need to hold the allocation lock during pthread_create. */\n+    threadAttach();\n+    UNLOCK();\n+\n+    start = si -> start_routine;\n+    start_arg = si -> arg;\n+    pthread_id = pthread_self();\n+\n+    GC_free(si); /* was allocated uncollectable */\n+\n+    pthread_cleanup_push(GC_thread_exit_proc, pthread_id);\n+    result = (*start)(start_arg);\n+    pthread_cleanup_pop(0);\n+\n+#   if DEBUG_CYGWIN_THREADS\n+      GC_printf2(\"thread 0x%x(0x%x) returned from start routine.\\n\",\n+\t\t (int)pthread_self(),GetCurrentThreadId());\n+#   endif\n+\n+    LOCK();\n+    for (i = 0; thread_table[i].pthread_id != pthread_id; i++) {\n+      if (i == MAX_THREADS - 1)\n+        ABORT(\"thread not found on exit\");\n+    }\n+    thread_table[i].status = result;\n+    UNLOCK();\n+\n+    return(result);\n+}\n+\n+void GC_thread_exit_proc(void *arg)\n+{\n+    pthread_t pthread_id = (pthread_t)arg;\n+    int i;\n+\n+#   if DEBUG_CYGWIN_THREADS\n+      GC_printf2(\"thread 0x%x(0x%x) called pthread_exit().\\n\",\n+\t\t (int)pthread_self(),GetCurrentThreadId());\n+#   endif\n+\n+    LOCK();\n+    for (i = 0; thread_table[i].pthread_id != pthread_id; i++) {\n+      if (i == MAX_THREADS - 1)\n+        ABORT(\"thread not found on exit\");\n+    }\n+    UNLOCK();\n+\n+#if 0\n+    /* TODO: we need a way to get the exit value after a pthread_exit so we can stash it safely away */\n+    thread_table[i].status = ???\n+#endif\n+}\n+\n+/* nothing required here... */\n+int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset) {\n+  return pthread_sigmask(how, set, oset);\n+}\n+int GC_pthread_detach(pthread_t thread) {\n+  return pthread_detach(thread);\n+}\n+#else /* !CYGWIN32 */\n \n /*\n- * This isn't generally safe, since DllMain is not premptible.\n- * If another thread holds the lock while this runs we're in trouble.\n+ * We avoid acquiring locks here, since this doesn't seem to be preemptable.\n  * Pontus Rydin suggests wrapping the thread start routine instead.\n  */\n+#ifdef GC_DLL\n BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n {\n   switch (reason) {\n@@ -542,75 +838,13 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n     GC_init();\t/* Force initialization before thread attach.\t*/\n     /* fall through */\n   case DLL_THREAD_ATTACH:\n-    {\n-      int i;\n-      /* It appears to be unsafe to acquire a lock here, since this\t*/\n-      /* code is apparently not preeemptible on some systems.\t\t*/\n-      /* (This is based on complaints, not on Microsoft's official\t*/\n-      /* documentation, which says this should perform \"only simple\t*/\n-      /* inititalization tasks\".)\t\t\t\t\t*/\n-      /* Hence we make do with nonblocking synchronization.\t\t*/\n-\n-      /* The following should be a noop according to the win32\t*/\n-      /* documentation.  There is empirical evidence that it\t*/\n-      /* isn't.\t\t- HB\t\t\t\t\t*/\n-#     ifdef MPROTECT_VDB\n-       if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n-#     endif\n-\n-      for (i = 0;\n-\t\t\t       /* cast away volatile qualifier */\n-\t   InterlockedExchange((LPLONG) &thread_table[i].in_use, 1) != 0;\n-\t   i++) {\n-\t/* Compare-and-swap would make this cleaner, but that's not \t*/\n-\t/* supported before Windows 98 and NT 4.0.  In Windows 2000,\t*/\n-\t/* InterlockedExchange is supposed to be replaced by\t\t*/\n-\t/* InterlockedExchangePointer, but that's not really what I\t*/\n-\t/* want here.\t\t\t\t\t\t\t*/\n-\tif (i == MAX_THREADS - 1)\n-\t  ABORT(\"too many threads\");\n-      }\n-      thread_table[i].id = GetCurrentThreadId();\n-      if (!DuplicateHandle(GetCurrentProcess(),\n-\t\t\t   GetCurrentThread(),\n-\t\t\t   GetCurrentProcess(),\n-\t\t\t   /* cast away volatile qualifier */\n-\t\t\t   (HANDLE *) &thread_table[i].handle,\n-\t\t\t   0,\n-\t\t\t   0,\n-\t\t\t   DUPLICATE_SAME_ACCESS)) {\n-\tDWORD last_error = GetLastError();\n-\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n-\tABORT(\"DuplicateHandle failed\");\n-      }\n-      thread_table[i].stack = GC_get_stack_base();\n-      /* If this thread is being created while we are trying to stop\t*/\n-      /* the world, wait here.  Hopefully this can't happen on any\t*/\n-      /* systems that don't allow us to block here.\t\t\t*/\n-      while (GC_please_stop) Sleep(20);\n-    }\n+    threadAttach();\n     break;\n+\n   case DLL_THREAD_DETACH:\n-    {\n-      int i;\n-      DWORD thread_id = GetCurrentThreadId();\n-      LOCK();\n-      for (i = 0;\n-           i < MAX_THREADS &&\n-\t   (thread_table[i].stack == 0 || thread_table[i].id != thread_id);\n-\t   i++) {}\n-      if (i >= MAX_THREADS) {\n-\t  WARN(\"thread %ld not found on detach\", (GC_word)thread_id);\n-      } else {\n-          thread_table[i].stack = 0;\n-          thread_table[i].in_use = FALSE;\n-          CloseHandle(thread_table[i].handle);\n-\t    /* cast away volatile qualifier */\n-          BZERO((void *) &thread_table[i].context, sizeof(CONTEXT));\n-      }\n-      UNLOCK();\n-    }\n+    threadDetach(GetCurrentThreadId());\n     break;\n+\n   case DLL_PROCESS_DETACH:\n     {\n       int i;\n@@ -636,8 +870,8 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n   }\n   return TRUE;\n }\n-\n-#   endif /* GC_DLL */\n+#endif /* GC_DLL */\n+#endif /* !CYGWIN32 */\n \n # endif /* !MSWINCE */\n "}]}