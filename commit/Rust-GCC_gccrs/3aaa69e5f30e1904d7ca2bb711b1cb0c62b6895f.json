{"sha": "3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhYTY5ZTVmMzBlMTkwNGQ3Y2EyYmI3MTFiMWNiMGM2MmI2ODk1Zg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T14:19:31Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-22T12:11:44Z"}, "message": "Initial value-relation code.\n\nThis code provides a both an equivalence and relation oracle which can be\naccessed via a range_query object.  This initial code drop includes the\noracles and access them, but does not utilize them yet.\n\n\t* Makefile.in (OBJS): Add value-relation.o.\n\t* gimple-range.h: Adjust include files.\n\t* tree-data-ref.c: Adjust include file order.\n\t* value-query.cc (range_query::get_value_range): Default to no oracle.\n\t(range_query::query_relation): New.\n\t(range_query::query_relation): New.\n\t* value-query.h (class range_query): Adjust.\n\t* value-relation.cc: New.\n\t* value-relation.h: New.", "tree": {"sha": "1caa5a6f5da442c5a2f837f34ea20d3b41d85996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1caa5a6f5da442c5a2f837f34ea20d3b41d85996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/comments", "author": null, "committer": null, "parents": [{"sha": "a2ef8395fa970498985764514044e5fd00f7d5c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ef8395fa970498985764514044e5fd00f7d5c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ef8395fa970498985764514044e5fd00f7d5c0"}], "stats": {"total": 1157, "additions": 1155, "deletions": 2}, "files": [{"sha": "ebf264429921883a408f5bddb4e4b8b6b535721e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -1688,6 +1688,7 @@ OBJS = \\\n \tvalue-query.o \\\n \tvalue-range.o \\\n \tvalue-range-equiv.o \\\n+\tvalue-relation.o \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\\n \tvarasm.o \\"}, {"sha": "b9cffdb8ee07c2595ef96b3d7f50e3f6e230919e", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -24,8 +24,8 @@ along with GCC; see the file COPYING3.  If not see\n \n \n #include \"range.h\"\n-#include \"range-op.h\"\n #include \"value-query.h\"\n+#include \"range-op.h\"\n #include \"gimple-range-edge.h\"\n #include \"gimple-range-gori.h\"\n #include \"gimple-range-cache.h\""}, {"sha": "b6abd8b8de7299f97311c270954acda03033b956", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -97,8 +97,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"ssa.h\"\n #include \"internal-fn.h\"\n-#include \"range-op.h\"\n #include \"vr-values.h\"\n+#include \"range-op.h\"\n \n static struct datadep_stats\n {"}, {"sha": "17dfdb1ccbe95e0f118a2ba63d309e2b1d29d45b", "filename": "gcc/value-query.cc", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -174,6 +174,7 @@ range_query::get_value_range (const_tree expr, gimple *stmt)\n range_query::range_query ()\n {\n   equiv_alloc = new equiv_allocator;\n+  m_oracle = NULL;\n }\n \n range_query::~range_query ()\n@@ -452,3 +453,52 @@ global_range_query::range_of_expr (irange &r, tree expr, gimple *stmt)\n \n   return true;\n }\n+\n+// Return any known relation between SSA1 and SSA2 before stmt S is executed.\n+// If GET_RANGE is true, query the range of both operands first to ensure\n+// the defintions have been processed and any relations have be created.\n+\n+relation_kind\n+range_query::query_relation (gimple *s, tree ssa1, tree ssa2, bool get_range)\n+{\n+  int_range_max tmp;\n+  if (!m_oracle || TREE_CODE (ssa1) != SSA_NAME || TREE_CODE (ssa2) != SSA_NAME)\n+    return VREL_NONE;\n+\n+  // Ensure ssa1 and ssa2 have both been evaluated.\n+  if (get_range)\n+    {\n+      range_of_expr (tmp, ssa1, s);\n+      range_of_expr (tmp, ssa2, s);\n+    }\n+  return m_oracle->query_relation (gimple_bb (s), ssa1, ssa2);\n+}\n+\n+// Return any known relation between SSA1 and SSA2 on edge E.\n+// If GET_RANGE is true, query the range of both operands first to ensure\n+// the defintions have been processed and any relations have be created.\n+\n+relation_kind\n+range_query::query_relation (edge e, tree ssa1, tree ssa2, bool get_range)\n+{\n+  basic_block bb;\n+  int_range_max tmp;\n+  if (!m_oracle || TREE_CODE (ssa1) != SSA_NAME || TREE_CODE (ssa2) != SSA_NAME)\n+    return VREL_NONE;\n+\n+  // Use destination block if it has a single predecessor, and this picks\n+  // up any relation on the edge.\n+  // Otherwise choose the src edge and the result is the same as on-exit.\n+  if (!single_pred_p (e->dest))\n+    bb = e->src;\n+  else\n+    bb = e->dest;\n+\n+  // Ensure ssa1 and ssa2 have both been evaluated.\n+  if (get_range)\n+    {\n+      range_on_edge (tmp, e, ssa1);\n+      range_on_edge (tmp, e, ssa2);\n+    }\n+  return m_oracle->query_relation (bb, ssa1, ssa2);\n+}"}, {"sha": "5161d23714b4e94f66648325f7df77a3e6b75228", "filename": "gcc/value-query.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_QUERY_H\n #define GCC_QUERY_H\n \n+#include \"value-relation.h\"\n+\n // The value_query class is used by optimization passes that require\n // valueizing SSA names in terms of a tree value, but have no neeed\n // for ranges.\n@@ -91,6 +93,14 @@ class range_query : public value_query\n   virtual bool range_on_edge (irange &r, edge, tree expr);\n   virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL);\n \n+  // Query if there is any relation between SSA1 and SSA2.\n+  relation_kind query_relation (gimple *s, tree ssa1, tree ssa2,\n+\t\t\t\tbool get_range = true);\n+  relation_kind query_relation (edge e, tree ssa1, tree ssa2,\n+\t\t\t\tbool get_range = true);\n+  // If present, Access relation oracle for more advanced uses.\n+  inline relation_oracle *oracle () const  { return m_oracle; }\n+\n   // DEPRECATED: This method is used from vr-values.  The plan is to\n   // rewrite all uses of it to the above API.\n   virtual const class value_range_equiv *get_value_range (const_tree,\n@@ -102,6 +112,7 @@ class range_query : public value_query\n   void free_value_range_equiv (class value_range_equiv *);\n   bool get_tree_range (irange &r, tree expr, gimple *stmt);\n   bool get_arith_expr_range (irange &r, tree expr, gimple *stmt);\n+  relation_oracle *m_oracle;\n \n private:\n   class equiv_allocator *equiv_alloc;"}, {"sha": "3c8698f2a54798ce103cb84c0a0279213f82228d", "filename": "gcc/value-relation.cc", "status": "added", "additions": 932, "deletions": 0, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -0,0 +1,932 @@\n+/* Header file for the value range relational processing.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+\n+#include \"gimple-range.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"alloc-pool.h\"\n+#include \"dominance.h\"\n+\n+// These VREL codes are arranged such that VREL_NONE is the first\n+// code, and all the rest are contiguous up to and including VREL_LAST.\n+\n+#define VREL_FIRST              VREL_NONE\n+#define VREL_LAST               NE_EXPR\n+#define VREL_COUNT              (VREL_LAST - VREL_FIRST + 1)\n+\n+// vrel_range_assert will either assert that the tree code passed is valid,\n+// or mark invalid codes as unreachable to help with table optimation.\n+#if CHECKING_P\n+  #define vrel_range_assert(c) \t\t\t\\\n+    gcc_checking_assert ((c) >= VREL_FIRST && (c) <= VREL_LAST)\n+#else\n+  #define vrel_range_assert(c)\t\t\t\\\n+    if ((c) < VREL_FIRST || (c) > VREL_LAST)\t\\\n+      gcc_unreachable ();\n+#endif\n+\n+static const char *kind_string[VREL_COUNT] =\n+{ \"none\", \"<\", \"<=\", \">\", \">=\", \"empty\", \"==\", \"!=\" };\n+\n+// Print a relation_kind REL to file F.\n+\n+void\n+print_relation (FILE *f, relation_kind rel)\n+{\n+  vrel_range_assert (rel);\n+  fprintf (f, \" %s \", kind_string[rel - VREL_FIRST]);\n+}\n+\n+// This table is used to negate the operands.  op1 REL op2 -> !(op1 REL op2).\n+relation_kind rr_negate_table[VREL_COUNT] = {\n+//     NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY,      EQ_EXPR, NE_EXPR\n+  VREL_NONE, GE_EXPR, GT_EXPR, LE_EXPR, LT_EXPR, VREL_EMPTY, NE_EXPR, EQ_EXPR };\n+\n+// Negate the relation, as in logical negation.\n+\n+relation_kind\n+relation_negate (relation_kind r)\n+{\n+  vrel_range_assert (r);\n+  return rr_negate_table [r - VREL_FIRST];\n+}\n+\n+// This table is used to swap the operands.  op1 REL op2 -> op2 REL op1.\n+relation_kind rr_swap_table[VREL_COUNT] = {\n+//     NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY,      EQ_EXPR, NE_EXPR\n+  VREL_NONE, GT_EXPR, GE_EXPR, LT_EXPR, LE_EXPR, VREL_EMPTY, EQ_EXPR, NE_EXPR };\n+\n+// Return the relation as if the operands were swapped.\n+\n+relation_kind\n+relation_swap (relation_kind r)\n+{\n+  vrel_range_assert (r);\n+  return rr_swap_table [r - VREL_FIRST];\n+}\n+\n+// This table is used to perform an intersection between 2 relations.\n+\n+relation_kind rr_intersect_table[VREL_COUNT][VREL_COUNT] = {\n+//   NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY, EQ_EXPR, NE_EXPR\n+// VREL_NONE\n+  { VREL_NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, VREL_EMPTY, EQ_EXPR, NE_EXPR },\n+// LT_EXPR\n+  { LT_EXPR, LT_EXPR, LT_EXPR, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, LT_EXPR },\n+// LE_EXPR\n+  { LE_EXPR, LT_EXPR, LE_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY, EQ_EXPR, LT_EXPR },\n+// GT_EXPR\n+  { GT_EXPR, VREL_EMPTY, VREL_EMPTY, GT_EXPR, GT_EXPR, VREL_EMPTY, VREL_EMPTY, GT_EXPR },\n+// GE_EXPR\n+  { GE_EXPR, VREL_EMPTY, EQ_EXPR, GT_EXPR, GE_EXPR, VREL_EMPTY, EQ_EXPR, GT_EXPR },\n+// VREL_EMPTY\n+  { VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY, VREL_EMPTY },\n+// EQ_EXPR\n+  { EQ_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY, EQ_EXPR, VREL_EMPTY },\n+// NE_EXPR\n+  { NE_EXPR, LT_EXPR, LT_EXPR, GT_EXPR, GT_EXPR, VREL_EMPTY, VREL_EMPTY, NE_EXPR } };\n+\n+\n+// Intersect relation R! with relation R2 and return the resulting relation.\n+\n+relation_kind\n+relation_intersect (relation_kind r1, relation_kind r2)\n+{\n+  vrel_range_assert (r1);\n+  vrel_range_assert (r2);\n+  return rr_intersect_table[r1 - VREL_FIRST][r2 - VREL_FIRST];\n+}\n+\n+\n+// This table is used to perform a union between 2 relations.\n+\n+relation_kind rr_union_table[VREL_COUNT][VREL_COUNT] = {\n+//    \t NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY, EQ_EXPR, NE_EXPR\n+// VREL_NONE\n+  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE },\n+// LT_EXPR\n+  { VREL_NONE, LT_EXPR, LE_EXPR, NE_EXPR, VREL_NONE, LT_EXPR, LE_EXPR, NE_EXPR },\n+// LE_EXPR\n+  { VREL_NONE, LE_EXPR, LE_EXPR, VREL_NONE, VREL_NONE, LE_EXPR, LE_EXPR, VREL_NONE },\n+// GT_EXPR\n+  { VREL_NONE, NE_EXPR, VREL_NONE, GT_EXPR, GE_EXPR, GT_EXPR, GE_EXPR, NE_EXPR },\n+// GE_EXPR\n+  { VREL_NONE, VREL_NONE, VREL_NONE, GE_EXPR, GE_EXPR, GE_EXPR, GE_EXPR, VREL_NONE },\n+// VREL_EMPTY\n+  { VREL_NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, VREL_EMPTY, EQ_EXPR, NE_EXPR },\n+// EQ_EXPR\n+  { VREL_NONE, LE_EXPR, LE_EXPR, GE_EXPR, GE_EXPR, EQ_EXPR, EQ_EXPR, VREL_NONE },\n+// NE_EXPR\n+  { VREL_NONE, NE_EXPR, VREL_NONE, NE_EXPR, VREL_NONE, NE_EXPR, VREL_NONE, NE_EXPR } };\n+\n+// Union relation R1 with relation R2 and return the result.\n+\n+relation_kind\n+relation_union (relation_kind r1, relation_kind r2)\n+{\n+  vrel_range_assert (r1);\n+  vrel_range_assert (r2);\n+  return rr_union_table[r1 - VREL_FIRST][r2 - VREL_FIRST];\n+}\n+\n+\n+// -------------------------------------------------------------------------\n+\n+// This class represents an equivalency set, and contains a link to the next\n+// one in the list to be searched.\n+\n+// The very first element in the m_equiv chain is actually just a summary\n+// element in which the m_names bitmap is used to indicate that an ssa_name\n+// has an equivalence set in this block.\n+// This allows for much faster traversal of the DOM chain, as a search for\n+// SSA_NAME simply requires walking the DOM chain until a block is found\n+// which has the bit for SSA_NAME set. Then scan for the equivalency set in\n+// that block.   No previous blcoks need be searched.\n+\n+class equiv_chain\n+{\n+public:\n+  bitmap m_names;\t\t// ssa-names in equiv set.\n+  basic_block m_bb;\t\t// Block this belongs to\n+  equiv_chain *m_next;\t\t// Next in block list.\n+  void dump (FILE *f) const;\t// Show names in this list.\n+};\n+\n+\n+// Dump the names in this equivalence set.\n+\n+void\n+equiv_chain::dump (FILE *f) const\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+  if (!m_names)\n+    return;\n+  fprintf (f, \"Equivalence set : [\");\n+  unsigned c = 0;\n+  EXECUTE_IF_SET_IN_BITMAP (m_names, 0, i, bi)\n+    {\n+      if (ssa_name (i))\n+\t{\n+\t  if (c++)\n+\t    fprintf (f, \", \");\n+\t  print_generic_expr (f, ssa_name (i), TDF_SLIM);\n+\t}\n+    }\n+  fprintf (f, \"]\\n\");\n+}\n+\n+// Instantiate an equivalency oracle.\n+\n+equiv_oracle::equiv_oracle ()\n+{\n+  bitmap_obstack_initialize (&m_bitmaps);\n+  m_equiv.create (0);\n+  m_equiv.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n+  m_equiv_set = BITMAP_ALLOC (&m_bitmaps);\n+  obstack_init (&m_chain_obstack);\n+}\n+\n+// Destruct an equivalency oracle.\n+\n+equiv_oracle::~equiv_oracle ()\n+{\n+  obstack_free (&m_chain_obstack, NULL);\n+  m_equiv.release ();\n+  bitmap_obstack_release (&m_bitmaps);\n+}\n+\n+// Find and return the equivalency set for SSA along the dominators of BB.\n+// This is the external API.\n+\n+const_bitmap\n+equiv_oracle::equiv_set (tree ssa, basic_block bb) const\n+{\n+  // Search the dominator tree for an equivalency.\n+  equiv_chain *equiv = find_equiv_dom (ssa, bb);\n+  if (equiv)\n+    return equiv->m_names;\n+\n+  return NULL;\n+}\n+\n+\n+// If SSA has an equivalence in block BB, find and return it.\n+// Otherwise return NULL.\n+\n+equiv_chain *\n+equiv_oracle::find_equiv_block (unsigned ssa, int bb) const\n+{\n+  equiv_chain *ptr = NULL;\n+  if (bb >= (int)m_equiv.length ())\n+    return NULL;\n+\n+  // If there are equiv sets and SSA is in one in this block, find it.\n+  // Otherwise return NULL.\n+  if (m_equiv[bb] && bitmap_bit_p (m_equiv[bb]->m_names, ssa))\n+    {\n+      for (ptr = m_equiv[bb]->m_next; ptr; ptr = ptr->m_next)\n+\tif (bitmap_bit_p (ptr->m_names, ssa))\n+\t  break;\n+    }\n+  return ptr;\n+}\n+\n+// Starting at block BB, walk the dominator chain looking for the nearest\n+// equivalence set containing NAME.\n+\n+equiv_chain *\n+equiv_oracle::find_equiv_dom (tree name, basic_block bb) const\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  // Short circuit looking for names which have no equivalences.\n+  // Saves time looking for something which does not exist.\n+  if (!bitmap_bit_p (m_equiv_set, v))\n+    return NULL;\n+\n+  // NAME has at least once equivalence set, check to see if it has one along\n+  // the dominator tree.\n+  for ( ; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      equiv_chain *ptr = find_equiv_block (v, bb->index);\n+      if (ptr)\n+\treturn ptr;\n+    }\n+  return NULL;\n+}\n+\n+// Register equivalance between ssa_name V and set EQUIV in block BB,\n+\n+bitmap\n+equiv_oracle::register_equiv (basic_block bb, unsigned v, equiv_chain *equiv)\n+{\n+  // V will have an equivalency now.\n+  bitmap_set_bit (m_equiv_set, v);\n+\n+  // If that equiv chain is in this block, simply use it.\n+  if (equiv->m_bb == bb)\n+    {\n+      bitmap_set_bit (equiv->m_names, v);\n+      bitmap_set_bit (m_equiv[bb->index]->m_names, v);\n+      return NULL;\n+    }\n+\n+  // Otherwise create an equivalence for this block which is a copy\n+  // of equiv, the add V to the set.\n+  bitmap b = BITMAP_ALLOC (&m_bitmaps);\n+  bitmap_copy (b, equiv->m_names);\n+  bitmap_set_bit (b, v);\n+  return b;\n+}\n+\n+// Register equivalence between set equiv_1 and equiv_2 in block BB.\n+// Return NULL if either name can be merged with the other.  Otherwise\n+// return a pointer to the combined bitmap of names.  This allows the\n+// caller to do any setup required for a new element.\n+\n+bitmap\n+equiv_oracle::register_equiv (basic_block bb, equiv_chain *equiv_1,\n+\t\t\t      equiv_chain *equiv_2)\n+{\n+  // If equiv_1 is alreayd in BB, use it as the combined set.\n+  if (equiv_1->m_bb == bb)\n+    {\n+      bitmap_ior_into  (equiv_1->m_names, equiv_2->m_names);\n+      // Its hard to delete from a single linked list, so\n+      // just clear the second one.\n+      if (equiv_2->m_bb == bb)\n+\tbitmap_clear (equiv_2->m_names);\n+      else\n+\t// Ensure equiv_2s names are in the summary for BB.\n+\tbitmap_ior_into (m_equiv[bb->index]->m_names, equiv_2->m_names);\n+      return NULL;\n+    }\n+  // If equiv_2 is in BB, use it for the combined set.\n+  if (equiv_2->m_bb == bb)\n+    {\n+      bitmap_ior_into (equiv_2->m_names, equiv_1->m_names);\n+      // Add equiv_1 names into the summary.\n+      bitmap_ior_into (m_equiv[bb->index]->m_names, equiv_1->m_names);\n+      return NULL;\n+    }\n+\n+  // At this point, neither equivalence is from this block.\n+  bitmap b = BITMAP_ALLOC (&m_bitmaps);\n+  bitmap_copy (b, equiv_1->m_names);\n+  bitmap_ior_into (b, equiv_2->m_names);\n+  return b;\n+}\n+\n+\n+// Register an equivalence between SSA1 and SSA2 in block BB.\n+// The equivalence oracle maintains a vector of equivalencies indexed by basic\n+// block. When an equivalence bteween SSA1 and SSA2 is registered in block BB,\n+// a query is made as to what equivalences both names have already, and\n+// any preexisting equivalences are merged to create a single equivalence\n+// containing all the ssa_names in this basic block.\n+\n+void\n+equiv_oracle::register_equiv (basic_block bb, tree ssa1, tree ssa2)\n+{\n+  unsigned v1 = SSA_NAME_VERSION (ssa1);\n+  unsigned v2 = SSA_NAME_VERSION (ssa2);\n+  equiv_chain *equiv_1 = find_equiv_dom (ssa1, bb);\n+  equiv_chain *equiv_2 = find_equiv_dom (ssa2, bb);\n+\n+  // Check if they are the same set\n+  if (equiv_1 && equiv_1 == equiv_2)\n+    return;\n+\n+  bitmap equiv_set;\n+\n+  // Case where we have 2 SSA_NAMEs that are not in any set.\n+  if (!equiv_1 && !equiv_2)\n+    {\n+      bitmap_set_bit (m_equiv_set, v1);\n+      bitmap_set_bit (m_equiv_set, v2);\n+\n+      equiv_set = BITMAP_ALLOC (&m_bitmaps);\n+      bitmap_set_bit (equiv_set, v1);\n+      bitmap_set_bit (equiv_set, v2);\n+    }\n+  else if (!equiv_1 && equiv_2)\n+    equiv_set = register_equiv (bb, v1, equiv_2);\n+  else if (equiv_1 && !equiv_2)\n+    equiv_set = register_equiv (bb, v2, equiv_1);\n+  else\n+    equiv_set = register_equiv (bb, equiv_1, equiv_2);\n+\n+  // A non-null return is a bitmap that is to be added to the current\n+  // block as a new equivalence.\n+  if (!equiv_set)\n+    return;\n+\n+  equiv_chain *ptr;\n+\n+  // Check if this is the first time a block has an equivalence added.\n+  // and create a header block. And set the summary for this block.\n+  if (!m_equiv[bb->index])\n+    {\n+      ptr = (equiv_chain *) obstack_alloc (&m_chain_obstack,\n+\t\t\t\t\t   sizeof (equiv_chain));\n+      ptr->m_names = BITMAP_ALLOC (&m_bitmaps);\n+      bitmap_copy (ptr->m_names, equiv_set);\n+      ptr->m_bb = bb;\n+      ptr->m_next = NULL;\n+      m_equiv[bb->index] = ptr;\n+    }\n+\n+  // Now create the element for this equiv set and initialize it.\n+  ptr = (equiv_chain *) obstack_alloc (&m_chain_obstack, sizeof (equiv_chain));\n+  ptr->m_names = equiv_set;\n+  ptr->m_bb = bb;\n+  gcc_checking_assert (bb->index < (int)m_equiv.length ());\n+  ptr->m_next = m_equiv[bb->index]->m_next;\n+  m_equiv[bb->index]->m_next = ptr;\n+  bitmap_ior_into (m_equiv[bb->index]->m_names, equiv_set);\n+}\n+\n+// Make sure the BB vector is big enough and grow it if needed.\n+\n+void\n+equiv_oracle::limit_check (basic_block bb)\n+{\n+  int i = (bb) ? bb->index : last_basic_block_for_fn (cfun);\n+  if (i >= (int)m_equiv.length ())\n+    m_equiv.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n+}\n+\n+// Dump the equivalence sets in BB to file F.\n+\n+void\n+equiv_oracle::dump (FILE *f, basic_block bb) const\n+{\n+  if (bb->index >= (int)m_equiv.length ())\n+    return;\n+  if (!m_equiv[bb->index])\n+    return;\n+\n+  equiv_chain *ptr = m_equiv[bb->index]->m_next;\n+  for (; ptr; ptr = ptr->m_next)\n+    ptr->dump (f);\n+}\n+\n+// Dump all equivalence sets known to the oracle.\n+\n+void\n+equiv_oracle::dump (FILE *f) const\n+{\n+  fprintf (f, \"Equivalency dump\\n\");\n+  for (unsigned i = 0; i < m_equiv.length (); i++)\n+    if (m_equiv[i])\n+      {\n+\tfprintf (f, \"BB%d\\n\", i);\n+\tdump (f, BASIC_BLOCK_FOR_FN (cfun, i));\n+      }\n+}\n+\n+\n+// --------------------------------------------------------------------------\n+\n+// The value-relation class is used to encapsulate the represention of an\n+// individual relation between 2 ssa-names, and to facilitate operating on\n+// the relation.\n+\n+class value_relation\n+{\n+public:\n+  value_relation ();\n+  value_relation (relation_kind kind, tree n1, tree n2);\n+  void set_relation (relation_kind kind, tree n1, tree n2);\n+\n+  inline relation_kind kind () const { return related; }\n+  inline tree op1 () const { return name1; }\n+  inline tree op2 () const { return name2; }\n+\n+  bool union_ (value_relation &p);\n+  bool intersect (value_relation &p);\n+  void negate ();\n+  void swap ();\n+\n+  void dump (FILE *f) const;\n+private:\n+  relation_kind related;\n+  tree name1, name2;\n+};\n+\n+// Set relation R between ssa_name N1 and N2.\n+\n+inline void\n+value_relation::set_relation (relation_kind r, tree n1, tree n2)\n+{\n+  gcc_checking_assert (SSA_NAME_VERSION (n1) != SSA_NAME_VERSION (n2));\n+  related = r;\n+  name1 = n1;\n+  name2 = n2;\n+}\n+\n+// Default constructor.\n+\n+inline\n+value_relation::value_relation ()\n+{\n+  related = VREL_NONE;\n+  name1 = NULL_TREE;\n+  name2 = NULL_TREE;\n+}\n+\n+// Constructor for relation R between SSA version N1 nd N2.\n+\n+inline\n+value_relation::value_relation (relation_kind kind, tree n1, tree n2)\n+{\n+  set_relation (kind, n1, n2);\n+}\n+\n+// Negate the current relation.\n+\n+void\n+value_relation::negate ()\n+{\n+  related = relation_negate (related);\n+}\n+\n+// Modify the relation as if the operands were being swapped.\n+\n+void\n+value_relation::swap ()\n+{\n+  related = relation_swap (related);\n+}\n+\n+// Perform an intersection between 2 relations. *this &&= p.\n+\n+bool\n+value_relation::intersect (value_relation &p)\n+{\n+  // Save previous value\n+  relation_kind old = related;\n+\n+  if (p.op1 () == op1 () && p.op2 () == op2 ())\n+    related = relation_intersect (kind (), p.kind ());\n+  else if (p.op2 () == op1 () && p.op1 () == op2 ())\n+    related = relation_intersect (kind (), relation_swap (p.kind ()));\n+  else\n+    return false;\n+\n+  return old != related;\n+}\n+\n+// Perform a union between 2 relations. *this ||= p.\n+\n+bool\n+value_relation::union_ (value_relation &p)\n+{\n+  // Save previous value\n+  relation_kind old = related;\n+\n+  if (p.op1 () == op1 () && p.op2 () == op2 ())\n+    related = relation_union (kind(), p.kind());\n+  else if (p.op2 () == op1 () && p.op1 () == op2 ())\n+    related = relation_union (kind(), relation_swap (p.kind ()));\n+  else\n+    return false;\n+\n+  return old != related;\n+}\n+\n+\n+// Dump the relation to file F.\n+\n+void\n+value_relation::dump (FILE *f) const\n+{\n+  if (!name1 || !name2)\n+    {\n+      fprintf (f, \"uninitialized\");\n+      return;\n+    }\n+  fputc ('(', f);\n+  print_generic_expr (f, op1 (), TDF_SLIM);\n+  print_relation (f, kind ());\n+  print_generic_expr (f, op2 (), TDF_SLIM);\n+  fputc(')', f);\n+}\n+\n+// This container is used to link relations in a chain.\n+\n+class relation_chain : public value_relation\n+{\n+public:\n+  relation_chain *m_next;\n+};\n+\n+// ------------------------------------------------------------------------\n+\n+// Instantiate a relation oracle.\n+\n+relation_oracle::relation_oracle ()\n+{\n+  m_relations.create (0);\n+  m_relations.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n+  m_relation_set = BITMAP_ALLOC (&m_bitmaps);\n+  m_tmp = BITMAP_ALLOC (&m_bitmaps);\n+}\n+\n+// Destruct a relation oracle.\n+\n+relation_oracle::~relation_oracle ()\n+{\n+  m_relations.release ();\n+}\n+\n+// Register relation K between ssa_name OP1 and OP2 on STMT.\n+\n+void\n+relation_oracle::register_relation (gimple *stmt, relation_kind k, tree op1,\n+\t\t\t\t    tree op2)\n+{\n+  gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n+  gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n+  gcc_checking_assert (stmt && gimple_bb (stmt));\n+\n+  // Don't register lack of a relation.\n+  if (k == VREL_NONE)\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      value_relation vr (k, op1, op2);\n+      fprintf (dump_file, \" Registering value_relation \");\n+      vr.dump (dump_file);\n+      fprintf (dump_file, \" (bb%d) at \", gimple_bb (stmt)->index);\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+    }\n+\n+  // This relation applies to the entire block, use STMT's block.\n+  // Equivalencies are handled by the equivalence oracle.\n+  if (k == EQ_EXPR)\n+    register_equiv (gimple_bb (stmt), op1, op2);\n+  else\n+    register_relation (gimple_bb (stmt), k, op1, op2);\n+}\n+\n+// Register relation K between ssa_name OP1 and OP2 on edge E.\n+\n+void\n+relation_oracle::register_relation (edge e, relation_kind k, tree op1,\n+\t\t\t\t    tree op2)\n+{\n+  gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n+  gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n+\n+  // Do not register lack of relation, or blocks which have more than\n+  // edge E for a predecessor.\n+  if (k == VREL_NONE || !single_pred_p (e->dest))\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      value_relation vr (k, op1, op2);\n+      fprintf (dump_file, \" Registering value_relation \");\n+      vr.dump (dump_file);\n+      fprintf (dump_file, \" on (%d->%d)\\n\", e->src->index, e->dest->index);\n+    }\n+\n+  // Equivalencies are handled by the equivalence oracle.\n+  if (k == EQ_EXPR)\n+    register_equiv (e->dest, op1, op2);\n+  else\n+    register_relation (e->dest, k, op1, op2);\n+}\n+\n+// Register relation K between OP! and OP2 in block BB.\n+// This creates the record and searches for existing records in the dominator\n+// tree to merge with.\n+\n+void\n+relation_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n+\t\t\t\t    tree op2)\n+{\n+  gcc_checking_assert (k != VREL_NONE);\n+\n+  value_relation vr(k, op1, op2);\n+  int bbi = bb->index;\n+\n+  if (bbi >= (int)m_relations.length())\n+    m_relations.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n+\n+  // Summary bitmap indicating what ssa_names have relations in this BB.\n+  bitmap bm = m_relations[bbi].m_names;\n+  if (!bm)\n+    bm = m_relations[bbi].m_names = BITMAP_ALLOC (&m_bitmaps);\n+  unsigned v1 = SSA_NAME_VERSION (op1);\n+  unsigned v2 = SSA_NAME_VERSION (op2);\n+\n+  relation_kind curr;\n+  relation_chain *ptr;\n+  curr = find_relation_block (bbi, v1, v2, &ptr);\n+  // There is an existing relation in this block, just intersect with it.\n+  if (curr != VREL_NONE)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"    Intersecting with existing \");\n+\t  ptr->dump (dump_file);\n+\t}\n+      // Check into whether we can simply replace the relation rather than\n+      // intersecting it.  THis may help with some optimistic iterative\n+      // updating algorithms.\n+      ptr->intersect (vr);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \" to produce \");\n+\t  ptr->dump (dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return;\n+    }\n+\n+  // Check for an existing relation further up the DOM chain.\n+  // By including dominating relations, The first one found in any search\n+  // will be the aggregate of all the previous ones.\n+  curr = find_relation_dom (bb, v1, v2);\n+  if (curr != VREL_NONE)\n+    k = relation_intersect (curr, k);\n+\n+  bitmap_set_bit (bm, v1);\n+  bitmap_set_bit (bm, v2);\n+  bitmap_set_bit (m_relation_set, v1);\n+  bitmap_set_bit (m_relation_set, v2);\n+\n+  ptr = (relation_chain *) obstack_alloc (&m_chain_obstack,\n+\t\t\t\t\t  sizeof (relation_chain));\n+  ptr->set_relation (k, op1, op2);\n+  ptr->m_next = m_relations[bbi].m_head;\n+  m_relations[bbi].m_head = ptr;;\n+}\n+\n+// Find the relation between any ssa_name in B1 and any name in B2 in block BB.\n+// This will allow equivalencies to be applied to any SSA_NAME in a relation.\n+\n+relation_kind\n+relation_oracle::find_relation_block (unsigned bb, const_bitmap b1,\n+\t\t\t\t      const_bitmap b2)\n+{\n+  const_bitmap bm;\n+  if (bb >= m_relations.length())\n+    return VREL_NONE;\n+\n+  bm = m_relations[bb].m_names;\n+  if (!bm)\n+    return VREL_NONE;\n+\n+  // If both b1 and b2 aren't referenced in thie block, cant be a relation\n+  if (!bitmap_intersect_p (bm, b1) || !bitmap_intersect_p (bm, b2))\n+    return VREL_NONE;\n+\n+  // Search for the fiorst relation that contains BOTH an element from B1\n+  // and B2, and return that relation.\n+  for (relation_chain *ptr = m_relations[bb].m_head; ptr ; ptr = ptr->m_next)\n+    {\n+      unsigned op1 = SSA_NAME_VERSION (ptr->op1 ());\n+      unsigned op2 = SSA_NAME_VERSION (ptr->op2 ());\n+      if (bitmap_bit_p (b1, op1) && bitmap_bit_p (b1, op2))\n+\treturn ptr->kind ();\n+      if (bitmap_bit_p (b1, op2) && bitmap_bit_p (b1, op1))\n+\treturn relation_swap (ptr->kind ());\n+    }\n+\n+  return VREL_NONE;\n+}\n+\n+// Search the DOM tree for a relation between an element of B1 and B2, starting\n+// with block BB.\n+\n+relation_kind\n+relation_oracle::find_relation_dom (basic_block bb, const_bitmap b1,\n+\t\t\t\t    const_bitmap b2)\n+{\n+  relation_kind r;\n+  // If either name does not occur in a relation anywhere, there isnt one.\n+  if (!bitmap_intersect_p (m_relation_set, b1)\n+      || !bitmap_intersect_p (m_relation_set, b2))\n+    return VREL_NONE;\n+\n+  // Search each block in the DOM tree checking.\n+  for ( ; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      r = find_relation_block (bb->index, b1, b2);\n+      if (r != VREL_NONE)\n+\treturn r;\n+    }\n+  return VREL_NONE;\n+\n+}\n+\n+// Find a relation in block BB between ssa version V1 and V2.  If a relation\n+// is found, return a pointer to the chain object in OBJ.\n+\n+relation_kind\n+relation_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n+\t\t\t\t     relation_chain **obj)\n+{\n+  if (bb >= (int)m_relations.length())\n+    return VREL_NONE;\n+\n+  const_bitmap bm = m_relations[bb].m_names;\n+  if (!bm)\n+    return VREL_NONE;\n+\n+  // If both b1 and b2 aren't referenced in thie block, cant be a relation\n+  if (!bitmap_bit_p (bm, v1) || !bitmap_bit_p (bm, v2))\n+    return VREL_NONE;\n+\n+  relation_chain *ptr;\n+  for (ptr = m_relations[bb].m_head; ptr ; ptr = ptr->m_next)\n+    {\n+      unsigned op1 = SSA_NAME_VERSION (ptr->op1 ());\n+      unsigned op2 = SSA_NAME_VERSION (ptr->op2 ());\n+      if (v1 == op1 && v2 == op2)\n+\t{\n+\t  if (obj)\n+\t    *obj = ptr;\n+\t  return ptr->kind ();\n+\t}\n+      if (v1 == op2 && v2 == op1)\n+\t{\n+\t  if (obj)\n+\t    *obj = ptr;\n+\t  return relation_swap (ptr->kind ());\n+\t}\n+    }\n+\n+  return VREL_NONE;\n+}\n+\n+// Find a relation between SSA version V1 and V2 in the dominator tree\n+// starting with block BB\n+\n+relation_kind\n+relation_oracle::find_relation_dom (basic_block bb, unsigned v1, unsigned v2)\n+{\n+  relation_kind r;\n+  // IF either name does not occur in a relation anywhere, there isnt one.\n+  if (!bitmap_bit_p (m_relation_set, v1) || !bitmap_bit_p (m_relation_set, v2))\n+    return VREL_NONE;\n+\n+  for ( ; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      r = find_relation_block (bb->index, v1, v2);\n+      if (r != VREL_NONE)\n+\treturn r;\n+    }\n+  return VREL_NONE;\n+\n+}\n+\n+// Query if there is a relation between SSA1 and SS2 in block BB or a\n+// dominator of BB\n+\n+relation_kind\n+relation_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n+{\n+  relation_kind kind;\n+  unsigned v1 = SSA_NAME_VERSION (ssa1);\n+  unsigned v2 = SSA_NAME_VERSION (ssa2);\n+  if (v1 == v2)\n+    return EQ_EXPR;\n+\n+  // Check for equivalence first.\n+  const_bitmap equiv1 = equiv_set (ssa1, bb);\n+  if (equiv1 && bitmap_bit_p (equiv1, v2))\n+    return EQ_EXPR;\n+\n+  // Initially look for a direct relationship and just return that.\n+  kind = find_relation_dom (bb, v1, v2);\n+  if (kind != VREL_NONE)\n+    return kind;\n+\n+  // If one is not found, see if there is a relationship between equivalences.\n+  // If v2 isn't in v1s equiv set, then v1 shouldn't be in v2's set either.\n+  const_bitmap equiv2 = equiv_set (ssa2, bb);\n+  gcc_checking_assert (!equiv2 || !bitmap_bit_p (equiv2, v1));\n+\n+  if (!equiv1 && !equiv2)\n+    kind = VREL_NONE;\n+  else if (!equiv1)\n+    {\n+      bitmap_clear (m_tmp);\n+      bitmap_set_bit (m_tmp, v1);\n+      kind = find_relation_dom (bb, m_tmp, equiv2);\n+    }\n+  else if (!equiv2)\n+    {\n+      bitmap_clear (m_tmp);\n+      bitmap_set_bit (m_tmp, v2);\n+      kind = find_relation_dom (bb, equiv1, m_tmp);\n+    }\n+  else\n+    kind = find_relation_dom (bb, equiv1, equiv2);\n+  return kind;\n+}\n+\n+// Dump all the relations in block BB to file F.\n+\n+void\n+relation_oracle::dump (FILE *f, basic_block bb) const\n+{\n+  equiv_oracle::dump (f,bb);\n+\n+  if (bb->index >= (int)m_relations.length ())\n+    return;\n+  if (!m_relations[bb->index].m_names)\n+    return;\n+\n+  relation_chain *ptr = m_relations[bb->index].m_head;\n+  for (; ptr; ptr = ptr->m_next)\n+    {\n+      fprintf (f, \"Relational : \");\n+      ptr->dump (f);\n+      fprintf (f, \"\\n\");\n+    }\n+}\n+\n+// Dump all the relations known to file F.\n+\n+void\n+relation_oracle::dump (FILE *f) const\n+{\n+  fprintf (f, \"Relation dump\\n\");\n+  for (unsigned i = 0; i < m_relations.length (); i++)\n+    {\n+      fprintf (f, \"BB%d\\n\", i);\n+      dump (f, BASIC_BLOCK_FOR_FN (cfun, i));\n+    }\n+}"}, {"sha": "11488541277569a2cdfc723c655bcad5a6fa7edb", "filename": "gcc/value-relation.h", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=3aaa69e5f30e1904d7ca2bb711b1cb0c62b6895f", "patch": "@@ -0,0 +1,159 @@\n+/* Header file for the value range relational processing.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VALUE_RELATION_H\n+#define GCC_VALUE_RELATION_H\n+\n+\n+// This file provides access to a relation oracle which can be used to\n+// maintain and query relations and equivalences between SSA_NAMES.\n+//\n+// The general range_query object provided in value-query.h provides\n+// access to an oracle, if one is available, via the oracle() method.\n+// Thre are also a couple of access routines provided, which even if there is\n+// no oracle, will return the default VREL_NONE no relation.\n+//\n+// Typically, when a ranger object is active, there will be an oracle, and\n+// any information available can be directly queried.  Ranger also sets and\n+// utilizes the relation information to enhance it's range calculations, this\n+// is totally transparent to the client, and they are free to make queries.\n+//\n+//\n+// relation_kind is a typedef of enum tree_code, but has restricted range\n+// and a couple of extra values.\n+//\n+// A query is made requesting the relation between SSA1 and SSA@ in a basic\n+// block, or on an edge, the possible return values are:\n+//\n+//  EQ_EXPR, NE_EXPR, LT_EXPR, LE_EXPR, GT_EXPR, and GE_EXPR mean the same.\n+//  VREL_NONE : No relation between the 2 names.\n+//  VREL_EMPTY : Impossible relation (ie, A < B && A > B produces VREL_EMPTY.\n+//\n+// The oracle maintains EQ_EXPR relations with equivalency sets, so if a\n+// relation comes back EQ_EXPR, it is also possible to query the set of\n+// equivlaencies.  These are basically bitmaps over ssa_names.\n+//\n+// relations are maintained via the dominace trees, are are optimized assuming\n+// they are registered in dominance order.   When a new relation is added, it\n+// is intersected with whatever existing relation exists in the dominance tree\n+// and registered at the specified block.\n+\n+\n+// Rather than introduce a new enumerated type for relations, we can use the\n+// existing tree_codes for relations, plus add a couple of #defines for\n+// the other cases.  These codes are arranged such that VREL_NONE is the first\n+// code, and all the rest are contiguous.\n+\n+typedef enum tree_code relation_kind;\n+\n+#define VREL_NONE\t\tTRUTH_NOT_EXPR\n+#define VREL_EMPTY\t\tLTGT_EXPR\n+\n+// General relation kind transformations.\n+relation_kind relation_union (relation_kind r1, relation_kind r2);\n+relation_kind relation_intersect (relation_kind r1, relation_kind r2);\n+relation_kind relation_negate (relation_kind r);\n+relation_kind relation_swap (relation_kind r);\n+void print_relation (FILE *f, relation_kind rel);\n+\n+// Declared internally in value-relation.cc\n+class equiv_chain;\n+\n+// The equivalency oracle maintains equivalencies using the dominator tree.\n+// Equivalencies apply to an entire basic block.  Equivalencies on edges\n+// can be represented only on edges whose destination is a single-pred block,\n+// and the equivalence is simply applied to that succesor block.\n+\n+class equiv_oracle\n+{\n+public:\n+  equiv_oracle ();\n+  ~equiv_oracle ();\n+\n+  const_bitmap equiv_set (tree ssa, basic_block bb) const;\n+  void register_equiv (basic_block bb, tree ssa1, tree ssa2);\n+\n+  void dump (FILE *f, basic_block bb) const;\n+  void dump (FILE *f) const;\n+\n+protected:\n+  bitmap_obstack m_bitmaps;\n+  struct obstack m_chain_obstack;\n+private:\n+  bitmap m_equiv_set;\t// Index by ssa-name. true if an equivalence exists.\n+  vec <equiv_chain *> m_equiv;\t// Index by BB.  list of equivalences.\n+\n+  void limit_check (basic_block bb = NULL);\n+  equiv_chain *find_equiv_block (unsigned ssa, int bb) const;\n+  equiv_chain *find_equiv_dom (tree name, basic_block bb) const;\n+\n+  bitmap register_equiv (basic_block bb, unsigned v, equiv_chain *equiv_1);\n+  bitmap register_equiv (basic_block bb, equiv_chain *equiv_1,\n+\t\t\t equiv_chain *equiv_2);\n+\n+};\n+\n+// Summary block header for relations.\n+\n+class relation_chain_head\n+{\n+public:\n+  bitmap m_names;\t\t// ssa_names with relations in this block.\n+  class relation_chain *m_head; // List of relations in block.\n+};\n+\n+// A relation oracle maintains a set of relations between ssa_names using the\n+// dominator tree structures.  Equivalencies are considered a subset of\n+// a general relation and maintained by an equivalence oracle by transparently\n+// passing any EQ_EXPR relations to it.\n+// Relations are handled at the basic block level.  All relations apply to\n+// an entire block, and are thus kept in a summary index by block.\n+// Similar to the equivalence oracle, edges are handled by applying the\n+// relation to the destination block of the edge, but ONLY if that block\n+// has a single successor.  For now.\n+\n+class relation_oracle : public equiv_oracle\n+{\n+public:\n+  relation_oracle ();\n+  ~relation_oracle ();\n+\n+  void register_relation (gimple *stmt, relation_kind k, tree op1, tree op2);\n+  void register_relation (edge e, relation_kind k, tree op1, tree op2);\n+\n+  relation_kind query_relation (basic_block bb, tree ssa1, tree ssa2);\n+\n+  void dump (FILE *f, basic_block bb) const;\n+  void dump (FILE *f) const;\n+private:\n+  bitmap m_tmp;\n+  bitmap m_relation_set;  // Index by ssa-name. True if a relation exists\n+  vec <relation_chain_head> m_relations;  // Index by BB, list of relations.\n+  relation_kind find_relation_block (unsigned bb, const_bitmap b1,\n+\t\t\t\t     const_bitmap b2);\n+  relation_kind find_relation_dom (basic_block bb, const_bitmap b1,\n+\t\t\t\t   const_bitmap b2);\n+  relation_kind find_relation_block (int bb, unsigned v1, unsigned v2,\n+\t\t\t\t     relation_chain **obj = NULL);\n+  relation_kind find_relation_dom (basic_block bb, unsigned v1, unsigned v2);\n+  void register_relation (basic_block bb, relation_kind k, tree op1, tree op2);\n+};\n+\n+#endif  /* GCC_VALUE_RELATION_H */"}]}