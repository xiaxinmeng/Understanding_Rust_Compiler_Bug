{"sha": "d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "node_id": "C_kwDOANBUbNoAKGQxZThmMjIxZTNmYzhkMzE1M2I2NjJjMmY5MTJiZjFhMjZkNjQ1ZmY", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-09T11:40:43Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-10T11:08:05Z"}, "message": "[c++] Disambiguate ModuleKind flags\n\nIn modules, 'attached to global module' nearly always means 'not in\nmodule purview'.  Also the implementation treats, 'in global module &&\nin module purview' as meaning 'header unit'.  The ModuleKind flags\nreflected that.  The 'nearly always' means there are cases that the\nfirst condition is not invariant, and that of course invalidates the\nsecond equivalence.\n\nThis disambiguates the ModuleKind flags to allow that 'not quite', and\nseparate out header-unitness from the GMF & purview flags combination.\n\n1) Separate out named-module vs header-unit from the MODULE/GLOBAL flags.\n\n2) Replace the MODULE/GLOBAL flags with PURVIEW & ATTACH flags.\n\n3) Adjust the parser state handling.\n\nLays ground-work for language-declaration changes.\n\n\tgcc/cp/\n\t* cp-tree.h (enum module_kind_bits): Disambiguate purview,\n\tattach, named module vs header-unit.\n\t(global_purview_p, not_module_p): Delete.\n\t(named_module_p): New.\n\t(header_module_p, module_purview_p): Adjust.\n\t(module_attach_p, named_module_purview_p): New.\n\t* decl.cc (duplicate_decls): Adjust.\n\t* module.cc (declare_module, preprocessed_module): Adjust.\n\t* name-lookup.cc (init_global_partition): Adjust.\n\t(get_fixed_binding_slot, pushdecl): Adjust.\n\t* parser.cc (cp_parser_module_declaration): Adjust.\n\t(cp_parser_import_declaration, cp_parser_declaration): Adjust.", "tree": {"sha": "fe461e95e9e42b16bd7b64c7e757585397ff0b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe461e95e9e42b16bd7b64c7e757585397ff0b6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76db543db88727789a6c117608a23edc2eace713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76db543db88727789a6c117608a23edc2eace713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76db543db88727789a6c117608a23edc2eace713"}], "stats": {"total": 158, "additions": 76, "deletions": 82}, "files": [{"sha": "8a5057a4dff1dca8796278efda398df2dcb989e7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "patch": "@@ -1720,7 +1720,8 @@ check_constraint_info (tree t)\n #define DECL_MODULE_CHECK(NODE)\t\t\t\t\t\t\\\n   TREE_NOT_CHECK (NODE, TEMPLATE_DECL)\n \n-/* In the purview of a module (including header unit).  */\n+/* In the purview of a named module (or in the purview of the\n+   header-unit being compiled).  */\n #define DECL_MODULE_PURVIEW_P(N) \\\n   (DECL_LANG_SPECIFIC (DECL_MODULE_CHECK (N))->u.base.module_purview_p)\n \n@@ -7137,47 +7138,41 @@ inline bool modules_p () { return flag_modules != 0; }\n /* The kind of module or part thereof that we're in.  */\n enum module_kind_bits\n {\n-  MK_MODULE = 1 << 0,     /* This TU is a module.  */\n-  MK_GLOBAL = 1 << 1,     /* Entities are in the global module.  */\n-  MK_INTERFACE = 1 << 2,  /* This TU is an interface.  */\n-  MK_PARTITION = 1 << 3,  /* This TU is a partition.  */\n-  MK_EXPORTING = 1 << 4,  /* We are in an export region.  */\n+  MK_NAMED = 1 << 0,\t// TU is a named module\n+  MK_HEADER = 1 << 1,\t// TU is a header unit\n+  MK_INTERFACE = 1 << 2,  // TU is an interface\n+  MK_PARTITION = 1 << 3,  // TU is a partition\n+\n+  MK_PURVIEW = 1 << 4,\t// In purview of current module\n+  MK_ATTACH = 1 << 5,\t// Attaching to named module\n+\n+  MK_EXPORTING = 1 << 6,  /* We are in an export region.  */\n };\n \n /* We do lots of bit-manipulation, so an unsigned is easier.  */\n extern unsigned module_kind;\n \n-/*  MK_MODULE & MK_GLOBAL have the following combined meanings:\n- MODULE GLOBAL\n-   0\t  0\tnot a module\n-   0\t  1\tGMF of named module (we've not yet seen module-decl)\n-   1\t  0\tpurview of named module\n-   1\t  1\theader unit.   */\n-\n-inline bool module_purview_p ()\n-{ return module_kind & MK_MODULE; }\n-inline bool global_purview_p ()\n-{ return module_kind & MK_GLOBAL; }\n-\n-inline bool not_module_p ()\n-{ return (module_kind & (MK_MODULE | MK_GLOBAL)) == 0; }\n+inline bool module_p ()\n+{ return module_kind & (MK_NAMED | MK_HEADER); }\n inline bool named_module_p ()\n-{ /* This is a named module if exactly one of MODULE and GLOBAL is\n-     set.  */\n-  /* The divides are constant shifts!  */\n-  return ((module_kind / MK_MODULE) ^ (module_kind / MK_GLOBAL)) & 1;\n-}\n+{ return module_kind & MK_NAMED; }\n inline bool header_module_p ()\n-{ return (module_kind & (MK_MODULE | MK_GLOBAL)) == (MK_MODULE | MK_GLOBAL); }\n-inline bool named_module_purview_p ()\n-{ return (module_kind & (MK_MODULE | MK_GLOBAL)) == MK_MODULE; }\n+{ return module_kind & MK_HEADER; }\n inline bool module_interface_p ()\n { return module_kind & MK_INTERFACE; }\n inline bool module_partition_p ()\n { return module_kind & MK_PARTITION; }\n inline bool module_has_cmi_p ()\n { return module_kind & (MK_INTERFACE | MK_PARTITION); }\n \n+inline bool module_purview_p ()\n+{ return module_kind & MK_PURVIEW; }\n+inline bool module_attach_p ()\n+{ return module_kind & MK_ATTACH; }\n+\n+inline bool named_module_purview_p ()\n+{ return named_module_p () && module_purview_p (); }\n+\n /* We're currently exporting declarations.  */\n inline bool module_exporting_p ()\n { return module_kind & MK_EXPORTING; }"}, {"sha": "4099fdeca5ac74906b9d8233ff00cf7b5ca60974", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "patch": "@@ -2110,7 +2110,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n     {\n       if (DECL_ARTIFICIAL (olddecl))\n \t{\n-\t  if (!(global_purview_p () || not_module_p ()))\n+\t  if (module_attach_p ())\n \t    error (\"declaration %qD conflicts with builtin\", newdecl);\n \t  else\n \t    DECL_MODULE_EXPORT_P (olddecl) = DECL_MODULE_EXPORT_P (newdecl);"}, {"sha": "bd4771bef72b6236a7065050cd11ff4202bc9849", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "patch": "@@ -18971,25 +18971,21 @@ declare_module (module_state *module, location_t from_loc, bool exporting_p,\n   gcc_checking_assert (module->is_direct () && module->has_location ());\n \n   /* Yer a module, 'arry.  */\n-  module_kind &= ~MK_GLOBAL;\n-  module_kind |= MK_MODULE;\n+  module_kind = module->is_header () ? MK_HEADER : MK_NAMED | MK_ATTACH;\n \n-  if (module->is_partition () || exporting_p)\n-    {\n-      gcc_checking_assert (module->get_flatname ());\n-\n-      if (module->is_partition ())\n-\tmodule_kind |= MK_PARTITION;\n-\n-      if (exporting_p)\n-\t{\n-\t  module->interface_p = true;\n-\t  module_kind |= MK_INTERFACE;\n-\t}\n+  // Even in header units, we consider the decls to be purview\n+  module_kind |= MK_PURVIEW;\n \n-      if (module->is_header ())\n-\tmodule_kind |= MK_GLOBAL | MK_EXPORTING;\n+  if (module->is_partition ())\n+    module_kind |= MK_PARTITION;\n+  if (exporting_p)\n+    {\n+      module->interface_p = true;\n+      module_kind |= MK_INTERFACE;\n+    }\n \n+  if (module_has_cmi_p ())\n+    {\n       /* Copy the importing information we may have already done.  We\n \t do not need to separate out the imports that only happen in\n \t the GMF, inspite of what the literal wording of the std\n@@ -19523,6 +19519,7 @@ preprocessed_module (cpp_reader *reader)\n \t  if (module->is_module ())\n \t    {\n \t      declare_module (module, cpp_main_loc (reader), true, NULL, reader);\n+\t      module_kind |= MK_EXPORTING;\n \t      break;\n \t    }\n \t}"}, {"sha": "a05244df74ee99240485484b7638614bba9c02a0", "filename": "gcc/cp/name-lookup.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fname-lookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fname-lookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.cc?ref=d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "patch": "@@ -190,25 +190,25 @@ search_imported_binding_slot (tree *slot, unsigned ix)\n static void\n init_global_partition (binding_cluster *cluster, tree decl)\n {\n-  bool purview = true;\n+  bool named = true;\n \n   if (header_module_p ())\n-    purview = false;\n+    named = false;\n   else if (TREE_PUBLIC (decl)\n \t   && TREE_CODE (decl) == NAMESPACE_DECL\n \t   && !DECL_NAMESPACE_ALIAS (decl))\n-    purview = false;\n+    named = false;\n   else if (!get_originating_module (decl))\n-    purview = false;\n+    named = false;\n \n   binding_slot *mslot;\n-  if (!purview)\n-    mslot = &cluster[0].slots[BINDING_SLOT_GLOBAL];\n-  else\n+  if (named)\n     mslot = &cluster[BINDING_SLOT_PARTITION\n \t\t     / BINDING_VECTOR_SLOTS_PER_CLUSTER]\n       .slots[BINDING_SLOT_PARTITION\n \t     % BINDING_VECTOR_SLOTS_PER_CLUSTER];\n+  else\n+    mslot = &cluster[0].slots[BINDING_SLOT_GLOBAL];\n \n   if (*mslot)\n     decl = ovl_make (decl, *mslot);\n@@ -248,7 +248,7 @@ get_fixed_binding_slot (tree *slot, tree name, unsigned ix, int create)\n       if (!create)\n \treturn NULL;\n \n-      /* The partition slot is only needed when we know we're a named\n+      /* The partition slot is only needed when we're a named\n \t module.  */\n       bool partition_slot = named_module_p ();\n       unsigned want = ((BINDING_SLOTS_FIXED + partition_slot + (create < 0)\n@@ -3472,9 +3472,9 @@ push_local_extern_decl_alias (tree decl)\n   DECL_LOCAL_DECL_ALIAS (decl) = alias;\n }\n \n-/* DECL is a global or module-purview entity.  If it has non-internal\n-   linkage, and we have a module vector, record it in the appropriate\n-   slot.  We have already checked for duplicates.  */\n+/* If DECL has non-internal linkage, and we have a module vector,\n+   record it in the appropriate slot.  We have already checked for\n+   duplicates.  */\n \n static void\n maybe_record_mergeable_decl (tree *slot, tree name, tree decl)\n@@ -3826,7 +3826,7 @@ pushdecl (tree decl, bool hiding)\n \n \t  if (level->kind == sk_namespace\n \t      && TREE_PUBLIC (level->this_entity)\n-\t      && !not_module_p ())\n+\t      && module_p ())\n \t    maybe_record_mergeable_decl (slot, name, decl);\n \t}\n     }"}, {"sha": "8da02de95fb0784a573dcbc0613e560b4f54d6d9", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e8f221e3fc8d3153b662c2f912bf1a26d645ff/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=d1e8f221e3fc8d3153b662c2f912bf1a26d645ff", "patch": "@@ -14582,7 +14582,7 @@ cp_parser_module_declaration (cp_parser *parser, module_parse mp_state,\n     {\n       /* Start global module fragment.  */\n       cp_lexer_consume_token (parser->lexer);\n-      module_kind |= MK_GLOBAL;\n+      module_kind = MK_NAMED;\n       mp_state = MP_GLOBAL;\n       cp_parser_require_pragma_eol (parser, token);\n     }\n@@ -14596,16 +14596,16 @@ cp_parser_module_declaration (cp_parser *parser, module_parse mp_state,\n       cp_lexer_consume_token (parser->lexer);\n       cp_parser_require_pragma_eol (parser, token);\n \n-      if (!(mp_state == MP_PURVIEW || mp_state == MP_PURVIEW_IMPORTS)\n-\t  || !module_interface_p () || module_partition_p ())\n-\terror_at (token->location,\n-\t\t  \"private module fragment only permitted in purview\"\n-\t\t  \" of module interface or partition\");\n-      else\n+      if ((mp_state == MP_PURVIEW || mp_state == MP_PURVIEW_IMPORTS)\n+\t  && module_has_cmi_p ())\n \t{\n \t  mp_state = MP_PRIVATE_IMPORTS;\n \t  sorry_at (token->location, \"private module fragment\");\n \t}\n+      else\n+\terror_at (token->location,\n+\t\t  \"private module fragment only permitted in purview\"\n+\t\t  \" of module interface or partition\");\n     }\n   else if (!(mp_state == MP_FIRST || mp_state == MP_GLOBAL))\n     {\n@@ -14642,10 +14642,7 @@ cp_parser_import_declaration (cp_parser *parser, module_parse mp_state,\n   parser->lexer->in_pragma = true;\n   cp_token *token = cp_lexer_consume_token (parser->lexer);\n \n-  if (mp_state != MP_PURVIEW_IMPORTS\n-      && mp_state != MP_PRIVATE_IMPORTS\n-      && module_purview_p ()\n-      && !global_purview_p ())\n+  if (mp_state == MP_PURVIEW || mp_state == MP_PRIVATE)\n     {\n       error_at (token->location, \"post-module-declaration\"\n \t\t\" imports must be contiguous\");\n@@ -14674,18 +14671,19 @@ cp_parser_import_declaration (cp_parser *parser, module_parse mp_state,\n \terror_at (token->location, \"import cannot appear directly in\"\n \t\t  \" a linkage-specification\");\n \n-      /* Module-purview imports must not be from source inclusion\n-\t [cpp.import]/7  */\n-      if (attrs && module_purview_p () && !global_purview_p ()\n-\t  && private_lookup_attribute (\"__translated\",\n-\t\t\t\t       strlen (\"__translated\"), attrs))\n-\terror_at (token->location, \"post-module-declaration imports\"\n-\t\t  \" must not be include-translated\");\n-      else if ((mp_state == MP_PURVIEW_IMPORTS\n-\t\t|| mp_state == MP_PRIVATE_IMPORTS)\n-\t       && !token->main_source_p)\n-\terror_at (token->location, \"post-module-declaration imports\"\n-\t\t  \" must not be from header inclusion\");\n+      if (mp_state == MP_PURVIEW_IMPORTS || mp_state == MP_PRIVATE_IMPORTS)\n+\t{\n+\t  /* Module-purview imports must not be from source inclusion\n+\t     [cpp.import]/7  */\n+\t  if (attrs\n+\t      && private_lookup_attribute (\"__translated\",\n+\t\t\t\t\t   strlen (\"__translated\"), attrs))\n+\t    error_at (token->location, \"post-module-declaration imports\"\n+\t\t      \" must not be include-translated\");\n+\t  else if (!token->main_source_p)\n+\t    error_at (token->location, \"post-module-declaration imports\"\n+\t\t      \" must not be from header inclusion\");\n+\t}\n \n       import_module (mod, token->location, exporting, attrs, parse_in);\n     }\n@@ -14941,10 +14939,14 @@ cp_parser_declaration (cp_parser* parser, tree prefix_attrs)\n       cp_token *next = exporting ? token2 : token1;\n       if (exporting)\n \tcp_lexer_consume_token (parser->lexer);\n+      // In module purview this will be ill-formed.\n+      auto state = (!named_module_p () ? MP_NOT_MODULE\n+\t\t    : module_purview_p () ? MP_PURVIEW\n+\t\t    : MP_GLOBAL);\n       if (next->keyword == RID__MODULE)\n-\tcp_parser_module_declaration (parser, MP_NOT_MODULE, exporting);\n+\tcp_parser_module_declaration (parser, state, exporting);\n       else\n-\tcp_parser_import_declaration (parser, MP_NOT_MODULE, exporting);\n+\tcp_parser_import_declaration (parser, state, exporting);\n     }\n   /* If the next token is `extern', 'static' or 'inline' and the one\n      after that is `template', we have a GNU extended explicit"}]}