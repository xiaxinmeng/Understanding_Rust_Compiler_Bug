{"sha": "f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyYWVkMjQ0YTFkMTBmMTliYTlkM2VhOTQzZDliYjMyZmIwMjA0MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-24T03:59:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-24T03:59:40Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1263", "tree": {"sha": "74f27bca772c329910ceeb39b9ae4ed0ab88bd26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f27bca772c329910ceeb39b9ae4ed0ab88bd26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/comments", "author": null, "committer": null, "parents": [{"sha": "8d6c8465b4aa95ec6d6dd35fd71908bcfbd7be3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d6c8465b4aa95ec6d6dd35fd71908bcfbd7be3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d6c8465b4aa95ec6d6dd35fd71908bcfbd7be3a"}], "stats": {"total": 64, "additions": 44, "deletions": 20}, "files": [{"sha": "2fcafcedaa8560427b143800e27075ed322bb804", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -442,7 +442,7 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n-  /* Size of the stack reserved for paramter registers.  */\n+  /* Size of the stack reserved for parameter registers.  */\n   int reg_parm_stack_space = 0;\n \n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */"}, {"sha": "f247d9fbafb8b3b1355359b3b9d47602b17413ef", "filename": "gcc/cccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -614,7 +614,7 @@ union hashval {\n  *\t\t{ wow(1, 2, 3); }\t->\t{ process( 2, 3, 1,  2, 3); }\n  *\t\t{ wow(one, two); }\t->\t{ process( two, one,  two); }\n  * if this \"rest_arg\" is used with the concat token '##' and if it is not\n- * supplied then the token attached to with ## will not be outputed.  Ex:\n+ * supplied then the token attached to with ## will not be outputted.  Ex:\n  * \t\t#define wow(a, b...)\t\tprocess(b ## , a, ## b)\n  *\t\t{ wow(1, 2); }\t\t->\t{ process( 2, 1,2); }\n  *\t\t{ wow(one); }\t\t->\t{ process( one); {\n@@ -6836,7 +6836,7 @@ macroexpand (hp, op)\n       if (rest_args)\n \tcontinue;\n       if (i < nargs || (nargs == 0 && i == 0)) {\n-\t/* if we are working on last arg which absorbes rest of args... */\n+\t/* if we are working on last arg which absorbs rest of args... */\n \tif (i == nargs - 1 && defn->rest_args)\n \t  rest_args = 1;\n \tparse_error = macarg (&args[i], rest_args);"}, {"sha": "7b5feb23e9f1f4c049aeb66ee5df94821613cef5", "filename": "gcc/collect2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -1380,7 +1380,7 @@ scan_prog_file (prog_name, which_pass)\n       load_cmd = load_end++;\n       load_hdr = (load_union_t *) (obj + offset);\n \n-      /* If modifing the program file, copy the header.  */\n+      /* If modifying the program file, copy the header.  */\n       if (rw)\n \t{\n \t  load_union_t *ptr = (load_union_t *) xmalloc (load_hdr->hdr.ldci_cmd_size);"}, {"sha": "79cc7e14822f01387fedc11fd324e6604a1efdae", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -1965,7 +1965,7 @@ find_split_point (loc)\n       /* If we have a PLUS whose second operand is a constant and the\n \t address is not valid, perhaps will can split it up using\n \t the machine-specific way to split large constants.  We use\n-\t the first psuedo-reg (one of the virtual regs) as a placeholder;\n+\t the first pseudo-reg (one of the virtual regs) as a placeholder;\n \t it will not remain in the result.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT"}, {"sha": "b05f014989256660ebd3a4e442e5b786c9d9feb5", "filename": "gcc/cse.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -2881,6 +2881,30 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t    return 0;\n \t  break;\n \n+\tcase ZERO_EXTEND:\n+\t  if (op_mode == VOIDmode\n+\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_INT)\n+\t    return 0;\n+\n+\t  hv = 0;\n+\t  lv = l1 & GET_MODE_MASK (op_mode);\n+\t  break;\n+\n+\tcase SIGN_EXTEND:\n+\t  if (op_mode == VOIDmode\n+\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_INT)\n+\t    return 0;\n+\t  else\n+\t    {\n+\t      lv = l1 & GET_MODE_MASK (op_mode);\n+\t      if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_INT\n+\t\t  && (lv & (1 << (GET_MODE_BITSIZE (op_mode) - 1))) != 0)\n+\t\tlv -= 1 << GET_MODE_BITSIZE (op_mode);\n+\n+\t      hv = (lv < 0) ? ~0 : 0;\n+\t    }\n+\t  break;\n+\n \tcase SQRT:\n \t  return 0;\n \n@@ -6775,7 +6799,7 @@ cse_around_loop (loop_start)\n \n   /* If the last insn of the loop (the end test) was an NE comparison,\n      we will interpret it as an EQ comparison, since we fell through\n-     the loop.  Any equivalances resulting from that comparison are\n+     the loop.  Any equivalences resulting from that comparison are\n      therefore not valid and must be invalidated.  */\n   if (last_jump_equiv_class)\n     for (p = last_jump_equiv_class->first_same_value; p;"}, {"sha": "d5ac243aaa589ce5908934a4e1c3f02721727877", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -1143,7 +1143,7 @@ dbxout_type (type, full, show_arg_types)\n \t    }\n \t  else\n \t    {\n-\t      /* When outputing destructors, we need to write\n+\t      /* When outputting destructors, we need to write\n \t\t the argument types out longhand.  */\n \t      dbxout_type (TYPE_METHOD_BASETYPE (type), 0, 0);\n \t      putc (',', asmfile);"}, {"sha": "f73d55196a8bb9e9ddf829381c00a96869e4981d", "filename": "gcc/dwarf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fdwarf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fdwarf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf.h?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -77,7 +77,7 @@ enum dwarf_tag {\n \n #define TAG_lo_user\t0x8000  /* implementation-defined range start */\n #define TAG_hi_user\t0xffff  /* implementation-defined range end */\n-#define TAG_source_file TAG_compile_unit  /* for backward compatability */\n+#define TAG_source_file TAG_compile_unit  /* for backward compatibility */\n \n /* Form names and codes.  */\n "}, {"sha": "57ac44b2bf3c2389269e2378c7f8dcbc7e17336e", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -161,7 +161,7 @@ static int new_block = 1;\n    and assume that they will both give the same number to each block.\n    Final uses these sequence numbers to generate assembler label names\n    LBBnnn and LBEnnn for the beginning and end of the symbol-block.\n-   Dbxout uses the sequence nunbers to generate references to the same labels\n+   Dbxout uses the sequence numbers to generate references to the same labels\n    from the dbx debugging information.\n \n    Sdb records this level at the beginning of each function,\n@@ -1029,7 +1029,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      if (GET_CODE (note) != NOTE && GET_CODE (note) != CODE_LABEL)\n \t\tbreak;\n \t      /* These types of notes can be significant\n-\t\t so make sure the preceeding line number stays.  */\n+\t\t so make sure the preceding line number stays.  */\n \t      else if (GET_CODE (note) == NOTE\n \t\t       && (NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_BEG\n \t\t\t   || NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_END"}, {"sha": "a2691096ba1649eb7da4958b130b4a5c0419a453", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -1694,7 +1694,7 @@ operand_equal_for_comparison_p (arg0, arg1, other)\n   return 0;\n }\n \f\n-/* See if ARG is an expression is either a comparison or is peforming\n+/* See if ARG is an expression that is either a comparison or is performing\n    arithmetic on comparisons.  The comparisons must only be comparing\n    two different values, which will be stored in *CVAL1 and *CVAL2; if\n    they are non-zero it means that some operands have already been found.\n@@ -1780,7 +1780,7 @@ twoval_comparison_p (arg, cval1, cval2)\n \f\n /* ARG is a tree that is known to contain just arithmetic operations and\n    comparisons.  Evaluate the operations in the tree substituting NEW0 for\n-   any occurrance of OLD0 as an operand of a comparison and likewise for\n+   any occurrence of OLD0 as an operand of a comparison and likewise for\n    NEW1 and OLD1.  */\n \n static tree\n@@ -2806,7 +2806,7 @@ fold (expr)\n \t       && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 1))))\n \t{\n \t  /* Don't leave an assignment inside a conversion\n-\t     unless assiging a bitfield.  */\n+\t     unless assigning a bitfield.  */\n \t  tree prev = TREE_OPERAND (t, 0);\n \t  TREE_OPERAND (t, 0) = TREE_OPERAND (prev, 1);\n \t  /* First do the assignment, then return converted constant.  */"}, {"sha": "dc96d815ab294d87e44f9c970bd51b0df3f27ad1", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -838,7 +838,7 @@ check_attr_test (exp, is_const)\n \t     so expressions using it can be permanent too.  */\n \t  exp = attr_eq (XSTR (exp, 0), XSTR (exp, 1));\n \n-\t  /* It shouldn't be possible to simplfy the value given to a\n+\t  /* It shouldn't be possible to simplify the value given to a\n \t     constant attribute, so don't expand this until it's time to\n \t     write the test expression.  */\t       \n \t  if (attr->is_const)"}, {"sha": "da509119f1dc22c456c4aa2f473359993ec7d245", "filename": "gcc/ginclude/stddef.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fginclude%2Fstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fginclude%2Fstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstddef.h?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -11,7 +11,7 @@\n #endif\n \n #ifndef __sys_stdtypes_h\n-/* This avoids lossage on Sunos but only if stdtypes.h comes first.\n+/* This avoids lossage on SunOS but only if stdtypes.h comes first.\n    There's no way to win with the other order!  Sun lossage.  */\n \n /* In case nobody has defined these types, but we aren't running under"}, {"sha": "315f147dcfd013656c3c745595738d43ded7e81b", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -2691,7 +2691,7 @@ st_to_string(symbol_type)\n \f\n /* Read a line from standard input, and return the start of the buffer\n    (which is grows if the line is too big).  We split lines at the\n-   semi-colon, and return each logical line indpendently.  */\n+   semi-colon, and return each logical line independently.  */\n \n STATIC char *\n read_line __proto((void))"}, {"sha": "ea3505c8e03422b2022d58695e0d0bc12c17c29a", "filename": "gcc/protoize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -50,7 +50,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #ifdef POSIX /* We should be able to define _POSIX_SOURCE unconditionally,\n \t\tbut some systems respond in buggy ways to it,\n-\t\tincluding Sunos 4.1.1.  Which we don't classify as POSIX.  */\n+\t\tincluding SunOS 4.1.1.  Which we don't classify as POSIX.  */\n /* In case this is a POSIX system with an ANSI C compiler,\n    ask for definition of all POSIX facilities.  */\n #undef _POSIX_SOURCE"}, {"sha": "d72010120f578accb976dffb395861fac3a749f3", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -84,7 +84,7 @@ init_recog ()\n \n /* Try recognizing the instruction INSN,\n    and return the code number that results.\n-   Remeber the code so that repeated calls do not\n+   Remember the code so that repeated calls do not\n    need to spend the time for actual rerecognition.\n \n    This function is the normal interface to instruction recognition."}, {"sha": "d9978b28aff31dbb7e4546fa81b113592150483a", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -1696,7 +1696,7 @@ immune_p (x, y, ydata)\n   return (xdata.start >= ydata.end || ydata.start >= xdata.end);\n }\n \n-/* Similiar, but calls decompose.  */\n+/* Similar, but calls decompose.  */\n \n int\n safe_from_earlyclobber (op, clobber)"}, {"sha": "f4f60039c2d5ac9e3c861b60ed40cb118369ad45", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72aed244a1d10f19ba9d3ea943d9bb32fb02041/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f72aed244a1d10f19ba9d3ea943d9bb32fb02041", "patch": "@@ -4256,7 +4256,7 @@ emit_jump_if_reachable (label)\n    current node are arranged to target the subordinates associated\n    code for out of bound conditions on the current node node.\n \n-   We can asume that when control reaches the code generated here,\n+   We can assume that when control reaches the code generated here,\n    the index value has already been compared with the parents\n    of this node, and determined to be on the same side of each parent\n    as this node is.  Thus, if this node tests for the value 51,"}]}