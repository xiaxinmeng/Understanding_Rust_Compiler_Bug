{"sha": "4f8cfb42883cc247f11096a3703e379d1f24ab3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY4Y2ZiNDI4ODNjYzI0N2YxMTA5NmEzNzAzZTM3OWQxZjI0YWIzZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-26T19:19:33Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-26T19:22:16Z"}, "message": "Extend builtin fnspecs\n\n\t* attr-fnspec.h: Update toplevel comment.\n\t(attr_fnspec::attr_fnspec): New constructor.\n\t(attr_fnspec::arg_read_p,\n\tattr_fnspec::arg_written_p,\n\tattr_fnspec::arg_access_size_given_by_arg_p,\n\tattr_fnspec::arg_single_access_p\n\tattr_fnspec::loads_known_p\n\tattr_fnspec::stores_known_p,\n\tattr_fnspec::clobbers_errno_p): New member functions.\n\t(gimple_call_fnspec): Declare.\n\t(builtin_fnspec): Declare.\n\t* builtins.c: Include attr-fnspec.h\n\t(builtin_fnspec): New function.\n\t* builtins.def (BUILT_IN_MEMCPY): Do not specify RET1 fnspec.\n\t(BUILT_IN_MEMMOVE): Do not specify RET1 fnspec.\n\t(BUILT_IN_MEMSET): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRCAT): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRCPY): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRNCAT): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRNCPY): Do not specify RET1 fnspec.\n\t(BUILT_IN_MEMCPY_CHK): Do not specify RET1 fnspec.\n\t(BUILT_IN_MEMMOVE_CHK): Do not specify RET1 fnspec.\n\t(BUILT_IN_MEMSET_CHK): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRCAT_CHK): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRCPY_CHK): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRNCAT_CHK): Do not specify RET1 fnspec.\n\t(BUILT_IN_STRNCPY_CHK): Do not specify RET1 fnspec.\n\t* gimple.c (gimple_call_fnspec): Return attr_fnspec.\n\t(gimple_call_arg_flags): Update.\n\t(gimple_call_return_flags): Update.\n\t* tree-ssa-alias.c (check_fnspec): New function.\n\t(ref_maybe_used_by_call_p_1): Use fnspec for builtin handling.\n\t(call_may_clobber_ref_p_1): Likewise.\n\t(attr_fnspec::verify): Update verifier.\n\t* calls.c (decl_fnspec): New function.\n\t(decl_return_flags): Use it.", "tree": {"sha": "427a28a3f52d39bc54bd04eda144d76ae53e7765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/427a28a3f52d39bc54bd04eda144d76ae53e7765"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f8cfb42883cc247f11096a3703e379d1f24ab3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f8cfb42883cc247f11096a3703e379d1f24ab3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f8cfb42883cc247f11096a3703e379d1f24ab3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f8cfb42883cc247f11096a3703e379d1f24ab3f/comments", "author": null, "committer": null, "parents": [{"sha": "2118438f49f0c193abe3fa3def350a8129045746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2118438f49f0c193abe3fa3def350a8129045746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2118438f49f0c193abe3fa3def350a8129045746"}], "stats": {"total": 915, "additions": 452, "deletions": 463}, "files": [{"sha": "78b1a5a2b1c57f8b25bb0a4ea486a7dccf335ce7", "filename": "gcc/attr-fnspec.h", "status": "modified", "additions": 102, "deletions": 2, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fattr-fnspec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fattr-fnspec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattr-fnspec.h?ref=4f8cfb42883cc247f11096a3703e379d1f24ab3f", "patch": "@@ -27,11 +27,18 @@\n      '.'\tspecifies that nothing is known.\n    character 1  specifies additional function properties\n      ' '        specifies that nothing is known\n+     'p' or 'P' specifies that function is pure except for described side\n+\t\teffects.\n+     'c' or 'C' specifies that function is const except for described side\n+\t\teffects.\n+   The uppercase letter in addition specifies that function clobbers errno.\n \n    character 2+2i specifies properties of argument number i as follows:\n      'x' or 'X' specifies that parameter is unused.\n      'r' or 'R' specifies that the memory pointed to by the parameter is only\n \t\tread and does not escape\n+     'o' or 'O' specifies that the memory pointed to by the parameter is only\n+\t\twritten and does not escape\n      'w' or 'W' specifies that the memory pointed to by the parameter does not\n \t\tescape\n      '.'\tspecifies that nothing is known.\n@@ -42,6 +49,10 @@\n    character 3+2i specifies additional properties of argument number i\n    as follows:\n      ' '        nothing is known\n+     't'\tthe size of value written/read corresponds to the size of\n+\t\tof the pointed-to type of the argument type\n+     '1'...'9'  the size of value written/read is given by the specified\n+\t\targument\n  */\n \n #ifndef ATTR_FNSPEC_H\n@@ -72,13 +83,30 @@ class attr_fnspec\n     if (flag_checking)\n       verify ();\n   }\n+  attr_fnspec (const char *str)\n+  : str (str), len (strlen (str))\n+  {\n+    if (flag_checking)\n+      verify ();\n+  }\n   attr_fnspec (const_tree identifier)\n   : str (TREE_STRING_POINTER (identifier)),\n     len (TREE_STRING_LENGTH (identifier))\n   {\n     if (flag_checking)\n       verify ();\n   }\n+  attr_fnspec ()\n+  : str (NULL), len (0)\n+  {\n+  }\n+\n+  /* Return true if fn spec is known.  */\n+  bool\n+  known_p ()\n+  {\n+    return len;\n+  }\n \n   /* Return true if arg I is specified.  */\n   bool\n@@ -94,7 +122,7 @@ class attr_fnspec\n   {\n     unsigned int idx = arg_idx (i);\n     gcc_checking_assert (arg_specified_p (i));\n-    return str[idx] == 'R' || str[idx] == 'W';\n+    return str[idx] == 'R' || str[idx] == 'O' || str[idx] == 'W';\n   }\n \n   /* True if argument is used.  */\n@@ -115,14 +143,62 @@ class attr_fnspec\n     return str[idx] == 'r' || str[idx] == 'R';\n   }\n \n+  /* True if memory reached by the argument is read (directly or indirectly)  */\n+  bool\n+  arg_maybe_read_p (unsigned int i)\n+  {\n+    unsigned int idx = arg_idx (i);\n+    gcc_checking_assert (arg_specified_p (i));\n+    return str[idx] != 'o' && str[idx] != 'O'\n+\t   && str[idx] != 'x' && str[idx] != 'X';\n+  }\n+\n+  /* True if memory reached by the argument is written.\n+     (directly or indirectly)  */\n+  bool\n+  arg_maybe_written_p (unsigned int i)\n+  {\n+    unsigned int idx = arg_idx (i);\n+    gcc_checking_assert (arg_specified_p (i));\n+    return str[idx] != 'r' && str[idx] != 'R'\n+\t   && str[idx] != 'x' && str[idx] != 'X';\n+  }\n+\n+  /* Return true if load of memory pointed to by argument I is specified\n+     by another argument.  In this case set ARG.  */\n+  bool\n+  arg_max_access_size_given_by_arg_p (unsigned int i, unsigned int *arg)\n+  {\n+    unsigned int idx = arg_idx (i);\n+    gcc_checking_assert (arg_specified_p (i));\n+    if (str[idx + 1] >= '1' && str[idx + 1] <= '9')\n+      {\n+\t*arg = str[idx + 1] - '1';\n+\treturn true;\n+      }\n+    else\n+      return false;\n+  }\n+\n+  /* Return true if the pointed-to type of the argument correspond to the\n+     size of the memory acccess.  */\n+  bool\n+  arg_access_size_given_by_type_p (unsigned int i)\n+  {\n+    unsigned int idx = arg_idx (i);\n+    gcc_checking_assert (arg_specified_p (i));\n+    return str[idx + 1] == 't';\n+  }\n+\n   /* True if the argument does not escape.  */\n   bool\n   arg_noescape_p (unsigned int i)\n   {\n     unsigned int idx = arg_idx (i);\n     gcc_checking_assert (arg_specified_p (i));\n     return str[idx] == 'w' || str[idx] == 'W'\n-\t   || str[idx] == 'R' || str[idx] == 'r';\n+\t   || str[idx] == 'r' || str[idx] == 'R'\n+\t   || str[idx] == 'o' || str[idx] == 'O';\n   }\n \n   /* Return true if function returns value of its parameter.  If ARG_NO is\n@@ -147,8 +223,32 @@ class attr_fnspec\n     return str[0] == 'm';\n   }\n \n+  /* Return true if all memory read by the function is specified by fnspec.  */\n+  bool\n+  global_memory_read_p ()\n+  {\n+    return str[1] != 'c' && str[1] != 'C';\n+  }\n+\n+  /* Return true if all memory written by the function \n+     is specified by fnspec.  */\n+  bool\n+  global_memory_written_p ()\n+  {\n+    return str[1] != 'c' && str[1] != 'C' && str[1] != 'p' && str[1] != 'P';\n+  }\n+\n+  bool\n+  errno_maybe_written_p ()\n+  {\n+    return str[1] == 'C' || str[1] == 'P';\n+  }\n+\n   /* Check validity of the string.  */\n   void verify ();\n };\n \n+extern attr_fnspec gimple_call_fnspec (const gcall *stmt);\n+extern attr_fnspec builtin_fnspec (tree);\n+\n #endif /* ATTR_FNSPEC_H  */"}, {"sha": "e7d4ff38083c12e203f05fbedefd099f93d279d6", "filename": "gcc/builtins.c", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4f8cfb42883cc247f11096a3703e379d1f24ab3f", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa.h\"\n #include \"tree-ssa-live.h\"\n #include \"tree-outof-ssa.h\"\n+#include \"attr-fnspec.h\"\n \n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n@@ -12913,3 +12914,165 @@ access_ref::offset_bounded () const\n   tree max = TYPE_MAX_VALUE (ptrdiff_type_node);\n   return wi::to_offset (min) <= offrng[0] && offrng[1] <= wi::to_offset (max);\n }\n+\n+/* If CALLEE has known side effects, fill in INFO and return true.\n+   See tree-ssa-structalias.c:find_func_aliases\n+   for the list of builtins we might need to handle here.  */\n+\n+attr_fnspec\n+builtin_fnspec (tree callee)\n+{\n+  built_in_function code = DECL_FUNCTION_CODE (callee);\n+\n+  switch (code)\n+    {\n+      /* All the following functions read memory pointed to by\n+\t their second argument and write memory pointed to by first\n+\t argument.\n+\t strcat/strncat additionally reads memory pointed to by the first\n+\t argument.  */\n+      case BUILT_IN_STRCAT:\n+      case BUILT_IN_STRCAT_CHK:\n+\treturn \"1cW R \";\n+      case BUILT_IN_STRNCAT:\n+      case BUILT_IN_STRNCAT_CHK:\n+\treturn \"1cW R3\";\n+      case BUILT_IN_STRCPY:\n+      case BUILT_IN_STRCPY_CHK:\n+\treturn \"1cO R \";\n+      case BUILT_IN_STPCPY:\n+      case BUILT_IN_STPCPY_CHK:\n+\treturn \".cO R \";\n+      case BUILT_IN_STRNCPY:\n+      case BUILT_IN_MEMCPY:\n+      case BUILT_IN_MEMMOVE:\n+      case BUILT_IN_TM_MEMCPY:\n+      case BUILT_IN_TM_MEMMOVE:\n+      case BUILT_IN_STRNCPY_CHK:\n+      case BUILT_IN_MEMCPY_CHK:\n+      case BUILT_IN_MEMMOVE_CHK:\n+\treturn \"1cO3R3\";\n+      case BUILT_IN_MEMPCPY:\n+      case BUILT_IN_MEMPCPY_CHK:\n+\treturn \".cO3R3\";\n+      case BUILT_IN_STPNCPY:\n+      case BUILT_IN_STPNCPY_CHK:\n+\treturn \".cO3R3\";\n+      case BUILT_IN_BCOPY:\n+\treturn \".cR3O3\";\n+\n+      /* The following functions read memory pointed to by their\n+\t first argument.  */\n+      CASE_BUILT_IN_TM_LOAD (1):\n+      CASE_BUILT_IN_TM_LOAD (2):\n+      CASE_BUILT_IN_TM_LOAD (4):\n+      CASE_BUILT_IN_TM_LOAD (8):\n+      CASE_BUILT_IN_TM_LOAD (FLOAT):\n+      CASE_BUILT_IN_TM_LOAD (DOUBLE):\n+      CASE_BUILT_IN_TM_LOAD (LDOUBLE):\n+      CASE_BUILT_IN_TM_LOAD (M64):\n+      CASE_BUILT_IN_TM_LOAD (M128):\n+      CASE_BUILT_IN_TM_LOAD (M256):\n+      case BUILT_IN_TM_LOG:\n+      case BUILT_IN_TM_LOG_1:\n+      case BUILT_IN_TM_LOG_2:\n+      case BUILT_IN_TM_LOG_4:\n+      case BUILT_IN_TM_LOG_8:\n+      case BUILT_IN_TM_LOG_FLOAT:\n+      case BUILT_IN_TM_LOG_DOUBLE:\n+      case BUILT_IN_TM_LOG_LDOUBLE:\n+      case BUILT_IN_TM_LOG_M64:\n+      case BUILT_IN_TM_LOG_M128:\n+      case BUILT_IN_TM_LOG_M256:\n+\treturn \".cR \";\n+\n+      case BUILT_IN_INDEX:\n+      case BUILT_IN_STRCHR:\n+      case BUILT_IN_STRRCHR:\n+\treturn \".cR \";\n+\n+      /* These read memory pointed to by the first argument.\n+\t Allocating memory does not have any side-effects apart from\n+\t being the definition point for the pointer.\n+\t Unix98 specifies that errno is set on allocation failure.  */\n+      case BUILT_IN_STRDUP:\n+\treturn \"mCR \";\n+      case BUILT_IN_STRNDUP:\n+\treturn \"mCR2\";\n+      /* Allocating memory does not have any side-effects apart from\n+\t being the definition point for the pointer.  */\n+      case BUILT_IN_MALLOC:\n+      case BUILT_IN_ALIGNED_ALLOC:\n+      case BUILT_IN_CALLOC:\n+\treturn \"mC\";\n+      CASE_BUILT_IN_ALLOCA:\n+\treturn \"mc\";\n+      /* These read memory pointed to by the first argument with size\n+\t in the third argument.  */\n+      case BUILT_IN_MEMCHR:\n+\treturn \".cR3\";\n+      /* These read memory pointed to by the first and second arguments.  */\n+      case BUILT_IN_STRSTR:\n+      case BUILT_IN_STRPBRK:\n+\treturn \".cR R \";\n+      /* Freeing memory kills the pointed-to memory.  More importantly\n+\t the call has to serve as a barrier for moving loads and stores\n+\t across it.  */\n+      case BUILT_IN_STACK_RESTORE:\n+      case BUILT_IN_FREE:\n+\treturn \".co \";\n+      case BUILT_IN_VA_END:\n+\treturn \".cO \";\n+      /* Realloc serves both as allocation point and deallocation point.  */\n+      case BUILT_IN_REALLOC:\n+\treturn \".cw \";\n+      case BUILT_IN_GAMMA_R:\n+      case BUILT_IN_GAMMAF_R:\n+      case BUILT_IN_GAMMAL_R:\n+      case BUILT_IN_LGAMMA_R:\n+      case BUILT_IN_LGAMMAF_R:\n+      case BUILT_IN_LGAMMAL_R:\n+\treturn \".C. Ot\";\n+      case BUILT_IN_FREXP:\n+      case BUILT_IN_FREXPF:\n+      case BUILT_IN_FREXPL:\n+      case BUILT_IN_MODF:\n+      case BUILT_IN_MODFF:\n+      case BUILT_IN_MODFL:\n+\treturn \".c. Ot\";\n+      case BUILT_IN_REMQUO:\n+      case BUILT_IN_REMQUOF:\n+      case BUILT_IN_REMQUOL:\n+\treturn \".c. . Ot\";\n+      case BUILT_IN_SINCOS:\n+      case BUILT_IN_SINCOSF:\n+      case BUILT_IN_SINCOSL:\n+\treturn \".c. OtOt\";\n+      case BUILT_IN_MEMSET:\n+      case BUILT_IN_MEMSET_CHK:\n+      case BUILT_IN_TM_MEMSET:\n+\treturn \"1cO3\";\n+      CASE_BUILT_IN_TM_STORE (1):\n+      CASE_BUILT_IN_TM_STORE (2):\n+      CASE_BUILT_IN_TM_STORE (4):\n+      CASE_BUILT_IN_TM_STORE (8):\n+      CASE_BUILT_IN_TM_STORE (FLOAT):\n+      CASE_BUILT_IN_TM_STORE (DOUBLE):\n+      CASE_BUILT_IN_TM_STORE (LDOUBLE):\n+      CASE_BUILT_IN_TM_STORE (M64):\n+      CASE_BUILT_IN_TM_STORE (M128):\n+      CASE_BUILT_IN_TM_STORE (M256):\n+\treturn \".cO \";\n+      case BUILT_IN_STACK_SAVE:\n+\treturn \".c\";\n+      case BUILT_IN_ASSUME_ALIGNED:\n+\treturn \"1cX \";\n+      /* But posix_memalign stores a pointer into the memory pointed to\n+\t by its first argument.  */\n+      case BUILT_IN_POSIX_MEMALIGN:\n+\treturn \".cOt\";\n+\n+      default:\n+\treturn \"\";\n+    }\n+}"}, {"sha": "61aff89e658cf83be2ac59122b415a97ac1fdfed", "filename": "gcc/builtins.def", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=4f8cfb42883cc247f11096a3703e379d1f24ab3f", "patch": "@@ -701,26 +701,26 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_BZERO, \"bzero\", BT_FN_VOID_PTR_SIZE, ATTR_NOTHR\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_INDEX, \"index\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_MEMCHR, \"memchr\", BT_FN_PTR_CONST_PTR_INT_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_MEMCMP, \"memcmp\", BT_FN_INT_CONST_PTR_CONST_PTR_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN\t       (BUILT_IN_MEMCPY, \"memcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN\t       (BUILT_IN_MEMMOVE, \"memmove\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN\t       (BUILT_IN_MEMCPY, \"memcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN\t       (BUILT_IN_MEMMOVE, \"memmove\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY, \"mempcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RETNONNULL_NOTHROW_LEAF)\n-DEF_LIB_BUILTIN\t       (BUILT_IN_MEMSET, \"memset\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN\t       (BUILT_IN_MEMSET, \"memset\", BT_FN_PTR_PTR_INT_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_RINDEX, \"rindex\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY, \"stpcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_RETNONNULL_NOTHROW_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPNCPY, \"stpncpy\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RETNONNULL_NOTHROW_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCASECMP, \"strcasecmp\", BT_FN_INT_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_STRCAT, \"strcat\", BT_FN_STRING_STRING_CONST_STRING, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_STRCAT, \"strcat\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCHR, \"strchr\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCMP, \"strcmp\", BT_FN_INT_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_STRCPY, \"strcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_STRCPY, \"strcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCSPN, \"strcspn\", BT_FN_SIZE_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_C2X_BUILTIN        (BUILT_IN_STRDUP, \"strdup\", BT_FN_STRING_CONST_STRING, ATTR_MALLOC_WARN_UNUSED_RESULT_NOTHROW_NONNULL_LEAF)\n DEF_C2X_BUILTIN        (BUILT_IN_STRNDUP, \"strndup\", BT_FN_STRING_CONST_STRING_SIZE, ATTR_MALLOC_WARN_UNUSED_RESULT_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRLEN, \"strlen\", BT_FN_SIZE_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCASECMP, \"strncasecmp\", BT_FN_INT_CONST_STRING_CONST_STRING_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_STRNCAT, \"strncat\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_STRNCAT, \"strncat\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRNCMP, \"strncmp\", BT_FN_INT_CONST_STRING_CONST_STRING_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_STRNCPY, \"strncpy\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_STRNCPY, \"strncpy\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNLEN, \"strnlen\", BT_FN_SIZE_CONST_STRING_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRPBRK, \"strpbrk\", BT_FN_STRING_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRRCHR, \"strrchr\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n@@ -970,16 +970,16 @@ DEF_BUILTIN_STUB (BUILT_IN_STRNCMP_EQ, \"__builtin_strncmp_eq\")\n \n /* Object size checking builtins.  */\n DEF_GCC_BUILTIN\t       (BUILT_IN_OBJECT_SIZE, \"object_size\", BT_FN_SIZE_CONST_PTR_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, \"__memcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, \"__memmove_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, \"__memcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, \"__memmove_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY_CHK, \"__mempcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RETNONNULL_NOTHROW_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMSET_CHK, \"__memset_chk\", BT_FN_PTR_PTR_INT_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMSET_CHK, \"__memset_chk\", BT_FN_PTR_PTR_INT_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY_CHK, \"__stpcpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RETNONNULL_NOTHROW_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPNCPY_CHK, \"__stpncpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_RETNONNULL_NOTHROW_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCAT_CHK, \"__strcat_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCPY_CHK, \"__strcpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCAT_CHK, \"__strncat_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCPY_CHK, \"__strncpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCAT_CHK, \"__strcat_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCPY_CHK, \"__strcpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCAT_CHK, \"__strncat_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCPY_CHK, \"__strncpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_SNPRINTF_CHK, \"__snprintf_chk\", BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_NOTHROW_5_6)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_SPRINTF_CHK, \"__sprintf_chk\", BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VAR, ATTR_NOTHROW_NONNULL_1_FORMAT_PRINTF_4_5)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_VSNPRINTF_CHK, \"__vsnprintf_chk\", BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_NOTHROW_5_0)"}, {"sha": "a8f459632f2f4f9fec667a5f697f6f825b833210", "filename": "gcc/calls.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4f8cfb42883cc247f11096a3703e379d1f24ab3f", "patch": "@@ -630,21 +630,32 @@ special_function_p (const_tree fndecl, int flags)\n   return flags;\n }\n \n+/* Return fnspec for DECL.  */\n+\n+static attr_fnspec\n+decl_fnspec (tree fndecl)\n+{\n+  tree attr;\n+  tree type = TREE_TYPE (fndecl);\n+  if (type)\n+    {\n+      attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n+      if (attr)\n+\t{\n+\t  return TREE_VALUE (TREE_VALUE (attr));\n+\t}\n+    }\n+  if (fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n+    return builtin_fnspec (fndecl);\n+  return \"\";\n+}\n+\n /* Similar to special_function_p; return a set of ERF_ flags for the\n    function FNDECL.  */\n static int\n decl_return_flags (tree fndecl)\n {\n-  tree attr;\n-  tree type = TREE_TYPE (fndecl);\n-  if (!type)\n-    return 0;\n-\n-  attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n-  if (!attr)\n-    return 0;\n-\n-  attr_fnspec fnspec (TREE_VALUE (TREE_VALUE (attr)));\n+  attr_fnspec fnspec = decl_fnspec (fndecl);\n \n   unsigned int arg;\n   if (fnspec.returns_arg (&arg))"}, {"sha": "469e6f369f3c32ae4b335b7402e08c3645c34978", "filename": "gcc/gimple.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4f8cfb42883cc247f11096a3703e379d1f24ab3f", "patch": "@@ -1487,37 +1487,43 @@ gimple_call_flags (const gimple *stmt)\n \n /* Return the \"fn spec\" string for call STMT.  */\n \n-static const_tree\n+attr_fnspec\n gimple_call_fnspec (const gcall *stmt)\n {\n   tree type, attr;\n \n   if (gimple_call_internal_p (stmt))\n-    return internal_fn_fnspec (gimple_call_internal_fn (stmt));\n+    {\n+      const_tree spec = internal_fn_fnspec (gimple_call_internal_fn (stmt));\n+      if (spec)\n+\treturn spec;\n+      else\n+\treturn \"\";\n+    }\n \n   type = gimple_call_fntype (stmt);\n-  if (!type)\n-    return NULL_TREE;\n-\n-  attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n-  if (!attr)\n-    return NULL_TREE;\n-\n-  return TREE_VALUE (TREE_VALUE (attr));\n+  if (type)\n+    {\n+      attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n+      if (attr)\n+\treturn TREE_VALUE (TREE_VALUE (attr));\n+    }\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    return builtin_fnspec (gimple_call_fndecl (stmt));\n+  return \"\";\n }\n \n /* Detects argument flags for argument number ARG on call STMT.  */\n \n int\n gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n {\n-  const_tree attr = gimple_call_fnspec (stmt);\n+  attr_fnspec fnspec = gimple_call_fnspec (stmt);\n \n-  if (!attr)\n+  if (!fnspec.known_p ())\n     return 0;\n \n   int flags = 0;\n-  attr_fnspec fnspec (attr);\n \n   if (!fnspec.arg_specified_p (arg))\n     ;\n@@ -1540,15 +1546,10 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n int\n gimple_call_return_flags (const gcall *stmt)\n {\n-  const_tree attr;\n-\n   if (gimple_call_flags (stmt) & ECF_MALLOC)\n     return ERF_NOALIAS;\n \n-  attr = gimple_call_fnspec (stmt);\n-  if (!attr)\n-    return 0;\n-  attr_fnspec fnspec (attr);\n+  attr_fnspec fnspec = gimple_call_fnspec (stmt);\n \n   unsigned int arg_no;\n   if (fnspec.returns_arg (&arg_no))"}, {"sha": "bc0f32a774ad249c4cbdda23e815648203218550", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 132, "deletions": 418, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f8cfb42883cc247f11096a3703e379d1f24ab3f/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4f8cfb42883cc247f11096a3703e379d1f24ab3f", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"errors.h\"\n #include \"dbgcnt.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"print-tree.h\"\n \n /* Broad overview of how alias analysis on gimple works:\n \n@@ -2572,6 +2573,99 @@ modref_may_conflict (const gimple *stmt,\n   return false;\n }\n \n+/* Check if REF conflicts with call using \"fn spec\" attribute.\n+   If CLOBBER is true we are checking for writes, otherwise check loads.\n+\n+   Return 0 if there are no conflicts (except for possible function call\n+   argument reads), 1 if there are conflicts and -1 if we can not decide by\n+   fn spec.  */\n+\n+static int\n+check_fnspec (gcall *call, ao_ref *ref, bool clobber)\n+{\n+  attr_fnspec fnspec = gimple_call_fnspec (call);\n+  if (fnspec.known_p ())\n+    {\n+      if (clobber\n+\t  ? !fnspec.global_memory_written_p ()\n+\t  : !fnspec.global_memory_read_p ())\n+\t{\n+\t  for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n+\t    if (POINTER_TYPE_P (TREE_TYPE (gimple_call_arg (call, i)))\n+\t\t&& (!fnspec.arg_specified_p (i)\n+\t\t    || (clobber ? fnspec.arg_maybe_written_p (i)\n+\t\t\t: fnspec.arg_maybe_read_p (i))))\n+\t      {\n+\t\tao_ref dref;\n+\t\ttree size = NULL_TREE;\n+\t\tunsigned int size_arg;\n+\n+\t\tif (!fnspec.arg_specified_p (i))\n+\t\t  ;\n+\t\telse if (fnspec.arg_max_access_size_given_by_arg_p\n+\t\t\t   (i, &size_arg))\n+\t\t  size = gimple_call_arg (call, size_arg);\n+\t\telse if (fnspec.arg_access_size_given_by_type_p (i))\n+\t\t  {\n+\t\t    tree callee = gimple_call_fndecl (call);\n+\t\t    tree t = TYPE_ARG_TYPES (TREE_TYPE (callee));\n+\n+\t\t    for (unsigned int p = 0; p < i; p++)\n+\t\t      t = TREE_CHAIN (t);\n+\t\t    size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_VALUE (t)));\n+\t\t  }\n+\t\tao_ref_init_from_ptr_and_size (&dref,\n+\t\t\t\t\t       gimple_call_arg (call, i),\n+\t\t\t\t\t       size);\n+\t\tif (refs_may_alias_p_1 (&dref, ref, false))\n+\t\t  return 1;\n+\t      }\n+\t  if (clobber\n+\t      && fnspec.errno_maybe_written_p ()\n+\t      && flag_errno_math\n+\t      && targetm.ref_may_alias_errno (ref))\n+\t    return 1;\n+\t  return 0;\n+\t}\n+    }\n+\n+ /* FIXME: we should handle barriers more consistently, but for now leave the\n+    check here.  */\n+  if (gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+    switch (DECL_FUNCTION_CODE (gimple_call_fndecl (call)))\n+      {\n+      /* __sync_* builtins and some OpenMP builtins act as threading\n+\t barriers.  */\n+#undef DEF_SYNC_BUILTIN\n+#define DEF_SYNC_BUILTIN(ENUM, NAME, TYPE, ATTRS) case ENUM:\n+#include \"sync-builtins.def\"\n+#undef DEF_SYNC_BUILTIN\n+      case BUILT_IN_GOMP_ATOMIC_START:\n+      case BUILT_IN_GOMP_ATOMIC_END:\n+      case BUILT_IN_GOMP_BARRIER:\n+      case BUILT_IN_GOMP_BARRIER_CANCEL:\n+      case BUILT_IN_GOMP_TASKWAIT:\n+      case BUILT_IN_GOMP_TASKGROUP_END:\n+      case BUILT_IN_GOMP_CRITICAL_START:\n+      case BUILT_IN_GOMP_CRITICAL_END:\n+      case BUILT_IN_GOMP_CRITICAL_NAME_START:\n+      case BUILT_IN_GOMP_CRITICAL_NAME_END:\n+      case BUILT_IN_GOMP_LOOP_END:\n+      case BUILT_IN_GOMP_LOOP_END_CANCEL:\n+      case BUILT_IN_GOMP_ORDERED_START:\n+      case BUILT_IN_GOMP_ORDERED_END:\n+      case BUILT_IN_GOMP_SECTIONS_END:\n+      case BUILT_IN_GOMP_SECTIONS_END_CANCEL:\n+      case BUILT_IN_GOMP_SINGLE_COPY_START:\n+      case BUILT_IN_GOMP_SINGLE_COPY_END:\n+\treturn 1;\n+\n+      default:\n+\treturn -1;\n+      }\n+  return -1;\n+}\n+\n /* If the call CALL may use the memory reference REF return true,\n    otherwise return false.  */\n \n@@ -2650,222 +2744,13 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       && !is_global_var (base))\n     goto process_args;\n \n-  /* Handle those builtin functions explicitly that do not act as\n-     escape points.  See tree-ssa-structalias.c:find_func_aliases\n-     for the list of builtins we might need to handle here.  */\n-  if (callee != NULL_TREE\n-      && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n-    switch (DECL_FUNCTION_CODE (callee))\n-      {\n-\t/* All the following functions read memory pointed to by\n-\t   their second argument.  strcat/strncat additionally\n-\t   reads memory pointed to by the first argument.  */\n-\tcase BUILT_IN_STRCAT:\n-\tcase BUILT_IN_STRNCAT:\n-\t  {\n-\t    ao_ref dref;\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   NULL_TREE);\n-\t    if (refs_may_alias_p_1 (&dref, ref, false))\n-\t      return true;\n-\t  }\n-\t  /* FALLTHRU */\n-\tcase BUILT_IN_STRCPY:\n-\tcase BUILT_IN_STRNCPY:\n-\tcase BUILT_IN_MEMCPY:\n-\tcase BUILT_IN_MEMMOVE:\n-\tcase BUILT_IN_MEMPCPY:\n-\tcase BUILT_IN_STPCPY:\n-\tcase BUILT_IN_STPNCPY:\n-\tcase BUILT_IN_TM_MEMCPY:\n-\tcase BUILT_IN_TM_MEMMOVE:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = NULL_TREE;\n-\t    if (gimple_call_num_args (call) == 3)\n-\t      size = gimple_call_arg (call, 2);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 1),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\tcase BUILT_IN_STRCAT_CHK:\n-\tcase BUILT_IN_STRNCAT_CHK:\n-\t  {\n-\t    ao_ref dref;\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   NULL_TREE);\n-\t    if (refs_may_alias_p_1 (&dref, ref, false))\n-\t      return true;\n-\t  }\n-\t  /* FALLTHRU */\n-\tcase BUILT_IN_STRCPY_CHK:\n-\tcase BUILT_IN_STRNCPY_CHK:\n-\tcase BUILT_IN_MEMCPY_CHK:\n-\tcase BUILT_IN_MEMMOVE_CHK:\n-\tcase BUILT_IN_MEMPCPY_CHK:\n-\tcase BUILT_IN_STPCPY_CHK:\n-\tcase BUILT_IN_STPNCPY_CHK:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = NULL_TREE;\n-\t    if (gimple_call_num_args (call) == 4)\n-\t      size = gimple_call_arg (call, 2);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 1),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\tcase BUILT_IN_BCOPY:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = gimple_call_arg (call, 2);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\n-\t/* The following functions read memory pointed to by their\n-\t   first argument.  */\n-\tCASE_BUILT_IN_TM_LOAD (1):\n-\tCASE_BUILT_IN_TM_LOAD (2):\n-\tCASE_BUILT_IN_TM_LOAD (4):\n-\tCASE_BUILT_IN_TM_LOAD (8):\n-\tCASE_BUILT_IN_TM_LOAD (FLOAT):\n-\tCASE_BUILT_IN_TM_LOAD (DOUBLE):\n-\tCASE_BUILT_IN_TM_LOAD (LDOUBLE):\n-\tCASE_BUILT_IN_TM_LOAD (M64):\n-\tCASE_BUILT_IN_TM_LOAD (M128):\n-\tCASE_BUILT_IN_TM_LOAD (M256):\n-\tcase BUILT_IN_TM_LOG:\n-\tcase BUILT_IN_TM_LOG_1:\n-\tcase BUILT_IN_TM_LOG_2:\n-\tcase BUILT_IN_TM_LOG_4:\n-\tcase BUILT_IN_TM_LOG_8:\n-\tcase BUILT_IN_TM_LOG_FLOAT:\n-\tcase BUILT_IN_TM_LOG_DOUBLE:\n-\tcase BUILT_IN_TM_LOG_LDOUBLE:\n-\tcase BUILT_IN_TM_LOG_M64:\n-\tcase BUILT_IN_TM_LOG_M128:\n-\tcase BUILT_IN_TM_LOG_M256:\n-\t  return ptr_deref_may_alias_ref_p_1 (gimple_call_arg (call, 0), ref);\n-\n-\t/* These read memory pointed to by the first argument.  */\n-\tcase BUILT_IN_STRDUP:\n-\tcase BUILT_IN_STRNDUP:\n-\tcase BUILT_IN_REALLOC:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = NULL_TREE;\n-\t    if (gimple_call_num_args (call) == 2)\n-\t      size = gimple_call_arg (call, 1);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\t/* These read memory pointed to by the first argument.  */\n-\tcase BUILT_IN_INDEX:\n-\tcase BUILT_IN_STRCHR:\n-\tcase BUILT_IN_STRRCHR:\n-\t  {\n-\t    ao_ref dref;\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   NULL_TREE);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\t/* These read memory pointed to by the first argument with size\n-\t   in the third argument.  */\n-\tcase BUILT_IN_MEMCHR:\n-\t  {\n-\t    ao_ref dref;\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   gimple_call_arg (call, 2));\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\t/* These read memory pointed to by the first and second arguments.  */\n-\tcase BUILT_IN_STRSTR:\n-\tcase BUILT_IN_STRPBRK:\n-\t  {\n-\t    ao_ref dref;\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   NULL_TREE);\n-\t    if (refs_may_alias_p_1 (&dref, ref, false))\n-\t      return true;\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 1),\n-\t\t\t\t\t   NULL_TREE);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\n-\t/* The following builtins do not read from memory.  */\n-\tcase BUILT_IN_FREE:\n-\tcase BUILT_IN_MALLOC:\n-\tcase BUILT_IN_POSIX_MEMALIGN:\n-\tcase BUILT_IN_ALIGNED_ALLOC:\n-\tcase BUILT_IN_CALLOC:\n-\tCASE_BUILT_IN_ALLOCA:\n-\tcase BUILT_IN_STACK_SAVE:\n-\tcase BUILT_IN_STACK_RESTORE:\n-\tcase BUILT_IN_MEMSET:\n-\tcase BUILT_IN_TM_MEMSET:\n-\tcase BUILT_IN_MEMSET_CHK:\n-\tcase BUILT_IN_FREXP:\n-\tcase BUILT_IN_FREXPF:\n-\tcase BUILT_IN_FREXPL:\n-\tcase BUILT_IN_GAMMA_R:\n-\tcase BUILT_IN_GAMMAF_R:\n-\tcase BUILT_IN_GAMMAL_R:\n-\tcase BUILT_IN_LGAMMA_R:\n-\tcase BUILT_IN_LGAMMAF_R:\n-\tcase BUILT_IN_LGAMMAL_R:\n-\tcase BUILT_IN_MODF:\n-\tcase BUILT_IN_MODFF:\n-\tcase BUILT_IN_MODFL:\n-\tcase BUILT_IN_REMQUO:\n-\tcase BUILT_IN_REMQUOF:\n-\tcase BUILT_IN_REMQUOL:\n-\tcase BUILT_IN_SINCOS:\n-\tcase BUILT_IN_SINCOSF:\n-\tcase BUILT_IN_SINCOSL:\n-\tcase BUILT_IN_ASSUME_ALIGNED:\n-\tcase BUILT_IN_VA_END:\n-\t  return false;\n-\t/* __sync_* builtins and some OpenMP builtins act as threading\n-\t   barriers.  */\n-#undef DEF_SYNC_BUILTIN\n-#define DEF_SYNC_BUILTIN(ENUM, NAME, TYPE, ATTRS) case ENUM:\n-#include \"sync-builtins.def\"\n-#undef DEF_SYNC_BUILTIN\n-\tcase BUILT_IN_GOMP_ATOMIC_START:\n-\tcase BUILT_IN_GOMP_ATOMIC_END:\n-\tcase BUILT_IN_GOMP_BARRIER:\n-\tcase BUILT_IN_GOMP_BARRIER_CANCEL:\n-\tcase BUILT_IN_GOMP_TASKWAIT:\n-\tcase BUILT_IN_GOMP_TASKGROUP_END:\n-\tcase BUILT_IN_GOMP_CRITICAL_START:\n-\tcase BUILT_IN_GOMP_CRITICAL_END:\n-\tcase BUILT_IN_GOMP_CRITICAL_NAME_START:\n-\tcase BUILT_IN_GOMP_CRITICAL_NAME_END:\n-\tcase BUILT_IN_GOMP_LOOP_END:\n-\tcase BUILT_IN_GOMP_LOOP_END_CANCEL:\n-\tcase BUILT_IN_GOMP_ORDERED_START:\n-\tcase BUILT_IN_GOMP_ORDERED_END:\n-\tcase BUILT_IN_GOMP_SECTIONS_END:\n-\tcase BUILT_IN_GOMP_SECTIONS_END_CANCEL:\n-\tcase BUILT_IN_GOMP_SINGLE_COPY_START:\n-\tcase BUILT_IN_GOMP_SINGLE_COPY_END:\n-\t  return true;\n-\n-\tdefault:\n-\t  /* Fallthru to general call handling.  */;\n-      }\n+  if (int res = check_fnspec (call, ref, false))\n+    {\n+      if (res == 1)\n+\treturn true;\n+    }\n+  else\n+    goto process_args;\n \n   /* Check if base is a global static variable that is not read\n      by the function.  */\n@@ -3104,205 +2989,13 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       && SSA_NAME_POINTS_TO_READONLY_MEMORY (TREE_OPERAND (base, 0)))\n     return false;\n \n-  /* Handle those builtin functions explicitly that do not act as\n-     escape points.  See tree-ssa-structalias.c:find_func_aliases\n-     for the list of builtins we might need to handle here.  */\n-  if (callee != NULL_TREE\n-      && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n-    switch (DECL_FUNCTION_CODE (callee))\n-      {\n-\t/* All the following functions clobber memory pointed to by\n-\t   their first argument.  */\n-\tcase BUILT_IN_STRCPY:\n-\tcase BUILT_IN_STRNCPY:\n-\tcase BUILT_IN_MEMCPY:\n-\tcase BUILT_IN_MEMMOVE:\n-\tcase BUILT_IN_MEMPCPY:\n-\tcase BUILT_IN_STPCPY:\n-\tcase BUILT_IN_STPNCPY:\n-\tcase BUILT_IN_STRCAT:\n-\tcase BUILT_IN_STRNCAT:\n-\tcase BUILT_IN_MEMSET:\n-\tcase BUILT_IN_TM_MEMSET:\n-\tCASE_BUILT_IN_TM_STORE (1):\n-\tCASE_BUILT_IN_TM_STORE (2):\n-\tCASE_BUILT_IN_TM_STORE (4):\n-\tCASE_BUILT_IN_TM_STORE (8):\n-\tCASE_BUILT_IN_TM_STORE (FLOAT):\n-\tCASE_BUILT_IN_TM_STORE (DOUBLE):\n-\tCASE_BUILT_IN_TM_STORE (LDOUBLE):\n-\tCASE_BUILT_IN_TM_STORE (M64):\n-\tCASE_BUILT_IN_TM_STORE (M128):\n-\tCASE_BUILT_IN_TM_STORE (M256):\n-\tcase BUILT_IN_TM_MEMCPY:\n-\tcase BUILT_IN_TM_MEMMOVE:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = NULL_TREE;\n-\t    /* Don't pass in size for strncat, as the maximum size\n-\t       is strlen (dest) + n + 1 instead of n, resp.\n-\t       n + 1 at dest + strlen (dest), but strlen (dest) isn't\n-\t       known.  */\n-\t    if (gimple_call_num_args (call) == 3\n-\t\t&& DECL_FUNCTION_CODE (callee) != BUILT_IN_STRNCAT)\n-\t      size = gimple_call_arg (call, 2);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\tcase BUILT_IN_STRCPY_CHK:\n-\tcase BUILT_IN_STRNCPY_CHK:\n-\tcase BUILT_IN_MEMCPY_CHK:\n-\tcase BUILT_IN_MEMMOVE_CHK:\n-\tcase BUILT_IN_MEMPCPY_CHK:\n-\tcase BUILT_IN_STPCPY_CHK:\n-\tcase BUILT_IN_STPNCPY_CHK:\n-\tcase BUILT_IN_STRCAT_CHK:\n-\tcase BUILT_IN_STRNCAT_CHK:\n-\tcase BUILT_IN_MEMSET_CHK:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = NULL_TREE;\n-\t    /* Don't pass in size for __strncat_chk, as the maximum size\n-\t       is strlen (dest) + n + 1 instead of n, resp.\n-\t       n + 1 at dest + strlen (dest), but strlen (dest) isn't\n-\t       known.  */\n-\t    if (gimple_call_num_args (call) == 4\n-\t\t&& DECL_FUNCTION_CODE (callee) != BUILT_IN_STRNCAT_CHK)\n-\t      size = gimple_call_arg (call, 2);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 0),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\tcase BUILT_IN_BCOPY:\n-\t  {\n-\t    ao_ref dref;\n-\t    tree size = gimple_call_arg (call, 2);\n-\t    ao_ref_init_from_ptr_and_size (&dref,\n-\t\t\t\t\t   gimple_call_arg (call, 1),\n-\t\t\t\t\t   size);\n-\t    return refs_may_alias_p_1 (&dref, ref, false);\n-\t  }\n-\t/* Allocating memory does not have any side-effects apart from\n-\t   being the definition point for the pointer.  */\n-\tcase BUILT_IN_MALLOC:\n-\tcase BUILT_IN_ALIGNED_ALLOC:\n-\tcase BUILT_IN_CALLOC:\n-\tcase BUILT_IN_STRDUP:\n-\tcase BUILT_IN_STRNDUP:\n-\t  /* Unix98 specifies that errno is set on allocation failure.  */\n-\t  if (flag_errno_math\n-\t      && targetm.ref_may_alias_errno (ref))\n-\t    return true;\n-\t  return false;\n-\tcase BUILT_IN_STACK_SAVE:\n-\tCASE_BUILT_IN_ALLOCA:\n-\tcase BUILT_IN_ASSUME_ALIGNED:\n-\t  return false;\n-\t/* But posix_memalign stores a pointer into the memory pointed to\n-\t   by its first argument.  */\n-\tcase BUILT_IN_POSIX_MEMALIGN:\n-\t  {\n-\t    tree ptrptr = gimple_call_arg (call, 0);\n-\t    ao_ref dref;\n-\t    ao_ref_init_from_ptr_and_size (&dref, ptrptr,\n-\t\t\t\t\t   TYPE_SIZE_UNIT (ptr_type_node));\n-\t    return (refs_may_alias_p_1 (&dref, ref, false)\n-\t\t    || (flag_errno_math\n-\t\t\t&& targetm.ref_may_alias_errno (ref)));\n-\t  }\n-\t/* Freeing memory kills the pointed-to memory.  More importantly\n-\t   the call has to serve as a barrier for moving loads and stores\n-\t   across it.  */\n-\tcase BUILT_IN_FREE:\n-\tcase BUILT_IN_VA_END:\n-\t  {\n-\t    tree ptr = gimple_call_arg (call, 0);\n-\t    return ptr_deref_may_alias_ref_p_1 (ptr, ref);\n-\t  }\n-\t/* Realloc serves both as allocation point and deallocation point.  */\n-\tcase BUILT_IN_REALLOC:\n-\t  {\n-\t    tree ptr = gimple_call_arg (call, 0);\n-\t    /* Unix98 specifies that errno is set on allocation failure.  */\n-\t    return ((flag_errno_math\n-\t\t     && targetm.ref_may_alias_errno (ref))\n-\t\t    || ptr_deref_may_alias_ref_p_1 (ptr, ref));\n-\t  }\n-\tcase BUILT_IN_GAMMA_R:\n-\tcase BUILT_IN_GAMMAF_R:\n-\tcase BUILT_IN_GAMMAL_R:\n-\tcase BUILT_IN_LGAMMA_R:\n-\tcase BUILT_IN_LGAMMAF_R:\n-\tcase BUILT_IN_LGAMMAL_R:\n-\t  {\n-\t    tree out = gimple_call_arg (call, 1);\n-\t    if (ptr_deref_may_alias_ref_p_1 (out, ref))\n-\t      return true;\n-\t    if (flag_errno_math)\n-\t      break;\n-\t    return false;\n-\t  }\n-\tcase BUILT_IN_FREXP:\n-\tcase BUILT_IN_FREXPF:\n-\tcase BUILT_IN_FREXPL:\n-\tcase BUILT_IN_MODF:\n-\tcase BUILT_IN_MODFF:\n-\tcase BUILT_IN_MODFL:\n-\t  {\n-\t    tree out = gimple_call_arg (call, 1);\n-\t    return ptr_deref_may_alias_ref_p_1 (out, ref);\n-\t  }\n-\tcase BUILT_IN_REMQUO:\n-\tcase BUILT_IN_REMQUOF:\n-\tcase BUILT_IN_REMQUOL:\n-\t  {\n-\t    tree out = gimple_call_arg (call, 2);\n-\t    if (ptr_deref_may_alias_ref_p_1 (out, ref))\n-\t      return true;\n-\t    if (flag_errno_math)\n-\t      break;\n-\t    return false;\n-\t  }\n-\tcase BUILT_IN_SINCOS:\n-\tcase BUILT_IN_SINCOSF:\n-\tcase BUILT_IN_SINCOSL:\n-\t  {\n-\t    tree sin = gimple_call_arg (call, 1);\n-\t    tree cos = gimple_call_arg (call, 2);\n-\t    return (ptr_deref_may_alias_ref_p_1 (sin, ref)\n-\t\t    || ptr_deref_may_alias_ref_p_1 (cos, ref));\n-\t  }\n-\t/* __sync_* builtins and some OpenMP builtins act as threading\n-\t   barriers.  */\n-#undef DEF_SYNC_BUILTIN\n-#define DEF_SYNC_BUILTIN(ENUM, NAME, TYPE, ATTRS) case ENUM:\n-#include \"sync-builtins.def\"\n-#undef DEF_SYNC_BUILTIN\n-\tcase BUILT_IN_GOMP_ATOMIC_START:\n-\tcase BUILT_IN_GOMP_ATOMIC_END:\n-\tcase BUILT_IN_GOMP_BARRIER:\n-\tcase BUILT_IN_GOMP_BARRIER_CANCEL:\n-\tcase BUILT_IN_GOMP_TASKWAIT:\n-\tcase BUILT_IN_GOMP_TASKGROUP_END:\n-\tcase BUILT_IN_GOMP_CRITICAL_START:\n-\tcase BUILT_IN_GOMP_CRITICAL_END:\n-\tcase BUILT_IN_GOMP_CRITICAL_NAME_START:\n-\tcase BUILT_IN_GOMP_CRITICAL_NAME_END:\n-\tcase BUILT_IN_GOMP_LOOP_END:\n-\tcase BUILT_IN_GOMP_LOOP_END_CANCEL:\n-\tcase BUILT_IN_GOMP_ORDERED_START:\n-\tcase BUILT_IN_GOMP_ORDERED_END:\n-\tcase BUILT_IN_GOMP_SECTIONS_END:\n-\tcase BUILT_IN_GOMP_SECTIONS_END_CANCEL:\n-\tcase BUILT_IN_GOMP_SINGLE_COPY_START:\n-\tcase BUILT_IN_GOMP_SINGLE_COPY_END:\n-\t  return true;\n-\tdefault:\n-\t  /* Fallthru to general call handling.  */;\n-      }\n+  if (int res = check_fnspec (call, ref, true))\n+    {\n+      if (res == 1)\n+\treturn true;\n+    }\n+  else\n+    return false;\n \n   /* Check if base is a global static variable that is not written\n      by the function.  */\n@@ -4079,6 +3772,8 @@ void\n attr_fnspec::verify ()\n {\n   bool err = false;\n+  if (!len)\n+    return;\n \n   /* Check return value specifier.  */\n   if (len < return_desc_size)\n@@ -4092,8 +3787,17 @@ attr_fnspec::verify ()\n \t   && str[0] != 'R' && str[0] != 'W')\n     err = true;\n \n-  if (str[1] != ' ')\n-    err = true;\n+  switch (str[1])\n+    {\n+      case ' ':\n+      case 'p':\n+      case 'P':\n+      case 'c':\n+      case 'C':\n+\tbreak;\n+      default:\n+\terr = true;\n+    }\n \n   /* Now check all parameters.  */\n   for (unsigned int i = 0; arg_specified_p (i); i++)\n@@ -4105,14 +3809,24 @@ attr_fnspec::verify ()\n \t  case 'X':\n \t  case 'r':\n \t  case 'R':\n+\t  case 'o':\n+\t  case 'O':\n \t  case 'w':\n \t  case 'W':\n \t  case '.':\n \t    break;\n \t  default:\n \t    err = true;\n \t}\n-      if (str[idx + 1] != ' ')\n+      if ((str[idx + 1] >= '1' && str[idx + 1] <= '9')\n+\t  || str[idx + 1] == 't')\n+\t{\n+\t  if (str[idx] != 'r' && str[idx] != 'R'\n+\t      && str[idx] != 'w' && str[idx] != 'W'\n+\t      && str[idx] != 'o' && str[idx] != 'O')\n+\t    err = true;\n+\t}\n+      else if (str[idx + 1] != ' ')\n \terr = true;\n     }\n   if (err)"}]}