{"sha": "ce65449a3562d260d3153d5345076bab06761df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2NTQ0OWEzNTYyZDI2MGQzMTUzZDUzNDUwNzZiYWIwNjc2MWRmNQ==", "commit": {"author": {"name": "Jose Ruiz", "email": "ruiz@adacore.com", "date": "2005-03-18T11:51:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-18T11:51:53Z"}, "message": "s-taprob.adb (Initialize_Protection): Initialize the protected object's owner to Null_Task.\n\n2005-03-17  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-taprob.adb (Initialize_Protection): Initialize the protected\n\tobject's owner to Null_Task.\n\t(Lock): If pragma Detect_Blocking is in effect and the caller of this\n\tprocedure is already the protected object's owner then Program_Error\n\tis raised. In addition the protected object's owner is updated.\n\t(Lock_Read_Only): If pragma Detect_Blocking is in effect and the caller\n\tof this procedure is already the protected object's owner then\n\tProgram_Error is raised.\n\tIn addition the protected object's owner is updated.\n\t(Unlock): Remove the ownership of the protected object.\n\n\t* s-taprob.ads (Protection): Add the field Owner, used to store the\n\tprotected object's owner.\n\tThis component is needed for detecting one type of potentially blocking\n\toperations (external calls on a protected subprogram with the same\n\ttarget object as that of the protected action). Document the rest of\n\tthe components.\n\n\t* s-tposen.adb, s-tpoben.adb (Initialize_Protection_Entries):\n\tInitialize the protected object's owner to Null_Task.\n\t(Lock_Read_Only_Entries): If pragma Detect_Blocking is in effect and the\n\tcaller of this procedure is already the protected object's owner then\n\tProgram_Error is raised.\n\tDo not raise Program_Error when this procedure is called from a\n\tprotected action.\n\t(Unlock_Entries): Remove the ownership of the protected object.\n\t(Lock_Entries): If pragma Detect_Blocking is in effect and the caller\n\tof this procedure is already the protected object's owner then\n\tProgram_Error is raised.\n\tDo not raise Program_Error when this procedure is called from\n\ta protected action.\n\n\t* s-tposen.ads, s-tpoben.ads (Protection_Entries): Add the field Owner,\n\tused to store the protected object's owner.\n\n\t* s-tpobop.adb (Protected_Entry_Call): If pragma Detect_Blocking is in\n\teffect and this procedure (a potentially blocking operation) is called\n\tfrom whithin a protected action, Program_Error is raised.\n\t(Timed_Protected_Entry_Call): If pragma Detect_Blocking is in effect\n\tand this procedure (a potentially blocking operation) is called from\n\twhithin a protected action, Program_Error is raised.\n\nFrom-SVN: r96675", "tree": {"sha": "64ee2821f35518d4a6aacb1c892e4cffb403f050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64ee2821f35518d4a6aacb1c892e4cffb403f050"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce65449a3562d260d3153d5345076bab06761df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce65449a3562d260d3153d5345076bab06761df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce65449a3562d260d3153d5345076bab06761df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce65449a3562d260d3153d5345076bab06761df5/comments", "author": {"login": "JoseRuizAdaCore", "id": 22770339, "node_id": "MDQ6VXNlcjIyNzcwMzM5", "avatar_url": "https://avatars.githubusercontent.com/u/22770339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoseRuizAdaCore", "html_url": "https://github.com/JoseRuizAdaCore", "followers_url": "https://api.github.com/users/JoseRuizAdaCore/followers", "following_url": "https://api.github.com/users/JoseRuizAdaCore/following{/other_user}", "gists_url": "https://api.github.com/users/JoseRuizAdaCore/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoseRuizAdaCore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoseRuizAdaCore/subscriptions", "organizations_url": "https://api.github.com/users/JoseRuizAdaCore/orgs", "repos_url": "https://api.github.com/users/JoseRuizAdaCore/repos", "events_url": "https://api.github.com/users/JoseRuizAdaCore/events{/privacy}", "received_events_url": "https://api.github.com/users/JoseRuizAdaCore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "725e2a15a1d1d22063f0fbaf9d4b18565b846fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/725e2a15a1d1d22063f0fbaf9d4b18565b846fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/725e2a15a1d1d22063f0fbaf9d4b18565b846fd1"}], "stats": {"total": 478, "additions": 345, "deletions": 133}, "files": [{"sha": "eeee8366a641e2e14a4d5ab61f6ef16cf237e12c", "filename": "gcc/ada/s-taprob.adb", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-taprob.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-taprob.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprob.adb?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Ada Core Technologies               --\n+--                   Copyright (C) 1995-2005, AdaCore                       --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -73,13 +73,15 @@ package body System.Tasking.Protected_Objects is\n       Ceiling_Priority : Integer)\n    is\n       Init_Priority : Integer := Ceiling_Priority;\n+\n    begin\n       if Init_Priority = Unspecified_Priority then\n          Init_Priority  := System.Priority'Last;\n       end if;\n \n       Initialize_Lock (Init_Priority, Object.L'Access);\n       Object.Ceiling := System.Any_Priority (Init_Priority);\n+      Object.Owner := Null_Task;\n    end Initialize_Protection;\n \n    ----------\n@@ -100,6 +102,17 @@ package body System.Tasking.Protected_Objects is\n       --  generated calls must be protected with cleanup handlers to ensure\n       --  that abort is undeferred in all cases.\n \n+      --  If pragma Detect_Blocking is active then, as described in the ARM\n+      --  9.5.1, par. 15, we must check whether this is an external call on a\n+      --  protected subprogram with the same target object as that of the\n+      --  protected action that is currently in progress (i.e., if the caller\n+      --  is already the protected object's owner). If this is the case hence\n+      --  Program_Error must be raised.\n+\n+      if Detect_Blocking and then Object.Owner = Self then\n+         raise Program_Error;\n+      end if;\n+\n       Write_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Parameters.Runtime_Traces then\n@@ -112,12 +125,18 @@ package body System.Tasking.Protected_Objects is\n \n       --  We are entering in a protected action, so that we increase the\n       --  protected object nesting level (if pragma Detect_Blocking is\n-      --  active).\n+      --  active), and update the protected object's owner.\n \n       if Detect_Blocking then\n          declare\n             Self_Id : constant Task_Id := Self;\n          begin\n+            --  Update the protected object's owner\n+\n+            Object.Owner := Self_Id;\n+\n+            --  Increase protected object nesting level\n+\n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting + 1;\n          end;\n@@ -132,6 +151,25 @@ package body System.Tasking.Protected_Objects is\n       Ceiling_Violation : Boolean;\n \n    begin\n+      --  If pragma Detect_Blocking is active then, as described in the ARM\n+      --  9.5.1, par. 15, we must check whether this is an external call on\n+      --  protected subprogram with the same target object as that of the\n+      --  protected action that is currently in progress (i.e., if the caller\n+      --  is already the protected object's owner). If this is the case hence\n+      --  Program_Error must be raised.\n+      --\n+      --  Note that in this case (getting read access), several tasks may have\n+      --  read ownership of the protected object, so that this method of\n+      --  storing the (single) protected object's owner does not work reliably\n+      --  for read locks. However, this is the approach taken for two major\n+      --  reasosn: first, this function is not currently being used (it is\n+      --  provided for possible future use), and second, it largely simplifies\n+      --  the implementation.\n+\n+      if Detect_Blocking and then Object.Owner = Self then\n+         raise Program_Error;\n+      end if;\n+\n       Read_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Parameters.Runtime_Traces then\n@@ -142,14 +180,19 @@ package body System.Tasking.Protected_Objects is\n          raise Program_Error;\n       end if;\n \n-      --  We are entering in a protected action, so that we increase the\n-      --  protected object nesting level (if pragma Detect_Blocking is\n-      --  active).\n+      --  We are entering in a protected action, so we increase the protected\n+      --  object nesting level (if pragma Detect_Blocking is active).\n \n       if Detect_Blocking then\n          declare\n             Self_Id : constant Task_Id := Self;\n          begin\n+            --  Update the protected object's owner\n+\n+            Object.Owner := Self_Id;\n+\n+            --  Increase protected object nesting level\n+\n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting + 1;\n          end;\n@@ -164,17 +207,26 @@ package body System.Tasking.Protected_Objects is\n    begin\n       --  We are exiting from a protected action, so that we decrease the\n       --  protected object nesting level (if pragma Detect_Blocking is\n-      --  active).\n+      --  active), and remove ownership of the protected object.\n \n       if Detect_Blocking then\n          declare\n             Self_Id : constant Task_Id := Self;\n \n          begin\n-            --  Cannot call this procedure without being within a protected\n-            --  action.\n+            --  Calls to this procedure can only take place when being within\n+            --  a protected action and when the caller is the protected\n+            --  object's owner.\n+\n+            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0\n+                             and then Object.Owner = Self_Id);\n+\n+            --  Remove ownership of the protected object\n+\n+            Object.Owner := Null_Task;\n \n-            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0);\n+            --  We are exiting from a protected action, so we decrease the\n+            --  protected object nesting level.\n \n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting - 1;"}, {"sha": "c28fa60ddd0d806a3cc5a2509b57dc0a7b22045e", "filename": "gcc/ada/s-taprob.ads", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-taprob.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-taprob.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprob.ads?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -206,13 +206,24 @@ package System.Tasking.Protected_Objects is\n \n private\n    type Protection is record\n-      L       : aliased Task_Primitives.Lock;\n+      L : aliased Task_Primitives.Lock;\n+      --  Lock used to ensure mutual exclusive access to the protected object\n+\n       Ceiling : System.Any_Priority;\n+      --  Ceiling priority associated to the protected object\n+\n+      Owner : Task_Id;\n+      --  This field contains the protected object's owner. Null_Task\n+      --  indicates that the protected object is not currently being used.\n+      --  This information is used for detecting the type of potentially\n+      --  blocking operations described in the ARM 9.5.1, par. 15 (external\n+      --  calls on a protected subprogram with the same target object as that\n+      --  of the protected action).\n    end record;\n \n    procedure Finalize_Protection (Object : in out Protection);\n-   --  Clean up a Protection object; in particular, finalize the associated\n-   --  Lock object. The compiler generates automatically calls to this\n+   --  Clean up a Protection object (in particular, finalize the associated\n+   --  Lock object). The compiler generates calls automatically to this\n    --  procedure\n \n end System.Tasking.Protected_Objects;"}, {"sha": "aba5666e5d7a4b5e501afe90e78902ec4216cef9", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 78, "deletions": 43, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -206,6 +206,7 @@ package body System.Tasking.Protected_Objects.Entries is\n       Initialize_Lock (Init_Priority, Object.L'Access);\n       Initialization.Undefer_Abort (Self_ID);\n       Object.Ceiling := System.Any_Priority (Init_Priority);\n+      Object.Owner := Null_Task;\n       Object.Compiler_Info := Compiler_Info;\n       Object.Pending_Action := False;\n       Object.Call_In_Progress := null;\n@@ -231,26 +232,15 @@ package body System.Tasking.Protected_Objects.Entries is\n            (Program_Error'Identity, \"Protected Object is finalized\");\n       end if;\n \n-      --  If pragma Detect_Blocking is active then Program_Error must be\n-      --  raised if this potentially blocking operation is called from a\n-      --  protected action, and the protected object nesting level must be\n-      --  increased.\n+      --  If pragma Detect_Blocking is active then, as described in the ARM\n+      --  9.5.1, par. 15, we must check whether this is an external call on a\n+      --  protected subprogram with the same target object as that of the\n+      --  protected action that is currently in progress (i.e., if the caller\n+      --  is already the protected object's owner). If this is the case hence\n+      --  Program_Error must be raised.\n \n-      if Detect_Blocking then\n-         declare\n-            Self_Id : constant Task_Id := STPO.Self;\n-         begin\n-            if Self_Id.Common.Protected_Action_Nesting > 0  then\n-               Ada.Exceptions.Raise_Exception\n-                 (Program_Error'Identity, \"potentially blocking operation\");\n-            else\n-               --  We are entering in a protected action, so that we increase\n-               --  the protected object nesting level.\n-\n-               Self_Id.Common.Protected_Action_Nesting :=\n-                 Self_Id.Common.Protected_Action_Nesting + 1;\n-            end if;\n-         end;\n+      if Detect_Blocking and then Object.Owner = Self then\n+         raise Program_Error;\n       end if;\n \n       --  The lock is made without defering abort\n@@ -265,6 +255,27 @@ package body System.Tasking.Protected_Objects.Entries is\n \n       pragma Assert (STPO.Self.Deferral_Level > 0);\n       Write_Lock (Object.L'Access, Ceiling_Violation);\n+\n+      --  We are entering in a protected action, so that we increase the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active), and update the protected object's owner.\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+\n+         begin\n+            --  Update the protected object's owner\n+\n+            Object.Owner := Self_Id;\n+\n+            --  Increase protected object nesting level\n+\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting + 1;\n+         end;\n+      end if;\n+\n    end Lock_Entries;\n \n    procedure Lock_Entries (Object : Protection_Entries_Access) is\n@@ -291,33 +302,50 @@ package body System.Tasking.Protected_Objects.Entries is\n            (Program_Error'Identity, \"Protected Object is finalized\");\n       end if;\n \n-      --  If pragma Detect_Blocking is active then Program_Error must be\n-      --  raised if this potentially blocking operation is called from a\n-      --  protected action, and the protected object nesting level must\n-      --  be increased.\n-\n-      if Detect_Blocking then\n-         declare\n-            Self_Id : constant Task_Id := STPO.Self;\n-         begin\n-            if Self_Id.Common.Protected_Action_Nesting > 0  then\n-               Ada.Exceptions.Raise_Exception\n-                 (Program_Error'Identity, \"potentially blocking operation\");\n-            else\n-               --  We are entering in a protected action, so that we increase\n-               --  the protected object nesting level.\n-\n-               Self_Id.Common.Protected_Action_Nesting :=\n-                 Self_Id.Common.Protected_Action_Nesting + 1;\n-            end if;\n-         end;\n+      --  If pragma Detect_Blocking is active then, as described in the ARM\n+      --  9.5.1, par. 15, we must check whether this is an external call on a\n+      --  protected subprogram with the same target object as that of the\n+      --  protected action that is currently in progress (i.e., if the caller\n+      --  is already the protected object's owner). If this is the case hence\n+      --  Program_Error must be raised.\n+\n+      --  Note that in this case (getting read access), several tasks may\n+      --  have read ownership of the protected object, so that this method of\n+      --  storing the (single) protected object's owner does not work\n+      --  reliably for read locks. However, this is the approach taken for two\n+      --  major reasosn: first, this function is not currently being used (it\n+      --  is provided for possible future use), and second, it largely\n+      --  simplifies the implementation.\n+\n+      if Detect_Blocking and then Object.Owner = Self then\n+         raise Program_Error;\n       end if;\n \n       Read_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n          Raise_Exception (Program_Error'Identity, \"Ceiling Violation\");\n       end if;\n+\n+      --  We are entering in a protected action, so that we increase the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active), and update the protected object's owner.\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+\n+         begin\n+            --  Update the protected object's owner\n+\n+            Object.Owner := Self_Id;\n+\n+            --  Increase protected object nesting level\n+\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting + 1;\n+         end;\n+      end if;\n    end Lock_Read_Only_Entries;\n \n    --------------------\n@@ -328,16 +356,23 @@ package body System.Tasking.Protected_Objects.Entries is\n    begin\n       --  We are exiting from a protected action, so that we decrease the\n       --  protected object nesting level (if pragma Detect_Blocking is\n-      --  active).\n+      --  active), and remove ownership of the protected object.\n \n       if Detect_Blocking then\n          declare\n             Self_Id : constant Task_Id := Self;\n+\n          begin\n-            --  Cannot call this procedure without being within a protected\n-            --  action.\n+            --  Calls to this procedure can only take place when being within\n+            --  a protected action and when the caller is the protected\n+            --  object's owner.\n+\n+            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0\n+                             and then Object.Owner = Self_Id);\n+\n+            --  Remove ownership of the protected object\n \n-            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0);\n+            Object.Owner := Null_Task;\n \n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting - 1;"}, {"sha": "027b9c9709e57cc28ffbb192a36878d59710b591", "filename": "gcc/ada/s-tpoben.ads", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tpoben.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tpoben.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.ads?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -83,31 +83,49 @@ package System.Tasking.Protected_Objects.Entries is\n       --  Note that you should never (un)lock Object.L directly, but instead\n       --  use Lock_Entries/Unlock_Entries.\n \n-      Compiler_Info     : System.Address;\n-      Call_In_Progress  : Entry_Call_Link;\n-      Ceiling           : System.Any_Priority;\n+      Compiler_Info : System.Address;\n+      --  Pointer to compiler-generated record representing protected object\n+\n+      Call_In_Progress : Entry_Call_Link;\n+      --  Pointer to the entry call being executed (if any)\n+\n+      Ceiling : System.Any_Priority;\n+      --  Ceiling priority associated with the protected object\n+\n+      Owner : Task_Id;\n+      --  This field contains the protected object's owner. Null_Task\n+      --  indicates that the protected object is not currently being used.\n+      --  This information is used for detecting the type of potentially\n+      --  blocking operations described in the ARM 9.5.1, par. 15 (external\n+      --  calls on a protected subprogram with the same target object as that\n+      --  of the protected action).\n+\n       Old_Base_Priority : System.Any_Priority;\n-      Pending_Action    : Boolean;\n-      --  Flag indicating that priority has been dipped temporarily\n-      --  in order to avoid violating the priority ceiling of the lock\n-      --  associated with this protected object, in Lock_Server.\n-      --  The flag tells Unlock_Server or Unlock_And_Update_Server to\n-      --  restore the old priority to Old_Base_Priority. This is needed\n-      --  because of situations (bad language design?) where one\n-      --  needs to lock a PO but to do so would violate the priority\n-      --  ceiling.  For example, this can happen when an entry call\n-      --  has been requeued to a lower-priority object, and the caller\n-      --  then tries to cancel the call while its own priority is higher\n-      --  than the ceiling of the new PO.\n-      Finalized         : Boolean := False;\n-      --  Set to True by Finalize to make this routine idempotent.\n-\n-      Entry_Bodies      : Protected_Entry_Body_Access;\n+      --  Task's base priority when the protected operation was called\n+\n+      Pending_Action  : Boolean;\n+      --  Flag indicating that priority has been dipped temporarily in order\n+      --  to avoid violating the priority ceiling of the lock associated with\n+      --  this protected object, in Lock_Server. The flag tells Unlock_Server\n+      --  or Unlock_And_Update_Server to restore the old priority to\n+      --  Old_Base_Priority. This is needed because of situations (bad\n+      --  language design?) where one needs to lock a PO but to do so would\n+      --  violate the priority ceiling. For example, this can happen when an\n+      --  entry call has been requeued to a lower-priority object, and the\n+      --  caller then tries to cancel the call while its own priority is\n+      --  higher than the ceiling of the new PO.\n+\n+      Finalized : Boolean := False;\n+      --  Set to True by Finalize to make this routine idempotent\n+\n+      Entry_Bodies : Protected_Entry_Body_Access;\n+      --  Pointer to an array containing the executable code for all entry\n+      --  bodies of a protected type.\n \n       --  The following function maps the entry index in a call (which denotes\n       --  the queue to the proper entry) into the body of the entry.\n \n-      Find_Body_Index   : Find_Body_Index_Access;\n+      Find_Body_Index : Find_Body_Index_Access;\n       Entry_Queues      : Protected_Entry_Queue_Array (1 .. Num_Entries);\n    end record;\n \n@@ -141,36 +159,36 @@ package System.Tasking.Protected_Objects.Entries is\n    --  to keep track of the runtime state of a protected object.\n \n    procedure Lock_Entries (Object : Protection_Entries_Access);\n-   --  Lock a protected object for write access. Upon return, the caller\n-   --  owns the lock to this object, and no other call to Lock or\n-   --  Lock_Read_Only with the same argument will return until the\n-   --  corresponding call to Unlock has been made by the caller.\n-   --  Program_Error is raised in case of ceiling violation.\n+   --  Lock a protected object for write access. Upon return, the caller owns\n+   --  the lock to this object, and no other call to Lock or Lock_Read_Only\n+   --  with the same argument will return until the corresponding call to\n+   --  Unlock has been made by the caller. Program_Error is raised in case of\n+   --  ceiling violation.\n \n    procedure Lock_Entries\n      (Object : Protection_Entries_Access; Ceiling_Violation : out Boolean);\n    --  Same as above, but return the ceiling violation status instead of\n    --  raising Program_Error.\n \n    procedure Lock_Read_Only_Entries (Object : Protection_Entries_Access);\n-   --  Lock a protected object for read access. Upon return, the caller\n-   --  owns the lock for read access, and no other calls to Lock with the\n-   --  same argument will return until the corresponding call to Unlock\n-   --  has been made by the caller. Other calls to Lock_Read_Only may (but\n-   --  need not) return before the call to Unlock, and the corresponding\n-   --  callers will also own the lock for read access.\n+   --  Lock a protected object for read access. Upon return, the caller owns\n+   --  the lock for read access, and no other calls to Lock with the same\n+   --  argument will return until the corresponding call to Unlock has been\n+   --  made by the caller. Other calls to Lock_Read_Only may (but need not)\n+   --  return before the call to Unlock, and the corresponding callers will\n+   --  also own the lock for read access.\n    --\n-   --  Note: we are not currently using this interface, it is provided\n-   --  for possible future use. At the current time, everyone uses Lock\n-   --  for both read and write locks.\n+   --  Note: we are not currently using this interface, it is provided for\n+   --  possible future use. At the current time, everyone uses Lock for both\n+   --  read and write locks.\n \n    procedure Unlock_Entries (Object : Protection_Entries_Access);\n-   --  Relinquish ownership of the lock for the object represented by\n-   --  the Object parameter. If this ownership was for write access, or\n-   --  if it was for read access where there are no other read access\n-   --  locks outstanding, one (or more, in the case of Lock_Read_Only)\n-   --  of the tasks waiting on this lock (if any) will be given the\n-   --  lock and allowed to return from the Lock or Lock_Read_Only call.\n+   --  Relinquish ownership of the lock for the object represented by the\n+   --  Object parameter. If this ownership was for write access, or if it was\n+   --  for read access where there are no other read access locks outstanding,\n+   --  one (or more, in the case of Lock_Read_Only) of the tasks waiting on\n+   --  this lock (if any) will be given the lock and allowed to return from\n+   --  the Lock or Lock_Read_Only call.\n \n private\n "}, {"sha": "3ab51b542c8254bab1f7759da34236c3ea0b1f13", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -537,6 +537,17 @@ package body System.Tasking.Protected_Objects.Operations is\n            (Storage_Error'Identity, \"not enough ATC nesting levels\");\n       end if;\n \n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if Detect_Blocking\n+        and then Self_ID.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       Initialization.Defer_Abort (Self_ID);\n       Lock_Entries (Object, Ceiling_Violation);\n \n@@ -889,6 +900,17 @@ package body System.Tasking.Protected_Objects.Operations is\n            \"not enough ATC nesting levels\");\n       end if;\n \n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       if Runtime_Traces then\n          Send_Trace_Info (POT_Call, Entry_Index (E), Timeout);\n       end if;"}, {"sha": "ded8d8401b91cd8d0526c56965711e9a6e353cee", "filename": "gcc/ada/s-tposen.adb", "status": "modified", "additions": 81, "deletions": 28, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tposen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tposen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.adb?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -333,6 +333,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n       STPO.Initialize_Lock (Init_Priority, Object.L'Access);\n       Object.Ceiling := System.Any_Priority (Init_Priority);\n+      Object.Owner := Null_Task;\n       Object.Compiler_Info := Compiler_Info;\n       Object.Call_In_Progress := null;\n       Object.Entry_Body := Entry_Body;\n@@ -350,59 +351,100 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Ceiling_Violation : Boolean;\n \n    begin\n-      --  If pragma Detect_Blocking is active then the protected object\n-      --  nesting level must be increased.\n+      --  If pragma Detect_Blocking is active then, as described in the ARM\n+      --  9.5.1, par. 15, we must check whether this is an external call on a\n+      --  protected subprogram with the same target object as that of the\n+      --  protected action that is currently in progress (i.e., if the caller\n+      --  is already the protected object's owner). If this is the case hence\n+      --  Program_Error must be raised.\n+\n+      if Detect_Blocking and then Object.Owner = Self then\n+         raise Program_Error;\n+      end if;\n+\n+      STPO.Write_Lock (Object.L'Access, Ceiling_Violation);\n+\n+      if Ceiling_Violation then\n+         raise Program_Error;\n+      end if;\n+\n+      --  We are entering in a protected action, so that we increase the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active), and update the protected object's owner.\n \n       if Detect_Blocking then\n          declare\n-            Self_Id : constant Task_Id := STPO.Self;\n+            Self_Id : constant Task_Id := Self;\n+\n          begin\n-            --  We are entering in a protected action, so that we\n-            --  increase the protected object nesting level.\n+            --  Update the protected object's owner\n+\n+            Object.Owner := Self_Id;\n+\n+            --  Increase protected object nesting level\n \n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting + 1;\n          end;\n       end if;\n-\n-      STPO.Write_Lock (Object.L'Access, Ceiling_Violation);\n-\n-      if Ceiling_Violation then\n-         raise Program_Error;\n-      end if;\n    end Lock_Entry;\n \n    --------------------------\n    -- Lock_Read_Only_Entry --\n    --------------------------\n \n-   --  Compiler interface only.\n-   --  Do not call this procedure from within the runtime system.\n+   --  Compiler interface only\n+\n+   --  Do not call this procedure from within the runtime system\n \n    procedure Lock_Read_Only_Entry (Object : Protection_Entry_Access) is\n       Ceiling_Violation : Boolean;\n \n    begin\n-      --  If pragma Detect_Blocking is active then the protected object\n-      --  nesting level must be increased.\n+      --  If pragma Detect_Blocking is active then, as described in the ARM\n+      --  9.5.1, par. 15, we must check whether this is an external call on a\n+      --  protected subprogram with the same target object as that of the\n+      --  protected action that is currently in progress (i.e., if the caller\n+      --  is already the protected object's owner). If this is the case hence\n+      --  Program_Error must be raised.\n+\n+      --  Note that in this case (getting read access), several tasks may\n+      --  have read ownership of the protected object, so that this method of\n+      --  storing the (single) protected object's owner does not work\n+      --  reliably for read locks. However, this is the approach taken for two\n+      --  major reasosn: first, this function is not currently being used (it\n+      --  is provided for possible future use), and second, it largely\n+      --  simplifies the implementation.\n+\n+      if Detect_Blocking and then Object.Owner = Self then\n+         raise Program_Error;\n+      end if;\n+\n+      STPO.Read_Lock (Object.L'Access, Ceiling_Violation);\n+\n+      if Ceiling_Violation then\n+         raise Program_Error;\n+      end if;\n+\n+      --  We are entering in a protected action, so that we increase the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active), and update the protected object's owner.\n \n       if Detect_Blocking then\n          declare\n-            Self_Id : constant Task_Id := STPO.Self;\n+            Self_Id : constant Task_Id := Self;\n+\n          begin\n-            --  We are entering in a protected action, so that we\n-            --  increase the protected object nesting level.\n+            --  Update the protected object's owner\n+\n+            Object.Owner := Self_Id;\n+\n+            --  Increase protected object nesting level\n \n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting + 1;\n          end;\n       end if;\n-\n-      STPO.Read_Lock (Object.L'Access, Ceiling_Violation);\n-\n-      if Ceiling_Violation then\n-         raise Program_Error;\n-      end if;\n    end Lock_Read_Only_Entry;\n \n    --------------------\n@@ -415,6 +457,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Entry_Call : Entry_Call_Link)\n    is\n       Barrier_Value : Boolean;\n+\n    begin\n       --  When the Action procedure for an entry body returns, it must be\n       --  completed (having called [Exceptional_]Complete_Entry_Body).\n@@ -423,6 +466,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n       if Barrier_Value then\n          if Object.Call_In_Progress /= null then\n+\n             --  This violates the No_Entry_Queue restriction, send\n             --  Program_Error to the caller.\n \n@@ -692,16 +736,25 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    procedure Unlock_Entry (Object : Protection_Entry_Access) is\n    begin\n       --  We are exiting from a protected action, so that we decrease the\n-      --  protected object nesting level (if pragma Detect_Blocking is active).\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active), and remove ownership of the protected object.\n \n       if Detect_Blocking then\n          declare\n             Self_Id : constant Task_Id := Self;\n \n          begin\n-            --  Cannot call Unlock_Entry without being within protected action\n+            --  Calls to this procedure can only take place when being within\n+            --  a protected action and when the caller is the protected\n+            --  object's owner.\n+\n+            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0\n+                             and then Object.Owner = Self_Id);\n+\n+            --  Remove ownership of the protected object\n+\n+            Object.Owner := Null_Task;\n \n-            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0);\n \n             Self_Id.Common.Protected_Action_Nesting :=\n               Self_Id.Common.Protected_Action_Nesting - 1;"}, {"sha": "8ad0cb43085cc7a119b10af8b0e22ffcb7505f66", "filename": "gcc/ada/s-tposen.ads", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tposen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce65449a3562d260d3153d5345076bab06761df5/gcc%2Fada%2Fs-tposen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.ads?ref=ce65449a3562d260d3153d5345076bab06761df5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -277,12 +277,33 @@ package System.Tasking.Protected_Objects.Single_Entry is\n \n private\n    type Protection_Entry is record\n-      L                 : aliased Task_Primitives.Lock;\n-      Compiler_Info     : System.Address;\n-      Call_In_Progress  : Entry_Call_Link;\n-      Ceiling           : System.Any_Priority;\n-      Entry_Body        : Entry_Body_Access;\n-      Entry_Queue       : Entry_Call_Link;\n+      L : aliased Task_Primitives.Lock;\n+      --  The underlying lock associated with a Protection_Entries. Note that\n+      --  you should never (un)lock Object.L directly, but instead use\n+      --  Lock_Entry/Unlock_Entry.\n+\n+      Compiler_Info : System.Address;\n+      --  Pointer to compiler-generated record representing protected object\n+\n+      Call_In_Progress : Entry_Call_Link;\n+      --  Pointer to the entry call being executed (if any)\n+\n+      Ceiling : System.Any_Priority;\n+      --  Ceiling priority associated to the protected object\n+\n+      Owner : Task_Id;\n+      --  This field contains the protected object's owner. Null_Task\n+      --  indicates that the protected object is not currently being used.\n+      --  This information is used for detecting the type of potentially\n+      --  blocking operations described in the ARM 9.5.1, par. 15 (external\n+      --  calls on a protected subprogram with the same target object as that\n+      --  of the protected action).\n+\n+      Entry_Body : Entry_Body_Access;\n+      --  Pointer to executable code for the entry body of the protected type\n+\n+      Entry_Queue : Entry_Call_Link;\n+      --  Place to store the waiting entry call (if any)\n    end record;\n \n end System.Tasking.Protected_Objects.Single_Entry;"}]}