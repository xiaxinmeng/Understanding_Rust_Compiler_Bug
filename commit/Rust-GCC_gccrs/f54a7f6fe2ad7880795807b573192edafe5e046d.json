{"sha": "f54a7f6fe2ad7880795807b573192edafe5e046d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0YTdmNmZlMmFkNzg4MDc5NTgwN2I1NzMxOTJlZGFmZTVlMDQ2ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-12T18:32:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-12T18:32:36Z"}, "message": "except.h (struct eh_queue): Add `next' pointer.\n\n\t* except.h (struct eh_queue): Add `next' pointer.\n\t(struct eh_status): Make x_ehqueue a pointer.\n\t(push_ehqueue):  Declare.\n\t(pop_ehqueue): Likewise.\n\t* except.c (expand_eh_region_end): Adjust now that ehqueue is a\n\tpointer.\n\t(expand_fixup_region_end): Likewise.\n\t(expand_leftover_cleanups): Likewise.\n\t(push_ehqueue): Define.\n\t(pop_ehqueue): Likewise.\n\t(emit_cleanup_handler): Use push_ehqueue and pop_ehqueue rather\n\tthan doing it inline.\n\t(expand_start_all_catch):  Adjust now that ehqueue is a\n\tpointer.\n\t(mark_eh_queue): Mark all level of the queue.\n\t(mark_eh_status):  Adjust now that ehqueue is a\n\tpointer.\n\t(init_eh_for_function): Allocate ehqueue.\n\t(free_eh_status): Free it.\n\t* stmt.c (expand_cleanups): Save the ehqueue around the cleanup\n\texpansion for a fixup.\n\nFrom-SVN: r30874", "tree": {"sha": "1e31e6a584113226ea69f8fdf57bada3aa50bfe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e31e6a584113226ea69f8fdf57bada3aa50bfe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f54a7f6fe2ad7880795807b573192edafe5e046d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54a7f6fe2ad7880795807b573192edafe5e046d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54a7f6fe2ad7880795807b573192edafe5e046d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54a7f6fe2ad7880795807b573192edafe5e046d/comments", "author": null, "committer": null, "parents": [{"sha": "d0017c11ff277f6e7aad314240da8f32c2d17069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0017c11ff277f6e7aad314240da8f32c2d17069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0017c11ff277f6e7aad314240da8f32c2d17069"}], "stats": {"total": 92, "additions": 76, "deletions": 16}, "files": [{"sha": "315e748681599d2afd404468bef57cff9e609e37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f54a7f6fe2ad7880795807b573192edafe5e046d", "patch": "@@ -1,3 +1,27 @@\n+1999-12-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* except.h (struct eh_queue): Add `next' pointer.\n+\t(struct eh_status): Make x_ehqueue a pointer.\n+\t(push_ehqueue):  Declare.\n+\t(pop_ehqueue): Likewise.\n+\t* except.c (expand_eh_region_end): Adjust now that ehqueue is a\n+\tpointer.\n+\t(expand_fixup_region_end): Likewise.\n+\t(expand_leftover_cleanups): Likewise.\n+\t(push_ehqueue): Define.\n+\t(pop_ehqueue): Likewise.\n+\t(emit_cleanup_handler): Use push_ehqueue and pop_ehqueue rather\n+\tthan doing it inline.\n+\t(expand_start_all_catch):  Adjust now that ehqueue is a\n+\tpointer.\n+\t(mark_eh_queue): Mark all level of the queue.\n+\t(mark_eh_status):  Adjust now that ehqueue is a\n+\tpointer.\n+\t(init_eh_for_function): Allocate ehqueue.\n+\t(free_eh_status): Free it.\n+\t* stmt.c (expand_cleanups): Save the ehqueue around the cleanup\n+\texpansion for a fixup.\n+\n 1999-12-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gthr-single.h (__gthread_active_p): Add prototype arguments."}, {"sha": "4b25b10199e698fb4416bf4aa1a9a867c57a6d35", "filename": "gcc/except.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f54a7f6fe2ad7880795807b573192edafe5e046d", "patch": "@@ -1533,7 +1533,7 @@ expand_eh_region_end (handler)\n   /* create region entry in final exception table */\n   r = new_eh_region_entry (NOTE_EH_HANDLER (note), entry->rethrow_label);\n \n-  enqueue_eh_entry (&ehqueue, entry);\n+  enqueue_eh_entry (ehqueue, entry);\n \n   /* If we have already started ending the bindings, don't recurse.  */\n   if (is_eh_region ())\n@@ -1551,7 +1551,7 @@ expand_eh_region_end (handler)\n \n   /* Go through the goto handlers in the queue, emitting their\n      handlers if we now have enough information to do so.  */\n-  for (node = ehqueue.head; node; node = node->chain)\n+  for (node = ehqueue->head; node; node = node->chain)\n     if (node->entry->goto_entry_p \n \t&& node->entry->outer_context == entry->rethrow_label)\n       emit_cleanup_handler (node->entry);\n@@ -1596,7 +1596,7 @@ expand_fixup_region_end (cleanup)\n   for (node = ehstack.top; node && node->entry->finalization != cleanup; )\n     node = node->chain;\n   if (node == 0)\n-    for (node = ehqueue.head; node && node->entry->finalization != cleanup; )\n+    for (node = ehqueue->head; node && node->entry->finalization != cleanup; )\n       node = node->chain;\n   if (node == 0)\n     abort ();\n@@ -1678,9 +1678,9 @@ expand_leftover_cleanups ()\n {\n   struct eh_entry *entry;\n \n-  for (entry = dequeue_eh_entry (&ehqueue); \n+  for (entry = dequeue_eh_entry (ehqueue); \n        entry;\n-       entry = dequeue_eh_entry (&ehqueue))\n+       entry = dequeue_eh_entry (ehqueue))\n     {\n       /* A leftover try block.  Shouldn't be one here.  */\n       if (entry->finalization == integer_zero_node)\n@@ -1787,6 +1787,29 @@ end_catch_handler ()\n   catchstack.top->entry->false_label = NULL_RTX;\n }\n \n+/* Save away the current ehqueue.  */\n+\n+void \n+push_ehqueue ()\n+{\n+  struct eh_queue *q;\n+  q = xcalloc (1, sizeof (struct eh_queue));\n+  q->next = ehqueue;\n+  ehqueue = q;\n+}\n+\n+/* Restore a previously pushed ehqueue.  */\n+\n+void\n+pop_ehqueue ()\n+{\n+  struct eh_queue *q;\n+  expand_leftover_cleanups ();\n+  q = ehqueue->next;\n+  free (ehqueue);\n+  ehqueue = q;\n+}\n+\n /* Emit the handler specified by ENTRY.  */\n \n static void\n@@ -1795,13 +1818,11 @@ emit_cleanup_handler (entry)\n {\n   rtx prev;\n   rtx handler_insns;\n-  struct eh_queue q;\n \n   /* Since the cleanup could itself contain try-catch blocks, we\n      squirrel away the current queue and replace it when we are done\n      with this function.  */\n-  q = ehqueue;\n-  ehqueue.head = ehqueue.tail = NULL;\n+  push_ehqueue ();\n \n   /* Put these handler instructions in a sequence.  */\n   do_pending_stack_adjust ();\n@@ -1844,8 +1865,7 @@ emit_cleanup_handler (entry)\n   end_sequence ();\n \n   /* Now we've left the handler.  */\n-  expand_leftover_cleanups ();\n-  ehqueue = q;\n+  pop_ehqueue ();\n }\n \n /* Generate RTL for the start of a group of catch clauses. \n@@ -1889,9 +1909,9 @@ expand_start_all_catch ()\n   /* Throw away entries in the queue that we won't need anymore.  We\n      need entries for regions that have ended but to which there might\n      still be gotos pending.  */\n-  for (entry = dequeue_eh_entry (&ehqueue); \n+  for (entry = dequeue_eh_entry (ehqueue); \n        entry->finalization != integer_zero_node;\n-       entry = dequeue_eh_entry (&ehqueue))\n+       entry = dequeue_eh_entry (ehqueue))\n     free (entry);\n \n   /* At this point, all the cleanups are done, and the ehqueue now has\n@@ -2477,8 +2497,11 @@ static void\n mark_eh_queue (q)\n      struct eh_queue *q;\n {\n-  if (q)\n-    mark_eh_node (q->head);\n+  while (q)\n+    {\n+      mark_eh_node (q->head);\n+      q = q->next;\n+    }\n }\n \n /* Mark NODE for GC.  A label_node contains a union containing either\n@@ -2506,7 +2529,7 @@ mark_eh_status (eh)\n \n   mark_eh_stack (&eh->x_ehstack);\n   mark_eh_stack (&eh->x_catchstack);\n-  mark_eh_queue (&eh->x_ehqueue);\n+  mark_eh_queue (eh->x_ehqueue);\n   ggc_mark_rtx (eh->x_catch_clauses);\n \n   lang_mark_false_label_stack (eh->x_false_label_stack);\n@@ -2577,6 +2600,7 @@ init_eh_for_function ()\n {\n   current_function->eh\n     = (struct eh_status *) xcalloc (1, sizeof (struct eh_status));\n+  ehqueue = (struct eh_queue *) xcalloc (1, sizeof (struct eh_queue));\n   eh_return_context = NULL_RTX;\n   eh_return_stack_adjust = NULL_RTX;\n   eh_return_handler = NULL_RTX;\n@@ -2586,6 +2610,7 @@ void\n free_eh_status (f)\n      struct function *f;\n {\n+  free (f->eh->x_ehqueue);\n   free (f->eh);\n   f->eh = NULL;\n }"}, {"sha": "befbccc94e6d8f98a855f0d1bb36fc9d0bcc2bb5", "filename": "gcc/except.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=f54a7f6fe2ad7880795807b573192edafe5e046d", "patch": "@@ -93,6 +93,7 @@ struct eh_stack {\n struct eh_queue {\n   struct eh_node *head;\n   struct eh_node *tail;\n+  struct eh_queue *next;\n };\n \n /* Used to save exception handling status for each function.  */\n@@ -115,7 +116,7 @@ struct eh_status\n      As we exit a region, we enqueue a new entry. The entries are then\n      dequeued during expand_leftover_cleanups and\n      expand_start_all_catch.  */\n-  struct eh_queue x_ehqueue;\n+  struct eh_queue *x_ehqueue;\n   /* Insns for all of the exception handlers for the current function.\n      They are currently emitted by the frontend code.  */\n   rtx x_catch_clauses;\n@@ -443,6 +444,12 @@ extern rtx get_dynamic_cleanup_chain\t\tPROTO((void));\n \n extern void emit_throw\t\t\t\tPROTO((void));\n \n+/* Save away the current ehqueue.  */\n+extern void push_ehqueue                        PROTO((void));\n+\n+/* Restore a previously pushed ehqueue.  */\n+extern void pop_ehqueue                         PROTO((void));\n+\n /* One to use setjmp/longjmp method of generating code.  */\n \n extern int exceptions_via_longjmp;"}, {"sha": "8256646bab2af3424502d2fa9208982444136911", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54a7f6fe2ad7880795807b573192edafe5e046d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f54a7f6fe2ad7880795807b573192edafe5e046d", "patch": "@@ -4270,7 +4270,11 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n \t\tif (protect)\n \t\t  expand_fixup_region_start ();\n \n+\t\t/* The cleanup might contain try-blocks, so we have to\n+\t\t   preserve our current queue.  */\n+\t\tpush_ehqueue ();\n \t\texpand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n+\t\tpop_ehqueue ();\n \t\tif (protect)\n \t\t  expand_fixup_region_end (TREE_VALUE (tail));\n \t\tfree_temp_slots ();"}]}