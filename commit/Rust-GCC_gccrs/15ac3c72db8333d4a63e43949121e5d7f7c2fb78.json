{"sha": "15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVhYzNjNzJkYjgzMzNkNGE2M2U0Mzk0OTEyMWU1ZDdmN2MyZmI3OA==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2009-09-17T08:42:39Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2009-09-17T08:42:39Z"}, "message": "algobase.h: Replace tabs by spaces; correct line breaks.\n\n2009-09-17  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/algobase.h: Replace tabs by spaces;\n        correct line breaks.\n        * include/parallel/algorithmfwd.h: Likewise.\n        * include/parallel/balanced_quicksort.h: Likewise.\n        * include/parallel/base.h: Likewise.\n        * include/parallel/checkers.h: Likewise.\n        * include/parallel/compatibility.h: Likewise.\n        * include/parallel/equally_split.h: Likewise.\n        * include/parallel/find.h: Likewise.\n        * include/parallel/for_each.h: Likewise.\n        * include/parallel/for_each_selectors.h: Likewise.\n        * include/parallel/iterator.h: Likewise.\n        * include/parallel/list_partition.h: Likewise.\n        * include/parallel/losertree.h: Likewise.\n        * include/parallel/merge.h: Likewise.\n        * include/parallel/multiseq_selection.h: Likewise.\n        * include/parallel/multiway_merge.h: Likewise.\n        * include/parallel/multiway_mergesort.h: Likewise.\n        * include/parallel/numeric: Likewise.\n        * include/parallel/numericfwd.h: Likewise.\n        * include/parallel/omp_loop.h: Likewise.\n        * include/parallel/omp_loop_static.h: Likewise.\n        * include/parallel/par_loop.h: Likewise.\n        * include/parallel/partial_sum.h: Likewise.\n        * include/parallel/partition.h: Likewise.\n        * include/parallel/queue.h: Likewise.\n        * include/parallel/quicksort.h: Likewise.\n        * include/parallel/random_number.h: Likewise.\n        * include/parallel/random_shuffle.h: Likewise.\n        * include/parallel/search.h: Likewise.\n        * include/parallel/set_operations.h: Likewise.\n        * include/parallel/settings.h: Likewise.\n        * include/parallel/sort.h: Likewise.\n        * include/parallel/types.h: Likewise.\n        * include/parallel/unique_copy.h: Likewise.\n        * include/parallel/workstealing.h: Likewise.\n        * include/parallel/algo.h: Likewise;\n        shorten _ForwardIterator to _FIterator.\n        * include/parallel/find_selectors.h: Likewise.\n\nFrom-SVN: r151791", "tree": {"sha": "11ed989c17b3740ffef24792c7397b0fbce1f891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11ed989c17b3740ffef24792c7397b0fbce1f891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/comments", "author": null, "committer": null, "parents": [{"sha": "10e154dfd7e4e61f1205a364d07ec0789c85bfd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e154dfd7e4e61f1205a364d07ec0789c85bfd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e154dfd7e4e61f1205a364d07ec0789c85bfd3"}], "stats": {"total": 4470, "additions": 2351, "deletions": 2119}, "files": [{"sha": "37de63fba142274ec676294830c2bdd66aceb139", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -1,3 +1,45 @@\n+2009-09-17  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/algobase.h: Replace tabs by spaces;\n+        correct line breaks.\n+        * include/parallel/algorithmfwd.h: Likewise.\n+        * include/parallel/balanced_quicksort.h: Likewise.\n+        * include/parallel/base.h: Likewise.\n+        * include/parallel/checkers.h: Likewise.\n+        * include/parallel/compatibility.h: Likewise.\n+        * include/parallel/equally_split.h: Likewise.\n+        * include/parallel/find.h: Likewise.\n+        * include/parallel/for_each.h: Likewise.\n+        * include/parallel/for_each_selectors.h: Likewise.\n+        * include/parallel/iterator.h: Likewise.\n+        * include/parallel/list_partition.h: Likewise.\n+        * include/parallel/losertree.h: Likewise.\n+        * include/parallel/merge.h: Likewise.\n+        * include/parallel/multiseq_selection.h: Likewise.\n+        * include/parallel/multiway_merge.h: Likewise.\n+        * include/parallel/multiway_mergesort.h: Likewise.\n+        * include/parallel/numeric: Likewise.\n+        * include/parallel/numericfwd.h: Likewise.\n+        * include/parallel/omp_loop.h: Likewise.\n+        * include/parallel/omp_loop_static.h: Likewise.\n+        * include/parallel/par_loop.h: Likewise.\n+        * include/parallel/partial_sum.h: Likewise.\n+        * include/parallel/partition.h: Likewise.\n+        * include/parallel/queue.h: Likewise.\n+        * include/parallel/quicksort.h: Likewise.\n+        * include/parallel/random_number.h: Likewise.\n+        * include/parallel/random_shuffle.h: Likewise.\n+        * include/parallel/search.h: Likewise.\n+        * include/parallel/set_operations.h: Likewise.\n+        * include/parallel/settings.h: Likewise.\n+        * include/parallel/sort.h: Likewise.\n+        * include/parallel/types.h: Likewise.\n+        * include/parallel/unique_copy.h: Likewise.\n+        * include/parallel/workstealing.h: Likewise.\n+        * include/parallel/algo.h: Likewise;\n+        shorten _ForwardIterator to _FIterator.\n+        * include/parallel/find_selectors.h: Likewise.\n+\n 2009-09-16  Johannes Singler  <singler@ira.uka.de>\n \n         * include/parallel/base.h: Correct some comments accidentally changed"}, {"sha": "1a75d24b91764b95c3f55680fc377dad60d3c3dc", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 406, "deletions": 421, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -94,9 +94,10 @@ namespace __parallel\n     __gnu_parallel::__for_each_selector<_RAIter> __functionality;\n \n           return __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end, __f, __functionality,\n-                                            __gnu_parallel::_DummyReduct(),\n-                                            true, __dummy, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __f, __functionality,\n+              __gnu_parallel::_DummyReduct(), true, __dummy, -1,\n+              __parallelism_tag);\n         }\n       else\n         return for_each(__begin, __end, __f, __gnu_parallel::sequential_tag());\n@@ -151,9 +152,9 @@ namespace __parallel\n         {\n           binder2nd<__gnu_parallel::equal_to<_ValueType, const _Tp&> >\n             __comp(__gnu_parallel::equal_to<_ValueType, const _Tp&>(), __val);\n-          return __gnu_parallel::__find_template(__begin, __end, __begin, __comp,\n-                                               __gnu_parallel::\n-                                               __find_if_selector()).first;\n+          return __gnu_parallel::__find_template(\n+                   __begin, __end, __begin, __comp,\n+                   __gnu_parallel::__find_if_selector()).first;\n         }\n       else\n         return _GLIBCXX_STD_P::find(__begin, __end, __val);\n@@ -190,7 +191,7 @@ namespace __parallel\n                    _Predicate __pred, random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n-        return __gnu_parallel::__find_template(__begin, __end, __begin, __pred, \n+        return __gnu_parallel::__find_template(__begin, __end, __begin, __pred,\n                                              __gnu_parallel::\n                                              __find_if_selector()).first;\n       else\n@@ -208,69 +209,71 @@ namespace __parallel\n     }\n \n   // Sequential fallback\n-  template<typename _IIter, typename _ForwardIterator>\n+  template<typename _IIter, typename _FIterator>\n     inline _IIter\n     find_first_of(_IIter __begin1, _IIter __end1, \n-                  _ForwardIterator __begin2, _ForwardIterator __end2, \n+                  _FIterator __begin2, _FIterator __end2, \n                   __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::find_first_of(__begin1, __end1, __begin2, __end2); }\n+    { return _GLIBCXX_STD_P::find_first_of(__begin1, __end1, __begin2, __end2);\n+      }\n \n   // Sequential fallback\n-  template<typename _IIter, typename _ForwardIterator,\n+  template<typename _IIter, typename _FIterator,\n            typename _BinaryPredicate>\n     inline _IIter\n     find_first_of(_IIter __begin1, _IIter __end1,\n-                  _ForwardIterator __begin2, _ForwardIterator __end2,\n+                  _FIterator __begin2, _FIterator __end2,\n                   _BinaryPredicate __comp, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::find_first_of(__begin1, __end1, __begin2, __end2, __comp); }\n+  { return _GLIBCXX_STD_P::find_first_of(\n+             __begin1, __end1, __begin2, __end2, __comp); }\n \n   // Sequential fallback for input iterator type\n-  template<typename _IIter, typename _ForwardIterator,\n+  template<typename _IIter, typename _FIterator,\n            typename _IteratorTag1, typename _IteratorTag2>\n     inline _IIter\n     __find_first_of_switch(_IIter __begin1, _IIter __end1,\n-                         _ForwardIterator __begin2, _ForwardIterator __end2, \n+                         _FIterator __begin2, _FIterator __end2, \n                          _IteratorTag1, _IteratorTag2)\n     { return find_first_of(__begin1, __end1, __begin2, __end2, \n                            __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators\n-  template<typename _RAIter, typename _ForwardIterator,\n+  template<typename _RAIter, typename _FIterator,\n            typename _BinaryPredicate, typename _IteratorTag>\n     inline _RAIter\n     __find_first_of_switch(_RAIter __begin1,\n                          _RAIter __end1,\n-                         _ForwardIterator __begin2, _ForwardIterator __end2, \n+                         _FIterator __begin2, _FIterator __end2, \n                          _BinaryPredicate __comp, random_access_iterator_tag, \n                          _IteratorTag)\n     {\n       return __gnu_parallel::\n         __find_template(__begin1, __end1, __begin1, __comp,\n                       __gnu_parallel::__find_first_of_selector\n-                      <_ForwardIterator>(__begin2, __end2)).first;\n+                      <_FIterator>(__begin2, __end2)).first;\n     }\n \n   // Sequential fallback for input iterator type\n-  template<typename _IIter, typename _ForwardIterator,\n+  template<typename _IIter, typename _FIterator,\n            typename _BinaryPredicate, typename _IteratorTag1,\n            typename _IteratorTag2>\n     inline _IIter\n     __find_first_of_switch(_IIter __begin1, _IIter __end1,\n-                         _ForwardIterator __begin2, _ForwardIterator __end2, \n+                         _FIterator __begin2, _FIterator __end2, \n                          _BinaryPredicate __comp, _IteratorTag1, _IteratorTag2)\n     { return find_first_of(__begin1, __end1, __begin2, __end2, __comp, \n                            __gnu_parallel::sequential_tag()); }\n \n   // Public interface\n-  template<typename _IIter, typename _ForwardIterator,\n+  template<typename _IIter, typename _FIterator,\n            typename _BinaryPredicate>\n     inline _IIter\n     find_first_of(_IIter __begin1, _IIter __end1,\n-                  _ForwardIterator __begin2, _ForwardIterator __end2, \n+                  _FIterator __begin2, _FIterator __end2, \n                   _BinaryPredicate __comp)\n     {\n       typedef std::iterator_traits<_IIter> _IIterTraits;\n-      typedef std::iterator_traits<_ForwardIterator> iteratorf_traits;\n+      typedef std::iterator_traits<_FIterator> iteratorf_traits;\n       typedef typename _IIterTraits::iterator_category _IIteratorCategory;\n       typedef typename iteratorf_traits::iterator_category iteratorf_category;\n \n@@ -279,13 +282,13 @@ namespace __parallel\n     }\n \n   // Public interface, insert default comparator\n-  template<typename _IIter, typename _ForwardIterator>\n+  template<typename _IIter, typename _FIterator>\n     inline _IIter\n     find_first_of(_IIter __begin1, _IIter __end1, \n-                  _ForwardIterator __begin2, _ForwardIterator __end2)\n+                  _FIterator __begin2, _FIterator __end2)\n     {\n       typedef std::iterator_traits<_IIter> _IIterTraits;\n-      typedef std::iterator_traits<_ForwardIterator> iteratorf_traits;\n+      typedef std::iterator_traits<_FIterator> iteratorf_traits;\n       typedef typename _IIterTraits::value_type _IValueType;\n       typedef typename iteratorf_traits::value_type _FValueType;\n \n@@ -328,7 +331,8 @@ namespace __parallel\n       if (_GLIBCXX_PARALLEL_CONDITION(\n             static_cast<__gnu_parallel::_SequenceIndex>(__last - __begin)\n             > __gnu_parallel::_Settings::get().unique_copy_minimal_n))\n-        return __gnu_parallel::__parallel_unique_copy(__begin, __last, __out, __pred);\n+        return __gnu_parallel::__parallel_unique_copy(\n+                 __begin, __last, __out, __pred);\n       else\n         return _GLIBCXX_STD_P::unique_copy(__begin, __last, __out, __pred);\n     }\n@@ -344,8 +348,9 @@ namespace __parallel\n       typedef typename _IIterTraits::value_type _ValueType;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __unique_copy_switch(__begin1, __end1, __out, equal_to<_ValueType>(),\n-                                _IIteratorCategory(), _OIterCategory());\n+      return __unique_copy_switch(\n+               __begin1, __end1, __out, equal_to<_ValueType>(),\n+               _IIteratorCategory(), _OIterCategory());\n     }\n \n   // Public interface\n@@ -359,8 +364,9 @@ namespace __parallel\n       typedef typename _IIterTraits::iterator_category _IIteratorCategory;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __unique_copy_switch(__begin1, __end1, __out, __pred, _IIteratorCategory(), \n-                                _OIterCategory());\n+      return __unique_copy_switch(\n+               __begin1, __end1, __out, __pred,\n+               _IIteratorCategory(), _OIterCategory());\n     }\n \n   // Sequential fallback\n@@ -370,7 +376,8 @@ namespace __parallel\n     set_union(_IIter1 __begin1, _IIter1 __end1,\n               _IIter2 __begin2, _IIter2 __end2,\n               _OutputIterator __out, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::set_union(__begin1, __end1, __begin2, __end2, __out); }\n+    { return _GLIBCXX_STD_P::set_union(\n+               __begin1, __end1, __begin2, __end2, __out); }\n \n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2,\n@@ -384,14 +391,14 @@ namespace __parallel\n                                        __begin2, __end2, __out, __pred); }\n \n   // Sequential fallback for input iterator case\n-  template<typename _IIter1, typename _IIter2,\n-           typename _Predicate, typename _OutputIterator,\n-           typename _IteratorTag1, typename _IteratorTag2, typename _IteratorTag3>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+           typename _OutputIterator, typename _IteratorTag1,\n+           typename _IteratorTag2, typename _IteratorTag3>\n     inline _OutputIterator\n-    __set_union_switch(_IIter1 __begin1, _IIter1 __end1, \n-                     _IIter2 __begin2, _IIter2 __end2, \n-                     _OutputIterator __result, _Predicate __pred, _IteratorTag1,\n-                     _IteratorTag2, _IteratorTag3)\n+    __set_union_switch(\n+      _IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, _IIter2 __end2,\n+      _OutputIterator __result, _Predicate __pred,\n+      _IteratorTag1, _IteratorTag2, _IteratorTag3)\n     { return _GLIBCXX_STD_P::set_union(__begin1, __end1,\n                                        __begin2, __end2, __result, __pred); }\n \n@@ -410,8 +417,8 @@ namespace __parallel\n             >= __gnu_parallel::_Settings::get().set_union_minimal_n\n             || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)\n             >= __gnu_parallel::_Settings::get().set_union_minimal_n))\n-        return __gnu_parallel::__parallel_set_union(__begin1, __end1,\n-                                                  __begin2, __end2, __result, __pred);\n+        return __gnu_parallel::__parallel_set_union(\n+                 __begin1, __end1, __begin2, __end2, __result, __pred);\n       else\n         return _GLIBCXX_STD_P::set_union(__begin1, __end1,\n                                          __begin2, __end2, __result, __pred);\n@@ -435,10 +442,10 @@ namespace __parallel\n       typedef typename _IIterTraits1::value_type _ValueType1;\n       typedef typename _IIterTraits2::value_type _ValueType2;\n \n-      return __set_union_switch(__begin1, __end1, __begin2, __end2, __out, \n-                              __gnu_parallel::_Less<_ValueType1, _ValueType2>(),\n-                              _IIterCategory1(), _IIterCategory2(),\n-                              _OIterCategory());\n+      return __set_union_switch(\n+               __begin1, __end1, __begin2, __end2, __out,\n+               __gnu_parallel::_Less<_ValueType1, _ValueType2>(),\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Public interface\n@@ -458,9 +465,9 @@ namespace __parallel\n         _IIterCategory2;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __set_union_switch(__begin1, __end1, __begin2, __end2, __out, __pred,\n-                              _IIterCategory1(), _IIterCategory2(),\n-                              _OIterCategory());\n+      return __set_union_switch(\n+               __begin1, __end1, __begin2, __end2, __out, __pred,\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Sequential fallback.\n@@ -481,20 +488,20 @@ namespace __parallel\n                      _IIter2 __begin2, _IIter2 __end2,\n                      _OutputIterator __out, _Predicate __pred, \n                      __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::set_intersection(__begin1, __end1, __begin2, __end2, \n-                                              __out, __pred); }\n+    { return _GLIBCXX_STD_P::set_intersection(\n+               __begin1, __end1, __begin2, __end2, __out, __pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename _IIter1, typename _IIter2,\n            typename _Predicate, typename _OutputIterator,\n            typename _IteratorTag1, typename _IteratorTag2,\n            typename _IteratorTag3>\n     inline _OutputIterator \n-    __set_intersection_switch(_IIter1 __begin1, _IIter1 __end1, \n-                            _IIter2 __begin2, _IIter2 __end2, \n-                            _OutputIterator __result, _Predicate __pred, \n-                            _IteratorTag1, _IteratorTag2, _IteratorTag3)\n-    { return _GLIBCXX_STD_P::set_intersection(__begin1, __end1, __begin2, \n+    __set_intersection_switch(_IIter1 __begin1, _IIter1 __end1,\n+                              _IIter2 __begin2, _IIter2 __end2,\n+                              _OutputIterator __result, _Predicate __pred,\n+                              _IteratorTag1, _IteratorTag2, _IteratorTag3)\n+    { return _GLIBCXX_STD_P::set_intersection(__begin1, __end1, __begin2,\n                                               __end2, __result, __pred); }\n \n   // Parallel set_intersection for random access iterators\n@@ -516,11 +523,11 @@ namespace __parallel\n             >= __gnu_parallel::_Settings::get().set_union_minimal_n\n             || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)\n             >= __gnu_parallel::_Settings::get().set_union_minimal_n))\n-        return __gnu_parallel::__parallel_set_intersection(__begin1, __end1, __begin2, \n-                                                         __end2, __result, __pred);\n+        return __gnu_parallel::__parallel_set_intersection(\n+                 __begin1, __end1, __begin2, __end2, __result, __pred);\n       else\n-        return _GLIBCXX_STD_P::set_intersection(__begin1, __end1, __begin2, \n-                                                __end2, __result, __pred);\n+        return _GLIBCXX_STD_P::set_intersection(\n+                 __begin1, __end1, __begin2, __end2, __result, __pred);\n     }\n \n   // Public interface\n@@ -542,12 +549,10 @@ namespace __parallel\n       typedef typename _IIterTraits1::value_type _ValueType1;\n       typedef typename _IIterTraits2::value_type _ValueType2;\n \n-      return __set_intersection_switch(__begin1, __end1, __begin2, __end2, __out,\n-                                     __gnu_parallel::\n-                                     _Less<_ValueType1, _ValueType2>(),\n-                                     _IIterCategory1(),\n-                                     _IIterCategory2(), \n-                                     _OIterCategory());\n+      return __set_intersection_switch(\n+               __begin1, __end1, __begin2, __end2, __out,\n+               __gnu_parallel::_Less<_ValueType1, _ValueType2>(),\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   template<typename _IIter1, typename _IIter2,\n@@ -566,10 +571,9 @@ namespace __parallel\n         _IIterCategory2;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __set_intersection_switch(__begin1, __end1, __begin2, __end2, __out, __pred,\n-                                     _IIterCategory1(),\n-                                     _IIterCategory2(),\n-                                     _OIterCategory());\n+      return __set_intersection_switch(\n+               __begin1, __end1, __begin2, __end2, __out, __pred,\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Sequential fallback\n@@ -580,8 +584,8 @@ namespace __parallel\n                              _IIter2 __begin2, _IIter2 __end2,\n                              _OutputIterator __out,\n                              __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::set_symmetric_difference(__begin1,__end1,\n-                                                      __begin2, __end2, __out); }\n+    { return _GLIBCXX_STD_P::set_symmetric_difference(\n+               __begin1, __end1, __begin2, __end2, __out); }\n \n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2,\n@@ -591,24 +595,21 @@ namespace __parallel\n                              _IIter2 __begin2, _IIter2 __end2,\n                              _OutputIterator __out, _Predicate __pred,\n                              __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::set_symmetric_difference(__begin1, __end1, __begin2,\n-                                                      __end2, __out, __pred); }\n+    { return _GLIBCXX_STD_P::set_symmetric_difference(\n+               __begin1, __end1, __begin2, __end2, __out, __pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename _IIter1, typename _IIter2,\n            typename _Predicate, typename _OutputIterator,\n            typename _IteratorTag1, typename _IteratorTag2,\n            typename _IteratorTag3>\n     inline _OutputIterator \n-    __set_symmetric_difference_switch(_IIter1 __begin1,\n-                                    _IIter1 __end1,\n-                                    _IIter2 __begin2,\n-                                    _IIter2 __end2,\n-                                    _OutputIterator __result, _Predicate __pred,\n-                                    _IteratorTag1, _IteratorTag2, _IteratorTag3)\n-    { return _GLIBCXX_STD_P::set_symmetric_difference(__begin1, __end1,\n-                                                      __begin2, __end2,\n-                                                      __result, __pred); }\n+    __set_symmetric_difference_switch(\n+      _IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, _IIter2 __end2,\n+      _OutputIterator __result, _Predicate __pred,\n+      _IteratorTag1, _IteratorTag2, _IteratorTag3)\n+    { return _GLIBCXX_STD_P::set_symmetric_difference(\n+               __begin1, __end1, __begin2, __end2, __result, __pred); }\n \n   // Parallel set_symmetric_difference for random access iterators\n   template<typename _RAIter1, typename _RAIter2,\n@@ -629,13 +630,11 @@ namespace __parallel\n       >= __gnu_parallel::_Settings::get().set_symmetric_difference_minimal_n\n       || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)\n       >= __gnu_parallel::_Settings::get().set_symmetric_difference_minimal_n))\n-  return __gnu_parallel::__parallel_set_symmetric_difference(__begin1, __end1,\n-                                                                 __begin2, __end2,\n-                                                                 __result, __pred);\n+  return __gnu_parallel::__parallel_set_symmetric_difference(\n+           __begin1, __end1, __begin2, __end2, __result, __pred);\n       else\n-        return _GLIBCXX_STD_P::set_symmetric_difference(__begin1, __end1,\n-                                                        __begin2, __end2,\n-                                                        __result, __pred);\n+        return _GLIBCXX_STD_P::set_symmetric_difference(\n+                 __begin1, __end1, __begin2, __end2, __result, __pred);\n     }\n \n   // Public interface.\n@@ -657,12 +656,10 @@ namespace __parallel\n       typedef typename _IIterTraits1::value_type _ValueType1;\n       typedef typename _IIterTraits2::value_type _ValueType2;\n \n-      return __set_symmetric_difference_switch(__begin1, __end1, __begin2, __end2, __out,\n-                                             __gnu_parallel::\n-                                             _Less<_ValueType1, _ValueType2>(),\n-                                             _IIterCategory1(),\n-                                             _IIterCategory2(),\n-                                             _OIterCategory());\n+      return __set_symmetric_difference_switch(\n+               __begin1, __end1, __begin2, __end2, __out,\n+               __gnu_parallel::_Less<_ValueType1, _ValueType2>(),\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Public interface.\n@@ -682,10 +679,9 @@ namespace __parallel\n         _IIterCategory2;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __set_symmetric_difference_switch(__begin1, __end1, __begin2, __end2, __out,\n-                                             __pred, _IIterCategory1(),\n-                                             _IIterCategory2(),\n-                                             _OIterCategory());\n+      return __set_symmetric_difference_switch(\n+               __begin1, __end1, __begin2, __end2, __out, __pred,\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Sequential fallback.\n@@ -695,7 +691,8 @@ namespace __parallel\n     set_difference(_IIter1 __begin1, _IIter1 __end1, \n                    _IIter2 __begin2, _IIter2 __end2, \n                    _OutputIterator __out, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::set_difference(__begin1,__end1, __begin2, __end2, __out); }\n+    { return _GLIBCXX_STD_P::set_difference(\n+               __begin1,__end1, __begin2, __end2, __out); }\n \n   // Sequential fallback.\n   template<typename _IIter1, typename _IIter2,\n@@ -709,16 +706,16 @@ namespace __parallel\n                                             __begin2, __end2, __out, __pred); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename _IIter1, typename _IIter2,\n-           typename _Predicate, typename _OutputIterator,\n-           typename _IteratorTag1, typename _IteratorTag2, typename _IteratorTag3>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate,\n+           typename _OutputIterator, typename _IteratorTag1,\n+           typename _IteratorTag2, typename _IteratorTag3>\n     inline _OutputIterator\n     __set_difference_switch(_IIter1 __begin1, _IIter1 __end1, \n                           _IIter2 __begin2, _IIter2 __end2, \n                           _OutputIterator __result, _Predicate __pred, \n                           _IteratorTag1, _IteratorTag2, _IteratorTag3)\n-    { return _GLIBCXX_STD_P::set_difference(__begin1, __end1,\n-                                            __begin2, __end2, __result, __pred); }\n+    { return _GLIBCXX_STD_P::set_difference(\n+               __begin1, __end1, __begin2, __end2, __result, __pred); }\n \n   // Parallel set_difference for random access iterators\n   template<typename _RAIter1, typename _RAIter2,\n@@ -738,12 +735,11 @@ namespace __parallel\n             >= __gnu_parallel::_Settings::get().set_difference_minimal_n\n             || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)\n             >= __gnu_parallel::_Settings::get().set_difference_minimal_n))\n-        return __gnu_parallel::__parallel_set_difference(__begin1, __end1,\n-                                                       __begin2, __end2,\n-                                                       __result, __pred);\n+        return __gnu_parallel::__parallel_set_difference(\n+                 __begin1, __end1, __begin2, __end2, __result, __pred);\n       else\n-        return _GLIBCXX_STD_P::set_difference(__begin1, __end1,\n-                                              __begin2, __end2, __result, __pred);\n+        return _GLIBCXX_STD_P::set_difference(\n+                 __begin1, __end1, __begin2, __end2, __result, __pred);\n     }\n \n   // Public interface\n@@ -765,12 +761,10 @@ namespace __parallel\n       typedef typename _IIterTraits1::value_type _ValueType1;\n       typedef typename _IIterTraits2::value_type _ValueType2;\n \n-      return __set_difference_switch(__begin1, __end1, __begin2, __end2, __out,\n-                                   __gnu_parallel::\n-                                   _Less<_ValueType1, _ValueType2>(), \n-                                   _IIterCategory1(),\n-                                   _IIterCategory2(), \n-                                   _OIterCategory());\n+      return __set_difference_switch(\n+               __begin1, __end1, __begin2, __end2, __out,\n+               __gnu_parallel::_Less<_ValueType1, _ValueType2>(),\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Public interface\n@@ -790,24 +784,24 @@ namespace __parallel\n         _IIterCategory2;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __set_difference_switch(__begin1, __end1, __begin2, __end2, __out, __pred,\n-                                   _IIterCategory1(),\n-                                   _IIterCategory2(), \n-                                   _OIterCategory());\n+      return __set_difference_switch(\n+               __begin1, __end1, __begin2, __end2, __out, __pred,\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    adjacent_find(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator>\n+    inline _FIterator\n+    adjacent_find(_FIterator __begin, _FIterator __end, \n                   __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::adjacent_find(__begin, __end); }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _BinaryPredicate>\n-    inline _ForwardIterator\n-    adjacent_find(_ForwardIterator __begin, _ForwardIterator __end, \n-                  _BinaryPredicate __binary_pred, __gnu_parallel::sequential_tag)\n+  template<typename _FIterator, typename _BinaryPredicate>\n+    inline _FIterator\n+    adjacent_find(_FIterator __begin, _FIterator __end, \n+                  _BinaryPredicate __binary_pred,\n+                  __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::adjacent_find(__begin, __end, __binary_pred); }\n \n   // Parallel algorithm for random access iterators\n@@ -822,8 +816,10 @@ namespace __parallel\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n         {\n           _RAIter spot = __gnu_parallel::\n-            __find_template(__begin, __end - 1, __begin, equal_to<_ValueType>(),\n-                          __gnu_parallel::__adjacent_find_selector()).first;\n+              __find_template(\n+                __begin, __end - 1, __begin, equal_to<_ValueType>(),\n+                __gnu_parallel::__adjacent_find_selector())\n+            .first;\n           if (spot == (__end - 1))\n             return __end;\n           else\n@@ -834,27 +830,27 @@ namespace __parallel\n     }\n \n   // Sequential fallback for input iterator case\n-  template<typename _ForwardIterator, typename _IteratorTag>\n-    inline _ForwardIterator\n-    __adjacent_find_switch(_ForwardIterator __begin, _ForwardIterator __end,\n+  template<typename _FIterator, typename _IteratorTag>\n+    inline _FIterator\n+    __adjacent_find_switch(_FIterator __begin, _FIterator __end,\n                          _IteratorTag)\n     { return adjacent_find(__begin, __end, __gnu_parallel::sequential_tag()); }\n \n   // Public interface\n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    adjacent_find(_ForwardIterator __begin, _ForwardIterator __end)\n+  template<typename _FIterator>\n+    inline _FIterator\n+    adjacent_find(_FIterator __begin, _FIterator __end)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n       return __adjacent_find_switch(__begin, __end, _IteratorCategory());\n     }\n \n   // Sequential fallback for input iterator case\n-  template<typename _ForwardIterator, typename _BinaryPredicate,\n+  template<typename _FIterator, typename _BinaryPredicate,\n            typename _IteratorTag>\n-    inline _ForwardIterator\n-    __adjacent_find_switch(_ForwardIterator __begin, _ForwardIterator __end, \n+    inline _FIterator\n+    __adjacent_find_switch(_FIterator __begin, _FIterator __end, \n                          _BinaryPredicate __pred, _IteratorTag)\n     { return adjacent_find(__begin, __end, __pred,\n                            __gnu_parallel::sequential_tag()); }\n@@ -866,7 +862,7 @@ namespace __parallel\n                          _BinaryPredicate __pred, random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n-        return __gnu_parallel::__find_template(__begin, __end, __begin, __pred, \n+        return __gnu_parallel::__find_template(__begin, __end, __begin, __pred,\n                                              __gnu_parallel::\n                                              __adjacent_find_selector()).first;\n       else\n@@ -875,14 +871,15 @@ namespace __parallel\n     }\n \n   // Public interface\n-  template<typename _ForwardIterator, typename _BinaryPredicate>\n-    inline _ForwardIterator\n-    adjacent_find(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator, typename _BinaryPredicate>\n+    inline _FIterator\n+    adjacent_find(_FIterator __begin, _FIterator __end, \n                   _BinaryPredicate __pred)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n-      return __adjacent_find_switch(__begin, __end, __pred, _IteratorCategory());\n+      return __adjacent_find_switch(__begin, __end, __pred,\n+                                    _IteratorCategory());\n     }\n \n   // Sequential fallback\n@@ -914,22 +911,24 @@ namespace __parallel\n             __functionality;\n           _DifferenceType __res = 0;\n           __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end, __value,\n-                                            __functionality,\n-                                            std::plus<_SequenceIndex>(),\n-                                            __res, __res, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __value, __functionality,\n+              std::plus<_SequenceIndex>(), __res, __res, -1,\n+              __parallelism_tag);\n           return __res;\n         }\n       else\n-        return count(__begin, __end, __value, __gnu_parallel::sequential_tag());\n+        return count(__begin, __end, __value,\n+                     __gnu_parallel::sequential_tag());\n     }\n \n   // Sequential fallback for input iterator case.\n   template<typename _IIter, typename _Tp, typename _IteratorTag>\n     inline typename iterator_traits<_IIter>::difference_type\n     __count_switch(_IIter __begin, _IIter __end, const _Tp& __value, \n                  _IteratorTag)\n-    { return count(__begin, __end, __value, __gnu_parallel::sequential_tag()); }\n+    { return count(__begin, __end, __value, __gnu_parallel::sequential_tag());\n+      }\n \n   // Public interface.\n   template<typename _IIter, typename _Tp>\n@@ -939,8 +938,8 @@ namespace __parallel\n     {\n       typedef iterator_traits<_IIter> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n-      return __count_switch(__begin, __end, __value, _IteratorCategory(), \n-                          __parallelism_tag);\n+      return __count_switch(__begin, __end, __value, _IteratorCategory(),\n+                            __parallelism_tag);\n     }\n \n   template<typename _IIter, typename _Tp>\n@@ -964,7 +963,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Predicate>\n     typename iterator_traits<_RAIter>::difference_type\n     __count_if_switch(_RAIter __begin, _RAIter __end, \n-                    _Predicate __pred, random_access_iterator_tag, \n+                    _Predicate __pred, random_access_iterator_tag,\n                     __gnu_parallel::_Parallelism __parallelism_tag\n                     = __gnu_parallel::parallel_unbalanced)\n     {\n@@ -983,22 +982,24 @@ namespace __parallel\n             __count_if_selector<_RAIter, _DifferenceType>\n             __functionality;\n           __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end, __pred,\n-                                            __functionality,\n-                                            std::plus<_SequenceIndex>(),\n-                                            __res, __res, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __pred, __functionality,\n+              std::plus<_SequenceIndex>(), __res, __res, -1,\n+              __parallelism_tag);\n           return __res;\n         }\n       else\n-        return count_if(__begin, __end, __pred, __gnu_parallel::sequential_tag());\n+        return count_if(__begin, __end, __pred,\n+                        __gnu_parallel::sequential_tag());\n     }\n \n   // Sequential fallback for input iterator case.\n   template<typename _IIter, typename _Predicate, typename _IteratorTag>\n     inline typename iterator_traits<_IIter>::difference_type\n     __count_if_switch(_IIter __begin, _IIter __end, _Predicate __pred, \n                     _IteratorTag)\n-    { return count_if(__begin, __end, __pred, __gnu_parallel::sequential_tag()); }\n+    { return count_if(__begin, __end, __pred,\n+                      __gnu_parallel::sequential_tag()); }\n \n   // Public interface.\n   template<typename _IIter, typename _Predicate>\n@@ -1023,10 +1024,10 @@ namespace __parallel\n \n \n   // Sequential fallback.\n-  template<typename ForwardIterator1, typename ForwardIterator2>\n-    inline ForwardIterator1\n-    search(ForwardIterator1 __begin1, ForwardIterator1 __end1,\n-           ForwardIterator2 __begin2, ForwardIterator2 __end2,\n+  template<typename _FIterator1, typename _FIterator2>\n+    inline _FIterator1\n+    search(_FIterator1 __begin1, _FIterator1 __end1,\n+           _FIterator2 __begin2, _FIterator2 __end2,\n            __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::search(__begin1, __end1, __begin2, __end2); }\n \n@@ -1044,46 +1045,48 @@ namespace __parallel\n \n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n         return __gnu_parallel::\n-          __search_template(__begin1, __end1, __begin2, __end2, __gnu_parallel::\n-                          equal_to<_ValueType1, _ValueType2>());\n+          __search_template(\n+            __begin1, __end1, __begin2, __end2,\n+            __gnu_parallel::equal_to<_ValueType1, _ValueType2>());\n       else\n         return search(__begin1, __end1, __begin2, __end2,\n                       __gnu_parallel::sequential_tag());\n     }\n \n   // Sequential fallback for input iterator case\n-  template<typename ForwardIterator1, typename ForwardIterator2,\n+  template<typename _FIterator1, typename _FIterator2,\n            typename _IteratorTag1, typename _IteratorTag2>\n-    inline ForwardIterator1\n-    __search_switch(ForwardIterator1 __begin1, ForwardIterator1 __end1,\n-                  ForwardIterator2 __begin2, ForwardIterator2 __end2,\n+    inline _FIterator1\n+    __search_switch(_FIterator1 __begin1, _FIterator1 __end1,\n+                  _FIterator2 __begin2, _FIterator2 __end2,\n                   _IteratorTag1, _IteratorTag2)\n     { return search(__begin1, __end1, __begin2, __end2,\n                     __gnu_parallel::sequential_tag()); }\n \n   // Public interface.\n-  template<typename ForwardIterator1, typename ForwardIterator2>\n-    inline ForwardIterator1\n-    search(ForwardIterator1 __begin1, ForwardIterator1 __end1,\n-           ForwardIterator2 __begin2, ForwardIterator2 __end2)\n+  template<typename _FIterator1, typename _FIterator2>\n+    inline _FIterator1\n+    search(_FIterator1 __begin1, _FIterator1 __end1,\n+           _FIterator2 __begin2, _FIterator2 __end2)\n     {\n-      typedef std::iterator_traits<ForwardIterator1> iterator1_traits;\n+      typedef std::iterator_traits<_FIterator1> iterator1_traits;\n       typedef typename iterator1_traits::iterator_category _IteratorCategory1;\n-      typedef std::iterator_traits<ForwardIterator2> iterator2_traits;\n+      typedef std::iterator_traits<_FIterator2> iterator2_traits;\n       typedef typename iterator2_traits::iterator_category _IteratorCategory2;\n \n       return __search_switch(__begin1, __end1, __begin2, __end2,\n                            _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   // Public interface.\n-  template<typename ForwardIterator1, typename ForwardIterator2,\n+  template<typename _FIterator1, typename _FIterator2,\n            typename _BinaryPredicate>\n-    inline ForwardIterator1\n-    search(ForwardIterator1 __begin1, ForwardIterator1 __end1,\n-           ForwardIterator2 __begin2, ForwardIterator2 __end2,\n+    inline _FIterator1\n+    search(_FIterator1 __begin1, _FIterator1 __end1,\n+           _FIterator2 __begin2, _FIterator2 __end2,\n            _BinaryPredicate __pred, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::search(__begin1, __end1, __begin2, __end2, __pred); }\n+    { return _GLIBCXX_STD_P::search(\n+                               __begin1, __end1, __begin2, __end2, __pred); }\n \n   // Parallel algorithm for random access iterator.\n   template<typename _RAIter1, typename _RAIter2,\n@@ -1103,55 +1106,56 @@ namespace __parallel\n     }\n \n   // Sequential fallback for input iterator case\n-  template<typename ForwardIterator1, typename ForwardIterator2,\n+  template<typename _FIterator1, typename _FIterator2,\n            typename _BinaryPredicate, typename _IteratorTag1,\n            typename _IteratorTag2>\n-    inline ForwardIterator1\n-    __search_switch(ForwardIterator1 __begin1, ForwardIterator1 __end1,\n-                  ForwardIterator2 __begin2, ForwardIterator2 __end2,\n+    inline _FIterator1\n+    __search_switch(_FIterator1 __begin1, _FIterator1 __end1,\n+                  _FIterator2 __begin2, _FIterator2 __end2,\n                   _BinaryPredicate __pred, _IteratorTag1, _IteratorTag2)\n     { return search(__begin1, __end1, __begin2, __end2, __pred,\n                     __gnu_parallel::sequential_tag()); }\n \n   // Public interface\n-  template<typename ForwardIterator1, typename ForwardIterator2,\n+  template<typename _FIterator1, typename _FIterator2,\n            typename _BinaryPredicate>\n-    inline ForwardIterator1\n-    search(ForwardIterator1 __begin1, ForwardIterator1 __end1,\n-           ForwardIterator2 __begin2, ForwardIterator2 __end2,\n+    inline _FIterator1\n+    search(_FIterator1 __begin1, _FIterator1 __end1,\n+           _FIterator2 __begin2, _FIterator2 __end2,\n            _BinaryPredicate  __pred)\n     {\n-      typedef std::iterator_traits<ForwardIterator1> iterator1_traits;\n+      typedef std::iterator_traits<_FIterator1> iterator1_traits;\n       typedef typename iterator1_traits::iterator_category _IteratorCategory1;\n-      typedef std::iterator_traits<ForwardIterator2> iterator2_traits;\n+      typedef std::iterator_traits<_FIterator2> iterator2_traits;\n       typedef typename iterator2_traits::iterator_category _IteratorCategory2;\n       return __search_switch(__begin1, __end1, __begin2, __end2, __pred,\n                            _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _Integer, typename _Tp>\n-    inline _ForwardIterator\n-    search_n(_ForwardIterator __begin, _ForwardIterator __end, _Integer count,\n+  template<typename _FIterator, typename _Integer, typename _Tp>\n+    inline _FIterator\n+    search_n(_FIterator __begin, _FIterator __end, _Integer count,\n              const _Tp& __val, __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::search_n(__begin, __end, count, __val); }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _Integer, typename _Tp,\n+  template<typename _FIterator, typename _Integer, typename _Tp,\n            typename _BinaryPredicate>\n-    inline _ForwardIterator\n-    search_n(_ForwardIterator __begin, _ForwardIterator __end, _Integer count,\n+    inline _FIterator\n+    search_n(_FIterator __begin, _FIterator __end, _Integer count,\n              const _Tp& __val, _BinaryPredicate __binary_pred,\n              __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::search_n(__begin, __end, count, __val, __binary_pred); }\n+    { return _GLIBCXX_STD_P::search_n(\n+               __begin, __end, count, __val, __binary_pred); }\n \n   // Public interface.\n-  template<typename _ForwardIterator, typename _Integer, typename _Tp>\n-    inline _ForwardIterator\n-    search_n(_ForwardIterator __begin, _ForwardIterator __end, _Integer count,\n+  template<typename _FIterator, typename _Integer, typename _Tp>\n+    inline _FIterator\n+    search_n(_FIterator __begin, _FIterator __end, _Integer count,\n              const _Tp& __val)\n     {\n-      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+      typedef typename iterator_traits<_FIterator>::value_type _ValueType;\n       return search_n(__begin, __end, count, __val,\n                       __gnu_parallel::equal_to<_ValueType, _Tp>());\n     }\n@@ -1160,38 +1164,40 @@ namespace __parallel\n   template<typename _RAIter, typename _Integer,\n            typename _Tp, typename _BinaryPredicate>\n     _RAIter\n-    __search_n_switch(_RAIter __begin, _RAIter __end,\n-                    _Integer count, const _Tp& __val, _BinaryPredicate __binary_pred,\n-                    random_access_iterator_tag)\n+    __search_n_switch(_RAIter __begin, _RAIter __end, _Integer count,\n+                      const _Tp& __val, _BinaryPredicate __binary_pred,\n+                      random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n         {\n           __gnu_parallel::_PseudoSequence<_Tp, _Integer> __ps(__val, count);\n-          return __gnu_parallel::__search_template(__begin, __end, __ps.begin(),\n-                                                 __ps.end(), __binary_pred);\n+          return __gnu_parallel::__search_template(\n+                   __begin, __end, __ps.begin(), __ps.end(), __binary_pred);\n         }\n       else\n         return std::__search_n(__begin, __end, count, __val,\n                                __binary_pred, random_access_iterator_tag());\n     }\n \n   // Sequential fallback for input iterator case.\n-  template<typename _ForwardIterator, typename _Integer, typename _Tp,\n+  template<typename _FIterator, typename _Integer, typename _Tp,\n            typename _BinaryPredicate, typename _IteratorTag>\n-    inline _ForwardIterator\n-    __search_n_switch(_ForwardIterator __begin, _ForwardIterator __end, _Integer count,\n-                    const _Tp& __val, _BinaryPredicate __binary_pred, _IteratorTag)\n-    { return __search_n(__begin, __end, count, __val, __binary_pred, _IteratorTag()); }\n+    inline _FIterator\n+    __search_n_switch(_FIterator __begin, _FIterator __end, _Integer count,\n+                      const _Tp& __val, _BinaryPredicate __binary_pred,\n+                      _IteratorTag)\n+    { return __search_n(__begin, __end, count, __val, __binary_pred,\n+                        _IteratorTag()); }\n \n   // Public interface.\n-  template<typename _ForwardIterator, typename _Integer, typename _Tp,\n+  template<typename _FIterator, typename _Integer, typename _Tp,\n            typename _BinaryPredicate>\n-    inline _ForwardIterator\n-    search_n(_ForwardIterator __begin, _ForwardIterator __end, _Integer count,\n+    inline _FIterator\n+    search_n(_FIterator __begin, _FIterator __end, _Integer count,\n              const _Tp& __val, _BinaryPredicate __binary_pred)\n     {\n       return __search_n_switch(__begin, __end, count, __val, __binary_pred,\n-                             typename std::iterator_traits<_ForwardIterator>::\n+                             typename std::iterator_traits<_FIterator>::\n                              iterator_category());\n     }\n \n@@ -1222,13 +1228,14 @@ namespace __parallel\n           bool __dummy = true;\n           typedef __gnu_parallel::_IteratorPair<_RAIter1,\n             _RAIter2, random_access_iterator_tag> _ItTrip;\n-          _ItTrip begin_pair(__begin, __result), end_pair(__end, __result + (__end - __begin));\n+          _ItTrip begin_pair(__begin, __result),\n+                  end_pair(__end, __result + (__end - __begin));\n           __gnu_parallel::__transform1_selector<_ItTrip> __functionality;\n           __gnu_parallel::\n-            __for_each_template_random_access(begin_pair, end_pair,\n-                                            unary_op, __functionality,\n-                                            __gnu_parallel::_DummyReduct(),\n-                                            __dummy, __dummy, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              begin_pair, end_pair, unary_op, __functionality,\n+              __gnu_parallel::_DummyReduct(),\n+              __dummy, __dummy, -1, __parallelism_tag);\n           return __functionality._M_finish_iterator;\n         }\n       else\n@@ -1358,9 +1365,10 @@ namespace __parallel\n       typedef std::iterator_traits<_OutputIterator> _OIterTraits;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __transform2_switch(__begin1, __end1, __begin2, __result, __binary_op,\n-                               _IIterCategory1(), _IIterCategory2(), \n-                               _OIterCategory(), __parallelism_tag);\n+      return __transform2_switch(\n+               __begin1, __end1, __begin2, __result, __binary_op,\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory(),\n+               __parallelism_tag);\n     }\n \n   template<typename _IIter1, typename _IIter2,\n@@ -1379,23 +1387,24 @@ namespace __parallel\n       typedef std::iterator_traits<_OutputIterator> _OIterTraits;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __transform2_switch(__begin1, __end1, __begin2, __result, __binary_op,\n-                               _IIterCategory1(), _IIterCategory2(),\n-                               _OIterCategory());\n+      return __transform2_switch(\n+               __begin1, __end1, __begin2, __result, __binary_op,\n+               _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n     }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _Tp>\n+  template<typename _FIterator, typename _Tp>\n     inline void\n-    replace(_ForwardIterator __begin, _ForwardIterator __end, const _Tp& __old_value, \n+    replace(_FIterator __begin, _FIterator __end, const _Tp& __old_value, \n             const _Tp& __new_value, __gnu_parallel::sequential_tag)\n     { _GLIBCXX_STD_P::replace(__begin, __end, __old_value, __new_value); }\n \n   // Sequential fallback for input iterator case\n-  template<typename _ForwardIterator, typename _Tp, typename _IteratorTag>\n+  template<typename _FIterator, typename _Tp, typename _IteratorTag>\n     inline void\n-    __replace_switch(_ForwardIterator __begin, _ForwardIterator __end, \n-                   const _Tp& __old_value, const _Tp& __new_value, _IteratorTag)\n+    __replace_switch(_FIterator __begin, _FIterator __end, \n+                     const _Tp& __old_value, const _Tp& __new_value,\n+                     _IteratorTag)\n     { replace(__begin, __end, __old_value, __new_value, \n               __gnu_parallel::sequential_tag()); }\n \n@@ -1414,40 +1423,43 @@ namespace __parallel\n     }\n \n   // Public interface\n-  template<typename _ForwardIterator, typename _Tp>\n+  template<typename _FIterator, typename _Tp>\n     inline void\n-    replace(_ForwardIterator __begin, _ForwardIterator __end, const _Tp& __old_value, \n-            const _Tp& __new_value, __gnu_parallel::_Parallelism __parallelism_tag)\n+    replace(_FIterator __begin, _FIterator __end, const _Tp& __old_value, \n+            const _Tp& __new_value,\n+            __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n-      __replace_switch(__begin, __end, __old_value, __new_value, _IteratorCategory(), \n+      __replace_switch(__begin, __end, __old_value, __new_value,\n+                       _IteratorCategory(),\n                      __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator, typename _Tp>\n+  template<typename _FIterator, typename _Tp>\n     inline void\n-    replace(_ForwardIterator __begin, _ForwardIterator __end, const _Tp& __old_value, \n+    replace(_FIterator __begin, _FIterator __end, const _Tp& __old_value, \n             const _Tp& __new_value)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n-      __replace_switch(__begin, __end, __old_value, __new_value, _IteratorCategory());\n+      __replace_switch(__begin, __end, __old_value, __new_value,\n+                       _IteratorCategory());\n     }\n \n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _Predicate, typename _Tp>\n+  template<typename _FIterator, typename _Predicate, typename _Tp>\n     inline void\n-    replace_if(_ForwardIterator __begin, _ForwardIterator __end, _Predicate __pred, \n+    replace_if(_FIterator __begin, _FIterator __end, _Predicate __pred, \n                const _Tp& __new_value, __gnu_parallel::sequential_tag)\n     { _GLIBCXX_STD_P::replace_if(__begin, __end, __pred, __new_value); }\n \n   // Sequential fallback for input iterator case\n-  template<typename _ForwardIterator, typename _Predicate, typename _Tp,\n+  template<typename _FIterator, typename _Predicate, typename _Tp,\n            typename _IteratorTag>\n     inline void\n-    __replace_if_switch(_ForwardIterator __begin, _ForwardIterator __end,\n+    __replace_if_switch(_FIterator __begin, _FIterator __end,\n                       _Predicate __pred, const _Tp& __new_value, _IteratorTag)\n     { replace_if(__begin, __end, __pred, __new_value,\n                  __gnu_parallel::sequential_tag()); }\n@@ -1471,50 +1483,51 @@ namespace __parallel\n             __replace_if_selector<_RAIter, _Predicate, _Tp>\n             __functionality(__new_value);\n           __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end, __pred,\n-                                            __functionality,\n-                                            __gnu_parallel::_DummyReduct(),\n-                                            true, __dummy, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __pred, __functionality,\n+              __gnu_parallel::_DummyReduct(),\n+              true, __dummy, -1, __parallelism_tag);\n         }\n       else\n         replace_if(__begin, __end, __pred, __new_value, \n                    __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n-  template<typename _ForwardIterator, typename _Predicate, typename _Tp>\n+  template<typename _FIterator, typename _Predicate, typename _Tp>\n     inline void\n-    replace_if(_ForwardIterator __begin, _ForwardIterator __end,\n+    replace_if(_FIterator __begin, _FIterator __end,\n                _Predicate __pred, const _Tp& __new_value, \n                __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef std::iterator_traits<_ForwardIterator> _IteratorTraits;\n+      typedef std::iterator_traits<_FIterator> _IteratorTraits;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n-      __replace_if_switch(__begin, __end, __pred, __new_value, _IteratorCategory(), \n-                        __parallelism_tag);\n+      __replace_if_switch(__begin, __end, __pred, __new_value,\n+                          _IteratorCategory(), __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator, typename _Predicate, typename _Tp>\n+  template<typename _FIterator, typename _Predicate, typename _Tp>\n     inline void\n-    replace_if(_ForwardIterator __begin, _ForwardIterator __end,\n+    replace_if(_FIterator __begin, _FIterator __end,\n                _Predicate __pred, const _Tp& __new_value)\n     {\n-      typedef std::iterator_traits<_ForwardIterator> _IteratorTraits;\n+      typedef std::iterator_traits<_FIterator> _IteratorTraits;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n-      __replace_if_switch(__begin, __end, __pred, __new_value, _IteratorCategory());\n+      __replace_if_switch(__begin, __end, __pred, __new_value,\n+                          _IteratorCategory());\n     }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename Generator>\n+  template<typename _FIterator, typename Generator>\n     inline void\n-    generate(_ForwardIterator __begin, _ForwardIterator __end, Generator __gen, \n+    generate(_FIterator __begin, _FIterator __end, Generator __gen, \n              __gnu_parallel::sequential_tag)\n     { _GLIBCXX_STD_P::generate(__begin, __end, __gen); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename _ForwardIterator, typename Generator, typename _IteratorTag>\n+  template<typename _FIterator, typename Generator, typename _IteratorTag>\n     inline void\n-    __generate_switch(_ForwardIterator __begin, _ForwardIterator __end, Generator __gen, \n+    __generate_switch(_FIterator __begin, _FIterator __end, Generator __gen,\n                     _IteratorTag)\n     { generate(__begin, __end, __gen, __gnu_parallel::sequential_tag()); }\n \n@@ -1535,30 +1548,32 @@ namespace __parallel\n           __gnu_parallel::__generate_selector<_RAIter>\n             __functionality;\n           __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end, __gen, __functionality,\n-                                            __gnu_parallel::_DummyReduct(),\n-                                            true, __dummy, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __gen, __functionality,\n+              __gnu_parallel::_DummyReduct(),\n+              true, __dummy, -1, __parallelism_tag);\n         }\n       else\n         generate(__begin, __end, __gen, __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n-  template<typename _ForwardIterator, typename Generator>\n+  template<typename _FIterator, typename Generator>\n     inline void\n-    generate(_ForwardIterator __begin, _ForwardIterator __end,\n+    generate(_FIterator __begin, _FIterator __end,\n              Generator __gen, __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef std::iterator_traits<_ForwardIterator> _IteratorTraits;\n+      typedef std::iterator_traits<_FIterator> _IteratorTraits;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n-      __generate_switch(__begin, __end, __gen, _IteratorCategory(), __parallelism_tag);\n+      __generate_switch(__begin, __end, __gen, _IteratorCategory(),\n+                        __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator, typename Generator>\n+  template<typename _FIterator, typename Generator>\n     inline void\n-    generate(_ForwardIterator __begin, _ForwardIterator __end, Generator __gen)\n+    generate(_FIterator __begin, _FIterator __end, Generator __gen)\n     {\n-      typedef std::iterator_traits<_ForwardIterator> _IteratorTraits;\n+      typedef std::iterator_traits<_FIterator> _IteratorTraits;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n       __generate_switch(__begin, __end, __gen, _IteratorCategory());\n     }\n@@ -1575,8 +1590,10 @@ namespace __parallel\n   template<typename _OutputIterator, typename _Size, typename Generator,\n            typename _IteratorTag>\n     inline _OutputIterator\n-    __generate_n_switch(_OutputIterator __begin, _Size __n, Generator __gen, _IteratorTag)\n-    { return generate_n(__begin, __n, __gen, __gnu_parallel::sequential_tag()); }\n+    __generate_n_switch(_OutputIterator __begin, _Size __n, Generator __gen,\n+                        _IteratorTag)\n+    { return generate_n(__begin, __n, __gen,\n+                        __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename _RAIter, typename _Size, typename Generator>\n@@ -1587,7 +1604,7 @@ namespace __parallel\n                       = __gnu_parallel::parallel_balanced)\n     {\n       // XXX parallel version is where?\n-      return generate_n(__begin, __n, __gen, __gnu_parallel::sequential_tag()); \n+      return generate_n(__begin, __n, __gen, __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n@@ -1623,7 +1640,8 @@ namespace __parallel\n   template<typename _RAIter, typename RandomNumberGenerator>\n     inline void\n     random_shuffle(_RAIter __begin, _RAIter __end, \n-                   RandomNumberGenerator& __rand, __gnu_parallel::sequential_tag)\n+                   RandomNumberGenerator& __rand,\n+                   __gnu_parallel::sequential_tag)\n     { _GLIBCXX_STD_P::random_shuffle(__begin, __end, __rand); }\n \n \n@@ -1663,18 +1681,19 @@ namespace __parallel\n     }\n \n   // Sequential fallback.\n-  template<typename _ForwardIterator, typename _Predicate>\n-    inline _ForwardIterator\n-    partition(_ForwardIterator __begin, _ForwardIterator __end,\n+  template<typename _FIterator, typename _Predicate>\n+    inline _FIterator\n+    partition(_FIterator __begin, _FIterator __end,\n               _Predicate __pred, __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::partition(__begin, __end, __pred); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename _ForwardIterator, typename _Predicate, typename _IteratorTag>\n-    inline _ForwardIterator\n-    __partition_switch(_ForwardIterator __begin, _ForwardIterator __end,\n+  template<typename _FIterator, typename _Predicate, typename _IteratorTag>\n+    inline _FIterator\n+    __partition_switch(_FIterator __begin, _FIterator __end,\n                      _Predicate __pred, _IteratorTag)\n-    { return partition(__begin, __end, __pred, __gnu_parallel::sequential_tag()); }\n+    { return partition(__begin, __end, __pred,\n+                       __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename _RAIter, typename _Predicate>\n@@ -1694,15 +1713,16 @@ namespace __parallel\n           return __begin + __middle;\n         }\n       else\n-        return partition(__begin, __end, __pred, __gnu_parallel::sequential_tag());\n+        return partition(__begin, __end, __pred,\n+                         __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n-  template<typename _ForwardIterator, typename _Predicate>\n-    inline _ForwardIterator\n-    partition(_ForwardIterator __begin, _ForwardIterator __end, _Predicate __pred)\n+  template<typename _FIterator, typename _Predicate>\n+    inline _FIterator\n+    partition(_FIterator __begin, _FIterator __end, _Predicate __pred)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n       return __partition_switch(__begin, __end, __pred, _IteratorCategory());\n     }\n@@ -1739,7 +1759,8 @@ namespace __parallel\n         if (_GLIBCXX_PARALLEL_CONDITION(\n             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin) >=\n               __gnu_parallel::_Settings::get().sort_minimal_n))\n-          __gnu_parallel::parallel_sort<false>(__begin, __end, __comp, __parallelism);\n+          __gnu_parallel::parallel_sort<false>(\n+                            __begin, __end, __comp, __parallelism);\n         else\n           sort(__begin, __end, __comp, __gnu_parallel::sequential_tag());\n       }\n@@ -1877,9 +1898,11 @@ namespace __parallel\n         if (_GLIBCXX_PARALLEL_CONDITION(\n               static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin) >=\n               __gnu_parallel::_Settings::get().sort_minimal_n))\n-          __gnu_parallel::parallel_sort<true>(__begin, __end, __comp, __parallelism);\n+          __gnu_parallel::parallel_sort<true>(\n+                            __begin, __end, __comp, __parallelism);\n         else\n-          stable_sort(__begin, __end, __comp, __gnu_parallel::sequential_tag());\n+          stable_sort(__begin, __end, __comp,\n+                      __gnu_parallel::sequential_tag());\n       }\n   }\n \n@@ -1957,59 +1980,19 @@ namespace __parallel\n   {\n     typedef iterator_traits<_RAIter> _TraitsType;\n     typedef typename _TraitsType::value_type _ValueType;\n-    stable_sort(__begin, __end, __comp, __gnu_parallel::default_parallel_tag());\n+    stable_sort(\n+      __begin, __end, __comp, __gnu_parallel::default_parallel_tag());\n   }\n \n-\n-//   // Sequential fallback\n-//   template<typename _RAIter>\n-//   inline void\n-//   stable_sort(_RAIter __begin, _RAIter __end, \n-//            __gnu_parallel::sequential_tag)\n-//   { return _GLIBCXX_STD_P::stable_sort(__begin, __end); }\n-// \n-//   // Sequential fallback\n-//   template<typename _RAIter, typename _Compare>\n-//   inline void\n-//   stable_sort(_RAIter __begin, _RAIter __end, \n-//            _Compare __comp, __gnu_parallel::sequential_tag)\n-//   { return _GLIBCXX_STD_P::stable_sort(__begin, __end, __comp); }\n-// \n-//   template<typename _RAIter>\n-//   void\n-//   stable_sort(_RAIter __begin, _RAIter __end)\n-//   {\n-//     typedef iterator_traits<_RAIter> _TraitsType;\n-//     typedef typename _TraitsType::value_type _ValueType;\n-//     stable_sort(__begin, __end, std::less<_ValueType>());\n-//   }\n-// \n-//   // Parallel algorithm for random access iterators\n-//   template<typename _RAIter, typename _Compare>\n-//   void\n-//   stable_sort(_RAIter __begin, _RAIter __end, \n-//            _Compare __comp)\n-//   {\n-//     if (__begin != __end)\n-//       {\n-//      if (_GLIBCXX_PARALLEL_CONDITION(\n-//            static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin) >=\n-//                __gnu_parallel::_Settings::get().sort_minimal_n))\n-//        __gnu_parallel::parallel_sort(__begin, __end, __comp,\n-//                                      __gnu_parallel::parallel_tag());\n-//      else\n-//        stable_sort(__begin, __end, __comp, __gnu_parallel::sequential_tag());\n-//       }\n-//   }\n-\n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2,\n            typename _OutputIterator>\n     inline _OutputIterator\n     merge(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n           _IIter2 __end2, _OutputIterator __result,\n           __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::merge(__begin1, __end1, __begin2, __end2, __result); }\n+    { return _GLIBCXX_STD_P::merge(\n+               __begin1, __end1, __begin2, __end2, __result); }\n \n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2,\n@@ -2018,12 +2001,13 @@ namespace __parallel\n     merge(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n           _IIter2 __end2, _OutputIterator __result, _Compare __comp,\n           __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::merge(__begin1, __end1, __begin2, __end2, __result, __comp); }\n+    { return _GLIBCXX_STD_P::merge(\n+                __begin1, __end1, __begin2, __end2, __result, __comp); }\n \n   // Sequential fallback for input iterator case\n-  template<typename _IIter1, typename _IIter2,\n-           typename _OutputIterator, typename _Compare,\n-           typename _IteratorTag1, typename _IteratorTag2, typename _IteratorTag3>\n+  template<typename _IIter1, typename _IIter2, typename _OutputIterator,\n+           typename _Compare, typename _IteratorTag1,\n+           typename _IteratorTag2, typename _IteratorTag3>\n     inline _OutputIterator\n     __merge_switch(_IIter1 __begin1, _IIter1 __end1,\n                  _IIter2 __begin2, _IIter2 __end2,\n@@ -2047,14 +2031,13 @@ namespace __parallel\n              >= __gnu_parallel::_Settings::get().merge_minimal_n\n              || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)\n              >= __gnu_parallel::_Settings::get().merge_minimal_n)))\n-        return __gnu_parallel::__parallel_merge_advance(__begin1, __end1,\n-                                                      __begin2, __end2,\n-                                                      __result, (__end1 - __begin1)\n-                                                      + (__end2 - __begin2), __comp);\n+        return __gnu_parallel::__parallel_merge_advance(\n+                 __begin1, __end1, __begin2, __end2, __result,\n+                 (__end1 - __begin1) + (__end2 - __begin2), __comp);\n       else\n-        return __gnu_parallel::__merge_advance(__begin1, __end1, __begin2, __end2,\n-                                             __result, (__end1 - __begin1)\n-                                             + (__end2 - __begin2), __comp);\n+        return __gnu_parallel::__merge_advance(\n+                 __begin1, __end1, __begin2, __end2, __result,\n+                 (__end1 - __begin1) + (__end2 - __begin2), __comp);\n   }\n \n   // Public interface\n@@ -2075,9 +2058,9 @@ namespace __parallel\n         _IIterCategory2;\n       typedef typename _OIterTraits::iterator_category _OIterCategory;\n \n-      return __merge_switch(__begin1, __end1, __begin2, __end2, __result, __comp, \n-                          _IIterCategory1(), _IIterCategory2(), \n-                          _OIterCategory());\n+      return __merge_switch(\n+              __begin1, __end1, __begin2, __end2, __result, __comp,\n+              _IIterCategory1(), _IIterCategory2(), _OIterCategory());\n   }\n \n \n@@ -2123,7 +2106,8 @@ namespace __parallel\n             >= __gnu_parallel::_Settings::get().nth_element_minimal_n))\n         __gnu_parallel::parallel_nth_element(__begin, __nth, __end, __comp);\n       else\n-        nth_element(__begin, __nth, __end, __comp, __gnu_parallel::sequential_tag());\n+        nth_element(__begin, __nth, __end, __comp,\n+                    __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface, insert default comparator\n@@ -2161,7 +2145,8 @@ namespace __parallel\n       if (_GLIBCXX_PARALLEL_CONDITION(\n             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n             >= __gnu_parallel::_Settings::get().partial_sort_minimal_n))\n-        __gnu_parallel::parallel_partial_sort(__begin, __middle, __end, __comp);\n+        __gnu_parallel::\n+          parallel_partial_sort(__begin, __middle, __end, __comp);\n       else\n         partial_sort(__begin, __middle, __end, __comp,\n                      __gnu_parallel::sequential_tag());\n@@ -2179,25 +2164,26 @@ namespace __parallel\n     }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    max_element(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator>\n+    inline _FIterator\n+    max_element(_FIterator __begin, _FIterator __end, \n                 __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::max_element(__begin, __end); }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _Compare>\n-    inline _ForwardIterator\n-    max_element(_ForwardIterator __begin, _ForwardIterator __end, _Compare __comp, \n+  template<typename _FIterator, typename _Compare>\n+    inline _FIterator\n+    max_element(_FIterator __begin, _FIterator __end, _Compare __comp, \n                 __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::max_element(__begin, __end, __comp); }\n \n   // Sequential fallback for input iterator case\n-  template<typename _ForwardIterator, typename _Compare, typename _IteratorTag>\n-    inline _ForwardIterator\n-    __max_element_switch(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator, typename _Compare, typename _IteratorTag>\n+    inline _FIterator\n+    __max_element_switch(_FIterator __begin, _FIterator __end, \n                        _Compare __comp, _IteratorTag)\n-    { return max_element(__begin, __end, __comp, __gnu_parallel::sequential_tag()); }\n+    { return max_element(__begin, __end, __comp,\n+                         __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators\n   template<typename _RAIter, typename _Compare>\n@@ -2216,79 +2202,79 @@ namespace __parallel\n           __gnu_parallel::__identity_selector<_RAIter>\n             __functionality;\n           __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end,\n-                                            __gnu_parallel::_Nothing(),\n-                                            __functionality,\n-                                            __gnu_parallel::\n-                                            __max_element_reduct<_Compare,\n-                                            _RAIter>(__comp),\n-                                            __res, __res, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __gnu_parallel::_Nothing(), __functionality,\n+              __gnu_parallel::__max_element_reduct<_Compare, _RAIter>(__comp),\n+              __res, __res, -1, __parallelism_tag);\n           return __res;\n         }\n       else\n-        return max_element(__begin, __end, __comp, __gnu_parallel::sequential_tag());\n+        return max_element(__begin, __end, __comp,\n+                           __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface, insert default comparator\n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    max_element(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator>\n+    inline _FIterator\n+    max_element(_FIterator __begin, _FIterator __end, \n                 __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n-      return max_element(__begin, __end, std::less<_ValueType>(), __parallelism_tag);\n+      typedef typename iterator_traits<_FIterator>::value_type _ValueType;\n+      return max_element(__begin, __end, std::less<_ValueType>(),\n+                         __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    max_element(_ForwardIterator __begin, _ForwardIterator __end)\n+  template<typename _FIterator>\n+    inline _FIterator\n+    max_element(_FIterator __begin, _FIterator __end)\n     {\n-      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+      typedef typename iterator_traits<_FIterator>::value_type _ValueType;\n       return max_element(__begin, __end, std::less<_ValueType>());\n     }\n \n   // Public interface\n-  template<typename _ForwardIterator, typename _Compare>\n-    inline _ForwardIterator\n-    max_element(_ForwardIterator __begin, _ForwardIterator __end, _Compare __comp,\n+  template<typename _FIterator, typename _Compare>\n+    inline _FIterator\n+    max_element(_FIterator __begin, _FIterator __end, _Compare __comp,\n                 __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n       return __max_element_switch(__begin, __end, __comp, _IteratorCategory(), \n-                                __parallelism_tag);\n+                                  __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator, typename _Compare>\n-    inline _ForwardIterator\n-    max_element(_ForwardIterator __begin, _ForwardIterator __end, _Compare __comp)\n+  template<typename _FIterator, typename _Compare>\n+    inline _FIterator\n+    max_element(_FIterator __begin, _FIterator __end, _Compare __comp)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n       return __max_element_switch(__begin, __end, __comp, _IteratorCategory());\n     }\n \n \n   // Sequential fallback\n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    min_element(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator>\n+    inline _FIterator\n+    min_element(_FIterator __begin, _FIterator __end, \n                 __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::min_element(__begin, __end); }\n \n   // Sequential fallback\n-  template<typename _ForwardIterator, typename _Compare>\n-    inline _ForwardIterator\n-    min_element(_ForwardIterator __begin, _ForwardIterator __end, _Compare __comp, \n+  template<typename _FIterator, typename _Compare>\n+    inline _FIterator\n+    min_element(_FIterator __begin, _FIterator __end, _Compare __comp, \n                 __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::min_element(__begin, __end, __comp); }\n \n   // Sequential fallback for input iterator case\n-  template<typename _ForwardIterator, typename _Compare, typename _IteratorTag>\n-    inline _ForwardIterator\n-    __min_element_switch(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator, typename _Compare, typename _IteratorTag>\n+    inline _FIterator\n+    __min_element_switch(_FIterator __begin, _FIterator __end, \n                        _Compare __comp, _IteratorTag)\n-    { return min_element(__begin, __end, __comp, __gnu_parallel::sequential_tag()); }\n+    { return min_element(__begin, __end, __comp,\n+                         __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators\n   template<typename _RAIter, typename _Compare>\n@@ -2307,54 +2293,53 @@ namespace __parallel\n           __gnu_parallel::__identity_selector<_RAIter>\n             __functionality;\n           __gnu_parallel::\n-            __for_each_template_random_access(__begin, __end,\n-                                            __gnu_parallel::_Nothing(),\n-                                            __functionality,\n-                                            __gnu_parallel::\n-                                            __min_element_reduct<_Compare,\n-                                            _RAIter>(__comp),\n-                                            __res, __res, -1, __parallelism_tag);\n+            __for_each_template_random_access(\n+              __begin, __end, __gnu_parallel::_Nothing(), __functionality,\n+              __gnu_parallel::__min_element_reduct<_Compare, _RAIter>(__comp),\n+              __res, __res, -1, __parallelism_tag);\n           return __res;\n         }\n       else\n-        return min_element(__begin, __end, __comp, __gnu_parallel::sequential_tag());\n+        return min_element(__begin, __end, __comp,\n+                           __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface, insert default comparator\n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    min_element(_ForwardIterator __begin, _ForwardIterator __end, \n+  template<typename _FIterator>\n+    inline _FIterator\n+    min_element(_FIterator __begin, _FIterator __end, \n                 __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n-      return min_element(__begin, __end, std::less<_ValueType>(), __parallelism_tag);\n+      typedef typename iterator_traits<_FIterator>::value_type _ValueType;\n+      return min_element(__begin, __end, std::less<_ValueType>(),\n+                         __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator>\n-    inline _ForwardIterator\n-    min_element(_ForwardIterator __begin, _ForwardIterator __end)\n+  template<typename _FIterator>\n+    inline _FIterator\n+    min_element(_FIterator __begin, _FIterator __end)\n     {\n-      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+      typedef typename iterator_traits<_FIterator>::value_type _ValueType;\n       return min_element(__begin, __end, std::less<_ValueType>());\n     }\n \n   // Public interface\n-  template<typename _ForwardIterator, typename _Compare>\n-    inline _ForwardIterator\n-    min_element(_ForwardIterator __begin, _ForwardIterator __end, _Compare __comp,\n+  template<typename _FIterator, typename _Compare>\n+    inline _FIterator\n+    min_element(_FIterator __begin, _FIterator __end, _Compare __comp,\n                 __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n       return __min_element_switch(__begin, __end, __comp, _IteratorCategory(), \n                                 __parallelism_tag);\n     }\n \n-  template<typename _ForwardIterator, typename _Compare>\n-    inline _ForwardIterator\n-    min_element(_ForwardIterator __begin, _ForwardIterator __end, _Compare __comp)\n+  template<typename _FIterator, typename _Compare>\n+    inline _FIterator\n+    min_element(_FIterator __begin, _FIterator __end, _Compare __comp)\n     {\n-      typedef iterator_traits<_ForwardIterator> _TraitsType;\n+      typedef iterator_traits<_FIterator> _TraitsType;\n       typedef typename _TraitsType::iterator_category _IteratorCategory;\n       return __min_element_switch(__begin, __end, __comp, _IteratorCategory());\n     }"}, {"sha": "b0571a47933e28ab37df0d6a1fcfd5fe28e255f7", "filename": "libstdc++-v3/include/parallel/algobase.h", "status": "modified", "additions": 95, "deletions": 103, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -53,44 +53,41 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2>\n     inline pair<_IIter1, _IIter2>\n     mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n-\t     __gnu_parallel::sequential_tag)\n+             __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2); }\n \n   // Sequential fallback\n-  template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     inline pair<_IIter1, _IIter2>\n     mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n-\t     _Predicate __pred, __gnu_parallel::sequential_tag)\n+             _Predicate __pred, __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>\n+           typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>\n     inline pair<_IIter1, _IIter2>\n-    __mismatch_switch(_IIter1 __begin1, _IIter1 __end1, \n-\t\t    _IIter2 __begin2, _Predicate __pred, _IteratorTag1, \n-\t\t    _IteratorTag2)\n+    __mismatch_switch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n+                      _Predicate __pred, _IteratorTag1, _IteratorTag2)\n     { return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred); }\n \n   // Parallel mismatch for random access iterators\n-  template<typename _RAIter1, typename _RAIter2,\n-\t   typename _Predicate>\n+  template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n     pair<_RAIter1, _RAIter2>\n     __mismatch_switch(_RAIter1 __begin1, _RAIter1 __end1,\n-\t\t    _RAIter2 __begin2, _Predicate __pred, \n-\t\t    random_access_iterator_tag, random_access_iterator_tag)\n+                      _RAIter2 __begin2, _Predicate __pred, \n+                      random_access_iterator_tag, random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n-\t{\n-\t  _RAIter1 __res =\n-\t    __gnu_parallel::__find_template(__begin1, __end1, __begin2, __pred,\n-\t\t\t\t\t  __gnu_parallel::\n-\t\t\t\t\t  __mismatch_selector()).first;\n-\t  return make_pair(__res , __begin2 + (__res - __begin1));\n-\t}\n+        {\n+          _RAIter1 __res =\n+            __gnu_parallel::__find_template(__begin1, __end1, __begin2, __pred,\n+                                            __gnu_parallel::\n+                                            __mismatch_selector()).first;\n+          return make_pair(__res , __begin2 + (__res - __begin1));\n+        }\n       else\n-\treturn _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred);\n+        return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred);\n     }\n \n   // Public interface\n@@ -108,38 +105,36 @@ namespace __parallel\n       typedef __gnu_parallel::equal_to<_ValueType1, _ValueType2> equal_to_type;\n \n       return __mismatch_switch(__begin1, __end1, __begin2, equal_to_type(),\n-\t\t\t     _IteratorCategory1(), _IteratorCategory2());\n+                               _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   // Public interface\n-  template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     inline pair<_IIter1, _IIter2>\n     mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n-\t     _Predicate __pred)\n+             _Predicate __pred)\n     {\n       typedef std::iterator_traits<_IIter1> iterator1_traits;\n       typedef std::iterator_traits<_IIter2> iterator2_traits;\n       typedef typename iterator1_traits::iterator_category _IteratorCategory1;\n       typedef typename iterator2_traits::iterator_category _IteratorCategory2;\n \n-      return __mismatch_switch(__begin1, __end1, __begin2, __pred, _IteratorCategory1(), \n-\t\t\t     _IteratorCategory2());\n+      return __mismatch_switch(__begin1, __end1, __begin2, __pred,\n+                               _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2>\n     inline bool\n     equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n-\t  __gnu_parallel::sequential_tag)\n+          __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::equal(__begin1, __end1, __begin2); }\n \n   // Sequential fallback\n-  template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     inline bool\n     equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n-\t  _Predicate __pred, __gnu_parallel::sequential_tag)\n+          _Predicate __pred, __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::equal(__begin1, __end1, __begin2, __pred); }\n \n   // Public interface\n@@ -149,99 +144,97 @@ namespace __parallel\n     { return mismatch(__begin1, __end1, __begin2).first == __end1; }\n \n   // Public interface\n-  template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     inline bool\n     equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n-\t  _Predicate __pred)\n+          _Predicate __pred)\n     { return mismatch(__begin1, __end1, __begin2, __pred).first == __end1; }\n \n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2>\n     inline bool\n     lexicographical_compare(_IIter1 __begin1, _IIter1 __end1, \n-\t\t\t    _IIter2 __begin2, _IIter2 __end2, \n-\t\t\t    __gnu_parallel::sequential_tag)\n+                            _IIter2 __begin2, _IIter2 __end2, \n+                            __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1,\n-\t\t\t\t\t\t     __begin2, __end2); }\n+                                                     __begin2, __end2); }\n \n   // Sequential fallback\n-  template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     inline bool\n     lexicographical_compare(_IIter1 __begin1, _IIter1 __end1, \n-\t\t\t    _IIter2 __begin2, _IIter2 __end2, \n-\t\t\t    _Predicate __pred, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1, \n-\t\t\t\t\t\t     __begin2, __end2, __pred); }\n+                            _IIter2 __begin2, _IIter2 __end2, \n+                            _Predicate __pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(\n+               __begin1, __end1, __begin2, __end2, __pred); }\n \n   // Sequential fallback for input iterator case\n   template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>\n+           typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>\n     inline bool\n-    __lexicographical_compare_switch(_IIter1 __begin1, _IIter1 __end1, \n-\t\t\t\t   _IIter2 __begin2, _IIter2 __end2, \n-\t\t\t\t   _Predicate __pred, _IteratorTag1, _IteratorTag2)\n-    { return _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1, \n-\t\t\t\t\t\t     __begin2, __end2, __pred); }\n+    __lexicographical_compare_switch(_IIter1 __begin1, _IIter1 __end1,\n+                                     _IIter2 __begin2, _IIter2 __end2, \n+                                     _Predicate __pred,\n+                                     _IteratorTag1, _IteratorTag2)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(\n+               __begin1, __end1, __begin2, __end2, __pred); }\n \n   // Parallel lexicographical_compare for random access iterators\n   // Limitation: Both valuetypes must be the same\n-  template<typename _RAIter1, typename _RAIter2,\n-\t   typename _Predicate>\n+  template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n     bool\n-    __lexicographical_compare_switch(_RAIter1 __begin1, \n-\t\t\t\t   _RAIter1 __end1, \n-\t\t\t\t   _RAIter2 __begin2, \n-\t\t\t\t   _RAIter2 __end2, _Predicate __pred, \n-\t\t\t\t   random_access_iterator_tag, \n-\t\t\t\t   random_access_iterator_tag)\n+    __lexicographical_compare_switch(_RAIter1 __begin1, _RAIter1 __end1,\n+                                     _RAIter2 __begin2, _RAIter2 __end2,\n+                                     _Predicate __pred,\n+                                     random_access_iterator_tag, \n+                                     random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n-\t{\n-\t  typedef iterator_traits<_RAIter1> _TraitsType1;\n-\t  typedef typename _TraitsType1::value_type _ValueType1;\n-\n-\t  typedef iterator_traits<_RAIter2> _TraitsType2;\n-\t  typedef typename _TraitsType2::value_type _ValueType2;\n-\n-\t  typedef __gnu_parallel::_EqualFromLess<_Predicate, _ValueType1,\n-\t                                          _ValueType2> _EqualFromLessCompare;\n-\n-\t  // Longer sequence in first place.\n-\t  if ((__end1 - __begin1) < (__end2 - __begin2))\n-\t    {\n-\t      typedef pair<_RAIter1, _RAIter2>\n-\t\t_SpotType;\n-\t      _SpotType __mm = __mismatch_switch(__begin1, __end1, __begin2, \n-\t\t\t\t\t     _EqualFromLessCompare(__pred), \n-\t\t\t\t\t     random_access_iterator_tag(), \n-\t\t\t\t\t     random_access_iterator_tag());\n-\n-\t      return (__mm.first == __end1) || bool(__pred(*__mm.first, *__mm.second));\n-\t    }\n-\t  else\n-\t    {\n-\t      typedef pair<_RAIter2, _RAIter1>\n-\t\t_SpotType;\n-\t      _SpotType __mm = __mismatch_switch(__begin2, __end2, __begin1, \n-\t\t\t\t\t     _EqualFromLessCompare(__pred), \n-\t\t\t\t\t     random_access_iterator_tag(), \n-\t\t\t\t\t     random_access_iterator_tag());\n-\n-\t      return (__mm.first != __end2) && bool(__pred(*__mm.second, *__mm.first));\n-\t    }\n-\t}\n+        {\n+          typedef iterator_traits<_RAIter1> _TraitsType1;\n+          typedef typename _TraitsType1::value_type _ValueType1;\n+\n+          typedef iterator_traits<_RAIter2> _TraitsType2;\n+          typedef typename _TraitsType2::value_type _ValueType2;\n+\n+          typedef __gnu_parallel::\n+                  _EqualFromLess<_Predicate, _ValueType1, _ValueType2>\n+                  _EqualFromLessCompare;\n+\n+          // Longer sequence in first place.\n+          if ((__end1 - __begin1) < (__end2 - __begin2))\n+            {\n+              typedef pair<_RAIter1, _RAIter2> _SpotType;\n+              _SpotType __mm = __mismatch_switch(__begin1, __end1, __begin2, \n+                                             _EqualFromLessCompare(__pred), \n+                                             random_access_iterator_tag(), \n+                                             random_access_iterator_tag());\n+\n+              return (__mm.first == __end1)\n+                        || bool(__pred(*__mm.first, *__mm.second));\n+            }\n+          else\n+            {\n+              typedef pair<_RAIter2, _RAIter1> _SpotType;\n+              _SpotType __mm = __mismatch_switch(__begin2, __end2, __begin1, \n+                                             _EqualFromLessCompare(__pred), \n+                                             random_access_iterator_tag(), \n+                                             random_access_iterator_tag());\n+\n+              return (__mm.first != __end2)\n+                        && bool(__pred(*__mm.second, *__mm.first));\n+            }\n+        }\n       else\n-\treturn _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1,\n-\t\t\t\t\t\t       __begin2, __end2, __pred);\n+        return _GLIBCXX_STD_P::lexicographical_compare(\n+                 __begin1, __end1, __begin2, __end2, __pred);\n     }\n \n   // Public interface\n   template<typename _IIter1, typename _IIter2>\n     inline bool\n     lexicographical_compare(_IIter1 __begin1, _IIter1 __end1,\n-\t\t\t    _IIter2 __begin2, _IIter2 __end2)\n+                            _IIter2 __begin2, _IIter2 __end2)\n     {\n       typedef iterator_traits<_IIter1> _TraitsType1;\n       typedef typename _TraitsType1::value_type _ValueType1;\n@@ -252,28 +245,27 @@ namespace __parallel\n       typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n       typedef __gnu_parallel::_Less<_ValueType1, _ValueType2> _LessType;\n \n-      return __lexicographical_compare_switch(__begin1, __end1, __begin2, __end2, \n-\t\t\t\t\t    _LessType(), _IteratorCategory1(), \n-\t\t\t\t\t    _IteratorCategory2());\n+      return __lexicographical_compare_switch(\n+               __begin1, __end1, __begin2, __end2, _LessType(),\n+               _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   // Public interface\n-  template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     inline bool\n     lexicographical_compare(_IIter1 __begin1, _IIter1 __end1,\n-\t\t\t    _IIter2 __begin2, _IIter2 __end2,\n-\t\t\t    _Predicate __pred)\n+                            _IIter2 __begin2, _IIter2 __end2,\n+                            _Predicate __pred)\n     {\n       typedef iterator_traits<_IIter1> _TraitsType1;\n       typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n \n       typedef iterator_traits<_IIter2> _TraitsType2;\n       typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n \n-      return __lexicographical_compare_switch(__begin1, __end1, __begin2, __end2, __pred, \n-\t\t\t\t\t    _IteratorCategory1(), \n-\t\t\t\t\t    _IteratorCategory2());\n+      return __lexicographical_compare_switch(\n+               __begin1, __end1, __begin2, __end2, __pred,\n+               _IteratorCategory1(), _IteratorCategory2());\n     }\n } // end namespace\n } // end namespace"}, {"sha": "5c93615da26ee550d6f60ab5fe31bc819f12e02a", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "modified", "additions": 155, "deletions": 150, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -62,7 +62,7 @@ namespace __parallel\n   template<typename _FIter, typename _BiPredicate>\n     _FIter\n     adjacent_find(_FIter, _FIter, _BiPredicate,\n-\t\t  __gnu_parallel::sequential_tag);\n+                  __gnu_parallel::sequential_tag);\n \n   template<typename _FIter, typename _BiPredicate, typename _IterTag>\n     _FIter\n@@ -71,7 +71,7 @@ namespace __parallel\n   template<typename _RAIter, typename _BiPredicate>\n     _RAIter\n     __adjacent_find_switch(_RAIter, _RAIter, _BiPredicate, \n-\t\t\t random_access_iterator_tag);\n+                         random_access_iterator_tag);\n \n \n   template<typename _IIter, typename _Tp>\n@@ -93,8 +93,8 @@ namespace __parallel\n   template<typename _RAIter, typename _Tp>\n     typename iterator_traits<_RAIter>::difference_type\n     __count_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag,\n-\t\t __gnu_parallel::_Parallelism __parallelism\n-\t\t = __gnu_parallel::parallel_unbalanced);\n+                 __gnu_parallel::_Parallelism __parallelism\n+                 = __gnu_parallel::parallel_unbalanced);\n \n \n   template<typename _IIter, typename _Predicate>\n@@ -116,8 +116,8 @@ namespace __parallel\n   template<typename _RAIter, typename _Predicate>\n     typename iterator_traits<_RAIter>::difference_type\n     __count_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag,\n-\t\t    __gnu_parallel::_Parallelism __parallelism\n-\t\t    = __gnu_parallel::parallel_unbalanced);\n+                    __gnu_parallel::_Parallelism __parallelism\n+                    = __gnu_parallel::parallel_unbalanced);\n \n   // algobase.h\n   template<typename _IIter1, typename _IIter2>\n@@ -127,7 +127,7 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2, typename _Predicate>\n     bool\n     equal(_IIter1, _IIter1, _IIter2, _Predicate,\n-\t  __gnu_parallel::sequential_tag);\n+          __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n     bool\n@@ -172,12 +172,12 @@ namespace __parallel\n   template<typename _IIter, typename _FIter>\n     _IIter\n     find_first_of(_IIter, _IIter, _FIter, _FIter,\n-\t\t  __gnu_parallel::sequential_tag);\n+                  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _FIter, typename _BiPredicate>\n     _IIter\n     find_first_of(_IIter, _IIter, _FIter, _FIter, _BiPredicate,\n-\t\t  __gnu_parallel::sequential_tag);\n+                  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _FIter, typename _BiPredicate>\n     _IIter\n@@ -188,21 +188,22 @@ namespace __parallel\n     find_first_of(_IIter, _IIter, _FIter, _FIter);\n \n   template<typename _IIter, typename _FIter,\n-\t   typename _IterTag1, typename _IterTag2>\n+           typename _IterTag1, typename _IterTag2>\n     _IIter\n-    __find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n+    __find_first_of_switch(\n+      _IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n \n   template<typename _RAIter, typename _FIter, typename _BiPredicate,\n-\t   typename _IterTag>\n+           typename _IterTag>\n     _RAIter\n     __find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, _BiPredicate,\n-\t\t\t random_access_iterator_tag, _IterTag);\n+                         random_access_iterator_tag, _IterTag);\n \n   template<typename _IIter, typename _FIter, typename _BiPredicate,\n-\t   typename _IterTag1, typename _IterTag2>\n+           typename _IterTag1, typename _IterTag2>\n     _IIter\n     __find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _BiPredicate,\n-\t\t\t _IterTag1, _IterTag2);\n+                         _IterTag1, _IterTag2);\n \n \n   template<typename _IIter, typename _Function>\n@@ -223,9 +224,9 @@ namespace __parallel\n \n   template<typename _RAIter, typename _Function>\n     _Function\n-    __for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag, \n-\t\t    __gnu_parallel::_Parallelism  __parallelism\n-\t\t    = __gnu_parallel::parallel_balanced);\n+    __for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag,\n+                    __gnu_parallel::_Parallelism  __parallelism\n+                    = __gnu_parallel::parallel_balanced);\n \n \n   template<typename _FIter, typename _Generator>\n@@ -246,9 +247,9 @@ namespace __parallel\n \n   template<typename _RAIter, typename _Generator>\n     void\n-    __generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag, \n-\t\t    __gnu_parallel::_Parallelism __parallelism\n-\t\t    = __gnu_parallel::parallel_balanced);\n+    __generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag,\n+                    __gnu_parallel::_Parallelism __parallelism\n+                    = __gnu_parallel::parallel_balanced);\n \n   template<typename _OIter, typename _Size, typename _Generator>\n     _OIter\n@@ -263,25 +264,25 @@ namespace __parallel\n     generate_n(_OIter, _Size, _Generator, __gnu_parallel::_Parallelism);\n \n   template<typename _OIter, typename _Size, typename _Generator,\n-\t   typename _IterTag>\n+           typename _IterTag>\n     _OIter\n     __generate_n_switch(_OIter, _Size, _Generator, _IterTag);\n \n   template<typename _RAIter, typename _Size, typename _Generator>\n     _RAIter\n-    __generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag, \n-\t\t      __gnu_parallel::_Parallelism __parallelism\n-\t\t      = __gnu_parallel::parallel_balanced);\n+    __generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag,\n+                      __gnu_parallel::_Parallelism __parallelism\n+                      = __gnu_parallel::parallel_balanced);\n \n   template<typename _IIter1, typename _IIter2>\n     bool\n     lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2,\n-\t\t\t    __gnu_parallel::sequential_tag);\n+                            __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _Predicate>\n     bool\n     lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Predicate,\n-\t\t\t    __gnu_parallel::sequential_tag);\n+                            __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n     bool\n@@ -292,16 +293,16 @@ namespace __parallel\n     lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Predicate);\n \n   template<typename _IIter1, typename _IIter2,\n-\t   typename _Predicate, typename _IterTag1, typename _IterTag2>\n+           typename _Predicate, typename _IterTag1, typename _IterTag2>\n     bool\n     __lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n-\t\t\t\t   _Predicate, _IterTag1, _IterTag2);\n+                                   _Predicate, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n     bool\n     __lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n-\t\t\t\t   _Predicate, random_access_iterator_tag,\n-\t\t\t\t   random_access_iterator_tag);\n+                                   _Predicate, random_access_iterator_tag,\n+                                   random_access_iterator_tag);\n \n   // algo.h\n   template<typename _IIter1, typename _IIter2>\n@@ -311,7 +312,7 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2, typename _Predicate>\n     pair<_IIter1, _IIter2>\n     mismatch(_IIter1, _IIter1, _IIter2, _Predicate,\n-\t     __gnu_parallel::sequential_tag);\n+             __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n     pair<_IIter1, _IIter2>\n@@ -322,15 +323,15 @@ namespace __parallel\n     mismatch(_IIter1, _IIter1, _IIter2, _Predicate);\n \n   template<typename _IIter1, typename _IIter2, typename _Predicate,\n-\t   typename _IterTag1, typename _IterTag2>\n+           typename _IterTag1, typename _IterTag2>\n     pair<_IIter1, _IIter2>\n     __mismatch_switch(_IIter1, _IIter1, _IIter2, _Predicate,\n-\t\t    _IterTag1, _IterTag2);\n+                    _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n     pair<_RAIter1, _RAIter2>\n     __mismatch_switch(_RAIter1, _RAIter1, _RAIter2, _Predicate,\n-\t\t    random_access_iterator_tag, random_access_iterator_tag);\n+                    random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2>\n     _FIter1\n@@ -343,7 +344,7 @@ namespace __parallel\n   template<typename _FIter1, typename _FIter2, typename _BiPredicate>\n     _FIter1\n     search(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate,\n-\t   __gnu_parallel::sequential_tag);\n+           __gnu_parallel::sequential_tag);\n \n   template<typename _FIter1, typename _FIter2, typename _BiPredicate>\n     _FIter1\n@@ -352,55 +353,55 @@ namespace __parallel\n   template<typename _RAIter1, typename _RAIter2>\n     _RAIter1\n     __search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n-\t\t  random_access_iterator_tag, random_access_iterator_tag);\n+                  random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2, typename _IterTag1,\n-\t   typename _IterTag2>\n+           typename _IterTag2>\n     _FIter1\n     __search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _BiPredicate>\n     _RAIter1\n     __search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _BiPredicate,\n-\t\t  random_access_iterator_tag, random_access_iterator_tag);\n+                  random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2, typename _BiPredicate,\n-\t   typename _IterTag1, typename _IterTag2>\n+           typename _IterTag1, typename _IterTag2>\n     _FIter1\n     __search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate,\n-\t\t  _IterTag1, _IterTag2);\n+                  _IterTag1, _IterTag2);\n \n   template<typename _FIter, typename _Integer, typename _Tp>\n     _FIter\n     search_n(_FIter, _FIter, _Integer, const _Tp&,\n-\t     __gnu_parallel::sequential_tag);\n+             __gnu_parallel::sequential_tag);\n \n   template<typename _FIter, typename _Integer, typename _Tp,\n-\t   typename _BiPredicate>\n+           typename _BiPredicate>\n     _FIter\n     search_n(_FIter, _FIter, _Integer, const _Tp&, _BiPredicate,\n-\t     __gnu_parallel::sequential_tag);\n+             __gnu_parallel::sequential_tag);\n     \n   template<typename _FIter, typename _Integer, typename _Tp>\n     _FIter\n     search_n(_FIter, _FIter, _Integer, const _Tp&);\n \n   template<typename _FIter, typename _Integer, typename _Tp,\n-\t   typename _BiPredicate>\n+           typename _BiPredicate>\n     _FIter\n     search_n(_FIter, _FIter, _Integer, const _Tp&, _BiPredicate);\n \n   template<typename _RAIter, typename _Integer, typename _Tp,\n-\t   typename _BiPredicate>\n+           typename _BiPredicate>\n     _RAIter\n     __search_n_switch(_RAIter, _RAIter, _Integer, const _Tp&,\n-\t\t    _BiPredicate, random_access_iterator_tag);\n+                    _BiPredicate, random_access_iterator_tag);\n \n   template<typename _FIter, typename _Integer, typename _Tp,\n-\t   typename _BiPredicate, typename _IterTag>\n+           typename _BiPredicate, typename _IterTag>\n     _FIter\n     __search_n_switch(_FIter, _FIter, _Integer, const _Tp&,\n-\t\t    _BiPredicate, _IterTag);\n+                    _BiPredicate, _IterTag);\n \n \n   template<typename _IIter, typename _OIter, typename _UnaryOperation>\n@@ -410,60 +411,60 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename _UnaryOperation>\n     _OIter\n     transform(_IIter, _IIter, _OIter, _UnaryOperation, \n-\t      __gnu_parallel::sequential_tag);\n+              __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename _UnaryOperation>\n     _OIter\n     transform(_IIter, _IIter, _OIter, _UnaryOperation, \n-\t      __gnu_parallel::_Parallelism);\n+              __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter, typename _UnaryOperation,\n-\t   typename _IterTag1, typename _IterTag2>\n+           typename _IterTag1, typename _IterTag2>\n     _OIter\n     __transform1_switch(_IIter, _IIter, _OIter, _UnaryOperation, \n-\t\t      _IterTag1, _IterTag2);\n+                      _IterTag1, _IterTag2);\n     \n \n   template<typename _RAIIter, typename _RAOIter, typename _UnaryOperation>\n     _RAOIter\n     __transform1_switch(_RAIIter, _RAIIter, _RAOIter, _UnaryOperation, \n-\t\t      random_access_iterator_tag, random_access_iterator_tag, \n-\t\t      __gnu_parallel::_Parallelism __parallelism\n-\t\t      = __gnu_parallel::parallel_balanced);\n+                      random_access_iterator_tag, random_access_iterator_tag, \n+                      __gnu_parallel::_Parallelism __parallelism\n+                      = __gnu_parallel::parallel_balanced);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _BiOperation>\n+           typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _BiOperation>\n+           typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n-\t      __gnu_parallel::sequential_tag);\n+              __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _BiOperation>\n+           typename _BiOperation>\n     _OIter\n     transform(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n-\t      __gnu_parallel::_Parallelism);\n+              __gnu_parallel::_Parallelism);\n \n   template<typename _RAIter1, typename _RAIter2, typename _RAIter3,\n-\t   typename _BiOperation>\n+           typename _BiOperation>\n     _RAIter3\n     __transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n-\t\t      random_access_iterator_tag, random_access_iterator_tag, \n-\t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::_Parallelism __parallelism\n-\t\t      = __gnu_parallel::parallel_balanced);\n+                      random_access_iterator_tag, random_access_iterator_tag, \n+                      random_access_iterator_tag,\n+                      __gnu_parallel::_Parallelism __parallelism\n+                      = __gnu_parallel::parallel_balanced);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _BiOperation, typename _Tag1,\n-\t   typename _Tag2, typename _Tag3>\n+           typename _BiOperation, typename _Tag1,\n+           typename _Tag2, typename _Tag3>\n     _OIter\n     __transform2_switch(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n-\t\t      _Tag1, _Tag2, _Tag3);\n+                      _Tag1, _Tag2, _Tag3);\n \n \n   template<typename _FIter, typename _Tp>\n@@ -473,12 +474,12 @@ namespace __parallel\n   template<typename _FIter, typename _Tp>\n     void\n     replace(_FIter, _FIter, const _Tp&, const _Tp&, \n-\t    __gnu_parallel::sequential_tag);\n+            __gnu_parallel::sequential_tag);\n \n   template<typename _FIter, typename _Tp>\n     void\n     replace(_FIter, _FIter, const _Tp&, const _Tp&,\n-\t    __gnu_parallel::_Parallelism);\n+            __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Tp, typename _IterTag>\n     void\n@@ -487,7 +488,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Tp>\n     void\n     __replace_switch(_RAIter, _RAIter, const _Tp&, const _Tp&, \n-\t\t   random_access_iterator_tag, __gnu_parallel::_Parallelism);\n+                   random_access_iterator_tag, __gnu_parallel::_Parallelism);\n \n \n   template<typename _FIter, typename _Predicate, typename _Tp>\n@@ -497,23 +498,23 @@ namespace __parallel\n   template<typename _FIter, typename _Predicate, typename _Tp>\n     void\n     replace_if(_FIter, _FIter, _Predicate, const _Tp&,\n-\t       __gnu_parallel::sequential_tag);\n+               __gnu_parallel::sequential_tag);\n \n   template<typename _FIter, typename _Predicate, typename _Tp>\n     void\n     replace_if(_FIter, _FIter, _Predicate, const _Tp&,\n-\t       __gnu_parallel::_Parallelism);\n+               __gnu_parallel::_Parallelism);\n \n   template<typename _FIter, typename _Predicate, typename _Tp,\n-\t   typename _IterTag>\n+           typename _IterTag>\n     void\n     __replace_if_switch(_FIter, _FIter, _Predicate, const _Tp&, _IterTag);\n  \n   template<typename _RAIter, typename _Predicate, typename _Tp>\n     void\n     __replace_if_switch(_RAIter, _RAIter, _Predicate, const _Tp&,\n-\t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::_Parallelism);\n+                      random_access_iterator_tag,\n+                      __gnu_parallel::_Parallelism);\n \n \n   template<typename _FIter>\n@@ -546,24 +547,25 @@ namespace __parallel\n \n   template<typename _RAIter, typename _Compare>\n     _RAIter\n-    __max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n-\t\t       __gnu_parallel::_Parallelism __parallelism\n-\t\t       = __gnu_parallel::parallel_balanced);\n+    __max_element_switch(\n+      _RAIter, _RAIter, _Compare, random_access_iterator_tag,\n+      __gnu_parallel::_Parallelism __parallelism\n+      = __gnu_parallel::parallel_balanced);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, \n-\t  __gnu_parallel::sequential_tag);\n+          __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Compare>\n+           typename _Compare>\n     _OIter\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n-\t  __gnu_parallel::sequential_tag);\n+          __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Compare>\n+           typename _Compare>\n     _OIter\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n \n@@ -572,18 +574,18 @@ namespace __parallel\n     merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Compare, typename _IterTag1, typename _IterTag2,\n-\t   typename _IterTag3>\n+           typename _Compare, typename _IterTag1, typename _IterTag2,\n+           typename _IterTag3>\n     _OIter\n     __merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n-\t\t _IterTag1, _IterTag2, _IterTag3);\n+                 _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Compare>\n+           typename _Compare>\n     _OIter\n     __merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n-\t\t random_access_iterator_tag, random_access_iterator_tag, \n-\t\t random_access_iterator_tag);\n+                 random_access_iterator_tag, random_access_iterator_tag, \n+                 random_access_iterator_tag);\n \n \n   template<typename _FIter>\n@@ -596,7 +598,8 @@ namespace __parallel\n \n   template<typename _FIter>\n     _FIter\n-    min_element(_FIter, _FIter, __gnu_parallel::_Parallelism __parallelism_tag);\n+    min_element(_FIter, _FIter,\n+                __gnu_parallel::_Parallelism __parallelism_tag);\n \n   template<typename _FIter, typename _Compare>\n     _FIter\n@@ -616,9 +619,10 @@ namespace __parallel\n \n   template<typename _RAIter, typename _Compare>\n     _RAIter\n-    __min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n-\t\t       __gnu_parallel::_Parallelism __parallelism\n-\t\t       = __gnu_parallel::parallel_balanced);\n+    __min_element_switch(\n+      _RAIter, _RAIter, _Compare, random_access_iterator_tag,\n+      __gnu_parallel::_Parallelism __parallelism\n+      = __gnu_parallel::parallel_balanced);\n \n   template<typename _RAIter>\n     void\n@@ -627,7 +631,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Compare>\n     void\n     nth_element(_RAIter, _RAIter, _RAIter, _Compare,\n-\t\t__gnu_parallel::sequential_tag);\n+                __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter, typename _Compare>\n     void\n@@ -640,7 +644,7 @@ namespace __parallel\n   template<typename _RAIter, typename _Compare>\n     void\n     partial_sort(_RAIter, _RAIter, _RAIter, _Compare,\n-\t\t __gnu_parallel::sequential_tag);\n+                 __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n     void\n@@ -668,7 +672,8 @@ namespace __parallel\n     \n   template<typename _RAIter, typename _Predicate>\n     _RAIter\n-    __partition_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag);\n+    __partition_switch(\n+      _RAIter, _RAIter, _Predicate, random_access_iterator_tag);\n \n   template<typename _RAIter>\n     void\n@@ -677,7 +682,7 @@ namespace __parallel\n   template<typename _RAIter, typename _RandomNumberGenerator>\n     void\n     random_shuffle(_RAIter, _RAIter, _RandomNumberGenerator&,\n-\t\t   __gnu_parallel::sequential_tag);\n+                   __gnu_parallel::sequential_tag);\n \n   template<typename _RAIter>\n     void\n@@ -690,147 +695,147 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t    __gnu_parallel::sequential_tag);\n+            __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter\n     set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate,\n-\t      __gnu_parallel::sequential_tag);\n+              __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter \n     set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate);\n \n   template<typename _IIter1, typename _IIter2, typename _Predicate,\n-\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n-\t   typename _IterTag3>\n+           typename _OIter, typename _IterTag1, typename _IterTag2,\n+           typename _IterTag3>\n     _OIter\n     __set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t     _Predicate, _IterTag1, _IterTag2, _IterTag3);\n+                     _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _Output_RAIter\n     __set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _Output_RAIter,\n-\t\t     _Predicate, random_access_iterator_tag,\n-\t\t     random_access_iterator_tag, random_access_iterator_tag);\n+                     _Predicate, random_access_iterator_tag,\n+                     random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t     __gnu_parallel::sequential_tag);\n+                     __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter\n     set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate,\n-\t\t     __gnu_parallel::sequential_tag);\n+                     __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter \n     set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate);\n \n   template<typename _IIter1, typename _IIter2, typename _Predicate,\n-\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n-\t   typename _IterTag3>\n+           typename _OIter, typename _IterTag1, typename _IterTag2,\n+           typename _IterTag3>\n     _OIter\n     __set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t\t    _Predicate, _IterTag1, _IterTag2, _IterTag3);\n+                            _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _Output_RAIter\n     __set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n-\t\t\t    _Output_RAIter, _Predicate,\n-\t\t\t    random_access_iterator_tag,\n-\t\t\t    random_access_iterator_tag,\n-\t\t\t    random_access_iterator_tag);\n+                            _Output_RAIter, _Predicate,\n+                            random_access_iterator_tag,\n+                            random_access_iterator_tag,\n+                            random_access_iterator_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t\t     __gnu_parallel::sequential_tag);\n+                             __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter\n     set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t\t     _Predicate, __gnu_parallel::sequential_tag);\n+                             _Predicate, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter \n     set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter \n     set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t\t     _Predicate);\n+                             _Predicate);\n \n   template<typename _IIter1, typename _IIter2, typename _Predicate,\n-\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n-\t   typename _IterTag3>\n+           typename _OIter, typename _IterTag1, typename _IterTag2,\n+           typename _IterTag3>\n     _OIter\n     __set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n-\t\t\t\t    _OIter, _Predicate, _IterTag1, _IterTag2,\n-\t\t\t\t    _IterTag3);\n+                                    _OIter, _Predicate, _IterTag1, _IterTag2,\n+                                    _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _Output_RAIter\n     __set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n-\t\t\t\t    _Output_RAIter, _Predicate,\n-\t\t\t\t    random_access_iterator_tag,\n-\t\t\t\t    random_access_iterator_tag,\n-\t\t\t\t    random_access_iterator_tag);\n+                                    _Output_RAIter, _Predicate,\n+                                    random_access_iterator_tag,\n+                                    random_access_iterator_tag,\n+                                    random_access_iterator_tag);\n \n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t   __gnu_parallel::sequential_tag);\n+                   __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter\n     set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate,\n-\t\t   __gnu_parallel::sequential_tag);\n+                   __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n     _OIter\n     set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _OIter\n     set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate);\n \n   template<typename _IIter1, typename _IIter2, typename _Predicate,\n-\t   typename _OIter, typename _IterTag1, typename _IterTag2,\n-\t   typename _IterTag3>\n+           typename _OIter, typename _IterTag1, typename _IterTag2,\n+           typename _IterTag3>\n     _OIter\n     __set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n-\t\t\t  _Predicate, _IterTag1, _IterTag2, _IterTag3);\n+                          _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n-\t   typename _Predicate>\n+           typename _Predicate>\n     _Output_RAIter\n     __set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n-\t\t\t  _Output_RAIter, _Predicate,\n-\t\t\t  random_access_iterator_tag,\n-\t\t\t  random_access_iterator_tag,\n-\t\t\t  random_access_iterator_tag);\n+                          _Output_RAIter, _Predicate,\n+                          random_access_iterator_tag,\n+                          random_access_iterator_tag,\n+                          random_access_iterator_tag);\n \n \n   template<typename _RAIter>\n@@ -872,7 +877,7 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename _Predicate>\n     _OIter\n     unique_copy(_IIter, _IIter, _OIter, _Predicate,\n-\t\t__gnu_parallel::sequential_tag);\n+                __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n     _OIter\n@@ -883,15 +888,15 @@ namespace __parallel\n     unique_copy(_IIter, _IIter, _OIter, _Predicate);\n \n   template<typename _IIter, typename _OIter, typename _Predicate,\n-\t   typename _IterTag1, typename _IterTag2>\n+           typename _IterTag1, typename _IterTag2>\n     _OIter\n     __unique_copy_switch(_IIter, _IIter, _OIter, _Predicate,\n-\t\t       _IterTag1, _IterTag2);\n+                       _IterTag1, _IterTag2);\n \n   template<typename _RAIter, typename _RandomAccess_OIter, typename _Predicate>\n     _RandomAccess_OIter\n     __unique_copy_switch(_RAIter, _RAIter, _RandomAccess_OIter, _Predicate,\n-\t\t       random_access_iterator_tag, random_access_iterator_tag);\n+                       random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace __parallel\n } // end namespace std\n "}, {"sha": "85e4d699e2689d60dfba0005d19fbad8c5a1728f", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -108,19 +108,25 @@ template<typename _RAIter, typename _Compare>\n \n     _RAIter __pivot_pos =\n       __median_of_three_iterators(__begin, __begin + (__end - __begin) / 2,\n-\t\t\t\t__end  - 1, __comp);\n+                                __end  - 1, __comp);\n \n #if defined(_GLIBCXX_ASSERTIONS)\n     // Must be in between somewhere.\n     _DifferenceType __n = __end - __begin;\n \n     _GLIBCXX_PARALLEL_ASSERT(\n-           (!__comp(*__pivot_pos, *__begin) && !__comp(*(__begin + __n / 2), *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *__begin) && !__comp(*(__end - 1), *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) && !__comp(*__begin, *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) && !__comp(*(__end - 1), *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__end - 1)) && !__comp(*__begin, *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__end - 1)) && !__comp(*(__begin + __n / 2), *__pivot_pos)));\n+           (!__comp(*__pivot_pos, *__begin) &&\n+              !__comp(*(__begin + __n / 2), *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *__begin) &&\n+              !__comp(*(__end - 1), *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) &&\n+              !__comp(*__begin, *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) &&\n+              !__comp(*(__end - 1), *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__end - 1)) &&\n+              !__comp(*__begin, *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__end - 1)) &&\n+              !__comp(*(__begin + __n / 2), *__pivot_pos)));\n #endif\n \n     // Swap pivot value to end.\n@@ -183,15 +189,17 @@ template<typename _RAIter, typename _Compare>\n       }\n \n     // Divide step.\n-    _DifferenceType __split_pos = __qsb_divide(__begin, __end, __comp, __num_threads);\n+    _DifferenceType __split_pos =\n+            __qsb_divide(__begin, __end, __comp, __num_threads);\n \n #if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(0 <= __split_pos && __split_pos < (__end - __begin));\n+    _GLIBCXX_PARALLEL_ASSERT(0 <= __split_pos &&\n+                             __split_pos < (__end - __begin));\n #endif\n \n     _ThreadIndex __num_threads_leftside =\n         std::max<_ThreadIndex>(1, std::min<_ThreadIndex>(\n-                          __num_threads - 1, __split_pos * __num_threads / __n));\n+            __num_threads - 1, __split_pos * __num_threads / __n));\n \n #   pragma omp atomic\n     *__tls[__iam]->_M_elements_leftover -= (_DifferenceType)1;\n@@ -284,11 +292,13 @@ template<typename _RAIter, typename _Compare>\n \n             // Divide, leave pivot unchanged in last place.\n             _RAIter __split_pos1, __split_pos2;\n-            __split_pos1 = __gnu_sequential::partition(__begin, __end - 1, __pred);\n+            __split_pos1 =\n+                    __gnu_sequential::partition(__begin, __end - 1, __pred);\n \n             // Left side: < __pivot_pos; __right side: >= __pivot_pos.\n #if _GLIBCXX_ASSERTIONS\n-            _GLIBCXX_PARALLEL_ASSERT(__begin <= __split_pos1 && __split_pos1 < __end);\n+            _GLIBCXX_PARALLEL_ASSERT(__begin <= __split_pos1\n+                                     && __split_pos1 < __end);\n #endif\n             // Swap pivot back to middle.\n             if (__split_pos1 != __pivot_pos)\n@@ -302,14 +312,14 @@ template<typename _RAIter, typename _Compare>\n                 // Very unequal split, one part smaller than one 128th\n                 // elements not strictly larger than the pivot.\n                 __gnu_parallel::__unary_negate<__gnu_parallel::__binder1st\n-\t\t  <_Compare, _ValueType, _ValueType, bool>, _ValueType>\n-\t\t  __pred(__gnu_parallel::__binder1st\n-\t\t       <_Compare, _ValueType, _ValueType, bool>(__comp,\n-\t\t\t\t\t\t\t\t  *__pivot_pos));\n+                  <_Compare, _ValueType, _ValueType, bool>, _ValueType>\n+                  __pred(__gnu_parallel::__binder1st\n+                       <_Compare, _ValueType, _ValueType, bool>(\n+                          __comp, *__pivot_pos));\n \n                 // Find other end of pivot-equal range.\n                 __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n-\t\t\t\t\t\t\t __end, __pred);\n+                                                         __end, __pred);\n               }\n             else\n               // Only skip the pivot.\n@@ -325,10 +335,10 @@ template<typename _RAIter, typename _Compare>\n               {\n                 // Right side larger.\n                 if ((__split_pos2) != __end)\n-                  __tl._M_leftover_parts.push_front(std::make_pair(__split_pos2,\n-\t\t\t\t\t\t\t      __end));\n+                  __tl._M_leftover_parts.push_front(\n+                    std::make_pair(__split_pos2, __end));\n \n-                //__current.first = __begin;\t//already set anyway\n+                //__current.first = __begin;    //already set anyway\n                 __current.second = __split_pos1;\n                 continue;\n               }\n@@ -337,10 +347,10 @@ template<typename _RAIter, typename _Compare>\n                 // Left side larger.\n                 if (__begin != __split_pos1)\n                   __tl._M_leftover_parts.push_front(std::make_pair(__begin,\n-\t\t\t\t\t\t\t      __split_pos1));\n+                                                              __split_pos1));\n \n                 __current.first = __split_pos2;\n-                //__current.second = __end;\t//already set anyway\n+                //__current.second = __end;     //already set anyway\n                 continue;\n               }\n           }\n@@ -367,10 +377,11 @@ template<typename _RAIter, typename _Compare>\n \n             // Look for new work.\n             bool __successfully_stolen = false;\n-            while (__wait && *__tl._M_elements_leftover > 0 && !__successfully_stolen\n+            while (__wait && *__tl._M_elements_leftover > 0\n+                   && !__successfully_stolen\n #if _GLIBCXX_ASSERTIONS\n-              // Possible dead-lock.\n-              && (omp_get_wtime() < (__search_start + 1.0))\n+                    // Possible dead-lock.\n+                   && (omp_get_wtime() < (__search_start + 1.0))\n #endif\n               )\n               {\n@@ -392,7 +403,7 @@ template<typename _RAIter, typename _Compare>\n               {\n                 sleep(1);\n                 _GLIBCXX_PARALLEL_ASSERT(omp_get_wtime()\n-\t\t\t\t\t < (__search_start + 1.0));\n+                                         < (__search_start + 1.0));\n               }\n #endif\n             if (!__successfully_stolen)\n@@ -439,11 +450,13 @@ template<typename _RAIter, typename _Compare>\n \n     // Initialize thread local storage\n     _TLSType** __tls = new _TLSType*[__num_threads];\n-    _DifferenceType __queue_size = __num_threads * (_ThreadIndex)(log2(__n) + 1);\n+    _DifferenceType __queue_size =\n+                           __num_threads * (_ThreadIndex)(log2(__n) + 1);\n     for (_ThreadIndex __t = 0; __t < __num_threads; ++__t)\n       __tls[__t] = new _QSBThreadLocal<_RAIter>(__queue_size);\n \n-    // There can never be more than ceil(log2(__n)) ranges on the stack, because\n+    // There can never be more than ceil(log2(__n)) ranges on the stack,\n+    // because\n     // 1. Only one processor pushes onto the stack\n     // 2. The largest range has at most length __n\n     // 3. Each range is larger than half of the range remaining\n@@ -459,13 +472,15 @@ template<typename _RAIter, typename _Compare>\n       }\n \n     // Main recursion call.\n-    __qsb_conquer(__tls, __begin, __begin + __n, __comp, 0, __num_threads, true);\n+    __qsb_conquer(\n+      __tls, __begin, __begin + __n, __comp, 0, __num_threads, true);\n \n #if _GLIBCXX_ASSERTIONS\n     // All stack must be empty.\n     _Piece __dummy;\n     for (int __i = 1; __i < __num_threads; ++__i)\n-      _GLIBCXX_PARALLEL_ASSERT(!__tls[__i]->_M_leftover_parts.pop_back(__dummy));\n+      _GLIBCXX_PARALLEL_ASSERT(\n+        !__tls[__i]->_M_leftover_parts.pop_back(__dummy));\n #endif\n \n     for (int __i = 0; __i < __num_threads; ++__i)"}, {"sha": "6925696a72e80ca2f15675fb1d8ec5e594dee390", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -119,7 +119,7 @@ template<typename _Size>\n   *  @see decode2\n   */\n inline _CASable\n-__encode2(int __a, int __b)\t//must all be non-negative, actually\n+__encode2(int __a, int __b)     //must all be non-negative, actually\n {\n   return (((_CASable)__a) << (_CASable_bits / 2)) | (((_CASable)__b) << 0);\n }\n@@ -192,7 +192,7 @@ template<typename _Predicate, typename argument_type>\n /** @brief Similar to std::__binder1st,\n   *  but giving the argument types explicitly. */\n template<typename _Operation, typename _FirstArgumentType,\n-\t typename _SecondArgumentType, typename _ResultType>\n+         typename _SecondArgumentType, typename _ResultType>\n   class __binder1st\n   : public std::unary_function<_SecondArgumentType, _ResultType>\n   {\n@@ -221,7 +221,7 @@ template<typename _Operation, typename _FirstArgumentType,\n   *  explicitly.\n   */\n template<typename _Operation, typename _FirstArgumentType,\n-\t typename _SecondArgumentType, typename _ResultType>\n+         typename _SecondArgumentType, typename _ResultType>\n   class binder2nd\n   : public std::unary_function<_FirstArgumentType, _ResultType>\n   {\n@@ -281,7 +281,7 @@ template<typename _Tp1, typename _Tp2>\n   struct _Plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n   {\n     typedef __typeof__(*static_cast<_Tp1*>(NULL)\n-\t\t       + *static_cast<_Tp2*>(NULL)) __result;\n+                       + *static_cast<_Tp2*>(NULL)) __result;\n \n     __result\n     operator()(const _Tp1& __x, const _Tp2& __y) const\n@@ -293,7 +293,7 @@ template<typename _Tp>\n   struct _Plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n   {\n     typedef __typeof__(*static_cast<_Tp*>(NULL)\n-\t\t       + *static_cast<_Tp*>(NULL)) __result;\n+                       + *static_cast<_Tp*>(NULL)) __result;\n \n     __result\n     operator()(const _Tp& __x, const _Tp& __y) const\n@@ -306,7 +306,7 @@ template<typename _Tp1, typename _Tp2>\n   struct _Multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n   {\n     typedef __typeof__(*static_cast<_Tp1*>(NULL)\n-\t\t       * *static_cast<_Tp2*>(NULL)) __result;\n+                       * *static_cast<_Tp2*>(NULL)) __result;\n \n     __result\n     operator()(const _Tp1& __x, const _Tp2& __y) const\n@@ -318,7 +318,7 @@ template<typename _Tp>\n   struct _Multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n   {\n     typedef __typeof__(*static_cast<_Tp*>(NULL)\n-\t\t       * *static_cast<_Tp*>(NULL)) __result;\n+                       * *static_cast<_Tp*>(NULL)) __result;\n \n     __result\n     operator()(const _Tp& __x, const _Tp& __y) const"}, {"sha": "5d3acfa4b8d2e46ea0d1de1cbff96b0734d40bd0", "filename": "libstdc++-v3/include/parallel/checkers.h", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -39,7 +39,8 @@\n namespace __gnu_parallel\n {\n   /**\n-   * @brief Check whether @__c [__begin, @__c __end) is sorted according to @__c __comp.\n+   * @brief Check whether @__c [__begin, @__c __end) is sorted according\n+   * to @__c __comp.\n    * @param __begin Begin iterator of sequence.\n    * @param __end End iterator of sequence.\n    * @param __comp Comparator.\n@@ -49,33 +50,34 @@ namespace __gnu_parallel\n   template<typename _IIter, typename _Compare>\n     bool\n     __is_sorted(_IIter __begin, _IIter __end,\n-\t      _Compare __comp\n-\t      = std::less<typename std::iterator_traits<_IIter>::\n-\t      _ValueType>())\n+              _Compare __comp\n+              = std::less<typename std::iterator_traits<_IIter>::\n+              _ValueType>())\n     {\n       if (__begin == __end)\n-\treturn true;\n+        return true;\n \n       _IIter __current(__begin), __recent(__begin);\n \n       unsigned long long __position = 1;\n       for (__current++; __current != __end; __current++)\n-\t{\n-\t  if (__comp(*__current, *__recent))\n-\t    {\n-\t      printf(\"__is_sorted: check failed before position %__i.\\n\",\n-\t\t     __position);\n-\t      return false;\n-\t    }\n-\t  __recent = __current;\n-\t  __position++;\n-\t}\n+        {\n+          if (__comp(*__current, *__recent))\n+            {\n+              printf(\"__is_sorted: check failed before position %__i.\\n\",\n+                     __position);\n+              return false;\n+            }\n+          __recent = __current;\n+          __position++;\n+        }\n \n       return true;\n     }\n \n   /**\n-   * @brief Check whether @__c [__begin, @__c __end) is sorted according to @__c __comp.\n+   * @brief Check whether @__c [__begin, @__c __end) is sorted according to\n+   * @__c __comp.\n    * Prints the position in case an unordered pair is found.\n    * @param __begin Begin iterator of sequence.\n    * @param __end End iterator of sequence.\n@@ -87,36 +89,37 @@ namespace __gnu_parallel\n   template<typename _IIter, typename _Compare>\n     bool\n     is_sorted_failure(_IIter __begin, _IIter __end,\n-\t\t      _IIter& __first_failure,\n-\t\t      _Compare __comp\n-\t\t      = std::less<typename std::iterator_traits<_IIter>::\n-\t\t      _ValueType>())\n+                      _IIter& __first_failure,\n+                      _Compare __comp\n+                      = std::less<typename std::iterator_traits<_IIter>::\n+                      _ValueType>())\n     {\n       if (__begin == __end)\n-\treturn true;\n+        return true;\n \n       _IIter __current(__begin), __recent(__begin);\n \n       unsigned long long __position = 1;\n       for (__current++; __current != __end; __current++)\n-\t{\n-\t  if (__comp(*__current, *__recent))\n-\t    {\n-\t      __first_failure = __current;\n-\t      printf(\"__is_sorted: check failed before position %lld.\\n\",\n-\t\t     __position);\n-\t      return false;\n-\t    }\n-\t  __recent = __current;\n-\t  __position++;\n-\t}\n+        {\n+          if (__comp(*__current, *__recent))\n+            {\n+              __first_failure = __current;\n+              printf(\"__is_sorted: check failed before position %lld.\\n\",\n+                     __position);\n+              return false;\n+            }\n+          __recent = __current;\n+          __position++;\n+        }\n \n       __first_failure = __end;\n       return true;\n     }\n \n   /**\n-   * @brief Check whether @__c [__begin, @__c __end) is sorted according to @__c __comp.\n+   * @brief Check whether @__c [__begin, @__c __end) is sorted according to\n+   * @__c __comp.\n    * Prints all unordered pair, including the surrounding two elements.\n    * @param __begin Begin iterator of sequence.\n    * @param __end End iterator of sequence.\n@@ -127,26 +130,26 @@ namespace __gnu_parallel\n     bool\n     // XXX Compare default template argument\n     is_sorted_print_failures(_IIter __begin, _IIter __end,\n-\t\t\t     _Compare __comp\n-\t\t\t     = std::less<typename std::iterator_traits\n-\t\t\t     <_IIter>::value_type>())\n+                             _Compare __comp\n+                             = std::less<typename std::iterator_traits\n+                             <_IIter>::value_type>())\n     {\n       if (__begin == __end)\n-\treturn true;\n+        return true;\n \n       _IIter __recent(__begin);\n       bool __ok = true;\n \n       for (_IIter __pos(__begin + 1); __pos != __end; __pos++)\n-\t{\n-\t  if (__comp(*__pos, *__recent))\n-\t    {\n-\t      printf(\"%ld: %d %d %d %d\\n\", __pos - __begin, *(__pos - 2),\n-\t\t     *(__pos- 1), *__pos, *(__pos + 1));\n-\t      __ok = false;\n-\t    }\n-\t  __recent = __pos;\n-\t}\n+        {\n+          if (__comp(*__pos, *__recent))\n+            {\n+              printf(\"%ld: %d %d %d %d\\n\", __pos - __begin, *(__pos - 2),\n+                     *(__pos- 1), *__pos, *(__pos + 1));\n+              __ok = false;\n+            }\n+          __recent = __pos;\n+        }\n       return __ok;\n     }\n }"}, {"sha": "e10370b6f54bde88e77d68441eb6b5a7f4c62468", "filename": "libstdc++-v3/include/parallel/compatibility.h", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -65,19 +65,19 @@ namespace __gnu_parallel\n   int32 __faa32(int32* __x, int32 __inc)\n   {\n     asm volatile(\"lock xadd %0,%1\"\n-\t\t : \"=__r\" (__inc), \"=__m\" (*__x)\n-\t\t : \"0\" (__inc)\n-\t\t : \"memory\");\n+                 : \"=__r\" (__inc), \"=__m\" (*__x)\n+                 : \"0\" (__inc)\n+                 : \"memory\");\n     return __inc;\n   }\n #if defined(__x86_64)\n   template<typename _MustBeInt = int>\n   int64 __faa64(int64* __x, int64 __inc)\n   {\n     asm volatile(\"lock xadd %0,%1\"\n-\t\t : \"=__r\" (__inc), \"=__m\" (*__x)\n-\t\t : \"0\" (__inc)\n-\t\t : \"memory\");\n+                 : \"=__r\" (__inc), \"=__m\" (*__x)\n+                 : \"0\" (__inc)\n+                 : \"memory\");\n     return __inc;\n   }\n #endif\n@@ -94,25 +94,25 @@ namespace __gnu_parallel\n   inline int32\n   __fetch_and_add_32(volatile int32* __ptr, int32 __addend)\n   {\n-#if defined(__ICC)\t//x86 version\n+#if defined(__ICC)      //x86 version\n     return _InterlockedExchangeAdd((void*)__ptr, __addend);\n-#elif defined(__ECC)\t//IA-64 version\n+#elif defined(__ECC)    //IA-64 version\n     return _InterlockedExchangeAdd((void*)__ptr, __addend);\n #elif defined(__ICL) || defined(_MSC_VER)\n     return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(__ptr),\n-\t\t\t\t   __addend);\n+                                   __addend);\n #elif defined(__GNUC__)\n     return __sync_fetch_and_add(__ptr, __addend);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n     volatile int32 __before, __after;\n     do\n       {\n-\t__before = *__ptr;\n-\t__after = __before + __addend;\n+        __before = *__ptr;\n+        __after = __before + __addend;\n       } while (atomic_cas_32((volatile unsigned int*)__ptr, __before,\n-\t\t\t     __after) != __before);\n+                             __after) != __before);\n     return __before;\n-#else\t//fallback, slow\n+#else   //fallback, slow\n #pragma message(\"slow __fetch_and_add_32\")\n     int32 __res;\n #pragma omp critical\n@@ -133,32 +133,32 @@ namespace __gnu_parallel\n   inline int64\n   __fetch_and_add_64(volatile int64* __ptr, int64 __addend)\n   {\n-#if defined(__ICC) && defined(__x86_64)\t//x86 version\n+#if defined(__ICC) && defined(__x86_64) //x86 version\n     return __faa64<int>((int64*)__ptr, __addend);\n-#elif defined(__ECC)\t//IA-64 version\n+#elif defined(__ECC)    //IA-64 version\n     return _InterlockedExchangeAdd64((void*)__ptr, __addend);\n #elif defined(__ICL) || defined(_MSC_VER)\n #ifndef _WIN64\n-    _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n+    _GLIBCXX_PARALLEL_ASSERT(false);    //not available in this case\n     return 0;\n #else\n     return _InterlockedExchangeAdd64(__ptr, __addend);\n #endif\n #elif defined(__GNUC__) && defined(__x86_64)\n     return __sync_fetch_and_add(__ptr, __addend);\n-#elif defined(__GNUC__) && defined(__i386) &&\t\t\t\\\n+#elif defined(__GNUC__) && defined(__i386) &&                   \\\n   (defined(__i686) || defined(__pentium4) || defined(__athlon))\n     return __sync_fetch_and_add(__ptr, __addend);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n     volatile int64 __before, __after;\n     do\n       {\n-\t__before = *__ptr;\n-\t__after = __before + __addend;\n+        __before = *__ptr;\n+        __after = __before + __addend;\n       } while (atomic_cas_64((volatile unsigned long long*)__ptr, __before,\n-\t\t\t     __after) != __before);\n+                             __after) != __before);\n     return __before;\n-#else\t//fallback, slow\n+#else   //fallback, slow\n #if defined(__GNUC__) && defined(__i386)\n     // XXX doesn'__t work with -march=native\n     //#warning \"please compile with -march=i686 or better\"\n@@ -201,9 +201,10 @@ namespace __gnu_parallel\n   {\n     int32 __before;\n     __asm__ __volatile__(\"lock; cmpxchgl %1,%2\"\n-\t\t\t : \"=a\"(__before)\n-\t\t\t : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)), \"0\"(__old)\n-\t\t\t : \"memory\");\n+                         : \"=a\"(__before)\n+                         : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)),\n+                               \"0\"(__old)\n+                         : \"memory\");\n     return __before;\n   }\n \n@@ -214,9 +215,10 @@ namespace __gnu_parallel\n   {\n     int64 __before;\n     __asm__ __volatile__(\"lock; cmpxchgq %1,%2\"\n-\t\t\t : \"=a\"(__before)\n-\t\t\t : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)), \"0\"(__old)\n-\t\t\t : \"memory\");\n+                         : \"=a\"(__before)\n+                         : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)),\n+                               \"0\"(__old)\n+                         : \"memory\");\n     return __before;\n   }\n #endif\n@@ -232,32 +234,35 @@ namespace __gnu_parallel\n    *  @param __replacement Replacement value.\n    */\n   inline bool\n-  __compare_and_swap_32(volatile int32* __ptr, int32 __comparand, int32 __replacement)\n+  __compare_and_swap_32(volatile int32* __ptr, int32 __comparand,\n+                        int32 __replacement)\n   {\n-#if defined(__ICC)\t//x86 version\n+#if defined(__ICC)      //x86 version\n     return _InterlockedCompareExchange((void*)__ptr, __replacement,\n-\t\t\t\t       __comparand) == __comparand;\n-#elif defined(__ECC)\t//IA-64 version\n+                                       __comparand) == __comparand;\n+#elif defined(__ECC)    //IA-64 version\n     return _InterlockedCompareExchange((void*)__ptr, __replacement,\n-\t\t\t\t       __comparand) == __comparand;\n+                                       __comparand) == __comparand;\n #elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedCompareExchange(reinterpret_cast<volatile long*>(__ptr),\n-\t\t\t\t       __replacement, __comparand) == __comparand;\n+    return _InterlockedCompareExchange(\n+               reinterpret_cast<volatile long*>(__ptr),\n+               __replacement, __comparand)\n+             == __comparand;\n #elif defined(__GNUC__)\n     return __sync_bool_compare_and_swap(__ptr, __comparand, __replacement);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n     return atomic_cas_32((volatile unsigned int*)__ptr, __comparand,\n-\t\t\t __replacement) == __comparand;\n+                         __replacement) == __comparand;\n #else\n #pragma message(\"slow __compare_and_swap_32\")\n     bool __res = false;\n #pragma omp critical\n     {\n       if (*__ptr == __comparand)\n-\t{\n-\t  *__ptr = __replacement;\n-\t  __res = true;\n-\t}\n+        {\n+          *__ptr = __replacement;\n+          __res = true;\n+        }\n     }\n     return __res;\n #endif\n@@ -272,30 +277,31 @@ namespace __gnu_parallel\n    *  @param __replacement Replacement value.\n    */\n   inline bool\n-  __compare_and_swap_64(volatile int64* __ptr, int64 __comparand, int64 __replacement)\n+  __compare_and_swap_64(volatile int64* __ptr, int64 __comparand,\n+                        int64 __replacement)\n   {\n-#if defined(__ICC) && defined(__x86_64)\t//x86 version\n+#if defined(__ICC) && defined(__x86_64) //x86 version\n     return __cas64<int>(__ptr, __comparand, __replacement) == __comparand;\n-#elif defined(__ECC)\t//IA-64 version\n+#elif defined(__ECC)    //IA-64 version\n     return _InterlockedCompareExchange64((void*)__ptr, __replacement,\n-\t\t\t\t\t __comparand) == __comparand;\n+                                         __comparand) == __comparand;\n #elif defined(__ICL) || defined(_MSC_VER)\n #ifndef _WIN64\n-    _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n+    _GLIBCXX_PARALLEL_ASSERT(false);    //not available in this case\n     return 0;\n #else\n     return _InterlockedCompareExchange64(__ptr, __replacement,\n-\t\t\t\t\t __comparand) == __comparand;\n+                                         __comparand) == __comparand;\n #endif\n \n #elif defined(__GNUC__) && defined(__x86_64)\n     return __sync_bool_compare_and_swap(__ptr, __comparand, __replacement);\n-#elif defined(__GNUC__) && defined(__i386) &&\t\t\t\\\n+#elif defined(__GNUC__) && defined(__i386) &&                   \\\n   (defined(__i686) || defined(__pentium4) || defined(__athlon))\n     return __sync_bool_compare_and_swap(__ptr, __comparand, __replacement);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n     return atomic_cas_64((volatile unsigned long long*)__ptr,\n-\t\t\t __comparand, __replacement) == __comparand;\n+                         __comparand, __replacement) == __comparand;\n #else\n #if defined(__GNUC__) && defined(__i386)\n     // XXX -march=native\n@@ -306,10 +312,10 @@ namespace __gnu_parallel\n #pragma omp critical\n     {\n       if (*__ptr == __comparand)\n-\t{\n-\t  *__ptr = __replacement;\n-\t  __res = true;\n-\t}\n+        {\n+          *__ptr = __replacement;\n+          __res = true;\n+        }\n     }\n     return __res;\n #endif\n@@ -327,9 +333,11 @@ namespace __gnu_parallel\n   __compare_and_swap(volatile _Tp* __ptr, _Tp __comparand, _Tp __replacement)\n   {\n     if (sizeof(_Tp) == sizeof(int32))\n-      return __compare_and_swap_32((volatile int32*) __ptr, (int32)__comparand, (int32)__replacement);\n+      return __compare_and_swap_32((volatile int32*) __ptr, (int32)__comparand,\n+                                   (int32)__replacement);\n     else if (sizeof(_Tp) == sizeof(int64))\n-      return __compare_and_swap_64((volatile int64*) __ptr, (int64)__comparand, (int64)__replacement);\n+      return __compare_and_swap_64((volatile int64*) __ptr, (int64)__comparand,\n+                                   (int64)__replacement);\n     else\n       _GLIBCXX_PARALLEL_ASSERT(false);\n   }"}, {"sha": "a41ed6ec41e877f3273d5e061345ebc543a85a0e", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -45,15 +45,17 @@ namespace __gnu_parallel\n  *  @returns End of splitter sequence, i.e. @__c __s+__num_threads+1 */\n template<typename _DifferenceType, typename _OutputIterator>\n   _OutputIterator\n-  equally_split(_DifferenceType __n, _ThreadIndex __num_threads, _OutputIterator __s)\n+  equally_split(_DifferenceType __n, _ThreadIndex __num_threads,\n+                _OutputIterator __s)\n   {\n     _DifferenceType __chunk_length = __n / __num_threads;\n     _DifferenceType __num_longer_chunks = __n % __num_threads;\n     _DifferenceType __pos = 0;\n     for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n       {\n         *__s++ = __pos;\n-        __pos += (__i < __num_longer_chunks) ? (__chunk_length + 1) : __chunk_length;\n+        __pos += (__i < __num_longer_chunks) ?\n+                                      (__chunk_length + 1) : __chunk_length;\n       }\n     *__s++ = __n;\n     return __s;"}, {"sha": "e7f0d8390869faa3c02b505468581801d5adfdbb", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -53,9 +53,9 @@ namespace __gnu_parallel\n  *  @return Place of finding in both sequences.\n  */\n template<typename _RAIter1,\n-\t typename _RAIter2,\n-\t typename _Pred,\n-\t typename _Selector>\n+         typename _RAIter2,\n+         typename _Pred,\n+         typename _Selector>\n   inline std::pair<_RAIter1, _RAIter2>\n   __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n                 _RAIter2 __begin2, _Pred __pred, _Selector __selector)\n@@ -64,13 +64,13 @@ template<typename _RAIter1,\n       {\n       case GROWING_BLOCKS:\n         return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n-\t\t\t     growing_blocks_tag());\n+                             growing_blocks_tag());\n       case CONSTANT_SIZE_BLOCKS:\n         return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n-\t\t\t     constant_size_blocks_tag());\n+                             constant_size_blocks_tag());\n       case EQUAL_SPLIT:\n         return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n-\t\t\t     equal_split_tag());\n+                             equal_split_tag());\n       default:\n         _GLIBCXX_PARALLEL_ASSERT(false);\n         return std::make_pair(__begin1, __begin2);\n@@ -90,9 +90,9 @@ template<typename _RAIter1,\n  *  @return Place of finding in both sequences.\n  */\n template<typename _RAIter1,\n-\t typename _RAIter2,\n-\t typename _Pred,\n-\t typename _Selector>\n+         typename _RAIter2,\n+         typename _Pred,\n+         typename _Selector>\n   std::pair<_RAIter1, _RAIter2>\n   __find_template(_RAIter1 __begin1,\n                 _RAIter1 __end1,\n@@ -125,7 +125,8 @@ template<typename _RAIter1,\n           } //single\n \n         _ThreadIndex __iam = omp_get_thread_num();\n-        _DifferenceType __start = __borders[__iam], __stop = __borders[__iam + 1];\n+        _DifferenceType __start = __borders[__iam],\n+                        __stop = __borders[__iam + 1];\n \n         _RAIter1 __i1 = __begin1 + __start;\n         _RAIter2 __i2 = __begin2 + __start;\n@@ -153,8 +154,7 @@ template<typename _RAIter1,\n     delete[] __borders;\n \n     return\n-      std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n-\t\t\t\t\t\t\t      __begin2 + __result);\n+      std::pair<_RAIter1, _RAIter2>(__begin1 + __result, __begin2 + __result);\n   }\n \n #endif\n@@ -178,15 +178,14 @@ template<typename _RAIter1,\n  *  There are two main differences between the growing blocks and\n  *  the constant-size blocks variants.\n  *  1. For GB, the block size grows; for CSB, the block size is fixed.\n-\n  *  2. For GB, the blocks are allocated dynamically;\n  *     for CSB, the blocks are allocated in a predetermined manner,\n  *     namely spacial round-robin.\n  */\n template<typename _RAIter1,\n-\t typename _RAIter2,\n-\t typename _Pred,\n-\t typename _Selector>\n+         typename _RAIter2,\n+         typename _Pred,\n+         typename _Selector>\n   std::pair<_RAIter1, _RAIter2>\n   __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n                 _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n@@ -231,7 +230,7 @@ template<typename _RAIter1,\n \n         _DifferenceType __block_size = __s.find_initial_block_size;\n         _DifferenceType __start =\n-            __fetch_and_add<_DifferenceType>(&__next_block_start, __block_size);\n+          __fetch_and_add<_DifferenceType>(&__next_block_start, __block_size);\n \n         // Get new block, update pointer to next block.\n         _DifferenceType __stop =\n@@ -250,7 +249,8 @@ template<typename _RAIter1,\n               }\n \n             __local_result = __selector._M_sequential_algorithm(\n-                __begin1 + __start, __begin1 + __stop, __begin2 + __start, __pred);\n+                               __begin1 + __start, __begin1 + __stop,\n+                               __begin2 + __start, __pred);\n             if (__local_result.first != (__begin1 + __stop))\n               {\n                 omp_set_lock(&__result_lock);\n@@ -259,29 +259,30 @@ template<typename _RAIter1,\n                     __result = __local_result.first - __begin1;\n \n                     // Result cannot be in future blocks, stop algorithm.\n-                    __fetch_and_add<_DifferenceType>(&__next_block_start, __length);\n+                    __fetch_and_add<_DifferenceType>(\n+                      &__next_block_start, __length);\n                   }\n                   omp_unset_lock(&__result_lock);\n               }\n \n-            __block_size =\n-\t      std::min<_DifferenceType>(__block_size * __s.find_increasing_factor,\n-\t\t\t\t\t__s.find_maximum_block_size);\n+            __block_size = std::min<_DifferenceType>(\n+              __block_size * __s.find_increasing_factor,\n+              __s.find_maximum_block_size);\n \n             // Get new block, update pointer to next block.\n             __start =\n-\t      __fetch_and_add<_DifferenceType>(&__next_block_start, __block_size);\n+              __fetch_and_add<_DifferenceType>(\n+                &__next_block_start, __block_size);\n             __stop = ((__length < (__start + __block_size))\n-\t\t    ? __length : (__start + __block_size));\n+                     ? __length : (__start + __block_size));\n           }\n       } //parallel\n \n     omp_destroy_lock(&__result_lock);\n \n     // Return iterator on found element.\n     return\n-      std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n-\t\t\t\t\t\t\t      __begin2 + __result);\n+      std::pair<_RAIter1, _RAIter2>(__begin1 + __result, __begin2 + __result);\n   }\n \n #endif\n@@ -307,9 +308,9 @@ template<typename _RAIter1,\n  *  round-robin.\n  */\n template<typename _RAIter1,\n-\t typename _RAIter2,\n-\t typename _Pred,\n-\t typename _Selector>\n+         typename _RAIter2,\n+         typename _Pred,\n+         typename _Selector>\n   std::pair<_RAIter1, _RAIter2>\n   __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n                 _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n@@ -329,8 +330,8 @@ template<typename _RAIter1,\n \n     // Try it sequentially first.\n     std::pair<_RAIter1, _RAIter2> __find_seq_result =\n-      __selector._M_sequential_algorithm(__begin1, __begin1 + __sequential_search_size,\n-                                    __begin2, __pred);\n+      __selector._M_sequential_algorithm(\n+        __begin1, __begin1 + __sequential_search_size, __begin2, __pred);\n \n     if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n       return __find_seq_result;\n@@ -384,16 +385,16 @@ template<typename _RAIter1,\n \n             // Where to work.\n             __start = __iteration_start + __iam * __block_size;\n-            __stop = std::min<_DifferenceType>(__length, __start + __block_size);\n+            __stop = std::min<_DifferenceType>(\n+                       __length, __start + __block_size);\n           }\n       } //parallel\n \n     omp_destroy_lock(&__result_lock);\n \n     // Return iterator on found element.\n     return\n-      std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n-\t\t\t\t\t\t\t      __begin2 + __result);\n+      std::pair<_RAIter1, _RAIter2>(__begin1 + __result, __begin2 + __result);\n   }\n #endif\n } // end namespace"}, {"sha": "2b1e118a64f4abe2180e52c17d4860105acfd078", "filename": "libstdc++-v3/include/parallel/find_selectors.h", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -55,7 +55,7 @@ namespace __gnu_parallel\n      * @param __pred Find predicate.\n      */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       bool \n       operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       { return __pred(*__i1); }\n@@ -67,13 +67,13 @@ namespace __gnu_parallel\n      *  @param __pred Find predicate.\n      */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       std::pair<_RAIter1, _RAIter2> \n       _M_sequential_algorithm(_RAIter1 __begin1,\n-\t\t\t   _RAIter1 __end1,\n-\t\t\t   _RAIter2 __begin2, _Pred __pred)\n+                           _RAIter1 __end1,\n+                           _RAIter2 __begin2, _Pred __pred)\n       { return std::make_pair(find_if(__begin1, __end1, __pred,\n-\t\t\t\t      sequential_tag()), __begin2); }\n+                                      sequential_tag()), __begin2); }\n   };\n \n   /** @brief Test predicate on two adjacent elements. */\n@@ -85,12 +85,12 @@ namespace __gnu_parallel\n      *  @param __pred Find predicate.\n      */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       bool \n       operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       {\n-\t// Passed end iterator is one short.\n-\treturn __pred(*__i1, *(__i1 + 1));\n+        // Passed end iterator is one short.\n+        return __pred(*__i1, *(__i1 + 1));\n       }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n@@ -100,18 +100,18 @@ namespace __gnu_parallel\n      *  @param __pred Find predicate.\n      */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       std::pair<_RAIter1, _RAIter2>\n       _M_sequential_algorithm(_RAIter1 __begin1,\n-\t\t\t   _RAIter1 __end1,\n-\t\t\t   _RAIter2 __begin2, _Pred __pred)\n+                           _RAIter1 __end1,\n+                           _RAIter2 __begin2, _Pred __pred)\n       {\n-\t// Passed end iterator is one short.\n-\t_RAIter1 spot = adjacent_find(__begin1, __end1 + 1,\n-\t\t\t\t\t\t   __pred, sequential_tag());\n-\tif (spot == (__end1 + 1))\n-\t  spot = __end1;\n-\treturn std::make_pair(spot, __begin2);\n+        // Passed end iterator is one short.\n+        _RAIter1 spot = adjacent_find(__begin1, __end1 + 1,\n+                                                   __pred, sequential_tag());\n+        if (spot == (__end1 + 1))\n+          spot = __end1;\n+        return std::make_pair(spot, __begin2);\n       }\n   };\n \n@@ -125,7 +125,7 @@ namespace __gnu_parallel\n      *  @param __pred Find predicate. \n      */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       bool \n       operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       { return !__pred(*__i1, *__i2); }\n@@ -138,39 +138,40 @@ namespace __gnu_parallel\n      *  @param __pred Find predicate. \n      */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       std::pair<_RAIter1, _RAIter2>\n       _M_sequential_algorithm(_RAIter1 __begin1,\n-\t\t\t   _RAIter1 __end1,\n-\t\t\t   _RAIter2 __begin2, _Pred __pred)\n-      { return mismatch(__begin1, __end1, __begin2, __pred, sequential_tag()); }\n+                           _RAIter1 __end1,\n+                           _RAIter2 __begin2, _Pred __pred)\n+      { return mismatch(__begin1, __end1, __begin2, __pred, sequential_tag());\n+        }\n   };\n \n \n   /** @brief Test predicate on several elements. */\n-  template<typename _ForwardIterator>\n+  template<typename _FIterator>\n   struct __find_first_of_selector : public __generic_find_selector\n   {\n-    _ForwardIterator _M_begin;\n-    _ForwardIterator _M_end;\n+    _FIterator _M_begin;\n+    _FIterator _M_end;\n \n-    explicit __find_first_of_selector(_ForwardIterator __begin, _ForwardIterator __end)\n+    explicit __find_first_of_selector(_FIterator __begin, _FIterator __end)\n     : _M_begin(__begin), _M_end(__end) { }\n \n     /** @brief Test on one position.\n      *  @param __i1 _Iterator on first sequence.\n      *  @param __i2 _Iterator on second sequence (unused).\n      *  @param __pred Find predicate. */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       bool \n       operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       {\n-\tfor (_ForwardIterator __pos_in_candidates = _M_begin;\n-\t     __pos_in_candidates != _M_end; ++__pos_in_candidates)\n-\t  if (__pred(*__i1, *__pos_in_candidates))\n-\t    return true;\n-\treturn false;\n+        for (_FIterator __pos_in_candidates = _M_begin;\n+             __pos_in_candidates != _M_end; ++__pos_in_candidates)\n+          if (__pred(*__i1, *__pos_in_candidates))\n+            return true;\n+        return false;\n       }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n@@ -179,13 +180,16 @@ namespace __gnu_parallel\n      *  @param __begin2 Begin iterator of second sequence.\n      *  @param __pred Find predicate. */\n     template<typename _RAIter1, typename _RAIter2,\n-\t     typename _Pred>\n+             typename _Pred>\n       std::pair<_RAIter1, _RAIter2>\n       _M_sequential_algorithm(_RAIter1 __begin1,\n-\t\t\t   _RAIter1 __end1,\n-\t\t\t   _RAIter2 __begin2, _Pred __pred)\n-      { return std::make_pair(find_first_of(__begin1, __end1, _M_begin, _M_end, __pred,\n-\t\t\t\t\t    sequential_tag()), __begin2); }\n+                           _RAIter1 __end1,\n+                           _RAIter2 __begin2, _Pred __pred)\n+      {\n+        return std::make_pair(\n+                 find_first_of(__begin1, __end1, _M_begin, _M_end, __pred,\n+                               sequential_tag()), __begin2);\n+      }\n   };\n }\n "}, {"sha": "f1c9c23b8a5520b5c86a1ad9bffda4ce197bbf9a", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -56,41 +56,44 @@ namespace __gnu_parallel\n    *  @param __bound Maximum number of elements processed.\n    *  @param __parallelism_tag Parallelization method */\n   template<typename _IIter, typename _UserOp,\n-\t   typename _Functionality, typename _Red, typename _Result>\n+           typename _Functionality, typename _Red, typename _Result>\n     _UserOp\n     __for_each_template_random_access(_IIter __begin, _IIter __end,\n-\t\t\t\t    _UserOp __user_op,\n-\t\t\t\t    _Functionality& __functionality,\n-\t\t\t\t    _Red __reduction, _Result __reduction_start,\n-\t\t\t\t    _Result& __output, typename\n-\t\t\t\t    std::iterator_traits<_IIter>::\n-\t\t\t\t    difference_type __bound,\n-\t\t\t\t    _Parallelism __parallelism_tag)\n+                                      _UserOp __user_op,\n+                                      _Functionality& __functionality,\n+                                      _Red __reduction,\n+                                      _Result __reduction_start,\n+                                      _Result& __output, typename\n+                                      std::iterator_traits<_IIter>::\n+                                      difference_type __bound,\n+                                      _Parallelism __parallelism_tag)\n     {\n       if (__parallelism_tag == parallel_unbalanced)\n-\treturn for_each_template_random_access_ed(__begin, __end, __user_op,\n-\t\t\t\t\t\t  __functionality, __reduction,\n-\t\t\t\t\t\t  __reduction_start,\n-\t\t\t\t\t\t  __output, __bound);\n+        return for_each_template_random_access_ed(__begin, __end, __user_op,\n+                                                  __functionality, __reduction,\n+                                                  __reduction_start,\n+                                                  __output, __bound);\n       else if (__parallelism_tag == parallel_omp_loop)\n-\treturn for_each_template_random_access_omp_loop(__begin, __end, __user_op,\n-\t\t\t\t\t\t\t__functionality,\n-\t\t\t\t\t\t\t__reduction,\n-\t\t\t\t\t\t\t__reduction_start,\n-\t\t\t\t\t\t\t__output, __bound);\n+        return for_each_template_random_access_omp_loop(\n+                                                  __begin, __end, __user_op,\n+                                                  __functionality,\n+                                                  __reduction,\n+                                                  __reduction_start,\n+                                                  __output, __bound);\n       else if (__parallelism_tag == parallel_omp_loop_static)\n-\treturn for_each_template_random_access_omp_loop(__begin, __end, __user_op,\n-\t\t\t\t\t\t\t__functionality,\n-\t\t\t\t\t\t\t__reduction,\n-\t\t\t\t\t\t\t__reduction_start,\n-\t\t\t\t\t\t\t__output, __bound);\n-      else\t//e. g. parallel_balanced\n-\treturn for_each_template_random_access_workstealing(__begin, __end,\n-\t\t\t\t\t\t\t    __user_op,\n-\t\t\t\t\t\t\t    __functionality,\n-\t\t\t\t\t\t\t    __reduction,\n-\t\t\t\t\t\t\t    __reduction_start,\n-\t\t\t\t\t\t\t    __output, __bound);\n+        return for_each_template_random_access_omp_loop(\n+                                                  __begin, __end, __user_op,\n+                                                  __functionality,\n+                                                  __reduction,\n+                                                  __reduction_start,\n+                                                  __output, __bound);\n+      else      //e. g. parallel_balanced\n+        return for_each_template_random_access_workstealing(__begin, __end,\n+                                                            __user_op,\n+                                                            __functionality,\n+                                                            __reduction,\n+                                                            __reduction_start,\n+                                                            __output, __bound);\n   }\n }\n "}, {"sha": "9b3bb6b5703d0a85f7a57d4415f467d12146c155", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -59,10 +59,10 @@ namespace __gnu_parallel\n       template<typename _Op>\n         bool\n         operator()(_Op& __o, _It __i)\n-\t{\n-\t  __o(*__i);\n-\t  return true;\n-\t}\n+        {\n+          __o(*__i);\n+          return true;\n+        }\n     };\n \n   /** @brief std::generate() selector. */\n@@ -76,9 +76,9 @@ namespace __gnu_parallel\n         bool\n         operator()(_Op& __o, _It __i)\n         {\n-\t  *__i = __o();\n-\t  return true;\n-\t}\n+          *__i = __o();\n+          return true;\n+        }\n     };\n \n   /** @brief std::fill() selector. */\n@@ -91,10 +91,10 @@ namespace __gnu_parallel\n       template<typename Val>\n         bool\n         operator()(Val& __v, _It __i)\n-\t{\n-\t  *__i = __v;\n-\t  return true;\n-\t}\n+        {\n+          *__i = __v;\n+          return true;\n+        }\n     };\n \n   /** @brief std::transform() __selector, one input sequence variant. */\n@@ -107,10 +107,10 @@ namespace __gnu_parallel\n       template<typename _Op>\n         bool\n         operator()(_Op& __o, _It __i)\n-\t{\n-\t  *__i.second = __o(*__i.first);\n-\t  return true;\n-\t}\n+        {\n+          *__i.second = __o(*__i.first);\n+          return true;\n+        }\n     };\n \n   /** @brief std::transform() __selector, two input sequences variant. */\n@@ -123,10 +123,10 @@ namespace __gnu_parallel\n       template<typename _Op>\n         bool\n         operator()(_Op& __o, _It __i)\n-\t{\n-\t  *__i._M_third = __o(*__i._M_first, *__i._M_second);\n-\t  return true;\n-\t}\n+        {\n+          *__i._M_third = __o(*__i._M_first, *__i._M_second);\n+          return true;\n+        }\n     };\n \n   /** @brief std::replace() selector. */\n@@ -147,9 +147,9 @@ namespace __gnu_parallel\n       bool\n       operator()(_Tp& __v, _It __i)\n       {\n-\tif (*__i == __v)\n-\t  *__i = __new_val;\n-\treturn true;\n+        if (*__i == __v)\n+          *__i = __new_val;\n+        return true;\n       }\n     };\n \n@@ -171,9 +171,9 @@ namespace __gnu_parallel\n       bool\n       operator()(_Op& __o, _It __i)\n       {\n-\tif (__o(*__i))\n-\t  *__i = __new_val;\n-\treturn true;\n+        if (__o(*__i))\n+          *__i = __new_val;\n+        return true;\n       }\n     };\n \n@@ -188,7 +188,7 @@ namespace __gnu_parallel\n       template<typename Val>\n         _Diff\n         operator()(Val& __v, _It __i)\n-\t{ return (__v == *__i) ? 1 : 0; }\n+        { return (__v == *__i) ? 1 : 0; }\n     };\n \n   /** @brief std::count_if () selector. */\n@@ -202,7 +202,7 @@ namespace __gnu_parallel\n       template<typename _Op>\n         _Diff\n         operator()(_Op& __o, _It __i)\n-\t{ return (__o(*__i)) ? 1 : 0; }\n+        { return (__o(*__i)) ? 1 : 0; }\n     };\n \n   /** @brief std::accumulate() selector. */\n@@ -214,8 +214,9 @@ namespace __gnu_parallel\n        *  @param __i iterator referencing object.\n        *  @return The current value. */\n       template<typename _Op>\n-        typename std::iterator_traits<_It>::value_type operator()(_Op __o, _It __i)\n-\t{ return *__i; }\n+        typename std::iterator_traits<_It>::value_type\n+        operator()(_Op __o, _It __i)\n+        { return *__i; }\n     };\n \n   /** @brief std::inner_product() selector. */\n@@ -242,11 +243,11 @@ namespace __gnu_parallel\n       template<typename _Op>\n         _Tp\n         operator()(_Op __mult, _It __current)\n-\t{\n-\t  typename std::iterator_traits<_It>::difference_type __position\n-\t    = __current - __begin1_iterator;\n-\t  return __mult(*__current, *(begin2_iterator + __position));\n-\t}\n+        {\n+          typename std::iterator_traits<_It>::difference_type __position\n+            = __current - __begin1_iterator;\n+          return __mult(*__current, *(begin2_iterator + __position));\n+        }\n     };\n \n   /** @brief Selector that just returns the passed iterator. */\n@@ -260,24 +261,25 @@ namespace __gnu_parallel\n       template<typename _Op>\n         _It\n         operator()(_Op __o, _It __i)\n-\t{ return __i; }\n+        { return __i; }\n     };\n \n   /** @brief Selector that returns the difference between two adjacent\n    *  __elements.\n    */\n   template<typename _It>\n-    struct __adjacent_difference_selector : public __generic_for_each_selector<_It>\n+    struct __adjacent_difference_selector :\n+           public __generic_for_each_selector<_It>\n     {\n       template<typename _Op>\n         bool\n         operator()(_Op& __o, _It __i)\n-\t{\n-\t  typename _It::first_type __go_back_one = __i.first;\n-\t  --__go_back_one;\n-\t  *__i.__second = __o(*__i.__first, *__go_back_one);\n-\t  return true;\n-\t}\n+        {\n+          typename _It::first_type __go_back_one = __i.first;\n+          --__go_back_one;\n+          *__i.__second = __o(*__i.__first, *__go_back_one);\n+          return true;\n+        }\n     };\n \n   // XXX move into type_traits?\n@@ -315,10 +317,10 @@ namespace __gnu_parallel\n       _It\n       operator()(_It __x, _It __y)\n       {\n-\tif (__comp(*__x, *__y))\n-\t  return __x;\n-\telse\n-\t  return __y;\n+        if (__comp(*__x, *__y))\n+          return __x;\n+        else\n+          return __y;\n       }\n     };\n \n@@ -334,10 +336,10 @@ namespace __gnu_parallel\n       _It\n       operator()(_It __x, _It __y)\n       {\n-\tif (__comp(*__x, *__y))\n-\t  return __y;\n-\telse\n-\t  return __x;\n+        if (__comp(*__x, *__y))\n+          return __y;\n+        else\n+          return __x;\n       }\n     };\n \n@@ -353,7 +355,7 @@ namespace __gnu_parallel\n       template<typename _Result, typename _Addend>\n         _Result\n         operator()(const _Result& __x, const _Addend& __y)\n-\t{ return __binop(__x, __y); }\n+        { return __binop(__x, __y); }\n     };\n }\n "}, {"sha": "013855076f408f4666606cf2a1287815e1a6e7e2", "filename": "libstdc++-v3/include/parallel/iterator.h", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -40,7 +40,8 @@ namespace __gnu_parallel\n   /** @brief A pair of iterators. The usual iterator operations are\n    *  applied to both child iterators.\n    */\n-  template<typename _Iterator1, typename _Iterator2, typename _IteratorCategory>\n+  template<typename _Iterator1, typename _Iterator2,\n+           typename _IteratorCategory>\n     class _IteratorPair : public std::pair<_Iterator1, _Iterator2>\n     {\n     private:\n@@ -57,16 +58,16 @@ namespace __gnu_parallel\n \n       _IteratorPair() { }\n \n-      _IteratorPair(const _Iterator1& __first, const _Iterator2& __second) \n+      _IteratorPair(const _Iterator1& __first, const _Iterator2& __second)\n       : _Base(__first, __second) { }\n \n       // Pre-increment operator.\n       _IteratorPair&\n       operator++()\n       {\n-\t++_Base::first;\n-\t++_Base::second;\n-\treturn *this;\n+        ++_Base::first;\n+        ++_Base::second;\n+        return *this;\n       }\n \n       // Post-increment operator.\n@@ -78,9 +79,9 @@ namespace __gnu_parallel\n       _IteratorPair&\n       operator--()\n       {\n-\t--_Base::first;\n-\t--_Base::second;\n-\treturn *this;\n+        --_Base::first;\n+        --_Base::second;\n+        return *this;\n       }\n \n       // Post-decrement operator.\n@@ -95,14 +96,15 @@ namespace __gnu_parallel\n       _IteratorPair&\n       operator=(const _IteratorPair& __other)\n       {\n-\t_Base::first = __other.first;\n-\t_Base::second = __other.second;\n-\treturn *this;\n+        _Base::first = __other.first;\n+        _Base::second = __other.second;\n+        return *this;\n       }\n \n       _IteratorPair\n       operator+(difference_type __delta) const\n-      { return _IteratorPair(_Base::first + __delta, _Base::second + __delta); }\n+      { return _IteratorPair(_Base::first + __delta, _Base::second + __delta);\n+        }\n \n       difference_type\n       operator-(const _IteratorPair& __other) const\n@@ -114,7 +116,7 @@ namespace __gnu_parallel\n       applied to all three child iterators.\n    */\n   template<typename _Iterator1, typename _Iterator2, typename _Iterator3,\n-\t   typename _IteratorCategory>\n+           typename _IteratorCategory>\n     class _IteratorTriple\n     {\n     public:\n@@ -132,21 +134,21 @@ namespace __gnu_parallel\n       _IteratorTriple() { }\n \n       _IteratorTriple(const _Iterator1& __first, const _Iterator2& __second,\n-\t\t      const _Iterator3& __third)\n+                      const _Iterator3& __third)\n       {\n-\t_M_first = __first;\n-\t_M_second = __second;\n-\t_M_third = __third;\n+        _M_first = __first;\n+        _M_second = __second;\n+        _M_third = __third;\n       }\n \n       // Pre-increment operator.\n       _IteratorTriple&\n       operator++()\n       {\n-\t++_M_first;\n-\t++_M_second;\n-\t++_M_third;\n-\treturn *this;\n+        ++_M_first;\n+        ++_M_second;\n+        ++_M_third;\n+        return *this;\n       }\n \n       // Post-increment operator.\n@@ -158,10 +160,10 @@ namespace __gnu_parallel\n       _IteratorTriple&\n       operator--()\n       {\n-\t--_M_first;\n-\t--_M_second;\n-\t--_M_third;\n-\treturn *this;\n+        --_M_first;\n+        --_M_second;\n+        --_M_third;\n+        return *this;\n       }\n \n       // Post-decrement operator.\n@@ -176,15 +178,16 @@ namespace __gnu_parallel\n       _IteratorTriple&\n       operator=(const _IteratorTriple& __other)\n       {\n-\t_M_first = __other._M_first;\n-\t_M_second = __other._M_second;\n-\t_M_third = __other._M_third;\n-\treturn *this;\n+        _M_first = __other._M_first;\n+        _M_second = __other._M_second;\n+        _M_third = __other._M_third;\n+        return *this;\n       }\n \n       _IteratorTriple\n       operator+(difference_type __delta) const\n-      { return _IteratorTriple(_M_first + __delta, _M_second + __delta, _M_third + __delta); }\n+      { return _IteratorTriple(_M_first + __delta, _M_second + __delta,\n+                               _M_third + __delta); }\n \n       difference_type\n       operator-(const _IteratorTriple& __other) const"}, {"sha": "7eed96b4a0d8930493cb8088d2c9373bd5f8487e", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -48,17 +48,17 @@ namespace __gnu_parallel\n   template<typename _IIter>\n     void\n     __shrink_and_double(std::vector<_IIter>& __os_starts,\n-\t\t      size_t& __count_to_two, size_t& __range_length,\n-\t\t      const bool __make_twice)\n+                      size_t& __count_to_two, size_t& __range_length,\n+                      const bool __make_twice)\n     {\n       ++__count_to_two;\n       if (not __make_twice or __count_to_two < 2)\n-\t__shrink(__os_starts, __count_to_two, __range_length);\n+        __shrink(__os_starts, __count_to_two, __range_length);\n       else\n-\t{\n-\t  __os_starts.resize((__os_starts.size() - 1) * 2 + 1);\n-\t  __count_to_two = 0;\n-\t}\n+        {\n+          __os_starts.resize((__os_starts.size() - 1) * 2 + 1);\n+          __count_to_two = 0;\n+        }\n     }\n \n   /** @brief Combines two ranges into one and thus halves the number of ranges.\n@@ -68,11 +68,11 @@ namespace __gnu_parallel\n   template<typename _IIter>\n     void\n     __shrink(std::vector<_IIter>& __os_starts, size_t& __count_to_two,\n-\t   size_t& __range_length)\n+           size_t& __range_length)\n     {\n       for (typename std::vector<_IIter>::size_type __i = 0;\n-\t   __i <= (__os_starts.size() / 2); ++__i)\n-\t__os_starts[__i] = __os_starts[__i * 2];\n+           __i <= (__os_starts.size() / 2); ++__i)\n+        __os_starts[__i] = __os_starts[__i * 2];\n       __range_length *= 2;\n     }\n \n@@ -98,17 +98,17 @@ namespace __gnu_parallel\n   template<typename _IIter, typename _FunctorType>\n     size_t\n     list_partition(const _IIter __begin, const _IIter __end,\n-\t\t   _IIter* __starts, size_t* __lengths, const int __num_parts,\n-\t\t   _FunctorType& __f, int __oversampling = 0)\n+                   _IIter* __starts, size_t* __lengths, const int __num_parts,\n+                   _FunctorType& __f, int __oversampling = 0)\n     {\n       bool __make_twice = false;\n \n       // The resizing algorithm is chosen according to the oversampling factor.\n       if (__oversampling == 0)\n-\t{\n-\t  __make_twice = true;\n-\t  __oversampling = 1;\n-\t}\n+        {\n+          __make_twice = true;\n+          __oversampling = 1;\n+        }\n \n       std::vector<_IIter> __os_starts(2 * __oversampling * __num_parts + 1);\n \n@@ -119,27 +119,28 @@ namespace __gnu_parallel\n       size_t __range_length = 1;\n       size_t __count_to_two = 0;\n       while (__it != __end)\n-\t{\n-\t  __cur = __next;\n-\t  for (; __cur < __os_starts.size() and __it != __end; ++__cur)\n-\t    {\n-\t      for (__dist_limit += __range_length;\n-\t\t   __dist < __dist_limit and __it != __end; ++__dist)\n-\t\t{\n-\t\t  __f(__it);\n-\t\t  ++__it;\n-\t\t}\n-\t      __os_starts[__cur] = __it;\n-\t    }\n-\n-\t  // Must compare for end and not __cur < __os_starts.size() , because\n-\t  // __cur could be == __os_starts.size() as well\n-\t  if (__it == __end)\n-\t    break;\n-\n-\t  __shrink_and_double(__os_starts, __count_to_two, __range_length, __make_twice);\n-\t  __next = __os_starts.size() / 2 + 1;\n-\t}\n+        {\n+          __cur = __next;\n+          for (; __cur < __os_starts.size() and __it != __end; ++__cur)\n+            {\n+              for (__dist_limit += __range_length;\n+                   __dist < __dist_limit and __it != __end; ++__dist)\n+                {\n+                  __f(__it);\n+                  ++__it;\n+                }\n+              __os_starts[__cur] = __it;\n+            }\n+\n+          // Must compare for end and not __cur < __os_starts.size() , because\n+          // __cur could be == __os_starts.size() as well\n+          if (__it == __end)\n+            break;\n+\n+          __shrink_and_double(__os_starts, __count_to_two, __range_length,\n+                              __make_twice);\n+          __next = __os_starts.size() / 2 + 1;\n+        }\n \n       // Calculation of the parts (one must be extracted from __current\n       // because the partition beginning at __end, consists only of\n@@ -152,19 +153,20 @@ namespace __gnu_parallel\n \n       // Smallest partitions.\n       for (int __i = 1; __i < (__num_parts + 1 - __size_greater); ++__i)\n-\t{\n-\t  __lengths[__i - 1] =  __size_part * __range_length;\n-\t  __index += __size_part;\n-\t  __starts[__i] = __os_starts[__index];\n-\t}\n+        {\n+          __lengths[__i - 1] =  __size_part * __range_length;\n+          __index += __size_part;\n+          __starts[__i] = __os_starts[__index];\n+        }\n \n       // Biggest partitions.\n-      for (int __i = __num_parts + 1 - __size_greater; __i <= __num_parts; ++__i)\n-\t{\n-\t  __lengths[__i - 1] =  (__size_part+1) * __range_length;\n-\t  __index += (__size_part+1);\n-\t  __starts[__i] = __os_starts[__index];\n-\t}\n+      for (int __i = __num_parts + 1 - __size_greater; __i <= __num_parts;\n+           ++__i)\n+        {\n+          __lengths[__i - 1] =  (__size_part+1) * __range_length;\n+          __index += (__size_part+1);\n+          __starts[__i] = __os_starts[__index];\n+        }\n \n       // Correction of the end size (the end iteration has not finished).\n       __lengths[__num_parts - 1] -= (__dist_limit - __dist);"}, {"sha": "239aac8c057626c4ccf59d102d0e44f5be21cadf", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -106,7 +106,8 @@ class _LoserTreeBase\n     _M_offset = _M_k;\n \n     // Avoid default-constructing _M_losers[]._M_key\n-    _M_losers = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n+    _M_losers\n+        = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n     for (unsigned int __i = _M_ik - 1; __i < _M_k; ++__i)\n       _M_losers[__i + _M_k]._M_sup = true;\n \n@@ -187,7 +188,7 @@ class _LoserTree : public _LoserTreeBase<_Tp, _Compare>\n         unsigned int __right = __init_winner (2 * __root + 1);\n         if (_M_losers[__right]._M_sup\n             || (!_M_losers[__left]._M_sup\n-              && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n+             && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n           {\n             // Left one is less or equal.\n             _M_losers[__root] = _M_losers[__right];\n@@ -223,7 +224,8 @@ class _LoserTree : public _LoserTreeBase<_Tp, _Compare>\n     for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n-        if ((_M_sup && (!_M_losers[__pos]._M_sup || _M_losers[__pos]._M_source < _M_source))\n+        if ((_M_sup && (!_M_losers[__pos]._M_sup\n+                || _M_losers[__pos]._M_source < _M_source))\n               || (!_M_sup && !_M_losers[__pos]._M_sup\n                 && ((_M_comp(_M_losers[__pos]._M_key, _M_key))\n                   || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n@@ -280,9 +282,9 @@ class _LoserTree</* __stable == */false, _Tp, _Compare> :\n       {\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n-        if (_M_losers[__right]._M_sup ||\n-            (!_M_losers[__left]._M_sup\n-              && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n+        if (_M_losers[__right]._M_sup\n+           || (!_M_losers[__left]._M_sup\n+             && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n           {\n             // Left one is less or equal.\n             _M_losers[__root] = _M_losers[__right];\n@@ -320,7 +322,8 @@ class _LoserTree</* __stable == */false, _Tp, _Compare> :\n     for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n     {\n         // The smaller one gets promoted.\n-      if (_M_sup || (!_M_losers[__pos]._M_sup && _M_comp(_M_losers[__pos]._M_key, _M_key)))\n+      if (_M_sup || (!_M_losers[__pos]._M_sup\n+                     && _M_comp(_M_losers[__pos]._M_key, _M_key)))\n       {\n             // The other one is smaller.\n         std::swap(_M_losers[__pos]._M_sup, _M_sup);\n@@ -414,8 +417,9 @@ class _LoserTreePointer : public _LoserTreePointerBase<_Tp, _Compare>\n         unsigned int __left = __init_winner (2 * __root);\n         unsigned int __right = __init_winner (2 * __root + 1);\n         if (_M_losers[__right]._M_sup\n-            || (!_M_losers[__left]._M_sup && !_M_comp(*_M_losers[__right]._M_keyp,\n-                                          *_M_losers[__left]._M_keyp)))\n+            || (!_M_losers[__left]._M_sup\n+                && !_M_comp(*_M_losers[__right]._M_keyp,\n+                            *_M_losers[__left]._M_keyp)))\n           {\n             // Left one is less or equal.\n             _M_losers[__root] = _M_losers[__right];\n@@ -445,7 +449,8 @@ class _LoserTreePointer : public _LoserTreePointerBase<_Tp, _Compare>\n     for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n-        if ((_M_sup && (!_M_losers[__pos]._M_sup || _M_losers[__pos]._M_source < _M_source)) ||\n+        if ((_M_sup && (!_M_losers[__pos]._M_sup ||\n+                _M_losers[__pos]._M_source < _M_source)) ||\n               (!_M_sup && !_M_losers[__pos]._M_sup &&\n               ((_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)) ||\n                 (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n@@ -495,7 +500,8 @@ class _LoserTreePointer</* __stable == */false, _Tp, _Compare> :\n         unsigned int __right = __init_winner (2 * __root + 1);\n         if (_M_losers[__right]._M_sup\n               || (!_M_losers[__left]._M_sup\n-                && !_M_comp(*_M_losers[__right]._M_keyp, *_M_losers[__left]._M_keyp)))\n+                && !_M_comp(*_M_losers[__right]._M_keyp,\n+                            *_M_losers[__left]._M_keyp)))\n           {\n             // Left one is less or equal.\n             _M_losers[__root] = _M_losers[__right];\n@@ -525,7 +531,8 @@ class _LoserTreePointer</* __stable == */false, _Tp, _Compare> :\n     for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (_M_sup || (!_M_losers[__pos]._M_sup && _M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)))\n+        if (_M_sup || (!_M_losers[__pos]._M_sup\n+                       && _M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)))\n           {\n             // The other one is smaller.\n             std::swap(_M_losers[__pos]._M_sup, _M_sup);\n@@ -576,7 +583,8 @@ class _LoserTreeUnguardedBase\n     _M_k = 1 << (__log2(_M_ik - 1) + 1);\n     _M_offset = _M_k;\n     // Avoid default-constructing _M_losers[]._M_key\n-    _M_losers = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n+    _M_losers\n+        = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n \n     for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n       {\n@@ -677,7 +685,8 @@ class _LoserTreeUnguarded : public _LoserTreeUnguardedBase<_Tp, _Compare>\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n         if (_M_comp(_M_losers[__pos]._M_key, _M_key)\n-              || (!_M_comp(_M_key, _M_losers[__pos]._M_key) && _M_losers[__pos]._M_source < _M_source))\n+              || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n+                  && _M_losers[__pos]._M_source < _M_source))\n           {\n             // The other one is smaller.\n             std::swap(_M_losers[__pos]._M_source, _M_source);\n@@ -914,7 +923,8 @@ class LoserTreePointerUnguarded :\n       {\n         // The smaller one gets promoted, ties are broken by _M_source.\n         if (_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)\n-          || (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp) && _M_losers[__pos]._M_source < _M_source))\n+          || (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n+              && _M_losers[__pos]._M_source < _M_source))\n           {\n             // The other one is smaller.\n             std::swap(_M_losers[__pos]._M_source, _M_source);"}, {"sha": "b2d8996ae5a3765b21a1b83838aadebe4fcb6257", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -51,36 +51,36 @@ namespace __gnu_parallel\n    * @param __comp Comparator.\n    * @return Output end iterator. */\n   template<typename _RAIter1, typename _RAIter2,\n-\t   typename _OutputIterator, typename _DifferenceTp,\n-\t   typename _Compare>\n+           typename _OutputIterator, typename _DifferenceTp,\n+           typename _Compare>\n     _OutputIterator\n     __merge_advance_usual(_RAIter1& __begin1,\n-\t\t\t_RAIter1 __end1,\n-\t\t\t_RAIter2& __begin2,\n-\t\t\t_RAIter2 __end2, _OutputIterator __target,\n-\t\t\t_DifferenceTp __max_length, _Compare __comp)\n+                        _RAIter1 __end1,\n+                        _RAIter2& __begin2,\n+                        _RAIter2 __end2, _OutputIterator __target,\n+                        _DifferenceTp __max_length, _Compare __comp)\n     {\n       typedef _DifferenceTp _DifferenceType;\n       while (__begin1 != __end1 && __begin2 != __end2 && __max_length > 0)\n-\t{\n-\t  // array1[__i1] < array0[i0]\n-\t  if (__comp(*__begin2, *__begin1))\n-\t    *__target++ = *__begin2++;\n-\t  else\n-\t    *__target++ = *__begin1++;\n-\t  --__max_length;\n-\t}\n+        {\n+          // array1[__i1] < array0[i0]\n+          if (__comp(*__begin2, *__begin1))\n+            *__target++ = *__begin2++;\n+          else\n+            *__target++ = *__begin1++;\n+          --__max_length;\n+        }\n \n       if (__begin1 != __end1)\n-\t{\n-\t  __target = std::copy(__begin1, __begin1 + __max_length, __target);\n-\t  __begin1 += __max_length;\n-\t}\n+        {\n+          __target = std::copy(__begin1, __begin1 + __max_length, __target);\n+          __begin1 += __max_length;\n+        }\n       else\n-\t{\n-\t  __target = std::copy(__begin2, __begin2 + __max_length, __target);\n-\t  __begin2 += __max_length;\n-\t}\n+        {\n+          __target = std::copy(__begin2, __begin2 + __max_length, __target);\n+          __begin2 += __max_length;\n+        }\n       return __target;\n     }\n \n@@ -100,56 +100,56 @@ namespace __gnu_parallel\n    * @param __comp Comparator.\n    * @return Output end iterator. */\n   template<typename _RAIter1, typename _RAIter2,\n-\t   typename _OutputIterator, typename _DifferenceTp,\n-\t   typename _Compare>\n+           typename _OutputIterator, typename _DifferenceTp,\n+           typename _Compare>\n     _OutputIterator\n     __merge_advance_movc(_RAIter1& __begin1,\n-\t\t       _RAIter1 __end1,\n-\t\t       _RAIter2& __begin2,\n-\t\t       _RAIter2 __end2,\n-\t\t       _OutputIterator __target,\n-\t\t       _DifferenceTp __max_length, _Compare __comp)\n+                       _RAIter1 __end1,\n+                       _RAIter2& __begin2,\n+                       _RAIter2 __end2,\n+                       _OutputIterator __target,\n+                       _DifferenceTp __max_length, _Compare __comp)\n     {\n       typedef _DifferenceTp _DifferenceType;\n       typedef typename std::iterator_traits<_RAIter1>::value_type\n-\tvalue_type1;\n+        value_type1;\n       typedef typename std::iterator_traits<_RAIter2>::value_type\n-\tvalue_type2;\n+        value_type2;\n \n #if _GLIBCXX_ASSERTIONS\n       _GLIBCXX_PARALLEL_ASSERT(__max_length >= 0);\n #endif\n \n       while (__begin1 != __end1 && __begin2 != __end2 && __max_length > 0)\n-\t{\n-\t  _RAIter1 __next1 = __begin1 + 1;\n-\t  _RAIter2 __next2 = __begin2 + 1;\n-\t  value_type1 __element1 = *__begin1;\n-\t  value_type2 __element2 = *__begin2;\n+        {\n+          _RAIter1 __next1 = __begin1 + 1;\n+          _RAIter2 __next2 = __begin2 + 1;\n+          value_type1 __element1 = *__begin1;\n+          value_type2 __element2 = *__begin2;\n \n-\t  if (__comp(__element2, __element1))\n-\t    {\n-\t      __element1 = __element2;\n-\t      __begin2 = __next2;\n-\t    }\n-\t  else\n-\t    __begin1 = __next1;\n+          if (__comp(__element2, __element1))\n+            {\n+              __element1 = __element2;\n+              __begin2 = __next2;\n+            }\n+          else\n+            __begin1 = __next1;\n \n-\t  *__target = __element1;\n+          *__target = __element1;\n \n-\t  ++__target;\n-\t  --__max_length;\n-\t}\n+          ++__target;\n+          --__max_length;\n+        }\n       if (__begin1 != __end1)\n-\t{\n-\t  __target = std::copy(__begin1, __begin1 + __max_length, __target);\n-\t  __begin1 += __max_length;\n-\t}\n+        {\n+          __target = std::copy(__begin1, __begin1 + __max_length, __target);\n+          __begin1 += __max_length;\n+        }\n       else\n-\t{\n-\t  __target = std::copy(__begin2, __begin2 + __max_length, __target);\n-\t  __begin2 += __max_length;\n-\t}\n+        {\n+          __target = std::copy(__begin2, __begin2 + __max_length, __target);\n+          __begin2 += __max_length;\n+        }\n       return __target;\n     }\n \n@@ -168,18 +168,18 @@ namespace __gnu_parallel\n    *  @param __comp Comparator.\n    *  @return Output end iterator. */\n   template<typename _RAIter1, typename _RAIter2,\n-\t   typename _OutputIterator, typename _DifferenceTp,\n-\t   typename _Compare>\n+           typename _OutputIterator, typename _DifferenceTp,\n+           typename _Compare>\n     inline _OutputIterator\n     __merge_advance(_RAIter1& __begin1, _RAIter1 __end1,\n-\t\t  _RAIter2& __begin2, _RAIter2 __end2,\n-\t\t  _OutputIterator __target, _DifferenceTp __max_length,\n-\t\t  _Compare __comp)\n+                  _RAIter2& __begin2, _RAIter2 __end2,\n+                  _OutputIterator __target, _DifferenceTp __max_length,\n+                  _Compare __comp)\n     {\n       _GLIBCXX_CALL(__max_length)\n \n       return __merge_advance_movc(__begin1, __end1, __begin2, __end2, __target,\n-\t\t\t\t__max_length, __comp);\n+                                __max_length, __comp);\n     }\n \n   /** @brief Merge routine fallback to sequential in case the\n@@ -193,19 +193,19 @@ namespace __gnu_parallel\n       *  @param __comp Comparator.\n       *  @return Output end iterator. */\n   template<typename _RAIter1, typename _RAIter2,\n-\t   typename _RAIter3, typename _Compare>\n+           typename _RAIter3, typename _Compare>\n     inline _RAIter3\n     __parallel_merge_advance(_RAIter1& __begin1,\n-\t\t\t   _RAIter1 __end1,\n-\t\t\t   _RAIter2& __begin2,\n-\t\t\t   // different iterators, parallel implementation\n-\t\t\t   // not available\t\t\t   \n-\t\t\t   _RAIter2 __end2,\n-\t\t\t   _RAIter3 __target, typename\n-\t\t\t   std::iterator_traits<_RAIter1>::\n-\t\t\t   difference_type __max_length, _Compare __comp)\n+                           _RAIter1 __end1,\n+                           _RAIter2& __begin2,\n+                           // different iterators, parallel implementation\n+                           // not available                        \n+                           _RAIter2 __end2,\n+                           _RAIter3 __target, typename\n+                           std::iterator_traits<_RAIter1>::\n+                           difference_type __max_length, _Compare __comp)\n     { return __merge_advance(__begin1, __end1, __begin2, __end2, __target,\n-\t\t\t   __max_length, __comp); }\n+                           __max_length, __comp); }\n \n   /** @brief Parallel merge routine being able to merge only the @__c\n    * __max_length smallest elements.\n@@ -223,28 +223,28 @@ namespace __gnu_parallel\n    *  @return Output end iterator.\n    */\n   template<typename _RAIter1, typename _RAIter3,\n-\t   typename _Compare>\n+           typename _Compare>\n     inline _RAIter3\n     __parallel_merge_advance(_RAIter1& __begin1,\n-\t\t\t   _RAIter1 __end1,\n-\t\t\t   _RAIter1& __begin2,\n-\t\t\t   _RAIter1 __end2,\n-\t\t\t   _RAIter3 __target, typename\n-\t\t\t   std::iterator_traits<_RAIter1>::\n-\t\t\t   difference_type __max_length, _Compare __comp)\n+                           _RAIter1 __end1,\n+                           _RAIter1& __begin2,\n+                           _RAIter1 __end2,\n+                           _RAIter3 __target, typename\n+                           std::iterator_traits<_RAIter1>::\n+                           difference_type __max_length, _Compare __comp)\n     {\n       typedef typename\n           std::iterator_traits<_RAIter1>::value_type _ValueType;\n       typedef typename std::iterator_traits<_RAIter1>::\n-\tdifference_type _DifferenceType1 /* == difference_type2 */;\n+        difference_type _DifferenceType1 /* == difference_type2 */;\n       typedef typename std::iterator_traits<_RAIter3>::\n-\tdifference_type _DifferenceType3;\n+        difference_type _DifferenceType3;\n       typedef typename std::pair<_RAIter1, _RAIter1>\n         _IteratorPair;\n \n       _IteratorPair\n-\tseqs[2] = { std::make_pair(__begin1, __end1),\n-\t\t    std::make_pair(__begin2, __end2) };\n+        seqs[2] = { std::make_pair(__begin1, __end1),\n+                    std::make_pair(__begin2, __end2) };\n       _RAIter3\n         __target_end = parallel_multiway_merge\n           < /* __stable = */ true, /* __sentinels = */ false>(\n@@ -256,6 +256,6 @@ namespace __gnu_parallel\n \n       return __target_end;\n     }\n-}\t//namespace __gnu_parallel\n+}       //namespace __gnu_parallel\n \n #endif /* _GLIBCXX_PARALLEL_MERGE_H */"}, {"sha": "539695fc7666425067f342bdd36d87304da68cc4", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 332, "deletions": 315, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -53,7 +53,8 @@ namespace __gnu_parallel\n   /** @brief Compare __a pair of types lexicographically, ascending. */\n   template<typename _T1, typename _T2, typename _Compare>\n     class _Lexicographic\n-    : public std::binary_function<std::pair<_T1, _T2>, std::pair<_T1, _T2>, bool>\n+    : public std::binary_function<\n+                                std::pair<_T1, _T2>, std::pair<_T1, _T2>, bool>\n     {\n     private:\n       _Compare& _M_comp;\n@@ -63,16 +64,16 @@ namespace __gnu_parallel\n \n       bool\n       operator()(const std::pair<_T1, _T2>& __p1,\n-\t\t const std::pair<_T1, _T2>& __p2) const\n+                 const std::pair<_T1, _T2>& __p2) const\n       {\n-\tif (_M_comp(__p1.first, __p2.first))\n-\t  return true;\n+        if (_M_comp(__p1.first, __p2.first))\n+          return true;\n \n-\tif (_M_comp(__p2.first, __p1.first))\n-\t  return false;\n+        if (_M_comp(__p2.first, __p1.first))\n+          return false;\n \n-\t// Firsts are equal.\n-\treturn __p1.second < __p2.second;\n+        // Firsts are equal.\n+        return __p1.second < __p2.second;\n       }\n     };\n \n@@ -88,16 +89,16 @@ namespace __gnu_parallel\n \n       bool\n       operator()(const std::pair<_T1, _T2>& __p1,\n-\t\t const std::pair<_T1, _T2>& __p2) const\n+                 const std::pair<_T1, _T2>& __p2) const\n       {\n-\tif (_M_comp(__p2.first, __p1.first))\n-\t  return true;\n+        if (_M_comp(__p2.first, __p1.first))\n+          return true;\n \n-\tif (_M_comp(__p1.first, __p2.first))\n-\t  return false;\n+        if (_M_comp(__p1.first, __p2.first))\n+          return false;\n \n-\t// Firsts are equal.\n-\treturn __p2.second < __p1.second;\n+        // Firsts are equal.\n+        return __p2.second < __p1.second;\n       }\n     };\n \n@@ -133,7 +134,7 @@ namespace __gnu_parallel\n       typedef typename std::iterator_traits<_RanSeqs>::value_type::first_type\n         _It;\n       typedef typename std::iterator_traits<_It>::difference_type\n-\t       _DifferenceType;\n+               _DifferenceType;\n       typedef typename std::iterator_traits<_It>::value_type _ValueType;\n \n       _Lexicographic<_ValueType, int, _Compare> __lcomp(__comp);\n@@ -146,9 +147,11 @@ namespace __gnu_parallel\n \n       for (int __i = 0; __i < __m; __i++)\n         {\n-          __N += std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n+          __N += std::distance(__begin_seqs[__i].first,\n+                               __begin_seqs[__i].second);\n           _GLIBCXX_PARALLEL_ASSERT(\n-            std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second) > 0);\n+            std::distance(__begin_seqs[__i].first,\n+                          __begin_seqs[__i].second) > 0);\n         }\n \n       if (__rank == __N)\n@@ -172,10 +175,11 @@ namespace __gnu_parallel\n       __ns[0] = std::distance(__begin_seqs[0].first, __begin_seqs[0].second);\n       __nmax = __ns[0];\n       for (int __i = 0; __i < __m; __i++)\n-\t{\n-\t  __ns[__i] = std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n-\t  __nmax = std::max(__nmax, __ns[__i]);\n-\t}\n+        {\n+          __ns[__i] = std::distance(__begin_seqs[__i].first,\n+                                    __begin_seqs[__i].second);\n+          __nmax = std::max(__nmax, __ns[__i]);\n+        }\n \n       __r = __log2(__nmax) + 1;\n \n@@ -187,10 +191,10 @@ namespace __gnu_parallel\n       __N = __l * __m;\n \n       for (int __i = 0; __i < __m; __i++)\n-\t{\n-\t  __a[__i] = 0;\n-\t  __b[__i] = __l;\n-\t}\n+        {\n+          __a[__i] = 0;\n+          __b[__i] = __l;\n+        }\n       __n = __l / 2;\n \n       // Invariants:\n@@ -202,124 +206,128 @@ namespace __gnu_parallel\n       std::vector<std::pair<_ValueType, int> > __sample;\n \n       for (int __i = 0; __i < __m; __i++)\n-\tif (__n < __ns[__i])\t//__sequence long enough\n-\t  __sample.push_back(std::make_pair(__S(__i)[__n], __i));\n+        if (__n < __ns[__i])    //__sequence long enough\n+          __sample.push_back(std::make_pair(__S(__i)[__n], __i));\n       __gnu_sequential::sort(__sample.begin(), __sample.end(), __lcomp);\n \n-      for (int __i = 0; __i < __m; __i++)\t//conceptual infinity\n-\tif (__n >= __ns[__i])\t//__sequence too short, conceptual infinity\n-\t  __sample.push_back(std::make_pair(__S(__i)[0] /*__dummy element*/, __i));\n+      for (int __i = 0; __i < __m; __i++)       //conceptual infinity\n+        if (__n >= __ns[__i])   //__sequence too short, conceptual infinity\n+          __sample.push_back(\n+            std::make_pair(__S(__i)[0] /*__dummy element*/, __i));\n \n       _DifferenceType localrank = __rank * __m / __N ;\n \n       int __j;\n-      for (__j = 0; __j < localrank && ((__n + 1) <= __ns[__sample[__j].second]); ++__j)\n-\t__a[__sample[__j].second] += __n + 1;\n+      for (__j = 0;\n+           __j < localrank && ((__n + 1) <= __ns[__sample[__j].second]); ++__j)\n+        __a[__sample[__j].second] += __n + 1;\n       for (; __j < __m; __j++)\n-\t__b[__sample[__j].second] -= __n + 1;\n+        __b[__sample[__j].second] -= __n + 1;\n       \n       // Further refinement.\n       while (__n > 0)\n-\t{\n-\t  __n /= 2;\n-\n-\t  int __lmax_seq = -1;\t// to avoid warning\n-\t  const _ValueType* __lmax = NULL; // impossible to avoid the warning?\n-\t  for (int __i = 0; __i < __m; __i++)\n-\t    {\n-\t      if (__a[__i] > 0)\n-\t\t{\n-\t\t  if (!__lmax)\n-\t\t    {\n-\t\t      __lmax = &(__S(__i)[__a[__i] - 1]);\n-\t\t      __lmax_seq = __i;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      // Max, favor rear sequences.\n-\t\t      if (!__comp(__S(__i)[__a[__i] - 1], *__lmax))\n-\t\t\t{\n-\t\t\t  __lmax = &(__S(__i)[__a[__i] - 1]);\n-\t\t\t  __lmax_seq = __i;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  int __i;\n-\t  for (__i = 0; __i < __m; __i++)\n-\t    {\n-\t      _DifferenceType __middle = (__b[__i] + __a[__i]) / 2;\n-\t      if (__lmax && __middle < __ns[__i] &&\n-\t\t  __lcomp(std::make_pair(__S(__i)[__middle], __i),\n-\t\t\tstd::make_pair(*__lmax, __lmax_seq)))\n-\t\t__a[__i] = std::min(__a[__i] + __n + 1, __ns[__i]);\n-\t      else\n-\t\t__b[__i] -= __n + 1;\n-\t    }\n-\n-\t  _DifferenceType __leftsize = 0, __total = 0;\n-\t  for (int __i = 0; __i < __m; __i++)\n-\t    {\n-\t      __leftsize += __a[__i] / (__n + 1);\n-\t      __total += __l / (__n + 1);\n-\t    }\n-\t  \n-\t  _DifferenceType __skew = static_cast<_DifferenceType>\n-\t    (static_cast<uint64>(__total) * __rank / __N - __leftsize);\n-\n-\t  if (__skew > 0)\n-\t    {\n-\t      // Move to the left, find smallest.\n-\t      std::priority_queue<std::pair<_ValueType, int>,\n-\t\tstd::vector<std::pair<_ValueType, int> >,\n-\t\t_LexicographicReverse<_ValueType, int, _Compare> >\n-\t\t__pq(__lrcomp);\n-\t      \n-\t      for (int __i = 0; __i < __m; __i++)\n-\t\tif (__b[__i] < __ns[__i])\n-\t\t  __pq.push(std::make_pair(__S(__i)[__b[__i]], __i));\n-\n-\t      for (; __skew != 0 && !__pq.empty(); --__skew)\n-\t\t{\n-\t\t  int source = __pq.top().second;\n-\t\t  __pq.pop();\n-\n-\t\t  __a[source] = std::min(__a[source] + __n + 1, __ns[source]);\n-\t\t  __b[source] += __n + 1;\n-\n-\t\t  if (__b[source] < __ns[source])\n-\t\t    __pq.push(std::make_pair(__S(source)[__b[source]], source));\n-\t\t}\n-\t    }\n-\t  else if (__skew < 0)\n-\t    {\n-\t      // Move to the right, find greatest.\n-\t      std::priority_queue<std::pair<_ValueType, int>,\n-\t\tstd::vector<std::pair<_ValueType, int> >,\n-\t\t_Lexicographic<_ValueType, int, _Compare> > __pq(__lcomp);\n-\n-\t      for (int __i = 0; __i < __m; __i++)\n-\t\tif (__a[__i] > 0)\n-\t\t  __pq.push(std::make_pair(__S(__i)[__a[__i] - 1], __i));\n-\n-\t      for (; __skew != 0; ++__skew)\n-\t\t{\n-\t\t  int source = __pq.top().second;\n-\t\t  __pq.pop();\n-\n-\t\t  __a[source] -= __n + 1;\n-\t\t  __b[source] -= __n + 1;\n-\n-\t\t  if (__a[source] > 0)\n-\t\t    __pq.push(std::make_pair(__S(source)[__a[source] - 1], source));\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          __n /= 2;\n+\n+          int __lmax_seq = -1;  // to avoid warning\n+          const _ValueType* __lmax = NULL; // impossible to avoid the warning?\n+          for (int __i = 0; __i < __m; __i++)\n+            {\n+              if (__a[__i] > 0)\n+                {\n+                  if (!__lmax)\n+                    {\n+                      __lmax = &(__S(__i)[__a[__i] - 1]);\n+                      __lmax_seq = __i;\n+                    }\n+                  else\n+                    {\n+                      // Max, favor rear sequences.\n+                      if (!__comp(__S(__i)[__a[__i] - 1], *__lmax))\n+                        {\n+                          __lmax = &(__S(__i)[__a[__i] - 1]);\n+                          __lmax_seq = __i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+          int __i;\n+          for (__i = 0; __i < __m; __i++)\n+            {\n+              _DifferenceType __middle = (__b[__i] + __a[__i]) / 2;\n+              if (__lmax && __middle < __ns[__i] &&\n+                  __lcomp(std::make_pair(__S(__i)[__middle], __i),\n+                        std::make_pair(*__lmax, __lmax_seq)))\n+                __a[__i] = std::min(__a[__i] + __n + 1, __ns[__i]);\n+              else\n+                __b[__i] -= __n + 1;\n+            }\n+\n+          _DifferenceType __leftsize = 0, __total = 0;\n+          for (int __i = 0; __i < __m; __i++)\n+            {\n+              __leftsize += __a[__i] / (__n + 1);\n+              __total += __l / (__n + 1);\n+            }\n+          \n+          _DifferenceType __skew = static_cast<_DifferenceType>\n+            (static_cast<uint64>(__total) * __rank / __N - __leftsize);\n+\n+          if (__skew > 0)\n+            {\n+              // Move to the left, find smallest.\n+              std::priority_queue<std::pair<_ValueType, int>,\n+                std::vector<std::pair<_ValueType, int> >,\n+                _LexicographicReverse<_ValueType, int, _Compare> >\n+                __pq(__lrcomp);\n+              \n+              for (int __i = 0; __i < __m; __i++)\n+                if (__b[__i] < __ns[__i])\n+                  __pq.push(std::make_pair(__S(__i)[__b[__i]], __i));\n+\n+              for (; __skew != 0 && !__pq.empty(); --__skew)\n+                {\n+                  int source = __pq.top().second;\n+                  __pq.pop();\n+\n+                  __a[source] = std::min(__a[source] + __n + 1, __ns[source]);\n+                  __b[source] += __n + 1;\n+\n+                  if (__b[source] < __ns[source])\n+                    __pq.push(\n+                      std::make_pair(__S(source)[__b[source]], source));\n+                }\n+            }\n+          else if (__skew < 0)\n+            {\n+              // Move to the right, find greatest.\n+              std::priority_queue<std::pair<_ValueType, int>,\n+                std::vector<std::pair<_ValueType, int> >,\n+                _Lexicographic<_ValueType, int, _Compare> > __pq(__lcomp);\n+\n+              for (int __i = 0; __i < __m; __i++)\n+                if (__a[__i] > 0)\n+                  __pq.push(std::make_pair(__S(__i)[__a[__i] - 1], __i));\n+\n+              for (; __skew != 0; ++__skew)\n+                {\n+                  int source = __pq.top().second;\n+                  __pq.pop();\n+\n+                  __a[source] -= __n + 1;\n+                  __b[source] -= __n + 1;\n+\n+                  if (__a[source] > 0)\n+                    __pq.push(\n+                      std::make_pair(__S(source)[__a[source] - 1], source));\n+                }\n+            }\n+        }\n \n       // Postconditions:\n-      // __a[__i] == __b[__i] in most cases, except when __a[__i] has been clamped\n-      // because of having reached the boundary\n+      // __a[__i] == __b[__i] in most cases, except when __a[__i] has been\n+      // clamped because of having reached the boundary\n \n       // Now return the result, calculate the offset.\n \n@@ -329,34 +337,34 @@ namespace __gnu_parallel\n       _ValueType* __maxleft = NULL;\n       _ValueType* __minright = NULL;\n       for (int __i = 0; __i < __m; __i++)\n-\t{\n-\t  if (__a[__i] > 0)\n-\t    {\n-\t      if (!__maxleft)\n-\t\t__maxleft = &(__S(__i)[__a[__i] - 1]);\n-\t      else\n-\t\t{\n-\t\t  // Max, favor rear sequences.\n-\t\t  if (!__comp(__S(__i)[__a[__i] - 1], *__maxleft))\n-\t\t    __maxleft = &(__S(__i)[__a[__i] - 1]);\n-\t\t}\n-\t    }\n-\t  if (__b[__i] < __ns[__i])\n-\t    {\n-\t      if (!__minright)\n-\t\t__minright = &(__S(__i)[__b[__i]]);\n-\t      else\n-\t\t{\n-\t\t  // Min, favor fore sequences.\n-\t\t  if (__comp(__S(__i)[__b[__i]], *__minright))\n-\t\t    __minright = &(__S(__i)[__b[__i]]);\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          if (__a[__i] > 0)\n+            {\n+              if (!__maxleft)\n+                __maxleft = &(__S(__i)[__a[__i] - 1]);\n+              else\n+                {\n+                  // Max, favor rear sequences.\n+                  if (!__comp(__S(__i)[__a[__i] - 1], *__maxleft))\n+                    __maxleft = &(__S(__i)[__a[__i] - 1]);\n+                }\n+            }\n+          if (__b[__i] < __ns[__i])\n+            {\n+              if (!__minright)\n+                __minright = &(__S(__i)[__b[__i]]);\n+              else\n+                {\n+                  // Min, favor fore sequences.\n+                  if (__comp(__S(__i)[__b[__i]], *__minright))\n+                    __minright = &(__S(__i)[__b[__i]]);\n+                }\n+            }\n+        }\n \n       int __seq = 0;\n       for (int __i = 0; __i < __m; __i++)\n-\t__begin_offsets[__i] = __S(__i) + __a[__i];\n+        __begin_offsets[__i] = __S(__i) + __a[__i];\n \n       delete[] __ns;\n       delete[] __a;\n@@ -379,17 +387,18 @@ namespace __gnu_parallel\n    *  @param __comp The ordering functor, defaults to std::less. \n    */\n   template<typename _Tp, typename _RanSeqs, typename _RankType,\n-\t   typename _Compare>\n+           typename _Compare>\n     _Tp\n-    multiseq_selection(_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank,\n-\t\t       _RankType& __offset, _Compare __comp = std::less<_Tp>())\n+    multiseq_selection(_RanSeqs __begin_seqs, _RanSeqs __end_seqs,\n+                       _RankType __rank,\n+                       _RankType& __offset, _Compare __comp = std::less<_Tp>())\n     {\n       _GLIBCXX_CALL(__end_seqs - __begin_seqs)\n \n       typedef typename std::iterator_traits<_RanSeqs>::value_type::first_type\n-\t_It;\n+        _It;\n       typedef typename std::iterator_traits<_It>::difference_type\n-\t_DifferenceType;\n+        _DifferenceType;\n \n       _Lexicographic<_Tp, int, _Compare> __lcomp(__comp);\n       _LexicographicReverse<_Tp, int, _Compare> __lrcomp(__comp);\n@@ -401,13 +410,14 @@ namespace __gnu_parallel\n       _DifferenceType __nmax, __n, __r;\n \n       for (int __i = 0; __i < __m; __i++)\n-\t__N += std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n+        __N += std::distance(__begin_seqs[__i].first,\n+                             __begin_seqs[__i].second);\n \n       if (__m == 0 || __N == 0 || __rank < 0 || __rank >= __N)\n-\t{\n-\t  // _Result undefined when there is no data or __rank is outside bounds.\n-\t  throw std::exception();\n-\t}\n+        {\n+          // result undefined if there is no data or __rank is outside bounds\n+          throw std::exception();\n+        }\n \n \n       _DifferenceType* __ns = new _DifferenceType[__m];\n@@ -418,10 +428,11 @@ namespace __gnu_parallel\n       __ns[0] = std::distance(__begin_seqs[0].first, __begin_seqs[0].second);\n       __nmax = __ns[0];\n       for (int __i = 0; __i < __m; ++__i)\n-\t{\n-\t  __ns[__i] = std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n-\t  __nmax = std::max(__nmax, __ns[__i]);\n-\t}\n+        {\n+          __ns[__i] = std::distance(__begin_seqs[__i].first,\n+                                    __begin_seqs[__i].second);\n+          __nmax = std::max(__nmax, __ns[__i]);\n+        }\n \n       __r = __log2(__nmax) + 1;\n \n@@ -433,10 +444,10 @@ namespace __gnu_parallel\n       __N = __l * __m;\n \n       for (int __i = 0; __i < __m; ++__i)\n-\t{\n-\t  __a[__i] = 0;\n-\t  __b[__i] = __l;\n-\t}\n+        {\n+          __a[__i] = 0;\n+          __b[__i] = __l;\n+        }\n       __n = __l / 2;\n \n       // Invariants:\n@@ -448,115 +459,120 @@ namespace __gnu_parallel\n       std::vector<std::pair<_Tp, int> > __sample;\n \n       for (int __i = 0; __i < __m; __i++)\n-\tif (__n < __ns[__i])\n-\t  __sample.push_back(std::make_pair(__S(__i)[__n], __i));\n+        if (__n < __ns[__i])\n+          __sample.push_back(std::make_pair(__S(__i)[__n], __i));\n       __gnu_sequential::sort(__sample.begin(), __sample.end(),\n-\t\t\t     __lcomp, sequential_tag());\n+                             __lcomp, sequential_tag());\n \n       // Conceptual infinity.\n       for (int __i = 0; __i < __m; __i++)\n-\tif (__n >= __ns[__i])\n-\t  __sample.push_back(std::make_pair(__S(__i)[0] /*__dummy element*/, __i));\n+        if (__n >= __ns[__i])\n+          __sample.push_back(\n+            std::make_pair(__S(__i)[0] /*__dummy element*/, __i));\n \n       _DifferenceType localrank = __rank * __m / __N ;\n \n       int __j;\n-      for (__j = 0; __j < localrank && ((__n + 1) <= __ns[__sample[__j].second]); ++__j)\n-\t__a[__sample[__j].second] += __n + 1;\n+      for (__j = 0;\n+           __j < localrank && ((__n + 1) <= __ns[__sample[__j].second]); ++__j)\n+        __a[__sample[__j].second] += __n + 1;\n       for (; __j < __m; ++__j)\n-\t__b[__sample[__j].second] -= __n + 1;\n+        __b[__sample[__j].second] -= __n + 1;\n \n       // Further refinement.\n       while (__n > 0)\n-\t{\n-\t  __n /= 2;\n-\n-\t  const _Tp* __lmax = NULL;\n-\t  for (int __i = 0; __i < __m; ++__i)\n-\t    {\n-\t      if (__a[__i] > 0)\n-\t\t{\n-\t\t  if (!__lmax)\n-\t\t    __lmax = &(__S(__i)[__a[__i] - 1]);\n-\t\t  else\n-\t\t    {\n-\t\t      if (__comp(*__lmax, __S(__i)[__a[__i] - 1]))\t//max\n-\t\t\t__lmax = &(__S(__i)[__a[__i] - 1]);\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  int __i;\n-\t  for (__i = 0; __i < __m; __i++)\n-\t    {\n-\t      _DifferenceType __middle = (__b[__i] + __a[__i]) / 2;\n-\t      if (__lmax && __middle < __ns[__i] && __comp(__S(__i)[__middle], *__lmax))\n-\t\t__a[__i] = std::min(__a[__i] + __n + 1, __ns[__i]);\n-\t      else\n-\t\t__b[__i] -= __n + 1;\n-\t    }\n-\n-\t  _DifferenceType __leftsize = 0, __total = 0;\n-\t  for (int __i = 0; __i < __m; ++__i)\n-\t    {\n-\t      __leftsize += __a[__i] / (__n + 1);\n-\t      __total += __l / (__n + 1);\n-\t    }\n-\n-\t  _DifferenceType __skew = ((unsigned long long)__total * __rank / __N\n-\t\t\t\t  - __leftsize);\n-\n-\t  if (__skew > 0)\n-\t    {\n-\t      // Move to the left, find smallest.\n-\t      std::priority_queue<std::pair<_Tp, int>,\n-\t\tstd::vector<std::pair<_Tp, int> >,\n-\t\t_LexicographicReverse<_Tp, int, _Compare> > __pq(__lrcomp);\n-\n-\t      for (int __i = 0; __i < __m; ++__i)\n-\t\tif (__b[__i] < __ns[__i])\n-\t\t  __pq.push(std::make_pair(__S(__i)[__b[__i]], __i));\n-\n-\t      for (; __skew != 0 && !__pq.empty(); --__skew)\n-\t\t{\n-\t\t  int source = __pq.top().second;\n-\t\t  __pq.pop();\n-\t\t  \n-\t\t  __a[source] = std::min(__a[source] + __n + 1, __ns[source]);\n-\t\t  __b[source] += __n + 1;\n-\t\t  \n-\t\t  if (__b[source] < __ns[source])\n-\t\t    __pq.push(std::make_pair(__S(source)[__b[source]], source));\n-\t\t}\n-\t    }\n-\t  else if (__skew < 0)\n-\t    {\n-\t      // Move to the right, find greatest.\n-\t      std::priority_queue<std::pair<_Tp, int>,\n-\t\tstd::vector<std::pair<_Tp, int> >,\n-\t\t_Lexicographic<_Tp, int, _Compare> > __pq(__lcomp);\n-\n-\t      for (int __i = 0; __i < __m; ++__i)\n-\t\tif (__a[__i] > 0)\n-\t\t  __pq.push(std::make_pair(__S(__i)[__a[__i] - 1], __i));\n-\n-\t      for (; __skew != 0; ++__skew)\n-\t\t{\n-\t\t  int source = __pq.top().second;\n-\t\t  __pq.pop();\n-\n-\t\t  __a[source] -= __n + 1;\n-\t\t  __b[source] -= __n + 1;\n-\n-\t\t  if (__a[source] > 0)\n-\t\t    __pq.push(std::make_pair(__S(source)[__a[source] - 1], source));\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          __n /= 2;\n+\n+          const _Tp* __lmax = NULL;\n+          for (int __i = 0; __i < __m; ++__i)\n+            {\n+              if (__a[__i] > 0)\n+                {\n+                  if (!__lmax)\n+                    __lmax = &(__S(__i)[__a[__i] - 1]);\n+                  else\n+                    {\n+                      if (__comp(*__lmax, __S(__i)[__a[__i] - 1]))      //max\n+                        __lmax = &(__S(__i)[__a[__i] - 1]);\n+                    }\n+                }\n+            }\n+\n+          int __i;\n+          for (__i = 0; __i < __m; __i++)\n+            {\n+              _DifferenceType __middle = (__b[__i] + __a[__i]) / 2;\n+              if (__lmax && __middle < __ns[__i]\n+                  && __comp(__S(__i)[__middle], *__lmax))\n+                __a[__i] = std::min(__a[__i] + __n + 1, __ns[__i]);\n+              else\n+                __b[__i] -= __n + 1;\n+            }\n+\n+          _DifferenceType __leftsize = 0, __total = 0;\n+          for (int __i = 0; __i < __m; ++__i)\n+            {\n+              __leftsize += __a[__i] / (__n + 1);\n+              __total += __l / (__n + 1);\n+            }\n+\n+          _DifferenceType __skew = ((unsigned long long)__total * __rank / __N\n+                                  - __leftsize);\n+\n+          if (__skew > 0)\n+            {\n+              // Move to the left, find smallest.\n+              std::priority_queue<std::pair<_Tp, int>,\n+                std::vector<std::pair<_Tp, int> >,\n+                _LexicographicReverse<_Tp, int, _Compare> > __pq(__lrcomp);\n+\n+              for (int __i = 0; __i < __m; ++__i)\n+                if (__b[__i] < __ns[__i])\n+                  __pq.push(std::make_pair(__S(__i)[__b[__i]], __i));\n+\n+              for (; __skew != 0 && !__pq.empty(); --__skew)\n+                {\n+                  int source = __pq.top().second;\n+                  __pq.pop();\n+\n+                  __a[source] = std::min(__a[source] + __n + 1, __ns[source]);\n+                  __b[source] += __n + 1;\n+\n+                  if (__b[source] < __ns[source])\n+                    __pq.push(\n+                      std::make_pair(__S(source)[__b[source]], source));\n+                }\n+            }\n+          else if (__skew < 0)\n+            {\n+              // Move to the right, find greatest.\n+              std::priority_queue<std::pair<_Tp, int>,\n+                std::vector<std::pair<_Tp, int> >,\n+                _Lexicographic<_Tp, int, _Compare> > __pq(__lcomp);\n+\n+              for (int __i = 0; __i < __m; ++__i)\n+                if (__a[__i] > 0)\n+                  __pq.push(std::make_pair(__S(__i)[__a[__i] - 1], __i));\n+\n+              for (; __skew != 0; ++__skew)\n+                {\n+                  int source = __pq.top().second;\n+                  __pq.pop();\n+\n+                  __a[source] -= __n + 1;\n+                  __b[source] -= __n + 1;\n+\n+                  if (__a[source] > 0)\n+                    __pq.push(\n+                      std::make_pair(__S(source)[__a[source] - 1], source));\n+                }\n+            }\n+        }\n \n       // Postconditions:\n-      // __a[__i] == __b[__i] in most cases, except when __a[__i] has been clamped\n-      // because of having reached the boundary\n+      // __a[__i] == __b[__i] in most cases, except when __a[__i] has been\n+      // clamped because of having reached the boundary\n \n       // Now return the result, calculate the offset.\n \n@@ -568,57 +584,58 @@ namespace __gnu_parallel\n       // Impossible to avoid the warning?\n       _Tp __maxleft, __minright;\n       for (int __i = 0; __i < __m; ++__i)\n-\t{\n-\t  if (__a[__i] > 0)\n-\t    {\n-\t      if (!__maxleftset)\n-\t\t{\n-\t\t  __maxleft = __S(__i)[__a[__i] - 1];\n-\t\t  __maxleftset = true;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // Max.\n-\t\t  if (__comp(__maxleft, __S(__i)[__a[__i] - 1]))\n-\t\t    __maxleft = __S(__i)[__a[__i] - 1];\n-\t\t}\n-\t    }\n-\t  if (__b[__i] < __ns[__i])\n-\t    {\n-\t      if (!__minrightset)\n-\t\t{\n-\t\t  __minright = __S(__i)[__b[__i]];\n-\t\t  __minrightset = true;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // Min.\n-\t\t  if (__comp(__S(__i)[__b[__i]], __minright))\n-\t\t    __minright = __S(__i)[__b[__i]];\n-\t\t}\n-\t    }\n+        {\n+          if (__a[__i] > 0)\n+            {\n+              if (!__maxleftset)\n+                {\n+                  __maxleft = __S(__i)[__a[__i] - 1];\n+                  __maxleftset = true;\n+                }\n+              else\n+                {\n+                  // Max.\n+                  if (__comp(__maxleft, __S(__i)[__a[__i] - 1]))\n+                    __maxleft = __S(__i)[__a[__i] - 1];\n+                }\n+            }\n+          if (__b[__i] < __ns[__i])\n+            {\n+              if (!__minrightset)\n+                {\n+                  __minright = __S(__i)[__b[__i]];\n+                  __minrightset = true;\n+                }\n+              else\n+                {\n+                  // Min.\n+                  if (__comp(__S(__i)[__b[__i]], __minright))\n+                    __minright = __S(__i)[__b[__i]];\n+                }\n+            }\n       }\n \n       // Minright is the splitter, in any case.\n \n       if (!__maxleftset || __comp(__minright, __maxleft))\n-\t{\n-\t  // Good luck, everything is split unambiguously.\n-\t  __offset = 0;\n-\t}\n+        {\n+          // Good luck, everything is split unambiguously.\n+          __offset = 0;\n+        }\n       else\n-\t{\n-\t  // We have to calculate an offset.\n-\t  __offset = 0;\n-\n-\t  for (int __i = 0; __i < __m; ++__i)\n-\t    {\n-\t      _DifferenceType lb = std::lower_bound(__S(__i), __S(__i) + __ns[__i],\n-\t\t\t\t\t\t    __minright,\n-\t\t\t\t\t\t    __comp) - __S(__i);\n-\t      __offset += __a[__i] - lb;\n-\t    }\n-\t}\n+        {\n+          // We have to calculate an offset.\n+          __offset = 0;\n+\n+          for (int __i = 0; __i < __m; ++__i)\n+            {\n+              _DifferenceType lb\n+                = std::lower_bound(__S(__i), __S(__i) + __ns[__i],\n+                                   __minright,\n+                                   __comp) - __S(__i);\n+              __offset += __a[__i] - lb;\n+            }\n+        }\n \n       delete[] __ns;\n       delete[] __a;"}, {"sha": "b5540e71426ea10076c7aa942b8de41421d1ddc4", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 92, "deletions": 66, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -144,11 +144,11 @@ template<typename _RAIter, typename _Compare>\n   operator<(_GuardedIterator<_RAIter, _Compare>& __bi1,\n             _GuardedIterator<_RAIter, _Compare>& __bi2)\n   {\n-    if (__bi1._M_current == __bi1._M_end)\t//__bi1 is sup\n-      return __bi2._M_current == __bi2._M_end;\t//__bi2 is not sup\n-    if (__bi2._M_current == __bi2._M_end)\t//__bi2 is sup\n+    if (__bi1._M_current == __bi1._M_end)       //__bi1 is sup\n+      return __bi2._M_current == __bi2._M_end;  //__bi2 is not sup\n+    if (__bi2._M_current == __bi2._M_end)       //__bi2 is sup\n       return true;\n-    return (__bi1.__comp)(*__bi1, *__bi2);\t//normal compare\n+    return (__bi1.__comp)(*__bi1, *__bi2);      //normal compare\n   }\n \n /** @brief Compare two elements referenced by guarded iterators.\n@@ -160,11 +160,11 @@ template<typename _RAIter, typename _Compare>\n   operator<=(_GuardedIterator<_RAIter, _Compare>& __bi1,\n                _GuardedIterator<_RAIter, _Compare>& __bi2)\n   {\n-    if (__bi2._M_current == __bi2._M_end)\t//__bi1 is sup\n-      return __bi1._M_current != __bi1._M_end;\t//__bi2 is not sup\n-    if (__bi1._M_current == __bi1._M_end)\t//__bi2 is sup\n+    if (__bi2._M_current == __bi2._M_end)       //__bi1 is sup\n+      return __bi1._M_current != __bi1._M_end;  //__bi2 is not sup\n+    if (__bi1._M_current == __bi1._M_end)       //__bi2 is sup\n       return false;\n-    return !(__bi1.__comp)(*__bi2, *__bi1);\t//normal compare\n+    return !(__bi1.__comp)(*__bi2, *__bi1);     //normal compare\n   }\n \n template<typename _RAIter, typename _Compare>\n@@ -282,10 +282,10 @@ template<typename _RAIter, typename _Compare>\n  * @return End iterator of output sequence.\n  */\n template<template<typename RAI, typename C> class iterator,\n-\t typename _RAIterIterator,\n-\t typename _RAIter3,\n-\t typename _DifferenceTp,\n-\t typename _Compare>\n+         typename _RAIterIterator,\n+         typename _RAIter3,\n+         typename _DifferenceTp,\n+         typename _Compare>\n   _RAIter3\n   multiway_merge_3_variant(\n       _RAIterIterator __seqs_begin,\n@@ -402,10 +402,10 @@ template<template<typename RAI, typename C> class iterator,\n  * @return End iterator of output sequence.\n  */\n template<template<typename RAI, typename C> class iterator,\n-\t typename _RAIterIterator,\n-\t typename _RAIter3,\n-\t typename _DifferenceTp,\n-\t typename _Compare>\n+         typename _RAIterIterator,\n+         typename _RAIter3,\n+         typename _DifferenceTp,\n+         typename _Compare>\n   _RAIter3\n   multiway_merge_4_variant(_RAIterIterator __seqs_begin,\n                            _RAIterIterator __seqs_end,\n@@ -427,10 +427,10 @@ template<template<typename RAI, typename C> class iterator,\n       __seq2(__seqs_begin[2].first, __seqs_begin[2].second, __comp),\n       __seq3(__seqs_begin[3].first, __seqs_begin[3].second, __comp);\n \n-#define _GLIBCXX_PARALLEL_DECISION(__a,__b,__c,d) {                   \\\n-      if (__seq ## d < __seq ## __a) goto __s ## d ## __a ## __b ## __c;\t\\\n-      if (__seq ## d < __seq ## __b) goto __s ## __a ## d ## __b ## __c;\t\\\n-      if (__seq ## d < __seq ## __c) goto __s ## __a ## __b ## d ## __c;\t\\\n+#define _GLIBCXX_PARALLEL_DECISION(__a,__b,__c,d) {                      \\\n+      if (__seq ## d < __seq ## __a) goto __s ## d ## __a ## __b ## __c; \\\n+      if (__seq ## d < __seq ## __b) goto __s ## __a ## d ## __b ## __c; \\\n+      if (__seq ## d < __seq ## __c) goto __s ## __a ## __b ## d ## __c; \\\n       goto __s ## __a ## __b ## __c ## d;  }\n \n     if (__seq0 <= __seq1)\n@@ -456,16 +456,16 @@ template<template<typename RAI, typename C> class iterator,\n           _GLIBCXX_PARALLEL_DECISION(2,1,0,3)\n             }\n \n-#define _GLIBCXX_PARALLEL_MERGE_4_CASE(__a,__b,__c,d,c0,c1,c2)        \\\n-    __s ## __a ## __b ## __c ## d:                                      \\\n-      if (__length == 0) goto finish;                             \\\n-    *__target = *__seq ## __a;                                        \\\n-    ++__target;                                                   \\\n-    --__length;                                                   \\\n-    ++__seq ## __a;                                                 \\\n-    if (__seq ## __a c0 __seq ## __b) goto __s ## __a ## __b ## __c ## d;       \\\n-    if (__seq ## __a c1 __seq ## __c) goto __s ## __b ## __a ## __c ## d;       \\\n-    if (__seq ## __a c2 __seq ## d) goto __s ## __b ## __c ## __a ## d;       \\\n+#define _GLIBCXX_PARALLEL_MERGE_4_CASE(__a,__b,__c,d,c0,c1,c2)            \\\n+    __s ## __a ## __b ## __c ## d:                                        \\\n+      if (__length == 0) goto finish;                                     \\\n+    *__target = *__seq ## __a;                                            \\\n+    ++__target;                                                           \\\n+    --__length;                                                           \\\n+    ++__seq ## __a;                                                       \\\n+    if (__seq ## __a c0 __seq ## __b) goto __s ## __a ## __b ## __c ## d; \\\n+    if (__seq ## __a c1 __seq ## __c) goto __s ## __b ## __a ## __c ## d; \\\n+    if (__seq ## __a c2 __seq ## d) goto __s ## __b ## __c ## __a ## d;   \\\n     goto __s ## __b ## __c ## d ## __a;\n \n     _GLIBCXX_PARALLEL_MERGE_4_CASE(0, 1, 2, 3, <=, <=, <=);\n@@ -526,10 +526,10 @@ template<template<typename RAI, typename C> class iterator,\n  * @return End iterator of output sequence.\n  */\n template<typename LT,\n-\t typename _RAIterIterator,\n-\t typename _RAIter3,\n-\t typename _DifferenceTp,\n-\t typename _Compare>\n+         typename _RAIterIterator,\n+         typename _RAIter3,\n+         typename _DifferenceTp,\n+         typename _Compare>\n   _RAIter3\n   multiway_merge_loser_tree(_RAIterIterator __seqs_begin,\n                             _RAIterIterator __seqs_end,\n@@ -638,7 +638,8 @@ template<typename LT,\n     for (int __t = 0; __t < __k; ++__t)\n       {\n #if _GLIBCXX_ASSERTIONS\n-        _GLIBCXX_PARALLEL_ASSERT(__seqs_begin[__t].first != __seqs_begin[__t].second);\n+        _GLIBCXX_PARALLEL_ASSERT(__seqs_begin[__t].first\n+                                 != __seqs_begin[__t].second);\n #endif\n         __lt.__insert_start(*__seqs_begin[__t].first, __t, false);\n       }\n@@ -914,7 +915,8 @@ struct __multiway_merge_k_variant_sentinel_switch\n             _LoserTreeTraits<_ValueType>::_M_use_pointer\n           , LoserTreePointerUnguarded<__stable, _ValueType, _Compare>\n           , _LoserTreeUnguarded<__stable, _ValueType, _Compare>\n-        >::__type>(__seqs_begin, __seqs_end, __target, __sentinel, __length, __comp);\n+        >::__type>(\n+            __seqs_begin, __seqs_end, __target, __sentinel, __length, __comp);\n   }\n };\n \n@@ -997,7 +999,8 @@ template<\n #if _GLIBCXX_ASSERTIONS\n     for (_RAIterIterator __s = __seqs_begin; __s != __seqs_end; ++__s)\n       {\n-        _GLIBCXX_PARALLEL_ASSERT(__is_sorted((*__s).first, (*__s).second, __comp));\n+        _GLIBCXX_PARALLEL_ASSERT(\n+          __is_sorted((*__s).first, (*__s).second, __comp));\n       }\n #endif\n \n@@ -1053,11 +1056,13 @@ template<\n             , _RAIterIterator\n             , _RAIter3\n             , _DifferenceTp\n-            , _Compare>()(__seqs_begin, __seqs_end, __target, __sentinel, __length, __comp);\n+            , _Compare>()(__seqs_begin, __seqs_end, __target, __sentinel,\n+                          __length, __comp);\n           break;\n       }\n #if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(__is_sorted(__target, __target + __length, __comp));\n+    _GLIBCXX_PARALLEL_ASSERT(\n+      __is_sorted(__target, __target + __length, __comp));\n #endif\n \n     return __return_target;\n@@ -1163,7 +1168,8 @@ void multiway_merge_sampling_splitting(\n               - __seqs_begin[__seq].first;\n         else\n             // Absolute end.\n-          __pieces[__slab][__seq].second = _GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__seq]);\n+          __pieces[__slab][__seq].second\n+            = _GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__seq]);\n       }\n     ::operator delete(__samples);\n }\n@@ -1379,7 +1385,8 @@ template<\n         } // parallel\n \n #if _GLIBCXX_ASSERTIONS\n-      _GLIBCXX_PARALLEL_ASSERT(__is_sorted(__target, __target + __length, __comp));\n+      _GLIBCXX_PARALLEL_ASSERT(\n+        __is_sorted(__target, __target + __length, __comp));\n #endif\n \n       __k = 0;\n@@ -1490,7 +1497,8 @@ multiway_merge(_RAIterPairIterator __seqs_begin\n   // Execute multiway merge *sequentially*.\n   return __sequential_multiway_merge\n     </* __stable = */ false, /* __sentinels = */ false>\n-      (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length, __comp);\n+      (__seqs_begin, __seqs_end, __target,\n+      *(__seqs_begin->second), __length, __comp);\n }\n \n // public interface\n@@ -1528,11 +1536,13 @@ multiway_merge(_RAIterPairIterator __seqs_begin\n           multiway_merge_exact_splitting</* __stable = */ false,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n                       </* __stable = */ false, /* __sentinels = */ false>(\n-          __seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length, __comp);\n+               __seqs_begin, __seqs_end, __target, *(__seqs_begin->second),\n+               __length, __comp);\n }\n \n // public interface\n@@ -1571,7 +1581,8 @@ multiway_merge(_RAIterPairIterator __seqs_begin\n           multiway_merge_exact_splitting</* __stable = */ false,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n                       </* __stable = */ false, /* __sentinels = */ false>(\n@@ -1637,7 +1648,8 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n     // Execute multiway merge *sequentially*.\n     return __sequential_multiway_merge\n       </* __stable = */ true, /* __sentinels = */ false>\n-        (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length, __comp);\n+        (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length,\n+         __comp);\n }\n \n // public interface\n@@ -1676,7 +1688,8 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n           multiway_merge_exact_splitting</* __stable = */ true,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge</* __stable = */ true,\n         /* __sentinels = */ false>(\n@@ -1720,7 +1733,8 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n           multiway_merge_sampling_splitting</* __stable = */ true,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n         </* __stable = */ true, /* __sentinels = */ false>(\n@@ -1742,8 +1756,9 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n     , _DifferenceTp __length, _Compare __comp\n     , parallel_tag __tag = parallel_tag(0))\n {\n-  return stable_multiway_merge(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n+  return stable_multiway_merge(\n+           __seqs_begin, __seqs_end, __target, __length, __comp,\n+           exact_tag(__tag.__get_num_threads()));\n }\n \n // public interface\n@@ -1759,8 +1774,9 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n     , _DifferenceTp __length, _Compare __comp\n     , default_parallel_tag __tag)\n {\n-  return stable_multiway_merge(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n+  return stable_multiway_merge(\n+           __seqs_begin, __seqs_end, __target, __length, __comp,\n+           exact_tag(__tag.__get_num_threads()));\n }\n \n /**\n@@ -1902,7 +1918,8 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n           multiway_merge_exact_splitting</* __stable = */ false,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n         </* __stable = */ false, /* __sentinels = */ true>(\n@@ -1945,7 +1962,8 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n           multiway_merge_sampling_splitting</* __stable = */ false,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n         </* __stable = */false, /* __sentinels = */ true>(\n@@ -1966,8 +1984,9 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n     , _DifferenceTp __length, _Compare __comp\n     , parallel_tag __tag = parallel_tag(0))\n {\n-  return multiway_merge_sentinels(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n+  return multiway_merge_sentinels(\n+           __seqs_begin, __seqs_end, __target, __length, __comp,\n+           exact_tag(__tag.__get_num_threads()));\n }\n \n // public interface\n@@ -1983,8 +2002,9 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n     , _DifferenceTp __length, _Compare __comp\n     , default_parallel_tag __tag)\n {\n-  return multiway_merge_sentinels(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n+  return multiway_merge_sentinels(\n+           __seqs_begin, __seqs_end, __target, __length, __comp,\n+           exact_tag(__tag.__get_num_threads()));\n }\n \n // stable_multiway_merge_sentinels\n@@ -2011,7 +2031,8 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n     // Execute multiway merge *sequentially*.\n     return __sequential_multiway_merge\n       </* __stable = */ true, /* __sentinels = */ true>\n-        (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length, __comp);\n+        (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length,\n+         __comp);\n }\n \n // public interface\n@@ -2050,11 +2071,13 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n           multiway_merge_exact_splitting</* __stable = */ true,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+          __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n         </* __stable = */ true, /* __sentinels = */ true>(\n-          __seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length, __comp);\n+          __seqs_begin, __seqs_end, __target, *(__seqs_begin->second),\n+          __length, __comp);\n }\n \n // public interface\n@@ -2093,7 +2116,8 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n           multiway_merge_sampling_splitting</* __stable = */ true,\n             typename std::iterator_traits<_RAIterPairIterator>\n               ::value_type*, _Compare, _DifferenceTp>,\n-          static_cast<_DifferenceType>(__length), __comp, __tag.__get_num_threads());\n+          static_cast<_DifferenceType>(__length), __comp,\n+                                       __tag.__get_num_threads());\n     else\n       return __sequential_multiway_merge\n         </* __stable = */ true, /* __sentinels = */ true>(\n@@ -2114,8 +2138,9 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n     , _DifferenceTp __length, _Compare __comp\n     , parallel_tag __tag = parallel_tag(0))\n {\n-  return stable_multiway_merge_sentinels(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n+  return stable_multiway_merge_sentinels(\n+           __seqs_begin, __seqs_end, __target, __length, __comp,\n+           exact_tag(__tag.__get_num_threads()));\n }\n \n // public interface\n@@ -2131,8 +2156,9 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n     , _DifferenceTp __length, _Compare __comp\n     , default_parallel_tag __tag)\n {\n-  return stable_multiway_merge_sentinels(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n+  return stable_multiway_merge_sentinels(\n+           __seqs_begin, __seqs_end, __target, __length, __comp,\n+           exact_tag(__tag.__get_num_threads()));\n }\n \n }; // namespace __gnu_parallel"}, {"sha": "9f61ce305a201ec33f5a3055f14fb78b05e2d1cd", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -111,7 +111,7 @@ template<typename _RAIter, typename _DifferenceTp>\n \n     for (_DifferenceType __i = 0; __i < __num_samples; ++__i)\n       ::new(&(__sd->_M_samples[__iam * __num_samples + __i]))\n-\t  _ValueType(__sd->_M_source[__sd->_M_starts[__iam] + __es[__i + 1]]);\n+          _ValueType(__sd->_M_source[__sd->_M_starts[__iam] + __es[__i + 1]]);\n \n     delete[] __es;\n   }\n@@ -144,25 +144,28 @@ template<typename _RAIter, typename _Compare,\n         seqs(__sd->_M_num_threads);\n     for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n       seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n-                                __sd->_M_temporary[__s]\n-                                    + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]));\n+                                 __sd->_M_temporary[__s]\n+                                 + (__sd->_M_starts[__s + 1]\n+                                 - __sd->_M_starts[__s]));\n \n     std::vector<_SortingPlacesIterator> _M_offsets(__sd->_M_num_threads);\n \n     // if not last thread\n     if (__iam < __sd->_M_num_threads - 1)\n       multiseq_partition(seqs.begin(), seqs.end(),\n-                          __sd->_M_starts[__iam + 1], _M_offsets.begin(), __comp);\n+                         __sd->_M_starts[__iam + 1], _M_offsets.begin(),\n+                         __comp);\n \n     for (int __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n       {\n         // for each sequence\n         if (__iam < (__sd->_M_num_threads - 1))\n-          __sd->_M_pieces[__iam][__seq]._M_end = _M_offsets[__seq] - seqs[__seq].first;\n+          __sd->_M_pieces[__iam][__seq]._M_end\n+            = _M_offsets[__seq] - seqs[__seq].first;\n         else\n           // very end of this sequence\n           __sd->_M_pieces[__iam][__seq]._M_end =\n-              __sd->_M_starts[__seq + 1] - __sd->_M_starts[__seq];\n+            __sd->_M_starts[__seq + 1] - __sd->_M_starts[__seq];\n       }\n \n #   pragma omp barrier\n@@ -171,7 +174,8 @@ template<typename _RAIter, typename _Compare,\n       {\n         // For each sequence.\n         if (__iam > 0)\n-          __sd->_M_pieces[__iam][__seq]._M_begin = __sd->_M_pieces[__iam - 1][__seq]._M_end;\n+          __sd->_M_pieces[__iam][__seq]._M_begin =\n+            __sd->_M_pieces[__iam - 1][__seq]._M_end;\n         else\n           // Absolute beginning.\n           __sd->_M_pieces[__iam][__seq]._M_begin = 0;\n@@ -204,7 +208,8 @@ template<typename _RAIter, typename _Compare,\n \n #     pragma omp single\n       __gnu_sequential::sort(__sd->_M_samples,\n-                             __sd->_M_samples + (__num_samples * __sd->_M_num_threads),\n+                             __sd->_M_samples\n+                                + (__num_samples * __sd->_M_num_threads),\n                              __comp);\n \n #     pragma omp barrier\n@@ -224,17 +229,19 @@ template<typename _RAIter, typename _Compare,\n             // Absolute beginning.\n             __sd->_M_pieces[__iam][__s]._M_begin = 0;\n \n-          if ((__num_samples * (__iam + 1)) < (__num_samples * __sd->_M_num_threads))\n+          if ((__num_samples * (__iam + 1)) <\n+                         (__num_samples * __sd->_M_num_threads))\n             __sd->_M_pieces[__iam][__s]._M_end =\n                 std::lower_bound(__sd->_M_temporary[__s],\n                         __sd->_M_temporary[__s]\n-                            + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n+                          + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n                         __sd->_M_samples[__num_samples * (__iam + 1)],\n                         __comp)\n                 - __sd->_M_temporary[__s];\n           else\n             // Absolute end.\n-            __sd->_M_pieces[__iam][__s]._M_end = __sd->_M_starts[__s + 1] - __sd->_M_starts[__s];\n+            __sd->_M_pieces[__iam][__s]._M_end = __sd->_M_starts[__s + 1]\n+                                                 - __sd->_M_starts[__s];\n         }\n     }\n   };\n@@ -283,8 +290,8 @@ template<typename Seq_RAIter, typename _RAIter,\n                       _Compare& __comp,\n                       DiffType __length_am) const\n     {\n-      stable_multiway_merge(__seqs_begin, __seqs_end, __target, __length_am, __comp,\n-                       sequential_tag());\n+      stable_multiway_merge(__seqs_begin, __seqs_end, __target, __length_am,\n+                            __comp, sequential_tag());\n     }\n   };\n \n@@ -322,7 +329,8 @@ template<bool __stable, bool __exact, typename _RAIter,\n     _ThreadIndex __iam = omp_get_thread_num();\n \n     // Length of this thread's chunk, before merging.\n-    _DifferenceType __length_local = __sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n+    _DifferenceType __length_local\n+                        = __sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n \n     // Sort in temporary storage, leave space for sentinel.\n \n@@ -333,12 +341,15 @@ template<bool __stable, bool __exact, typename _RAIter,\n         ::operator new(sizeof(_ValueType) * (__length_local + 1)));\n \n     // Copy there.\n-    std::uninitialized_copy(__sd->_M_source + __sd->_M_starts[__iam],\n-                            __sd->_M_source + __sd->_M_starts[__iam] + __length_local,\n-                            __sd->_M_temporary[__iam]);\n+    std::uninitialized_copy(\n+                __sd->_M_source + __sd->_M_starts[__iam],\n+                __sd->_M_source + __sd->_M_starts[__iam] + __length_local,\n+                __sd->_M_temporary[__iam]);\n \n     __possibly_stable_sort<__stable, _SortingPlacesIterator, _Compare>()\n-        (__sd->_M_temporary[__iam], __sd->_M_temporary[__iam] + __length_local, __comp);\n+        (__sd->_M_temporary[__iam],\n+         __sd->_M_temporary[__iam] + __length_local,\n+         __comp);\n \n     // Invariant: locally sorted subsequence in sd->_M_temporary[__iam],\n     // __sd->_M_temporary[__iam] + __length_local.\n@@ -355,7 +366,8 @@ template<bool __stable, bool __exact, typename _RAIter,\n     _DifferenceType __offset = 0, __length_am = 0;\n     for (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n       {\n-        __length_am += __sd->_M_pieces[__iam][__s]._M_end - __sd->_M_pieces[__iam][__s]._M_begin;\n+        __length_am += __sd->_M_pieces[__iam][__s]._M_end\n+                       - __sd->_M_pieces[__iam][__s]._M_begin;\n         __offset += __sd->_M_pieces[__iam][__s]._M_begin;\n       }\n \n@@ -367,8 +379,9 @@ template<bool __stable, bool __exact, typename _RAIter,\n     for (int __s = 0; __s < __sd->_M_num_threads; ++__s)\n       {\n         seqs[__s] =\n-          std::make_pair(__sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_begin,\n-        __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_end);\n+          std::make_pair(\n+            __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_begin,\n+            __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_end);\n       }\n \n     __possibly_stable_multiway_merge<\n@@ -420,7 +433,7 @@ template<bool __stable, bool __exact, typename _RAIter,\n \n #   pragma omp parallel num_threads(__num_threads)\n       {\n-        __num_threads = omp_get_num_threads();  //no more threads than requested\n+        __num_threads = omp_get_num_threads(); //no more threads than requested\n \n #       pragma omp single\n           {\n@@ -432,7 +445,7 @@ template<bool __stable, bool __exact, typename _RAIter,\n             if (!__exact)\n               {\n                 _DifferenceType size =\n-                    (_Settings::get().sort_mwms_oversampling * __num_threads - 1)\n+                  (_Settings::get().sort_mwms_oversampling * __num_threads - 1)\n                         * __num_threads;\n                 __sd._M_samples = static_cast<_ValueType*>(\n                               ::operator new(size * sizeof(_ValueType)));\n@@ -441,18 +454,21 @@ template<bool __stable, bool __exact, typename _RAIter,\n               __sd._M_samples = NULL;\n \n             __sd._M_offsets = new _DifferenceType[__num_threads - 1];\n-            __sd._M_pieces = new std::vector<_Piece<_DifferenceType> >[__num_threads];\n+            __sd._M_pieces\n+                = new std::vector<_Piece<_DifferenceType> >[__num_threads];\n             for (int __s = 0; __s < __num_threads; ++__s)\n               __sd._M_pieces[__s].resize(__num_threads);\n-            _M_starts = __sd._M_starts = new _DifferenceType[__num_threads + 1];\n+            _M_starts = __sd._M_starts\n+                = new _DifferenceType[__num_threads + 1];\n \n             _DifferenceType __chunk_length = __n / __num_threads;\n             _DifferenceType __split = __n % __num_threads;\n             _DifferenceType __pos = 0;\n             for (int __i = 0; __i < __num_threads; ++__i)\n               {\n                 _M_starts[__i] = __pos;\n-                __pos += (__i < __split) ? (__chunk_length + 1) : __chunk_length;\n+                __pos += (__i < __split)\n+                         ? (__chunk_length + 1) : __chunk_length;\n               }\n             _M_starts[__num_threads] = __pos;\n           } //single"}, {"sha": "5d03e679c270a7d71af4c840c2969cd759f77819", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 186, "deletions": 179, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -54,76 +54,77 @@ namespace __parallel\n   template<typename _IIter, typename _Tp>\n     inline _Tp\n     accumulate(_IIter __begin, _IIter __end, _Tp __init, \n-\t       __gnu_parallel::sequential_tag)\n+               __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::accumulate(__begin, __end, __init); }\n \n   template<typename _IIter, typename _Tp, typename _BinaryOperation>\n     inline _Tp\n     accumulate(_IIter __begin, _IIter __end, _Tp __init,\n-\t       _BinaryOperation __binary_op, __gnu_parallel::sequential_tag)\n+               _BinaryOperation __binary_op, __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::accumulate(__begin, __end, __init, __binary_op); }\n \n   // Sequential fallback for input iterator case.\n   template<typename _IIter, typename _Tp, typename _IteratorTag>\n     inline _Tp\n     __accumulate_switch(_IIter __begin, _IIter __end,\n-\t\t      _Tp __init, _IteratorTag) \n-    { return accumulate(__begin, __end, __init, __gnu_parallel::sequential_tag()); }\n+                      _Tp __init, _IteratorTag) \n+    { return accumulate(__begin, __end, __init,\n+__gnu_parallel::sequential_tag()); }\n \n   template<typename _IIter, typename _Tp, typename _BinaryOperation,\n-\t   typename _IteratorTag>\n+           typename _IteratorTag>\n     inline _Tp\n     __accumulate_switch(_IIter __begin, _IIter __end, _Tp __init, \n-\t\t      _BinaryOperation __binary_op, _IteratorTag)\n+                      _BinaryOperation __binary_op, _IteratorTag)\n     { return accumulate(__begin, __end, __init, __binary_op, \n-\t\t\t__gnu_parallel::sequential_tag()); }\n+                        __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename __RAIter, typename _Tp,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     _Tp\n     __accumulate_switch(__RAIter __begin, __RAIter __end, \n-\t\t      _Tp __init, _BinaryOperation __binary_op, \n-\t\t      random_access_iterator_tag, \n-\t\t      __gnu_parallel::_Parallelism __parallelism_tag  \n-\t\t      = __gnu_parallel::parallel_unbalanced)\n+                      _Tp __init, _BinaryOperation __binary_op, \n+                      random_access_iterator_tag, \n+                      __gnu_parallel::_Parallelism __parallelism_tag  \n+                      = __gnu_parallel::parallel_unbalanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n-\t    >= __gnu_parallel::_Settings::get().accumulate_minimal_n\n-\t    && __gnu_parallel::__is_parallel(__parallelism_tag)))\n-\t{\n-\t  _Tp __res = __init;\n-\t  __gnu_parallel::__accumulate_selector<__RAIter>\n-\t    __my_selector;\n-\t  __gnu_parallel::\n-\t    for_each_template_random_access_ed(__begin, __end,\n-\t\t\t\t\t    __gnu_parallel::_Nothing(),\n-\t\t\t\t\t    __my_selector,\n-\t\t\t\t\t    __gnu_parallel::\n-\t\t\t\t\t    __accumulate_binop_reduct\n-\t\t\t\t\t    <_BinaryOperation>(__binary_op),\n-\t\t\t\t\t    __res, __res, -1);\n-\t  return __res;\n-\t}\n+            static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n+            >= __gnu_parallel::_Settings::get().accumulate_minimal_n\n+            && __gnu_parallel::__is_parallel(__parallelism_tag)))\n+        {\n+          _Tp __res = __init;\n+          __gnu_parallel::__accumulate_selector<__RAIter>\n+            __my_selector;\n+          __gnu_parallel::\n+            for_each_template_random_access_ed(__begin, __end,\n+                                            __gnu_parallel::_Nothing(),\n+                                            __my_selector,\n+                                            __gnu_parallel::\n+                                            __accumulate_binop_reduct\n+                                            <_BinaryOperation>(__binary_op),\n+                                            __res, __res, -1);\n+          return __res;\n+        }\n       else\n-\treturn accumulate(__begin, __end, __init, __binary_op, \n-\t\t\t  __gnu_parallel::sequential_tag());\n+        return accumulate(__begin, __end, __init, __binary_op, \n+                          __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n   template<typename _IIter, typename _Tp>\n     inline _Tp\n     accumulate(_IIter __begin, _IIter __end, _Tp __init, \n-\t       __gnu_parallel::_Parallelism __parallelism_tag)\n+               __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n       typedef std::iterator_traits<_IIter> _IteratorTraits;\n       typedef typename _IteratorTraits::value_type _ValueType;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n \n       return __accumulate_switch(__begin, __end, __init,\n-\t\t\t       __gnu_parallel::_Plus<_Tp, _ValueType>(),\n-\t\t\t       _IteratorCategory(), __parallelism_tag);\n+                               __gnu_parallel::_Plus<_Tp, _ValueType>(),\n+                               _IteratorCategory(), __parallelism_tag);\n     }\n \n   template<typename _IIter, typename _Tp>\n@@ -135,218 +136,220 @@ namespace __parallel\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n \n       return __accumulate_switch(__begin, __end, __init,\n-\t\t\t       __gnu_parallel::_Plus<_Tp, _ValueType>(),\n-\t\t\t       _IteratorCategory());\n+                               __gnu_parallel::_Plus<_Tp, _ValueType>(),\n+                               _IteratorCategory());\n     }\n \n   template<typename _IIter, typename _Tp, typename _BinaryOperation>\n     inline _Tp\n     accumulate(_IIter __begin, _IIter __end, _Tp __init, \n-\t       _BinaryOperation __binary_op, \n-\t       __gnu_parallel::_Parallelism __parallelism_tag)\n+               _BinaryOperation __binary_op, \n+               __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n       typedef iterator_traits<_IIter> _IteratorTraits;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n       return __accumulate_switch(__begin, __end, __init, __binary_op, \n-\t\t\t       _IteratorCategory(), __parallelism_tag);\n+                               _IteratorCategory(), __parallelism_tag);\n     }\n \n   template<typename _IIter, typename _Tp, typename _BinaryOperation>\n     inline _Tp\n     accumulate(_IIter __begin, _IIter __end, _Tp __init, \n-\t       _BinaryOperation __binary_op) \n+               _BinaryOperation __binary_op) \n     {\n       typedef iterator_traits<_IIter> _IteratorTraits;\n       typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n       return __accumulate_switch(__begin, __end, __init, __binary_op, \n-\t\t\t       _IteratorCategory());\n+                               _IteratorCategory());\n     }\n \n \n   // Sequential fallback.\n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     inline _Tp\n     inner_product(_IIter1 __first1, _IIter1 __last1, \n-\t\t  _IIter2 __first2, _Tp __init,\n-\t\t  __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::inner_product(__first1, __last1, __first2, __init); }\n+                  _IIter2 __first2, _Tp __init,\n+                  __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::inner_product(\n+                               __first1, __last1, __first2, __init); }\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename BinaryFunction1, typename BinaryFunction2>\n+           typename BinaryFunction1, typename BinaryFunction2>\n     inline _Tp\n     inner_product(_IIter1 __first1, _IIter1 __last1, \n-\t\t  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n-\t\t  BinaryFunction2 __binary_op2, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::inner_product(__first1, __last1, __first2, __init, \n-\t\t\t\t\t   __binary_op1, __binary_op2); }\n+                  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n+                  BinaryFunction2 __binary_op2, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::inner_product(__first1, __last1, __first2, __init,\n+                                           __binary_op1, __binary_op2); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename _RAIter1, typename _RAIter2,\n-\t   typename _Tp, typename BinaryFunction1, typename BinaryFunction2>\n+           typename _Tp, typename BinaryFunction1, typename BinaryFunction2>\n     _Tp\n     __inner_product_switch(_RAIter1 __first1,\n-\t\t\t _RAIter1 __last1,\n-\t\t\t _RAIter2 __first2, _Tp __init,\n-\t\t\t BinaryFunction1 __binary_op1,\n-\t\t\t BinaryFunction2 __binary_op2,\n-\t\t\t random_access_iterator_tag,\n-\t\t\t random_access_iterator_tag,\n-\t\t\t __gnu_parallel::_Parallelism __parallelism_tag\n-\t\t\t = __gnu_parallel::parallel_unbalanced)\n+                         _RAIter1 __last1,\n+                         _RAIter2 __first2, _Tp __init,\n+                         BinaryFunction1 __binary_op1,\n+                         BinaryFunction2 __binary_op2,\n+                         random_access_iterator_tag,\n+                         random_access_iterator_tag,\n+                         __gnu_parallel::_Parallelism __parallelism_tag\n+                         = __gnu_parallel::parallel_unbalanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION((__last1 - __first1)\n-\t\t\t\t      >= __gnu_parallel::_Settings::get().\n-\t\t\t\t      accumulate_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      __is_parallel(__parallelism_tag)))\n-\t{\n-\t  _Tp __res = __init;\n-\t  __gnu_parallel::\n-\t    __inner_product_selector<_RAIter1,\n-\t    _RAIter2, _Tp> __my_selector(__first1, __first2);\n-\t  __gnu_parallel::\n-\t    for_each_template_random_access_ed(__first1, __last1, __binary_op2,\n-\t\t\t\t\t    __my_selector, __binary_op1,\n-\t\t\t\t\t    __res, __res, -1);\n-\t  return __res;\n-\t}\n+                                      >= __gnu_parallel::_Settings::get().\n+                                      accumulate_minimal_n\n+                                      && __gnu_parallel::\n+                                      __is_parallel(__parallelism_tag)))\n+        {\n+          _Tp __res = __init;\n+          __gnu_parallel::\n+            __inner_product_selector<_RAIter1,\n+            _RAIter2, _Tp> __my_selector(__first1, __first2);\n+          __gnu_parallel::\n+            for_each_template_random_access_ed(__first1, __last1, __binary_op2,\n+                                            __my_selector, __binary_op1,\n+                                            __res, __res, -1);\n+          return __res;\n+        }\n       else\n-\treturn inner_product(__first1, __last1, __first2, __init, \n-\t\t\t     __gnu_parallel::sequential_tag());\n+        return inner_product(__first1, __last1, __first2, __init, \n+                             __gnu_parallel::sequential_tag());\n     }\n \n   // No parallelism for input iterators.\n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename BinaryFunction1, typename BinaryFunction2,\n-\t   typename _IteratorTag1, typename _IteratorTag2>\n+           typename BinaryFunction1, typename BinaryFunction2,\n+           typename _IteratorTag1, typename _IteratorTag2>\n     inline _Tp\n     __inner_product_switch(_IIter1 __first1, _IIter1 __last1, \n-\t\t\t _IIter2 __first2, _Tp __init, \n-\t\t\t BinaryFunction1 __binary_op1,\n-\t\t\t BinaryFunction2 __binary_op2, \n-\t\t\t _IteratorTag1, _IteratorTag2)\n+                         _IIter2 __first2, _Tp __init, \n+                         BinaryFunction1 __binary_op1,\n+                         BinaryFunction2 __binary_op2, \n+                         _IteratorTag1, _IteratorTag2)\n     { return inner_product(__first1, __last1, __first2, __init,\n-\t\t\t   __binary_op1, __binary_op2,\n-\t\t\t   __gnu_parallel::sequential_tag()); }\n+                           __binary_op1, __binary_op2,\n+                           __gnu_parallel::sequential_tag()); }\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename BinaryFunction1, typename BinaryFunction2>\n+           typename BinaryFunction1, typename BinaryFunction2>\n     inline _Tp\n     inner_product(_IIter1 __first1, _IIter1 __last1, \n-\t\t  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n-\t\t  BinaryFunction2 __binary_op2, \n-\t\t  __gnu_parallel::_Parallelism __parallelism_tag)\n+                  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n+                  BinaryFunction2 __binary_op2, \n+                  __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n       typedef iterator_traits<_IIter1> _TraitsType1;\n       typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n \n       typedef iterator_traits<_IIter2> _TraitsType2;\n       typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n \n-      return __inner_product_switch(__first1, __last1, __first2, __init, __binary_op1, \n-\t\t\t\t  __binary_op2, _IteratorCategory1(), \n-\t\t\t\t  _IteratorCategory2(), __parallelism_tag);\n+      return __inner_product_switch(\n+               __first1, __last1, __first2, __init, __binary_op1,\n+               __binary_op2, _IteratorCategory1(), _IteratorCategory2(),\n+               __parallelism_tag);\n     }\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename BinaryFunction1, typename BinaryFunction2>\n+           typename BinaryFunction1, typename BinaryFunction2>\n     inline _Tp\n     inner_product(_IIter1 __first1, _IIter1 __last1, \n-\t\t  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n-\t\t  BinaryFunction2 __binary_op2)\n+                  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n+                  BinaryFunction2 __binary_op2)\n     {\n       typedef iterator_traits<_IIter1> _TraitsType1;\n       typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n \n       typedef iterator_traits<_IIter2> _TraitsType2;\n       typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n \n-      return __inner_product_switch(__first1, __last1, __first2, __init, __binary_op1, \n-\t\t\t\t  __binary_op2, _IteratorCategory1(),\n-\t\t\t\t  _IteratorCategory2());\n+      return __inner_product_switch(\n+               __first1, __last1, __first2, __init, __binary_op1, __binary_op2,\n+               _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     inline _Tp\n     inner_product(_IIter1 __first1, _IIter1 __last1, \n-\t\t  _IIter2 __first2, _Tp __init, \n-\t\t  __gnu_parallel::_Parallelism __parallelism_tag)\n+                  _IIter2 __first2, _Tp __init, \n+                  __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n       typedef iterator_traits<_IIter1> traits_type1;\n       typedef typename traits_type1::value_type value_type1;\n       typedef iterator_traits<_IIter2> traits_type2;\n       typedef typename traits_type2::value_type value_type2;\n \n       typedef typename\n-\t__gnu_parallel::_Multiplies<value_type1, value_type2>::__result\n+        __gnu_parallel::_Multiplies<value_type1, value_type2>::__result\n         _MultipliesResultType;\n       return inner_product(__first1, __last1, __first2, __init,\n                            __gnu_parallel::_Plus<_Tp, _MultipliesResultType>(),\n                            __gnu_parallel::\n-\t\t\t   _Multiplies<value_type1, value_type2>(),\n+                           _Multiplies<value_type1, value_type2>(),\n                            __parallelism_tag);\n     }\n \n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     inline _Tp\n     inner_product(_IIter1 __first1, _IIter1 __last1, \n-\t\t  _IIter2 __first2, _Tp __init)\n+                  _IIter2 __first2, _Tp __init)\n     {\n       typedef iterator_traits<_IIter1> traits_type1;\n       typedef typename traits_type1::value_type value_type1;\n       typedef iterator_traits<_IIter2> traits_type2;\n       typedef typename traits_type2::value_type value_type2;\n \n       typedef typename\n-\t__gnu_parallel::_Multiplies<value_type1, value_type2>::__result\n+        __gnu_parallel::_Multiplies<value_type1, value_type2>::__result\n         _MultipliesResultType;\n       return inner_product(__first1, __last1, __first2, __init,\n                            __gnu_parallel::_Plus<_Tp, _MultipliesResultType>(),\n                            __gnu_parallel::\n-\t\t\t   _Multiplies<value_type1, value_type2>());\n+                           _Multiplies<value_type1, value_type2>());\n     }\n \n   // Sequential fallback.\n   template<typename _IIter, typename _OutputIterator>\n     inline _OutputIterator\n     partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result,\n-\t\t__gnu_parallel::sequential_tag)\n+                __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::partial_sum(__begin, __end, __result); }\n \n   // Sequential fallback.\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     inline _OutputIterator\n     partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result,\n-\t\t_BinaryOperation __bin_op, __gnu_parallel::sequential_tag)\n+                _BinaryOperation __bin_op, __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::partial_sum(__begin, __end, __result, __bin_op); }\n \n   // Sequential fallback for input iterator case.\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation, typename _IteratorTag1,\n-\t   typename _IteratorTag2>\n+           typename _BinaryOperation, typename _IteratorTag1,\n+           typename _IteratorTag2>\n     inline _OutputIterator\n     __partial_sum_switch(_IIter __begin, _IIter __end,\n-\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t       _IteratorTag1, _IteratorTag2)\n+                       _OutputIterator __result, _BinaryOperation __bin_op,\n+                       _IteratorTag1, _IteratorTag2)\n     { return _GLIBCXX_STD_P::partial_sum(__begin, __end, __result, __bin_op); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     _OutputIterator\n     __partial_sum_switch(_IIter __begin, _IIter __end,\n-\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t       random_access_iterator_tag, random_access_iterator_tag)\n+                       _OutputIterator __result, _BinaryOperation __bin_op,\n+                       random_access_iterator_tag, random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n-\t    >= __gnu_parallel::_Settings::get().partial_sum_minimal_n))\n-\treturn __gnu_parallel::__parallel_partial_sum(__begin, __end,\n-\t\t\t\t\t\t    __result, __bin_op);\n+            static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n+            >= __gnu_parallel::_Settings::get().partial_sum_minimal_n))\n+        return __gnu_parallel::__parallel_partial_sum(__begin, __end,\n+                                                    __result, __bin_op);\n       else\n-\treturn partial_sum(__begin, __end, __result, __bin_op,\n-\t\t\t   __gnu_parallel::sequential_tag());\n+        return partial_sum(__begin, __end, __result, __bin_op,\n+                           __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n@@ -360,10 +363,10 @@ namespace __parallel\n \n   // Public interface\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     inline _OutputIterator\n     partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result,\n-\t\t_BinaryOperation __binary_op)\n+                _BinaryOperation __binary_op)\n     {\n       typedef iterator_traits<_IIter> traitsi_type;\n       typedef typename traitsi_type::iterator_category _IIteratorCategory;\n@@ -372,127 +375,131 @@ namespace __parallel\n       typedef typename _OTraitsType::iterator_category _OIterCategory;\n \n       return __partial_sum_switch(__begin, __end, __result, __binary_op,\n-\t\t\t\t_IIteratorCategory(), _OIterCategory());\n+                                _IIteratorCategory(), _OIterCategory());\n     }\n \n   // Sequential fallback.\n   template<typename _IIter, typename _OutputIterator>\n     inline _OutputIterator\n-    adjacent_difference(_IIter __begin, _IIter __end,\n-\t\t\t_OutputIterator __result, __gnu_parallel::sequential_tag)\n+    adjacent_difference(_IIter __begin, _IIter __end, _OutputIterator __result,\n+                        __gnu_parallel::sequential_tag)\n     { return _GLIBCXX_STD_P::adjacent_difference(__begin, __end, __result); }\n \n   // Sequential fallback.\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     inline _OutputIterator\n     adjacent_difference(_IIter __begin, _IIter __end,\n-\t\t\t_OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t\t__gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::adjacent_difference(__begin, __end, __result, __bin_op); }\n+                        _OutputIterator __result, _BinaryOperation __bin_op,\n+                        __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::adjacent_difference(\n+                               __begin, __end, __result, __bin_op); }\n \n   // Sequential fallback for input iterator case.\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation, typename _IteratorTag1,\n-\t   typename _IteratorTag2>\n+           typename _BinaryOperation, typename _IteratorTag1,\n+           typename _IteratorTag2>\n     inline _OutputIterator\n-    __adjacent_difference_switch(_IIter __begin, _IIter __end,\n-\t\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t\t     _IteratorTag1, _IteratorTag2)\n-    { return adjacent_difference(__begin, __end, __result, __bin_op,  \n-\t\t\t\t __gnu_parallel::sequential_tag()); }\n+    __adjacent_difference_switch(\n+      _IIter __begin, _IIter __end, _OutputIterator __result,\n+      _BinaryOperation __bin_op, _IteratorTag1, _IteratorTag2)\n+    { return adjacent_difference(__begin, __end, __result, __bin_op,\n+                                 __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     _OutputIterator\n-    __adjacent_difference_switch(_IIter __begin, _IIter __end,\n-\t\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t\t       random_access_iterator_tag, \n-\t\t\t       random_access_iterator_tag,\n-\t\t\t       __gnu_parallel::_Parallelism __parallelism_tag\n-\t\t\t       = __gnu_parallel::parallel_balanced)\n+    __adjacent_difference_switch(\n+      _IIter __begin, _IIter __end, _OutputIterator __result,\n+      _BinaryOperation __bin_op,\n+      random_access_iterator_tag, random_access_iterator_tag,\n+      __gnu_parallel::_Parallelism __parallelism_tag\n+                               = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n-\t    >= __gnu_parallel::_Settings::get().adjacent_difference_minimal_n\n-\t    && __gnu_parallel::__is_parallel(__parallelism_tag)))\n-\t{\n-\t  bool __dummy = true;\n-\t  typedef __gnu_parallel::_IteratorPair<_IIter, _OutputIterator,\n-\t    random_access_iterator_tag> _ItTrip;\n-\t  *__result = *__begin;\n-\t  _ItTrip begin_pair(__begin + 1, __result + 1),\n-\t    end_pair(__end, __result + (__end - __begin));\n-\t  __gnu_parallel::__adjacent_difference_selector<_ItTrip> __functionality;\n-\t  __gnu_parallel::\n-\t    for_each_template_random_access_ed(begin_pair, end_pair, __bin_op,\n-\t\t\t\t\t    __functionality,\n-\t\t\t\t\t    __gnu_parallel::_DummyReduct(),\n-\t\t\t\t\t    __dummy, __dummy, -1);\n-\t  return __functionality.finish_iterator;\n-\t}\n+            static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n+            >= __gnu_parallel::_Settings::get().adjacent_difference_minimal_n\n+            && __gnu_parallel::__is_parallel(__parallelism_tag)))\n+        {\n+          bool __dummy = true;\n+          typedef __gnu_parallel::_IteratorPair<_IIter, _OutputIterator,\n+            random_access_iterator_tag> _ItTrip;\n+          *__result = *__begin;\n+          _ItTrip begin_pair(__begin + 1, __result + 1),\n+            end_pair(__end, __result + (__end - __begin));\n+          __gnu_parallel::__adjacent_difference_selector<_ItTrip>\n+                                                            __functionality;\n+          __gnu_parallel::\n+            for_each_template_random_access_ed(begin_pair, end_pair, __bin_op,\n+                                            __functionality,\n+                                            __gnu_parallel::_DummyReduct(),\n+                                            __dummy, __dummy, -1);\n+          return __functionality.finish_iterator;\n+        }\n       else\n-\treturn adjacent_difference(__begin, __end, __result, __bin_op, \n-\t\t\t\t   __gnu_parallel::sequential_tag());\n+        return adjacent_difference(__begin, __end, __result, __bin_op, \n+                                   __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n   template<typename _IIter, typename _OutputIterator>\n     inline _OutputIterator\n     adjacent_difference(_IIter __begin, _IIter __end,\n-\t\t\t_OutputIterator __result,\n-\t\t\t__gnu_parallel::_Parallelism __parallelism_tag)\n+                        _OutputIterator __result,\n+                        __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n       typedef iterator_traits<_IIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n-      return adjacent_difference(__begin, __end, __result, std::minus<_ValueType>(),\n-\t\t\t\t __parallelism_tag);\n+      return adjacent_difference(\n+               __begin, __end, __result, std::minus<_ValueType>(),\n+               __parallelism_tag);\n     }\n \n   template<typename _IIter, typename _OutputIterator>\n     inline _OutputIterator\n     adjacent_difference(_IIter __begin, _IIter __end,\n-\t\t\t_OutputIterator __result)\n+                        _OutputIterator __result)\n     {\n       typedef iterator_traits<_IIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n-      return adjacent_difference(__begin, __end, __result, std::minus<_ValueType>());\n+      return adjacent_difference(__begin, __end, __result,\n+                                 std::minus<_ValueType>());\n     }\n \n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     inline _OutputIterator\n     adjacent_difference(_IIter __begin, _IIter __end,\n-\t\t\t_OutputIterator __result, _BinaryOperation __binary_op,\n-\t\t\t__gnu_parallel::_Parallelism __parallelism_tag)\n+                        _OutputIterator __result, _BinaryOperation __binary_op,\n+                        __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n       typedef iterator_traits<_IIter> traitsi_type;\n       typedef typename traitsi_type::iterator_category _IIteratorCategory;\n \n       typedef iterator_traits<_OutputIterator> _OTraitsType;\n       typedef typename _OTraitsType::iterator_category _OIterCategory;\n \n-      return __adjacent_difference_switch(__begin, __end, __result, __binary_op,\n-\t\t\t\t\t_IIteratorCategory(), \n-\t\t\t\t\t_OIterCategory(), __parallelism_tag);\n+      return __adjacent_difference_switch(\n+               __begin, __end, __result, __binary_op,\n+               _IIteratorCategory(), _OIterCategory(), __parallelism_tag);\n     }\n \n   template<typename _IIter, typename _OutputIterator,\n-\t   typename _BinaryOperation>\n+           typename _BinaryOperation>\n     inline _OutputIterator\n     adjacent_difference(_IIter __begin, _IIter __end,\n-\t\t\t_OutputIterator __result, _BinaryOperation __binary_op)\n+                        _OutputIterator __result, _BinaryOperation __binary_op)\n     {\n       typedef iterator_traits<_IIter> traitsi_type;\n       typedef typename traitsi_type::iterator_category _IIteratorCategory;\n \n       typedef iterator_traits<_OutputIterator> _OTraitsType;\n       typedef typename _OTraitsType::iterator_category _OIterCategory;\n \n-      return __adjacent_difference_switch(__begin, __end, __result, __binary_op,\n-\t\t\t\t\t_IIteratorCategory(), \n-\t\t\t\t\t_OIterCategory());\n+      return __adjacent_difference_switch(\n+               __begin, __end, __result, __binary_op,\n+               _IIteratorCategory(), _OIterCategory());\n     }\n } // end namespace\n } // end namespace"}, {"sha": "e8d887be05c336a5f3c0953910f0adb6865462db", "filename": "libstdc++-v3/include/parallel/numericfwd.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -61,24 +61,24 @@ namespace __parallel\n   template<typename _IIter, typename _Tp, typename _BinaryOper>\n     _Tp\n     accumulate(_IIter, _IIter, _Tp, _BinaryOper,\n-\t       __gnu_parallel::sequential_tag);\n+               __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _Tp, typename _BinaryOper>\n     _Tp\n     accumulate(_IIter, _IIter, _Tp, _BinaryOper,\n-\t       __gnu_parallel::_Parallelism);\n+               __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _Tp, typename _BinaryOper,\n-\t   typename _Tag>\n+           typename _Tag>\n     _Tp\n     __accumulate_switch(_IIter, _IIter, _Tp, _BinaryOper, _Tag);\n \n   template<typename _RAIter, typename _Tp, typename _BinaryOper>\n     _Tp\n     __accumulate_switch(_RAIter, _RAIter, _Tp, _BinaryOper,\n-\t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::_Parallelism __parallelism\n-\t\t      = __gnu_parallel::parallel_unbalanced);\n+                      random_access_iterator_tag,\n+                      __gnu_parallel::_Parallelism __parallelism\n+                      = __gnu_parallel::parallel_unbalanced);\n \n   template<typename _IIter, typename _OIter>\n     _OIter\n@@ -91,36 +91,36 @@ namespace __parallel\n   template<typename _IIter, typename _OIter>\n     _OIter\n     adjacent_difference(_IIter, _IIter, _OIter,\n-\t\t\t__gnu_parallel::sequential_tag);\n+                        __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n     adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t\t__gnu_parallel::sequential_tag);\n+                        __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n     _OIter\n     adjacent_difference(_IIter, _IIter, _OIter,\n-\t\t\t__gnu_parallel::_Parallelism);\n+                        __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n     adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t\t__gnu_parallel::_Parallelism);\n+                        __gnu_parallel::_Parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper,\n-\t   typename _Tag1, typename _Tag2>\n+           typename _Tag1, typename _Tag2>\n     _OIter\n     __adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper,\n-\t\t\t       _Tag1, _Tag2);\n+                               _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n     __adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t\t       random_access_iterator_tag, \n-\t\t\t       random_access_iterator_tag, \n-\t\t\t       __gnu_parallel::_Parallelism __parallelism\n-\t\t\t       = __gnu_parallel::parallel_unbalanced);\n+                               random_access_iterator_tag, \n+                               random_access_iterator_tag, \n+                               __gnu_parallel::_Parallelism __parallelism\n+                               = __gnu_parallel::parallel_unbalanced);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     _Tp\n@@ -129,46 +129,46 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n-\t\t  __gnu_parallel::sequential_tag);\n+                  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n-\t\t  __gnu_parallel::_Parallelism);\n+                  __gnu_parallel::_Parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename _BinaryFunction1, typename _BinaryFunction2>\n+           typename _BinaryFunction1, typename _BinaryFunction2>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n-\t\t  _BinaryFunction1, _BinaryFunction2);\n+                  _BinaryFunction1, _BinaryFunction2);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename _BinaryFunction1, typename _BinaryFunction2>\n+           typename _BinaryFunction1, typename _BinaryFunction2>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp, _BinaryFunction1,\n-\t\t  _BinaryFunction2, __gnu_parallel::sequential_tag);\n+                  _BinaryFunction2, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename BinaryFunction1, typename BinaryFunction2>\n+           typename BinaryFunction1, typename BinaryFunction2>\n     _Tp\n     inner_product(_IIter1, _IIter1, _IIter2, _Tp, BinaryFunction1,\n-\t\t  BinaryFunction2, __gnu_parallel::_Parallelism);\n+                  BinaryFunction2, __gnu_parallel::_Parallelism);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Tp,\n-\t   typename BinaryFunction1, typename BinaryFunction2>\n+           typename BinaryFunction1, typename BinaryFunction2>\n     _Tp\n     __inner_product_switch(_RAIter1, _RAIter1, _RAIter2, _Tp, BinaryFunction1, \n-\t\t\t BinaryFunction2, random_access_iterator_tag, \n-\t\t\t random_access_iterator_tag, \n-\t\t\t __gnu_parallel::_Parallelism\n-\t\t\t = __gnu_parallel::parallel_unbalanced);\n+                         BinaryFunction2, random_access_iterator_tag, \n+                         random_access_iterator_tag, \n+                         __gnu_parallel::_Parallelism\n+                         = __gnu_parallel::parallel_unbalanced);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp,\n-\t   typename _BinaryFunction1, typename _BinaryFunction2,\n-\t   typename _Tag1, typename _Tag2>\n+           typename _BinaryFunction1, typename _BinaryFunction2,\n+           typename _Tag1, typename _Tag2>\n     _Tp\n     __inner_product_switch(_IIter1, _IIter1, _IIter2, _Tp, _BinaryFunction1, \n-\t\t\t _BinaryFunction2, _Tag1, _Tag2);\n+                         _BinaryFunction2, _Tag1, _Tag2);\n \n \n   template<typename _IIter, typename _OIter>\n@@ -178,7 +178,7 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n     partial_sum(_IIter, _IIter, _OIter, _BinaryOper,\n-\t\t__gnu_parallel::sequential_tag);\n+                __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n     _OIter\n@@ -189,14 +189,14 @@ namespace __parallel\n     partial_sum(_IIter, _IIter, _OIter, _BinaryOper);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper,\n-\t   typename _Tag1, typename _Tag2>\n+           typename _Tag1, typename _Tag2>\n     _OIter\n     __partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n     __partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper,\n-\t\t       random_access_iterator_tag, random_access_iterator_tag);\n+                       random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace\n } // end namespace\n "}, {"sha": "7147961df980aea47c33b282d0dacc415a6d7d76", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -59,18 +59,15 @@ namespace __gnu_parallel\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n template<typename _RAIter,\n-\t typename _Op,\n-\t typename _Fu,\n-\t typename _Red,\n-\t typename _Result>\n+         typename _Op,\n+         typename _Fu,\n+         typename _Red,\n+         typename _Result>\n   _Op\n-  for_each_template_random_access_omp_loop(_RAIter __begin,\n-\t\t\t\t\t   _RAIter __end,\n-\t\t\t\t\t   _Op __o, _Fu& __f, _Red __r, _Result __base,\n-\t\t\t\t\t   _Result& __output,\n-\t\t\t\t\t   typename std::iterator_traits\n-\t\t\t\t\t   <_RAIter>::\n-\t\t\t\t\t   difference_type __bound)\n+  for_each_template_random_access_omp_loop(\n+    _RAIter __begin, _RAIter __end, _Op __o, _Fu& __f, _Red __r,\n+    _Result __base, _Result& __output,\n+    typename std::iterator_traits<_RAIter>::difference_type __bound)\n   {\n     typedef typename\n         std::iterator_traits<_RAIter>::difference_type\n@@ -95,7 +92,7 @@ template<typename _RAIter,\n \n         _ThreadIndex __iam = omp_get_thread_num();\n \n-#      pragma omp for schedule(dynamic, _Settings::get().workstealing_chunk_size)\n+#pragma omp for schedule(dynamic, _Settings::get().workstealing_chunk_size)\n         for (_DifferenceType __pos = 0; __pos < __length; ++__pos)\n           __thread_results[__iam] =\n               __r(__thread_results[__iam], __f(__o, __begin+__pos));"}, {"sha": "cc3443ba1a91ceba8c6708adcb84a5aa4ef15c0b", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -59,18 +59,15 @@ namespace __gnu_parallel\n    *  @return User-supplied functor (that may contain a part of the result).\n    */\n template<typename _RAIter,\n-\t typename _Op,\n-\t typename _Fu,\n-\t typename _Red,\n-\t typename _Result>\n+         typename _Op,\n+         typename _Fu,\n+         typename _Red,\n+         typename _Result>\n   _Op\n-  for_each_template_random_access_omp_loop_static(_RAIter __begin,\n-\t\t\t\t\t\t  _RAIter __end,\n-\t\t\t\t\t\t  _Op __o, _Fu& __f, _Red __r,\n-\t\t\t\t\t\t  _Result __base, _Result& __output,\n-\t\t\t\t\t\t  typename std::iterator_traits\n-\t\t\t\t\t\t  <_RAIter>::\n-\t\t\t\t\t\t  difference_type __bound)\n+  for_each_template_random_access_omp_loop_static(\n+    _RAIter __begin, _RAIter __end, _Op __o, _Fu& __f, _Red __r,\n+    _Result __base, _Result& __output,\n+    typename std::iterator_traits<_RAIter>::difference_type __bound)\n   {\n     typedef typename\n       std::iterator_traits<_RAIter>::difference_type\n@@ -95,9 +92,10 @@ template<typename _RAIter,\n \n         _ThreadIndex __iam = omp_get_thread_num();\n \n-#       pragma omp for schedule(static, _Settings::get().workstealing_chunk_size)\n+#pragma omp for schedule(static, _Settings::get().workstealing_chunk_size)\n         for (_DifferenceType __pos = 0; __pos < __length; ++__pos)\n-          __thread_results[__iam] = __r(__thread_results[__iam], __f(__o, __begin+__pos));\n+          __thread_results[__iam] = __r(__thread_results[__iam],\n+                                        __f(__o, __begin+__pos));\n       } //parallel\n \n     for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)"}, {"sha": "0a71831342e38a764b15cf16945630207537a626", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -60,18 +60,15 @@ namespace __gnu_parallel\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n template<typename _RAIter,\n-\t typename _Op,\n-\t typename _Fu,\n-\t typename _Red,\n-\t typename _Result>\n+         typename _Op,\n+         typename _Fu,\n+         typename _Red,\n+         typename _Result>\n   _Op\n-  for_each_template_random_access_ed(_RAIter __begin,\n-\t\t\t\t     _RAIter __end,\n-\t\t\t\t     _Op __o, _Fu& __f, _Red __r, _Result __base,\n-\t\t\t\t     _Result& __output,\n-\t\t\t\t     typename std::iterator_traits\n-\t\t\t\t     <_RAIter>::\n-\t\t\t\t     difference_type __bound)\n+  for_each_template_random_access_ed(\n+    _RAIter __begin, _RAIter __end, _Op __o, _Fu& __f, _Red __r,\n+    _Result __base, _Result& __output,\n+    typename std::iterator_traits<_RAIter>::difference_type __bound)\n   {\n     typedef std::iterator_traits<_RAIter> _TraitsType;\n     typedef typename _TraitsType::difference_type _DifferenceType;\n@@ -87,15 +84,17 @@ template<typename _RAIter,\n #       pragma omp single\n           {\n             __num_threads = omp_get_num_threads();\n-            __thread_results = static_cast<_Result*>(\n-                                ::operator new(__num_threads * sizeof(_Result)));\n+            __thread_results =\n+              static_cast<_Result*>(\n+                            ::operator new(__num_threads * sizeof(_Result)));\n             __constructed = new bool[__num_threads];\n           }\n \n         _ThreadIndex __iam = omp_get_thread_num();\n \n         // Neutral element.\n-        _Result* __reduct = static_cast<_Result*>(::operator new(sizeof(_Result)));\n+        _Result* __reduct =\n+                   static_cast<_Result*>(::operator new(sizeof(_Result)));\n \n         _DifferenceType\n             __start = equally_split_point(__length, __num_threads, __iam),"}, {"sha": "b121e1ff8c72fa3691e10750bf14299ec872b5ce", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -52,13 +52,13 @@ namespace __gnu_parallel\n   *  element is unknown in general.\n   *  @return End iterator of output sequence. */\n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _BinaryOperation>\n+         typename _OutputIterator,\n+         typename _BinaryOperation>\n   _OutputIterator\n-  __parallel_partial_sum_basecase(_IIter __begin, _IIter __end,\n-\t\t\t\t_OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t\t\ttypename std::iterator_traits\n-\t\t\t\t<_IIter>::value_type __value)\n+  __parallel_partial_sum_basecase(\n+    _IIter __begin, _IIter __end, _OutputIterator __result,\n+    _BinaryOperation __bin_op,\n+    typename std::iterator_traits <_IIter>::value_type __value)\n   {\n     if (__begin == __end)\n       return __result;\n@@ -84,13 +84,13 @@ template<typename _IIter,\n     *  @return End iterator of output sequence.\n     */\n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _BinaryOperation>\n+         typename _OutputIterator,\n+         typename _BinaryOperation>\n   _OutputIterator\n-  __parallel_partial_sum_linear(_IIter __begin, _IIter __end,\n-\t\t\t      _OutputIterator __result, _BinaryOperation __bin_op,\n-\t\t\t      typename std::iterator_traits\n-\t\t\t      <_IIter>::difference_type __n)\n+  __parallel_partial_sum_linear(\n+        _IIter __begin, _IIter __end, _OutputIterator __result,\n+        _BinaryOperation __bin_op,\n+        typename std::iterator_traits<_IIter>::difference_type __n)\n   {\n     typedef std::iterator_traits<_IIter> _TraitsType;\n     typedef typename _TraitsType::value_type _ValueType;\n@@ -128,8 +128,8 @@ template<typename _IIter,\n               {\n                 _DifferenceType __chunk_length =\n                     ((double)__n\n-\t\t     / ((double)__num_threads + __s.partial_sum_dilation)),\n-\t\t  __borderstart = __n - __num_threads * __chunk_length;\n+                     / ((double)__num_threads + __s.partial_sum_dilation)),\n+                  __borderstart = __n - __num_threads * __chunk_length;\n                 __borders[0] = 0;\n                 for (int __i = 1; __i < (__num_threads + 1); ++__i)\n                   {\n@@ -140,41 +140,43 @@ template<typename _IIter,\n               }\n \n             __sums = static_cast<_ValueType*>(::operator new(sizeof(_ValueType)\n-\t\t\t\t\t\t\t   * __num_threads));\n+                                                           * __num_threads));\n             _OutputIterator __target_end;\n           } //single\n \n         _ThreadIndex __iam = omp_get_thread_num();\n         if (__iam == 0)\n           {\n             *__result = *__begin;\n-            __parallel_partial_sum_basecase(__begin + 1, __begin + __borders[1],\n-\t\t\t\t\t  __result + 1, __bin_op, *__begin);\n+            __parallel_partial_sum_basecase(\n+                __begin + 1, __begin + __borders[1], __result + 1,\n+                __bin_op, *__begin);\n             ::new(&(__sums[__iam])) _ValueType(*(__result + __borders[1] - 1));\n           }\n         else\n           {\n             ::new(&(__sums[__iam]))\n-\t      _ValueType(std::accumulate(__begin + __borders[__iam] + 1,\n-\t\t\t\t\t __begin + __borders[__iam + 1],\n-\t\t\t\t\t *(__begin + __borders[__iam]),\n-\t\t\t\t\t __bin_op,\n-\t\t\t\t\t __gnu_parallel::sequential_tag()));\n+              _ValueType(std::accumulate(__begin + __borders[__iam] + 1,\n+                                         __begin + __borders[__iam + 1],\n+                                         *(__begin + __borders[__iam]),\n+                                         __bin_op,\n+                                         __gnu_parallel::sequential_tag()));\n           }\n \n #       pragma omp barrier\n \n #       pragma omp single\n-          __parallel_partial_sum_basecase(\n-              __sums + 1, __sums + __num_threads, __sums + 1, __bin_op, __sums[0]);\n+          __parallel_partial_sum_basecase(__sums + 1, __sums + __num_threads,\n+                                          __sums + 1, __bin_op, __sums[0]);\n \n #       pragma omp barrier\n \n         // Still same team.\n-        __parallel_partial_sum_basecase(__begin + __borders[__iam + 1],\n-\t\t\t\t      __begin + __borders[__iam + 2],\n-\t\t\t\t      __result + __borders[__iam + 1], __bin_op,\n-\t\t\t\t      __sums[__iam]);\n+        __parallel_partial_sum_basecase(\n+                __begin + __borders[__iam + 1],\n+                __begin + __borders[__iam + 2],\n+                __result + __borders[__iam + 1],\n+                __bin_op, __sums[__iam]);\n       } //parallel\n \n     ::operator delete(__sums);\n@@ -190,8 +192,8 @@ template<typename _IIter,\n   *  @param __bin_op Associative binary function.\n   *  @return End iterator of output sequence. */\n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _BinaryOperation>\n+         typename _OutputIterator,\n+         typename _BinaryOperation>\n   _OutputIterator\n   __parallel_partial_sum(_IIter __begin, _IIter __end,\n                        _OutputIterator __result, _BinaryOperation __bin_op)\n@@ -208,7 +210,8 @@ template<typename _IIter,\n       {\n       case LINEAR:\n         // Need an initial offset.\n-        return __parallel_partial_sum_linear(__begin, __end, __result, __bin_op, __n);\n+        return __parallel_partial_sum_linear(\n+                 __begin, __end, __result, __bin_op, __n);\n       default:\n     // Partial_sum algorithm not implemented.\n         _GLIBCXX_PARALLEL_ASSERT(0);"}, {"sha": "f50e83bbfd3103bc62e48dc16437a129f566ef05", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -88,9 +88,10 @@ template<typename _RAIter, typename _Predicate>\n             __reserved_right = new bool[__num_threads];\n \n             if (__s.partition_chunk_share > 0.0)\n-              __chunk_size = std::max<_DifferenceType>(__s.partition_chunk_size,\n-\t\t\t\t    (double)__n * __s.partition_chunk_share\n-\t\t\t\t\t\t     / (double)__num_threads);\n+              __chunk_size = std::max<_DifferenceType>(\n+                __s.partition_chunk_size,\n+                (double)__n * __s.partition_chunk_share /\n+                    (double)__num_threads);\n             else\n               __chunk_size = __s.partition_chunk_size;\n           }\n@@ -99,7 +100,8 @@ template<typename _RAIter, typename _Predicate>\n           {\n #           pragma omp single\n               {\n-                _DifferenceType __num_chunks = (__right - __left + 1) / __chunk_size;\n+                _DifferenceType __num_chunks\n+                    = (__right - __left + 1) / __chunk_size;\n \n                 for (int __r = 0; __r < __num_threads; ++__r)\n                   {\n@@ -198,7 +200,8 @@ template<typename _RAIter, typename _Predicate>\n                 && __thread_left_border >= __leftnew)\n               {\n                 // Chunk already in place, reserve spot.\n-                __reserved_left[(__left - (__thread_left_border + 1)) / __chunk_size]\n+                __reserved_left\n+                  [(__left - (__thread_left_border + 1)) / __chunk_size]\n                     = true;\n               }\n \n@@ -208,7 +211,7 @@ template<typename _RAIter, typename _Predicate>\n               {\n                 // Chunk already in place, reserve spot.\n                 __reserved_right[((__thread_right_border - 1) - __right)\n-\t\t\t       / __chunk_size] = true;\n+                               / __chunk_size] = true;\n               }\n \n #           pragma omp barrier\n@@ -233,9 +236,9 @@ template<typename _RAIter, typename _Predicate>\n #endif\n \n                 std::swap_ranges(__begin + __thread_left_border\n-\t\t\t\t - (__chunk_size - 1),\n-\t\t\t\t __begin + __thread_left_border + 1,\n-\t\t\t\t __begin + __swapstart);\n+                                 - (__chunk_size - 1),\n+                                 __begin + __thread_left_border + 1,\n+                                 __begin + __swapstart);\n               }\n \n             if (thread_right >= __thread_right_border\n@@ -257,9 +260,10 @@ template<typename _RAIter, typename _Predicate>\n                 _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n #endif\n \n-                std::swap_ranges(__begin + __thread_right_border,\n-\t\t\t\t __begin + __thread_right_border + __chunk_size,\n-\t\t\t\t __begin + __swapstart);\n+                std::swap_ranges(\n+                    __begin + __thread_right_border,\n+                    __begin + __thread_right_border + __chunk_size,\n+                    __begin + __swapstart);\n               }\n #if _GLIBCXX_ASSERTIONS\n #             pragma omp barrier\n@@ -328,7 +332,7 @@ template<typename _RAIter, typename _Predicate>\n template<typename _RAIter, typename _Compare>\n   void \n   parallel_nth_element(_RAIter __begin, _RAIter __nth, \n-\t\t       _RAIter __end, _Compare __comp)\n+                       _RAIter __end, _Compare __comp)\n   {\n     typedef std::iterator_traits<_RAIter> _TraitsType;\n     typedef typename _TraitsType::value_type _ValueType;\n@@ -355,18 +359,19 @@ template<typename _RAIter, typename _Compare>\n         __pivot_pos = __end - 1;\n \n         // XXX _Compare must have first__ValueType, second__ValueType,\n-\t// _ResultType\n+        // _ResultType\n         // _Compare == __gnu_parallel::_Lexicographic<S, int,\n-\t// __gnu_parallel::_Less<S, S> >\n+        // __gnu_parallel::_Less<S, S> >\n         // __pivot_pos == std::pair<S, int>*\n         // XXX binder2nd only for _RAIters??\n         __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n-\t  __pred(__comp, *__pivot_pos);\n+          __pred(__comp, *__pivot_pos);\n \n         // Divide, leave pivot unchanged in last place.\n         _RAIter __split_pos1, __split_pos2;\n-        __split_pos1 = __begin + __parallel_partition(__begin, __end - 1, __pred,\n-\t\t\t\t\t\t__get_max_threads());\n+        __split_pos1 = __begin\n+                       + __parallel_partition(__begin, __end - 1, __pred,\n+                                              __get_max_threads());\n \n         // Left side: < __pivot_pos; __right side: >= __pivot_pos\n \n@@ -377,18 +382,18 @@ template<typename _RAIter, typename _Compare>\n \n         // In case all elements are equal, __split_pos1 == 0\n         if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n-\t    || (__end - __split_pos1) < (__n >> 7))\n+            || (__end - __split_pos1) < (__n >> 7))\n           {\n             // Very unequal split, one part smaller than one 128th\n             // elements not strictly larger than the pivot.\n             __gnu_parallel::__unary_negate<__gnu_parallel::\n-\t      __binder1st<_Compare, _ValueType, _ValueType, bool>, _ValueType>\n-\t      __pred(__gnu_parallel::__binder1st<_Compare, _ValueType,\n-\t\t   _ValueType, bool>(__comp, *__pivot_pos));\n+              __binder1st<_Compare, _ValueType, _ValueType, bool>, _ValueType>\n+              __pred(__gnu_parallel::__binder1st<_Compare, _ValueType,\n+                   _ValueType, bool>(__comp, *__pivot_pos));\n \n             // Find other end of pivot-equal range.\n             __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n-\t\t\t\t\t\t     __end, __pred);\n+                                                     __end, __pred);\n           }\n         else\n           // Only skip the pivot.\n@@ -415,8 +420,8 @@ template<typename _RAIter, typename _Compare>\n template<typename _RAIter, typename _Compare>\n   void\n   parallel_partial_sort(_RAIter __begin,\n-\t\t\t_RAIter __middle,\n-\t\t\t_RAIter __end, _Compare __comp)\n+                        _RAIter __middle,\n+                        _RAIter __end, _Compare __comp)\n   {\n     parallel_nth_element(__begin, __middle, __end, __comp);\n     std::sort(__begin, __middle, __comp);"}, {"sha": "348bb1ac90088afa196924fbf6646df4645e9b6c", "filename": "libstdc++-v3/include/parallel/queue.h", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -59,17 +59,17 @@ namespace __gnu_parallel\n       _SequenceIndex _M_max_size;\n \n       /** @brief Cyclic __begin and __end pointers contained in one\n-\t  atomically changeable value. */\n+          atomically changeable value. */\n       _GLIBCXX_VOLATILE _CASable _M_borders;\n \n     public:\n       /** @brief Constructor. Not to be called concurrent, of course.\n        *  @param _M_max_size Maximal number of elements to be contained. */\n       _RestrictedBoundedConcurrentQueue(_SequenceIndex _M_max_size)\n       {\n-\tthis->_M_max_size = _M_max_size;\n-\t_M_base = new _Tp[_M_max_size];\n-\t_M_borders = __encode2(0, 0);\n+        this->_M_max_size = _M_max_size;\n+        _M_base = new _Tp[_M_max_size];\n+        _M_borders = __encode2(0, 0);\n #pragma omp flush\n       }\n \n@@ -82,67 +82,73 @@ namespace __gnu_parallel\n       void\n       push_front(const _Tp& __t)\n       {\n-\t_CASable __former_borders = _M_borders;\n-\tint __former_front, __former_back;\n-\tdecode2(__former_borders, __former_front, __former_back);\n-\t*(_M_base + __former_front % _M_max_size) = __t;\n+        _CASable __former_borders = _M_borders;\n+        int __former_front, __former_back;\n+        decode2(__former_borders, __former_front, __former_back);\n+        *(_M_base + __former_front % _M_max_size) = __t;\n #if _GLIBCXX_ASSERTIONS\n-\t// Otherwise: front - back > _M_max_size eventually.\n-\t_GLIBCXX_PARALLEL_ASSERT(((__former_front + 1) - __former_back)\n-\t\t\t\t <= _M_max_size);\n+        // Otherwise: front - back > _M_max_size eventually.\n+        _GLIBCXX_PARALLEL_ASSERT(((__former_front + 1) - __former_back)\n+                                 <= _M_max_size);\n #endif\n-\t__fetch_and_add(&_M_borders, __encode2(1, 0));\n+        __fetch_and_add(&_M_borders, __encode2(1, 0));\n       }\n \n       /** @brief Pops one element from the queue at the front end.\n        *  Must not be called concurrently with pop_front(). */\n       bool\n       pop_front(_Tp& __t)\n       {\n-\tint __former_front, __former_back;\n+        int __former_front, __former_back;\n #pragma omp flush\n-\tdecode2(_M_borders, __former_front, __former_back);\n-\twhile (__former_front > __former_back)\n-\t  {\n-\t    // Chance.\n-\t    _CASable __former_borders = __encode2(__former_front, __former_back);\n-\t    _CASable __new_borders = __encode2(__former_front - 1, __former_back);\n-\t    if (__compare_and_swap(&_M_borders, __former_borders, __new_borders))\n-\t      {\n-\t\t__t = *(_M_base + (__former_front - 1) % _M_max_size);\n-\t\treturn true;\n-\t      }\n+        decode2(_M_borders, __former_front, __former_back);\n+        while (__former_front > __former_back)\n+          {\n+            // Chance.\n+            _CASable\n+                __former_borders = __encode2(__former_front, __former_back);\n+            _CASable\n+                __new_borders = __encode2(__former_front - 1, __former_back);\n+            if (__compare_and_swap(\n+                  &_M_borders, __former_borders, __new_borders))\n+              {\n+                __t = *(_M_base + (__former_front - 1) % _M_max_size);\n+                return true;\n+              }\n #pragma omp flush\n-\t    decode2(_M_borders, __former_front, __former_back);\n-\t  }\n-\treturn false;\n+            decode2(_M_borders, __former_front, __former_back);\n+          }\n+        return false;\n       }\n \n       /** @brief Pops one element from the queue at the front end.\n        *  Must not be called concurrently with pop_front(). */\n       bool\n-      pop_back(_Tp& __t)\t//queue behavior\n+      pop_back(_Tp& __t)        //queue behavior\n       {\n-\tint __former_front, __former_back;\n+        int __former_front, __former_back;\n #pragma omp flush\n-\tdecode2(_M_borders, __former_front, __former_back);\n-\twhile (__former_front > __former_back)\n-\t  {\n-\t    // Chance.\n-\t    _CASable __former_borders = __encode2(__former_front, __former_back);\n-\t    _CASable __new_borders = __encode2(__former_front, __former_back + 1);\n-\t    if (__compare_and_swap(&_M_borders, __former_borders, __new_borders))\n-\t      {\n-\t\t__t = *(_M_base + __former_back % _M_max_size);\n-\t\treturn true;\n-\t      }\n+        decode2(_M_borders, __former_front, __former_back);\n+        while (__former_front > __former_back)\n+          {\n+            // Chance.\n+            _CASable\n+              __former_borders = __encode2(__former_front, __former_back);\n+            _CASable\n+              __new_borders = __encode2(__former_front, __former_back + 1);\n+            if (__compare_and_swap(\n+                  &_M_borders, __former_borders, __new_borders))\n+              {\n+                __t = *(_M_base + __former_back % _M_max_size);\n+                return true;\n+              }\n #pragma omp flush\n-\t    decode2(_M_borders, __former_front, __former_back);\n-\t  }\n-\treturn false;\n+            decode2(_M_borders, __former_front, __former_back);\n+          }\n+        return false;\n       }\n   };\n-}\t//namespace __gnu_parallel\n+}       //namespace __gnu_parallel\n \n #undef _GLIBCXX_VOLATILE\n "}, {"sha": "1ed46b4a77fd6e2f7481a47e5214d5974792d70f", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -49,12 +49,12 @@ namespace __gnu_parallel\n   template<typename _RAIter, typename _Compare>\n     typename std::iterator_traits<_RAIter>::difference_type\n     __parallel_sort_qs_divide(_RAIter __begin,\n-\t\t\t    _RAIter __end,\n-\t\t\t    _Compare __comp, typename std::iterator_traits\n-\t\t\t    <_RAIter>::difference_type __pivot_rank,\n-\t\t\t    typename std::iterator_traits\n-\t\t\t    <_RAIter>::difference_type\n-\t\t\t    __num_samples, _ThreadIndex __num_threads)\n+                            _RAIter __end,\n+                            _Compare __comp, typename std::iterator_traits\n+                            <_RAIter>::difference_type __pivot_rank,\n+                            typename std::iterator_traits\n+                            <_RAIter>::difference_type\n+                            __num_samples, _ThreadIndex __num_threads)\n     {\n       typedef std::iterator_traits<_RAIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n@@ -65,15 +65,15 @@ namespace __gnu_parallel\n \n       // Allocate uninitialized, to avoid default constructor.\n       _ValueType* __samples =\n-\tstatic_cast<_ValueType*>(::operator new(__num_samples\n-\t\t\t\t\t\t* sizeof(_ValueType)));\n+        static_cast<_ValueType*>(::operator new(__num_samples\n+                                                * sizeof(_ValueType)));\n \n       for (_DifferenceType __s = 0; __s < __num_samples; ++__s)\n-\t{\n-\t  const unsigned long long __index = static_cast<unsigned long long>(__s)\n-\t    * __n / __num_samples;\n-\t  ::new(&(__samples[__s])) _ValueType(__begin[__index]);\n-\t}\n+        {\n+          const unsigned long long __index\n+            = static_cast<unsigned long long>(__s) * __n / __num_samples;\n+          ::new(&(__samples[__s])) _ValueType(__begin[__index]);\n+        }\n \n       __gnu_sequential::sort(__samples, __samples + __num_samples, __comp);\n \n@@ -99,47 +99,47 @@ namespace __gnu_parallel\n   template<typename _RAIter, typename _Compare>\n     void\n     __parallel_sort_qs_conquer(_RAIter __begin,\n-\t\t\t     _RAIter __end,\n-\t\t\t     _Compare __comp,\n-\t\t\t     _ThreadIndex __num_threads)\n+                             _RAIter __end,\n+                             _Compare __comp,\n+                             _ThreadIndex __num_threads)\n     {\n       typedef std::iterator_traits<_RAIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n       typedef typename _TraitsType::difference_type _DifferenceType;\n \n       if (__num_threads <= 1)\n-\t{\n-\t  __gnu_sequential::sort(__begin, __end, __comp);\n-\t  return;\n-\t}\n+        {\n+          __gnu_sequential::sort(__begin, __end, __comp);\n+          return;\n+        }\n \n       _DifferenceType __n = __end - __begin, __pivot_rank;\n \n       if (__n <= 1)\n-\treturn;\n+        return;\n \n       _ThreadIndex __num_threads_left;\n \n       if ((__num_threads % 2) == 1)\n-\t__num_threads_left = __num_threads / 2 + 1;\n+        __num_threads_left = __num_threads / 2 + 1;\n       else\n-\t__num_threads_left = __num_threads / 2;\n+        __num_threads_left = __num_threads / 2;\n \n       __pivot_rank = __n * __num_threads_left / __num_threads;\n \n       _DifferenceType __split =\n-\t__parallel_sort_qs_divide(__begin, __end, __comp, __pivot_rank,\n-\t\t\t\t_Settings::get().sort_qs_num_samples_preset,\n-\t\t\t\t__num_threads);\n+        __parallel_sort_qs_divide(__begin, __end, __comp, __pivot_rank,\n+                                _Settings::get().sort_qs_num_samples_preset,\n+                                __num_threads);\n \n #pragma omp parallel sections num_threads(2)\n       {\n #pragma omp section\n-\t__parallel_sort_qs_conquer(__begin, __begin + __split,\n-\t\t\t\t __comp, __num_threads_left);\n+        __parallel_sort_qs_conquer(__begin, __begin + __split,\n+                                 __comp, __num_threads_left);\n #pragma omp section\n-\t__parallel_sort_qs_conquer(__begin + __split, __end,\n-\t\t\t\t __comp, __num_threads - __num_threads_left);\n+        __parallel_sort_qs_conquer(__begin + __split, __end,\n+                                 __comp, __num_threads - __num_threads_left);\n       }\n     }\n \n@@ -155,9 +155,9 @@ namespace __gnu_parallel\n   template<typename _RAIter, typename _Compare>\n     void\n     __parallel_sort_qs(_RAIter __begin,\n-\t\t     _RAIter __end,\n-\t\t     _Compare __comp,\n-\t\t     _ThreadIndex __num_threads)\n+                     _RAIter __end,\n+                     _Compare __comp,\n+                     _ThreadIndex __num_threads)\n     {\n       _GLIBCXX_CALL(__n)\n \n@@ -171,7 +171,8 @@ namespace __gnu_parallel\n       if (__num_threads > __n)\n         __num_threads = static_cast<_ThreadIndex>(__n);\n \n-      __parallel_sort_qs_conquer(__begin, __begin + __n, __comp, __num_threads);\n+      __parallel_sort_qs_conquer(\n+        __begin, __begin + __n, __comp, __num_threads);\n     }\n \n } //namespace __gnu_parallel"}, {"sha": "6447087ebbb183d7be138dadb1949e1dafc07b90", "filename": "libstdc++-v3/include/parallel/random_number.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -41,32 +41,32 @@ namespace __gnu_parallel\n   class _RandomNumber\n   {\n   private:\n-    std::tr1::mt19937 \t_M_mt;\n-    uint64 \t\t_M_supremum;\n-    uint64 \t\t_M_rand_sup;\n-    double \t\t_M_supremum_reciprocal;\n-    double \t\t_M_rand_sup_reciprocal;\n+    std::tr1::mt19937   _M_mt;\n+    uint64              _M_supremum;\n+    uint64              _M_rand_sup;\n+    double              _M_supremum_reciprocal;\n+    double              _M_rand_sup_reciprocal;\n \n     // Assumed to be twice as long as the usual random number.\n-    uint64 \t\t__cache;  \n+    uint64              __cache;  \n \n     // Bit results.\n     int __bits_left;\n     \n     static uint32\n     __scale_down(uint64 __x,\n #if _GLIBCXX_SCALE_DOWN_FPU\n-\t       uint64 /*_M_supremum*/, double _M_supremum_reciprocal)\n+               uint64 /*_M_supremum*/, double _M_supremum_reciprocal)\n #else\n                uint64 _M_supremum, double /*_M_supremum_reciprocal*/)\n #endif\n-\t{\n+        {\n #if _GLIBCXX_SCALE_DOWN_FPU\n-\t  return uint32(__x * _M_supremum_reciprocal);\n+          return uint32(__x * _M_supremum_reciprocal);\n #else\n-\t  return static_cast<uint32>(__x % _M_supremum);\n+          return static_cast<uint32>(__x % _M_supremum);\n #endif\n-\t}\n+        }\n \n   public:\n     /** @brief Default constructor. Seed with 0. */\n@@ -94,12 +94,12 @@ namespace __gnu_parallel\n     { return __scale_down(_M_mt(), _M_supremum, _M_supremum_reciprocal); }\n \n     /** @brief Generate unsigned random 32-bit integer in the\n-\tinterval @__c [0,local_supremum). */\n+        interval @__c [0,local_supremum). */\n     uint32\n     operator()(uint64 local_supremum)\n     {\n       return __scale_down(_M_mt(), local_supremum,\n-\t\t\tdouble(local_supremum * _M_rand_sup_reciprocal));\n+                        double(local_supremum * _M_rand_sup_reciprocal));\n     }\n \n     /** @brief Generate a number of random bits, run-time parameter.\n@@ -111,10 +111,10 @@ namespace __gnu_parallel\n       __cache = __cache >> __bits;\n       __bits_left -= __bits;\n       if (__bits_left < 32)\n-\t{\n-\t  __cache |= ((uint64(_M_mt())) << __bits_left);\n-\t  __bits_left += 32;\n-\t}\n+        {\n+          __cache |= ((uint64(_M_mt())) << __bits_left);\n+          __bits_left += 32;\n+        }\n       return __res;\n     }\n };"}, {"sha": "49d0d8557b736668d3e9ed2dd74c29e39dfa4e7d", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -70,7 +70,7 @@ template<typename _RAIter>\n     _DifferenceType* _M_starts;\n \n     /** @brief Number of the thread that will further process the\n-\tcorresponding bin. */\n+        corresponding bin. */\n     _ThreadIndex* _M_bin_proc;\n \n     /** @brief Number of bins to distribute to. */\n@@ -131,7 +131,8 @@ template<typename _RAIter, typename RandomNumberGenerator>\n     _DRandomShufflingGlobalData<_RAIter>* _M_sd = d->_M_sd;\n \n     // Indexing: _M_dist[bin][processor]\n-    _DifferenceType __length = _M_sd->_M_starts[__iam + 1] - _M_sd->_M_starts[__iam];\n+    _DifferenceType __length = _M_sd->_M_starts[__iam + 1] -\n+                               _M_sd->_M_starts[__iam];\n     _BinIndex* __oracles = new _BinIndex[__length];\n     _DifferenceType* _M_dist = new _DifferenceType[_M_sd->_M_num_bins + 1];\n     _BinIndex* _M_bin_proc = new _BinIndex[_M_sd->_M_num_bins];\n@@ -161,12 +162,13 @@ template<typename _RAIter, typename RandomNumberGenerator>\n \n #   pragma omp single\n     {\n-      // Sum up bins, _M_sd->_M_dist[__s + 1][d->_M_num_threads] now contains the\n-      // total number of items in bin __s\n+      // Sum up bins, _M_sd->_M_dist[__s + 1][d->_M_num_threads] now contains\n+      // the total number of items in bin __s\n       for (_BinIndex __s = 0; __s < _M_sd->_M_num_bins; ++__s)\n-        __gnu_sequential::partial_sum(_M_sd->_M_dist[__s + 1],\n-                                      _M_sd->_M_dist[__s + 1] + d->_M_num_threads + 1,\n-                                      _M_sd->_M_dist[__s + 1]);\n+        __gnu_sequential::partial_sum(\n+          _M_sd->_M_dist[__s + 1],\n+          _M_sd->_M_dist[__s + 1] + d->_M_num_threads + 1,\n+          _M_sd->_M_dist[__s + 1]);\n     }\n \n #   pragma omp barrier\n@@ -179,9 +181,9 @@ template<typename _RAIter, typename RandomNumberGenerator>\n \n     for (_BinIndex __s = d->_M_bins_begin; __s < d->__bins_end; ++__s)\n       {\n-\tfor (int __t = 0; __t < d->_M_num_threads + 1; ++__t)\n-\t  _M_sd->_M_dist[__s + 1][__t] += __offset;\n-\t__offset = _M_sd->_M_dist[__s + 1][d->_M_num_threads];\n+        for (int __t = 0; __t < d->_M_num_threads + 1; ++__t)\n+          _M_sd->_M_dist[__s + 1][__t] += __offset;\n+        __offset = _M_sd->_M_dist[__s + 1][d->_M_num_threads];\n       }\n \n     _M_sd->_M_temporaries[__iam] = static_cast<_ValueType*>(\n@@ -208,7 +210,7 @@ template<typename _RAIter, typename RandomNumberGenerator>\n \n         // Last column [d->_M_num_threads] stays unchanged.\n         ::new(&(_M_temporaries[target_p][_M_dist[target_bin + 1]++]))\n-\t    _ValueType(*(_M_source + __i + __start));\n+            _ValueType(*(_M_source + __i + __start));\n       }\n \n     delete[] __oracles;\n@@ -223,12 +225,15 @@ template<typename _RAIter, typename RandomNumberGenerator>\n       {\n         _ValueType* __begin =\n                     _M_sd->_M_temporaries[__iam] +\n-                    ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]),\n+                    ((__b == d->_M_bins_begin)\n+                      ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]),\n                   * __end =\n-                    _M_sd->_M_temporaries[__iam] + _M_sd->_M_dist[__b + 1][d->_M_num_threads];\n+                    _M_sd->_M_temporaries[__iam] +\n+                      _M_sd->_M_dist[__b + 1][d->_M_num_threads];\n         __sequential_random_shuffle(__begin, __end, __rng);\n         std::copy(__begin, __end, _M_sd->_M_source + __global_offset +\n-            ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]));\n+                  ((__b == d->_M_bins_begin)\n+                  ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]));\n       }\n \n     ::operator delete(_M_sd->_M_temporaries[__iam]);\n@@ -256,11 +261,11 @@ template<typename _Tp>\n template<typename _RAIter, typename RandomNumberGenerator>\n   void\n   __parallel_random_shuffle_drs(_RAIter __begin,\n-\t\t\t      _RAIter __end,\n-\t\t\t      typename std::iterator_traits\n-\t\t\t      <_RAIter>::difference_type __n,\n-\t\t\t      _ThreadIndex __num_threads,\n-\t\t\t      RandomNumberGenerator& __rng)\n+                              _RAIter __end,\n+                              typename std::iterator_traits\n+                              <_RAIter>::difference_type __n,\n+                              _ThreadIndex __num_threads,\n+                              RandomNumberGenerator& __rng)\n   {\n     typedef std::iterator_traits<_RAIter> _TraitsType;\n     typedef typename _TraitsType::value_type _ValueType;\n@@ -343,7 +348,8 @@ template<typename _RAIter, typename RandomNumberGenerator>\n                 _M_sd._M_dist[0][0] = 0;\n                 _M_sd._M_dist[__b][0] = 0;\n               }\n-            _M_starts = _M_sd._M_starts = new _DifferenceType[__num_threads + 1];\n+            _M_starts = _M_sd._M_starts\n+              = new _DifferenceType[__num_threads + 1];\n             int bin_cursor = 0;\n             _M_sd._M_num_bins = _M_num_bins;\n             _M_sd._M_num_bits = __log2(_M_num_bins);\n@@ -355,7 +361,8 @@ template<typename _RAIter, typename RandomNumberGenerator>\n             for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n               {\n                 _M_starts[__i] = __start;\n-                __start += (__i < __split) ? (__chunk_length + 1) : __chunk_length;\n+                __start += (__i < __split)\n+                           ? (__chunk_length + 1) : __chunk_length;\n                 int __j = __pus[__i]._M_bins_begin = bin_cursor;\n \n                 // Range of bins for this processor.\n@@ -469,14 +476,16 @@ template<typename _RAIter, typename RandomNumberGenerator>\n           }\n \n         // Sum up bins.\n-        __gnu_sequential::partial_sum(__dist0, __dist0 + _M_num_bins + 1, __dist0);\n+        __gnu_sequential::\n+            partial_sum(__dist0, __dist0 + _M_num_bins + 1, __dist0);\n \n         for (int __b = 0; __b < _M_num_bins + 1; ++__b)\n           __dist1[__b] = __dist0[__b];\n \n         // Distribute according to oracles.\n         for (_DifferenceType __i = 0; __i < __n; ++__i)\n-          ::new(&(__target[(__dist0[__oracles[__i]])++])) _ValueType(*(__begin + __i));\n+          ::new(&(__target[(__dist0[__oracles[__i]])++]))\n+            _ValueType(*(__begin + __i));\n \n         for (int __b = 0; __b < _M_num_bins; ++__b)\n           {\n@@ -511,7 +520,8 @@ template<typename _RAIter, typename RandomNumberGenerator>\n     typedef std::iterator_traits<_RAIter> _TraitsType;\n     typedef typename _TraitsType::difference_type _DifferenceType;\n     _DifferenceType __n = __end - __begin;\n-    __parallel_random_shuffle_drs(__begin, __end, __n, __get_max_threads(), __rng) ;\n+    __parallel_random_shuffle_drs(\n+      __begin, __end, __n, __get_max_threads(), __rng) ;\n   }\n \n }"}, {"sha": "a253126d90ac676f9125178168763df96dcb9641", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -76,8 +76,8 @@ template<typename _RAIter, typename _DifferenceTp>\n    *  @param __pred Find predicate.\n    *  @return Place of finding in first sequences. */\n template<typename __RAIter1,\n-\t typename __RAIter2,\n-\t typename _Pred>\n+         typename __RAIter2,\n+         typename _Pred>\n   __RAIter1\n   __search_template(__RAIter1 __begin1, __RAIter1 __end1,\n                   __RAIter2 __begin2, __RAIter2 __end2,\n@@ -126,7 +126,8 @@ template<typename __RAIter1,\n \n         _ThreadIndex __iam = omp_get_thread_num();\n \n-        _DifferenceType __start = __splitters[__iam], __stop = __splitters[__iam + 1];\n+        _DifferenceType __start = __splitters[__iam],\n+                        __stop = __splitters[__iam + 1];\n \n         _DifferenceType __pos_in_pattern = 0;\n         bool __found_pattern = false;\n@@ -156,7 +157,8 @@ template<typename __RAIter1,\n             // Make safe jump.\n             __start += (__pos_in_pattern - __advances[__pos_in_pattern]);\n             __pos_in_pattern =\n-                (__advances[__pos_in_pattern] < 0) ? 0 : __advances[__pos_in_pattern];\n+                (__advances[__pos_in_pattern] < 0) ?\n+                  0 : __advances[__pos_in_pattern];\n           }\n       } //parallel\n "}, {"sha": "ac669c55d5d44cc618fa7f8b04193c04a5cbd75c", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -63,8 +63,8 @@ template<typename _IIter, typename _OutputIterator>\n   }\n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   struct symmetric_difference_func\n   {\n     typedef std::iterator_traits<_IIter> _TraitsType;\n@@ -77,8 +77,8 @@ template<typename _IIter,\n \n     _OutputIterator\n     _M_invoke(_IIter __a, _IIter __b,\n-\t   _IIter __c, _IIter d,\n-\t   _OutputIterator __r) const\n+           _IIter __c, _IIter d,\n+           _OutputIterator __r) const\n     {\n       while (__a != __b && __c != d)\n         {\n@@ -105,7 +105,7 @@ template<typename _IIter,\n \n     _DifferenceType\n     __count(_IIter __a, _IIter __b,\n-\t  _IIter __c, _IIter d) const\n+          _IIter __c, _IIter d) const\n     {\n       _DifferenceType __counter = 0;\n \n@@ -142,8 +142,8 @@ template<typename _IIter,\n \n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   struct __difference_func\n   {\n     typedef std::iterator_traits<_IIter> _TraitsType;\n@@ -179,7 +179,7 @@ template<typename _IIter,\n \n     _DifferenceType\n     __count(_IIter __a, _IIter __b,\n-\t  _IIter __c, _IIter d) const\n+          _IIter __c, _IIter d) const\n     {\n       _DifferenceType __counter = 0;\n \n@@ -210,8 +210,8 @@ template<typename _IIter,\n \n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   struct __intersection_func\n   {\n     typedef std::iterator_traits<_IIter> _TraitsType;\n@@ -246,7 +246,7 @@ template<typename _IIter,\n \n     _DifferenceType\n     __count(_IIter __a, _IIter __b,\n-\t  _IIter __c, _IIter d) const\n+          _IIter __c, _IIter d) const\n     {\n       _DifferenceType __counter = 0;\n \n@@ -315,7 +315,7 @@ template<class _IIter, class _OutputIterator, class _Compare>\n \n     _DifferenceType\n     __count(_IIter __a, _IIter __b,\n-\t  _IIter __c, _IIter d) const\n+          _IIter __c, _IIter d) const\n     {\n       _DifferenceType __counter = 0;\n \n@@ -348,8 +348,8 @@ template<class _IIter, class _OutputIterator, class _Compare>\n   };\n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename Operation>\n+         typename _OutputIterator,\n+         typename Operation>\n   _OutputIterator\n   __parallel_set_operation(_IIter __begin1, _IIter __end1,\n                          _IIter __begin2, _IIter __end2,\n@@ -370,7 +370,7 @@ template<typename _IIter,\n     const _DifferenceType size = (__end1 - __begin1) + (__end2 - __begin2);\n \n     const _IteratorPair __sequence[ 2 ] =\n-        { std::make_pair(__begin1, __end1), std::make_pair(__begin2, __end2) } ;\n+      { std::make_pair(__begin1, __end1), std::make_pair(__begin2, __end2) };\n     _OutputIterator return_value = __result;\n     _DifferenceType *__borders;\n     _IteratorPair *__block_begins;\n@@ -400,7 +400,8 @@ template<typename _IIter,\n         _IIter __offset[2];\n         const _DifferenceType __rank = __borders[__iam + 1];\n \n-        multiseq_partition(__sequence, __sequence + 2, __rank, __offset, __op._M_comp);\n+        multiseq_partition(__sequence, __sequence + 2,\n+                           __rank, __offset, __op._M_comp);\n \n         // allowed to read?\n         // together\n@@ -427,15 +428,16 @@ template<typename _IIter,\n         if (__iam == 0)\n           {\n             // The first thread can copy already.\n-            __lengths[ __iam ] = __op._M_invoke(__block_begin.first, block_end.first,\n-                                       __block_begin.second, block_end.second,\n-                                       __result)\n+            __lengths[ __iam ] =\n+              __op._M_invoke(__block_begin.first, block_end.first,\n+                             __block_begin.second, block_end.second, __result)\n                               - __result;\n           }\n         else\n           {\n-            __lengths[ __iam ] = __op.__count(__block_begin.first, block_end.first,\n-                        __block_begin.second, block_end.second);\n+            __lengths[ __iam ] =\n+              __op.__count(__block_begin.first, block_end.first,\n+                           __block_begin.second, block_end.second);\n           }\n \n         // Make sure everyone wrote their lengths.\n@@ -453,7 +455,7 @@ template<typename _IIter,\n \n             // Return the result iterator of the last block.\n             return_value = __op._M_invoke(\n-                __block_begin.first, __end1, __block_begin.second, __end2, __r);\n+              __block_begin.first, __end1, __block_begin.second, __end2, __r);\n \n           }\n         else\n@@ -471,52 +473,56 @@ template<typename _IIter,\n \n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   inline _OutputIterator\n   __parallel_set_union(_IIter __begin1, _IIter __end1,\n                      _IIter __begin2, _IIter __end2,\n                      _OutputIterator __result, _Compare _M_comp)\n   {\n-    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        __union_func< _IIter, _OutputIterator, _Compare>(_M_comp));\n+    return __parallel_set_operation(__begin1, __end1, __begin2, __end2,\n+        __result, __union_func< _IIter, _OutputIterator, _Compare>(_M_comp));\n   }\n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   inline _OutputIterator\n   __parallel_set_intersection(_IIter __begin1, _IIter __end1,\n-                            _IIter __begin2, _IIter __end2,\n-                            _OutputIterator __result, _Compare _M_comp)\n+                              _IIter __begin2, _IIter __end2,\n+                              _OutputIterator __result, _Compare _M_comp)\n   {\n-    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        __intersection_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n+    return __parallel_set_operation(\n+             __begin1, __end1, __begin2, __end2, __result,\n+             __intersection_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n   }\n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   inline _OutputIterator\n   __parallel_set_difference(_IIter __begin1, _IIter __end1,\n-                          _IIter __begin2, _IIter __end2,\n-                          _OutputIterator __result, _Compare _M_comp)\n+                            _IIter __begin2, _IIter __end2,\n+                            _OutputIterator __result, _Compare _M_comp)\n   {\n-    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        __difference_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n+    return __parallel_set_operation(\n+             __begin1, __end1, __begin2, __end2, __result,\n+             __difference_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n   }\n \n template<typename _IIter,\n-\t typename _OutputIterator,\n-\t typename _Compare>\n+         typename _OutputIterator,\n+         typename _Compare>\n   inline _OutputIterator\n   __parallel_set_symmetric_difference(_IIter __begin1, _IIter __end1,\n-                                    _IIter __begin2, _IIter __end2,\n-                                    _OutputIterator __result, _Compare _M_comp)\n+                                      _IIter __begin2, _IIter __end2,\n+                                      _OutputIterator __result,\n+                                      _Compare _M_comp)\n   {\n-    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n-        symmetric_difference_func<_IIter, _OutputIterator, _Compare>\n-            (_M_comp));\n+    return __parallel_set_operation(\n+             __begin1, __end1, __begin2, __end2, __result,\n+            symmetric_difference_func<_IIter, _OutputIterator, _Compare>\n+              (_M_comp));\n   }\n \n }"}, {"sha": "e83ecc50ea57952a44fd28c88b4bfb5dbfc77ce2", "filename": "libstdc++-v3/include/parallel/settings.h", "status": "modified", "additions": 110, "deletions": 56, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -92,7 +92,12 @@\n   * __gnu_parallel::_Settings::algorithm_strategy. Usually a decision\n   * based on the input size.\n   */\n-#define _GLIBCXX_PARALLEL_CONDITION(__c) (__gnu_parallel::_Settings::get().algorithm_strategy != __gnu_parallel::force_sequential && ((__gnu_parallel::__get_max_threads() > 1 && (__c)) || __gnu_parallel::_Settings::get().algorithm_strategy == __gnu_parallel::force_parallel))\n+#define _GLIBCXX_PARALLEL_CONDITION(__c) \\\n+  (__gnu_parallel::_Settings::get().algorithm_strategy \\\n+    != __gnu_parallel::force_sequential \\\n+  && ((__gnu_parallel::__get_max_threads() > 1 && (__c)) \\\n+     || __gnu_parallel::_Settings::get().algorithm_strategy \\\n+        == __gnu_parallel::force_parallel))\n \n /*\n inline bool\n@@ -103,166 +108,166 @@ parallel_condition(bool __c)\n   if (__s.algorithm_strategy != force_seqential)\n     {\n       if (__s.algorithm_strategy == force_parallel)\n-\tret = true;\n+        ret = true;\n       else\n-\tret = __get_max_threads() > 1 && __c;\n+        ret = __get_max_threads() > 1 && __c;\n     }\n   return ret;\n }\n */\n \n namespace __gnu_parallel\n {\n-  /// class _Settings \n-  /// Run-time settings for the parallel mode, including all tunable parameters.\n+  /// class _Settings\n+  /// Run-time settings for the parallel mode including all tunable parameters.\n   struct _Settings\n   {\n-    _AlgorithmStrategy \t\talgorithm_strategy;\n+    _AlgorithmStrategy          algorithm_strategy;\n     \n-    _SortAlgorithm \t\tsort_algorithm;\n-    _PartialSumAlgorithm \tpartial_sum_algorithm;\n-    _MultiwayMergeAlgorithm \tmultiway_merge_algorithm;\n-    _FindAlgorithm \t\tfind_algorithm;\n+    _SortAlgorithm              sort_algorithm;\n+    _PartialSumAlgorithm        partial_sum_algorithm;\n+    _MultiwayMergeAlgorithm     multiway_merge_algorithm;\n+    _FindAlgorithm              find_algorithm;\n \n-    _SplittingAlgorithm \tsort_splitting;\n-    _SplittingAlgorithm \tmerge_splitting;\n-    _SplittingAlgorithm \tmultiway_merge_splitting;\n+    _SplittingAlgorithm         sort_splitting;\n+    _SplittingAlgorithm         merge_splitting;\n+    _SplittingAlgorithm         multiway_merge_splitting;\n \n     // Per-algorithm settings.\n \n     /// Minimal input size for accumulate.\n-    _SequenceIndex \t\taccumulate_minimal_n;\n+    _SequenceIndex              accumulate_minimal_n;\n \n     /// Minimal input size for adjacent_difference.\n-    unsigned int \t\tadjacent_difference_minimal_n;\n+    unsigned int                adjacent_difference_minimal_n;\n \n     /// Minimal input size for count and count_if.\n-    _SequenceIndex \t\tcount_minimal_n;\n+    _SequenceIndex              count_minimal_n;\n \n     /// Minimal input size for fill.\n-    _SequenceIndex \t\tfill_minimal_n;\n+    _SequenceIndex              fill_minimal_n;\n \n     /// Block size increase factor for find.\n-    double \t\t\tfind_increasing_factor;\n+    double                      find_increasing_factor;\n \n     /// Initial block size for find.\n-    _SequenceIndex \t\tfind_initial_block_size;\n+    _SequenceIndex              find_initial_block_size;\n \n     /// Maximal block size for find.\n-    _SequenceIndex \t\tfind_maximum_block_size;\n+    _SequenceIndex              find_maximum_block_size;\n \n     /// Start with looking for this many elements sequentially, for find.\n-    _SequenceIndex \t\tfind_sequential_search_size;\n+    _SequenceIndex              find_sequential_search_size;\n \n     /// Minimal input size for for_each.\n-    _SequenceIndex \t\tfor_each_minimal_n;\n+    _SequenceIndex              for_each_minimal_n;\n \n     /// Minimal input size for generate.\n-    _SequenceIndex \t\tgenerate_minimal_n;\n+    _SequenceIndex              generate_minimal_n;\n \n     /// Minimal input size for max_element.\n-    _SequenceIndex \t\tmax_element_minimal_n;\n+    _SequenceIndex              max_element_minimal_n;\n \n     /// Minimal input size for merge.\n-    _SequenceIndex \t\tmerge_minimal_n;\n+    _SequenceIndex              merge_minimal_n;\n \n     /// Oversampling factor for merge.\n-    unsigned int \t\tmerge_oversampling;\n+    unsigned int                merge_oversampling;\n \n     /// Minimal input size for min_element.\n-    _SequenceIndex \t\tmin_element_minimal_n;\n+    _SequenceIndex              min_element_minimal_n;\n \n     /// Minimal input size for multiway_merge.\n-    _SequenceIndex \t\tmultiway_merge_minimal_n;\n+    _SequenceIndex              multiway_merge_minimal_n;\n \n     /// Oversampling factor for multiway_merge.\n-    int \t\t\tmultiway_merge_minimal_k;\n+    int                         multiway_merge_minimal_k;\n \n     /// Oversampling factor for multiway_merge.\n-    unsigned int \t\tmultiway_merge_oversampling;\n+    unsigned int                multiway_merge_oversampling;\n \n     /// Minimal input size for nth_element.\n-    _SequenceIndex \t\tnth_element_minimal_n;\n+    _SequenceIndex              nth_element_minimal_n;\n \n     /// Chunk size for partition.\n-    _SequenceIndex \t\tpartition_chunk_size;\n+    _SequenceIndex              partition_chunk_size;\n \n     /// Chunk size for partition, relative to input size.  If > 0.0,\n     /// this value overrides partition_chunk_size.\n-    double \t\t\tpartition_chunk_share;\n+    double                      partition_chunk_share;\n \n     /// Minimal input size for partition.\n-    _SequenceIndex \t\tpartition_minimal_n;\n+    _SequenceIndex              partition_minimal_n;\n \n     /// Minimal input size for partial_sort.\n-    _SequenceIndex \t\tpartial_sort_minimal_n;\n+    _SequenceIndex              partial_sort_minimal_n;\n \n     /// Ratio for partial_sum. Assume \"sum and write result\" to be\n     /// this factor slower than just \"sum\".\n-    float \t\t\tpartial_sum_dilation;\n+    float                       partial_sum_dilation;\n \n     /// Minimal input size for partial_sum.\n-    unsigned int \t\tpartial_sum_minimal_n;\n+    unsigned int                partial_sum_minimal_n;\n \n     /// Minimal input size for random_shuffle.\n-    unsigned int \t\trandom_shuffle_minimal_n;\n+    unsigned int                random_shuffle_minimal_n;\n \n     /// Minimal input size for replace and replace_if.\n-    _SequenceIndex \t\treplace_minimal_n;\n+    _SequenceIndex              replace_minimal_n;\n \n     /// Minimal input size for set_difference.\n-    _SequenceIndex \t\tset_difference_minimal_n;\n+    _SequenceIndex              set_difference_minimal_n;\n \n     /// Minimal input size for set_intersection.\n-    _SequenceIndex \t\tset_intersection_minimal_n;\n+    _SequenceIndex              set_intersection_minimal_n;\n \n     /// Minimal input size for set_symmetric_difference.\n-    _SequenceIndex \t\tset_symmetric_difference_minimal_n;\n+    _SequenceIndex              set_symmetric_difference_minimal_n;\n \n     /// Minimal input size for set_union.\n-    _SequenceIndex \t\tset_union_minimal_n;\n+    _SequenceIndex              set_union_minimal_n;\n \n     /// Minimal input size for parallel sorting.\n-    _SequenceIndex \t\tsort_minimal_n;\n+    _SequenceIndex              sort_minimal_n;\n \n     /// Oversampling factor for parallel std::sort (MWMS).\n-    unsigned int \t\tsort_mwms_oversampling;\n+    unsigned int                sort_mwms_oversampling;\n \n     /// Such many samples to take to find a good pivot (quicksort).\n-    unsigned int \t\tsort_qs_num_samples_preset;\n+    unsigned int                sort_qs_num_samples_preset;\n \n     /// Maximal subsequence __length to switch to unbalanced __base case.\n     /// Applies to std::sort with dynamically load-balanced quicksort.\n-    _SequenceIndex \t\tsort_qsb_base_case_maximal_n;\n+    _SequenceIndex              sort_qsb_base_case_maximal_n;\n \n     /// Minimal input size for parallel std::transform.\n-    _SequenceIndex \t\ttransform_minimal_n;\n+    _SequenceIndex              transform_minimal_n;\n \n     /// Minimal input size for unique_copy. \n-    _SequenceIndex \t\tunique_copy_minimal_n;\n+    _SequenceIndex              unique_copy_minimal_n;\n \n-    _SequenceIndex \t\tworkstealing_chunk_size;\n+    _SequenceIndex              workstealing_chunk_size;\n \n     // Hardware dependent tuning parameters.\n \n     /// size of the L1 cache in bytes (underestimation).\n-    unsigned long long \t\tL1_cache_size;\n+    unsigned long long          L1_cache_size;\n \n     /// size of the L2 cache in bytes (underestimation).\n-    unsigned long long \t\tL2_cache_size;\n+    unsigned long long          L2_cache_size;\n \n     /// size of the Translation Lookaside Buffer (underestimation).\n-    unsigned int \t\tTLB_size;\n+    unsigned int                TLB_size;\n \n     /// Overestimation of cache line size.  Used to avoid false\n     /// sharing, i.e. elements of different threads are at least this\n     /// amount apart.\n-    unsigned int \t\tcache_line_size;\n+    unsigned int                cache_line_size;\n \n     // Statistics.\n \n     /// The number of stolen ranges in load-balanced quicksort.\n-    _SequenceIndex \t\tqsb_steals;\n+    _SequenceIndex              qsb_steals;\n \n     /// Get the global settings.\n     _GLIBCXX_CONST static const _Settings&\n@@ -273,7 +278,56 @@ namespace __gnu_parallel\n     set(_Settings&) throw();\n \n     explicit \n-    _Settings() : algorithm_strategy(heuristic), sort_algorithm(MWMS), partial_sum_algorithm(LINEAR), multiway_merge_algorithm(LOSER_TREE), find_algorithm(CONSTANT_SIZE_BLOCKS), sort_splitting(EXACT), merge_splitting(EXACT), multiway_merge_splitting(EXACT), accumulate_minimal_n(1000), adjacent_difference_minimal_n(1000), count_minimal_n(1000), fill_minimal_n(1000), find_increasing_factor(2.0), find_initial_block_size(256), find_maximum_block_size(8192), find_sequential_search_size(256), for_each_minimal_n(1000), generate_minimal_n(1000), max_element_minimal_n(1000), merge_minimal_n(1000), merge_oversampling(10), min_element_minimal_n(1000), multiway_merge_minimal_n(1000), multiway_merge_minimal_k(2), multiway_merge_oversampling(10), nth_element_minimal_n(1000), partition_chunk_size(1000), partition_chunk_share(0.0), partition_minimal_n(1000), partial_sort_minimal_n(1000), partial_sum_dilation(1.0f), partial_sum_minimal_n(1000), random_shuffle_minimal_n(1000), replace_minimal_n(1000), set_difference_minimal_n(1000), set_intersection_minimal_n(1000), set_symmetric_difference_minimal_n(1000), set_union_minimal_n(1000), sort_minimal_n(1000), sort_mwms_oversampling(10), sort_qs_num_samples_preset(100), sort_qsb_base_case_maximal_n(100), transform_minimal_n(1000), unique_copy_minimal_n(10000), workstealing_chunk_size(100), L1_cache_size(16 << 10), L2_cache_size(256 << 10), TLB_size(128), cache_line_size(64), qsb_steals(0)\n+    _Settings() :\n+            algorithm_strategy(heuristic),\n+            sort_algorithm(MWMS),\n+            partial_sum_algorithm(LINEAR),\n+            multiway_merge_algorithm(LOSER_TREE),\n+            find_algorithm(CONSTANT_SIZE_BLOCKS),\n+            sort_splitting(EXACT),\n+            merge_splitting(EXACT),\n+            multiway_merge_splitting(EXACT),\n+            accumulate_minimal_n(1000),\n+            adjacent_difference_minimal_n(1000),\n+            count_minimal_n(1000),\n+            fill_minimal_n(1000),\n+            find_increasing_factor(2.0),\n+            find_initial_block_size(256),\n+            find_maximum_block_size(8192),\n+            find_sequential_search_size(256),\n+            for_each_minimal_n(1000),\n+            generate_minimal_n(1000),\n+            max_element_minimal_n(1000),\n+            merge_minimal_n(1000),\n+            merge_oversampling(10),\n+            min_element_minimal_n(1000),\n+            multiway_merge_minimal_n(1000),\n+            multiway_merge_minimal_k(2), multiway_merge_oversampling(10),\n+            nth_element_minimal_n(1000),\n+            partition_chunk_size(1000),\n+            partition_chunk_share(0.0),\n+            partition_minimal_n(1000),\n+            partial_sort_minimal_n(1000),\n+            partial_sum_dilation(1.0f),\n+            partial_sum_minimal_n(1000),\n+            random_shuffle_minimal_n(1000),\n+            replace_minimal_n(1000),\n+            set_difference_minimal_n(1000),\n+            set_intersection_minimal_n(1000),\n+            set_symmetric_difference_minimal_n(1000),\n+            set_union_minimal_n(1000),\n+            sort_minimal_n(1000),\n+            sort_mwms_oversampling(10),\n+            sort_qs_num_samples_preset(100),\n+            sort_qsb_base_case_maximal_n(100),\n+            transform_minimal_n(1000),\n+            unique_copy_minimal_n(10000),\n+            workstealing_chunk_size(100),\n+            L1_cache_size(16 << 10),\n+            L2_cache_size(256 << 10),\n+            TLB_size(128),\n+            cache_line_size(64),\n+            qsb_steals(0)\n     { }\n   };\n }"}, {"sha": "03b19210a828887b2ccce059fba00112f3b10321", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -54,13 +54,13 @@\n \n namespace __gnu_parallel\n {\n-\t//prototype\n+        //prototype\n   template<bool __stable, typename _RAIter,\n            typename _Compare, typename _Parallelism>\n   void\n   parallel_sort(_RAIter __begin, _RAIter __end,\n   _Compare __comp, _Parallelism __parallelism);\n-\t\n+        \n   /** \n    *  @brief Choose multiway mergesort, splitting variant at run-time,\n    *  for parallel sorting.\n@@ -138,7 +138,8 @@ namespace __gnu_parallel\n \n     _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n \n-    __parallel_sort_qs(__begin, __end, __comp, __parallelism.__get_num_threads());\n+    __parallel_sort_qs(__begin, __end, __comp,\n+                       __parallelism.__get_num_threads());\n   }\n \n   /**\n@@ -158,7 +159,8 @@ namespace __gnu_parallel\n \n     _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n \n-    __parallel_sort_qsb(__begin, __end, __comp, __parallelism.__get_num_threads());\n+    __parallel_sort_qsb(__begin, __end, __comp,\n+                        __parallelism.__get_num_threads());\n   }\n \n \n@@ -215,11 +217,13 @@ namespace __gnu_parallel\n #endif\n #if _GLIBCXX_QUICKSORT\n       else if (_Settings::get().sort_algorithm == QS)\n-        __parallel_sort_qs(__begin, __end, __comp, __parallelism.__get_num_threads());\n+        __parallel_sort_qs(__begin, __end, __comp,\n+                           __parallelism.__get_num_threads());\n #endif\n #if _GLIBCXX_BAL_QUICKSORT\n       else if (_Settings::get().sort_algorithm == QS_BALANCED)\n-        __parallel_sort_qsb(__begin, __end, __comp, __parallelism.__get_num_threads());\n+        __parallel_sort_qsb(__begin, __end, __comp,\n+                            __parallelism.__get_num_threads());\n #endif\n       else\n         __gnu_sequential::sort(__begin, __end, __comp);"}, {"sha": "3321f2d5bad487a6dfe6d260be5bc3349b480b60", "filename": "libstdc++-v3/include/parallel/types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -149,7 +149,8 @@ namespace __gnu_parallel\n   static const int _CASable_bits = sizeof(_CASable) * 8;\n \n   /// ::_CASable with the right half of bits set to 1.\n-  static const _CASable _CASable_mask = ((_CASable(1) << (_CASable_bits / 2)) - 1);\n+  static const _CASable _CASable_mask =\n+                            ((_CASable(1) << (_CASable_bits / 2)) - 1);\n }\n \n #endif /* _GLIBCXX_PARALLEL_TYPES_H */"}, {"sha": "327870e7d868c124383b5b1fd5c0873b2e955a32", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -45,11 +45,11 @@ namespace __gnu_parallel\n   *  @param __binary_pred Equality predicate.\n   *  @return End iterator of result __sequence. */\n template<typename _IIter,\n-\t class _OutputIterator,\n-\t class _BinaryPredicate>\n+         class _OutputIterator,\n+         class _BinaryPredicate>\n   _OutputIterator\n   __parallel_unique_copy(_IIter __first, _IIter __last,\n-                       _OutputIterator __result, _BinaryPredicate __binary_pred)\n+    _OutputIterator __result, _BinaryPredicate __binary_pred)\n   {\n     _GLIBCXX_CALL(__last - __first)\n \n@@ -72,10 +72,10 @@ template<typename _IIter,\n       {\n #       pragma omp single\n           {\n-\t    __num_threads = omp_get_num_threads();\n-\t    __borders = new _DifferenceType[__num_threads + 2];\n-\t    equally_split(size, __num_threads + 1, __borders);\n-\t    __counter = new _DifferenceType[__num_threads + 1];\n+            __num_threads = omp_get_num_threads();\n+            __borders = new _DifferenceType[__num_threads + 2];\n+            equally_split(size, __num_threads + 1, __borders);\n+            __counter = new _DifferenceType[__num_threads + 1];\n           }\n \n         _ThreadIndex __iam = omp_get_thread_num();\n@@ -89,7 +89,7 @@ template<typename _IIter,\n \n         if (__iam == 0)\n         {\n-          __begin = __borders[0] + 1;\t// == 1\n+          __begin = __borders[0] + 1;   // == 1\n           __end = __borders[__iam + 1];\n \n           ++__i;\n@@ -112,8 +112,8 @@ template<typename _IIter,\n           for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n             {\n               if (!__binary_pred(*iter, *(iter - 1)))\n-\t\t++__i;\n-\t    }\n+                ++__i;\n+            }\n         }\n       __counter[__iam] = __i;\n \n@@ -157,8 +157,8 @@ template<typename _IIter,\n           for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n             {\n               if (!__binary_pred(*iter, *(iter-1)))\n-\t\t*__iter_out++ = *iter;\n-\t    }\n+                *__iter_out++ = *iter;\n+            }\n         }\n     }\n \n@@ -184,7 +184,7 @@ template<typename _IIter, class _OutputIterator>\n     typedef typename std::iterator_traits<_IIter>::value_type\n       _ValueType;\n     return __parallel_unique_copy(__first, __last, __result,\n-\t\t\t\tstd::equal_to<_ValueType>());\n+                                std::equal_to<_ValueType>());\n   }\n \n }//namespace __gnu_parallel"}, {"sha": "ca6eb0cc4d3c48e7b9832de4672bf94788a8de90", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15ac3c72db8333d4a63e43949121e5d7f7c2fb78/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=15ac3c72db8333d4a63e43949121e5d7f7c2fb78", "patch": "@@ -91,18 +91,15 @@ template<typename _DifferenceTp>\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n template<typename _RAIter,\n-\t typename _Op,\n-\t typename _Fu,\n-\t typename _Red,\n-\t typename _Result>\n+         typename _Op,\n+         typename _Fu,\n+         typename _Red,\n+         typename _Result>\n   _Op\n-  for_each_template_random_access_workstealing(_RAIter __begin,\n-\t\t\t\t\t       _RAIter __end,\n-\t\t\t\t\t       _Op __op, _Fu& __f, _Red __r,\n-\t\t\t\t\t       _Result __base, _Result& __output,\n-\t\t\t\t\t       typename std::iterator_traits\n-\t\t\t\t\t       <_RAIter>::\n-\t\t\t\t\t       difference_type __bound)\n+  for_each_template_random_access_workstealing(\n+    _RAIter __begin, _RAIter __end, _Op __op, _Fu& __f, _Red __r,\n+    _Result __base, _Result& __output,\n+    typename std::iterator_traits<_RAIter>::difference_type __bound)\n   {\n     _GLIBCXX_CALL(__end - __begin)\n \n@@ -111,13 +108,15 @@ template<typename _RAIter,\n     \n     const _Settings& __s = _Settings::get();\n \n-    _DifferenceType __chunk_size = static_cast<_DifferenceType>(__s.workstealing_chunk_size);\n+    _DifferenceType __chunk_size =\n+        static_cast<_DifferenceType>(__s.workstealing_chunk_size);\n \n     // How many jobs?\n     _DifferenceType __length = (__bound < 0) ? (__end - __begin) : __bound;\n \n     // To avoid false sharing in a cache line.\n-    const int __stride = __s.cache_line_size * 10 / sizeof(_Job<_DifferenceType>) + 1;\n+    const int __stride =\n+                __s.cache_line_size * 10 / sizeof(_Job<_DifferenceType>) + 1;\n \n     // Total number of threads currently working.\n     _ThreadIndex __busy = 0;\n@@ -132,8 +131,8 @@ template<typename _RAIter,\n \n     // No more threads than jobs, at least one thread.\n     _ThreadIndex __num_threads =\n-        __gnu_parallel::max<_ThreadIndex>(1,\n-            __gnu_parallel::min<_DifferenceType>(__length, __get_max_threads()));\n+      __gnu_parallel::max<_ThreadIndex>(1,\n+        __gnu_parallel::min<_DifferenceType>(__length, __get_max_threads()));\n \n #   pragma omp parallel shared(__busy) num_threads(__num_threads)\n       {\n@@ -184,7 +183,7 @@ template<typename _RAIter,\n             (__length - 1) : ((__iam + 1) * (__length / __num_threads) - 1);\n         __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n \n-        // Init result with _M_first __value (to have a base value for reduction).\n+        // Init result with _M_first value (to have a base value for reduction)\n         if (__my_job._M_first <= __my_job._M_last)\n           {\n             // Cannot use volatile variable directly.\n@@ -211,13 +210,15 @@ template<typename _RAIter,\n                 // fetch-and-add call\n                 // Reserve current job block (size __chunk_size) in my queue.\n                 _DifferenceType current_job =\n-                  __fetch_and_add<_DifferenceType>(&(__my_job._M_first), __chunk_size);\n+                  __fetch_and_add<_DifferenceType>(\n+                    &(__my_job._M_first), __chunk_size);\n \n                 // Update _M_load, to make the three values consistent,\n                 // _M_first might have been changed in the meantime\n                 __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n                 for (_DifferenceType job_counter = 0;\n-                     job_counter < __chunk_size && current_job <= __my_job._M_last;\n+                     job_counter < __chunk_size\n+                       && current_job <= __my_job._M_last;\n                      ++job_counter)\n                   {\n                     // Yes: process it!\n@@ -254,7 +255,8 @@ template<typename _RAIter,\n               }\n             while (__busy > 0\n               && ((__supposed_load <= 0)\n-                || ((__supposed_first + __supposed_load - 1) != __supposed_last)));\n+                || ((__supposed_first + __supposed_load - 1)\n+                                                         != __supposed_last)));\n \n             if (__busy == 0)\n               break;\n@@ -273,7 +275,8 @@ template<typename _RAIter,\n                     __stolen_first + __steal - _DifferenceType(1);\n \n                 __my_job._M_first = __stolen_first;\n-                __my_job._M_last = __gnu_parallel::min(stolen_try, __supposed_last);\n+                __my_job._M_last =\n+                  __gnu_parallel::min(stolen_try, __supposed_last);\n                 __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n \n                 // Has potential work again."}]}