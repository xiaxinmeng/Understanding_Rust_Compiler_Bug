{"sha": "2604412d6c346665fb913e2f58b5ab6747fbfc73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYwNDQxMmQ2YzM0NjY2NWZiOTEzZTJmNThiNWFiNjc0N2ZiZmM3Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-03-02T12:22:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-02T12:22:33Z"}, "message": "parse.y (explicit_template_type): Remove TEMPLATE keyword.\n\n\t* parse.y (explicit_template_type): Remove TEMPLATE keyword.\n\t(nested_name_specifier): And add it before this use.\n\t(typename_sub0): And this use.  Also add use without the keyword.\n\t(typename_sub1): Likewise.\n\t* pt.c (instantiate_class_template): Don't actually instantiate\n\tanything if our type uses template parms.\n\nFrom-SVN: r18358", "tree": {"sha": "3a0fd15dddb30a689665cf103e9f7928837c7316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a0fd15dddb30a689665cf103e9f7928837c7316"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2604412d6c346665fb913e2f58b5ab6747fbfc73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2604412d6c346665fb913e2f58b5ab6747fbfc73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2604412d6c346665fb913e2f58b5ab6747fbfc73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2604412d6c346665fb913e2f58b5ab6747fbfc73/comments", "author": null, "committer": null, "parents": [{"sha": "fc470718aca25ebac8f4e07cbabef1da140755ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc470718aca25ebac8f4e07cbabef1da140755ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc470718aca25ebac8f4e07cbabef1da140755ae"}], "stats": {"total": 5822, "additions": 2941, "deletions": 2881}, "files": [{"sha": "b68eeaa8202a81601887c2c53a2529976ffa2caa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2604412d6c346665fb913e2f58b5ab6747fbfc73", "patch": "@@ -1,3 +1,12 @@\n+Mon Mar  2 12:11:06 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (explicit_template_type): Remove TEMPLATE keyword.\n+\t(nested_name_specifier): And add it before this use.\n+\t(typename_sub0): And this use.  Also add use without the keyword.\n+\t(typename_sub1): Likewise.\n+\t* pt.c (instantiate_class_template): Don't actually instantiate \n+\tanything if our type uses template parms.\n+\n Mon Mar  2 11:04:59 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* decl.c (start_function): Don't call temporary_allocation for a"}, {"sha": "3edfc6d632d82258185f3b51da120005a9308cbf", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 2845, "deletions": 2794, "changes": 5639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=2604412d6c346665fb913e2f58b5ab6747fbfc73"}, {"sha": "db829a8d47a1ac4118bb762b1eb6054783e4b332", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2604412d6c346665fb913e2f58b5ab6747fbfc73", "patch": "@@ -3169,8 +3169,8 @@ nested_name_specifier:\n \t  nested_name_specifier_1\n \t| nested_name_specifier nested_name_specifier_1\n \t\t{ $$ = $2; }\n-\t| nested_name_specifier explicit_template_type SCOPE\n-\t\t{ got_scope = $$ = make_typename_type ($1, $2); }\n+\t| nested_name_specifier TEMPLATE explicit_template_type SCOPE\n+\t\t{ got_scope = $$ = make_typename_type ($1, $3); }\n \t;\n \n /* Why the @#$%^& do type_name and notype_identifier need to be expanded\n@@ -3238,14 +3238,10 @@ typename_sub0:\n \t\t}\n \t| typename_sub1 template_type %prec EMPTY\n \t\t{ $$ = TREE_TYPE ($2); }\n-\t| typename_sub1 identifier '<' template_arg_list_opt\n-\t  template_close_bracket\n-\t\t{\n-\t\t  $$ = build_min_nt (TEMPLATE_ID_EXPR, $2, $4);\n-\t\t  $$ = make_typename_type ($1, $$);\n-\t\t}\n \t| typename_sub1 explicit_template_type %prec EMPTY\n \t\t{ $$ = make_typename_type ($1, $2); }\n+\t| typename_sub1 TEMPLATE explicit_template_type %prec EMPTY\n+\t\t{ $$ = make_typename_type ($1, $3); }\n \t;\n \n typename_sub1:\n@@ -3269,6 +3265,8 @@ typename_sub1:\n \t\t}\n \t| typename_sub1 explicit_template_type SCOPE\n \t\t{ got_scope = $$ = make_typename_type ($1, $2); }\n+\t| typename_sub1 TEMPLATE explicit_template_type SCOPE\n+\t\t{ got_scope = $$ = make_typename_type ($1, $3); }\n \t;\n \n typename_sub2:\n@@ -3301,8 +3299,8 @@ typename_sub2:\n \t;\n \n explicit_template_type:\n-\t  TEMPLATE identifier '<' template_arg_list_opt template_close_bracket\n-\t\t{ $$ = build_min_nt (TEMPLATE_ID_EXPR, $2, $4); }\n+\t  identifier '<' template_arg_list_opt template_close_bracket\n+\t\t{ $$ = build_min_nt (TEMPLATE_ID_EXPR, $1, $3); }\n \t;\n \n complex_type_name:"}, {"sha": "8751a70e096d20f7e826672ecaa45a7292178a7b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2604412d6c346665fb913e2f58b5ab6747fbfc73/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2604412d6c346665fb913e2f58b5ab6747fbfc73", "patch": "@@ -3022,17 +3022,17 @@ instantiate_class_template (type)\n \t  CLASSTYPE_INTERFACE_ONLY (type) = interface_only;\n \t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X (type, interface_unknown);\n \t  CLASSTYPE_VTABLE_NEEDS_WRITING (type)\n-\t    = ! CLASSTYPE_INTERFACE_ONLY (type)\n-\t      && CLASSTYPE_INTERFACE_KNOWN (type);\n+\t    = (! CLASSTYPE_INTERFACE_ONLY (type)\n+\t       && CLASSTYPE_INTERFACE_KNOWN (type));\n \t}\n       else\n \t{\n \t  CLASSTYPE_INTERFACE_ONLY (type) = CLASSTYPE_INTERFACE_ONLY (pattern);\n \t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n \t    (type, CLASSTYPE_INTERFACE_UNKNOWN (pattern));\n \t  CLASSTYPE_VTABLE_NEEDS_WRITING (type)\n-\t    = ! CLASSTYPE_INTERFACE_ONLY (type)\n-\t      && CLASSTYPE_INTERFACE_KNOWN (type);\n+\t    = (! CLASSTYPE_INTERFACE_ONLY (type)\n+\t       && CLASSTYPE_INTERFACE_KNOWN (type));\n \t}\n     }\n   else\n@@ -3067,6 +3067,21 @@ instantiate_class_template (type)\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);\n   TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n \n+  CLASSTYPE_LOCAL_TYPEDECLS (type) = CLASSTYPE_LOCAL_TYPEDECLS (pattern);\n+\n+  /* If this is a partial instantiation, don't tsubst anything.  We will\n+     only use this type for implicit typename, so the actual contents don't\n+     matter.  All that matters is whether a particular name is a type.  */\n+  if (uses_template_parms (type))\n+    {\n+      TYPE_BINFO_BASETYPES (type) = TYPE_BINFO_BASETYPES (pattern);\n+      TYPE_FIELDS (type) = TYPE_FIELDS (pattern);\n+      TYPE_METHODS (type) = TYPE_METHODS (pattern);\n+      CLASSTYPE_TAGS (type) = CLASSTYPE_TAGS (pattern);\n+      TYPE_SIZE (type) = integer_zero_node;\n+      goto end;\n+    }\n+\n   {\n     tree binfo = TYPE_BINFO (type);\n     tree pbases = TYPE_BINFO_BASETYPES (pattern);\n@@ -3089,9 +3104,7 @@ instantiate_class_template (type)\n \t      cp_error\n \t\t(\"base type `%T' of `%T' fails to be a struct or class type\",\n \t\t TREE_TYPE (elt), type);\n-\t    else if (! uses_template_parms (type)\n-\t\t     && (TYPE_SIZE (complete_type (TREE_TYPE (elt)))\n-\t\t\t == NULL_TREE))\n+\t    else if (TYPE_SIZE (complete_type (TREE_TYPE (elt))) == NULL_TREE)\n \t      cp_error (\"base class `%T' of `%T' has incomplete type\",\n \t\t\tTREE_TYPE (elt), type);\n \t  }\n@@ -3101,8 +3114,6 @@ instantiate_class_template (type)\n       }\n   }\n \n-  CLASSTYPE_LOCAL_TYPEDECLS (type) = CLASSTYPE_LOCAL_TYPEDECLS (pattern);\n-\n   field_chain = &TYPE_FIELDS (type);\n \n   for (t = CLASSTYPE_TAGS (pattern); t; t = TREE_CHAIN (t))\n@@ -3131,9 +3142,8 @@ instantiate_class_template (type)\n \ttree r = tsubst (t, args, NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n-\t    if (! uses_template_parms (r))\n-\t      pending_statics = perm_tree_cons (NULL_TREE, r, pending_statics);\n-\t    /* Perhaps I should do more of grokfield here.  */\n+\t    pending_statics = perm_tree_cons (NULL_TREE, r, pending_statics);\n+\t    /* Perhaps we should do more of grokfield here.  */\n \t    start_decl_1 (r);\n \t    DECL_IN_AGGR_P (r) = 1;\n \t    DECL_EXTERNAL (r) = 1;\n@@ -3153,87 +3163,79 @@ instantiate_class_template (type)\n \tgrok_op_properties (t, DECL_VIRTUAL_P (t), 0);\n     }\n \n-  if (! uses_template_parms (type))\n+  /* Construct the DECL_FRIENDLIST for the new class type.  */\n+  typedecl = TYPE_MAIN_DECL (type);\n+  for (t = DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern));\n+       t != NULL_TREE;\n+       t = TREE_CHAIN (t))\n     {\n-      /* Construct the DECL_FRIENDLIST for the new class type.  */\n-      typedecl = TYPE_MAIN_DECL (type);\n-      for (t = DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern));\n-\t   t != NULL_TREE;\n-\t   t = TREE_CHAIN (t))\n-\t{\n-\t  tree friends;\n+      tree friends;\n \n-\t  DECL_FRIENDLIST (typedecl)\n-\t    = tree_cons (TREE_PURPOSE (t), NULL_TREE, \n-\t\t\t DECL_FRIENDLIST (typedecl));\n+      DECL_FRIENDLIST (typedecl)\n+\t= tree_cons (TREE_PURPOSE (t), NULL_TREE, \n+\t\t     DECL_FRIENDLIST (typedecl));\n \n-\t  for (friends = TREE_VALUE (t);\n-\t       friends != NULL_TREE;\n-\t       friends = TREE_CHAIN (friends))\n+      for (friends = TREE_VALUE (t);\n+\t   friends != NULL_TREE;\n+\t   friends = TREE_CHAIN (friends))\n+\t{\n+\t  if (TREE_PURPOSE (friends) == error_mark_node)\n \t    {\n-\t      if (TREE_PURPOSE (friends) == error_mark_node)\n-\t\t{\n-\t\t  TREE_VALUE (DECL_FRIENDLIST (typedecl))\n-\t\t    = tree_cons (error_mark_node, \n-\t\t\t\t tsubst_friend_function (TREE_VALUE (friends),\n-\t\t\t\t\t\t\t args),\n-\t\t\t\t TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  TREE_VALUE (DECL_FRIENDLIST (typedecl))\n-\t\t    = tree_cons (tsubst (TREE_PURPOSE (friends), args, NULL_TREE),\n-\t\t\t\t NULL_TREE,\n-\t\t\t\t TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n+\t      TREE_VALUE (DECL_FRIENDLIST (typedecl))\n+\t\t= tree_cons (error_mark_node, \n+\t\t\t     tsubst_friend_function (TREE_VALUE (friends),\n+\t\t\t\t\t\t     args),\n+\t\t\t     TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n+\t    }\n+\t  else\n+\t    {\n+\t      TREE_VALUE (DECL_FRIENDLIST (typedecl))\n+\t\t= tree_cons (tsubst (TREE_PURPOSE (friends), args, NULL_TREE),\n+\t\t\t     NULL_TREE,\n+\t\t\t     TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n \n-\t\t}\n \t    }\n \t}\n+    }\n \n-      t = CLASSTYPE_FRIEND_CLASSES (type)\n-\t= tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), args, NULL_TREE);\n+  t = CLASSTYPE_FRIEND_CLASSES (type)\n+    = tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), args, NULL_TREE);\n \n-      /* This does injection for friend classes.  */\n-      for (; t; t = TREE_CHAIN (t))\n-\tTREE_VALUE (t) = xref_tag_from_type (TREE_VALUE (t), NULL_TREE, 1);\n+  /* This does injection for friend classes.  */\n+  for (; t; t = TREE_CHAIN (t))\n+    TREE_VALUE (t) = xref_tag_from_type (TREE_VALUE (t), NULL_TREE, 1);\n \n-      /* This does injection for friend functions. */\n-      if (!processing_template_decl)\n-\t{\n-\t  t = tsubst (DECL_TEMPLATE_INJECT (template), args, NULL_TREE);\n+  /* This does injection for friend functions. */\n+  if (!processing_template_decl)\n+    {\n+      t = tsubst (DECL_TEMPLATE_INJECT (template), args, NULL_TREE);\n \n-\t  for (; t; t = TREE_CHAIN (t))\n-\t    {\n-\t      tree d = TREE_VALUE (t);\n+      for (; t; t = TREE_CHAIN (t))\n+\t{\n+\t  tree d = TREE_VALUE (t);\n \n-\t      if (TREE_CODE (d) == TYPE_DECL)\n-\t\t/* Already injected.  */;\n-\t      else\n-\t\tpushdecl (d);\n-\t    }\n-\t} \n+\t  if (TREE_CODE (d) == TYPE_DECL)\n+\t    /* Already injected.  */;\n+\t  else\n+\t    pushdecl (d);\n+\t}\n+    } \n \n-      for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n-\tif (TREE_CODE (t) == FIELD_DECL)\n-\t  {\n-\t    TREE_TYPE (t) = complete_type (TREE_TYPE (t));\n-\t    require_complete_type (t);\n-\t  }\n+  for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+    if (TREE_CODE (t) == FIELD_DECL)\n+      {\n+\tTREE_TYPE (t) = complete_type (TREE_TYPE (t));\n+\trequire_complete_type (t);\n+      }\n \n-      type = finish_struct_1 (type, 0);\n-      CLASSTYPE_GOT_SEMICOLON (type) = 1;\n+  type = finish_struct_1 (type, 0);\n+  CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \n-      repo_template_used (type);\n-      if (at_eof && TYPE_BINFO_VTABLE (type) != NULL_TREE)\n-\tfinish_prevtable_vardecl (NULL, TYPE_BINFO_VTABLE (type));\n-    }\n-  else\n-    {\n-      TYPE_SIZE (type) = integer_zero_node;\n-      CLASSTYPE_METHOD_VEC (type)\n-\t= finish_struct_methods (type, TYPE_METHODS (type), 1);\n-    }\n+  repo_template_used (type);\n+  if (at_eof && TYPE_BINFO_VTABLE (type) != NULL_TREE)\n+    finish_prevtable_vardecl (NULL, TYPE_BINFO_VTABLE (type));\n \n+ end:\n   TYPE_BEING_DEFINED (type) = 0;\n   popclass (0);\n "}]}