{"sha": "2f31f742a6932e2138ca47c8fa9556d41a64ac1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzMWY3NDJhNjkzMmUyMTM4Y2E0N2M4ZmE5NTU2ZDQxYTY0YWMxZA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-12-17T11:39:43Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-12-17T11:39:43Z"}, "message": "re PR tree-optimization/51491 (ccp when converting from alloca should add a CLOBBER to right before __builtin_stack_restore)\n\n2011-12-17  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/51491\n\t* tree-ssa-ccp.c (insert_clobber_before_stack_restore)\n\t(gsi_prev_dom_bb_nondebug, insert_clobbers_for_var): New function.\n\t(ccp_fold_stmt): Use insert_clobbers_for_var after a successful\n\tfold_builtin_alloca_with_align.\n\t(ccp_visit_stmt): Calculate and free dominator info.\n\nFrom-SVN: r182432", "tree": {"sha": "535efde96351b106338d928086aa9c5c4e41364e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/535efde96351b106338d928086aa9c5c4e41364e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f31f742a6932e2138ca47c8fa9556d41a64ac1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f31f742a6932e2138ca47c8fa9556d41a64ac1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f31f742a6932e2138ca47c8fa9556d41a64ac1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f31f742a6932e2138ca47c8fa9556d41a64ac1d/comments", "author": null, "committer": null, "parents": [{"sha": "eb0287685d51079b766ce4649ebadd9b2f8b5886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb0287685d51079b766ce4649ebadd9b2f8b5886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb0287685d51079b766ce4649ebadd9b2f8b5886"}], "stats": {"total": 109, "additions": 106, "deletions": 3}, "files": [{"sha": "e38ab91624f16f245e038b28b9ca615fad4c84db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f31f742a6932e2138ca47c8fa9556d41a64ac1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f31f742a6932e2138ca47c8fa9556d41a64ac1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f31f742a6932e2138ca47c8fa9556d41a64ac1d", "patch": "@@ -1,3 +1,12 @@\n+2011-12-17  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/51491\n+\t* tree-ssa-ccp.c (insert_clobber_before_stack_restore)\n+\t(gsi_prev_dom_bb_nondebug, insert_clobbers_for_var): New function.\n+\t(ccp_fold_stmt): Use insert_clobbers_for_var after a successful\n+\tfold_builtin_alloca_with_align.\n+\t(ccp_visit_stmt): Calculate and free dominator info.\n+\n 2011-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.md (UNSPEC_FRAME_BLOCKAGE): New constant."}, {"sha": "a9c38ee8fad124e4acf1ef0a851f3ebd135e9ab7", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f31f742a6932e2138ca47c8fa9556d41a64ac1d/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f31f742a6932e2138ca47c8fa9556d41a64ac1d/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=2f31f742a6932e2138ca47c8fa9556d41a64ac1d", "patch": "@@ -1690,6 +1690,96 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n+/* Given a BUILT_IN_STACK_SAVE value SAVED_VAL, insert a clobber of VAR before\n+   each matching BUILT_IN_STACK_RESTORE.  Mark visited phis in VISITED.  */\n+\n+static void\n+insert_clobber_before_stack_restore (tree saved_val, tree var, htab_t *visited)\n+{\n+  gimple stmt, clobber_stmt;\n+  tree clobber;\n+  imm_use_iterator iter;\n+  gimple_stmt_iterator i;\n+  gimple *slot;\n+\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, saved_val)\n+    if (gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))\n+      {\n+\tclobber = build_constructor (TREE_TYPE (var), NULL);\n+\tTREE_THIS_VOLATILE (clobber) = 1;\n+\tclobber_stmt = gimple_build_assign (var, clobber);\n+\n+\ti = gsi_for_stmt (stmt);\n+\tgsi_insert_before (&i, clobber_stmt, GSI_SAME_STMT);\n+      }\n+    else if (gimple_code (stmt) == GIMPLE_PHI)\n+      {\n+\tif (*visited == NULL)\n+\t  *visited = htab_create (10, htab_hash_pointer, htab_eq_pointer, NULL);\n+\n+\tslot = (gimple *)htab_find_slot (*visited, stmt, INSERT);\n+\tif (*slot != NULL)\n+\t  continue;\n+\n+\t*slot = stmt;\n+\tinsert_clobber_before_stack_restore (gimple_phi_result (stmt), var,\n+\t\t\t\t\t     visited);\n+      }\n+    else\n+      gcc_assert (is_gimple_debug (stmt));\n+}\n+\n+/* Advance the iterator to the previous non-debug gimple statement in the same\n+   or dominating basic block.  */\n+\n+static inline void\n+gsi_prev_dom_bb_nondebug (gimple_stmt_iterator *i)\n+{\n+  basic_block dom;\n+\n+  gsi_prev_nondebug (i);\n+  while (gsi_end_p (*i))\n+    {\n+      dom = get_immediate_dominator (CDI_DOMINATORS, i->bb);\n+      if (dom == NULL || dom == ENTRY_BLOCK_PTR)\n+\treturn;\n+\n+      *i = gsi_last_bb (dom);\n+    }\n+}\n+\n+/* Find a BUILT_IN_STACK_SAVE dominating gsi_stmt (I), and insert\n+   a clobber of VAR before each matching BUILT_IN_STACK_RESTORE.  */\n+\n+static void\n+insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n+{\n+  bool save_found;\n+  gimple stmt;\n+  tree saved_val;\n+  htab_t visited = NULL;\n+\n+  for (save_found = false; !gsi_end_p (i); gsi_prev_dom_bb_nondebug (&i))\n+    {\n+      stmt = gsi_stmt (i);\n+\n+      if (!gimple_call_builtin_p (stmt, BUILT_IN_STACK_SAVE))\n+\tcontinue;\n+      save_found = true;\n+\n+      saved_val = gimple_call_lhs (stmt);\n+      if (saved_val == NULL_TREE)\n+\tcontinue;\n+\n+      insert_clobber_before_stack_restore (saved_val, var, &visited);\n+      break;\n+    }\n+\n+  if (visited != NULL)\n+    htab_delete (visited);\n+  gcc_assert (save_found);\n+}\n+\n /* Detects a __builtin_alloca_with_align with constant size argument.  Declares\n    fixed-size array and returns the address, if found, otherwise returns\n    NULL_TREE.  */\n@@ -1824,7 +1914,9 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n             if (new_rhs)\n \t      {\n \t\tbool res = update_call_from_tree (gsi, new_rhs);\n+\t\ttree var = TREE_OPERAND (TREE_OPERAND (new_rhs, 0),0);\n \t\tgcc_assert (res);\n+\t\tinsert_clobbers_for_var (*gsi, var);\n \t\treturn true;\n \t      }\n           }\n@@ -2024,12 +2116,14 @@ ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n static unsigned int\n do_ssa_ccp (void)\n {\n+  unsigned int todo = 0;\n+  calculate_dominance_info (CDI_DOMINATORS);\n   ccp_initialize ();\n   ssa_propagate (ccp_visit_stmt, ccp_visit_phi_node);\n   if (ccp_finalize ())\n-    return (TODO_cleanup_cfg | TODO_update_ssa | TODO_remove_unused_locals);\n-  else\n-    return 0;\n+    todo = (TODO_cleanup_cfg | TODO_update_ssa | TODO_remove_unused_locals);\n+  free_dominance_info (CDI_DOMINATORS);\n+  return todo;\n }\n \n "}]}