{"sha": "0088fcb1959f84a5789d695da687b1cdb560daba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4OGZjYjE5NTlmODRhNTc4OWQ2OTVkYTY4N2IxY2RiNTYwZGFiYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-29T01:26:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-29T01:26:23Z"}, "message": "(expand_assignment, expand_expr, do_jumps): Push and pop temp slots\naround making new temp slots and freeing them.\n\nFrom-SVN: r5524", "tree": {"sha": "c883a5e903edbafba1722d9fd8a8e37714428100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c883a5e903edbafba1722d9fd8a8e37714428100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0088fcb1959f84a5789d695da687b1cdb560daba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0088fcb1959f84a5789d695da687b1cdb560daba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0088fcb1959f84a5789d695da687b1cdb560daba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0088fcb1959f84a5789d695da687b1cdb560daba/comments", "author": null, "committer": null, "parents": [{"sha": "0eb202977b11c6a77c28a44e66e5d31b89cc6a82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb202977b11c6a77c28a44e66e5d31b89cc6a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb202977b11c6a77c28a44e66e5d31b89cc6a82"}], "stats": {"total": 34, "additions": 27, "deletions": 7}, "files": [{"sha": "ce4c426169491583ff37ffe9c4cd5e03234e652a", "filename": "gcc/expr.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0088fcb1959f84a5789d695da687b1cdb560daba/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0088fcb1959f84a5789d695da687b1cdb560daba/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0088fcb1959f84a5789d695da687b1cdb560daba", "patch": "@@ -2316,7 +2316,10 @@ expand_assignment (to, from, want_value, suggest_reg)\n       tree offset;\n       int unsignedp;\n       int volatilep = 0;\n-      tree tem = get_inner_reference (to, &bitsize, &bitpos, &offset,\n+      tree tem;\n+\n+      push_temp_slots ();\n+      tem = get_inner_reference (to, &bitsize, &bitpos, &offset,\n \t\t\t\t      &mode1, &unsignedp, &volatilep);\n \n       /* If we are going to use store_bit_field and extract_bit_field,\n@@ -2359,6 +2362,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t\t    int_size_in_bytes (TREE_TYPE (tem)));\n       preserve_temp_slots (result);\n       free_temp_slots ();\n+      pop_temp_slots ();\n \n       /* If the value is meaningful, convert RESULT to the proper mode.\n \t Otherwise, return nothing.  */\n@@ -2376,12 +2380,16 @@ expand_assignment (to, from, want_value, suggest_reg)\n      requires loading up part of an address in a separate insn.  */\n   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from))\n     {\n-      rtx value = expand_expr (from, NULL_RTX, VOIDmode, 0);\n+      rtx value;\n+\n+      push_temp_slots ();\n+      value = expand_expr (from, NULL_RTX, VOIDmode, 0);\n       if (to_rtx == 0)\n \tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, 0);\n       emit_move_insn (to_rtx, value);\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n+      pop_temp_slots ();\n       return want_value ? to_rtx : NULL_RTX;\n     }\n \n@@ -2394,10 +2402,14 @@ expand_assignment (to, from, want_value, suggest_reg)\n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL && GET_CODE (to_rtx) == REG)\n     {\n-      rtx temp = expand_expr (from, 0, GET_MODE (to_rtx), 0);\n+      rtx temp;\n+\n+      push_temp_slots ();\n+      temp = expand_expr (from, 0, GET_MODE (to_rtx), 0);\n       emit_move_insn (to_rtx, temp);\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n+      pop_temp_slots ();\n       return want_value ? to_rtx : NULL_RTX;\n     }\n \n@@ -2408,8 +2420,11 @@ expand_assignment (to, from, want_value, suggest_reg)\n       && current_function_returns_struct\n       && !current_function_returns_pcc_struct)\n     {\n-      rtx from_rtx = expand_expr (from, NULL_RTX, VOIDmode, 0);\n-      rtx size = expr_size (from);\n+      rtx from_rtx, size;\n+\n+      push_temp_slots ();\n+      from_rtx = expr_size (from);\n+      size = expand_expr (from, NULL_RTX, VOIDmode, 0);\n \n #ifdef TARGET_MEM_FUNCTIONS\n       emit_library_call (memcpy_libfunc, 0,\n@@ -2429,14 +2444,17 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n+      pop_temp_slots ();\n       return want_value ? to_rtx : NULL_RTX;\n     }\n \n   /* Compute FROM and store the value in the rtx we got.  */\n \n+  push_temp_slots ();\n   result = store_expr (from, to_rtx, want_value);\n   preserve_temp_slots (result);\n   free_temp_slots ();\n+  pop_temp_slots ();\n   return want_value ? result : NULL_RTX;\n }\n \n@@ -3834,9 +3852,11 @@ expand_expr (exp, target, tmode, modifier)\n       return const0_rtx;\n \n     case LOOP_EXPR:\n+      push_temp_slots ();\n       expand_start_loop (1);\n       expand_expr_stmt (TREE_OPERAND (exp, 0));\n       expand_end_loop ();\n+      pop_temp_slots ();\n \n       return const0_rtx;\n \n@@ -8078,8 +8098,10 @@ do_jump (exp, if_false_label, if_true_label)\n       break;\n \n     case COMPOUND_EXPR:\n+      push_temp_slots ();\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n       free_temp_slots ();\n+      pop_temp_slots ();\n       emit_queue ();\n       do_pending_stack_adjust ();\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n@@ -8251,8 +8273,6 @@ do_jump (exp, if_false_label, if_true_label)\n   else if (comparison)\n     do_jump_for_compare (comparison, if_false_label, if_true_label);\n \n-  free_temp_slots ();\n-\n   if (drop_through_label)\n     {\n       /* If do_jump produces code that might be jumped around,"}]}