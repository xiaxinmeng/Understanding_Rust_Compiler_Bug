{"sha": "45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU4NjlhNmNhYjE0YzA5MDRkMjFhMGE2Njk5ZGVlNzNkOWNiYmU0Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-15T11:27:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-15T11:27:43Z"}, "message": "cp-tree.def (TYPENAME_TYPE): Add to documentation.\n\n\t* cp-tree.def (TYPENAME_TYPE): Add to documentation.\n\t* cp-tree.h (TYPENAME_TYPE_FULLNAME): Document.\n\t(build_typename_type): New function.\n\t* decl.c (build_typename_type): Broken out from ...\n\t(make_typename_type): Use it.\n\t* search.c (lookup_field): Likewise.\n\nFrom-SVN: r23110", "tree": {"sha": "2411eb0474f73e5c07a2298b3088b34464cf149a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2411eb0474f73e5c07a2298b3088b34464cf149a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/comments", "author": null, "committer": null, "parents": [{"sha": "80fba193dd65d41044e3175d95e5a3b29d2ab353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80fba193dd65d41044e3175d95e5a3b29d2ab353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80fba193dd65d41044e3175d95e5a3b29d2ab353"}], "stats": {"total": 100, "additions": 78, "deletions": 22}, "files": [{"sha": "2b249696dc16b68ad34b15f17c1d68f30e757228", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "patch": "@@ -143,7 +143,10 @@ DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n    The TYPE_FIELDS value will be a TEMPLATE_PARM_INDEX.  */\n DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", 't', 0)\n \n-/* A type designated by 'typename T::t'. */\n+/* A type designated by `typename T::t'.  TYPE_CONTEXT is `T',\n+   TYPE_NAME is a TYPE_DECL for `t'.  If TREE_TYPE is present, this\n+   type was generated by the implicit typename extension, and the\n+   TREE_TYPE is a _TYPE from a baseclass of `T'.  */\n DEFTREECODE (TYPENAME_TYPE, \"typename_type\", 't', 0)\n \n /* A thunk is a stub function."}, {"sha": "6a74d265eb5f66b52d4f02da9a65122c38a71082", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "patch": "@@ -1337,6 +1337,10 @@ struct lang_decl\n    && !CLASSTYPE_USE_TEMPLATE (NODE) \\\n    && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE)))\n \n+/* The name used by the user to name the typename type.  Typically,\n+   this is an IDENTIFIER_NODE, and the same as the DECL_NAME on the\n+   corresponding TYPE_DECL.  However, this may also be a\n+   TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n #define TYPENAME_TYPE_FULLNAME(NODE)\tCLASSTYPE_SIZE (NODE)\n \n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n@@ -2543,6 +2547,7 @@ extern tree binding_for_name                    PROTO((tree, tree));\n extern tree namespace_binding                   PROTO((tree, tree));\n extern void set_namespace_binding               PROTO((tree, tree, tree));\n extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n+extern tree build_typename_type                 PROTO((tree, tree, tree, tree));\n extern tree make_typename_type\t\t\tPROTO((tree, tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree lookup_function_nonclass            PROTO((tree, tree));"}, {"sha": "8facd96efb106d82be043901fcf25881884c3408", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "patch": "@@ -4776,11 +4776,51 @@ lookup_namespace_name (namespace, name)\n   return error_mark_node;\n }\n \n+/* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is\n+   the type of `T', NAME is the IDENTIFIER_NODE for `t'.  If BASE_TYPE\n+   is non-NULL, this type is being created by the implicit typename\n+   extension, and BASE_TYPE is a type named `t' in some base class of\n+   `T' which depends on template parameters.  \n+\n+   Returns the new TYPENAME_TYPE.  */\n+\n+tree\n+build_typename_type (context, name, fullname, base_type)\n+     tree context;\n+     tree name;\n+     tree fullname;\n+     tree base_type;\n+{\n+  tree t;\n+  tree d;\n+\n+  if (processing_template_decl)\n+    push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  /* Build the TYPENAME_TYPE.  */\n+  t = make_lang_type (TYPENAME_TYPE);\n+  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n+  TYPENAME_TYPE_FULLNAME (t) = fullname;\n+  TREE_TYPE (t) = base_type;\n+  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n+\n+  /* Build the corresponding TYPE_DECL.  */\n+  d = build_decl (TYPE_DECL, name, t);\n+  TYPE_NAME (TREE_TYPE (d)) = d;\n+  TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n+  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n+\n+  if (processing_template_decl)\n+    pop_obstacks ();\n+\n+  return t;\n+}\n+\n tree\n make_typename_type (context, name)\n      tree context, name;\n {\n-  tree t, d;\n+  tree t;\n   tree fullname;\n \n   if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n@@ -4846,22 +4886,8 @@ make_typename_type (context, name)\n \t  return TREE_TYPE (t);\n \t}\n     }\n-\n-  if (processing_template_decl)\n-    push_obstacks (&permanent_obstack, &permanent_obstack);\n-  t = make_lang_type (TYPENAME_TYPE);\n-  TYPENAME_TYPE_FULLNAME (t) = fullname;\n-  d = build_decl (TYPE_DECL, name, t);\n-  if (processing_template_decl)\n-    pop_obstacks ();\n-\n-  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n-  TYPE_NAME (TREE_TYPE (d)) = d;\n-  TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n-  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n-  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n-\n-  return t;\n+  \n+  return build_typename_type (context, name, fullname,  NULL_TREE);\n }\n \n /* Select the right _DECL from multiple choices. */"}, {"sha": "50afeeebb87a507a23def6978280d63a956ad951", "filename": "gcc/cp/search.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "patch": "@@ -1178,7 +1178,14 @@ lookup_field (xbasetype, name, protect, want_type)\n       rval = error_mark_node;\n     }\n \n-  /* Do implicit typename stuff.  */\n+  /* Do implicit typename stuff.  This code also handles out-of-class\n+     definitions of nested classes whose enclosing class is a\n+     template.  For example:\n+    \n+       template <class T> struct S { struct I { void f(); }; };\n+       template <class T> void S<T>::I::f() {}\n+\n+     will come through here to handle `S<T>::I'.  */\n   if (rval && TREE_CODE (rval) == TYPE_DECL\n       && processing_template_decl\n       && ! currently_open_class (BINFO_TYPE (rval_binfo))\n@@ -1191,9 +1198,9 @@ lookup_field (xbasetype, name, protect, want_type)\n \t\t== current_class_type))\n \t  break;\n \n-      entry = make_typename_type (BINFO_TYPE (binfo), name);\n-      TREE_TYPE (entry) = TREE_TYPE (rval);\n-      rval = TYPE_MAIN_DECL (entry);\n+      entry = build_typename_type (BINFO_TYPE (binfo), name,  name, \n+\t\t\t\t   TREE_TYPE (rval));\n+      return TYPE_STUB_DECL (entry);\n     }\n \n   return rval;"}, {"sha": "7365b66801d174f31b69028df41e4a88f71ed08a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename14.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45869a6cab14c0904d21a0a6699dee73d9cbbe4b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename14.C?ref=45869a6cab14c0904d21a0a6699dee73d9cbbe4b", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+// Special g++ Options:\n+\n+template <class T>\n+struct B {\n+  typedef T X;\n+};\n+\n+template <class T>\n+struct S : public B<T>\n+{\n+  struct I {\n+    void f(X x);\n+  };\n+};"}]}