{"sha": "486b97f297eb20c5b72140ea257ff63143a69ab7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg2Yjk3ZjI5N2ViMjBjNWI3MjE0MGVhMjU3ZmY2MzE0M2E2OWFiNw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-01-09T18:54:20Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-01-09T18:54:20Z"}, "message": "Handle CALL_INSN_FUNCTION_USAGE clobbers in regcprop.c\n\n2015-01-09  Tom de Vries  <tom@codesourcery.com>\n\n\tPR rtl-optimization/64539\n\t* regcprop.c (kill_clobbered_values): Factor out of ...\n\t(copyprop_hardreg_forward_1): ... here.  Use kill_clobbered_values\n\tinstead of note_stores with kill_clobbered_value.\n\nFrom-SVN: r219400", "tree": {"sha": "381a5fca650264f9920f721e61b4238adc3072c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381a5fca650264f9920f721e61b4238adc3072c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/486b97f297eb20c5b72140ea257ff63143a69ab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486b97f297eb20c5b72140ea257ff63143a69ab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/486b97f297eb20c5b72140ea257ff63143a69ab7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486b97f297eb20c5b72140ea257ff63143a69ab7/comments", "author": null, "committer": null, "parents": [{"sha": "a5dbcace37f1cfe87beda11af3e4ce2c0beb9a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5dbcace37f1cfe87beda11af3e4ce2c0beb9a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5dbcace37f1cfe87beda11af3e4ce2c0beb9a91"}], "stats": {"total": 41, "additions": 29, "deletions": 12}, "files": [{"sha": "340b03f4f5149c627cd414bbe5b9ccc8c98fba6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486b97f297eb20c5b72140ea257ff63143a69ab7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486b97f297eb20c5b72140ea257ff63143a69ab7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=486b97f297eb20c5b72140ea257ff63143a69ab7", "patch": "@@ -1,3 +1,10 @@\n+2015-01-09  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR rtl-optimization/64539\n+\t* regcprop.c (kill_clobbered_values): Factor out of ...\n+\t(copyprop_hardreg_forward_1): ... here.  Use kill_clobbered_values\n+\tinstead of note_stores with kill_clobbered_value.\n+\n 2015-01-09  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t * ginclude/unwind-arm-common.h: Revert previous commit."}, {"sha": "c809e774c58a30e57312049b490567467336dde6", "filename": "gcc/regcprop.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486b97f297eb20c5b72140ea257ff63143a69ab7/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486b97f297eb20c5b72140ea257ff63143a69ab7/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=486b97f297eb20c5b72140ea257ff63143a69ab7", "patch": "@@ -734,6 +734,26 @@ cprop_find_used_regs (rtx *loc, void *data)\n     }\n }\n \n+/* Apply clobbers of INSN in PATTERN and C_I_F_U to value_data VD.  */\n+\n+static void\n+kill_clobbered_values (rtx_insn *insn, struct value_data *vd)\n+{\n+  note_stores (PATTERN (insn), kill_clobbered_value, vd);\n+\n+  if (CALL_P (insn))\n+    {\n+      rtx exp;\n+\n+      for (exp = CALL_INSN_FUNCTION_USAGE (insn); exp; exp = XEXP (exp, 1))\n+\t{\n+\t  rtx x = XEXP (exp, 0);\n+\t  if (GET_CODE (x) == CLOBBER)\n+\t    kill_value (SET_DEST (x), vd);\n+\t}\n+    }\n+}\n+\n /* Perform the forward copy propagation on basic block BB.  */\n \n static bool\n@@ -800,7 +820,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       /* Within asms, a clobber cannot overlap inputs or outputs.\n \t I wouldn't think this were true for regular insns, but\n \t scan_rtx treats them like that...  */\n-      note_stores (PATTERN (insn), kill_clobbered_value, vd);\n+      kill_clobbered_values (insn, vd);\n \n       /* Kill all auto-incremented values.  */\n       /* ??? REG_INC is useless, since stack pushes aren't done that way.  */\n@@ -1035,17 +1055,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t     but instead among CLOBBERs on the CALL_INSN, we could wrongly\n \t     assume the value in it is still live.  */\n \t  if (ksvd.ignore_set_reg)\n-\t    {\n-\t      note_stores (PATTERN (insn), kill_clobbered_value, vd);\n-\t      for (exp = CALL_INSN_FUNCTION_USAGE (insn);\n-\t\t   exp;\n-\t\t   exp = XEXP (exp, 1))\n-\t\t{\n-\t\t  rtx x = XEXP (exp, 0);\n-\t\t  if (GET_CODE (x) == CLOBBER)\n-\t\t    kill_value (SET_DEST (x), vd);\n-\t\t}\n-\t    }\n+\t    kill_clobbered_values (insn, vd);\n \t}\n \n       bool copy_p = (set"}]}