{"sha": "fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM2YjRhYTQzYWQzZGZkYjYzMGI2YmJkZDQ0MWRhZDkyM2ZhOTBiOQ==", "commit": {"author": {"name": "David Daney", "email": "ddaney@avtrex.com", "date": "2005-03-09T22:11:33Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2005-03-09T22:11:33Z"}, "message": "re PR libgcj/20389 (BufferedInputStream gets ArrayIndexOutOfBoundsExeception)\n\n2005-03-09  David Daney  <ddaney@avtrex.com>\n\n\tPR libgcj/20389\n\tMerge BufferedInputStream from GNU Classpath.\n\t* java/io/BufferedInputStream.java (marktarget): Field removed.\n\t(CHUNKSIZE): Field removed.\n\t(bufferSize): New field.\n\t(BufferedInputStream): Initialize fields.\n\t(close): Invalidate mark and buffer indexes.\n\t(mark):  Rewritten.\n\t(read()): Move mark handling code to refill.\n\t(read(byte[], int, int)): Ditto.\n\t(skip): Ditto and simplify EOF testing.\n\t(refill): Rewritten.\n\t* java/io/InputStreamReader.java (refill): Removed mark and reset\n\tof internal BufferedInputStream.\n\nFrom-SVN: r96217", "tree": {"sha": "6288b3f4fc2b8b47f82bdb4050df99906a36cf50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6288b3f4fc2b8b47f82bdb4050df99906a36cf50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/comments", "author": null, "committer": null, "parents": [{"sha": "9c90a97e936f00e67938ba115719fe7dda5c545e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c90a97e936f00e67938ba115719fe7dda5c545e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c90a97e936f00e67938ba115719fe7dda5c545e"}], "stats": {"total": 101, "additions": 46, "deletions": 55}, "files": [{"sha": "e55087ceddb43a56df785b17a76ddf7cf932be97", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "patch": "@@ -1,3 +1,20 @@\n+2005-03-09  David Daney  <ddaney@avtrex.com>\n+\n+\tPR libgcj/20389\n+\tMerge BufferedInputStream from GNU Classpath.\n+\t* java/io/BufferedInputStream.java (marktarget): Field removed.\n+\t(CHUNKSIZE): Field removed.\n+\t(bufferSize): New field.\n+\t(BufferedInputStream): Initialize fields.\n+\t(close): Invalidate mark and buffer indexes.\n+\t(mark):  Rewritten.\n+\t(read()): Move mark handling code to refill.\n+\t(read(byte[], int, int)): Ditto.\n+\t(skip): Ditto and simplify EOF testing.\n+\t(refill): Rewritten.\n+\t* java/io/InputStreamReader.java (refill): Removed mark and reset\n+\tof internal BufferedInputStream.\n+\n 2005-03-09  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natVMClassLoader.cc (defineClass): Reference"}, {"sha": "bbb38c4371995c37be7994bb12c95077db56ab6b", "filename": "libjava/java/io/BufferedInputStream.java", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedInputStream.java?ref=fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "patch": "@@ -65,6 +65,7 @@\n  */\n public class BufferedInputStream extends FilterInputStream\n {\n+\n   /**\n    * This is the default buffer size\n    */\n@@ -103,17 +104,11 @@ public class BufferedInputStream extends FilterInputStream\n   protected int marklimit;\n \n   /**\n-   * This is the maximum size we have to allocate for the mark buffer.\n-   * This number may be huge (Integer.MAX_VALUE). The class will continue\n-   * to allocate new chunks (specified by <code>CHUNKSIZE</code>) until the\n-   * the size specified by this field is achieved.\n-   */\n-  private int marktarget = 0;\n-\n-  /**\n-   * This is the number of bytes to allocate to reach marktarget.\n+   * This is the initial buffer size. When the buffer is grown because\n+   * of marking requirements, it will be grown by bufferSize increments.\n+   * The underlying stream will be read in chunks of bufferSize.\n    */\n-  static final private int CHUNKSIZE = 1024;\n+  private final int bufferSize;\n \n   /**\n    * This method initializes a new <code>BufferedInputStream</code> that will\n@@ -143,6 +138,9 @@ public BufferedInputStream(InputStream in, int size)\n     if (size <= 0)\n       throw new IllegalArgumentException();\n     buf = new byte[size];\n+    // initialize pos & count to bufferSize, to prevent refill from\n+    // allocating a new buffer (if the caller starts out by calling mark()).\n+    pos = count = bufferSize = size;\n   }\n \n   /**\n@@ -173,6 +171,8 @@ public void close() throws IOException\n   {\n     // Free up the array memory.\n     buf = null;\n+    pos = count = 0;\n+    markpos = -1;\n     super.close();\n   }\n \n@@ -196,9 +196,7 @@ public void close() throws IOException\n    */\n   public synchronized void mark(int readlimit)\n   {\n-    marktarget = marklimit = readlimit;\n-    if (marklimit > CHUNKSIZE)\n-      marklimit = CHUNKSIZE;\n+    marklimit = readlimit;\n     markpos = pos;\n   }\n \n@@ -231,9 +229,6 @@ public synchronized int read() throws IOException\n     if (pos >= count && !refill())\n       return -1;\t// EOF\n \n-    if (markpos >= 0 && pos - markpos > marktarget)\n-      markpos = -1;\n-\n     return buf[pos++] & 0xFF;\n   }\n \n@@ -278,9 +273,6 @@ public synchronized int read(byte[] b, int off, int len) throws IOException\n     off += totalBytesRead;\n     len -= totalBytesRead;\n \n-    if (markpos >= 0 && pos - markpos > marktarget)\n-      markpos = -1;\n-\n     while (len > 0 && super.available() > 0 && refill())\n       {\n \tint remain = Math.min(count - pos, len);\n@@ -289,9 +281,6 @@ public synchronized int read(byte[] b, int off, int len) throws IOException\n \toff += remain;\n \tlen -= remain;\n \ttotalBytesRead += remain;\n-\n-\tif (markpos >= 0 && pos - markpos > marktarget)\n-\t  markpos = -1;\n       }\n \n     return totalBytesRead;\n@@ -339,22 +328,17 @@ public synchronized long skip(long n) throws IOException\n     while (n > 0L)\n       {\n \tif (pos >= count && !refill())\n-\t  if (n < origN)\n-\t    break;\n-\t  else\n-\t    return 0;\t// No bytes were read before EOF.\n+          break;\n \n \tint numread = (int) Math.min((long) (count - pos), n);\n \tpos += numread;\n \tn -= numread;\n-\n-        if (markpos >= 0 && pos - markpos > marktarget)\n-          markpos = -1;\n       }\n \n     return origN - n;\n   }\n \n+  // GCJ LOCAL: package-private for use by InputStreamReader\n   /**\n    * Called to refill the buffer (when count is equal to pos).\n    *\n@@ -366,39 +350,31 @@ boolean refill() throws IOException\n     if (buf == null)\n       throw new IOException(\"Stream closed.\");\n \n-    if (markpos < 0)\n-      count = pos = 0;\n-    else if (markpos > 0)\n+    if (markpos == -1 || count - markpos >= marklimit)\n       {\n-        // Shift the marked bytes (if any) to the beginning of the array\n-\t// but don't grow it.  This saves space in case a reset is done\n-\t// before we reach the max capacity of this array.\n-        System.arraycopy(buf, markpos, buf, 0, count - markpos);\n-\tcount -= markpos;\n-\tpos -= markpos;\n-\tmarkpos = 0;\n+\tmarkpos = -1;\n+\tpos = count = 0;\n       }\n-    else if (count >= buf.length && count < marktarget)\t// BTW, markpos == 0\n+    else\n       {\n-\t// Need to grow the buffer now to have room for marklimit bytes.\n-\t// Note that the new buffer is one greater than marklimit.\n-\t// This is so that there will be one byte past marklimit to be read\n-\t// before having to call refill again, thus allowing marklimit to be\n-\t// invalidated.  That way refill doesn't have to check marklimit.\n-\tmarklimit += CHUNKSIZE;\n-\tif (marklimit >= marktarget)\n-\t  marklimit = marktarget;\n-\tbyte[] newbuf = new byte[marklimit + 1];\n-\tSystem.arraycopy(buf, 0, newbuf, 0, count);\n+\tbyte[] newbuf = buf;\n+\tif (markpos < bufferSize)\n+\t  {\n+\t    newbuf = new byte[count - markpos + bufferSize];\n+\t  }\n+\tSystem.arraycopy(buf, markpos, newbuf, 0, count - markpos);\n \tbuf = newbuf;\n+\tcount -= markpos;\n+\tpos -= markpos;\n+\tmarkpos = 0;\n       }\n \n-    int numread = super.read(buf, count, buf.length - count);\n+    int numread = super.read(buf, count, bufferSize);\n \n-    if (numread < 0)\t// EOF\n+    if (numread <= 0)\t// EOF\n       return false;\n \n     count += numread;\n-    return numread > 0;\n+    return true;\n   }\n }"}, {"sha": "b3f65368ce31d51d66e7df6177707d04b625f3c2", "filename": "libjava/java/io/InputStreamReader.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/libjava%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9/libjava%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStreamReader.java?ref=fc6b4aa43ad3dfdb630b6bbdd441dad923fa90b9", "patch": "@@ -282,11 +282,9 @@ private int refill(char[] buf, int offset, int length) throws IOException\n       {\n \t// We have knowledge of the internals of BufferedInputStream\n \t// here.  Eww.\n-\tin.mark (0);\n \t// BufferedInputStream.refill() can only be called when\n \t// `pos>=count'.\n \tboolean r = in.pos < in.count || in.refill ();\n-\tin.reset ();\n \tif (! r)\n \t  return -1;\n \tconverter.setInput(in.buf, in.pos, in.count);"}]}