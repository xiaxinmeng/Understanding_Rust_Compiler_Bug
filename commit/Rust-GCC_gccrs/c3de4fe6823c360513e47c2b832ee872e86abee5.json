{"sha": "c3de4fe6823c360513e47c2b832ee872e86abee5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNkZTRmZTY4MjNjMzYwNTEzZTQ3YzJiODMyZWU4NzJlODZhYmVlNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-03T23:44:03Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-03T23:44:03Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r873", "tree": {"sha": "0c859bd490373b2c6772afacce858b130a020cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c859bd490373b2c6772afacce858b130a020cfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3de4fe6823c360513e47c2b832ee872e86abee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3de4fe6823c360513e47c2b832ee872e86abee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3de4fe6823c360513e47c2b832ee872e86abee5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3de4fe6823c360513e47c2b832ee872e86abee5/comments", "author": null, "committer": null, "parents": [{"sha": "5c18abb46c50705d03f1825143c0a34462b0d255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c18abb46c50705d03f1825143c0a34462b0d255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c18abb46c50705d03f1825143c0a34462b0d255"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "c74275a709b777aa84bc2a5a96f3fcbaa981c04a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3de4fe6823c360513e47c2b832ee872e86abee5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3de4fe6823c360513e47c2b832ee872e86abee5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c3de4fe6823c360513e47c2b832ee872e86abee5", "patch": "@@ -1090,10 +1090,13 @@ output_move_double (operands)\n \t if it is in a struct.  But a DImode need not be 8-byte aligned,\n \t because it could be a struct containing two ints or pointers.\n \t Hence, a constant DFmode address will always be 8-byte aligned.\n+\t Any DFmode access inside a struct will always be aligned.\n \t If TARGET_HOPE_ALIGN, then assume all doubles are aligned even if this\n \t is not a constant address.  */\n-      else if (GET_CODE (addr) == MEM && GET_MODE (addr) == DFmode\n-\t       && (CONSTANT_P (addr) || TARGET_HOPE_ALIGN))\n+      else if (GET_MODE (addr) == DFmode\n+\t       && (CONSTANT_P (XEXP (addr, 0))\n+\t\t   || MEM_IN_STRUCT_P (addr)\n+\t\t   || TARGET_HOPE_ALIGN))\n \treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n     }\n "}, {"sha": "0897dd3a3dd94a0fe2182fa8e6e334825eec46bd", "filename": "gcc/sched.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3de4fe6823c360513e47c2b832ee872e86abee5/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3de4fe6823c360513e47c2b832ee872e86abee5/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=c3de4fe6823c360513e47c2b832ee872e86abee5", "patch": "@@ -137,6 +137,9 @@ static int *insn_luid;\n static int *insn_priority;\n #define INSN_PRIORITY(INSN) (insn_priority[INSN_UID (INSN)])\n \n+static short *insn_costs;\n+#define INSN_COST(INSN)\tinsn_costs[INSN_UID (INSN)]\n+\n #define DONE_PRIORITY\t-1\n #define MAX_PRIORITY\t0x7fffffff\n #define TAIL_PRIORITY\t0x7ffffffe\n@@ -899,20 +902,27 @@ insn_cost (insn)\n {\n   register int cost;\n \n+  if (INSN_COST (insn))\n+    return INSN_COST (insn);\n+\n   recog_memoized (insn);\n \n   /* A USE insn, or something else we don't need to understand.\n      We can't pass these directly to result_ready_cost because it will trigger\n      a fatal error for unrecognizable insns.  */\n   if (INSN_CODE (insn) < 0)\n-    return 1;\n+    {\n+      INSN_COST (insn) = 1;\n+      return 1;\n+    }\n   else\n     {\n       cost = result_ready_cost (insn);\n \n       if (cost < 1)\n \tcost = 1;\n \n+      INSN_COST (insn) = cost;\n       return cost;\n     }\n }\n@@ -1422,14 +1432,14 @@ sched_analyze_2 (x, insn)\n     case ASM_OPERANDS:\n     case ASM_INPUT:\n     case UNSPEC_VOLATILE:\n+    case TRAP_IF:\n       {\n \trtx u;\n \n \t/* Traditional and volatile asm instructions must be considered to use\n \t   and clobber all hard registers and all of memory.  So must\n-\t   UNSPEC_VOLATILE operations.  */\n-\tif ((code == ASM_OPERANDS && MEM_VOLATILE_P (x)) || code == ASM_INPUT\n-\t    || code == UNSPEC_VOLATILE)\n+\t   TRAP_IF and UNSPEC_VOLATILE operations.  */\n+\tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n \t  {\n \t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t      {\n@@ -3794,10 +3804,9 @@ schedule_insns (dump_file)\n \n   /* Allocate data for this pass.  See comments, above,\n      for what these vectors do.  */\n-  /* ??? Instruction splitting below may create new instructions, so these\n-     arrays must be bigger than just max_uid.  */\n   insn_luid = (int *) alloca (max_uid * sizeof (int));\n   insn_priority = (int *) alloca (max_uid * sizeof (int));\n+  insn_costs = (short *) alloca (max_uid * sizeof (short));\n   insn_ref_count = (int *) alloca (max_uid * sizeof (int));\n \n   if (reload_completed == 0)\n@@ -3848,6 +3857,7 @@ schedule_insns (dump_file)\n \n   bzero (insn_luid, max_uid * sizeof (int));\n   bzero (insn_priority, max_uid * sizeof (int));\n+  bzero (insn_costs, max_uid * sizeof (short));\n   bzero (insn_ref_count, max_uid * sizeof (int));\n \n   /* Schedule each basic block, block by block.  */"}]}