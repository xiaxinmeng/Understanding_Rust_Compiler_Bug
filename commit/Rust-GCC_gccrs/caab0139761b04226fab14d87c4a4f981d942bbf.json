{"sha": "caab0139761b04226fab14d87c4a4f981d942bbf", "node_id": "C_kwDOANBUbNoAKGNhYWIwMTM5NzYxYjA0MjI2ZmFiMTRkODdjNGE0Zjk4MWQ5NDJiYmY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-18T13:55:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-19T07:12:41Z"}, "message": "Remove check_aligned parameter from vect_supportable_dr_alignment\n\nThere are two calls with true as parameter, one is only relevant\nfor the case of the misalignment being unknown which means the\naccess is never aligned there, the other is in the peeling hash\ninsert code used conditional on the unlimited cost model which\nadds an artificial count.  But the way it works right now is\nthat it boosts the count if the specific misalignment when not peeling\nis unsupported - in particular when the access is currently aligned\nwe'll query the backend with a misalign value of zero.  I've\nchanged it to boost the peeling when unknown alignment is not\nsupported instead and noted how we could in principle improve this.\n\n2021-10-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_supportable_dr_alignment): Remove\n\tcheck_aligned argument.\n\t* tree-vect-data-refs.c (vect_supportable_dr_alignment):\n\tLikewise.\n\t(vect_peeling_hash_insert): Add supportable_if_not_aligned\n\targument and do not call vect_supportable_dr_alignment here.\n\t(vect_peeling_supportable): Adjust.\n\t(vect_enhance_data_refs_alignment): Compute whether the\n\taccess is supported with different alignment here and\n\tpass that down to vect_peeling_hash_insert.\n\t(vect_vfa_access_size): Adjust.\n\t* tree-vect-stmts.c (vect_get_store_cost): Likewise.\n\t(vect_get_load_cost): Likewise.\n\t(get_negative_load_store_type): Likewise.\n\t(get_group_load_store_type): Likewise.\n\t(get_load_store_type): Likewise.", "tree": {"sha": "59970dad791382ee123f8a40aab415c6bb05e8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59970dad791382ee123f8a40aab415c6bb05e8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caab0139761b04226fab14d87c4a4f981d942bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caab0139761b04226fab14d87c4a4f981d942bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caab0139761b04226fab14d87c4a4f981d942bbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caab0139761b04226fab14d87c4a4f981d942bbf/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df592811f950301ed3b10a08e476dad0f2eff26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df592811f950301ed3b10a08e476dad0f2eff26a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df592811f950301ed3b10a08e476dad0f2eff26a"}], "stats": {"total": 55, "additions": 30, "deletions": 25}, "files": [{"sha": "7c95f9ad69e0c51d1ae21b311878efaf23bbdcd8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caab0139761b04226fab14d87c4a4f981d942bbf/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caab0139761b04226fab14d87c4a4f981d942bbf/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=caab0139761b04226fab14d87c4a4f981d942bbf", "patch": "@@ -1465,14 +1465,10 @@ peel_info_hasher::equal (const _vect_peel_info *a, const _vect_peel_info *b)\n static void\n vect_peeling_hash_insert (hash_table<peel_info_hasher> *peeling_htab,\n \t\t\t  loop_vec_info loop_vinfo, dr_vec_info *dr_info,\n-                          int npeel)\n+\t\t\t  int npeel, bool supportable_if_not_aligned)\n {\n   struct _vect_peel_info elem, *slot;\n   _vect_peel_info **new_slot;\n-  tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n-  bool supportable_dr_alignment\n-    = (vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype, true)\n-       != dr_unaligned_unsupported);\n \n   elem.npeel = npeel;\n   slot = peeling_htab->find (&elem);\n@@ -1488,7 +1484,9 @@ vect_peeling_hash_insert (hash_table<peel_info_hasher> *peeling_htab,\n       *new_slot = slot;\n     }\n \n-  if (!supportable_dr_alignment\n+  /* If this DR is not supported with unknown misalignment then bias\n+     this slot when the cost model is disabled.  */\n+  if (!supportable_if_not_aligned\n       && unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n     slot->count += VECT_MAX_COST;\n }\n@@ -1661,7 +1659,7 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n       vect_update_misalignment_for_peel (dr_info, dr0_info, npeel);\n       tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n       supportable_dr_alignment\n-\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype, false);\n+\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n       SET_DR_MISALIGNMENT (dr_info, save_misalignment);\n \n       if (supportable_dr_alignment == dr_unaligned_unsupported)\n@@ -1803,7 +1801,6 @@ opt_result\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum dr_alignment_support supportable_dr_alignment;\n   dr_vec_info *first_store = NULL;\n   dr_vec_info *dr0_info = NULL;\n   struct data_reference *dr;\n@@ -1912,8 +1909,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       stmt_vec_info stmt_info = dr_info->stmt;\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      supportable_dr_alignment\n-\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype, true);\n       do_peeling = vector_alignment_reachable_p (dr_info);\n       if (do_peeling)\n         {\n@@ -1957,11 +1952,20 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t}\n \n \t      /* Save info about DR in the hash table.  Also include peeling\n-\t         amounts according to the explanation above.  */\n+\t\t amounts according to the explanation above.  Indicate\n+\t\t the alignment status when the ref is not aligned.\n+\t\t ???  Rather than using unknown alignment here we should\n+\t\t prune all entries from the peeling hashtable which cause\n+\t\t DRs to be not supported.  */\n+\t      bool supportable_if_not_aligned\n+\t\t= targetm.vectorize.support_vector_misalignment\n+\t\t    (TYPE_MODE (vectype), TREE_TYPE (DR_REF (dr_info->dr)),\n+\t\t     DR_MISALIGNMENT_UNKNOWN, false);\n \t      while (known_le (npeel_tmp, nscalars))\n                 {\n                   vect_peeling_hash_insert (&peeling_htab, loop_vinfo,\n-\t\t\t\t\t    dr_info, npeel_tmp);\n+\t\t\t\t\t    dr_info, npeel_tmp,\n+\t\t\t\t\t    supportable_if_not_aligned);\n \t\t  npeel_tmp += MAX (1, target_align / dr_size);\n                 }\n \n@@ -2000,6 +2004,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n \t      /* Check for data refs with unsupportable alignment that\n \t         can be peeled.  */\n+\t      enum dr_alignment_support supportable_dr_alignment\n+\t\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n \t      if (supportable_dr_alignment == dr_unaligned_unsupported)\n \t\t{\n \t\t  one_dr_unsupportable = true;\n@@ -2354,9 +2360,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      break;\n \t    }\n \n-\t  supportable_dr_alignment\n-\t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n-\t\t\t\t\t     false);\n+\t  enum dr_alignment_support supportable_dr_alignment\n+\t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype);\n \t  if (supportable_dr_alignment == dr_unaligned_unsupported)\n             {\n \t      if (known_alignment_for_access_p (dr_info, vectype)\n@@ -3305,7 +3310,7 @@ vect_vfa_access_size (vec_info *vinfo, dr_vec_info *dr_info)\n     }\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   if (STMT_VINFO_VEC_STMTS (stmt_vinfo).exists ()\n-      && (vect_supportable_dr_alignment (vinfo, dr_info, vectype, false)\n+      && (vect_supportable_dr_alignment (vinfo, dr_info, vectype)\n \t  == dr_explicit_realign_optimized))\n     {\n       /* We might access a full vector's worth.  */\n@@ -6630,7 +6635,7 @@ vect_can_force_dr_alignment_p (const_tree decl, poly_uint64 alignment)\n \n enum dr_alignment_support\n vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n-\t\t\t       tree vectype, bool check_aligned_accesses)\n+\t\t\t       tree vectype)\n {\n   data_reference *dr = dr_info->dr;\n   stmt_vec_info stmt_info = dr_info->stmt;\n@@ -6639,7 +6644,7 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n   class loop *vect_loop = NULL;\n   bool nested_in_vect_loop = false;\n \n-  if (aligned_access_p (dr_info, vectype) && !check_aligned_accesses)\n+  if (aligned_access_p (dr_info, vectype))\n     return dr_aligned;\n \n   /* For now assume all conditional loads/stores support unaligned"}, {"sha": "5d8fe42e20082094a3bdc4dd6a5cf4bfd19709d3", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caab0139761b04226fab14d87c4a4f981d942bbf/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caab0139761b04226fab14d87c4a4f981d942bbf/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=caab0139761b04226fab14d87c4a4f981d942bbf", "patch": "@@ -1028,7 +1028,7 @@ vect_get_store_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   dr_alignment_support alignment_support_scheme\n-    = vect_supportable_dr_alignment (vinfo, dr_info, vectype, false);\n+    = vect_supportable_dr_alignment (vinfo, dr_info, vectype);\n \n   switch (alignment_support_scheme)\n     {\n@@ -1219,7 +1219,7 @@ vect_get_load_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   dr_alignment_support alignment_support_scheme\n-    = vect_supportable_dr_alignment (vinfo, dr_info, vectype, false);\n+    = vect_supportable_dr_alignment (vinfo, dr_info, vectype);\n \n   switch (alignment_support_scheme)\n     {\n@@ -1987,7 +1987,7 @@ get_negative_load_store_type (vec_info *vinfo,\n     }\n \n   alignment_support_scheme = vect_supportable_dr_alignment (vinfo, dr_info,\n-\t\t\t\t\t\t\t    vectype, false);\n+\t\t\t\t\t\t\t    vectype);\n   if (alignment_support_scheme != dr_aligned\n       && alignment_support_scheme != dr_unaligned_supported)\n     {\n@@ -2186,7 +2186,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t      && !masked_p\n \t      && (((alignment_support_scheme\n \t\t      = vect_supportable_dr_alignment (vinfo, first_dr_info,\n-\t\t\t\t\t\t       vectype, false)))\n+\t\t\t\t\t\t       vectype)))\n \t\t   == dr_aligned\n \t\t  || alignment_support_scheme == dr_unaligned_supported)\n \t      && known_eq (nunits, (group_size - gap) * 2)\n@@ -2297,7 +2297,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n     *alignment_support_scheme = dr_unaligned_supported;\n   else\n     *alignment_support_scheme\n-      = vect_supportable_dr_alignment (vinfo, first_dr_info, vectype, false);\n+      = vect_supportable_dr_alignment (vinfo, first_dr_info, vectype);\n \n   if (vls_type != VLS_LOAD && first_stmt_info == stmt_info)\n     {\n@@ -2438,7 +2438,7 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t  *alignment_support_scheme\n \t    = vect_supportable_dr_alignment (vinfo,\n \t\t\t\t\t     STMT_VINFO_DR_INFO (stmt_info),\n-\t\t\t\t\t     vectype, false);\n+\t\t\t\t\t     vectype);\n \t}\n     }\n "}, {"sha": "954a0e18d031ee91f4f7010cb9945bde4f81702d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caab0139761b04226fab14d87c4a4f981d942bbf/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caab0139761b04226fab14d87c4a4f981d942bbf/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=caab0139761b04226fab14d87c4a4f981d942bbf", "patch": "@@ -1978,7 +1978,7 @@ extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info, unsigned int = 0);\n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, poly_uint64);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n-\t\t\t\t   (vec_info *, dr_vec_info *, tree, bool);\n+\t\t\t\t   (vec_info *, dr_vec_info *, tree);\n extern tree vect_get_smallest_scalar_type (stmt_vec_info, tree);\n extern opt_result vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n extern bool vect_slp_analyze_instance_dependence (vec_info *, slp_instance);"}]}