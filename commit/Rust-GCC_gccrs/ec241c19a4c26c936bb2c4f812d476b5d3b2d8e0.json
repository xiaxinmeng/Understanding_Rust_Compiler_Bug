{"sha": "ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyNDFjMTlhNGMyNmM5MzZiYjJjNGY4MTJkNDc2YjVkM2IyZDhlMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-16T01:50:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-16T01:50:54Z"}, "message": "pa.h (EXTRA_CONSTRAINT, case 'S'): Do not accept CONSTANTP if TARGET_LONG_CALLS.\n\n\t* pa.h (EXTRA_CONSTRAINT, case 'S'): Do not accept CONSTANTP\n\tif TARGET_LONG_CALLS.\n\n\t* pa.h (EXTRA_CONSTRAINT): Merge strict and non-strict variants.\n\tDelete 'R' constraint.\n\nFrom-SVN: r3751", "tree": {"sha": "01c7977e12f58db2bb2393a8cdd9d0e78b52a80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c7977e12f58db2bb2393a8cdd9d0e78b52a80f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0/comments", "author": null, "committer": null, "parents": [{"sha": "b2fb324cbfb09352c24371289122455a62830138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2fb324cbfb09352c24371289122455a62830138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2fb324cbfb09352c24371289122455a62830138"}], "stats": {"total": 53, "additions": 24, "deletions": 29}, "files": [{"sha": "e50ce45e34c00a115341b889f2e0064955ae813b", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ec241c19a4c26c936bb2c4f812d476b5d3b2d8e0", "patch": "@@ -1050,12 +1050,35 @@ extern union tree_node *current_function_decl;\n    these things in insns and then not re-recognize the insns, causing\n    constrain_operands to fail.\n \n-   `R' handles the LO_SUM which can be an address for `Q'.\n+   `R' is unused.\n \n    `S' handles constraints for calls.\n \n    `T' is for fp load and store addresses.*/\n \n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ?\t\t\t\t\t\t\\\n+   ((GET_CODE (OP) == MEM\t\t\t\t\\\n+     && memory_address_p (GET_MODE (OP), XEXP (OP, 0))\t\\\n+     && ! symbolic_memory_operand (OP, VOIDmode))\t\\\n+    || (GET_CODE (OP) == REG\t\t\t\t\\\n+\t&& REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n+\t&& reg_renumber[REGNO (OP)] < 0))\t\t\\\n+   : ((C) == 'S' ? \t\t\t\t\t\\\n+      ((CONSTANT_P (OP) && ! TARGET_LONG_CALLS)\t\t\\\n+        || (reload_in_progress \t\t\t\t\\\n+\t    ? strict_memory_address_p (Pmode, OP)\t\\\n+\t    : memory_address_p (Pmode, OP))\t\t\\\n+       || (reload_in_progress\t\t\t\t\\\n+\t   && GET_CODE (OP) == REG\t\t\t\\\n+\t   && reg_renumber[REGNO (OP)] > 0))\t\t\\\n+   : ((C) == 'T' ? \t\t\t\t\t\\\n+      ((GET_CODE (OP) == MEM\t\t\t\t\\\n+\t&& short_memory_operand (OP, VOIDmode))\t\t\\\n+       || (GET_CODE (OP) == REG\t\t\t\t\\\n+\t   && REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\\\n+\t   && reg_renumber[REGNO (OP)] < 0)) : 0)))\n+\n #ifndef REG_OK_STRICT\n \n /* Nonzero if X is a hard reg that can be used as an index\n@@ -1067,41 +1090,13 @@ extern union tree_node *current_function_decl;\n #define REG_OK_FOR_BASE_P(X) \\\n (REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ?\t\t\t\t\t\t\\\n-   ((GET_CODE (OP) == MEM\t\t\t\t\\\n-     && memory_address_p (GET_MODE (OP), XEXP (OP, 0))\t\\\n-     && ! symbolic_memory_operand (OP, VOIDmode)))\t\\\n-   : ((C) == 'R' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n-       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n-      : ((C) == 'S'\t\t\t\t\t\\\n-\t ? CONSTANT_P (OP) || memory_address_p (Pmode, OP)\\\n-\t : ((C) == 'T' ? short_memory_operand (OP, VOIDmode) : 0))))\\\n-\n-\n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  (((C) == 'Q' || (C) == 'T') ?\t\t\t\t\\\n-   (GET_CODE (OP) == REG ?\t\t\t\t\\\n-    (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n-     && reg_renumber[REGNO (OP)] < 0)\t\t\t\\\n-    : GET_CODE (OP) == MEM)\t\t\t\t\\\n-   : ((C) == 'R' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n-       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n-      : (CONSTANT_P (OP)\t\t\t\t\\\n-\t    || (GET_CODE (OP) == REG && reg_renumber[REGNO (OP)] > 0)\\\n-\t    || strict_memory_address_p (Pmode, OP))))\n-\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression"}]}