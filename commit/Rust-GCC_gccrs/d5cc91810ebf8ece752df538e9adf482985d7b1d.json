{"sha": "d5cc91810ebf8ece752df538e9adf482985d7b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVjYzkxODEwZWJmOGVjZTc1MmRmNTM4ZTlhZGY0ODI5ODVkN2IxZA==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2011-06-16T13:45:47Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2011-06-16T13:45:47Z"}, "message": "re PR middle-end/46500 (target.h includes tm.h)\n\n\tPR middle-end/46500\ngcc:\n\t* doc/tm.texi.in: Update Copyright date.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_setup_incoming_varargs): Replace\n\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n\t(default_pretend_outgoing_varargs_named): Likewise.\n\t(hook_pass_by_reference_must_pass_in_stack): Likewise.\n\t(hook_callee_copies_named): Likewise.\n\t(default_function_arg_advance): Likewise.\n\t(default_function_arg): Likewise.\n\t(default_function_incoming_arg): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_false): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_true): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true): Likewise.\n\t(hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Likewise.\n\t* targhooks.h (default_setup_incoming_varargs): Likewise.\n\t(default_pretend_outgoing_varargs_named): Likewise.\n\t(hook_pass_by_reference_must_pass_in_stack): Likewise.\n\t(hook_callee_copies_named): Likewise.\n\t(default_function_arg_advance): Likewise.\n\t(default_function_arg): Likewise.\n\t(default_function_incoming_arg): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_false): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_true): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false): Likewise.\n\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true): Likewise.\n\t(hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Likewise.\n\t* target.def (pass_by_reference): Likewise.\n\t(setup_incoming_varargs, strict_argument_naming): Likewise.\n\t(pretend_outgoing_varargs_named, callee_copies): Likewise.\n\t(arg_partial_bytes, function_arg_advance, function_arg): Likewise.\n\t(function_incoming_arg): Likewise.\n\t* target.h: Don't include \"tm.h\" .\n\t(cumulative_args_t): New typedef.\n\t[GCC_TM_H] (get_cumulative_args): New static inline function.\n\t[GCC_TM_H] (pack_cumulative_args): Likewise.\n\t* config/alpha/alpha.c (alpha_function_arg): Replace CUMULATIVE_ARGS*\n\targument type with cumulative_args_t.\n\t(alpha_function_arg_advance, alpha_arg_partial_bytes): Likewise.\n\t(alpha_pass_by_reference, alpha_setup_incoming_varargs): Likewise.\n\t* config/frv/frv.c (frv_setup_incoming_varargs): Likewise.\n\t(frv_arg_partial_bytes, frv_function_arg): Likewise.\n\t(frv_function_incoming_arg, frv_function_arg_advance): Likewise.\n\t(frv_function_arg_1): Likewise.\n\t* config/s390/s390.c (s390_pass_by_reference): Likewise.\n\t(s390_function_arg_advance, s390_function_arg): Likewise.\n\t* config/m32c/m32c.c (m32c_function_arg): Likewise.\n\t(m32c_pass_by_reference, m32c_function_arg_advance): Likewise.\n\t(m32c_strict_argument_naming): Likewise.\n\t* config/spu/spu.c (spu_pass_by_reference, spu_function_arg): Likewise.\n\t(spu_function_arg_advance): Likewise.\n\t(spu_setup_incoming_varargs): Likewise.  Make static.\n\t* config/spu/spu-protos.h (spu_setup_incoming_varargs):\n\tRemove prototype.\n\t* config/sparc/sparc.c (sparc_strict_argument_naming): Replace\n\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n\t(sparc_pass_by_reference, sparc_function_arg_advance): Likewise.\n\t(sparc_function_arg, sparc_function_incoming_arg): Likewise.\n\t(sparc_arg_partial_bytes, sparc_function_arg_1): Likewise.\n\t* config/mep/mep.c (mep_setup_incoming_varargs): Likewise.\n\t(mep_pass_by_reference, mep_function_arg): Likewise.\n\t(mep_function_arg_advance): Likewise.\n\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Likewise.\n\t(m32r_pass_by_reference, m32r_arg_partial_bytes): Likewise.\n\t(m32r_function_arg, m32r_function_arg_advance): Likewise.\n\t* config/rx/rx.c (rx_function_arg, rx_function_arg_advance): Likewise.\n\t* config/i386/i386.c (ix86_function_arg_advance): Likewise.\n\t(ix86_function_arg, ix86_pass_by_reference): Likewise.\n\t(ix86_setup_incoming_varargs): Likewise.\n\t* config/sh/sh.c (sh_setup_incoming_varargs): Likewise.\n\t(sh_strict_argument_naming): Likewise.\n\t(sh_pretend_outgoing_varargs_named, sh_pass_by_reference): Likewise.\n\t(sh_callee_copies, sh_arg_partial_bytes): Likewise.\n\t(sh_function_arg_advance, sh_function_arg): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_function_arg): Likewise.\n\t(pdp11_function_arg_advance): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_function_arg_advance):\n\tLikewise.\n\t(microblaze_function_arg, function_arg_partial_bytes): Likewise.\n\t* config/avr/avr.c (avr_function_arg): Likewise.\n\t(avr_function_arg_advance): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_function_arg_advance): Likewise.\n\t(xtensa_function_arg, xtensa_function_incoming_arg): Likewise.\n\t(xtensa_function_arg_1): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_function_arg_advance): Likewise.\n\t(xstormy16_function_arg): Likewise.\n\t* config/fr30/fr30.c (fr30_setup_incoming_varargs): Likewise.\n\t(fr30_arg_partial_bytes, fr30_function_arg): Likewise.\n\t(fr30_function_arg_advance): Likewise.\n\t* config/lm32/lm32.c (lm32_setup_incoming_varargs): Likewise.\n\t(lm32_function_arg, lm32_function_arg_advance): Likewise.\n\t* config/moxie/moxie.c (moxie_setup_incoming_varargs): Likewise.\n\t(moxie_function_arg, moxie_function_arg_advance): Likewise.\n\t(moxie_pass_by_reference, moxie_arg_partial_bytes): Likewise.\n\t* config/cris/cris.c (cris_setup_incoming_varargs): Likewise.\n\t(cris_pass_by_reference, cris_arg_partial_bytes): Likewise.\n\t(cris_function_arg, cris_function_incoming_arg): Likewise.\n\t(cris_function_arg_advance, cris_function_arg_1): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_setup_incoming_varargs): Likewise.\n\t(iq2000_pass_by_reference, iq2000_arg_partial_bytes): Likewise.\n\t(iq2000_function_arg, iq2000_function_arg_advance): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_pass_by_reference): Likewise.\n\t(mn10300_function_arg, mn10300_function_arg_advance): Likewise.\n\t(mn10300_arg_partial_bytes): Likewise.\n\t* config/ia64/ia64.c (ia64_setup_incoming_varargs): Likewise.\n\t(ia64_arg_partial_bytes, ia64_function_arg): Likewise.\n\t(ia64_function_incoming_arg, ia64_function_arg_advance): Likewise.\n\t(ia64_function_arg_1): Likewise.\n\t* config/m68k/m68k.c (m68k_function_arg_advance): Likewise.\n\t(m68k_function_arg): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_function_arg_advance): Likewise.\n\t(rs6000_function_arg, setup_incoming_varargs): Likewise.\n\t(rs6000_pass_by_reference, rs6000_arg_partial_bytes): Likewise.\n\t* config/picochip/picochip.c (picochip_arg_partial_bytes): Likewise.\n\t(picochip_function_arg, picochip_incoming_function_arg): Likewise.\n\t(picochip_arg_advance): Likewise.\n\t* config/mcore/mcore.c (mcore_setup_incoming_varargs): Likewise.\n\t(mcore_arg_partial_bytes, mcore_function_arg): Likewise.\n\t(mcore_function_arg_advance): Likewise.\n\t* config/score/score.c (score_pass_by_reference): Likewise.\n\t(score_function_arg_advance): Likewise.\n\t(score_arg_partial_bytes): Likewise.  Make static.\n\t* config/score/score-protos.h (score_arg_partial_bytes): Don't declare.\n\t* config/arm/arm.c (arm_arg_partial_bytes): Replace\n\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n\t(arm_function_arg, arm_function_arg_advance): Likewise.\n\t(arm_setup_incoming_varargs, arm_pass_by_reference): Likewise.\n\t* config/pa/pa.c (pa_pass_by_reference): Likewise.\n\t(pa_arg_partial_bytes, pa_function_arg_advance): Likewise.\n\t(pa_function_arg): Likewise.\n\t* config/mips/mips.c (mips_strict_argument_naming): Likewise.\n\t(mips_function_arg, mips_function_arg_advance): Likewise.\n\t(mips_arg_partial_bytes, mips_pass_by_reference): Likewise.\n\t(mips_callee_copies, mips_setup_incoming_varargs): Likewise.\n\t* config/vax/vax.c (vax_function_arg): Likewise.\n\t(vax_function_arg_advance): Likewise.\n\t* config/h8300/h8300.c (h8300_function_arg): Likewise.\n\t(h8300_function_arg_advance): Likewise.\n\t* config/v850/v850.c (v850_pass_by_reference): Likewise.\n\t(v850_strict_argument_naming, v850_function_arg): Likewise.\n\t(v850_arg_partial_bytes, v850_function_arg_advance): Likewise.\n\t(v850_setup_incoming_varargs): Likewise.\n\t* config/mmix/mmix.c (mmix_setup_incoming_varargs): Likewise.\n\t(mmix_function_arg_advance, mmix_function_incoming_arg): Likewise.\n\t(mmix_function_arg, mmix_pass_by_reference): Likewise.\n\t(mmix_function_arg_1): Replace const CUMULATIVE_ARGS* argument type\n\twith const void *.\n\t* config/bfin/bfin.c (setup_incoming_varargs): Replace\n\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n\t(bfin_function_arg_advance, bfin_function_arg): Likewise.\n\t(bfin_arg_partial_bytes, bfin_pass_by_reference): Likewise.\n\t* calls.c (emit_call_1): Change type of args_so_far to\n\tcumulative_args_t.  Changed all callers.\n\t(initialize_argument_information): Likewise.\n\t(expand_call, emit_library_call_value_1): Use pack_cumulative_args.\n\t* dse.c (get_call_args): Likewise.\n\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n\t* function.c (pass_by_reference, reference_callee_copied): Likewise.\n\t(struct assign_parm_data_all): Rename args_so_far to args_so_far_v.\n\tNew member args_so_far_v.  Changed all users.\n\t* var-tracking.c (prepare_call_arguments): Use pack_cumulative_args.\n\t* config/iq2000/iq2000.c (iq2000_expand_prologue): Likewise.\n\t* config/mips/mips.c (mips_output_args_xfer): Likewise.\n\t* config/s390/s390.c (s390_call_saved_register_used): Likewise.\n\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_expand_prologue): Likewise.\n\t* config/m32r/m32r.c (m32r_return_in_memory): Adjust for changed\n\tm32r_pass_by_reference.\ngcc/ada:\n\t* gcc-interface/decl.c (gnat_to_gnu_param): Use pack_cumulative_args.\n\nFrom-SVN: r175103", "tree": {"sha": "6743d4344d7e67eee9f7e260f9fb67f3449e8691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6743d4344d7e67eee9f7e260f9fb67f3449e8691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5cc91810ebf8ece752df538e9adf482985d7b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5cc91810ebf8ece752df538e9adf482985d7b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5cc91810ebf8ece752df538e9adf482985d7b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5cc91810ebf8ece752df538e9adf482985d7b1d/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5131223306f3957935567b1ed652b1b0360918ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5131223306f3957935567b1ed652b1b0360918ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5131223306f3957935567b1ed652b1b0360918ad"}], "stats": {"total": 1254, "additions": 824, "deletions": 430}, "files": [{"sha": "273ae1a2c48ca7249d8dc06fb9448346f1036151", "filename": "gcc/ChangeLog", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1,3 +1,175 @@\n+2010-06-16  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR middle-end/46500\n+\t* doc/tm.texi.in: Update Copyright date.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_setup_incoming_varargs): Replace\n+\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n+\t(default_pretend_outgoing_varargs_named): Likewise.\n+\t(hook_pass_by_reference_must_pass_in_stack): Likewise.\n+\t(hook_callee_copies_named): Likewise.\n+\t(default_function_arg_advance): Likewise.\n+\t(default_function_arg): Likewise.\n+\t(default_function_incoming_arg): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_false): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_true): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true): Likewise.\n+\t(hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Likewise.\n+\t* targhooks.h (default_setup_incoming_varargs): Likewise.\n+\t(default_pretend_outgoing_varargs_named): Likewise.\n+\t(hook_pass_by_reference_must_pass_in_stack): Likewise.\n+\t(hook_callee_copies_named): Likewise.\n+\t(default_function_arg_advance): Likewise.\n+\t(default_function_arg): Likewise.\n+\t(default_function_incoming_arg): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_false): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_true): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false): Likewise.\n+\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true): Likewise.\n+\t(hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Likewise.\n+\t* target.def (pass_by_reference): Likewise.\n+\t(setup_incoming_varargs, strict_argument_naming): Likewise.\n+\t(pretend_outgoing_varargs_named, callee_copies): Likewise.\n+\t(arg_partial_bytes, function_arg_advance, function_arg): Likewise.\n+\t(function_incoming_arg): Likewise.\n+\t* target.h: Don't include \"tm.h\" .\n+\t(cumulative_args_t): New typedef.\n+\t[GCC_TM_H] (get_cumulative_args): New static inline function.\n+\t[GCC_TM_H] (pack_cumulative_args): Likewise.\n+\t* config/alpha/alpha.c (alpha_function_arg): Replace CUMULATIVE_ARGS*\n+\targument type with cumulative_args_t.\n+\t(alpha_function_arg_advance, alpha_arg_partial_bytes): Likewise.\n+\t(alpha_pass_by_reference, alpha_setup_incoming_varargs): Likewise.\n+\t* config/frv/frv.c (frv_setup_incoming_varargs): Likewise.\n+\t(frv_arg_partial_bytes, frv_function_arg): Likewise.\n+\t(frv_function_incoming_arg, frv_function_arg_advance): Likewise.\n+\t(frv_function_arg_1): Likewise.\n+\t* config/s390/s390.c (s390_pass_by_reference): Likewise.\n+\t(s390_function_arg_advance, s390_function_arg): Likewise.\n+\t* config/m32c/m32c.c (m32c_function_arg): Likewise.\n+\t(m32c_pass_by_reference, m32c_function_arg_advance): Likewise.\n+\t(m32c_strict_argument_naming): Likewise.\n+\t* config/spu/spu.c (spu_pass_by_reference, spu_function_arg): Likewise.\n+\t(spu_function_arg_advance): Likewise.\n+\t(spu_setup_incoming_varargs): Likewise.  Make static.\n+\t* config/spu/spu-protos.h (spu_setup_incoming_varargs):\n+\tRemove prototype.\n+\t* config/sparc/sparc.c (sparc_strict_argument_naming): Replace\n+\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n+\t(sparc_pass_by_reference, sparc_function_arg_advance): Likewise.\n+\t(sparc_function_arg, sparc_function_incoming_arg): Likewise.\n+\t(sparc_arg_partial_bytes, sparc_function_arg_1): Likewise.\n+\t* config/mep/mep.c (mep_setup_incoming_varargs): Likewise.\n+\t(mep_pass_by_reference, mep_function_arg): Likewise.\n+\t(mep_function_arg_advance): Likewise.\n+\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Likewise.\n+\t(m32r_pass_by_reference, m32r_arg_partial_bytes): Likewise.\n+\t(m32r_function_arg, m32r_function_arg_advance): Likewise.\n+\t* config/rx/rx.c (rx_function_arg, rx_function_arg_advance): Likewise.\n+\t* config/i386/i386.c (ix86_function_arg_advance): Likewise.\n+\t(ix86_function_arg, ix86_pass_by_reference): Likewise.\n+\t(ix86_setup_incoming_varargs): Likewise.\n+\t* config/sh/sh.c (sh_setup_incoming_varargs): Likewise.\n+\t(sh_strict_argument_naming): Likewise.\n+\t(sh_pretend_outgoing_varargs_named, sh_pass_by_reference): Likewise.\n+\t(sh_callee_copies, sh_arg_partial_bytes): Likewise.\n+\t(sh_function_arg_advance, sh_function_arg): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_function_arg): Likewise.\n+\t(pdp11_function_arg_advance): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_function_arg_advance):\n+\tLikewise.\n+\t(microblaze_function_arg, function_arg_partial_bytes): Likewise.\n+\t* config/avr/avr.c (avr_function_arg): Likewise.\n+\t(avr_function_arg_advance): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_function_arg_advance): Likewise.\n+\t(xtensa_function_arg, xtensa_function_incoming_arg): Likewise.\n+\t(xtensa_function_arg_1): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_function_arg_advance): Likewise.\n+\t(xstormy16_function_arg): Likewise.\n+\t* config/fr30/fr30.c (fr30_setup_incoming_varargs): Likewise.\n+\t(fr30_arg_partial_bytes, fr30_function_arg): Likewise.\n+\t(fr30_function_arg_advance): Likewise.\n+\t* config/lm32/lm32.c (lm32_setup_incoming_varargs): Likewise.\n+\t(lm32_function_arg, lm32_function_arg_advance): Likewise.\n+\t* config/moxie/moxie.c (moxie_setup_incoming_varargs): Likewise.\n+\t(moxie_function_arg, moxie_function_arg_advance): Likewise.\n+\t(moxie_pass_by_reference, moxie_arg_partial_bytes): Likewise.\n+\t* config/cris/cris.c (cris_setup_incoming_varargs): Likewise.\n+\t(cris_pass_by_reference, cris_arg_partial_bytes): Likewise.\n+\t(cris_function_arg, cris_function_incoming_arg): Likewise.\n+\t(cris_function_arg_advance, cris_function_arg_1): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_setup_incoming_varargs): Likewise.\n+\t(iq2000_pass_by_reference, iq2000_arg_partial_bytes): Likewise.\n+\t(iq2000_function_arg, iq2000_function_arg_advance): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_pass_by_reference): Likewise.\n+\t(mn10300_function_arg, mn10300_function_arg_advance): Likewise.\n+\t(mn10300_arg_partial_bytes): Likewise.\n+\t* config/ia64/ia64.c (ia64_setup_incoming_varargs): Likewise.\n+\t(ia64_arg_partial_bytes, ia64_function_arg): Likewise.\n+\t(ia64_function_incoming_arg, ia64_function_arg_advance): Likewise.\n+\t(ia64_function_arg_1): Likewise.\n+\t* config/m68k/m68k.c (m68k_function_arg_advance): Likewise.\n+\t(m68k_function_arg): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_function_arg_advance): Likewise.\n+\t(rs6000_function_arg, setup_incoming_varargs): Likewise.\n+\t(rs6000_pass_by_reference, rs6000_arg_partial_bytes): Likewise.\n+\t* config/picochip/picochip.c (picochip_arg_partial_bytes): Likewise.\n+\t(picochip_function_arg, picochip_incoming_function_arg): Likewise.\n+\t(picochip_arg_advance): Likewise.\n+\t* config/mcore/mcore.c (mcore_setup_incoming_varargs): Likewise.\n+\t(mcore_arg_partial_bytes, mcore_function_arg): Likewise.\n+\t(mcore_function_arg_advance): Likewise.\n+\t* config/score/score.c (score_pass_by_reference): Likewise.\n+\t(score_function_arg_advance): Likewise.\n+\t(score_arg_partial_bytes): Likewise.  Make static.\n+\t* config/score/score-protos.h (score_arg_partial_bytes): Don't declare.\n+\t* config/arm/arm.c (arm_arg_partial_bytes): Replace\n+\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n+\t(arm_function_arg, arm_function_arg_advance): Likewise.\n+\t(arm_setup_incoming_varargs, arm_pass_by_reference): Likewise.\n+\t* config/pa/pa.c (pa_pass_by_reference): Likewise.\n+\t(pa_arg_partial_bytes, pa_function_arg_advance): Likewise.\n+\t(pa_function_arg): Likewise.\n+\t* config/mips/mips.c (mips_strict_argument_naming): Likewise.\n+\t(mips_function_arg, mips_function_arg_advance): Likewise.\n+\t(mips_arg_partial_bytes, mips_pass_by_reference): Likewise.\n+\t(mips_callee_copies, mips_setup_incoming_varargs): Likewise.\n+\t* config/vax/vax.c (vax_function_arg): Likewise.\n+\t(vax_function_arg_advance): Likewise.\n+\t* config/h8300/h8300.c (h8300_function_arg): Likewise.\n+\t(h8300_function_arg_advance): Likewise.\n+\t* config/v850/v850.c (v850_pass_by_reference): Likewise.\n+\t(v850_strict_argument_naming, v850_function_arg): Likewise.\n+\t(v850_arg_partial_bytes, v850_function_arg_advance): Likewise.\n+\t(v850_setup_incoming_varargs): Likewise.\n+\t* config/mmix/mmix.c (mmix_setup_incoming_varargs): Likewise.\n+\t(mmix_function_arg_advance, mmix_function_incoming_arg): Likewise.\n+\t(mmix_function_arg, mmix_pass_by_reference): Likewise.\n+\t(mmix_function_arg_1): Replace const CUMULATIVE_ARGS* argument type\n+\twith const void *.\n+\t* config/bfin/bfin.c (setup_incoming_varargs): Replace\n+\tCUMULATIVE_ARGS* argument type with cumulative_args_t.\n+\t(bfin_function_arg_advance, bfin_function_arg): Likewise.\n+\t(bfin_arg_partial_bytes, bfin_pass_by_reference): Likewise.\n+\t* calls.c (emit_call_1): Change type of args_so_far to\n+\tcumulative_args_t.  Changed all callers.\n+\t(initialize_argument_information): Likewise.\n+\t(expand_call, emit_library_call_value_1): Use pack_cumulative_args.\n+\t* dse.c (get_call_args): Likewise.\n+\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n+\t* function.c (pass_by_reference, reference_callee_copied): Likewise.\n+\t(struct assign_parm_data_all): Rename args_so_far to args_so_far_v.\n+\tNew member args_so_far_v.  Changed all users.\n+\t* var-tracking.c (prepare_call_arguments): Use pack_cumulative_args.\n+\t* config/iq2000/iq2000.c (iq2000_expand_prologue): Likewise.\n+\t* config/mips/mips.c (mips_output_args_xfer): Likewise.\n+\t* config/s390/s390.c (s390_call_saved_register_used): Likewise.\n+\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_expand_prologue): Likewise.\n+\t* config/m32r/m32r.c (m32r_return_in_memory): Adjust for changed\n+\tm32r_pass_by_reference.\n+\n 2011-06-16  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* tree-vectorizer.h (vect_recog_func_ptr): Change the first"}, {"sha": "b4d5a67e6215ed2e8a5e57f2af1a7387cb1c54dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1,3 +1,8 @@\n+2010-06-16  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR middle-end/46500\n+\t* gcc-interface/decl.c (gnat_to_gnu_param): Use pack_cumulative_args.\n+\n 2011-06-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc-interface/Make-lang.in (gnatbind$(exeext)): Use ggc-none.o."}, {"sha": "3803c2d5ceeea3f3c1accc934cf536189868ee25", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -5452,7 +5452,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n \t passed by reference.  Pass them by explicit reference, this will\n \t generate more debuggable code at -O0.  */\n       if (TYPE_IS_FAT_POINTER_P (gnu_param_type)\n-\t  && targetm.calls.pass_by_reference (NULL,\n+\t  && targetm.calls.pass_by_reference (pack_cumulative_args (NULL),\n \t\t\t\t\t      TYPE_MODE (gnu_param_type),\n \t\t\t\t\t      gnu_param_type,\n \t\t\t\t\t      true))"}, {"sha": "3d9a03f3632a71cf2fea146cee08481d0195c561", "filename": "gcc/calls.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -125,7 +125,7 @@ static int stack_arg_under_construction;\n \n static void emit_call_1 (rtx, tree, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t HOST_WIDE_INT, rtx, rtx, int, rtx, int,\n-\t\t\t CUMULATIVE_ARGS *);\n+\t\t\t cumulative_args_t);\n static void precompute_register_parameters (int, struct arg_data *, int *);\n static int store_one_arg (struct arg_data *, rtx, int, int, int);\n static void store_unaligned_arguments_into_pseudos (struct arg_data *, int);\n@@ -136,7 +136,7 @@ static int compute_argument_block_size (int, struct args_size *, tree, tree, int\n static void initialize_argument_information (int, struct arg_data *,\n \t\t\t\t\t     struct args_size *, int,\n \t\t\t\t\t     tree, tree,\n-\t\t\t\t\t     tree, tree, CUMULATIVE_ARGS *, int,\n+\t\t\t\t\t     tree, tree, cumulative_args_t, int,\n \t\t\t\t\t     rtx *, int *, int *, int *,\n \t\t\t\t\t     bool *, bool);\n static void compute_argument_addresses (struct arg_data *, rtx, int);\n@@ -252,7 +252,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t     HOST_WIDE_INT struct_value_size ATTRIBUTE_UNUSED,\n \t     rtx next_arg_reg ATTRIBUTE_UNUSED, rtx valreg,\n \t     int old_inhibit_defer_pop, rtx call_fusage, int ecf_flags,\n-\t     CUMULATIVE_ARGS *args_so_far ATTRIBUTE_UNUSED)\n+\t     cumulative_args_t args_so_far ATTRIBUTE_UNUSED)\n {\n   rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n   rtx call_insn, call, funmem;\n@@ -261,7 +261,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n     = targetm.calls.return_pops_args (fndecl, funtype, stack_size);\n \n #ifdef CALL_POPS_ARGS\n-  n_popped += CALL_POPS_ARGS (* args_so_far);\n+  n_popped += CALL_POPS_ARGS (*get_cumulative_args (args_so_far));\n #endif\n \n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n@@ -967,12 +967,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t int n_named_args ATTRIBUTE_UNUSED,\n \t\t\t\t tree exp, tree struct_value_addr_value,\n \t\t\t\t tree fndecl, tree fntype,\n-\t\t\t\t CUMULATIVE_ARGS *args_so_far,\n+\t\t\t\t cumulative_args_t args_so_far,\n \t\t\t\t int reg_parm_stack_space,\n \t\t\t\t rtx *old_stack_level, int *old_pending_adj,\n \t\t\t\t int *must_preallocate, int *ecf_flags,\n \t\t\t\t bool *may_tailcall, bool call_from_thunk_p)\n {\n+  CUMULATIVE_ARGS *args_so_far_pnt = get_cumulative_args (args_so_far);\n   location_t loc = EXPR_LOCATION (exp);\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n@@ -1064,14 +1065,14 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t with those made by function.c.  */\n \n       /* See if this argument should be passed by invisible reference.  */\n-      if (pass_by_reference (args_so_far, TYPE_MODE (type),\n+      if (pass_by_reference (args_so_far_pnt, TYPE_MODE (type),\n \t\t\t     type, argpos < n_named_args))\n \t{\n \t  bool callee_copies;\n \t  tree base;\n \n \t  callee_copies\n-\t    = reference_callee_copied (args_so_far, TYPE_MODE (type),\n+\t    = reference_callee_copied (args_so_far_pnt, TYPE_MODE (type),\n \t\t\t\t       type, argpos < n_named_args);\n \n \t  /* If we're compiling a thunk, pass through invisible references\n@@ -2005,7 +2006,8 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Size of arguments before any adjustments (such as rounding).  */\n   int unadjusted_args_size;\n   /* Data on reg parms scanned so far.  */\n-  CUMULATIVE_ARGS args_so_far;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n   /* Nonzero if a reg parm has been scanned.  */\n   int reg_parm_seen;\n   /* Nonzero if this is an indirect function call.  */\n@@ -2243,7 +2245,8 @@ expand_call (tree exp, rtx target, int ignore)\n      calling convention than normal calls.  The fourth argument in\n      INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call\n      or not.  */\n-  INIT_CUMULATIVE_ARGS (args_so_far, funtype, NULL_RTX, fndecl, n_named_args);\n+  INIT_CUMULATIVE_ARGS (args_so_far_v, funtype, NULL_RTX, fndecl, n_named_args);\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n \n   /* Now possibly adjust the number of named args.\n      Normally, don't include the last named arg if anonymous args follow.\n@@ -2264,10 +2267,10 @@ expand_call (tree exp, rtx target, int ignore)\n      registers, so we must force them into memory.  */\n \n   if (type_arg_types != 0\n-      && targetm.calls.strict_argument_naming (&args_so_far))\n+      && targetm.calls.strict_argument_naming (args_so_far))\n     ;\n   else if (type_arg_types != 0\n-\t   && ! targetm.calls.pretend_outgoing_varargs_named (&args_so_far))\n+\t   && ! targetm.calls.pretend_outgoing_varargs_named (args_so_far))\n     /* Don't include the last named arg.  */\n     --n_named_args;\n   else\n@@ -2283,7 +2286,7 @@ expand_call (tree exp, rtx target, int ignore)\n   initialize_argument_information (num_actuals, args, &args_size,\n \t\t\t\t   n_named_args, exp,\n \t\t\t\t   structure_value_addr_value, fndecl, fntype,\n-\t\t\t\t   &args_so_far, reg_parm_stack_space,\n+\t\t\t\t   args_so_far, reg_parm_stack_space,\n \t\t\t\t   &old_stack_level, &old_pending_adj,\n \t\t\t\t   &must_preallocate, &flags,\n \t\t\t\t   &try_tail_call, CALL_FROM_THUNK_P (exp));\n@@ -2873,12 +2876,12 @@ expand_call (tree exp, rtx target, int ignore)\n       /* Set up next argument register.  For sibling calls on machines\n \t with register windows this should be the incoming register.  */\n       if (pass == 0)\n-\tnext_arg_reg = targetm.calls.function_incoming_arg (&args_so_far,\n+\tnext_arg_reg = targetm.calls.function_incoming_arg (args_so_far,\n \t\t\t\t\t\t\t    VOIDmode,\n \t\t\t\t\t\t\t    void_type_node,\n \t\t\t\t\t\t\t    true);\n       else\n-\tnext_arg_reg = targetm.calls.function_arg (&args_so_far,\n+\tnext_arg_reg = targetm.calls.function_arg (args_so_far,\n \t\t\t\t\t\t   VOIDmode, void_type_node,\n \t\t\t\t\t\t   true);\n \n@@ -2893,7 +2896,7 @@ expand_call (tree exp, rtx target, int ignore)\n       emit_call_1 (funexp, exp, fndecl, funtype, unadjusted_args_size,\n \t\t   adjusted_args_size.constant, struct_value_size,\n \t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n-\t\t   flags, & args_so_far);\n+\t\t   flags, args_so_far);\n \n       /* If the call setup or the call itself overlaps with anything\n \t of the argument setup we probably clobbered our call address.\n@@ -3324,7 +3327,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   int inc;\n   int count;\n   rtx argblock = 0;\n-  CUMULATIVE_ARGS args_so_far;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n   struct arg\n   {\n     rtx value;\n@@ -3436,10 +3440,11 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   memset (argvec, 0, (nargs + 1) * sizeof (struct arg));\n \n #ifdef INIT_CUMULATIVE_LIBCALL_ARGS\n-  INIT_CUMULATIVE_LIBCALL_ARGS (args_so_far, outmode, fun);\n+  INIT_CUMULATIVE_LIBCALL_ARGS (args_so_far_v, outmode, fun);\n #else\n-  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0, nargs);\n+  INIT_CUMULATIVE_ARGS (args_so_far_v, NULL_TREE, fun, 0, nargs);\n #endif\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n \n   args_size.constant = 0;\n   args_size.var = 0;\n@@ -3466,9 +3471,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].mode = Pmode;\n       argvec[count].partial = 0;\n \n-      argvec[count].reg = targetm.calls.function_arg (&args_so_far,\n+      argvec[count].reg = targetm.calls.function_arg (args_so_far,\n \t\t\t\t\t\t      Pmode, NULL_TREE, true);\n-      gcc_assert (targetm.calls.arg_partial_bytes (&args_so_far, Pmode,\n+      gcc_assert (targetm.calls.arg_partial_bytes (args_so_far, Pmode,\n \t\t\t\t\t\t   NULL_TREE, 1) == 0);\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n@@ -3483,7 +3488,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].locate.size.constant;\n \n-      targetm.calls.function_arg_advance (&args_so_far, Pmode, (tree) 0, true);\n+      targetm.calls.function_arg_advance (args_so_far, Pmode, (tree) 0, true);\n \n       count++;\n     }\n@@ -3504,11 +3509,11 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  && !(CONSTANT_P (val) && targetm.legitimate_constant_p (mode, val)))\n \tval = force_operand (val, NULL_RTX);\n \n-      if (pass_by_reference (&args_so_far, mode, NULL_TREE, 1))\n+      if (pass_by_reference (&args_so_far_v, mode, NULL_TREE, 1))\n \t{\n \t  rtx slot;\n \t  int must_copy\n-\t    = !reference_callee_copied (&args_so_far, mode, NULL_TREE, 1);\n+\t    = !reference_callee_copied (&args_so_far_v, mode, NULL_TREE, 1);\n \n \t  /* If this was a CONST function, it is now PURE since it now\n \t     reads memory.  */\n@@ -3543,11 +3548,11 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       mode = promote_function_mode (NULL_TREE, mode, &unsigned_p, NULL_TREE, 0);\n       argvec[count].mode = mode;\n       argvec[count].value = convert_modes (mode, GET_MODE (val), val, unsigned_p);\n-      argvec[count].reg = targetm.calls.function_arg (&args_so_far, mode,\n+      argvec[count].reg = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t\t      NULL_TREE, true);\n \n       argvec[count].partial\n-\t= targetm.calls.arg_partial_bytes (&args_so_far, mode, NULL_TREE, 1);\n+\t= targetm.calls.arg_partial_bytes (args_so_far, mode, NULL_TREE, 1);\n \n       locate_and_pad_parm (mode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -3564,7 +3569,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].locate.size.constant;\n \n-      targetm.calls.function_arg_advance (&args_so_far, mode, (tree) 0, true);\n+      targetm.calls.function_arg_advance (args_so_far, mode, (tree) 0, true);\n     }\n \n   /* If this machine requires an external definition for library\n@@ -3876,10 +3881,10 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t       build_function_type (tfom, NULL_TREE),\n \t       original_args_size.constant, args_size.constant,\n \t       struct_value_size,\n-\t       targetm.calls.function_arg (&args_so_far,\n+\t       targetm.calls.function_arg (args_so_far,\n \t\t\t\t\t   VOIDmode, void_type_node, true),\n \t       valreg,\n-\t       old_inhibit_defer_pop + 1, call_fusage, flags, & args_so_far);\n+\t       old_inhibit_defer_pop + 1, call_fusage, flags, args_so_far);\n \n   /* For calls to `setjmp', etc., inform function.c:setjmp_warnings\n      that it should complain if nonvolatile values are live.  For"}, {"sha": "ffe9fc0bce403ca698ec729086bc367a4014cff4", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -5380,9 +5380,10 @@ alpha_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    and the rest are pushed.  */\n \n static rtx\n-alpha_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+alpha_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int basereg;\n   int num_args;\n \n@@ -5441,9 +5442,10 @@ alpha_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-alpha_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+alpha_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   bool onstack = targetm.calls.must_pass_in_stack (mode, type);\n   int increment = onstack ? 6 : ALPHA_ARG_SIZE (mode, type, named);\n \n@@ -5457,12 +5459,13 @@ alpha_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static int\n-alpha_arg_partial_bytes (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+alpha_arg_partial_bytes (cumulative_args_t cum_v,\n \t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t tree type ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n   int words = 0;\n+  CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED = get_cumulative_args (cum_v);\n \n #if TARGET_ABI_OPEN_VMS\n   if (cum->num_args < 6\n@@ -5537,7 +5540,7 @@ alpha_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n /* Return true if TYPE should be passed by invisible reference.  */\n \n static bool\n-alpha_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+alpha_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode mode,\n \t\t\t const_tree type ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n@@ -5875,13 +5878,14 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n    variable number of arguments.  */\n \n static void\n-alpha_setup_incoming_varargs (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+alpha_setup_incoming_varargs (cumulative_args_t pcum, enum machine_mode mode,\n \t\t\t      tree type, int *pretend_size, int no_rtl)\n {\n-  CUMULATIVE_ARGS cum = *pcum;\n+  CUMULATIVE_ARGS cum = *get_cumulative_args (pcum);\n \n   /* Skip the current argument.  */\n-  targetm.calls.function_arg_advance (&cum, mode, type, true);\n+  targetm.calls.function_arg_advance (pack_cumulative_args (&cum), mode, type,\n+\t\t\t\t      true);\n \n #if TARGET_ABI_OPEN_VMS\n   /* For VMS, we allocate space for all 6 arg registers plus a count."}, {"sha": "8297122735dc8f61cbf5709abdeacabb945b35d4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -166,11 +166,11 @@ static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static tree arm_builtin_decl (unsigned, bool);\n static void emit_constant_insn (rtx cond, rtx pattern);\n static rtx emit_set_insn (rtx, rtx);\n-static int arm_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int arm_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t  tree, bool);\n-static rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx arm_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t     const_tree, bool);\n-static void arm_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void arm_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n static unsigned int arm_function_arg_boundary (enum machine_mode, const_tree);\n static rtx aapcs_allocate_return_reg (enum machine_mode, const_tree,\n@@ -188,9 +188,9 @@ static void arm_encode_section_info (tree, rtx, int);\n static void arm_file_end (void);\n static void arm_file_start (void);\n \n-static void arm_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n+static void arm_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n \t\t\t\t\ttree, int *, int);\n-static bool arm_pass_by_reference (CUMULATIVE_ARGS *,\n+static bool arm_pass_by_reference (cumulative_args_t,\n \t\t\t\t   enum machine_mode, const_tree, bool);\n static bool arm_promote_prototypes (const_tree);\n static bool arm_default_short_enums (void);\n@@ -4389,9 +4389,10 @@ arm_needs_doubleword_align (enum machine_mode mode, const_tree type)\n    indeed make it pass in the stack if necessary).  */\n \n static rtx\n-arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+arm_function_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n \t\t  const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   int nregs;\n \n   /* Handle the special case quickly.  Pick an arbitrary value for op2 of\n@@ -4449,9 +4450,10 @@ arm_function_arg_boundary (enum machine_mode mode, const_tree type)\n }\n \n static int\n-arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+arm_arg_partial_bytes (cumulative_args_t pcum_v, enum machine_mode mode,\n \t\t       tree type, bool named)\n {\n+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   int nregs = pcum->nregs;\n \n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n@@ -4476,9 +4478,11 @@ arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-arm_function_arg_advance (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+arm_function_arg_advance (cumulative_args_t pcum_v, enum machine_mode mode,\n \t\t\t  const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n+\n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n     {\n       aapcs_layout_arg (pcum, mode, type, named);\n@@ -4512,7 +4516,7 @@ arm_function_arg_advance (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n    extension to the ARM ABI.  */\n \n static bool\n-arm_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+arm_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n@@ -21933,12 +21937,13 @@ arm_output_load_gr (rtx *operands)\n    that way.  */\n \n static void\n-arm_setup_incoming_varargs (CUMULATIVE_ARGS *pcum,\n+arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n \t\t\t    enum machine_mode mode,\n \t\t\t    tree type,\n \t\t\t    int *pretend_size,\n \t\t\t    int second_time ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   int nregs;\n   \n   cfun->machine->uses_anonymous_args = 1;"}, {"sha": "e46ccd3c6a545c2d2d718ecfdc7076497a374b32", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -102,9 +102,9 @@ static unsigned int avr_case_values_threshold (void);\n static bool avr_frame_pointer_required_p (void);\n static bool avr_can_eliminate (const int, const int);\n static bool avr_class_likely_spilled_p (reg_class_t c);\n-static rtx avr_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx avr_function_arg (cumulative_args_t , enum machine_mode,\n \t\t\t     const_tree, bool);\n-static void avr_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void avr_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n static void avr_help (void);\n static bool avr_function_ok_for_sibcall (tree, tree);\n@@ -1743,9 +1743,10 @@ avr_num_arg_regs (enum machine_mode mode, const_tree type)\n    in a register, and which register.  */\n \n static rtx\n-avr_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+avr_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes = avr_num_arg_regs (mode, type);\n \n   if (cum->nregs && bytes <= cum->nregs)\n@@ -1758,9 +1759,10 @@ avr_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    in the argument list.  */\n    \n static void\n-avr_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+avr_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes = avr_num_arg_regs (mode, type);\n \n   cum->nregs -= bytes;"}, {"sha": "72fc42383ee48cea9cb6ab2a9336ab91d2872ce6", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -560,7 +560,7 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n    - now, the vastart pointer can access all arguments from the stack.  */\n \n static void\n-setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+setup_incoming_varargs (cumulative_args_t cum,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\ttree type ATTRIBUTE_UNUSED, int *pretend_size,\n \t\t\tint no_rtl)\n@@ -576,7 +576,7 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n      if they are in the first 3 words.  We assume at least 1 named argument\n      exists, so we never generate [ARGP] = R0 here.  */\n \n-  for (i = cum->words + 1; i < max_arg_registers; i++)\n+  for (i = get_cumulative_args (cum)->words + 1; i < max_arg_registers; i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n \t\t\t plus_constant (arg_pointer_rtx, (i * UNITS_PER_WORD)));\n@@ -1647,9 +1647,10 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-bfin_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+bfin_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int count, bytes, words;\n \n   bytes = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n@@ -1686,9 +1687,10 @@ bfin_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-bfin_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+bfin_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes\n     = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n \n@@ -1715,13 +1717,13 @@ bfin_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    stack.   */\n \n static int\n-bfin_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+bfin_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n \t\t\ttree type ATTRIBUTE_UNUSED,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n   int bytes\n     = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n-  int bytes_left = cum->nregs * UNITS_PER_WORD;\n+  int bytes_left = get_cumulative_args (cum)->nregs * UNITS_PER_WORD;\n   \n   if (bytes == -1)\n     return 0;\n@@ -1736,7 +1738,7 @@ bfin_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Variable sized types are passed by reference.  */\n \n static bool\n-bfin_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+bfin_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {"}, {"sha": "54a0f266cac4675a088e0a983869e85a06139c94", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -98,7 +98,7 @@ static struct machine_function * cris_init_machine_status (void);\n \n static rtx cris_struct_value_rtx (tree, int);\n \n-static void cris_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n+static void cris_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n \t\t\t\t\t tree type, int *, int);\n \n static int cris_initial_frame_pointer_offset (void);\n@@ -125,15 +125,15 @@ static int cris_register_move_cost (enum machine_mode, reg_class_t, reg_class_t)\n static int cris_memory_move_cost (enum machine_mode, reg_class_t, bool);\n static bool cris_rtx_costs (rtx, int, int, int *, bool);\n static int cris_address_cost (rtx, bool);\n-static bool cris_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool cris_pass_by_reference (cumulative_args_t, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n-static int cris_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int cris_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx cris_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx cris_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n-static rtx cris_function_incoming_arg (CUMULATIVE_ARGS *,\n+static rtx cris_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       enum machine_mode, const_tree, bool);\n-static void cris_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void cris_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static tree cris_md_asm_clobbers (tree, tree, tree);\n \n@@ -3676,12 +3676,14 @@ cris_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-cris_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n+cris_setup_incoming_varargs (cumulative_args_t ca_v,\n \t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     tree type ATTRIBUTE_UNUSED,\n \t\t\t     int *pretend_arg_size,\n \t\t\t     int second_time)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   if (ca->regs < CRIS_MAX_ARGS_IN_REGS)\n     {\n       int stdarg_regs = CRIS_MAX_ARGS_IN_REGS - ca->regs;\n@@ -3699,7 +3701,7 @@ cris_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n    For cris, we pass <= 8 bytes by value, others by reference.  */\n \n static bool\n-cris_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+cris_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -3757,10 +3759,10 @@ cris_function_value_regno_p (const unsigned int regno)\n }\n \n static int\n-cris_arg_partial_bytes (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+cris_arg_partial_bytes (cumulative_args_t ca, enum machine_mode mode,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n-  if (ca->regs == CRIS_MAX_ARGS_IN_REGS - 1\n+  if (get_cumulative_args (ca)->regs == CRIS_MAX_ARGS_IN_REGS - 1\n       && !targetm.calls.must_pass_in_stack (mode, type)\n       && CRIS_FUNCTION_ARG_SIZE (mode, type) > 4\n       && CRIS_FUNCTION_ARG_SIZE (mode, type) <= 8)\n@@ -3770,11 +3772,13 @@ cris_arg_partial_bytes (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n }\n \n static rtx\n-cris_function_arg_1 (const CUMULATIVE_ARGS *ca,\n+cris_function_arg_1 (cumulative_args_t ca_v,\n \t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     const_tree type ATTRIBUTE_UNUSED,\n \t\t     bool named, bool incoming)\n {\n+  const CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   if ((!incoming || named) && ca->regs < CRIS_MAX_ARGS_IN_REGS)\n     return gen_rtx_REG (mode, CRIS_FIRST_ARG_REG + ca->regs);\n   else\n@@ -3785,7 +3789,7 @@ cris_function_arg_1 (const CUMULATIVE_ARGS *ca,\n    The void_type_node is sent as a \"closing\" call.  */\n \n static rtx\n-cris_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+cris_function_arg (cumulative_args_t ca, enum machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   return cris_function_arg_1 (ca, mode, type, named, false);\n@@ -3799,7 +3803,7 @@ cris_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n    void_type_node TYPE parameter.  */\n \n static rtx\n-cris_function_incoming_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+cris_function_incoming_arg (cumulative_args_t ca, enum machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n   return cris_function_arg_1 (ca, mode, type, named, true);\n@@ -3808,9 +3812,11 @@ cris_function_incoming_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n /* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-cris_function_arg_advance (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+cris_function_arg_advance (cumulative_args_t ca_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   ca->regs += (3 + CRIS_FUNCTION_ARG_SIZE (mode, type)) / 4;\n }\n "}, {"sha": "e6a3712a3f9330445b6cbb3beba26acfe50b746f", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -114,14 +114,14 @@ static struct fr30_frame_info \tcurrent_frame_info;\n /* Zero structure to initialize current_frame_info.  */\n static struct fr30_frame_info \tzero_frame_info;\n \n-static void fr30_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n+static void fr30_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static bool fr30_must_pass_in_stack (enum machine_mode, const_tree);\n-static int fr30_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int fr30_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx fr30_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx fr30_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n-static void fr30_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void fr30_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static bool fr30_frame_pointer_required (void);\n static rtx fr30_function_value (const_tree, const_tree, bool);\n@@ -454,22 +454,25 @@ fr30_expand_epilogue (void)\n    ARG_REGS_USED_SO_FAR has *not* been updated for the last named argument\n    which has type TYPE and mode MODE, and we rely on this fact.  */\n void\n-fr30_setup_incoming_varargs (CUMULATIVE_ARGS *arg_regs_used_so_far,\n+fr30_setup_incoming_varargs (cumulative_args_t arg_regs_used_so_far_v,\n \t\t\t     enum machine_mode mode,\n \t\t\t     tree type ATTRIBUTE_UNUSED,\n \t\t\t     int *pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *arg_regs_used_so_far\n+    = get_cumulative_args (arg_regs_used_so_far_v);\n   int size;\n \n   /* All BLKmode values are passed by reference.  */\n   gcc_assert (mode != BLKmode);\n \n   /* ??? This run-time test as well as the code inside the if\n      statement is probably unnecessary.  */\n-  if (targetm.calls.strict_argument_naming (arg_regs_used_so_far))\n+  if (targetm.calls.strict_argument_naming (arg_regs_used_so_far_v))\n     /* If TARGET_STRICT_ARGUMENT_NAMING returns true, then the last named\n        arg must not be treated as an anonymous arg.  */\n+    /* ??? This is a pointer increment, which makes no sense.  */\n     arg_regs_used_so_far += fr30_num_arg_regs (mode, type);\n \n   size = FR30_NUM_ARG_REGS - (* arg_regs_used_so_far);\n@@ -769,9 +772,11 @@ fr30_num_arg_regs (enum machine_mode mode, const_tree type)\n    parameters to the function.  */\n \n static int\n-fr30_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+fr30_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\ttree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   /* Unnamed arguments, i.e. those that are prototyped as ...\n      are always passed on the stack.\n      Also check here to see if all the argument registers are full.  */\n@@ -791,9 +796,11 @@ fr30_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static rtx\n-fr30_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+fr30_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (!named\n       || fr30_must_pass_in_stack (mode, type)\n       || *cum >= FR30_NUM_ARG_REGS)\n@@ -811,10 +818,10 @@ fr30_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    the stack.  The compiler knows how to track the amount of stack space used\n    for arguments without any special help.  */\n static void\n-fr30_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+fr30_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n-  *cum += named * fr30_num_arg_regs (mode, type);\n+  *get_cumulative_args (cum) += named * fr30_num_arg_regs (mode, type);\n }\n \n /*}}}*/"}, {"sha": "cbd04f1c6ff57219e7776d93eef9deadb143baf0", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -359,7 +359,7 @@ static void frv_init_libfuncs\t\t\t(void);\n static bool frv_in_small_data_p\t\t\t(const_tree);\n static void frv_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n-static void frv_setup_incoming_varargs\t\t(CUMULATIVE_ARGS *,\n+static void frv_setup_incoming_varargs\t\t(cumulative_args_t,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int *, int);\n static rtx frv_expand_builtin_saveregs\t\t(void);\n@@ -380,13 +380,13 @@ static void frv_output_const_unspec\t\t(FILE *,\n static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n static bool frv_must_pass_in_stack (enum machine_mode mode, const_tree type);\n-static int frv_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int frv_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t  tree, bool);\n-static rtx frv_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx frv_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t     const_tree, bool);\n-static rtx frv_function_incoming_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx frv_function_incoming_arg (cumulative_args_t, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n-static void frv_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void frv_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static unsigned int frv_function_arg_boundary\t(enum machine_mode,\n \t\t\t\t\t\t const_tree);\n@@ -2110,12 +2110,14 @@ frv_initial_elimination_offset (int from, int to)\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-frv_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+frv_setup_incoming_varargs (cumulative_args_t cum_v,\n                             enum machine_mode mode,\n                             tree type ATTRIBUTE_UNUSED,\n                             int *pretend_size,\n                             int second_time)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n \t     \"setup_vararg: words = %2d, mode = %4s, pretend_size = %d, second_time = %d\\n\",\n@@ -3102,10 +3104,12 @@ frv_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n static rtx\n-frv_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+frv_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t    const_tree type ATTRIBUTE_UNUSED, bool named,\n \t\t    bool incoming ATTRIBUTE_UNUSED)\n {\n+  const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int arg_num = *cum;\n   rtx ret;\n@@ -3139,14 +3143,14 @@ frv_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static rtx\n-frv_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+frv_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t  const_tree type, bool named)\n {\n   return frv_function_arg_1 (cum, mode, type, named, false);\n }\n \n static rtx\n-frv_function_incoming_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+frv_function_incoming_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n   return frv_function_arg_1 (cum, mode, type, named, true);\n@@ -3163,11 +3167,13 @@ frv_function_incoming_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    for arguments without any special help.  */\n \n static void\n-frv_function_arg_advance (CUMULATIVE_ARGS *cum,\n+frv_function_arg_advance (cumulative_args_t cum_v,\n                           enum machine_mode mode,\n                           const_tree type ATTRIBUTE_UNUSED,\n                           bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n   int words = (bytes + UNITS_PER_WORD  - 1) / UNITS_PER_WORD;\n@@ -3199,13 +3205,14 @@ frv_function_arg_advance (CUMULATIVE_ARGS *cum,\n    the called function.  */\n \n static int\n-frv_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+frv_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n \t\t       tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n+\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  int arg_num = *cum;\n+  int arg_num = *get_cumulative_args (cum);\n   int ret;\n \n   ret = ((arg_num <= LAST_ARG_REGNUM && arg_num + words > LAST_ARG_REGNUM+1)"}, {"sha": "bf87417bc8bc44647da5f6c392258492d7e4111d", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1031,9 +1031,11 @@ h8300_pr_saveall (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n    case the first 3 arguments are passed in registers.  */\n \n static rtx\n-h8300_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+h8300_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   static const char *const hand_list[] = {\n     \"__main\",\n     \"__cmpsi2\",\n@@ -1102,9 +1104,11 @@ h8300_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-h8300_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+h8300_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   cum->nbytes += (mode != BLKmode\n \t\t  ? (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD\n \t\t  : (int_size_in_bytes (type) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD);"}, {"sha": "8d0b6b614517121ca7a91c7a1fd354d99f1048c0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -6338,9 +6338,10 @@ function_arg_advance_ms_64 (CUMULATIVE_ARGS *cum, HOST_WIDE_INT bytes,\n    may not be available.)  */\n \n static void\n-ix86_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ix86_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   HOST_WIDE_INT bytes, words;\n \n   if (mode == BLKmode)\n@@ -6585,9 +6586,10 @@ function_arg_ms_64 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    ellipsis).  */\n \n static rtx\n-ix86_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n+ix86_function_arg (cumulative_args_t cum_v, enum machine_mode omode,\n \t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   enum machine_mode mode = omode;\n   HOST_WIDE_INT bytes, words;\n   rtx arg;\n@@ -6629,10 +6631,12 @@ ix86_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n    appropriate for passing a pointer to that type.  */\n \n static bool\n-ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+ix86_pass_by_reference (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   /* See Windows x64 Software Convention.  */\n   if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)\n     {\n@@ -7380,10 +7384,11 @@ setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n }\n \n static void\n-ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ix86_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t     int no_rtl)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   CUMULATIVE_ARGS next_cum;\n   tree fntype;\n \n@@ -7400,7 +7405,8 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n      For stdargs, we do want to skip the last named argument.  */\n   next_cum = *cum;\n   if (stdarg_p (fntype))\n-    ix86_function_arg_advance (&next_cum, mode, type, true);\n+    ix86_function_arg_advance (pack_cumulative_args (&next_cum), mode, type,\n+\t\t\t       true);\n \n   if (cum->call_abi == MS_ABI)\n     setup_incoming_varargs_ms_64 (&next_cum);"}, {"sha": "78d2441a32c033582e25a7f45ef1ef695d82fc0c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -195,17 +195,17 @@ static void ia64_option_override (void);\n static void ia64_option_default_params (void);\n static bool ia64_can_eliminate (const int, const int);\n static enum machine_mode hfa_element_mode (const_tree, bool);\n-static void ia64_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n+static void ia64_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n-static int ia64_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int ia64_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx ia64_function_arg_1 (const CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx ia64_function_arg_1 (cumulative_args_t, enum machine_mode,\n \t\t\t\tconst_tree, bool, bool);\n-static rtx ia64_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx ia64_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n-static rtx ia64_function_incoming_arg (CUMULATIVE_ARGS *,\n+static rtx ia64_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       enum machine_mode, const_tree, bool);\n-static void ia64_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void ia64_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static unsigned int ia64_function_arg_boundary (enum machine_mode,\n \t\t\t\t\t\tconst_tree);\n@@ -4157,14 +4157,14 @@ ia64_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n    We generate the actual spill instructions during prologue generation.  */\n \n static void\n-ia64_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ia64_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     tree type, int * pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n-  CUMULATIVE_ARGS next_cum = *cum;\n+  CUMULATIVE_ARGS next_cum = *get_cumulative_args (cum);\n \n   /* Skip the current argument.  */\n-  ia64_function_arg_advance (&next_cum, mode, type, 1);\n+  ia64_function_arg_advance (pack_cumulative_args (&next_cum), mode, type, 1);\n \n   if (next_cum.words < MAX_ARGUMENT_SLOTS)\n     {\n@@ -4312,9 +4312,11 @@ ia64_function_arg_offset (const CUMULATIVE_ARGS *cum,\n    registers.  */\n \n static rtx\n-ia64_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ia64_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t     const_tree type, bool named, bool incoming)\n {\n+  const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   int basereg = (incoming ? GR_ARG_FIRST : AR_ARG_FIRST);\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n@@ -4505,7 +4507,7 @@ ia64_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Implement TARGET_FUNCION_ARG target hook.  */\n \n static rtx\n-ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ia64_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   return ia64_function_arg_1 (cum, mode, type, named, false);\n@@ -4514,7 +4516,7 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Implement TARGET_FUNCION_INCOMING_ARG target hook.  */\n \n static rtx\n-ia64_function_incoming_arg (CUMULATIVE_ARGS *cum,\n+ia64_function_incoming_arg (cumulative_args_t cum,\n \t\t\t    enum machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n@@ -4526,9 +4528,11 @@ ia64_function_incoming_arg (CUMULATIVE_ARGS *cum,\n    in memory.  */\n \n static int\n-ia64_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ia64_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n \n@@ -4567,9 +4571,10 @@ ia64_arg_type (enum machine_mode mode)\n    ia64_function_arg.  */\n \n static void\n-ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+ia64_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n   enum machine_mode hfa_mode = VOIDmode;"}, {"sha": "916acf28408aae47c4c7c44b2b5f56ba86dedcfd", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -148,20 +148,20 @@ static section *iq2000_select_rtx_section (enum machine_mode, rtx,\n static void iq2000_init_builtins      (void);\n static rtx  iq2000_expand_builtin     (tree, rtx, rtx, enum machine_mode, int);\n static bool iq2000_return_in_memory   (const_tree, const_tree);\n-static void iq2000_setup_incoming_varargs (CUMULATIVE_ARGS *,\n+static void iq2000_setup_incoming_varargs (cumulative_args_t,\n \t\t\t\t\t   enum machine_mode, tree, int *,\n \t\t\t\t\t   int);\n static bool iq2000_rtx_costs          (rtx, int, int, int *, bool);\n static int  iq2000_address_cost       (rtx, bool);\n static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n static rtx  iq2000_legitimize_address (rtx, rtx, enum machine_mode);\n-static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool iq2000_pass_by_reference  (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n-static int  iq2000_arg_partial_bytes  (CUMULATIVE_ARGS *, enum machine_mode,\n+static int  iq2000_arg_partial_bytes  (cumulative_args_t, enum machine_mode,\n \t\t\t\t       tree, bool);\n-static rtx iq2000_function_arg\t      (CUMULATIVE_ARGS *,\n+static rtx iq2000_function_arg\t      (cumulative_args_t,\n \t\t\t\t       enum machine_mode, const_tree, bool);\n-static void iq2000_function_arg_advance (CUMULATIVE_ARGS *,\n+static void iq2000_function_arg_advance (cumulative_args_t,\n \t\t\t\t\t enum machine_mode, const_tree, bool);\n static unsigned int iq2000_function_arg_boundary (enum machine_mode,\n \t\t\t\t\t\t  const_tree);\n@@ -1129,9 +1129,11 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n    position in CUM.  */\n \n static void\n-iq2000_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+iq2000_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t     const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (TARGET_DEBUG_D_MODE)\n     {\n       fprintf (stderr,\n@@ -1198,9 +1200,10 @@ iq2000_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    and type TYPE in CUM, or 0 if the argument is to be passed on the stack.  */\n \n static rtx\n-iq2000_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+iq2000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t     const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   rtx ret;\n   int regbase = -1;\n   int bias = 0;\n@@ -1374,10 +1377,12 @@ iq2000_function_arg_boundary (enum machine_mode mode, const_tree type)\n }\n \n static int\n-iq2000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+iq2000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1)\n     {\n       if (TARGET_DEBUG_D_MODE)\n@@ -1879,7 +1884,8 @@ iq2000_expand_prologue (void)\n   int i;\n   tree next_arg;\n   tree cur_arg;\n-  CUMULATIVE_ARGS args_so_far;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n   int store_args_on_stack = (iq2000_can_use_return_insn ());\n \n   /* If struct value address is treated as the first argument.  */\n@@ -1903,7 +1909,8 @@ iq2000_expand_prologue (void)\n      variable arguments.\n \n      This is only needed if store_args_on_stack is true.  */\n-  INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, 0, 0);\n+  INIT_CUMULATIVE_ARGS (args_so_far_v, fntype, NULL_RTX, 0, 0);\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n   regno = GP_ARG_FIRST;\n \n   for (cur_arg = fnargs; cur_arg != 0; cur_arg = next_arg)\n@@ -1918,10 +1925,10 @@ iq2000_expand_prologue (void)\n \t  passed_mode = Pmode;\n \t}\n \n-      entry_parm = iq2000_function_arg (&args_so_far, passed_mode,\n+      entry_parm = iq2000_function_arg (args_so_far, passed_mode,\n \t\t\t\t\tpassed_type, true);\n \n-      iq2000_function_arg_advance (&args_so_far, passed_mode,\n+      iq2000_function_arg_advance (args_so_far, passed_mode,\n \t\t\t\t   passed_type, true);\n       next_arg = DECL_CHAIN (cur_arg);\n \n@@ -1964,7 +1971,7 @@ iq2000_expand_prologue (void)\n      iq2000_unction_arg has encoded a PARALLEL rtx, holding a vector of\n      adjustments to be made as the next_arg_reg variable, so we split up\n      the insns, and emit them separately.  */\n-  next_arg_reg = iq2000_function_arg (&args_so_far, VOIDmode,\n+  next_arg_reg = iq2000_function_arg (args_so_far, VOIDmode,\n \t\t\t\t      void_type_node, true);\n   if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)\n     {\n@@ -2238,9 +2245,10 @@ iq2000_function_value_regno_p (const unsigned int regno)\n /* Return true when an argument must be passed by reference.  */\n \n static bool\n-iq2000_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+iq2000_pass_by_reference (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int size;\n \n   /* We must pass by reference if we would be both passing in registers\n@@ -2254,7 +2262,8 @@ iq2000_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n        CUMULATIVE_ARGS temp;\n \n        temp = *cum;\n-       if (iq2000_function_arg (&temp, mode, type, named) != 0)\n+       if (iq2000_function_arg (pack_cumulative_args (&temp), mode, type, named)\n+\t   != 0)\n \t return 1;\n      }\n \n@@ -2835,11 +2844,12 @@ iq2000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-iq2000_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+iq2000_setup_incoming_varargs (cumulative_args_t cum_v,\n \t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       tree type ATTRIBUTE_UNUSED, int * pretend_size,\n \t\t\t       int no_rtl)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   unsigned int iq2000_off = ! cum->last_arg_fp; \n   unsigned int iq2000_fp_off = cum->last_arg_fp; \n "}, {"sha": "e9800e7f55e29b34fae1d3c37097ba36499b7c85", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -65,7 +65,7 @@ static rtx emit_add (rtx dest, rtx src0, rtx src1);\n static void expand_save_restore (struct lm32_frame_info *info, int op);\n static void stack_adjust (HOST_WIDE_INT amount);\n static bool lm32_in_small_data_p (const_tree);\n-static void lm32_setup_incoming_varargs (CUMULATIVE_ARGS * cum,\n+static void lm32_setup_incoming_varargs (cumulative_args_t cum,\n \t\t\t\t\t enum machine_mode mode, tree type,\n \t\t\t\t\t int *pretend_size, int no_rtl);\n static bool lm32_rtx_costs (rtx x, int code, int outer_code, int *total,\n@@ -75,10 +75,10 @@ static bool\n lm32_legitimate_address_p (enum machine_mode mode, rtx x, bool strict);\n static HOST_WIDE_INT lm32_compute_frame_size (int size);\n static void lm32_option_override (void);\n-static rtx lm32_function_arg (CUMULATIVE_ARGS * cum,\n+static rtx lm32_function_arg (cumulative_args_t cum,\n \t\t\t      enum machine_mode mode, const_tree type,\n \t\t\t      bool named);\n-static void lm32_function_arg_advance (CUMULATIVE_ARGS * cum,\n+static void lm32_function_arg_advance (cumulative_args_t cum,\n \t\t\t\t       enum machine_mode mode,\n \t\t\t\t       const_tree type, bool named);\n static bool lm32_legitimate_constant_p (enum machine_mode, rtx);\n@@ -623,9 +623,11 @@ lm32_print_operand_address (FILE * file, rtx addr)\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-lm32_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+lm32_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (mode == VOIDmode)\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (0);\n@@ -640,10 +642,10 @@ lm32_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static void\n-lm32_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+lm32_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n-  *cum += LM32_NUM_REGS2 (mode, type);\n+  *get_cumulative_args (cum) += LM32_NUM_REGS2 (mode, type);\n }\n \n HOST_WIDE_INT\n@@ -676,9 +678,10 @@ lm32_compute_initial_elimination_offset (int from, int to)\n }\n \n static void\n-lm32_setup_incoming_varargs (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+lm32_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t     tree type, int *pretend_size, int no_rtl)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int first_anon_arg;\n   tree fntype;\n "}, {"sha": "0336d0ea587afe0934b3e9eb53e1c36d2d4a88ad", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -73,15 +73,15 @@ static struct machine_function *m32c_init_machine_status (void);\n static void m32c_insert_attributes (tree, tree *);\n static bool m32c_legitimate_address_p (enum machine_mode, rtx, bool);\n static bool m32c_addr_space_legitimate_address_p (enum machine_mode, rtx, bool, addr_space_t);\n-static rtx m32c_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx m32c_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n-static bool m32c_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool m32c_pass_by_reference (cumulative_args_t, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n-static void m32c_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void m32c_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static unsigned int m32c_function_arg_boundary (enum machine_mode, const_tree);\n static int m32c_pushm_popm (Push_Pop_Type);\n-static bool m32c_strict_argument_naming (CUMULATIVE_ARGS *);\n+static bool m32c_strict_argument_naming (cumulative_args_t);\n static rtx m32c_struct_value_rtx (tree, int);\n static rtx m32c_subreg (enum machine_mode, rtx, enum machine_mode, int);\n static int need_to_save (int);\n@@ -1536,9 +1536,11 @@ m32c_push_rounding (int n)\n #undef TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG m32c_function_arg\n static rtx\n-m32c_function_arg (CUMULATIVE_ARGS * ca,\n+m32c_function_arg (cumulative_args_t ca_v,\n \t\t   enum machine_mode mode, const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   /* Can return a reg, parallel, or 0 for stack */\n   rtx rv = NULL_RTX;\n #if DEBUG0\n@@ -1587,7 +1589,7 @@ m32c_function_arg (CUMULATIVE_ARGS * ca,\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE m32c_pass_by_reference\n static bool\n-m32c_pass_by_reference (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED,\n+m32c_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type ATTRIBUTE_UNUSED,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n@@ -1617,11 +1619,13 @@ m32c_init_cumulative_args (CUMULATIVE_ARGS * ca,\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE m32c_function_arg_advance\n static void\n-m32c_function_arg_advance (CUMULATIVE_ARGS * ca,\n+m32c_function_arg_advance (cumulative_args_t ca_v,\n \t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t\t   bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   if (ca->force_mem)\n     ca->force_mem = 0;\n   else\n@@ -1783,7 +1787,7 @@ m32c_epilogue_uses (int regno ATTRIBUTE_UNUSED)\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING m32c_strict_argument_naming\n static bool\n-m32c_strict_argument_naming (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED)\n+m32c_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return 1;\n }"}, {"sha": "577345e9c98e99f2599eefb7b4d305f806d94425", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -81,18 +81,18 @@ static bool m32r_return_in_memory (const_tree, const_tree);\n static rtx m32r_function_value (const_tree, const_tree, bool);\n static rtx m32r_libcall_value (enum machine_mode, const_rtx);\n static bool m32r_function_value_regno_p (const unsigned int);\n-static void m32r_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n+static void m32r_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static void init_idents (void);\n static bool m32r_rtx_costs (rtx, int, int, int *, bool speed);\n static int m32r_memory_move_cost (enum machine_mode, reg_class_t, bool);\n-static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool m32r_pass_by_reference (cumulative_args_t, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n-static int m32r_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int m32r_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx m32r_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx m32r_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n-static void m32r_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void m32r_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static bool m32r_can_eliminate (const int, const int);\n static void m32r_conditional_register_usage (void);\n@@ -648,7 +648,7 @@ memreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n /* Return nonzero if TYPE must be passed by indirect reference.  */\n \n static bool\n-m32r_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+m32r_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -1138,9 +1138,11 @@ gen_split_move_double (rtx operands[])\n \n \f\n static int\n-m32r_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+m32r_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   int words;\n   unsigned int size =\n     (((mode == BLKmode && type)\n@@ -1196,10 +1198,12 @@ m32r_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    and the rest are pushed.  */\n \n static rtx\n-m32r_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+m32r_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t   bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   return (PASS_IN_REG_P (*cum, mode, type)\n \t  ? gen_rtx_REG (mode, ROUND_ADVANCE_CUM (*cum, mode, type))\n \t  : NULL_RTX);\n@@ -1210,9 +1214,11 @@ m32r_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-m32r_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+m32r_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum = (ROUND_ADVANCE_CUM (*cum, mode, type)\n \t  + ROUND_ADVANCE_ARG (mode, type));\n }\n@@ -1222,7 +1228,9 @@ m32r_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n static bool\n m32r_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n-  return m32r_pass_by_reference (NULL, TYPE_MODE (type), type, false);\n+  cumulative_args_t dummy = pack_cumulative_args (NULL);\n+\n+  return m32r_pass_by_reference (dummy, TYPE_MODE (type), type, false);\n }\n \n /* Worker function for TARGET_FUNCTION_VALUE.  */\n@@ -1262,7 +1270,7 @@ m32r_function_value_regno_p (const unsigned int regno)\n    and mode MODE, and we rely on this fact.  */\n \n static void\n-m32r_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+m32r_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     tree type, int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n@@ -1273,7 +1281,7 @@ m32r_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   /* All BLKmode values are passed by reference.  */\n   gcc_assert (mode != BLKmode);\n \n-  first_anon_arg = (ROUND_ADVANCE_CUM (*cum, mode, type)\n+  first_anon_arg = (ROUND_ADVANCE_CUM (*get_cumulative_args (cum), mode, type)\n \t\t    + ROUND_ADVANCE_ARG (mode, type));\n \n   if (first_anon_arg < M32R_MAX_PARM_REGS)"}, {"sha": "c0621c1fce1f49e410aabbdc35babe64adb7340d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -157,9 +157,9 @@ static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void m68k_trampoline_init (rtx, tree, rtx);\n static int m68k_return_pops_args (tree, tree, int);\n static rtx m68k_delegitimize_address (rtx);\n-static void m68k_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void m68k_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx m68k_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx m68k_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n static bool m68k_cannot_force_const_mem (enum machine_mode mode, rtx x);\n \f\n@@ -1372,7 +1372,7 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)\n /* On the m68k all args are always pushed.  */\n \n static rtx\n-m68k_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+m68k_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t   bool named ATTRIBUTE_UNUSED)\n@@ -1381,9 +1381,11 @@ m68k_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n }\n \n static void\n-m68k_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+m68k_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum += (mode != BLKmode\n \t   ? (GET_MODE_SIZE (mode) + 3) & ~3\n \t   : (int_size_in_bytes (type) + 3) & ~3);"}, {"sha": "8a822bd185c76b0ef62fb1a4c770f79b3c715150", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -96,7 +96,7 @@ static int        calc_live_regs                (int *);\n static int        try_constant_tricks           (long, HOST_WIDE_INT *, HOST_WIDE_INT *);\n static const char *     output_inline_const     (enum machine_mode, rtx *);\n static void       layout_mcore_frame            (struct mcore_frame *);\n-static void       mcore_setup_incoming_varargs\t(CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n+static void       mcore_setup_incoming_varargs\t(cumulative_args_t, enum machine_mode, tree, int *, int);\n static cond_type  is_cond_candidate             (rtx);\n static rtx        emit_new_cond_insn            (rtx, int);\n static rtx        conditionalize_block          (rtx);\n@@ -124,13 +124,13 @@ static int        mcore_ior_cost               \t(rtx);\n static bool       mcore_rtx_costs\t\t(rtx, int, int, int *, bool);\n static void       mcore_external_libcall\t(rtx);\n static bool       mcore_return_in_memory\t(const_tree, const_tree);\n-static int        mcore_arg_partial_bytes       (CUMULATIVE_ARGS *,\n+static int        mcore_arg_partial_bytes       (cumulative_args_t,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, bool);\n-static rtx        mcore_function_arg            (CUMULATIVE_ARGS *,\n+static rtx        mcore_function_arg            (cumulative_args_t,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t const_tree, bool);\n-static void       mcore_function_arg_advance    (CUMULATIVE_ARGS *,\n+static void       mcore_function_arg_advance    (cumulative_args_t,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t const_tree, bool);\n static unsigned int mcore_function_arg_boundary (enum machine_mode,\n@@ -1911,11 +1911,13 @@ mcore_initial_elimination_offset (int from, int to)\n /* Keep track of some information about varargs for the prolog.  */\n \n static void\n-mcore_setup_incoming_varargs (CUMULATIVE_ARGS *args_so_far,\n+mcore_setup_incoming_varargs (cumulative_args_t args_so_far_v,\n \t\t\t      enum machine_mode mode, tree type,\n \t\t\t      int * ptr_pretend_size ATTRIBUTE_UNUSED,\n \t\t\t      int second_time ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *args_so_far = get_cumulative_args (args_so_far_v);\n+\n   current_function_anonymous_args = 1;\n \n   /* We need to know how many argument registers are used before\n@@ -2783,7 +2785,7 @@ mcore_function_value (const_tree valtype, const_tree func)\n    its data type forbids.  */\n \n static rtx\n-mcore_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mcore_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n   int arg_reg;\n@@ -2794,7 +2796,7 @@ mcore_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (targetm.calls.must_pass_in_stack (mode, type))\n     return 0;\n \n-  arg_reg = ROUND_REG (*cum, mode);\n+  arg_reg = ROUND_REG (*get_cumulative_args (cum), mode);\n   \n   if (arg_reg < NPARM_REGS)\n     return handle_structs_in_regs (mode, type, FIRST_PARM_REG + arg_reg);\n@@ -2803,9 +2805,11 @@ mcore_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static void\n-mcore_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mcore_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum = (ROUND_REG (*cum, mode)\n \t  + (int)named * mcore_num_arg_regs (mode, type));\n }\n@@ -2828,10 +2832,10 @@ mcore_function_arg_boundary (enum machine_mode mode,\n    the function.  */\n \n static int\n-mcore_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mcore_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t tree type, bool named)\n {\n-  int reg = ROUND_REG (*cum, mode);\n+  int reg = ROUND_REG (*get_cumulative_args (cum), mode);\n \n   if (named == 0)\n     return 0;"}, {"sha": "a946c9350aaa362352cb2a1850672ac3f04790b0", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -213,13 +213,13 @@ static rtx mep_make_bundle (rtx, rtx);\n static void mep_bundle_insns (rtx);\n static bool mep_rtx_cost (rtx, int, int, int *, bool);\n static int mep_address_cost (rtx, bool);\n-static void mep_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n+static void mep_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n \t\t\t\t\ttree, int *, int);\n-static bool mep_pass_by_reference (CUMULATIVE_ARGS * cum, enum machine_mode,\n+static bool mep_pass_by_reference (cumulative_args_t cum, enum machine_mode,\n \t\t\t\t   const_tree, bool);\n-static rtx mep_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx mep_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t     const_tree, bool);\n-static void mep_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void mep_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n static bool mep_vector_mode_supported_p (enum machine_mode);\n static rtx  mep_allocate_initial_value (rtx);\n@@ -3494,12 +3494,12 @@ mep_final_prescan_insn (rtx insn, rtx *operands ATTRIBUTE_UNUSED,\n /* Function args in registers.  */\n \n static void\n-mep_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+mep_setup_incoming_varargs (cumulative_args_t cum,\n \t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    tree type ATTRIBUTE_UNUSED, int *pretend_size,\n \t\t\t    int second_time ATTRIBUTE_UNUSED)\n {\n-  int nsave = 4 - (cum->nregs + 1);\n+  int nsave = 4 - (get_cumulative_args (cum)->nregs + 1);\n \n   if (nsave > 0)\n     cfun->machine->arg_regs_to_save = nsave;\n@@ -3770,10 +3770,12 @@ mep_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n    first arg.  For varargs, we copy $1..$4 to the stack.  */\n \n static rtx\n-mep_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mep_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t  const_tree type ATTRIBUTE_UNUSED,\n \t\t  bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   /* VOIDmode is a signal for the backend to pass data to the call\n      expander via the second operand to the call pattern.  We use\n      this to determine whether to use \"jsr\" or \"jsrv\".  */\n@@ -3794,7 +3796,7 @@ mep_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static bool\n-mep_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n+mep_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode,\n \t\t       const_tree        type,\n \t\t       bool              named ATTRIBUTE_UNUSED)\n@@ -3810,18 +3812,19 @@ mep_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n     return true;\n   if (size <= 4)\n     return false;\n-  if (TARGET_IVC2 && cum->nregs < 4 && type != NULL_TREE && VECTOR_TYPE_P (type))\n+  if (TARGET_IVC2 && get_cumulative_args (cum)->nregs < 4\n+      && type != NULL_TREE && VECTOR_TYPE_P (type))\n     return false;\n   return true;\n }\n \n static void\n-mep_function_arg_advance (CUMULATIVE_ARGS *pcum,\n+mep_function_arg_advance (cumulative_args_t pcum,\n \t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type ATTRIBUTE_UNUSED,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n-  pcum->nregs += 1;\n+  get_cumulative_args (pcum)->nregs += 1;\n }\n \n bool"}, {"sha": "288b86fc10f0aedbfed9a9357c38266b1af100a2", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1091,9 +1091,12 @@ init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n /* Advance the argument to the next argument position.  */\n \n static void\n-microblaze_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+microblaze_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t\t enum machine_mode mode,\n \t\t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   cum->arg_number++;\n   switch (mode)\n     {\n@@ -1146,10 +1149,12 @@ microblaze_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n    or 0 if the argument is to be passed on the stack.  */\n \n static rtx\n-microblaze_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode, \n+microblaze_function_arg (cumulative_args_t cum_v, enum machine_mode mode, \n \t\t\t const_tree type ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   rtx ret;\n   int regbase = -1;\n   int *arg_words = &cum->arg_words;\n@@ -1197,9 +1202,11 @@ microblaze_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n \n /* Return number of bytes of argument to put in registers. */\n static int\n-function_arg_partial_bytes (CUMULATIVE_ARGS * cum, enum machine_mode mode,\t\n+function_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\t\n \t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\t\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if ((mode == BLKmode\n        || GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n        || GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n@@ -2220,7 +2227,8 @@ microblaze_expand_prologue (void)\n   int i;\n   tree next_arg;\n   tree cur_arg;\n-  CUMULATIVE_ARGS args_so_far;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n   rtx mem_rtx, reg_rtx;\n \n   /* If struct value address is treated as the first argument, make it so.  */\n@@ -2238,7 +2246,8 @@ microblaze_expand_prologue (void)\n \n   /* Determine the last argument, and get its name.  */\n \n-  INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, 0, 0);\n+  INIT_CUMULATIVE_ARGS (args_so_far_v, fntype, NULL_RTX, 0, 0);\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n   regno = GP_ARG_FIRST;\n \n   for (cur_arg = fnargs; cur_arg != 0; cur_arg = next_arg)\n@@ -2253,7 +2262,7 @@ microblaze_expand_prologue (void)\n \t  passed_mode = Pmode;\n \t}\n \n-      entry_parm = targetm.calls.function_arg (&args_so_far, passed_mode,\n+      entry_parm = targetm.calls.function_arg (args_so_far, passed_mode,\n \t\t\t\t\t       passed_type, true);\n \n       if (entry_parm)\n@@ -2274,7 +2283,7 @@ microblaze_expand_prologue (void)\n \t  break;\n \t}\n \n-      targetm.calls.function_arg_advance (&args_so_far, passed_mode,\n+      targetm.calls.function_arg_advance (args_so_far, passed_mode,\n \t\t\t\t\t  passed_type, true);\n \n       next_arg = TREE_CHAIN (cur_arg);\n@@ -2289,7 +2298,7 @@ microblaze_expand_prologue (void)\n \n   /* Split parallel insn into a sequence of insns.  */\n \n-  next_arg_reg = targetm.calls.function_arg (&args_so_far, VOIDmode,\n+  next_arg_reg = targetm.calls.function_arg (args_so_far, VOIDmode,\n \t\t\t\t\t     void_type_node, true);\n   if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)\n     {"}, {"sha": "f4010da3657fc2895792202f72c187c03d3368c8", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -4715,17 +4715,18 @@ mips_arg_regno (const struct mips_arg_info *info, bool hard_float_p)\n /* Implement TARGET_STRICT_ARGUMENT_NAMING.  */\n \n static bool\n-mips_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+mips_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return !TARGET_OLDABI;\n }\n \n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-mips_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mips_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   struct mips_arg_info info;\n \n   /* We will be called with a mode of VOIDmode after the last argument\n@@ -4849,9 +4850,10 @@ mips_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-mips_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mips_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   struct mips_arg_info info;\n \n   mips_get_arg_info (&info, cum, mode, type, named);\n@@ -4885,12 +4887,12 @@ mips_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Implement TARGET_ARG_PARTIAL_BYTES.  */\n \n static int\n-mips_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+mips_arg_partial_bytes (cumulative_args_t cum,\n \t\t\tenum machine_mode mode, tree type, bool named)\n {\n   struct mips_arg_info info;\n \n-  mips_get_arg_info (&info, cum, mode, type, named);\n+  mips_get_arg_info (&info, get_cumulative_args (cum), mode, type, named);\n   return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n }\n \n@@ -4969,7 +4971,7 @@ mips_pad_reg_upward (enum machine_mode mode, tree type)\n /* Return nonzero when an argument must be passed by reference.  */\n \n static bool\n-mips_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+mips_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -4996,7 +4998,7 @@ mips_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n /* Implement TARGET_CALLEE_COPIES.  */\n \n static bool\n-mips_callee_copies (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+mips_callee_copies (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    const_tree type ATTRIBUTE_UNUSED, bool named)\n {\n@@ -5263,7 +5265,7 @@ mips_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mips_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t     int no_rtl)\n {\n@@ -5273,8 +5275,9 @@ mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   /* The caller has advanced CUM up to, but not beyond, the last named\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n-  local_cum = *cum;\n-  mips_function_arg_advance (&local_cum, mode, type, true);\n+  local_cum = *get_cumulative_args (cum);\n+  mips_function_arg_advance (pack_cumulative_args (&local_cum), mode, type,\n+\t\t\t     true);\n \n   /* Found out how many registers we need to save.  */\n   gp_saved = MAX_ARGS_IN_REGISTERS - local_cum.num_gprs;\n@@ -5925,7 +5928,7 @@ mips_output_args_xfer (int fp_code, char direction)\n       else\n \tmips_output_64bit_xfer (direction, gparg, fparg);\n \n-      mips_function_arg_advance (&cum, mode, NULL, true);\n+      mips_function_arg_advance (pack_cumulative_args (&cum), mode, NULL, true);\n     }\n }\n "}, {"sha": "13234219578dab3d04a32ba731e6cdf234163215", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for MMIX.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010\n+   2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n \n@@ -135,26 +135,26 @@ static void mmix_reorg (void);\n static void mmix_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n static void mmix_setup_incoming_varargs\n-  (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n+  (cumulative_args_t, enum machine_mode, tree, int *, int);\n static void mmix_file_start (void);\n static void mmix_file_end (void);\n static bool mmix_rtx_costs (rtx, int, int, int *, bool);\n static rtx mmix_struct_value_rtx (tree, int);\n static enum machine_mode mmix_promote_function_mode (const_tree,\n \t\t\t\t\t\t     enum machine_mode,\n \t                                             int *, const_tree, int);\n-static void mmix_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void mmix_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx mmix_function_arg_1 (const CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx mmix_function_arg_1 (const cumulative_args_t, enum machine_mode,\n \t\t\t\tconst_tree, bool, bool);\n-static rtx mmix_function_incoming_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx mmix_function_incoming_arg (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx mmix_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx mmix_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n static rtx mmix_function_value (const_tree, const_tree, bool);\n static rtx mmix_libcall_value (enum machine_mode, const_rtx);\n static bool mmix_function_value_regno_p (const unsigned int);\n-static bool mmix_pass_by_reference (CUMULATIVE_ARGS *,\n+static bool mmix_pass_by_reference (cumulative_args_t,\n \t\t\t\t    enum machine_mode, const_tree, bool);\n static bool mmix_frame_pointer_required (void);\n static void mmix_asm_trampoline_template (FILE *);\n@@ -627,9 +627,10 @@ mmix_initial_elimination_offset (int fromreg, int toreg)\n }\n \n static void\n-mmix_function_arg_advance (CUMULATIVE_ARGS *argsp, enum machine_mode mode,\n+mmix_function_arg_advance (cumulative_args_t argsp_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n   int arg_size = MMIX_FUNCTION_ARG_SIZE (mode, type);\n \n   argsp->regs = ((targetm.calls.must_pass_in_stack (mode, type)\n@@ -643,12 +644,14 @@ mmix_function_arg_advance (CUMULATIVE_ARGS *argsp, enum machine_mode mode,\n /* Helper function for mmix_function_arg and mmix_function_incoming_arg.  */\n \n static rtx\n-mmix_function_arg_1 (const CUMULATIVE_ARGS *argsp,\n+mmix_function_arg_1 (const cumulative_args_t argsp_v,\n \t\t     enum machine_mode mode,\n \t\t     const_tree type,\n \t\t     bool named ATTRIBUTE_UNUSED,\n \t\t     bool incoming)\n {\n+  CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n+\n   /* Last-argument marker.  */\n   if (type == void_type_node)\n     return (argsp->regs < MMIX_MAX_ARGS_IN_REGS)\n@@ -675,7 +678,7 @@ mmix_function_arg_1 (const CUMULATIVE_ARGS *argsp,\n    one that must go on stack.  */\n \n static rtx\n-mmix_function_arg (CUMULATIVE_ARGS *argsp,\n+mmix_function_arg (cumulative_args_t argsp,\n \t\t   enum machine_mode mode,\n \t\t   const_tree type,\n \t\t   bool named)\n@@ -684,7 +687,7 @@ mmix_function_arg (CUMULATIVE_ARGS *argsp,\n }\n \n static rtx\n-mmix_function_incoming_arg (CUMULATIVE_ARGS *argsp,\n+mmix_function_incoming_arg (cumulative_args_t argsp,\n \t\t\t    enum machine_mode mode,\n \t\t\t    const_tree type,\n \t\t\t    bool named)\n@@ -696,9 +699,11 @@ mmix_function_incoming_arg (CUMULATIVE_ARGS *argsp,\n    everything that goes by value.  */\n \n static bool\n-mmix_pass_by_reference (CUMULATIVE_ARGS *argsp, enum machine_mode mode,\n+mmix_pass_by_reference (cumulative_args_t argsp_v, enum machine_mode mode,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n+\n   /* FIXME: Check: I'm not sure the must_pass_in_stack check is\n      necessary.  */\n   if (targetm.calls.must_pass_in_stack (mode, type))\n@@ -961,12 +966,14 @@ mmix_function_profiler (FILE *stream ATTRIBUTE_UNUSED,\n    can parse all arguments in registers, to improve performance.  */\n \n static void\n-mmix_setup_incoming_varargs (CUMULATIVE_ARGS *args_so_farp,\n+mmix_setup_incoming_varargs (cumulative_args_t args_so_farp_v,\n \t\t\t     enum machine_mode mode,\n \t\t\t     tree vartype,\n \t\t\t     int *pretend_sizep,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *args_so_farp = get_cumulative_args (args_so_farp_v);\n+\n   /* The last named variable has been handled, but\n      args_so_farp has not been advanced for it.  */\n   if (args_so_farp->regs + 1 < MMIX_MAX_ARGS_IN_REGS)"}, {"sha": "24a07d87d554f27656d70c365be9c583e8c65917", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1492,7 +1492,7 @@ mn10300_va_start (tree valist, rtx nextarg)\n /* Return true when a parameter should be passed by reference.  */\n \n static bool\n-mn10300_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+mn10300_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\t   enum machine_mode mode, const_tree type,\n \t\t\t   bool named ATTRIBUTE_UNUSED)\n {\n@@ -1510,9 +1510,10 @@ mn10300_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    from a function.  If the result is NULL_RTX, the argument is pushed.  */\n \n static rtx\n-mn10300_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mn10300_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   rtx result = NULL_RTX;\n   int size;\n \n@@ -1558,9 +1559,11 @@ mn10300_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-mn10300_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mn10300_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   cum->nbytes += (mode != BLKmode\n \t\t  ? (GET_MODE_SIZE (mode) + 3) & ~3\n \t\t  : (int_size_in_bytes (type) + 3) & ~3);\n@@ -1570,9 +1573,10 @@ mn10300_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    partially in registers and partially in memory.  */\n \n static int\n-mn10300_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+mn10300_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int size;\n \n   /* We only support using 2 data registers as argument registers.  */"}, {"sha": "d70eaac3015594ede660f47e54ad6fbc1b41474f", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1,5 +1,5 @@\n /* Target Code for moxie\n-   Copyright (C) 2008, 2009, 2010  Free Software Foundation\n+   Copyright (C) 2008, 2009, 2010, 2011  Free Software Foundation\n    Contributed by Anthony Green.\n \n    This file is part of GCC.\n@@ -370,11 +370,12 @@ moxie_initial_elimination_offset (int from, int to)\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-moxie_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+moxie_setup_incoming_varargs (cumulative_args_t cum_v,\n \t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t      tree type ATTRIBUTE_UNUSED,\n \t\t\t      int *pretend_size, int no_rtl)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int regno;\n   int regs = 8 - *cum;\n   \n@@ -409,10 +410,12 @@ moxie_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    NULL_RTX if there's no more space.  */\n \n static rtx\n-moxie_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+moxie_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t    const_tree type ATTRIBUTE_UNUSED,\n \t\t    bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (*cum < 8)\n     return gen_rtx_REG (mode, *cum);\n   else \n@@ -424,9 +427,11 @@ moxie_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    : (unsigned) int_size_in_bytes (TYPE))\n \n static void\n-moxie_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+moxie_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum = (*cum < MOXIE_R6\n \t  ? *cum + ((3 + MOXIE_FUNCTION_ARG_SIZE (mode, type)) / 4)\n \t  : *cum);\n@@ -436,7 +441,7 @@ moxie_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    passed by reference.  */\n \n static bool\n-moxie_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+moxie_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode mode, const_tree type,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n@@ -459,16 +464,17 @@ moxie_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    that fit in argument passing registers.  */\n \n static int\n-moxie_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+moxie_arg_partial_bytes (cumulative_args_t cum_v,\n \t\t\t enum machine_mode mode,\n \t\t\t tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes_left, size;\n \n   if (*cum >= 8)\n     return 0;\n \n-  if (moxie_pass_by_reference (cum, mode, type, named))\n+  if (moxie_pass_by_reference (cum_v, mode, type, named))\n     size = 4;\n   else if (type)\n     {"}, {"sha": "2a54bdde266e40b682c8bcba66c8d262591ffa60", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -158,13 +158,13 @@ static void pa_hpux_file_end (void);\n static void pa_hpux_init_libfuncs (void);\n #endif\n static rtx pa_struct_value_rtx (tree, int);\n-static bool pa_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool pa_pass_by_reference (cumulative_args_t, enum machine_mode,\n \t\t\t\t  const_tree, bool);\n-static int pa_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int pa_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t tree, bool);\n-static void pa_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void pa_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t     const_tree, bool);\n-static rtx pa_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx pa_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t    const_tree, bool);\n static unsigned int pa_function_arg_boundary (enum machine_mode, const_tree);\n static struct machine_function * pa_init_machine_status (void);\n@@ -5948,7 +5948,7 @@ pa_eh_return_handler_rtx (void)\n    or updates the ABI.  */\n \n static bool\n-pa_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+pa_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t      enum machine_mode mode, const_tree type,\n \t\t      bool named ATTRIBUTE_UNUSED)\n {\n@@ -9386,9 +9386,10 @@ pa_function_value_regno_p (const unsigned int regno)\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-pa_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+pa_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int arg_size = FUNCTION_ARG_SIZE (mode, type);\n \n   cum->nargs_prototype--;\n@@ -9407,9 +9408,10 @@ pa_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    ??? We might want to restructure this so that it looks more like other\n    ports.  */\n static rtx\n-pa_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+pa_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int max_arg_words = (TARGET_64BIT ? 8 : 4);\n   int alignment = 0;\n   int arg_size;\n@@ -9617,9 +9619,10 @@ pa_function_arg_boundary (enum machine_mode mode, const_tree type)\n    then this routine should return zero.  */\n \n static int\n-pa_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+pa_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   unsigned int max_arg_words = 8;\n   unsigned int offset = 0;\n "}, {"sha": "870b94715185f1c7ea5a56ad81e7ca76a44c54f9", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -149,9 +149,9 @@ static rtx pdp11_function_value (const_tree, const_tree, bool);\n static rtx pdp11_libcall_value (enum machine_mode, const_rtx);\n static bool pdp11_function_value_regno_p (const unsigned int);\n static void pdp11_trampoline_init (rtx, tree, rtx);\n-static rtx pdp11_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx pdp11_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t       const_tree, bool);\n-static void pdp11_function_arg_advance (CUMULATIVE_ARGS *,\n+static void pdp11_function_arg_advance (cumulative_args_t,\n \t\t\t\t\tenum machine_mode, const_tree, bool);\n static void pdp11_conditional_register_usage (void);\n static bool pdp11_legitimate_constant_p (enum machine_mode, rtx);\n@@ -1813,7 +1813,7 @@ pdp11_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-pdp11_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+pdp11_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    const_tree type ATTRIBUTE_UNUSED,\n \t\t    bool named ATTRIBUTE_UNUSED)\n@@ -1828,9 +1828,11 @@ pdp11_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    may not be available.)  */\n \n static void\n-pdp11_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+pdp11_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum += (mode != BLKmode\n \t   ? GET_MODE_SIZE (mode)\n \t   : int_size_in_bytes (type));"}, {"sha": "c3a7046763aea635ac1e95bf4de6534fc2d0e6d2", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -77,16 +77,16 @@ void picochip_asm_file_end (void);\n void picochip_init_libfuncs (void);\n void picochip_reorg (void);\n \n-int picochip_arg_partial_bytes (CUMULATIVE_ARGS * p_cum,\n+int picochip_arg_partial_bytes (cumulative_args_t p_cum,\n \t\t\t\t       enum machine_mode mode,\n \t\t\t\t       tree type, bool named);\n-rtx picochip_function_arg (CUMULATIVE_ARGS * p_cum,\n+rtx picochip_function_arg (cumulative_args_t p_cum,\n \t\t\t   enum machine_mode mode,\n \t\t\t   const_tree type, bool named);\n-rtx picochip_incoming_function_arg (CUMULATIVE_ARGS * p_cum,\n+rtx picochip_incoming_function_arg (cumulative_args_t p_cum,\n \t\t\t\t    enum machine_mode mode,\n \t\t\t\t    const_tree type, bool named);\n-void picochip_arg_advance (CUMULATIVE_ARGS * p_cum, enum machine_mode mode,\n+void picochip_arg_advance (cumulative_args_t p_cum, enum machine_mode mode,\n \t\t\t   const_tree type, bool named);\n unsigned int picochip_function_arg_boundary (enum machine_mode mode,\n \t\t\t\t\t     const_tree type);\n@@ -821,9 +821,10 @@ picochip_compute_arg_size (const_tree type, enum machine_mode mode)\n \n /* Determine where the next outgoing arg should be placed. */\n rtx\n-picochip_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+picochip_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int reg = 0;\n   int type_align_in_units = 0;\n   int type_size_in_units;\n@@ -919,7 +920,7 @@ picochip_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    passed in registers, which are then pushed onto the stack by the\n    function prologue). */\n rtx\n-picochip_incoming_function_arg (CUMULATIVE_ARGS *cum,\n+picochip_incoming_function_arg (cumulative_args_t cum,\n \t\t\t\tenum machine_mode mode,\n \t\t\t\tconst_tree type, bool named)\n {\n@@ -953,15 +954,15 @@ picochip_function_arg_boundary (enum machine_mode mode,\n \n /* Compute partial registers. */\n int\n-picochip_arg_partial_bytes (CUMULATIVE_ARGS * p_cum, enum machine_mode mode,\n+picochip_arg_partial_bytes (cumulative_args_t p_cum, enum machine_mode mode,\n \t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\n {\n   int type_align_in_units = 0;\n   int type_size_in_units;\n   int new_offset = 0;\n   int offset_overflow = 0;\n \n-  unsigned cum = *((unsigned *) p_cum);\n+  unsigned cum = *get_cumulative_args (p_cum);\n \n   /* VOIDmode is passed when computing the second argument to a `call'\n      pattern. This can be ignored. */\n@@ -1009,9 +1010,10 @@ picochip_arg_partial_bytes (CUMULATIVE_ARGS * p_cum, enum machine_mode mode,\n \n /* Advance the cumulative args counter CUM. */\n void\n-picochip_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+picochip_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int type_align_in_units = 0;\n   int type_size_in_units;\n   int new_offset = 0;"}, {"sha": "c15c04e1e6a2a71c0af0a391b1e7e3896f11600e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1081,19 +1081,19 @@ static void rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *,\n \t\t\t\t\t\trtx[], int *);\n static rtx rs6000_darwin64_record_arg (CUMULATIVE_ARGS *, const_tree, bool, bool);\n static rtx rs6000_mixed_function_arg (enum machine_mode, const_tree, int);\n-static void rs6000_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void rs6000_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t\t const_tree, bool);\n-static rtx rs6000_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx rs6000_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t\tconst_tree, bool);\n static unsigned int rs6000_function_arg_boundary (enum machine_mode,\n \t\t\t\t\t\t  const_tree);\n static void rs6000_move_block_from_reg (int regno, rtx x, int nregs);\n-static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n+static void setup_incoming_varargs (cumulative_args_t,\n \t\t\t\t    enum machine_mode, tree,\n \t\t\t\t    int *, int);\n-static bool rs6000_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool rs6000_pass_by_reference (cumulative_args_t, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n-static int rs6000_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int rs6000_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t     tree, bool);\n static const char *invalid_arg_for_unprototyped_fn (const_tree, const_tree, const_tree);\n #if TARGET_MACHO\n@@ -8040,10 +8040,11 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static void\n-rs6000_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+rs6000_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     const_tree type, bool named)\n {\n-  rs6000_function_arg_advance_1 (cum, mode, type, named, 0);\n+  rs6000_function_arg_advance_1 (get_cumulative_args (cum), mode, type, named,\n+\t\t\t\t 0);\n }\n \n static rtx\n@@ -8407,9 +8408,10 @@ rs6000_mixed_function_arg (enum machine_mode mode, const_tree type,\n    itself.  */\n \n static rtx\n-rs6000_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t     const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   enum rs6000_abi abi = DEFAULT_ABI;\n \n   /* Return a marker to indicate whether CR1 needs to set or clear the\n@@ -8679,9 +8681,10 @@ rs6000_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    returns the number of bytes used by the first element of the PARALLEL.  */\n \n static int\n-rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int ret = 0;\n   int align_words;\n \n@@ -8742,7 +8745,7 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    reference.  */\n \n static bool\n-rs6000_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+rs6000_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\t  enum machine_mode mode, const_tree type,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -8842,7 +8845,7 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n    stack and set PRETEND_SIZE to the length of the registers pushed.  */\n \n static void\n-setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\tint no_rtl)\n {\n@@ -8853,7 +8856,7 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   alias_set_type set;\n \n   /* Skip the last named argument.  */\n-  next_cum = *cum;\n+  next_cum = *get_cumulative_args (cum);\n   rs6000_function_arg_advance_1 (&next_cum, mode, type, true, 0);\n \n   if (DEFAULT_ABI == ABI_V4)"}, {"sha": "dcf693a63376f3c1a1956ee10c40912c0b7ad2a2", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -832,11 +832,11 @@ rx_function_arg_size (enum machine_mode mode, const_tree type)\n    variable parameter list.  */\n \n static rtx\n-rx_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+rx_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t const_tree type, bool named)\n {\n   unsigned int next_reg;\n-  unsigned int bytes_so_far = *cum;\n+  unsigned int bytes_so_far = *get_cumulative_args (cum);\n   unsigned int size;\n   unsigned int rounded_size;\n \n@@ -870,10 +870,10 @@ rx_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n }\n \n static void\n-rx_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+rx_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n-  *cum += rx_function_arg_size (mode, type);\n+  *get_cumulative_args (cum) += rx_function_arg_size (mode, type);\n }\n \n static unsigned int"}, {"sha": "a91f4c1107c9875a7514d37f2b3ac04a6a81fb69", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -8511,7 +8511,7 @@ s390_function_arg_integer (enum machine_mode mode, const_tree type)\n    reference.  */\n \n static bool\n-s390_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+s390_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -8539,9 +8539,11 @@ s390_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n    matching an ellipsis).  */\n \n static void\n-s390_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+s390_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (s390_function_arg_float (mode, type))\n     {\n       cum->fprs += 1;\n@@ -8575,9 +8577,11 @@ s390_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    are pushed to the stack.  */\n \n static rtx\n-s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+s390_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (s390_function_arg_float (mode, type))\n     {\n       if (cum->fprs + 1 > FP_ARG_NUM_REG)\n@@ -9622,14 +9626,16 @@ s390_valid_pointer_mode (enum machine_mode mode)\n static bool\n s390_call_saved_register_used (tree call_expr)\n {\n-  CUMULATIVE_ARGS cum;\n+  CUMULATIVE_ARGS cum_v;\n+  cumulative_args_t cum;\n   tree parameter;\n   enum machine_mode mode;\n   tree type;\n   rtx parm_rtx;\n   int reg, i;\n \n-  INIT_CUMULATIVE_ARGS (cum, NULL, NULL, 0, 0);\n+  INIT_CUMULATIVE_ARGS (cum_v, NULL, NULL, 0, 0);\n+  cum = pack_cumulative_args (&cum_v);\n \n   for (i = 0; i < call_expr_nargs (call_expr); i++)\n     {\n@@ -9647,15 +9653,15 @@ s390_call_saved_register_used (tree call_expr)\n       mode = TYPE_MODE (type);\n       gcc_assert (mode);\n \n-      if (pass_by_reference (&cum, mode, type, true))\n+      if (pass_by_reference (&cum_v, mode, type, true))\n  \t{\n  \t  mode = Pmode;\n  \t  type = build_pointer_type (type);\n  \t}\n \n-       parm_rtx = s390_function_arg (&cum, mode, type, 0);\n+       parm_rtx = s390_function_arg (cum, mode, type, 0);\n \n-       s390_function_arg_advance (&cum, mode, type, 0);\n+       s390_function_arg_advance (cum, mode, type, 0);\n \n        if (!parm_rtx)\n \t continue;"}, {"sha": "3a96eabd176b91a2dd8d22e1f1c156c4a14fb592", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1,5 +1,6 @@\n /* score-protos.h for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -63,9 +64,6 @@ extern enum reg_class score_preferred_reload_class (rtx x,\n extern HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n extern void score_print_operand (FILE *file, rtx op, int letter);\n extern void score_print_operand_address (FILE *file, rtx addr);\n-extern int score_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n-                                    enum machine_mode mode,\n-                                    tree type, bool named);\n extern int score_symbolic_constant_p (rtx x,\n                                       enum score_symbol_type *symbol_type);\n extern void score_movsicc (rtx *ops);"}, {"sha": "a9b6013bda21dbbea50163cc3d35061cbdf04845", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -152,7 +152,7 @@ score_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n \n /* Return nonzero when an argument must be passed by reference.  */\n static bool\n-score_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+score_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n                          enum machine_mode mode, const_tree type,\n                          bool named ATTRIBUTE_UNUSED)\n {\n@@ -352,33 +352,34 @@ score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n \n /* Implement TARGET_FUNCTION_ARG_ADVANCE hook.  */\n static void\n-score_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+score_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n                             const_tree type, bool named)\n {\n   if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_function_arg_advance (cum, mode, type, named);\n+    score7_function_arg_advance (get_cumulative_args (cum), mode, type, named);\n   else\n     gcc_unreachable ();\n }\n \n /* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n int\n-score_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+score_arg_partial_bytes (cumulative_args_t cum,\n                          enum machine_mode mode, tree type, bool named)\n {\n   if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_arg_partial_bytes (cum, mode, type, named);\n+    return score7_arg_partial_bytes (get_cumulative_args (cum), mode, type,\n+\t\t\t\t     named);\n   else\n     gcc_unreachable ();\n }\n \n /* Implement TARGET_FUNCTION_ARG hook.  */\n static rtx\n-score_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+score_function_arg (cumulative_args_t cum, enum machine_mode mode,\n                     const_tree type, bool named)\n {\n   if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_function_arg (cum, mode, type, named);\n+    return score7_function_arg (get_cumulative_args (cum), mode, type, named);\n   else\n     gcc_unreachable ();\n }"}, {"sha": "327a236a9e3060fa9e8bbf92b0451a42d5670265", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -273,9 +273,9 @@ static bool sh_function_value_regno_p (const unsigned int);\n static rtx sh_libcall_value (enum machine_mode, const_rtx);\n static bool sh_return_in_memory (const_tree, const_tree);\n static rtx sh_builtin_saveregs (void);\n-static void sh_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n-static bool sh_strict_argument_naming (CUMULATIVE_ARGS *);\n-static bool sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n+static void sh_setup_incoming_varargs (cumulative_args_t, enum machine_mode, tree, int *, int);\n+static bool sh_strict_argument_naming (cumulative_args_t);\n+static bool sh_pretend_outgoing_varargs_named (cumulative_args_t);\n static tree sh_build_builtin_va_list (void);\n static void sh_va_start (tree, rtx);\n static tree sh_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n@@ -285,15 +285,15 @@ static enum machine_mode sh_promote_function_mode (const_tree type,\n \t\t\t\t\t\t   int *punsignedp,\n \t\t\t\t\t\t   const_tree funtype,\n \t\t\t\t\t\t   int for_return);\n-static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool sh_pass_by_reference (cumulative_args_t, enum machine_mode,\n \t\t\t\t  const_tree, bool);\n-static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n+static bool sh_callee_copies (cumulative_args_t, enum machine_mode,\n \t\t\t      const_tree, bool);\n-static int sh_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+static int sh_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t         tree, bool);\n-static void sh_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void sh_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t     const_tree, bool);\n-static rtx sh_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx sh_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t    const_tree, bool);\n static bool sh_scalar_mode_supported_p (enum machine_mode);\n static int sh_dwarf_calling_convention (const_tree);\n@@ -8182,9 +8182,11 @@ shcompact_byref (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static bool\n-sh_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sh_pass_by_reference (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (targetm.calls.must_pass_in_stack (mode, type))\n     return true;\n \n@@ -8204,21 +8206,22 @@ sh_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static bool\n-sh_callee_copies (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sh_callee_copies (cumulative_args_t cum, enum machine_mode mode,\n \t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   /* ??? How can it possibly be correct to return true only on the\n      caller side of the equation?  Is there someplace else in the\n      sh backend that's magically producing the copies?  */\n-  return (cum->outgoing\n+  return (get_cumulative_args (cum)->outgoing\n \t  && ((mode == BLKmode ? TYPE_ALIGN (type) : GET_MODE_ALIGNMENT (mode))\n \t      % SH_MIN_ALIGN_FOR_CALLEE_COPY == 0));\n }\n \n static int\n-sh_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sh_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int words = 0;\n \n   if (!TARGET_SH5\n@@ -8258,9 +8261,11 @@ sh_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    its data type forbids.  */\n \n static rtx\n-sh_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n \t\t const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   if (! TARGET_SH5 && mode == VOIDmode)\n     return GEN_INT (ca->renesas_abi ? 1 : 0);\n \n@@ -8346,9 +8351,11 @@ sh_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n    available.)  */\n \n static void\n-sh_function_arg_advance (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+sh_function_arg_advance (cumulative_args_t ca_v, enum machine_mode mode,\n \t\t\t const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   if (ca->force_mem)\n     ca->force_mem = 0;\n   else if (TARGET_SH5)\n@@ -8574,7 +8581,7 @@ sh_return_in_memory (const_tree type, const_tree fndecl)\n    later.  Fortunately, we already have two flags that are part of struct\n    function that tell if a function uses varargs or stdarg.  */\n static void\n-sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n+sh_setup_incoming_varargs (cumulative_args_t ca,\n \t\t\t   enum machine_mode mode,\n \t\t\t   tree type,\n \t\t\t   int *pretend_arg_size,\n@@ -8585,7 +8592,7 @@ sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n     {\n       int named_parm_regs, anon_parm_regs;\n \n-      named_parm_regs = (ROUND_REG (*ca, mode)\n+      named_parm_regs = (ROUND_REG (*get_cumulative_args (ca), mode)\n \t\t\t + (mode == BLKmode\n \t\t\t    ? ROUND_ADVANCE (int_size_in_bytes (type))\n \t\t\t    : ROUND_ADVANCE (GET_MODE_SIZE (mode))));\n@@ -8596,14 +8603,16 @@ sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n }\n \n static bool\n-sh_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+sh_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return TARGET_SH5;\n }\n \n static bool\n-sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *ca)\n+sh_pretend_outgoing_varargs_named (cumulative_args_t ca_v)\n {\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n+\n   return ! (TARGET_HITACHI || ca->renesas_abi) && ! TARGET_SH5;\n }\n \n@@ -11568,9 +11577,10 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       tree ptype = build_pointer_type (TREE_TYPE (funtype));\n \n-      sh_function_arg_advance (&cum, Pmode, ptype, true);\n+      sh_function_arg_advance (pack_cumulative_args (&cum), Pmode, ptype, true);\n     }\n-  this_rtx = sh_function_arg (&cum, Pmode, ptr_type_node, true);\n+  this_rtx\n+    = sh_function_arg (pack_cumulative_args (&cum), Pmode, ptr_type_node, true);\n \n   /* For SHcompact, we only have r0 for a scratch register: r1 is the\n      static chain pointer (even if you can't have nested virtual functions"}, {"sha": "fe28d55ee432026c3e02598f35c65742d07c6d53", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -436,7 +436,7 @@ static rtx sparc_struct_value_rtx (tree, int);\n static enum machine_mode sparc_promote_function_mode (const_tree, enum machine_mode,\n \t\t\t\t\t\t      int *, const_tree, int);\n static bool sparc_return_in_memory (const_tree, const_tree);\n-static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n+static bool sparc_strict_argument_naming (cumulative_args_t);\n static void sparc_va_start (tree, rtx);\n static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool sparc_vector_mode_supported_p (enum machine_mode);\n@@ -446,19 +446,19 @@ static rtx sparc_legitimize_pic_address (rtx, rtx);\n static rtx sparc_legitimize_address (rtx, rtx, enum machine_mode);\n static rtx sparc_delegitimize_address (rtx);\n static bool sparc_mode_dependent_address_p (const_rtx);\n-static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n+static bool sparc_pass_by_reference (cumulative_args_t,\n \t\t\t\t     enum machine_mode, const_tree, bool);\n-static void sparc_function_arg_advance (CUMULATIVE_ARGS *,\n+static void sparc_function_arg_advance (cumulative_args_t,\n \t\t\t\t\tenum machine_mode, const_tree, bool);\n-static rtx sparc_function_arg_1 (const CUMULATIVE_ARGS *,\n+static rtx sparc_function_arg_1 (cumulative_args_t,\n \t\t\t\t enum machine_mode, const_tree, bool, bool);\n-static rtx sparc_function_arg (CUMULATIVE_ARGS *,\n+static rtx sparc_function_arg (cumulative_args_t,\n \t\t\t       enum machine_mode, const_tree, bool);\n-static rtx sparc_function_incoming_arg (CUMULATIVE_ARGS *,\n+static rtx sparc_function_incoming_arg (cumulative_args_t,\n \t\t\t\t\tenum machine_mode, const_tree, bool);\n static unsigned int sparc_function_arg_boundary (enum machine_mode,\n \t\t\t\t\t\t const_tree);\n-static int sparc_arg_partial_bytes (CUMULATIVE_ARGS *,\n+static int sparc_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t    enum machine_mode, tree, bool);\n static void sparc_dwarf_handle_frame_unspec (const char *, rtx, int);\n static void sparc_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n@@ -5429,7 +5429,7 @@ sparc_promote_function_mode (const_tree type,\n /* Handle the TARGET_STRICT_ARGUMENT_NAMING target hook.  */\n \n static bool\n-sparc_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+sparc_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return TARGET_ARCH64 ? true : false;\n }\n@@ -6075,9 +6075,11 @@ function_arg_vector_value (int size, int regno)\n     TARGET_FUNCTION_INCOMING_ARG.  */\n \n static rtx\n-sparc_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sparc_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      const_tree type, bool named, bool incoming_p)\n {\n+  const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   int regbase = (incoming_p\n \t\t ? SPARC_INCOMING_INT_ARG_FIRST\n \t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n@@ -6211,7 +6213,7 @@ sparc_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Handle the TARGET_FUNCTION_ARG target hook.  */\n \n static rtx\n-sparc_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sparc_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n   return sparc_function_arg_1 (cum, mode, type, named, false);\n@@ -6220,7 +6222,7 @@ sparc_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Handle the TARGET_FUNCTION_INCOMING_ARG target hook.  */\n \n static rtx\n-sparc_function_incoming_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sparc_function_incoming_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     const_tree type, bool named)\n {\n   return sparc_function_arg_1 (cum, mode, type, named, true);\n@@ -6249,14 +6251,14 @@ sparc_function_arg_boundary (enum machine_mode mode, const_tree type)\n    mode] will be split between that reg and memory.  */\n \n static int\n-sparc_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+sparc_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t tree type, bool named)\n {\n   int slotno, regno, padding;\n \n   /* We pass false for incoming_p here, it doesn't matter.  */\n-  slotno = function_arg_slotno (cum, mode, type, named, false,\n-\t\t\t\t&regno, &padding);\n+  slotno = function_arg_slotno (get_cumulative_args (cum), mode, type, named,\n+\t\t\t\tfalse, &regno, &padding);\n \n   if (slotno == -1)\n     return 0;\n@@ -6307,7 +6309,7 @@ sparc_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    Specify whether to pass the argument by reference.  */\n \n static bool\n-sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+sparc_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode mode, const_tree type,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n@@ -6360,9 +6362,10 @@ sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    TYPE is null for libcalls where that information may not be available.  */\n \n static void\n-sparc_function_arg_advance (struct sparc_args *cum, enum machine_mode mode,\n+sparc_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int regno, padding;\n \n   /* We pass false for incoming_p here, it doesn't matter.  */"}, {"sha": "cb5cc24153972cb57ee1b681b620c3e968ac2803", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -55,9 +55,6 @@ extern int spu_constant_address_p (rtx x);\n extern bool spu_legitimate_constant_p (enum machine_mode, rtx);\n extern int spu_initial_elimination_offset (int from, int to);\n extern rtx spu_function_value (const_tree type, const_tree func);\n-extern void spu_setup_incoming_varargs (int *cum, enum machine_mode mode,\n-\t\t\t\t\ttree type, int *pretend_size,\n-\t\t\t\t\tint no_rtl);\n extern int spu_expand_mov (rtx * ops, enum machine_mode mode);\n extern int spu_split_load (rtx * ops);\n extern int spu_split_store (rtx * ops);"}, {"sha": "0da736c8be1d7ed73b3ca77d9b69df9e40c38d83", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -187,11 +187,13 @@ static tree spu_handle_vector_attribute (tree * node, tree name, tree args,\n \t\t\t\t\t int flags,\n \t\t\t\t\t bool *no_add_attrs);\n static int spu_naked_function_p (tree func);\n-static bool spu_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+static bool spu_pass_by_reference (cumulative_args_t cum,\n+\t\t\t\t   enum machine_mode mode,\n \t\t\t\t   const_tree type, bool named);\n-static rtx spu_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+static rtx spu_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     const_tree type, bool named);\n-static void spu_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+static void spu_function_arg_advance (cumulative_args_t cum,\n+\t\t\t\t      enum machine_mode mode,\n \t\t\t\t      const_tree type, bool named);\n static tree spu_build_builtin_va_list (void);\n static void spu_va_start (tree, rtx);\n@@ -412,6 +414,10 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_EXPAND_BUILTIN_VA_START\n #define TARGET_EXPAND_BUILTIN_VA_START spu_va_start\n \n+static void spu_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t\t\tenum machine_mode mode,\n+\t\t\t\t\ttree type, int *pretend_size,\n+\t\t\t\t\tint no_rtl);\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS spu_setup_incoming_varargs\n \n@@ -4039,10 +4045,11 @@ spu_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED)\n }\n \n static rtx\n-spu_function_arg (CUMULATIVE_ARGS *cum,\n+spu_function_arg (cumulative_args_t cum_v,\n \t\t  enum machine_mode mode,\n \t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int byte_size;\n \n   if (*cum >= MAX_REGISTER_ARGS)\n@@ -4075,9 +4082,11 @@ spu_function_arg (CUMULATIVE_ARGS *cum,\n }\n \n static void\n-spu_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+spu_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum += (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n \t   ? 1\n \t   : mode == BLKmode\n@@ -4089,7 +4098,7 @@ spu_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n \n /* Variable sized types are passed by reference.  */\n static bool\n-spu_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n+spu_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n@@ -4282,20 +4291,20 @@ spu_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n    to the first unnamed parameters.  If the first unnamed parameter is\n    in the stack then save no registers.  Set pretend_args_size to the\n    amount of space needed to save the registers. */\n-void\n-spu_setup_incoming_varargs (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+static void\n+spu_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t    tree type, int *pretend_size, int no_rtl)\n {\n   if (!no_rtl)\n     {\n       rtx tmp;\n       int regno;\n       int offset;\n-      int ncum = *cum;\n+      int ncum = *get_cumulative_args (cum);\n \n       /* cum currently points to the last named argument, we want to\n          start at the next argument. */\n-      spu_function_arg_advance (&ncum, mode, type, true);\n+      spu_function_arg_advance (pack_cumulative_args (&ncum), mode, type, true);\n \n       offset = -STACK_POINTER_OFFSET;\n       for (regno = ncum; regno < MAX_REGISTER_ARGS; regno++)"}, {"sha": "97965280cb96914b969225467ca20e7d52d38a08", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1201,9 +1201,11 @@ xstormy16_function_profiler (void)\n    the word count.  */\n \n static void\n-xstormy16_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+xstormy16_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   /* If an argument would otherwise be passed partially in registers,\n      and partially on the stack, the whole of it is passed on the\n      stack.  */\n@@ -1215,9 +1217,11 @@ xstormy16_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static rtx\n-xstormy16_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+xstormy16_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   if (mode == VOIDmode)\n     return const0_rtx;\n   if (targetm.calls.must_pass_in_stack (mode, type)"}, {"sha": "5074ebe417fe4177ced4a5218a709850ff53558e", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -77,7 +77,7 @@ static GTY(()) section * zbss_section;\n    Specify whether to pass the argument by reference.  */\n \n static bool\n-v850_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+v850_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -94,7 +94,7 @@ v850_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n /* Implementing the Varargs Macros.  */\n \n static bool\n-v850_strict_argument_naming (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED)\n+v850_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return !TARGET_GHS ? true : false;\n }\n@@ -104,9 +104,10 @@ v850_strict_argument_naming (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED)\n    is NULL_RTX, the argument will be pushed.  */\n \n static rtx\n-v850_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+v850_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   rtx result = NULL_RTX;\n   int size, align;\n \n@@ -165,9 +166,10 @@ v850_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n /* Return the number of bytes which must be put into registers\n    for values which are part in registers and part in memory.  */\n static int\n-v850_arg_partial_bytes (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+v850_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n                         tree type, bool named)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int size, align;\n \n   if (TARGET_GHS && !named)\n@@ -206,9 +208,11 @@ v850_arg_partial_bytes (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-v850_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+v850_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   cum->nbytes += (((type && int_size_in_bytes (type) > 8\n \t\t    ? GET_MODE_SIZE (Pmode)\n \t\t    : (mode != BLKmode\n@@ -2964,13 +2968,13 @@ v850_function_value (const_tree valtype,\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-v850_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n+v850_setup_incoming_varargs (cumulative_args_t ca,\n \t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     tree type ATTRIBUTE_UNUSED,\n \t\t\t     int *pretend_arg_size ATTRIBUTE_UNUSED,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n-  ca->anonymous_args = (!TARGET_GHS ? 1 : 0);\n+  get_cumulative_args (ca)->anonymous_args = (!TARGET_GHS ? 1 : 0);\n }\n \n /* Worker function for TARGET_CAN_ELIMINATE.  */"}, {"sha": "7c7070c901695cf6f6559bd9ea6800c01226a7f0", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -56,9 +56,9 @@ static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx, bool);\n static bool vax_rtx_costs (rtx, int, int, int *, bool);\n-static rtx vax_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx vax_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t     const_tree, bool);\n-static void vax_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void vax_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t      const_tree, bool);\n static rtx vax_struct_value_rtx (tree, int);\n static rtx vax_builtin_setjmp_frame_value (void);\n@@ -2106,7 +2106,7 @@ vax_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n /* On the VAX all args are pushed.  */\n \n static rtx\n-vax_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+vax_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  const_tree type ATTRIBUTE_UNUSED,\n \t\t  bool named ATTRIBUTE_UNUSED)\n@@ -2119,9 +2119,11 @@ vax_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    may not be available.)  */\n \n static void\n-vax_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+vax_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n   *cum += (mode != BLKmode\n \t   ? (GET_MODE_SIZE (mode) + 3) & ~3\n \t   : (int_size_in_bytes (type) + 3) & ~3);"}, {"sha": "ef246a0aeec2f8c11d955bcb3b068458872a0ccc", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -144,11 +144,11 @@ static tree xtensa_build_builtin_va_list (void);\n static bool xtensa_return_in_memory (const_tree, const_tree);\n static tree xtensa_gimplify_va_arg_expr (tree, tree, gimple_seq *,\n \t\t\t\t\t gimple_seq *);\n-static void xtensa_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+static void xtensa_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t\t const_tree, bool);\n-static rtx xtensa_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+static rtx xtensa_function_arg (cumulative_args_t, enum machine_mode,\n \t\t\t\tconst_tree, bool);\n-static rtx xtensa_function_incoming_arg (CUMULATIVE_ARGS *,\n+static rtx xtensa_function_incoming_arg (cumulative_args_t,\n \t\t\t\t\t enum machine_mode, const_tree, bool);\n static rtx xtensa_function_value (const_tree, const_tree, bool);\n static rtx xtensa_libcall_value (enum machine_mode, const_rtx);\n@@ -2061,13 +2061,13 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, int incoming)\n /* Advance the argument to the next argument position.  */\n \n static void\n-xtensa_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+xtensa_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t     const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   int words, max;\n   int *arg_words;\n \n-  arg_words = &cum->arg_words;\n+  arg_words = &get_cumulative_args (cum)->arg_words;\n   max = MAX_ARGS_IN_REGISTERS;\n \n   words = (((mode != BLKmode)\n@@ -2088,9 +2088,10 @@ xtensa_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    if this is an incoming argument to the current function.  */\n \n static rtx\n-xtensa_function_arg_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+xtensa_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t       const_tree type, bool incoming_p)\n {\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int regbase, words, max;\n   int *arg_words;\n   int regno;\n@@ -2123,7 +2124,7 @@ xtensa_function_arg_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-xtensa_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+xtensa_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t     const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   return xtensa_function_arg_1 (cum, mode, type, false);\n@@ -2132,7 +2133,7 @@ xtensa_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Implement TARGET_FUNCTION_INCOMING_ARG.  */\n \n static rtx\n-xtensa_function_incoming_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+xtensa_function_incoming_arg (cumulative_args_t cum, enum machine_mode mode,\n \t\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   return xtensa_function_arg_1 (cum, mode, type, true);"}, {"sha": "fec5d55df246cbcdc9e6f3e24904e85ac8af65ad", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -3968,7 +3968,7 @@ This section describes the macros which let you control how various\n types of arguments are passed in registers or how they are arranged in\n the stack.\n \n-@deftypefn {Target Hook} rtx TARGET_FUNCTION_ARG (CUMULATIVE_ARGS *@var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_ARG (cumulative_args_t @var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n Return an RTX indicating whether a function argument is passed in a\n register and if so, which register.\n \n@@ -4028,7 +4028,7 @@ definition that is usually appropriate, refer to @file{expr.h} for additional\n documentation.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_FUNCTION_INCOMING_ARG (CUMULATIVE_ARGS *@var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_INCOMING_ARG (cumulative_args_t @var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n Define this hook if the target machine has ``register windows'', so\n that the register in which a function sees an arguments is not\n necessarily the same as the one in which the caller passed the\n@@ -4044,7 +4044,7 @@ If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\n @code{TARGET_FUNCTION_ARG} serves both purposes.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (cumulative_args_t @var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n This target hook returns the number of bytes at the beginning of an\n argument that must be put in registers.  The value must be zero for\n arguments that are passed entirely in registers or that are entirely\n@@ -4063,7 +4063,7 @@ register to be used by the caller for this argument; likewise\n @code{TARGET_FUNCTION_INCOMING_ARG}, for the called function.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (cumulative_args_t @var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n This target hook should return @code{true} if an argument at the\n position indicated by @var{cum} should be passed by reference.  This\n predicate is queried after target independent reasons for being\n@@ -4075,7 +4075,7 @@ The pointer is passed in whatever way is appropriate for passing a pointer\n to that type.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (cumulative_args_t @var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n The function argument described by the parameters to this hook is\n known to be passed by reference.  The hook should return true if the\n function argument should be copied by the callee instead of copied\n@@ -4154,7 +4154,7 @@ argument @var{libname} exists for symmetry with\n @c --mew 5feb93   i switched the order of the sentences.  --mew 10feb93\n @end defmac\n \n-@deftypefn {Target Hook} void TARGET_FUNCTION_ARG_ADVANCE (CUMULATIVE_ARGS *@var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} void TARGET_FUNCTION_ARG_ADVANCE (cumulative_args_t @var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n This hook updates the summarizer variable pointed to by @var{ca} to\n advance past an argument in the argument list.  The values @var{mode},\n @var{type} and @var{named} describe that argument.  Once this is done,\n@@ -5045,7 +5045,7 @@ return value of this function should be an RTX that contains the value\n to use as the return of @code{__builtin_saveregs}.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (CUMULATIVE_ARGS *@var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n+@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (cumulative_args_t @var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n This target hook offers an alternative to using\n @code{__builtin_saveregs} and defining the hook\n @code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  Use it to store the anonymous\n@@ -5079,7 +5079,7 @@ end of the source file.  The hook @code{TARGET_SETUP_INCOMING_VARARGS} should\n not generate any instructions in this case.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_STRICT_ARGUMENT_NAMING (CUMULATIVE_ARGS *@var{ca})\n+@deftypefn {Target Hook} bool TARGET_STRICT_ARGUMENT_NAMING (cumulative_args_t @var{ca})\n Define this hook to return @code{true} if the location where a function\n argument is passed depends on whether or not it is a named argument.\n \n@@ -5094,7 +5094,7 @@ except the last are treated as named.\n You need not define this hook if it always returns @code{false}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED (CUMULATIVE_ARGS *@var{ca})\n+@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED (cumulative_args_t @var{ca})\n If you need to conditionally change ABIs so that one works with\n @code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither\n @code{TARGET_SETUP_INCOMING_VARARGS} nor @code{TARGET_STRICT_ARGUMENT_NAMING} was"}, {"sha": "3646b0420e3509b8a17ee9ca2bdeb9ed4c192b3a", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -2321,11 +2321,13 @@ check_mem_read_use (rtx *loc, void *data)\n static bool\n get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n {\n-  CUMULATIVE_ARGS args_so_far;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n   tree arg;\n   int idx;\n \n-  INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (fn), NULL_RTX, 0, 3);\n+  INIT_CUMULATIVE_ARGS (args_so_far_v, TREE_TYPE (fn), NULL_RTX, 0, 3);\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n \n   arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   for (idx = 0;\n@@ -2334,7 +2336,7 @@ get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n     {\n       enum machine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n       rtx reg, link, tmp;\n-      reg = targetm.calls.function_arg (&args_so_far, mode, NULL_TREE, true);\n+      reg = targetm.calls.function_arg (args_so_far, mode, NULL_TREE, true);\n       if (!reg || !REG_P (reg) || GET_MODE (reg) != mode\n \t  || GET_MODE_CLASS (mode) != MODE_INT)\n \treturn false;\n@@ -2368,7 +2370,7 @@ get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n       if (tmp)\n \targs[idx] = tmp;\n \n-      targetm.calls.function_arg_advance (&args_so_far, mode, NULL_TREE, true);\n+      targetm.calls.function_arg_advance (args_so_far, mode, NULL_TREE, true);\n     }\n   if (arg != void_list_node || idx != nargs)\n     return false;"}, {"sha": "bb6e3f14a8a1ff02b467de58881dcf71d2c38058", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1228,23 +1228,25 @@ block_move_libcall_safe_for_call_parm (void)\n   /* If any argument goes in memory, then it might clobber an outgoing\n      argument.  */\n   {\n-    CUMULATIVE_ARGS args_so_far;\n+    CUMULATIVE_ARGS args_so_far_v;\n+    cumulative_args_t args_so_far;\n     tree fn, arg;\n \n     fn = emit_block_move_libcall_fn (false);\n-    INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (fn), NULL_RTX, 0, 3);\n+    INIT_CUMULATIVE_ARGS (args_so_far_v, TREE_TYPE (fn), NULL_RTX, 0, 3);\n+    args_so_far = pack_cumulative_args (&args_so_far_v);\n \n     arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n     for ( ; arg != void_list_node ; arg = TREE_CHAIN (arg))\n       {\n \tenum machine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n-\trtx tmp = targetm.calls.function_arg (&args_so_far, mode,\n+\trtx tmp = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t      NULL_TREE, true);\n \tif (!tmp || !REG_P (tmp))\n \t  return false;\n-\tif (targetm.calls.arg_partial_bytes (&args_so_far, mode, NULL, 1))\n+\tif (targetm.calls.arg_partial_bytes (args_so_far, mode, NULL, 1))\n \t  return false;\n-\ttargetm.calls.function_arg_advance (&args_so_far, mode,\n+\ttargetm.calls.function_arg_advance (args_so_far, mode,\n \t\t\t\t\t    NULL_TREE, true);\n       }\n   }"}, {"sha": "5be018afde77097d73df972a3f56262f6c9e8440", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -2128,7 +2128,8 @@ pass_by_reference (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n \t}\n     }\n \n-  return targetm.calls.pass_by_reference (ca, mode, type, named_arg);\n+  return targetm.calls.pass_by_reference (pack_cumulative_args (ca), mode,\n+\t\t\t\t\t  type, named_arg);\n }\n \n /* Return true if TYPE, which is passed by reference, should be callee\n@@ -2140,7 +2141,8 @@ reference_callee_copied (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n {\n   if (type && TREE_ADDRESSABLE (type))\n     return false;\n-  return targetm.calls.callee_copies (ca, mode, type, named_arg);\n+  return targetm.calls.callee_copies (pack_cumulative_args (ca), mode, type,\n+\t\t\t\t      named_arg);\n }\n \n /* Structures to communicate between the subroutines of assign_parms.\n@@ -2149,7 +2151,10 @@ reference_callee_copied (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n \n struct assign_parm_data_all\n {\n-  CUMULATIVE_ARGS args_so_far;\n+  /* When INIT_CUMULATIVE_ARGS gets revamped, allocating CUMULATIVE_ARGS\n+     should become a job of the target or otherwise encapsulated.  */\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n   struct args_size stack_args_size;\n   tree function_result_decl;\n   tree orig_fnargs;\n@@ -2189,11 +2194,12 @@ assign_parms_initialize_all (struct assign_parm_data_all *all)\n   fntype = TREE_TYPE (current_function_decl);\n \n #ifdef INIT_CUMULATIVE_INCOMING_ARGS\n-  INIT_CUMULATIVE_INCOMING_ARGS (all->args_so_far, fntype, NULL_RTX);\n+  INIT_CUMULATIVE_INCOMING_ARGS (all->args_so_far_v, fntype, NULL_RTX);\n #else\n-  INIT_CUMULATIVE_ARGS (all->args_so_far, fntype, NULL_RTX,\n+  INIT_CUMULATIVE_ARGS (all->args_so_far_v, fntype, NULL_RTX,\n \t\t\tcurrent_function_decl, -1);\n #endif\n+  all->args_so_far = pack_cumulative_args (&all->args_so_far_v);\n \n #ifdef REG_PARM_STACK_SPACE\n   all->reg_parm_stack_space = REG_PARM_STACK_SPACE (current_function_decl);\n@@ -2314,7 +2320,7 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n     data->named_arg = 1;  /* No variadic parms.  */\n   else if (DECL_CHAIN (parm))\n     data->named_arg = 1;  /* Not the last non-variadic parm. */\n-  else if (targetm.calls.strict_argument_naming (&all->args_so_far))\n+  else if (targetm.calls.strict_argument_naming (all->args_so_far))\n     data->named_arg = 1;  /* Only variadic ones are unnamed.  */\n   else\n     data->named_arg = 0;  /* Treat as variadic.  */\n@@ -2350,7 +2356,7 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n     passed_type = TREE_TYPE (first_field (passed_type));\n \n   /* See if this arg was passed by invisible reference.  */\n-  if (pass_by_reference (&all->args_so_far, passed_mode,\n+  if (pass_by_reference (&all->args_so_far_v, passed_mode,\n \t\t\t passed_type, data->named_arg))\n     {\n       passed_type = nominal_type = build_pointer_type (passed_type);\n@@ -2379,7 +2385,7 @@ assign_parms_setup_varargs (struct assign_parm_data_all *all,\n {\n   int varargs_pretend_bytes = 0;\n \n-  targetm.calls.setup_incoming_varargs (&all->args_so_far,\n+  targetm.calls.setup_incoming_varargs (all->args_so_far,\n \t\t\t\t\tdata->promoted_mode,\n \t\t\t\t\tdata->passed_type,\n \t\t\t\t\t&varargs_pretend_bytes, no_rtl);\n@@ -2408,7 +2414,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n       return;\n     }\n \n-  entry_parm = targetm.calls.function_incoming_arg (&all->args_so_far,\n+  entry_parm = targetm.calls.function_incoming_arg (all->args_so_far,\n \t\t\t\t\t\t    data->promoted_mode,\n \t\t\t\t\t\t    data->passed_type,\n \t\t\t\t\t\t    data->named_arg);\n@@ -2432,10 +2438,10 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n #endif\n   if (!in_regs && !data->named_arg)\n     {\n-      if (targetm.calls.pretend_outgoing_varargs_named (&all->args_so_far))\n+      if (targetm.calls.pretend_outgoing_varargs_named (all->args_so_far))\n \t{\n \t  rtx tem;\n-\t  tem = targetm.calls.function_incoming_arg (&all->args_so_far,\n+\t  tem = targetm.calls.function_incoming_arg (all->args_so_far,\n \t\t\t\t\t\t     data->promoted_mode,\n \t\t\t\t\t\t     data->passed_type, true);\n \t  in_regs = tem != NULL;\n@@ -2452,7 +2458,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n     {\n       int partial;\n \n-      partial = targetm.calls.arg_partial_bytes (&all->args_so_far,\n+      partial = targetm.calls.arg_partial_bytes (all->args_so_far,\n \t\t\t\t\t\t data->promoted_mode,\n \t\t\t\t\t\t data->passed_type,\n \t\t\t\t\t\t data->named_arg);\n@@ -3388,7 +3394,7 @@ assign_parms (tree fndecl)\n \tset_decl_incoming_rtl (parm, data.entry_parm, false);\n \n       /* Update info on where next arg arrives in registers.  */\n-      targetm.calls.function_arg_advance (&all.args_so_far, data.promoted_mode,\n+      targetm.calls.function_arg_advance (all.args_so_far, data.promoted_mode,\n \t\t\t\t\t  data.passed_type, data.named_arg);\n \n       assign_parm_adjust_stack_rtl (&data);\n@@ -3498,7 +3504,7 @@ assign_parms (tree fndecl)\n   /* For stdarg.h function, save info about\n      regs and stack space used by the named args.  */\n \n-  crtl->args.info = all.args_so_far;\n+  crtl->args.info = all.args_so_far_v;\n \n   /* Set the rtx used for the function return value.  Put this in its\n      own variable so any optimizers that need this information don't have\n@@ -3587,7 +3593,7 @@ gimplify_parameters (void)\n \tcontinue;\n \n       /* Update info on where next arg arrives in registers.  */\n-      targetm.calls.function_arg_advance (&all.args_so_far, data.promoted_mode,\n+      targetm.calls.function_arg_advance (all.args_so_far, data.promoted_mode,\n \t\t\t\t\t  data.passed_type, data.named_arg);\n \n       /* ??? Once upon a time variable_size stuffed parameter list\n@@ -3606,7 +3612,7 @@ gimplify_parameters (void)\n       if (data.passed_pointer)\n \t{\n           tree type = TREE_TYPE (data.passed_type);\n-\t  if (reference_callee_copied (&all.args_so_far, TYPE_MODE (type),\n+\t  if (reference_callee_copied (&all.args_so_far_v, TYPE_MODE (type),\n \t\t\t\t       type, data.named_arg))\n \t    {\n \t      tree local, t;"}, {"sha": "94c434ff360a5eca2edfa3f87dbe1f6dd5d87256", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1924,7 +1924,7 @@ DEFHOOK\n (pass_by_reference,\n  \"\",\n  bool,\n- (CUMULATIVE_ARGS *cum, enum machine_mode mode, const_tree type, bool named),\n+ (cumulative_args_t cum, enum machine_mode mode, const_tree type, bool named),\n  hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false)\n \n DEFHOOK\n@@ -1937,14 +1937,14 @@ DEFHOOK\n DEFHOOK\n (setup_incoming_varargs,\n  \"\",\n- void, (CUMULATIVE_ARGS *args_so_far, enum machine_mode mode, tree type,\n+ void, (cumulative_args_t args_so_far, enum machine_mode mode, tree type,\n \tint *pretend_args_size, int second_time),\n  default_setup_incoming_varargs)\n \n DEFHOOK\n (strict_argument_naming,\n  \"\",\n- bool, (CUMULATIVE_ARGS *ca),\n+ bool, (cumulative_args_t ca),\n  hook_bool_CUMULATIVE_ARGS_false)\n \n /* Returns true if we should use\n@@ -1953,7 +1953,7 @@ DEFHOOK\n DEFHOOK\n (pretend_outgoing_varargs_named,\n  \"\",\n- bool, (CUMULATIVE_ARGS *ca),\n+ bool, (cumulative_args_t ca),\n  default_pretend_outgoing_varargs_named)\n \n /* Given a complex type T, return true if a parameter of type T\n@@ -1980,7 +1980,7 @@ DEFHOOK\n (callee_copies,\n  \"\",\n  bool,\n- (CUMULATIVE_ARGS *cum, enum machine_mode mode, const_tree type, bool named),\n+ (cumulative_args_t cum, enum machine_mode mode, const_tree type, bool named),\n  hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false)\n \n /* Return zero for arguments passed entirely on the stack or entirely\n@@ -1989,7 +1989,7 @@ DEFHOOK\n DEFHOOK\n (arg_partial_bytes,\n  \"\",\n- int, (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named),\n+ int, (cumulative_args_t cum, enum machine_mode mode, tree type, bool named),\n  hook_int_CUMULATIVE_ARGS_mode_tree_bool_0)\n \n /* Update the state in CA to advance past an argument in the\n@@ -1999,7 +1999,7 @@ DEFHOOK\n (function_arg_advance,\n  \"\",\n  void,\n- (CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type, bool named),\n+ (cumulative_args_t ca, enum machine_mode mode, const_tree type, bool named),\n  default_function_arg_advance)\n \n /* Return zero if the argument described by the state of CA should\n@@ -2009,7 +2009,7 @@ DEFHOOK\n DEFHOOK\n (function_arg,\n  \"\",\n- rtx, (CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type,\n+ rtx, (cumulative_args_t ca, enum machine_mode mode, const_tree type,\n        bool named),\n  default_function_arg)\n \n@@ -2018,7 +2018,7 @@ DEFHOOK\n DEFHOOK\n (function_incoming_arg,\n  \"\",\n- rtx, (CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type,\n+ rtx, (cumulative_args_t ca, enum machine_mode mode, const_tree type,\n        bool named),\n  default_function_incoming_arg)\n "}, {"sha": "12fd9b085a0da0e43251f5f51b5fba821093db5e", "filename": "gcc/target.h", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -1,5 +1,6 @@\n /* Data structure definitions for a generic GCC target.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011\n    Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify it\n@@ -49,9 +50,24 @@\n #ifndef GCC_TARGET_H\n #define GCC_TARGET_H\n \n-#include \"tm.h\"\n #include \"insn-modes.h\"\n \n+#ifdef ENABLE_CHECKING\n+\n+typedef struct { void *magic; void *p; } cumulative_args_t;\n+\n+#else /* !ENABLE_CHECKING */\n+\n+/* When using a GCC build compiler, we could use\n+   __attribute__((transparent_union)) to get cumulative_args_t function\n+   arguments passed like scalars where the ABI would mandate a less\n+   efficient way of argument passing otherwise.  However, that would come\n+   at the cost of less type-safe !ENABLE_CHECKING compilation.  */\n+\n+typedef union { void *p; } cumulative_args_t;\n+\n+#endif /* !ENABLE_CHECKING */\n+\n /* Types used by the record_gcc_switches() target function.  */\n typedef enum\n {\n@@ -141,4 +157,32 @@ enum vect_cost_for_stmt\n \n extern struct gcc_target targetm;\n \n+#ifdef GCC_TM_H\n+\n+#ifndef CUMULATIVE_ARGS_MAGIC\n+#define CUMULATIVE_ARGS_MAGIC ((void *) &targetm.calls)\n+#endif\n+\n+static inline CUMULATIVE_ARGS *\n+get_cumulative_args (cumulative_args_t arg)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (arg.magic == CUMULATIVE_ARGS_MAGIC);\n+#endif /* ENABLE_CHECKING */\n+  return (CUMULATIVE_ARGS *) arg.p;\n+}\n+\n+static inline cumulative_args_t\n+pack_cumulative_args (CUMULATIVE_ARGS *arg)\n+{\n+  cumulative_args_t ret;\n+\n+#ifdef ENABLE_CHECKING\n+  ret.magic = CUMULATIVE_ARGS_MAGIC;\n+#endif /* ENABLE_CHECKING */\n+  ret.p = (void *) arg;\n+  return ret;\n+}\n+#endif /* GCC_TM_H */\n+\n #endif /* GCC_TARGET_H */"}, {"sha": "bcb8a12bc4e35afd0f40ee1f6357d96ce5cf0f86", "filename": "gcc/targhooks.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -170,7 +170,7 @@ default_expand_builtin_saveregs (void)\n }\n \n void\n-default_setup_incoming_varargs (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+default_setup_incoming_varargs (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\ttree type ATTRIBUTE_UNUSED,\n \t\t\t\tint *pretend_arg_size ATTRIBUTE_UNUSED,\n@@ -189,13 +189,13 @@ default_builtin_setjmp_frame_value (void)\n /* Generic hook that takes a CUMULATIVE_ARGS pointer and returns false.  */\n \n bool\n-hook_bool_CUMULATIVE_ARGS_false (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+hook_bool_CUMULATIVE_ARGS_false (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n bool\n-default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+default_pretend_outgoing_varargs_named (cumulative_args_t ca ATTRIBUTE_UNUSED)\n {\n   return (targetm.calls.setup_incoming_varargs\n \t  != default_setup_incoming_varargs);\n@@ -253,7 +253,7 @@ default_mode_rep_extended (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */\n \n bool\n-hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS * a ATTRIBUTE_UNUSED)\n+hook_bool_CUMULATIVE_ARGS_true (cumulative_args_t a ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n@@ -302,7 +302,7 @@ default_cxx_get_cookie_size (tree type)\n    of the TARGET_PASS_BY_REFERENCE hook uses just MUST_PASS_IN_STACK.  */\n \n bool\n-hook_pass_by_reference_must_pass_in_stack (CUMULATIVE_ARGS *c ATTRIBUTE_UNUSED,\n+hook_pass_by_reference_must_pass_in_stack (cumulative_args_t c ATTRIBUTE_UNUSED,\n \tenum machine_mode mode ATTRIBUTE_UNUSED, const_tree type ATTRIBUTE_UNUSED,\n \tbool named_arg ATTRIBUTE_UNUSED)\n {\n@@ -313,7 +313,7 @@ hook_pass_by_reference_must_pass_in_stack (CUMULATIVE_ARGS *c ATTRIBUTE_UNUSED,\n    version of the hook is true for all named arguments.  */\n \n bool\n-hook_callee_copies_named (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+hook_callee_copies_named (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type ATTRIBUTE_UNUSED, bool named)\n {\n@@ -555,7 +555,7 @@ default_builtin_reciprocal (unsigned int fn ATTRIBUTE_UNUSED,\n \n bool\n hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n-\tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\tcumulative_args_t ca ATTRIBUTE_UNUSED,\n \tenum machine_mode mode ATTRIBUTE_UNUSED,\n \tconst_tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n@@ -564,7 +564,7 @@ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n \n bool\n hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true (\n-\tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\tcumulative_args_t ca ATTRIBUTE_UNUSED,\n \tenum machine_mode mode ATTRIBUTE_UNUSED,\n \tconst_tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n@@ -573,15 +573,15 @@ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true (\n \n int\n hook_int_CUMULATIVE_ARGS_mode_tree_bool_0 (\n-\tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\tcumulative_args_t ca ATTRIBUTE_UNUSED,\n \tenum machine_mode mode ATTRIBUTE_UNUSED,\n \ttree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n void\n-default_function_arg_advance (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+default_function_arg_advance (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t      const_tree type ATTRIBUTE_UNUSED,\n \t\t\t      bool named ATTRIBUTE_UNUSED)\n@@ -590,7 +590,7 @@ default_function_arg_advance (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n }\n \n rtx\n-default_function_arg (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+default_function_arg (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      const_tree type ATTRIBUTE_UNUSED,\n \t\t      bool named ATTRIBUTE_UNUSED)\n@@ -599,7 +599,7 @@ default_function_arg (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n }\n \n rtx\n-default_function_incoming_arg (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+default_function_incoming_arg (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       const_tree type ATTRIBUTE_UNUSED,\n \t\t\t       bool named ATTRIBUTE_UNUSED)"}, {"sha": "ce89d32afca7814733be64a6a9f2cb3b27894873", "filename": "gcc/targhooks.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -35,9 +35,9 @@ extern enum machine_mode default_cc_modes_compatible (enum machine_mode,\n extern bool default_return_in_memory (const_tree, const_tree);\n \n extern rtx default_expand_builtin_saveregs (void);\n-extern void default_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n+extern void default_setup_incoming_varargs (cumulative_args_t, enum machine_mode, tree, int *, int);\n extern rtx default_builtin_setjmp_frame_value (void);\n-extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n+extern bool default_pretend_outgoing_varargs_named (cumulative_args_t);\n \n extern enum machine_mode default_eh_return_filter_mode (void);\n extern enum machine_mode default_libgcc_cmp_return_mode (void);\n@@ -58,9 +58,9 @@ extern tree default_cxx_guard_type (void);\n extern tree default_cxx_get_cookie_size (tree);\n \n extern bool hook_pass_by_reference_must_pass_in_stack\n-  (CUMULATIVE_ARGS *, enum machine_mode mode, const_tree, bool);\n+  (cumulative_args_t, enum machine_mode mode, const_tree, bool);\n extern bool hook_callee_copies_named\n-  (CUMULATIVE_ARGS *ca, enum machine_mode, const_tree, bool);\n+  (cumulative_args_t ca, enum machine_mode, const_tree, bool);\n \n extern void default_print_operand (FILE *, rtx, int);\n extern void default_print_operand_address (FILE *, rtx);\n@@ -96,23 +96,23 @@ extern unsigned int default_autovectorize_vector_sizes (void);\n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */\n \n-extern bool hook_bool_CUMULATIVE_ARGS_false (CUMULATIVE_ARGS *);\n-extern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\n+extern bool hook_bool_CUMULATIVE_ARGS_false (cumulative_args_t);\n+extern bool hook_bool_CUMULATIVE_ARGS_true (cumulative_args_t);\n \n extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n-  (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);\n+  (cumulative_args_t, enum machine_mode, const_tree, bool);\n extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n-  (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);\n+  (cumulative_args_t, enum machine_mode, const_tree, bool);\n extern int hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n-  (CUMULATIVE_ARGS *, enum machine_mode, tree, bool);\n+  (cumulative_args_t, enum machine_mode, tree, bool);\n extern const char *hook_invalid_arg_for_unprototyped_fn\n   (const_tree, const_tree, const_tree);\n extern void default_function_arg_advance\n-  (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);\n+  (cumulative_args_t, enum machine_mode, const_tree, bool);\n extern rtx default_function_arg\n-  (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);\n+  (cumulative_args_t, enum machine_mode, const_tree, bool);\n extern rtx default_function_incoming_arg\n-  (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);\n+  (cumulative_args_t, enum machine_mode, const_tree, bool);\n extern unsigned int default_function_arg_boundary (enum machine_mode,\n \t\t\t\t\t\t   const_tree);\n extern bool hook_bool_const_rtx_commutative_p (const_rtx, int);"}, {"sha": "a8574d21c300cbc7a02b8ccfd350b75353e885cc", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5cc91810ebf8ece752df538e9adf482985d7b1d/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d5cc91810ebf8ece752df538e9adf482985d7b1d", "patch": "@@ -5589,9 +5589,11 @@ prepare_call_arguments (basic_block bb, rtx insn)\n   rtx this_arg = NULL_RTX;\n   tree type = NULL_TREE, t, fndecl = NULL_TREE;\n   tree obj_type_ref = NULL_TREE;\n-  CUMULATIVE_ARGS args_so_far;\n+  CUMULATIVE_ARGS args_so_far_v;\n+  cumulative_args_t args_so_far;\n \n-  memset (&args_so_far, 0, sizeof (args_so_far));\n+  memset (&args_so_far_v, 0, sizeof (args_so_far_v));\n+  args_so_far = pack_cumulative_args (&args_so_far_v);\n   if (GET_CODE (call) == PARALLEL)\n     call = XVECEXP (call, 0, 0);\n   if (GET_CODE (call) == SET)\n@@ -5639,11 +5641,11 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t\t  tree struct_addr = build_pointer_type (TREE_TYPE (type));\n \t\t  enum machine_mode mode = TYPE_MODE (struct_addr);\n \t\t  rtx reg;\n-\t\t  INIT_CUMULATIVE_ARGS (args_so_far, type, NULL_RTX, fndecl,\n+\t\t  INIT_CUMULATIVE_ARGS (args_so_far_v, type, NULL_RTX, fndecl,\n \t\t\t\t\tnargs + 1);\n-\t\t  reg = targetm.calls.function_arg (&args_so_far, mode,\n+\t\t  reg = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t\t    struct_addr, true);\n-\t\t  targetm.calls.function_arg_advance (&args_so_far, mode,\n+\t\t  targetm.calls.function_arg_advance (args_so_far, mode,\n \t\t\t\t\t\t      struct_addr, true);\n \t\t  if (reg == NULL_RTX)\n \t\t    {\n@@ -5658,14 +5660,14 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t\t}\n \t      else\n #endif\n-\t\tINIT_CUMULATIVE_ARGS (args_so_far, type, NULL_RTX, fndecl,\n+\t\tINIT_CUMULATIVE_ARGS (args_so_far_v, type, NULL_RTX, fndecl,\n \t\t\t\t      nargs);\n \t      if (obj_type_ref && TYPE_ARG_TYPES (type) != void_list_node)\n \t\t{\n \t\t  enum machine_mode mode;\n \t\t  t = TYPE_ARG_TYPES (type);\n \t\t  mode = TYPE_MODE (TREE_VALUE (t));\n-\t\t  this_arg = targetm.calls.function_arg (&args_so_far, mode,\n+\t\t  this_arg = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t\t\t TREE_VALUE (t), true);\n \t\t  if (this_arg && !REG_P (this_arg))\n \t\t    this_arg = NULL_RTX;\n@@ -5745,12 +5747,12 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t    tree argtype = TREE_VALUE (t);\n \t    enum machine_mode mode = TYPE_MODE (argtype);\n \t    rtx reg;\n-\t    if (pass_by_reference (&args_so_far, mode, argtype, true))\n+\t    if (pass_by_reference (&args_so_far_v, mode, argtype, true))\n \t      {\n \t\targtype = build_pointer_type (argtype);\n \t\tmode = TYPE_MODE (argtype);\n \t      }\n-\t    reg = targetm.calls.function_arg (&args_so_far, mode,\n+\t    reg = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t      argtype, true);\n \t    if (TREE_CODE (argtype) == REFERENCE_TYPE\n \t\t&& INTEGRAL_TYPE_P (TREE_TYPE (argtype))\n@@ -5804,7 +5806,7 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t\t\t}\n \t\t  }\n \t      }\n-\t    targetm.calls.function_arg_advance (&args_so_far, mode,\n+\t    targetm.calls.function_arg_advance (args_so_far, mode,\n \t\t\t\t\t\targtype, true);\n \t    t = TREE_CHAIN (t);\n \t  }"}]}