{"sha": "9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3OTM3Y2Y4YTA2YzJkMDVkYzFhNWYzNTdlZjgxOGYwYzczNmNmYQ==", "commit": {"author": {"name": "Robert Suchanek", "email": "robert.suchanek@imgtec.com", "date": "2016-07-26T13:20:03Z"}, "committer": {"name": "Robert Suchanek", "email": "rts@gcc.gnu.org", "date": "2016-07-26T13:20:03Z"}, "message": "Add support to run auto-vectorization tests for multiple effective targets.\n\ngcc/testsuite/\n\n\t* g++.dg/vect/vect.exp: Add and set new global EFFECTIVE_TARGETS. Call\n\tg++-dg-runtest via et-dg-runtest.\n\t* gcc.dg/graphite/graphite.exp: Likewise, but for dg-runtest.\n\t* gcc.dg/vect/vect.exp: Likewise.\n\t* gfortran.dg/graphite/graphite.exp: Likewise, but for\n\tgfortran-dg-runtest.\n\t* gfortran.dg/vect/vect.exp: Likewise.\n\t* lib/target-supports.exp (check_mpaired_single_hw_available): New.\n\t(check_mips_loongson_hw_available): Likewise.\n\t(check_effective_target_mpaired_single_runtime): Likewise.\n\t(check_effective_target_mips_loongson_runtime): Likewise.\n\t(add_options_for_mpaired_single): Likewise.\n\t(check_effective_target_vect_int): Add global et_index.\n\tCheck and save the supported feature for a target selected by\n\tthe et_index target.  Break long lines where appropriate.  Call\n\tet-is-effective-target for MIPS with an argument instead of\n\tcheck_effective_target_* where appropriate.\n\t(check_effective_target_vect_intfloat_cvt): Likewise.\n\t(check_effective_target_vect_uintfloat_cvt): Likewise.\n\t(check_effective_target_vect_floatint_cvt): Likewise.\n\t(check_effective_target_vect_floatuint_cvt): Likewise.\n\t(check_effective_target_vect_simd_clones): Likewise.\n\t(check_effective_target_vect_shift): ewise.\n\t(check_effective_target_whole_vector_shift): Likewise.\n\t(check_effective_target_vect_bswap): Likewise.\n\t(check_effective_target_vect_shift_char): Likewise.\n\t(check_effective_target_vect_long): Likewise.\n\t(check_effective_target_vect_float): Likewise.\n\t(check_effective_target_vect_double): Likewise.\n\t(check_effective_target_vect_long_long): Likewise.\n\t(check_effective_target_vect_no_int_max): Likewise.\n\t(check_effective_target_vect_no_int_add): Likewise.\n\t(check_effective_target_vect_no_bitwise): Likewise.\n\t(check_effective_target_vect_widen_shift): Likewise.\n\t(check_effective_target_vect_no_align): Likewise.\n\t(check_effective_target_vect_hw_misalign): Likewise.\n\t(check_effective_target_vect_element_align): Likewise.\n\t(check_effective_target_vect_condition): Likewise.\n\t(check_effective_target_vect_cond_mixed): Likewise.\n\t(check_effective_target_vect_char_mult): Likewise.\n\t(check_effective_target_vect_short_mult): Likewise.\n\t(check_effective_target_vect_int_mult): Likewise.\n\t(check_effective_target_vect_extract_even_odd): Likewise.\n\t(check_effective_target_vect_interleave): Likewise.\n\t(check_effective_target_vect_stridedN): Likewise.\n\t(check_effective_target_vect_multiple_sizes): Likewise.\n\t(check_effective_target_vect64): Likewise.\n\t(check_effective_target_vect_call_copysignf): Likewise.\n\t(check_effective_target_vect_call_sqrtf): Likewise.\n\t(check_effective_target_vect_call_btrunc): Likewise.\n\t(check_effective_target_vect_call_btruncf): Likewise.\n\t(check_effective_target_vect_call_ceil): Likewise.\n\t(check_effective_target_vect_call_ceilf): Likewise.\n\t(check_effective_target_vect_call_floor): Likewise.\n\t(check_effective_target_vect_call_floorf): Likewise.\n\t(check_effective_target_vect_call_lceil): Likewise.\n\t(check_effective_target_vect_call_lfloor): Likewise.\n\t(check_effective_target_vect_call_nearbyint): Likewise.\n\t(check_effective_target_vect_call_nearbyintf): Likewise.\n\t(check_effective_target_vect_call_round): Likewise.\n\t(check_effective_target_vect_call_roundf): Likewise.\n\t(check_effective_target_vect_perm): Likewise, but also append *_saved\n\tto the existing global name to properly cache the result.\n\t(check_effective_target_vect_perm_byte): Likewise.\n\t(check_effective_target_vect_perm_short): Likewise.\n\t(check_effective_target_vect_widen_sum_hi_to_si_pattern): Likewise.\n\t(check_effective_target_vect_widen_sum_hi_to_si): Likewise.\n\t(check_effective_target_vect_widen_sum_qi_to_hi): Likewise.\n\t(check_effective_target_vect_widen_sum_qi_to_si): Likewise.\n\t(check_effective_target_vect_widen_mult_qi_to_hi_pattern): Likewise.\n\t(check_effective_target_vect_widen_mult_qi_to_hi): Likewise.\n\t(check_effective_target_vect_widen_mult_hi_to_si_pattern): Likewise.\n\t(check_effective_target_vect_widen_mult_si_to_di_pattern): Likewise.\n\t(check_effective_target_vect_sdot_qi): Likewise.\n\t(check_effective_target_vect_udot_qi): Likewise.\n\t(check_effective_target_vect_sdot_hi): Likewise.\n\t(check_effective_target_vect_udot_hi): Likewise.\n\t(check_effective_target_vect_usad_char): Likewise.\n\t(check_effective_target_vect_pack_trunc): Likewise.\n\t(check_effective_target_vect_unpack): Likewise.\n\t(check_effective_target_vect_aligned_arrays): Likewise.\n\t(check_effective_target_vect_natural_alignment): Likewise.\n\t(check_effective_target_vector_alignment_reachable): Likewise.\n\t(check_effective_target_vector_alignment_reachable_for_64bit): Likewise.\n\t(is-effective-target): Initialize et_index if undefined.\n\t(et-dg-runtest): New.\n\t(et-is-effective-target): Likewise.\n\t(check_vect_support_and_set_flags): Add supported MIPS targets to\n\tEFFECTIVE_TARGETS list.  Return the number of supported targets.\n\nFrom-SVN: r238755", "tree": {"sha": "a3d9b77babdb9630eb8f5a5376288b4b65ce5a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3d9b77babdb9630eb8f5a5376288b4b65ce5a7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/comments", "author": null, "committer": null, "parents": [{"sha": "8f63caf6826e918678482413161e34b037a13fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f63caf6826e918678482413161e34b037a13fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f63caf6826e918678482413161e34b037a13fa7"}], "stats": {"total": 1429, "additions": 940, "deletions": 489}, "files": [{"sha": "5307adfcb9728760104043be74cce71b7417cdbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -1,3 +1,95 @@\n+2016-07-26  Robert Suchanek  <robert.suchanek@imgtec.com>\n+\n+\t* g++.dg/vect/vect.exp: Add and set new global EFFECTIVE_TARGETS. Call\n+\tg++-dg-runtest via et-dg-runtest.\n+\t* gcc.dg/graphite/graphite.exp: Likewise, but for dg-runtest.\n+\t* gcc.dg/vect/vect.exp: Likewise.\n+\t* gfortran.dg/graphite/graphite.exp: Likewise, but for\n+\tgfortran-dg-runtest.\n+\t* gfortran.dg/vect/vect.exp: Likewise.\n+\t* lib/target-supports.exp (check_mpaired_single_hw_available): New.\n+\t(check_mips_loongson_hw_available): Likewise.\n+\t(check_effective_target_mpaired_single_runtime): Likewise.\n+\t(check_effective_target_mips_loongson_runtime): Likewise.\n+\t(add_options_for_mpaired_single): Likewise.\n+\t(check_effective_target_vect_int): Add global et_index.\n+\tCheck and save the supported feature for a target selected by\n+\tthe et_index target.  Break long lines where appropriate.  Call\n+\tet-is-effective-target for MIPS with an argument instead of\n+\tcheck_effective_target_* where appropriate.\n+\t(check_effective_target_vect_intfloat_cvt): Likewise.\n+\t(check_effective_target_vect_uintfloat_cvt): Likewise.\n+\t(check_effective_target_vect_floatint_cvt): Likewise.\n+\t(check_effective_target_vect_floatuint_cvt): Likewise.\n+\t(check_effective_target_vect_simd_clones): Likewise.\n+\t(check_effective_target_vect_shift): ewise.\n+\t(check_effective_target_whole_vector_shift): Likewise.\n+\t(check_effective_target_vect_bswap): Likewise.\n+\t(check_effective_target_vect_shift_char): Likewise.\n+\t(check_effective_target_vect_long): Likewise.\n+\t(check_effective_target_vect_float): Likewise.\n+\t(check_effective_target_vect_double): Likewise.\n+\t(check_effective_target_vect_long_long): Likewise.\n+\t(check_effective_target_vect_no_int_max): Likewise.\n+\t(check_effective_target_vect_no_int_add): Likewise.\n+\t(check_effective_target_vect_no_bitwise): Likewise.\n+\t(check_effective_target_vect_widen_shift): Likewise.\n+\t(check_effective_target_vect_no_align): Likewise.\n+\t(check_effective_target_vect_hw_misalign): Likewise.\n+\t(check_effective_target_vect_element_align): Likewise.\n+\t(check_effective_target_vect_condition): Likewise.\n+\t(check_effective_target_vect_cond_mixed): Likewise.\n+\t(check_effective_target_vect_char_mult): Likewise.\n+\t(check_effective_target_vect_short_mult): Likewise.\n+\t(check_effective_target_vect_int_mult): Likewise.\n+\t(check_effective_target_vect_extract_even_odd): Likewise.\n+\t(check_effective_target_vect_interleave): Likewise.\n+\t(check_effective_target_vect_stridedN): Likewise.\n+\t(check_effective_target_vect_multiple_sizes): Likewise.\n+\t(check_effective_target_vect64): Likewise.\n+\t(check_effective_target_vect_call_copysignf): Likewise.\n+\t(check_effective_target_vect_call_sqrtf): Likewise.\n+\t(check_effective_target_vect_call_btrunc): Likewise.\n+\t(check_effective_target_vect_call_btruncf): Likewise.\n+\t(check_effective_target_vect_call_ceil): Likewise.\n+\t(check_effective_target_vect_call_ceilf): Likewise.\n+\t(check_effective_target_vect_call_floor): Likewise.\n+\t(check_effective_target_vect_call_floorf): Likewise.\n+\t(check_effective_target_vect_call_lceil): Likewise.\n+\t(check_effective_target_vect_call_lfloor): Likewise.\n+\t(check_effective_target_vect_call_nearbyint): Likewise.\n+\t(check_effective_target_vect_call_nearbyintf): Likewise.\n+\t(check_effective_target_vect_call_round): Likewise.\n+\t(check_effective_target_vect_call_roundf): Likewise.\n+\t(check_effective_target_vect_perm): Likewise, but also append *_saved\n+\tto the existing global name to properly cache the result.\n+\t(check_effective_target_vect_perm_byte): Likewise.\n+\t(check_effective_target_vect_perm_short): Likewise.\n+\t(check_effective_target_vect_widen_sum_hi_to_si_pattern): Likewise.\n+\t(check_effective_target_vect_widen_sum_hi_to_si): Likewise.\n+\t(check_effective_target_vect_widen_sum_qi_to_hi): Likewise.\n+\t(check_effective_target_vect_widen_sum_qi_to_si): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi_pattern): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi): Likewise.\n+\t(check_effective_target_vect_widen_mult_hi_to_si_pattern): Likewise.\n+\t(check_effective_target_vect_widen_mult_si_to_di_pattern): Likewise.\n+\t(check_effective_target_vect_sdot_qi): Likewise.\n+\t(check_effective_target_vect_udot_qi): Likewise.\n+\t(check_effective_target_vect_sdot_hi): Likewise.\n+\t(check_effective_target_vect_udot_hi): Likewise.\n+\t(check_effective_target_vect_usad_char): Likewise.\n+\t(check_effective_target_vect_pack_trunc): Likewise.\n+\t(check_effective_target_vect_unpack): Likewise.\n+\t(check_effective_target_vect_aligned_arrays): Likewise.\n+\t(check_effective_target_vect_natural_alignment): Likewise.\n+\t(check_effective_target_vector_alignment_reachable): Likewise.\n+\t(check_effective_target_vector_alignment_reachable_for_64bit): Likewise.\n+\t(is-effective-target): Initialize et_index if undefined.\n+\t(et-dg-runtest): New.\n+\t(et-is-effective-target): Likewise.\n+\t(check_vect_support_and_set_flags): Add supported MIPS targets to\n+\tEFFECTIVE_TARGETS list.  Return the number of supported targets.\n+\n 2016-07-26  Richard Biener  <rguenther@suse.de>\n \t    Prathamesh Kulkarni <prathamesh.kulkarni@linaro.org>\n "}, {"sha": "f699082bf35d2159ba52a3dcc5ac04789d8b17da", "filename": "gcc/testsuite/g++.dg/vect/vect.exp", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -39,6 +39,11 @@ set save-dg-do-what-default ${dg-do-what-default}\n global DEFAULT_VECTCFLAGS\n set DEFAULT_VECTCFLAGS \"\"\n \n+# Set up a list of effective targets to run vector tests for all supported\n+# targets.\n+global EFFECTIVE_TARGETS\n+set EFFECTIVE_TARGETS \"\"\n+\n # These flags are used for all targets.\n lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fno-vect-cost-model\"\n \n@@ -58,10 +63,10 @@ lappend VECT_SLP_CFLAGS \"-fdump-tree-slp-details\"\n dg-init\n \n # Main loop.\n-g++-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/{pr,simd}*.{c,cc,S} ]] \\\n-        \"\" $DEFAULT_VECTCFLAGS\n-g++-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/slp-pr*.{c,cc,S} ]] \\\n-        \"\" $VECT_SLP_CFLAGS\n+et-dg-runtest g++-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/{pr,simd}*.{c,cc,S} ]] \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest g++-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/slp-pr*.{c,cc,S} ]] \"\" $VECT_SLP_CFLAGS\n \n #### Tests with special options\n global SAVED_DEFAULT_VECTCFLAGS\n@@ -70,8 +75,8 @@ set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n # --param max-aliased-vops=0\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"--param max-aliased-vops=0\"\n-g++-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/param-max-aliased*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest g++-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/param-max-aliased*.\\[cS\\]]] \"\" $DEFAULT_VECTCFLAGS\n \n # Clean up.\n set dg-do-what-default ${save-dg-do-what-default} "}, {"sha": "ac81e82f24d97f7db8e3536b2508af08222e91f4", "filename": "gcc/testsuite/gcc.dg/graphite/graphite.exp", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -37,6 +37,11 @@ set save-dg-do-what-default ${dg-do-what-default}\n # Initialize `dg'.\n dg-init\n \n+# Set up a list of effective targets to run vector tests for all supported\n+# targets.\n+global EFFECTIVE_TARGETS\n+set EFFECTIVE_TARGETS \"\"\n+\n set wait_to_run_files [lsort [glob -nocomplain $srcdir/$subdir/*.c ] ]\n set scop_files        [lsort [glob -nocomplain $srcdir/$subdir/scop-*.c ] ]\n set id_files          [lsort [glob -nocomplain $srcdir/$subdir/id-*.c ] ]\n@@ -69,7 +74,7 @@ global DEFAULT_VECTCFLAGS\n set DEFAULT_VECTCFLAGS \"-O2 -fgraphite-identity -ftree-vectorize -fno-vect-cost-model -fdump-tree-vect-details -ffast-math\"\n \n if [check_vect_support_and_set_flags] {\n-    dg-runtest $vect_files        \"\" $DEFAULT_VECTCFLAGS\n+    et-dg-runtest dg-runtest $vect_files        \"\" $DEFAULT_VECTCFLAGS\n }\n \n # The default action for the rest of the files is 'compile'."}, {"sha": "bbb9f5ca1bb55febcd6fb08da89dd8b2119a621e", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 100, "deletions": 58, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -24,6 +24,11 @@ load_lib clearcap.exp\n global DEFAULT_VECTCFLAGS\n set DEFAULT_VECTCFLAGS \"\"\n \n+# Set up a list of effective targets to run vector tests for all supported\n+# targets.\n+global EFFECTIVE_TARGETS\n+set EFFECTIVE_TARGETS \"\"\n+\n # If the target system supports vector instructions, the default action\n # for a test is 'run', otherwise it's 'compile'.  Save current default.\n # Executing vector instructions on a system without hardware vector support\n@@ -62,13 +67,15 @@ lappend O_VECTCFLAGS \"-fdump-tree-vect-details\"\n lappend DEFAULT_VECTCFLAGS \"-O2\"\n \n # Tests that should be run without generating dump info\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/nodump-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/nodump-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # \"-O -fdump-tree-veclower2\"\n lappend VEC_FLAGS \"-O\" \"-fdump-tree-veclower2\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vec-scal-*.\\[cS\\]]]  \\\n-        \"\" $VEC_FLAGS\n+et-dg-runtest dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/vec-scal-*.\\[cS\\]]] \\\n+\t\"\" $VEC_FLAGS\n \n set VECT_SLP_CFLAGS $DEFAULT_VECTCFLAGS\n \n@@ -81,14 +88,18 @@ if { [check_effective_target_lto] } {\n     lappend VECT_ADDITIONAL_FLAGS \"-flto -ffat-lto-objects\"\n }\n foreach flags $VECT_ADDITIONAL_FLAGS {\n-    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr*.\\[cS\\]]]  \\\n+    et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/pr*.\\[cS\\]]] \\\n+\t$flags $DEFAULT_VECTCFLAGS\n+    et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/vect-*.\\[cS\\]]] \\\n \t$flags $DEFAULT_VECTCFLAGS\n-    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[cS\\]]]  \\\n+    et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/slp-*.\\[cS\\]]] \\\n \t$flags $DEFAULT_VECTCFLAGS\n-    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/slp-*.\\[cS\\]]]  \\\n-        $flags $DEFAULT_VECTCFLAGS\n-    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/bb-slp*.\\[cS\\]]]  \\\n-        $flags $VECT_SLP_CFLAGS\n+    et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/bb-slp*.\\[cS\\]]] \\\n+\t$flags $VECT_SLP_CFLAGS\n }\n \n #### Tests with special options\n@@ -99,141 +110,164 @@ set SAVED_VECT_SLP_CFLAGS $VECT_SLP_CFLAGS\n # --param vect-max-version-for-alias-checks=0 tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"--param\" \"vect-max-version-for-alias-checks=0\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -ffast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-\\[ipsv\\]*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/fast-math-\\[ipsv\\]*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -ffast-math SLP tests\n set VECT_SLP_CFLAGS $SAVED_VECT_SLP_CFLAGS\n lappend VECT_SLP_CFLAGS \"-ffast-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-bb-slp-*.\\[cS\\]]]  \\\n-        \"\" $VECT_SLP_CFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/fast-math-bb-slp-*.\\[cS\\]]] \\\n+\t\"\" $VECT_SLP_CFLAGS\n \n # -fno-fast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-fast-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-fast-math-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-fast-math-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-math-errno tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-math-errno\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-math-errno-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-math-errno-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fwrapv tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fwrapv\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/wrapv-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/wrapv-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -ftrapv tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ftrapv\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/trapv-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/trapv-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-dce tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-dce\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-dce-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-tree-dce-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fsection-anchors tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fsection-anchors\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/section-anchors-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/section-anchors-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # alignment-sensitive -fsection-anchors tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fsection-anchors\" \\\n \t\"-fdump-ipa-increase_alignment-details\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/aligned-section-anchors-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/aligned-section-anchors-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-section-anchors tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-section-anchors\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-section-anchors-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-section-anchors-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -funswitch-loops tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-funswitch-loops\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/unswitch-loops-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/unswitch-loops-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-trapping-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-trapping-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-trapping-math-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-trapping-math-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-scev-cprop\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-vect-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-scevccp-vect-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-scev-cprop\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-pr*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-scevccp-pr*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-scev-cprop\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-outer-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-scevccp-outer-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-scev-cprop -fno-tree-reassoc\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\" \"-fno-tree-reassoc\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-noreassoc-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-scevccp-noreassoc-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-scev-cprop\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-slp-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-scevccp-slp-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-dominator-opts\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-dominator-opts\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-dom-*.\\[cS\\]]]  \\\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-tree-dom-*.\\[cS\\]]] \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-pre\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-pre\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-pre-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-tree-pre-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With -Os\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-Os\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/Os-vect-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/Os-vect-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With --param ggc-min-expand=0 --param ggc-min-heapsize=0 \n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"--param\" \"ggc-min-expand=0\" \"--param\" \"ggc-min-heapsize=0\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/ggc-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/ggc-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -ftree-loop-if-convert-stores\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ftree-loop-if-convert-stores\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/if-cvt-stores-vect-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/if-cvt-stores-vect-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With -O3.\n # Don't allow IPA cloning, because it throws our counts out of whack.\n@@ -242,40 +276,48 @@ lappend DEFAULT_VECTCFLAGS \"-O3\" \"-fno-ipa-cp-clone\"\n if  [istarget \"spu-*-*\"] {\n   lappend DEFAULT_VECTCFLAGS \"-funroll-loops\"\n }\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/O3-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/O3-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With -O1\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/O1-*.\\[cS\\]]]  \\\n-        \"\" $O1_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/O1-*.\\[cS\\]]] \\\n+\t\"\" $O1_VECTCFLAGS\n \n # With -O\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/O-*.\\[cS\\]]]  \\\n-        \"\" $O_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/O-*.\\[cS\\]]] \\\n+\t\"\" $O_VECTCFLAGS\n \n # -fno-tree-reassoc\n set VECT_SLP_CFLAGS $SAVED_VECT_SLP_CFLAGS\n lappend VECT_SLP_CFLAGS \"-fno-tree-reassoc\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-reassoc-bb-slp-*.\\[cS\\]]]  \\\n-        \"\" $VECT_SLP_CFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-tree-reassoc-bb-slp-*.\\[cS\\]]] \\\n+\t\"\" $VECT_SLP_CFLAGS\n \n # -fno-tree-fre\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-fre\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-fre-*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-tree-fre-*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-fre -fno-tree-pre\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-fre\" \"-fno-tree-pre\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-fre-pre*.\\[cS\\]]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-fre-pre*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-tree-sra\n set VECT_SLP_CFLAGS $SAVED_VECT_SLP_CFLAGS\n lappend VECT_SLP_CFLAGS \"-fno-tree-sra\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-sra-bb-slp-*.\\[cS\\]]]  \\\n-        \"\" $VECT_SLP_CFLAGS\n+et-dg-runtest dg-runtest [lsort \\\n+\t[glob -nocomplain $srcdir/$subdir/no-tree-sra-bb-slp-*.\\[cS\\]]] \\\n+\t\"\" $VECT_SLP_CFLAGS\n \n \n # Clean up."}, {"sha": "f3f83ac5d6655b5048049e76482b18e7902f2b89", "filename": "gcc/testsuite/gfortran.dg/graphite/graphite.exp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -51,9 +51,15 @@ gfortran-dg-runtest $scop_files        \"\" \"-O2 -fgraphite -fdump-tree-graphite-a\n gfortran-dg-runtest $id_files          \"\" \"-O2 -fgraphite-identity -ffast-math\"\n gfortran-dg-runtest $opt_files         \"\" \"-O2 -floop-nest-optimize -ffast-math -fdump-tree-graphite-all\"\n \n+# Set up a list of effective targets to run vector tests for all supported\n+# targets.\n+global EFFECTIVE_TARGETS\n+set EFFECTIVE_TARGETS \"\"\n+\n # Vectorizer tests, to be run or compiled, depending on target capabilities.\n if [check_vect_support_and_set_flags] {\n-    gfortran-dg-runtest $vect_files \"\" \"-O2 -fgraphite-identity -ftree-vectorize -fno-vect-cost-model -fdump-tree-vect-details -ffast-math\"\n+   et-dg-runtest gfortran-dg-runtest $vect_files \"\" \\\n+      \"-O2 -fgraphite-identity -ftree-vectorize -fno-vect-cost-model -fdump-tree-vect-details -ffast-math\"\n }\n \n # Tests to be run."}, {"sha": "bd35a7c7c8ad0b76cbdf9574e4766551629f0334", "filename": "gcc/testsuite/gfortran.dg/vect/vect.exp", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -24,6 +24,11 @@ load_lib target-supports.exp\n global DEFAULT_VECTCFLAGS\n set DEFAULT_VECTCFLAGS \"\"\n \n+# Set up a list of effective targets to run vector tests for all supported\n+# targets.\n+global EFFECTIVE_TARGETS\n+set EFFECTIVE_TARGETS \"\"\n+\n # These flags are used for all targets.\n lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fvect-cost-model=unlimited\" \\\n   \"-fdump-tree-vect-details\"\n@@ -47,8 +52,10 @@ if ![check_vect_support_and_set_flags] {\n dg-init\n \n # Main loop.\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[fF\\]{,90,95,03,08} ]] \"\" $DEFAULT_VECTCFLAGS\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr*.\\[fF\\]{,90,95,03,08} ]] \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/vect-*.\\[fF\\]{,90,95,03,08} ]] \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/pr*.\\[fF\\]{,90,95,03,08} ]] \"\" $DEFAULT_VECTCFLAGS\n \n #### Tests with special options\n global SAVED_DEFAULT_VECTCFLAGS\n@@ -57,44 +64,51 @@ set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n # -ffast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/fast-math-*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -ffast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ffast-math\" \"-fdefault-real-8\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-real8*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/fast-math-real8*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # -fvect-cost-model tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fvect-cost-model=dynamic\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/cost-model-*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/cost-model-*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # --param vect-max-version-for-alias-checks=0 tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"--param\" \"vect-max-version-for-alias-checks=0\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/no-vfa-*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With -O3\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-O3\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/O3-*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/O3-*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With -Ofast\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-Ofast\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/Ofast-*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/Ofast-*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # With -fno-tree-copy-prop -fno-tree-fre -O3\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-copy-prop\" \"-fno-tree-fre\" \"-O3\"\n-gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-fre-no-copy-prop-O3-*.\\[fF\\]{,90,95,03,08} ]]  \\\n-        \"\" $DEFAULT_VECTCFLAGS\n+et-dg-runtest gfortran-dg-runtest [lsort [glob -nocomplain \\\n+\t$srcdir/$subdir/no-fre-no-copy-prop-O3-*.\\[fF\\]{,90,95,03,08} ]] \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n \n # Clean up.\n set dg-do-what-default ${save-dg-do-what-default}"}, {"sha": "770268f3e2f86cee95c8d7d15c79a7476e36c44b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 694, "deletions": 407, "changes": 1101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=9b7937cf8a06c2d05dc1a5f357ef818f0c736cfa", "patch": "@@ -1585,6 +1585,47 @@ proc check_sse_hw_available { } {\n     }]\n }\n \n+# Return 1 if the target supports executing MIPS Paired-Single instructions,\n+# 0 otherwise.  Cache the result.\n+\n+proc check_mpaired_single_hw_available { } {\n+    return [check_cached_effective_target mpaired_single_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget mips*-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache mpaired_single_hw_available {\n+\t      int main()\n+\t      {\n+\t\tasm volatile (\"pll.ps $f2,$f4,$f6\");\n+\t\treturn 0;\n+\t      }\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n+# Return 1 if the target supports executing Loongson vector instructions,\n+# 0 otherwise.  Cache the result.\n+\n+proc check_mips_loongson_hw_available { } {\n+    return [check_cached_effective_target mips_loongson_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget mips*-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache mips_loongson_hw_available {\n+\t      #include <loongson.h>\n+\t      int main()\n+\t      {\n+\t\tasm volatile (\"paddw $f2,$f4,$f6\");\n+\t\treturn 0;\n+\t      }\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports executing SSE2 instructions, 0\n # otherwise.  Cache the result.\n \n@@ -1688,6 +1729,27 @@ proc check_effective_target_sse4_runtime { } {\n     return 0\n }\n \n+# Return 1 if the target supports running MIPS Paired-Single\n+# executables, 0 otherwise.\n+\n+proc check_effective_target_mpaired_single_runtime { } {\n+    if { [check_effective_target_mpaired_single]\n+\t && [check_mpaired_single_hw_available] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n+# Return 1 if the target supports running Loongson executables, 0 otherwise.\n+\n+proc check_effective_target_mips_loongson_runtime { } {\n+    if { [check_effective_target_mips_loongson]\n+\t && [check_mips_loongson_hw_available] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n # Return 1 if the target supports running AVX executables, 0 otherwise.\n \n proc check_effective_target_avx_runtime { } {\n@@ -2560,11 +2622,12 @@ proc check_effective_target_vect_cmdline_needed { } {\n \n proc check_effective_target_vect_int { } {\n     global et_vect_int_saved\n+    global et_index\n \n-    if [info exists et_vect_int_saved] {\n+    if [info exists et_vect_int_saved($et_index)] {\n \tverbose \"check_effective_target_vect_int: using cached result\" 2\n     } else {\n-\tset et_vect_int_saved 0\n+\tset et_vect_int_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || ([istarget powerpc*-*-*]\n                   && ![istarget powerpc-*-linux*paired*])\n@@ -2575,36 +2638,40 @@ proc check_effective_target_vect_int { } {\n \t      || [istarget aarch64*-*-*]\n \t      || [check_effective_target_arm32]\n \t      || ([istarget mips*-*-*]\n-\t\t  && [check_effective_target_mips_loongson]) } {\n-\t   set et_vect_int_saved 1\n+\t\t  && [et-is-effective-target mips_loongson]) } {\n+\t    set et_vect_int_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_int: returning $et_vect_int_saved\" 2\n-    return $et_vect_int_saved\n+    verbose \"check_effective_target_vect_int:\\\n+\t     returning $et_vect_int_saved($et_index)\" 2\n+    return $et_vect_int_saved($et_index)\n }\n \n # Return 1 if the target supports signed int->float conversion \n #\n \n proc check_effective_target_vect_intfloat_cvt { } {\n     global et_vect_intfloat_cvt_saved\n+    global et_index\n \n-    if [info exists et_vect_intfloat_cvt_saved] {\n-        verbose \"check_effective_target_vect_intfloat_cvt: using cached result\" 2\n+    if [info exists et_vect_intfloat_cvt_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_intfloat_cvt:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_intfloat_cvt_saved 0\n+\tset et_vect_intfloat_cvt_saved($et_index) 0\n         if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n               || ([istarget powerpc*-*-*]\n                    && ![istarget powerpc-*-linux*paired*])\n               || ([istarget arm*-*-*]\n                   && [check_effective_target_arm_neon_ok])} {\n-           set et_vect_intfloat_cvt_saved 1\n+\t   set et_vect_intfloat_cvt_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_intfloat_cvt: returning $et_vect_intfloat_cvt_saved\" 2\n-    return $et_vect_intfloat_cvt_saved\n+    verbose \"check_effective_target_vect_intfloat_cvt:\\\n+\t     returning $et_vect_intfloat_cvt_saved($et_index)\" 2\n+    return $et_vect_intfloat_cvt_saved($et_index)\n }\n \n #Return 1 if we're supporting __int128 for target, 0 otherwise.\n@@ -2626,23 +2693,26 @@ proc check_effective_target_int128 { } {\n \n proc check_effective_target_vect_uintfloat_cvt { } {\n     global et_vect_uintfloat_cvt_saved\n+    global et_index\n \n-    if [info exists et_vect_uintfloat_cvt_saved] {\n-        verbose \"check_effective_target_vect_uintfloat_cvt: using cached result\" 2\n+    if [info exists et_vect_uintfloat_cvt_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_uintfloat_cvt:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_uintfloat_cvt_saved 0\n+\tset et_vect_uintfloat_cvt_saved($et_index) 0\n         if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t      || ([istarget powerpc*-*-*]\n \t\t  && ![istarget powerpc-*-linux*paired*])\n \t      || [istarget aarch64*-*-*]\n \t      || ([istarget arm*-*-*]\n \t\t  && [check_effective_target_arm_neon_ok])} {\n-           set et_vect_uintfloat_cvt_saved 1\n+\t   set et_vect_uintfloat_cvt_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_uintfloat_cvt: returning $et_vect_uintfloat_cvt_saved\" 2\n-    return $et_vect_uintfloat_cvt_saved\n+    verbose \"check_effective_target_vect_uintfloat_cvt:\\\n+\t     returning $et_vect_uintfloat_cvt_saved($et_index)\" 2\n+    return $et_vect_uintfloat_cvt_saved($et_index)\n }\n \n \n@@ -2651,44 +2721,50 @@ proc check_effective_target_vect_uintfloat_cvt { } {\n \n proc check_effective_target_vect_floatint_cvt { } {\n     global et_vect_floatint_cvt_saved\n+    global et_index\n \n-    if [info exists et_vect_floatint_cvt_saved] {\n-        verbose \"check_effective_target_vect_floatint_cvt: using cached result\" 2\n+    if [info exists et_vect_floatint_cvt_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_floatint_cvt:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_floatint_cvt_saved 0\n+\tset et_vect_floatint_cvt_saved($et_index) 0\n         if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n               || ([istarget powerpc*-*-*]\n                    && ![istarget powerpc-*-linux*paired*])\n               || ([istarget arm*-*-*]\n                   && [check_effective_target_arm_neon_ok])} {\n-           set et_vect_floatint_cvt_saved 1\n+\t   set et_vect_floatint_cvt_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_floatint_cvt: returning $et_vect_floatint_cvt_saved\" 2\n-    return $et_vect_floatint_cvt_saved\n+    verbose \"check_effective_target_vect_floatint_cvt:\\\n+\t     returning $et_vect_floatint_cvt_saved($et_index)\" 2\n+    return $et_vect_floatint_cvt_saved($et_index)\n }\n \n # Return 1 if the target supports unsigned float->int conversion\n #\n \n proc check_effective_target_vect_floatuint_cvt { } {\n     global et_vect_floatuint_cvt_saved\n+    global et_index\n \n-    if [info exists et_vect_floatuint_cvt_saved] {\n-        verbose \"check_effective_target_vect_floatuint_cvt: using cached result\" 2\n+    if [info exists et_vect_floatuint_cvt_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_floatuint_cvt:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_floatuint_cvt_saved 0\n+\tset et_vect_floatuint_cvt_saved($et_index) 0\n         if { ([istarget powerpc*-*-*]\n \t      && ![istarget powerpc-*-linux*paired*])\n \t    || ([istarget arm*-*-*]\n-\t        && [check_effective_target_arm_neon_ok])} {\n-           set et_vect_floatuint_cvt_saved 1\n+\t\t&& [check_effective_target_arm_neon_ok])} {\n+\t   set et_vect_floatuint_cvt_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_floatuint_cvt: returning $et_vect_floatuint_cvt_saved\" 2\n-    return $et_vect_floatuint_cvt_saved\n+    verbose \"check_effective_target_vect_floatuint_cvt:\\\n+\t     returning $et_vect_floatuint_cvt_saved($et_index)\" 2\n+    return $et_vect_floatuint_cvt_saved($et_index)\n }\n \n # Return 1 if the target supports #pragma omp declare simd, 0 otherwise.\n@@ -2697,24 +2773,26 @@ proc check_effective_target_vect_floatuint_cvt { } {\n \n proc check_effective_target_vect_simd_clones { } {\n     global et_vect_simd_clones_saved\n+    global et_index\n \n-    if [info exists et_vect_simd_clones_saved] {\n+    if [info exists et_vect_simd_clones_saved($et_index)] {\n \tverbose \"check_effective_target_vect_simd_clones: using cached result\" 2\n     } else {\n-\tset et_vect_simd_clones_saved 0\n+\tset et_vect_simd_clones_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n \t    # On i?86/x86_64 #pragma omp declare simd builds a sse2, avx and\n \t    # avx2 clone.  Only the right clone for the specified arch will be\n \t    # chosen, but still we need to at least be able to assemble\n \t    # avx2.\n \t    if { [check_effective_target_avx512f] } {\n-\t\tset et_vect_simd_clones_saved 1\n+\t\tset et_vect_simd_clones_saved($et_index) 1\n \t    }\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_simd_clones: returning $et_vect_simd_clones_saved\" 2\n-    return $et_vect_simd_clones_saved\n+    verbose \"check_effective_target_vect_simd_clones:\\\n+\t     returning $et_vect_simd_clones_saved($et_index)\" 2\n+    return $et_vect_simd_clones_saved($et_index)\n }\n \n # Return 1 if this is a AArch64 target supporting big endian\n@@ -3709,6 +3787,15 @@ proc check_effective_target_arm_acq_rel { } {\n     }]\n }\n \n+# Add the options needed for MIPS Paired-Single.\n+\n+proc add_options_for_mpaired_single { flags } {\n+    if { ! [check_effective_target_mpaired_single] } {\n+\treturn \"$flags\"\n+    }\n+    return \"$flags -mpaired-single\"\n+}\n+\n # Return 1 if this a Loongson-2E or -2F target using an ABI that supports\n # the Loongson vector modes.\n \n@@ -4230,25 +4317,27 @@ proc check_effective_target_sparc_vis { } {\n \n proc check_effective_target_vect_shift { } {\n     global et_vect_shift_saved\n+    global et_index\n \n-    if [info exists et_vect_shift_saved] {\n+    if [info exists et_vect_shift_saved($et_index)] {\n \tverbose \"check_effective_target_vect_shift: using cached result\" 2\n     } else {\n-\tset et_vect_shift_saved 0\n+\tset et_vect_shift_saved($et_index) 0\n \tif { ([istarget powerpc*-*-*]\n              && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [check_effective_target_arm32]\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mips_loongson]) } {\n-\t   set et_vect_shift_saved 1\n+\t\t&& [et-is-effective-target mips_loongson]) } {\n+\t   set et_vect_shift_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_shift: returning $et_vect_shift_saved\" 2\n-    return $et_vect_shift_saved\n+    verbose \"check_effective_target_vect_shift:\\\n+\t     returning $et_vect_shift_saved($et_index)\" 2\n+    return $et_vect_shift_saved($et_index)\n }\n \n proc check_effective_target_whole_vector_shift { } {\n@@ -4259,7 +4348,7 @@ proc check_effective_target_whole_vector_shift { } {\n \t || ([check_effective_target_arm32]\n \t     && [check_effective_target_arm_little_endian])\n \t || ([istarget mips*-*-*]\n-\t     && [check_effective_target_mips_loongson]) } {\n+\t     && [et-is-effective-target mips_loongson]) } {\n \tset answer 1\n     } else {\n \tset answer 0\n@@ -4273,41 +4362,45 @@ proc check_effective_target_whole_vector_shift { } {\n \n proc check_effective_target_vect_bswap { } {\n     global et_vect_bswap_saved\n+    global et_index\n \n-    if [info exists et_vect_bswap_saved] {\n+    if [info exists et_vect_bswap_saved($et_index)] {\n \tverbose \"check_effective_target_vect_bswap: using cached result\" 2\n     } else {\n-\tset et_vect_bswap_saved 0\n+\tset et_vect_bswap_saved($et_index) 0\n \tif { [istarget aarch64*-*-*]\n              || ([istarget arm*-*-*]\n                 && [check_effective_target_arm_neon])\n \t   } {\n-\t   set et_vect_bswap_saved 1\n+\t   set et_vect_bswap_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_bswap: returning $et_vect_bswap_saved\" 2\n-    return $et_vect_bswap_saved\n+    verbose \"check_effective_target_vect_bswap:\\\n+\t     returning $et_vect_bswap_saved($et_index)\" 2\n+    return $et_vect_bswap_saved($et_index)\n }\n \n # Return 1 if the target supports hardware vector shift operation for char.\n \n proc check_effective_target_vect_shift_char { } {\n     global et_vect_shift_char_saved\n+    global et_index\n \n-    if [info exists et_vect_shift_char_saved] {\n+    if [info exists et_vect_shift_char_saved($et_index)] {\n \tverbose \"check_effective_target_vect_shift_char: using cached result\" 2\n     } else {\n-\tset et_vect_shift_char_saved 0\n+\tset et_vect_shift_char_saved($et_index) 0\n \tif { ([istarget powerpc*-*-*]\n              && ![istarget powerpc-*-linux*paired*])\n \t     || [check_effective_target_arm32] } {\n-\t   set et_vect_shift_char_saved 1\n+\t   set et_vect_shift_char_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_shift_char: returning $et_vect_shift_char_saved\" 2\n-    return $et_vect_shift_char_saved\n+    verbose \"check_effective_target_vect_shift_char:\\\n+\t     returning $et_vect_shift_char_saved($et_index)\" 2\n+    return $et_vect_shift_char_saved($et_index)\n }\n \n # Return 1 if the target supports hardware vectors of long, 0 otherwise.\n@@ -4337,11 +4430,12 @@ proc check_effective_target_vect_long { } {\n \n proc check_effective_target_vect_float { } {\n     global et_vect_float_saved\n+    global et_index\n \n-    if [info exists et_vect_float_saved] {\n+    if [info exists et_vect_float_saved($et_index)] {\n \tverbose \"check_effective_target_vect_float: using cached result\" 2\n     } else {\n-\tset et_vect_float_saved 0\n+\tset et_vect_float_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t      || [istarget powerpc*-*-*]\n \t      || [istarget spu-*-*]\n@@ -4350,12 +4444,13 @@ proc check_effective_target_vect_float { } {\n \t      || [istarget ia64-*-*]\n \t      || [istarget aarch64*-*-*]\n \t      || [check_effective_target_arm32] } {\n-\t   set et_vect_float_saved 1\n+\t   set et_vect_float_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_float: returning $et_vect_float_saved\" 2\n-    return $et_vect_float_saved\n+    verbose \"check_effective_target_vect_float:\\\n+\t     returning $et_vect_float_saved($et_index)\" 2\n+    return $et_vect_float_saved($et_index)\n }\n \n # Return 1 if the target supports hardware vectors of double, 0 otherwise.\n@@ -4364,31 +4459,33 @@ proc check_effective_target_vect_float { } {\n \n proc check_effective_target_vect_double { } {\n     global et_vect_double_saved\n+    global et_index\n \n-    if [info exists et_vect_double_saved] {\n+    if [info exists et_vect_double_saved($et_index)] {\n \tverbose \"check_effective_target_vect_double: using cached result\" 2\n     } else {\n-\tset et_vect_double_saved 0\n+\tset et_vect_double_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget aarch64*-*-*] } {\n \t   if { [check_no_compiler_messages vect_double assembly {\n \t\t #ifdef __tune_atom__\n \t\t # error No double vectorizer support.\n \t\t #endif\n \t\t}] } {\n-\t\tset et_vect_double_saved 1\n+\t\tset et_vect_double_saved($et_index) 1\n \t    } else {\n-\t\tset et_vect_double_saved 0\n+\t\tset et_vect_double_saved($et_index) 0\n \t    }\n \t} elseif { [istarget spu-*-*] } {\n-\t   set et_vect_double_saved 1\n+\t   set et_vect_double_saved($et_index) 1\n \t} elseif { [istarget powerpc*-*-*] && [check_vsx_hw_available] } {\n-\t   set et_vect_double_saved 1\n+\t   set et_vect_double_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_double: returning $et_vect_double_saved\" 2\n-    return $et_vect_double_saved\n+    verbose \"check_effective_target_vect_double:\\\n+\t     returning $et_vect_double_saved($et_index)\" 2\n+    return $et_vect_double_saved($et_index)\n }\n \n # Return 1 if the target supports hardware vectors of long long, 0 otherwise.\n@@ -4397,18 +4494,20 @@ proc check_effective_target_vect_double { } {\n \n proc check_effective_target_vect_long_long { } {\n     global et_vect_long_long_saved\n+    global et_index\n \n-    if [info exists et_vect_long_long_saved] {\n+    if [info exists et_vect_long_long_saved($et_index)] {\n         verbose \"check_effective_target_vect_long_long: using cached result\" 2\n     } else {\n-        set et_vect_long_long_saved 0\n-        if { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n-           set et_vect_long_long_saved 1\n+\tset et_vect_long_long_saved($et_index) 0\n+\tif { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n+\t   set et_vect_long_long_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_long_long: returning $et_vect_long_long_saved\" 2\n-    return $et_vect_long_long_saved\n+    verbose \"check_effective_target_vect_long_long:\\\n+\t     returning $et_vect_long_long_saved($et_index)\" 2\n+    return $et_vect_long_long_saved($et_index)\n }\n \n \n@@ -4419,21 +4518,24 @@ proc check_effective_target_vect_long_long { } {\n \n proc check_effective_target_vect_no_int_min_max { } {\n     global et_vect_no_int_min_max_saved\n+    global et_index\n \n-    if [info exists et_vect_no_int_min_max_saved] {\n-\tverbose \"check_effective_target_vect_no_int_min_max: using cached result\" 2\n+    if [info exists et_vect_no_int_min_max_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_no_int_min_max:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_no_int_min_max_saved 0\n+\tset et_vect_no_int_min_max_saved($et_index) 0\n \tif { [istarget sparc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget alpha*-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mips_loongson]) } {\n-\t    set et_vect_no_int_min_max_saved 1\n+\t\t && [et-is-effective-target mips_loongson]) } {\n+\t    set et_vect_no_int_min_max_saved($et_index) 1\n \t}\n     }\n-    verbose \"check_effective_target_vect_no_int_min_max: returning $et_vect_no_int_min_max_saved\" 2\n-    return $et_vect_no_int_min_max_saved\n+    verbose \"check_effective_target_vect_no_int_min_max:\\\n+\t     returning $et_vect_no_int_min_max_saved($et_index)\" 2\n+    return $et_vect_no_int_min_max_saved($et_index)\n }\n \n # Return 1 if the target plus current options does not support a vector\n@@ -4443,18 +4545,20 @@ proc check_effective_target_vect_no_int_min_max { } {\n \n proc check_effective_target_vect_no_int_add { } {\n     global et_vect_no_int_add_saved\n+    global et_index\n \n-    if [info exists et_vect_no_int_add_saved] {\n+    if [info exists et_vect_no_int_add_saved($et_index)] {\n \tverbose \"check_effective_target_vect_no_int_add: using cached result\" 2\n     } else {\n-\tset et_vect_no_int_add_saved 0\n+\tset et_vect_no_int_add_saved($et_index) 0\n \t# Alpha only supports vector add on V8QI and V4HI.\n \tif { [istarget alpha*-*-*] } {\n-\t    set et_vect_no_int_add_saved 1\n+\t    set et_vect_no_int_add_saved($et_index) 1\n \t}\n     }\n-    verbose \"check_effective_target_vect_no_int_add: returning $et_vect_no_int_add_saved\" 2\n-    return $et_vect_no_int_add_saved\n+    verbose \"check_effective_target_vect_no_int_add:\\\n+\t     returning $et_vect_no_int_add_saved($et_index)\" 2\n+    return $et_vect_no_int_add_saved($et_index)\n }\n \n # Return 1 if the target plus current options does not support vector\n@@ -4464,14 +4568,16 @@ proc check_effective_target_vect_no_int_add { } {\n \n proc check_effective_target_vect_no_bitwise { } {\n     global et_vect_no_bitwise_saved\n+    global et_index\n \n-    if [info exists et_vect_no_bitwise_saved] {\n+    if [info exists et_vect_no_bitwise_saved($et_index)] {\n \tverbose \"check_effective_target_vect_no_bitwise: using cached result\" 2\n     } else {\n-\tset et_vect_no_bitwise_saved 0\n+\tset et_vect_no_bitwise_saved($et_index) 0\n     }\n-    verbose \"check_effective_target_vect_no_bitwise: returning $et_vect_no_bitwise_saved\" 2\n-    return $et_vect_no_bitwise_saved\n+    verbose \"check_effective_target_vect_no_bitwise:\\\n+\t     returning $et_vect_no_bitwise_saved($et_index)\" 2\n+    return $et_vect_no_bitwise_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports vector permutation,\n@@ -4480,24 +4586,26 @@ proc check_effective_target_vect_no_bitwise { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_perm { } {\n-    global et_vect_perm\n+    global et_vect_perm_saved\n+    global et_index\n \n-    if [info exists et_vect_perm_saved] {\n+    if [info exists et_vect_perm_saved($et_index)] {\n         verbose \"check_effective_target_vect_perm: using cached result\" 2\n     } else {\n-        set et_vect_perm_saved 0\n+\tset et_vect_perm_saved($et_index) 0\n         if { [is-effective-target arm_neon_ok]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mpaired_single]) } {\n-            set et_vect_perm_saved 1\n+\t\t && [et-is-effective-target mpaired_single]) } {\n+\t    set et_vect_perm_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_perm: returning $et_vect_perm_saved\" 2\n-    return $et_vect_perm_saved\n+    verbose \"check_effective_target_vect_perm:\\\n+\t     returning $et_vect_perm_saved($et_index)\" 2\n+    return $et_vect_perm_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports vector permutation\n@@ -4506,23 +4614,25 @@ proc check_effective_target_vect_perm { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_perm_byte { } {\n-    global et_vect_perm_byte\n+    global et_vect_perm_byte_saved\n+    global et_index\n \n-    if [info exists et_vect_perm_byte_saved] {\n+    if [info exists et_vect_perm_byte_saved($et_index)] {\n         verbose \"check_effective_target_vect_perm_byte: using cached result\" 2\n     } else {\n-        set et_vect_perm_byte_saved 0\n+\tset et_vect_perm_byte_saved($et_index) 0\n         if { ([is-effective-target arm_neon_ok]\n \t      && [is-effective-target arm_little_endian])\n \t     || ([istarget aarch64*-*-*]\n \t\t && [is-effective-target aarch64_little_endian])\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n-            set et_vect_perm_byte_saved 1\n+\t    set et_vect_perm_byte_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_perm_byte: returning $et_vect_perm_byte_saved\" 2\n-    return $et_vect_perm_byte_saved\n+    verbose \"check_effective_target_vect_perm_byte:\\\n+\t     returning $et_vect_perm_byte_saved($et_index)\" 2\n+    return $et_vect_perm_byte_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports vector permutation\n@@ -4531,23 +4641,25 @@ proc check_effective_target_vect_perm_byte { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_perm_short { } {\n-    global et_vect_perm_short\n+    global et_vect_perm_short_saved\n+    global et_index\n \n-    if [info exists et_vect_perm_short_saved] {\n+    if [info exists et_vect_perm_short_saved($et_index)] {\n         verbose \"check_effective_target_vect_perm_short: using cached result\" 2\n     } else {\n-        set et_vect_perm_short_saved 0\n+\tset et_vect_perm_short_saved($et_index) 0\n         if { ([is-effective-target arm_neon_ok]\n \t      && [is-effective-target arm_little_endian])\n \t     || ([istarget aarch64*-*-*]\n \t\t && [is-effective-target aarch64_little_endian])\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n-            set et_vect_perm_short_saved 1\n+\t    set et_vect_perm_short_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_perm_short: returning $et_vect_perm_short_saved\" 2\n-    return $et_vect_perm_short_saved\n+    verbose \"check_effective_target_vect_perm_short:\\\n+\t     returning $et_vect_perm_short_saved($et_index)\" 2\n+    return $et_vect_perm_short_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4556,22 +4668,25 @@ proc check_effective_target_vect_perm_short { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {\n-    global et_vect_widen_sum_hi_to_si_pattern\n+    global et_vect_widen_sum_hi_to_si_pattern_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_sum_hi_to_si_pattern_saved] {\n-        verbose \"check_effective_target_vect_widen_sum_hi_to_si_pattern: using cached result\" 2\n+    if [info exists et_vect_widen_sum_hi_to_si_pattern_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_sum_hi_to_si_pattern:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_widen_sum_hi_to_si_pattern_saved 0\n+\tset et_vect_widen_sum_hi_to_si_pattern_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n              || [istarget aarch64*-*-*]\n \t     || ([istarget arm*-*-*] &&\n \t\t [check_effective_target_arm_neon_ok])\n              || [istarget ia64-*-*] } {\n-            set et_vect_widen_sum_hi_to_si_pattern_saved 1\n+\t    set et_vect_widen_sum_hi_to_si_pattern_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_sum_hi_to_si_pattern: returning $et_vect_widen_sum_hi_to_si_pattern_saved\" 2\n-    return $et_vect_widen_sum_hi_to_si_pattern_saved\n+    verbose \"check_effective_target_vect_widen_sum_hi_to_si_pattern:\\\n+\t     returning $et_vect_widen_sum_hi_to_si_pattern_saved($et_index)\" 2\n+    return $et_vect_widen_sum_hi_to_si_pattern_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4582,19 +4697,23 @@ proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_hi_to_si { } {\n-    global et_vect_widen_sum_hi_to_si\n+    global et_vect_widen_sum_hi_to_si_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_sum_hi_to_si_saved] {\n-        verbose \"check_effective_target_vect_widen_sum_hi_to_si: using cached result\" 2\n+    if [info exists et_vect_widen_sum_hi_to_si_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_sum_hi_to_si:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_widen_sum_hi_to_si_saved [check_effective_target_vect_unpack]\n+\tset et_vect_widen_sum_hi_to_si_saved($et_index) \\\n+\t    [check_effective_target_vect_unpack]\n         if { [istarget powerpc*-*-*] \n \t     || [istarget ia64-*-*] } {\n-            set et_vect_widen_sum_hi_to_si_saved 1\n+\t    set et_vect_widen_sum_hi_to_si_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_sum_hi_to_si: returning $et_vect_widen_sum_hi_to_si_saved\" 2\n-    return $et_vect_widen_sum_hi_to_si_saved\n+    verbose \"check_effective_target_vect_widen_sum_hi_to_si:\\\n+\t     returning $et_vect_widen_sum_hi_to_si_saved($et_index)\" 2\n+    return $et_vect_widen_sum_hi_to_si_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4605,20 +4724,23 @@ proc check_effective_target_vect_widen_sum_hi_to_si { } {\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_qi_to_hi { } {\n-    global et_vect_widen_sum_qi_to_hi\n+    global et_vect_widen_sum_qi_to_hi_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_sum_qi_to_hi_saved] {\n-        verbose \"check_effective_target_vect_widen_sum_qi_to_hi: using cached result\" 2\n+    if [info exists et_vect_widen_sum_qi_to_hi_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_sum_qi_to_hi:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_widen_sum_qi_to_hi_saved 0\n+\tset et_vect_widen_sum_qi_to_hi_saved($et_index) 0\n \tif { [check_effective_target_vect_unpack] \n \t     || [check_effective_target_arm_neon_ok]\n \t     || [istarget ia64-*-*] } {\n-            set et_vect_widen_sum_qi_to_hi_saved 1\n+\t    set et_vect_widen_sum_qi_to_hi_saved($et_index) 1\n \t}\n     }\n-    verbose \"check_effective_target_vect_widen_sum_qi_to_hi: returning $et_vect_widen_sum_qi_to_hi_saved\" 2\n-    return $et_vect_widen_sum_qi_to_hi_saved\n+    verbose \"check_effective_target_vect_widen_sum_qi_to_hi:\\\n+\t     returning $et_vect_widen_sum_qi_to_hi_saved($et_index)\" 2\n+    return $et_vect_widen_sum_qi_to_hi_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4627,18 +4749,21 @@ proc check_effective_target_vect_widen_sum_qi_to_hi { } {\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_qi_to_si { } {\n-    global et_vect_widen_sum_qi_to_si\n+    global et_vect_widen_sum_qi_to_si_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_sum_qi_to_si_saved] {\n-        verbose \"check_effective_target_vect_widen_sum_qi_to_si: using cached result\" 2\n+    if [info exists et_vect_widen_sum_qi_to_si_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_sum_qi_to_si:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_widen_sum_qi_to_si_saved 0\n+\tset et_vect_widen_sum_qi_to_si_saved($et_index) 0\n         if { [istarget powerpc*-*-*] } {\n-            set et_vect_widen_sum_qi_to_si_saved 1\n+\t    set et_vect_widen_sum_qi_to_si_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_sum_qi_to_si: returning $et_vect_widen_sum_qi_to_si_saved\" 2\n-    return $et_vect_widen_sum_qi_to_si_saved\n+    verbose \"check_effective_target_vect_widen_sum_qi_to_si:\\\n+\t     returning $et_vect_widen_sum_qi_to_si_saved($et_index)\" 2\n+    return $et_vect_widen_sum_qi_to_si_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4651,25 +4776,28 @@ proc check_effective_target_vect_widen_sum_qi_to_si { } {\n \n \n proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n-    global et_vect_widen_mult_qi_to_hi\n+    global et_vect_widen_mult_qi_to_hi_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_mult_qi_to_hi_saved] {\n-        verbose \"check_effective_target_vect_widen_mult_qi_to_hi: using cached result\" 2\n+    if [info exists et_vect_widen_mult_qi_to_hi_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_mult_qi_to_hi:\\\n+\t\t using cached result\" 2\n     } else {\n \tif { [check_effective_target_vect_unpack]\n \t     && [check_effective_target_vect_short_mult] } {\n-\t    set et_vect_widen_mult_qi_to_hi_saved 1\n+\t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 1\n \t} else {\n-\t    set et_vect_widen_mult_qi_to_hi_saved 0\n+\t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 0\n \t}\n         if { [istarget powerpc*-*-*]\n               || [istarget aarch64*-*-*]\n               || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]) } {\n-            set et_vect_widen_mult_qi_to_hi_saved 1\n+\t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_mult_qi_to_hi: returning $et_vect_widen_mult_qi_to_hi_saved\" 2\n-    return $et_vect_widen_mult_qi_to_hi_saved\n+    verbose \"check_effective_target_vect_widen_mult_qi_to_hi:\\\n+\t     returning $et_vect_widen_mult_qi_to_hi_saved($et_index)\" 2\n+    return $et_vect_widen_mult_qi_to_hi_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4682,28 +4810,32 @@ proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n \n \n proc check_effective_target_vect_widen_mult_hi_to_si { } {\n-    global et_vect_widen_mult_hi_to_si\n+    global et_vect_widen_mult_hi_to_si_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_mult_hi_to_si_saved] {\n-        verbose \"check_effective_target_vect_widen_mult_hi_to_si: using cached result\" 2\n+    if [info exists et_vect_widen_mult_hi_to_si_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_mult_hi_to_si:\\\n+\t\t using cached result\" 2\n     } else {\n         if { [check_effective_target_vect_unpack]\n              && [check_effective_target_vect_int_mult] } {\n-          set et_vect_widen_mult_hi_to_si_saved 1\n+\t  set et_vect_widen_mult_hi_to_si_saved($et_index) 1\n         } else {\n-          set et_vect_widen_mult_hi_to_si_saved 0\n+\t  set et_vect_widen_mult_hi_to_si_saved($et_index) 0\n         }\n         if { [istarget powerpc*-*-*]\n \t      || [istarget spu-*-*]\n \t      || [istarget ia64-*-*]\n \t      || [istarget aarch64*-*-*]\n \t      || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-              || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]) } {\n-            set et_vect_widen_mult_hi_to_si_saved 1\n+\t      || ([istarget arm*-*-*]\n+\t\t  && [check_effective_target_arm_neon_ok]) } {\n+\t    set et_vect_widen_mult_hi_to_si_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_mult_hi_to_si: returning $et_vect_widen_mult_hi_to_si_saved\" 2\n-    return $et_vect_widen_mult_hi_to_si_saved\n+    verbose \"check_effective_target_vect_widen_mult_hi_to_si:\\\n+\t     returning $et_vect_widen_mult_hi_to_si_saved($et_index)\" 2\n+    return $et_vect_widen_mult_hi_to_si_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4712,21 +4844,24 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n-    global et_vect_widen_mult_qi_to_hi_pattern\n+    global et_vect_widen_mult_qi_to_hi_pattern_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_mult_qi_to_hi_pattern_saved] {\n-        verbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern: using cached result\" 2\n+    if [info exists et_vect_widen_mult_qi_to_hi_pattern_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_widen_mult_qi_to_hi_pattern_saved 0\n+\tset et_vect_widen_mult_qi_to_hi_pattern_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n               || ([istarget arm*-*-*]\n \t\t  && [check_effective_target_arm_neon_ok]\n \t\t  && [check_effective_target_arm_little_endian]) } {\n-            set et_vect_widen_mult_qi_to_hi_pattern_saved 1\n+\t    set et_vect_widen_mult_qi_to_hi_pattern_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern: returning $et_vect_widen_mult_qi_to_hi_pattern_saved\" 2\n-    return $et_vect_widen_mult_qi_to_hi_pattern_saved\n+    verbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern:\\\n+\t     returning $et_vect_widen_mult_qi_to_hi_pattern_saved($et_index)\" 2\n+    return $et_vect_widen_mult_qi_to_hi_pattern_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4735,24 +4870,27 @@ proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n-    global et_vect_widen_mult_hi_to_si_pattern\n+    global et_vect_widen_mult_hi_to_si_pattern_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_mult_hi_to_si_pattern_saved] {\n-        verbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern: using cached result\" 2\n+    if [info exists et_vect_widen_mult_hi_to_si_pattern_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_widen_mult_hi_to_si_pattern_saved 0\n+\tset et_vect_widen_mult_hi_to_si_pattern_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n               || [istarget spu-*-*]\n               || [istarget ia64-*-*]\n               || [istarget i?86-*-*] || [istarget x86_64-*-*]\n               || ([istarget arm*-*-*]\n \t\t  && [check_effective_target_arm_neon_ok]\n \t\t  && [check_effective_target_arm_little_endian]) } {\n-            set et_vect_widen_mult_hi_to_si_pattern_saved 1\n+\t    set et_vect_widen_mult_hi_to_si_pattern_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern: returning $et_vect_widen_mult_hi_to_si_pattern_saved\" 2\n-    return $et_vect_widen_mult_hi_to_si_pattern_saved\n+    verbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern:\\\n+\t     returning $et_vect_widen_mult_hi_to_si_pattern_saved($et_index)\" 2\n+    return $et_vect_widen_mult_hi_to_si_pattern_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4761,19 +4899,22 @@ proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_mult_si_to_di_pattern { } {\n-    global et_vect_widen_mult_si_to_di_pattern\n+    global et_vect_widen_mult_si_to_di_pattern_saved\n+    global et_index\n \n-    if [info exists et_vect_widen_mult_si_to_di_pattern_saved] {\n-        verbose \"check_effective_target_vect_widen_mult_si_to_di_pattern: using cached result\" 2\n+    if [info exists et_vect_widen_mult_si_to_di_pattern_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_widen_mult_si_to_di_pattern:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_widen_mult_si_to_di_pattern_saved 0\n+\tset et_vect_widen_mult_si_to_di_pattern_saved($et_index) 0\n         if {[istarget ia64-*-*]\n \t    || [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n-            set et_vect_widen_mult_si_to_di_pattern_saved 1\n+\t    set et_vect_widen_mult_si_to_di_pattern_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_mult_si_to_di_pattern: returning $et_vect_widen_mult_si_to_di_pattern_saved\" 2\n-    return $et_vect_widen_mult_si_to_di_pattern_saved\n+    verbose \"check_effective_target_vect_widen_mult_si_to_di_pattern:\\\n+\t     returning $et_vect_widen_mult_si_to_di_pattern_saved($et_index)\" 2\n+    return $et_vect_widen_mult_si_to_di_pattern_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4783,17 +4924,19 @@ proc check_effective_target_vect_widen_mult_si_to_di_pattern { } {\n \n proc check_effective_target_vect_widen_shift { } {\n     global et_vect_widen_shift_saved\n+    global et_index\n \n-    if [info exists et_vect_shift_saved] {\n+    if [info exists et_vect_shift_saved($et_index)] {\n         verbose \"check_effective_target_vect_widen_shift: using cached result\" 2\n     } else {\n-        set et_vect_widen_shift_saved 0\n+\tset et_vect_widen_shift_saved($et_index) 0\n         if { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]) } {\n-            set et_vect_widen_shift_saved 1\n+\t    set et_vect_widen_shift_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_widen_shift: returning $et_vect_widen_shift_saved\" 2\n-    return $et_vect_widen_shift_saved\n+    verbose \"check_effective_target_vect_widen_shift:\\\n+\t     returning $et_vect_widen_shift_saved($et_index)\" 2\n+    return $et_vect_widen_shift_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4802,18 +4945,20 @@ proc check_effective_target_vect_widen_shift { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_sdot_qi { } {\n-    global et_vect_sdot_qi\n+    global et_vect_sdot_qi_saved\n+    global et_index\n \n-    if [info exists et_vect_sdot_qi_saved] {\n+    if [info exists et_vect_sdot_qi_saved($et_index)] {\n         verbose \"check_effective_target_vect_sdot_qi: using cached result\" 2\n     } else {\n-        set et_vect_sdot_qi_saved 0\n+\tset et_vect_sdot_qi_saved($et_index) 0\n         if { [istarget ia64-*-*] } {\n             set et_vect_udot_qi_saved 1\n         }\n     }\n-    verbose \"check_effective_target_vect_sdot_qi: returning $et_vect_sdot_qi_saved\" 2\n-    return $et_vect_sdot_qi_saved\n+    verbose \"check_effective_target_vect_sdot_qi:\\\n+\t     returning $et_vect_sdot_qi_saved($et_index)\" 2\n+    return $et_vect_sdot_qi_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4822,19 +4967,21 @@ proc check_effective_target_vect_sdot_qi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_udot_qi { } {\n-    global et_vect_udot_qi\n+    global et_vect_udot_qi_saved\n+    global et_index\n \n-    if [info exists et_vect_udot_qi_saved] {\n+    if [info exists et_vect_udot_qi_saved($et_index)] {\n         verbose \"check_effective_target_vect_udot_qi: using cached result\" 2\n     } else {\n-        set et_vect_udot_qi_saved 0\n+\tset et_vect_udot_qi_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n              || [istarget ia64-*-*] } {\n-            set et_vect_udot_qi_saved 1\n+\t    set et_vect_udot_qi_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_udot_qi: returning $et_vect_udot_qi_saved\" 2\n-    return $et_vect_udot_qi_saved\n+    verbose \"check_effective_target_vect_udot_qi:\\\n+\t     returning $et_vect_udot_qi_saved($et_index)\" 2\n+    return $et_vect_udot_qi_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4843,20 +4990,22 @@ proc check_effective_target_vect_udot_qi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_sdot_hi { } {\n-    global et_vect_sdot_hi\n+    global et_vect_sdot_hi_saved\n+    global et_index\n \n-    if [info exists et_vect_sdot_hi_saved] {\n+    if [info exists et_vect_sdot_hi_saved($et_index)] {\n         verbose \"check_effective_target_vect_sdot_hi: using cached result\" 2\n     } else {\n-        set et_vect_sdot_hi_saved 0\n+\tset et_vect_sdot_hi_saved($et_index) 0\n         if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n-            set et_vect_sdot_hi_saved 1\n+\t    set et_vect_sdot_hi_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_sdot_hi: returning $et_vect_sdot_hi_saved\" 2\n-    return $et_vect_sdot_hi_saved\n+    verbose \"check_effective_target_vect_sdot_hi:\\\n+\t     returning $et_vect_sdot_hi_saved($et_index)\" 2\n+    return $et_vect_sdot_hi_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4865,18 +5014,20 @@ proc check_effective_target_vect_sdot_hi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_udot_hi { } {\n-    global et_vect_udot_hi\n+    global et_vect_udot_hi_saved\n+    global et_index\n \n-    if [info exists et_vect_udot_hi_saved] {\n+    if [info exists et_vect_udot_hi_saved($et_index)] {\n         verbose \"check_effective_target_vect_udot_hi: using cached result\" 2\n     } else {\n-        set et_vect_udot_hi_saved 0\n+\tset et_vect_udot_hi_saved($et_index) 0\n         if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*]) } {\n-            set et_vect_udot_hi_saved 1\n+\t    set et_vect_udot_hi_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_udot_hi: returning $et_vect_udot_hi_saved\" 2\n-    return $et_vect_udot_hi_saved\n+    verbose \"check_effective_target_vect_udot_hi:\\\n+\t     returning $et_vect_udot_hi_saved($et_index)\" 2\n+    return $et_vect_udot_hi_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4885,18 +5036,20 @@ proc check_effective_target_vect_udot_hi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_usad_char { } {\n-    global et_vect_usad_char\n+    global et_vect_usad_char_saved\n+    global et_index\n \n-    if [info exists et_vect_usad_char_saved] {\n+    if [info exists et_vect_usad_char_saved($et_index)] {\n         verbose \"check_effective_target_vect_usad_char: using cached result\" 2\n     } else {\n-        set et_vect_usad_char_saved 0\n+\tset et_vect_usad_char_saved($et_index) 0\n         if { ([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n-            set et_vect_usad_char_saved 1\n+\t    set et_vect_usad_char_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_usad_char: returning $et_vect_usad_char_saved\" 2\n-    return $et_vect_usad_char_saved\n+    verbose \"check_effective_target_vect_usad_char:\\\n+\t     returning $et_vect_usad_char_saved($et_index)\" 2\n+    return $et_vect_usad_char_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4906,23 +5059,25 @@ proc check_effective_target_vect_usad_char { } {\n # This won't change for different subtargets so cache the result.\n                                                                                 \n proc check_effective_target_vect_pack_trunc { } {\n-    global et_vect_pack_trunc\n+    global et_vect_pack_trunc_saved\n+    global et_index\n                                                                                 \n-    if [info exists et_vect_pack_trunc_saved] {\n+    if [info exists et_vect_pack_trunc_saved($et_index)] {\n         verbose \"check_effective_target_vect_pack_trunc: using cached result\" 2\n     } else {\n-        set et_vect_pack_trunc_saved 0\n+\tset et_vect_pack_trunc_saved($et_index) 0\n         if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget aarch64*-*-*]\n              || [istarget spu-*-*]\n              || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]\n \t\t && [check_effective_target_arm_little_endian]) } {\n-            set et_vect_pack_trunc_saved 1\n+\t    set et_vect_pack_trunc_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_pack_trunc: returning $et_vect_pack_trunc_saved\" 2\n-    return $et_vect_pack_trunc_saved\n+    verbose \"check_effective_target_vect_pack_trunc:\\\n+\t     returning $et_vect_pack_trunc_saved($et_index)\" 2\n+    return $et_vect_pack_trunc_saved($et_index)\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -4931,24 +5086,26 @@ proc check_effective_target_vect_pack_trunc { } {\n # This won't change for different subtargets so cache the result.\n                                    \n proc check_effective_target_vect_unpack { } {\n-    global et_vect_unpack\n+    global et_vect_unpack_saved\n+    global et_index\n                                         \n-    if [info exists et_vect_unpack_saved] {\n+    if [info exists et_vect_unpack_saved($et_index)] {\n         verbose \"check_effective_target_vect_unpack: using cached result\" 2\n     } else {\n-        set et_vect_unpack_saved 0\n+\tset et_vect_unpack_saved($et_index) 0\n         if { ([istarget powerpc*-*-*] && ![istarget powerpc-*paired*])\n              || [istarget i?86-*-*] || [istarget x86_64-*-*] \n              || [istarget spu-*-*]\n              || [istarget ia64-*-*]\n              || [istarget aarch64*-*-*]\n              || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]\n \t\t && [check_effective_target_arm_little_endian]) } {\n-            set et_vect_unpack_saved 1\n+\t    set et_vect_unpack_saved($et_index) 1\n         }\n     }\n-    verbose \"check_effective_target_vect_unpack: returning $et_vect_unpack_saved\" 2  \n-    return $et_vect_unpack_saved\n+    verbose \"check_effective_target_vect_unpack:\\\n+\t     returning $et_vect_unpack_saved($et_index)\" 2\n+    return $et_vect_unpack_saved($et_index)\n }\n \n # Return 1 if the target plus current options does not guarantee\n@@ -4975,24 +5132,26 @@ proc check_effective_target_unaligned_stack { } {\n \n proc check_effective_target_vect_no_align { } {\n     global et_vect_no_align_saved\n+    global et_index\n \n-    if [info exists et_vect_no_align_saved] {\n+    if [info exists et_vect_no_align_saved($et_index)] {\n \tverbose \"check_effective_target_vect_no_align: using cached result\" 2\n     } else {\n-\tset et_vect_no_align_saved 0\n+\tset et_vect_no_align_saved($et_index) 0\n \tif { [istarget mipsisa64*-*-*]\n \t     || [istarget mips-sde-elf]\n \t     || [istarget sparc*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [check_effective_target_arm_vect_no_misalign]\n \t     || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mips_loongson]) } {\n-\t    set et_vect_no_align_saved 1\n+\t\t && [et-is-effective-target mips_loongson]) } {\n+\t    set et_vect_no_align_saved($et_index) 1\n \t}\n     }\n-    verbose \"check_effective_target_vect_no_align: returning $et_vect_no_align_saved\" 2\n-    return $et_vect_no_align_saved\n+    verbose \"check_effective_target_vect_no_align:\\\n+\t     returning $et_vect_no_align_saved($et_index)\" 2\n+    return $et_vect_no_align_saved($et_index)\n }\n \n # Return 1 if the target supports a vector misalign access, 0 otherwise.\n@@ -5001,19 +5160,21 @@ proc check_effective_target_vect_no_align { } {\n \n proc check_effective_target_vect_hw_misalign { } {\n     global et_vect_hw_misalign_saved\n+    global et_index\n \n-    if [info exists et_vect_hw_misalign_saved] {\n+    if [info exists et_vect_hw_misalign_saved($et_index)] {\n         verbose \"check_effective_target_vect_hw_misalign: using cached result\" 2\n     } else {\n-        set et_vect_hw_misalign_saved 0\n-       if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-            || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])\n-\t    || [istarget aarch64*-*-*] } {\n-          set et_vect_hw_misalign_saved 1\n-       }\n+\tset et_vect_hw_misalign_saved($et_index) 0\n+\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+\t     || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])\n+\t     || [istarget aarch64*-*-*] } {\n+\t  set et_vect_hw_misalign_saved($et_index) 1\n+\t}\n     }\n-    verbose \"check_effective_target_vect_hw_misalign: returning $et_vect_hw_misalign_saved\" 2\n-    return $et_vect_hw_misalign_saved\n+    verbose \"check_effective_target_vect_hw_misalign:\\\n+\t     returning $et_vect_hw_misalign_saved($et_index)\" 2\n+    return $et_vect_hw_misalign_saved($et_index)\n }\n \n \n@@ -5023,25 +5184,28 @@ proc check_effective_target_vect_hw_misalign { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_aligned_arrays { } {\n-    global et_vect_aligned_arrays\n+    global et_vect_aligned_arrays_saved\n+    global et_index\n \n-    if [info exists et_vect_aligned_arrays_saved] {\n-\tverbose \"check_effective_target_vect_aligned_arrays: using cached result\" 2\n+    if [info exists et_vect_aligned_arrays_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_aligned_arrays:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_aligned_arrays_saved 0\n+\tset et_vect_aligned_arrays_saved($et_index) 0\n         if { ([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n \t    if { ([is-effective-target lp64]\n \t          && ( ![check_avx_available]\n \t\t     || [check_prefer_avx128])) } {\n-\t         set et_vect_aligned_arrays_saved 1\n+\t\t set et_vect_aligned_arrays_saved($et_index) 1\n \t    }\n \t}\n         if [istarget spu-*-*] {\n-\t    set et_vect_aligned_arrays_saved 1\n+\t    set et_vect_aligned_arrays_saved($et_index) 1\n \t}\n     }\n-    verbose \"check_effective_target_vect_aligned_arrays: returning $et_vect_aligned_arrays_saved\" 2\n-    return $et_vect_aligned_arrays_saved\n+    verbose \"check_effective_target_vect_aligned_arrays:\\\n+\t     returning $et_vect_aligned_arrays_saved($et_index)\" 2\n+    return $et_vect_aligned_arrays_saved($et_index)\n }\n \n # Return 1 if types of size 32 bit or less are naturally aligned\n@@ -5092,82 +5256,93 @@ proc check_effective_target_natural_alignment_64 { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_natural_alignment { } {\n-    global et_vect_natural_alignment\n+    global et_vect_natural_alignment_saved\n+    global et_index\n \n-    if [info exists et_vect_natural_alignment_saved] {\n+    if [info exists et_vect_natural_alignment_saved($et_index)] {\n         verbose \"check_effective_target_vect_natural_alignment: using cached result\" 2\n     } else {\n-        set et_vect_natural_alignment_saved 1\n+\tset et_vect_natural_alignment_saved($et_index) 1\n         if { [check_effective_target_arm_eabi]\n \t     || [istarget nvptx-*-*]\n \t     || [istarget s390*-*-*] } {\n-            set et_vect_natural_alignment_saved 0\n+\t    set et_vect_natural_alignment_saved($et_index) 0\n         }\n     }\n-    verbose \"check_effective_target_vect_natural_alignment: returning $et_vect_natural_alignment_saved\" 2\n-    return $et_vect_natural_alignment_saved\n+    verbose \"check_effective_target_vect_natural_alignment:\\\n+\t     returning $et_vect_natural_alignment_saved($et_index)\" 2\n+    return $et_vect_natural_alignment_saved($et_index)\n }\n \n # Return 1 if vector alignment (for types of size 32 bit or less) is reachable, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vector_alignment_reachable { } {\n-    global et_vector_alignment_reachable\n+    global et_vector_alignment_reachable_saved\n+    global et_index\n \n-    if [info exists et_vector_alignment_reachable_saved] {\n-        verbose \"check_effective_target_vector_alignment_reachable: using cached result\" 2\n+    if [info exists et_vector_alignment_reachable_saved($et_index)] {\n+\tverbose \"check_effective_target_vector_alignment_reachable:\\\n+\t\t using cached result\" 2\n     } else {\n         if { [check_effective_target_vect_aligned_arrays]\n              || [check_effective_target_natural_alignment_32] } {\n-            set et_vector_alignment_reachable_saved 1\n+\t    set et_vector_alignment_reachable_saved($et_index) 1\n         } else {\n-            set et_vector_alignment_reachable_saved 0\n+\t    set et_vector_alignment_reachable_saved($et_index) 0\n         }\n     }\n-    verbose \"check_effective_target_vector_alignment_reachable: returning $et_vector_alignment_reachable_saved\" 2\n-    return $et_vector_alignment_reachable_saved\n+    verbose \"check_effective_target_vector_alignment_reachable:\\\n+\t     returning $et_vector_alignment_reachable_saved($et_index)\" 2\n+    return $et_vector_alignment_reachable_saved($et_index)\n }\n \n # Return 1 if vector alignment for 64 bit is reachable, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vector_alignment_reachable_for_64bit { } {\n-    global et_vector_alignment_reachable_for_64bit\n+    global et_vector_alignment_reachable_for_64bit_saved\n+    global et_index\n \n-    if [info exists et_vector_alignment_reachable_for_64bit_saved] {\n-        verbose \"check_effective_target_vector_alignment_reachable_for_64bit: using cached result\" 2\n+    if [info exists et_vector_alignment_reachable_for_64bit_saved($et_index)] {\n+\tverbose \"check_effective_target_vector_alignment_reachable_for_64bit:\\\n+\t\t using cached result\" 2\n     } else {\n         if { [check_effective_target_vect_aligned_arrays] \n              || [check_effective_target_natural_alignment_64] } {\n-            set et_vector_alignment_reachable_for_64bit_saved 1\n+\t    set et_vector_alignment_reachable_for_64bit_saved($et_index) 1\n         } else {\n-            set et_vector_alignment_reachable_for_64bit_saved 0\n+\t    set et_vector_alignment_reachable_for_64bit_saved($et_index) 0\n         }\n     }\n-    verbose \"check_effective_target_vector_alignment_reachable_for_64bit: returning $et_vector_alignment_reachable_for_64bit_saved\" 2\n-    return $et_vector_alignment_reachable_for_64bit_saved\n+    verbose \"check_effective_target_vector_alignment_reachable_for_64bit:\\\n+\t returning $et_vector_alignment_reachable_for_64bit_saved($et_index)\" 2\n+    return $et_vector_alignment_reachable_for_64bit_saved($et_index)\n }\n \n # Return 1 if the target only requires element alignment for vector accesses\n \n proc check_effective_target_vect_element_align { } {\n     global et_vect_element_align\n+    global et_index\n \n-    if [info exists et_vect_element_align] {\n-\tverbose \"check_effective_target_vect_element_align: using cached result\" 2\n+    if [info exists et_vect_element_align($et_index)] {\n+\tverbose \"check_effective_target_vect_element_align:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_element_align 0\n+\tset et_vect_element_align($et_index) 0\n \tif { ([istarget arm*-*-*]\n \t      && ![check_effective_target_arm_vect_no_misalign])\n \t     || [check_effective_target_vect_hw_misalign] } {\n-\t   set et_vect_element_align 1\n+\t   set et_vect_element_align($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_element_align: returning $et_vect_element_align\" 2\n-    return $et_vect_element_align\n+    verbose \"check_effective_target_vect_element_align:\\\n+\t     returning $et_vect_element_align($et_index)\" 2\n+    return $et_vect_element_align($et_index)\n }\n \n # Return 1 if the target supports vector LOAD_LANES operations, 0 otherwise.\n@@ -5193,188 +5368,207 @@ proc check_effective_target_vect_load_lanes { } {\n \n proc check_effective_target_vect_condition { } {\n     global et_vect_cond_saved\n+    global et_index\n \n-    if [info exists et_vect_cond_saved] {\n+    if [info exists et_vect_cond_saved($et_index)] {\n \tverbose \"check_effective_target_vect_cond: using cached result\" 2\n     } else {\n-\tset et_vect_cond_saved 0\n+\tset et_vect_cond_saved($et_index) 0\n \tif { [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget spu-*-*]\n-\t     || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]) } {\n-\t   set et_vect_cond_saved 1\n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok]) } {\n+\t   set et_vect_cond_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_cond: returning $et_vect_cond_saved\" 2\n-    return $et_vect_cond_saved\n+    verbose \"check_effective_target_vect_cond:\\\n+\t     returning $et_vect_cond_saved($et_index)\" 2\n+    return $et_vect_cond_saved($et_index)\n }\n \n # Return 1 if the target supports vector conditional operations where\n # the comparison has different type from the lhs, 0 otherwise.\n \n proc check_effective_target_vect_cond_mixed { } {\n     global et_vect_cond_mixed_saved\n+    global et_index\n \n-    if [info exists et_vect_cond_mixed_saved] {\n+    if [info exists et_vect_cond_mixed_saved($et_index)] {\n \tverbose \"check_effective_target_vect_cond_mixed: using cached result\" 2\n     } else {\n-\tset et_vect_cond_mixed_saved 0\n+\tset et_vect_cond_mixed_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*] } {\n-\t   set et_vect_cond_mixed_saved 1\n+\t   set et_vect_cond_mixed_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_cond_mixed: returning $et_vect_cond_mixed_saved\" 2\n-    return $et_vect_cond_mixed_saved\n+    verbose \"check_effective_target_vect_cond_mixed:\\\n+\t     returning $et_vect_cond_mixed_saved($et_index)\" 2\n+    return $et_vect_cond_mixed_saved($et_index)\n }\n \n # Return 1 if the target supports vector char multiplication, 0 otherwise.\n \n proc check_effective_target_vect_char_mult { } {\n     global et_vect_char_mult_saved\n+    global et_index\n \n-    if [info exists et_vect_char_mult_saved] {\n+    if [info exists et_vect_char_mult_saved($et_index)] {\n \tverbose \"check_effective_target_vect_char_mult: using cached result\" 2\n     } else {\n-\tset et_vect_char_mult_saved 0\n+\tset et_vect_char_mult_saved($et_index) 0\n \tif { [istarget aarch64*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [check_effective_target_arm32]\n \t     || [check_effective_target_powerpc_altivec] } {\n-\t   set et_vect_char_mult_saved 1\n+\t   set et_vect_char_mult_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_char_mult: returning $et_vect_char_mult_saved\" 2\n-    return $et_vect_char_mult_saved\n+    verbose \"check_effective_target_vect_char_mult:\\\n+\t     returning $et_vect_char_mult_saved($et_index)\" 2\n+    return $et_vect_char_mult_saved($et_index)\n }\n \n # Return 1 if the target supports vector short multiplication, 0 otherwise.\n \n proc check_effective_target_vect_short_mult { } {\n     global et_vect_short_mult_saved\n+    global et_index\n \n-    if [info exists et_vect_short_mult_saved] {\n+    if [info exists et_vect_short_mult_saved($et_index)] {\n \tverbose \"check_effective_target_vect_short_mult: using cached result\" 2\n     } else {\n-\tset et_vect_short_mult_saved 0\n+\tset et_vect_short_mult_saved($et_index) 0\n \tif { [istarget ia64-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [check_effective_target_arm32]\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mips_loongson]) } {\n-\t   set et_vect_short_mult_saved 1\n+\t\t && [et-is-effective-target mips_loongson]) } {\n+\t   set et_vect_short_mult_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_short_mult: returning $et_vect_short_mult_saved\" 2\n-    return $et_vect_short_mult_saved\n+    verbose \"check_effective_target_vect_short_mult:\\\n+\t     returning $et_vect_short_mult_saved($et_index)\" 2\n+    return $et_vect_short_mult_saved($et_index)\n }\n \n # Return 1 if the target supports vector int multiplication, 0 otherwise.\n \n proc check_effective_target_vect_int_mult { } {\n     global et_vect_int_mult_saved\n+    global et_index\n \n-    if [info exists et_vect_int_mult_saved] {\n+    if [info exists et_vect_int_mult_saved($et_index)] {\n \tverbose \"check_effective_target_vect_int_mult: using cached result\" 2\n     } else {\n-\tset et_vect_int_mult_saved 0\n+\tset et_vect_int_mult_saved($et_index) 0\n \tif { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [check_effective_target_arm32] } {\n-\t   set et_vect_int_mult_saved 1\n+\t   set et_vect_int_mult_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_int_mult: returning $et_vect_int_mult_saved\" 2\n-    return $et_vect_int_mult_saved\n+    verbose \"check_effective_target_vect_int_mult:\\\n+\t     returning $et_vect_int_mult_saved($et_index)\" 2\n+    return $et_vect_int_mult_saved($et_index)\n }\n \n # Return 1 if the target supports vector even/odd elements extraction, 0 otherwise.\n \n proc check_effective_target_vect_extract_even_odd { } {\n     global et_vect_extract_even_odd_saved\n+    global et_index\n     \n-    if [info exists et_vect_extract_even_odd_saved] {\n-        verbose \"check_effective_target_vect_extract_even_odd: using cached result\" 2\n+    if [info exists et_vect_extract_even_odd_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_extract_even_odd:\\\n+\t\t using cached result\" 2\n     } else {\n-        set et_vect_extract_even_odd_saved 0 \n+\tset et_vect_extract_even_odd_saved($et_index) 0\n \tif { [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [is-effective-target arm_neon_ok]\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget ia64-*-*]\n              || [istarget spu-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mpaired_single]) } {\n-\t    set et_vect_extract_even_odd_saved 1\n+\t\t && [et-is-effective-target mpaired_single]) } {\n+\t    set et_vect_extract_even_odd_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_extract_even_odd: returning $et_vect_extract_even_odd_saved\" 2\n-    return $et_vect_extract_even_odd_saved\n+    verbose \"check_effective_target_vect_extract_even_odd:\\\n+\t     returning $et_vect_extract_even_odd_saved($et_index)\" 2\n+    return $et_vect_extract_even_odd_saved($et_index)\n }\n \n # Return 1 if the target supports vector interleaving, 0 otherwise.\n \n proc check_effective_target_vect_interleave { } {\n     global et_vect_interleave_saved\n+    global et_index\n     \n-    if [info exists et_vect_interleave_saved] {\n+    if [info exists et_vect_interleave_saved($et_index)] {\n         verbose \"check_effective_target_vect_interleave: using cached result\" 2\n     } else {\n-        set et_vect_interleave_saved 0\n+\tset et_vect_interleave_saved($et_index) 0\n \tif { [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [is-effective-target arm_neon_ok]\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget ia64-*-*]\n              || [istarget spu-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [check_effective_target_mpaired_single]) } {\n-           set et_vect_interleave_saved 1\n+\t\t && [et-is-effective-target mpaired_single]) } {\n+\t   set et_vect_interleave_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect_interleave: returning $et_vect_interleave_saved\" 2\n-    return $et_vect_interleave_saved\n+    verbose \"check_effective_target_vect_interleave:\\\n+\t     returning $et_vect_interleave_saved($et_index)\" 2\n+    return $et_vect_interleave_saved($et_index)\n }\n \n foreach N {2 3 4 8} {\n     eval [string map [list N $N] {\n \t# Return 1 if the target supports 2-vector interleaving\n \tproc check_effective_target_vect_stridedN { } {\n \t    global et_vect_stridedN_saved\n+\t    global et_index\n \n-\t    if [info exists et_vect_stridedN_saved] {\n-\t\tverbose \"check_effective_target_vect_stridedN: using cached result\" 2\n+\t    if [info exists et_vect_stridedN_saved($et_index)] {\n+\t\tverbose \"check_effective_target_vect_stridedN:\\\n+\t\t\t using cached result\" 2\n \t    } else {\n-\t\tset et_vect_stridedN_saved 0\n+\t\tset et_vect_stridedN_saved($et_index) 0\n \t\tif { (N & -N) == N\n \t\t     && [check_effective_target_vect_interleave]\n \t\t     && [check_effective_target_vect_extract_even_odd] } {\n-\t\t    set et_vect_stridedN_saved 1\n+\t\t    set et_vect_stridedN_saved($et_index) 1\n \t\t}\n \t\tif { ([istarget arm*-*-*]\n \t\t      || [istarget aarch64*-*-*]) && N >= 2 && N <= 4 } {\n-\t\t    set et_vect_stridedN_saved 1\n+\t\t    set et_vect_stridedN_saved($et_index) 1\n \t\t}\n \t    }\n \n-\t    verbose \"check_effective_target_vect_stridedN: returning $et_vect_stridedN_saved\" 2\n-\t    return $et_vect_stridedN_saved\n+\t    verbose \"check_effective_target_vect_stridedN:\\\n+\t\t     returning $et_vect_stridedN_saved($et_index)\" 2\n+\t    return $et_vect_stridedN_saved($et_index)\n \t}\n     }]\n }\n@@ -5383,61 +5577,68 @@ foreach N {2 3 4 8} {\n \n proc check_effective_target_vect_multiple_sizes { } {\n     global et_vect_multiple_sizes_saved\n+    global et_index\n \n-    set et_vect_multiple_sizes_saved 0\n+    set et_vect_multiple_sizes_saved($et_index) 0\n     if { ([istarget aarch64*-*-*]\n \t  || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])) } {\n-       set et_vect_multiple_sizes_saved 1\n+       set et_vect_multiple_sizes_saved($et_index) 1\n     }\n     if { ([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n       if { ([check_avx_available] && ![check_prefer_avx128]) } {\n-\tset et_vect_multiple_sizes_saved 1\n+\tset et_vect_multiple_sizes_saved($et_index) 1\n       }\n     }\n \n-    verbose \"check_effective_target_vect_multiple_sizes: returning $et_vect_multiple_sizes_saved\" 2\n-    return $et_vect_multiple_sizes_saved\n+    verbose \"check_effective_target_vect_multiple_sizes:\\\n+\t     returning $et_vect_multiple_sizes_saved($et_index)\" 2\n+    return $et_vect_multiple_sizes_saved($et_index)\n }\n \n # Return 1 if the target supports vectors of 64 bits.\n \n proc check_effective_target_vect64 { } {\n     global et_vect64_saved\n+    global et_index\n \n-    if [info exists et_vect64_saved] {\n+    if [info exists et_vect64_saved($et_index)] {\n         verbose \"check_effective_target_vect64: using cached result\" 2\n     } else {\n-        set et_vect64_saved 0\n+\tset et_vect64_saved($et_index) 0\n         if { ([istarget arm*-*-*]\n \t      && [check_effective_target_arm_neon_ok]\n \t      && [check_effective_target_arm_little_endian])\n \t     || [istarget aarch64*-*-*]\n              || [istarget sparc*-*-*] } {\n-           set et_vect64_saved 1\n+\t   set et_vect64_saved($et_index) 1\n         }\n     }\n \n-    verbose \"check_effective_target_vect64: returning $et_vect64_saved\" 2\n-    return $et_vect64_saved\n+    verbose \"check_effective_target_vect64:\\\n+\t     returning $et_vect64_saved($et_index)\" 2\n+    return $et_vect64_saved($et_index)\n }\n \n # Return 1 if the target supports vector copysignf calls.\n \n proc check_effective_target_vect_call_copysignf { } {\n     global et_vect_call_copysignf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_copysignf_saved] {\n-\tverbose \"check_effective_target_vect_call_copysignf: using cached result\" 2\n+    if [info exists et_vect_call_copysignf_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_call_copysignf:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_call_copysignf_saved 0\n+\tset et_vect_call_copysignf_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*] } {\n-\t   set et_vect_call_copysignf_saved 1\n+\t   set et_vect_call_copysignf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_copysignf: returning $et_vect_call_copysignf_saved\" 2\n-    return $et_vect_call_copysignf_saved\n+    verbose \"check_effective_target_vect_call_copysignf:\\\n+\t     returning $et_vect_call_copysignf_saved($et_index)\" 2\n+    return $et_vect_call_copysignf_saved($et_index)\n }\n \n # Return 1 if the target supports hardware square root instructions.\n@@ -5465,20 +5666,22 @@ proc check_effective_target_sqrt_insn { } {\n \n proc check_effective_target_vect_call_sqrtf { } {\n     global et_vect_call_sqrtf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_sqrtf_saved] {\n+    if [info exists et_vect_call_sqrtf_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_sqrtf: using cached result\" 2\n     } else {\n-\tset et_vect_call_sqrtf_saved 0\n+\tset et_vect_call_sqrtf_saved($et_index) 0\n \tif { [istarget aarch64*-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available]) } {\n-\t    set et_vect_call_sqrtf_saved 1\n+\t    set et_vect_call_sqrtf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_sqrtf: returning $et_vect_call_sqrtf_saved\" 2\n-    return $et_vect_call_sqrtf_saved\n+    verbose \"check_effective_target_vect_call_sqrtf:\\\n+\t     returning $et_vect_call_sqrtf_saved($et_index)\" 2\n+    return $et_vect_call_sqrtf_saved($et_index)\n }\n \n # Return 1 if the target supports vector lrint calls.\n@@ -5498,216 +5701,243 @@ proc check_effective_target_vect_call_lrint { } {\n \n proc check_effective_target_vect_call_btrunc { } {\n     global et_vect_call_btrunc_saved\n+    global et_index\n \n-    if [info exists et_vect_call_btrunc_saved] {\n-\tverbose \"check_effective_target_vect_call_btrunc: using cached result\" 2\n+    if [info exists et_vect_call_btrunc_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_call_btrunc:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_call_btrunc_saved 0\n+\tset et_vect_call_btrunc_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_btrunc_saved 1\n+\t  set et_vect_call_btrunc_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_btrunc: returning $et_vect_call_btrunc_saved\" 2\n-    return $et_vect_call_btrunc_saved\n+    verbose \"check_effective_target_vect_call_btrunc:\\\n+\t     returning $et_vect_call_btrunc_saved($et_index)\" 2\n+    return $et_vect_call_btrunc_saved($et_index)\n }\n \n # Return 1 if the target supports vector btruncf calls.\n \n proc check_effective_target_vect_call_btruncf { } {\n     global et_vect_call_btruncf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_btruncf_saved] {\n-\tverbose \"check_effective_target_vect_call_btruncf: using cached result\" 2\n+    if [info exists et_vect_call_btruncf_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_call_btruncf:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_call_btruncf_saved 0\n+\tset et_vect_call_btruncf_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_btruncf_saved 1\n+\t  set et_vect_call_btruncf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_btruncf: returning $et_vect_call_btruncf_saved\" 2\n-    return $et_vect_call_btruncf_saved\n+    verbose \"check_effective_target_vect_call_btruncf:\\\n+\t     returning $et_vect_call_btruncf_saved($et_index)\" 2\n+    return $et_vect_call_btruncf_saved($et_index)\n }\n \n # Return 1 if the target supports vector ceil calls.\n \n proc check_effective_target_vect_call_ceil { } {\n     global et_vect_call_ceil_saved\n+    global et_index\n \n-    if [info exists et_vect_call_ceil_saved] {\n+    if [info exists et_vect_call_ceil_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_ceil: using cached result\" 2\n     } else {\n-\tset et_vect_call_ceil_saved 0\n+\tset et_vect_call_ceil_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_ceil_saved 1\n+\t  set et_vect_call_ceil_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_ceil: returning $et_vect_call_ceil_saved\" 2\n-    return $et_vect_call_ceil_saved\n+    verbose \"check_effective_target_vect_call_ceil:\\\n+\t     returning $et_vect_call_ceil_saved($et_index)\" 2\n+    return $et_vect_call_ceil_saved($et_index)\n }\n \n # Return 1 if the target supports vector ceilf calls.\n \n proc check_effective_target_vect_call_ceilf { } {\n     global et_vect_call_ceilf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_ceilf_saved] {\n+    if [info exists et_vect_call_ceilf_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_ceilf: using cached result\" 2\n     } else {\n-\tset et_vect_call_ceilf_saved 0\n+\tset et_vect_call_ceilf_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_ceilf_saved 1\n+\t  set et_vect_call_ceilf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_ceilf: returning $et_vect_call_ceilf_saved\" 2\n-    return $et_vect_call_ceilf_saved\n+    verbose \"check_effective_target_vect_call_ceilf:\\\n+\t     returning $et_vect_call_ceilf_saved($et_index)\" 2\n+    return $et_vect_call_ceilf_saved($et_index)\n }\n \n # Return 1 if the target supports vector floor calls.\n \n proc check_effective_target_vect_call_floor { } {\n     global et_vect_call_floor_saved\n+    global et_index\n \n-    if [info exists et_vect_call_floor_saved] {\n+    if [info exists et_vect_call_floor_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_floor: using cached result\" 2\n     } else {\n-\tset et_vect_call_floor_saved 0\n+\tset et_vect_call_floor_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_floor_saved 1\n+\t  set et_vect_call_floor_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_floor: returning $et_vect_call_floor_saved\" 2\n-    return $et_vect_call_floor_saved\n+    verbose \"check_effective_target_vect_call_floor:\\\n+\t     returning $et_vect_call_floor_saved($et_index)\" 2\n+    return $et_vect_call_floor_saved($et_index)\n }\n \n # Return 1 if the target supports vector floorf calls.\n \n proc check_effective_target_vect_call_floorf { } {\n     global et_vect_call_floorf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_floorf_saved] {\n+    if [info exists et_vect_call_floorf_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_floorf: using cached result\" 2\n     } else {\n-\tset et_vect_call_floorf_saved 0\n+\tset et_vect_call_floorf_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_floorf_saved 1\n+\t  set et_vect_call_floorf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_floorf: returning $et_vect_call_floorf_saved\" 2\n-    return $et_vect_call_floorf_saved\n+    verbose \"check_effective_target_vect_call_floorf:\\\n+\t     returning $et_vect_call_floorf_saved($et_index)\" 2\n+    return $et_vect_call_floorf_saved($et_index)\n }\n \n # Return 1 if the target supports vector lceil calls.\n \n proc check_effective_target_vect_call_lceil { } {\n     global et_vect_call_lceil_saved\n+    global et_index\n \n-    if [info exists et_vect_call_lceil_saved] {\n+    if [info exists et_vect_call_lceil_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_lceil: using cached result\" 2\n     } else {\n-\tset et_vect_call_lceil_saved 0\n+\tset et_vect_call_lceil_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_lceil_saved 1\n+\t  set et_vect_call_lceil_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_lceil: returning $et_vect_call_lceil_saved\" 2\n-    return $et_vect_call_lceil_saved\n+    verbose \"check_effective_target_vect_call_lceil:\\\n+\t     returning $et_vect_call_lceil_saved($et_index)\" 2\n+    return $et_vect_call_lceil_saved($et_index)\n }\n \n # Return 1 if the target supports vector lfloor calls.\n \n proc check_effective_target_vect_call_lfloor { } {\n     global et_vect_call_lfloor_saved\n+    global et_index\n \n-    if [info exists et_vect_call_lfloor_saved] {\n+    if [info exists et_vect_call_lfloor_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_lfloor: using cached result\" 2\n     } else {\n-\tset et_vect_call_lfloor_saved 0\n+\tset et_vect_call_lfloor_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_lfloor_saved 1\n+\t  set et_vect_call_lfloor_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_lfloor: returning $et_vect_call_lfloor_saved\" 2\n-    return $et_vect_call_lfloor_saved\n+    verbose \"check_effective_target_vect_call_lfloor:\\\n+\t     returning $et_vect_call_lfloor_saved($et_index)\" 2\n+    return $et_vect_call_lfloor_saved($et_index)\n }\n \n # Return 1 if the target supports vector nearbyint calls.\n \n proc check_effective_target_vect_call_nearbyint { } {\n     global et_vect_call_nearbyint_saved\n+    global et_index\n \n-    if [info exists et_vect_call_nearbyint_saved] {\n+    if [info exists et_vect_call_nearbyint_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_nearbyint: using cached result\" 2\n     } else {\n-\tset et_vect_call_nearbyint_saved 0\n+\tset et_vect_call_nearbyint_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_nearbyint_saved 1\n+\t  set et_vect_call_nearbyint_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_nearbyint: returning $et_vect_call_nearbyint_saved\" 2\n-    return $et_vect_call_nearbyint_saved\n+    verbose \"check_effective_target_vect_call_nearbyint:\\\n+\t     returning $et_vect_call_nearbyint_saved($et_index)\" 2\n+    return $et_vect_call_nearbyint_saved($et_index)\n }\n \n # Return 1 if the target supports vector nearbyintf calls.\n \n proc check_effective_target_vect_call_nearbyintf { } {\n     global et_vect_call_nearbyintf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_nearbyintf_saved] {\n-\tverbose \"check_effective_target_vect_call_nearbyintf: using cached result\" 2\n+    if [info exists et_vect_call_nearbyintf_saved($et_index)] {\n+\tverbose \"check_effective_target_vect_call_nearbyintf:\\\n+\t\t using cached result\" 2\n     } else {\n-\tset et_vect_call_nearbyintf_saved 0\n+\tset et_vect_call_nearbyintf_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_nearbyintf_saved 1\n+\t  set et_vect_call_nearbyintf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_nearbyintf: returning $et_vect_call_nearbyintf_saved\" 2\n-    return $et_vect_call_nearbyintf_saved\n+    verbose \"check_effective_target_vect_call_nearbyintf:\\\n+\t     returning $et_vect_call_nearbyintf_saved($et_index)\" 2\n+    return $et_vect_call_nearbyintf_saved($et_index)\n }\n \n # Return 1 if the target supports vector round calls.\n \n proc check_effective_target_vect_call_round { } {\n     global et_vect_call_round_saved\n+    global et_index\n \n-    if [info exists et_vect_call_round_saved] {\n+    if [info exists et_vect_call_round_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_round: using cached result\" 2\n     } else {\n-\tset et_vect_call_round_saved 0\n+\tset et_vect_call_round_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_round_saved 1\n+\t  set et_vect_call_round_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_round: returning $et_vect_call_round_saved\" 2\n-    return $et_vect_call_round_saved\n+    verbose \"check_effective_target_vect_call_round:\\\n+\t     returning $et_vect_call_round_saved($et_index)\" 2\n+    return $et_vect_call_round_saved($et_index)\n }\n \n # Return 1 if the target supports vector roundf calls.\n \n proc check_effective_target_vect_call_roundf { } {\n     global et_vect_call_roundf_saved\n+    global et_index\n \n-    if [info exists et_vect_call_roundf_saved] {\n+    if [info exists et_vect_call_roundf_saved($et_index)] {\n \tverbose \"check_effective_target_vect_call_roundf: using cached result\" 2\n     } else {\n-\tset et_vect_call_roundf_saved 0\n+\tset et_vect_call_roundf_saved($et_index) 0\n \tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_roundf_saved 1\n+\t  set et_vect_call_roundf_saved($et_index) 1\n \t}\n     }\n \n-    verbose \"check_effective_target_vect_call_roundf: returning $et_vect_call_roundf_saved\" 2\n-    return $et_vect_call_roundf_saved\n+    verbose \"check_effective_target_vect_call_roundf:\\\n+\t     returning $et_vect_call_roundf_saved($et_index)\" 2\n+    return $et_vect_call_roundf_saved($et_index)\n }\n \n # Return 1 if the target supports section-anchors\n@@ -6104,7 +6334,13 @@ proc check_effective_target_init_priority {} {\n # arguments with keywords that pass particular arguments.\n \n proc is-effective-target { arg } {\n+    global et_index\n     set selected 0\n+    if { ![info exists et_index] } {\n+\t# Initialize the effective target index that is used in some\n+\t# check_effective_target_* procs.\n+\tset et_index 0\n+    }\n     if { [info procs check_effective_target_${arg}] != [list] } {\n \tset selected [check_effective_target_${arg}]\n     } else {\n@@ -6155,6 +6391,50 @@ proc is-effective-target-keyword { arg } {\n     }\n }\n \n+# Execute tests for all targets in EFFECTIVE_TARGETS list.  Set et_index to\n+# indicate what target is currently being processed.  This is for\n+# the vectorizer tests, e.g. vect_int, to keep track what target supports\n+# a given feature.\n+\n+proc et-dg-runtest { runtest testcases flags default-extra-flags } {\n+    global dg-do-what-default\n+    global EFFECTIVE_TARGETS\n+    global et_index\n+\n+    if { [llength $EFFECTIVE_TARGETS] > 0 } {\n+\tforeach target $EFFECTIVE_TARGETS {\n+\t    set target_flags $flags\n+\t    set dg-do-what-default compile\n+\t    set et_index [lsearch -exact $EFFECTIVE_TARGETS $target]\n+\t    if { [info procs add_options_for_${target}] != [list] } {\n+\t\tset target_flags [add_options_for_${target} \"$flags\"]\n+\t    }\n+\t    if { [info procs check_effective_target_${target}_runtime]\n+\t\t != [list] && [check_effective_target_${target}_runtime] } {\n+\t\tset dg-do-what-default run\n+\t    }\n+\t    $runtest $testcases $target_flags ${default-extra-flags}\n+\t}\n+    } else {\n+\tset et_index 0\n+\t$runtest $testcases $flags ${default-extra-flags}\n+    }\n+}\n+\n+# Return 1 if a target matches the target in EFFECTIVE_TARGETS at index\n+# et_index, 0 otherwise.\n+\n+proc et-is-effective-target { target } {\n+    global EFFECTIVE_TARGETS\n+    global et_index\n+\n+    if { [llength $EFFECTIVE_TARGETS] > $et_index\n+\t && [lindex $EFFECTIVE_TARGETS $et_index] == $target } {\n+\t    return 1\n+    }\n+    return 0\n+}\n+\n # Return 1 if target default to short enums\n \n proc check_effective_target_short_enums { } {\n@@ -6855,13 +7135,19 @@ proc check_effective_target_stpcpy {} {\n \n # Check whether the vectorizer tests are supported by the target and\n # append additional target-dependent compile flags to DEFAULT_VECTCFLAGS.\n+# If a port wants to execute the tests more than once it should append\n+# the supported target to EFFECTIVE_TARGETS instead, and the compile flags\n+# will be added by a call to add_options_for_<target>.\n # Set dg-do-what-default to either compile or run, depending on target\n-# capabilities.  Return 1 if vectorizer tests are supported by\n-# target, 0 otherwise.\n+# capabilities.  Do not set this if the supported target is appended to\n+# EFFECTIVE_TARGETS.  Flags and this variable will be set by et-dg-runtest\n+# automatically.  Return the number of effective targets if vectorizer tests\n+# are supported, 0 otherwise.\n \n proc check_vect_support_and_set_flags { } {\n     global DEFAULT_VECTCFLAGS\n     global dg-do-what-default\n+    global EFFECTIVE_TARGETS\n \n     if  [istarget powerpc-*paired*]  {\n         lappend DEFAULT_VECTCFLAGS \"-mpaired\"\n@@ -6904,13 +7190,14 @@ proc check_vect_support_and_set_flags { } {\n             set dg-do-what-default compile\n         }\n     } elseif { [istarget mips*-*-*]\n-               && ([check_effective_target_mpaired_single]\n-                    || [check_effective_target_mips_loongson])\n-               && [check_effective_target_nomips16] } {\n-        if { [check_effective_target_mpaired_single] } {\n-            lappend DEFAULT_VECTCFLAGS \"-mpaired-single\"\n+\t       && [check_effective_target_nomips16] } {\n+\tif { [check_effective_target_mpaired_single] } {\n+\t    lappend EFFECTIVE_TARGETS mpaired_single\n+\t}\n+\tif { [check_effective_target_mips_loongson] } {\n+\t    lappend EFFECTIVE_TARGETS mips_loongson\n         }\n-        set dg-do-what-default run\n+\treturn [llength $EFFECTIVE_TARGETS]\n     } elseif [istarget sparc*-*-*] {\n         lappend DEFAULT_VECTCFLAGS \"-mcpu=ultrasparc\" \"-mvis\"\n         if [check_effective_target_ultrasparc_hw] {"}]}