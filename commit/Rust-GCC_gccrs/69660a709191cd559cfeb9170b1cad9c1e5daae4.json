{"sha": "69660a709191cd559cfeb9170b1cad9c1e5daae4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk2NjBhNzA5MTkxY2Q1NTljZmViOTE3MGIxY2FkOWMxZTVkYWFlNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-08T12:57:50Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-08T12:57:50Z"}, "message": "optabs.c (expand_binop): Use GET_MODE_PRECISION instead of GET_MODE_BITSIZE where appropriate.\n\n\t* optabs.c (expand_binop): Use GET_MODE_PRECISION instead of\n\tGET_MODE_BITSIZE where appropriate.\n\t(widen_leading, expand_parity, expand_ctz, expand_ffs,\n\texpand_unop, expand_abs_nojump, expand_one_cmpl_abs_nojump,\n\texpand_float, expand_fix): Likewise.\n\t* expr.c (convert_move, convert_modes, expand_expr_real_2,\n\texpand_expr_real_1, reduce_to_bit_field_precision): Likewise.\n\t* cfgexpand.c (convert_debug_memory_address, expand_debug_expr):\n\tLikewise.\n\t* convert.c (convert_to_integer): Likewise.\n\t* expmed.c (expand_shift_1): Likewise.\n\nFrom-SVN: r176038", "tree": {"sha": "dbfc3d0e9b173b47f6d2222de19d36b1c0d27471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbfc3d0e9b173b47f6d2222de19d36b1c0d27471"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69660a709191cd559cfeb9170b1cad9c1e5daae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69660a709191cd559cfeb9170b1cad9c1e5daae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69660a709191cd559cfeb9170b1cad9c1e5daae4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69660a709191cd559cfeb9170b1cad9c1e5daae4/comments", "author": null, "committer": null, "parents": [{"sha": "2c50b2c366a178161e90caad85d9dd883b5bfa90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c50b2c366a178161e90caad85d9dd883b5bfa90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c50b2c366a178161e90caad85d9dd883b5bfa90"}], "stats": {"total": 106, "additions": 61, "deletions": 45}, "files": [{"sha": "ff37cdab3ac05cd63cd67449ddc41e180c885884", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69660a709191cd559cfeb9170b1cad9c1e5daae4", "patch": "@@ -1,3 +1,18 @@\n+2011-07-08  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* optabs.c (expand_binop): Use GET_MODE_PRECISION instead of\n+\tGET_MODE_BITSIZE where appropriate.\n+\t(widen_leading, expand_parity, expand_ctz, expand_ffs,\n+\texpand_unop, expand_abs_nojump, expand_one_cmpl_abs_nojump,\n+\texpand_float, expand_fix): Likewise.\n+\t* expr.c (convert_move, convert_modes, expand_expr_real_2,\n+\texpand_expr_real_1, reduce_to_bit_field_precision): Likewise.\n+\t* stor-layout.c (get_mode_bounds): Likewise.\n+\t* cfgexpand.c (convert_debug_memory_address, expand_debug_expr):\n+\tLikewise.\n+\t* convert.c (convert_to_integer): Likewise.\n+\t* expmed.c (expand_shift_1): Likewise.\n+\n 2011-07-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Makefile.in (LIBGCOV): Remove."}, {"sha": "60e57523ea1bd3ce47127967c5c81fecdb223036", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=69660a709191cd559cfeb9170b1cad9c1e5daae4", "patch": "@@ -2303,7 +2303,7 @@ convert_debug_memory_address (enum machine_mode mode, rtx x,\n   if (GET_MODE (x) == mode || GET_MODE (x) == VOIDmode)\n     return x;\n \n-  if (GET_MODE_BITSIZE (mode) < GET_MODE_BITSIZE (xmode))\n+  if (GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (xmode))\n     x = simplify_gen_subreg (mode, x, xmode,\n \t\t\t     subreg_lowpart_offset\n \t\t\t     (mode, xmode));\n@@ -2558,7 +2558,7 @@ expand_debug_expr (tree exp)\n \t      op0 = simplify_gen_unary (FIX, mode, op0, inner_mode);\n \t  }\n \telse if (CONSTANT_P (op0)\n-\t\t || GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (inner_mode))\n+\t\t || GET_MODE_PRECISION (mode) <= GET_MODE_PRECISION (inner_mode))\n \t  op0 = simplify_gen_subreg (mode, op0, inner_mode,\n \t\t\t\t     subreg_lowpart_offset (mode,\n \t\t\t\t\t\t\t    inner_mode));"}, {"sha": "84ba13d1812f4b3439fceee55d2ad5d7c6ca4646", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=69660a709191cd559cfeb9170b1cad9c1e5daae4", "patch": "@@ -583,7 +583,7 @@ convert_to_integer (tree type, tree expr)\n \t     be cleared.  */\n \t  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (TREE_TYPE (expr))\n \t      && (TYPE_PRECISION (TREE_TYPE (expr))\n-\t\t  != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (expr)))))\n+\t\t  != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (expr)))))\n \t    code = CONVERT_EXPR;\n \t  else\n \t    code = NOP_EXPR;\n@@ -602,7 +602,7 @@ convert_to_integer (tree type, tree expr)\n \t type corresponding to its mode, then do a nop conversion\n \t to TYPE.  */\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t       || outprec != GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t       || outprec != GET_MODE_PRECISION (TYPE_MODE (type)))\n \treturn build1 (NOP_EXPR, type,\n \t\t       convert (lang_hooks.types.type_for_mode\n \t\t\t\t(TYPE_MODE (type), TYPE_UNSIGNED (type)),"}, {"sha": "272994f7f430eacdfe0225bdbf516a1fc852cb1f", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=69660a709191cd559cfeb9170b1cad9c1e5daae4", "patch": "@@ -2090,7 +2090,7 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n   if (code == LSHIFT_EXPR\n       && CONST_INT_P (op1)\n       && INTVAL (op1) > 0\n-      && INTVAL (op1) < GET_MODE_BITSIZE (mode)\n+      && INTVAL (op1) < GET_MODE_PRECISION (mode)\n       && INTVAL (op1) < MAX_BITS_PER_WORD\n       && shift_cost[speed][mode][INTVAL (op1)] > INTVAL (op1) * add_cost[speed][mode]\n       && shift_cost[speed][mode][INTVAL (op1)] != MAX_COST)\n@@ -2146,7 +2146,7 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t      else\n \t\tother_amount\n \t\t  = simplify_gen_binary (MINUS, GET_MODE (op1),\n-\t\t\t\t\t GEN_INT (GET_MODE_BITSIZE (mode)),\n+\t\t\t\t\t GEN_INT (GET_MODE_PRECISION (mode)),\n \t\t\t\t\t op1);\n \n \t      shifted = force_reg (mode, shifted);"}, {"sha": "fb4379f8108dd9bf104fd5ade139a7df74fcfba6", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=69660a709191cd559cfeb9170b1cad9c1e5daae4", "patch": "@@ -336,8 +336,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n      TO here.  */\n \n   if (GET_CODE (from) == SUBREG && SUBREG_PROMOTED_VAR_P (from)\n-      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (from)))\n-\t  >= GET_MODE_SIZE (to_mode))\n+      && (GET_MODE_PRECISION (GET_MODE (SUBREG_REG (from)))\n+\t  >= GET_MODE_PRECISION (to_mode))\n       && SUBREG_PROMOTED_UNSIGNED_P (from) == unsignedp)\n     from = gen_lowpart (to_mode, from), from_mode = to_mode;\n \n@@ -478,8 +478,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n   /* Now both modes are integers.  */\n \n   /* Handle expanding beyond a word.  */\n-  if (GET_MODE_BITSIZE (from_mode) < GET_MODE_BITSIZE (to_mode)\n-      && GET_MODE_BITSIZE (to_mode) > BITS_PER_WORD)\n+  if (GET_MODE_PRECISION (from_mode) < GET_MODE_PRECISION (to_mode)\n+      && GET_MODE_PRECISION (to_mode) > BITS_PER_WORD)\n     {\n       rtx insns;\n       rtx lowpart;\n@@ -503,7 +503,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t  return;\n \t}\n       /* Next, try converting via full word.  */\n-      else if (GET_MODE_BITSIZE (from_mode) < BITS_PER_WORD\n+      else if (GET_MODE_PRECISION (from_mode) < BITS_PER_WORD\n \t       && ((code = can_extend_p (to_mode, word_mode, unsignedp))\n \t\t   != CODE_FOR_nothing))\n \t{\n@@ -529,7 +529,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \tfrom = force_reg (from_mode, from);\n \n       /* Get a copy of FROM widened to a word, if necessary.  */\n-      if (GET_MODE_BITSIZE (from_mode) < BITS_PER_WORD)\n+      if (GET_MODE_PRECISION (from_mode) < BITS_PER_WORD)\n \tlowpart_mode = word_mode;\n       else\n \tlowpart_mode = from_mode;\n@@ -567,8 +567,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n     }\n \n   /* Truncating multi-word to a word or less.  */\n-  if (GET_MODE_BITSIZE (from_mode) > BITS_PER_WORD\n-      && GET_MODE_BITSIZE (to_mode) <= BITS_PER_WORD)\n+  if (GET_MODE_PRECISION (from_mode) > BITS_PER_WORD\n+      && GET_MODE_PRECISION (to_mode) <= BITS_PER_WORD)\n     {\n       if (!((MEM_P (from)\n \t     && ! MEM_VOLATILE_P (from)\n@@ -603,7 +603,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n     }\n \n   /* Handle extension.  */\n-  if (GET_MODE_BITSIZE (to_mode) > GET_MODE_BITSIZE (from_mode))\n+  if (GET_MODE_PRECISION (to_mode) > GET_MODE_PRECISION (from_mode))\n     {\n       /* Convert directly if that works.  */\n       if ((code = can_extend_p (to_mode, from_mode, unsignedp))\n@@ -635,8 +635,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n \t  /* No suitable intermediate mode.\n \t     Generate what we need with\tshifts.  */\n-\t  shift_amount = (GET_MODE_BITSIZE (to_mode)\n-\t\t\t  - GET_MODE_BITSIZE (from_mode));\n+\t  shift_amount = (GET_MODE_PRECISION (to_mode)\n+\t\t\t  - GET_MODE_PRECISION (from_mode));\n \t  from = gen_lowpart (to_mode, force_reg (from_mode, from));\n \t  tmp = expand_shift (LSHIFT_EXPR, to_mode, from, shift_amount,\n \t\t\t      to, unsignedp);\n@@ -664,7 +664,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n      ??? Code above formerly short-circuited this, for most integer\n      mode pairs, with a force_reg in from_mode followed by a recursive\n      call to this routine.  Appears always to have been wrong.  */\n-  if (GET_MODE_BITSIZE (to_mode) < GET_MODE_BITSIZE (from_mode))\n+  if (GET_MODE_PRECISION (to_mode) < GET_MODE_PRECISION (from_mode))\n     {\n       rtx temp = force_reg (to_mode, gen_lowpart (to_mode, from));\n       emit_move_insn (to, temp);\n@@ -742,11 +742,11 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n      wider than HOST_BITS_PER_WIDE_INT, we must be narrowing the operand.  */\n \n   if ((CONST_INT_P (x)\n-       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+       && GET_MODE_PRECISION (mode) <= HOST_BITS_PER_WIDE_INT)\n       || (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_CLASS (oldmode) == MODE_INT\n \t  && (GET_CODE (x) == CONST_DOUBLE\n-\t      || (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (oldmode)\n+\t      || (GET_MODE_PRECISION (mode) <= GET_MODE_PRECISION (oldmode)\n \t\t  && ((MEM_P (x) && ! MEM_VOLATILE_P (x)\n \t\t       && direct_load[(int) mode])\n \t\t      || (REG_P (x)\n@@ -759,7 +759,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n \t X does not need sign- or zero-extension.   This may not be\n \t the case, but it's the best we can do.  */\n       if (CONST_INT_P (x) && oldmode != VOIDmode\n-\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (oldmode))\n+\t  && GET_MODE_PRECISION (mode) > GET_MODE_PRECISION (oldmode))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (x);\n \n@@ -4279,7 +4279,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       if (!MEM_P (to_rtx)\n \t  && GET_MODE (to_rtx) != BLKmode\n \t  && (unsigned HOST_WIDE_INT) bitpos\n-\t     >= GET_MODE_BITSIZE (GET_MODE (to_rtx)))\n+\t     >= GET_MODE_PRECISION (GET_MODE (to_rtx)))\n \t{\n \t  expand_normal (from);\n \t  result = NULL;\n@@ -7476,7 +7476,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  if (modifier == EXPAND_STACK_PARM)\n \t    target = 0;\n \t  if (TREE_CODE (treeop0) == INTEGER_CST\n-\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && GET_MODE_PRECISION (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && TREE_CONSTANT (treeop1))\n \t    {\n \t      rtx constant_part;\n@@ -7498,7 +7498,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t    }\n \n \t  else if (TREE_CODE (treeop1) == INTEGER_CST\n-\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t\t   && GET_MODE_PRECISION (mode) <= HOST_BITS_PER_WIDE_INT\n \t\t   && TREE_CONSTANT (treeop0))\n \t    {\n \t      rtx constant_part;\n@@ -8968,7 +8968,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t   we can't do this optimization.  */\n \t\t&& (! DECL_BIT_FIELD (field)\n \t\t    || ((GET_MODE_CLASS (DECL_MODE (field)) == MODE_INT)\n-\t\t\t&& (GET_MODE_BITSIZE (DECL_MODE (field))\n+\t\t\t&& (GET_MODE_PRECISION (DECL_MODE (field))\n \t\t\t    <= HOST_BITS_PER_WIDE_INT))))\n \t      {\n \t\tif (DECL_BIT_FIELD (field)\n@@ -8987,7 +8987,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tint count = GET_MODE_BITSIZE (imode) - bitsize;\n+\t\t\tint count = GET_MODE_PRECISION (imode) - bitsize;\n \n \t\t\top0 = expand_shift (LSHIFT_EXPR, imode, op0, count,\n \t\t\t\t\t    target, 0);\n@@ -9431,7 +9431,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* If neither mode is BLKmode, and both modes are the same size\n \t then we can use gen_lowpart.  */\n       else if (mode != BLKmode && GET_MODE (op0) != BLKmode\n-\t       && GET_MODE_SIZE (mode) == GET_MODE_SIZE (GET_MODE (op0))\n+\t       && (GET_MODE_PRECISION (mode)\n+\t\t   == GET_MODE_PRECISION (GET_MODE (op0)))\n \t       && !COMPLEX_MODE_P (GET_MODE (op0)))\n \t{\n \t  if (GET_CODE (op0) == SUBREG)\n@@ -9754,7 +9755,7 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n     }\n   else\n     {\n-      int count = GET_MODE_BITSIZE (GET_MODE (exp)) - prec;\n+      int count = GET_MODE_PRECISION (GET_MODE (exp)) - prec;\n       exp = expand_shift (LSHIFT_EXPR, GET_MODE (exp),\n \t\t\t  exp, count, target, 0);\n       return expand_shift (RSHIFT_EXPR, GET_MODE (exp),"}, {"sha": "e1e172b5d0dc28d59dd418cb8474bd9df50e5434", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69660a709191cd559cfeb9170b1cad9c1e5daae4/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=69660a709191cd559cfeb9170b1cad9c1e5daae4", "patch": "@@ -1407,7 +1407,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n     {\n       optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n       rtx newop1;\n-      unsigned int bits = GET_MODE_BITSIZE (mode);\n+      unsigned int bits = GET_MODE_PRECISION (mode);\n \n       if (CONST_INT_P (op1))\n         newop1 = GEN_INT (bits - INTVAL (op1));\n@@ -2353,8 +2353,8 @@ widen_leading (enum machine_mode mode, rtx op0, rtx target, optab unoptab)\n \t\t\t\t  unoptab != clrsb_optab);\n \t      if (temp != 0)\n \t\ttemp = expand_binop (wider_mode, sub_optab, temp,\n-\t\t\t\t     GEN_INT (GET_MODE_BITSIZE (wider_mode)\n-\t\t\t\t\t      - GET_MODE_BITSIZE (mode)),\n+\t\t\t\t     GEN_INT (GET_MODE_PRECISION (wider_mode)\n+\t\t\t\t\t      - GET_MODE_PRECISION (mode)),\n \t\t\t\t     target, true, OPTAB_DIRECT);\n \t      if (temp == 0)\n \t\tdelete_insns_since (last);\n@@ -2540,7 +2540,7 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n }\n \n /* Try calculating ctz(x) as K - clz(x & -x) ,\n-   where K is GET_MODE_BITSIZE(mode) - 1.\n+   where K is GET_MODE_PRECISION(mode) - 1.\n \n    Both __builtin_ctz and __builtin_clz are undefined at zero, so we\n    don't have to worry about what the hardware does in that case.  (If\n@@ -2568,7 +2568,7 @@ expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n   if (temp)\n     temp = expand_unop_direct (mode, clz_optab, temp, NULL_RTX, true);\n   if (temp)\n-    temp = expand_binop (mode, sub_optab, GEN_INT (GET_MODE_BITSIZE (mode) - 1),\n+    temp = expand_binop (mode, sub_optab, GEN_INT (GET_MODE_PRECISION (mode) - 1),\n \t\t\t temp, target,\n \t\t\t true, OPTAB_DIRECT);\n   if (temp == 0)\n@@ -2619,7 +2619,7 @@ expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n       if (CLZ_DEFINED_VALUE_AT_ZERO (mode, val) == 2)\n \t{\n \t  defined_at_zero = true;\n-\t  val = (GET_MODE_BITSIZE (mode) - 1) - val;\n+\t  val = (GET_MODE_PRECISION (mode) - 1) - val;\n \t}\n     }\n   else\n@@ -3077,8 +3077,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t      if ((unoptab == clz_optab || unoptab == clrsb_optab)\n \t\t  && temp != 0)\n \t\ttemp = expand_binop (wider_mode, sub_optab, temp,\n-\t\t\t\t     GEN_INT (GET_MODE_BITSIZE (wider_mode)\n-\t\t\t\t\t      - GET_MODE_BITSIZE (mode)),\n+\t\t\t\t     GEN_INT (GET_MODE_PRECISION (wider_mode)\n+\t\t\t\t\t      - GET_MODE_PRECISION (mode)),\n \t\t\t\t     target, true, OPTAB_DIRECT);\n \n \t      if (temp)\n@@ -3173,7 +3173,7 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n \t      \t      false) >= 2)\n     {\n       rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t   GET_MODE_BITSIZE (mode) - 1,\n+\t\t\t\t   GET_MODE_PRECISION (mode) - 1,\n \t\t\t\t   NULL_RTX, 0);\n \n       temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n@@ -3274,7 +3274,7 @@ expand_one_cmpl_abs_nojump (enum machine_mode mode, rtx op0, rtx target)\n \t             false) >= 2)\n     {\n       rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t   GET_MODE_BITSIZE (mode) - 1,\n+\t\t\t\t   GET_MODE_PRECISION (mode) - 1,\n \t\t\t\t   NULL_RTX, 0);\n \n       temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n@@ -4663,7 +4663,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \tint doing_unsigned = unsignedp;\n \n \tif (fmode != GET_MODE (to)\n-\t    && significand_size (fmode) < GET_MODE_BITSIZE (GET_MODE (from)))\n+\t    && significand_size (fmode) < GET_MODE_PRECISION (GET_MODE (from)))\n \t  continue;\n \n \ticode = can_float_p (fmode, imode, unsignedp);\n@@ -4707,7 +4707,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \n       for (fmode = GET_MODE (to);  fmode != VOIDmode;\n \t   fmode = GET_MODE_WIDER_MODE (fmode))\n-\tif (GET_MODE_BITSIZE (GET_MODE (from)) < GET_MODE_BITSIZE (fmode)\n+\tif (GET_MODE_PRECISION (GET_MODE (from)) < GET_MODE_BITSIZE (fmode)\n \t    && can_float_p (fmode, GET_MODE (from), 0) != CODE_FOR_nothing)\n \t  break;\n \n@@ -4718,7 +4718,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \n \t  /* Avoid double-rounding when TO is narrower than FROM.  */\n \t  if ((significand_size (fmode) + 1)\n-\t      < GET_MODE_BITSIZE (GET_MODE (from)))\n+\t      < GET_MODE_PRECISION (GET_MODE (from)))\n \t    {\n \t      rtx temp1;\n \t      rtx neglabel = gen_label_rtx ();\n@@ -4785,7 +4785,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t\t\t       0, label);\n \n \n-      real_2expN (&offset, GET_MODE_BITSIZE (GET_MODE (from)), fmode);\n+      real_2expN (&offset, GET_MODE_PRECISION (GET_MODE (from)), fmode);\n       temp = expand_binop (fmode, add_optab, target,\n \t\t\t   CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n@@ -4915,18 +4915,18 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      2^63.  The subtraction of 2^63 should not generate any rounding as it\n      simply clears out that bit.  The rest is trivial.  */\n \n-  if (unsignedp && GET_MODE_BITSIZE (GET_MODE (to)) <= HOST_BITS_PER_WIDE_INT)\n+  if (unsignedp && GET_MODE_PRECISION (GET_MODE (to)) <= HOST_BITS_PER_WIDE_INT)\n     for (fmode = GET_MODE (from); fmode != VOIDmode;\n \t fmode = GET_MODE_WIDER_MODE (fmode))\n       if (CODE_FOR_nothing != can_fix_p (GET_MODE (to), fmode, 0, &must_trunc)\n \t  && (!DECIMAL_FLOAT_MODE_P (fmode)\n-\t      || GET_MODE_BITSIZE (fmode) > GET_MODE_BITSIZE (GET_MODE (to))))\n+\t      || GET_MODE_BITSIZE (fmode) > GET_MODE_PRECISION (GET_MODE (to))))\n \t{\n \t  int bitsize;\n \t  REAL_VALUE_TYPE offset;\n \t  rtx limit, lab1, lab2, insn;\n \n-\t  bitsize = GET_MODE_BITSIZE (GET_MODE (to));\n+\t  bitsize = GET_MODE_PRECISION (GET_MODE (to));\n \t  real_2expN (&offset, bitsize - 1, fmode);\n \t  limit = CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode);\n \t  lab1 = gen_label_rtx ();"}]}