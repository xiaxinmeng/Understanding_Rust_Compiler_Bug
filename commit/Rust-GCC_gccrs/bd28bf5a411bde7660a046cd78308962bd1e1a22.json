{"sha": "bd28bf5a411bde7660a046cd78308962bd1e1a22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQyOGJmNWE0MTFiZGU3NjYwYTA0NmNkNzgzMDg5NjJiZDFlMWEyMg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-01-19T10:11:00Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-01-19T10:11:00Z"}, "message": "arm/lib1funcs.asm (__divsi3, __modsi3, __udivsi3, __umodsi3): Replace\nwith smaller, faster versions.\n\nFrom-SVN: r11070", "tree": {"sha": "e7273b9707b412666712c0271a514bf4999b7cac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7273b9707b412666712c0271a514bf4999b7cac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd28bf5a411bde7660a046cd78308962bd1e1a22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd28bf5a411bde7660a046cd78308962bd1e1a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd28bf5a411bde7660a046cd78308962bd1e1a22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd28bf5a411bde7660a046cd78308962bd1e1a22/comments", "author": null, "committer": null, "parents": [{"sha": "b920730aaf463fe390beeddeb2cdeb09d1822129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b920730aaf463fe390beeddeb2cdeb09d1822129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b920730aaf463fe390beeddeb2cdeb09d1822129"}], "stats": {"total": 1824, "additions": 304, "deletions": 1520}, "files": [{"sha": "c2db824738feddda17ff46f8aac9f9fb38f2673d", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 304, "deletions": 1520, "changes": 1824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd28bf5a411bde7660a046cd78308962bd1e1a22/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd28bf5a411bde7660a046cd78308962bd1e1a22/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=bd28bf5a411bde7660a046cd78308962bd1e1a22", "patch": "@@ -1,9 +1,7 @@\n @ libgcc1 routines for ARM cpu.\n-@ Division and remainder, from Appendix E of the Sparc Version 8\n-@ Architecture Manual, with fixes from Gordon Irlam.\n-@ Rewritten for the ARM by Richard Earnshaw (rwe@pegasus.esprit.ec.org)\n+@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)\n \n-/* Copyright (C) 1995 Free Software Foundation, Inc.\n+/* Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -35,243 +33,13 @@ Boston, MA 02111-1307, USA.  */\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n \n-/*\n- * Input: dividend and divisor in r0 and r1 respectively.\n- *\n- * m4 parameters:\n- *  NAME\tname of function to generate\n- *  OP\t\tOP=div => r0 / r1; OP=mod => r0 % r1\n- *  S\t\tS=true => signed; S=false => unsigned\n- *\n- * Algorithm parameters:\n- *  N\t\thow many bits per iteration we try to get (4)\n- *  WORDSIZE\ttotal number of bits (32)\n- *\n- * Derived constants:\n- *  TOPBITS\tnumber of bits in the top `decade' of a number\n- *\n- * Important variables:\n- *  Q\t\tthe partial quotient under development (initially 0)\n- *  R\t\tthe remainder so far, initially the dividend\n- *  ITER\tnumber of main division loop iterations required;\n- *\t\tequal to ceil(log2(quotient) / N).  Note that this\n- *\t\tis the log base (2^N) of the quotient.\n- *  V\t\tthe current comparand, initially divisor*2^(ITER*N-1)\n- *\n- * Cost:\n- *  Current estimate for non-large dividend is\n- *\tceil(log2(quotient) / N) * (10 + 7N/2) + C\n- *  A large dividend is one greater than 2^(31-TOPBITS) and takes a\n- *  different path, as the upper bits of the quotient must be developed\n- *  one bit at a time.\n- */\n-\n-/*\n-define(N, `4')dnl\n-define(WORDSIZE, `32')dnl\n-define(TOPBITS, eval(WORDSIZE - N*((WORDSIZE-1)/N)))dnl\n-dnl\n-define(dividend, `r0')dnl\n-define(divisor, `r1')dnl\n-define(Q, `r2')dnl\n-define(R, `r3')dnl\n-define(ITER, `ip')dnl\n-define(V, `lr')dnl\n-dnl\n-dnl m4 reminder: ifelse(a,b,c,d) => if a is b, then c, else d\n-define(T, `r4')dnl\n-define(SC, `r5')dnl\n-ifelse(S, `true', `define(SIGN, `r6')')dnl\n-define(REGLIST, `ifelse(S, `true', `{r4, r5, r6,', `{r4, r5,')')dnl\n-define(ret, `ldmia\tsp!, REGLIST pc}')dnl\n-dnl\n-dnl This is the recursive definition for developing quotient digits.\n-dnl\n-dnl Parameters:\n-dnl  $1\tthe current depth, 1 <= $1 <= N\n-dnl  $2\tthe current accumulation of quotient bits\n-dnl  N\tmax depth\n-dnl\n-dnl We add a new bit to $2 and either recurse or insert the bits in\n-dnl the quotient.  R, Q, and V are inputs and outputs as defined above;\n-dnl the condition codes are expected to reflect the input R, and are\n-dnl modified to reflect the output R.\n-dnl\n-define(DEVELOP_QUOTIENT_BITS,\n-`\t@ depth $1, accumulated bits $2\n-\tmov\tV, V, lsr #1\n-\tblt\tL.$1.eval(2^N+$2+999)\n-\t@ remainder is positive\n-\tsubs\tR, R, V\n-\tifelse($1, N,\n-\t`\tifelse(eval(2*$2+1<0), `0',\n-\t\t`add\tQ, Q, `#'eval($2*2+1)',\n-\t\t`sub\tQ, Q, `#'eval(-($2*2+1))')\n-\n-\t\tb\t9f\n-\t', `\tDEVELOP_QUOTIENT_BITS(incr($1), `eval(2*$2+1)')')\n-L.$1.eval(2^N+$2+999):\n-\t@ remainder is negative\n-\tadds\tR, R, V\n-\tifelse($1, N,\n-\t`\tifelse(eval(2*$2-1<0), `0',\n-\t\t`add\tQ, Q, `#'eval($2*2-1)',\n-\t\t`sub\tQ, Q, `#'eval(-($2*2-1))')\n-\t\tb\t9f\n-\n-\t', `\tDEVELOP_QUOTIENT_BITS(incr($1), `eval(2*$2-1)')')\n-\tifelse($1, 1, `9:')')dnl\n-\n-#include \"trap.h\"\n-\n-ip\t.req\tr12\n-sp\t.req\tr13\n-lr\t.req\tr14\n-pc\t.req\tr15\n-.text\n-\t.globl NAME\n-\t.align 0\n-NAME:\n-\tstmdb\tsp!, REGLIST lr}\n-ifelse(S, `true',\n-`\t@ compute sign of result; if neither is negative, no problem\n-\tifelse(OP, `div', `eor\tSIGN, divisor, dividend\t@ compute sign',\n-\t\t`mov\tSIGN, dividend')\n-\tcmp\tdivisor, #0\n-\trsbmi\tdivisor, divisor, #0\n-\tbeq\tLdiv_zero\n-\tmov\tV, divisor\n-\tmovs\tR, dividend\n-\trsbmi\tR, R, #0\t@ make dividend nonnegative\n-',\n-`\t@ Ready to divide.  Compute size of quotient; scale comparand.\n-\tmovs\tV, divisor\n-\tmov\tR, dividend\n-\tbeq\tLdiv_zero\n-')\n-\n-\tcmp\tR, V\t\t\t@ if divisor exceeds dividend, done\n-\tmov\tQ, #0\n-\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n-\tmov\tT, `#'(1 << (WORDSIZE - TOPBITS - 1))\n-\tcmp\tR, T\n-\tmov\tITER, #0\n-\tbcc\tLnot_really_big\n-\n-\t@ `Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n-\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n-\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n-\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n-\t@ the top decade: so do not even bother to compare to R.'\n-\t\tmov\tSC, #1\n-\t1:\n-\t\tcmp\tV, T\n-\t\tbcs\t3f\n-\t\tmov\tV, V, lsl `#'N\n-\t\tadd\tITER, ITER, #1\n-\t\tb\t1b\n-\n-\t@ Now compute SC.\n-\t2:\tadds\tV, V, V\n-\t\tadd\tSC, SC, #1\n-\t\tbcc\tLnot_too_big\n-\n-\t\t@ We get here if the divisor overflowed while shifting.\n-\t\t@ This means that R has the high-order bit set.\n-\t\t@ Restore V and subtract from R.\n-\t\tmov\tT, T, lsl `#'TOPBITS\n-\t\tmov\tV, V, lsr #1\n-\t\tadd\tV, T, V\n-\t\tsub\tSC, SC, #1\n-\t\tb\tLdo_single_div\n-\n-\tLnot_too_big:\n-\t3:\tcmp\tV, R\n-\t\tbcc\t2b\n-@\t\tbeq\tLdo_single_div\n-\n-\t/-* NB: these are commented out in the V8-Sparc manual as well *-/\n-\t/-* (I do not understand this) *-/\n-\t@ V > R: went too far: back up 1 step\n-\t@\tsrl\tV, 1, V\n-\t@\tdec\tSC\n-\t@ do single-bit divide steps\n-\t@\n-\t@ We have to be careful here.  We know that R >= V, so we can do the\n-\t@ first divide step without thinking.  BUT, the others are conditional,\n-\t@ and are only done if R >= 0.  Because both R and V may have the high-\n-\t@ order bit set in the first step, just falling into the regular\n-\t@ division loop will mess up the first time around.\n-\t@ So we unroll slightly...\n-\tLdo_single_div:\n-\t\tsubs\tSC, SC, #1\n-\t\tblt\tLend_regular_divide\n-\t\tsub\tR, R, V\n-\t\tmov\tQ, #1\n-\t\tb\tLend_single_divloop\n-\tLsingle_divloop:\n-\t\tcmp\tR, #0\n-\t\tmov\tQ, Q, lsl #1\n-\t\tmov\tV, V, lsr #1\n-\t\t@ R >= 0\n-\t\tsubpl\tR, R, V\n-\t\taddpl\tQ, Q, #1\n-\t\t@ R < 0\n-\t\taddmi\tR, R, V\n-\t\tsubmi\tQ, Q, #1\n-\tLend_single_divloop:\n-\t\tsubs\tSC, SC, #1\n-\t\tbge\tLsingle_divloop\n-\t\tb\tLend_regular_divide\n-\n-1:\n-\tadd\tITER, ITER, #1\n-Lnot_really_big:\n-\tmov\tV, V, lsl `#'N\n-\tcmp\tV, R\n-\tbls\t1b\n-\t@\n-\t@\tHOW CAN ITER EVER BE -1 HERE ?????\n-\t@\n-\tcmn\tITER, #1\n-\tbeq\tLgot_result\n-\n-Ldivloop:\n-\tcmp\tR, #0\t@ set up for initial iteration\n-\tmov\tQ, Q, lsl `#'N\n-\tDEVELOP_QUOTIENT_BITS(1, 0)\n-Lend_regular_divide:\n-\tsubs\tITER, ITER, #1\n-\tbge\tLdivloop\n-\tcmp\tR, #0\n-\t@ non-restoring fixup here (one instruction only!)\n-ifelse(OP, `div',\n-`\tsublt\tQ, Q, #1\n-', `\taddlt\tR, divisor, R\n-')\n-\n-Lgot_result:\n-ifelse(S, `true',\n-`\t@ check to see if answer should be < 0\n-\tcmp\tSIGN, #0\n-\tifelse(OP, `div', `rsbmi Q, Q, #0', `rsbmi R, R, #0')\n-')\n-\tifelse(OP, `div', `mov r0, Q', `mov r0, R')\n-\tret\n-\n-Ldiv_zero:\n-\t@ Divide by zero trap.  If it returns, return 0 (about as\n-\t@ wrong as possible, but that is what SunOS does...).\n-\tbl\t___div0\n-\tmov\tr0, #0\n-\tret\n-*/\n-\n #ifdef __APCS_26__\n #define RET\tmovs\n+#define RETc(x)\tmov##x##s\n #define RETCOND ^\n #else\n #define RET\tmov\n+#define RETc(x)\tmov##x\n #define RETCOND\n #endif\n \n@@ -290,1323 +58,339 @@ Ldiv_zero:\n \n #ifdef L_udivsi3\n \n-ip\t.req\tr12\n-sp\t.req\tr13\n-lr\t.req\tr14\n-pc\t.req\tr15\n-.text\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+result\t\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n \t.globl SYM (__udivsi3)\n \t.align 0\n-SYM (__udivsi3):\n-\tstmdb\tsp!, {r4, r5, lr}\n-\t@ Ready to divide.  Compute size of quotient; scale comparand.\n-\tmovs\tlr, r1\n-\tmov\tr3, r0\n-\tbeq\tLdiv_zero\n-\n-\n-\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n-\tmov\tr2, #0\n-\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n-\tmov\tr4, #(1 << (32 - 4 - 1))\n-\tcmp\tr3, r4\n-\tmov\tip, #0\n-\tbcc\tLnot_really_big\n-\n-\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n-\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n-\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n-\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n-\t@ the top decade: so do not even bother to compare to R.\n-\t\tmov\tr5, #1\n-\t1:\n-\t\tcmp\tlr, r4\n-\t\tbcs\t3f\n-\t\tmov\tlr, lr, lsl #4\n-\t\tadd\tip, ip, #1\n-\t\tb\t1b\n-\n-\t@ Now compute r5.\n-\t2:\tadds\tlr, lr, lr\n-\t\tadd\tr5, r5, #1\n-\t\tbcc\tLnot_too_big\n-\n-\t\t@ We get here if the r1 overflowed while shifting.\n-\t\t@ This means that r3 has the high-order bit set.\n-\t\t@ Restore lr and subtract from r3.\n-\t\tmov\tr4, r4, lsl #4\n-\t\tmov\tlr, lr, lsr #1\n-\t\tadd\tlr, r4, lr\n-\t\tsub\tr5, r5, #1\n-\t\tb\tLdo_single_div\n-\n-\tLnot_too_big:\n-\t3:\tcmp\tlr, r3\n-\t\tbcc\t2b\n-@\t\tbeq\tLdo_single_div\n-\n-\t/* NB: these are commented out in the V8-Sparc manual as well */\n-\t/* (I do not understand this) */\n-\t@ lr > r3: went too far: back up 1 step\n-\t@\tsrl\tlr, 1, lr\n-\t@\tdec\tr5\n-\t@ do single-bit divide steps\n-\t@\n-\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n-\t@ first divide step without thinking.  BUT, the others are conditional,\n-\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n-\t@ order bit set in the first step, just falling into the regular\n-\t@ division loop will mess up the first time around.\n-\t@ So we unroll slightly...\n-\tLdo_single_div:\n-\t\tsubs\tr5, r5, #1\n-\t\tblt\tLend_regular_divide\n-\t\tsub\tr3, r3, lr\n-\t\tmov\tr2, #1\n-\t\tb\tLend_single_divloop\n-\tLsingle_divloop:\n-\t\tcmp\tr3, #0\n-\t\tmov\tr2, r2, lsl #1\n-\t\tmov\tlr, lr, lsr #1\n-\t\t@ r3 >= 0\n-\t\tsubpl\tr3, r3, lr\n-\t\taddpl\tr2, r2, #1\n-\t\t@ r3 < 0\n-\t\taddmi\tr3, r3, lr\n-\t\tsubmi\tr2, r2, #1\n-\tLend_single_divloop:\n-\t\tsubs\tr5, r5, #1\n-\t\tbge\tLsingle_divloop\n-\t\tb\tLend_regular_divide\n-\n-1:\n-\tadd\tip, ip, #1\n-Lnot_really_big:\n-\tmov\tlr, lr, lsl #4\n-\tcmp\tlr, r3\n-\tbls\t1b\n-\t@\n-\t@\tHOW CAN ip EVER BE -1 HERE ?????\n-\t@\n-\tcmn\tip, #1\n-\tbeq\tLgot_result\n-\n-Ldivloop:\n-\tcmp\tr3, #0\t@ set up for initial iteration\n-\tmov\tr2, r2, lsl #4\n-\t\t@ depth 1, accumulated bits 0\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.1.1015\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1022\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #15\n-\n-\t\tb\t9f\n-\t\n-L.4.1022:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #13\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1020\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #11\n-\n-\t\tb\t9f\n-\t\n-L.4.1020:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #9\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #7\n-\n-\t\tb\t9f\n-\t\n-L.4.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #5\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #3\n-\n-\t\tb\t9f\n-\t\n-L.4.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #1\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-L.1.1015:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #1\n-\n-\t\tb\t9f\n-\t\n-L.4.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #3\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #5\n-\n-\t\tb\t9f\n-\t\n-L.4.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #7\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1010\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #9\n-\n-\t\tb\t9f\n-\t\n-L.4.1010:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #11\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1008\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #13\n-\n-\t\tb\t9f\n-\t\n-L.4.1008:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #15\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-\t9:\n-Lend_regular_divide:\n-\tsubs\tip, ip, #1\n-\tbge\tLdivloop\n-\tcmp\tr3, #0\n-\t@ non-restoring fixup here (one instruction only!)\n-\tsublt\tr2, r2, #1\n-\n \n+SYM (__udivsi3):\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, #0x10000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #4\n+\tmovcc\tcurbit, curbit, lsl #4\n+\tbcc\tLoop1\n+\n+Lbignum:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, #0x80000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #1\n+\tmovcc\tcurbit, curbit, lsl #1\n+\tbcc\tLbignum\n+\n+Loop3:\n+\t@ Test for possible subtractions, and note which bits\n+\t@ are done in the result.  On the final pass, this may subtract\n+\t@ too much from the dividend, but the result will be ok, since the\n+\t@ \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tsubcs\tdividend, dividend, divisor\n+\torrcs\tresult, result, curbit\n+\tcmp\tdividend, divisor, lsr #1\n+\tsubcs\tdividend, dividend, divisor, lsr #1\n+\torrcs\tresult, result, curbit, lsr #1\n+\tcmp\tdividend, divisor, lsr #2\n+\tsubcs\tdividend, dividend, divisor, lsr #2\n+\torrcs\tresult, result, curbit, lsr #2\n+\tcmp\tdividend, divisor, lsr #3\n+\tsubcs\tdividend, dividend, divisor, lsr #3\n+\torrcs\tresult, result, curbit, lsr #3\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n+\tmovne\tdivisor, divisor, lsr #4\n+\tbne\tLoop3\n Lgot_result:\n+\tmov\tr0, result\n+\tRET\tpc, lr\n \n-\tmov r0, r2\n-\tldmia\tsp!, {r4, r5, pc}RETCOND\n-\n-Ldiv_zero:\n-\t@ Divide by zero trap.  If it returns, return 0 (about as\n-\t@ wrong as possible, but that is what SunOS does...).\n+Ldiv0:\n+\tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0)\n-\tmov\tr0, #0\n-\tldmia\tsp!, {r4, r5, pc}RETCOND\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tldmia\tsp!, {pc}RETCOND\n \n #endif /* L_udivsi3 */\n \n-#ifdef L_divsi3\n-\n-ip\t.req\tr12\n-sp\t.req\tr13\n-lr\t.req\tr14\n-pc\t.req\tr15\n-.text\n-\t.globl SYM (__divsi3)\n-\t.align 0\n-SYM (__divsi3):\n-\tstmdb\tsp!, {r4, r5, r6, lr}\n-\t@ compute sign of result; if neither is negative, no problem\n-\teor\tr6, r1, r0\t@ compute sign\n-\tcmp\tr1, #0\n-\trsbmi\tr1, r1, #0\n-\tbeq\tLdiv_zero\n-\tmov\tlr, r1\n-\tmovs\tr3, r0\n-\trsbmi\tr3, r3, #0\t@ make dividend nonnegative\n-\n-\n-\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n-\tmov\tr2, #0\n-\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n-\tmov\tr4, #(1 << (32 - 4 - 1))\n-\tcmp\tr3, r4\n-\tmov\tip, #0\n-\tbcc\tLnot_really_big\n-\n-\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n-\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n-\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n-\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n-\t@ the top decade: so do not even bother to compare to R.\n-\t\tmov\tr5, #1\n-\t1:\n-\t\tcmp\tlr, r4\n-\t\tbcs\t3f\n-\t\tmov\tlr, lr, lsl #4\n-\t\tadd\tip, ip, #1\n-\t\tb\t1b\n-\n-\t@ Now compute r5.\n-\t2:\tadds\tlr, lr, lr\n-\t\tadd\tr5, r5, #1\n-\t\tbcc\tLnot_too_big\n-\n-\t\t@ We get here if the r1 overflowed while shifting.\n-\t\t@ This means that r3 has the high-order bit set.\n-\t\t@ Restore lr and subtract from r3.\n-\t\tmov\tr4, r4, lsl #4\n-\t\tmov\tlr, lr, lsr #1\n-\t\tadd\tlr, r4, lr\n-\t\tsub\tr5, r5, #1\n-\t\tb\tLdo_single_div\n-\n-\tLnot_too_big:\n-\t3:\tcmp\tlr, r3\n-\t\tbcc\t2b\n-@\t\tbeq\tLdo_single_div\n-\n-\t/* NB: these are commented out in the V8-Sparc manual as well */\n-\t/* (I do not understand this) */\n-\t@ lr > r3: went too far: back up 1 step\n-\t@\tsrl\tlr, 1, lr\n-\t@\tdec\tr5\n-\t@ do single-bit divide steps\n-\t@\n-\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n-\t@ first divide step without thinking.  BUT, the others are conditional,\n-\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n-\t@ order bit set in the first step, just falling into the regular\n-\t@ division loop will mess up the first time around.\n-\t@ So we unroll slightly...\n-\tLdo_single_div:\n-\t\tsubs\tr5, r5, #1\n-\t\tblt\tLend_regular_divide\n-\t\tsub\tr3, r3, lr\n-\t\tmov\tr2, #1\n-\t\tb\tLend_single_divloop\n-\tLsingle_divloop:\n-\t\tcmp\tr3, #0\n-\t\tmov\tr2, r2, lsl #1\n-\t\tmov\tlr, lr, lsr #1\n-\t\t@ r3 >= 0\n-\t\tsubpl\tr3, r3, lr\n-\t\taddpl\tr2, r2, #1\n-\t\t@ r3 < 0\n-\t\taddmi\tr3, r3, lr\n-\t\tsubmi\tr2, r2, #1\n-\tLend_single_divloop:\n-\t\tsubs\tr5, r5, #1\n-\t\tbge\tLsingle_divloop\n-\t\tb\tLend_regular_divide\n-\n-1:\n-\tadd\tip, ip, #1\n-Lnot_really_big:\n-\tmov\tlr, lr, lsl #4\n-\tcmp\tlr, r3\n-\tbls\t1b\n-\t@\n-\t@\tHOW CAN ip EVER BE -1 HERE ?????\n-\t@\n-\tcmn\tip, #1\n-\tbeq\tLgot_result\n-\n-Ldivloop:\n-\tcmp\tr3, #0\t@ set up for initial iteration\n-\tmov\tr2, r2, lsl #4\n-\t\t@ depth 1, accumulated bits 0\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.1.1015\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1022\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #15\n-\n-\t\tb\t9f\n-\t\n-L.4.1022:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #13\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1020\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #11\n-\n-\t\tb\t9f\n-\t\n-L.4.1020:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #9\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #7\n-\n-\t\tb\t9f\n-\t\n-L.4.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #5\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #3\n-\n-\t\tb\t9f\n-\t\n-L.4.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #1\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-L.1.1015:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #1\n-\n-\t\tb\t9f\n-\t\n-L.4.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #3\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #5\n-\n-\t\tb\t9f\n-\t\n-L.4.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #7\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1010\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #9\n-\n-\t\tb\t9f\n-\t\n-L.4.1010:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #11\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1008\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #13\n-\n-\t\tb\t9f\n-\t\n-L.4.1008:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #15\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-\t9:\n-Lend_regular_divide:\n-\tsubs\tip, ip, #1\n-\tbge\tLdivloop\n-\tcmp\tr3, #0\n-\t@ non-restoring fixup here (one instruction only!)\n-\tsublt\tr2, r2, #1\n-\n-\n-Lgot_result:\n-\t@ check to see if answer should be < 0\n-\tcmp\tr6, #0\n-\trsbmi r2, r2, #0\n-\n-\tmov r0, r2\n-\tldmia\tsp!, {r4, r5, r6, pc}RETCOND\n-\n-Ldiv_zero:\n-\t@ Divide by zero trap.  If it returns, return 0 (about as\n-\t@ wrong as possible, but that is what SunOS does...).\n-\tbl\tSYM (__div0)\n-\tmov\tr0, #0\n-\tldmia\tsp!, {r4, r5, r6, pc}RETCOND\n-\n-#endif /* L_divsi3 */\n-\n #ifdef L_umodsi3\n \n-ip\t.req\tr12\n-sp\t.req\tr13\n-lr\t.req\tr14\n-pc\t.req\tr15\n-.text\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+overdone\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n \t.globl SYM (__umodsi3)\n \t.align 0\n-SYM (__umodsi3):\n-\tstmdb\tsp!, {r4, r5, lr}\n-\t@ Ready to divide.  Compute size of quotient; scale comparand.\n-\tmovs\tlr, r1\n-\tmov\tr3, r0\n-\tbeq\tLdiv_zero\n-\n-\n-\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n-\tmov\tr2, #0\n-\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n-\tmov\tr4, #(1 << (32 - 4 - 1))\n-\tcmp\tr3, r4\n-\tmov\tip, #0\n-\tbcc\tLnot_really_big\n-\n-\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n-\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n-\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n-\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n-\t@ the top decade: so do not even bother to compare to R.\n-\t\tmov\tr5, #1\n-\t1:\n-\t\tcmp\tlr, r4\n-\t\tbcs\t3f\n-\t\tmov\tlr, lr, lsl #4\n-\t\tadd\tip, ip, #1\n-\t\tb\t1b\n-\n-\t@ Now compute r5.\n-\t2:\tadds\tlr, lr, lr\n-\t\tadd\tr5, r5, #1\n-\t\tbcc\tLnot_too_big\n-\n-\t\t@ We get here if the r1 overflowed while shifting.\n-\t\t@ This means that r3 has the high-order bit set.\n-\t\t@ Restore lr and subtract from r3.\n-\t\tmov\tr4, r4, lsl #4\n-\t\tmov\tlr, lr, lsr #1\n-\t\tadd\tlr, r4, lr\n-\t\tsub\tr5, r5, #1\n-\t\tb\tLdo_single_div\n-\n-\tLnot_too_big:\n-\t3:\tcmp\tlr, r3\n-\t\tbcc\t2b\n-@\t\tbeq\tLdo_single_div\n-\n-\t/* NB: these are commented out in the V8-Sparc manual as well */\n-\t/* (I do not understand this) */\n-\t@ lr > r3: went too far: back up 1 step\n-\t@\tsrl\tlr, 1, lr\n-\t@\tdec\tr5\n-\t@ do single-bit divide steps\n-\t@\n-\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n-\t@ first divide step without thinking.  BUT, the others are conditional,\n-\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n-\t@ order bit set in the first step, just falling into the regular\n-\t@ division loop will mess up the first time around.\n-\t@ So we unroll slightly...\n-\tLdo_single_div:\n-\t\tsubs\tr5, r5, #1\n-\t\tblt\tLend_regular_divide\n-\t\tsub\tr3, r3, lr\n-\t\tmov\tr2, #1\n-\t\tb\tLend_single_divloop\n-\tLsingle_divloop:\n-\t\tcmp\tr3, #0\n-\t\tmov\tr2, r2, lsl #1\n-\t\tmov\tlr, lr, lsr #1\n-\t\t@ r3 >= 0\n-\t\tsubpl\tr3, r3, lr\n-\t\taddpl\tr2, r2, #1\n-\t\t@ r3 < 0\n-\t\taddmi\tr3, r3, lr\n-\t\tsubmi\tr2, r2, #1\n-\tLend_single_divloop:\n-\t\tsubs\tr5, r5, #1\n-\t\tbge\tLsingle_divloop\n-\t\tb\tLend_regular_divide\n \n-1:\n-\tadd\tip, ip, #1\n-Lnot_really_big:\n-\tmov\tlr, lr, lsl #4\n-\tcmp\tlr, r3\n-\tbls\t1b\n-\t@\n-\t@\tHOW CAN ip EVER BE -1 HERE ?????\n-\t@\n-\tcmn\tip, #1\n-\tbeq\tLgot_result\n-\n-Ldivloop:\n-\tcmp\tr3, #0\t@ set up for initial iteration\n-\tmov\tr2, r2, lsl #4\n-\t\t@ depth 1, accumulated bits 0\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.1.1015\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1022\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #15\n-\n-\t\tb\t9f\n-\t\n-L.4.1022:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #13\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1020\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #11\n-\n-\t\tb\t9f\n-\t\n-L.4.1020:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #9\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #7\n-\n-\t\tb\t9f\n-\t\n-L.4.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #5\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #3\n-\n-\t\tb\t9f\n-\t\n-L.4.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #1\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-L.1.1015:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #1\n-\n-\t\tb\t9f\n-\t\n-L.4.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #3\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #5\n-\n-\t\tb\t9f\n-\t\n-L.4.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #7\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1010\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #9\n-\n-\t\tb\t9f\n-\t\n-L.4.1010:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #11\n-\t\tb\t9f\n+SYM (__umodsi3):\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tmov\tcurbit, #1\n+\tcmp\tdividend, divisor\n+\tRETc(cc)\tpc, lr\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, #0x10000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #4\n+\tmovcc\tcurbit, curbit, lsl #4\n+\tbcc\tLoop1\n+\n+Lbignum:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, #0x80000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #1\n+\tmovcc\tcurbit, curbit, lsl #1\n+\tbcc\tLbignum\n+\n+Loop3:\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend, so keep track of which\n+\t@ subtractions are done, we can fix them up afterwards...\n+\tmov\toverdone, #0\n+\tcmp\tdividend, divisor\n+\tsubcs\tdividend, dividend, divisor\n+\tcmp\tdividend, divisor, lsr #1\n+\tsubcs\tdividend, dividend, divisor, lsr #1\n+\torrcs\toverdone, overdone, curbit, ror #1\n+\tcmp\tdividend, divisor, lsr #2\n+\tsubcs\tdividend, dividend, divisor, lsr #2\n+\torrcs\toverdone, overdone, curbit, ror #2\n+\tcmp\tdividend, divisor, lsr #3\n+\tsubcs\tdividend, dividend, divisor, lsr #3\n+\torrcs\toverdone, overdone, curbit, ror #3\n+\tmov\tip, curbit\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n+\tmovne\tdivisor, divisor, lsr #4\n+\tbne\tLoop3\n+\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of \"overdone\".  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in ip.\n+\t@ If we terminated early, because dividend became zero,\n+\t@ then none of the below will match, since the bit in ip will not be\n+\t@ in the bottom nibble.\n+\tands\toverdone, overdone, #0xe0000000\n+\tRETc(eq)\tpc, lr\t\t\t\t@ No fixups needed\n+\ttst\toverdone, ip, ror #3\n+\taddne\tdividend, dividend, divisor, lsr #3\n+\ttst\toverdone, ip, ror #2\n+\taddne\tdividend, dividend, divisor, lsr #2\n+\ttst\toverdone, ip, ror #1\n+\taddne\tdividend, dividend, divisor, lsr #1\n+\tRET\tpc, lr\n \n-\t\n-\t\n-L.3.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1008\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #13\n+Ldiv0:\n+\tstr\tlr, [sp, #-4]!\n+\tbl\tSYM (__div0)\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tldmia\tsp!, {pc}RETCOND\n \n-\t\tb\t9f\n-\t\n-L.4.1008:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #15\n-\t\tb\t9f\n+#endif /* L_umodsi3 */\n \n-\t\n-\t\n-\t\n-\t\n-\t9:\n-Lend_regular_divide:\n-\tsubs\tip, ip, #1\n-\tbge\tLdivloop\n-\tcmp\tr3, #0\n-\t@ non-restoring fixup here (one instruction only!)\n-\taddlt\tr3, r1, r3\n+#ifdef L_divsi3\n \n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+result\t\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n+\t.globl SYM (__divsi3)\n+\t.align 0\n \n+SYM (__divsi3):\n+\teor\tip, dividend, divisor\t\t@ Save the sign of the result.\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\tcmp\tdivisor, #0\n+\trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n+\tbeq\tLdiv0\n+\tcmp\tdividend, #0\n+\trsbmi\tdividend, dividend, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, #0x10000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #4\n+\tmovcc\tcurbit, curbit, lsl #4\n+\tbcc\tLoop1\n+\n+Lbignum:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, #0x80000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #1\n+\tmovcc\tcurbit, curbit, lsl #1\n+\tbcc\tLbignum\n+\n+Loop3:\n+\t@ Test for possible subtractions, and note which bits\n+\t@ are done in the result.  On the final pass, this may subtract\n+\t@ too much from the dividend, but the result will be ok, since the\n+\t@ \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tsubcs\tdividend, dividend, divisor\n+\torrcs\tresult, result, curbit\n+\tcmp\tdividend, divisor, lsr #1\n+\tsubcs\tdividend, dividend, divisor, lsr #1\n+\torrcs\tresult, result, curbit, lsr #1\n+\tcmp\tdividend, divisor, lsr #2\n+\tsubcs\tdividend, dividend, divisor, lsr #2\n+\torrcs\tresult, result, curbit, lsr #2\n+\tcmp\tdividend, divisor, lsr #3\n+\tsubcs\tdividend, dividend, divisor, lsr #3\n+\torrcs\tresult, result, curbit, lsr #3\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n+\tmovne\tdivisor, divisor, lsr #4\n+\tbne\tLoop3\n Lgot_result:\n+\tmov\tr0, result\n+\tcmp\tip, #0\n+\trsbmi\tr0, r0, #0\n+\tRET\tpc, lr\n \n-\tmov r0, r3\n-\tldmia\tsp!, {r4, r5, pc}RETCOND\n-\n-Ldiv_zero:\n-\t@ Divide by zero trap.  If it returns, return 0 (about as\n-\t@ wrong as possible, but that is what SunOS does...).\n+Ldiv0:\n+\tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0)\n-\tmov\tr0, #0\n-\tldmia\tsp!, {r4, r5, pc}RETCOND\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tldmia\tsp!, {pc}RETCOND\n \n-#endif /* L_umodsi3 */\n+#endif /* L_divsi3 */\n \n #ifdef L_modsi3\n \n-ip\t.req\tr12\n-sp\t.req\tr13\n-lr\t.req\tr14\n-pc\t.req\tr15\n-.text\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+overdone\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n \t.globl SYM (__modsi3)\n \t.align 0\n-SYM (__modsi3):\n-\tstmdb\tsp!, {r4, r5, r6, lr}\n-\t@ compute sign of result; if neither is negative, no problem\n-\tmov\tr6, r0\n-\tcmp\tr1, #0\n-\trsbmi\tr1, r1, #0\n-\tbeq\tLdiv_zero\n-\tmov\tlr, r1\n-\tmovs\tr3, r0\n-\trsbmi\tr3, r3, #0\t@ make dividend nonnegative\n \n-\n-\tcmp\tr3, lr\t\t\t@ if r1 exceeds r0, done\n-\tmov\tr2, #0\n-\tbcc\tLgot_result\t\t@ (and algorithm fails otherwise)\n-\tmov\tr4, #(1 << (32 - 4 - 1))\n-\tcmp\tr3, r4\n-\tmov\tip, #0\n-\tbcc\tLnot_really_big\n-\n-\t@ Here the dividend is >= 2^(31-N) or so.  We must be careful here,\n-\t@ as our usual N-at-a-shot divide step will cause overflow and havoc.\n-\t@ The number of bits in the result here is N*ITER+SC, where SC <= N.\n-\t@ Compute ITER in an unorthodox manner: know we need to shift V into\n-\t@ the top decade: so do not even bother to compare to R.\n-\t\tmov\tr5, #1\n-\t1:\n-\t\tcmp\tlr, r4\n-\t\tbcs\t3f\n-\t\tmov\tlr, lr, lsl #4\n-\t\tadd\tip, ip, #1\n-\t\tb\t1b\n-\n-\t@ Now compute r5.\n-\t2:\tadds\tlr, lr, lr\n-\t\tadd\tr5, r5, #1\n-\t\tbcc\tLnot_too_big\n-\n-\t\t@ We get here if the r1 overflowed while shifting.\n-\t\t@ This means that r3 has the high-order bit set.\n-\t\t@ Restore lr and subtract from r3.\n-\t\tmov\tr4, r4, lsl #4\n-\t\tmov\tlr, lr, lsr #1\n-\t\tadd\tlr, r4, lr\n-\t\tsub\tr5, r5, #1\n-\t\tb\tLdo_single_div\n-\n-\tLnot_too_big:\n-\t3:\tcmp\tlr, r3\n-\t\tbcc\t2b\n-@\t\tbeq\tLdo_single_div\n-\n-\t/* NB: these are commented out in the V8-Sparc manual as well */\n-\t/* (I do not understand this) */\n-\t@ lr > r3: went too far: back up 1 step\n-\t@\tsrl\tlr, 1, lr\n-\t@\tdec\tr5\n-\t@ do single-bit divide steps\n-\t@\n-\t@ We have to be careful here.  We know that r3 >= lr, so we can do the\n-\t@ first divide step without thinking.  BUT, the others are conditional,\n-\t@ and are only done if r3 >= 0.  Because both r3 and lr may have the high-\n-\t@ order bit set in the first step, just falling into the regular\n-\t@ division loop will mess up the first time around.\n-\t@ So we unroll slightly...\n-\tLdo_single_div:\n-\t\tsubs\tr5, r5, #1\n-\t\tblt\tLend_regular_divide\n-\t\tsub\tr3, r3, lr\n-\t\tmov\tr2, #1\n-\t\tb\tLend_single_divloop\n-\tLsingle_divloop:\n-\t\tcmp\tr3, #0\n-\t\tmov\tr2, r2, lsl #1\n-\t\tmov\tlr, lr, lsr #1\n-\t\t@ r3 >= 0\n-\t\tsubpl\tr3, r3, lr\n-\t\taddpl\tr2, r2, #1\n-\t\t@ r3 < 0\n-\t\taddmi\tr3, r3, lr\n-\t\tsubmi\tr2, r2, #1\n-\tLend_single_divloop:\n-\t\tsubs\tr5, r5, #1\n-\t\tbge\tLsingle_divloop\n-\t\tb\tLend_regular_divide\n-\n-1:\n-\tadd\tip, ip, #1\n-Lnot_really_big:\n-\tmov\tlr, lr, lsl #4\n-\tcmp\tlr, r3\n-\tbls\t1b\n-\t@\n-\t@\tHOW CAN ip EVER BE -1 HERE ?????\n-\t@\n-\tcmn\tip, #1\n+SYM (__modsi3):\n+\tmov\tcurbit, #1\n+\tcmp\tdivisor, #0\n+\trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n+\tbeq\tLdiv0\n+\t@ Need to save the sign of the dividend, unfortunately, we need\n+\t@ ip later on; this is faster than pushing lr and using that.\n+\tstr\tdividend, [sp, #-4]!\n+\tcmp\tdividend, #0\n+\trsbmi\tdividend, dividend, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, #0x10000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #4\n+\tmovcc\tcurbit, curbit, lsl #4\n+\tbcc\tLoop1\n+\n+Lbignum:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, #0x80000000\n+\tcmpcc\tdivisor, dividend\n+\tmovcc\tdivisor, divisor, lsl #1\n+\tmovcc\tcurbit, curbit, lsl #1\n+\tbcc\tLbignum\n+\n+Loop3:\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend, so keep track of which\n+\t@ subtractions are done, we can fix them up afterwards...\n+\tmov\toverdone, #0\n+\tcmp\tdividend, divisor\n+\tsubcs\tdividend, dividend, divisor\n+\tcmp\tdividend, divisor, lsr #1\n+\tsubcs\tdividend, dividend, divisor, lsr #1\n+\torrcs\toverdone, overdone, curbit, ror #1\n+\tcmp\tdividend, divisor, lsr #2\n+\tsubcs\tdividend, dividend, divisor, lsr #2\n+\torrcs\toverdone, overdone, curbit, ror #2\n+\tcmp\tdividend, divisor, lsr #3\n+\tsubcs\tdividend, dividend, divisor, lsr #3\n+\torrcs\toverdone, overdone, curbit, ror #3\n+\tmov\tip, curbit\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n+\tmovne\tdivisor, divisor, lsr #4\n+\tbne\tLoop3\n+\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of \"overdone\".  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in ip.\n+\t@ If we terminated early, because dividend became zero,\n+\t@ then none of the below will match, since the bit in ip will not be\n+\t@ in the bottom nibble.\n+\tands\toverdone, overdone, #0xe0000000\n \tbeq\tLgot_result\n-\n-Ldivloop:\n-\tcmp\tr3, #0\t@ set up for initial iteration\n-\tmov\tr2, r2, lsl #4\n-\t\t@ depth 1, accumulated bits 0\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.1.1015\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1022\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #15\n-\n-\t\tb\t9f\n-\t\n-L.4.1022:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #13\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1020\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #11\n-\n-\t\tb\t9f\n-\t\n-L.4.1020:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #9\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1018\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #7\n-\n-\t\tb\t9f\n-\t\n-L.4.1018:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #5\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits 1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1016\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tadd\tr2, r2, #3\n-\n-\t\tb\t9f\n-\t\n-L.4.1016:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tadd\tr2, r2, #1\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-L.1.1015:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 2, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.2.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -1\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1014\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #1\n-\n-\t\tb\t9f\n-\t\n-L.4.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #3\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #5\n-\n-\t\tb\t9f\n-\t\n-L.4.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #7\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-L.2.1014:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 3, accumulated bits -3\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.3.1012\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -5\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1010\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #9\n-\n-\t\tb\t9f\n-\t\n-L.4.1010:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #11\n-\t\tb\t9f\n-\n-\t\n-\t\n-L.3.1012:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\t\t@ depth 4, accumulated bits -7\n-\tmov\tlr, lr, lsr #1\n-\tblt\tL.4.1008\n-\t@ remainder is positive\n-\tsubs\tr3, r3, lr\n-\t\tsub\tr2, r2, #13\n-\n-\t\tb\t9f\n-\t\n-L.4.1008:\n-\t@ remainder is negative\n-\tadds\tr3, r3, lr\n-\t\tsub\tr2, r2, #15\n-\t\tb\t9f\n-\n-\t\n-\t\n-\t\n-\t\n-\t9:\n-Lend_regular_divide:\n-\tsubs\tip, ip, #1\n-\tbge\tLdivloop\n-\tcmp\tr3, #0\n-\t@ non-restoring fixup here (one instruction only!)\n-\taddlt\tr3, r1, r3\n-\n-\n+\ttst\toverdone, ip, ror #3\n+\taddne\tdividend, dividend, divisor, lsr #3\n+\ttst\toverdone, ip, ror #2\n+\taddne\tdividend, dividend, divisor, lsr #2\n+\ttst\toverdone, ip, ror #1\n+\taddne\tdividend, dividend, divisor, lsr #1\n Lgot_result:\n-\t@ check to see if answer should be < 0\n-\tcmp\tr6, #0\n-\trsbmi r3, r3, #0\n-\n-\tmov r0, r3\n-\tldmia\tsp!, {r4, r5, r6, pc}RETCOND\n+\tldr\tip, [sp], #4\n+\tcmp\tip, #0\n+\trsbmi\tdividend, dividend, #0\n+\tRET\tpc, lr\n \n-Ldiv_zero:\n-\t@ Divide by zero trap.  If it returns, return 0 (about as\n-\t@ wrong as possible, but that is what SunOS does...).\n+Ldiv0:\n+\tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0)\n-\tmov\tr0, #0\n-\tldmia\tsp!, {r4, r5, r6, pc}RETCOND\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tldmia\tsp!, {pc}RETCOND\n \n #endif /* L_modsi3 */\n "}]}