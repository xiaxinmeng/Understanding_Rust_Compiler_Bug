{"sha": "33031ee69097eeac734dfba91b717d5e9a583073", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwMzFlZTY5MDk3ZWVhYzczNGRmYmE5MWI3MTdkNWU5YTU4MzA3Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-06-01T12:49:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-01T12:49:44Z"}, "message": "Fix phi backedge detection in backprop (PR85989)\n\nThis PR is a nasty wrong code bug due to my fluffing a test for a\nbackedge in gimple-ssa-backprop.c.  Backedges are supposed to be\nfrom definitions in the statement we're visiting to uses in statements\nthat we haven't visited yet.  However, the check failed to account for\nPHIs in the current block that had already been processed, so if two\nPHIs in the same block referenced each other, we'd treat both\nreferences as backedges.\n\nIn more detail:\n\nThe first phase of the pass goes through all statements in an arbitrary\norder, making optimistic assumptions about any statements that haven't\nbeen visited yet.  The second phase then calculates a correct\n(supposedly maximal) fixed point.\n\nAlthough the first phase order is arbitrary in principle, we still use\nthe CFG rpo to cut down on the backedges.  This means that the only\nthing that's truly arbitrary is the order that we process the PHIs\nin a block.  Any order should be OK and should eventually give the\nsame results.  But we have to follow whatever order we pick,\nand the pass wasn't doing that.\n\n2018-06-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/85989\n\t* gimple-ssa-backprop.c (backprop::m_visited_phis): New member\n\tvariable.\n\t(backprop::intersect_uses): Check it when deciding whether this\n\tis a backedge reference.\n\t(backprop::process_block): Add each phi to m_visited_phis\n\tafter visiting it, then clear it at the end.\n\ngcc/testsuite/\n\tPR tree-optimization/85989\n\t* gcc.dg/torture/pr85989.c: New test.\n\nFrom-SVN: r261064", "tree": {"sha": "931a386dcb9b808d744e5031d01708070be44177", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/931a386dcb9b808d744e5031d01708070be44177"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33031ee69097eeac734dfba91b717d5e9a583073", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33031ee69097eeac734dfba91b717d5e9a583073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33031ee69097eeac734dfba91b717d5e9a583073", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33031ee69097eeac734dfba91b717d5e9a583073/comments", "author": null, "committer": null, "parents": [{"sha": "57c454d29c12a948fee4a0b437fd57af870710b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c454d29c12a948fee4a0b437fd57af870710b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c454d29c12a948fee4a0b437fd57af870710b4"}], "stats": {"total": 67, "additions": 63, "deletions": 4}, "files": [{"sha": "87305aebeebc66775b620e4cb26c06957252a20c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33031ee69097eeac734dfba91b717d5e9a583073", "patch": "@@ -1,3 +1,13 @@\n+2018-06-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/85989\n+\t* gimple-ssa-backprop.c (backprop::m_visited_phis): New member\n+\tvariable.\n+\t(backprop::intersect_uses): Check it when deciding whether this\n+\tis a backedge reference.\n+\t(backprop::process_block): Add each phi to m_visited_phis\n+\tafter visiting it, then clear it at the end.\n+\n 2018-06-01  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vectorizer.h (vect_dr_stmt): New function."}, {"sha": "bbc6311ff284dcc63b408b3ef956a16b621fead8", "filename": "gcc/gimple-ssa-backprop.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2Fgimple-ssa-backprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2Fgimple-ssa-backprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-backprop.c?ref=33031ee69097eeac734dfba91b717d5e9a583073", "patch": "@@ -260,6 +260,11 @@ class backprop\n      post-order walk.  */\n   auto_sbitmap m_visited_blocks;\n \n+  /* A bitmap of phis that we have finished processing in the initial\n+     post-order walk, excluding those from blocks mentioned in\n+     M_VISITED_BLOCKS.  */\n+  auto_bitmap m_visited_phis;\n+\n   /* A worklist of SSA names whose definitions need to be reconsidered.  */\n   auto_vec <tree, 64> m_worklist;\n \n@@ -496,16 +501,19 @@ backprop::intersect_uses (tree var, usage_info *info)\n     {\n       if (is_gimple_debug (stmt))\n \tcontinue;\n-      if (is_a <gphi *> (stmt)\n-\t  && !bitmap_bit_p (m_visited_blocks, gimple_bb (stmt)->index))\n+      gphi *phi = dyn_cast <gphi *> (stmt);\n+      if (phi\n+\t  && !bitmap_bit_p (m_visited_blocks, gimple_bb (phi)->index)\n+\t  && !bitmap_bit_p (m_visited_phis,\n+\t\t\t    SSA_NAME_VERSION (gimple_phi_result (phi))))\n \t{\n \t  /* Skip unprocessed phis.  */\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"[BACKEDGE] \");\n \t      print_generic_expr (dump_file, var);\n \t      fprintf (dump_file, \" in \");\n-\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t      print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n \t    }\n \t}\n       else\n@@ -629,7 +637,12 @@ backprop::process_block (basic_block bb)\n     }\n   for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi);\n        gsi_next (&gpi))\n-    process_var (gimple_phi_result (gpi.phi ()));\n+    {\n+      tree result = gimple_phi_result (gpi.phi ());\n+      process_var (result);\n+      bitmap_set_bit (m_visited_phis, SSA_NAME_VERSION (result));\n+    }\n+  bitmap_clear (m_visited_phis);\n }\n \n /* Delete the definition of VAR, which has no uses.  */"}, {"sha": "050e7545ac1609feabe39c9b5a4713516ad7c2ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33031ee69097eeac734dfba91b717d5e9a583073", "patch": "@@ -1,3 +1,8 @@\n+2018-06-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/85989\n+\t* gcc.dg/torture/pr85989.c: New test.\n+\n 2018-06-01  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/86017"}, {"sha": "4dff5e69089180d0f712b7801f4270c0763381f8", "filename": "gcc/testsuite/gcc.dg/torture/pr85989.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr85989.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33031ee69097eeac734dfba91b717d5e9a583073/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr85989.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr85989.c?ref=33031ee69097eeac734dfba91b717d5e9a583073", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+\n+#define N 9\n+\n+void __attribute__((noipa))\n+f (double x, double y, double *res)\n+{\n+  y = -y;\n+  for (int i = 0; i < N; ++i)\n+    {\n+      double tmp = y;\n+      y = x;\n+      x = tmp;\n+      res[i] = i;\n+    }\n+  res[N] = y * y;\n+  res[N + 1] = x;\n+}\n+\n+int\n+main (void)\n+{\n+  double res[N + 2];\n+  f (10, 20, res);\n+  for (int i = 0; i < N; ++i)\n+    if (res[i] != i)\n+      __builtin_abort ();\n+  if (res[N] != 100 || res[N + 1] != -20)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}