{"sha": "5b485d2c39f2090470aab982739cb0cc71bbeb58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0ODVkMmMzOWYyMDkwNDcwYWFiOTgyNzM5Y2IwY2M3MWJiZWI1OA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-01-14T19:21:29Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-01-14T19:21:29Z"}, "message": "(CPP_SPEC): Add -mfrw support.\n\n(OVERRIDE_OPTIONS): Define.  Can't omit frame pointer or do pic\nwhen profiling.\n(REG_USED_SO_FAR): Delete.\n(CONST_COSTS): Give SMALL_INT constants cost of 0.  Make UDIV,\nDIV, MOD, UMOD more expensive.  Make FIX same cost as FLOAT.\n(TARGET_FRW): Define.\n(TARGET_DEFAULTS): Add -mfrw flag.\n(INITIAL_FRAME_POINTER_OFFSET): Add -mfrw support.\n(BASE_OUTGOING_VALUE_REG, BASE_INCOMING_ARG_REG): Likewise.\n(FUNCTION_PROLOGUE, FUNCTION_EPILOGUE): Likewise.\n(DELAY_SLOTS_FOR_EPILOGUE, ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n(EXPAND_BUILTIN_SAVEREGS): Likewise.\n\nFrom-SVN: r3236", "tree": {"sha": "17c150b140a0ef8971c4b38432a33a8e3d88ae4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17c150b140a0ef8971c4b38432a33a8e3d88ae4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b485d2c39f2090470aab982739cb0cc71bbeb58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b485d2c39f2090470aab982739cb0cc71bbeb58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b485d2c39f2090470aab982739cb0cc71bbeb58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b485d2c39f2090470aab982739cb0cc71bbeb58/comments", "author": null, "committer": null, "parents": [{"sha": "114b9aa4cd7daae9c8cfba2feb1011b39e4c6aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114b9aa4cd7daae9c8cfba2feb1011b39e4c6aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114b9aa4cd7daae9c8cfba2feb1011b39e4c6aea"}], "stats": {"total": 67, "additions": 40, "deletions": 27}, "files": [{"sha": "22bbc7e7db71111b91e8e5fe6c4496e050462082", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b485d2c39f2090470aab982739cb0cc71bbeb58/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b485d2c39f2090470aab982739cb0cc71bbeb58/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=5b485d2c39f2090470aab982739cb0cc71bbeb58", "patch": "@@ -34,7 +34,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define ASM_SPEC \" %| %{fpic:-k} %{fPIC:-k}\"\n \n /* Define macros to distinguish architectures.  */\n-#define CPP_SPEC \"%{msparclite:-D__sparclite__} %{mv8:-D__sparc_v8__}\"\n+#define CPP_SPEC \"%{msparclite:-D__sparclite__} %{mv8:-D__sparc_v8__} \\\n+  %{mfrw:-D__sparc_frw__}\"\n \n /* Prevent error on `-sun4' and `-target sun4' options.  */\n /* This used to translate -dalign to -malign, but that is no good\n@@ -63,6 +64,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n     }\t\t\t\t\t\t\t\t\\\n }\n \n+/* To make profiling work with -f{pic,PIC}, we need to emit the profiling\n+   code into the rtl.  Also, if we are profiling, we cannot eliminate\n+   the frame pointer (because the return address will get smashed).  */\n+\n+#define OVERRIDE_OPTIONS \\\n+  do { if (profile_flag || profile_block_flag)\t\\\n+\t flag_omit_frame_pointer = 0, flag_pic = 0; } while (0)\n+\n /* These compiler options take an argument.  We ignore -target for now.  */\n \n #define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n@@ -112,6 +121,10 @@ extern int target_flags;\n /* Nonzero means that we should generate code for a sparclite.  */\n #define TARGET_SPARCLITE (target_flags & 128)\n \n+/* Nonzero means that we should generate code using a flat register window\n+   model, i.e. no save/restore instructions are generated.  */\n+#define TARGET_FRW (target_flags & 256)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -133,6 +146,8 @@ extern int target_flags;\n     {\"sparclite\", -1},\t\t\\\n     {\"no-sparclite\", -128},\t\\\n     {\"no-sparclite\", 1},\t\\\n+    {\"frw\", 256},\t\t\\\n+    {\"no-frw\", -256},\t\t\\\n     { \"\", TARGET_DEFAULT}}\n \n #define TARGET_DEFAULT 3\n@@ -270,7 +285,7 @@ extern int target_flags;\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n-   0 is used for the condition code and not to represent %g0, which is\n+   g0 is used for the condition code and not to represent %g0, which is\n    hardwired to 0, so reg 0 is *not* fixed.\n    g1 through g4 are free to use as temporaries.\n    g5 through g7 are reserved for the operating system.  */\n@@ -391,7 +406,8 @@ extern int leaf_function;\n    it's not, there's no point in trying to eliminate the\n    frame pointer.  If it is a leaf function, we guessed right!  */\n #define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n-  do { (VAR) = compute_frame_size (get_frame_size (), 1); } while (0)\n+  ((VAR) = (TARGET_FRW ? sparc_frw_compute_frame_size (get_frame_size ()) \\\n+\t    : compute_frame_size (get_frame_size (), 1)))\n \n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 30\n@@ -521,15 +537,6 @@ extern char leaf_reg_remap[];\n extern char leaf_reg_backmap[];\n #define LEAF_REG_BACKMAP(REGNO) (leaf_reg_backmap[REGNO])\n \n-#define REG_USED_SO_FAR(REGNO) \\\n-  ((REGNO) >= 24 && (REGNO) < 30\t\\\n-   ? (regs_ever_live[24]\t\t\\\n-      || regs_ever_live[25]\t\t\\\n-      || regs_ever_live[26]\t\t\\\n-      || regs_ever_live[27]\t\t\\\n-      || regs_ever_live[28]\t\t\\\n-      || regs_ever_live[29]) : 0)\n-\n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n@@ -669,13 +676,16 @@ extern char leaf_reg_backmap[];\n \n #define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n \n-/* Some subroutine macros specific to this machine.  */\n+/* Some subroutine macros specific to this machine.\n+   When !TARGET_FPU, put float return values in the general registers,\n+   since we don't have any fp registers.  */\n #define BASE_RETURN_VALUE_REG(MODE) \\\n  (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32 : 8)\n #define BASE_OUTGOING_VALUE_REG(MODE) \\\n- (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32 : 24)\n+ (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32\t\\\n+  : (TARGET_FRW ? 8 : 24))\n #define BASE_PASSING_ARG_REG(MODE) (8)\n-#define BASE_INCOMING_ARG_REG(MODE) (24)\n+#define BASE_INCOMING_ARG_REG(MODE) (TARGET_FRW ? 8 : 24)\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -882,7 +892,8 @@ extern int apparent_fsize;\n    to do this is made in regclass.c.  */\n \n #define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\\\n-  output_function_prologue (FILE, SIZE, leaf_function)\n+  (TARGET_FRW ? sparc_frw_output_function_prologue (FILE, SIZE, leaf_function)\\\n+   : output_function_prologue (FILE, SIZE, leaf_function))\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n@@ -950,11 +961,14 @@ extern int current_function_outgoing_args_size;\n extern union tree_node *current_function_decl;\n \n #define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  output_function_epilogue (FILE, SIZE, leaf_function)\n+  (TARGET_FRW ? sparc_frw_output_function_epilogue (FILE, SIZE, leaf_function)\\\n+   : output_function_epilogue (FILE, SIZE, leaf_function))\n \n-#define DELAY_SLOTS_FOR_EPILOGUE 1\n+#define DELAY_SLOTS_FOR_EPILOGUE\t\\\n+  (TARGET_FRW ? sparc_frw_epilogue_delay_slots () : 1)\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\\n-  eligible_for_epilogue_delay (trial, slots_filled)\n+  (TARGET_FRW ? sparc_frw_eligible_for_epilogue_delay (trial, slots_filled) \\\n+   : eligible_for_epilogue_delay (trial, slots_filled))\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n@@ -1024,8 +1038,8 @@ extern union tree_node *current_function_decl;\n    explicit.  */\n \n #define EXPAND_BUILTIN_SAVEREGS(ARGLIST)\t\t\t\t\\\n-  (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, TImode, 24))),\t\\\n-   emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DImode, 28))),\t\\\n+  (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, TImode, BASE_INCOMING_ARG_REG (VOIDmode)))),\t\\\n+   emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DImode, BASE_INCOMING_ARG_REG (VOIDmode)+4))),\t\\\n    expand_call (exp, target, ignore))\n \f\n /* Addressing modes, and classification of registers for them.  */\n@@ -1401,10 +1415,8 @@ extern struct rtx_def *legitimize_pic_address ();\n \n #define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL (RTX) == 0)\t\t\t\t\t\\\n-      return 0;\t\t\t\t\t\t\t\\\n     if (INTVAL (RTX) < 0x1000 && INTVAL (RTX) >= -0x1000)\t\\\n-      return 1;\t\t\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n   case HIGH:\t\t\t\t\t\t\t\\\n     return 2;\t\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n@@ -1418,7 +1430,7 @@ extern struct rtx_def *legitimize_pic_address ();\n \t  || (XINT (RTX, 3) == -1\t\t\t\t\\\n \t      && XINT (RTX, 2) < 0\t\t\t\t\\\n \t      && XINT (RTX, 2) >= -0x1000))\t\t\t\\\n-\treturn 1;\t\t\t\t\t\t\\\n+\treturn 0;\t\t\t\t\t\t\\\n     return 8;\n \n /* SPARC offers addressing modes which are \"as cheap as a register\".\n@@ -1447,10 +1459,11 @@ extern struct rtx_def *legitimize_pic_address ();\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (20);\t\t\t\t\\\n-  /* Make FLOAT more expensive than CONST_DOUBLE,\t\\\n+    return COSTS_N_INSNS (25);\t\t\t\t\\\n+  /* Make FLOAT and FIX more expensive than CONST_DOUBLE,\\\n      so that cse will favor the latter.  */\t\t\\\n   case FLOAT:\t\t\t\t\t\t\\\n+  case FIX:\t\t\t\t\t\t\\\n     return 19;\n \n /* Conditional branches with empty delay slots have a length of two.  */"}]}