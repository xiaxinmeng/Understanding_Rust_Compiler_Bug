{"sha": "b7091901cd984928b3599dc62507045dee1754d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcwOTE5MDFjZDk4NDkyOGIzNTk5ZGM2MjUwNzA0NWRlZTE3NTRkNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-06-27T18:53:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-06-27T18:53:43Z"}, "message": "re PR tree-optimization/36400 (points-to results wrong)\n\n2008-06-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/36400\n\tPR tree-optimization/36373\n\tPR tree-optimization/36344\n\t* tree-ssa-structalias.c (var_escaped, escaped_tree, escaped_id,\n\tvar_nonlocal, nonlocal_tree, nonlocal_id): New globals\n\t(update_alias_info): Remove call clobbering code.\n\t(make_constraint_to): New helper function.\n\t(make_escape_constraint): Likewise.\n\t(handle_rhs_call): Use it on all pointer containing arguments.\n\tAlso mark the static chain escaped.\n\t(handle_lhs_call): Make constraints from NONLOCAL and ESCAPED\n\tinstead of ANYTHING.\n\t(make_constraint_from): New helper split out from ...\n\t(make_constraint_from_anything): ... here.\n\t(find_func_aliases): Add constraints for escape sites.\n\t(intra_create_variable_infos): Make constraints from NONLOCAL\n\tfor parameters.\n\t(find_what_p_points_to): Interpret NONLOCAL and ESCAPED the same\n\tas ANYTHING.\n\t(clobber_what_p_points_to): Remove.\n\t(clobber_what_escaped): New function.\n\t(init_base_vars): Init NONLOCAL and ESCAPED.\n\t(do_sd_constraint): Do not propagate the solution from ESCAPED\n\tbut use ESCAPED as a placeholder.\n\t(solve_graph): Likewise.\n\t* tree-flow.h (clobber_what_p_points_to): Remove.\n\t(clobber_what_escaped): Declare.\n\t* tree-ssa-alias.c (set_initial_properties): Call it.\n\tRemove code clobbering escaped pointers.\n\n\t* gcc.dg/torture/pr36373-1.c: New testcase.\n\t* gcc.dg/torture/pr36373-2.c: Likewise.\n\t* gcc.dg/torture/pr36373-3.c: Likewise.\n\t* gcc.dg/torture/pr36373-4.c: Likewise.\n\t* gcc.dg/torture/pr36373-5.c: Likewise.\n\t* gcc.dg/torture/pr36373-6.c: Likewise.\n\t* gcc.dg/torture/pr36373-7.c: Likewise.\n\t* gcc.dg/torture/pr36373-8.c: Likewise.\n\t* gcc.dg/torture/pr36373-9.c: Likewise.\n\t* gcc.dg/torture/pr36373-10.c: Likewise.\n\t* gcc.dg/torture/pr36400.c: Likewise.\n\t* gcc.c-torture/execute/pta-field-1.c: Likewise.\n\t* gcc.c-torture/execute/pta-field-2.c: Likewise.\n\t* gcc.dg/tree-ssa/loadpre8.c: Remove XFAIL.\n\t* gcc.dg/tree-ssa/pr24287.c: XFAIL.\n\nFrom-SVN: r137197", "tree": {"sha": "84f496a9d6b5b6bc4fe24fd19e64d6e7e6d43e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84f496a9d6b5b6bc4fe24fd19e64d6e7e6d43e4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7091901cd984928b3599dc62507045dee1754d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7091901cd984928b3599dc62507045dee1754d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7091901cd984928b3599dc62507045dee1754d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7091901cd984928b3599dc62507045dee1754d6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04dbd891905aafb4186382d5417afeefc9522e67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04dbd891905aafb4186382d5417afeefc9522e67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04dbd891905aafb4186382d5417afeefc9522e67"}], "stats": {"total": 466, "additions": 353, "deletions": 113}, "files": [{"sha": "f1279f8b7af05d833538187ef57e8191d2796209", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -1,3 +1,35 @@\n+2008-06-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36400\n+\tPR tree-optimization/36373\n+\tPR tree-optimization/36344\n+\t* tree-ssa-structalias.c (var_escaped, escaped_tree, escaped_id,\n+\tvar_nonlocal, nonlocal_tree, nonlocal_id): New globals\n+\t(update_alias_info): Remove call clobbering code.\n+\t(make_constraint_to): New helper function.\n+\t(make_escape_constraint): Likewise.\n+\t(handle_rhs_call): Use it on all pointer containing arguments.\n+\tAlso mark the static chain escaped.\n+\t(handle_lhs_call): Make constraints from NONLOCAL and ESCAPED\n+\tinstead of ANYTHING.\n+\t(make_constraint_from): New helper split out from ...\n+\t(make_constraint_from_anything): ... here.\n+\t(find_func_aliases): Add constraints for escape sites.\n+\t(intra_create_variable_infos): Make constraints from NONLOCAL\n+\tfor parameters.\n+\t(find_what_p_points_to): Interpret NONLOCAL and ESCAPED the same\n+\tas ANYTHING.\n+\t(clobber_what_p_points_to): Remove.\n+\t(clobber_what_escaped): New function.\n+\t(init_base_vars): Init NONLOCAL and ESCAPED.\n+\t(do_sd_constraint): Do not propagate the solution from ESCAPED\n+\tbut use ESCAPED as a placeholder.\n+\t(solve_graph): Likewise.\n+\t* tree-flow.h (clobber_what_p_points_to): Remove.\n+\t(clobber_what_escaped): Declare.\n+\t* tree-ssa-alias.c (set_initial_properties): Call it.\n+\tRemove code clobbering escaped pointers.\n+\n 2008-06-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* function.c (allocate_struct_function): Only allocate a unique"}, {"sha": "086345b87ca3f00b787f579b314d861484ba0ef2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -1,3 +1,24 @@\n+2008-06-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36400\n+\tPR tree-optimization/36373\n+\tPR tree-optimization/36344\n+\t* gcc.dg/torture/pr36373-1.c: New testcase.\n+\t* gcc.dg/torture/pr36373-2.c: Likewise.\n+\t* gcc.dg/torture/pr36373-3.c: Likewise.\n+\t* gcc.dg/torture/pr36373-4.c: Likewise.\n+\t* gcc.dg/torture/pr36373-5.c: Likewise.\n+\t* gcc.dg/torture/pr36373-6.c: Likewise.\n+\t* gcc.dg/torture/pr36373-7.c: Likewise.\n+\t* gcc.dg/torture/pr36373-8.c: Likewise.\n+\t* gcc.dg/torture/pr36373-9.c: Likewise.\n+\t* gcc.dg/torture/pr36373-10.c: Likewise.\n+\t* gcc.dg/torture/pr36400.c: Likewise.\n+\t* gcc.c-torture/execute/pta-field-1.c: Likewise.\n+\t* gcc.c-torture/execute/pta-field-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/loadpre8.c: Remove XFAIL.\n+\t* gcc.dg/tree-ssa/pr24287.c: XFAIL.\n+\n 2008-06-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/aggr9.ad[sb]: New test."}, {"sha": "056c3fd635404fe79584050b81c7468346d814a1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre8.c?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -93,5 +93,5 @@ rewrite_add_phi_arguments (basic_block bb)\n \t  get_reaching_def ((get_def_from_ptr (get_phi_result_ptr (phi)))->ssa_name.var);\n     }\n }\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "c4b172295b4fdf07e52fe5b7b8aa93e26a43fcde", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr24287.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24287.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24287.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24287.c?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -21,5 +21,5 @@ int g(void)\n     link_error ();\n   return t2 == 2;\n }\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "15329ac002ec9400ddb2b0e76eb2aa5d18146431", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -1173,7 +1173,7 @@ tree gimple_fold_indirect_ref (tree);\n \n /* In tree-ssa-structalias.c */\n bool find_what_p_points_to (tree);\n-bool clobber_what_p_points_to (tree);\n+bool clobber_what_escaped (void);\n \n /* In tree-ssa-live.c */\n extern void remove_unused_locals (void);"}, {"sha": "7c24739e407ab960fcebec00a079938b22cabd01", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -537,6 +537,12 @@ set_initial_properties (struct alias_info *ai)\n \t}\n     }\n \n+  if (!clobber_what_escaped ())\n+    {\n+      any_pt_anything = true;\n+      pt_anything_mask |= ESCAPE_TO_CALL;\n+    }\n+\n   for (i = 0; VEC_iterate (tree, ai->processed_ptrs, i, ptr); i++)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n@@ -557,18 +563,6 @@ set_initial_properties (struct alias_info *ai)\n \n \t  if (tag)\n \t    mark_call_clobbered (tag, pi->escape_mask);\n-\n-\t  /* Defer to points-to analysis if possible, otherwise\n-\t     clobber all addressable variables.  Parameters cannot\n-\t     point to local memory though.\n-\t     ???  Properly tracking which pointers point to non-local\n-\t     memory only would make a big difference here.  */\n-\t  if (!clobber_what_p_points_to (ptr)\n-\t      && !(pi->escape_mask & ESCAPE_IS_PARM))\n-\t    {\n-\t      any_pt_anything = true;\n-\t      pt_anything_mask |= pi->escape_mask;\n-\t    }\n \t}\n \n       /* If the name tag is call clobbered, so is the symbol tag\n@@ -2906,6 +2900,12 @@ is_escape_site (tree stmt)\n       if (TREE_CODE (lhs) == SSA_NAME)\n \treturn NO_ESCAPE;\n \n+      /* If the LHS is a non-global decl, it isn't a non-local memory store.\n+\t If the LHS escapes, the RHS escape is dealt with in the PTA solver.  */\n+      if (DECL_P (lhs)\n+\t  && !is_global_var (lhs))\n+\treturn NO_ESCAPE;\n+\n       /* FIXME: LHS is not an SSA_NAME.  Even if it's an assignment to a\n \t local variables we cannot be sure if it will escape, because we\n \t don't have information about objects not in SSA form.  Need to"}, {"sha": "2b6c56fa1a706a98df98543133f8db9a093198aa", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 285, "deletions": 98, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7091901cd984928b3599dc62507045dee1754d6/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=b7091901cd984928b3599dc62507045dee1754d6", "patch": "@@ -294,26 +294,34 @@ get_varinfo_fc (unsigned int n)\n   return v;\n }\n \n+/* Static IDs for the special variables.  */\n+enum { nothing_id = 0, anything_id = 1, readonly_id = 2,\n+       escaped_id = 3, nonlocal_id = 4, integer_id = 5 };\n+\n /* Variable that represents the unknown pointer.  */\n static varinfo_t var_anything;\n static tree anything_tree;\n-static unsigned int anything_id;\n \n /* Variable that represents the NULL pointer.  */\n static varinfo_t var_nothing;\n static tree nothing_tree;\n-static unsigned int nothing_id;\n \n /* Variable that represents read only memory.  */\n static varinfo_t var_readonly;\n static tree readonly_tree;\n-static unsigned int readonly_id;\n+\n+/* Variable that represents escaped memory.  */\n+static varinfo_t var_escaped;\n+static tree escaped_tree;\n+\n+/* Variable that represents nonlocal memory.  */\n+static varinfo_t var_nonlocal;\n+static tree nonlocal_tree;\n \n /* Variable that represents integers.  This is used for when people do things\n    like &0->a.b.  */\n static varinfo_t var_integer;\n static tree integer_tree;\n-static unsigned int integer_id;\n \n /* Lookup a heap var for FROM, and return it if we find one.  */\n \n@@ -1399,6 +1407,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n        bitmap_set_bit (sol, anything_id);\n      goto done;\n    }\n+\n   /* For each variable j in delta (Sol(y)), add\n      an edge in the graph from j to x, and union Sol(j) into Sol(x).  */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n@@ -1417,8 +1426,16 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \n \t  /* Adding edges from the special vars is pointless.\n \t     They don't have sets that can change.  */\n-\t  if (get_varinfo (t) ->is_special_var)\n+\t  if (get_varinfo (t)->is_special_var)\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n+\t  /* Merging the solution from ESCAPED needlessly increases\n+\t     the set.  Use ESCAPED as representative instead.  */\n+\t  else if (get_varinfo (t)->id == escaped_id\n+\t\t   && !bitmap_bit_p (sol, get_varinfo (t)->id))\n+\t    {\n+\t      bitmap_set_bit (sol, escaped_id);\n+\t      flag = true;\n+\t    }\n \t  else if (add_graph_edge (graph, lhs, t))\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t}\n@@ -2351,7 +2368,9 @@ solve_graph (constraint_graph_t graph)\n \n \t      solution_empty = bitmap_empty_p (solution);\n \n-\t      if (!solution_empty)\n+\t      if (!solution_empty\n+\t\t  /* Do not propagate the ESCAPED solution.  */\n+\t\t  && i != escaped_id)\n \t\t{\n \t\t  bitmap_iterator bi;\n \n@@ -3271,24 +3290,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n   /* Mark all the variables whose address are taken by the statement.  */\n   addr_taken = addresses_taken (stmt);\n   if (addr_taken)\n-    {\n-      bitmap_ior_into (gimple_addressable_vars (cfun), addr_taken);\n-\n-      /* If STMT is an escape point, all the addresses taken by it are\n-\t call-clobbered.  */\n-      if (stmt_escape_type != NO_ESCAPE)\n-\t{\n-\t  bitmap_iterator bi;\n-\t  unsigned i;\n-\n-\t  EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n-\t    {\n-\t      tree rvar = referenced_var (i);\n-\t      if (!unmodifiable_var_p (rvar))\n-\t\tmark_call_clobbered (rvar, stmt_escape_type);\n-\t    }\n-\t}\n-    }\n+    bitmap_ior_into (gimple_addressable_vars (cfun), addr_taken);\n \n   /* Process each operand use.  For pointers, determine whether they\n      are dereferenced by the statement, or whether their value\n@@ -3573,6 +3575,34 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n   return true;\n }\n \n+/* Create a constraint ID = OP.  */\n+\n+static void\n+make_constraint_to (unsigned id, tree op)\n+{\n+  VEC(ce_s, heap) *rhsc = NULL;\n+  struct constraint_expr *c;\n+  struct constraint_expr includes;\n+  unsigned int j;\n+\n+  includes.var = id;\n+  includes.offset = 0;\n+  includes.type = SCALAR;\n+\n+  get_constraint_for (op, &rhsc);\n+  for (j = 0; VEC_iterate (ce_s, rhsc, j, c); j++)\n+    process_constraint_1 (new_constraint (includes, *c), true);\n+  VEC_free (ce_s, heap, rhsc);\n+}\n+\n+/* Make constraints necessary to make OP escape.  */\n+\n+static void\n+make_escape_constraint (tree op)\n+{\n+  make_constraint_to (escaped_id, op);\n+}\n+\n /* For non-IPA mode, generate constraints necessary for a call on the\n    RHS.  */\n \n@@ -3581,35 +3611,21 @@ handle_rhs_call  (tree rhs)\n {\n   tree arg;\n   call_expr_arg_iterator iter;\n-  struct constraint_expr rhsc;\n-\n-  rhsc.var = anything_id;\n-  rhsc.offset = 0;\n-  rhsc.type = ADDRESSOF;\n \n   FOR_EACH_CALL_EXPR_ARG (arg, iter, rhs)\n-    {\n-      VEC(ce_s, heap) *lhsc = NULL;\n-\n-      /* Find those pointers being passed, and make sure they end up\n-\t pointing to anything.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (arg)))\n-\t{\n-\t  unsigned int j;\n-\t  struct constraint_expr *lhsp;\n-\n-\t  get_constraint_for (arg, &lhsc);\n-\t  do_deref (&lhsc);\n-\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\t    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n-\t  VEC_free (ce_s, heap, lhsc);\n-\t}\n-    }\n+    /* Find those pointers being passed, and make sure they end up\n+       pointing to anything.  */\n+    if (could_have_pointers (arg))\n+      make_escape_constraint (arg);\n+\n+  /* The static chain escapes as well.  */\n+  if (CALL_EXPR_STATIC_CHAIN (rhs))\n+    make_escape_constraint (CALL_EXPR_STATIC_CHAIN (rhs));\n }\n \n /* For non-IPA mode, generate constraints necessary for a call\n    that returns a pointer and assigns it to LHS.  This simply makes\n-   the LHS point to anything.  */\n+   the LHS point to global and escaped variables.  */\n \n static void\n handle_lhs_call (tree lhs)\n@@ -3619,12 +3635,70 @@ handle_lhs_call (tree lhs)\n   unsigned int j;\n   struct constraint_expr *lhsp;\n \n-  rhsc.var = anything_id;\n+  get_constraint_for (lhs, &lhsc);\n+  rhsc.var = nonlocal_id;\n+  rhsc.offset = 0;\n+  rhsc.type = ADDRESSOF;\n+  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+  rhsc.var = escaped_id;\n   rhsc.offset = 0;\n   rhsc.type = ADDRESSOF;\n+  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+  VEC_free (ce_s, heap, lhsc);\n+}\n+\n+/* For non-IPA mode, generate constraints necessary for a call of a\n+   const function that returns a pointer in the statement STMT.  */\n+\n+static void\n+handle_const_call (tree stmt)\n+{\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  tree call = get_call_expr_in (stmt);\n+  VEC(ce_s, heap) *lhsc = NULL;\n+  struct constraint_expr rhsc;\n+  unsigned int j;\n+  struct constraint_expr *lhsp;\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+\n   get_constraint_for (lhs, &lhsc);\n+\n+  /* If this is a nested function then it can return anything.  */\n+  if (CALL_EXPR_STATIC_CHAIN (call))\n+    {\n+      rhsc.var = anything_id;\n+      rhsc.offset = 0;\n+      rhsc.type = ADDRESSOF;\n+      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\tprocess_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+      VEC_free (ce_s, heap, lhsc);\n+      return;\n+    }\n+\n+  /* May return addresses of globals.  */\n+  rhsc.var = nonlocal_id;\n+  rhsc.offset = 0;\n+  rhsc.type = ADDRESSOF;\n   for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n     process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+\n+  /* May return arguments.  */\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+    if (could_have_pointers (arg))\n+      {\n+\tVEC(ce_s, heap) *argc = NULL;\n+\tstruct constraint_expr *argp;\n+\tint i;\n+\tget_constraint_for (arg, &argc);\n+\tfor (i = 0; VEC_iterate (ce_s, argc, i, argp); i++)\n+\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t    process_constraint_1 (new_constraint (*lhsp, *argp), true);\n+\tVEC_free (ce_s, heap, argc);\n+      }\n+\n   VEC_free (ce_s, heap, lhsc);\n }\n \n@@ -3636,10 +3710,12 @@ handle_lhs_call (tree lhs)\n static void\n find_func_aliases (tree origt)\n {\n-  tree t = origt;\n+  tree call, t = origt;\n   VEC(ce_s, heap) *lhsc = NULL;\n   VEC(ce_s, heap) *rhsc = NULL;\n   struct constraint_expr *c;\n+  enum escape_type stmt_escape_type;\n+  int flags;\n \n   if (TREE_CODE (t) == RETURN_EXPR && TREE_OPERAND (t, 0))\n     t = TREE_OPERAND (t, 0);\n@@ -3688,17 +3764,26 @@ find_func_aliases (tree origt)\n \n      In non-ipa mode, we need to generate constraints for each\n      pointer passed by address.  */\n-  else if (((TREE_CODE (t) == GIMPLE_MODIFY_STMT\n-\t     && TREE_CODE (GIMPLE_STMT_OPERAND (t, 1)) == CALL_EXPR\n-\t     && !(call_expr_flags (GIMPLE_STMT_OPERAND (t, 1))\n-\t\t  & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-\t    || (TREE_CODE (t) == CALL_EXPR\n-\t\t&& !(call_expr_flags (t)\n-\t\t     & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))))\n+  else if ((call = get_call_expr_in (t)) != NULL_TREE\n+\t   && !((flags = call_expr_flags (call))\n+\t\t& (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n     {\n       if (!in_ipa_mode)\n \t{\n-\t  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+\t  /* Const functions can return their arguments and addresses\n+\t     of global memory but not of escaped memory.  */\n+\t  if (flags & ECF_CONST)\n+\t    {\n+\t      if (TREE_CODE (t) == GIMPLE_MODIFY_STMT\n+\t\t  && could_have_pointers (GIMPLE_STMT_OPERAND (t, 1)))\n+\t\thandle_const_call (t);\n+\t    }\n+\t  /* Pure functions can return addresses in and of memory\n+\t     reachable from their arguments, but they are not an escape\n+\t     point for reachable memory of their arguments.  But as we\n+\t     do not compute call-used memory separately we cannot do\n+\t     something special here.  */\n+\t  else if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n \t    {\n \t      handle_rhs_call (GIMPLE_STMT_OPERAND (t, 1));\n \t      if (could_have_pointers (GIMPLE_STMT_OPERAND (t, 1)))\n@@ -3893,6 +3978,57 @@ find_func_aliases (tree origt)\n \tget_varinfo (c->var)->no_tbaa_pruning = true;\n     }\n \n+  stmt_escape_type = is_escape_site (t);\n+  if (stmt_escape_type == ESCAPE_STORED_IN_GLOBAL)\n+    {\n+      tree rhs;\n+      gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+      rhs = GIMPLE_STMT_OPERAND (t, 1);\n+      if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t{\n+\t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n+\t  if (base\n+\t      && (!DECL_P (base)\n+\t\t  || !is_global_var (base)))\n+\t    make_escape_constraint (rhs);\n+\t}\n+      else if (TREE_CODE (rhs) == SSA_NAME\n+\t       && POINTER_TYPE_P (TREE_TYPE (rhs)))\n+\tmake_escape_constraint (rhs);\n+      else if (could_have_pointers (rhs))\n+\tmake_escape_constraint (rhs);\n+    }\n+  else if (stmt_escape_type == ESCAPE_BAD_CAST)\n+    {\n+      tree rhs;\n+      gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+      rhs = GIMPLE_STMT_OPERAND (t, 1);\n+      gcc_assert (CONVERT_EXPR_P (rhs)\n+\t\t  || TREE_CODE (rhs) == VIEW_CONVERT_EXPR);\n+      rhs = TREE_OPERAND (rhs, 0);\n+      make_escape_constraint (rhs);\n+    }\n+  else if (stmt_escape_type == ESCAPE_TO_ASM)\n+    {\n+      tree link;\n+      int i;\n+      for (i = 0, link = ASM_OUTPUTS (t); link; i++, link = TREE_CHAIN (link))\n+\t{\n+\t  tree op = TREE_VALUE (link);\n+\t  if (op && could_have_pointers (op))\n+\t    /* Strictly we'd only need the constraints from ESCAPED and\n+\t       NONLOCAL.  */\n+\t    make_escape_constraint (op);\n+\t}\n+      for (i = 0, link = ASM_INPUTS (t); link; i++, link = TREE_CHAIN (link))\n+\t{\n+\t  tree op = TREE_VALUE (link);\n+\t  if (op && could_have_pointers (op))\n+\t    /* Strictly we'd only need the constraint to ESCAPED.  */\n+\t    make_escape_constraint (op);\n+\t}\n+    }\n+\n   /* After promoting variables and computing aliasing we will\n      need to re-scan most statements.  FIXME: Try to minimize the\n      number of statements re-scanned.  It's not really necessary to\n@@ -4118,22 +4254,30 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n   return count;\n }\n \n-/* Create a constraint from ANYTHING variable to VI.  */\n+/* Create a constraint ID = &FROM.  */\n+\n static void\n-make_constraint_from_anything (varinfo_t vi)\n+make_constraint_from (varinfo_t vi, int from)\n {\n   struct constraint_expr lhs, rhs;\n \n   lhs.var = vi->id;\n   lhs.offset = 0;\n   lhs.type = SCALAR;\n \n-  rhs.var = anything_id;\n+  rhs.var = from;\n   rhs.offset = 0;\n   rhs.type = ADDRESSOF;\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n+/* Create a constraint from ANYTHING variable to VI.  */\n+static void\n+make_constraint_from_anything (varinfo_t vi)\n+{\n+  make_constraint_from (vi, anything_id);\n+}\n+\n /* Count the number of arguments DECL has, and set IS_VARARGS to true\n    if it is a varargs function.  */\n \n@@ -4478,7 +4622,7 @@ intra_create_variable_infos (void)\n   struct constraint_expr lhs, rhs;\n \n   /* For each incoming pointer argument arg, create the constraint ARG\n-     = ANYTHING or a dummy variable if flag_argument_noalias is set.  */\n+     = NONLOCAL or a dummy variable if flag_argument_noalias is set.  */\n   for (t = DECL_ARGUMENTS (current_function_decl); t; t = TREE_CHAIN (t))\n     {\n       varinfo_t p;\n@@ -4539,7 +4683,7 @@ intra_create_variable_infos (void)\n \t  varinfo_t arg_vi = get_vi_for_tree (t);\n \n \t  for (p = arg_vi; p; p = p->next)\n-\t    make_constraint_from_anything (p);\n+\t    make_constraint_from (p, nonlocal_id);\n \t}\n     }\n }\n@@ -4794,7 +4938,9 @@ find_what_p_points_to (tree p)\n \t\t     aliases.  */\n \t\t  if (vi->id == nothing_id)\n \t\t    pi->pt_null = 1;\n-\t\t  else if (vi->id == anything_id)\n+\t\t  else if (vi->id == anything_id\n+\t\t\t   || vi->id == nonlocal_id\n+\t\t\t   || vi->id == escaped_id)\n \t\t    was_pt_anything = 1;\n \t\t  else if (vi->id == readonly_id)\n \t\t    was_pt_anything = 1;\n@@ -4843,42 +4989,23 @@ find_what_p_points_to (tree p)\n   return false;\n }\n \n-/* Mark everything that p points to as call clobbered.  Returns true\n-   if everything is done and false if all addressable variables need to\n-   be clobbered because p points to anything.  */\n+/* Mark the ESCAPED solution as call clobbered.  Returns false if\n+   pt_anything escaped which needs all locals that have their address\n+   taken marked call clobbered as well.  */\n \n bool\n-clobber_what_p_points_to (tree p)\n+clobber_what_escaped (void)\n {\n-  tree lookup_p = p;\n   varinfo_t vi;\n-  struct ptr_info_def *pi;\n   unsigned int i;\n   bitmap_iterator bi;\n \n   if (!have_alias_info)\n     return false;\n \n-  /* For parameters, get at the points-to set for the actual parm\n-     decl.  */\n-  if (TREE_CODE (p) == SSA_NAME\n-      && TREE_CODE (SSA_NAME_VAR (p)) == PARM_DECL\n-      && SSA_NAME_IS_DEFAULT_DEF (p))\n-    lookup_p = SSA_NAME_VAR (p);\n-\n-  vi = lookup_vi_for_tree (lookup_p);\n-  if (!vi)\n-    return false;\n-\n-  /* We are asking for the points-to solution of pointers.  */\n-  gcc_assert (!vi->is_artificial_var\n-\t      && vi->size == vi->fullsize);\n-\n-  pi = get_ptr_info (p);\n-\n   /* This variable may have been collapsed, let's get the real\n-     variable.  */\n-  vi = get_varinfo (find (vi->id));\n+     variable for escaped_id.  */\n+  vi = get_varinfo (find (escaped_id));\n \n   /* Mark variables in the solution call-clobbered.  */\n   EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n@@ -4903,12 +5030,13 @@ clobber_what_p_points_to (tree p)\n \t   || TREE_CODE (vi->decl) == PARM_DECL\n \t   || TREE_CODE (vi->decl) == RESULT_DECL)\n \t  && !unmodifiable_var_p (vi->decl))\n-\tmark_call_clobbered (vi->decl, pi->escape_mask);\n+\tmark_call_clobbered (vi->decl, ESCAPE_TO_CALL);\n     }\n \n   return true;\n }\n \n+\n /* Dump points-to information to OUTFILE.  */\n \n void\n@@ -4959,28 +5087,26 @@ init_base_vars (void)\n   /* Create the NULL variable, used to represent that a variable points\n      to NULL.  */\n   nothing_tree = create_tmp_var_raw (void_type_node, \"NULL\");\n-  var_nothing = new_var_info (nothing_tree, 0, \"NULL\");\n+  var_nothing = new_var_info (nothing_tree, nothing_id, \"NULL\");\n   insert_vi_for_tree (nothing_tree, var_nothing);\n   var_nothing->is_artificial_var = 1;\n   var_nothing->offset = 0;\n   var_nothing->size = ~0;\n   var_nothing->fullsize = ~0;\n   var_nothing->is_special_var = 1;\n-  nothing_id = 0;\n   VEC_safe_push (varinfo_t, heap, varmap, var_nothing);\n \n   /* Create the ANYTHING variable, used to represent that a variable\n      points to some unknown piece of memory.  */\n   anything_tree = create_tmp_var_raw (void_type_node, \"ANYTHING\");\n-  var_anything = new_var_info (anything_tree, 1, \"ANYTHING\");\n+  var_anything = new_var_info (anything_tree, anything_id, \"ANYTHING\");\n   insert_vi_for_tree (anything_tree, var_anything);\n   var_anything->is_artificial_var = 1;\n   var_anything->size = ~0;\n   var_anything->offset = 0;\n   var_anything->next = NULL;\n   var_anything->fullsize = ~0;\n   var_anything->is_special_var = 1;\n-  anything_id = 1;\n \n   /* Anything points to anything.  This makes deref constraints just\n      work in the presence of linked list and other p = *p type loops,\n@@ -5001,15 +5127,14 @@ init_base_vars (void)\n   /* Create the READONLY variable, used to represent that a variable\n      points to readonly memory.  */\n   readonly_tree = create_tmp_var_raw (void_type_node, \"READONLY\");\n-  var_readonly = new_var_info (readonly_tree, 2, \"READONLY\");\n+  var_readonly = new_var_info (readonly_tree, readonly_id, \"READONLY\");\n   var_readonly->is_artificial_var = 1;\n   var_readonly->offset = 0;\n   var_readonly->size = ~0;\n   var_readonly->fullsize = ~0;\n   var_readonly->next = NULL;\n   var_readonly->is_special_var = 1;\n   insert_vi_for_tree (readonly_tree, var_readonly);\n-  readonly_id = 2;\n   VEC_safe_push (varinfo_t, heap, varmap, var_readonly);\n \n   /* readonly memory points to anything, in order to make deref\n@@ -5020,23 +5145,65 @@ init_base_vars (void)\n   lhs.var = readonly_id;\n   lhs.offset = 0;\n   rhs.type = ADDRESSOF;\n-  rhs.var = anything_id;\n+  rhs.var = readonly_id;  /* FIXME */\n   rhs.offset = 0;\n+  process_constraint (new_constraint (lhs, rhs));\n \n+  /* Create the ESCAPED variable, used to represent the set of escaped\n+     memory.  */\n+  escaped_tree = create_tmp_var_raw (void_type_node, \"ESCAPED\");\n+  var_escaped = new_var_info (escaped_tree, escaped_id, \"ESCAPED\");\n+  insert_vi_for_tree (escaped_tree, var_escaped);\n+  var_escaped->is_artificial_var = 1;\n+  var_escaped->offset = 0;\n+  var_escaped->size = ~0;\n+  var_escaped->fullsize = ~0;\n+  var_escaped->is_special_var = 0;\n+  VEC_safe_push (varinfo_t, heap, varmap, var_escaped);\n+  gcc_assert (VEC_index (varinfo_t, varmap, 3) == var_escaped);\n+\n+  /* ESCAPED = *ESCAPED, because escaped is may-deref'd at calls, etc.  */\n+  lhs.type = SCALAR;\n+  lhs.var = escaped_id;\n+  lhs.offset = 0;\n+  rhs.type = DEREF;\n+  rhs.var = escaped_id;\n+  rhs.offset = 0;\n+  process_constraint_1 (new_constraint (lhs, rhs), true);\n+\n+  /* Create the NONLOCAL variable, used to represent the set of nonlocal\n+     memory.  */\n+  nonlocal_tree = create_tmp_var_raw (void_type_node, \"NONLOCAL\");\n+  var_nonlocal = new_var_info (nonlocal_tree, nonlocal_id, \"NONLOCAL\");\n+  insert_vi_for_tree (nonlocal_tree, var_nonlocal);\n+  var_nonlocal->is_artificial_var = 1;\n+  var_nonlocal->offset = 0;\n+  var_nonlocal->size = ~0;\n+  var_nonlocal->fullsize = ~0;\n+  var_nonlocal->is_special_var = 1;\n+  VEC_safe_push (varinfo_t, heap, varmap, var_nonlocal);\n+\n+  /* Nonlocal memory points to escaped (which includes nonlocal),\n+     in order to make deref easier.  */\n+  lhs.type = SCALAR;\n+  lhs.var = nonlocal_id;\n+  lhs.offset = 0;\n+  rhs.type = ADDRESSOF;\n+  rhs.var = escaped_id;\n+  rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n \n   /* Create the INTEGER variable, used to represent that a variable points\n      to an INTEGER.  */\n   integer_tree = create_tmp_var_raw (void_type_node, \"INTEGER\");\n-  var_integer = new_var_info (integer_tree, 3, \"INTEGER\");\n+  var_integer = new_var_info (integer_tree, integer_id, \"INTEGER\");\n   insert_vi_for_tree (integer_tree, var_integer);\n   var_integer->is_artificial_var = 1;\n   var_integer->size = ~0;\n   var_integer->fullsize = ~0;\n   var_integer->offset = 0;\n   var_integer->next = NULL;\n   var_integer->is_special_var = 1;\n-  integer_id = 3;\n   VEC_safe_push (varinfo_t, heap, varmap, var_integer);\n \n   /* INTEGER = ANYTHING, because we don't know where a dereference of\n@@ -5048,6 +5215,26 @@ init_base_vars (void)\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n+\n+  /* *ESCAPED = &ESCAPED.  This is true because we have to assume\n+     everything pointed to by escaped can also point to escaped. */\n+  lhs.type = DEREF;\n+  lhs.var = escaped_id;\n+  lhs.offset = 0;\n+  rhs.type = ADDRESSOF;\n+  rhs.var = escaped_id;\n+  rhs.offset = 0;\n+  process_constraint_1 (new_constraint (lhs, rhs), true);\n+\n+  /* *ESCAPED = &NONLOCAL.  This is true because we have to assume\n+     everything pointed to by escaped can also point to nonlocal. */\n+  lhs.type = DEREF;\n+  lhs.var = escaped_id;\n+  lhs.offset = 0;\n+  rhs.type = ADDRESSOF;\n+  rhs.var = nonlocal_id;\n+  rhs.offset = 0;\n+  process_constraint_1 (new_constraint (lhs, rhs), true);\n }\n \n /* Initialize things necessary to perform PTA */"}]}