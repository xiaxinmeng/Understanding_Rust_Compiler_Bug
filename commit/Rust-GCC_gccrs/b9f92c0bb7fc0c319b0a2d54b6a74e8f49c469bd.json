{"sha": "b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlmOTJjMGJiN2ZjMGMzMTliMGEyZDU0YjZhNzRlOGY0OWM0NjliZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-12-13T23:16:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-12-13T23:16:56Z"}, "message": "re PR middle-end/78468 (libgomp.c/reduction-10.c and many more FAIL)\n\n\tPR middle-end/78468\n\t* emit-rtl.c (init_emit): Remove ??? comment.\n\t* explow.c (get_dynamic_stack_size): Take known alignment of stack\n\tpointer + STACK_DYNAMIC_OFFSET into account in lieu of STACK_BOUNDARY.\n\t* config/sparc/sparc.h (INIT_EXPANDERS): In 32-bit mode, lower the\n\talignment of 3 virtual registers to BITS_PER_WORD.\n\n\t* config/sparc/sparc.c (sparc_compute_frame_size): Simplify.\n\nCo-Authored-By: Dominik Vogt <vogt@linux.vnet.ibm.com>\n\nFrom-SVN: r255616", "tree": {"sha": "6a7f304d8ee14fef74899d293496f9f886e83325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a7f304d8ee14fef74899d293496f9f886e83325"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/comments", "author": null, "committer": null, "parents": [{"sha": "f4615940b171c449a0e799195dbd28041f677f35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4615940b171c449a0e799195dbd28041f677f35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4615940b171c449a0e799195dbd28041f677f35"}], "stats": {"total": 59, "additions": 41, "deletions": 18}, "files": [{"sha": "272bb7696f2f28654437bd29d33c756073dcb495", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "patch": "@@ -1,3 +1,15 @@\n+2017-12-13  Eric Botcazou  <ebotcazou@adacore.com>\n+            Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\tPR middle-end/78468\n+\t* emit-rtl.c (init_emit): Remove ??? comment.\n+\t* explow.c (get_dynamic_stack_size): Take known alignment of stack\n+\tpointer + STACK_DYNAMIC_OFFSET into account in lieu of STACK_BOUNDARY.\n+\t* config/sparc/sparc.h (INIT_EXPANDERS): In 32-bit mode, lower the\n+\talignment of 3 virtual registers to BITS_PER_WORD.\n+\n+\t* config/sparc/sparc.c (sparc_compute_frame_size): Simplify.\n+\n 2017-12-13  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* config/rs6000/ppc-auxv.h (PPC_FEATURE2_HTM_NO_SUSPEND): New define."}, {"sha": "890bde9fc0add5a04b9d4e9b5ac6c35a7c6ad392", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "patch": "@@ -5483,10 +5483,8 @@ sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function)\n     frame_size = apparent_frame_size = 0;\n   else\n     {\n-      /* We subtract TARGET_STARTING_FRAME_OFFSET, remember it's negative.  */\n-      apparent_frame_size\n-\t= ROUND_UP (size - targetm.starting_frame_offset (), 8);\n-      apparent_frame_size += n_global_fp_regs * 4;\n+      /* Start from the apparent frame size.  */\n+      apparent_frame_size = ROUND_UP (size, 8) + n_global_fp_regs * 4;\n \n       /* We need to add the size of the outgoing argument area.  */\n       frame_size = apparent_frame_size + ROUND_UP (args_size, 8);"}, {"sha": "3d8e198b30781078369e2a6b579adbf03d62b1cf", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "patch": "@@ -771,13 +771,29 @@ extern enum cmodel sparc_cmodel;\n /* The soft frame pointer does not have the stack bias applied.  */\n #define FRAME_POINTER_REGNUM 101\n \n-/* Given the stack bias, the stack pointer isn't actually aligned.  */\n #define INIT_EXPANDERS\t\t\t\t\t\t\t \\\n   do {\t\t\t\t\t\t\t\t\t \\\n-    if (crtl->emit.regno_pointer_align && SPARC_STACK_BIAS)\t \\\n+    if (crtl->emit.regno_pointer_align)\t\t\t\t\t \\\n       {\t\t\t\t\t\t\t\t\t \\\n-\tREGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = BITS_PER_UNIT;\t \\\n-\tREGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = BITS_PER_UNIT; \\\n+\t/* The biased stack pointer is only aligned on BITS_PER_UNIT.  */\\\n+\tif (SPARC_STACK_BIAS)\t\t\t\t\t\t \\\n+\t  {\t\t\t\t\t\t\t\t \\\n+\t    REGNO_POINTER_ALIGN (STACK_POINTER_REGNUM)\t\t\t \\\n+\t      = BITS_PER_UNIT;\t \t\t\t\t\t \\\n+\t    REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM)\t\t \\\n+\t      = BITS_PER_UNIT;\t\t\t\t\t\t \\\n+\t  }\t\t\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\t/* In 32-bit mode, not everything is double-word aligned.  */\t \\\n+\tif (TARGET_ARCH32)\t\t\t\t\t\t \\\n+\t  {\t\t\t\t\t\t\t\t \\\n+\t    REGNO_POINTER_ALIGN (VIRTUAL_INCOMING_ARGS_REGNUM)\t\t \\\n+\t      = BITS_PER_WORD;\t\t\t\t\t\t \\\n+\t    REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM)\t\t \\\n+\t      = BITS_PER_WORD;\t\t\t\t\t\t \\\n+\t    REGNO_POINTER_ALIGN (VIRTUAL_OUTGOING_ARGS_REGNUM)\t\t \\\n+\t      = BITS_PER_WORD;\t\t\t\t\t\t \\\n+\t  }\t\t\t\t\t\t\t\t \\\n       }\t\t\t\t\t\t\t\t\t \\\n   } while (0)\n "}, {"sha": "5ab1fb79085b42de3b82102a9fbf24855c899ea3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "patch": "@@ -5764,8 +5764,6 @@ init_emit (void)\n   REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = STACK_BOUNDARY;\n   REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) = STACK_BOUNDARY;\n \n-  /* ??? These are problematic (for example, 3 out of 4 are wrong on\n-     32-bit SPARC and cannot be all fixed because of the ABI).  */\n   REGNO_POINTER_ALIGN (VIRTUAL_INCOMING_ARGS_REGNUM) = STACK_BOUNDARY;\n   REGNO_POINTER_ALIGN (VIRTUAL_STACK_VARS_REGNUM) = STACK_BOUNDARY;\n   REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM) = STACK_BOUNDARY;"}, {"sha": "696f06673eb71f3033d00fac2b529bbfee45cc54", "filename": "gcc/explow.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "patch": "@@ -1206,7 +1206,6 @@ get_dynamic_stack_size (rtx *psize, unsigned size_align,\n \t\t\tunsigned required_align,\n \t\t\tHOST_WIDE_INT *pstack_usage_size)\n {\n-  unsigned extra = 0;\n   rtx size = *psize;\n \n   /* Ensure the size is in the proper mode.  */\n@@ -1242,16 +1241,16 @@ get_dynamic_stack_size (rtx *psize, unsigned size_align,\n      example), so we must preventively align the value.  We leave space\n      in SIZE for the hole that might result from the alignment operation.  */\n \n-  /* Since the stack is presumed to be aligned before this allocation,\n-     we only need to increase the size of the allocation if the required\n-     alignment is more than the stack alignment.  */\n-  if (required_align > STACK_BOUNDARY)\n+  unsigned known_align = REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM);\n+  if (known_align == 0)\n+    known_align = BITS_PER_UNIT;\n+  if (required_align > known_align)\n     {\n-      extra = (required_align - STACK_BOUNDARY) / BITS_PER_UNIT;\n+      unsigned extra = (required_align - known_align) / BITS_PER_UNIT;\n       size = plus_constant (Pmode, size, extra);\n       size = force_operand (size, NULL_RTX);\n-      if (size_align > STACK_BOUNDARY)\n-\tsize_align = STACK_BOUNDARY;\n+      if (size_align > known_align)\n+\tsize_align = known_align;\n \n       if (flag_stack_usage_info && pstack_usage_size)\n \t*pstack_usage_size += extra;"}]}