{"sha": "3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1MGRlZDFlZGRiMzViN2Y5MDMwYzU1NDVkMWU1NDJjZWY1ZjhiMg==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2021-06-22T04:47:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-20T12:31:31Z"}, "message": "[Ada] Implementation of Preelaborable_Initialization attribute for AI12-0409\n\ngcc/ada/\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Fold\n\tPreelaborable_Initialization attribute in cases where it hasn't\n\tbeen folded by the analyzer.\n\t* exp_disp.adb (Original_View_In_Visible_Part): This function is\n\tremoved and moved to sem_util.adb.\n\t* sem_attr.adb (Attribute_22): Add\n\tAttribute_Preelaborable_Initialization as an Ada 2022 attribute.\n\t(Analyze_Attribute, Attribute_Preelaborable_Initialization):\n\tCheck that the prefix of the attribute is either a formal\n\tprivate or derived type, or a composite type declared within the\n\tvisible part of a package or generic package.\n\t(Eval_Attribute): Perform folding of\n\tPreelaborable_Initialization attribute based on\n\tHas_Preelaborable_Initialization applied to the prefix type.\n\t* sem_ch3.adb (Resolve_Aspects): Add specialized code for\n\tPreelaborable_Initialization used at the end of a package\n\tvisible part for setting Known_To_Have_Preelab_Init on types\n\tthat are specified with True or that have a conjunction of one\n\tor more P_I attributes applied to formal types.\n\t* sem_ch7.adb (Analyze_Package_Specification): On call to\n\tHas_Preelaborable_Initialization, pass True for new formal\n\tFormal_Types_Have_Preelab_Init, so that error checking treats\n\tsubcomponents that are declared within types in generics as\n\thaving preelaborable initialization when the subcomponents are\n\tof formal types.\n\t* sem_ch13.adb (Analyze_Aspects_At_Freeze_Point): Add test for\n\tP_I to prevent calling Make_Pragma_From_Boolean_Aspect, since\n\tthis aspect is handled specially and the\n\tKnown_To_Have_Preelab_Init flag will get set on types that have\n\tthe aspect by other means.\n\t(Analyze_Aspect_Specifications.Analyze_One_Aspect): Add test for\n\tAspect_Preelaborable_Initialization for allowing the aspect to\n\tbe specified on formal type declarations.\n\t(Is_Operational_Item): Treat Attribute_Put_Image as an\n\toperational attribute.  The need for this was encountered while\n\tworking on these changes.\n\t* sem_util.ads (Has_Preelaborable_Initialization): Add\n\tFormal_Types_Have_Preelab_Init as a new formal parameter that\n\tdefaults to False.\n\t(Is_Conjunction_Of_Formal_Preelab_Init_Attributes): New\n\tfunction.\n\t(Original_View_In_Visible_Part): Moved here from exp_disp.adb,\n\tso it can be called by Analyze_Attribute.\n\t* sem_util.adb (Has_Preelaborable_Initialization): Return True\n\tfor formal private and derived types when new formal\n\tFormal_Types_Have_Preelab_Init is True, and pass along the\n\tFormal_Types_Have_Preelab_Init flag in the array component case.\n\t(Check_Components): Pass along Formal_Types_Have_Preelab_Init\n\tflag on call to Has_Preelaborable_Initialization.\n\t(Is_Conjunction_Of_Formal_Preelab_Init_Attributes): New function\n\tthat returns True when passed an expression that includes one or\n\tmore attributes for Preelaborable_Initialization applied to\n\tprefixes that denote formal types.\n\t(Is_Formal_Preelab_Init_Attribute): New utility function nested\n\twithin Is_Conjunction_Of_Formal_Preelab_Init_Attributes that\n\tdetermines whether a node is a P_I attribute applied to a\n\tgeneric formal type.\n\t(Original_View_In_Visible_Part): Moved here from exp_util.adb,\n\tso it can be called by Analyze_Attribute.\n\t* snames.ads-tmpl: Add note near the start of spec giving\n\tdetails about what needs to be done when adding a name that\n\tcorresponds to both an attribute and a pragma.  Delete existing\n\toccurrence of Name_Preelaborable_Initialization, and add a note\n\tcomment in the list of Name_* constants at that place,\n\tindicating that it's included in type Pragma_Id, etc., echoing\n\tother such comments for names that are both an attribute and a\n\tpragma.  Insert Name_Preelaborable_Initialization in the\n\talphabetized set of Name_* constants corresponding to\n\tattributes (between First_Attribute_Name and\n\tLast_Attribute_Name).\n\t(type Attribute_Id): Add new literal\n\tAttribute_Preelaborable_Initialization.\n\t(type Pragma_Id): Move Pragma_Preelaborable_Initialization from\n\tits current position to the end of the type, in the special set\n\tof pragma literals that have corresponding atttributes. Add to\n\taccompanying comment, indicating that functions Get_Pragma_Id\n\tand Is_Pragma_Name need to be updated when adding a pragma\n\tliteral to the special set.\n\t* snames.adb-tmpl (Get_Pragma_Id): Add case alternative for\n\tPragma_Preelaborable_Initialization.\n\t(Is_Pragma_Name): Add test for\n\tName_Preelaborable_Initialization.", "tree": {"sha": "8c6d1980e37a5cd632b2ef321dbe417a9ff7a69a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c6d1980e37a5cd632b2ef321dbe417a9ff7a69a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c83448aaf907f3895194167098b7003ed932583d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83448aaf907f3895194167098b7003ed932583d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c83448aaf907f3895194167098b7003ed932583d"}], "stats": {"total": 352, "additions": 295, "deletions": 57}, "files": [{"sha": "e86cb8f028fe3231916fc6fcf070a39f483ee9ad", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -5530,6 +5530,21 @@ package body Exp_Attr is\n          end if;\n       end Pred;\n \n+      ----------------------------------\n+      -- Preelaborable_Initialization --\n+      ----------------------------------\n+\n+      when Attribute_Preelaborable_Initialization =>\n+\n+         --  This attribute should already be folded during analysis, but if\n+         --  for some reason it hasn't been, we fold it now.\n+\n+         Fold_Uint\n+           (N,\n+            UI_From_Int\n+              (Boolean'Pos (Has_Preelaborable_Initialization (Ptyp))),\n+            Static => False);\n+\n       --------------\n       -- Priority --\n       --------------"}, {"sha": "4db883cd296b57644a9d0494fb8df1decfbe2af9", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -93,10 +93,6 @@ package body Exp_Disp is\n    --  Duplicate_Subexpr with an explicit dereference when From is an access\n    --  parameter.\n \n-   function Original_View_In_Visible_Part (Typ : Entity_Id) return Boolean;\n-   --  Check if the type has a private view or if the public view appears in\n-   --  the visible part of a package spec.\n-\n    function Prim_Op_Kind\n      (Prim : Entity_Id;\n       Typ  : Entity_Id) return Node_Id;\n@@ -7394,31 +7390,6 @@ package body Exp_Disp is\n       end if;\n    end New_Value;\n \n-   -----------------------------------\n-   -- Original_View_In_Visible_Part --\n-   -----------------------------------\n-\n-   function Original_View_In_Visible_Part (Typ : Entity_Id) return Boolean is\n-      Scop : constant Entity_Id := Scope (Typ);\n-\n-   begin\n-      --  The scope must be a package\n-\n-      if not Is_Package_Or_Generic_Package (Scop) then\n-         return False;\n-      end if;\n-\n-      --  A type with a private declaration has a private view declared in\n-      --  the visible part.\n-\n-      if Has_Private_Declaration (Typ) then\n-         return True;\n-      end if;\n-\n-      return List_Containing (Parent (Typ)) =\n-        Visible_Declarations (Package_Specification (Scop));\n-   end Original_View_In_Visible_Part;\n-\n    ------------------\n    -- Prim_Op_Kind --\n    ------------------"}, {"sha": "e37b61a4b4d4a6bacd0c40df0043a1d6c74ed7c7", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 75, "deletions": 18, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -175,6 +175,7 @@ package body Sem_Attr is\n    Attribute_22 : constant Attribute_Class_Array := Attribute_Class_Array'(\n       Attribute_Enum_Rep                     |\n       Attribute_Enum_Val                     => True,\n+      Attribute_Preelaborable_Initialization => True,\n       others                                 => False);\n \n    --  The following array contains all attributes that imply a modification\n@@ -5408,6 +5409,45 @@ package body Sem_Attr is\n             end if;\n          end if;\n \n+      ----------------------------------\n+      -- Preelaborable_Initialization --\n+      ----------------------------------\n+\n+      when Attribute_Preelaborable_Initialization =>\n+         Check_E0;\n+         Check_Type;\n+\n+         --  If we're in an instance, we know that the legality of the\n+         --  attribute prefix type was already checked in the generic.\n+\n+         if not In_Instance then\n+\n+            --  If the prefix type is a generic formal type, then it must be\n+            --  either a formal private type or a formal derived type.\n+\n+            if Is_Generic_Type (P_Type) then\n+               if not Is_Private_Type (P_Type)\n+                 and then not Is_Derived_Type (P_Type)\n+               then\n+                  Error_Attr_P (\"formal type prefix of % attribute must be \"\n+                                 & \"formal private or formal derived type\");\n+               end if;\n+\n+            --  Otherwise, the prefix type must be a nonformal composite\n+            --  type declared within the visible part of a package or\n+            --  generic package.\n+\n+            elsif not Is_Composite_Type (P_Type)\n+              or else not Original_View_In_Visible_Part (P_Type)\n+            then\n+               Error_Attr_P\n+                 (\"prefix of % attribute must be composite type declared \"\n+                    & \"in visible part of a package or generic package\");\n+            end if;\n+         end if;\n+\n+         Set_Etype (N, Standard_Boolean);\n+\n       --------------\n       -- Priority --\n       --------------\n@@ -8182,15 +8222,16 @@ package body Sem_Attr is\n       --  is to say if we are within an instantiation. Same processing applies\n       --  to selected GNAT attributes.\n \n-      elsif (Id = Attribute_Atomic_Always_Lock_Free or else\n-             Id = Attribute_Definite                or else\n-             Id = Attribute_Descriptor_Size         or else\n-             Id = Attribute_Has_Access_Values       or else\n-             Id = Attribute_Has_Discriminants       or else\n-             Id = Attribute_Has_Tagged_Values       or else\n-             Id = Attribute_Lock_Free               or else\n-             Id = Attribute_Type_Class              or else\n-             Id = Attribute_Unconstrained_Array     or else\n+      elsif (Id = Attribute_Atomic_Always_Lock_Free      or else\n+             Id = Attribute_Definite                     or else\n+             Id = Attribute_Descriptor_Size              or else\n+             Id = Attribute_Has_Access_Values            or else\n+             Id = Attribute_Has_Discriminants            or else\n+             Id = Attribute_Has_Tagged_Values            or else\n+             Id = Attribute_Lock_Free                    or else\n+             Id = Attribute_Preelaborable_Initialization or else\n+             Id = Attribute_Type_Class                   or else\n+             Id = Attribute_Unconstrained_Array          or else\n              Id = Attribute_Max_Alignment_For_Allocation)\n         and then not Is_Generic_Type (P_Entity)\n       then\n@@ -8315,15 +8356,20 @@ package body Sem_Attr is\n       --  unconstrained arrays. Furthermore, it is essential to fold this\n       --  in the packed case, since otherwise the value will be incorrect.\n \n-      elsif Id = Attribute_Atomic_Always_Lock_Free or else\n-            Id = Attribute_Definite                or else\n-            Id = Attribute_Descriptor_Size         or else\n-            Id = Attribute_Has_Access_Values       or else\n-            Id = Attribute_Has_Discriminants       or else\n-            Id = Attribute_Has_Tagged_Values       or else\n-            Id = Attribute_Lock_Free               or else\n-            Id = Attribute_Type_Class              or else\n-            Id = Attribute_Unconstrained_Array     or else\n+      --  Folding can also be done for Preelaborable_Initialization based on\n+      --  whether the prefix type has preelaborable initialization, even though\n+      --  the attribute is nonstatic.\n+\n+      elsif Id = Attribute_Atomic_Always_Lock_Free      or else\n+            Id = Attribute_Definite                     or else\n+            Id = Attribute_Descriptor_Size              or else\n+            Id = Attribute_Has_Access_Values            or else\n+            Id = Attribute_Has_Discriminants            or else\n+            Id = Attribute_Has_Tagged_Values            or else\n+            Id = Attribute_Lock_Free                    or else\n+            Id = Attribute_Preelaborable_Initialization or else\n+            Id = Attribute_Type_Class                   or else\n+            Id = Attribute_Unconstrained_Array          or else\n             Id = Attribute_Component_Size\n       then\n          Static := False;\n@@ -9609,6 +9655,17 @@ package body Sem_Attr is\n             Fold_Uint (N, Expr_Value (E1) - 1, Static);\n          end if;\n \n+      ----------------------------------\n+      -- Preelaborable_Initialization --\n+      ----------------------------------\n+\n+      when Attribute_Preelaborable_Initialization =>\n+         Fold_Uint\n+           (N,\n+            UI_From_Int\n+              (Boolean'Pos (Has_Preelaborable_Initialization (P_Type))),\n+            Static);\n+\n       -----------\n       -- Range --\n       -----------"}, {"sha": "db6a4a47c414f8d63a770b0a7a7c516ef124437d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -1455,9 +1455,17 @@ package body Sem_Ch13 is\n                      --  Aspect Full_Access_Only must be analyzed last so that\n                      --  aspects Volatile and Atomic, if any, are analyzed.\n \n+                     --  Skip creation of pragma Preelaborable_Initialization\n+                     --  in the case where the aspect has an expression,\n+                     --  because the pragma is only needed for setting flag\n+                     --  Known_To_Have_Preelab_Init, which is set by other\n+                     --  means following resolution of the aspect expression.\n+\n                      if A_Id not in Aspect_Export\n                                   | Aspect_Full_Access_Only\n                                   | Aspect_Import\n+                       and then (A_Id /= Aspect_Preelaborable_Initialization\n+                                  or else not Present (Expression (ASN)))\n                      then\n                         Make_Pragma_From_Boolean_Aspect (ASN);\n                      end if;\n@@ -2915,6 +2923,7 @@ package body Sem_Ch13 is\n                             | Aspect_Async_Writers\n                             | Aspect_Effective_Reads\n                             | Aspect_Effective_Writes\n+                            | Aspect_Preelaborable_Initialization\n             then\n                Error_Msg_Name_1 := Nam;\n \n@@ -2951,6 +2960,7 @@ package body Sem_Ch13 is\n                                   | Aspect_Async_Writers\n                                   | Aspect_Effective_Reads\n                                   | Aspect_Effective_Writes\n+                                  | Aspect_Preelaborable_Initialization\n                   then\n                      Error_Msg_N\n                        (\"aspect % not allowed for formal type declaration\",\n@@ -13700,6 +13710,7 @@ package body Sem_Ch13 is\n                                       | Attribute_Iterable\n                                       | Attribute_Iterator_Element\n                                       | Attribute_Output\n+                                      | Attribute_Put_Image\n                                       | Attribute_Read\n                                       | Attribute_Variable_Indexing\n                                       | Attribute_Write;"}, {"sha": "c0983f5c25894d144668d69db3d984f502926e54", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -2648,6 +2648,48 @@ package body Sem_Ch3 is\n          E := First_Entity (Current_Scope);\n          while Present (E) loop\n             Resolve_Aspect_Expressions (E);\n+\n+            --  Now that the aspect expressions have been resolved, if this is\n+            --  at the end of the visible declarations, we can set the flag\n+            --  Known_To_Have_Preelab_Init properly on types declared in the\n+            --  visible part, which is needed for checking whether full types\n+            --  in the private part satisfy the Preelaborable_Initialization\n+            --  aspect of the partial view. We can't wait for the creation of\n+            --  the pragma by Analyze_Aspects_At_Freeze_Point, because the\n+            --  freeze point may occur after the end of the package declaration\n+            --  (in the case of nested packages).\n+\n+            if Is_Type (E)\n+              and then L = Visible_Declarations (Parent (L))\n+              and then Has_Aspect (E, Aspect_Preelaborable_Initialization)\n+            then\n+               declare\n+                  ASN  : constant Node_Id :=\n+                    Find_Aspect (E, Aspect_Preelaborable_Initialization);\n+                  Expr : constant Node_Id := Expression (ASN);\n+               begin\n+                  --  Set Known_To_Have_Preelab_Init to True if aspect has no\n+                  --  expression, or if the expression is True (or was folded\n+                  --  to True), or if the expression is a conjunction of one or\n+                  --  more Preelaborable_Initialization attributes applied to\n+                  --  formal types and wasn't folded to False. (Note that\n+                  --  Is_Conjunction_Of_Formal_Preelab_Init_Attributes goes to\n+                  --  Original_Node if needed, hence test for Standard_False.)\n+\n+                  if not Present (Expr)\n+                    or else (Is_Entity_Name (Expr)\n+                              and then Entity (Expr) = Standard_True)\n+                    or else\n+                      (Is_Conjunction_Of_Formal_Preelab_Init_Attributes (Expr)\n+                        and then\n+                          not (Is_Entity_Name (Expr)\n+                                and then Entity (Expr) = Standard_False))\n+                  then\n+                     Set_Known_To_Have_Preelab_Init (E);\n+                  end if;\n+               end;\n+            end if;\n+\n             Next_Entity (E);\n          end loop;\n       end Resolve_Aspects;"}, {"sha": "30eade2cb3b8eb20f4332e743df78df8c0502500", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -1768,11 +1768,16 @@ package body Sem_Ch7 is\n          end if;\n \n          --  Check preelaborable initialization for full type completing a\n-         --  private type for which pragma Preelaborable_Initialization given.\n+         --  private type when aspect Preelaborable_Initialization is True.\n+         --  We pass True for the parameter Formal_Types_Have_Preelab_Init\n+         --  to take into account the rule that presumes that subcomponents\n+         --  of generic formal types mentioned in the type's P_I aspect have\n+         --  preelaborable initialization (see RM 10.2.1(11.8/5)).\n \n          if Is_Type (E)\n            and then Must_Have_Preelab_Init (E)\n-           and then not Has_Preelaborable_Initialization (E)\n+           and then not Has_Preelaborable_Initialization\n+                          (E, Formal_Types_Have_Preelab_Init => True)\n          then\n             Error_Msg_N\n               (\"full view of & does not have preelaborable initialization\", E);"}, {"sha": "78cf674aee34eeb6e13a7864b5b0af4dd682cb5f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 97, "deletions": 4, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -13399,7 +13399,10 @@ package body Sem_Util is\n    -- Has_Preelaborable_Initialization --\n    --------------------------------------\n \n-   function Has_Preelaborable_Initialization (E : Entity_Id) return Boolean is\n+   function Has_Preelaborable_Initialization\n+     (E                              : Entity_Id;\n+      Formal_Types_Have_Preelab_Init : Boolean := False) return Boolean\n+   is\n       Has_PE : Boolean;\n \n       procedure Check_Components (E : Entity_Id);\n@@ -13453,7 +13456,9 @@ package body Sem_Util is\n             --  component type has PI.\n \n             if No (Exp) then\n-               if not Has_Preelaborable_Initialization (Etype (Ent)) then\n+               if not Has_Preelaborable_Initialization\n+                        (Etype (Ent), Formal_Types_Have_Preelab_Init)\n+               then\n                   Has_PE := False;\n                   exit;\n                end if;\n@@ -13499,7 +13504,8 @@ package body Sem_Util is\n       --  Array types have PI if the component type has PI\n \n       elsif Is_Array_Type (E) then\n-         Has_PE := Has_Preelaborable_Initialization (Component_Type (E));\n+         Has_PE := Has_Preelaborable_Initialization\n+                     (Component_Type (E), Formal_Types_Have_Preelab_Init);\n \n       --  A derived type has preelaborable initialization if its parent type\n       --  has preelaborable initialization and (in the case of a derived record\n@@ -13510,6 +13516,14 @@ package body Sem_Util is\n \n       elsif Is_Derived_Type (E) then\n \n+         --  When the rule of RM 10.2.1(11.8/5) applies, we presume a component\n+         --  of a generic formal derived type has preelaborable initialization.\n+         --  (See comment on spec of Has_Preelaborable_Initialization.)\n+\n+         if Is_Generic_Type (E) and then Formal_Types_Have_Preelab_Init then\n+            return True;\n+         end if;\n+\n          --  If the derived type is a private extension then it doesn't have\n          --  preelaborable initialization.\n \n@@ -13545,7 +13559,16 @@ package body Sem_Util is\n       --  have preelaborable initialization.\n \n       elsif Is_Private_Type (E) then\n-         return False;\n+\n+         --  When the rule of RM 10.2.1(11.8/5) applies, we presume a component\n+         --  of a generic formal private type has preelaborable initialization.\n+         --  (See comment on spec of Has_Preelaborable_Initialization.)\n+\n+         if Is_Generic_Type (E) and then Formal_Types_Have_Preelab_Init then\n+            return True;\n+         else\n+            return False;\n+         end if;\n \n       --  Record type has PI if it is non private and all components have PI\n \n@@ -16277,6 +16300,49 @@ package body Sem_Util is\n         or else Is_Task_Interface (T);\n    end Is_Concurrent_Interface;\n \n+   ------------------------------------------------------\n+   -- Is_Conjunction_Of_Formal_Preelab_Init_Attributes --\n+   ------------------------------------------------------\n+\n+   function Is_Conjunction_Of_Formal_Preelab_Init_Attributes\n+     (Expr : Node_Id) return Boolean\n+   is\n+\n+      function Is_Formal_Preelab_Init_Attribute\n+        (N : Node_Id) return Boolean;\n+      --  Returns True if N is a Preelaborable_Initialization attribute\n+      --  applied to a generic formal type, or N's Original_Node is such\n+      --  an attribute.\n+\n+      --------------------------------------\n+      -- Is_Formal_Preelab_Init_Attribute --\n+      --------------------------------------\n+\n+      function Is_Formal_Preelab_Init_Attribute\n+        (N : Node_Id) return Boolean\n+      is\n+         Orig_N : constant Node_Id := Original_Node (N);\n+\n+      begin\n+         return Nkind (Orig_N) = N_Attribute_Reference\n+           and then Attribute_Name (Orig_N) = Name_Preelaborable_Initialization\n+           and then Is_Entity_Name (Prefix (Orig_N))\n+           and then Is_Generic_Type (Entity (Prefix (Orig_N)));\n+      end Is_Formal_Preelab_Init_Attribute;\n+\n+   --  Start of Is_Conjunction_Of_Formal_Preelab_Init_Attributes\n+\n+   begin\n+      return Is_Formal_Preelab_Init_Attribute (Expr)\n+        or else (Nkind (Expr) = N_Op_And\n+                  and then\n+                    Is_Conjunction_Of_Formal_Preelab_Init_Attributes\n+                      (Left_Opnd (Expr))\n+                  and then\n+                    Is_Conjunction_Of_Formal_Preelab_Init_Attributes\n+                      (Right_Opnd (Expr)));\n+   end Is_Conjunction_Of_Formal_Preelab_Init_Attributes;\n+\n    -----------------------\n    -- Is_Constant_Bound --\n    -----------------------\n@@ -25996,6 +26062,33 @@ package body Sem_Util is\n       end if;\n    end Original_Corresponding_Operation;\n \n+   -----------------------------------\n+   -- Original_View_In_Visible_Part --\n+   -----------------------------------\n+\n+   function Original_View_In_Visible_Part\n+     (Typ : Entity_Id) return Boolean\n+   is\n+      Scop : constant Entity_Id := Scope (Typ);\n+\n+   begin\n+      --  The scope must be a package\n+\n+      if not Is_Package_Or_Generic_Package (Scop) then\n+         return False;\n+      end if;\n+\n+      --  A type with a private declaration has a private view declared in\n+      --  the visible part.\n+\n+      if Has_Private_Declaration (Typ) then\n+         return True;\n+      end if;\n+\n+      return List_Containing (Parent (Typ)) =\n+        Visible_Declarations (Package_Specification (Scop));\n+   end Original_View_In_Visible_Part;\n+\n    -------------------\n    -- Output_Entity --\n    -------------------"}, {"sha": "2c5b2866bc0ffbb2abd5f807fb4fc3b8249e01cf", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -1530,9 +1530,18 @@ package Sem_Util is\n    --  non-null), which causes the type to not have preelaborable\n    --  initialization.\n \n-   function Has_Preelaborable_Initialization (E : Entity_Id) return Boolean;\n+   function Has_Preelaborable_Initialization\n+     (E                              : Entity_Id;\n+      Formal_Types_Have_Preelab_Init : Boolean := False) return Boolean;\n    --  Return True iff type E has preelaborable initialization as defined in\n    --  Ada 2005 (see AI-161 for details of the definition of this attribute).\n+   --  If Formal_Types_Have_Preelab_Init is True, indicates that the function\n+   --  should presume that for any subcomponents of formal private or derived\n+   --  types, the types have preelaborable initialization (RM 10.2.1(11.8/5)).\n+   --  NOTE: The treatment of subcomponents of formal types should only apply\n+   --  for types actually specified in the P_I aspect of the outer type, but\n+   --  for now we take a more liberal interpretation. This needs addressing,\n+   --  perhaps by passing the outermost type instead of the simple flag. ???\n \n    function Has_Prefix (N : Node_Id) return Boolean;\n    --  Return True if N has attribute Prefix\n@@ -1828,6 +1837,13 @@ package Sem_Util is\n    --  Returns true if the two specifications of the given\n    --  nonoverridable aspect are compatible.\n \n+   function Is_Conjunction_Of_Formal_Preelab_Init_Attributes\n+     (Expr : Node_Id) return Boolean;\n+   --  Returns True if Expr is a Preelaborable_Initialization attribute applied\n+   --  to a formal type, or a sequence of two or more such attributes connected\n+   --  by \"and\" operators, or if the Original_Node of Expr or its constituents\n+   --  is such an attribute.\n+\n    function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n    --  Exp is the expression for an array bound. Determines whether the\n    --  bound is a compile-time known value, or a constant entity, or an\n@@ -2845,6 +2861,10 @@ package Sem_Util is\n    --  corresponding operation of S is the original corresponding operation of\n    --  S2. Otherwise, it is S itself.\n \n+   function Original_View_In_Visible_Part (Typ : Entity_Id) return Boolean;\n+   --  Returns True if the type Typ has a private view or if the public view\n+   --  appears in the visible part of a package spec.\n+\n    procedure Output_Entity (Id : Entity_Id);\n    --  Print entity Id to standard output. The name of the entity appears in\n    --  fully qualified form."}, {"sha": "8701ea928bdc8dbf05dd361551e5baca698b2a9e", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -258,6 +258,8 @@ package body Snames is\n             return Pragma_Interrupt_Priority;\n          when Name_Lock_Free                        =>\n             return Pragma_Lock_Free;\n+         when Name_Preelaborable_Initialization     =>\n+            return Pragma_Preelaborable_Initialization;\n          when Name_Priority                         =>\n             return Pragma_Priority;\n          when Name_Secondary_Stack_Size             =>\n@@ -488,6 +490,7 @@ package body Snames is\n         or else N = Name_Interface\n         or else N = Name_Interrupt_Priority\n         or else N = Name_Lock_Free\n+        or else N = Name_Preelaborable_Initialization\n         or else N = Name_Priority\n         or else N = Name_Secondary_Stack_Size\n         or else N = Name_Storage_Size"}, {"sha": "34f1cef946d2bc32c8feb20f7adc8dd7b322ee31", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3450ded1eddb35b7f9030c5545d1e542cef5f8b2/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=3450ded1eddb35b7f9030c5545d1e542cef5f8b2", "patch": "@@ -37,6 +37,17 @@ package Snames is\n    --  some exceptions). See the body of Get_Attribute_Id for details. The\n    --  same is true of other enumeration types declared in this package.\n \n+   --  ALSO NOTE: In the case of a name that corresponds to both an attribute\n+   --  and a pragma, the Name_Id must be defined in the attribute section\n+   --  (between First_Attribute_Name and Last_Attribute_Name). Also, please\n+   --  add a comment in the list of Name_Ids at the point where the name would\n+   --  normally appear alphabetically (for an example, see comment starting\n+   --  \"Note: CPU ...\"). The Pragma_Id with that name must be defined in the\n+   --  last section of literals for type Pragma_Id (see set of Pragma_Ids that\n+   --  require special processing due to matching an attribute name). Finally,\n+   --  the bodies of functions Get_Pragma_Id and Is_Pragma_Name must be updated\n+   --  to test for each such pragma that shares a name with an attribute.\n+\n    ------------------\n    -- Preset Names --\n    ------------------\n@@ -624,7 +635,13 @@ package Snames is\n    Name_Precondition                   : constant Name_Id := N + $; -- GNAT\n    Name_Predicate                      : constant Name_Id := N + $; -- GNAT\n    Name_Predicate_Failure              : constant Name_Id := N + $; -- Ada 12\n-   Name_Preelaborable_Initialization   : constant Name_Id := N + $; -- Ada 05\n+\n+   --  Note: Preelaborable_Initialization is not in this list because its name\n+   --  matches the name of the corresponding attribute. However, it is included\n+   --  in the definition of the type Pragma_Id, and the functions Get_Pragma_Id\n+   --  and Is_Pragma_Name correctly recognize and process that pragma name.\n+   --  Preelaborable_Initialization is a standard Ada 2005 pragma.\n+\n    Name_Preelaborate                   : constant Name_Id := N + $;\n    Name_Pre_Class                      : constant Name_Id := N + $; -- GNAT\n \n@@ -1007,6 +1024,7 @@ package Snames is\n    Name_Pool_Address                   : constant Name_Id := N + $; -- GNAT\n    Name_Pos                            : constant Name_Id := N + $;\n    Name_Position                       : constant Name_Id := N + $;\n+   Name_Preelaborable_Initialization   : constant Name_Id := N + $; -- Ada 22\n    Name_Priority                       : constant Name_Id := N + $; -- Ada 05\n    Name_Range                          : constant Name_Id := N + $;\n    Name_Range_Length                   : constant Name_Id := N + $; -- GNAT\n@@ -1536,6 +1554,7 @@ package Snames is\n       Attribute_Pool_Address,\n       Attribute_Pos,\n       Attribute_Position,\n+      Attribute_Preelaborable_Initialization,\n       Attribute_Priority,\n       Attribute_Range,\n       Attribute_Range_Length,\n@@ -1921,7 +1940,6 @@ package Snames is\n       Pragma_Precondition,\n       Pragma_Predicate,\n       Pragma_Predicate_Failure,\n-      Pragma_Preelaborable_Initialization,\n       Pragma_Preelaborate,\n       Pragma_Pre_Class,\n       Pragma_Provide_Shift_Operators,\n@@ -1974,7 +1992,9 @@ package Snames is\n \n       --  The following pragmas are on their own, out of order, because of the\n       --  special processing required to deal with the fact that their names\n-      --  match existing attribute names.\n+      --  match existing attribute names. Note that when a pragma is added in\n+      --  this section, functions Get_Pragma_Id and Is_Pragma_Name must be\n+      --  updated to account for the new pragma.\n \n       Pragma_CPU,\n       Pragma_Default_Scalar_Storage_Order,\n@@ -1983,6 +2003,7 @@ package Snames is\n       Pragma_Interface,\n       Pragma_Interrupt_Priority,\n       Pragma_Lock_Free,\n+      Pragma_Preelaborable_Initialization,\n       Pragma_Priority,\n       Pragma_Secondary_Stack_Size,\n       Pragma_Storage_Size,"}]}