{"sha": "f09db6e0cab711b2a0f3401174169452c2c92157", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA5ZGI2ZTBjYWI3MTFiMmEwZjM0MDExNzQxNjk0NTJjMmM5MjE1Nw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-09-02T09:59:57Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-09-02T09:59:57Z"}, "message": "Change HANDLE_PRAGMA macro so that it will work with USE_CPPLIB.\n\nAdd INSERT_ATTRIBUTES macro.\n\nFrom-SVN: r22165", "tree": {"sha": "918fb38ee8db4c60c48c8398ff8413404b9a7bcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/918fb38ee8db4c60c48c8398ff8413404b9a7bcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f09db6e0cab711b2a0f3401174169452c2c92157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f09db6e0cab711b2a0f3401174169452c2c92157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f09db6e0cab711b2a0f3401174169452c2c92157", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f09db6e0cab711b2a0f3401174169452c2c92157/comments", "author": null, "committer": null, "parents": [{"sha": "56420c2cf3ff7643dd699174648ca409420b79d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56420c2cf3ff7643dd699174648ca409420b79d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56420c2cf3ff7643dd699174648ca409420b79d2"}], "stats": {"total": 219, "additions": 164, "deletions": 55}, "files": [{"sha": "7af0d14973323f67abf8c11b2de17c4c26e42451", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -1,3 +1,35 @@\n+Wed Sep 2 09:25:29 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* c-lex.c (check_newline):  Call HANDLE_PRAGMA before\n+\tHANDLE_SYSV_PRAGMA if both are defined.  Generate warning messages\n+\tif unknown pragmas are encountered.\n+\t(handle_sysv_pragma): Interpret return code from\n+\thandle_pragma_token ().  Return success/failure indication rather\n+\tthan next unprocessed character. \n+\t(pragma_getc): New function: retrieves characters from the\n+\tinput stream.  Defined when HANDLE_PRAGMA is enabled.\n+\t(pragma_ungetc): New function: replaces characters back into the\n+\tinput stream.  Defined when HANDLE_PRAGMA is enabled.\n+\t\n+\t* c-pragma.c (handle_pragma_token): Return success/failure status\n+\tof the parse.\n+\t\n+\t* c-pragma.h: Change prototype of handle_pragma_token().\n+\n+\t* varasm.c: (handle_pragma_weak): Only create this function if\n+\tHANDLE_PRAGMA_WEAK is defined.\n+\n+\t* c-common,c (decl_attributes): If defined call the expression\n+\tcontained within the INSERT_ATTRIBUTES macro before adding\n+\tattributes to a decl.\n+\n+\t* tm.texi (HANDLE_PRAGMA): Document the new verion of\n+\tHANDLE_PRAGMA, which takes three arguments.\n+\t(INSERT_ATTRIBUTES): Document this new macro.  \n+\n+\t* LANGUAGES: Document the new version of HANDLE_PRAGMA and the\n+\tnew INSERT_ATTRIBUTES macro.\n+\n Wed Sep  2 02:03:23 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* config/sparc/sparc.md (movdf): Only generate special RTL for"}, {"sha": "c3d4223477eeff00ca73dccdefa924e5db0cbe01", "filename": "gcc/LANGUAGES", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2FLANGUAGES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2FLANGUAGES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FLANGUAGES?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -6,6 +6,18 @@ time as we can formally start documenting the interface this file will\n serve as a repository for information on these interface and any incompatable\n changes we've made.\n \n+Aug 31, 1998:\n+  The interface to HANDLE_PRAGMA has changed.  It now takes three arguments.\n+  The first two are pointers to functions that should be used to read characters\n+  from the input stream, and to push them back into the input stream respectively.\n+  The third argument is a pointer to a null terminate string which is the first\n+  word after #pragma.  The expression supplied by HANDLE_PRAGMA should return\n+  non-zero if it parsed and implemented the pragma.  Otherwise it should return\n+  zero, and leave the input stream as it was before the expression was evaluated.\n+\n+  A new back-end definable macro has been added: INSERT_ATTRIBUTES.  This macro\n+  allows backend to add attributes to decls as they are created.\n+\n Jun 10, 1998:\n   The interface to lang_decode_option has changed. It now uses and argc/argv\n   interface to allow for options that use more than one input string. The new"}, {"sha": "a5f738bdf5c0a96274f9888a616ff364837c98ee", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -420,6 +420,10 @@ decl_attributes (node, attributes, prefix_attributes)\n   else if (TREE_CODE_CLASS (TREE_CODE (node)) == 't')\n     type = node, is_type = 1;\n \n+#ifdef INSERT_ATTRIBUTES\n+  INSERT_ATTRIBUTES (node, & attributes, & prefix_attributes);\n+#endif\n+  \n   attributes = chainon (prefix_attributes, attributes);\n \n   for (a = attributes; a; a = TREE_CHAIN (a))\n@@ -644,7 +648,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t      = (args ? TREE_VALUE (args)\n \t\t : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n \t    int align;\n-\n+\t    \n \t    /* Strip any NOPs of any kind.  */\n \t    while (TREE_CODE (align_expr) == NOP_EXPR\n \t\t   || TREE_CODE (align_expr) == CONVERT_EXPR"}, {"sha": "2f225282e7e52550c14c64ef23fd11d1658458b1", "filename": "gcc/c-lex.c", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -479,6 +479,22 @@ extend_token_buffer (p)\n   return token_buffer + offset;\n }\n \f\n+#if defined HANDLE_PRAGMA \n+/* Local versions of these macros, that can be passed as function pointers.  */\n+static int\n+pragma_getc ()\n+{\n+  return GETC();\n+}\n+\n+static void\n+pragma_ungetc (arg)\n+     int arg;\n+{\n+  UNGETC (arg);\n+}\n+#endif\n+\n /* At the beginning of a line, increment the line number\n    and process any #-directive on this line.\n    If the line is a #-directive, read the entire line and return a newline.\n@@ -530,34 +546,43 @@ check_newline ()\n \t\tc = GETC ();\n \t      if (c == '\\n')\n \t\treturn c;\n-#ifdef HANDLE_SYSV_PRAGMA\n+\n+#if defined HANDLE_PRAGMA || defined HANDLE_SYSV_PRAGMA\t      \n \t      UNGETC (c);\n \t      token = yylex ();\n \t      if (token != IDENTIFIER)\n \t\tgoto skipline;\n-\t      return handle_sysv_pragma (token);\n-#else /* !HANDLE_SYSV_PRAGMA */\n+\t      \n #ifdef HANDLE_PRAGMA\n+\t      /* We invoke HANDLE_PRAGMA before HANDLE_SYSV_PRAGMA\n+\t\t (if both are defined), in order to give the back\n+\t\t end a chance to override the interpretation of\n+\t\t SYSV style pragmas.  */\n #if !USE_CPPLIB\n-\t      UNGETC (c);\n-\t      token = yylex ();\n-\t      if (token != IDENTIFIER)\n-\t\tgoto skipline;\n \t      if (nextchar >= 0)\n-\t\tc = nextchar, nextchar = -1;\n-\t      else\n-\t\tc = GETC ();\n-\t      ungetc (c, finput);\n-\t      if (HANDLE_PRAGMA (finput, yylval.ttype))\n \t\t{\n-\t\t  c = GETC ();\n-\t\t  return c;\n+\t\t  c = nextchar, nextchar = -1;\n+\t\t  UNGETC (c);\n \t\t}\n-#else\n-\t      ??? do not know what to do ???;\n-#endif /* !USE_CPPLIB */\n+#endif\n+\t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n+\t\t\t\t IDENTIFIER_POINTER (yylval.ttype)))\n+\t\treturn GETC ();\n #endif /* HANDLE_PRAGMA */\n+\t      \n+#ifdef HANDLE_SYSV_PRAGMA\n+\t      if (handle_sysv_pragma (token))\n+\t\treturn GETC ();\n #endif /* !HANDLE_SYSV_PRAGMA */\n+#endif /* HANDLE_PRAGMA || HANDLE_SYSV_PRAGMA */\n+\t      \n+\t      /* Issue a warning message if we have been asked to do so.\n+\t\t Ignoring unknown pragmas in system header file unless\n+\t\t an explcit -Wunknown-pragmas has been given. */\n+\t      if (warn_unknown_pragmas > 1\n+\t\t  || (warn_unknown_pragmas && ! in_system_header))\n+\t\twarning (\"ignoring pragma: %s\", token_buffer);\n+\t      \n \t      goto skipline;\n \t    }\n \t}\n@@ -842,7 +867,7 @@ handle_sysv_pragma (token)\n \t  handle_pragma_token (token_buffer, yylval.ttype);\n \t  break;\n \tdefault:\n-\t  handle_pragma_token (token_buffer, 0);\n+\t  handle_pragma_token (token_buffer, NULL);\n \t}\n #if !USE_CPPLIB\n       if (nextchar >= 0)\n@@ -853,12 +878,11 @@ handle_sysv_pragma (token)\n \n       while (c == ' ' || c == '\\t')\n \tc = GETC ();\n-      if (c == '\\n' || c == EOF)\n-\t{\n-\t  handle_pragma_token (0, 0);\n-\t  return c;\n-\t}\n       UNGETC (c);\n+      \n+      if (c == '\\n' || c == EOF)\n+\treturn handle_pragma_token (NULL, NULL);\n+\n       token = yylex ();\n     }\n }"}, {"sha": "cb215700c6c2263c93602d06b01880a91dde95a5", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -1,5 +1,5 @@\n /* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.\n-   Copyright (C) 1992, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -37,13 +37,12 @@ Boston, MA 02111-1307, USA.  */\n \n extern int maximum_field_alignment;\n \n-/* File used for outputting assembler code.  */\n-extern FILE *asm_out_file;\n-\n /* Handle one token of a pragma directive.  TOKEN is the\n-   current token, and STRING is its printable form.  */\n+   current token, and STRING is its printable form. \n+   Return zero if an entire pragma was parsed, but it was\n+   flawed in some way.  Return non-zero in all other cases.  */\n \n-void\n+int\n handle_pragma_token (string, token)\n      char *string;\n      tree token;\n@@ -53,26 +52,33 @@ handle_pragma_token (string, token)\n   static char *value;\n   static int align;\n \n-  if (string == 0)\n+  if (string == NULL)\n     {\n+      int ret_val = 1;\n+      \n       if (type == ps_pack)\n \t{\n \t  if (state == ps_right)\n \t    maximum_field_alignment = align * 8;\n \t  else\n-\t    warning (\"malformed `#pragma pack'\");\n+\t    {\n+\t      warning (\"malformed `#pragma pack'\");\n+\t      ret_val = 0;\n+\t    }\n \t}\n+      else if (type == ps_bad)\n+\tret_val = 0;\n       else if (type == ps_weak)\n \t{\n #ifdef HANDLE_PRAGMA_WEAK\n \t  if (HANDLE_PRAGMA_WEAK)\n \t    handle_pragma_weak (state, name, value);\n-\n #endif /* HANDLE_PRAGMA_WEAK */\n \t}\n \n       type = state = ps_start;\n-      return;\n+      \n+      return ret_val;\n     }\n \n   switch (state)\n@@ -82,24 +88,18 @@ handle_pragma_token (string, token)\n \t{\n \t  if (strcmp (IDENTIFIER_POINTER (token), \"pack\") == 0)\n \t    type = state = ps_pack;\n+#ifdef HANDLE_PRAGMA_WEAK\n \t  else if (strcmp (IDENTIFIER_POINTER (token), \"weak\") == 0)\n \t    type = state = ps_weak;\n+#endif\t  \n \t  else\n-\t    {\n-\t      type = state = ps_done;\n-\n-\t      /* Issue a warning message if we have been asked to do so.\n-\t\t Ignoring unknown pragmas in system header file unless          \n-\t\t an explcit -Wunknown-pragmas has been given. */                \n-\t      if (warn_unknown_pragmas > 1\n-\t\t  || (warn_unknown_pragmas && ! in_system_header))\n-\t\twarning (\"ignoring pragma: %s\", string);\n-\t    }\n+\t    type = state = ps_done;\n \t}\n       else\n \ttype = state = ps_done;\n       break;\n-\n+      \n+#ifdef HANDLE_PRAGMA_WEAK\n     case ps_weak:\n       if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n \t{\n@@ -109,7 +109,8 @@ handle_pragma_token (string, token)\n       else\n \tstate = ps_bad;\n       break;\n-\n+#endif\n+      \n     case ps_name:\n       state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n       break;\n@@ -177,5 +178,7 @@ handle_pragma_token (string, token)\n     default:\n       abort ();\n     }\n+\n+  return 1;\n }\n #endif /* HANDLE_SYSV_PRAGMA */"}, {"sha": "5478977608e1a0fe2a97761d91285009e478d9b3", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -1,5 +1,5 @@\n /* Pragma related interfaces.\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifdef HANDLE_SYSV_PRAGMA\n+\n /* Support #pragma weak iff ASM_WEAKEN_LABEL and ASM_OUTPUT_DEF are\n    defined.  */\n #if defined (ASM_WEAKEN_LABEL) && defined (ASM_OUTPUT_DEF)\n@@ -43,4 +45,6 @@ enum pragma_state\n extern void handle_pragma_weak PROTO((enum pragma_state, char *, char *));\n \n /* Handle a C style pragma */\n-extern void handle_pragma_token PROTO((char *, tree));\n+extern int handle_pragma_token PROTO((char *, tree));\n+\n+#endif /* HANDLE_SYSV_PRAGMA */"}, {"sha": "bf6fdd155b1ef00403dc359b5a67a8efa8ef67e0", "filename": "gcc/tm.texi", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -7315,18 +7315,32 @@ C++, which is to pretend that the file's contents are enclosed in\n @findex HANDLE_PRAGMA\n @findex #pragma\n @findex pragma\n-@item HANDLE_PRAGMA (@var{stream}, @var{node})\n+@item HANDLE_PRAGMA (@var{getc}, @var{ungetc}, @var{node})\n Define this macro if you want to implement any pragmas.  If defined, it\n-is a C expression whose value is 1 if the pragma was handled by the function.\n-The argument @var{stream} is the stdio input stream from which the source text\n-can be read.  @var{node} is the tree node for the identifier after the\n-@code{#pragma}.\n+is a C expression whose value is 1 if the pragma was handled by the\n+function, zero otherwise.  The argument @var{getc} is a function of type\n+@samp{int (*)(void)} which will return the next character in the input\n+stream, or EOF if no characters are left.  The argument @var{ungetc} is\n+a function of type @samp{void (*)(int)} which will push a character back\n+into the input stream.  The argument @var{name} is the word following\n+#pragma in the input stream.  The input stream pointer will be pointing\n+just beyond the end of this word.  The input stream should be left\n+undistrubed if the expression returns zero, otherwise it should be\n+pointing at the last character after the end of the pragma (newline or\n+end-of-file). \n \n It is generally a bad idea to implement new uses of @code{#pragma}.  The\n only reason to define this macro is for compatibility with other\n compilers that do support @code{#pragma} for the sake of any user\n programs which already use it.\n \n+If the pragma can be implemented by atttributes then the macro\n+@samp{INSERT_ATTRIBUTES} might be a useful one to define as well.\n+\n+Note: older versions of this macro only had two arguments: @var{stream}\n+and @var{token}.  The macro was changed in order to allow it to work\n+when gcc is built both with and without a cpp library.\n+\n @findex VALID_MACHINE_DECL_ATTRIBUTE\n @item VALID_MACHINE_DECL_ATTRIBUTE (@var{decl}, @var{attributes}, @var{identifier}, @var{args})\n If defined, a C expression whose value is nonzero if @var{identifier} with\n@@ -7367,11 +7381,27 @@ of @var{olddecl}.  Examples of when this is needed are when one attribute\n overrides another, or when an attribute is nullified by a subsequent\n definition.\n \n+@findex INSERT_ATTRIBUTES\n+@item INSERT_ATTRIBUTES (@var{node}, @var{attr_ptr}, @var{prefix_ptr})\n+Define this macro if you want to be able to add attributes to a decl\n+when it is being created.  This is normally useful for backends which\n+wish to implement a pragma by using the attributes which correspond to\n+the pragma's effect.  The @var{node} argument is the decl which is being\n+created.  The @var{attr_ptr} argument is a pointer to the attribute list\n+for this decl.  The @var{prefix_ptr} is a pointer to the list of\n+attributes that have appeared after the specifiers and modifiers of the\n+declaration, but before the declaration proper.\n+\n @findex SET_DEFAULT_DECL_ATTRIBUTES\n @item SET_DEFAULT_DECL_ATTRIBUTES (@var{decl}, @var{attributes})\n If defined, a C statement that assigns default attributes to\n newly defined @var{decl}.\n \n+@findex SET_DEFAULT_SECTION_NAME\n+@item SET_DEFAULT_SECTION_NAME (@var{decl})\n+If defined, a C statement that assigns a section name to the newly\n+created @var{decl}.\n+\n @findex DOLLARS_IN_IDENTIFIERS\n @item DOLLARS_IN_IDENTIFIERS\n Define this macro to control use of the character @samp{$} in identifier"}, {"sha": "495a860c47773b931b396ab577fb3ecf3ede6aa4", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f09db6e0cab711b2a0f3401174169452c2c92157/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f09db6e0cab711b2a0f3401174169452c2c92157", "patch": "@@ -4244,14 +4244,14 @@ output_constructor (exp, size)\n     assemble_zeros (size - total_bytes);\n }\n \n+#ifdef HANDLE_PRAGMA_WEAK\n /* Output asm to handle ``#pragma weak'' */\n \n void\n handle_pragma_weak (what, name, value)\n      enum pragma_state what;\n      char *name, *value;\n {\n-#ifdef HANDLE_PRAGMA_WEAK\n   if (what == ps_name || what == ps_value)\n     {\n       struct weak_syms *weak =\n@@ -4273,8 +4273,8 @@ handle_pragma_weak (what, name, value)\n     }\n   else if (! (what == ps_done || what == ps_start))\n     warning (\"malformed `#pragma weak'\");\n-#endif /* HANDLE_PRAGMA_WEAK */\n }\n+#endif /* HANDLE_PRAGMA_WEAK */\n \n /* Declare DECL to be a weak symbol.  */\n "}]}