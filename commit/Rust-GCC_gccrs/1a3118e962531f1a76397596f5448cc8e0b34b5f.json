{"sha": "1a3118e962531f1a76397596f5448cc8e0b34b5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEzMTE4ZTk2MjUzMWYxYTc2Mzk3NTk2ZjU0NDhjYzhlMGIzNGI1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-20T01:04:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-20T01:04:51Z"}, "message": "ipa-inline-transform.c (save_inline_function_body): Add comments.\n\n\t* ipa-inline-transform.c (save_inline_function_body): Add comments.\n\t* ipa-inline.c (inline_small_functions): Compute summaries first, populate\n\theap later.\n\nFrom-SVN: r172751", "tree": {"sha": "6d94167b35596d4f96592be435d8120a71ea2597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d94167b35596d4f96592be435d8120a71ea2597"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a3118e962531f1a76397596f5448cc8e0b34b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3118e962531f1a76397596f5448cc8e0b34b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a3118e962531f1a76397596f5448cc8e0b34b5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3118e962531f1a76397596f5448cc8e0b34b5f/comments", "author": null, "committer": null, "parents": [{"sha": "8d6a938b8923bff9a19ae3fc3544c254eb4fec53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d6a938b8923bff9a19ae3fc3544c254eb4fec53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d6a938b8923bff9a19ae3fc3544c254eb4fec53"}], "stats": {"total": 51, "additions": 36, "deletions": 15}, "files": [{"sha": "9ca4ae40b6839c8a7213e6112a1128dbbee68488", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3118e962531f1a76397596f5448cc8e0b34b5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3118e962531f1a76397596f5448cc8e0b34b5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a3118e962531f1a76397596f5448cc8e0b34b5f", "patch": "@@ -1,3 +1,9 @@\n+2011-04-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-transform.c (save_inline_function_body): Add comments.\n+\t* ipa-inline.c (inline_small_functions): Compute summaries first, populate\n+\theap later.\n+\n 2011-04-19  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (save_inline_function_body): Remove."}, {"sha": "25ad84a418cd4862c6a4654d656c2453313e627f", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3118e962531f1a76397596f5448cc8e0b34b5f/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3118e962531f1a76397596f5448cc8e0b34b5f/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=1a3118e962531f1a76397596f5448cc8e0b34b5f", "patch": "@@ -253,6 +253,9 @@ save_inline_function_body (struct cgraph_node *node)\n   /* Now node in question has no clones.  */\n   node->clones = NULL;\n \n+  /* Inline clones share decl with the function they are cloned\n+     from.  Walk the whole clone tree and redirect them all to the\n+     new decl.  */\n   if (first_clone->clones)\n     for (n = first_clone->clones; n != first_clone;)\n       {\n@@ -275,6 +278,8 @@ save_inline_function_body (struct cgraph_node *node)\n   tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL,\n \t\t\t    NULL, NULL);\n \n+  /* The function will be short lived and removed after we inline all the clones,\n+     but make it internal so we won't confuse ourself.  */\n   DECL_EXTERNAL (first_clone->decl) = 0;\n   DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n   TREE_PUBLIC (first_clone->decl) = 0;"}, {"sha": "48d38983459fa41ee1945cefbfa628f00c4590e6", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3118e962531f1a76397596f5448cc8e0b34b5f/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3118e962531f1a76397596f5448cc8e0b34b5f/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1a3118e962531f1a76397596f5448cc8e0b34b5f", "patch": "@@ -1127,22 +1127,18 @@ inline_small_functions (void)\n \t     \"\\nDeciding on inlining of small functions.  Starting with size %i.\\n\",\n \t     initial_size);\n \n-  /* Populate the heeap with all edges we might inline.\n-     While doing so compute overall unit size and other global\n-     parameters used by badness metrics.  */\n+  /* Compute overall unit size and other global parameters used by badness\n+     metrics.  */\n \n   max_count = 0;\n   max_benefit = 0;\n+\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed\n \t&& !node->global.inlined_to)\n       {\n \tstruct inline_summary *info = inline_summary (node);\n \n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Enqueueing calls of %s/%i.\\n\",\n-\t\t   cgraph_node_name (node), node->uid);\n-\n \tinfo->estimated_growth = INT_MIN;\n \n \tif (!DECL_EXTERNAL (node->decl))\n@@ -1156,20 +1152,34 @@ inline_small_functions (void)\n \t      max_count = edge->count;\n \t    if (max_benefit < benefit)\n \t      max_benefit = benefit;\n-\t    if (edge->inline_failed\n-\t\t&& can_inline_edge_p (edge, true)\n-\t\t&& want_inline_small_function_p (edge, true)\n-\t\t&& edge->inline_failed)\n-\t      {\n-\t\tgcc_assert (!edge->aux);\n-\t\tupdate_edge_key (heap, edge);\n-\t      }\n \t   }\n       }\n \n   overall_size = initial_size;\n   max_size = compute_max_insns (overall_size);\n   min_size = overall_size;\n+\n+  /* Populate the heeap with all edges we might inline.  */\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed\n+\t&& !node->global.inlined_to)\n+      {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"Enqueueing calls of %s/%i.\\n\",\n+\t\t   cgraph_node_name (node), node->uid);\n+\n+\tfor (edge = node->callers; edge; edge = edge->next_caller)\n+\t  if (edge->inline_failed\n+\t      && can_inline_edge_p (edge, true)\n+\t      && want_inline_small_function_p (edge, true)\n+\t      && edge->inline_failed)\n+\t    {\n+\t      gcc_assert (!edge->aux);\n+\t      update_edge_key (heap, edge);\n+\t    }\n+      }\n+\n   gcc_assert (in_lto_p\n \t      || !max_count\n \t      || (profile_info && flag_branch_probabilities));"}]}