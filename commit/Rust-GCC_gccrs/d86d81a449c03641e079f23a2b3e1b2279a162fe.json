{"sha": "d86d81a449c03641e079f23a2b3e1b2279a162fe", "node_id": "C_kwDOANBUbNoAKGQ4NmQ4MWE0NDljMDM2NDFlMDc5ZjIzYTJiM2UxYjIyNzlhMTYyZmU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-04T07:21:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-04T13:01:38Z"}, "message": "Backwards threader greedy search TLC\n\nI've tried to understand how the greedy search works seeing the\nbitmap dances and the split into resolve_phi.  I've summarized\nthe intent of the algorithm as\n\n      // For further greedy searching we want to remove interesting\n      // names defined in BB but add ones on the PHI edges for the\n      // respective edges.\n\nbut the implementation differs in detail.  In particular when\nthere is more than one interesting PHI in BB it seems to only consider\nthe first for translating defs across edges.  It also only applies\nthe loop crossing restriction when there is an interesting PHI.\n\nThe following preserves the loop crossing restriction to the case\nof interesting PHIs but merges resolve_phi back, changing interesting\nas outlined with the intent above.  It should get more threading\ncases when there are multiple interesting PHI defs in a block.\nIt might be a bit faster due to less bitmap operations but in the\nend the main intent was to make what happens more obvious.\n\n\t* tree-ssa-threadbackward.cc (populate_worklist): Remove.\n\t(back_threader::resolve_phi): Likewise.\n\t(back_threader::find_paths_to_names): Rewrite greedy search.", "tree": {"sha": "cf1b9f0dfdb39bd8a84669ab365b80073fea6c95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1b9f0dfdb39bd8a84669ab365b80073fea6c95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d86d81a449c03641e079f23a2b3e1b2279a162fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86d81a449c03641e079f23a2b3e1b2279a162fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d86d81a449c03641e079f23a2b3e1b2279a162fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86d81a449c03641e079f23a2b3e1b2279a162fe/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c7ee4d2d42f4728928556dbbe0700f9a13db90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c7ee4d2d42f4728928556dbbe0700f9a13db90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c7ee4d2d42f4728928556dbbe0700f9a13db90"}], "stats": {"total": 156, "additions": 57, "deletions": 99}, "files": [{"sha": "3acd66a7780a02a0bfc68739f56484beb5e62890", "filename": "gcc/tree-ssa-threadbackward.cc", "status": "modified", "additions": 57, "deletions": 99, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86d81a449c03641e079f23a2b3e1b2279a162fe/gcc%2Ftree-ssa-threadbackward.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86d81a449c03641e079f23a2b3e1b2279a162fe/gcc%2Ftree-ssa-threadbackward.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.cc?ref=d86d81a449c03641e079f23a2b3e1b2279a162fe", "patch": "@@ -91,7 +91,6 @@ class back_threader\n   edge maybe_register_path ();\n   void maybe_register_path_dump (edge taken_edge);\n   void find_paths_to_names (basic_block bb, bitmap imports);\n-  void resolve_phi (gphi *phi, bitmap imports);\n   edge find_taken_edge (const vec<basic_block> &path);\n   edge find_taken_edge_cond (const vec<basic_block> &path, gcond *);\n   edge find_taken_edge_switch (const vec<basic_block> &path, gswitch *);\n@@ -335,71 +334,6 @@ back_threader::find_taken_edge_cond (const vec<basic_block> &path,\n   return NULL;\n }\n \n-// Populate a vector of trees from a bitmap.\n-\n-static inline void\n-populate_worklist (vec<tree> &worklist, bitmap bits)\n-{\n-  bitmap_iterator bi;\n-  unsigned i;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (bits, 0, i, bi)\n-    {\n-      tree name = ssa_name (i);\n-      worklist.quick_push (name);\n-    }\n-}\n-\n-// Find jump threading paths that go through a PHI.\n-\n-void\n-back_threader::resolve_phi (gphi *phi, bitmap interesting)\n-{\n-  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_phi_result (phi)))\n-    return;\n-\n-  for (size_t i = 0; i < gimple_phi_num_args (phi); ++i)\n-    {\n-      edge e = gimple_phi_arg_edge (phi, i);\n-\n-      // This is like path_crosses_loops in profitable_path_p but more\n-      // restrictive to avoid peeling off loop iterations (see\n-      // tree-ssa/pr14341.c for an example).\n-      bool profitable_p = m_path[0]->loop_father == e->src->loop_father;\n-      if (!profitable_p)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"  FAIL: path through PHI in bb%d (incoming bb:%d) crosses loop\\n\",\n-\t\t       e->dest->index, e->src->index);\n-\t      fprintf (dump_file, \"path: %d->\", e->src->index);\n-\t      dump_path (dump_file, m_path);\n-\t      fprintf (dump_file, \"->xx REJECTED\\n\");\n-\t    }\n-\t  continue;\n-\t}\n-\n-      tree arg = gimple_phi_arg_def (phi, i);\n-      unsigned v = 0;\n-\n-      if (TREE_CODE (arg) == SSA_NAME\n-\t  && !bitmap_bit_p (interesting, SSA_NAME_VERSION (arg)))\n-\t{\n-\t  // Record that ARG is interesting when searching down this path.\n-\t  v = SSA_NAME_VERSION (arg);\n-\t  gcc_checking_assert (v != 0);\n-\t  bitmap_set_bit (interesting, v);\n-\t  bitmap_set_bit (m_imports, v);\n-\t}\n-\n-      find_paths_to_names (e->src, interesting);\n-\n-      if (v)\n-\tbitmap_clear_bit (interesting, v);\n-    }\n-}\n-\n // Find jump threading paths to any of the SSA names in the\n // INTERESTING bitmap, and register any such paths.\n //\n@@ -417,51 +351,75 @@ back_threader::find_paths_to_names (basic_block bb, bitmap interesting)\n   if (m_path.length () > 1\n       && (!m_profit.profitable_path_p (m_path, m_name, NULL)\n \t  || maybe_register_path ()))\n-    {\n-      m_path.pop ();\n-      m_visited_bbs.remove (bb);\n-      return;\n-    }\n+    ;\n \n-  auto_bitmap processed;\n-  bool done = false;\n-  // We use a worklist instead of iterating through the bitmap,\n-  // because we may add new items in-flight.\n-  auto_vec<tree> worklist (bitmap_count_bits (interesting));\n-  populate_worklist (worklist, interesting);\n-  while (!worklist.is_empty ())\n+  // Continue looking for ways to extend the path\n+  else\n     {\n-      tree name = worklist.pop ();\n-      unsigned i = SSA_NAME_VERSION (name);\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-      basic_block def_bb = gimple_bb (def_stmt);\n-\n-      // Process any PHIs defined in this block.\n-      if (def_bb == bb\n-\t  && bitmap_set_bit (processed, i)\n-\t  && gimple_code (def_stmt) == GIMPLE_PHI)\n+      // For further greedy searching we want to remove interesting\n+      // names defined in BB but add ones on the PHI edges for the\n+      // respective edges.  We do this by starting with all names\n+      // not defined in BB as interesting, collecting a list of\n+      // interesting PHIs in BB on the fly.  Then we iterate over\n+      // predecessor edges, adding interesting PHI edge defs to\n+      // the set of interesting names to consider when processing it.\n+      auto_bitmap new_interesting;\n+      auto_vec<gphi *, 4> interesting_phis;\n+      bitmap_iterator bi;\n+      unsigned i;\n+      EXECUTE_IF_SET_IN_BITMAP (interesting, 0, i, bi)\n \t{\n-\t  resolve_phi (as_a<gphi *> (def_stmt), interesting);\n-\t  done = true;\n-\t  break;\n+\t  tree name = ssa_name (i);\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\t  if (gimple_bb (def_stmt) != bb)\n+\t    bitmap_set_bit (new_interesting, i);\n+\t  else if (gphi *phi = dyn_cast<gphi *> (def_stmt))\n+\t    {\n+\t      tree res = gimple_phi_result (phi);\n+\t      if (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (res))\n+\t\tinteresting_phis.safe_push (phi);\n+\t    }\n \t}\n-    }\n-  // If there are interesting names not yet processed, keep looking.\n-  if (!done)\n-    {\n-      bitmap_and_compl_into (interesting, processed);\n-      if (!bitmap_empty_p (interesting))\n+      if (!bitmap_empty_p (new_interesting)\n+\t  || !interesting_phis.is_empty ())\n \t{\n+\t  auto_vec<tree, 4> unwind (interesting_phis.length ());\n \t  edge_iterator iter;\n \t  edge e;\n \t  FOR_EACH_EDGE (e, iter, bb->preds)\n-\t    if ((e->flags & EDGE_ABNORMAL) == 0)\n-\t      find_paths_to_names (e->src, interesting);\n+\t    {\n+\t      if (e->flags & EDGE_ABNORMAL\n+\t\t  // This is like path_crosses_loops in profitable_path_p but\n+\t\t  // more restrictive to avoid peeling off loop iterations (see\n+\t\t  // tree-ssa/pr14341.c for an example).\n+\t\t  // ???  Note this restriction only applied when visiting an\n+\t\t  // interesting PHI with the former resolve_phi.\n+\t\t  || (!interesting_phis.is_empty ()\n+\t\t      && m_path[0]->loop_father != e->src->loop_father))\n+\t\tcontinue;\n+\t      for (gphi *phi : interesting_phis)\n+\t\t{\n+\t\t  tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t\t  if (TREE_CODE (def) == SSA_NAME)\n+\t\t    if (bitmap_set_bit (new_interesting,\n+\t\t\t\t\tSSA_NAME_VERSION (def)))\n+\t\t      {\n+\t\t\tbitmap_set_bit (m_imports, SSA_NAME_VERSION (def));\n+\t\t\tunwind.quick_push (def);\n+\t\t      }\n+\t\t}\n+\t      find_paths_to_names (e->src, new_interesting);\n+\t      // Restore new_interesting.  We leave m_imports alone since\n+\t      // we do not prune defs in BB from it and separately keeping\n+\t      // track of which bits to unwind isn't worth the trouble.\n+\t      for (tree def : unwind)\n+\t\tbitmap_clear_bit (new_interesting, SSA_NAME_VERSION (def));\n+\t      unwind.truncate (0);\n+\t    }\n \t}\n     }\n \n   // Reset things to their original state.\n-  bitmap_ior_into (interesting, processed);\n   m_path.pop ();\n   m_visited_bbs.remove (bb);\n }"}]}