{"sha": "8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "node_id": "C_kwDOANBUbNoAKDhmOTVlM2MwNGQ2NTlkNTQxY2E0OTM3YjNkZjJmMTE3NWExYzVmMDU", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-09-29T10:00:14Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-09-29T10:00:14Z"}, "message": "aarch64: Improve size optimisation heuristic for setmem expansion\n\nThis patch adjusts the setmem expansion in the backend to track the number of ops it generates\nfor the DUP + STR/STP inline sequences. This way we can compare the size/complexity of the sequence\nagainst alternatives, notably just returning \"false\" and thus just emitting a call to memset.\n\nThe simple heuristic change here is that if we were going to emit more than 4 operations then\nwe shouldn't bother and just call memset. The number 4 is chosen because in the worst case for memset\nwe need to emit 4 instructions: 3 to move the arguments into the right registers and 1 for the call.\n\nThe speed optimisation decisions are not affected, though I do want to extend these expansions in a later\npatch and I'd like to reuse this ops counting logic there. In any case this patch should make sense on its own.\n\nFor the code:\nvoid __attribute__((__noinline__))\nset127byte (int64_t *src, int c)\n{\n  __builtin_memset (src, c, 127);\n}\n\nvoid __attribute__((__noinline__))\nset128byte (int64_t *src, int c)\n{\n  __builtin_memset (src, c, 128);\n}\n\nwhen optimising for size we now get just an immediate move + a call to memset (2 instructions) where before we'd have generated:\nset127byte(long*, int):\n        dup     v0.16b, w1\n        str     q0, [x0, 96]\n        stp     q0, q0, [x0]\n        stp     q0, q0, [x0, 32]\n        stp     q0, q0, [x0, 64]\n        str     q0, [x0, 111]\n        ret\nset128byte(long*, int):\n        dup     v0.16b, w1\n        stp     q0, q0, [x0]\n        stp     q0, q0, [x0, 32]\n        stp     q0, q0, [x0, 64]\n        stp     q0, q0, [x0, 96]\n        ret\n\nwhich is clearly undesirable for -Os.\n\nI've adjusted the recently-added gcc.target/aarch64/memset-strict-align-1.c testcase to use a bigger struct\nand switch to speed optimisation as with this patch we'll just call memset rather than expanding inline.\nThat is the right decision for size optimisation (the resulting code is indeed shorter).\nWith -O2 and the new struct size we still try the SIMD expansion and still trigger the path that the testcase is supposed to exercise.\n\n2021-09-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_expand_setmem): Count number of\n\temitted operations and adjust heuristic for code size.\n\n2021-09-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* gcc.target/aarch64/memset-corner-cases-2.c: New test.\n\t* gcc.target/aarch64/memset-strict-align-1.c: Adjust.", "tree": {"sha": "7d594f44833d3cfb7697805d1d528aee5e2d34da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d594f44833d3cfb7697805d1d528aee5e2d34da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e7bb15e28c554bf4484a912f3b9c18c60ec68f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e7bb15e28c554bf4484a912f3b9c18c60ec68f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e7bb15e28c554bf4484a912f3b9c18c60ec68f"}], "stats": {"total": 71, "additions": 53, "deletions": 18}, "files": [{"sha": "ac17c1c88fb42dc1a8543b64934a624d49f1779d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "patch": "@@ -23534,40 +23534,37 @@ aarch64_expand_setmem (rtx *operands)\n   if (!CONST_INT_P (operands[1]))\n     return false;\n \n-  bool speed_p = !optimize_function_for_size_p (cfun);\n+  bool size_p = optimize_function_for_size_p (cfun);\n \n   /* Default the maximum to 256-bytes.  */\n   unsigned max_set_size = 256;\n \n-  /* In case we are optimizing for size or if the core does not\n-     want to use STP Q regs, lower the max_set_size.  */\n-  max_set_size = (!speed_p\n-\t\t  || (aarch64_tune_params.extra_tuning_flags\n-\t\t      & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS))\n-\t\t  ? max_set_size / 2 : max_set_size;\n-\n   len = INTVAL (operands[1]);\n \n   /* Upper bound check.  */\n   if (len > max_set_size)\n     return false;\n \n+  /* Attempt a sequence with a vector broadcast followed by stores.\n+     Count the number of operations involved to see if it's worth it for\n+     code size.  */\n+  start_sequence ();\n+  unsigned nops = 0;\n   base = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   dst = adjust_automodify_address (dst, VOIDmode, base, 0);\n \n   /* Prepare the val using a DUP/MOVI v0.16B, val.  */\n   src = expand_vector_broadcast (V16QImode, val);\n   src = force_reg (V16QImode, src);\n-\n+  nops++;\n   /* Convert len to bits to make the rest of the code simpler.  */\n   n = len * BITS_PER_UNIT;\n \n   /* Maximum amount to copy in one go.  We allow 256-bit chunks based on the\n      AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS tuning parameter.  setmem expand\n      pattern is only turned on for TARGET_SIMD.  */\n-  const int copy_limit = (speed_p\n-\t\t\t  && (aarch64_tune_params.extra_tuning_flags\n-\t\t\t      & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS))\n+  const int copy_limit = (aarch64_tune_params.extra_tuning_flags\n+\t\t\t  & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS)\n \t\t\t  ? GET_MODE_BITSIZE (TImode) : 256;\n \n   while (n > 0)\n@@ -23583,7 +23580,7 @@ aarch64_expand_setmem (rtx *operands)\n \n       mode_bits = GET_MODE_BITSIZE (cur_mode).to_constant ();\n       aarch64_set_one_block_and_progress_pointer (src, &dst, cur_mode);\n-\n+      nops++;\n       n -= mode_bits;\n \n       /* Do certain trailing copies as overlapping if it's going to be\n@@ -23599,7 +23596,15 @@ aarch64_expand_setmem (rtx *operands)\n \t  n = n_bits;\n \t}\n     }\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+  /* A call to memset in the worst case requires 3 instructions to prepare\n+     the arguments + 1 for the call.  Prefer the inline sequence for size if\n+     it is no longer than that.  */\n+  if (size_p && nops > 4)\n+    return false;\n \n+  emit_insn (seq);\n   return true;\n }\n "}, {"sha": "9ee96f33255e1841be516734892c1fbb20772a3d", "filename": "gcc/testsuite/gcc.target/aarch64/memset-corner-cases-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-corner-cases-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-corner-cases-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-corner-cases-2.c?ref=8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdint.h>\n+\n+/* 127 bytes should use libcall for size.\n+**set127byte:\n+**\tmov\tx2, 127\n+**\tb\tmemset\n+*/\n+void __attribute__((__noinline__))\n+set127byte (int64_t *src, int c)\n+{\n+  __builtin_memset (src, c, 127);\n+}\n+\n+/* 128 bytes should use libcall for size.\n+**set128byte:\n+**\tmov\tx2, 128\n+**\tb\tmemset\n+*/\n+void __attribute__((__noinline__))\n+set128byte (int64_t *src, int c)\n+{\n+  __builtin_memset (src, c, 128);\n+}\n+\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+"}, {"sha": "664d43aee1300819022691ac337d6b8c03d6b8dd", "filename": "gcc/testsuite/gcc.target/aarch64/memset-strict-align-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-strict-align-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f95e3c04d659d541ca4937b3df2f1175a1c5f05/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-strict-align-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-strict-align-1.c?ref=8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "patch": "@@ -1,22 +1,22 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Os -mstrict-align\" } */\n+/* { dg-options \"-O2 -mstrict-align\" } */\n \n-struct s { char x[95]; };\n+struct s { char x[255]; };\n void foo (struct s *);\n void bar (void) { struct s s1 = {}; foo (&s1); }\n \n-/* memset (s1 = {}, sizeof = 95) should be expanded out\n+/* memset (s1 = {}, sizeof = 255) should be expanded out\n    such that there are no overlap stores when -mstrict-align\n    is in use.\n-   so 2 pair 16 bytes stores (64 bytes).\n+   so 7 pairs of 16 bytes stores (224 bytes).\n    1 16 byte stores\n    1 8 byte store\n    1 4 byte store\n    1 2 byte store\n    1 1 byte store\n    */\n \n-/* { dg-final { scan-assembler-times \"stp\\tq\" 2 } } */\n+/* { dg-final { scan-assembler-times \"stp\\tq\" 7 } } */\n /* { dg-final { scan-assembler-times \"str\\tq\" 1 } } */\n /* { dg-final { scan-assembler-times \"str\\txzr\" 1 } } */\n /* { dg-final { scan-assembler-times \"str\\twzr\" 1 } } */"}]}