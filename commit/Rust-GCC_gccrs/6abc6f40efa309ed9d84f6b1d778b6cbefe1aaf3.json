{"sha": "6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiYzZmNDBlZmEzMDllZDlkODRmNmIxZDc3OGI2Y2JlZmUxYWFmMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-09-05T22:22:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-09-05T22:22:07Z"}, "message": "alpha.c (alpha_ra_ever_killed): Inspect the topmost sequence, not whatever we're generating now.\n\n        * alpha.c (alpha_ra_ever_killed): Inspect the topmost sequence,\n        not whatever we're generating now.\n        * alpha.c (set_frame_related_p, FRP): New.\n        (alpha_expand_prologue): Mark frame related insns.\n        (alpha_expand_epilogue): Likewise, but with a null FRP.\n        * alpha.h (INCOMING_RETURN_ADDR_RTX): New.\n        * alpha.md (exception_receiver): New.\n        * alpha/crtbegin.asm (.eh_frame): New beginning.\n        (__do_frame_setup, __do_frame_takedown): New.\n        * alpha/crtend.asm (.eh_frame): New ending.\n        * alpha/elf.h (DWARF2_DEBUGGING_INFO): Define.\n        (ASM_SPEC): Don't emit both dwarf2 and mdebug.\n        (ASM_FILE_START): Don't emit .file for dwarf2.\n\nFrom-SVN: r22277", "tree": {"sha": "08f1b3bd01cc97bc3538c0c23730f536d7c2d692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08f1b3bd01cc97bc3538c0c23730f536d7c2d692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/comments", "author": null, "committer": null, "parents": [{"sha": "07ebc9309dd2deabc568c3c8ea6fc0ab7edc7fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ebc9309dd2deabc568c3c8ea6fc0ab7edc7fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ebc9309dd2deabc568c3c8ea6fc0ab7edc7fe7"}], "stats": {"total": 287, "additions": 226, "deletions": 61}, "files": [{"sha": "0f3b52e0c586b4202009a8986f0c8c158d2565f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -1,5 +1,20 @@\n Sat Sep  5 22:05:25 1998  Richard Henderson  <rth@cygnus.com>\n \n+\t* alpha.c (alpha_ra_ever_killed): Inspect the topmost sequence,\n+\tnot whatever we're generating now.\n+\n+\t* alpha.c (set_frame_related_p, FRP): New.\n+\t(alpha_expand_prologue): Mark frame related insns.\n+\t(alpha_expand_epilogue): Likewise, but with a null FRP.\n+\t* alpha.h (INCOMING_RETURN_ADDR_RTX): New.\n+\t* alpha.md (exception_receiver): New.\n+\t* alpha/crtbegin.asm (.eh_frame): New beginning.\n+\t(__do_frame_setup, __do_frame_takedown): New.\n+\t* alpha/crtend.asm (.eh_frame): New ending.\n+\t* alpha/elf.h (DWARF2_DEBUGGING_INFO): Define.\n+\t(ASM_SPEC): Don't emit both dwarf2 and mdebug.\n+\t(ASM_FILE_START): Don't emit .file for dwarf2.\n+\n \t* rtl.h (enum reg_note): Add REG_FRAME_RELATED_EXPR.\n \t* rtl.c (reg_note_name): Likewise.\n \t* rtl.texi (REG_NOTES): Likewise."}, {"sha": "e19ddab0fd8408ded8b46fc606b4800b01e6a85f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 101, "deletions": 50, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -2468,15 +2468,20 @@ alpha_return_addr (count, frame)\n static int\n alpha_ra_ever_killed ()\n {\n+  rtx top;\n+\n #ifdef ASM_OUTPUT_MI_THUNK\n   if (current_function_is_thunk)\n     return 0;\n #endif\n   if (!alpha_return_addr_rtx)\n     return regs_ever_live[REG_RA];\n \n-  return reg_set_between_p (gen_rtx_REG (Pmode, REG_RA),\n-\t\t\t    get_insns(), NULL_RTX);\n+  push_topmost_sequence ();\n+  top = get_insns ();\n+  pop_topmost_sequence ();\n+\n+  return reg_set_between_p (gen_rtx_REG (Pmode, REG_RA), top, NULL_RTX);\n }\n \n \f\n@@ -3192,6 +3197,32 @@ alpha_write_verstamp (file)\n #endif\n }\n \f\n+/* Helper function to set RTX_FRAME_RELATED_P on instructions, including\n+   sequences.  */\n+\n+static rtx\n+set_frame_related_p ()\n+{\n+  rtx seq = gen_sequence ();\n+  end_sequence ();\n+\n+  if (GET_CODE (seq) == SEQUENCE)\n+    {\n+      int i = XVECLEN (seq, 0);\n+      while (--i >= 0)\n+\tRTX_FRAME_RELATED_P (XVECEXP (seq, 0, i)) = 1;\n+     return emit_insn (seq);\n+    }\n+  else\n+    {\n+      seq = emit_insn (seq);\n+      RTX_FRAME_RELATED_P (seq) = 1;\n+      return seq;\n+    }\n+}\n+\n+#define FRP(exp)  (start_sequence (), exp, set_frame_related_p ())\n+\n /* Write function prologue.  */\n \n /* On vms we have two kinds of functions:\n@@ -3271,8 +3302,8 @@ alpha_expand_prologue ()\n \n       if (frame_size != 0)\n \t{\n-\t  emit_move_insn (stack_pointer_rtx,\n-\t\t\t  plus_constant (stack_pointer_rtx, -frame_size));\n+\t  FRP (emit_move_insn (stack_pointer_rtx,\n+\t\t\t       plus_constant (stack_pointer_rtx, -frame_size)));\n \t}\n     }\n   else\n@@ -3302,7 +3333,18 @@ alpha_expand_prologue ()\n \t  emit_move_insn (last, const0_rtx);\n \t}\n \n-      emit_move_insn (stack_pointer_rtx, plus_constant (ptr, -leftover));\n+      ptr = emit_move_insn (stack_pointer_rtx, plus_constant (ptr, -leftover));\n+\n+      /* This alternative is special, because the DWARF code cannot possibly\n+\t intuit through the loop above.  So we invent this note it looks at\n+\t instead.  */\n+      RTX_FRAME_RELATED_P (ptr) = 1;\n+      REG_NOTES (ptr)\n+\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t     gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t       gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     GEN_INT (-frame_size))),\n+\t\t\t     REG_NOTES (ptr));\n     }\n \n   /* Cope with very large offsets to the register save area.  */\n@@ -3318,21 +3360,22 @@ alpha_expand_prologue ()\n \tbias = reg_offset, reg_offset = 0;\n \n       sa_reg = gen_rtx_REG (DImode, 24);\n-      emit_move_insn (sa_reg, plus_constant (stack_pointer_rtx, bias));\n+      FRP (emit_move_insn (sa_reg, plus_constant (stack_pointer_rtx, bias)));\n     }\n     \n   /* Save regs in stack order.  Beginning with VMS PV.  */\n   if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n     {\n-      emit_move_insn (gen_rtx_MEM (DImode, stack_pointer_rtx),\n-\t\t      gen_rtx_REG (DImode, REG_PV));\n+      FRP (emit_move_insn (gen_rtx_MEM (DImode, stack_pointer_rtx),\n+\t\t           gen_rtx_REG (DImode, REG_PV)));\n     }\n \n   /* Save register RA next.  */\n   if (imask & (1L << REG_RA))\n     {\n-      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset)),\n-\t\t      gen_rtx_REG (DImode, REG_RA));\n+      FRP (emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t\tplus_constant (sa_reg, reg_offset)),\n+\t\t           gen_rtx_REG (DImode, REG_RA)));\n       imask &= ~(1L << REG_RA);\n       reg_offset += 8;\n     }\n@@ -3341,18 +3384,18 @@ alpha_expand_prologue ()\n   for (i = 0; i < 32; i++)\n     if (imask & (1L << i))\n       {\n-\temit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t     plus_constant (sa_reg, reg_offset)),\n-\t\t\tgen_rtx_REG (DImode, i));\n+\tFRP (emit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t          plus_constant (sa_reg, reg_offset)),\n+\t\t\t     gen_rtx_REG (DImode, i)));\n \treg_offset += 8;\n       }\n \n   for (i = 0; i < 32; i++)\n     if (fmask & (1L << i))\n       {\n-\temit_move_insn (gen_rtx_MEM (DFmode,\n-\t\t\t\t     plus_constant (sa_reg, reg_offset)),\n-\t\t\tgen_rtx_REG (DFmode, i+32));\n+\tFRP (emit_move_insn (gen_rtx_MEM (DFmode,\n+\t\t\t\t          plus_constant (sa_reg, reg_offset)),\n+\t\t\t     gen_rtx_REG (DFmode, i+32)));\n \treg_offset += 8;\n       }\n \n@@ -3361,25 +3404,25 @@ alpha_expand_prologue ()\n       if (!vms_is_stack_procedure)\n \t{\n \t  /* Register frame procedures fave the fp.  */\n-\t  emit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),\n-\t\t\t  hard_frame_pointer_rtx);\n+\t  FRP (emit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),\n+\t\t\t       hard_frame_pointer_rtx));\n \t}\n \n       if (vms_base_regno != REG_PV)\n-\temit_move_insn (gen_rtx_REG (DImode, vms_base_regno),\n-\t\t\tgen_rtx_REG (DImode, REG_PV));\n+\tFRP (emit_move_insn (gen_rtx_REG (DImode, vms_base_regno),\n+\t\t\t     gen_rtx_REG (DImode, REG_PV)));\n \n       if (vms_unwind_regno == HARD_FRAME_POINTER_REGNUM)\n \t{\n-\t  emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t  FRP (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n \t}\n \n       /* If we have to allocate space for outgoing args, do it now.  */\n       if (current_function_outgoing_args_size != 0)\n \t{\n-\t  emit_move_insn (stack_pointer_rtx, \n-\t    plus_constant (hard_frame_pointer_rtx,\n-\t      - ALPHA_ROUND (current_function_outgoing_args_size)));\n+\t  FRP (emit_move_insn (stack_pointer_rtx, \n+\t        plus_constant (hard_frame_pointer_rtx,\n+\t         - ALPHA_ROUND (current_function_outgoing_args_size))));\n \t}\n     }\n   else\n@@ -3388,13 +3431,13 @@ alpha_expand_prologue ()\n       if (frame_pointer_needed)\n \t{\n \t  if (TARGET_CAN_FAULT_IN_PROLOGUE)\n-\t    emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t    FRP (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n \t  else\n \t    {\n \t      /* This must always be the last instruction in the\n \t\t prologue, thus we emit a special move + clobber.  */\n-\t      emit_insn (gen_init_fp (hard_frame_pointer_rtx,\n-\t\t\t\t      stack_pointer_rtx, sa_reg));\n+\t      FRP (emit_insn (gen_init_fp (hard_frame_pointer_rtx,\n+\t\t\t\t           stack_pointer_rtx, sa_reg)));\n \t    }\n \t}\n     }\n@@ -3611,6 +3654,12 @@ output_end_prologue (file)\n \n /* Write function epilogue.  */\n \n+/* ??? At some point we will want to support full unwind, and so will \n+   need to mark the epilogue as well.  At the moment, we just confuse\n+   dwarf2out.  */\n+#undef FRP\n+#define FRP(exp) exp\n+\n void\n alpha_expand_epilogue ()\n {\n@@ -3659,7 +3708,7 @@ alpha_expand_epilogue ()\n \t   && vms_unwind_regno == HARD_FRAME_POINTER_REGNUM)\n \t  || (!TARGET_OPEN_VMS && frame_pointer_needed))\n \t{\n-\t  emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n+\t  FRP (emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx));\n \t}\n \n       /* Cope with very large offsets to the register save area.  */\n@@ -3677,13 +3726,14 @@ alpha_expand_epilogue ()\n \t  sa_reg = gen_rtx_REG (DImode, 22);\n \t  sa_reg_exp = plus_constant (stack_pointer_rtx, bias);\n \n-\t  emit_move_insn (sa_reg, sa_reg_exp);\n+\t  FRP (emit_move_insn (sa_reg, sa_reg_exp));\n \t}\n \t  \n       /* Restore registers in order, excepting a true frame pointer. */\n \n-      emit_move_insn (gen_rtx_REG (DImode, REG_RA),\n-\t\t      gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset)));\n+      FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA),\n+\t\t           gen_rtx_MEM (DImode, plus_constant(sa_reg,\n+\t\t\t\t\t\t\t      reg_offset))));\n       reg_offset += 8;\n       imask &= ~(1L << REG_RA);\n \n@@ -3694,20 +3744,21 @@ alpha_expand_epilogue ()\n \t      fp_offset = reg_offset;\n \t    else\n \t      {\n-\t\temit_move_insn (gen_rtx_REG (DImode, i),\n-\t\t\t\tgen_rtx_MEM (DImode,\n-\t\t\t\t\t     plus_constant(sa_reg,\n-\t\t\t\t\t\t           reg_offset)));\n+\t\tFRP (emit_move_insn (gen_rtx_REG (DImode, i),\n+\t\t\t\t     gen_rtx_MEM (DImode,\n+\t\t\t\t\t          plus_constant(sa_reg,\n+\t\t\t\t\t\t                reg_offset))));\n \t      }\n \t    reg_offset += 8;\n \t  }\n \n       for (i = 0; i < 32; ++i)\n \tif (fmask & (1L << i))\n \t  {\n-\t    emit_move_insn (gen_rtx_REG (DFmode, i+32),\n-\t\t\t    gen_rtx_MEM (DFmode,\n-\t\t\t\t\t plus_constant(sa_reg, reg_offset)));\n+\t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32),\n+\t\t\t         gen_rtx_MEM (DFmode,\n+\t\t\t\t\t      plus_constant(sa_reg,\n+\t\t\t\t\t\t\t    reg_offset))));\n \t    reg_offset += 8;\n \t  }\n     }\n@@ -3732,20 +3783,20 @@ alpha_expand_epilogue ()\n \t  else\n \t    {\n \t      sp_adj1 = gen_rtx_REG (DImode, 23);\n-\t      emit_move_insn (sp_adj1, sp_adj2);\n+\t      FRP (emit_move_insn (sp_adj1, sp_adj2));\n \t    }\n \t  sp_adj2 = GEN_INT (low);\n \t}\n       else\n \t{\n \t  sp_adj2 = gen_rtx_REG (DImode, 23);\n-\t  sp_adj1 = alpha_emit_set_const (sp_adj2, DImode, frame_size, 3);\n+\t  FRP (sp_adj1 = alpha_emit_set_const (sp_adj2, DImode, frame_size, 3));\n \t  if (!sp_adj1)\n \t    {\n \t      /* We can't drop new things to memory this late, afaik,\n \t\t so build it up by pieces.  */\n #if HOST_BITS_PER_WIDE_INT == 64\n-\t      sp_adj1 = alpha_emit_set_long_const (sp_adj2, frame_size);\n+\t      FRP (sp_adj1 = alpha_emit_set_long_const (sp_adj2, frame_size));\n \t      if (!sp_adj1)\n \t\tabort ();\n #else\n@@ -3761,29 +3812,29 @@ alpha_expand_epilogue ()\n       if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n-\t  emit_move_insn (hard_frame_pointer_rtx,\n-\t\t\t  gen_rtx_MEM (DImode,\n-\t\t\t\t       plus_constant(sa_reg, fp_offset)));\n+\t  FRP (emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t       gen_rtx_MEM (DImode,\n+\t\t\t\t            plus_constant(sa_reg, fp_offset))));\n \t}\n       else if (TARGET_OPEN_VMS)\n \t{\n \t  emit_insn (gen_blockage ());\n-\t  emit_move_insn (hard_frame_pointer_rtx,\n-\t\t\t  gen_rtx_REG (DImode, vms_save_fp_regno));\n+\t  FRP (emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t       gen_rtx_REG (DImode, vms_save_fp_regno)));\n \t}\n \n       /* Restore the stack pointer.  */\n       emit_insn (gen_blockage ());\n-      emit_move_insn (stack_pointer_rtx,\n-\t\t      gen_rtx_PLUS (DImode, sp_adj1, sp_adj2));\n+      FRP (emit_move_insn (stack_pointer_rtx,\n+\t\t           gen_rtx_PLUS (DImode, sp_adj1, sp_adj2)));\n     }\n   else \n     {\n       if (TARGET_OPEN_VMS && !vms_is_stack_procedure)\n         {\n           emit_insn (gen_blockage ());\n-          emit_move_insn (hard_frame_pointer_rtx,\n-\t\t\t  gen_rtx_REG (DImode, vms_save_fp_regno));\n+          FRP (emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t       gen_rtx_REG (DImode, vms_save_fp_regno)));\n         }\n     }\n "}, {"sha": "9aacab5d83310f71fee102f943234cc5dab13298", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -1301,6 +1301,9 @@ extern void alpha_initialize_trampoline ();\n #define RETURN_ADDR_RTX  alpha_return_addr\n extern struct rtx_def *alpha_return_addr ();\n \n+/* Before the prologue, RA lives in $26. */\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)\n+\n /* Initialize data used by insn expanders.  This is called from insn_emit,\n    once for every function before code is generated.  */\n "}, {"sha": "232fb01def14ba1aafca04bf733fd789ff4aa8d0", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -39,6 +39,7 @@\n ;;\t4\ttrapb\n ;;\t5\tprologue_stack_probe_loop\n ;;\t6\trealign\n+;;\t7\texception_receiver\n \f\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n@@ -5177,7 +5178,14 @@\n (define_insn \"\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n-  \"br $27,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($27)\"\n+  \"br $29,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($29)\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"multi\")])\n+\n+(define_insn \"exception_receiver\"\n+  [(unspec_volatile [(const_int 0)] 7)]\n+  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n+  \"br $29,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($29)\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"multi\")])\n "}, {"sha": "f954f1ab0d3e55670131a60c85b33d240ac9f045", "filename": "gcc/config/alpha/crtbegin.asm", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fcrtbegin.asm?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -50,6 +50,8 @@ __CTOR_LIST__:\n __DTOR_LIST__:\n \t.quad -1\n \n+.section .eh_frame,\"aw\"\n+__EH_FRAME_BEGIN__:\n \n  #\n  # Fragment of the ELF _fini routine that invokes our dtor cleanup.\n@@ -67,34 +69,48 @@ __DTOR_LIST__:\n 1:\tldgp    $29,0($29)\n \tjsr     $26,__do_global_dtors_aux\n \n+\t# Ideally this call would go in crtend.o, except that we can't\n+\t# get hold of __EH_FRAME_BEGIN__ there.\n+\n+\tjsr\t$26,__do_frame_takedown\n+\n \t# Must match the alignment we got from crti.o else we get\n \t# zero-filled holes in our _fini function and then SIGILL.\n \t.align 3\n \n+ #\n+ # Fragment of the ELF _init routine that sets up the frame info.\n+ #\n+\n+.section .init,\"ax\"\n+       br      $29,1f\n+1:     ldgp    $29,0($29)\n+       jsr     $26,__do_frame_setup\n+       .align 3\n+\n  #\n  # Invoke our destructors in order.\n  #\n \n .data\n \n  # Support recursive calls to exit.\n-9:\t.quad\t__DTOR_LIST__\n+$ptr:\t.quad\t__DTOR_LIST__\n \n .text\n \n \t.align 3\n \t.ent __do_global_dtors_aux\n \n __do_global_dtors_aux:\n-\tldgp\t$29,0($27)\n \tlda     $30,-16($30)\n \t.frame  $30,16,$26,0\n \tstq\t$9,8($30)\n \tstq     $26,0($30)\n \t.mask   0x4000200,-16\n-\t.prologue 1\n+\t.prologue 0\n \n-\tlda     $9,9b\n+\tlda     $9,$ptr\n \tbr      1f\n 0:\tstq\t$1,0($9)\n \tjsr     $26,($27)\n@@ -109,3 +125,68 @@ __do_global_dtors_aux:\n \tret\n \n \t.end __do_global_dtors_aux\n+\n+ #\n+ # Install our frame info.\n+ #\n+\n+ # ??? How can we rationally keep this size correct?\n+\n+.section .bss\n+\t.type $object,@object\n+\t.align 3\n+$object:\n+\t.zero 48\n+\t.size $object, 48\n+\n+.text \n+\n+\t.align 3\n+\t.ent __do_frame_setup\n+\n+__do_frame_setup:\n+\tldgp\t$29,0($27)\n+\tlda     $30,-16($30)\n+\t.frame  $30,16,$26,0\n+\tstq     $26,0($30)\n+\t.mask   0x4000000,-16\n+\t.prologue 1\n+\n+\tlda\t$1,__register_frame_info\n+\tbeq\t$1,0f\n+\tlda\t$16,__EH_FRAME_BEGIN__\n+\tlda\t$17,$object\n+\tjsr\t$26,__register_frame_info\n+\tldq     $26,0($30)\n+0:\tlda     $30,16($30)\n+\tret\n+\n+\t.end __do_frame_setup\n+\n+ #\n+ # Remove our frame info.\n+ #\n+\n+\t.align 3\n+\t.ent __do_frame_takedown\n+\n+__do_frame_takedown:\n+\tldgp\t$29,0($27)\n+\tlda     $30,-16($30)\n+\t.frame  $30,16,$26,0\n+\tstq     $26,0($30)\n+\t.mask   0x4000000,-16\n+\t.prologue 1\n+\n+\tlda\t$1,__deregister_frame_info\n+\tbeq\t$1,0f\n+\tlda\t$16,__EH_FRAME_BEGIN__\n+\tjsr\t$26,__deregister_frame_info\n+\tldq     $26,0($30)\n+0:\tlda     $30,16($30)\n+\tret\n+\n+\t.end __do_frame_takedown\n+\n+.weak __register_frame_info\n+.weak __deregister_frame_info"}, {"sha": "4a0cc5e9f61247e59def8532d0cf1b2ac011ddff", "filename": "gcc/config/alpha/crtend.asm", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fcrtend.asm?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -50,6 +50,9 @@ __CTOR_END__:\n __DTOR_END__:\n \t.quad   0\n \n+.section .eh_frame,\"aw\"\n+__FRAME_END__:\n+\t.quad\t0\n \n  #\n  # Fragment of the ELF _init routine that invokes our ctor startup"}, {"sha": "89eda748c0650c8e36314b13a985f761b9a016a1", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=6abc6f40efa309ed9d84f6b1d778b6cbefe1aaf3", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.    */\n #define OBJECT_FORMAT_ELF\n \n #define DBX_DEBUGGING_INFO\n+#define DWARF2_DEBUGGING_INFO\n \n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n@@ -34,7 +35,7 @@ Boston, MA 02111-1307, USA.    */\n #define CC1_SPEC  \"%{G*}\"\n \n #undef ASM_SPEC\n-#define ASM_SPEC  \"%{G*} %{relax:-relax}\"\n+#define ASM_SPEC  \"%{G*} %{relax:-relax} %{gdwarf*:-no-mdebug}\"\n \n #undef LINK_SPEC\n #define LINK_SPEC \"-m elf64alpha %{G*} %{relax:-relax}\t\t\\\n@@ -49,18 +50,21 @@ Boston, MA 02111-1307, USA.    */\n /* Output at beginning of assembler file.  */\n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  alpha_write_verstamp (FILE);\t\t\t\t\t\\\n-  output_file_directive (FILE, main_input_filename);\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (write_symbols != DWARF2_DEBUG)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      alpha_write_verstamp (FILE);\t\t\t\t\\\n+      output_file_directive (FILE, main_input_filename);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.set noreorder\\n\");                         \\\n+  fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n   if (TARGET_BWX | TARGET_MAX | TARGET_CIX)\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       fprintf (FILE, \"\\t.arch %s\\n\",\t\t\t\t\\\n                (alpha_cpu == PROCESSOR_EV6 ? \"ev6\"\t\t\\\n                 : TARGET_MAX ? \"pca56\" : \"ev56\"));\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \n extern void output_file_directive ();\n "}]}