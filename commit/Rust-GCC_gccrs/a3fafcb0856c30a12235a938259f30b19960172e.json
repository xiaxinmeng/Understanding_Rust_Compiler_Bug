{"sha": "a3fafcb0856c30a12235a938259f30b19960172e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmYWZjYjA4NTZjMzBhMTIyMzVhOTM4MjU5ZjMwYjE5OTYwMTcyZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-12-16T11:43:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-12-16T11:43:46Z"}, "message": "Checkin missing parts of my 2005-12-12 patch\n\nFrom-SVN: r108636", "tree": {"sha": "93ee1416eaddeccb1448e06fc0b9eea02af325c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93ee1416eaddeccb1448e06fc0b9eea02af325c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3fafcb0856c30a12235a938259f30b19960172e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fafcb0856c30a12235a938259f30b19960172e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3fafcb0856c30a12235a938259f30b19960172e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fafcb0856c30a12235a938259f30b19960172e/comments", "author": null, "committer": null, "parents": [{"sha": "00dcee0c2b28fcca272fe3e9ad67782022612671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00dcee0c2b28fcca272fe3e9ad67782022612671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00dcee0c2b28fcca272fe3e9ad67782022612671"}], "stats": {"total": 5651, "additions": 2, "deletions": 5649}, "files": [{"sha": "6c8a2d4846150676c890c5e2264117b43c1dd426", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3fafcb0856c30a12235a938259f30b19960172e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3fafcb0856c30a12235a938259f30b19960172e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a3fafcb0856c30a12235a938259f30b19960172e", "patch": "@@ -1582,9 +1582,9 @@ mn10300-*-*)\n \tuse_collect2=no\n \tuse_fixproto=yes\n \t;;\n-ms1-*-elf)\n+mt-*-elf)\n         tm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n-        tmake_file=\"${tmake_file} ms1/t-ms1\"\n+        tmake_file=\"${tmake_file} mt/t-mt\"\n         ;;\n ns32k-*-netbsdelf*)\n \techo \"GCC does not yet support the ${target} target\"; exit 1"}, {"sha": "97dfbb80a866c154b492ed3b211dbbd3ce62fafe", "filename": "gcc/config/ms1/ABI.txt", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2FABI.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2FABI.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2FABI.txt?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,219 +0,0 @@\n-     Copyright (C) 2005 Free Software Foundation, Inc.\n-\n-     Copying and distribution of this file, with or without modification,\n-     are permitted in any medium without royalty provided the copyright\n-     notice and this notice are preserved.\n-\n---------------------------------------------------------------------------\n-\n-\t\t\tMS1 ABI\n-\t\t\t=========\n-\n-Sizes and alignments\n---------------------\n-\n-\tType\t\tSize (bytes)\tAlignment (bytes)\n-\n-\tchar\t\t1\t\t1\n-\tshort\t\t2\t\t2\n-\tint\t\t4\t\t4\n-\tunsigned\t4\t\t4\n-\tlong\t\t4\t\t4 \n-\tlong long\t8\t\t8\n-\tfloat\t\t4\t\t4\n-\tdouble\t\t8\t\t8\n-\tpointers\t4\t\t4 \n-\n-* alignment within aggregates (structs and unions) is as above, with\n-  padding added if needed\n-* aggregates have alignment equal to that of their most aligned\n-  member\n-* aggregates have sizes which are a multiple of their alignment\n-\n-\n-Floating point\n---------------\n-\n-All emulated using IEEE floating point conventions.\n-\n-Registers\n-----------------\n-\n-r0\t\talways zero\n-r1\t\targument register 1\n-r2\t\targument register 2\n-r3\t\targument register 3\n-r4\t\targument register 4\n-r5\t\tcallee must save\n-r6\t\tcallee must save\n-r7\t\tcall clobbers\n-r8\t\tcall clobbers\n-r9\t\tcall clobbers\n-r10\t\tcall clobbers\n-r11\t\tfunction return value\n-r12\t\tframe pointer\n-r13\t\tstack pointer\n-r14\t\tlinkage pointer\n-r15\t\tinterrupt pointer\n-\n-Stack alignment\t\t8 bytes\n-\n-Structures passed\t<= 32 bits as values, else as pointers\n-\n-The MS1 Stack\n----------------\n-\n-Space is allocated as needed in the stack frame for the following at compile\n-time:\n-\n-* Outgoing parameters beyond the fourth\n-\n-* All automatic arrays, automatic data aggregates, automatic\n-  scalars which must be addressable, and automatic scalars for\n-  which there is no room in registers \n-\n-* Compiler-generated temporary values (typically when there are\n-  too many for the compiler to keep them all in registers) \n-\n-Space can be allocated dynamically (at runtime) in the stack frame for the\n-following:\n-\n-* Memory allocated using the alloca() function of the C library\n-\n-Addressable automatic variables on the stack are addressed with positive\n-offsets relative to r12; dynamically allocated space is addressed with positive\n-offsets from the pointer returned by alloca().\n-\n-Stack Frame\n------------\n-\n-        +-----------------------+\n-\t|    Parameter Word 1\t|\n-        +-----------------------+ <-sp\n-\t|    Previous FP\t|\n-\t+-----------------------+\n- \t|    Return address\t|\n-\t+-----------------------+\n-\t|    Saved Registers\t|\n-\t+-----------------------+\n-\t|        ...\t\t|\n-\t+-----------------------+\n-\t|    Local Variables\t|\n-\t+-----------------------+ <-fp\n-\t|    Alloca\t\t|\n-\t+-----------------------+\n-\t|        ...\t\t|\n-\t+-----------------------+\n-\t|   Parameter Word 2\t|\n-\t+-----------------------+\n-\t|   Parameter Word 1\t|\n-\t+-----------------------+ <-sp\n-\n-\n-Parameter Assignment to Registers\n----------------------------------\n-\n-Consider the parameters in a function call as ordered from left (first\n-parameter) to right.  GR contains the number of the next available\n-general-purpose register.  STARG is the address of the next available stack\n-parameter word.\n-\n-INITIALIZE:\n-\tSet GR=r1 and STARG to point to parameter word 1.\n-\n-SCAN:\n-\tIf there are no more parameters, terminate.\n-\tOtherwise, select one of the following depending on the type\n-\tof the next parameter:\n-\n-    SIMPLE ARG:\n-\n-\tA SIMPLE ARG is one of the following:\n-\n-\t* One of the simple integer types which will fit into a\n-\t  general-purpose register,\n-\t* A pointer to an object of any type,\n-\t* A struct or union small enough to fit in a register (<= 32 bits)\n-\t* A larger struct or union, which shall be treated as a\n-\t  pointer to the object or to a copy of the object.\n-\t  (See below for when copies are made.)\n-\n-\tIf GR > r4, go to STACK.  Otherwise, load the parameter value into\n-\tgeneral-purpose register GR and advance GR to the next general-purpose\n-\tregister.  Values shorter than the register size are sign-extended or\n-\tzero-extended depending on whether they are signed or unsigned.  Then\n-\tgo to SCAN.\n-\n-    DOUBLE or LONG LONG\n-\n-\tIf GR > r3, go to STACK.  Otherwise, if GR is odd, advance GR to the\n-\tnext register.  Load the 64-bit long long or double value into register\n-\tpair GR and GR+1.  Advance GR to GR+2 and go to SCAN.\n-\n-    STACK:\n-\n-\tParameters not otherwise handled above are passed in the parameter\n-\twords of the caller's stack frame.  SIMPLE ARGs, as defined above, are\n-\tconsidered to have size and alignment equal to the size of a\n-\tgeneral-purpose register, with simple argument types shorter than this\n-\tsign- or zero-extended to this width.  Round STARG up to a multiple of\n-\tthe alignment requirement of the parameter and copy the argument\n-\tbyte-for-byte into STARG, STARG+1, ...  STARG+size-1.  Set STARG to\n-\tSTARG+size and go to SCAN.\n-\n-\n-Structure passing\n------------------\n-\n-As noted above, code which passes structures and unions by value is implemented\n-specially.  (In this section, \"struct\" will refer to structs and unions\n-inclusively.)  Structs small enough to fit in a register are passed by value in\n-a single register or in a stack frame slot the size of a register.  Structs\n-containing a single double or long long component are passed by value in two\n-registers or in a stack frame slot the size of two registers.  Other structs\n-are handled by passing the address of the structure.  In this case, a copy of\n-the structure will be made if necessary in order to preserve the pass-by-value\n-semantics.\n-\n-Copies of large structs are made under the following rules:\n-\n-\t\t\tANSI mode\t\t\tK&R Mode\n-\t\t\t---------\t\t\t--------\n-Normal param\t \tCallee copies if needed\t\tCaller copies\n-Varargs (...) param\tCaller copies\t\t\tCaller copies\n-\n-In the case of normal (non-varargs) large-struct parameters in ANSI mode, the\n-callee is responsible for producing the same effect as if a copy of the\n-structure were passed, preserving the pass-by-value semantics.  This may be\n-accomplished by having the callee make a copy, but in some cases the callee may\n-be able to determine that a copy is not necessary in order to produce the same\n-results.  In such cases, the callee may choose to avoid making a copy of the\n-parameter.\n-\n-\n-Varargs handling\n-----------------\n-\n-No special changes are needed for handling varargs parameters other than the\n-caller knowing that a copy is needed on struct parameters larger than a\n-register (see above).\n-\n-The varargs macros set up a register save area for the general-purpose\n-registers to be saved.  Because the save area lies between the caller and\n-callee stack frames, the saved register parameters are contiguous with\n-parameters passed on the stack.  A pointer advances from the register save area\n-into the caller's stack frame.\n-\n-\n-Function return values\n-----------------------\n-\n-\tType\t\tRegister\n-\t----\t\t--------\n-\tint\t\tr11\n-\tshort\t\tr11\n-\tlong\t\tr11\n-\tlong long\tstack\n-\tfloat\t\tr11\n-\tdouble\t\tstack\n-"}, {"sha": "115b96e7cb8f7719d7fbe3994682bdfe4f8918fe", "filename": "gcc/config/ms1/crti.asm", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fcrti.asm?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,71 +0,0 @@\n-# crti.asm for ms1\n-#\n-#   Copyright (C) 2005 Free Software Foundation, Inc.\n-# \n-# This file is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option) any\n-# later version.\n-# \n-# In addition to the permissions in the GNU General Public License, the\n-# Free Software Foundation gives you unlimited permission to link the\n-# compiled version of this file with other programs, and to distribute\n-# those programs without any restriction coming from the use of this\n-# file.  (The General Public License restrictions do apply in other\n-# respects; for example, they cover modification of the file, and\n-# distribution when not linked into another program.)\n-# \n-# This file is distributed in the hope that it will be useful, but\n-# WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-# General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING.  If not, write to the Free\n-# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-# 02110-1301, USA.\n-# \n-#    As a special exception, if you link this library with files\n-#    compiled with GCC to produce an executable, this does not cause\n-#    the resulting executable to be covered by the GNU General Public License.\n-#    This exception does not however invalidate any other reasons why\n-#    the executable file might be covered by the GNU General Public License.\n-# \n-\n-# This file just make a stack frame for the contents of the .fini and\n-# .init sections.  Users may put any desired instructions in those\n-# sections.\n-\n-\t.file\t\t\"crti.asm\"\n-\n-\t.section\t\".init\"\n-\t.global\t_init\n-\t.type\t_init,#function\n-\t.align\t4\n-_init:\n-\tsubi\tsp, sp, #4\n-\tstw\tr14, sp, #0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\n-\t.section\t\".fini\"\n-\t.global\t_fini\n-\t.type\t_fini,#function\n-\t.align\t4\n-_fini:\n-\tsubi\tsp, sp, #4\n-\tstw\tr14, sp, #0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0\n-\tor\tr0, r0, r0"}, {"sha": "5fbe7ece9695544f2770f7b94afa94d3a07cca8f", "filename": "gcc/config/ms1/crtn.asm", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fcrtn.asm?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,56 +0,0 @@\n-# crtn.asm for ms1\n-\n-#   Copyright (C) 2005 Free Software Foundation, Inc.\n-# \n-# This file is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option) any\n-# later version.\n-# \n-# In addition to the permissions in the GNU General Public License, the\n-# Free Software Foundation gives you unlimited permission to link the\n-# compiled version of this file with other programs, and to distribute\n-# those programs without any restriction coming from the use of this\n-# file.  (The General Public License restrictions do apply in other\n-# respects; for example, they cover modification of the file, and\n-# distribution when not linked into another program.)\n-# \n-# This file is distributed in the hope that it will be useful, but\n-# WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-# General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING.  If not, write to the Free\n-# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-# 02110-1301, USA.\n-# \n-#    As a special exception, if you link this library with files\n-#    compiled with GCC to produce an executable, this does not cause\n-#    the resulting executable to be covered by the GNU General Public License.\n-#    This exception does not however invalidate any other reasons why\n-#    the executable file might be covered by the GNU General Public License.\n-# \n-\n-# This file just makes sure that the .fini and .init sections do in\n-# fact return.  Users may put any desired instructions in those sections.\n-# This file is the last thing linked into any executable.\n-\n-\t.file\t\t\"crtn.asm\"\n-\n-\t.section\t\".init\"\n-\t.align\t\t4\n-\tldw\tr14, sp, #0\n-\taddi\tsp, sp, #4\n-\tnop\n-\tjal\tr0, r14\n-\tor\tr0, r0, r0\n-\t\n-\t.section\t\".fini\"\n-\t.align\t\t4\n-\n-\tldw\tr14, sp, #0\n-\taddi\tsp, sp, #4\n-\tnop\n-\tjal\tr0, r14\n-\tor\tr0, r0, r0"}, {"sha": "6f5ec6a619ca29134914bf58960e7998161a7f75", "filename": "gcc/config/ms1/lib2extra-funcs.c", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Flib2extra-funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Flib2extra-funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Flib2extra-funcs.c?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,232 +0,0 @@\n-/* Copyright (C) 2005 Free Software Foundation,\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301, USA.  */\n-\n-#define BITS_PER_UNIT\t8\n-\n-typedef \t int HItype\t\t__attribute__ ((mode (HI)));\n-typedef unsigned int UHItype\t\t__attribute__ ((mode (HI)));\n-\n-typedef\t\t int SItype\t\t__attribute__ ((mode (SI)));\n-typedef unsigned int USItype\t\t__attribute__ ((mode (SI)));\n-\n-typedef int word_type\t\t\t__attribute__ ((mode (__word__)));\n-\n-struct SIstruct {HItype low, high;};\n-\n-typedef union\n-{\n-  struct SIstruct s;\n-  SItype ll;\n-} SIunion;\n-\n-SItype\n-__lshrsi3 (SItype u, word_type b)\n-{\n-  SIunion w;\n-  word_type bm;\n-  SIunion uu;\n-\n-  if (b == 0)\n-    return u;\n-\n-  uu.ll = u;\n-\n-  bm = (sizeof (HItype) * BITS_PER_UNIT) - b;\n-  if (bm <= 0)\n-    {\n-      w.s.high = 0;\n-      w.s.low = (UHItype)uu.s.high >> -bm;\n-    }\n-  else\n-    {\n-      UHItype carries = (UHItype)uu.s.high << bm;\n-      w.s.high = (UHItype)uu.s.high >> b;\n-      w.s.low = ((UHItype)uu.s.low >> b) | carries;\n-    }\n-\n-  return w.ll;\n-}\n-\n-SItype\n-__ashlsi3 (SItype u, word_type b)\n-{\n-  SIunion w;\n-  word_type bm;\n-  SIunion uu;\n-\n-  if (b == 0)\n-    return u;\n-\n-  uu.ll = u;\n-\n-  bm = (sizeof (HItype) * BITS_PER_UNIT) - b;\n-  if (bm <= 0)\n-    {\n-      w.s.low = 0;\n-      w.s.high = (UHItype)uu.s.low << -bm;\n-    }\n-  else\n-    {\n-      UHItype carries = (UHItype)uu.s.low >> bm;\n-      w.s.low = (UHItype)uu.s.low << b;\n-      w.s.high = ((UHItype)uu.s.high << b) | carries;\n-    }\n-\n-  return w.ll;\n-}\n-\n-SItype\n-__ashrsi3 (SItype u, word_type b)\n-{\n-  SIunion w;\n-  word_type bm;\n-  SIunion uu;\n-\n-  if (b == 0)\n-    return u;\n-\n-  uu.ll = u;\n-\n-  bm = (sizeof (HItype) * BITS_PER_UNIT) - b;\n-  if (bm <= 0)\n-    {\n-      /* w.s.high = 1..1 or 0..0 */\n-      w.s.high = uu.s.high >> (sizeof (HItype) * BITS_PER_UNIT - 1);\n-      w.s.low = uu.s.high >> -bm;\n-    }\n-  else\n-    {\n-      UHItype carries = (UHItype)uu.s.high << bm;\n-      w.s.high = uu.s.high >> b;\n-      w.s.low = ((UHItype)uu.s.low >> b) | carries;\n-    }\n-\n-  return w.ll;\n-}\n-\n-USItype\n-__mulsi3 (USItype a, USItype b)\n-{\n-  USItype c = 0;\n-\n-  while (a != 0)\n-    {\n-      if (a & 1)\n-\tc += b;\n-      a >>= 1;\n-      b <<= 1;\n-    }\n-\n-  return c;\n-}\n-\n-USItype\n-udivmodsi4(USItype num, USItype den, word_type modwanted)\n-{\n-  USItype bit = 1;\n-  USItype res = 0;\n-\n-  while (den < num && bit && !(den & (1L<<31)))\n-    {\n-      den <<=1;\n-      bit <<=1;\n-    }\n-  while (bit)\n-    {\n-      if (num >= den)\n-\t{\n-\t  num -= den;\n-\t  res |= bit;\n-\t}\n-      bit >>=1;\n-      den >>=1;\n-    }\n-  if (modwanted) return num;\n-  return res;\n-}\n-\n-SItype\n-__divsi3 (SItype a, SItype b)\n-{\n-  word_type neg = 0;\n-  SItype res;\n-\n-  if (a < 0)\n-    {\n-      a = -a;\n-      neg = !neg;\n-    }\n-\n-  if (b < 0)\n-    {\n-      b = -b;\n-      neg = !neg;\n-    }\n-\n-  res = udivmodsi4 (a, b, 0);\n-\n-  if (neg)\n-    res = -res;\n-\n-  return res;\n-}\n-\n-SItype\n-__modsi3 (SItype a, SItype b)\n-{\n-  word_type neg = 0;\n-  SItype res;\n-\n-  if (a < 0)\n-    {\n-      a = -a;\n-      neg = 1;\n-    }\n-\n-  if (b < 0)\n-    b = -b;\n-\n-  res = udivmodsi4 (a, b, 1);\n-\n-  if (neg)\n-    res = -res;\n-\n-  return res;\n-}\n-\n-SItype\n-__udivsi3 (SItype a, SItype b)\n-{\n-  return udivmodsi4 (a, b, 0);\n-}\n-\n-SItype\n-__umodsi3 (SItype a, SItype b)\n-{\n-  return udivmodsi4 (a, b, 1);\n-}"}, {"sha": "c37048263ca99e0c93fd7ae3d47102964084ad8e", "filename": "gcc/config/ms1/mt-protos.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fmt-protos.h?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,66 +0,0 @@\n-/* Prototypes for exported functions defined in ms1.c\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 2, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful,but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-   02110-1301, USA.  */\n-\n-extern void         ms1_init_expanders\t (void);\n-extern void         ms1_expand_prologue\t (void);\n-extern void         ms1_expand_epilogue\t (enum epilogue_type);\n-extern unsigned     ms1_compute_frame_size (int);\n-extern void\t    ms1_override_options (void);\n-extern int\t    ms1_initial_elimination_offset (int, int);\n-extern const char * ms1_asm_output_opcode (FILE *, const char *);\n-extern int          ms1_epilogue_uses\t (int);\n-extern void\t    ms1_add_loop \t (void);\n-\n-#ifdef TREE_CODE\n-extern const char * ms1_cannot_inline_p\t (tree);\n-extern int          ms1_function_arg_boundary (enum machine_mode, tree);\n-extern void         ms1_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree,  int);\n-#endif\n-\n-#ifdef RTX_CODE\n-extern void\t    ms1_expand_eh_return (rtx *);\n-extern void\t    ms1_emit_eh_epilogue (rtx *);\n-extern void         ms1_print_operand\t (FILE *, rtx, int);\n-extern void         ms1_print_operand_address (FILE *, rtx);\n-extern int          ms1_check_split\t (rtx, enum machine_mode);\n-extern int          ms1_reg_ok_for_base_p (rtx, int);\n-extern int          ms1_legitimate_address_p (enum machine_mode, rtx, int);\n-/* Predicates for machine description.  */\n-extern int          uns_arith_operand\t (rtx, enum machine_mode);\n-extern int          arith_operand\t (rtx, enum machine_mode);\n-extern int          reg_or_0_operand\t (rtx, enum machine_mode);\n-extern int\t    big_const_operand\t (rtx, enum machine_mode);\n-extern int\t    single_const_operand (rtx, enum machine_mode);\n-extern void\t    ms1_emit_cbranch\t (enum rtx_code, rtx, rtx, rtx);\n-extern void\t    ms1_set_memflags\t (rtx);\n-extern rtx\t    ms1_return_addr_rtx\t (int);\n-extern void\t    ms1_split_words\t (enum machine_mode, enum machine_mode, rtx *);\n-extern void\t    ms1_final_prescan_insn (rtx, rtx *, int);\n-#endif\n-\n-#ifdef TREE_CODE\n-#ifdef RTX_CODE\n-extern void         ms1_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n-extern rtx          ms1_function_arg\t (const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int);\n-extern void\t    ms1_va_start\t (tree, rtx);\n-extern enum reg_class ms1_secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n-extern rtx\t    ms1_function_value\t (tree, enum machine_mode, tree);\n-#endif\n-#endif"}, {"sha": "3695f0fb8b483b1f27a0b3e9b6cee3e4c51f9512", "filename": "gcc/config/ms1/mt.c", "status": "removed", "additions": 0, "deletions": 2498, "changes": 2498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fmt.c?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,2498 +0,0 @@\n-/* Target definitions for the MorphoRISC1\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n-   Contributed by Red Hat, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 2, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-   02110-1301, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-attr.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"output.h\"\n-#include \"integrate.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"libfuncs.h\"\n-#include \"flags.h\"\n-#include \"tm_p.h\"\n-#include \"ggc.h\"\n-#include \"insn-flags.h\"\n-#include \"obstack.h\"\n-#include \"except.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"basic-block.h\"\n-\n-/* Frame pointer register mask.  */\n-#define FP_MASK\t\t \t (1 << (GPR_FP))\n-\n-/* Link register mask.  */\n-#define LINK_MASK\t \t (1 << (GPR_LINK))\n-\n-/* First GPR.  */\n-#define MS1_INT_ARG_FIRST 1\n-\n-/* Given a SIZE in bytes, advance to the next word.  */\n-#define ROUND_ADVANCE(SIZE) (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* A C structure for machine-specific, per-function data.\n-   This is added to the cfun structure.  */\n-struct machine_function GTY(())\n-{\n-  /* Flags if __builtin_return_address (n) with n >= 1 was used.  */\n-  int ra_needs_full_frame;\n-  struct rtx_def * eh_stack_adjust;\n-  int interrupt_handler;\n-  int has_loops;\n-};\n-\n-/* Define the information needed to generate branch and scc insns.\n-   This is stored from the compare operation.  */\n-struct rtx_def * ms1_compare_op0;\n-struct rtx_def * ms1_compare_op1;\n-\n-/* Current frame information calculated by compute_frame_size.  */\n-struct ms1_frame_info current_frame_info;\n-\n-/* Zero structure to initialize current_frame_info.  */\n-struct ms1_frame_info zero_frame_info;\n-\n-/* ms1 doesn't have unsigned compares need a library call for this.  */\n-struct rtx_def * ms1_ucmpsi3_libcall;\n-\n-static int ms1_flag_delayed_branch;\n-\n-\f\n-static rtx\n-ms1_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n-\t\t\t int incoming ATTRIBUTE_UNUSED)\n-{\n-  return gen_rtx_REG (Pmode, RETVAL_REGNUM);\n-}\n-\n-/* Implement RETURN_ADDR_RTX.  */\n-rtx\n-ms1_return_addr_rtx (int count)\n-{\n-  if (count != 0)\n-    return NULL_RTX;\n-\n-  return get_hard_reg_initial_val (Pmode, GPR_LINK);\n-}\n-\n-/* The following variable value indicates the number of nops required\n-   between the current instruction and the next instruction to avoid\n-   any pipeline hazards.  */\n-static int ms1_nops_required = 0;\n-static const char * ms1_nop_reasons = \"\";\n-\n-/* Implement ASM_OUTPUT_OPCODE.  */\n-const char *\n-ms1_asm_output_opcode (FILE *f ATTRIBUTE_UNUSED, const char *ptr)\n-{\n-  if (ms1_nops_required)\n-    fprintf (f, \";# need %d nops because of %s\\n\\t\",\n-\t     ms1_nops_required, ms1_nop_reasons);\n-  \n-  while (ms1_nops_required)\n-    {\n-      fprintf (f, \"or r0, r0, r0\\n\\t\");\n-      -- ms1_nops_required;\n-    }\n-  \n-  return ptr;\n-}\n-\n-/* Given an insn, return whether it's a memory operation or a branch\n-   operation, otherwise return TYPE_ARITH.  */\n-static enum attr_type\n-ms1_get_attr_type (rtx complete_insn)\n-{\n-  rtx insn = PATTERN (complete_insn);\n-\n-  if (JUMP_P (complete_insn))\n-    return TYPE_BRANCH;\n-  if (CALL_P (complete_insn))\n-    return TYPE_BRANCH;\n-\n-  if (GET_CODE (insn) != SET)\n-    return TYPE_ARITH;\n-\n-  if (SET_DEST (insn) == pc_rtx)\n-    return TYPE_BRANCH;\n-\n-  if (GET_CODE (SET_DEST (insn)) == MEM)\n-    return TYPE_STORE;\n-\n-  if (GET_CODE (SET_SRC (insn)) == MEM)\n-    return TYPE_LOAD;\n-  \n-  return TYPE_ARITH;\n-}\n-\n-/* A helper routine for insn_dependent_p called through note_stores.  */\n-\n-static void\n-insn_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n-{\n-  rtx * pinsn = (rtx *) data;\n-\n-  if (*pinsn && reg_mentioned_p (x, *pinsn))\n-    *pinsn = NULL_RTX;\n-}\n-\n-/* Return true if anything in insn X is (anti,output,true)\n-   dependent on anything in insn Y.  */\n-\n-static bool\n-insn_dependent_p (rtx x, rtx y)\n-{\n-  rtx tmp;\n-\n-  if (! INSN_P (x) || ! INSN_P (y))\n-    return 0;\n-\n-  tmp = PATTERN (y);\n-  note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n-  if (tmp == NULL_RTX)\n-    return true;\n-\n-  tmp = PATTERN (x);\n-  note_stores (PATTERN (y), insn_dependent_p_1, &tmp);\n-  return (tmp == NULL_RTX);\n-}\n-\n-\n-/* Return true if anything in insn X is true dependent on anything in\n-   insn Y.  */\n-static bool\n-insn_true_dependent_p (rtx x, rtx y)\n-{\n-  rtx tmp;\n-\n-  if (! INSN_P (x) || ! INSN_P (y))\n-    return 0;\n-\n-  tmp = PATTERN (y);\n-  note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n-  return (tmp == NULL_RTX);\n-}\n-\n-/* The following determines the number of nops that need to be\n-   inserted between the previous instructions and current instruction\n-   to avoid pipeline hazards on the ms1 processor.  Remember that\n-   the function is not called for asm insns.  */\n-\n-void\n-ms1_final_prescan_insn (rtx   insn,\n-\t\t\trtx * opvec ATTRIBUTE_UNUSED,\n-\t\t\tint   noperands ATTRIBUTE_UNUSED)\n-{\n-  rtx prev_i;\n-  enum attr_type prev_attr;\n-\n-  ms1_nops_required = 0;\n-  ms1_nop_reasons = \"\";\n-\n-  /* ms2 constraints are dealt with in reorg.  */\n-  if (ms1_cpu == PROCESSOR_MS2)\n-    return;\n-  \n-  /* Only worry about real instructions.  */\n-  if (! INSN_P (insn))\n-    return;\n-\n-  /* Find the previous real instructions.  */\n-  for (prev_i = PREV_INSN (insn);\n-       prev_i != NULL\n-\t && (! INSN_P (prev_i)\n-\t     || GET_CODE (PATTERN (prev_i)) == USE\n-\t     || GET_CODE (PATTERN (prev_i)) == CLOBBER);\n-       prev_i = PREV_INSN (prev_i))\n-    {\n-      /* If we meet a barrier, there is no flow through here.  */\n-      if (BARRIER_P (prev_i))\n-\treturn;\n-    }\n-  \n-  /* If there isn't one then there is nothing that we need do.  */\n-  if (prev_i == NULL || ! INSN_P (prev_i))\n-    return;\n-\n-  prev_attr = ms1_get_attr_type (prev_i);\n-  \n-  /* Delayed branch slots already taken care of by delay branch scheduling.  */\n-  if (prev_attr == TYPE_BRANCH)\n-    return;\n-\n-  switch (ms1_get_attr_type (insn))\n-    {\n-    case TYPE_LOAD:\n-    case TYPE_STORE:\n-      /* Avoid consecutive memory operation.  */\n-      if  ((prev_attr == TYPE_LOAD || prev_attr == TYPE_STORE)\n-\t   && ms1_cpu == PROCESSOR_MS1_64_001)\n-\t{\n-\t  ms1_nops_required = 1;\n-\t  ms1_nop_reasons = \"consecutive mem ops\";\n-\t}\n-      /* Drop through.  */\n-\n-    case TYPE_ARITH:\n-    case TYPE_COMPLEX:\n-      /* One cycle of delay is required between load\n-\t and the dependent arithmetic instruction.  */\n-      if (prev_attr == TYPE_LOAD\n-\t  && insn_true_dependent_p (prev_i, insn))\n-\t{\n-\t  ms1_nops_required = 1;\n-\t  ms1_nop_reasons = \"load->arith dependency delay\";\n-\t}\n-      break;\n-\n-    case TYPE_BRANCH:\n-      if (insn_dependent_p (prev_i, insn))\n-\t{\n-\t  if (prev_attr == TYPE_ARITH\n-\t      && ms1_cpu == PROCESSOR_MS1_64_001)\n-\t    {\n-\t      /* One cycle of delay between arith\n-\t\t instructions and branch dependent on arith.  */\n-\t      ms1_nops_required = 1;\n-\t      ms1_nop_reasons = \"arith->branch dependency delay\";\n-\t    }\n-\t  else if (prev_attr == TYPE_LOAD)\n-\t    {\n-\t      /* Two cycles of delay are required\n-\t\t between load and dependent branch.  */\n-\t      if (ms1_cpu == PROCESSOR_MS1_64_001)\n-\t\tms1_nops_required = 2;\n-\t      else\n-\t\tms1_nops_required = 1;\n-\t      ms1_nop_reasons = \"load->branch dependency delay\";\n-\t    }\n-\t}\n-      break;\n-\n-    default:\n-      fatal_insn (\"ms1_final_prescan_insn, invalid insn #1\", insn);\n-      break;\n-    }\n-}\n-\n-/* Print debugging information for a frame.  */\n-static void\n-ms1_debug_stack (struct ms1_frame_info * info)\n-{\n-  int regno;\n-\n-  if (!info)\n-    {\n-      error (\"info pointer NULL\");\n-      gcc_unreachable ();\n-    }\n-\n-  fprintf (stderr, \"\\nStack information for function %s:\\n\",\n-\t   ((current_function_decl && DECL_NAME (current_function_decl))\n-\t    ? IDENTIFIER_POINTER (DECL_NAME (current_function_decl))\n-\t    : \"<unknown>\"));\n-\n-  fprintf (stderr, \"\\ttotal_size       = %d\\n\", info->total_size);\n-  fprintf (stderr, \"\\tpretend_size     = %d\\n\", info->pretend_size);\n-  fprintf (stderr, \"\\targs_size        = %d\\n\", info->args_size);\n-  fprintf (stderr, \"\\textra_size       = %d\\n\", info->extra_size);\n-  fprintf (stderr, \"\\treg_size         = %d\\n\", info->reg_size);\n-  fprintf (stderr, \"\\tvar_size         = %d\\n\", info->var_size);\n-  fprintf (stderr, \"\\tframe_size       = %d\\n\", info->frame_size);\n-  fprintf (stderr, \"\\treg_mask         = 0x%x\\n\", info->reg_mask);\n-  fprintf (stderr, \"\\tsave_fp          = %d\\n\", info->save_fp);\n-  fprintf (stderr, \"\\tsave_lr          = %d\\n\", info->save_lr);\n-  fprintf (stderr, \"\\tinitialized      = %d\\n\", info->initialized);\n-  fprintf (stderr, \"\\tsaved registers =\");\n-\n-  /* Print out reg_mask in a more readable format.  */\n-  for (regno = GPR_R0; regno <= GPR_LAST; regno++)\n-    if ( (1 << regno) & info->reg_mask)\n-      fprintf (stderr, \" %s\", reg_names[regno]);\n-\n-  putc ('\\n', stderr);\n-  fflush (stderr);\n-}\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-static void\n-ms1_print_operand_simple_address (FILE * file, rtx addr)\n-{\n-  if (!addr)\n-    error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n-\n-  else\n-    switch (GET_CODE (addr))\n-      {\n-      case REG:\n-\tfprintf (file, \"%s, #0\", reg_names [REGNO (addr)]);\n-\tbreak;\n-\t\n-      case PLUS:\n-\t{\n-\t  rtx reg = 0;\n-\t  rtx offset = 0;\n-\t  rtx arg0 = XEXP (addr, 0);\n-\t  rtx arg1 = XEXP (addr, 1);\n-\n-\t  if (GET_CODE (arg0) == REG)\n-\t    {\n-\t      reg = arg0;\n-\t      offset = arg1;\n-\t      if (GET_CODE (offset) == REG)\n-\t\tfatal_insn (\"PRINT_OPERAND_ADDRESS, 2 regs\", addr);\n-\t    }\n-\n-\t  else if (GET_CODE (arg1) == REG)\n-\t      reg = arg1, offset = arg0;\n-\t  else if (CONSTANT_P (arg0) && CONSTANT_P (arg1))\n-\t    {\n-\t      fprintf (file, \"%s, #\", reg_names [GPR_R0]);\n-\t      output_addr_const (file, addr);\n-\t      break;\n-\t    }\n-\t  fprintf (file, \"%s, #\", reg_names [REGNO (reg)]);\n-\t  output_addr_const (file, offset);\n-\t  break;\n-\t}\n-\n-      case LABEL_REF:\n-      case SYMBOL_REF:\n-      case CONST_INT:\n-      case CONST:\n-\toutput_addr_const (file, addr);\n-\tbreak;\n-\n-      default:\n-\tfatal_insn (\"PRINT_OPERAND_ADDRESS, invalid insn #1\", addr);\n-\tbreak;\n-      }\n-}\n-\n-/* Implement PRINT_OPERAND_ADDRESS.  */\n-void\n-ms1_print_operand_address (FILE * file, rtx addr)\n-{\n-  if (GET_CODE (addr) == AND\n-      && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-      && INTVAL (XEXP (addr, 1)) == -3)\n-    ms1_print_operand_simple_address (file, XEXP (addr, 0));\n-  else\n-    ms1_print_operand_simple_address (file, addr);\n-}\n-\n-/* Implement PRINT_OPERAND.  */\n-void\n-ms1_print_operand (FILE * file, rtx x, int code)\n-{\n-  switch (code)\n-    {\n-    case '#':\n-      /* Output a nop if there's nothing for the delay slot.  */\n-      if (dbr_sequence_length () == 0)\n-\tfputs (\"\\n\\tor r0, r0, r0\", file);\n-      return;\n-      \n-    case 'H': \n-      fprintf(file, \"#%%hi16(\");\n-      output_addr_const (file, x);\n-      fprintf(file, \")\");\n-      return;\n-      \n-    case 'L': \n-      fprintf(file, \"#%%lo16(\");\n-      output_addr_const (file, x);\n-      fprintf(file, \")\");\n-      return;\n-\n-    case 'N': \n-      fprintf(file, \"#%ld\", ~INTVAL (x));\n-      return;\n-\n-    case 'z':\n-      if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0)\n-\t{\n-\t  fputs (reg_names[GPR_R0], file);\n-\t  return;\n-\t}\n-\n-    case 0:\n-      /* Handled below.  */\n-      break;\n-\n-    default:\n-      /* output_operand_lossage (\"ms1_print_operand: unknown code\"); */\n-      fprintf (file, \"unknown code\");\n-      return;\n-    }\n-\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      fputs (reg_names [REGNO (x)], file);\n-      break;\n-\n-    case CONST:\n-    case CONST_INT:\n-      fprintf(file, \"#%ld\", INTVAL (x));\n-      break;\n-\n-    case MEM:\n-      ms1_print_operand_address(file, XEXP (x,0));\n-      break;\n-\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      output_addr_const (file, x);\n-      break;\n-      \n-    default:\n-      fprintf(file, \"Uknown code: %d\", GET_CODE (x));\n-      break;\n-    }\n-\n-  return;\n-}\n-\n-/* Implement INIT_CUMULATIVE_ARGS.  */\n-void\n-ms1_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype, rtx libname,\n-\t\t\t     tree fndecl ATTRIBUTE_UNUSED, int incoming)\n-{\n-  *cum = 0;\n-\n-  if (TARGET_DEBUG_ARG)\n-    {\n-      fprintf (stderr, \"\\nms1_init_cumulative_args:\");\n-\n-      if (incoming)\n-\tfputs (\" incoming\", stderr);\n-\n-      if (fntype)\n-\t{\n-\t  tree ret_type = TREE_TYPE (fntype);\n-\t  fprintf (stderr, \" return = %s,\",\n-\t\t   tree_code_name[ (int)TREE_CODE (ret_type) ]);\n-\t}\n-\n-      if (libname && GET_CODE (libname) == SYMBOL_REF)\n-\tfprintf (stderr, \" libname = %s\", XSTR (libname, 0));\n-\n-      if (cfun->returns_struct)\n-\tfprintf (stderr, \" return-struct\");\n-\n-      putc ('\\n', stderr);\n-    }\n-}\n-\n-/* Compute the slot number to pass an argument in.\n-   Returns the slot number or -1 if passing on the stack.\n-\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-   INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.\n-   *PREGNO records the register number to use if scalar type.  */\n-\n-static int\n-ms1_function_arg_slotno (const CUMULATIVE_ARGS * cum,\n-\t\t\t    enum machine_mode mode,\n-\t\t\t    tree type,\n-\t\t\t    int named ATTRIBUTE_UNUSED,\n-\t\t\t    int incoming_p ATTRIBUTE_UNUSED,\n-\t\t\t    int * pregno)\n-{\n-  int regbase = MS1_INT_ARG_FIRST;\n-  int slotno  = * cum;\n-\n-  if (mode == VOIDmode || targetm.calls.must_pass_in_stack (mode, type))\n-    return -1;\n-\n-  if (slotno >= MS1_NUM_ARG_REGS)\n-    return -1;\n-\n-  * pregno = regbase + slotno;\n-\n-  return slotno;\n-}\n-\n-/* Implement FUNCTION_ARG.  */\n-rtx\n-ms1_function_arg (const CUMULATIVE_ARGS * cum,\n-\t\t  enum machine_mode mode,\n-\t\t  tree type,\n-\t\t  int named,\n-\t\t  int incoming_p)\n-{\n-  int slotno, regno;\n-  rtx reg;\n-\n-  slotno = ms1_function_arg_slotno (cum, mode, type, named, incoming_p, \n-\t\t\t\t       & regno);\n-\n-  if (slotno == -1)\n-    reg = NULL_RTX;\n-  else\n-    reg = gen_rtx_REG (mode, regno);\n-\n-  return reg;\n-}\n-\n-/* Implement FUNCTION_ARG_ADVANCE.  */\n-void\n-ms1_function_arg_advance (CUMULATIVE_ARGS * cum,\n-\t\t\t  enum machine_mode mode,\n-\t\t\t  tree type ATTRIBUTE_UNUSED,\n-\t\t\t  int named)\n-{\n-  int slotno, regno;\n-\n-  /* We pass 0 for incoming_p here, it doesn't matter.  */\n-  slotno = ms1_function_arg_slotno (cum, mode, type, named, 0, &regno);\n-\n-  * cum += (mode != BLKmode\n-\t    ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n-\t    : ROUND_ADVANCE (int_size_in_bytes (type)));\n-\n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr,\n-\t     \"ms1_function_arg_advance: words = %2d, mode = %4s, named = %d, size = %3d\\n\",\n-\t     *cum, GET_MODE_NAME (mode), named, \n-\t     (*cum) * UNITS_PER_WORD);\n-}\n-\n-/* Implement hook TARGET_ARG_PARTIAL_BYTES.\n-\n-   Returns the number of bytes at the beginning of an argument that\n-   must be put in registers.  The value must be zero for arguments\n-   that are passed entirely in registers or that are entirely pushed\n-   on the stack.  */\n-static int\n-ms1_arg_partial_bytes (CUMULATIVE_ARGS * pcum,\n-\t\t       enum machine_mode mode,\n-\t\t       tree type,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n-{\n-  int cum = * pcum;\n-  int words;\n-\n-  if (mode == BLKmode)\n-    words = ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n-\t     / UNITS_PER_WORD);\n-  else\n-    words = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (! targetm.calls.pass_by_reference (& cum, mode, type, named)\n-      && cum < MS1_NUM_ARG_REGS\n-      && (cum + words) > MS1_NUM_ARG_REGS)\n-    {\n-      int bytes = (MS1_NUM_ARG_REGS - cum) * UNITS_PER_WORD; \n-\n-      if (TARGET_DEBUG)\n-\tfprintf (stderr, \"function_arg_partial_nregs = %d\\n\", bytes);\n-      return bytes;\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* Implement TARGET_PASS_BY_REFERENCE hook.  */\n-static bool\n-ms1_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       tree type,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n-{\n-  return (type && int_size_in_bytes (type) > 4 * UNITS_PER_WORD);\n-}\n-\n-/* Implement FUNCTION_ARG_BOUNDARY.  */\n-int\n-ms1_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t   tree type ATTRIBUTE_UNUSED)\n-{\n-  return BITS_PER_WORD;\n-}\n-\n-/* Implement REG_OK_FOR_BASE_P.  */\n-int\n-ms1_reg_ok_for_base_p (rtx x, int strict)\n-{\n-  if (strict)\n-    return  (((unsigned) REGNO (x)) < FIRST_PSEUDO_REGISTER);\n-  return 1;\n-}\n-\n-/* Helper function of ms1_legitimate_address_p.  Return true if XINSN\n-   is a simple address, otherwise false.  */\n-static bool\n-ms1_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\t rtx xinsn,\n-\t\t\t\t int strict)\n-{\n-  if (TARGET_DEBUG)\t\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      fprintf (stderr, \"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\n-\t       strict ? \"\" : \"not \");\n-      debug_rtx (xinsn);\n-    }\n-\n-  if (GET_CODE (xinsn) == REG && ms1_reg_ok_for_base_p (xinsn, strict))\n-    return true;\n-\n-  if (GET_CODE (xinsn) == PLUS\n-      && GET_CODE (XEXP (xinsn, 0)) == REG\n-      && ms1_reg_ok_for_base_p (XEXP (xinsn, 0), strict)\n-      && GET_CODE (XEXP (xinsn, 1)) == CONST_INT\n-      && SMALL_INT (XEXP (xinsn, 1)))\n-    return true;\n-\n-  return false;\n-}\n-\n-\n-/* Helper function of GO_IF_LEGITIMATE_ADDRESS.  Return non-zero if\n-   XINSN is a legitimate address on MS1.  */\n-int\n-ms1_legitimate_address_p (enum machine_mode mode,\n-\t\t\t  rtx xinsn,\n-\t\t\t  int strict)\n-{\n-  if (ms1_legitimate_simple_address_p (mode, xinsn, strict))\n-    return 1;\n-\n-  if ((mode) == SImode\n-      && GET_CODE (xinsn) == AND\n-      && GET_CODE (XEXP (xinsn, 1)) == CONST_INT\n-      && INTVAL (XEXP (xinsn, 1)) == -3)\n-    return ms1_legitimate_simple_address_p (mode, XEXP (xinsn, 0), strict);\n-  else\n-    return 0;\n-}\n-\n-/* Return truth value of whether OP can be used as an operands where a\n-   register or 16 bit unsigned integer is needed.  */\n-\n-int\n-uns_arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n-    return 1;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return truth value of whether OP can be used as an operands where a\n-   16 bit integer is needed.  */\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-    return 1;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return truth value of whether OP is a register or the constant 0.  */\n-\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      return INTVAL (op) == 0;\n-\n-    case REG:\n-    case SUBREG:\n-      return register_operand (op, mode);\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return truth value of whether OP is a constant that requires two\n-   loads to put in a register.  */\n-\n-int\n-big_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_LETTER_P (INTVAL (op), 'M'))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return truth value of whether OP is a constant that require only\n-   one load to put in a register.  */\n-\n-int\n-single_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (big_const_operand (op, mode)\n-      || GET_CODE (op) == CONST\n-      || GET_CODE (op) == LABEL_REF\n-      || GET_CODE (op) == SYMBOL_REF)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* True if the current function is an interrupt handler\n-   (either via #pragma or an attribute specification).  */\n-int interrupt_handler;\n-enum processor_type ms1_cpu;\n-\n-static struct machine_function *\n-ms1_init_machine_status (void)\n-{\n-  struct machine_function *f;\n-\n-  f = ggc_alloc_cleared (sizeof (struct machine_function));\n-\n-  return f;\n-}\n-\n-/* Implement OVERRIDE_OPTIONS.  */\n-void\n-ms1_override_options (void)\n-{\n-  if (ms1_cpu_string != NULL)\n-    {\n-      if (!strcasecmp (ms1_cpu_string, \"MS1-64-001\"))\n-\tms1_cpu = PROCESSOR_MS1_64_001;\n-      else if (!strcasecmp (ms1_cpu_string, \"MS1-16-002\"))\n-\tms1_cpu = PROCESSOR_MS1_16_002;\n-      else if  (!strcasecmp (ms1_cpu_string, \"MS1-16-003\"))\n-\tms1_cpu = PROCESSOR_MS1_16_003;\n-      else if (!strcasecmp (ms1_cpu_string, \"MS2\"))\n-\tms1_cpu = PROCESSOR_MS2;\n-      else\n-\terror (\"bad value (%s) for -march= switch\", ms1_cpu_string);\n-    }\n-  else\n-    ms1_cpu = PROCESSOR_MS2;\n-\n-  if (flag_exceptions)\n-    {\n-      flag_omit_frame_pointer = 0;\n-      flag_gcse = 0;\n-    }\n-\n-  /* We do delayed branch filling in machine dependent reorg */\n-  ms1_flag_delayed_branch = flag_delayed_branch;\n-  flag_delayed_branch = 0;\n-\n-  init_machine_status = ms1_init_machine_status;\n-}\n-\n-/* Do what is necessary for `va_start'.  We look at the current function\n-   to determine if stdarg or varargs is used and return the address of the\n-   first unnamed parameter.  */\n-\n-static rtx\n-ms1_builtin_saveregs (void)\n-{\n-  int first_reg = 0;\n-  rtx address;\n-  int regno;\n-\n-  for (regno = first_reg; regno < MS1_NUM_ARG_REGS; regno ++)\n-    emit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t       gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n-\t\t\t\t\t       GEN_INT (UNITS_PER_WORD * regno))),\n-\t\t    gen_rtx_REG (word_mode,\n-\t\t\t\t MS1_INT_ARG_FIRST + regno));\n-\n-  address = gen_rtx_PLUS (Pmode,\n-\t\t\t  gen_rtx_REG (SImode, ARG_POINTER_REGNUM),\n-\t\t\t  GEN_INT (UNITS_PER_WORD * first_reg));\n-  return address;\n-}\n-\n-/* Implement `va_start'.  */\n-\n-void\n-ms1_va_start (tree valist, rtx nextarg)\n-{\n-  ms1_builtin_saveregs ();\n-  std_expand_builtin_va_start (valist, nextarg);\n-}\n-\n-/* Returns the number of bytes offset between the frame pointer and the stack\n-   pointer for the current function.  SIZE is the number of bytes of space\n-   needed for local variables.  */\n-\n-unsigned int\n-ms1_compute_frame_size (int size)\n-{\n-  int           regno;\n-  unsigned int  total_size;\n-  unsigned int  var_size;\n-  unsigned int  args_size;\n-  unsigned int  pretend_size;\n-  unsigned int  extra_size;\n-  unsigned int  reg_size;\n-  unsigned int  frame_size;\n-  unsigned int  reg_mask;\n-\n-  var_size      = size;\n-  args_size     = current_function_outgoing_args_size;\n-  pretend_size  = current_function_pretend_args_size;\n-  extra_size    = FIRST_PARM_OFFSET (0);\n-  total_size    = extra_size + pretend_size + args_size + var_size;\n-  reg_size      = 0;\n-  reg_mask\t= 0;\n-\n-  /* Calculate space needed for registers.  */\n-  for (regno = GPR_R0; regno <= GPR_LAST; regno++)\n-    {\n-      if (MUST_SAVE_REGISTER (regno))\n-        {\n-          reg_size += UNITS_PER_WORD;\n-          reg_mask |= 1 << regno;\n-        }\n-    }\n-\n-  current_frame_info.save_fp = (regs_ever_live [GPR_FP]\n-\t\t\t\t|| frame_pointer_needed\n-\t\t\t\t|| interrupt_handler);\n-  current_frame_info.save_lr = (regs_ever_live [GPR_LINK]\n-\t\t\t\t|| profile_flag\n-\t\t\t\t|| interrupt_handler);\n- \n-  reg_size += (current_frame_info.save_fp + current_frame_info.save_lr)\n-               * UNITS_PER_WORD;\n-  total_size += reg_size;\n-  total_size = ((total_size + 3) & ~3);\n-\n-  frame_size = total_size;\n-\n-  /* Save computed information.  */\n-  current_frame_info.pretend_size = pretend_size;\n-  current_frame_info.var_size     = var_size;\n-  current_frame_info.args_size    = args_size;\n-  current_frame_info.reg_size     = reg_size;\n-  current_frame_info.frame_size   = args_size + var_size;\n-  current_frame_info.total_size   = total_size;\n-  current_frame_info.extra_size   = extra_size;\n-  current_frame_info.reg_mask     = reg_mask;\n-  current_frame_info.initialized  = reload_completed;\n- \n-  return total_size;\n-}\n-\n-/* Emit code to save REG in stack offset pointed to by MEM.\n-   STACK_OFFSET is the offset from the SP where the save will happen.\n-   This function sets the REG_FRAME_RELATED_EXPR note accordingly.  */\n-static void\n-ms1_emit_save_restore (enum save_direction direction,\n-\t\t       rtx reg,\n-\t\t       rtx mem,\n-\t\t       int stack_offset)\n-{\n-  if (direction == FROM_PROCESSOR_TO_MEM)\n-    {\n-      rtx insn;\n-  \n-      insn = emit_move_insn (mem, reg);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      REG_NOTES (insn)\n-\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t     gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t  gen_rtx_MEM\n-\t\t\t\t\t  (SImode,\n-\t\t\t\t\t   gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t\t\t GEN_INT (stack_offset))),\n-\t\t\t\t\t  reg),\n-\t\t\t     REG_NOTES (insn));\n-    }\n-  else\n-    emit_move_insn (reg, mem);\n-}\n-\n-\n-/* Emit code to save the frame pointer in the prologue and restore\n-   frame pointer in epilogue.  */\n-\n-static void\n-ms1_emit_save_fp (enum save_direction direction,\n-\t\t  struct ms1_frame_info info)\n-{\n-  rtx base_reg;\n-  int reg_mask = info.reg_mask  & ~(FP_MASK | LINK_MASK);\n-  int offset = info.total_size;\n-  int stack_offset = info.total_size;\n-\n-  /* If there is nothing to save, get out now.  */\n-  if (! info.save_fp && ! info.save_lr && ! reg_mask)\n-    return;\n-\n-  /* If offset doesn't fit in a 15-bit signed integer,\n-     uses a scratch registers to get a smaller offset.  */\n-  if (CONST_OK_FOR_LETTER_P(offset, 'O'))\n-    base_reg = stack_pointer_rtx;\n-  else\n-    {\n-      /* Use the scratch register R9 that holds old stack pointer.  */\n-      base_reg = gen_rtx_REG (SImode, GPR_R9);\n-      offset = 0;\n-    }\n-\n-  if (info.save_fp)\n-    {\n-      offset -= UNITS_PER_WORD;\n-      stack_offset -= UNITS_PER_WORD;\n-      ms1_emit_save_restore (direction, gen_rtx_REG (SImode, GPR_FP),\n-\t     gen_rtx_MEM (SImode, \n-\t\t\t  gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n-\t     stack_offset);\n-    }\n-}\n-\n-/* Emit code to save registers in the prologue and restore register\n-   in epilogue.  */\n-\n-static void\n-ms1_emit_save_regs (enum save_direction direction,\n-\t\t    struct ms1_frame_info info)\n-{\n-  rtx base_reg;\n-  int regno;\n-  int reg_mask = info.reg_mask  & ~(FP_MASK | LINK_MASK);\n-  int offset = info.total_size;\n-  int stack_offset = info.total_size;\n-\n-  /* If there is nothing to save, get out now.  */\n-  if (! info.save_fp && ! info.save_lr && ! reg_mask)\n-    return;\n-\n-  /* If offset doesn't fit in a 15-bit signed integer,\n-     uses a scratch registers to get a smaller offset.  */\n-  if (CONST_OK_FOR_LETTER_P(offset, 'O'))\n-    base_reg = stack_pointer_rtx;\n-  else\n-    {\n-      /* Use the scratch register R9 that holds old stack pointer.  */\n-      base_reg = gen_rtx_REG (SImode, GPR_R9);\n-      offset = 0;\n-    }\n-\n-  if (info.save_fp)\n-    {\n-      /* This just records the space for it, the actual move generated in\n-\t ms1_emit_save_fp ().  */\n-      offset -= UNITS_PER_WORD;\n-      stack_offset -= UNITS_PER_WORD;\n-    }\n-\n-  if (info.save_lr)\n-    {\n-      offset -= UNITS_PER_WORD;\n-      stack_offset -= UNITS_PER_WORD;\n-      ms1_emit_save_restore (direction, gen_rtx_REG (SImode, GPR_LINK), \n-\t\tgen_rtx_MEM (SImode,\n-\t\t\t     gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n-\t\tstack_offset);\n-    }\n-\n-  /* Save any needed call-saved regs.  */\n-  for (regno = GPR_R0; regno <= GPR_LAST; regno++)\n-    {\n-      if ((reg_mask & (1 << regno)) != 0)\n-\t{\n-\t  offset -= UNITS_PER_WORD;\n-\t  stack_offset -= UNITS_PER_WORD;\n-\t  ms1_emit_save_restore (direction, gen_rtx_REG (SImode, regno),\n-\t\t\t\t    gen_rtx_MEM (SImode,\n-\t\t\t\t\t\t gen_rtx_PLUS (SImode, base_reg, GEN_INT (offset))),\n-\t\t\t\t    stack_offset);\n-\t}\n-    }\n-}\n-\n-/* Return true if FUNC is a function with the 'interrupt' attribute.  */\n-static bool\n-ms1_interrupt_function_p (tree func)\n-{\n-  tree a;\n-\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    return false;\n-\n-  a = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (func));\n-  return a != NULL_TREE;\n-}\n-\n-/* Generate prologue code.  */\n-void\n-ms1_expand_prologue (void)\n-{\n-  rtx size_rtx, insn;\n-  unsigned int frame_size;\n-\n-  if (ms1_interrupt_function_p (current_function_decl))\n-    {\n-      interrupt_handler = 1;\n-      if (cfun->machine)\n-\tcfun->machine->interrupt_handler = 1;\n-    }\n-\n-  ms1_compute_frame_size (get_frame_size ());\n-\n-  if (TARGET_DEBUG_STACK)\n-    ms1_debug_stack (&current_frame_info);\n-\n-  /* Compute size of stack adjustment.  */\n-  frame_size = current_frame_info.total_size;\n-\n-  /* If offset doesn't fit in a 15-bit signed integer,\n-     uses a scratch registers to get a smaller offset.  */\n-  if (CONST_OK_FOR_LETTER_P(frame_size, 'O'))\n-    size_rtx = GEN_INT (frame_size);\n-  else\n-    {\n-      /* We do not have any scratch registers.  */\n-      gcc_assert (!interrupt_handler);\n-\n-      size_rtx = gen_rtx_REG (SImode, GPR_R9);\n-      insn = emit_move_insn (size_rtx, GEN_INT (frame_size & 0xffff0000));\n-      insn = emit_insn (gen_iorsi3 (size_rtx, size_rtx,\n-\t\t\t\t    GEN_INT (frame_size & 0x0000ffff)));\n-    }\n-\n-  /* Allocate stack for this frame.  */\n-  /* Make stack adjustment and use scratch register if constant too\n-     large to fit as immediate.  */\n-  if (frame_size)\n-    {\n-      insn = emit_insn (gen_subsi3 (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t size_rtx));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      REG_NOTES (insn)\n-\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t     gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t  gen_rtx_MINUS (SImode,\n-\t\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t\tGEN_INT (frame_size))),\n-\t\t\t     REG_NOTES (insn));\n-    }\n-\n-  /* Set R9 to point to old sp if required for access to register save area.  */\n-  if ( current_frame_info.reg_size != 0\n-       && !CONST_OK_FOR_LETTER_P (frame_size, 'O'))\n-      emit_insn (gen_addsi3 (size_rtx, size_rtx, stack_pointer_rtx));\n-  \n-  /* Save the frame pointer.  */\n-  ms1_emit_save_fp (FROM_PROCESSOR_TO_MEM, current_frame_info);\n-\n-  /* Now put the frame pointer into the frame pointer register.  */\n-  if (frame_pointer_needed)\n-    {\n-      insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n-\n-  /* Save the registers.  */\n-  ms1_emit_save_regs (FROM_PROCESSOR_TO_MEM, current_frame_info);\n-\n-  /* If we are profiling, make sure no instructions are scheduled before\n-     the call to mcount.  */\n-  if (profile_flag)\n-    emit_insn (gen_blockage ());\n-}\n-\n-/* Implement EPILOGUE_USES.  */\n-int\n-ms1_epilogue_uses (int regno)\n-{\n-  if (cfun->machine && cfun->machine->interrupt_handler && reload_completed)\n-    return 1;\n-  return regno == GPR_LINK;\n-}\n-\n-/* Generate epilogue.  EH_MODE is NORMAL_EPILOGUE when generating a\n-   function epilogue, or EH_EPILOGUE when generating an EH\n-   epilogue.  */\n-void\n-ms1_expand_epilogue (enum epilogue_type eh_mode)\n-{\n-  rtx size_rtx, insn;\n-  unsigned frame_size;\n-\n-  ms1_compute_frame_size (get_frame_size ());\n-\n-  if (TARGET_DEBUG_STACK)\n-    ms1_debug_stack (& current_frame_info);\n-\n-  /* Compute size of stack adjustment.  */\n-  frame_size = current_frame_info.total_size;\n-\n-  /* If offset doesn't fit in a 15-bit signed integer,\n-     uses a scratch registers to get a smaller offset.  */\n-  if (CONST_OK_FOR_LETTER_P(frame_size, 'O'))\n-    size_rtx = GEN_INT (frame_size);\n-  else\n-    {\n-      /* We do not have any scratch registers.  */\n-      gcc_assert (!interrupt_handler);\n-\n-      size_rtx = gen_rtx_REG (SImode, GPR_R9);\n-      insn = emit_move_insn (size_rtx, GEN_INT (frame_size & 0xffff0000));\n-      insn = emit_insn (gen_iorsi3 (size_rtx, size_rtx,\n-\t\t\t\t    GEN_INT (frame_size & 0x0000ffff)));\n-      /* Set R9 to point to old sp if required for access to register\n-\t save area.  */\n-      emit_insn (gen_addsi3 (size_rtx, size_rtx, stack_pointer_rtx));\n-    }\n-\n-  /* Restore sp if there was some possible change to it.  */\n-  if (frame_pointer_needed)\n-    insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\n-  /* Restore the registers.  */\n-  ms1_emit_save_fp (FROM_MEM_TO_PROCESSOR, current_frame_info);\n-  ms1_emit_save_regs (FROM_MEM_TO_PROCESSOR, current_frame_info);\n-\n-  /* Make stack adjustment and use scratch register if constant too\n-     large to fit as immediate.  */\n-  if (frame_size)\n-    {\n-      if (CONST_OK_FOR_LETTER_P(frame_size, 'O'))\n-\t/* Can handle this with simple add.  */\n-\tinsn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t      size_rtx));\n-      else\n-\t/* Scratch reg R9 has the old sp value.  */\n-\tinsn = emit_move_insn (stack_pointer_rtx, \n-\t\t\t       gen_rtx_REG (SImode, GPR_R9));\n-\n-      REG_NOTES (insn)\n-\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t     gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t  gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t\tGEN_INT (frame_size))),\n-\t\t\t     REG_NOTES (insn));\n-    }\n-\n-  if (cfun->machine && cfun->machine->eh_stack_adjust != NULL_RTX)\n-    /* Perform the additional bump for __throw.  */\n-    emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t   stack_pointer_rtx,\n-\t\t\t   cfun->machine->eh_stack_adjust));\n-\n-  /* Generate the appropriate return.  */\n-  if (eh_mode == EH_EPILOGUE)\n-    {\n-      emit_jump_insn (gen_eh_return_internal ());\n-      emit_barrier ();\n-    }\n-  else if (interrupt_handler)\n-    emit_jump_insn (gen_return_interrupt_internal ());\n-  else\n-    emit_jump_insn (gen_return_internal ());\n-\n-  /* Reset state info for each function.  */\n-  interrupt_handler = 0;\n-  current_frame_info = zero_frame_info;\n-  if (cfun->machine)\n-    cfun->machine->eh_stack_adjust = NULL_RTX;\n-}\n-\n-\n-/* Generate code for the \"eh_return\" pattern.  */\n-void\n-ms1_expand_eh_return (rtx * operands)\n-{\n-  if (GET_CODE (operands[0]) != REG\n-      || REGNO (operands[0]) != EH_RETURN_STACKADJ_REGNO)\n-    {\n-      rtx sp = EH_RETURN_STACKADJ_RTX;\n-\n-      emit_move_insn (sp, operands[0]);\n-      operands[0] = sp;\n-    }\n-\n-  emit_insn (gen_eh_epilogue (operands[0]));\n-}\n-\n-/* Generate code for the \"eh_epilogue\" pattern.  */\n-void\n-ms1_emit_eh_epilogue (rtx * operands ATTRIBUTE_UNUSED)\n-{\n-  cfun->machine->eh_stack_adjust = EH_RETURN_STACKADJ_RTX; /* operands[0]; */\n-  ms1_expand_epilogue (EH_EPILOGUE);\n-}\n-\n-/* Handle an \"interrupt\" attribute.  */\n-static tree\n-ms1_handle_interrupt_attribute (tree * node,\n-\t\t\t  tree   name,\n-\t\t\t  tree   args  ATTRIBUTE_UNUSED,\n-\t\t\t  int    flags ATTRIBUTE_UNUSED,\n-\t\t\t  bool * no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FUNCTION_DECL)\n-    {\n-      warning (OPT_Wattributes,\n-\t       \"%qs attribute only applies to functions\",\n-\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Table of machine attributes.  */\n-const struct attribute_spec ms1_attribute_table[] =\n-{\n-  /* name,        min, max, decl?, type?, func?, handler  */\n-  { \"interrupt\",  0,   0,   false, false, false, ms1_handle_interrupt_attribute },\n-  { NULL,         0,   0,   false, false, false, NULL }\n-};\n-\n-/* Implement INITIAL_ELIMINATION_OFFSET.  */\n-int\n-ms1_initial_elimination_offset (int from, int to)\n-{\n-  ms1_compute_frame_size (get_frame_size ());\n-\n-  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return 0;\n-\n-  else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return current_frame_info.total_size;\n-\n-  else if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n-    return current_frame_info.total_size;\n-\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Generate a compare for CODE.  Return a brand-new rtx that\n-   represents the result of the compare.  */\n-\n-static rtx\n-ms1_generate_compare (enum rtx_code code, rtx op0, rtx op1)\n-{\n-  rtx scratch0, scratch1, const_scratch;\n-\n-  switch (code)\n-    {\n-    case GTU:\n-    case LTU:\n-    case GEU:\n-    case LEU:\n-      /* Need to adjust ranges for faking unsigned compares.  */\n-      scratch0 = gen_reg_rtx (SImode);\n-      scratch1 = gen_reg_rtx (SImode);\n-      const_scratch = force_reg (SImode, GEN_INT(MS1_MIN_INT));\n-      emit_insn (gen_addsi3 (scratch0, const_scratch, op0));\n-      emit_insn (gen_addsi3 (scratch1, const_scratch, op1));\n-      break;\n-    default:\n-      scratch0 = op0;\n-      scratch1 = op1;\n-      break;\n-    }\n-    \n-  /* Adjust compare operator to fake unsigned compares.  */\n-  switch (code)\n-    {\n-    case GTU:\n-      code = GT; break;\n-    case LTU:\n-      code = LT; break;\n-    case GEU:\n-      code = GE; break;\n-    case LEU:\n-      code = LE; break;\n-    default:\n-      /* do nothing */\n-      break;\n-    }\n-\n-  /* Generate the actual compare.  */\n-  return gen_rtx_fmt_ee (code, VOIDmode, scratch0, scratch1);\n-}\n-\n-/* Emit a branch of kind CODE to location LOC.  */\n-\n-void\n-ms1_emit_cbranch (enum rtx_code code, rtx loc, rtx op0, rtx op1)\n-{\n-  rtx condition_rtx, loc_ref;\n-\n-  if (! reg_or_0_operand (op0, SImode))\n-    op0 = copy_to_mode_reg (SImode, op0);\n-\n-  if (! reg_or_0_operand (op1, SImode))\n-    op1 = copy_to_mode_reg (SImode, op1);\n-\n-  condition_rtx = ms1_generate_compare (code, op0, op1);\n-  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n-\t\t\t\t\t\t     loc_ref, pc_rtx)));\n-}\n-\n-/* Subfunction of the following function.  Update the flags of any MEM\n-   found in part of X.  */\n-\n-static void\n-ms1_set_memflags_1 (rtx x, int in_struct_p, int volatile_p)\n-{\n-  int i;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SEQUENCE:\n-    case PARALLEL:\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\tms1_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p);\n-      break;\n-\n-    case INSN:\n-      ms1_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p);\n-      break;\n-\n-    case SET:\n-      ms1_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p);\n-      ms1_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p);\n-      break;\n-\n-    case MEM:\n-      MEM_IN_STRUCT_P (x) = in_struct_p;\n-      MEM_VOLATILE_P (x) = volatile_p;\n-      /* Sadly, we cannot use alias sets because the extra aliasing\n-\t produced by the AND interferes.  Given that two-byte quantities\n-\t are the only thing we would be able to differentiate anyway,\n-\t there does not seem to be any point in convoluting the early\n-\t out of the alias check.  */\n-      /* set_mem_alias_set (x, alias_set); */\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Look for any MEMs in the current sequence of insns and set the\n-   in-struct, unchanging, and volatile flags from the flags in REF.\n-   If REF is not a MEM, don't do anything.  */\n-\n-void\n-ms1_set_memflags (rtx ref)\n-{\n-  rtx insn;\n-  int in_struct_p, volatile_p;\n-\n-  if (GET_CODE (ref) != MEM)\n-    return;\n-\n-  in_struct_p = MEM_IN_STRUCT_P (ref);\n-  volatile_p = MEM_VOLATILE_P (ref);\n-\n-  /* This is only called from ms1.md, after having had something \n-     generated from one of the insn patterns.  So if everything is\n-     zero, the pattern is already up-to-date.  */\n-  if (! in_struct_p && ! volatile_p)\n-    return;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    ms1_set_memflags_1 (insn, in_struct_p, volatile_p);\n-}\n-\n-/* Implement SECONDARY_RELOAD_CLASS.  */\n-enum reg_class\n-ms1_secondary_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n-\t\t\t    enum machine_mode mode,\n-\t\t\t    rtx x)\n-{\n-  if ((mode == QImode && (!TARGET_BYTE_ACCESS)) || mode == HImode)\n-    {\n-      if (GET_CODE (x) == MEM\n-\t  || (GET_CODE (x) == REG && true_regnum (x) == -1)\n-\t  || (GET_CODE (x) == SUBREG\n-\t      && (GET_CODE (SUBREG_REG (x)) == MEM\n-\t\t  || (GET_CODE (SUBREG_REG (x)) == REG\n-\t\t      && true_regnum (SUBREG_REG (x)) == -1))))\n-\treturn GENERAL_REGS;\n-    }\n-\n-  return NO_REGS;\n-}\n-\n-/* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE\n-   macros.  */\n-rtx\n-ms1_function_value (tree valtype, enum machine_mode mode, tree func_decl ATTRIBUTE_UNUSED)\n-{\n-  if ((mode) == DImode || (mode) == DFmode)\n-    return gen_rtx_MEM (mode, gen_rtx_REG (mode, RETURN_VALUE_REGNUM));\n-\n-  if (valtype)\n-    mode = TYPE_MODE (valtype);\n-\n-  return gen_rtx_REG (mode, RETURN_VALUE_REGNUM);\n-}\n-\n-/* Split a move into two smaller pieces.\n-   MODE indicates the reduced mode.  OPERANDS[0] is the original destination\n-   OPERANDS[1] is the original src.  The new destinations are\n-   OPERANDS[2] and OPERANDS[4], while the new sources are OPERANDS[3]\n-   and OPERANDS[5].  */\n-\n-void\n-ms1_split_words (enum machine_mode nmode,\n-\t\t enum machine_mode omode,\n-\t\t rtx *operands)\n-{\n-  rtx dl,dh;\t/* src/dest pieces.  */\n-  rtx sl,sh;\n-  int\tmove_high_first = 0;\t/* Assume no overlap.  */\n-\n-  switch (GET_CODE (operands[0])) /* Dest.  */\n-    {\n-    case SUBREG:\n-    case REG:\n-      if ((GET_CODE (operands[1]) == REG\n-\t   || GET_CODE (operands[1]) == SUBREG)\n-\t  && true_regnum (operands[0]) <= true_regnum (operands[1]))\n-\tmove_high_first = 1;\n-\n-      if (GET_CODE (operands[0]) == SUBREG)\n-\t{\n-\t  dl = gen_rtx_SUBREG (nmode, SUBREG_REG (operands[0]),\n-\t\t\t       SUBREG_BYTE (operands[0]) + GET_MODE_SIZE (nmode));\n-\t  dh = gen_rtx_SUBREG (nmode, SUBREG_REG (operands[0]), SUBREG_BYTE (operands[0]));\n-\t}\n-      else if (GET_CODE (operands[0]) == REG && ! IS_PSEUDO_P (operands[0]))\n-\t{\n-\t  int\tr = REGNO (operands[0]);\n-\t  dh = gen_rtx_REG (nmode, r);\n-\t  dl = gen_rtx_REG (nmode, r + HARD_REGNO_NREGS (r, nmode));\n-\t}\n-      else\n-\t{\n-\t  dh = gen_rtx_SUBREG (nmode, operands[0], 0);\n-\t  dl = gen_rtx_SUBREG (nmode, operands[0], GET_MODE_SIZE (nmode));\n-\t}\n-      break;\n-\n-    case MEM:\n-      switch (GET_CODE (XEXP (operands[0], 0)))\n-\t{\n-\tcase POST_INC:\n-\tcase POST_DEC:\n-\t  gcc_unreachable ();\n-\tdefault:\n-\t  dl = operand_subword (operands[0],\n-\t\t\t\tGET_MODE_SIZE (nmode)/UNITS_PER_WORD,\n-\t\t\t\t0, omode);\n-\t  dh = operand_subword (operands[0], 0, 0, omode);\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  switch (GET_CODE (operands[1]))\n-    {\n-    case REG:\n-      if (! IS_PSEUDO_P (operands[1]))\n-\t{\n-\t  int r = REGNO (operands[1]);\n-\n-\t  sh = gen_rtx_REG (nmode, r);\n-\t  sl = gen_rtx_REG (nmode, r + HARD_REGNO_NREGS (r, nmode));\n-\t}\n-      else\n-\t{\n-\t  sh = gen_rtx_SUBREG (nmode, operands[1], 0);\n-\t  sl = gen_rtx_SUBREG (nmode, operands[1], GET_MODE_SIZE (nmode));\n-\t}\n-      break;\n-\n-    case CONST_DOUBLE:\n-      if (operands[1] == const0_rtx)\n-\tsh = sl = const0_rtx;\n-      else\n-\tsplit_double (operands[1], & sh, & sl);\n-      break;\n-\n-    case CONST_INT:\n-      if (operands[1] == const0_rtx)\n-\tsh = sl = const0_rtx;\n-      else\n-\t{\n-\t  int vl, vh;\n-\n-\t  switch (nmode)\n-\t    {\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t    \n-\t  sl = GEN_INT (vl);\n-\t  sh = GEN_INT (vh);\n-\t}\n-      break;\n-\n-    case SUBREG:\n-      sl = gen_rtx_SUBREG (nmode,\n-\t\t\t   SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_BYTE (operands[1]) + GET_MODE_SIZE (nmode));\n-      sh = gen_rtx_SUBREG (nmode,\n-\t\t\t   SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_BYTE (operands[1]));\n-      break;\n-\n-    case MEM:\n-      switch (GET_CODE (XEXP (operands[1], 0)))\n-\t{\n-\tcase POST_DEC:\n-\tcase POST_INC:\n-\t  gcc_unreachable ();\n-\t  break;\n-\tdefault:\n-\t  sl = operand_subword (operands[1], \n-\t\t\t\tGET_MODE_SIZE (nmode)/UNITS_PER_WORD,\n-\t\t\t\t0, omode);\n-\t  sh = operand_subword (operands[1], 0, 0, omode);\n-\t  \n-\t  /* Check if the DF load is going to clobber the register\n-             used for the address, and if so make sure that is going\n-             to be the second move.  */\n-\t  if (GET_CODE (dl) == REG\n-\t      && true_regnum (dl)\n-\t      == true_regnum (XEXP (XEXP (sl, 0 ), 0)))\n-\t    move_high_first = 1;\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (move_high_first)\n-    {\n-      operands[2] = dh;\n-      operands[3] = sh;\n-      operands[4] = dl;\n-      operands[5] = sl;\n-    }\n-  else\n-    {\n-      operands[2] = dl;\n-      operands[3] = sl;\n-      operands[4] = dh;\n-      operands[5] = sh;\n-    }\n-  return;\n-}\n-\n-/* Implement TARGET_MUST_PASS_IN_STACK hook.  */\n-static bool\n-ms1_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n-{\n-  return (((type) != 0\n-\t   && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t       || TREE_ADDRESSABLE (type))));\n-}\n-\f\n-/* Increment the counter for the number of loop instructions in the\n-   current function.  */\n-\n-void ms1_add_loop (void)\n-{\n-  cfun->machine->has_loops++;\n-}\n-\n-\n-/* Maxium loop nesting depth.  */\n-#define MAX_LOOP_DEPTH 4\n-/* Maxium size of a loop (allows some headroom for delayed branch slot\n-   filling.  */\n-#define MAX_LOOP_LENGTH (200 * 4)\n-\n-/* We need to keep a vector of basic blocks */\n-DEF_VEC_P (basic_block);\n-DEF_VEC_ALLOC_P (basic_block,heap);\n-\n-/* And a vector of loops */\n-typedef struct loop_info *loop_info;\n-DEF_VEC_P (loop_info);\n-DEF_VEC_ALLOC_P (loop_info,heap);\n-\n-/* Information about a loop we have found (or are in the process of\n-   finding).  */\n-struct loop_info GTY (())\n-{\n-  /* loop number, for dumps */\n-  int loop_no;\n-  \n-  /* Predecessor block of the loop.   This is the one that falls into\n-     the loop and contains the initialization instruction.  */\n-  basic_block predecessor;\n-\n-  /* First block in the loop.  This is the one branched to by the dbnz\n-     insn.  */\n-  basic_block head;\n-  \n-  /* Last block in the loop (the one with the dbnz insn */\n-  basic_block tail;\n-\n-  /* The successor block of the loop.  This is the one the dbnz insn\n-     falls into.  */\n-  basic_block successor;\n-\n-  /* The dbnz insn.  */\n-  rtx dbnz;\n-\n-  /* The initialization insn.  */\n-  rtx init;\n-\n-  /* The new initialization instruction.  */\n-  rtx loop_init;\n-\n-  /* The new ending instruction. */\n-  rtx loop_end;\n-\n-  /* The new label placed at the end of the loop. */\n-  rtx end_label;\n-\n-  /* The nesting depth of the loop.  Set to -1 for a bad loop.  */\n-  int depth;\n-\n-  /* The length of the loop.  */\n-  int length;\n-\n-  /* Next loop in the graph. */\n-  struct loop_info *next;\n-\n-  /* Vector of blocks only within the loop, (excluding those within\n-     inner loops).  */\n-  VEC (basic_block,heap) *blocks;\n-\n-  /* Vector of inner loops within this loop  */\n-  VEC (loop_info,heap) *loops;\n-};\n-\n-/* Information used during loop detection.  */\n-typedef struct loop_work GTY(())\n-{\n-  /* Basic block to be scanned.  */\n-  basic_block block;\n-\n-  /* Loop it will be within.  */\n-  loop_info loop;\n-} loop_work;\n-\n-/* Work list.  */\n-DEF_VEC_O (loop_work);\n-DEF_VEC_ALLOC_O (loop_work,heap);\n-\n-/* Determine the nesting and length of LOOP.  Return false if the loop\n-   is bad.  */\n-\n-static bool\n-ms1_loop_nesting (loop_info loop)\n-{\n-  loop_info inner;\n-  unsigned ix;\n-  int inner_depth = 0;\n-  \n-  if (!loop->depth)\n-    {\n-      /* Make sure we only have one entry point.  */\n-      if (EDGE_COUNT (loop->head->preds) == 2)\n-\t{\n-\t  loop->predecessor = EDGE_PRED (loop->head, 0)->src;\n-\t  if (loop->predecessor == loop->tail)\n-\t    /* We wanted the other predecessor.  */\n-\t    loop->predecessor = EDGE_PRED (loop->head, 1)->src;\n-\t  \n-\t  /* We can only place a loop insn on a fall through edge of a\n-\t     single exit block.  */\n-\t  if (EDGE_COUNT (loop->predecessor->succs) != 1\n-\t      || !(EDGE_SUCC (loop->predecessor, 0)->flags & EDGE_FALLTHRU))\n-\t    loop->predecessor = NULL;\n-\t}\n-\n-      /* Mark this loop as bad for now.  */\n-      loop->depth = -1;\n-      if (loop->predecessor)\n-\t{\n-\t  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix++, inner);)\n-\t    {\n-\t      if (!inner->depth)\n-\t\tms1_loop_nesting (inner);\n-\t      \n-\t      if (inner->depth < 0)\n-\t\t{\n-\t\t  inner_depth = -1;\n-\t\t  break;\n-\t\t}\n-\t      \n-\t      if (inner_depth < inner->depth)\n-\t\tinner_depth = inner->depth;\n-\t      loop->length += inner->length;\n-\t    }\n-\t  \n-\t  /* Set the proper loop depth, if it was good. */\n-\t  if (inner_depth >= 0)\n-\t    loop->depth = inner_depth + 1;\n-\t}\n-    }\n-  return (loop->depth > 0\n-\t  && loop->predecessor\n-\t  && loop->depth < MAX_LOOP_DEPTH\n-\t  && loop->length < MAX_LOOP_LENGTH);\n-}\n-\n-/* Determine the length of block BB.  */\n-\n-static int\n-ms1_block_length (basic_block bb)\n-{\n-  int length = 0;\n-  rtx insn;\n-\n-  for (insn = BB_HEAD (bb);\n-       insn != NEXT_INSN (BB_END (bb));\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (!INSN_P (insn))\n-\tcontinue;\n-      if (CALL_P (insn))\n-\t{\n-\t  /* Calls are not allowed in loops.  */\n-\t  length = MAX_LOOP_LENGTH + 1;\n-\t  break;\n-\t}\n-      \n-      length += get_attr_length (insn);\n-    }\n-  return length;\n-}\n-\n-/* Scan the blocks of LOOP (and its inferiors) looking for uses of\n-   REG.  Return true, if we find any.  Don't count the loop's dbnz\n-   insn if it matches DBNZ.  */\n-\n-static bool\n-ms1_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n-{\n-  unsigned ix;\n-  loop_info inner;\n-  basic_block bb;\n-  \n-  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n-    {\n-      rtx insn;\n-\n-      for (insn = BB_HEAD (bb);\n-\t   insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (!INSN_P (insn))\n-\t    continue;\n-\t  if (insn == dbnz)\n-\t    continue;\n-\t  if (reg_mentioned_p (reg, PATTERN (insn)))\n-\t    return true;\n-\t}\n-    }\n-  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n-    if (ms1_scan_loop (inner, reg, NULL_RTX))\n-      return true;\n-  \n-  return false;\n-}\n-\n-/* MS2 has a loop instruction which needs to be placed just before the\n-   loop.  It indicates the end of the loop and specifies the number of\n-   loop iterations.  It can be nested with an automatically maintained\n-   stack of counter and end address registers.  It's an ideal\n-   candidate for doloop.  Unfortunately, gcc presumes that loops\n-   always end with an explicit instriction, and the doloop_begin\n-   instruction is not a flow control instruction so it can be\n-   scheduled earlier than just before the start of the loop.  To make\n-   matters worse, the optimization pipeline can duplicate loop exit\n-   and entrance blocks and fails to track abnormally exiting loops.\n-   Thus we cannot simply use doloop.\n-\n-   What we do is emit a dbnz pattern for the doloop optimization, and\n-   let that be optimized as normal.  Then in machine dependent reorg\n-   we have to repeat the loop searching algorithm.  We use the\n-   flow graph to find closed loops ending in a dbnz insn.  We then try\n-   and convert it to use the loop instruction.  The conditions are,\n-\n-   * the loop has no abnormal exits, duplicated end conditions or\n-   duplicated entrance blocks\n-\n-   * the loop counter register is only used in the dbnz instruction\n-   within the loop\n-   \n-   * we can find the instruction setting the initial value of the loop\n-   counter\n-\n-   * the loop is not executed more than 65535 times. (This might be\n-   changed to 2^32-1, and would therefore allow variable initializers.)\n-\n-   * the loop is not nested more than 4 deep 5) there are no\n-   subroutine calls in the loop.  */\n-\n-static void\n-ms1_reorg_loops (FILE *dump_file)\n-{\n-  basic_block bb;\n-  loop_info loops = NULL;\n-  loop_info loop;\n-  int nloops = 0;\n-  unsigned dwork = 0;\n-  VEC (loop_work,heap) *works = VEC_alloc (loop_work,heap,20);\n-  loop_work *work;\n-  edge e;\n-  edge_iterator ei;\n-  bool replaced = false;\n-\n-  /* Find all the possible loop tails.  This means searching for every\n-     dbnz instruction.  For each one found, create a loop_info\n-     structure and add the head block to the work list. */\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx tail = BB_END (bb);\n-\n-      while (GET_CODE (tail) == NOTE)\n-\ttail = PREV_INSN (tail);\n-      \n-      bb->aux = NULL;\n-      if (recog_memoized (tail) == CODE_FOR_decrement_and_branch_until_zero)\n-\t{\n-\t  /* A possible loop end */\n-\n-\t  loop = XNEW (struct loop_info);\n-\t  loop->next = loops;\n-\t  loops = loop;\n-\t  loop->tail = bb;\n-\t  loop->head = BRANCH_EDGE (bb)->dest;\n-\t  loop->successor = FALLTHRU_EDGE (bb)->dest;\n-\t  loop->predecessor = NULL;\n-\t  loop->dbnz = tail;\n-\t  loop->depth = 0;\n-\t  loop->length = ms1_block_length (bb);\n-\t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n-\t  VEC_quick_push (basic_block, loop->blocks, bb);\n-\t  loop->loops = NULL;\n-\t  loop->loop_no = nloops++;\n-\t  \n-\t  loop->init = loop->end_label = NULL_RTX;\n-\t  loop->loop_init = loop->loop_end = NULL_RTX;\n-\t  \n-\t  work = VEC_safe_push (loop_work, heap, works, NULL);\n-\t  work->block = loop->head;\n-\t  work->loop = loop;\n-\n-\t  bb->aux = loop;\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \";; potential loop %d ending at\\n\",\n-\t\t       loop->loop_no);\n-\t      print_rtl_single (dump_file, tail);\n-\t    }\n-\t}\n-    }\n-\n-  /*  Now find all the closed loops.\n-      until work list empty,\n-       if block's auxptr is set\n-         if != loop slot\n-           if block's loop's start != block\n-\t     mark loop as bad\n-\t   else\n-             append block's loop's fallthrough block to worklist\n-\t     increment this loop's depth\n-       else if block is exit block\n-         mark loop as bad\n-       else\n-     \t  set auxptr\n-\t  for each target of block\n-     \t    add to worklist */\n-  while (VEC_iterate (loop_work, works, dwork++, work))\n-    {\n-      loop = work->loop;\n-      bb = work->block;\n-      if (bb == EXIT_BLOCK_PTR)\n-\t/* We've reached the exit block.  The loop must be bad. */\n-\tloop->depth = -1;\n-      else if (!bb->aux)\n-\t{\n-\t  /* We've not seen this block before.  Add it to the loop's\n-\t     list and then add each successor to the work list.  */\n-\t  bb->aux = loop;\n-\t  loop->length += ms1_block_length (bb);\n-\t  VEC_safe_push (basic_block, heap, loop->blocks, bb);\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      if (!VEC_space (loop_work, works, 1))\n-\t\t{\n-\t\t  if (dwork)\n-\t\t    {\n-\t\t      VEC_block_remove (loop_work, works, 0, dwork);\n-\t\t      dwork = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    VEC_reserve (loop_work, heap, works, 1);\n-\t\t}\n-\t      work = VEC_quick_push (loop_work, works, NULL);\n-\t      work->block = EDGE_SUCC (bb, ei.index)->dest;\n-\t      work->loop = loop;\n-\t    }\n-\t}\n-      else if (bb->aux != loop)\n-\t{\n-\t  /* We've seen this block in a different loop.  If it's not\n-\t     the other loop's head, then this loop must be bad.\n-\t     Otherwise, the other loop might be a nested loop, so\n-\t     continue from that loop's successor.  */\n-\t  loop_info other = bb->aux;\n-\t  \n-\t  if (other->head != bb)\n-\t    loop->depth = -1;\n-\t  else\n-\t    {\n-\t      VEC_safe_push (loop_info, heap, loop->loops, other);\n-\t      work = VEC_safe_push (loop_work, heap, works, NULL);\n-\t      work->loop = loop;\n-\t      work->block = other->successor;\n-\t    }\n-\t}\n-    }\n-  VEC_free (loop_work, heap, works);\n-\n-  /* Now optimize the loops.  */\n-  for (loop = loops; loop; loop = loop->next)\n-    {\n-      rtx iter_reg, insn, init_insn;\n-      rtx init_val, loop_end, loop_init, end_label, head_label;\n-\n-      if (!ms1_loop_nesting (loop))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n-\t  continue;\n-\t}\n-\n-      /* Get the loop iteration register.  */\n-      iter_reg = SET_DEST (XVECEXP (PATTERN (loop->dbnz), 0, 1));\n-      \n-      if (!REG_P (iter_reg))\n-\t{\n-\t  /* Spilled */\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \";; loop %d has spilled iteration count\\n\",\n-\t\t     loop->loop_no);\n-\t  continue;\n-\t}\n-\n-      /* Look for the initializing insn */\n-      init_insn = NULL_RTX;\n-      for (insn = BB_END (loop->predecessor);\n-\t   insn != PREV_INSN (BB_HEAD (loop->predecessor));\n-\t   insn = PREV_INSN (insn))\n-\t{\n-\t  if (!INSN_P (insn))\n-\t    continue;\n-\t  if (reg_mentioned_p (iter_reg, PATTERN (insn)))\n-\t    {\n-\t      rtx set = single_set (insn);\n-\n-\t      if (set && rtx_equal_p (iter_reg, SET_DEST (set)))\n-\t\tinit_insn = insn;\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (!init_insn)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \";; loop %d has no initializer\\n\",\n-\t\t     loop->loop_no);\n-\t  continue;\n-\t}\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \";; loop %d initialized by\\n\",\n-\t\t   loop->loop_no);\n-\t  print_rtl_single (dump_file, init_insn);\n-\t}\n-\n-      init_val = PATTERN (init_insn);\n-      if (GET_CODE (init_val) == SET)\n-\tinit_val = SET_SRC (init_val);\n-      if (GET_CODE (init_val) != CONST_INT || INTVAL (init_val) >= 65535)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \";; loop %d has complex initializer\\n\",\n-\t\t     loop->loop_no);\n-\t  continue;\n-\t}\n-      \n-      /* Scan all the blocks to make sure they don't use iter_reg.  */\n-      if (ms1_scan_loop (loop, iter_reg, loop->dbnz))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \";; loop %d uses iterator\\n\",\n-\t\t     loop->loop_no);\n-\t  continue;\n-\t}\n-\n-      /* The loop is good for replacement.  */\n-      \n-      /* loop is 1 based, dbnz is zero based.  */\n-      init_val = GEN_INT (INTVAL (init_val) + 1);\n-      \n-      iter_reg = gen_rtx_REG (SImode, LOOP_FIRST + loop->depth - 1);\n-      end_label = gen_label_rtx ();\n-      head_label = XEXP (SET_SRC (XVECEXP (PATTERN (loop->dbnz), 0, 0)), 1);\n-      loop_end = gen_loop_end (iter_reg, head_label);\n-      loop_init = gen_loop_init (iter_reg, init_val, end_label);\n-      loop->init = init_insn;\n-      loop->end_label = end_label;\n-      loop->loop_init = loop_init;\n-      loop->loop_end = loop_end;\n-      replaced = true;\n-      \n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \";; replacing loop %d initializer with\\n\",\n-\t\t   loop->loop_no);\n-\t  print_rtl_single (dump_file, loop->loop_init);\n-\t  fprintf (dump_file, \";; replacing loop %d terminator with\\n\",\n-\t\t   loop->loop_no);\n-\t  print_rtl_single (dump_file, loop->loop_end);\n-\t}\n-    }\n-\n-  /* Now apply the optimizations.  Do it this way so we don't mess up\n-     the flow graph half way through.  */\n-  for (loop = loops; loop; loop = loop->next)\n-    if (loop->loop_init)\n-      {\n-\temit_jump_insn_after (loop->loop_init, BB_END (loop->predecessor));\n-\tdelete_insn (loop->init);\n-\temit_label_before (loop->end_label, loop->dbnz);\n-\temit_jump_insn_before (loop->loop_end, loop->dbnz);\n-\tdelete_insn (loop->dbnz);\n-      }\n-\n-  /* Free up the loop structures */\n-  while (loops)\n-    {\n-      loop = loops;\n-      loops = loop->next;\n-      VEC_free (loop_info, heap, loop->loops);\n-      VEC_free (basic_block, heap, loop->blocks);\n-      XDELETE (loop);\n-    }\n-\n-  if (replaced && dump_file)\n-    {\n-      fprintf (dump_file, \";; Replaced loops\\n\");\n-      print_rtl (dump_file, get_insns ());\n-    }\n-}\n-\n-/* Structures to hold branch information during reorg.  */\n-typedef struct branch_info\n-{\n-  rtx insn;  /* The branch insn.  */\n-  \n-  struct branch_info *next;\n-} branch_info;\n-\n-typedef struct label_info\n-{\n-  rtx label;  /* The label.  */\n-  branch_info *branches;  /* branches to this label.  */\n-  struct label_info *next;\n-} label_info;\n-\n-/* Chain of labels found in current function, used during reorg.  */\n-static label_info *ms1_labels;\n-\n-/* If *X is a label, add INSN to the list of branches for that\n-   label.  */\n-\n-static int\n-ms1_add_branches (rtx *x, void *insn)\n-{\n-  if (GET_CODE (*x) == LABEL_REF)\n-    {\n-      branch_info *branch = xmalloc (sizeof (*branch));\n-      rtx label = XEXP (*x, 0);\n-      label_info *info;\n-\n-      for (info = ms1_labels; info; info = info->next)\n-\tif (info->label == label)\n-\t  break;\n-\n-      if (!info)\n-\t{\n-\t  info = xmalloc (sizeof (*info));\n-\t  info->next = ms1_labels;\n-\t  ms1_labels = info;\n-\t  \n-\t  info->label = label;\n-\t  info->branches = NULL;\n-\t}\n-\n-      branch->next = info->branches;\n-      info->branches = branch;\n-      branch->insn = insn;\n-    }\n-  return 0;\n-}\n-\n-/* If BRANCH has a filled delay slot, check if INSN is dependent upon\n-   it.  If so, undo the delay slot fill.   Returns the next insn, if\n-   we patch out the branch.  Returns the branch insn, if we cannot\n-   patch out the branch (due to anti-dependency in the delay slot).\n-   In that case, the caller must insert nops at the branch target.  */\n-\n-static rtx\n-ms1_check_delay_slot (rtx branch, rtx insn)\n-{\n-  rtx slot;\n-  rtx tmp;\n-  rtx p;\n-  rtx jmp;\n-  \n-  gcc_assert (GET_CODE (PATTERN (branch)) == SEQUENCE);\n-  if (INSN_DELETED_P (branch))\n-    return NULL_RTX;\n-  slot = XVECEXP (PATTERN (branch), 0, 1);\n-  \n-  tmp = PATTERN (insn);\n-  note_stores (PATTERN (slot), insn_dependent_p_1, &tmp);\n-  if (tmp)\n-    /* Not dependent.  */\n-    return NULL_RTX;\n-  \n-  /* Undo the delay slot.  */\n-  jmp = XVECEXP (PATTERN (branch), 0, 0);\n-  \n-  tmp = PATTERN (jmp);\n-  note_stores (PATTERN (slot), insn_dependent_p_1, &tmp);\n-  if (!tmp)\n-    /* Anti dependent. */\n-    return branch;\n-      \n-  p = PREV_INSN (branch);\n-  NEXT_INSN (p) = slot;\n-  PREV_INSN (slot) = p;\n-  NEXT_INSN (slot) = jmp;\n-  PREV_INSN (jmp) = slot;\n-  NEXT_INSN (jmp) = branch;\n-  PREV_INSN (branch) = jmp;\n-  XVECEXP (PATTERN (branch), 0, 0) = NULL_RTX;\n-  XVECEXP (PATTERN (branch), 0, 1) = NULL_RTX;\n-  delete_insn (branch);\n-  return jmp;\n-}\n-\n-/* Insert nops to satisfy pipeline constraints.  We only deal with ms2\n-   constraints here.  Earlier CPUs are dealt with by inserting nops with\n-   final_prescan (but that can lead to inferior code, and is\n-   impractical with ms2's JAL hazard).\n-\n-   ms2 dynamic constraints\n-   1) a load and a following use must be separated by one insn\n-   2) an insn and a following dependent call must be separated by two insns\n-   \n-   only arith insns are placed in delay slots so #1 cannot happen with\n-   a load in a delay slot.  #2 can happen with an arith insn in the\n-   delay slot.  */\n-\n-static void\n-ms1_reorg_hazard (void)\n-{\n-  rtx insn, next;\n-\n-  /* Find all the branches */\n-  for (insn = get_insns ();\n-       insn;\n-       insn = NEXT_INSN (insn))\n-    {\n-      rtx jmp;\n-\n-      if (!INSN_P (insn))\n-\tcontinue;\n-\n-      jmp = PATTERN (insn);\n-      \n-      if (GET_CODE (jmp) != SEQUENCE)\n-\t/* If it's not got a filled delay slot, then it can't\n-\t   conflict.  */\n-\tcontinue;\n-      \n-      jmp = XVECEXP (jmp, 0, 0);\n-\n-      if (recog_memoized (jmp) == CODE_FOR_tablejump)\n-\tfor (jmp = XEXP (XEXP (XVECEXP (PATTERN (jmp), 0, 1), 0), 0);\n-\t     !JUMP_TABLE_DATA_P (jmp);\n-\t     jmp = NEXT_INSN (jmp))\n-\t  continue;\n-\n-      for_each_rtx (&PATTERN (jmp), ms1_add_branches, insn);\n-    }\n-\n-  /* Now scan for dependencies.  */\n-  for (insn = get_insns ();\n-       insn && !INSN_P (insn);\n-       insn = NEXT_INSN (insn))\n-    continue;\n-  \n-  for (;\n-       insn;\n-       insn = next)\n-    {\n-      rtx jmp, tmp;\n-      enum attr_type attr;\n-      \n-      gcc_assert (INSN_P (insn) && !INSN_DELETED_P (insn));\n-      for (next = NEXT_INSN (insn);\n-\t   next && !INSN_P (next);\n-\t   next = NEXT_INSN (next))\n-\tcontinue;\n-\n-      jmp = insn;\n-      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tjmp = XVECEXP (PATTERN (insn), 0, 0);\n-      \n-      attr = recog_memoized (jmp) >= 0 ? get_attr_type (jmp) : TYPE_UNKNOWN;\n-      \n-      if (next && attr == TYPE_LOAD)\n-\t{\n-\t  /* A load.  See if NEXT is dependent, and if so insert a\n-\t     nop.  */\n-\t  \n-\t  tmp = PATTERN (next);\n-\t  if (GET_CODE (tmp) == SEQUENCE)\n-\t    tmp = PATTERN (XVECEXP (tmp, 0, 0));\n-\t  note_stores (PATTERN (insn), insn_dependent_p_1, &tmp);\n-\t  if (!tmp)\n-\t    emit_insn_after (gen_nop (), insn);\n-\t}\n-      \n-      if (attr == TYPE_CALL)\n-\t{\n-\t  /* A call.  Make sure we're not dependent on either of the\n-\t     previous two dynamic instructions.  */\n-\t  int nops = 0;\n-\t  int count;\n-\t  rtx prev = insn;\n-\t  rtx rescan = NULL_RTX;\n-\n-\t  for (count = 2; count && !nops;)\n-\t    {\n-\t      int type;\n-\t      \n-\t      prev = PREV_INSN (prev);\n-\t      if (!prev)\n-\t\t{\n-\t\t  /* If we reach the start of the function, we must\n-\t\t     presume the caller set the address in the delay\n-\t\t     slot of the call instruction.  */\n-\t\t  nops = count;\n-\t\t  break;\n-\t\t}\n-\t      \n-\t      if (BARRIER_P (prev))\n-\t\tbreak;\n-\t      if (LABEL_P (prev))\n-\t\t{\n-\t\t  /* Look at branches to this label.  */\n-\t\t  label_info *label;\n-\t\t  branch_info *branch;\n-\n-\t\t  for (label = ms1_labels;\n-\t\t       label;\n-\t\t       label = label->next)\n-\t\t    if (label->label == prev)\n-\t\t      {\n-\t\t\tfor (branch = label->branches;\n-\t\t\t     branch;\n-\t\t\t     branch = branch->next)\n-\t\t\t  {\n-\t\t\t    tmp = ms1_check_delay_slot (branch->insn, jmp);\n-\n-\t\t\t    if (tmp == branch->insn)\n-\t\t\t      {\n-\t\t\t\tnops = count;\n-\t\t\t\tbreak;\n-\t\t\t      }\n-\t\t\t    \n-\t\t\t    if (tmp && branch->insn == next)\n-\t\t\t      rescan = tmp;\n-\t\t\t  }\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  continue;\n-\t\t}\n-\t      if (!INSN_P (prev))\n-\t\tcontinue;\n-\t      \n-\t      if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n-\t\t{\n-\t\t  /* Look at the delay slot.  */\n-\t\t  tmp = ms1_check_delay_slot (prev, jmp);\n-\t\t  if (tmp == prev)\n-\t\t    nops = count;\n-\t\t  break;\n-\t\t}\n-\t      \n-\t      type = (INSN_CODE (prev) >= 0 ? get_attr_type (prev)\n-\t\t      : TYPE_COMPLEX);\n-\t      if (type == TYPE_CALL || type == TYPE_BRANCH)\n-\t\tbreak;\n-\t      \n-\t      if (type == TYPE_LOAD\n-\t\t  || type == TYPE_ARITH\n-\t\t  || type == TYPE_COMPLEX)\n-\t\t{\n-\t\t  tmp = PATTERN (jmp);\n-\t\t  note_stores (PATTERN (prev), insn_dependent_p_1, &tmp);\n-\t\t  if (!tmp)\n-\t\t    {\n-\t\t      nops = count;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t      if (INSN_CODE (prev) >= 0)\n-\t\t{\n-\t\t  rtx set = single_set (prev);\n-\n-\t\t  /* A noop set will get deleted in a later split pass,\n-\t     \t     so we can't count on it for hazard avoidance.  */\n-\t\t  if (!set || !set_noop_p (set))\n-\t\t    count--;\n-\t\t}\n-\t    }\n-\n-\t  if (rescan)\n-\t    for (next = NEXT_INSN (rescan);\n-\t\t next && !INSN_P (next);\n-\t\t next = NEXT_INSN (next))\n-\t      continue;\n-\t  while (nops--)\n-\t    emit_insn_before (gen_nop (), insn);\n-\t}\n-    }\n-\n-  /* Free the data structures.  */\n-  while (ms1_labels)\n-    {\n-      label_info *label = ms1_labels;\n-      branch_info *branch, *next;\n-      \n-      ms1_labels = label->next;\n-      for (branch = label->branches; branch; branch = next)\n-\t{\n-\t  next = branch->next;\n-\t  free (branch);\n-\t}\n-      free (label);\n-    }\n-}\n-\n-/* Fixup the looping instructions, do delayed branch scheduling, fixup\n-   scheduling hazards.  */\n-\n-static void\n-ms1_machine_reorg (void)\n-{\n-  if (cfun->machine->has_loops)\n-    ms1_reorg_loops (dump_file);\n-\n-  if (ms1_flag_delayed_branch)\n-    dbr_schedule (get_insns (), dump_file);\n-  \n-  if (ms1_cpu == PROCESSOR_MS2)\n-    ms1_reorg_hazard ();\n-}\n-\f\n-/* Initialize the GCC target structure.  */\n-const struct attribute_spec ms1_attribute_table[];\n-\n-#undef  TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE \t\tms1_attribute_table\n-#undef  TARGET_STRUCT_VALUE_RTX\n-#define TARGET_STRUCT_VALUE_RTX\t\tms1_struct_value_rtx\n-#undef  TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES\thook_bool_tree_true\n-#undef  TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE\tms1_pass_by_reference\n-#undef  TARGET_MUST_PASS_IN_STACK\n-#define TARGET_MUST_PASS_IN_STACK       ms1_pass_in_stack\n-#undef  TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES\tms1_arg_partial_bytes\n-#undef  TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG  ms1_machine_reorg\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-#include \"gt-ms1.h\""}, {"sha": "eff36c7cbaa797c4a5ba66f1659486fe667d9669", "filename": "gcc/config/ms1/mt.h", "status": "removed", "additions": 0, "deletions": 879, "changes": 879, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fmt.h?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,879 +0,0 @@\n-/* Target Definitions for MorphoRISC1\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n-   Contributed by Red Hat, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 2, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-   02110-1301, USA.  */\n-\n-extern struct rtx_def * ms1_ucmpsi3_libcall;\n-\n-enum processor_type\n-{\n-  PROCESSOR_MS1_64_001,\n-  PROCESSOR_MS1_16_002,\n-  PROCESSOR_MS1_16_003,\n-  PROCESSOR_MS2\n-};\n-\n-enum epilogue_type\n-{\n-  EH_EPILOGUE,\n-  NORMAL_EPILOGUE\n-};\n-\n-extern enum processor_type ms1_cpu;\n-\n-\f\n-/* A C string constant that tells the GCC driver program options to pass to\n-   the assembler.  */\n-#undef  ASM_SPEC\n-#define ASM_SPEC \"%{march=*} %{!march=*: -march=ms2}\"\n-\n-/* A string to pass to at the end of the command given to the linker.  */\n-#undef  LIB_SPEC\n-#define LIB_SPEC \"--start-group -lc -lsim --end-group \\\n-%{msim: ; \\\n-march=ms1-64-001:-T 64-001.ld%s; \\\n-march=MS1-64-001:-T 64-001.ld%s; \\\n-march=ms1-16-002:-T 16-002.ld%s; \\\n-march=MS1-16-002:-T 16-002.ld%s; \\\n-march=ms1-16-003:-T 16-003.ld%s; \\\n-march=MS1-16-003:-T 16-003.ld%s; \\\n-march=ms2:-T ms2.ld%s; \\\n-march=MS2:-T ms2.ld%s; \\\n-\t : -T ms2.ld}\"\n-\n-/* A string to pass at the very beginning of the command given to the\n-   linker.  */\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \"%{msim:crt0.o%s;\\\n-march=ms1-64-001:%{!mno-crt0:crt0-64-001.o%s} startup-64-001.o%s; \\\n-march=MS1-64-001:%{!mno-crt0:crt0-64-001.o%s} startup-64-001.o%s; \\\n-march=ms1-16-002:%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s; \\\n-march=MS1-16-002:%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s; \\\n-march=ms1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n-march=MS1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n-march=ms2:%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s; \\\n-march=MS2:%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s; \\\n-\t :%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s} \\\n-crti.o%s crtbegin.o%s\"\n-\n-/* A string to pass at the end of the command given to the linker.  */\n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC \"%{msim:exit.o%s; \\\n-march=ms1-64-001:exit-64-001.o%s; \\\n-march=MS1-64-001:exit-64-001.o%s; \\\n-march=ms1-16-002:exit-16-002.o%s; \\\n-march=MS1-16-002:exit-16-002.o%s; \\\n-march=ms1-16-003:exit-16-003.o%s; \\\n-march=MS1-16-003:exit-16-003.o%s; \\\n-march=ms2:exit-ms2.o%s; \\\n-march=MS2:exit-ms2.o%s; \\\n-\t :exit-ms2.o%s} \\\n- crtend.o%s crtn.o%s\"\n-\f\n-/* Run-time target specifications.  */\n-\n-#define TARGET_CPU_CPP_BUILTINS() \t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"ms1\");\t\t\\\n-      builtin_assert (\"machine=ms1\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define TARGET_MS1_64_001 (ms1_cpu == PROCESSOR_MS1_64_001)\n-#define TARGET_MS1_16_002 (ms1_cpu == PROCESSOR_MS1_16_002)\n-#define TARGET_MS1_16_003 (ms1_cpu == PROCESSOR_MS1_16_003)\n-#define TARGET_MS2 (ms1_cpu == PROCESSOR_MS2)\n-\n-#define TARGET_VERSION  fprintf (stderr, \" (ms1)\");\n-\n-#define OVERRIDE_OPTIONS ms1_override_options ()\n-\n-#define CAN_DEBUG_WITHOUT_FP 1\n-\n-\f\n-/* Storage Layout.  */\n-\n-#define BITS_BIG_ENDIAN 0\n-\n-#define BYTES_BIG_ENDIAN 1\n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-#define UNITS_PER_WORD 4\n-\n-/* A macro to update MODE and UNSIGNEDP when an object whose type is TYPE and\n-   which has the specified mode and signedness is to be stored in a register.\n-   This macro is only called when TYPE is a scalar type.\n-\n-   On most RISC machines, which only have operations that operate on a full\n-   register, define this macro to set M to `word_mode' if M is an integer mode\n-   narrower than `BITS_PER_WORD'.  In most cases, only integer modes should be\n-   widened because wider-precision floating-point operations are usually more\n-   expensive than their narrower counterparts.\n-\n-   For most machines, the macro definition does not change UNSIGNEDP.  However,\n-   some machines, have instructions that preferentially handle either signed or\n-   unsigned quantities of certain modes.  For example, on the DEC Alpha, 32-bit\n-   loads from memory and 32-bit add instructions sign-extend the result to 64\n-   bits.  On such machines, set UNSIGNEDP according to which kind of extension\n-   is more efficient.\n-\n-   Do not define this macro if it would never modify MODE.  */\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n-\t  && GET_MODE_SIZE (MODE) < 4)\t\t\t\t\\\n-\t(MODE) = SImode;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Normal alignment required for function parameters on the stack, in bits.\n-   All stack parameters receive at least this much alignment regardless of data\n-   type.  On most machines, this is the same as the size of an integer.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Define this macro to the minimum alignment enforced by hardware for\n-   the stack pointer on this machine.  The definition is a C\n-   expression for the desired alignment (measured in bits).  This\n-   value is used as a default if PREFERRED_STACK_BOUNDARY is not\n-   defined.  On most machines, this should be the same as\n-   PARM_BOUNDARY.  */\n-#define STACK_BOUNDARY 32\n-\n-/* Alignment required for a function entry point, in bits.  */\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Biggest alignment that any data type can require on this machine,\n-   in bits.  */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* If defined, a C expression to compute the alignment for a variable\n-   in the static store.  TYPE is the data type, and ALIGN is the\n-   alignment that the object would ordinarily have.  The value of this\n-   macro is used instead of that alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* If defined, a C expression to compute the alignment given to a constant that\n-   is being placed in memory.  CONSTANT is the constant and ALIGN is the\n-   alignment that the object would ordinarily have.  The value of this macro is\n-   used instead of that alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.\n-\n-   The typical use of this macro is to increase alignment for string constants\n-   to be word aligned so that `strcpy' calls that copy constants can be done\n-   inline.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Number of bits which any structure or union's size must be a multiple of.\n-   Each structure or union's size is rounded up to a multiple of this.\n-\n-   If you do not define this macro, the default is the same as `BITS_PER_UNIT'.  */\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-\n-/* Define this macro to be the value 1 if instructions will fail to work if\n-   given data not on the nominal alignment.  If instructions will merely go\n-   slower in that case, define this macro as 0.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* Define this if you wish to imitate the way many other C compilers handle\n-   alignment of bitfields and the structures that contain them.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\f\n-/* Layout of Source Language Data Types.  */\n-\n-#define INT_TYPE_SIZE 32\n-\n-#define SHORT_TYPE_SIZE 16\n-\n-#define LONG_TYPE_SIZE 32\n-\n-#define LONG_LONG_TYPE_SIZE 64\n-\n-#define CHAR_TYPE_SIZE 8\n-\n-#define FLOAT_TYPE_SIZE 32\n-\n-#define DOUBLE_TYPE_SIZE 64\n-\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\f\n-/* Register Basics.  */\n-\n-/* General purpose registers.  */\n-#define GPR_FIRST       0               /* First gpr */\n-#define GPR_LAST        15\t\t/* Last possible gpr */\n-\n-#define GPR_R0          0\t\t/* Always 0 */\n-#define GPR_R7          7\t\t/* Used as a scratch register */\n-#define GPR_R8          8\t\t/* Used as a scratch register */\n-#define GPR_R9          9\t\t/* Used as a scratch register */\n-#define GPR_R10         10\t\t/* Used as a scratch register */\n-#define GPR_R11         11\t\t/* Used as a scratch register */\n-#define GPR_FP          12\t\t/* Frame pointer */\n-#define GPR_SP          13\t        /* Stack pointer */\n-#define GPR_LINK\t14\t\t/* Saved return address as\n-\t\t\t\t\t   seen  by the caller */\n-#define GPR_INTERRUPT_LINK 15\t\t/* hold return addres for interrupts */\n-\n-#define LOOP_FIRST         (GPR_LAST + 1)\n-#define LOOP_LAST\t   (LOOP_FIRST + 3)\n-\n-/* Argument register that is eliminated in favor of the frame and/or stack\n-   pointer.  Also add register to point to where the return address is\n-   stored.  */\n-#define SPECIAL_REG_FIRST\t\t(LOOP_LAST + 1)\n-#define SPECIAL_REG_LAST\t\t(SPECIAL_REG_FIRST)\n-#define ARG_POINTER_REGNUM\t\t(SPECIAL_REG_FIRST + 0)\n-#define SPECIAL_REG_P(R)\t\t((R) == SPECIAL_REG_FIRST)\n-\n-/* The first/last register that can contain the arguments to a function.  */\n-#define FIRST_ARG_REGNUM\t1\n-#define LAST_ARG_REGNUM\t\t4\n-\n-/* The register used to hold functions return value */\n-#define RETVAL_REGNUM\t\t11\n-\n-#define FIRST_PSEUDO_REGISTER (SPECIAL_REG_LAST + 1)\n-\n-#define IS_PSEUDO_P(R)\t(REGNO (R) >= FIRST_PSEUDO_REGISTER)\n-\n-/* R0\t\talways has the value 0\n-   R10          static link\n-   R12\tFP\tpointer to active frame\n-   R13\tSP\tpointer to top of stack\n-   R14\tRA\treturn address\n-   R15\tIRA\tinterrupt return address.  */\n-#define FIXED_REGISTERS { 1, 0, 0, 0, 0, 0, 0, 0, \\\n-\t\t\t  0, 0, 0, 0, 1, 1, 1, 1, \\\n-\t\t\t  1, 1, 1, 1, 1\t\t  \\\n-\t\t\t }\n-\n-/* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n-   general) by function calls as well as for fixed registers.  This macro\n-   therefore identifies the registers that are not available for general\n-   allocation of values that must live across function calls.  */\n-#define CALL_USED_REGISTERS\t{ 1, 1, 1, 1, 1, 0, 0, 1, \\\n-\t\t\t\t  1, 1, 1, 1, 1, 1, 1, 1, \\\n-\t\t\t\t  1, 1, 1, 1, 1\t\t  \\\n-\t\t\t\t}\n-\n-\f\n-/* How Values Fit in Registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-/* A C expression that is nonzero if a value of mode MODE1 is\n-   accessible in mode MODE2 without copying.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\f\n-/* Register Classes.  */\n-\n-enum reg_class\n-{\n-  NO_REGS,\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define   GENERAL_REGS\tALL_REGS\n-\n-#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n-\n-#define REG_CLASS_NAMES {\"NO_REGS\", \"ALL_REGS\" }\n-\n-#define REG_CLASS_CONTENTS \\\n-   {\t\t\t\t\t\t\t\t\\\n-     { 0x0 },\t\t\t\t\t\t\t\\\n-     { 0x000fffff },\t\t\t\t\t\t\\\n-   }\n-\n-/* A C expression whose value is a register class containing hard register\n-   REGNO.  In general there is more than one such class; choose a class which\n-   is \"minimal\", meaning that no smaller class also contains the register.  */\n-#define REGNO_REG_CLASS(REGNO) GENERAL_REGS\n-\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-#define INDEX_REG_CLASS NO_REGS\n-\n-#define REG_CLASS_FROM_LETTER(CHAR) NO_REGS\n-\n-#define REGNO_OK_FOR_BASE_P(NUM) 1\n-\n-#define REGNO_OK_FOR_INDEX_P(NUM) 1\n-\n-/* A C expression that places additional restrictions on the register class to\n-   use when it is necessary to copy value X into a register in class CLASS.\n-   The value is a register class; perhaps CLASS, or perhaps another, smaller\n-   class.  On many machines, the following definition is safe:\n-\n-        #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n-*/\n-#define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,X) \\\n-  ms1_secondary_reload_class((CLASS), (MODE), (X))\n-\n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* For MorphoRISC1:\n-\n-   `I'\tis used for the range of constants an arithmetic insn can\n-\tactually contain (16 bits signed integers).\n-\n-   `J'\tis used for the range which is just zero (ie, $r0).\n-\n-   `K'\tis used for the range of constants a logical insn can actually\n-\tcontain (16 bit zero-extended integers).\n-\n-   `L'\tis used for the range of constants that be loaded with lui\n-\t(ie, the bottom 16 bits are zero).\n-\n-   `M'\tis used for the range of constants that take two words to load\n-\t(ie, not matched by `I', `K', and `L').\n-\n-   `N'\tis used for negative 16 bit constants other than -65536.\n-\n-   `O'\tis a 15 bit signed integer.\n-\n-   `P'\tis used for positive 16 bit constants.  */\n-\n-#define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n-#define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)\n-\n-/* A C expression that defines the machine-dependent operand\n-   constraint letters that specify particular ranges of integer\n-   values.  If C is one of those letters, the expression should check\n-   that VALUE, an integer, is in the appropriate range and return 1 if\n-   so, 0 otherwise.  If C is not one of those letters, the value\n-   should be 0 regardless of VALUE.  */\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\\n-   : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n-   : (C) == 'K' ? ((unsigned HOST_WIDE_INT) (VALUE) < 0x10000)\t\t\\\n-   : (C) == 'L' ? (((VALUE) & 0x0000ffff) == 0\t\t\t\t\\\n-\t\t   && (((VALUE) & ~2147483647) == 0\t\t\t\\\n-\t\t       || ((VALUE) & ~2147483647) == ~2147483647))\t\\\n-   : (C) == 'M' ? ((((VALUE) & ~0x0000ffff) != 0)\t\t\t\\\n-\t\t   && (((VALUE) & ~0x0000ffff) != ~0x0000ffff)\t\t\\\n-\t\t   && (((VALUE) & 0x0000ffff) != 0\t\t\t\\\n-\t\t       || (((VALUE) & ~2147483647) != 0\t\t\t\\\n-\t\t\t   && ((VALUE) & ~2147483647) != ~2147483647)))\t\\\n-   : (C) == 'N' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0xffff) < 0xffff) \\\n-   : (C) == 'O' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x4000) < 0x8000) \\\n-   : (C) == 'P' ? ((VALUE) != 0 && (((VALUE) & ~0x0000ffff) == 0))\t\\\n-   : 0)\n-\n-/* A C expression that defines the machine-dependent operand constraint letters\n-   (`G', `H') that specify particular ranges of `const_double' values.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-/* Most negative value represent on ms1 */\n-#define MS1_MIN_INT 0x80000000\n-\f\n-/* Basic Stack Layout.  */\n-\n-enum save_direction\n-{\n-  FROM_PROCESSOR_TO_MEM,\n-  FROM_MEM_TO_PROCESSOR\n-};\n-\n-/* Tell prologue and epilogue if register REGNO should be saved / restored.\n-   The return address and frame pointer are treated separately.\n-   Don't consider them here.  */\n-#define MUST_SAVE_REGISTER(regno)\t\t\t\t\\\n-  (   (regno) != GPR_LINK \t\t\t\t\t\\\n-   && (regno) != GPR_FP\t\t  \t\t\t\t\\\n-   && (regno) != GPR_SP\t\t  \t\t\t\t\\\n-   && (regno) != GPR_R0\t\t  \t\t\t\t\\\n-   &&   (( regs_ever_live [regno] && ! call_used_regs [regno] ) \\\n-       /* Save ira register in an interrupt handler.  */\t\\\n-\t|| (interrupt_handler && (regno) == GPR_INTERRUPT_LINK)\t\\\n-       /* Save any register used in an interrupt handler.  */\t\\\n-\t|| (interrupt_handler && regs_ever_live [regno])\t\\\n-       /* Save call clobbered registers in non-leaf interrupt\t\\\n-\t  handlers.  */\t\t\t\t\t\t\\\n-\t|| (interrupt_handler && call_used_regs[regno] \t\t\\\n-\t   && !current_function_is_leaf)\t\t\t\\\n-\t||(current_function_calls_eh_return\t\t\t\\\n-\t   && (regno == GPR_R7 || regno == GPR_R8))\t\t\\\n-\t)\t\t\t\t\t\t\t\\\n-  )\n-\n-#define STACK_GROWS_DOWNWARD 1\n-\n-/* Offset from the frame pointer to the first local variable slot to be\n-   allocated.\n-\n-   If `FRAME_GROWS_DOWNWARD', find the next slot's offset by\n-   subtracting the first slot's length from `STARTING_FRAME_OFFSET'.\n-   Otherwise, it is found by adding the length of the first slot to\n-   the value `STARTING_FRAME_OFFSET'.  */\n-#define STARTING_FRAME_OFFSET current_function_outgoing_args_size\n-\n-/* Offset from the argument pointer register to the first argument's address.\n-   On some machines it may depend on the data type of the function.\n-\n-   If `ARGS_GROW_DOWNWARD', this is the offset to the location above the first\n-   argument's address.  */\n-#define FIRST_PARM_OFFSET(FUNDECL) 0\n-\n-#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) \t\t\t\t\\\n-    ms1_return_addr_rtx (COUNT)\n-\n-/* A C expression whose value is RTL representing the location of the incoming\n-   return address at the beginning of any function, before the prologue.  This\n-   RTL is either a `REG', indicating that the return value is saved in `REG',\n-   or a `MEM' representing a location in the stack.\n-\n-   You only need to define this macro if you want to support call frame\n-   debugging information like that provided by DWARF 2.  */\n-#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (SImode, GPR_LINK)\n-\n-/* A C expression whose value is an integer giving the offset, in bytes, from\n-   the value of the stack pointer register to the top of the stack frame at the\n-   beginning of any function, before the prologue.  The top of the frame is\n-   defined to be the value of the stack pointer in the previous frame, just\n-   before the call instruction.\n-\n-   You only need to define this macro if you want to support call frame\n-   debugging information like that provided by DWARF 2.  */\n-#define INCOMING_FRAME_SP_OFFSET 0\n-\n-#define STACK_POINTER_REGNUM GPR_SP\n-\n-#define FRAME_POINTER_REGNUM GPR_FP\n-\n-/* The register number of the arg pointer register, which is used to\n-   access the function's argument list.  */\n-#define ARG_POINTER_REGNUM\t\t(SPECIAL_REG_FIRST + 0)\n-\n-/* Register numbers used for passing a function's static chain pointer.  */\n-#define STATIC_CHAIN_REGNUM 10\n-\n-/* A C expression which is nonzero if a function must have and use a frame\n-   pointer.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Structure to be filled in by compute_frame_size with register\n-   save masks, and offsets for the current function.  */\n-\n-struct ms1_frame_info\n-{\n-  unsigned int total_size;      /* # Bytes that the entire frame takes up.  */\n-  unsigned int pretend_size;    /* # Bytes we push and pretend caller did.  */\n-  unsigned int args_size;       /* # Bytes that outgoing arguments take up.  */\n-  unsigned int extra_size;\n-  unsigned int reg_size;        /* # Bytes needed to store regs.  */\n-  unsigned int var_size;        /* # Bytes that variables take up.  */\n-  unsigned int frame_size;      /* # Bytes in current frame.  */\n-  unsigned int reg_mask;        /* Mask of saved registers.  */\n-  unsigned int save_fp;         /* Nonzero if frame pointer must be saved.  */\n-  unsigned int save_lr;         /* Nonzero if return pointer must be saved.  */\n-  int          initialized;     /* Nonzero if frame size already calculated.  */\n-}; \n-\n-extern struct ms1_frame_info current_frame_info;\n-\n-/* If defined, this macro specifies a table of register pairs used to eliminate\n-   unneeded registers that point into the stack frame.  */\n-#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  {ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\t\t\\\n-  {ARG_POINTER_REGNUM,\t FRAME_POINTER_REGNUM},\t\t\t\t\\\n-  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\t\t\\\n-}\n-\n-/* A C expression that returns non-zero if the compiler is allowed to try to\n-   replace register number FROM with register number TO.  */\n-#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n- ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\\n-  ? ! frame_pointer_needed\t\t\t\t\t\t\\\n-  : 1)\n-\n-/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n-   specifies the initial difference between the specified pair of\n-   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n-   defined.  */\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-  (OFFSET) = ms1_initial_elimination_offset (FROM, TO)\n-\n-/* If defined, the maximum amount of space required for outgoing\n-   arguments will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Define this if it is the responsibility of the caller to\n-   allocate the area reserved for arguments passed in registers.  */\n-#define OUTGOING_REG_PARM_STACK_SPACE\n-\n-/* The number of register assigned to holding function arguments.  */\n-#define MS1_NUM_ARG_REGS        4\n-\n-/* Define this if it is the responsibility of the caller to allocate\n-   the area reserved for arguments passed in registers.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) (MS1_NUM_ARG_REGS * UNITS_PER_WORD)\n-\n-/* Define this macro if `REG_PARM_STACK_SPACE' is defined, but the stack\n-   parameters don't skip the area specified by it.  */\n-#define STACK_PARMS_IN_REG_PARM_AREA\n-\n-/* A C expression that should indicate the number of bytes of its own\n-   arguments that a function pops on returning, or 0 if the function\n-   pops no arguments and the caller must therefore pop them all after\n-   the function returns.  */\n-#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-   ms1_function_arg (& (CUM), (MODE), (TYPE), (NAMED), FALSE)\n-\n-#define CUMULATIVE_ARGS int\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS)\t\\\n-    ms1_init_cumulative_args (& (CUM), FNTYPE, LIBNAME, FNDECL, FALSE)\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-    ms1_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n-\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n-    ms1_function_arg_boundary (MODE, TYPE)\n-\n-#define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\t\t\\\n-  ((REGNO) >= FIRST_ARG_REGNUM && ((REGNO) <= LAST_ARG_REGNUM))\n-\n-#define RETURN_VALUE_REGNUM\tRETVAL_REGNUM\n-     \n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-   ms1_function_value (VALTYPE, TYPE_MODE(VALTYPE), FUNC)\n-\n-#define LIBCALL_VALUE(MODE) \\\n-   ms1_function_value (NULL_TREE, MODE, NULL_TREE)\n-\n-#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == RETURN_VALUE_REGNUM)\n-\n-/* A C expression which can inhibit the returning of certain function\n-   values in registers, based on the type of value.  */\n-#define RETURN_IN_MEMORY(TYPE) (int_size_in_bytes (TYPE) > UNITS_PER_WORD)\n-\n-/* Define this macro to be 1 if all structure and union return values must be\n-   in memory.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* Define this macro as a C expression that is nonzero if the return\n-   instruction or the function epilogue ignores the value of the stack\n-   pointer; in other words, if it is safe to delete an instruction to\n-   adjust the stack pointer before a return from the function.  */\n-#define EXIT_IGNORE_STACK 1\n-\n-#define EPILOGUE_USES(REGNO) ms1_epilogue_uses(REGNO)\n-\n-/* Define this macro if the function epilogue contains delay slots to which\n-   instructions from the rest of the function can be \"moved\".  */\n-#define DELAY_SLOTS_FOR_EPILOGUE 1\n-\n-/* A C expression that returns 1 if INSN can be placed in delay slot number N\n-   of the epilogue.  */\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN, N) 0\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) gcc_unreachable ()\n-\n-#define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG)\t\t\\\n-  ms1_va_start (VALIST, NEXTARG)\n-\n-/* Trampolines are not implemented.  */\n-#define TRAMPOLINE_SIZE 0\n-\n-#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN)\n-\n-/* ?? What is this -- aldyh ?? */\n-#define UCMPSI3_LIBCALL\t\t\"__ucmpsi3\"\n-\n-/* Addressing Modes.  */\n-\n-/* A C expression that is 1 if the RTX X is a constant which is a valid\n-   address.  */\n-#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n-\n-/* A number, the maximum number of registers that can appear in a valid memory\n-   address.  Note that it is up to you to specify a value equal to the maximum\n-   number that `GO_IF_LEGITIMATE_ADDRESS' would ever accept.  */\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-{\t\t\t\t\t\t\\\n-  if (ms1_legitimate_address_p (MODE, X, 1))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-{\t\t\t\t\t\t\\\n-  if (ms1_legitimate_address_p (MODE, X, 0))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n-#endif\n-\n-#ifdef REG_OK_STRICT\n-#define REG_OK_FOR_BASE_P(X) ms1_reg_ok_for_base_p (X, 1)\n-#else\n-#define REG_OK_FOR_BASE_P(X) ms1_reg_ok_for_base_p (X, 0)\n-#endif\n-\n-#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN) {}\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* A C expression for the cost of moving data of mode M between a register and\n-   memory.  A value of 2 is the default; this cost is relative to those in\n-   `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than between two\n-   registers, you should define this macro to express the relative cost.  */\n-#define MEMORY_MOVE_COST(M,C,I) 10\n-\n-/* Define this macro as a C expression which is nonzero if accessing less than\n-   a word of memory (i.e. a `char' or a `short') is no faster than accessing a\n-   word of memory.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1 \n-\n-#define TEXT_SECTION_ASM_OP \".text\"\n-\n-#define DATA_SECTION_ASM_OP \".data\"\n-\n-#define BSS_SECTION_ASM_OP \"\\t.section\\t.bss\"\n-\n-/* A C string constant for text to be output before each `asm' statement or\n-   group of consecutive ones.  Normally this is `\"#APP\"', which is a comment\n-   that has no effect on most assemblers but tells the GNU assembler that it\n-   must check the lines that follow for all valid assembler constructs.  */\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* A C string constant for text to be output after each `asm' statement or\n-   group of consecutive ones.  Normally this is `\"#NO_APP\"', which tells the\n-   GNU assembler to resume making the time-saving assumptions that are valid\n-   for ordinary compiler output.  */\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* This is how to output an assembler line defining a `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.byte\\t\");\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to output an assembler line defining a `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.hword\\t\");\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   We also handle symbol output here.  */\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.word\\t\");\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* A C statement to output to the stdio stream STREAM an assembler instruction\n-   to assemble a single byte containing the number VALUE.\n-\n-   This declaration must be present.  */\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n-  fprintf (STREAM, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.globl \"\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{ \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\",\t\t\t\\\n-  \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\t\t\t\\\n-  \"LOOP1\", \"LOOP2\", \"LOOP3\", \"LOOP4\", \"ap\" }\n-\n-/* If defined, a C initializer for an array of structures containing a name and\n-   a register number.  This macro defines additional names for hard registers,\n-   thus allowing the `asm' option in declarations to refer to registers using\n-   alternate names.  */\n-#define ADDITIONAL_REGISTER_NAMES \\\n-{ { \"FP\", 12}, {\"SP\", 13}, {\"RA\", 14}, {\"IRA\", 15} }\n-\n-/* Define this macro if you are using an unusual assembler that requires\n-   different names for the machine instructions.\n-\n-   The definition is a C statement or statements which output an assembler\n-   instruction opcode to the stdio stream STREAM.  The macro-operand PTR is a\n-   variable of type `char *' which points to the opcode name in its \"internal\"\n-   form--the form that is written in the machine description.  The definition\n-   should output the opcode name to STREAM, performing any translation you\n-   desire, and increment the variable PTR to point at the end of the opcode so\n-   that it will not be output twice.  */\n-#define ASM_OUTPUT_OPCODE(STREAM, PTR) \\\n-   (PTR) = ms1_asm_output_opcode (STREAM, PTR)\n-\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n-  ms1_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n-\n-#define PRINT_OPERAND(STREAM, X, CODE) ms1_print_operand (STREAM, X, CODE)\n-\n-/* A C expression which evaluates to true if CODE is a valid punctuation\n-   character for use in the `PRINT_OPERAND' macro.  */\n-/* #:  Print nop for delay slot.  */\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n-\n-#define PRINT_OPERAND_ADDRESS(STREAM, X) ms1_print_operand_address (STREAM, X)\n-\n-/* If defined, C string expressions to be used for the `%R', `%L', `%U', and\n-   `%I' options of `asm_fprintf' (see `final.c').  These are useful when a\n-   single `md' file must support multiple assembler formats.  In that case, the\n-   various `tm.h' files can define these macros differently.\n-\n-   USER_LABEL_PREFIX is defined in svr4.h.  */\n-#define REGISTER_PREFIX     \"%\"\n-#define LOCAL_LABEL_PREFIX  \".\"\n-#define USER_LABEL_PREFIX   \"\"\n-#define IMMEDIATE_PREFIX    \"\"\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are relative to the table's own address.\n-\n-   The definition should be a C statement to output to the stdio stream STREAM\n-   an assembler pseudo-instruction to generate a difference between two labels.\n-   VALUE and REL are the numbers of two internal labels.  The definitions of\n-   these labels are output using `targetm.asm_out.internal_label', and they\n-   must be printed in the same way here.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL) \\\n-fprintf (STREAM, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are absolute.\n-\n-   The definition should be a C statement to output to the stdio stream STREAM\n-   an assembler pseudo-instruction to generate a reference to a label.  VALUE\n-   is the number of an internal label whose definition is output using\n-   `targetm.asm_out.internal_label'.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n-fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n-\n-#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (GPR_LINK)\n-\n-#define EH_RETURN_DATA_REGNO(N) \\\n-  ((N) == 0 ? GPR_R7 : (N) == 1 ? GPR_R8 : INVALID_REGNUM)\n-\n-#define EH_RETURN_STACKADJ_REGNO\tGPR_R11\n-#define EH_RETURN_STACKADJ_RTX\t\t\\\n-\tgen_rtx_REG (SImode, EH_RETURN_STACKADJ_REGNO)\n-#define EH_RETURN_HANDLER_REGNO\t\tGPR_R10\n-#define EH_RETURN_HANDLER_RTX\t\t\\\n-\tgen_rtx_REG (SImode, EH_RETURN_HANDLER_REGNO)\n-\f\n-#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n-  fprintf ((STREAM), \"\\t.p2align %d\\n\", (POWER))\n-\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-#ifndef DWARF2_DEBUGGING_INFO\n-#define DWARF2_DEBUGGING_INFO\n-#endif\n-\n-/* Define this macro if GCC should produce dwarf version 2-style\n-   line numbers.  This usually requires extending the assembler to\n-   support them, and #defining DWARF2_LINE_MIN_INSN_LENGTH in the\n-   assembler configuration header files.  */\n-#define DWARF2_ASM_LINE_DEBUG_INFO 1\n-\n-/* An alias for a machine mode name.  This is the machine mode that\n-   elements of a jump-table should have.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define this macro if operations between registers with integral\n-   mode smaller than a word are always performed on the entire\n-   register.  Most RISC machines have this property and most CISC\n-   machines do not.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* The maximum number of bytes that a single instruction can move quickly from\n-   memory to memory.  */\n-#define MOVE_MAX 4\n-\n-/* A C expression which is nonzero if on this machine it is safe to \"convert\"\n-   an integer of INPREC bits to one of OUTPREC bits (where OUTPREC is smaller\n-   than INPREC) by merely operating on it as if it had only OUTPREC bits.\n-\n-   On many machines, this expression can be 1.\n-\n-   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for modes for\n-   which `MODES_TIEABLE_P' is 0, suboptimal code can result.  If this is the\n-   case, making `TRULY_NOOP_TRUNCATION' return 0 in such cases may improve\n-   things.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-#define Pmode SImode\n-\n-/* An alias for the machine mode used for memory references to functions being\n-   called, in `call' RTL expressions.  On most machines this should be\n-   `QImode'.  */\n-#define FUNCTION_MODE QImode\n-\n-#define HANDLE_SYSV_PRAGMA 1\n-\n-/* Indicate how many instructions can be issued at the same time.  */\n-#define ISSUE_RATE 1\n-\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-extern struct rtx_def * ms1_compare_op0;\n-extern struct rtx_def * ms1_compare_op1;\n-"}, {"sha": "104f2829e29a4b4b47146a4f0908cbf8e0503b69", "filename": "gcc/config/ms1/mt.md", "status": "removed", "additions": 0, "deletions": 1500, "changes": 1500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fmt.md?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,1500 +0,0 @@\n-;; Machine description for MorphoRISC1\n-;; Copyright (C) 2005 Free Software Foundation, Inc.\n-;; Contributed by Red Hat, Inc.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING.  If not, write to the Free\n-;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-;; 02110-1301, USA.\n-\f\n-;; UNSPECs\n-(define_constants\n-  [\n-    (UNSPEC_BLOCKAGE 0)\n-    (UNSPEC_EI 1)\n-    (UNSPEC_DI 2)\n-    (UNSPEC_LOOP 3)\n-  ])\n-\n-;; Attributes\n-(define_attr \"type\" \"branch,call,load,store,io,arith,complex,unknown\"\n-\t (const_string \"unknown\") )\n-\n-;; If the attribute takes numeric values, no `enum' type will be defined and\n-;; the function to obtain the attribute's value will return `int'.\n-\n-(define_attr \"length\" \"\" (const_int 4))\n-\n-\f\n-;; DFA scheduler.\n-(define_automaton \"other\")\n-(define_cpu_unit \"decode_unit\" \"other\")\n-(define_cpu_unit \"memory_unit\" \"other\")\n-(define_cpu_unit \"branch_unit\" \"other\")\n-\n-(define_insn_reservation \"mem_access\" 2\n-  (ior (eq_attr \"type\" \"load\") (eq_attr \"type\" \"store\"))\n-  \"decode_unit+memory_unit*2\")\n-\n-(define_insn_reservation \"io_access\" 2\n-  (eq_attr \"type\" \"io\")\n-  \"decode_unit+memory_unit*2\")\n-\n-(define_insn_reservation \"branch_access\" 2\n-  (ior (eq_attr \"type\" \"branch\")\n-       (eq_attr \"type\" \"call\"))\n-  \"decode_unit+branch_unit*2\")\n-\n-(define_insn_reservation \"arith_access\" 1\n-  (eq_attr \"type\" \"arith\")\n-  \"decode_unit\")\n-\n-(define_bypass 2 \"arith_access\" \"branch_access\")\n-(define_bypass 3 \"mem_access\" \"branch_access\")\n-(define_bypass 3 \"io_access\" \"branch_access\")\n-\n-\f\n-;; Delay Slots\n-\n-;; The ms1 does not allow branches in the delay slot.\n-;; The ms1 does not allow back to back memory or io instruction.\n-;; The compiler does not know what the type of instruction is at\n-;; the destination of the branch.  Thus, only type that will be acceptable\n-;; (safe) is the arith type.\n-\n-(define_delay (ior (eq_attr \"type\" \"branch\")\n-\t\t   (eq_attr \"type\" \"call\"))\n-\t\t [(eq_attr \"type\" \"arith\") (nil) (nil)])\n-\n-\f\n-(define_insn \"decrement_and_branch_until_zero\"\n-   [(set (pc)\n-\t (if_then_else\n-\t  (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+r,*m\")\n-\t      (const_int 0))\n-\t  (label_ref (match_operand 1 \"\" \"\"))\n-\t  (pc)))\n-    (set (match_dup 0)\n-\t (plus:SI (match_dup 0)\n-\t\t  (const_int -1)))\n-    (clobber (match_scratch:SI 2 \"=X,&r\"))]\n-  \"TARGET_MS1_16_003 || TARGET_MS2\"\n-  \"@\n-   dbnz\\t%0, %l1%#\n-   #\"\n-  [(set_attr \"length\" \"4,16\")\n-   (set_attr \"type\" \"branch,unknown\")]\n-)\n-\n-;; Split the above to handle the case where operand 0 is in memory\n-;; (a register that couldn't get a hard register).\n-(define_split\n-  [(set (pc)\n-\t(if_then_else\n-\t  (ne (match_operand:SI 0 \"memory_operand\" \"\")\n-\t      (const_int 0))\n-\t  (label_ref (match_operand 1 \"\" \"\"))\n-\t  (pc)))\n-    (set (match_dup 0)\n-\t (plus:SI (match_dup 0)\n-\t\t  (const_int -1)))\n-    (clobber (match_scratch:SI 2 \"\"))]\n-  \"TARGET_MS1_16_003 || TARGET_MS2\"\n-  [(set (match_dup 2) (match_dup 0))\n-   (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n-   (set (match_dup 0) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else\n-\t (ne (match_dup 2)\n-\t     (const_int 0))\n-\t (label_ref (match_dup 1))\n-\t (pc)))]\n-  \"\")\n-\n-;; This peephole is defined in the vain hope that it might actually trigger one\n-;; day, although I have yet to find a test case that matches it.  The normal\n-;; problem is that GCC likes to move the loading of the constant value -1 out\n-;; of the loop, so it is not here to be matched.\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0) (const_int -1)))\n-   (set (match_operand:SI 1 \"register_operand\" \"\")\n-     (const_int -1))\n-   (set (pc) (if_then_else\n-\t        (ne (match_dup 0) (match_dup 1))\n-\t\t(label_ref (match_operand 2 \"\" \"\"))\n-\t\t(pc)))]\n-  \"TARGET_MS1_16_003 || TARGET_MS2\"\n-  [(parallel [(set (pc)\n-\t           (if_then_else\n-\t              (ne (match_dup 0) (const_int 0))\n-\t              (label_ref (match_dup 2))\n-\t              (pc)))\n-              (set (match_dup 0)\n-\t           (plus:SI (match_dup 0) (const_int -1)))\n-\t      (clobber (reg:SI 0))])]\n-  \"\")\n-\n-\f\n-;; Loop instructions.  ms2 has a low overhead looping instructions.\n-;; these take a constant or register loop count and a loop length\n-;; offset.  Unfortunately the loop can only be up to 256 instructions,\n-;; We deal with longer loops by moving the loop end upwards.  To do\n-;; otherwise would force us to to be very pessimistic right up until\n-;; the end.\n-\n-;; This instruction is a placeholder to make the control flow explicit.\n-(define_insn \"loop_end\"\n-  [(set (pc) (if_then_else\n-\t\t\t  (ne (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t\t      (const_int 1))\n-\t\t\t  (label_ref (match_operand 1 \"\" \"\"))\n-\t\t\t  (pc)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))\n-   (unspec [(const_int 0)] UNSPEC_LOOP)]\n-  \"TARGET_MS2\"\n-  \";loop end %0,%l1\"\n-  [(set_attr \"length\" \"0\")])\n-\n-;; This is the real looping instruction.  It is placed just before the\n-;; loop body.  We make it a branch insn, so it stays at the end of the\n-;; block it is in.\n-(define_insn \"loop_init\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:SI 1 \"uns_arith_operand\" \"r,K\"))\n-   (unspec [(label_ref (match_operand 2 \"\" \"\"))] UNSPEC_LOOP)]\n-  \"TARGET_MS2\"\n-  \"@\n-   loop  %1,%l2 ;%0%#\n-   loopi %1,%l2 ;%0%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the label to jump to at the top of the loop\n-(define_expand \"doloop_end\"\n-  [(parallel [(set (pc) (if_then_else\n-\t\t\t  (ne (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t\t      (const_int 0))\n-\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n-\t\t\t  (pc)))\n-\t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (const_int -1)))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n-  \"TARGET_MS1_16_003 || TARGET_MS2\"\n-  {ms1_add_loop ();})\n-\f\n-;; Moves\n-\n-(define_expand \"loadqi\"\n-  [\n-   ;; compute shift\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(and:SI (match_dup 1) (const_int 3)))\n-   (set (match_dup 2)\t(xor:SI (match_dup 2) (const_int 3)))\n-   (set (match_dup 2 )\t(ashift:SI (match_dup 2) (const_int 3)))\n-\n-   ;; get word that contains byte\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mem:SI (and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t(const_int -3))))\n-\n-   ;; align byte\n-   (set (match_dup 0)   (ashiftrt:SI (match_dup 0) (match_dup 2)))\n-  ]\n-  \"\"\n-  \"\")\n-\n-\n-;; storeqi\n-;; operand 0 byte value to store\n-;; operand 1 address\n-;; operand 2 temp, word containing byte\n-;; operand 3 temp, shift count\n-;; operand 4 temp, mask, aligned and masked byte\n-;; operand 5 (unused)\n-(define_expand \"storeqi\"\n-  [\n-   ;; compute shift\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int 3)))\n-   (set (match_dup 3)\t(xor:SI (match_dup 3) (const_int 3)))\n-   (set (match_dup 3)\t(ashift:SI (match_dup 3) (const_int 3)))\n-\n-   ;; get word that contains byte\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(mem:SI (and:SI (match_dup 1) (const_int -3))))\n-\n-   ;; generate mask\n-   (set (match_operand:SI 4 \"register_operand\" \"\") (const_int 255))\n-   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n-   (set (match_dup 4) (not:SI (match_dup 4)))\n-\n-   ;; clear appropriate bits\n-   (set (match_dup 2) (and:SI (match_dup 2) (match_dup 4)))\n-\n-   ;; align byte\n-   (set (match_dup 4)\n-\t(and:SI (match_operand:SI 0 \"register_operand\" \"\") (const_int 255)))\n-   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n-\n-   ;; combine\n-   (set (match_dup 2) (ior:SI (match_dup 4) (match_dup 2)))\n-   ;; store updated word\n-   (set (mem:SI (and:SI (match_dup 1) (const_int -3))) (match_dup 2))\n-  ]\n-  \"\"\n-  \"\")\n-\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (!reload_in_progress\n-      && !reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (QImode, operands[1]);\n-  \n-  if ( (! TARGET_BYTE_ACCESS) && GET_CODE (operands[0]) == MEM)\n-    {\n-\trtx scratch1 = gen_reg_rtx (SImode);\n-\trtx scratch2 = gen_reg_rtx (SImode);\n-\trtx scratch3 = gen_reg_rtx (SImode);\n-\trtx data     = operands[1];\n-\trtx address  = XEXP (operands[0], 0);\n-\trtx seq;\n-\n-\tif ( GET_CODE (data) != REG )\n-\t    data = copy_to_mode_reg (QImode, data);\n-\n-\tif ( GET_CODE (address) != REG )\n-\t  address = copy_to_mode_reg (SImode, address);\n-\n-\tstart_sequence ();\n-\temit_insn (gen_storeqi (gen_lowpart (SImode, data), address,\n-\t\t\t\tscratch1, scratch2, scratch3));\n-\tms1_set_memflags (operands[0]);\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\temit_insn (seq);\n-\tDONE;\n-    }\n-\n-  if ( (! TARGET_BYTE_ACCESS) && GET_CODE (operands[1]) == MEM)\n-    {\n-\trtx scratch1 = gen_reg_rtx (SImode);\n-\trtx data = operands[0];\n-\trtx address = XEXP (operands[1], 0);\n-\trtx seq;\n-\n-\tif ( GET_CODE (address) != REG )\n-\t  address = copy_to_mode_reg (SImode, address);\n-\n-\tstart_sequence ();\n-\temit_insn (gen_loadqi (gen_lowpart (SImode, data), address, scratch1));\n-\tms1_set_memflags (operands[1]);\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\temit_insn (seq);\n-\tDONE;\n-    }\n-\n-   /* If the load is a pseudo register in a stack slot, some simplification\n-      can be made because the loads are aligned */\n-  if ( (! TARGET_BYTE_ACCESS) \n-        && (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n-\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n-    {\n-\trtx data = operands[0];\n-\trtx address = XEXP (operands[1], 0);\n-\trtx seq;\n-\n-\tstart_sequence ();\n-\temit_insn (gen_movsi (gen_lowpart (SImode, data), address));\n-\tms1_set_memflags (operands[1]);\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\temit_insn (seq);\n-\tDONE;\n-    }\n-}\")\n-\n-(define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,r\")\n-\t(match_operand:QI 1 \"general_operand\" \"r,m,r,I\"))]\n-  \"TARGET_BYTE_ACCESS\n-    && (!memory_operand (operands[0], QImode)\n-        || !memory_operand (operands[1], QImode))\"\n-  \"@\n-   or  %0, %1, %1\n-   ldb %0, %1\n-   stb %1, %0\n-   addi %0, r0, %1\"\n-  [(set_attr \"length\" \"4,4,4,4\")\n-   (set_attr \"type\" \"arith,load,store,arith\")])\n-\n-(define_insn \"*movqi_internal_nobyte\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:QI 1 \"arith_operand\" \"r,I\"))]\n-  \"!TARGET_BYTE_ACCESS\n-    && (!memory_operand (operands[0], QImode)\n-        || !memory_operand (operands[1], QImode))\"\n-  \"@\n-   or   %0, %1, %1\n-   addi %0, r0, %1\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-\n-;; The MorphoRISC does not have 16-bit loads and stores.\n-;; These operations must be synthesized.  Note that the code\n-;; for loadhi and storehi assumes that the least significant bits\n-;; is ignored.\n-\n-;; loadhi\n-;; operand 0 location of result\n-;; operand 1 memory address\n-;; operand 2 temp\n-(define_expand \"loadhi\"\n-  [\n-   ;; compute shift\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(and:SI (match_dup 1) (const_int 2)))\n-   (set (match_dup 2)\t(xor:SI (match_dup 2) (const_int 2)))\n-   (set (match_dup 2 )\t(ashift:SI (match_dup 2) (const_int 3)))\n-\n-   ;; get word that contains the 16-bits\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mem:SI (and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t(const_int -3))))\n-\n-   ;; align 16-bit value\n-   (set (match_dup 0)\t(ashiftrt:SI (match_dup 0) (match_dup 2)))\n-  ]\n-  \"\"\n-  \"\")\n-\n-;; storehi\n-;; operand 0 byte value to store\n-;; operand 1 address\n-;; operand 2 temp, word containing byte\n-;; operand 3 temp, shift count\n-;; operand 4 temp, mask, aligned and masked byte\n-;; operand 5 (unused)\n-(define_expand \"storehi\"\n-  [\n-   ;; compute shift\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int 2)))\n-   (set (match_dup 3)\t(xor:SI (match_dup 3) (const_int 2)))\n-   (set (match_dup 3)\t(ashift:SI (match_dup 3) (const_int 3)))\n-\n-   ;; get word that contains the 16-bits\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(mem:SI (and:SI (match_dup 1) (const_int -3))))\n-\n-   ;; generate mask\n-   (set (match_operand:SI 4 \"register_operand\" \"\") (const_int 65535))\n-   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n-   (set (match_dup 4) (not:SI (match_dup 4)))\n-\n-   ;; clear appropriate bits\n-   (set (match_dup 2) (and:SI (match_dup 2) (match_dup 4)))\n-\n-   ;; align 16-bit value\n-   (set (match_dup 4)\n-\t(and:SI (match_operand:SI 0 \"register_operand\" \"\") (const_int 65535)))\n-   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n-\n-   ;; combine\n-   (set (match_dup 2) (ior:SI (match_dup 4) (match_dup 2)))\n-   ;; store updated word\n-   (set (mem:SI (and:SI (match_dup 1) (const_int -3))) (match_dup 2))\n-  ]\n-  \"\"\n-  \"\")\n-\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (!reload_in_progress\n-      && !reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (HImode, operands[1]);\n-\n-  if ( GET_CODE (operands[0]) == MEM)\n-    {\n-\trtx scratch1 = gen_reg_rtx (SImode);\n-\trtx scratch2 = gen_reg_rtx (SImode);\n-\trtx scratch3 = gen_reg_rtx (SImode);\n-\trtx data     = operands[1];\n-\trtx address  = XEXP (operands[0], 0);\n-\trtx seq;\n-\n-\tif (GET_CODE (data) != REG)\n-\t  data = copy_to_mode_reg (HImode, data);\n-\n-\tif (GET_CODE (address) != REG)\n-\t  address = copy_to_mode_reg (SImode, address);\n-\n-\tstart_sequence ();\n-\temit_insn (gen_storehi (gen_lowpart (SImode, data), address,\n-\t\t\t        scratch1, scratch2, scratch3));\n-\tms1_set_memflags (operands[0]);\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\temit_insn (seq);\n-\tDONE;\n-    }\n-\n-  if ( GET_CODE (operands[1]) == MEM)\n-    {\n-\trtx scratch1 = gen_reg_rtx (SImode);\n-\trtx data     = operands[0];\n-\trtx address  = XEXP (operands[1], 0);\n-\trtx seq;\n-\n-\tif (GET_CODE (address) != REG)\n-\t    address = copy_to_mode_reg (SImode, address);\n-\n-\tstart_sequence ();\n-\temit_insn (gen_loadhi (gen_lowpart (SImode, data), address,\n-\t\t\t       scratch1));\n-\tms1_set_memflags (operands[1]);\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\temit_insn (seq);\n-\tDONE;\n-    }\n-\n-   /* If the load is a pseudo register in a stack slot, some simplification\n-      can be made because the loads are aligned */\n-  if ( (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n-\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n-    {\n-\trtx data = operands[0];\n-\trtx address = XEXP (operands[1], 0);\n-\trtx seq;\n-\n-\tstart_sequence ();\n-\temit_insn (gen_movsi (gen_lowpart (SImode, data), address));\n-\tms1_set_memflags (operands[1]);\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\temit_insn (seq);\n-\tDONE;\n-    }\n-}\")\n-\n-(define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:HI 1 \"arith_operand\" \"r,I\"))]\n-  \"!memory_operand (operands[0], HImode) || !memory_operand (operands[1], HImode)\"\n-  \"@\n-  or    %0, %1, %1\n-  addi  %0, r0, %1\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (!reload_in_progress  && !reload_completed\n-      && !register_operand (operands[0], SImode)\n-      && !register_operand (operands[1], SImode))\n-    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n-\n-  /* Take care of constants that don't fit in single instruction */\n-  if ( (reload_in_progress || reload_completed)\n-   && !single_const_operand (operands[1], SImode))\n-    {\n-      emit_insn (gen_movsi_high (operands[0], operands[1]));\n-      emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-}\")\n-\n-(define_insn \"movsi_high\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (high:SI (match_operand:SI 1 \"general_operand\" \"i\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"ldui\\\\t%0, %H1\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-\n-(define_insn \"movsi_lo_sum\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-                   (match_operand:SI 2 \"general_operand\" \"i\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"addui\\\\t%0, %1, %L2\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-/* Take care of constants that don't fit in single instruction */\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"(reload_in_progress || reload_completed)\n-   && !single_const_operand (operands[1], SImode)\"\n-\n-  [(set (match_dup 0 )\n-        (high:SI (match_dup 1)))\n-   (set (match_dup 0 )\n-        (lo_sum:SI (match_dup 0)\n-                   (match_dup 1)))]\n-)\n-\n-\n-;; The last pattern in movsi (with two instructions)\n-;; is really handled by the emit_insn's in movsi\n-;; and the define_split above.  This provides additional\n-;; instructions to fill delay slots.\n-\n-;; Note - it is best to only have one movsi pattern and to handle\n-;; all the various contingencies by the use of alternatives.  This\n-;; allows reload the greatest amount of flexibility (since reload will\n-;; only choose amoungst alternatives for a selected insn, it will not\n-;; replace the insn with another one).\n-(define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,r\")\n-\t(match_operand:SI 1 \"general_operand\"       \"r,m,r,I,P,L,N,i\"))]\n-  \"(!memory_operand (operands[0], SImode) || !memory_operand (operands[1], SImode))\n-   && !((reload_in_progress || reload_completed)\n-\t && !single_const_operand (operands[1], SImode))\"\n-  \"@\n-  or     %0, %1, %1\n-  ldw    %0, %1\n-  stw    %1, %0\n-  addi   %0, r0, %1\n-  addui  %0, r0, %1\n-  ldui   %0, %H1\n-  nori   %0, r0, %N1\n-  ldui   %0, %H1\\;addui %0, %0, %L1\"\n-  [(set_attr \"length\" \"4,4,4,4,4,4,4,8\")\n-   (set_attr \"type\" \"arith,load,store,arith,arith,arith,arith,complex\")]\n-)\n-\n-;; Floating Point Moves\n-;;\n-;; Note - Patterns for SF mode moves are compulsory, but\n-;; patterns for DF are optional, as GCC can synthesize them.\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (!reload_in_progress\n-      && !reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM\n-         || GET_CODE (operands[1]) == CONST_DOUBLE))\n-    operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n-\n-  /* Take care of reg <- SF constant */\n-  if ( const_double_operand (operands[1], GET_MODE (operands[1]) ) )\n-    {\n-      emit_insn (gen_movsf_high (operands[0], operands[1]));\n-      emit_insn (gen_movsf_lo_sum (operands[0], operands[0], operands[1]));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"movsf_lo_sum\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-        (lo_sum:SF (match_operand:SF 1 \"register_operand\" \"r\")\n-                   (match_operand:SF 2 \"const_double_operand\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  REAL_VALUE_TYPE r;\n-  long i;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[2]);\n-  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-  operands[2] = GEN_INT (i);\n-  return \\\"addui\\\\t%0, %1, %L2\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-(define_insn \"movsf_high\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-        (high:SF (match_operand:SF 1 \"const_double_operand\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  REAL_VALUE_TYPE r;\n-  long i;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-  operands[1] = GEN_INT (i);\n-  return \\\"ldui\\\\t%0, %H1\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-\n-(define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:SF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n-  \"!memory_operand (operands[0], SFmode) || !memory_operand (operands[1], SFmode)\"\n-  \"@\n-  or     %0, %1, %1\n-  ldw    %0, %1\n-  stw    %1, %0\"\n-  [(set_attr \"length\" \"4,4,4\")\n-   (set_attr \"type\" \"arith,load,store\")]\n-)\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register or 0 */\n-  if (!register_operand (operand0, DFmode)\n-      && !reg_or_0_operand (operand1, DFmode))\n-    operands[1] = copy_to_mode_reg (DFmode, operand1);\n-}\")\n-\n-(define_insn_and_split \"*movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(match_operand:DF 1 \"general_operand\" \t   \"rim,r\"))]\n-  \"! (memory_operand (operands[0], DFmode)\n-         && memory_operand (operands[1], DFmode))\"\n-  \"#\"\n-\n-  \"(reload_completed || reload_in_progress)\"\n-\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))\n-  ]\n-\n-  \"{\n-    /* figure out what precisely to put into operands 2, 3, 4, and 5 */\n-    ms1_split_words (SImode, DFmode, operands);\n-  }\"\n-)\n-\n-\f\n-;; Reloads\n-\n-;; Like `movM', but used when a scratch register is required to move between\n-;; operand 0 and operand 1.  Operand 2 describes the scratch register.  See the\n-;; discussion of the `SECONDARY_RELOAD_CLASS' macro.\n-\n-(define_expand \"reload_inqi\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (match_operand:QI 1 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))]\n-  \"! TARGET_BYTE_ACCESS\"\n-  \"\n-{\n-  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n-  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n-  rtx data = operands[0];\n-  rtx address = XEXP (operands[1], 0);\n-  rtx swap, seq;\n-\n-  /* It is possible that the registers we got for scratch1\n-     might coincide with that of operands[0].  gen_loadqi\n-     requires operand0 and operand2 to be different registers.\n-     The following statement ensure that is always the case. */\n-  if (REGNO(operands[0]) == REGNO(scratch1))\n-    {\n-\tswap = scratch1;\n-\tscratch1 = scratch2;\n-\tscratch2 = swap;\n-    }\n-\n-  /* need to make sure address is already in register */\n-  if ( GET_CODE (address) != REG )\n-    address = force_operand (address, scratch2);\n-\n-  start_sequence ();\n-  emit_insn (gen_loadqi (gen_lowpart (SImode, data), address, scratch1));\n-  ms1_set_memflags (operands[1]);\n-  seq = get_insns ();\n-  end_sequence ();\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\n-(define_expand \"reload_outqi\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n-        (match_operand:QI 1 \"register_operand\" \"r\"))\n-   (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))]\n-  \"! TARGET_BYTE_ACCESS\"\n-  \"\n-{\n-  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n-  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n-  rtx scratch3 = gen_rtx_REG (SImode, REGNO (operands[2])+2);\n-  rtx scratch4 = gen_rtx_REG (SImode, REGNO (operands[2])+3);\n-  rtx data     = operands[1];\n-  rtx address  = XEXP (operands[0], 0);\n-  rtx seq;\n-\n-  /* need to make sure address is already in register */\n-  if ( GET_CODE (address) != REG )\n-    address = force_operand (address, scratch4);\n-\n-  start_sequence ();\n-  emit_insn (gen_storeqi (gen_lowpart (SImode, data), address, \n-\t\t\t  scratch1, scratch2, scratch3));\n-  ms1_set_memflags (operands[0]);\n-  seq = get_insns ();\n-  end_sequence ();\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\n-(define_expand \"reload_inhi\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (match_operand:HI 1 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))]\n-  \"\"\n-  \"\n-{\n-  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n-  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n-  rtx data     = operands[0];\n-  rtx address  = XEXP (operands[1], 0);\n-  rtx swap, seq;\n-\n-  /* It is possible that the registers we got for scratch1\n-     might coincide with that of operands[0].  gen_loadqi\n-     requires operand0 and operand2 to be different registers.\n-     The following statement ensure that is always the case. */\n-  if (REGNO(operands[0]) == REGNO(scratch1))\n-    {\n-\tswap = scratch1;\n-\tscratch1 = scratch2;\n-\tscratch2 = swap;\n-    }\n-\n-  /* need to make sure address is already in register */\n-  if ( GET_CODE (address) != REG )\n-    address = force_operand (address, scratch2);\n-\n-  start_sequence ();\n-  emit_insn (gen_loadhi (gen_lowpart (SImode, data), address,\n-\t\t         scratch1));\n-  ms1_set_memflags (operands[1]);\n-  seq = get_insns ();\n-  end_sequence ();\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\n-(define_expand \"reload_outhi\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n-        (match_operand:HI 1 \"register_operand\" \"r\"))\n-   (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))]\n-  \"\"\n-  \"\n-{\n-  rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));\n-  rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2])+1);\n-  rtx scratch3 = gen_rtx_REG (SImode, REGNO (operands[2])+2);\n-  rtx scratch4 = gen_rtx_REG (SImode, REGNO (operands[2])+3);\n-  rtx data     = operands[1];\n-  rtx address  = XEXP (operands[0], 0);\n-  rtx seq;\n-\n-  /* need to make sure address is already in register */\n-  if ( GET_CODE (address) != REG )\n-    address = force_operand (address, scratch4);\n-\n-  start_sequence ();\n-  emit_insn (gen_storehi (gen_lowpart (SImode, data), address,\n-\t\t          scratch1, scratch2, scratch3));\n-  ms1_set_memflags (operands[0]);\n-  seq = get_insns ();\n-  end_sequence ();\n-  emit_insn (seq);\n-  DONE;\n-}\")\n-\n-\f\n-;; 32 bit Integer arithmetic\n-\n-;; Addition\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"r,I\")))]\n-  \"\"\n-  \"@\n-  add %0, %1, %2\n-  addi %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-;; Subtraction\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ,rJ\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"rJ,I\")))]\n-  \"\"\n-  \"@\n-  sub %0, %z1, %z2\n-  subi %0, %z1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-;;  Negation \n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"r,I\")))]\n-  \"\"\n-  \"@\n-  sub  %0, r0, %1\n-  subi  %0, r0, %1\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-\f\n-;; 32 bit Integer Shifts and Rotates\n-\n-;; Arithmetic Shift Left\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-  lsl %0, %1, %2\n-  lsli %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-;; Arithmetic Shift Right\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n-\t\t     (match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-  asr %0, %1, %2\n-  asri %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-;; Logical Shift Right\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n-\t\t     (match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-  lsr %0, %1, %2\n-  lsri %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-\f\n-;; 32 Bit Integer Logical operations\n-\n-;; Logical AND, 32 bit integers\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-  and %0, %1, %2\n-  andi %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-;; Inclusive OR, 32 bit integers\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-  or %0, %1, %2\n-  ori %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-;; Exclusive OR, 32 bit integers\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n-\t\t(match_operand:SI 2 \"uns_arith_operand\" \"r,K\")))]\n-  \"\"\n-  \"@\n-  xor %0, %1, %2\n-  xori %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-\n-;; One's complement, 32 bit integers\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"nor %0, %1, %1\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-\f\n-;; Multiply\n-\n-(define_insn \"mulhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-     (mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%r,r\"))\n-     \t      (sign_extend:SI (match_operand:HI 2 \"arith_operand\" \"r,I\"))))]\n-  \"TARGET_MS1_16_003 || TARGET_MS2\"\n-  \"@\n-  mul %0, %1, %2\n-  muli %0, %1, %2\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"type\" \"arith,arith\")])\n-\n-\f\n-;; Comparisons\n-\n-;; Note, we store the operands in the comparison insns, and use them later\n-;; when generating the branch or scc operation.\n-\n-;; First the routines called by the machine independent part of the compiler\n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-        (compare (match_operand:SI 0 \"register_operand\" \"\")\n-  \t\t (match_operand:SI 1 \"arith_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  ms1_compare_op0 = operands[0];\n-  ms1_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-\f\n-;; Branches\n-\n-(define_expand \"beq\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (EQ, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bne\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (NE, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (GE, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (GT, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"ble\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (LE, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"blt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (LT, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (GEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (GTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (LEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (LTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bunge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{  ms1_emit_cbranch (GEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bungt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  ms1_emit_cbranch (GTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bunle\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  ms1_emit_cbranch (LEU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_expand \"bunlt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  ms1_emit_cbranch (LTU, operands[0],\n-\tms1_compare_op0, ms1_compare_op1);\n-  DONE;\n-}\")\n-\n-(define_insn \"*beq_true\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"breq %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*beq_false\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"brne %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-\n-(define_insn \"*bne_true\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brne %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*bne_false\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"breq %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*blt_true\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brlt %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*blt_false\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"brle %z1, %z0,%l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*ble_true\"\n-  [(set (pc)\n-\t(if_then_else (le (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brle %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*ble_false\"\n-  [(set (pc)\n-\t(if_then_else (le (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"brlt %z1, %z0,%l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*bgt_true\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brlt %z1, %z0, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*bgt_false\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"brle %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*bge_true\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"brle %z1, %z0,%l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*bge_false\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:SI 0 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"brlt %z0, %z1, %l2%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-;; No unsigned operators on Morpho ms1.  All the unsigned operations are\n-;; converted to the signed operations above.\n-\n-\f\n-;; Set flag operations\n-\n-;; \"seq\", \"sne\", \"slt\", \"sle\", \"sgt\", \"sge\", \"sltu\", \"sleu\",\n-;; \"sgtu\", and \"sgeu\" don't exist as regular instruction on the\n-;; ms1, so these are not defined\n-\n-;; Call and branch instructions\n-\n-(define_expand \"call\"\n-  [(parallel [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t\t    (match_operand 1 \"\" \"\"))\n-\t      (clobber (reg:SI 14))])]\n-  \"\"\n-  \"\n-{\n-    operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n-}\")\n-\n-(define_insn \"call_internal\"\n-  [(call (mem:SI (match_operand 0 \"register_operand\" \"r\"))\n-\t (match_operand 1 \"\" \"\"))\n-   ;; possibly add a clobber of the reg that gets the return address\n-   (clobber (reg:SI 14))]\n-  \"\"\n-  \"jal r14, %0%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-(define_expand \"call_value\"\n-  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n-\t\t   (call (mem:SI (match_operand:SI 1 \"register_operand\" \"\"))\n-\t\t\t\t (match_operand 2 \"general_operand\" \"\")))\n-\t      (clobber (reg:SI 14))])]\n-  \"\"\n-  \"\n-{\n-    operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n-}\")\n-\n-\n-(define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(call (mem:SI (match_operand 1 \"register_operand\" \"r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-\t;; possibly add a clobber of the reg that gets the return address\n-\t(clobber (reg:SI 14))]\n-  \"\"\n-  \"jal r14, %1%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-;; Subroutine return\n-(define_insn \"return_internal\"\n-  [(const_int 2)\n-   (return)\n-   (use (reg:SI 14))]\n-  \"\"\n-  \"jal r0, r14%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-;; Interrupt return\n-(define_insn \"return_interrupt_internal\"\n-  [(const_int 3)\n-   (return)\n-   (use (reg:SI 15))]\n-  \"\"\n-  \"reti r15%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-;; Subroutine return\n-(define_insn \"eh_return_internal\"\n-  [(return)\n-   (use (reg:SI 7))\n-   (use (reg:SI 8))\n-   (use (reg:SI 11))\n-   (use (reg:SI 10))]\n-  \"\"\n-  \"jal r0, r11%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-\n-;; Normal unconditional jump\n-(define_insn \"jump\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"jmp %l0%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-;; Indirect jump through a register\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"jal r0,%0%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jal r0, %0%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")])\n-\n-\f\n-(define_expand \"prologue\"\n-  [(const_int 1)]\n-  \"\"\n-  \"\n-{\n-  ms1_expand_prologue ();\n-  DONE;\n-}\")\n-\n-(define_expand \"epilogue\"\n-  [(const_int 2)]\n-  \"\"\n-  \"\n-{\n-  ms1_expand_epilogue (NORMAL_EPILOGUE);\n-  DONE;\n-}\")\n-\n-\n-(define_expand \"eh_return\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"\n-{\n-  ms1_expand_eh_return (operands);\n-  DONE;\n-}\")\n-\n-\n-(define_insn_and_split \"eh_epilogue\"\n-  [(unspec [(match_operand 0 \"register_operand\" \"r\")] 6)]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(const_int 1)]\n-  \"ms1_emit_eh_epilogue (operands); DONE;\"\n-)\n-\f\n-;; No operation, needed in case the user uses -g but not -O.\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"or\tr0,r0,r0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-;; ::::::::::::::::::::\n-;; ::\n-;; :: UNSPEC_VOLATILE usage\n-;; ::\n-;; ::::::::::::::::::::\n-;; \n-;;\t0\tblockage\n-;;\t1\tEnable interrupts\n-;;\t2\tDisable interrupts\n-;;\n-\n-;; Pseudo instruction that prevents the scheduler from moving code above this\n-;; point.\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_BLOCKAGE)]\n-  \"\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")])\n-\n-;; Trap instruction to allow usage of the __builtin_trap function\n-(define_insn \"trap\"\n-  [(trap_if (const_int 1) (const_int 0))\n-   (clobber (reg:SI 14))]\n-  \"\"\n-  \"si\tr14%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n-\n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t\t\t    [(match_dup 2)\n-\t\t\t     (match_dup 3)])\n-\t    (match_operand 1 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = ms1_compare_op0;\n-  operands[3] = ms1_compare_op1;\n-}\")\n-\n-;; Templates to control handling of interrupts\n-\n-;; Enable interrupts template\n-(define_insn \"ei\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_EI)]\n-  \"\"\n-  \"ei\"\n-  [(set_attr \"length\" \"4\")])\n-\n-;; Enable interrupts template\n-(define_insn \"di\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_DI)]\n-  \"\"\n-  \"di\"\n-  [(set_attr \"length\" \"4\")])"}, {"sha": "eba1eeabeebde57777cb8f4483843dfd864a0a60", "filename": "gcc/config/ms1/mt.opt", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Fmt.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fmt.opt?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,56 +0,0 @@\n-; Options for the ms1 port of the compiler\n-;\n-; Copyright (C) 2005 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 2, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT\n-; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-; License for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING.  If not, write to the Free\n-; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-; 02110-1301, USA.\n-\n-mbacc\n-Target Report Mask(BYTE_ACCESS)\n-Use byte loads and stores when generating code.\n-\n-msim\n-Target RejectNegative\n-Use simulator runtime\n-\n-mno-crt0\n-Target RejectNegative\n-Do not include crt0.o in the startup files\n-\n-mdebug-arg\n-Target RejectNegative Mask(DEBUG_ARG)\n-Internal debug switch\n-\n-mdebug-addr\n-Target RejectNegative Mask(DEBUG_ADDR)\n-Internal debug switch\n-\n-mdebug-stack\n-Target RejectNegative Mask(DEBUG_STACK)\n-Internal debug switch\n-\n-mdebug-loc\n-Target RejectNegative Mask(DEBUG_LOC)\n-Internal debug switch\n-\n-mdebug\n-Target RejectNegative Mask(DEBUG)\n-Internal debug switch\n-\n-march=\n-Target RejectNegative Joined Var(ms1_cpu_string)\n-Specify CPU for code generation purposes"}, {"sha": "3093fc445dbc9940707a30758eeda42d351d766c", "filename": "gcc/config/ms1/t-mt", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Ft-mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcee0c2b28fcca272fe3e9ad67782022612671/gcc%2Fconfig%2Fms1%2Ft-mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Ft-mt?ref=00dcee0c2b28fcca272fe3e9ad67782022612671", "patch": "@@ -1,70 +0,0 @@\n-#  Copyright (C) 2005 Free Software Foundation, Inc.\n-#\n-#   This file is part of GCC.\n-#\n-#   GCC is free software; you can redistribute it and/or modify it\n-#   under the terms of the GNU General Public License as published\n-#   by the Free Software Foundation; either version 2, or (at your\n-#   option) any later version.\n-#\n-#   GCC is distributed in the hope that it will be useful, but WITHOUT\n-#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-#   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-#   License for more details.\n-#\n-#   You should have received a copy of the GNU General Public License\n-#   along with GCC; see the file COPYING.  If not, write to the Free\n-#   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-#   02110-1301, USA.\n-\n-# Name of assembly file containing libgcc1 functions.\n-# This entry must be present, but it can be empty if the target does\n-# not need any assembler functions to support its code generation.\n-CROSS_LIBGCC1 =\n-#\n-# Alternatively if assembler functions *are* needed then define the\n-# entries below:\n-# CROSS_LIBGCC1 = libgcc1-asm.a\n-# LIB1ASMSRC    = ms1/lib1funcs.asm\n-# LIB1ASMFUNCS  = _udivsi3 etc...\n-\n-LIB2FUNCS_EXTRA = $(srcdir)/config/ms1/lib2extra-funcs.c\n-\n-# If any special flags are necessary when building libgcc2 put them here.\n-#\n-# TARGET_LIBGCC2_CFLAGS = \n-\n-EXTRA_PARTS = crtbegin.o crtend.o crti.o crtn.o\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n-\n-# Assemble startup files.\n-crti.o: $(srcdir)/config/ms1/crti.asm $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) -c -o crti.o -x assembler $(srcdir)/config/ms1/crti.asm\n- \n-crtn.o: $(srcdir)/config/ms1/crtn.asm $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) -c -o crtn.o -x assembler $(srcdir)/config/ms1/crtn.asm\n-\n-# Enable the following if multilibs are needed.\n-# See gcc/genmultilib, gcc/gcc.texi and gcc/tm.texi for a\n-# description of the options and their values.\n-#\n-MULTILIB_OPTIONS    = march=ms1-64-001/march=ms1-16-002/march=ms1-16-003\n-MULTILIB_DIRNAMES   = 64-001 16-002 16-003\n-# MULTILIB_MATCHES    =\n-# MULTILIB_EXCEPTIONS =\n-# MULTILIB_EXTRA_OPTS = \n-#\n-# LIBGCC = stmp-multilib\n-# INSTALL_LIBGCC = install-multilib\n-"}]}