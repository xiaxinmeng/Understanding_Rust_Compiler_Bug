{"sha": "8ac61af705335691fd0d91ec6cd96e65bb81201c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFjNjFhZjcwNTMzNTY5MWZkMGQ5MWVjNmNkOTZlNjViYjgxMjAxYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-23T18:51:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-23T18:51:18Z"}, "message": "alias.c (can_address_p): Compnonents are not addressable if the containing type has alias set 0.\n\n\t* alias.c (can_address_p): Compnonents are not addressable if\n\tthe containing type has alias set 0.\n\t(get_alias_set): Rework to use STRIP_NOPS.\n\tOnly call front-end routine on object, type, or object with\n\tNOPs stripped, not inner values.\n\tUse language hook to call front-end routine.\n\t* builtins.c (get_memory_rtx): Always call set_mem_attributes.\n\t(expand_builtin_apply): Call set_mem_align on MEMs we make.\n\tDon't pass alignment to emit_block_move.\n\t(expand_builtin_memcpy, expand_builtin_va_copy): Likewise.\n\t(expand_builtin_memset): Likewise, but for clear_storage.\n\t* c-common.c (lang_get_alias_set): Renamed to c_common_alias_set\n\tand remove C++ specific parts.\n\t* c-common.h (c_common_get_alias_set): Add declaration.\n\t* c-lang.c (LANG_HOOKS_GET_ALIAS_SET): New macro.\n\t* calls.c (emit_call_1): Fix typo in sibcall_pop case.\n\t(save_fixed_argument_area): Call set_mem_align.\n\tRemove alignment in call to emit_block_move.\n\t(emit_library_call_value_1, store_one_arg): Likewise.\n\t(target_for_arg): Remove; disabled long ago.\n\t* emit-rtl.c (set_mem_attributes): Rework to only call get_mem_attrs\n\tonce and similar cleanups.\n\t(offset_address): Use proper introductory comment.\n\t* expr.c (emit_block_move): Use alignment from that of MEM args, not\n\tfrom explicit operand; all callers changed.\n\t(clear_storage): Likewise.\n\t(expand_assignment): Don't call set_mem_alias_set on to_rtx.\n\t(store_field): Remove kludge on alias set used for to_rtx.\n\t(highest_pow2_factor, case *_DIV_EXPR): Never return 0.\n\t(expand_expr_unaligned): Call set_mem_attributes instead of\n\tset_mem_alias_set.\n\t* expr.h (emit_block_move, clear_storage): Remove ALIGN argument.\n\t* function.c (assign_stack_temp_for_type): Set MEM alignment.\n\t(expand_function_end): Track MEM attributes of trampolines.\n\t* ifcvt.c (noce_try_cmove_arith): Set alignment of new MEM.\n\t* integrate.c (copy_rtx_and_substitute, case CALL): Copy memory\n\tattributes from original.\n\t* langhooks.c (lang_hook_default_get_alias_set): New function.\n\t(hook_get_alias_set_0): New function.\n\t* langhooks.h (hook_get_alias_set_0): New declaration.\n\t(lang_hook_default_get_alias_set): Likewise.\n\t(LANG_HOOKS_GET_ALIAS_SET): New macro; add to initializer.\n\t* reload1.c (alter_reg): Use adjust_address_nv.\n\t* rtl.c (get_mode_alignment): Moved to here.\n\t* rtl.h (MEM_ALIGN): Take default from mode, if not BLKmode, and\n\tchange default if unknown from 1 to BITS_PER_UNIT.\n\t* stor-layout.c (get_mode_alignment): Remove from here.\n\t* toplev.h (struct lang_hoks): Add get_alias_set field.\n\t* tree.h (lang_get_alias_set): Delete declaration.\n\t* config/arc/arc.c (arc_setup_incoming_varags): Set MEM alignment.\n\t* config/i386/i386.c (ix86_setup_incoming_varargs): Likewise.\n\t(ix86_va_arg): Likewise.\n\t* config/i960/i960.c (i960_setup_incoming_varargs): Likewise.\n\t* config/pa/pa.c (hppa_builtin_saveregs): Likewise.\n\t* config/sparc/sparc.c (sparc_va_arg): Likewise.\n\t* config/rs6000/rs6000.c (setup_incoming_varargs): Likewise.\n\t(expand_block_move_mem): Remove dead code.\n\t* cp/cp-lang.c (cxx_get_alias_set): New function.\n\tPoint LANG_HOOKS_GET_ALIAS_SET to it.\n\t* f/com.c (LANG_HOOKS_GET_ALIAS_SET): New macro.\n\t(lang_get_alias_set): Delete.\n\t* java/lang.c (lang_get_alias_set): Deleted.\n\nFrom-SVN: r46440", "tree": {"sha": "4f314d9fb9d201416fb3ebce0a67307306ae796f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f314d9fb9d201416fb3ebce0a67307306ae796f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ac61af705335691fd0d91ec6cd96e65bb81201c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ac61af705335691fd0d91ec6cd96e65bb81201c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ac61af705335691fd0d91ec6cd96e65bb81201c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ac61af705335691fd0d91ec6cd96e65bb81201c/comments", "author": null, "committer": null, "parents": [{"sha": "6c36d76bf6521dd1cc09b8d7e379a02d138ffd53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c36d76bf6521dd1cc09b8d7e379a02d138ffd53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c36d76bf6521dd1cc09b8d7e379a02d138ffd53"}], "stats": {"total": 651, "additions": 363, "deletions": 288}, "files": [{"sha": "6272d5bab1c05b0ebd22d087cbc10040a5df5075", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1,3 +1,63 @@\n+Tue Oct 23 13:05:53 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (can_address_p): Compnonents are not addressable if\n+\tthe containing type has alias set 0.\n+\t(get_alias_set): Rework to use STRIP_NOPS.\n+\tOnly call front-end routine on object, type, or object with\n+\tNOPs stripped, not inner values.\n+\tUse language hook to call front-end routine.\n+\t* builtins.c (get_memory_rtx): Always call set_mem_attributes.\n+\t(expand_builtin_apply): Call set_mem_align on MEMs we make.\n+\tDon't pass alignment to emit_block_move.\n+\t(expand_builtin_memcpy, expand_builtin_va_copy): Likewise.\n+\t(expand_builtin_memset): Likewise, but for clear_storage.\n+\t* c-common.c (lang_get_alias_set): Renamed to c_common_alias_set\n+\tand remove C++ specific parts.\n+\t* c-common.h (c_common_get_alias_set): Add declaration.\n+\t* c-lang.c (LANG_HOOKS_GET_ALIAS_SET): New macro.\n+\t* calls.c (emit_call_1): Fix typo in sibcall_pop case.\n+\t(save_fixed_argument_area): Call set_mem_align.\n+\tRemove alignment in call to emit_block_move.\n+\t(emit_library_call_value_1, store_one_arg): Likewise.\n+\t(target_for_arg): Remove; disabled long ago.\n+\t* emit-rtl.c (set_mem_attributes): Rework to only call get_mem_attrs\n+\tonce and similar cleanups.\n+\t(offset_address): Use proper introductory comment.\n+\t* expr.c (emit_block_move): Use alignment from that of MEM args, not\n+\tfrom explicit operand; all callers changed.\n+\t(clear_storage): Likewise.\n+\t(expand_assignment): Don't call set_mem_alias_set on to_rtx.\n+\t(store_field): Remove kludge on alias set used for to_rtx.\n+\t(highest_pow2_factor, case *_DIV_EXPR): Never return 0.\n+\t(expand_expr_unaligned): Call set_mem_attributes instead of\n+\tset_mem_alias_set.\n+\t* expr.h (emit_block_move, clear_storage): Remove ALIGN argument.\n+\t* function.c (assign_stack_temp_for_type): Set MEM alignment.\n+\t(expand_function_end): Track MEM attributes of trampolines.\n+\t* ifcvt.c (noce_try_cmove_arith): Set alignment of new MEM.\n+\t* integrate.c (copy_rtx_and_substitute, case CALL): Copy memory\n+\tattributes from original.\n+\t* langhooks.c (lang_hook_default_get_alias_set): New function.\n+\t(hook_get_alias_set_0): New function.\n+\t* langhooks.h (hook_get_alias_set_0): New declaration.\n+\t(lang_hook_default_get_alias_set): Likewise.\n+\t(LANG_HOOKS_GET_ALIAS_SET): New macro; add to initializer.\n+\t* reload1.c (alter_reg): Use adjust_address_nv.\n+\t* rtl.c (get_mode_alignment): Moved to here.\n+\t* rtl.h (MEM_ALIGN): Take default from mode, if not BLKmode, and\n+\tchange default if unknown from 1 to BITS_PER_UNIT.\n+\t* stor-layout.c (get_mode_alignment): Remove from here.\n+\t* toplev.h (struct lang_hoks): Add get_alias_set field.\n+\t* tree.h (lang_get_alias_set): Delete declaration.\n+\t* config/arc/arc.c (arc_setup_incoming_varags): Set MEM alignment.\n+\t* config/i386/i386.c (ix86_setup_incoming_varargs): Likewise.\n+\t(ix86_va_arg): Likewise.\n+\t* config/i960/i960.c (i960_setup_incoming_varargs): Likewise.\n+\t* config/pa/pa.c (hppa_builtin_saveregs): Likewise.\n+\t* config/sparc/sparc.c (sparc_va_arg): Likewise.\n+\t* config/rs6000/rs6000.c (setup_incoming_varargs): Likewise.\n+\t(expand_block_move_mem): Remove dead code.\n+\n 2001-10-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-common.c (warn_div_by_zero): New."}, {"sha": "3de48b2973b1a53c0360d70f0d91971b0242b53b", "filename": "gcc/alias.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -438,13 +438,18 @@ can_address_p (t)\n   else if (TREE_CODE (t) == BIT_FIELD_REF)\n     return 0;\n \n+  /* Fields are addressable unless they are marked as nonaddressable or\n+     the containing type has alias set 0.  */\n   else if (TREE_CODE (t) == COMPONENT_REF\n \t   && ! DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1))\n+\t   && get_alias_set (TREE_TYPE (TREE_OPERAND (t, 0))) != 0\n \t   && can_address_p (TREE_OPERAND (t, 0)))\n     return 1;\n \n+  /* Likewise for arrays.  */\n   else if ((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t   && ! TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t   && get_alias_set (TREE_TYPE (TREE_OPERAND (t, 0))) != 0\n \t   && can_address_p (TREE_OPERAND (t, 0)))\n     return 1;\n \n@@ -478,22 +483,25 @@ get_alias_set (t)\n       tree inner = t;\n       tree placeholder_ptr = 0;\n \n+      /* Remove any nops, then give the language a chance to do\n+\t something with this tree before we look at it.  */\n+      STRIP_NOPS (t);\n+      set = (*lang_hooks.get_alias_set) (t);\n+      if (set != -1)\n+\treturn set;\n+\n       /* First see if the actual object referenced is an INDIRECT_REF from a\n-\t restrict-qualified pointer or a \"void *\".  Start by removing nops\n-\t since we care only about the actual object.  Also replace\n+\t restrict-qualified pointer or a \"void *\".  Replace\n \t PLACEHOLDER_EXPRs.  */\n-      while (((TREE_CODE (inner) == NOP_EXPR\n-\t       || TREE_CODE (inner) == CONVERT_EXPR)\n-\t      && (TYPE_MODE (TREE_TYPE (inner))\n-\t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (inner, 0)))))\n-\t     || TREE_CODE (inner) == NON_LVALUE_EXPR\n-\t     || TREE_CODE (inner) == PLACEHOLDER_EXPR\n+      while (TREE_CODE (inner) == PLACEHOLDER_EXPR\n \t     || handled_component_p (inner))\n \t{\n \t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n \t    inner = find_placeholder (inner, &placeholder_ptr);\n \t  else\n \t    inner = TREE_OPERAND (inner, 0);\n+\n+\t  STRIP_NOPS (inner);\n \t}\n \n       /* Check for accesses through restrict-qualified pointers.  */\n@@ -540,27 +548,16 @@ get_alias_set (t)\n       /* Otherwise, pick up the outermost object that we could have a pointer\n \t to, processing conversion and PLACEHOLDER_EXPR as above.  */\n       placeholder_ptr = 0;\n-      while (((TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR)\n- \t      && (TYPE_MODE (TREE_TYPE (t))\n-\t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0)))))\n-\t     || TREE_CODE (t) == NON_LVALUE_EXPR\n-\t     || TREE_CODE (t) == PLACEHOLDER_EXPR\n+      while (TREE_CODE (t) == PLACEHOLDER_EXPR\n \t     || (handled_component_p (t) && ! can_address_p (t)))\n \t{\n-\t  /* Give the language a chance to do something with this tree\n-\t     before we go inside it.  */\n-\t  if ((set = lang_get_alias_set (t)) != -1)\n-\t    return set;\n-\n \t  if (TREE_CODE (t) == PLACEHOLDER_EXPR)\n \t    t = find_placeholder (t, &placeholder_ptr);\n \t  else\n \t    t = TREE_OPERAND (t, 0);\n-\t}\n \n-      /* Give the language another chance to do something.  */\n-      if ((set = lang_get_alias_set (t)) != -1)\n-\treturn set;\n+\t  STRIP_NOPS (t);\n+\t}\n \n       /* If we've already determined the alias set for a decl, just return\n \t it.  This is necessary for C++ anonymous unions, whose component\n@@ -580,7 +577,8 @@ get_alias_set (t)\n     return TYPE_ALIAS_SET (t);\n \n   /* See if the language has special handling for this type.  */\n-  if ((set = lang_get_alias_set (t)) != -1)\n+  set = (*lang_hooks.get_alias_set) (t);\n+  if (set != -1)\n     return set;\n \n   /* There are no objects of FUNCTION_TYPE, so there's no point in"}, {"sha": "fe127925ac2bf4b470a518931b8d0c0ea5569133", "filename": "gcc/builtins.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -724,6 +724,8 @@ get_memory_rtx (exp)\n \t\t\t\t\t expand_expr (exp, NULL_RTX,\n \t\t\t\t\t\t      ptr_mode, EXPAND_SUM)));\n \n+  set_mem_attributes (mem, exp, 0);\n+\n   /* Get an expression we can use to find the attributes to assign to MEM.\n      If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if\n      we can.  First remove any nops.  */\n@@ -739,7 +741,6 @@ get_memory_rtx (exp)\n   else\n     return mem;\n \n-  set_mem_attributes (mem, exp, 0);\n   /* memcpy, memset and other builtin stringops can alias with anything.  */\n   set_mem_alias_set (mem, 0);\n   return mem;\n@@ -1040,7 +1041,7 @@ expand_builtin_apply (function, arguments, argsize)\n {\n   int size, align, regno;\n   enum machine_mode mode;\n-  rtx incoming_args, result, reg, dest, call_insn;\n+  rtx incoming_args, result, reg, dest, src, call_insn;\n   rtx old_stack_level = 0;\n   rtx call_fusage = 0;\n \n@@ -1079,13 +1080,16 @@ expand_builtin_apply (function, arguments, argsize)\n      but it's likely that the source and/or destination addresses in\n      the block copy will need updating in machine specific ways.  */\n   dest = allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT);\n-  emit_block_move (gen_rtx_MEM (BLKmode, dest),\n-\t\t   gen_rtx_MEM (BLKmode, incoming_args),\n-\t\t   argsize, PARM_BOUNDARY);\n+  dest = gen_rtx_MEM (BLKmode, dest);\n+  set_mem_align (dest, PARM_BOUNDARY);\n+  src = gen_rtx_MEM (BLKmode, incoming_args);\n+  set_mem_align (src, PARM_BOUNDARY);\n+  emit_block_move (dest, src, argsize);\n \n   /* Refer to the argument block.  */\n   apply_args_size ();\n   arguments = gen_rtx_MEM (BLKmode, arguments);\n+  set_mem_align (arguments, PARM_BOUNDARY);\n \n   /* Walk past the arg-pointer and structure value address.  */\n   size = GET_MODE_SIZE (Pmode);\n@@ -1813,6 +1817,7 @@ expand_builtin_memcpy (arglist)\n \treturn 0;\n \n       dest_mem = get_memory_rtx (dest);\n+      set_mem_align (dest_mem, dest_align);\n       len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n       src_str = c_getstr (src);\n \n@@ -1833,6 +1838,7 @@ expand_builtin_memcpy (arglist)\n \t}\n \n       src_mem = get_memory_rtx (src);\n+      set_mem_align (src_mem, src_align);\n \n       /* Just copy the rights of SRC to the rights of DEST.  */\n       if (current_function_check_memory_usage)\n@@ -1842,9 +1848,7 @@ expand_builtin_memcpy (arglist)\n \t\t\t   len_rtx, TYPE_MODE (sizetype));\n \n       /* Copy word part most expediently.  */\n-      dest_addr\n-\t= emit_block_move (dest_mem, src_mem, len_rtx,\n-\t\t\t   MIN (src_align, dest_align));\n+      dest_addr = emit_block_move (dest_mem, src_mem, len_rtx);\n \n       if (dest_addr == 0)\n \tdest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -2041,6 +2045,7 @@ expand_builtin_memset (exp)\n       len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n \n       dest_mem = get_memory_rtx (dest);\n+      set_mem_align (dest_mem, dest_align);\n \t   \n       /* Just check DST is writable and mark it as readable.  */\n       if (current_function_check_memory_usage)\n@@ -2051,7 +2056,7 @@ expand_builtin_memset (exp)\n \t\t\t   TYPE_MODE (integer_type_node));\n \n \n-      dest_addr = clear_storage (dest_mem, len_rtx, dest_align);\n+      dest_addr = clear_storage (dest_mem, len_rtx);\n \n       if (dest_addr == 0)\n \tdest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3013,11 +3018,13 @@ expand_builtin_va_copy (arglist)\n       /* \"Dereference\" to BLKmode memories.  */\n       dstb = gen_rtx_MEM (BLKmode, dstb);\n       set_mem_alias_set (dstb, get_alias_set (TREE_TYPE (TREE_TYPE (dst))));\n+      set_mem_align (dstb, TYPE_ALIGN (va_list_type_node));\n       srcb = gen_rtx_MEM (BLKmode, srcb);\n       set_mem_alias_set (srcb, get_alias_set (TREE_TYPE (TREE_TYPE (src))));\n+      set_mem_align (srcb, TYPE_ALIGN (va_list_type_node));\n \n       /* Copy.  */\n-      emit_block_move (dstb, srcb, size, TYPE_ALIGN (va_list_type_node));\n+      emit_block_move (dstb, srcb, size);\n     }\n \n   return const0_rtx;"}, {"sha": "7f42e5cddebcd763bd561044260ddd78eb53c0d8", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2146,7 +2146,7 @@ c_apply_type_quals_to_decl (type_quals, decl)\n    or a type.  Return -1 if we don't do anything special.  */\n \n HOST_WIDE_INT\n-lang_get_alias_set (t)\n+c_common_get_alias_set (t)\n      tree t;\n {\n   tree u;\n@@ -2221,10 +2221,6 @@ lang_get_alias_set (t)\n       if (t1 != t)\n \treturn get_alias_set (t1);\n     }\n-  /* It's not yet safe to use alias sets for classes in C++ because\n-     the TYPE_FIELDs list for a class doesn't mention base classes.  */\n-  else if (c_language == clk_cplusplus && AGGREGATE_TYPE_P (t))\n-    return 0;\n \n   return -1;\n }"}, {"sha": "8d378b823488e269a2352022709a6c1709999009", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -542,7 +542,7 @@ extern void c_common_nodes_and_builtins\t\tPARAMS ((void));\n extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n \n extern void c_common_lang_init\t\t\tPARAMS ((void));\n-\n+extern HOST_WIDE_INT c_common_get_alias_set\tPARAMS ((tree));\n extern bool c_promoting_integer_type_p\t\tPARAMS ((tree));\n extern int self_promoting_args_p\t\tPARAMS ((tree));\n extern tree simple_type_promotes_to\t\tPARAMS ((tree));"}, {"sha": "59e8d5c040aea839980a5039d9f6d75d75341906", "filename": "gcc/c-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -56,6 +56,9 @@ static int c_cannot_inline_tree_fn PARAMS ((tree *));\n #define LANG_HOOKS_DECODE_OPTION c_decode_option\n #undef LANG_HOOKS_POST_OPTIONS\n #define LANG_HOOKS_POST_OPTIONS c_post_options\n+#undef LANG_HOOKS_GET_ALIAS_SET\n+#define LANG_HOOKS_GET_ALIAS_SET c_common_get_alias_set\n+\n #undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n #define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n   c_cannot_inline_tree_fn"}, {"sha": "957ddaedf3ef95611655ec1dc653f539af3612dd", "filename": "gcc/calls.c", "status": "modified", "additions": 22, "deletions": 57, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -475,7 +475,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n       && HAVE_sibcall_pop && HAVE_sibcall_value_pop\n       && (n_popped > 0 || stack_size == 0))\n     {\n-      rtx n_pop = GEN_INT (n_popped));\n+      rtx n_pop = GEN_INT (n_popped);\n       rtx pat;\n \n       /* If this subroutine pops its own args, record that in the call insn\n@@ -497,10 +497,10 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n #endif\n \n #if defined (HAVE_call_pop) && defined (HAVE_call_value_pop)\n-/* If the target has \"call\" or \"call_value\" insns, then prefer them\n-   if no arguments are actually popped.  If the target does not have\n-   \"call\" or \"call_value\" insns, then we must use the popping versions\n-   even if the call has no arguments to pop.  */\n+  /* If the target has \"call\" or \"call_value\" insns, then prefer them\n+     if no arguments are actually popped.  If the target does not have\n+     \"call\" or \"call_value\" insns, then we must use the popping versions\n+     even if the call has no arguments to pop.  */\n #if defined (HAVE_call) && defined (HAVE_call_value)\n   if (HAVE_call && HAVE_call_value && HAVE_call_pop && HAVE_call_value_pop\n       && n_popped > 0 && ! (ecf_flags & ECF_SP_DEPRESSED))\n@@ -573,12 +573,12 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \n   /* Mark memory as used for \"pure\" function call.  */\n   if (ecf_flags & ECF_PURE)\n-    {\n-      call_fusage =  gen_rtx_EXPR_LIST (VOIDmode,\n-\tgen_rtx_USE (VOIDmode,\n-\t\t     gen_rtx_MEM (BLKmode,\n-\t\t\t\t  gen_rtx_SCRATCH (VOIDmode))), call_fusage);\n-    }\n+    call_fusage\n+      = gen_rtx_EXPR_LIST\n+\t(VOIDmode,\n+\t gen_rtx_USE (VOIDmode,\n+\t\t      gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode))),\n+\t call_fusage);\n \n   /* Put the register usage information on the CALL.  If there is already\n      some usage information, put ours at the end.  */\n@@ -939,6 +939,8 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n \t\t\t\t\t\tplus_constant (argblock,\n \t\t\t\t\t\t\t       *low_to_save)));\n #endif\n+\n+      set_mem_align (stack_area, PARM_BOUNDARY);\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n@@ -954,6 +956,7 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n \t  emit_move_insn (save_area, stack_area);\n \t}\n     }\n+\n   return save_area;\n }\n \n@@ -3322,8 +3325,7 @@ expand_call (exp, target, ignore)\n \t\telse\n \t\t  emit_block_move (stack_area,\n \t\t\t\t   validize_mem (args[i].save_area),\n-\t\t\t\t   GEN_INT (args[i].size.constant),\n-\t\t\t\t   PARM_BOUNDARY);\n+\t\t\t\t   GEN_INT (args[i].size.constant));\n \t      }\n \n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n@@ -3447,6 +3449,7 @@ expand_call (exp, target, ignore)\n /* Output a library call to function FUN (a SYMBOL_REF rtx).\n    The RETVAL parameter specifies whether return value needs to be saved, other\n    parameters are documented in the emit_library_call function below.  */\n+\n static rtx\n emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      int retval;\n@@ -3894,8 +3897,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t  if (save_mode == BLKmode)\n \t    {\n \t      save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t      emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t       GEN_INT (num_to_save), PARM_BOUNDARY);\n+\t      set_mem_align (save_area, PARM_BOUNDARY);\n+\t      emit_block_move (validize_mem (save_area), stack_area);\n \t    }\n \t  else\n \t    {\n@@ -4161,12 +4164,13 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t\t\t   memory_address (save_mode,\n \t\t\t\t\t   plus_constant (argblock, low_to_save)));\n #endif\n+\n+\t  set_mem_align (stack_area, PARM_BOUNDARY);\n \t  if (save_mode != BLKmode)\n \t    emit_move_insn (stack_area, save_area);\n \t  else\n \t    emit_block_move (stack_area, validize_mem (save_area),\n-\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n-\t\t\t     PARM_BOUNDARY);\n+\t\t\t     GEN_INT (high_to_save - low_to_save + 1));\n \t}\n #endif\n \n@@ -4250,44 +4254,6 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value,\n   return result;\n }\n \f\n-#if 0\n-/* Return an rtx which represents a suitable home on the stack\n-   given TYPE, the type of the argument looking for a home.\n-   This is called only for BLKmode arguments.\n-\n-   SIZE is the size needed for this target.\n-   ARGS_ADDR is the address of the bottom of the argument block for this call.\n-   OFFSET describes this parameter's offset into ARGS_ADDR.  It is meaningless\n-   if this machine uses push insns.  */\n-\n-static rtx\n-target_for_arg (type, size, args_addr, offset)\n-     tree type;\n-     rtx size;\n-     rtx args_addr;\n-     struct args_size offset;\n-{\n-  rtx target;\n-  rtx offset_rtx = ARGS_SIZE_RTX (offset);\n-\n-  /* We do not call memory_address if possible,\n-     because we want to address as close to the stack\n-     as possible.  For non-variable sized arguments,\n-     this will be stack-pointer relative addressing.  */\n-  if (GET_CODE (offset_rtx) == CONST_INT)\n-    target = plus_constant (args_addr, INTVAL (offset_rtx));\n-  else\n-    {\n-      /* I have no idea how to guarantee that this\n-\t will work in the presence of register parameters.  */\n-      target = gen_rtx_PLUS (Pmode, args_addr, offset_rtx);\n-      target = memory_address (QImode, target);\n-    }\n-\n-  return gen_rtx_MEM (BLKmode, target);\n-}\n-#endif\n-\f\n /* Store a single argument for a function call\n    into the register or memory area where it must be passed.\n    *ARG describes the argument value and where to pass it.\n@@ -4379,8 +4345,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t\t  arg->save_area = assign_temp (nt, 0, 1, 1);\n \t\t  preserve_temp_slots (arg->save_area);\n \t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n-\t\t\t\t   expr_size (arg->tree_value),\n-\t\t\t\t   MIN (PARM_BOUNDARY, TYPE_ALIGN (nt)));\n+\t\t\t\t   expr_size (arg->tree_value));\n \t\t}\n \t      else\n \t\t{"}, {"sha": "79586d04f16f3e5814c1d69750ebca4416a78683", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -813,6 +813,7 @@ arc_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t\t\t\t\t     FIRST_PARM_OFFSET (0)\n \t\t\t\t\t     + align_slop * UNITS_PER_WORD));\n       set_mem_alias_set (regblock, get_varargs_alias_set ());\n+      set_mem_align (regblock, BITS_PER_WORD);\n       move_block_from_reg (first_reg_offset, regblock,\n \t\t\t   MAX_ARC_PARM_REGS - first_reg_offset,\n \t\t\t   ((MAX_ARC_PARM_REGS - first_reg_offset)"}, {"sha": "52e24146cb81f8eade70fd58c5f20351f51689d1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2249,14 +2249,16 @@ ix86_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t pointing 127 bytes after first byte to store - this is needed to keep\n \t instruction size limited by 4 bytes.  */\n       tmp_reg = gen_reg_rtx (Pmode);\n-      emit_insn (gen_rtx_SET(VOIDmode, tmp_reg,\n-\t\t\t     plus_constant (save_area, 8 * REGPARM_MAX + 127)));\n+      emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n+\t\t\t      plus_constant (save_area,\n+\t\t\t\t\t     8 * REGPARM_MAX + 127)));\n       mem = gen_rtx_MEM (BLKmode, plus_constant (tmp_reg, -127));\n       set_mem_alias_set (mem, set);\n+      set_mem_align (mem, BITS_PER_WORD);\n \n       /* And finally do the dirty job!  */\n-      emit_insn (gen_sse_prologue_save (mem, nsse_reg, GEN_INT (next_cum.sse_regno),\n-\t\t label));\n+      emit_insn (gen_sse_prologue_save (mem, nsse_reg,\n+\t\t\t\t\tGEN_INT (next_cum.sse_regno), label));\n     }\n \n }\n@@ -2467,6 +2469,7 @@ ix86_va_arg (valist, type)\n \t  addr_rtx = XEXP (assign_temp (type, 0, 1, 0), 0);\n \t  mem = gen_rtx_MEM (BLKmode, addr_rtx);\n \t  set_mem_alias_set (mem, get_varargs_alias_set ());\n+\t  set_mem_align (mem, BITS_PER_UNIT);\n \n \t  for (i = 0; i < XVECLEN (container, 0); i++)\n \t    {\n@@ -2492,7 +2495,6 @@ ix86_va_arg (valist, type)\n \t      set_mem_alias_set (src_mem, get_varargs_alias_set ());\n \t      src_mem = adjust_address (src_mem, mode, src_offset);\n \t      dest_mem = adjust_address (mem, mode, INTVAL (XEXP (slot, 1)));\n-\t      PUT_MODE (dest_mem, mode);\n \t      emit_move_insn (dest_mem, src_mem);\n \t    }\n \t}"}, {"sha": "8c7c8d40b1244d1db05cc584ce8070d2ba7e548a", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2583,6 +2583,7 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       regblock = gen_rtx_MEM (BLKmode,\n \t\t\t      plus_constant (arg_pointer_rtx, first_reg * 4));\n       set_mem_alias_set (regblock, get_varargs_alias_set ());\n+      set_mem_align (regblock, BITS_PER_WORD);\n       move_block_from_reg (first_reg, regblock,\n \t\t\t   NPARM_REGS - first_reg,\n \t\t\t   (NPARM_REGS - first_reg) * UNITS_PER_WORD);"}, {"sha": "593f0858cf497914d8838cf08d61d638abe73520", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -4872,6 +4872,7 @@ hppa_builtin_saveregs ()\n \t\t      plus_constant (current_function_internal_arg_pointer,\n \t\t\t\t     -16));\n   set_mem_alias_set (dest, get_varargs_alias_set ());\n+  set_mem_align (dest, BITS_PER_WORD);\n   move_block_from_reg (23, dest, 4, 4 * UNITS_PER_WORD);\n \n   /* move_block_from_reg will emit code to store the argument registers"}, {"sha": "6e6f428f6e0b359dd1bb6d11835b25aa706814eb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2499,6 +2499,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t\t         plus_constant (save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size)),\n       set_mem_alias_set (mem, set);\n+      set_mem_align (mem, BITS_PER_WORD);\n \n       move_block_from_reg\n \t(GP_ARG_MIN_REG + first_reg_offset, mem,\n@@ -2850,9 +2851,6 @@ expand_block_move_mem (mode, addr, orig_mem)\n   rtx mem = gen_rtx_MEM (mode, addr);\n \n   MEM_COPY_ATTRIBUTES (mem, orig_mem);\n-#ifdef MEM_UNALIGNED_P\n-  MEM_UNALIGNED_P (mem) = MEM_UNALIGNED_P (orig_mem);\n-#endif\n   return mem;\n }\n \n@@ -5697,12 +5695,16 @@ rs6000_return_addr (count, frame)\n       || DEFAULT_ABI == ABI_AIX_NODESC)\n     {\n       cfun->machine->ra_needs_full_frame = 1;\n-      return gen_rtx_MEM (Pmode,\n-\t       memory_address (Pmode,\n-\t\t plus_constant (copy_to_reg\n-\t\t\t\t(gen_rtx_MEM (Pmode,\n-\t\t\t\t\t      memory_address (Pmode, frame))),\n-\t\t\t\tRETURN_ADDRESS_OFFSET)));\n+\n+      return\n+\tgen_rtx_MEM\n+\t  (Pmode,\n+\t   memory_address\n+\t   (Pmode,\n+\t    plus_constant (copy_to_reg\n+\t\t\t   (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t memory_address (Pmode, frame))),\n+\t\t\t   RETURN_ADDRESS_OFFSET)));\n     }\n \n   return get_hard_reg_initial_val (Pmode, LINK_REGISTER_REGNUM);"}, {"sha": "1b64987dabe58a58c9daf7cc571db6a827e42715", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2811,8 +2811,8 @@ legitimize_pic_address (orig, mode, reg)\n \taddress = orig;\n \n       pic_ref = gen_rtx_MEM (Pmode,\n-\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t  pic_offset_table_rtx, address));\n+\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t   pic_offset_table_rtx, address));\n       current_function_uses_pic_offset_table = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n       insn = emit_move_insn (reg, pic_ref);\n@@ -4833,17 +4833,18 @@ sparc_builtin_saveregs ()\n \n   for (regno = first_reg; regno < NPARM_REGS (word_mode); regno++)\n     emit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t      frame_pointer_rtx,\n-\t\t\t\t      GEN_INT (STACK_POINTER_OFFSET\n-\t\t\t\t\t       + UNITS_PER_WORD * regno))),\n+\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t       frame_pointer_rtx,\n+\t\t\t\t\t       GEN_INT (STACK_POINTER_OFFSET\n+\t\t\t\t\t\t\t+ (UNITS_PER_WORD\n+\t\t\t\t\t\t\t   * regno)))),\n \t\t    gen_rtx_REG (word_mode,\n-\t\t\t     BASE_INCOMING_ARG_REG (word_mode) + regno));\n+\t\t\t\t BASE_INCOMING_ARG_REG (word_mode) + regno));\n \n   address = gen_rtx_PLUS (Pmode,\n-\t\t     frame_pointer_rtx,\n-\t\t     GEN_INT (STACK_POINTER_OFFSET\n-\t\t\t      + UNITS_PER_WORD * first_reg));\n+\t\t\t  frame_pointer_rtx,\n+\t\t\t  GEN_INT (STACK_POINTER_OFFSET\n+\t\t\t\t   + UNITS_PER_WORD * first_reg));\n \n   if (current_function_check_memory_usage\n       && first_reg < NPARM_REGS (word_mode))\n@@ -4955,12 +4956,12 @@ sparc_va_arg (valist, type)\n       addr_rtx = force_reg (Pmode, addr_rtx);\n       addr_rtx = gen_rtx_MEM (BLKmode, addr_rtx);\n       set_mem_alias_set (addr_rtx, get_varargs_alias_set ());\n+      set_mem_align (addr_rtx, BITS_PER_WORD);\n       tmp = shallow_copy_rtx (tmp);\n       PUT_MODE (tmp, BLKmode);\n       set_mem_alias_set (tmp, 0);\n       \n-      dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize), \n-\t\t\t\t   BITS_PER_WORD);\n+      dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize));\n       if (dest_addr != NULL_RTX)\n \taddr_rtx = dest_addr;\n       else"}, {"sha": "a8f7c2fdafb53c1173045890ab28ab7a75b30dae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1,3 +1,8 @@\n+Tue Oct 23 14:00:20 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cp-lang.c (cxx_get_alias_set): New function.\n+\tPoint LANG_HOOKS_GET_ALIAS_SET to it.\n+\n 2001-10-23  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* cp-tree.def (UNBOUND_CLASS_TEMPLATE): New tree node."}, {"sha": "ca9f88fb8cb0ea3afb3d796e348f41e6cefee035", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -26,6 +26,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"langhooks.h\"\n \n+static HOST_WIDE_INT cxx_get_alias_set PARAMS ((tree));\n+\n #undef LANG_HOOKS_INIT\n #define LANG_HOOKS_INIT cxx_init\n #undef LANG_HOOKS_FINISH\n@@ -36,6 +38,8 @@ Boston, MA 02111-1307, USA.  */\n #define LANG_HOOKS_DECODE_OPTION cxx_decode_option\n #undef LANG_HOOKS_POST_OPTIONS\n #define LANG_HOOKS_POST_OPTIONS cxx_post_options\n+#undef LANG_HOOKS_GET_ALIAS_SET\n+#define LANG_HOOKS_GET_ALIAS_SET cxx_get_alias_set\n \n #undef LANG_HOOKS_TREE_INLINING_WALK_SUBTREES\n #define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES \\\n@@ -60,3 +64,17 @@ Boston, MA 02111-1307, USA.  */\n \n /* Each front end provides its own hooks, for toplev.c.  */\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+/* Special routine to get the alias set for C++.  */\n+\n+static HOST_WIDE_INT\n+cxx_get_alias_set (t)\n+     tree t;\n+{\n+  /* It's not yet safe to use alias sets for classes in C++ because\n+     the TYPE_FIELDs list for a class doesn't mention base classes.  */\n+  if (AGGREGATE_TYPE_P (t))\n+    return 0;\n+\n+  return c_common_get_alias_set (t);\n+}"}, {"sha": "79cdf5cdfab598b21cd6ab3a891c39bc628f6803", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1651,6 +1651,11 @@ set_mem_attributes (ref, t, objectp)\n      tree t;\n      int objectp;\n {\n+  HOST_WIDE_INT alias = MEM_ALIAS_SET (ref);\n+  tree decl = MEM_DECL (ref);\n+  rtx offset = MEM_OFFSET (ref);\n+  rtx size = MEM_SIZE (ref);\n+  unsigned int align = MEM_ALIGN (ref);\n   tree type;\n \n   /* It can happen that type_for_mode was given a mode for which there\n@@ -1669,66 +1674,63 @@ set_mem_attributes (ref, t, objectp)\n     abort ();\n \n   /* Get the alias set from the expression or type (perhaps using a\n-     front-end routine).  */\n-  set_mem_alias_set (ref, get_alias_set (t));\n+     front-end routine) and use it.  */\n+  alias = get_alias_set (t);\n \n   MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n   MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n   RTX_UNCHANGING_P (ref)\n     |= (lang_hooks.honor_readonly\n \t&& (TYPE_READONLY (type) || TREE_READONLY (t)));\n \n-  /* If we are making an object of this type, we know that it is a scalar if\n-     the type is not an aggregate.  */\n-  if (objectp && ! AGGREGATE_TYPE_P (type))\n+  /* If we are making an object of this type, or if this is a DECL, we know\n+     that it is a scalar if the type is not an aggregate.  */\n+  if ((objectp || DECL_P (t)) && ! AGGREGATE_TYPE_P (type))\n     MEM_SCALAR_P (ref) = 1;\n \n   /* If the size is known, we can set that.  */\n   if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))\n-    MEM_ATTRS (ref)\n-      = get_mem_attrs (MEM_ALIAS_SET (ref), MEM_DECL (ref), MEM_OFFSET (ref),\n-\t\t       GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1)),\n-\t\t       MEM_ALIGN (ref));\n+    size = GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1));\n \n-  /* If T is a type, there's nothing more we can do.  Otherwise, we may be able\n-     to deduce some more information about the expression.  */\n+  /* If T is not a type.  Otherwise, we may be able to deduce some more\n+     information about the expression.  */\n   if (TYPE_P (t))\n-    return;\n-\n-  maybe_set_unchanging (ref, t);\n-  if (TREE_THIS_VOLATILE (t))\n-    MEM_VOLATILE_P (ref) = 1;\n+    {\n+      maybe_set_unchanging (ref, t);\n+      if (TREE_THIS_VOLATILE (t))\n+\tMEM_VOLATILE_P (ref) = 1;\n \n-  /* Now remove any NOPs: they don't change what the underlying object is.\n+      /* Now remove any NOPs: they don't change what the underlying object is.\n      Likewise for SAVE_EXPR.  */\n-  while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n-\t || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-\n-  /* If this is a decl, set the attributes of the MEM from it.  */\n-  if (DECL_P (t))\n-    MEM_ATTRS (ref)\n-      = get_mem_attrs\n-\t(MEM_ALIAS_SET (ref), t, GEN_INT (0),\n-\t (TYPE_SIZE_UNIT (TREE_TYPE (t))\n-\t  && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (t)), 1))\n-\t ? GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (t)), 1))\n-\t : 0, DECL_ALIGN (t));\n-\n-  /* If this is an INDIRECT_REF, we know its alignment.  */\n-  if (TREE_CODE (t) == INDIRECT_REF)\n-    set_mem_align (ref, TYPE_ALIGN (type));\n-\n-  /* Now see if we can say more about whether it's an aggregate or\n-     scalar.  If we already know it's an aggregate, don't bother.  */\n-  if (MEM_IN_STRUCT_P (ref))\n+      while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n+\t     || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n+\tt = TREE_OPERAND (t, 0);\n+\n+      /* If this is a decl, set the attributes of the MEM from it.  */\n+      if (DECL_P (t))\n+\t{\n+\t  decl = t;\n+\t  offset = GEN_INT (0);\n+\t  size = (DECL_SIZE_UNIT (t)\n+\t\t  && host_integerp (DECL_SIZE_UNIT (t), 1)\n+\t\t  ? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n+\t  align =  DECL_ALIGN (t);\n+\t}\n+\n+      /* If this is an INDIRECT_REF, we know its alignment.  */\n+      else if (TREE_CODE (t) == INDIRECT_REF)\n+\talign = TYPE_ALIGN (type);\n+    }\n+\n+  /* Now set the attributes we computed above.  */\n+  MEM_ATTRS (ref) = get_mem_attrs (alias, decl, offset, size, align);\n+\n+  /* If this is already known to be a scalar or aggregate, we are done.  */\n+  if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))\n     return;\n \n-  /* Since we already know the type isn't an aggregate, if this is a decl,\n-     it must be a scalar.  Or if it is a reference into an aggregate,\n-     this is part of an aggregate.   Otherwise we don't know.  */\n-  if (DECL_P (t))\n-    MEM_SCALAR_P (ref) = 1;\n+  /* If it is a reference into an aggregate, this is part of an aggregate.\n+     Otherwise we don't know.  */\n   else if (TREE_CODE (t) == COMPONENT_REF || TREE_CODE (t) == ARRAY_REF\n \t   || TREE_CODE (t) == ARRAY_RANGE_REF\n \t   || TREE_CODE (t) == BIT_FIELD_REF)\n@@ -1878,10 +1880,9 @@ adjust_address_1 (memref, mode, offset, validate)\n   return new;\n }\n \n-/* Return a memory reference like MEMREF, but with its address changed to\n-   ADDR.  The caller is asserting that the actual piece of memory pointed\n-   to is the same, just the form of the address is being changed, such as\n-   by putting something into a register.  */\n+/* Return a memory reference like MEMREF, but whose address is changed by\n+   adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor\n+   known to be in OFFSET (possibly 1).  */\n \n rtx\n offset_address (memref, offset, pow2)"}, {"sha": "77503d3bc952a9bd10636fcae6555c8bc96e56dc", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1635,16 +1635,16 @@ move_by_pieces_1 (genfun, mode, data)\n    0 otherwise.  */\n \n rtx\n-emit_block_move (x, y, size, align)\n+emit_block_move (x, y, size)\n      rtx x, y;\n      rtx size;\n-     unsigned int align;\n {\n   rtx retval = 0;\n #ifdef TARGET_MEM_FUNCTIONS\n   static tree fn;\n   tree call_expr, arg_list;\n #endif\n+  unsigned int align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n \n   if (GET_MODE (x) != BLKmode)\n     abort ();\n@@ -2540,21 +2540,20 @@ store_by_pieces_2 (genfun, mode, data)\n }\n \f\n /* Write zeros through the storage of OBJECT.  If OBJECT has BLKmode, SIZE is\n-   its length in bytes and ALIGN is the maximum alignment we can is has.\n-\n-   If we call a function that returns the length of the block, return it.  */\n+   its length in bytes.  */\n \n rtx\n-clear_storage (object, size, align)\n+clear_storage (object, size)\n      rtx object;\n      rtx size;\n-     unsigned int align;\n {\n #ifdef TARGET_MEM_FUNCTIONS\n   static tree fn;\n   tree call_expr, arg_list;\n #endif\n   rtx retval = 0;\n+  unsigned int align = (GET_CODE (object) == MEM ? MEM_ALIGN (object)\n+\t\t\t: GET_MODE_ALIGNMENT (GET_MODE (object)));\n \n   /* If OBJECT is not BLKmode and SIZE is the same size as its mode,\n      just move a zero.  Otherwise, do this a piece at a time.  */\n@@ -3415,6 +3414,8 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t of sibling calls.  */\n \t      set_mem_alias_set (target, 0);\n \t    }\n+\t  else\n+\t    set_mem_align (target, align);\n \n \t  /* TEMP is the address of the block.  Copy the data there.  */\n \t  if (GET_CODE (size) == CONST_INT\n@@ -3833,8 +3834,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  rtx inner_to_rtx\n \t    = adjust_address (to_rtx, BLKmode, bitpos / BITS_PER_UNIT);\n \n-\t  emit_block_move (inner_to_rtx, from_rtx, expr_size (from),\n-\t\t\t   MIN (alignment, from_align));\n+\t  emit_block_move (inner_to_rtx, from_rtx, expr_size (from));\n+\n \t  free_temp_slots ();\n \t  pop_temp_slots ();\n \t  return to_rtx;\n@@ -3894,8 +3895,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \temit_group_load (to_rtx, value, int_size_in_bytes (TREE_TYPE (from)),\n \t\t\t TYPE_ALIGN (TREE_TYPE (from)));\n       else if (GET_MODE (to_rtx) == BLKmode)\n-\temit_block_move (to_rtx, value, expr_size (from),\n-\t\t\t TYPE_ALIGN (TREE_TYPE (from)));\n+\temit_block_move (to_rtx, value, expr_size (from));\n       else\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n@@ -3915,11 +3915,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */\n \n   if (to_rtx == 0)\n-    {\n-      to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n-      if (GET_CODE (to_rtx) == MEM)\n-\tset_mem_alias_set (to_rtx, get_alias_set (to));\n-    }\n+    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n \n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL\n@@ -4274,22 +4270,20 @@ store_expr (exp, target, want_value)\n \t  size = expr_size (exp);\n \t  if (GET_CODE (size) == CONST_INT\n \t      && INTVAL (size) < TREE_STRING_LENGTH (exp))\n-\t    emit_block_move (target, temp, size, TYPE_ALIGN (TREE_TYPE (exp)));\n+\t    emit_block_move (target, temp, size);\n \t  else\n \t    {\n \t      /* Compute the size of the data to copy from the string.  */\n \t      tree copy_size\n \t\t= size_binop (MIN_EXPR,\n \t\t\t      make_tree (sizetype, size),\n \t\t\t      size_int (TREE_STRING_LENGTH (exp)));\n-\t      unsigned int align = TYPE_ALIGN (TREE_TYPE (exp));\n \t      rtx copy_size_rtx = expand_expr (copy_size, NULL_RTX,\n \t\t\t\t\t       VOIDmode, 0);\n \t      rtx label = 0;\n \n \t      /* Copy that much.  */\n-\t      emit_block_move (target, temp, copy_size_rtx,\n-\t\t\t       TYPE_ALIGN (TREE_TYPE (exp)));\n+\t      emit_block_move (target, temp, copy_size_rtx);\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n \t\t Do all calculations in ptr_mode.  */\n@@ -4301,10 +4295,6 @@ store_expr (exp, target, want_value)\n \t\t{\n \t\t  addr = plus_constant (addr, TREE_STRING_LENGTH (exp));\n \t\t  size = plus_constant (size, -TREE_STRING_LENGTH (exp));\n-\t\t  align = MIN (align,\n-\t\t\t       (unsigned int) (BITS_PER_UNIT\n-\t\t\t\t\t       * (INTVAL (copy_size_rtx)\n-\t\t\t\t\t\t  & - INTVAL (copy_size_rtx))));\n \t\t}\n \t      else\n \t\t{\n@@ -4317,12 +4307,10 @@ store_expr (exp, target, want_value)\n \t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n \t\t\t\t       OPTAB_LIB_WIDEN);\n \n-\t\t  align = BITS_PER_UNIT;\n \t\t  label = gen_label_rtx ();\n \t\t  emit_cmp_and_jump_insns (size, const0_rtx, LT, NULL_RTX,\n \t\t\t\t\t   GET_MODE (size), 0, 0, label);\n \t\t}\n-\t      align = MIN (align, expr_align (copy_size));\n \n \t      if (size != const0_rtx)\n \t\t{\n@@ -4340,7 +4328,7 @@ store_expr (exp, target, want_value)\n  \t\t\t\t       GEN_INT (MEMORY_USE_WO),\n \t\t\t\t       TYPE_MODE (integer_type_node));\n \t\t  in_check_memory_usage = 0;\n-\t\t  clear_storage (dest, size, align);\n+\t\t  clear_storage (dest, size);\n \t\t}\n \n \t      if (label)\n@@ -4353,8 +4341,7 @@ store_expr (exp, target, want_value)\n \temit_group_load (target, temp, int_size_in_bytes (TREE_TYPE (exp)),\n \t\t\t TYPE_ALIGN (TREE_TYPE (exp)));\n       else if (GET_MODE (temp) == BLKmode)\n-\temit_block_move (target, temp, expr_size (exp),\n-\t\t\t TYPE_ALIGN (TREE_TYPE (exp)));\n+\temit_block_move (target, temp, expr_size (exp));\n       else\n \temit_move_insn (target, temp);\n     }\n@@ -4552,7 +4539,7 @@ store_constructor (exp, target, align, cleared, size)\n \n \t  /* If the constructor is empty, clear the union.  */\n \t  if (! CONSTRUCTOR_ELTS (exp)  && ! cleared)\n-\t    clear_storage (target, expr_size (exp), TYPE_ALIGN (type));\n+\t    clear_storage (target, expr_size (exp));\n \t}\n \n       /* If we are building a static constructor into a register,\n@@ -4581,7 +4568,7 @@ store_constructor (exp, target, align, cleared, size)\n \t\t   || (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (target)) == size))\n \t{\n \t  if (! cleared)\n-\t    clear_storage (target, GEN_INT (size), align);\n+\t    clear_storage (target, GEN_INT (size));\n \n \t  cleared = 1;\n \t}\n@@ -4776,7 +4763,7 @@ store_constructor (exp, target, align, cleared, size)\n       if (need_to_clear && size > 0)\n \t{\n \t  if (! cleared)\n-\t    clear_storage (target, GEN_INT (size), align);\n+\t    clear_storage (target, GEN_INT (size));\n \t  cleared = 1;\n \t}\n       else if (REG_P (target))\n@@ -4962,7 +4949,7 @@ store_constructor (exp, target, align, cleared, size)\n       if (elt == NULL_TREE && size > 0)\n \t{\n \t  if (!cleared)\n-\t    clear_storage (target, GEN_INT (size), TYPE_ALIGN (type));\n+\t    clear_storage (target, GEN_INT (size));\n \t  return;\n \t}\n \n@@ -5037,7 +5024,7 @@ store_constructor (exp, target, align, cleared, size)\n \t\t   || (tree_low_cst (TREE_VALUE (elt), 0)\n \t\t       - tree_low_cst (TREE_PURPOSE (elt), 0) + 1\n \t\t       != (HOST_WIDE_INT) nbits))))\n-\t  clear_storage (target, expr_size (exp), TYPE_ALIGN (type));\n+\t  clear_storage (target, expr_size (exp));\n \n       for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n \t{\n@@ -5281,8 +5268,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t  emit_block_move (target, temp,\n \t\t\t   bitsize == -1 ? expr_size (exp)\n \t\t\t   : GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n-\t\t\t\t      / BITS_PER_UNIT),\n-\t\t\t   align);\n+\t\t\t\t      / BITS_PER_UNIT));\n \n \t  return value_mode == VOIDmode ? const0_rtx : target;\n \t}\n@@ -5343,15 +5329,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t\t bitpos / BITS_PER_UNIT));\n \n       MEM_SET_IN_STRUCT_P (to_rtx, 1);\n-      /* If the address of the structure varies, then it might be on\n-\t the stack.  And, stack slots may be shared across scopes.\n-\t So, two different structures, of different types, can end up\n-\t at the same location.  We will give the structures alias set\n-\t zero; here we must be careful not to give non-zero alias sets\n-\t to their fields.  */\n-      set_mem_alias_set (to_rtx,\n-\t\t\t rtx_varies_p (addr, /*for_alias=*/0)\n-\t\t\t ? 0 : alias_set);\n+      set_mem_alias_set (to_rtx, alias_set);\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n     }\n@@ -5999,7 +5977,7 @@ highest_pow2_factor (exp)\n     case CEIL_DIV_EXPR:\n       c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n       c1 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n-      return c0 / c1;\n+      return MAX (1, c0 / c1);\n \n     case NON_LVALUE_EXPR:  case NOP_EXPR:  case CONVERT_EXPR:\n     case COMPOUND_EXPR:  case SAVE_EXPR:\n@@ -7189,8 +7167,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\temit_block_move (target, op0,\n \t\t\t\t bitsize == -1 ? expr_size  (exp)\n \t\t\t\t : GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n-\t\t\t\t\t    / BITS_PER_UNIT),\n-\t\t\t\t BITS_PER_UNIT);\n+\t\t\t\t\t    / BITS_PER_UNIT));\n \n \t\treturn target;\n \t      }\n@@ -9172,7 +9149,7 @@ expand_expr_unaligned (exp, palign)\n \t  /* Get a reference to just this component.  */\n \t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \n-\tset_mem_alias_set (op0, get_alias_set (exp));\n+\tset_mem_attributes (op0, exp, 0);\n \n \t/* Adjust the alignment in case the bit position is not\n \t   a multiple of the alignment of the inner object.  */"}, {"sha": "015561159bb290ad1c418cfedda3529fb6fb1546", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -410,7 +410,7 @@ extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t  rtx, int));\n \n /* Emit code to move a block Y to a block X.  */\n-extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, unsigned int));\n+extern rtx emit_block_move PARAMS ((rtx, rtx, rtx));\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n@@ -444,9 +444,8 @@ extern void use_regs PARAMS ((rtx *, int, int));\n extern void use_group_regs PARAMS ((rtx *, rtx));\n \n /* Write zeros through the storage of OBJECT.\n-   If OBJECT has BLKmode, SIZE is its length in bytes and ALIGN is its\n-   alignment.  */\n-extern rtx clear_storage PARAMS ((rtx, rtx, unsigned int));\n+   If OBJECT has BLKmode, SIZE is its length in bytes.  */\n+extern rtx clear_storage PARAMS ((rtx, rtx));\n \n /* Return non-zero if it is desirable to store LEN bytes generated by\n    CONSTFUN with several move instructions by store_by_pieces"}, {"sha": "b0fa255dc9caf40a8ac8f3ca11495465e5d7e181", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1,3 +1,8 @@\n+Tue Oct 23 14:01:27 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* com.c (LANG_HOOKS_GET_ALIAS_SET): New macro.\n+\t(lang_get_alias_set): Delete.\n+\n 2001-10-23  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* g77.texi (Sending Patches): Remove."}, {"sha": "ccff61a9d68e303955c869192044ef58f4c4a65e", "filename": "gcc/f/com.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -14276,6 +14276,14 @@ static void ffe_init_options PARAMS ((void));\n #undef  LANG_HOOKS_DECODE_OPTION\n #define LANG_HOOKS_DECODE_OPTION\tffe_decode_option\n \n+/* We do not wish to use alias-set based aliasing at all.  Used in the\n+   extreme (every object with its own set, with equivalences recorded) it\n+   might be helpful, but there are problems when it comes to inlining.  We\n+   get on ok with flag_argument_noalias, and alias-set aliasing does\n+   currently limit how stack slots can be reused, which is a lose.  */\n+#undef LANG_HOOKS_GET_ALIAS_SET\n+#define LANG_HOOKS_GET_ALIAS_SET hook_get_alias_set_0\n+\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* used by print-tree.c */\n@@ -14303,21 +14311,6 @@ lang_identify ()\n   return \"f77\";\n }\n \n-/* Return the typed-based alias set for T, which may be an expression\n-   or a type.  Return -1 if we don't do anything special.  */\n-\n-HOST_WIDE_INT\n-lang_get_alias_set (t)\n-     tree t ATTRIBUTE_UNUSED;\n-{\n-  /* We do not wish to use alias-set based aliasing at all.  Used in the\n-     extreme (every object with its own set, with equivalences recorded)\n-     it might be helpful, but there are problems when it comes to inlining.\n-     We get on ok with flag_argument_noalias, and alias-set aliasing does\n-     currently limit how stack slots can be reused, which is a lose.  */\n-  return 0;\n-}\n-\n static void\n ffe_init_options ()\n {"}, {"sha": "1cbd68892bd231343a5ade8468e1e6c2452d5683", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1109,6 +1109,8 @@ noce_try_cmove_arith (if_info)\n \tMEM_SCALAR_P (tmp) = 1;\n       if (MEM_ALIAS_SET (if_info->a) == MEM_ALIAS_SET (if_info->b))\n \tset_mem_alias_set (tmp, MEM_ALIAS_SET (if_info->a));\n+      set_mem_align (tmp,\n+\t\t     MIN (MEM_ALIGN (if_info->a), MEM_ALIGN (if_info->b)));\n \n       noce_emit_move_insn (if_info->x, tmp);\n     }"}, {"sha": "05522671f46b6ad710e6875e4f1b4ea76284d2dd", "filename": "gcc/integrate.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2184,13 +2184,18 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n #ifndef NO_FUNCTION_CSE\n       if (! (optimize && ! flag_no_function_cse))\n #endif\n-\treturn\n-\t  gen_rtx_CALL\n-\t    (GET_MODE (orig),\n-\t     gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n-\t\t\t  copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0),\n-\t\t\t\t\t\t   map, 0)),\n-\t     copy_rtx_and_substitute (XEXP (orig, 1), map, 0));\n+\t{\n+\t  rtx copy\n+\t    = gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n+\t\t\t   copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0),\n+\t\t\t\t\t\t    map, 0));\n+\n+\t  MEM_COPY_ATTRIBUTES (copy, orig);\n+\n+\t  return\n+\t    gen_rtx_CALL (GET_MODE (orig), copy, \n+\t\t\t  copy_rtx_and_substitute (XEXP (orig, 1), map, 0));\n+\t}\n       break;\n \n #if 0"}, {"sha": "6ed62044613b11f0d9c47440d1418f918fca7a62", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1,3 +1,7 @@\n+Tue Oct 23 14:02:17 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* lang.c (lang_get_alias_set): Deleted.\n+\n 2001-10-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gjavah.c (jni_print_char): Fix thinko in last change."}, {"sha": "ff1fce58252aea21996315e2129d225355552137", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -789,13 +789,3 @@ lang_print_xnode (file, node, indent)\n      int indent __attribute ((__unused__));\n {\n }\n-\n-/* Return the typed-based alias set for T, which may be an expression\n-   or a type.  Return -1 if we don't do anything special.  */\n-\n-HOST_WIDE_INT\n-lang_get_alias_set (t)\n-     tree t ATTRIBUTE_UNUSED;\n-{\n-  return -1;\n-}"}, {"sha": "b912e711bfcd66d65de21a110bd7676e729deb01", "filename": "gcc/langhooks.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -30,12 +30,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n \n /* Do nothing; in many cases the default hook.  */\n+\n void\n lang_hook_default_do_nothing ()\n {\n }\n \n+/* Provide a default routine for alias sets that always returns -1.  This\n+   is used by languages that don't need to do anything special.  */\n+\n+HOST_WIDE_INT\n+lang_hook_default_get_alias_set (t)\n+     tree t ATTRIBUTE_UNUSED;\n+{\n+  return -1;\n+}\n+\n /* Do nothing; the default hook to decode an option.  */\n+\n int\n lang_hook_default_decode_option (argc, argv)\n      int argc ATTRIBUTE_UNUSED;\n@@ -44,6 +56,16 @@ lang_hook_default_decode_option (argc, argv)\n   return 0;\n }\n \n+/* Provide a hook routine for alias sets that always returns 0.  This is\n+   used by languages that haven't deal with alias sets yet.  */\n+\n+HOST_WIDE_INT\n+hook_get_alias_set_0 (t)\n+     tree t ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n /* lang_hooks.tree_inlining.walk_subtrees is called by walk_tree()\n    after handling common cases, but before walking code-specific\n    sub-trees.  If this hook is overridden for a language, it should"}, {"sha": "69ff1d819bf626a90fb5968ea93b42b12d0f5155", "filename": "gcc/langhooks.h", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -22,6 +22,10 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_LANG_HOOKS_H\n #define GCC_LANG_HOOKS_H\n \n+/* Provide a hook routine for alias sets that always returns 1.  This is\n+   used by languages that haven't deal with alias sets yet.  */\n+extern HOST_WIDE_INT hook_get_alias_set_0\tPARAMS ((tree));\n+\n /* Note to creators of new hooks:\n \n    The macros in this file should NOT be surrounded by a\n@@ -33,30 +37,34 @@ Boston, MA 02111-1307, USA.  */\n \n extern void lang_hook_default_do_nothing PARAMS ((void));\n extern int lang_hook_default_decode_option PARAMS ((int, char **));\n+extern HOST_WIDE_INT lang_hook_default_get_alias_set PARAMS ((tree));\n \n #define LANG_HOOKS_INIT\t\t\tlang_hook_default_do_nothing\n #define LANG_HOOKS_FINISH\t\tlang_hook_default_do_nothing\n #define LANG_HOOKS_INIT_OPTIONS\t\tlang_hook_default_do_nothing\n #define LANG_HOOKS_DECODE_OPTION\tlang_hook_default_decode_option\n #define LANG_HOOKS_POST_OPTIONS\t\tlang_hook_default_do_nothing\n+#define LANG_HOOKS_GET_ALIAS_SET\tlang_hook_default_get_alias_set\n \n #define LANG_HOOKS_HONOR_READONLY\tfalse\n \n /* Declarations of default tree inlining hooks.  */\n-tree tree_inlining_default_hook_walk_subtrees PARAMS ((tree*, int *,\n-\t\t\t\t\t\t       walk_tree_fn,\n-\t\t\t\t\t\t       void *, void *));\n-int tree_inlining_default_hook_cannot_inline_tree_fn PARAMS ((tree*));\n-int tree_inlining_default_hook_disregard_inline_limits PARAMS ((tree));\n-tree tree_inlining_default_hook_add_pending_fn_decls PARAMS ((void*, tree));\n-int tree_inlining_default_hook_tree_chain_matters_p PARAMS ((tree));\n-int tree_inlining_default_hook_auto_var_in_fn_p PARAMS ((tree, tree));\n+tree tree_inlining_default_hook_walk_subtrees\t\tPARAMS ((tree *, int *,\n+\t\t\t\t\t\t\t\t walk_tree_fn,\n+\t\t\t\t\t\t\t\t void *,\n+\t\t\t\t\t\t\t\t void *));\n+int tree_inlining_default_hook_cannot_inline_tree_fn\tPARAMS ((tree *));\n+int tree_inlining_default_hook_disregard_inline_limits\tPARAMS ((tree));\n+tree tree_inlining_default_hook_add_pending_fn_decls\tPARAMS ((void *,\n+\t\t\t\t\t\t\t\t tree));\n+int tree_inlining_default_hook_tree_chain_matters_p\tPARAMS ((tree));\n+int tree_inlining_default_hook_auto_var_in_fn_p\t\tPARAMS ((tree, tree));\n tree tree_inlining_default_hook_copy_res_decl_for_inlining PARAMS ((tree, tree,\n \t\t\t\t\t\t\t\t    tree,\n \t\t\t\t\t\t\t\t    void *,\n \t\t\t\t\t\t\t\t    int *,\n \t\t\t\t\t\t\t\t    void *));\n-int tree_inlining_default_hook_anon_aggr_type_p PARAMS ((tree));\n+int tree_inlining_default_hook_anon_aggr_type_p\t\tPARAMS ((tree));\n \n /* Tree inlining hooks.  */\n #define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES \\\n@@ -94,6 +102,7 @@ int tree_inlining_default_hook_anon_aggr_type_p PARAMS ((tree));\n   LANG_HOOKS_INIT_OPTIONS, \\\n   LANG_HOOKS_DECODE_OPTION, \\\n   LANG_HOOKS_POST_OPTIONS, \\\n+  LANG_HOOKS_GET_ALIAS_SET, \\\n   LANG_HOOKS_HONOR_READONLY, \\\n   LANG_HOOKS_TREE_INLINING_INITIALIZER \\\n }"}, {"sha": "1f98f7cdf1d0967d5ed584c8de0a5e50dd56fc03", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2025,10 +2025,11 @@ alter_reg (i, from_reg)\n \t\t below.  */\n \t      adjust = GET_MODE_SIZE (mode) - total_size;\n \t      if (adjust)\n-\t\tstack_slot = gen_rtx_MEM (mode_for_size (total_size\n+\t\tstack_slot\n+\t\t  = adjust_address_nv (x, mode_for_size (total_size\n \t\t\t\t\t\t\t * BITS_PER_UNIT,\n \t\t\t\t\t\t\t MODE_INT, 1),\n-\t\t\t\t\t  plus_constant (XEXP (x, 0), adjust));\n+\t\t\t\t       adjust);\n \t    }\n \n \t  spill_stack_slot[from_reg] = stack_slot;"}, {"sha": "deaf22c24cf39e266670fa0a044af0f3f4303f14", "filename": "gcc/rtl.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -531,6 +531,7 @@ copy_most_rtx (orig, may_share)\n }\n \n /* Create a new copy of an rtx.  Only copy just one level.  */\n+\n rtx\n shallow_copy_rtx (orig)\n      rtx orig;\n@@ -551,6 +552,23 @@ shallow_copy_rtx (orig)\n \n   return copy;\n }\n+\n+/* Return the alignment of MODE. This will be bounded by 1 and\n+   BIGGEST_ALIGNMENT.  */\n+\n+unsigned int\n+get_mode_alignment (mode)\n+     enum machine_mode mode;\n+{\n+  unsigned int alignment = GET_MODE_UNIT_SIZE (mode);\n+  \n+  /* Extract the LSB of the size.  */\n+  alignment = alignment & -alignment;\n+  alignment *= BITS_PER_UNIT;\n+\n+  alignment = MIN (BIGGEST_ALIGNMENT, MAX (1, alignment));\n+  return alignment;\n+}\n \f\n /* This is 1 until after the rtl generation pass.  */\n int rtx_equal_function_value_matters;"}, {"sha": "d1071673e35c59b7c5bdaae9c5af52b86d9493c7", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -913,7 +913,11 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n #define MEM_SIZE(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->size)\n \n /* For a MEM rtx, the alignment in bits.  */\n-#define MEM_ALIGN(RTX) (MEM_ATTRS (RTX) == 0 ? 1 : MEM_ATTRS (RTX)->align)\n+#define MEM_ALIGN(RTX)\t\t\t\t\t\t\t\\\n+(MEM_ATTRS (RTX) != 0 ? MEM_ATTRS (RTX)->align\t\t\t\t\\\n+ : GET_MODE (RTX) != BLKmode ? GET_MODE_ALIGNMENT (GET_MODE (RTX))\t\\\n+ : BITS_PER_UNIT)\n+\n \n /* Copy the attributes that apply to memory locations from RHS to LHS.  */\n #define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\\"}, {"sha": "c0837dafd5ec152b5536f75a699e384ccac5eed2", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -1860,23 +1860,6 @@ get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n   return mode;\n }\n \n-/* Return the alignment of MODE. This will be bounded by 1 and\n-   BIGGEST_ALIGNMENT.  */\n-\n-unsigned int\n-get_mode_alignment (mode)\n-     enum machine_mode mode;\n-{\n-  unsigned int alignment = GET_MODE_UNIT_SIZE (mode);\n-  \n-  /* Extract the LSB of the size.  */\n-  alignment = alignment & -alignment;\n-  alignment *= BITS_PER_UNIT;\n-\n-  alignment = MIN (BIGGEST_ALIGNMENT, MAX (1, alignment));\n-  return alignment;\n-}\n-\n /* This function is run once to initialize stor-layout.c.  */\n \n void"}, {"sha": "93b30f44578994d2b05d22764b1e5e20f4648c70", "filename": "gcc/toplev.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -31,7 +31,7 @@ struct rtx_def;\n #define skip_leading_substring(whole,  part) \\\n    (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n \n-extern int toplev_main\t\t\tPARAMS ((int argc, char **argv));\n+extern int toplev_main\t\t\tPARAMS ((int, char **));\n extern int read_integral_parameter\tPARAMS ((const char *, const char *,\n \t\t\t\t\t\tconst int));\n extern int count_error\t\t\tPARAMS ((int));\n@@ -127,7 +127,8 @@ struct lang_hooks_for_tree_inlining\n \t\t\t\t\t     void *, void *));\n   int (*cannot_inline_tree_fn) PARAMS ((union tree_node **));\n   int (*disregard_inline_limits) PARAMS ((union tree_node *));\n-  union tree_node *(*add_pending_fn_decls) PARAMS ((void*, union tree_node *));\n+  union tree_node *(*add_pending_fn_decls) PARAMS ((void *,\n+\t\t\t\t\t\t    union tree_node *));\n   int (*tree_chain_matters_p) PARAMS ((union tree_node *));\n   int (*auto_var_in_fn_p) PARAMS ((union tree_node *, union tree_node *));\n   union tree_node *(*copy_res_decl_for_inlining) PARAMS ((union tree_node *,\n@@ -164,6 +165,10 @@ struct lang_hooks\n   /* Called when all command line options have been processed.  */\n   void (*post_options) PARAMS ((void));\n \n+  /* Called to obtain the alias set to be used for an expression or type.\n+     Returns -1 if the language does nothing special for it.  */\n+  HOST_WIDE_INT (*get_alias_set) PARAMS ((tree));\n+\n   /* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */\n   bool honor_readonly;\n "}, {"sha": "44c54974e223af69e117f0baebb0d75a9e881890", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac61af705335691fd0d91ec6cd96e65bb81201c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8ac61af705335691fd0d91ec6cd96e65bb81201c", "patch": "@@ -2818,9 +2818,6 @@ extern int alias_sets_conflict_p\t\tPARAMS ((HOST_WIDE_INT,\n extern int readonly_fields_p\t\t\tPARAMS ((tree));\n extern int objects_must_conflict_p\t\tPARAMS ((tree, tree));\n \n-/* In c-common.c */\n-extern HOST_WIDE_INT lang_get_alias_set\t\tPARAMS ((tree));\n-\n /* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of thing\n    that the assembler should talk about, set DECL_ASSEMBLER_NAME to an\n    appropriate IDENTIFIER_NODE.  Otherwise, set it to the"}]}