{"sha": "6be583037c3cc9bd254d252e6b50a7f3dba27879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlNTgzMDM3YzNjYzliZDI1NGQyNTJlNmI1MGE3ZjNkYmEyNzg3OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-07-08T21:41:02Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-07-08T21:41:02Z"}, "message": "(get_inner_unaligned_p): New function.\n\n(expand_assignment, expand_expr): Use it.\n\nFrom-SVN: r7685", "tree": {"sha": "2b4729609923f7fbc449e6e7b58c0af83ed45d71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4729609923f7fbc449e6e7b58c0af83ed45d71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6be583037c3cc9bd254d252e6b50a7f3dba27879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be583037c3cc9bd254d252e6b50a7f3dba27879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be583037c3cc9bd254d252e6b50a7f3dba27879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be583037c3cc9bd254d252e6b50a7f3dba27879/comments", "author": null, "committer": null, "parents": [{"sha": "4ee16841d49a370564703362a152dfd75412d6ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee16841d49a370564703362a152dfd75412d6ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee16841d49a370564703362a152dfd75412d6ad"}], "stats": {"total": 50, "additions": 43, "deletions": 7}, "files": [{"sha": "d9fe56030c73d5f923448d2ba97426af7a3062c2", "filename": "gcc/expr.c", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be583037c3cc9bd254d252e6b50a7f3dba27879/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be583037c3cc9bd254d252e6b50a7f3dba27879/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6be583037c3cc9bd254d252e6b50a7f3dba27879", "patch": "@@ -147,6 +147,7 @@ static void move_by_pieces_1\tPROTO((rtx (*) (), enum machine_mode,\n static void store_constructor\tPROTO((tree, rtx));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int, int));\n+static int get_inner_unaligned_p PROTO((tree));\n static tree save_noncopied_parts PROTO((tree, tree));\n static tree init_noncopied_parts PROTO((tree, tree));\n static int safe_from_p\t\tPROTO((rtx, tree));\n@@ -2353,14 +2354,16 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n   /* Assignment of a structure component needs special treatment\n      if the structure component's rtx is not simply a MEM.\n-     Assignment of an array element at a constant index\n-     has the same problem.  */\n+     Assignment of an array element at a constant index, and assignment of\n+     an array element in an unaligned packed structure field, has the same\n+     problem.  */\n \n   if (TREE_CODE (to) == COMPONENT_REF\n       || TREE_CODE (to) == BIT_FIELD_REF\n       || (TREE_CODE (to) == ARRAY_REF\n-\t  && TREE_CODE (TREE_OPERAND (to, 1)) == INTEGER_CST\n-\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (to))) == INTEGER_CST))\n+\t  && ((TREE_CODE (TREE_OPERAND (to, 1)) == INTEGER_CST\n+\t       && TREE_CODE (TYPE_SIZE (TREE_TYPE (to))) == INTEGER_CST)\n+\t      || (STRICT_ALIGNMENT && get_inner_unaligned_p (to)))))\n     {\n       enum machine_mode mode1;\n       int bitsize;\n@@ -3126,6 +3129,37 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n     }\n }\n \f\n+/* Return true if any object containing the innermost array is an unaligned\n+   packed structure field.  */\n+\n+static int\n+get_inner_unaligned_p (exp)\n+     tree exp;\n+{\n+  int needed_alignment = TYPE_ALIGN (TREE_TYPE (exp));\n+\n+  while (1)\n+    {\n+      if (TREE_CODE (exp) == COMPONENT_REF || TREE_CODE (exp) == BIT_FIELD_REF)\n+\t{\n+\t  if (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n+\t      < needed_alignment)\n+\t    return 1;\n+\t}\n+      else if (TREE_CODE (exp) != ARRAY_REF\n+\t       && TREE_CODE (exp) != NON_LVALUE_EXPR\n+\t       && ! ((TREE_CODE (exp) == NOP_EXPR\n+\t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n+\t\t     && (TYPE_MODE (TREE_TYPE (exp))\n+\t\t\t == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))))\n+\tbreak;\n+\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+\n+  return 0;\n+}\n+\n /* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,\n    or an ARRAY_REF, look for nested COMPONENT_REFs, BIT_FIELD_REFs, or\n    ARRAY_REFs and find the ultimate containing object, which we return.\n@@ -4232,10 +4266,12 @@ expand_expr (exp, target, tmode, modifier)\n \t  index = fold (build (MINUS_EXPR, index_type, index,\n \t\t\t       convert (sizetype, low_bound)));\n \n-\tif (TREE_CODE (index) != INTEGER_CST\n-\t    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\tif ((TREE_CODE (index) != INTEGER_CST\n+\t     || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t    && (! STRICT_ALIGNMENT || ! get_inner_unaligned_p (exp)))\n \t  {\n-\t    /* Nonconstant array index or nonconstant element size.\n+\t    /* Nonconstant array index or nonconstant element size, and\n+\t       not an array in an unaligned (packed) structure field.\n \t       Generate the tree for *(&array+index) and expand that,\n \t       except do it in a language-independent way\n \t       and don't complain about non-lvalue arrays."}]}