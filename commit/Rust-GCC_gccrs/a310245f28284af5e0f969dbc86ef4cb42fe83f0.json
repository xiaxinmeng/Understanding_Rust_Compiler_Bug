{"sha": "a310245f28284af5e0f969dbc86ef4cb42fe83f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxMDI0NWYyODI4NGFmNWUwZjk2OWRiYzg2ZWY0Y2I0MmZlODNmMA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-02-20T11:09:16Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-02-20T11:09:16Z"}, "message": "re PR middle-end/19698 (Infinite loop in update_life_info)\n\n\tPR middle-end/19698\n\t* function.h (struct function): New field `max_loop_depth'.\n\t* cfgloop.c (establish_preds): Update maximum loop depth seen so far.\n\t(flow_loops_find): Reset the max loop depth count before finding loops.\n\t* flow.c (MAX_LIVENESS_ROUNDS): New constant.\n\t(update_life_info_in_dirty_blocks): Remove 2002-05-28 workaround.\n\t(calculate_global_regs_live): Make sure the loop will terminate\n\twhen the initial sets are not empty.\n\nFrom-SVN: r95299", "tree": {"sha": "90c7593e6e12d11084f0ca47062016f232b3612f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90c7593e6e12d11084f0ca47062016f232b3612f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a310245f28284af5e0f969dbc86ef4cb42fe83f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a310245f28284af5e0f969dbc86ef4cb42fe83f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a310245f28284af5e0f969dbc86ef4cb42fe83f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a310245f28284af5e0f969dbc86ef4cb42fe83f0/comments", "author": null, "committer": null, "parents": [{"sha": "9f9348d75afa0bbeb07232c7ad1acc4941b0d8fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f9348d75afa0bbeb07232c7ad1acc4941b0d8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f9348d75afa0bbeb07232c7ad1acc4941b0d8fa"}], "stats": {"total": 167, "additions": 149, "deletions": 18}, "files": [{"sha": "eb1a9be39ebbd5b18354ab47b9cb845290a45c8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a310245f28284af5e0f969dbc86ef4cb42fe83f0", "patch": "@@ -1,3 +1,14 @@\n+2005-02-19  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR middle-end/19698 \n+\t* function.h (struct function): New field `max_loop_depth'.\n+\t* cfgloop.c (establish_preds): Update maximum loop depth seen so far.\n+\t(flow_loops_find): Reset the max loop depth count before finding loops.\n+\t* flow.c (MAX_LIVENESS_ROUNDS): New constant.\n+\t(update_life_info_in_dirty_blocks): Remove 2002-05-28 workaround.\n+\t(calculate_global_regs_live): Make sure the loop will terminate\n+\twhen the initial sets are not empty.\n+\n 2005-02-19  Zack Weinberg  <zack@codesourcery.com>\n \n \t* mklibgcc.in: If libgcc_eh.a would be empty, put a dummy\n@@ -125,8 +136,8 @@\n 2005-02-18  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR middle-end/20030\n-\t* fold-const.c (fold_indirect_ref_1): Use the correct index for zero access,\n-\tthe lower bound of the array type if it exists.\n+\t* fold-const.c (fold_indirect_ref_1): Use the correct index for zero\n+\taccess, the lower bound of the array type if it exists.\n \n 2005-02-18  Alexandre Oliva  <aoliva@redhat.com>\n \n@@ -764,7 +775,7 @@\n \t* libgcc2.c (__divsc3, __divdc3, __divxc3, __divtc3,\n \t__mulsc3, __muldc3, __mulxc3, __multc3): New.\n \t* libgcc2.h: Declare them.\n- \t* libgcc-std.ver: Export them.\n+\t* libgcc-std.ver: Export them.\n \t* mklibgcc.in (lib2funcs): Build them.\n \n 2005-02-11  Steven Bosscher  <stevenb@suse.de>"}, {"sha": "40a6de489ccdb8bf436436436bf77adf6a7b4442", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=a310245f28284af5e0f969dbc86ef4cb42fe83f0", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n #include \"obstack.h\"\n+#include \"function.h\"\n #include \"basic-block.h\"\n #include \"toplev.h\"\n #include \"cfgloop.h\"\n@@ -510,6 +511,10 @@ establish_preds (struct loop *loop)\n   struct loop *ploop, *father = loop->outer;\n \n   loop->depth = father->depth + 1;\n+\n+  /* Remember the current loop depth if it is the largest seen so far.  */\n+  cfun->max_loop_depth = MAX (cfun->max_loop_depth, loop->depth);\n+\n   if (loop->pred)\n     free (loop->pred);\n   loop->pred = xmalloc (sizeof (struct loop *) * loop->depth);\n@@ -819,6 +824,10 @@ flow_loops_find (struct loops *loops, int flags)\n \n   memset (loops, 0, sizeof *loops);\n \n+  /* We are going to recount the maximum loop depth,\n+     so throw away the last count.  */\n+  cfun->max_loop_depth = 0;\n+\n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n   if (n_basic_blocks == 0)\n@@ -1213,7 +1222,7 @@ remove_bb_from_loops (basic_block bb)\n      loop->pred[i]->num_nodes--;\n    bb->loop_father = NULL;\n    bb->loop_depth = 0;\n- }\n+}\n \n /* Finds nearest common ancestor in loop tree for given loops.  */\n struct loop *"}, {"sha": "172541d2fa58ba513850065ba41fcfc9719d1a06", "filename": "gcc/flow.c", "status": "modified", "additions": 117, "deletions": 14, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a310245f28284af5e0f969dbc86ef4cb42fe83f0", "patch": "@@ -165,6 +165,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif\n #endif\n \n+/* This is the maximum number of times we process any given block if the\n+   latest loop depth count is smaller than this number.  Only used for the\n+   failure strategy to avoid infinite loops in calculate_global_regs_live.  */\n+#define MAX_LIVENESS_ROUNDS 20\n+\n /* Nonzero if the second flow pass has completed.  */\n int flow2_completed;\n \n@@ -729,21 +734,10 @@ update_life_info_in_dirty_blocks (enum update_life_extent extent, int prop_flags\n   sbitmap_zero (update_life_blocks);\n   FOR_EACH_BB (bb)\n     {\n-      if (extent == UPDATE_LIFE_LOCAL)\n+      if (bb->flags & BB_DIRTY)\n \t{\n-\t  if (bb->flags & BB_DIRTY)\n-\t    {\n-\t      SET_BIT (update_life_blocks, bb->index);\n-\t      n++;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* ??? Bootstrap with -march=pentium4 fails to terminate\n-\t     with only a partial life update.  */\n \t  SET_BIT (update_life_blocks, bb->index);\n-\t  if (bb->flags & BB_DIRTY)\n-\t    n++;\n+\t  n++;\n \t}\n     }\n \n@@ -1010,6 +1004,9 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n {\n   basic_block *queue, *qhead, *qtail, *qend, bb;\n   regset tmp, new_live_at_end, invalidated_by_call;\n+  regset registers_made_dead;\n+  bool failure_strategy_required = false;\n+  int *block_accesses;\n \n   /* The registers that are modified within this in block.  */\n   regset *local_sets;\n@@ -1030,6 +1027,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n   tmp = ALLOC_REG_SET (&reg_obstack);\n   new_live_at_end = ALLOC_REG_SET (&reg_obstack);\n   invalidated_by_call = ALLOC_REG_SET (&reg_obstack);\n+  registers_made_dead = ALLOC_REG_SET (&reg_obstack);\n \n   /* Inconveniently, this is only readily available in hard reg set form.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n@@ -1070,6 +1068,8 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t}\n     }\n \n+  block_accesses = xcalloc (last_basic_block, sizeof (int));\n+  \n   /* We clean aux when we remove the initially-enqueued bbs, but we\n      don't enqueue ENTRY and EXIT initially, so clean them upfront and\n      unconditionally.  */\n@@ -1095,7 +1095,41 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n      from GLOBAL_LIVE_AT_START.  In the former case, the register\n      could go away only if it disappeared from GLOBAL_LIVE_AT_START\n      for one of the successor blocks.  By induction, that cannot\n-     occur.  */\n+     occur.\n+\n+     ??? This reasoning doesn't work if we start from non-empty initial\n+     GLOBAL_LIVE_AT_START sets.  And there are actually two problems:\n+       1) Updating may not terminate (endless oscillation).\n+       2) Even if it does (and it usually does), the resulting information\n+\t  may be inaccurate.  Consider for example the following case:\n+\n+\t  a = ...;\n+\t  while (...) {...}  -- 'a' not mentioned at all\n+\t  ... = a;\n+\n+\t  If the use of 'a' is deleted between two calculations of liveness\n+\t  information and the initial sets are not cleared, the information\n+\t  about a's liveness will get stuck inside the loop and the set will\n+\t  appear not to be dead.\n+\n+     We do not attempt to solve 2) -- the information is conservatively\n+     correct (i.e. we never claim that something live is dead) and the\n+     amount of optimization opportunities missed due to this problem is\n+     not significant.\n+\n+     1) is more serious.  In order to fix it, we monitor the number of times\n+     each block is processed.  Once one of the blocks has been processed more\n+     times than the maximum number of rounds, we use the following strategy:\n+     When a register disappears from one of the sets, we add it to a MAKE_DEAD\n+     set, remove all registers in this set from all GLOBAL_LIVE_AT_* sets and\n+     add the blocks with changed sets into the queue.  Thus we are guaranteed\n+     to terminate (the worst case corresponds to all registers in MADE_DEAD,\n+     in which case the original reasoning above is valid), but in general we\n+     only fix up a few offending registers.\n+\n+     The maximum number of rounds for computing liveness is the largest of\n+     MAX_LIVENESS_ROUNDS and the latest loop depth count for this function.  */\n+\n   while (qhead != qtail)\n     {\n       int rescan, changed;\n@@ -1108,6 +1142,17 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \tqhead = queue;\n       bb->aux = NULL;\n \n+      /* Should we start using the failure strategy?  */\n+      if (bb != ENTRY_BLOCK_PTR)\n+\t{\n+\t  int max_liveness_rounds =\n+\t    MAX (MAX_LIVENESS_ROUNDS, cfun->max_loop_depth);\n+\n+\t  block_accesses[bb->index]++;\n+\t  if (block_accesses[bb->index] > max_liveness_rounds)\n+\t    failure_strategy_required = true;\n+\t}\n+\n       /* Begin by propagating live_at_start from the successor blocks.  */\n       CLEAR_REG_SET (new_live_at_end);\n \n@@ -1263,6 +1308,62 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t  if (REG_SET_EQUAL_P (bb->global_live_at_start, new_live_at_end))\n \t    continue;\n \n+\t  if (failure_strategy_required)\n+\t    {\n+\t      /* Get the list of registers that were removed from the\n+\t         bb->global_live_at_start set.  */\n+\t      bitmap_and_compl (tmp, bb->global_live_at_start,\n+\t\t\t\tnew_live_at_end);\n+\t      if (!bitmap_empty_p (tmp))\n+\t\t{\n+\t\t  bool pbb_changed;\n+\t\t  basic_block pbb;\n+                \n+\t\t  /* It should not happen that one of registers we have\n+\t\t     removed last time is disappears again before any other\n+\t\t     register does.  */\n+\t\t  pbb_changed = bitmap_ior_into (registers_made_dead, tmp);\n+\t\t  gcc_assert (pbb_changed);\n+\n+\t\t  /* Now remove the registers from all sets.  */\n+\t\t  FOR_EACH_BB (pbb)\n+\t\t    {\n+\t\t      pbb_changed = false;\n+\n+\t\t      pbb_changed\n+\t\t\t|= bitmap_and_compl_into (pbb->global_live_at_start,\n+\t\t\t\t\t\t  registers_made_dead);\n+\t\t      pbb_changed\n+\t\t\t|= bitmap_and_compl_into (pbb->global_live_at_end,\n+\t\t\t\t\t\t  registers_made_dead);\n+\t\t      if (!pbb_changed)\n+\t\t\tcontinue;\n+\n+\t\t      /* Note the (possible) change.  */\n+\t\t      if (blocks_out)\n+\t\t\tSET_BIT (blocks_out, pbb->index);\n+\n+\t\t      /* Makes sure to really rescan the block.  */\n+\t\t      if (local_sets[pbb->index - (INVALID_BLOCK + 1)])\n+\t\t\t{\n+\t\t\t  FREE_REG_SET (local_sets[pbb->index - (INVALID_BLOCK + 1)]);\n+\t\t\t  FREE_REG_SET (cond_local_sets[pbb->index - (INVALID_BLOCK + 1)]);\n+\t\t\t  local_sets[pbb->index - (INVALID_BLOCK + 1)] = 0;\n+\t\t\t}\n+\n+\t\t      /* Add it to the queue.  */\n+\t\t      if (pbb->aux == NULL)\n+\t\t\t{\n+\t\t\t  *qtail++ = pbb;\n+\t\t\t  if (qtail == qend)\n+\t\t\t    qtail = queue;\n+\t\t\t  pbb->aux = pbb;\n+\t\t\t}\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\t    } /* end of failure_strategy_required */\n+\n \t  COPY_REG_SET (bb->global_live_at_start, new_live_at_end);\n \t}\n \n@@ -1284,6 +1385,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n   FREE_REG_SET (tmp);\n   FREE_REG_SET (new_live_at_end);\n   FREE_REG_SET (invalidated_by_call);\n+  FREE_REG_SET (registers_made_dead);\n \n   if (blocks_out)\n     {\n@@ -1303,6 +1405,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t}\n     }\n \n+  free (block_accesses);\n   free (queue);\n   free (cond_local_sets);\n   free (local_sets);"}, {"sha": "ef0f55a4c389b938e8d1198430585c2d2a6ff114", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a310245f28284af5e0f969dbc86ef4cb42fe83f0/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a310245f28284af5e0f969dbc86ef4cb42fe83f0", "patch": "@@ -284,12 +284,20 @@ struct function GTY(())\n   int no_debugging_symbols;\n   rtvec original_arg_vector;\n   tree original_decl_initial;\n+\n   /* Highest label number in current function.  */\n   int inl_max_label_num;\n \n   /* Function sequence number for profiling, debugging, etc.  */\n   int funcdef_no;\n \n+  /* For flow.c.  */\n+\n+  /* Highest loop depth seen so far in loop analysis.  Used in flow.c\n+     for the \"failure strategy\" when doing liveness analysis starting\n+     with non-empty initial sets.  */\n+  int max_loop_depth;\n+\n   /* For md files.  */\n \n   /* tm.h can use this to store whatever it likes.  */"}]}