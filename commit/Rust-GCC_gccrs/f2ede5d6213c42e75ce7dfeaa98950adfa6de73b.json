{"sha": "f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJlZGU1ZDYyMTNjNDJlNzVjZTdkZmVhYTk4OTUwYWRmYTZkZTczYg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-11-24T16:04:47Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-11-24T16:04:47Z"}, "message": "[multiple changes]\n\n\n2004-11-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/Makefile.am (tr1_headers): Add utility, functional.\n\t* include/Makefile.in: Regenerate.\n\n2004-11-24  Chris Jefferson  <chris@bubblescope.net>\n\n\t* include/tr1/tuple(operator!=): Change operator\n\tdefinition to match (draft) technical report.\n\t(operator>): Same.\n\t(operator<=): Same.\n\t(operator>=): Same.\n\t(ref): Move to include/tr1/functional.\n\t(cref): Same.\n\t(tuple_size<pair>): Move to include/tr1/utility.\n\t(tuple_element<,pair>): Same.\n\t* include/tr1/functional: New.\n\t* include/tr1/utility: New.\n\t* testsuite/tr1/6_container/utility/pair.cc: New.\n\nFrom-SVN: r91171", "tree": {"sha": "f7ae421ab2ab034f148557e5a3f3d6204d84cfa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7ae421ab2ab034f148557e5a3f3d6204d84cfa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/comments", "author": null, "committer": null, "parents": [{"sha": "624b15fa3fe15db62c967c61d265ed405dd7a0ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624b15fa3fe15db62c967c61d265ed405dd7a0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624b15fa3fe15db62c967c61d265ed405dd7a0ef"}], "stats": {"total": 434, "additions": 284, "deletions": 150}, "files": [{"sha": "77e328d7791ea6f84a573d797096e7b86855f80d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -1,3 +1,23 @@\n+2004-11-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/Makefile.am (tr1_headers): Add utility, functional.\n+\t* include/Makefile.in: Regenerate.\n+\n+2004-11-24  Chris Jefferson  <chris@bubblescope.net>\n+\n+\t* include/tr1/tuple(operator!=): Change operator \n+\tdefinition to match (draft) technical report.\n+\t(operator>): Same.\n+\t(operator<=): Same.\n+\t(operator>=): Same.\n+\t(ref): Move to include/tr1/functional.\n+\t(cref): Same.\n+\t(tuple_size<pair>): Move to include/tr1/utility.\n+\t(tuple_element<,pair>): Same.\n+\t* include/tr1/functional: New.\n+\t* include/tr1/utility: New.\n+\t* testsuite/tr1/6_container/utility/pair.cc: New.\n+\n 2004-11-24  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* config/locale/ieee_1003.1-2001/codecvt_specializations.h"}, {"sha": "2bcc65d592797da3859ee7018f60973673f787fb", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -229,7 +229,10 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n-\t${tr1_srcdir}/tuple\n+\t${tr1_srcdir}/functional \\\n+\t${tr1_srcdir}/tuple \\\n+\t${tr1_srcdir}/utility\n+\n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)"}, {"sha": "913529c55bc9e1c7b868711f4c1ff67e7e640c6c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -446,7 +446,9 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n-\t${tr1_srcdir}/tuple\n+\t${tr1_srcdir}/functional \\\n+\t${tr1_srcdir}/tuple \\\n+\t${tr1_srcdir}/utility\n \n \n # This is the common subset of files that all three \"C\" header models use."}, {"sha": "1e897e2b3c78be6ce22ae5b6f2631f9cb6e41b78", "filename": "libstdc++-v3/include/tr1/functional", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -0,0 +1,85 @@\n+// TR1 functional header -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+#ifndef _TR1_FUNCTIONAL\n+#define _TR1_FUNCTIONAL 1\n+\n+#include \"../functional\"\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  template<typename _Tp>\n+    class reference_wrapper\n+    {\n+      _Tp* _M_data;\n+    public:\n+      typedef _Tp type;\n+      explicit reference_wrapper(_Tp& __indata): _M_data(&__indata)\n+      { }\n+    \n+      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n+      _M_data(__inref._M_data)\n+      { }\n+\n+      reference_wrapper& \n+      operator=(const reference_wrapper<_Tp>& __inref)\n+      {\n+\t_M_data = __inref._M_data;\n+\treturn *this;\n+      }\n+      \n+      operator _Tp&() const\n+      { return this->get(); }\n+    \n+      _Tp&\n+      get() const\n+      { return *_M_data; }\n+    };\n+  \n+  // Denotes a reference should be taken to a variable.\n+  template<typename _Tp>\n+    reference_wrapper<_Tp>\n+    ref(_Tp& __t)\n+    { return reference_wrapper<_Tp>(__t); }\n+  \n+  // Denotes a const reference should be taken to a variable.\n+  template<typename _Tp>\n+    reference_wrapper<const _Tp>\n+    cref(const _Tp& __t)\n+    { return reference_wrapper<const _Tp>(__t); }\n+\n+  template<typename _Tp>\n+    reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t)\n+    { return ref(__t.get()); }\n+\n+  template<typename _Tp>\n+    reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t)\n+    { return cref(__t.get()); }\n+}\n+}\n+\n+#endif\n+"}, {"sha": "928c75f88cf8095c6984db66e82bd85cad3716b3", "filename": "libstdc++-v3/include/tr1/tuple", "status": "modified", "additions": 29, "deletions": 148, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -18,18 +18,19 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n-// Chris Jefferson <chris@bubblescope.net>\n-\n-// This header is automatically generated: see maketuple.c for details.\n-\n /** @file \n  *  This is a TR1 C++ Library header. \n  */\n \n+// Chris Jefferson <chris@bubblescope.net>\n+\n+// This header is automatically generated: see maketuple.c for details.\n+\n #ifndef _TUPLE\n #define _TUPLE 1\n \n-#include<utility>\n+#include <tr1/utility>\n+#include <tr1/functional>\n \n namespace std\n {\n@@ -1046,9 +1047,8 @@ namespace tr1\n       { return __in._M_t9; }\n     };\n \n-  /* Returns a reference to the ith element of a tuple.\n-   * Any const or non-const ref elements are returned with their original type\n-   */\n+  // Returns a reference to the ith element of a tuple.\n+  // Any const or non-const ref elements are returned with their original type.\n   template<int __i, typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n \t\t    typename _Tp4, typename _Tp5, typename _Tp6, typename _Tp7,\n \t\t    typename _Tp8, typename _Tp9>\n@@ -1063,9 +1063,8 @@ namespace tr1\n \t\t\t\t     _Tp7, _Tp8, _Tp9> >::get_value(__t);\n     }\n \n-  /* Returns a const reference to the ith element of a tuple.\n-   * Any const or non-const ref elements are returned with their original type\n-   */\n+  // Returns a const reference to the ith element of a tuple.\n+  // Any const or non-const ref elements are returned with their original type.\n   template<int __i, typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n \t\t    typename _Tp4, typename _Tp5, typename _Tp6, typename _Tp7,\n \t\t    typename _Tp8, typename _Tp9>\n@@ -1092,48 +1091,20 @@ namespace tr1\n         return get<__i>(__t) == get<__i>(__u) &&\n            __tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u);\n       }\n-      static bool __neq(const _Tp& __t, const _Up& __u)\n-      {\n-        return get<__i>(__t) != get<__i>(__u) ||\n-           __tuple_compare<0, __i+1, __j, _Tp, _Up>::__neq(__t, __u);\n-      }\n       static bool __less(const _Tp& __t, const _Up& __u)\n       {\n         return (get<__i>(__t) < get<__i>(__u)) || !(get<__i>(__u) < get<__i>(__t)) &&\n            __tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u);\n       }\n-      static bool __greater(const _Tp& __t, const _Up& __u)\n-      {\n-        return (get<__i>(__t) > get<__i>(__u)) || !(get<__i>(__u) > get<__i>(__t)) &&\n-           __tuple_compare<0, __i+1, __j, _Tp, _Up>::__greater(__t, __u);\n-      }\n-      static bool __leq(const _Tp& __t, const _Up& __u)\n-      {\n-        return (get<__i>(__t) <= get<__i>(__u)) && (!(get<__i>(__u)<=get<__i>(__t)) ||\n-        \t\t\t\t\t   __tuple_compare<0, __i+1, __j, _Tp, _Up>::__leq(__t, __u));\n-      }\n-      static bool __geq(const _Tp& __t, const _Up& __u)\n-      {\n-        return (get<__i>(__t) >= get<__i>(__u)) && (!(get<__i>(__u)>=get<__i>(__t)) ||\n-        \t\t\t\t\t   __tuple_compare<0, __i+1, __j, _Tp, _Up>::__geq(__t, __u));\n-      }\n     };\n \n   template<int __i, typename _Tp, typename _Up>\n     struct __tuple_compare<0, __i, __i, _Tp, _Up>\n     {\n       static bool __eq(const _Tp&, const _Up&)\n       { return true; }\n-      static bool __neq(const _Tp&, const _Up&)\n-      { return false; }\n-      static bool __leq(const _Tp&, const _Up&)\n-      { return true; }\n-      static bool __geq(const _Tp&, const _Up&)\n-      { return true; }\n       static bool __less(const _Tp&, const _Up&)\n       { return false; }\n-      static bool __greater(const _Tp&, const _Up&)\n-      { return false; }\n     };\n \n   template<typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n@@ -1146,12 +1117,12 @@ namespace tr1\n \t     const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n   {\n     typedef tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8,\n-\t\t  _Tp9> __t_tuple;\n+\t\t  _Tp9> _Tp;\n     typedef tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8,\n-\t\t  _Up9> __u_tuple;\n-    return __tuple_compare<tuple_size<__t_tuple>::value -\n-     tuple_size<__u_tuple>::value, 0,\n-      tuple_size<__t_tuple>::value, __t_tuple, __u_tuple>::__eq(__t, __u);\n+\t\t  _Up9> _Up;\n+    return __tuple_compare<tuple_size<_Tp>::value -\n+     tuple_size<_Tp>::value, 0,\n+      tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u);\n   }\n \n   template<typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n@@ -1160,16 +1131,16 @@ namespace tr1\n \t   typename _Up2, typename _Up3, typename _Up4, typename _Up5,\n \t   typename _Up6, typename _Up7, typename _Up8, typename _Up9>\n   bool\n-  operator!=(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n-\t     const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n+  operator<(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n+\t    const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n   {\n     typedef tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8,\n-\t\t  _Tp9> __t_tuple;\n+\t\t  _Tp9> _Tp;\n     typedef tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8,\n-\t\t  _Up9> __u_tuple;\n-    return __tuple_compare<tuple_size<__t_tuple>::value -\n-     tuple_size<__u_tuple>::value, 0,\n-      tuple_size<__t_tuple>::value, __t_tuple, __u_tuple>::__neq(__t, __u);\n+\t\t  _Up9> _Up;\n+    return __tuple_compare<tuple_size<_Tp>::value -\n+     tuple_size<_Tp>::value, 0,\n+      tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u);\n   }\n \n   template<typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n@@ -1178,18 +1149,11 @@ namespace tr1\n \t   typename _Up2, typename _Up3, typename _Up4, typename _Up5,\n \t   typename _Up6, typename _Up7, typename _Up8, typename _Up9>\n   bool\n-  operator<(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n-\t    const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n+  operator!=(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n+\t     const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n   {\n-    typedef tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8,\n-\t\t  _Tp9> __t_tuple;\n-    typedef tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8,\n-\t\t  _Up9> __u_tuple;\n-    return __tuple_compare<tuple_size<__t_tuple>::value -\n-     tuple_size<__u_tuple>::value, 0,\n-      tuple_size<__t_tuple>::value, __t_tuple, __u_tuple>::__less(__t, __u);\n+      return !(__t == __u);\n   }\n-\n   template<typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n \t   typename _Tp4, typename _Tp5, typename _Tp6, typename _Tp7,\n \t   typename _Tp8, typename _Tp9, typename _Up0, typename _Up1,\n@@ -1199,15 +1163,8 @@ namespace tr1\n   operator>(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n \t    const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n   {\n-    typedef tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8,\n-\t\t  _Tp9> __t_tuple;\n-    typedef tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8,\n-\t\t  _Up9> __u_tuple;\n-    return __tuple_compare<tuple_size<__t_tuple>::value -\n-     tuple_size<__u_tuple>::value, 0,\n-      tuple_size<__t_tuple>::value, __t_tuple, __u_tuple>::__greater(__t, __u);\n+      return __u < __t;\n   }\n-\n   template<typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n \t   typename _Tp4, typename _Tp5, typename _Tp6, typename _Tp7,\n \t   typename _Tp8, typename _Tp9, typename _Up0, typename _Up1,\n@@ -1217,15 +1174,8 @@ namespace tr1\n   operator<=(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n \t     const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n   {\n-    typedef tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8,\n-\t\t  _Tp9> __t_tuple;\n-    typedef tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8,\n-\t\t  _Up9> __u_tuple;\n-    return __tuple_compare<tuple_size<__t_tuple>::value -\n-     tuple_size<__u_tuple>::value, 0,\n-      tuple_size<__t_tuple>::value, __t_tuple, __u_tuple>::__leq(__t, __u);\n+      return !(__u < __t);\n   }\n-\n   template<typename _Tp0, typename _Tp1, typename _Tp2, typename _Tp3,\n \t   typename _Tp4, typename _Tp5, typename _Tp6, typename _Tp7,\n \t   typename _Tp8, typename _Tp9, typename _Up0, typename _Up1,\n@@ -1235,54 +1185,9 @@ namespace tr1\n   operator>=(const tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8, _Tp9>& __t,\n \t     const tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8, _Up9>& __u)\n   {\n-    typedef tuple<_Tp0, _Tp1, _Tp2, _Tp3, _Tp4, _Tp5, _Tp6, _Tp7, _Tp8,\n-\t\t  _Tp9> __t_tuple;\n-    typedef tuple<_Up0, _Up1, _Up2, _Up3, _Up4, _Up5, _Up6, _Up7, _Up8,\n-\t\t  _Up9> __u_tuple;\n-    return __tuple_compare<tuple_size<__t_tuple>::value -\n-     tuple_size<__u_tuple>::value, 0,\n-      tuple_size<__t_tuple>::value, __t_tuple, __u_tuple>::__geq(__t, __u);\n+      return !(__t < __u);\n   }\n \n-  // Provides a way to annotate that a reference to\n-  // an object should be passed.\n-  template<typename _Tp>\n-    class reference_wrapper\n-    {\n-      _Tp& _M_data;\n-      public:\n-        typedef _Tp type;\n-        explicit reference_wrapper(_Tp& __indata): _M_data(__indata)\n-        { }\n-\n-        operator _Tp& () const\n-        {\n-\t  return this->get();\n-        }\n-\n-        _Tp&\n-        get() const\n-        {\n-\t  return _M_data;\n-        }\n-    };\n-\n-  // Denotes a reference should be taken to a variable.\n-  template<typename _Tp>\n-    reference_wrapper<_Tp>\n-    ref(_Tp& __t)\n-    {\n-      return reference_wrapper<_Tp>(__t);\n-    }\n-\n-  // Denotes a const reference should be taken to a variable.\n-  template<typename _Tp>\n-    reference_wrapper<_Tp const>\n-    cref(const _Tp& __t)\n-    {\n-      return reference_wrapper<_Tp const>(__t);\n-    }\n-\n   // Helper which adds a reference to a type when given a reference_wrapper\n   template<typename _Tp>\n     struct __strip_reference_wrapper\n@@ -1430,7 +1335,6 @@ namespace tr1\n \n   // A class (and instance) which can be used in 'tie' when an element\n   // of a tuple is not required\n-\n   struct swallow_assign\n   {\n     template<class T>\n@@ -1439,7 +1343,7 @@ namespace tr1\n       { return *this; }\n   };\n \n-  // TODO: Put this in some kind of shared file\n+  // TODO: Put this in some kind of shared file.\n   namespace\n   {\n     swallow_assign ignore;\n@@ -1538,29 +1442,6 @@ namespace tr1\n \t\t        ref(__t9));\n     };\n \n-  // Various functions which give std::pair a tuple-like interface.\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_size<std::pair<_Tp1, _Tp2> >\n-    { static const int value = 2; };\n-\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n-    { typedef _Tp1 type; };\n-\n-  template<class _Tp1, class _Tp2>\n-    struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n-    { typedef _Tp2 type; };\n-\n-  template<int _Int, class _Tp1, class _Tp2>\n-    typename tuple_element<_Int, tuple<_Tp1, _Tp2> >::type\n-    get(pair<_Tp1, _Tp2>& __in)\n-    { return get<_Int>(tie(__in.first, __in.second)); }\n-\n-  template<int _Int, class _Tp1, class _Tp2>\n-    typename tuple_element<_Int, tuple<_Tp1, _Tp2> >::type\n-    get(const pair<_Tp1, _Tp2>& __in)\n-    { return get<_Int>(tie(__in.first, __in.second)); }\n-\n }\n }\n "}, {"sha": "92484ea8cc5a112fb3c88144b587bbbc6b713337", "filename": "libstdc++-v3/include/tr1/utility", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Futility?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -0,0 +1,89 @@\n+// TR1 utility -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+#ifndef _TR1_UTILITY\n+#define _TR1_UTILITY 1\n+\n+#include \"../utility\"\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  template<class _Tp> class tuple_size;\n+  template<int _Int, class _Tp> class tuple_element;\n+\n+   // Various functions which give std::pair a tuple-like interface.\n+  template<class _Tp1, class _Tp2>\n+    struct tuple_size<std::pair<_Tp1, _Tp2> >\n+    { static const int value = 2; };\n+ \n+  template<class _Tp1, class _Tp2>\n+    struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n+    { typedef _Tp1 type; };\n+ \n+  template<class _Tp1, class _Tp2>\n+    struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n+    { typedef _Tp2 type; };\n+ \n+\n+  template<int _Int> struct __pair_get;\n+\n+  template<>\n+    struct __pair_get<0>\n+    {\n+      template<typename _Tp1, typename _Tp2>\n+      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.first; }\n+\n+      template<typename _Tp1, typename _Tp2>\n+      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.first; }\n+    };\n+\n+  template<>\n+    struct __pair_get<1>\n+    {\n+      template<typename _Tp1, typename _Tp2>\n+      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.second; }\n+\n+      template<typename _Tp1, typename _Tp2>\n+      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)\n+      { return __pair.second; }\n+    };\n+\n+   template<int _I, class _Tp1, class _Tp2>\n+     typename tuple_element<_I, std::pair<_Tp1, _Tp2> >::type&\n+     get(pair<_Tp1, _Tp2>& __in)\n+     { return __pair_get<_I>::__get(__in); }\n+ \n+   template<int _I, class _Tp1, class _Tp2>\n+     const typename tuple_element<_I, std::pair<_Tp1, _Tp2> >::type&\n+     get(const pair<_Tp1, _Tp2>& __in)\n+     { return __pair_get<_I>::__const_get(__in); }\n+}\n+} \n+\n+#endif"}, {"sha": "e5683b4665f862206a9880f68bc123260888f31b", "filename": "libstdc++-v3/testsuite/tr1/6_containers/utility/pair.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Futility%2Fpair.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ede5d6213c42e75ce7dfeaa98950adfa6de73b/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Futility%2Fpair.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Futility%2Fpair.cc?ref=f2ede5d6213c42e75ce7dfeaa98950adfa6de73b", "patch": "@@ -0,0 +1,54 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// tr1 additions to pair\n+\n+#include <tr1/utility>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+struct blank_class\n+{ };\n+\n+int\n+main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef pair<int,int> test_pair_type;\n+  VERIFY(tuple_size<test_pair_type>::value == 2);\n+  // Test if tuple_element::type returns the correct type\n+  blank_class blank;\n+  tuple_element<0, pair<blank_class, int> >::type blank2 = blank;\n+  tuple_element<1, pair<int ,blank_class> >::type blank3 = blank;\n+  pair<int,int> test_pair(1, 2);\n+  VERIFY(get<0>(test_pair) == 1);\n+  VERIFY(get<1>(test_pair) == 2);\n+  get<0>(test_pair) = 3;\n+  get<1>(test_pair) = 4;\n+  VERIFY(get<0>(test_pair) == 3);\n+  VERIFY(get<1>(test_pair) == 4);\n+\n+  const pair<int,int> test_pair2(1,2);\n+  VERIFY(get<0>(test_pair2) == 1);\n+  VERIFY(get<1>(test_pair2) == 2);\n+}\n+"}]}