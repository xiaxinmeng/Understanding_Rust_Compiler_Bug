{"sha": "3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxMGM5YjIwMmIzMTk3YmQ5MmNlN2I4ZGJhYmNiODZkNDY0MWVlNg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-12T15:06:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-12T15:06:52Z"}, "message": "Merge #613\n\n613: Resolve module filename r=philberty a=CohenArthur\n\nThis PR is a first attempt at resolving the filename corresponding to an external module correctly. Some of the cases are not handled yet and a lot of FIXMEs are still here, as I am looking for feedback on certain things:\r\n\r\n* Am I correct in assuming that we have to go through directories the C way because we are using C++11 and the `filesystem` header is not available until C++17? Is there some gcc abstraction for this that I'm overlooking?\r\n* How important is the existence of a separate SEPARATOR macro for Windows? From what I'm understanding, the OS also understands normal slashes `/` on top of the backward slashes it usually uses `\\`. I don't know what happens when they are mixed and matched or how the file system handles it.\r\n* For review simplicity, outer attributes could be accessed in a later PR. I believe they can already be accessed and looked at but haven't looked into it. I'm also unsure if this would be the right place to implement that outer_attr lookup\n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>", "tree": {"sha": "a8be78ea928d605ce6ea8f29a896fcbb48f42af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8be78ea928d605ce6ea8f29a896fcbb48f42af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhFTkMCRBK7hj4Ov3rIwAA8dwIAKmlZ3jn/1dOo5IqhNT9aP0y\nWolxxpBpnRRRalDjCAPtNASQlOvn2j5auzf/40W1Fxx2H4ZwfUL09GOLkJMjc+3A\n1ivOLiWfk66IP4bUAZQLzBBezaeBmYO5YW7Z1HAmNVi/rWWEjYo+8xVR/uiR+n1h\nuMTN0YcFUYkZ7PvAf1pFF837RsINRs6nQIYP1LlyoAyEAGO+mZzBGpJTfv0PAGmO\n7AC3mrJmrMPIXZvsRtqT/zvnFBEDuZJUSE7CNhjUUfxgC5wSadJWqFJ7VhXbXmuw\nuNN1C4Hc1dEX/ExH5is7Z+xcdS01Gl1mIQVyUoI5rtTdVpnqMrWfbx8+t4zQedg=\n=ZMmc\n-----END PGP SIGNATURE-----\n", "payload": "tree a8be78ea928d605ce6ea8f29a896fcbb48f42af4\nparent 7be0232c686a75f98b2ca3c27f7de3139b8999c6\nparent b4993a629348279023b2c0159169ed62f10ac453\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628780812 +0000\ncommitter GitHub <noreply@github.com> 1628780812 +0000\n\nMerge #613\n\n613: Resolve module filename r=philberty a=CohenArthur\n\nThis PR is a first attempt at resolving the filename corresponding to an external module correctly. Some of the cases are not handled yet and a lot of FIXMEs are still here, as I am looking for feedback on certain things:\r\n\r\n* Am I correct in assuming that we have to go through directories the C way because we are using C++11 and the `filesystem` header is not available until C++17? Is there some gcc abstraction for this that I'm overlooking?\r\n* How important is the existence of a separate SEPARATOR macro for Windows? From what I'm understanding, the OS also understands normal slashes `/` on top of the backward slashes it usually uses `\\`. I don't know what happens when they are mixed and matched or how the file system handles it.\r\n* For review simplicity, outer attributes could be accessed in a later PR. I believe they can already be accessed and looked at but haven't looked into it. I'm also unsure if this would be the right place to implement that outer_attr lookup\n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7be0232c686a75f98b2ca3c27f7de3139b8999c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7be0232c686a75f98b2ca3c27f7de3139b8999c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7be0232c686a75f98b2ca3c27f7de3139b8999c6"}, {"sha": "b4993a629348279023b2c0159169ed62f10ac453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4993a629348279023b2c0159169ed62f10ac453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4993a629348279023b2c0159169ed62f10ac453"}], "stats": {"total": 105, "additions": 99, "deletions": 6}, "files": [{"sha": "6033ce95acd8f0351e726aa6c782f04c8ee109ec", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "patch": "@@ -17,6 +17,9 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+// FIXME: This does not work on Windows\n+#include <unistd.h>\n+\n #include \"rust-ast-full.h\"\n #include \"rust-diagnostics.h\"\n #include \"rust-ast-visitor.h\"\n@@ -4050,6 +4053,73 @@ Module::add_crate_name (std::vector<std::string> &names) const\n     item->add_crate_name (names);\n }\n \n+static bool\n+file_exists (const std::string path)\n+{\n+  // Simply check if the file exists\n+  // FIXME: This does not work on Windows\n+  return access (path.c_str (), F_OK) != -1;\n+}\n+\n+// FIXME: This function should also check if the module has a `path` outer\n+// attribute and fetch the path from here in that case, i.e:\n+// ```\n+// #[path=\"<dir>/<subdir>/<file>.rs\"]\n+// mod <mod_name>;\n+// ```\n+std::string\n+Module::get_filename ()\n+{\n+  rust_assert (kind == Module::ModuleKind::UNLOADED);\n+\n+  // This corresponds to the path of the file 'including' the module. So the\n+  // file that contains the 'mod <file>;' directive\n+  std::string including_fname (outer_filename);\n+\n+  std::string expected_file_path = module_name + \".rs\";\n+  std::string expected_dir_path = \"mod.rs\";\n+\n+  auto dir_slash_pos = including_fname.rfind (file_separator);\n+  std::string current_directory_name;\n+\n+  // If we haven't found a file_separator, then we have to look for files in the\n+  // current directory ('.')\n+  if (dir_slash_pos == std::string::npos)\n+    current_directory_name = std::string (\".\") + file_separator;\n+  else\n+    current_directory_name\n+      = including_fname.substr (0, dir_slash_pos) + file_separator;\n+\n+  // FIXME: We also have to search for\n+  // <directory>/<including_fname>/<module_name>.rs In rustc, this is done via\n+  // the concept of `DirOwnernship`, which is based on whether or not the\n+  // current file is titled `mod.rs`.\n+\n+  // First, we search for <directory>/<module_name>.rs\n+  bool file_mod_found\n+    = file_exists (current_directory_name + expected_file_path);\n+\n+  // Then, search for <directory>/<module_name>/mod.rs\n+  current_directory_name += module_name + file_separator;\n+  bool dir_mod_found = file_exists (current_directory_name + expected_dir_path);\n+\n+  bool multiple_candidates_found = file_mod_found && dir_mod_found;\n+  bool no_candidates_found = !file_mod_found && !dir_mod_found;\n+\n+  if (multiple_candidates_found)\n+    rust_error_at (locus,\n+\t\t   \"two candidates found for module %s: %s.rs and %s%smod.rs\",\n+\t\t   module_name.c_str (), module_name.c_str (),\n+\t\t   module_name.c_str (), file_separator);\n+\n+  if (no_candidates_found)\n+    rust_error_at (locus, \"no candidate found for module %s\",\n+\t\t   module_name.c_str ());\n+\n+  return file_mod_found ? expected_file_path\n+\t\t\t: current_directory_name + expected_dir_path;\n+}\n+\n void\n Attribute::parse_attr_to_meta_item ()\n {"}, {"sha": "dac76f5ce7a919ecbbd951e198a64ab26cb21c80", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "patch": "@@ -977,6 +977,8 @@ class Module : public VisItem\n   Location locus;\n   ModuleKind kind;\n \n+  // Name of the file including the module\n+  std::string outer_filename;\n   // bool has_inner_attrs;\n   std::vector<Attribute> inner_attrs;\n   // bool has_items;\n@@ -998,10 +1000,11 @@ class Module : public VisItem\n \n   // Unloaded module constructor\n   Module (Identifier module_name, Visibility visibility,\n-\t  std::vector<Attribute> outer_attrs, Location locus)\n+\t  std::vector<Attribute> outer_attrs, Location locus,\n+\t  std::string outer_filename)\n     : VisItem (std::move (visibility), std::move (outer_attrs)),\n       module_name (module_name), locus (locus), kind (ModuleKind::UNLOADED),\n-      inner_attrs (std::vector<Attribute> ()),\n+      outer_filename (outer_filename), inner_attrs (std::vector<Attribute> ()),\n       items (std::vector<std::unique_ptr<Item>> ())\n   {}\n \n@@ -1013,7 +1016,8 @@ class Module : public VisItem\n \t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : VisItem (std::move (visibility), std::move (outer_attrs)),\n       module_name (name), locus (locus), kind (ModuleKind::LOADED),\n-      inner_attrs (std::move (inner_attrs)), items (std::move (items))\n+      outer_filename (std::string ()), inner_attrs (std::move (inner_attrs)),\n+      items (std::move (items))\n   {}\n \n   // Copy constructor with vector clone\n@@ -1049,6 +1053,9 @@ class Module : public VisItem\n     return *this;\n   }\n \n+  // Search for the filename associated with an external module\n+  std::string get_filename ();\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   /* Override that runs the function recursively on all items contained within"}, {"sha": "4998dc8441fabcd4dcfe13ed8c40d4ec37dcc7b1", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "patch": "@@ -2036,6 +2036,10 @@ class AttrVisitor : public AST::ASTVisitor\n \t    return;\n \t  }\n       }\n+    else\n+      {\n+\tstd::string mod_file = module.get_filename ();\n+      }\n \n     // strip items if required\n     expand_pointer_allow_strip (module.get_items ());"}, {"sha": "1b37a9c4705d4b788477a5a41b4f1bc4daac11d6", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "patch": "@@ -14,6 +14,7 @@ struct RAIIFile\n {\n private:\n   FILE *file;\n+  const char *filename;\n \n   void close ()\n   {\n@@ -22,7 +23,7 @@ struct RAIIFile\n   }\n \n public:\n-  RAIIFile (const char *filename)\n+  RAIIFile (const char *filename) : filename (filename)\n   {\n     if (strcmp (filename, \"-\") == 0)\n       file = stdin;\n@@ -47,6 +48,7 @@ struct RAIIFile\n   ~RAIIFile () { close (); }\n \n   FILE *get_raw () { return file; }\n+  const char *get_filename () { return filename; }\n };\n \n class Lexer\n@@ -136,6 +138,7 @@ class Lexer\n   void split_current_token (TokenId new_left, TokenId new_right);\n \n   Linemap *get_line_map () { return line_map; }\n+  std::string get_filename () { return std::string (input.get_filename ()); }\n \n private:\n   // File for use as input."}, {"sha": "731e0b3682f112eeaa19a65d892c7d75181dbac8", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "patch": "@@ -2101,10 +2101,11 @@ Parser<ManagedTokenSource>::parse_module (AST::Visibility vis,\n     case SEMICOLON:\n       lexer.skip_token ();\n \n+      // Construct an external module\n       return std::unique_ptr<AST::Module> (\n \tnew AST::Module (std::move (name), std::move (vis),\n-\t\t\t std::move (outer_attrs),\n-\t\t\t locus)); // module name?\n+\t\t\t std::move (outer_attrs), locus,\n+\t\t\t lexer.get_filename ()));\n       case LEFT_CURLY: {\n \tlexer.skip_token ();\n "}, {"sha": "40bca63e67bbe6c2f9e6721a88cdff22289bb058", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3610c9b202b3197bd92ce7b8dbabcb86d4641ee6/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=3610c9b202b3197bd92ce7b8dbabcb86d4641ee6", "patch": "@@ -59,6 +59,14 @@\n #include \"diagnostic-core.h\" /* For error_at and friends.  */\n #include \"intl.h\"\t     /* For _().  */\n \n+// File separator to use based on whether or not the OS we're working with is\n+// DOS-based\n+#if defined(HAVE_DOS_BASED_FILE_SYSTEM)\n+constexpr static const char *file_separator = \"\\\\\";\n+#else\n+constexpr static const char *file_separator = \"/\";\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n // When using gcc, rust_assert is just gcc_assert.\n #define rust_assert(EXPR) gcc_assert (EXPR)\n "}]}