{"sha": "f7d504c227fb7e621b6521fe282956f021cd2337", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdkNTA0YzIyN2ZiN2U2MjFiNjUyMWZlMjgyOTU2ZjAyMWNkMjMzNw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-07-25T18:33:26Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-07-25T18:33:26Z"}, "message": "cfglayout.c (insn_scope, insn_line): Constify.\n\n\t* cfglayout.c (insn_scope, insn_line): Constify.\n\t* emit-rtl.c (const_int_htab_hash, const_int_htab_eq,\n\tconst_double_htab_hash, const_double_htab_eq,\n\tmem_attrs_htab_hash): Likewise.\n\t* loop-iv.c (biv_eq): Likewise.\n\t* print-rtl.c (print_rtx, print_decl_name, print_mem_expr,\n\tprint_inline_rtx, debug_rtx, debug_rtx_list, debug_rtx_range,\n\tdebug_rtx_find, print_rtl, print_rtl_single, print_simple_rtl):\n\tLikewise. \n\t* rtl-error.c (location_for_asm, diagnostic_for_asm,\n\terror_for_asm, warning_for_asm, _fatal_insn,\n\t_fatal_insn_not_found): Likewise. \n\t* rtl.c (rtx_size, shared_const_p, shallow_copy_rtx_stat,\n\trtx_equal_p, rtl_check_failed_bounds, rtl_check_failed_type1,\n\trtl_check_failed_type2, rtl_check_failed_code1,\n\trtl_check_failed_code2, rtl_check_failed_code_mode,\n\trtvec_check_failed_bounds, rtl_check_failed_flag): Likewise.\n\t* rtl.h (rtl_check_failed_bounds, rtl_check_failed_type1,\n\trtl_check_failed_type2, rtl_check_failed_code1,\n\trtl_check_failed_code2, rtl_check_failed_code_mode,\n\trtvec_check_failed_bounds, rtl_check_failed_flag, LABEL_KIND,\n\tSET_LABEL_KIND, rhs_regno, subreg_lsb, subreg_regno, subreg_nregs,\n\tshared_const_p, rtx_size, shallow_copy_rtx_stat, rtx_equal_p,\n\tget_pool_mode, insn_line, insn_file, simplify_replace_rtx,\n\tmode_signbit_p, rtx_addr_can_trap_p, nonzero_address_p,\n\trtx_unstable_p, get_integer_term, get_related_value,\n\toffset_within_block_p, reg_mentioned_p, count_occurrences,\n\treg_referenced_p, reg_used_between_p, no_labels_between_p,\n\tsingle_set_2, multiple_sets, set_noop_p, refers_to_regno_p,\n\treg_overlap_mentioned_p, dead_or_set_p, dead_or_set_regno_p,\n\tfind_reg_note, find_regno_note, find_reg_equal_equiv_note,\n\tfind_constant_src, find_reg_fusage, find_regno_fusage,\n\tpure_call_p, remove_note, side_effects_p, volatile_refs_p,\n\tvolatile_insn_p, may_trap_p, may_trap_after_code_motion_p,\n\tmay_trap_or_fault_p, inequality_comparisons_p, tablejump_p,\n\tcomputed_jump_p, auto_inc_p, in_expr_list_p,\n\tremove_node_from_expr_list, loc_mentioned_in_p,\n\tlabel_is_jump_target_p, reversed_comparison_code_parts,\n\tdebug_rtx, debug_rtx_list, debug_rtx_range, debug_rtx_find,\n\tprint_mem_expr, print_rtl, print_simple_rtl, print_rtl_single,\n\tprint_inline_rtx): Likewise.\n\t* rtlanal.c (covers_regno_p, covers_regno_no_parallel_p,\n\tcomputed_jump_p_1, nonzero_bits1, rtx_unstable_p,\n\trtx_addr_can_trap_p_1, rtx_addr_can_trap_p, nonzero_address_p,\n\tget_integer_term, get_related_value, offset_within_block_p,\n\tcount_occurrences, reg_mentioned_p, no_labels_between_p,\n\treg_used_between_p, reg_referenced_p, single_set_2,\n\tmultiple_sets, set_noop_p, refers_to_regno_p,\n\treg_overlap_mentioned_p, dead_or_set_p,\n\tcovers_regno_no_parallel_p, covers_regno_p,\n\tdead_or_set_regno_p, find_reg_note, find_regno_note,\n\tfind_reg_equal_equiv_note, find_constant_src, find_reg_fusage,\n\tfind_regno_fusage, pure_call_p, remove_note, in_expr_list_p,\n\tremove_node_from_expr_list, volatile_insn_p, volatile_refs_p,\n\tside_effects_p, may_trap_p_1, may_trap_p,\n\tmay_trap_after_code_motion_p, may_trap_or_fault_p,\n\tinequality_comparisons_p, tablejump_p, computed_jump_p_1,\n\tcomputed_jump_p, auto_inc_p, loc_mentioned_in_p, subreg_lsb,\n\tsubreg_regno, subreg_nregs, label_is_jump_target_p): Likewise.\n\t* simplify-rtx.c (neg_const_int, plus_minus_operand_p,\n\tmode_signbit_p, simplify_replace_rtx, plus_minus_operand_p):\n\tLikewise. \n\t* toplev.h (_fatal_insn_not_found, _fatal_insn, error_for_asm,\n\twarning_for_asm): Likewise.\n\t* tree.h (print_rtl): Likewise.\n\t* varasm.c (get_pool_mode): Likewise.\n\nFrom-SVN: r126922", "tree": {"sha": "2498ca4a42d5077cfa66327ea66af1bd5fba93c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2498ca4a42d5077cfa66327ea66af1bd5fba93c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7d504c227fb7e621b6521fe282956f021cd2337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d504c227fb7e621b6521fe282956f021cd2337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d504c227fb7e621b6521fe282956f021cd2337", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d504c227fb7e621b6521fe282956f021cd2337/comments", "author": null, "committer": null, "parents": [{"sha": "5f754896d3ba9d28ba6bf94923e5e1564cbf4e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f754896d3ba9d28ba6bf94923e5e1564cbf4e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f754896d3ba9d28ba6bf94923e5e1564cbf4e36"}], "stats": {"total": 479, "additions": 269, "deletions": 210}, "files": [{"sha": "61a3bec73235ac408dbbe47a11c5cf76a2b36901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -1,3 +1,72 @@\n+2007-07-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cfglayout.c (insn_scope, insn_line): Constify.\n+\t* emit-rtl.c (const_int_htab_hash, const_int_htab_eq,\n+\tconst_double_htab_hash, const_double_htab_eq,\n+\tmem_attrs_htab_hash): Likewise.\n+\t* loop-iv.c (biv_eq): Likewise.\n+\t* print-rtl.c (print_rtx, print_decl_name, print_mem_expr,\n+\tprint_inline_rtx, debug_rtx, debug_rtx_list, debug_rtx_range,\n+\tdebug_rtx_find, print_rtl, print_rtl_single, print_simple_rtl):\n+\tLikewise. \n+\t* rtl-error.c (location_for_asm, diagnostic_for_asm,\n+\terror_for_asm, warning_for_asm, _fatal_insn,\n+\t_fatal_insn_not_found): Likewise. \n+\t* rtl.c (rtx_size, shared_const_p, shallow_copy_rtx_stat,\n+\trtx_equal_p, rtl_check_failed_bounds, rtl_check_failed_type1,\n+\trtl_check_failed_type2, rtl_check_failed_code1,\n+\trtl_check_failed_code2, rtl_check_failed_code_mode,\n+\trtvec_check_failed_bounds, rtl_check_failed_flag): Likewise.\n+\t* rtl.h (rtl_check_failed_bounds, rtl_check_failed_type1,\n+\trtl_check_failed_type2, rtl_check_failed_code1,\n+\trtl_check_failed_code2, rtl_check_failed_code_mode,\n+\trtvec_check_failed_bounds, rtl_check_failed_flag, LABEL_KIND,\n+\tSET_LABEL_KIND, rhs_regno, subreg_lsb, subreg_regno, subreg_nregs,\n+\tshared_const_p, rtx_size, shallow_copy_rtx_stat, rtx_equal_p,\n+\tget_pool_mode, insn_line, insn_file, simplify_replace_rtx,\n+\tmode_signbit_p, rtx_addr_can_trap_p, nonzero_address_p,\n+\trtx_unstable_p, get_integer_term, get_related_value,\n+\toffset_within_block_p, reg_mentioned_p, count_occurrences,\n+\treg_referenced_p, reg_used_between_p, no_labels_between_p,\n+\tsingle_set_2, multiple_sets, set_noop_p, refers_to_regno_p,\n+\treg_overlap_mentioned_p, dead_or_set_p, dead_or_set_regno_p,\n+\tfind_reg_note, find_regno_note, find_reg_equal_equiv_note,\n+\tfind_constant_src, find_reg_fusage, find_regno_fusage,\n+\tpure_call_p, remove_note, side_effects_p, volatile_refs_p,\n+\tvolatile_insn_p, may_trap_p, may_trap_after_code_motion_p,\n+\tmay_trap_or_fault_p, inequality_comparisons_p, tablejump_p,\n+\tcomputed_jump_p, auto_inc_p, in_expr_list_p,\n+\tremove_node_from_expr_list, loc_mentioned_in_p,\n+\tlabel_is_jump_target_p, reversed_comparison_code_parts,\n+\tdebug_rtx, debug_rtx_list, debug_rtx_range, debug_rtx_find,\n+\tprint_mem_expr, print_rtl, print_simple_rtl, print_rtl_single,\n+\tprint_inline_rtx): Likewise.\n+\t* rtlanal.c (covers_regno_p, covers_regno_no_parallel_p,\n+\tcomputed_jump_p_1, nonzero_bits1, rtx_unstable_p,\n+\trtx_addr_can_trap_p_1, rtx_addr_can_trap_p, nonzero_address_p,\n+\tget_integer_term, get_related_value, offset_within_block_p,\n+\tcount_occurrences, reg_mentioned_p, no_labels_between_p,\n+\treg_used_between_p, reg_referenced_p, single_set_2,\n+\tmultiple_sets, set_noop_p, refers_to_regno_p,\n+\treg_overlap_mentioned_p, dead_or_set_p,\n+\tcovers_regno_no_parallel_p, covers_regno_p,\n+\tdead_or_set_regno_p, find_reg_note, find_regno_note,\n+\tfind_reg_equal_equiv_note, find_constant_src, find_reg_fusage,\n+\tfind_regno_fusage, pure_call_p, remove_note, in_expr_list_p,\n+\tremove_node_from_expr_list, volatile_insn_p, volatile_refs_p,\n+\tside_effects_p, may_trap_p_1, may_trap_p,\n+\tmay_trap_after_code_motion_p, may_trap_or_fault_p,\n+\tinequality_comparisons_p, tablejump_p, computed_jump_p_1,\n+\tcomputed_jump_p, auto_inc_p, loc_mentioned_in_p, subreg_lsb,\n+\tsubreg_regno, subreg_nregs, label_is_jump_target_p): Likewise.\n+\t* simplify-rtx.c (neg_const_int, plus_minus_operand_p,\n+\tmode_signbit_p, simplify_replace_rtx, plus_minus_operand_p):\n+\tLikewise. \n+\t* toplev.h (_fatal_insn_not_found, _fatal_insn, error_for_asm,\n+\twarning_for_asm): Likewise.\n+\t* tree.h (print_rtl): Likewise.\n+\t* varasm.c (get_pool_mode): Likewise.\n+\n 2007-07-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-lex.c (c_lex_with_flags, lex_string): Constify."}, {"sha": "c350883ce97e904b7c8453ca69e54730f5e93eda", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -54,7 +54,7 @@ static void change_scope (rtx, tree, tree);\n \n void verify_insn_chain (void);\n static void fixup_fallthru_exit_predecessor (void);\n-static tree insn_scope (rtx);\n+static tree insn_scope (const_rtx);\n \f\n rtx\n unlink_insn_chain (rtx first, rtx last)\n@@ -451,7 +451,7 @@ change_scope (rtx orig_insn, tree s1, tree s2)\n \n /* Return lexical scope block insn belong to.  */\n static tree\n-insn_scope (rtx insn)\n+insn_scope (const_rtx insn)\n {\n   int max = VEC_length (int, block_locators_locs);\n   int min = 0;\n@@ -528,7 +528,7 @@ locator_line (int loc)\n \n /* Return line number of the statement that produced this insn.  */\n int\n-insn_line (rtx insn)\n+insn_line (const_rtx insn)\n {\n   return locator_line (INSN_LOCATOR (insn));\n }\n@@ -547,7 +547,7 @@ locator_file (int loc)\n \n /* Return source file of the statement that produced this insn.  */\n const char *\n-insn_file (rtx insn)\n+insn_file (const_rtx insn)\n {\n   return locator_file (INSN_LOCATOR (insn));\n }"}, {"sha": "06ddf52c54068c35572d077807f220d393ff7f4b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -195,7 +195,7 @@ int split_branch_probability = -1;\n static hashval_t\n const_int_htab_hash (const void *x)\n {\n-  return (hashval_t) INTVAL ((rtx) x);\n+  return (hashval_t) INTVAL ((const_rtx) x);\n }\n \n /* Returns nonzero if the value represented by X (which is really a\n@@ -205,14 +205,14 @@ const_int_htab_hash (const void *x)\n static int\n const_int_htab_eq (const void *x, const void *y)\n {\n-  return (INTVAL ((rtx) x) == *((const HOST_WIDE_INT *) y));\n+  return (INTVAL ((const_rtx) x) == *((const HOST_WIDE_INT *) y));\n }\n \n /* Returns a hash code for X (which is really a CONST_DOUBLE).  */\n static hashval_t\n const_double_htab_hash (const void *x)\n {\n-  rtx value = (rtx) x;\n+  const_rtx const value = (const_rtx) x;\n   hashval_t h;\n \n   if (GET_MODE (value) == VOIDmode)\n@@ -231,7 +231,7 @@ const_double_htab_hash (const void *x)\n static int\n const_double_htab_eq (const void *x, const void *y)\n {\n-  rtx a = (rtx)x, b = (rtx)y;\n+  const_rtx const a = (const_rtx)x, b = (const_rtx)y;\n \n   if (GET_MODE (a) != GET_MODE (b))\n     return 0;\n@@ -248,7 +248,7 @@ const_double_htab_eq (const void *x, const void *y)\n static hashval_t\n mem_attrs_htab_hash (const void *x)\n {\n-  mem_attrs *p = (mem_attrs *) x;\n+  const mem_attrs *const p = (const mem_attrs *) x;\n \n   return (p->alias ^ (p->align * 1000)\n \t  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)"}, {"sha": "19da19927b1b4e57e6f70ac67fed0af751cec9f6", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -244,7 +244,7 @@ biv_hash (const void *b)\n static int\n biv_eq (const void *b, const void *r)\n {\n-  return ((const struct biv_entry *) b)->regno == REGNO ((rtx) r);\n+  return ((const struct biv_entry *) b)->regno == REGNO ((const_rtx) r);\n }\n \n /* Prepare the data for an induction variable analysis of a LOOP.  */"}, {"sha": "59422c8557fd15a1d0fe75593d60cd052e3e3d9d", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -49,7 +49,7 @@ static int sawclose = 0;\n \n static int indent;\n \n-static void print_rtx (rtx);\n+static void print_rtx (const_rtx);\n \n /* String printed at beginning of each RTL when it is dumped.\n    This string is set to ASM_COMMENT_START when the RTL is dumped in\n@@ -69,7 +69,7 @@ int dump_for_graph;\n \n #ifndef GENERATOR_FILE\n static void\n-print_decl_name (FILE *outfile, tree node)\n+print_decl_name (FILE *outfile, const_tree node)\n {\n   if (DECL_NAME (node))\n     fputs (IDENTIFIER_POINTER (DECL_NAME (node)), outfile);\n@@ -86,7 +86,7 @@ print_decl_name (FILE *outfile, tree node)\n }\n \n void\n-print_mem_expr (FILE *outfile, tree expr)\n+print_mem_expr (FILE *outfile, const_tree expr)\n {\n   if (TREE_CODE (expr) == COMPONENT_REF)\n     {\n@@ -128,7 +128,7 @@ print_mem_expr (FILE *outfile, tree expr)\n /* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */\n \n static void\n-print_rtx (rtx in_rtx)\n+print_rtx (const_rtx in_rtx)\n {\n   int i = 0;\n   int j;\n@@ -603,7 +603,7 @@ print_rtx (rtx in_rtx)\n    characters.  */\n \n void\n-print_inline_rtx (FILE *outf, rtx x, int ind)\n+print_inline_rtx (FILE *outf, const_rtx x, int ind)\n {\n   int oldsaw = sawclose;\n   int oldindent = indent;\n@@ -619,7 +619,7 @@ print_inline_rtx (FILE *outf, rtx x, int ind)\n /* Call this function from the debugger to see what X looks like.  */\n \n void\n-debug_rtx (rtx x)\n+debug_rtx (const_rtx x)\n {\n   outfile = stderr;\n   sawclose = 0;\n@@ -639,10 +639,10 @@ int debug_rtx_count = 0;\t/* 0 is treated as equivalent to 1 */\n    EG: -5 prints 2 rtx's on either side (in addition to the specified rtx).  */\n \n void\n-debug_rtx_list (rtx x, int n)\n+debug_rtx_list (const_rtx x, int n)\n {\n   int i,count;\n-  rtx insn;\n+  const_rtx insn;\n \n   count = n == 0 ? 1 : n < 0 ? -n : n;\n \n@@ -666,7 +666,7 @@ debug_rtx_list (rtx x, int n)\n /* Call this function to print an rtx list from START to END inclusive.  */\n \n void\n-debug_rtx_range (rtx start, rtx end)\n+debug_rtx_range (const_rtx start, const_rtx end)\n {\n   while (1)\n     {\n@@ -682,8 +682,8 @@ debug_rtx_range (rtx start, rtx end)\n    and then call debug_rtx_list to print it, using DEBUG_RTX_COUNT.\n    The found insn is returned to enable further debugging analysis.  */\n \n-rtx\n-debug_rtx_find (rtx x, int uid)\n+const_rtx\n+debug_rtx_find (const_rtx x, int uid)\n {\n   while (x != 0 && INSN_UID (x) != uid)\n     x = NEXT_INSN (x);\n@@ -706,9 +706,9 @@ debug_rtx_find (rtx x, int uid)\n    If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */\n \n void\n-print_rtl (FILE *outf, rtx rtx_first)\n+print_rtl (FILE *outf, const_rtx rtx_first)\n {\n-  rtx tmp_rtx;\n+  const_rtx tmp_rtx;\n \n   outfile = outf;\n   sawclose = 0;\n@@ -745,7 +745,7 @@ print_rtl (FILE *outf, rtx rtx_first)\n /* Return nonzero if we actually printed anything.  */\n \n int\n-print_rtl_single (FILE *outf, rtx x)\n+print_rtl_single (FILE *outf, const_rtx x)\n {\n   outfile = outf;\n   sawclose = 0;\n@@ -764,7 +764,7 @@ print_rtl_single (FILE *outf, rtx x)\n    if RTX is a CONST_INT then print in decimal format.  */\n \n void\n-print_simple_rtl (FILE *outf, rtx x)\n+print_simple_rtl (FILE *outf, const_rtx x)\n {\n   flag_simple = 1;\n   print_rtl (outf, x);"}, {"sha": "0396fb30795b2a1e9057175130ffdff23ffbdbd6", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -33,12 +33,12 @@ Boston, MA 02110-1301, USA.  */\n #include \"intl.h\"\n #include \"diagnostic.h\"\n \n-static location_t location_for_asm (rtx);\n-static void diagnostic_for_asm (rtx, const char *, va_list *, diagnostic_t) ATTRIBUTE_GCC_DIAG(2,0);\n+static location_t location_for_asm (const_rtx);\n+static void diagnostic_for_asm (const_rtx, const char *, va_list *, diagnostic_t) ATTRIBUTE_GCC_DIAG(2,0);\n \n /* Figure the location of the given INSN.  */\n static location_t\n-location_for_asm (rtx insn)\n+location_for_asm (const_rtx insn)\n {\n   rtx body = PATTERN (insn);\n   rtx asmop;\n@@ -76,7 +76,7 @@ location_for_asm (rtx insn)\n    of the insn INSN.  This is used only when INSN is an `asm' with operands,\n    and each ASM_OPERANDS records its own source file and line.  */\n static void\n-diagnostic_for_asm (rtx insn, const char *msg, va_list *args_ptr,\n+diagnostic_for_asm (const_rtx insn, const char *msg, va_list *args_ptr,\n \t\t    diagnostic_t kind)\n {\n   diagnostic_info diagnostic;\n@@ -87,7 +87,7 @@ diagnostic_for_asm (rtx insn, const char *msg, va_list *args_ptr,\n }\n \n void\n-error_for_asm (rtx insn, const char *gmsgid, ...)\n+error_for_asm (const_rtx insn, const char *gmsgid, ...)\n {\n   va_list ap;\n \n@@ -97,7 +97,7 @@ error_for_asm (rtx insn, const char *gmsgid, ...)\n }\n \n void\n-warning_for_asm (rtx insn, const char *gmsgid, ...)\n+warning_for_asm (const_rtx insn, const char *gmsgid, ...)\n {\n   va_list ap;\n \n@@ -107,7 +107,7 @@ warning_for_asm (rtx insn, const char *gmsgid, ...)\n }\n \n void\n-_fatal_insn (const char *msgid, rtx insn, const char *file, int line,\n+_fatal_insn (const char *msgid, const_rtx insn, const char *file, int line,\n \t     const char *function)\n {\n   error (\"%s\", _(msgid));\n@@ -121,7 +121,7 @@ _fatal_insn (const char *msgid, rtx insn, const char *file, int line,\n }\n \n void\n-_fatal_insn_not_found (rtx insn, const char *file, int line,\n+_fatal_insn_not_found (const_rtx insn, const char *file, int line,\n \t\t       const char *function)\n {\n   if (INSN_CODE (insn) < 0)"}, {"sha": "cb79a70dd886f8d411dd90ebe713e356493e89ca", "filename": "gcc/rtl.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -168,7 +168,7 @@ rtvec_alloc (int n)\n /* Return the number of bytes occupied by rtx value X.  */\n \n unsigned int\n-rtx_size (rtx x)\n+rtx_size (const_rtx x)\n {\n   if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_HAS_BLOCK_INFO_P (x))\n     return RTX_HDR_SIZE + sizeof (struct block_symbol);\n@@ -204,7 +204,7 @@ rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n /* Return true if ORIG is a sharable CONST.  */\n \n bool\n-shared_const_p (rtx orig)\n+shared_const_p (const_rtx orig)\n {\n   gcc_assert (GET_CODE (orig) == CONST);\n   \n@@ -319,15 +319,11 @@ copy_rtx (rtx orig)\n /* Create a new copy of an rtx.  Only copy just one level.  */\n \n rtx\n-shallow_copy_rtx_stat (rtx orig MEM_STAT_DECL)\n+shallow_copy_rtx_stat (const_rtx orig MEM_STAT_DECL)\n {\n-  unsigned int size;\n-  rtx copy;\n-\n-  size = rtx_size (orig);\n-  copy = (rtx) ggc_alloc_zone_pass_stat (size, &rtl_zone);\n-  memcpy (copy, orig, size);\n-  return copy;\n+  const unsigned int size = rtx_size (orig);\n+  rtx const copy = (rtx) ggc_alloc_zone_pass_stat (size, &rtl_zone);\n+  return memcpy (copy, orig, size);\n }\n \f\n /* Nonzero when we are generating CONCATs.  */\n@@ -341,7 +337,7 @@ int currently_expanding_to_rtl;\n    This is the Lisp function EQUAL for rtx arguments.  */\n \n int\n-rtx_equal_p (rtx x, rtx y)\n+rtx_equal_p (const_rtx x, const_rtx y)\n {\n   int i;\n   int j;\n@@ -480,7 +476,7 @@ dump_rtx_statistics (void)\n \f\n #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)\n void\n-rtl_check_failed_bounds (rtx r, int n, const char *file, int line,\n+rtl_check_failed_bounds (const_rtx r, int n, const char *file, int line,\n \t\t\t const char *func)\n {\n   internal_error\n@@ -490,7 +486,7 @@ rtl_check_failed_bounds (rtx r, int n, const char *file, int line,\n }\n \n void\n-rtl_check_failed_type1 (rtx r, int n, int c1, const char *file, int line,\n+rtl_check_failed_type1 (const_rtx r, int n, int c1, const char *file, int line,\n \t\t\tconst char *func)\n {\n   internal_error\n@@ -500,7 +496,7 @@ rtl_check_failed_type1 (rtx r, int n, int c1, const char *file, int line,\n }\n \n void\n-rtl_check_failed_type2 (rtx r, int n, int c1, int c2, const char *file,\n+rtl_check_failed_type2 (const_rtx r, int n, int c1, int c2, const char *file,\n \t\t\tint line, const char *func)\n {\n   internal_error\n@@ -510,7 +506,7 @@ rtl_check_failed_type2 (rtx r, int n, int c1, int c2, const char *file,\n }\n \n void\n-rtl_check_failed_code1 (rtx r, enum rtx_code code, const char *file,\n+rtl_check_failed_code1 (const_rtx r, enum rtx_code code, const char *file,\n \t\t\tint line, const char *func)\n {\n   internal_error (\"RTL check: expected code '%s', have '%s' in %s, at %s:%d\",\n@@ -519,7 +515,7 @@ rtl_check_failed_code1 (rtx r, enum rtx_code code, const char *file,\n }\n \n void\n-rtl_check_failed_code2 (rtx r, enum rtx_code code1, enum rtx_code code2,\n+rtl_check_failed_code2 (const_rtx r, enum rtx_code code1, enum rtx_code code2,\n \t\t\tconst char *file, int line, const char *func)\n {\n   internal_error\n@@ -529,7 +525,7 @@ rtl_check_failed_code2 (rtx r, enum rtx_code code1, enum rtx_code code2,\n }\n \n void\n-rtl_check_failed_code_mode (rtx r, enum rtx_code code, enum machine_mode mode,\n+rtl_check_failed_code_mode (const_rtx r, enum rtx_code code, enum machine_mode mode,\n \t\t\t    bool not_mode, const char *file, int line,\n \t\t\t    const char *func)\n {\n@@ -556,7 +552,7 @@ rtl_check_failed_block_symbol (const char *file, int line, const char *func)\n \n /* XXX Maybe print the vector?  */\n void\n-rtvec_check_failed_bounds (rtvec r, int n, const char *file, int line,\n+rtvec_check_failed_bounds (const_rtvec r, int n, const char *file, int line,\n \t\t\t   const char *func)\n {\n   internal_error\n@@ -567,7 +563,7 @@ rtvec_check_failed_bounds (rtvec r, int n, const char *file, int line,\n \n #if defined ENABLE_RTL_FLAG_CHECKING\n void\n-rtl_check_failed_flag (const char *name, rtx r, const char *file,\n+rtl_check_failed_flag (const char *name, const_rtx r, const char *file,\n \t\t       int line, const char *func)\n {\n   internal_error"}, {"sha": "ae910f7c4ebae736073c133698f3f82904e9f0a7", "filename": "gcc/rtl.h", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -538,27 +538,27 @@ struct rtvec_def GTY(()) {\n \t\t\t\t    __FUNCTION__);\t\t\t\\\n    &_symbol->u.block_sym; })\n \n-extern void rtl_check_failed_bounds (rtx, int, const char *, int,\n+extern void rtl_check_failed_bounds (const_rtx, int, const char *, int,\n \t\t\t\t     const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_type1 (rtx, int, int, const char *, int,\n+extern void rtl_check_failed_type1 (const_rtx, int, int, const char *, int,\n \t\t\t\t    const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_type2 (rtx, int, int, int, const char *,\n+extern void rtl_check_failed_type2 (const_rtx, int, int, int, const char *,\n \t\t\t\t    int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code1 (rtx, enum rtx_code, const char *,\n+extern void rtl_check_failed_code1 (const_rtx, enum rtx_code, const char *,\n \t\t\t\t    int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code2 (rtx, enum rtx_code, enum rtx_code,\n+extern void rtl_check_failed_code2 (const_rtx, enum rtx_code, enum rtx_code,\n \t\t\t\t    const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code_mode (rtx, enum rtx_code, enum machine_mode,\n+extern void rtl_check_failed_code_mode (const_rtx, enum rtx_code, enum machine_mode,\n \t\t\t\t\tbool, const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n extern void rtl_check_failed_block_symbol (const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void rtvec_check_failed_bounds (rtvec, int, const char *, int,\n+extern void rtvec_check_failed_bounds (const_rtvec, int, const char *, int,\n \t\t\t\t       const char *)\n     ATTRIBUTE_NORETURN;\n \n@@ -655,7 +655,7 @@ extern void rtvec_check_failed_bounds (rtvec, int, const char *, int,\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n-extern void rtl_check_failed_flag (const char *, rtx, const char *,\n+extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n \t\t\t\t   int, const char *)\n     ATTRIBUTE_NORETURN\n     ;\n@@ -910,15 +910,15 @@ enum label_kind\n \n /* Retrieve the kind of LABEL.  */\n #define LABEL_KIND(LABEL) __extension__\t\t\t\t\t\\\n-({ __typeof (LABEL) const _label = (LABEL);\t\t\t\t\t\\\n+({ __typeof (LABEL) const _label = (LABEL);\t\t\t\t\\\n    if (GET_CODE (_label) != CODE_LABEL)\t\t\t\t\t\\\n      rtl_check_failed_flag (\"LABEL_KIND\", _label, __FILE__, __LINE__,\t\\\n \t\t\t    __FUNCTION__);\t\t\t\t\\\n    (enum label_kind) ((_label->jump << 1) | _label->call); })\n \n /* Set the kind of LABEL.  */\n #define SET_LABEL_KIND(LABEL, KIND) do {\t\t\t\t\\\n-   rtx const _label = (LABEL);\t\t\t\t\t\t\\\n+   __typeof (LABEL) const _label = (LABEL);\t\t\t\t\\\n    const unsigned int _kind = (KIND);\t\t\t\t\t\\\n    if (GET_CODE (_label) != CODE_LABEL)\t\t\t\t\t\\\n      rtl_check_failed_flag (\"SET_LABEL_KIND\", _label, __FILE__, __LINE__, \\\n@@ -967,7 +967,7 @@ enum label_kind\n \n /* Force the REGNO macro to only be used on the lhs.  */\n static inline unsigned int\n-rhs_regno (rtx x)\n+rhs_regno (const_rtx x)\n {\n   return XCUINT (x, 0, REG);\n }\n@@ -1036,15 +1036,15 @@ rhs_regno (rtx x)\n extern void init_rtlanal (void);\n extern int rtx_cost (rtx, enum rtx_code);\n extern int address_cost (rtx, enum machine_mode);\n-extern unsigned int subreg_lsb (rtx);\n+extern unsigned int subreg_lsb (const_rtx);\n extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,\n \t\t\t\t  unsigned int);\n extern unsigned int subreg_regno_offset\t(unsigned int, enum machine_mode,\n \t\t\t\t\t unsigned int, enum machine_mode);\n extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n \t\t\t\t\t   unsigned int, enum machine_mode);\n-extern unsigned int subreg_regno (rtx);\n-extern unsigned int subreg_nregs (rtx);\n+extern unsigned int subreg_regno (const_rtx);\n+extern unsigned int subreg_nregs (const_rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (rtx, enum machine_mode);\n extern unsigned int num_sign_bit_copies (rtx, enum machine_mode);\n extern bool constant_pool_constant_p (rtx);\n@@ -1466,18 +1466,18 @@ extern rtx rtx_alloc_stat (RTX_CODE MEM_STAT_DECL);\n #define rtx_alloc(c) rtx_alloc_stat (c MEM_STAT_INFO)\n \n extern rtvec rtvec_alloc (int);\n-extern bool shared_const_p (rtx);\n+extern bool shared_const_p (const_rtx);\n extern rtx copy_rtx (rtx);\n extern void dump_rtx_statistics (void);\n \n /* In emit-rtl.c */\n extern rtx copy_rtx_if_shared (rtx);\n \n /* In rtl.c */\n-extern unsigned int rtx_size (rtx);\n-extern rtx shallow_copy_rtx_stat (rtx MEM_STAT_DECL);\n+extern unsigned int rtx_size (const_rtx);\n+extern rtx shallow_copy_rtx_stat (const_rtx MEM_STAT_DECL);\n #define shallow_copy_rtx(a) shallow_copy_rtx_stat (a MEM_STAT_INFO)\n-extern int rtx_equal_p (rtx, rtx);\n+extern int rtx_equal_p (const_rtx, const_rtx);\n \n /* In emit-rtl.c */\n extern rtvec gen_rtvec_v (int, rtx *);\n@@ -1529,7 +1529,7 @@ extern rtx force_const_mem (enum machine_mode, rtx);\n struct function;\n extern rtx get_pool_constant (rtx);\n extern rtx get_pool_constant_mark (rtx, bool *);\n-extern enum machine_mode get_pool_mode (rtx);\n+extern enum machine_mode get_pool_mode (const_rtx);\n extern rtx simplify_subtraction (rtx);\n \n /* In function.c  */\n@@ -1591,8 +1591,8 @@ extern rtx next_cc0_user (rtx);\n extern rtx prev_cc0_setter (rtx);\n \n /* In cfglayout.c  */\n-extern int insn_line (rtx);\n-extern const char * insn_file (rtx);\n+extern int insn_line (const_rtx);\n+extern const char * insn_file (const_rtx);\n extern int locator_line (int);\n extern const char * locator_file (int);\n extern int prologue_locator, epilogue_locator;\n@@ -1645,10 +1645,10 @@ extern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t    unsigned int);\n extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t\tunsigned int);\n-extern rtx simplify_replace_rtx (rtx, rtx, rtx);\n+extern rtx simplify_replace_rtx (rtx, const_rtx, rtx);\n extern rtx simplify_rtx (rtx);\n extern rtx avoid_constant_pool_reference (rtx);\n-extern bool mode_signbit_p (enum machine_mode, rtx);\n+extern bool mode_signbit_p (enum machine_mode, const_rtx);\n \n /* In regclass.c  */\n extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,\n@@ -1675,69 +1675,69 @@ typedef struct replace_label_data\n   bool update_label_nuses;\n } replace_label_data;\n \n-extern int rtx_addr_can_trap_p (rtx);\n-extern bool nonzero_address_p (rtx);\n-extern int rtx_unstable_p (rtx);\n+extern int rtx_addr_can_trap_p (const_rtx);\n+extern bool nonzero_address_p (const_rtx);\n+extern int rtx_unstable_p (const_rtx);\n extern int rtx_varies_p (rtx, int);\n extern int rtx_addr_varies_p (rtx, int);\n-extern HOST_WIDE_INT get_integer_term (rtx);\n-extern rtx get_related_value (rtx);\n-extern bool offset_within_block_p (rtx, HOST_WIDE_INT);\n+extern HOST_WIDE_INT get_integer_term (const_rtx);\n+extern rtx get_related_value (const_rtx);\n+extern bool offset_within_block_p (const_rtx, HOST_WIDE_INT);\n extern void split_const (rtx, rtx *, rtx *);\n-extern int reg_mentioned_p (rtx, rtx);\n-extern int count_occurrences (rtx, rtx, int);\n-extern int reg_referenced_p (rtx, rtx);\n-extern int reg_used_between_p (rtx, rtx, rtx);\n+extern int reg_mentioned_p (const_rtx, const_rtx);\n+extern int count_occurrences (const_rtx, const_rtx, int);\n+extern int reg_referenced_p (const_rtx, const_rtx);\n+extern int reg_used_between_p (const_rtx, const_rtx, const_rtx);\n extern int reg_set_between_p (rtx, rtx, rtx);\n extern int commutative_operand_precedence (rtx);\n extern bool swap_commutative_operands_p (rtx, rtx);\n extern int modified_between_p (rtx, rtx, rtx);\n-extern int no_labels_between_p (rtx, rtx);\n+extern int no_labels_between_p (const_rtx, const_rtx);\n extern int modified_in_p (rtx, rtx);\n extern int reg_set_p (rtx, rtx);\n-extern rtx single_set_2 (rtx, rtx);\n-extern int multiple_sets (rtx);\n-extern int set_noop_p (rtx);\n+extern rtx single_set_2 (const_rtx, const_rtx);\n+extern int multiple_sets (const_rtx);\n+extern int set_noop_p (const_rtx);\n extern int noop_move_p (rtx);\n extern rtx find_last_value (rtx, rtx *, rtx, int);\n-extern int refers_to_regno_p (unsigned int, unsigned int, rtx, rtx *);\n-extern int reg_overlap_mentioned_p (rtx, rtx);\n+extern int refers_to_regno_p (unsigned int, unsigned int, const_rtx, rtx *);\n+extern int reg_overlap_mentioned_p (const_rtx, const_rtx);\n extern rtx set_of (rtx, rtx);\n extern void note_stores (rtx, void (*) (rtx, rtx, void *), void *);\n extern void note_uses (rtx *, void (*) (rtx *, void *), void *);\n-extern int dead_or_set_p (rtx, rtx);\n-extern int dead_or_set_regno_p (rtx, unsigned int);\n-extern rtx find_reg_note (rtx, enum reg_note, rtx);\n-extern rtx find_regno_note (rtx, enum reg_note, unsigned int);\n-extern rtx find_reg_equal_equiv_note (rtx);\n-extern rtx find_constant_src (rtx);\n-extern int find_reg_fusage (rtx, enum rtx_code, rtx);\n-extern int find_regno_fusage (rtx, enum rtx_code, unsigned int);\n-extern int pure_call_p (rtx);\n-extern void remove_note (rtx, rtx);\n+extern int dead_or_set_p (const_rtx, const_rtx);\n+extern int dead_or_set_regno_p (const_rtx, unsigned int);\n+extern rtx find_reg_note (const_rtx, enum reg_note, const_rtx);\n+extern rtx find_regno_note (const_rtx, enum reg_note, unsigned int);\n+extern rtx find_reg_equal_equiv_note (const_rtx);\n+extern rtx find_constant_src (const_rtx);\n+extern int find_reg_fusage (const_rtx, enum rtx_code, const_rtx);\n+extern int find_regno_fusage (const_rtx, enum rtx_code, unsigned int);\n+extern int pure_call_p (const_rtx);\n+extern void remove_note (rtx, const_rtx);\n extern void remove_reg_equal_equiv_notes (rtx);\n-extern int side_effects_p (rtx);\n-extern int volatile_refs_p (rtx);\n-extern int volatile_insn_p (rtx);\n-extern int may_trap_p (rtx);\n-extern int may_trap_after_code_motion_p (rtx);\n-extern int may_trap_or_fault_p (rtx);\n-extern int inequality_comparisons_p (rtx);\n+extern int side_effects_p (const_rtx);\n+extern int volatile_refs_p (const_rtx);\n+extern int volatile_insn_p (const_rtx);\n+extern int may_trap_p (const_rtx);\n+extern int may_trap_after_code_motion_p (const_rtx);\n+extern int may_trap_or_fault_p (const_rtx);\n+extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n extern int replace_label (rtx *, void *);\n extern int rtx_referenced_p (rtx, rtx);\n-extern bool tablejump_p (rtx, rtx *, rtx *);\n-extern int computed_jump_p (rtx);\n+extern bool tablejump_p (const_rtx, rtx *, rtx *);\n+extern int computed_jump_p (const_rtx);\n typedef int (*rtx_function) (rtx *, void *);\n extern int for_each_rtx (rtx *, rtx_function, void *);\n extern rtx regno_use_in (unsigned int, rtx);\n-extern int auto_inc_p (rtx);\n-extern int in_expr_list_p (rtx, rtx);\n-extern void remove_node_from_expr_list (rtx, rtx *);\n-extern int loc_mentioned_in_p (rtx *, rtx);\n+extern int auto_inc_p (const_rtx);\n+extern int in_expr_list_p (const_rtx, const_rtx);\n+extern void remove_node_from_expr_list (const_rtx, rtx *);\n+extern int loc_mentioned_in_p (rtx *, const_rtx);\n extern rtx find_first_parameter_load (rtx, rtx);\n extern bool keep_with_call_p (rtx);\n-extern bool label_is_jump_target_p (rtx, rtx);\n+extern bool label_is_jump_target_p (const_rtx, const_rtx);\n extern int insn_rtx_cost (rtx);\n \n /* Given an insn and condition, return a canonical description of\n@@ -2028,8 +2028,8 @@ extern int redirect_jump (rtx, rtx, int);\n extern void rebuild_jump_labels (rtx);\n extern rtx reversed_comparison (rtx, enum machine_mode);\n extern enum rtx_code reversed_comparison_code (rtx, rtx);\n-extern enum rtx_code reversed_comparison_code_parts (enum rtx_code,\n-\t\t\t\t\t\t     rtx, rtx, rtx);\n+extern enum rtx_code reversed_comparison_code_parts (enum rtx_code, rtx,\n+\t\t\t\t\t\t     rtx, rtx);\n extern void delete_for_peephole (rtx, rtx);\n extern int condjump_in_parallel_p (rtx);\n \n@@ -2103,15 +2103,15 @@ extern void fix_sched_param (const char *, const char *);\n \n /* In print-rtl.c */\n extern const char *print_rtx_head;\n-extern void debug_rtx (rtx);\n-extern void debug_rtx_list (rtx, int);\n-extern void debug_rtx_range (rtx, rtx);\n-extern rtx debug_rtx_find (rtx, int);\n-extern void print_mem_expr (FILE *, tree);\n-extern void print_rtl (FILE *, rtx);\n-extern void print_simple_rtl (FILE *, rtx);\n-extern int print_rtl_single (FILE *, rtx);\n-extern void print_inline_rtx (FILE *, rtx, int);\n+extern void debug_rtx (const_rtx);\n+extern void debug_rtx_list (const_rtx, int);\n+extern void debug_rtx_range (const_rtx, const_rtx);\n+extern const_rtx debug_rtx_find (const_rtx, int);\n+extern void print_mem_expr (FILE *, const_tree);\n+extern void print_rtl (FILE *, const_rtx);\n+extern void print_simple_rtl (FILE *, const_rtx);\n+extern int print_rtl_single (FILE *, const_rtx);\n+extern void print_inline_rtx (FILE *, const_rtx, int);\n \n /* In function.c */\n extern void reposition_prologue_and_epilogue_notes (void);"}, {"sha": "c5dd23a342b47ff15231601c462277a3b40afa31", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 66, "deletions": 72, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -54,10 +54,10 @@ struct subreg_info\n \n /* Forward declarations */\n static void set_of_1 (rtx, rtx, void *);\n-static bool covers_regno_p (rtx, unsigned int);\n-static bool covers_regno_no_parallel_p (rtx, unsigned int);\n+static bool covers_regno_p (const_rtx, unsigned int);\n+static bool covers_regno_no_parallel_p (const_rtx, unsigned int);\n static int rtx_referenced_p_1 (rtx *, void *);\n-static int computed_jump_p_1 (rtx);\n+static int computed_jump_p_1 (const_rtx);\n static void parms_set (rtx, rtx, void *);\n static void subreg_get_info (unsigned int, enum machine_mode,\n \t\t\t     unsigned int, enum machine_mode,\n@@ -66,8 +66,8 @@ static void subreg_get_info (unsigned int, enum machine_mode,\n static unsigned HOST_WIDE_INT cached_nonzero_bits (rtx, enum machine_mode,\n                                                    rtx, enum machine_mode,\n                                                    unsigned HOST_WIDE_INT);\n-static unsigned HOST_WIDE_INT nonzero_bits1 (rtx, enum machine_mode, rtx,\n-                                             enum machine_mode,\n+static unsigned HOST_WIDE_INT nonzero_bits1 (rtx, enum machine_mode,\n+\t\t\t\t\t     rtx, enum machine_mode,\n                                              unsigned HOST_WIDE_INT);\n static unsigned int cached_num_sign_bit_copies (rtx, enum machine_mode, rtx,\n                                                 enum machine_mode,\n@@ -107,9 +107,9 @@ num_sign_bit_copies_in_rep[MAX_MODE_INT + 1][MAX_MODE_INT + 1];\n    (within one function) and so is anything marked `unchanging'.  */\n \n int\n-rtx_unstable_p (rtx x)\n+rtx_unstable_p (const_rtx x)\n {\n-  RTX_CODE code = GET_CODE (x);\n+  const RTX_CODE code = GET_CODE (x);\n   int i;\n   const char *fmt;\n \n@@ -262,7 +262,7 @@ rtx_varies_p (rtx x, int for_alias)\n    alignment machines.  */\n \n static int\n-rtx_addr_can_trap_p_1 (rtx x, enum machine_mode mode, bool unaligned_mems)\n+rtx_addr_can_trap_p_1 (const_rtx x, enum machine_mode mode, bool unaligned_mems)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -348,17 +348,17 @@ rtx_addr_can_trap_p_1 (rtx x, enum machine_mode mode, bool unaligned_mems)\n /* Return nonzero if the use of X as an address in a MEM can cause a trap.  */\n \n int\n-rtx_addr_can_trap_p (rtx x)\n+rtx_addr_can_trap_p (const_rtx x)\n {\n   return rtx_addr_can_trap_p_1 (x, VOIDmode, false);\n }\n \n /* Return true if X is an address that is known to not be zero.  */\n \n bool\n-nonzero_address_p (rtx x)\n+nonzero_address_p (const_rtx x)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -465,7 +465,7 @@ rtx_addr_varies_p (rtx x, int for_alias)\n    This is used in cse.c with the `related_value' field.  */\n \n HOST_WIDE_INT\n-get_integer_term (rtx x)\n+get_integer_term (const_rtx x)\n {\n   if (GET_CODE (x) == CONST)\n     x = XEXP (x, 0);\n@@ -484,7 +484,7 @@ get_integer_term (rtx x)\n    Only obvious integer terms are detected.  */\n \n rtx\n-get_related_value (rtx x)\n+get_related_value (const_rtx x)\n {\n   if (GET_CODE (x) != CONST)\n     return 0;\n@@ -502,7 +502,7 @@ get_related_value (rtx x)\n    to somewhere in the same object or object_block as SYMBOL.  */\n \n bool\n-offset_within_block_p (rtx symbol, HOST_WIDE_INT offset)\n+offset_within_block_p (const_rtx symbol, HOST_WIDE_INT offset)\n {\n   tree decl;\n \n@@ -557,7 +557,7 @@ split_const (rtx x, rtx *base_out, rtx *offset_out)\n    zero, we do not count occurrences inside the destination of a SET.  */\n \n int\n-count_occurrences (rtx x, rtx find, int count_dest)\n+count_occurrences (const_rtx x, const_rtx find, int count_dest)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -627,7 +627,7 @@ count_occurrences (rtx x, rtx find, int count_dest)\n    for a subexpression of IN that is Lisp \"equal\" to REG.  */\n \n int\n-reg_mentioned_p (rtx reg, rtx in)\n+reg_mentioned_p (const_rtx reg, const_rtx in)\n {\n   const char *fmt;\n   int i;\n@@ -692,7 +692,7 @@ reg_mentioned_p (rtx reg, rtx in)\n    no CODE_LABEL insn.  */\n \n int\n-no_labels_between_p (rtx beg, rtx end)\n+no_labels_between_p (const_rtx beg, const_rtx end)\n {\n   rtx p;\n   if (beg == end)\n@@ -707,7 +707,7 @@ no_labels_between_p (rtx beg, rtx end)\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n int\n-reg_used_between_p (rtx reg, rtx from_insn, rtx to_insn)\n+reg_used_between_p (const_rtx reg, const_rtx from_insn, const_rtx to_insn)\n {\n   rtx insn;\n \n@@ -727,7 +727,7 @@ reg_used_between_p (rtx reg, rtx from_insn, rtx to_insn)\n    we do not consider it a reference.  */\n \n int\n-reg_referenced_p (rtx x, rtx body)\n+reg_referenced_p (const_rtx x, const_rtx body)\n {\n   int i;\n \n@@ -988,7 +988,7 @@ set_of (rtx pat, rtx insn)\n    will not be used, which we ignore.  */\n \n rtx\n-single_set_2 (rtx insn, rtx pat)\n+single_set_2 (const_rtx insn, const_rtx pat)\n {\n   rtx set = NULL;\n   int set_verified = 1;\n@@ -1041,7 +1041,7 @@ single_set_2 (rtx insn, rtx pat)\n    zero.  */\n \n int\n-multiple_sets (rtx insn)\n+multiple_sets (const_rtx insn)\n {\n   int found;\n   int i;\n@@ -1072,7 +1072,7 @@ multiple_sets (rtx insn)\n    and there are no side effects.  */\n \n int\n-set_noop_p (rtx set)\n+set_noop_p (const_rtx set)\n {\n   rtx src = SET_SRC (set);\n   rtx dst = SET_DEST (set);\n@@ -1203,7 +1203,7 @@ find_last_value (rtx x, rtx *pinsn, rtx valid_to, int allow_hwreg)\n    LOC may be zero, meaning don't ignore anything.  */\n \n int\n-refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n+refers_to_regno_p (unsigned int regno, unsigned int endregno, const_rtx x,\n \t\t   rtx *loc)\n {\n   int i;\n@@ -1312,7 +1312,7 @@ refers_to_regno_p (unsigned int regno, unsigned int endregno, rtx x,\n    conflict because we expect this to be a rare case.  */\n \n int\n-reg_overlap_mentioned_p (rtx x, rtx in)\n+reg_overlap_mentioned_p (const_rtx x, const_rtx in)\n {\n   unsigned int regno, endregno;\n \n@@ -1550,7 +1550,7 @@ note_uses (rtx *pbody, void (*fun) (rtx *, void *), void *data)\n    by INSN.  */\n \n int\n-dead_or_set_p (rtx insn, rtx x)\n+dead_or_set_p (const_rtx insn, const_rtx x)\n {\n   unsigned int regno, end_regno;\n   unsigned int i;\n@@ -1575,7 +1575,7 @@ dead_or_set_p (rtx insn, rtx x)\n    part of the register is TEST_REGNO.  */\n \n static bool\n-covers_regno_no_parallel_p (rtx dest, unsigned int test_regno)\n+covers_regno_no_parallel_p (const_rtx dest, unsigned int test_regno)\n {\n   unsigned int regno, endregno;\n \n@@ -1598,7 +1598,7 @@ covers_regno_no_parallel_p (rtx dest, unsigned int test_regno)\n    any member matches the covers_regno_no_parallel_p criteria.  */\n \n static bool\n-covers_regno_p (rtx dest, unsigned int test_regno)\n+covers_regno_p (const_rtx dest, unsigned int test_regno)\n {\n   if (GET_CODE (dest) == PARALLEL)\n     {\n@@ -1624,9 +1624,9 @@ covers_regno_p (rtx dest, unsigned int test_regno)\n /* Utility function for dead_or_set_p to check an individual register. */\n \n int\n-dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n+dead_or_set_regno_p (const_rtx insn, unsigned int test_regno)\n {\n-  rtx pattern;\n+  const_rtx pattern;\n \n   /* See if there is a death note for something that includes TEST_REGNO.  */\n   if (find_regno_note (insn, REG_DEAD, test_regno))\n@@ -1667,7 +1667,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n    If DATUM is nonzero, look for one whose datum is DATUM.  */\n \n rtx\n-find_reg_note (rtx insn, enum reg_note kind, rtx datum)\n+find_reg_note (const_rtx insn, enum reg_note kind, const_rtx datum)\n {\n   rtx link;\n \n@@ -1696,7 +1696,7 @@ find_reg_note (rtx insn, enum reg_note kind, rtx datum)\n    it might be the case that the note overlaps REGNO.  */\n \n rtx\n-find_regno_note (rtx insn, enum reg_note kind, unsigned int regno)\n+find_regno_note (const_rtx insn, enum reg_note kind, unsigned int regno)\n {\n   rtx link;\n \n@@ -1719,7 +1719,7 @@ find_regno_note (rtx insn, enum reg_note kind, unsigned int regno)\n    has such a note.  */\n \n rtx\n-find_reg_equal_equiv_note (rtx insn)\n+find_reg_equal_equiv_note (const_rtx insn)\n {\n   rtx link;\n \n@@ -1748,7 +1748,7 @@ find_reg_equal_equiv_note (rtx insn)\n    return null.  */\n \n rtx\n-find_constant_src (rtx insn)\n+find_constant_src (const_rtx insn)\n {\n   rtx note, set, x;\n \n@@ -1771,7 +1771,7 @@ find_constant_src (rtx insn)\n    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */\n \n int\n-find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n+find_reg_fusage (const_rtx insn, enum rtx_code code, const_rtx datum)\n {\n   /* If it's not a CALL_INSN, it can't possibly have a\n      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */\n@@ -1816,7 +1816,7 @@ find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n    in the CALL_INSN_FUNCTION_USAGE information of INSN.  */\n \n int\n-find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n+find_regno_fusage (const_rtx insn, enum rtx_code code, unsigned int regno)\n {\n   rtx link;\n \n@@ -1844,9 +1844,9 @@ find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n /* Return true if INSN is a call to a pure function.  */\n \n int\n-pure_call_p (rtx insn)\n+pure_call_p (const_rtx insn)\n {\n-  rtx link;\n+  const_rtx link;\n \n   if (!CALL_P (insn) || ! CONST_OR_PURE_CALL_P (insn))\n     return 0;\n@@ -1868,7 +1868,7 @@ pure_call_p (rtx insn)\n /* Remove register note NOTE from the REG_NOTES of INSN.  */\n \n void\n-remove_note (rtx insn, rtx note)\n+remove_note (rtx insn, const_rtx note)\n {\n   rtx link;\n \n@@ -1919,9 +1919,9 @@ remove_reg_equal_equiv_notes (rtx insn)\n    NODE matches.  */\n \n int\n-in_expr_list_p (rtx listp, rtx node)\n+in_expr_list_p (const_rtx listp, const_rtx node)\n {\n-  rtx x;\n+  const_rtx x;\n \n   for (x = listp; x; x = XEXP (x, 1))\n     if (node == XEXP (x, 0))\n@@ -1936,7 +1936,7 @@ in_expr_list_p (rtx listp, rtx node)\n    A simple equality test is used to determine if NODE matches.  */\n \n void\n-remove_node_from_expr_list (rtx node, rtx *listp)\n+remove_node_from_expr_list (const_rtx node, rtx *listp)\n {\n   rtx temp = *listp;\n   rtx prev = NULL_RTX;\n@@ -1965,11 +1965,9 @@ remove_node_from_expr_list (rtx node, rtx *listp)\n    only volatile asms and UNSPEC_VOLATILE instructions.  */\n \n int\n-volatile_insn_p (rtx x)\n+volatile_insn_p (const_rtx x)\n {\n-  RTX_CODE code;\n-\n-  code = GET_CODE (x);\n+  const RTX_CODE code = GET_CODE (x);\n   switch (code)\n     {\n     case LABEL_REF:\n@@ -2005,7 +2003,7 @@ volatile_insn_p (rtx x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    const char *fmt = GET_RTX_FORMAT (code);\n+    const char *const fmt = GET_RTX_FORMAT (code);\n     int i;\n \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -2031,11 +2029,9 @@ volatile_insn_p (rtx x)\n    UNSPEC_VOLATILE operations or volatile ASM_OPERANDS expressions.  */\n \n int\n-volatile_refs_p (rtx x)\n+volatile_refs_p (const_rtx x)\n {\n-  RTX_CODE code;\n-\n-  code = GET_CODE (x);\n+  const RTX_CODE code = GET_CODE (x);\n   switch (code)\n     {\n     case LABEL_REF:\n@@ -2069,7 +2065,7 @@ volatile_refs_p (rtx x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    const char *fmt = GET_RTX_FORMAT (code);\n+    const char *const fmt = GET_RTX_FORMAT (code);\n     int i;\n \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -2095,11 +2091,9 @@ volatile_refs_p (rtx x)\n    incrementing.  */\n \n int\n-side_effects_p (rtx x)\n+side_effects_p (const_rtx x)\n {\n-  RTX_CODE code;\n-\n-  code = GET_CODE (x);\n+  const RTX_CODE code = GET_CODE (x);\n   switch (code)\n     {\n     case LABEL_REF:\n@@ -2181,7 +2175,7 @@ enum may_trap_p_flags\n    elsewhere.  */\n \n static int\n-may_trap_p_1 (rtx x, unsigned flags)\n+may_trap_p_1 (const_rtx x, unsigned flags)\n {\n   int i;\n   enum rtx_code code;\n@@ -2317,7 +2311,7 @@ may_trap_p_1 (rtx x, unsigned flags)\n /* Return nonzero if evaluating rtx X might cause a trap.  */\n \n int\n-may_trap_p (rtx x)\n+may_trap_p (const_rtx x)\n {\n   return may_trap_p_1 (x, 0);\n }\n@@ -2326,7 +2320,7 @@ may_trap_p (rtx x)\n    is moved from its current location by some optimization.  */\n \n int\n-may_trap_after_code_motion_p (rtx x)\n+may_trap_after_code_motion_p (const_rtx x)\n {\n   return may_trap_p_1 (x, MTP_AFTER_MOVE);\n }\n@@ -2372,7 +2366,7 @@ may_trap_after_code_motion_p (rtx x)\n    on a strict alignment machine.  */\n \n int\n-may_trap_or_fault_p (rtx x)\n+may_trap_or_fault_p (const_rtx x)\n {\n   return may_trap_p_1 (x, MTP_UNALIGNED_MEMS);\n }\n@@ -2381,11 +2375,11 @@ may_trap_or_fault_p (rtx x)\n    i.e., an inequality.  */\n \n int\n-inequality_comparisons_p (rtx x)\n+inequality_comparisons_p (const_rtx x)\n {\n   const char *fmt;\n   int len, i;\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -2604,7 +2598,7 @@ rtx_referenced_p (rtx x, rtx body)\n    *LABELP and the jump table to *TABLEP.  LABELP and TABLEP may be NULL.  */\n \n bool\n-tablejump_p (rtx insn, rtx *labelp, rtx *tablep)\n+tablejump_p (const_rtx insn, rtx *labelp, rtx *tablep)\n {\n   rtx label, table;\n \n@@ -2629,9 +2623,9 @@ tablejump_p (rtx insn, rtx *labelp, rtx *tablep)\n    of an IF_THEN_ELSE.  */\n \n static int\n-computed_jump_p_1 (rtx x)\n+computed_jump_p_1 (const_rtx x)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n   int i, j;\n   const char *fmt;\n \n@@ -2683,7 +2677,7 @@ computed_jump_p_1 (rtx x)\n    we can recognize them by a (use (label_ref)).  */\n \n int\n-computed_jump_p (rtx insn)\n+computed_jump_p (const_rtx insn)\n {\n   int i;\n   if (JUMP_P (insn))\n@@ -2941,7 +2935,7 @@ swap_commutative_operands_p (rtx x, rtx y)\n /* Return 1 if X is an autoincrement side effect and the register is\n    not the stack pointer.  */\n int\n-auto_inc_p (rtx x)\n+auto_inc_p (const_rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2962,7 +2956,7 @@ auto_inc_p (rtx x)\n \n /* Return nonzero if IN contains a piece of rtl that has the address LOC.  */\n int\n-loc_mentioned_in_p (rtx *loc, rtx in)\n+loc_mentioned_in_p (rtx *loc, const_rtx in)\n {\n   enum rtx_code code;\n   const char *fmt;\n@@ -3036,7 +3030,7 @@ subreg_lsb_1 (enum machine_mode outer_mode,\n    (counting from the least significant bit of the reg).  */\n \n unsigned int\n-subreg_lsb (rtx x)\n+subreg_lsb (const_rtx x)\n {\n   return subreg_lsb_1 (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n \t\t       SUBREG_BYTE (x));\n@@ -3233,7 +3227,7 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \n /* Return the final regno that a subreg expression refers to.  */\n unsigned int\n-subreg_regno (rtx x)\n+subreg_regno (const_rtx x)\n {\n   unsigned int ret;\n   rtx subreg = SUBREG_REG (x);\n@@ -3250,7 +3244,7 @@ subreg_regno (rtx x)\n /* Return the number of registers that a subreg expression refers\n    to.  */\n unsigned int\n-subreg_nregs (rtx x)\n+subreg_nregs (const_rtx x)\n {\n   struct subreg_info info;\n   rtx subreg = SUBREG_REG (x);\n@@ -3389,7 +3383,7 @@ keep_with_call_p (rtx insn)\n    not apply to the fallthru case of a conditional jump.  */\n \n bool\n-label_is_jump_target_p (rtx label, rtx jump_insn)\n+label_is_jump_target_p (const_rtx label, const_rtx jump_insn)\n {\n   rtx tmp = JUMP_LABEL (jump_insn);\n \n@@ -4541,7 +4535,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n {\n   enum rtx_code code;\n   rtx prev = insn;\n-  rtx set;\n+  const_rtx set;\n   rtx tem;\n   rtx op0, op1;\n   int reverse_code = 0;"}, {"sha": "590efd1cb04be1f9e6dd1ab6bfa26e4464851c1c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -50,8 +50,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define HWI_SIGN_EXTEND(low) \\\n  ((((HOST_WIDE_INT) low) < 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))\n \n-static rtx neg_const_int (enum machine_mode, rtx);\n-static bool plus_minus_operand_p (rtx);\n+static rtx neg_const_int (enum machine_mode, const_rtx);\n+static bool plus_minus_operand_p (const_rtx);\n static bool simplify_plus_minus_op_data_cmp (rtx, rtx);\n static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx, rtx);\n static rtx simplify_immed_subreg (enum machine_mode, rtx, enum machine_mode,\n@@ -67,7 +67,7 @@ static rtx simplify_binary_operation_1 (enum rtx_code, enum machine_mode,\n /* Negate a CONST_INT rtx, truncating (because a conversion from a\n    maximally negative number can overflow).  */\n static rtx\n-neg_const_int (enum machine_mode mode, rtx i)\n+neg_const_int (enum machine_mode mode, const_rtx i)\n {\n   return gen_int_mode (- INTVAL (i), mode);\n }\n@@ -76,7 +76,7 @@ neg_const_int (enum machine_mode mode, rtx i)\n    the most significant bit of machine mode MODE.  */\n \n bool\n-mode_signbit_p (enum machine_mode mode, rtx x)\n+mode_signbit_p (enum machine_mode mode, const_rtx x)\n {\n   unsigned HOST_WIDE_INT val;\n   unsigned int width;\n@@ -255,7 +255,7 @@ simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n    resulting RTX.  Return a new RTX which is as simplified as possible.  */\n \n rtx\n-simplify_replace_rtx (rtx x, rtx old_rtx, rtx new_rtx)\n+simplify_replace_rtx (rtx x, const_rtx old_rtx, rtx new_rtx)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -3601,7 +3601,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \n /* Check whether an operand is suitable for calling simplify_plus_minus.  */\n static bool\n-plus_minus_operand_p (rtx x)\n+plus_minus_operand_p (const_rtx x)\n {\n   return GET_CODE (x) == PLUS\n          || GET_CODE (x) == MINUS"}, {"sha": "d8c0ec20d80e3c827ff1e2bb1efc1a3155b985ae", "filename": "gcc/toplev.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -31,9 +31,9 @@ extern int toplev_main (unsigned int, const char **);\n extern int read_integral_parameter (const char *, const char *, const int);\n extern void strip_off_ending (char *, int);\n extern const char *trim_filename (const char *);\n-extern void _fatal_insn_not_found (rtx, const char *, int, const char *)\n+extern void _fatal_insn_not_found (const_rtx, const char *, int, const char *)\n      ATTRIBUTE_NORETURN;\n-extern void _fatal_insn (const char *, rtx, const char *, int, const char *)\n+extern void _fatal_insn (const char *, const_rtx, const char *, int, const char *)\n      ATTRIBUTE_NORETURN;\n \n #define fatal_insn(msgid, insn) \\\n@@ -76,8 +76,8 @@ extern bool enable_rtl_dump_file (int);\n \n extern void announce_function (tree);\n \n-extern void error_for_asm (rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n-extern void warning_for_asm (rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n+extern void error_for_asm (const_rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n+extern void warning_for_asm (const_rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void warn_deprecated_use (tree);\n \n #ifdef BUFSIZ"}, {"sha": "34b88eb54781b34b23a55a88670bbd5ac11fd338", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -4647,7 +4647,7 @@ extern tree gimplify_parameters (void);\n \n /* In print-rtl.c */\n #ifdef BUFSIZ\n-extern void print_rtl (FILE *, rtx);\n+extern void print_rtl (FILE *, const_rtx);\n #endif\n \n /* In print-tree.c */"}, {"sha": "f367561dc12050015b7c373fe29aa7b8ef6b9bd0", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d504c227fb7e621b6521fe282956f021cd2337/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f7d504c227fb7e621b6521fe282956f021cd2337", "patch": "@@ -3603,7 +3603,7 @@ get_pool_constant_mark (rtx addr, bool *pmarked)\n /* Similar, return the mode.  */\n \n enum machine_mode\n-get_pool_mode (rtx addr)\n+get_pool_mode (const_rtx addr)\n {\n   return SYMBOL_REF_CONSTANT (addr)->mode;\n }"}]}