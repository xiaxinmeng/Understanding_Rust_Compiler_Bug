{"sha": "e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5YjAxZjJiMWJiN2I0YTY4OTUwMmRkMjM3NzUzMDFlZjM2ZWIwZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-30T09:45:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-30T09:45:58Z"}, "message": "Fix LRA subreg calculation for big-endian targets\n\nLRA was using a subreg offset of 0 whenever constraints matched\ntwo operands with different modes.  That leads to an invalid offset\n(and ICE) on big-endian targets if one of the modes is narrower\nthan a word.  E.g. if a (reg:SI X) is matched to a (reg:QI Y),\nthe big-endian subreg should be (subreg:QI (reg:SI X) 3) rather\nthan (subreg:QI (reg:SI X) 0).\n\nBut this raises the issue of what the behaviour should be when the\nmatched operands occupy different numbers of registers.  Should the\nregister numbers match, or should the locations of the lsbs match?\nAlthough the documentation isn't clear, reload went for the second\ninterpretation (which seems the most natural to me):\n\n      /* On a REG_WORDS_BIG_ENDIAN machine, point to the last register of a\n         multiple hard register group of scalar integer registers, so that\n         for example (reg:DI 0) and (reg:SI 1) will be considered the same\n         register.  */\n\nSo I think this means that we can/must use the lowpart offset\nunconditionally, rather than trying to separate out the multi-register\ncase.  This also matches the LRA handling of constant integers, which\nalready uses lowpart subregs.\n\nThe patch fixes gcc.target/aarch64/sve/extract_[34].c for aarch64_be.\n\n2018-01-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* lra-constraints.c (match_reload): Use subreg_lowpart_offset\n\trather than 0 when creating partial subregs.\n\nFrom-SVN: r257177", "tree": {"sha": "0a08a5f52896b5ecba9f5b1401c322bd854e0891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a08a5f52896b5ecba9f5b1401c322bd854e0891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89b01f2b1bb7b4a689502dd23775301ef36eb0d/comments", "author": null, "committer": null, "parents": [{"sha": "65aa25a4430017f9d72cd3ccfaf25bd589908bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65aa25a4430017f9d72cd3ccfaf25bd589908bc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65aa25a4430017f9d72cd3ccfaf25bd589908bc6"}], "stats": {"total": 15, "additions": 13, "deletions": 2}, "files": [{"sha": "771aa014ebdc0085db6f3d6c393a1bebe25534a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89b01f2b1bb7b4a689502dd23775301ef36eb0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89b01f2b1bb7b4a689502dd23775301ef36eb0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "patch": "@@ -1,3 +1,8 @@\n+2018-01-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lra-constraints.c (match_reload): Use subreg_lowpart_offset\n+\trather than 0 when creating partial subregs.\n+\n 2018-01-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* vec-perm-indices.c (vec_perm_indices::series_p): Give examples"}, {"sha": "c2443124566548bec03a8f53784c6fd2f391f270", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89b01f2b1bb7b4a689502dd23775301ef36eb0d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89b01f2b1bb7b4a689502dd23775301ef36eb0d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "patch": "@@ -945,7 +945,10 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t  if (SCALAR_INT_MODE_P (inmode))\n \t    new_out_reg = gen_lowpart_SUBREG (outmode, reg);\n \t  else\n-\t    new_out_reg = gen_rtx_SUBREG (outmode, reg, 0);\n+\t    {\n+\t      poly_uint64 offset = subreg_lowpart_offset (outmode, inmode);\n+\t      new_out_reg = gen_rtx_SUBREG (outmode, reg, offset);\n+\t    }\n \t  LRA_SUBREG_P (new_out_reg) = 1;\n \t  /* If the input reg is dying here, we can use the same hard\n \t     register for REG and IN_RTX.  We do it only for original\n@@ -965,7 +968,10 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t  if (SCALAR_INT_MODE_P (outmode))\n \t    new_in_reg = gen_lowpart_SUBREG (inmode, reg);\n \t  else\n-\t    new_in_reg = gen_rtx_SUBREG (inmode, reg, 0);\n+\t    {\n+\t      poly_uint64 offset = subreg_lowpart_offset (inmode, outmode);\n+\t      new_in_reg = gen_rtx_SUBREG (inmode, reg, offset);\n+\t    }\n \t  /* NEW_IN_REG is non-paradoxical subreg.  We don't want\n \t     NEW_OUT_REG living above.  We add clobber clause for\n \t     this.  This is just a temporary clobber.  We can remove"}]}