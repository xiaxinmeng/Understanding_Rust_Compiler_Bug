{"sha": "c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3NTQ2ZmU5NDcxMmE3MjNiYzJlMTIzNDQ1ZGM1ZDliMGEwY2ExYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-03-18T12:25:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-03-18T12:25:32Z"}, "message": "Fix a case in which the vector cost model was ignored\n\nThis patch fixes a case in which we vectorised something with a\nfully-predicated loop even after the cost model had rejected it.\nE.g. the loop in the testcase has the costs:\n\n  Vector inside of loop cost: 27\n  Vector prologue cost: 0\n  Vector epilogue cost: 0\n  Scalar iteration cost: 7\n  Scalar outside cost: 6\n  Vector outside cost: 0\n  prologue iterations: 0\n  epilogue iterations: 0\n\nand we can see that the loop executes at most three times, but we\ndecided to vectorise it anyway.\n\n(The costs here are equal for three iterations, but the same thing\nhappens even when the vector code is strictly more expensive.)\n\nThe problem is the handling of \"/VF\" in:\n\n  /* Calculate number of iterations required to make the vector version\n     profitable, relative to the loop bodies only.  The following condition\n     must hold true:\n     SIC * niters + SOC > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC\n     where\n     SIC = scalar iteration cost, VIC = vector iteration cost,\n     VOC = vector outside cost, VF = vectorization factor,\n     PL_ITERS = prologue iterations, EP_ITERS= epilogue iterations\n     SOC = scalar outside cost for run time cost model check.  */\n\nWe treat the \"/VF\" as truncating, but for fully-predicated loops, it's\ncloser to a ceil division, since fractional iterations are handled by a\nfull iteration with some predicate bits set to false.\n\nThe easiest fix seemed to be to calculate the minimum number of vector\niterations first, then use that to calculate the minimum number of scalar\niterations.\n\nCalculating the minimum number of vector iterations might make sense for\nunpredicated loops too, since calculating the scalar niters directly\ndoesn't take into account the fact that the VIC multiple has to be an\ninteger.  But the handling of PL_ITERS and EP_ITERS for unpredicated\nloops is a bit hand-wavy anyway, so maybe vagueness here cancels out\nvagueness there?\n\nEither way, changing this for unpredicated loops would be much too\ninvasive for stage 4, so the patch keeps it specific to fully-predicated\nloops (i.e. SVE) for now.  There's no functional change for other targets.\n\n2019-03-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Fix the\n\tcalculation of the minimum number of scalar iterations for\n\tfully-predicated loops.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/cost_model_1.c: New test.\n\nFrom-SVN: r269763", "tree": {"sha": "e39368cb43ea4317b388677a39f9487d60b6d38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e39368cb43ea4317b388677a39f9487d60b6d38a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cfce6e055d98cf55a912dfe814d48a331ec2eee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfce6e055d98cf55a912dfe814d48a331ec2eee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfce6e055d98cf55a912dfe814d48a331ec2eee9"}], "stats": {"total": 150, "additions": 126, "deletions": 24}, "files": [{"sha": "d5c8114fb741ecc3bbff7735ee9a2fa5ec59891f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "patch": "@@ -1,3 +1,9 @@\n+2019-03-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Fix the\n+\tcalculation of the minimum number of scalar iterations for\n+\tfully-predicated loops.\n+\n 2019-03-18  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/89546"}, {"sha": "012f2a059b884ffcec7739767ea978d12e0b116c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "patch": "@@ -1,3 +1,7 @@\n+2019-03-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/cost_model_1.c: New test.\n+\n 2019-03-18  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/89546"}, {"sha": "a6d64422666cbc93f173bf007a315ed45a0e456d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cost_model_1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_1.c?ref=c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-details\" } */\n+\n+void\n+f (unsigned int *restrict x, unsigned int *restrict y,\n+   unsigned char *restrict z, unsigned int n)\n+{\n+  for (unsigned int i = 0; i < n % 4; ++i)\n+    x[i] = x[i] + y[i] + z[i];\n+}\n+\n+/* { dg-final { scan-tree-dump \"not vectorized: estimated iteration count too small\" vect } } */\n+/* { dg-final { scan-tree-dump \"vectorized 0 loops\" vect } } */"}, {"sha": "0edcdc7ee5f35983e40ce69f1812686780fe95b0", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57546fe94712a723bc2e123445dc5d9b0a0ca1a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "patch": "@@ -3600,14 +3600,89 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   /* Calculate number of iterations required to make the vector version\n      profitable, relative to the loop bodies only.  The following condition\n      must hold true:\n-     SIC * niters + SOC > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC\n+     SIC * niters + SOC > VIC * ((niters - NPEEL) / VF) + VOC\n      where\n      SIC = scalar iteration cost, VIC = vector iteration cost,\n      VOC = vector outside cost, VF = vectorization factor,\n-     PL_ITERS = prologue iterations, EP_ITERS= epilogue iterations\n+     NPEEL = prologue iterations + epilogue iterations,\n      SOC = scalar outside cost for run time cost model check.  */\n \n-  if ((scalar_single_iter_cost * assumed_vf) > (int) vec_inside_cost)\n+  int saving_per_viter = (scalar_single_iter_cost * assumed_vf\n+\t\t\t  - vec_inside_cost);\n+  if (saving_per_viter <= 0)\n+    {\n+      if (LOOP_VINFO_LOOP (loop_vinfo)->force_vectorize)\n+\twarning_at (vect_location.get_location_t (), OPT_Wopenmp_simd,\n+\t\t    \"vectorization did not happen for a simd loop\");\n+\n+      if (dump_enabled_p ())\n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"cost model: the vector iteration cost = %d \"\n+\t\t\t \"divided by the scalar iteration cost = %d \"\n+\t\t\t \"is greater or equal to the vectorization factor = %d\"\n+                         \".\\n\",\n+\t\t\t vec_inside_cost, scalar_single_iter_cost, assumed_vf);\n+      *ret_min_profitable_niters = -1;\n+      *ret_min_profitable_estimate = -1;\n+      return;\n+    }\n+\n+  /* ??? The \"if\" arm is written to handle all cases; see below for what\n+     we would do for !LOOP_VINFO_FULLY_MASKED_P.  */\n+  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    {\n+      /* Rewriting the condition above in terms of the number of\n+\t vector iterations (vniters) rather than the number of\n+\t scalar iterations (niters) gives:\n+\n+\t SIC * (vniters * VF + NPEEL) + SOC > VIC * vniters + VOC\n+\n+\t <==> vniters * (SIC * VF - VIC) > VOC - SIC * NPEEL - SOC\n+\n+\t For integer N, X and Y when X > 0:\n+\n+\t N * X > Y <==> N >= (Y /[floor] X) + 1.  */\n+      int outside_overhead = (vec_outside_cost\n+\t\t\t      - scalar_single_iter_cost * peel_iters_prologue\n+\t\t\t      - scalar_single_iter_cost * peel_iters_epilogue\n+\t\t\t      - scalar_outside_cost);\n+      /* We're only interested in cases that require at least one\n+\t vector iteration.  */\n+      int min_vec_niters = 1;\n+      if (outside_overhead > 0)\n+\tmin_vec_niters = outside_overhead / saving_per_viter + 1;\n+\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"  Minimum number of vector iterations: %d\\n\",\n+\t\t     min_vec_niters);\n+\n+      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\t{\n+\t  /* Now that we know the minimum number of vector iterations,\n+\t     find the minimum niters for which the scalar cost is larger:\n+\n+\t     SIC * niters > VIC * vniters + VOC - SOC\n+\n+\t     We know that the minimum niters is no more than\n+\t     vniters * VF + NPEEL, but it might be (and often is) less\n+\t     than that if a partial vector iteration is cheaper than the\n+\t     equivalent scalar code.  */\n+\t  int threshold = (vec_inside_cost * min_vec_niters\n+\t\t\t   + vec_outside_cost\n+\t\t\t   - scalar_outside_cost);\n+\t  if (threshold <= 0)\n+\t    min_profitable_iters = 1;\n+\t  else\n+\t    min_profitable_iters = threshold / scalar_single_iter_cost + 1;\n+\t}\n+      else\n+\t/* Convert the number of vector iterations into a number of\n+\t   scalar iterations.  */\n+\tmin_profitable_iters = (min_vec_niters * assumed_vf\n+\t\t\t\t+ peel_iters_prologue\n+\t\t\t\t+ peel_iters_epilogue);\n+    }\n+  else\n     {\n       min_profitable_iters = ((vec_outside_cost - scalar_outside_cost)\n \t\t\t      * assumed_vf\n@@ -3617,8 +3692,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n         min_profitable_iters = 0;\n       else\n \t{\n-\t  min_profitable_iters /= ((scalar_single_iter_cost * assumed_vf)\n-\t\t\t\t   - vec_inside_cost);\n+\t  min_profitable_iters /= saving_per_viter;\n \n \t  if ((scalar_single_iter_cost * assumed_vf * min_profitable_iters)\n \t      <= (((int) vec_inside_cost * min_profitable_iters)\n@@ -3627,24 +3701,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t    min_profitable_iters++;\n \t}\n     }\n-  /* vector version will never be profitable.  */\n-  else\n-    {\n-      if (LOOP_VINFO_LOOP (loop_vinfo)->force_vectorize)\n-\twarning_at (vect_location.get_location_t (), OPT_Wopenmp_simd,\n-\t\t    \"vectorization did not happen for a simd loop\");\n-\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"cost model: the vector iteration cost = %d \"\n-\t\t\t \"divided by the scalar iteration cost = %d \"\n-\t\t\t \"is greater or equal to the vectorization factor = %d\"\n-                         \".\\n\",\n-\t\t\t vec_inside_cost, scalar_single_iter_cost, assumed_vf);\n-      *ret_min_profitable_niters = -1;\n-      *ret_min_profitable_estimate = -1;\n-      return;\n-    }\n \n   if (dump_enabled_p ())\n     dump_printf (MSG_NOTE,\n@@ -3668,10 +3724,34 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n      Non-vectorized variant is SIC * niters and it must win over vector\n      variant on the expected loop trip count.  The following condition must hold true:\n-     SIC * niters > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC + SOC  */\n+     SIC * niters > VIC * ((niters - NPEEL) / VF) + VOC + SOC  */\n \n   if (vec_outside_cost <= 0)\n     min_profitable_estimate = 0;\n+  else if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    {\n+      /* This is a repeat of the code above, but with + SOC rather\n+\t than - SOC.  */\n+      int outside_overhead = (vec_outside_cost\n+\t\t\t      - scalar_single_iter_cost * peel_iters_prologue\n+\t\t\t      - scalar_single_iter_cost * peel_iters_epilogue\n+\t\t\t      + scalar_outside_cost);\n+      int min_vec_niters = 1;\n+      if (outside_overhead > 0)\n+\tmin_vec_niters = outside_overhead / saving_per_viter + 1;\n+\n+      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\t{\n+\t  int threshold = (vec_inside_cost * min_vec_niters\n+\t\t\t   + vec_outside_cost\n+\t\t\t   + scalar_outside_cost);\n+\t  min_profitable_estimate = threshold / scalar_single_iter_cost + 1;\n+\t}\n+      else\n+\tmin_profitable_estimate = (min_vec_niters * assumed_vf\n+\t\t\t\t   + peel_iters_prologue\n+\t\t\t\t   + peel_iters_epilogue);\n+    }\n   else\n     {\n       min_profitable_estimate = ((vec_outside_cost + scalar_outside_cost)"}]}