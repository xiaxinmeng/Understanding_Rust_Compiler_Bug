{"sha": "7c6e92558c74d538f6790a81178b8cbe21f9dedc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M2ZTkyNTU4Yzc0ZDUzOGY2NzkwYTgxMTc4YjhjYmUyMWY5ZGVkYw==", "commit": {"author": {"name": "Jacob Gladish", "email": "gladish@spinnakernet.com", "date": "2003-08-07T01:13:46Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2003-08-07T01:13:46Z"}, "message": "natPlainSocketImplPosix.cc (connect): Pass the FD as a ready-to-write argument to _Jv_Select.\n\n\t* java/net/natPlainSocketImplPosix.cc (connect): Pass the FD as a\n\tready-to-write argument to _Jv_Select. Reset the socket back to\n\tnon-blocking state after connecting.\n\t(accept): Pass the FD as a ready-to-write argument to _Jv_Select.\n\tThrow SocketTimeoutException not InterruptedIOException.\n\t(read): Throw SocketTimeoutException not InterruptedIOException.\n\nCo-Authored-By: Bryce McKinlay <bryce@mckinlay.net.nz>\n\nFrom-SVN: r70217", "tree": {"sha": "0663d033ddf9ad5a8fd25a8dd8f844c58ce3875d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0663d033ddf9ad5a8fd25a8dd8f844c58ce3875d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c6e92558c74d538f6790a81178b8cbe21f9dedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6e92558c74d538f6790a81178b8cbe21f9dedc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c6e92558c74d538f6790a81178b8cbe21f9dedc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6e92558c74d538f6790a81178b8cbe21f9dedc/comments", "author": null, "committer": null, "parents": [{"sha": "6eac0ef54eba75e34876c600199e30d290747b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eac0ef54eba75e34876c600199e30d290747b13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eac0ef54eba75e34876c600199e30d290747b13"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "e773c70c6f04f9f4db973f3f5b0d23a17773e442", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6e92558c74d538f6790a81178b8cbe21f9dedc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6e92558c74d538f6790a81178b8cbe21f9dedc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7c6e92558c74d538f6790a81178b8cbe21f9dedc", "patch": "@@ -1,3 +1,13 @@\n+2003-08-07  Jacob Gladish <gladish@spinnakernet.com>\n+            Bryce McKinlay  <bryce@mckinlay.net.nz>\n+\n+\t* java/net/natPlainSocketImplPosix.cc (connect): Pass the FD as a\n+\tready-to-write argument to _Jv_Select. Reset the socket back to \n+\tnon-blocking state after connecting.\n+\t(accept): Pass the FD as a ready-to-write argument to _Jv_Select.\n+\tThrow SocketTimeoutException not InterruptedIOException.\n+\t(read): Throw SocketTimeoutException not InterruptedIOException.\n+\n 2003-08-07  Bryce McKinlay  <bryce@mckinlay.net.nz>\n \n \t* java/lang/Thread.java (Thread): Check for null \"name\" from"}, {"sha": "f2a71b68a02a8d8109e9412902821c184b1f171b", "filename": "libjava/java/net/natPlainSocketImplPosix.cc", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6e92558c74d538f6790a81178b8cbe21f9dedc/libjava%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6e92558c74d538f6790a81178b8cbe21f9dedc/libjava%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc?ref=7c6e92558c74d538f6790a81178b8cbe21f9dedc", "patch": "@@ -174,19 +174,21 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n       if ((_Jv_connect (fnum, ptr, len) != 0) && (errno != EINPROGRESS))\n         goto error;\n \n-      fd_set rset;\n+      fd_set fset;\n       struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n+      FD_ZERO(&fset);\n+      FD_SET(fnum, &fset);\n       tv.tv_sec = timeout / 1000;\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n       \n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+      if ((retval = _Jv_select (fnum + 1, &fset, &fset, NULL, &tv)) < 0)\n         goto error;\n       else if (retval == 0)\n         throw new java::net::SocketTimeoutException\n           (JvNewStringUTF (\"Connect timed out\"));\n+       // Set the socket back into a blocking state.\n+       ::fcntl (fnum, F_SETFL, flags);\n     }\n   else\n     {\n@@ -233,17 +235,17 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n   // Do timeouts via select since SO_RCVTIMEO is not always available.\n   if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n     {\n-      fd_set rset;\n+      fd_set fset;\n       struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n+      FD_ZERO(&fset);\n+      FD_SET(fnum, &fset);\n       tv.tv_sec = timeout / 1000;\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+      if ((retval = _Jv_select (fnum + 1, &fset, &fset, NULL, &tv)) < 0)\n         goto error;\n       else if (retval == 0)\n-        throw new java::io::InterruptedIOException (\n+        throw new java::net::SocketTimeoutException (\n \t                                  JvNewStringUTF(\"Accept timed out\"));\n     }\n \n@@ -402,7 +404,7 @@ java::net::PlainSocketImpl::read(void)\n       // If select returns 0 we've waited without getting data...\n       // that means we've timed out.\n       if (sel_retval == 0)\n-        throw new java::io::InterruptedIOException\n+        throw new java::net::SocketTimeoutException\n           (JvNewStringUTF (\"read timed out\") );\n       // If select returns ok we know we either got signalled or read some data...\n       // either way we need to try to read.\n@@ -467,11 +469,10 @@ java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n       // the socket to see what happened.\n       if (sel_retval == 0)\n         {\n-          java::io::InterruptedIOException *iioe =\n-            new java::io::InterruptedIOException\n-            (JvNewStringUTF (\"read interrupted\"));\n-          iioe->bytesTransferred = 0;\n-          throw iioe;\n+          java::net::SocketTimeoutException *timeoutException =\n+            new java::net::SocketTimeoutException\n+            (JvNewStringUTF (\"read timed out\"));\n+          throw timeoutException;\n         }\n     }\n "}]}