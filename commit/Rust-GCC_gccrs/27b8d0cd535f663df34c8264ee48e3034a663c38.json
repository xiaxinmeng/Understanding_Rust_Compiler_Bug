{"sha": "27b8d0cd535f663df34c8264ee48e3034a663c38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdiOGQwY2Q1MzVmNjYzZGYzNGM4MjY0ZWU0OGUzMDM0YTY2M2MzOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-07-23T01:01:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-07-23T01:01:16Z"}, "message": "call.c (NEED_TEMPORARY_P): New macro.\n\n\t* call.c (NEED_TEMPORARY_P): New macro.\n\t(standard_conversion): Set it, for derived-to-base conversions.\n\t(reference_related_p): New function.\n\t(reference_compatible_p): Likewise.\n\t(convert_class_to_reference): Likewise.\n\t(direct_reference_binding): Likewise.\n\t(reference_binding): Rework for standards-compliance.\n\t(convert_like): Adjust accordingly.\n\t(maybe_handle_ref_bind): Simplify; the right conversion sequences\n\tare now built up in reference_binding.\n\t(initialize_reference): New function.\n\t* cp-tree.h (ICS_USER_FLAG): Document.\n\t(ICS_THIS_FLAG): Likewise.\n\t(ICS_BAD_FLAG): Likewise.\n\t(NEED_TEMPORARY_P): Likewise.\n\t(cp_lvalue_kind): New type.\n\t(real_lvalue_p): Return it.\n\t* error.c (dump_expr): Provide more accurate representation for\n\tAGGR_INIT_EXPRs.\n\t* init.c (expand_default_init): Do not try to perform implicit\n\tconversions for a brace-enclosed initializer.\n\t* search.c (lookup_conversions): Document.\n\t* tree.c (lvalue_p_1): Return a cp_lvalue_kind.  Calculate\n\tappropriately.\n\t(real_lvalue_p): Adjust accordingly.\n\t(lvalue_p): Likewise.\n\t(build_cplus_new): Don't allow the creation of an abstract class.\n\t* typeck.c (convert_for_initialization): Use initialize_reference.\n\nFrom-SVN: r28221", "tree": {"sha": "7ab5ead2d1ccd9e6e12bd7904bc7fecc99b3fe43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab5ead2d1ccd9e6e12bd7904bc7fecc99b3fe43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27b8d0cd535f663df34c8264ee48e3034a663c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27b8d0cd535f663df34c8264ee48e3034a663c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27b8d0cd535f663df34c8264ee48e3034a663c38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27b8d0cd535f663df34c8264ee48e3034a663c38/comments", "author": null, "committer": null, "parents": [{"sha": "ac1d97ceb67feea6e4e37e14a8bc86c5851574c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1d97ceb67feea6e4e37e14a8bc86c5851574c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1d97ceb67feea6e4e37e14a8bc86c5851574c3"}], "stats": {"total": 664, "additions": 532, "deletions": 132}, "files": [{"sha": "c111a86527961cd295b930eacb78106c59a183b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -1,3 +1,34 @@\n+1999-07-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (NEED_TEMPORARY_P): New macro.\n+\t(standard_conversion): Set it, for derived-to-base conversions.\n+\t(reference_related_p): New function.\n+\t(reference_compatible_p): Likewise.\n+\t(convert_class_to_reference): Likewise.\n+\t(direct_reference_binding): Likewise.\n+\t(reference_binding): Rework for standards-compliance.\n+\t(convert_like): Adjust accordingly.\n+\t(maybe_handle_ref_bind): Simplify; the right conversion sequences\n+\tare now built up in reference_binding.\n+\t(initialize_reference): New function.\n+\t* cp-tree.h (ICS_USER_FLAG): Document.\n+\t(ICS_THIS_FLAG): Likewise.\n+\t(ICS_BAD_FLAG): Likewise.\n+\t(NEED_TEMPORARY_P): Likewise.\n+\t(cp_lvalue_kind): New type.\n+\t(real_lvalue_p): Return it.\n+\t* error.c (dump_expr): Provide more accurate representation for\n+\tAGGR_INIT_EXPRs.\n+\t* init.c (expand_default_init): Do not try to perform implicit\n+\tconversions for a brace-enclosed initializer.\n+\t* search.c (lookup_conversions): Document.\n+\t* tree.c (lvalue_p_1): Return a cp_lvalue_kind.  Calculate\n+\tappropriately.\n+\t(real_lvalue_p): Adjust accordingly.\n+\t(lvalue_p): Likewise.\n+\t(build_cplus_new): Don't allow the creation of an abstract class.\n+\t* typeck.c (convert_for_initialization): Use initialize_reference.\n+\t\n 1999-07-21  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* lex.c (real_yylex) : Correct the test for overflow when lexing"}, {"sha": "22f30dcc46b2e682e89bb67c40244402fb23e07d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 381, "deletions": 83, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -92,6 +92,10 @@ static struct z_candidate * add_candidate PROTO((struct z_candidate *,\n \t\t\t\t\t\t tree, tree, int));\n static tree source_type PROTO((tree));\n static void add_warning PROTO((struct z_candidate *, struct z_candidate *));\n+static int reference_related_p PROTO ((tree, tree));\n+static int reference_compatible_p PROTO ((tree, tree));\n+static tree convert_class_to_reference PROTO ((tree, tree, tree));\n+static tree direct_reference_binding PROTO ((tree, tree));\n \n tree\n build_vfield_ref (datum, type)\n@@ -534,6 +538,10 @@ struct z_candidate {\n #define ICS_THIS_FLAG(NODE) TREE_LANG_FLAG_2 (NODE)\n #define ICS_BAD_FLAG(NODE) TREE_LANG_FLAG_3 (NODE)\n \n+/* In a REF_BIND or a BASE_CONV, this indicates that a temporary\n+   should be created to hold the result of the conversion.  */\n+#define NEED_TEMPORARY_P(NODE) (TREE_LANG_FLAG_4 ((NODE)))\n+\n #define USER_CONV_CAND(NODE) \\\n   ((struct z_candidate *)WRAPPER_PTR (TREE_OPERAND (NODE, 1)))\n #define USER_CONV_FN(NODE) (USER_CONV_CAND (NODE)->fn)\n@@ -767,13 +775,209 @@ standard_conversion (to, from, expr)\n       if (TREE_CODE (conv) == RVALUE_CONV)\n \tconv = TREE_OPERAND (conv, 0);\n       conv = build_conv (BASE_CONV, to, conv);\n+      /* The derived-to-base conversion indicates the initialization\n+\t of a parameter with base type from an object of a derived\n+\t type.  A temporary object is created to hold the result of\n+\t the conversion.  */\n+      NEED_TEMPORARY_P (conv) = 1;\n     }\n   else\n     return 0;\n \n   return conv;\n }\n \n+/* Returns non-zero if T1 is reference-related to T2.  */\n+\n+static int\n+reference_related_p (t1, t2)\n+     tree t1;\n+     tree t2;\n+{\n+  t1 = TYPE_MAIN_VARIANT (t1);\n+  t2 = TYPE_MAIN_VARIANT (t2);\n+\n+  /* [dcl.init.ref]\n+\n+     Given types \"cv1 T1\" and \"cv2 T2,\" \"cv1 T1\" is reference-related\n+     to \"cv2 T2\" if T1 is the same type as T2, or T1 is a base class\n+     of T2.  */\n+  return (same_type_p (t1, t2)\n+\t  || (CLASS_TYPE_P (t1) && CLASS_TYPE_P (t2)\n+\t      && DERIVED_FROM_P (t1, t2)));\n+}\n+\n+/* Returns non-zero if T1 is reference-compatible with T2.  */\n+\n+static int\n+reference_compatible_p (t1, t2)\n+     tree t1;\n+     tree t2;\n+{\n+  /* [dcl.init.ref]\n+\n+     \"cv1 T1\" is reference compatible with \"cv2 T2\" if T1 is\n+     reference-related to T2 and cv1 is the same cv-qualification as,\n+     or greater cv-qualification than, cv2.  */\n+  return (reference_related_p (t1, t2)\n+\t  && at_least_as_qualified_p (t1, t2));\n+}\n+\n+/* Determine whether or not the EXPR (of class type S) can be\n+   converted to T as in [over.match.ref].  */\n+\n+static tree\n+convert_class_to_reference (t, s, expr)\n+     tree t;\n+     tree s;\n+     tree expr;\n+{\n+  tree conversions;\n+  tree arglist;\n+  tree conv;\n+  struct z_candidate *candidates;\n+  struct z_candidate *cand;\n+\n+  /* [over.match.ref]\n+\n+     Assuming that \"cv1 T\" is the underlying type of the reference\n+     being initialized, and \"cv S\" is the type of the initializer\n+     expression, with S a class type, the candidate functions are\n+     selected as follows:\n+\n+     --The conversion functions of S and its base classes are\n+       considered.  Those that are not hidden within S and yield type\n+       \"reference to cv2 T2\", where \"cv1 T\" is reference-compatible\n+       (_dcl.init.ref_) with \"cv2 T2\", are candidate functions.\n+\n+     The argument list has one argument, which is the initializer\n+     expression.  */\n+\n+  candidates = 0;\n+\n+  /* Conceptually, we should take the address of EXPR and put it in\n+     the argument list.  Unfortunately, however, that can result in\n+     error messages, which we should not issue now because we are just\n+     trying to find a conversion operator.  Therefore, we use NULL,\n+     cast to the appropriate type.  */\n+  arglist = build_int_2 (0, 0);\n+  TREE_TYPE (arglist) = build_pointer_type (s);\n+  arglist = build_scratch_list (NULL_TREE, arglist);\n+  \n+  for (conversions = lookup_conversions (s);\n+       conversions;\n+       conversions = TREE_CHAIN (conversions))\n+    {\n+      tree fns = TREE_VALUE (conversions);\n+\n+      while (fns)\n+\t{\n+\t  tree f = OVL_CURRENT (fns);\n+\t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n+\t  struct z_candidate *old_candidates = candidates;\n+\n+\t  /* If this is a template function, try to get an exact\n+             match.  */\n+\t  if (TREE_CODE (f) == TEMPLATE_DECL)\n+\t    {\n+\t      candidates \n+\t\t= add_template_candidate (candidates,\n+\t\t\t\t\t  f,\n+\t\t\t\t\t  NULL_TREE,\n+\t\t\t\t\t  arglist,\n+\t\t\t\t\t  build_reference_type (t),\n+\t\t\t\t\t  LOOKUP_NORMAL,\n+\t\t\t\t\t  DEDUCE_CONV);\n+\t      \n+\t      if (candidates != old_candidates)\n+\t\t{\n+\t\t  /* Now, see if the conversion function really returns\n+\t\t     an lvalue of the appropriate type.  From the\n+\t\t     point of view of unification, simply returning an\n+\t\t     rvalue of the right type is good enough.  */\n+\t\t  f = candidates->fn;\n+\t\t  t2 = TREE_TYPE (TREE_TYPE (f));\n+\t\t  if (TREE_CODE (t2) != REFERENCE_TYPE\n+\t\t      || !reference_compatible_p (t, TREE_TYPE (t2)))\n+\t\t    candidates = candidates->next;\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (t2) == REFERENCE_TYPE\n+\t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n+\t    candidates \n+\t      = add_function_candidate (candidates, f, arglist, \n+\t\t\t\t\tLOOKUP_NORMAL);\n+\n+\t  if (candidates != old_candidates)\n+\t    candidates->basetype_path = TREE_PURPOSE (conversions);\n+\n+\t  fns = OVL_NEXT (fns);\n+\t}\n+    }\n+\n+  /* If none of the conversion functions worked out, let our caller\n+     know.  */\n+  if (!any_viable (candidates))\n+    return NULL_TREE;\n+  \n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates);\n+  if (!cand)\n+    return NULL_TREE;\n+\n+  conv = build_conv (IDENTITY_CONV, s, expr);\n+  conv = build_conv (USER_CONV,\n+\t\t     non_reference (TREE_TYPE (TREE_TYPE (cand->fn))),\n+\t\t     expr);\n+  TREE_OPERAND (conv, 1) = build_expr_ptr_wrapper (cand);\n+  ICS_USER_FLAG (conv) = 1;\n+  if (cand->viable == -1)\n+    ICS_BAD_FLAG (conv) = 1;\n+  cand->second_conv = conv;\n+\n+  return conv;\n+}\n+\n+/* A reference of the indicated TYPE is being bound directly to the\n+   expression represented by the implicit conversion sequence CONV.\n+   Return a conversion sequence for this binding.  */\n+\n+static tree\n+direct_reference_binding (type, conv)\n+     tree type;\n+     tree conv;\n+{\n+  tree t = TREE_TYPE (type);\n+\n+  /* [over.ics.rank] \n+     \n+     When a parameter of reference type binds directly\n+     (_dcl.init.ref_) to an argument expression, the implicit\n+     conversion sequence is the identity conversion, unless the\n+     argument expression has a type that is a derived class of the\n+     parameter type, in which case the implicit conversion sequence is\n+     a derived-to-base Conversion.\n+\t \n+     If the parameter binds directly to the result of applying a\n+     conversion function to the argument expression, the implicit\n+     conversion sequence is a user-defined conversion sequence\n+     (_over.ics.user_), with the second standard conversion sequence\n+     either an identity conversion or, if the conversion function\n+     returns an entity of a type that is a derived class of the\n+     parameter type, a derived-to-base conversion.  */\n+  if (!same_type_p (TYPE_MAIN_VARIANT (t),\n+\t\t    TYPE_MAIN_VARIANT (TREE_TYPE (conv))))\n+    {\n+      /* Represent the derived-to-base conversion.  */\n+      conv = build_conv (BASE_CONV, t, conv);\n+      /* We will actually be binding to the base-class subobject in\n+\t the derived class, so we mark this conversion appropriately.\n+\t That way, convert_like knows not to generate a temporary.  */\n+      NEED_TEMPORARY_P (conv) = 0;\n+    }\n+  return build_conv (REF_BIND, type, conv);\n+}\n+\n /* Returns the conversion path from type FROM to reference type TO for\n    purposes of reference binding.  For lvalue binding, either pass a\n    reference type to FROM or an lvalue expression to EXPR.\n@@ -786,11 +990,12 @@ reference_binding (rto, rfrom, expr, flags)\n      tree rto, rfrom, expr;\n      int flags;\n {\n-  tree conv;\n-  int lvalue = 1;\n+  tree conv = NULL_TREE;\n   tree to = TREE_TYPE (rto);\n   tree from = rfrom;\n-  int related;\n+  int related_p;\n+  int compatible_p;\n+  cp_lvalue_kind lvalue_p = clk_none;\n \n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n     {\n@@ -800,54 +1005,123 @@ reference_binding (rto, rfrom, expr, flags)\n       from = TREE_TYPE (expr);\n     }\n \n-  if (TREE_CODE (from) == REFERENCE_TYPE)\n-    from = TREE_TYPE (from);\n-  else if (! expr || ! real_lvalue_p (expr))\n-    lvalue = 0;\n+  related_p = reference_related_p (to, from);\n+  compatible_p = reference_compatible_p (to, from);\n \n-  related = (same_type_p (TYPE_MAIN_VARIANT (to),\n-\t\t\t  TYPE_MAIN_VARIANT (from))\n-\t     || (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n-\t\t && DERIVED_FROM_P (to, from)));\n+  if (TREE_CODE (from) == REFERENCE_TYPE)\n+    {\n+      /* Anything with reference type is an lvalue.  */\n+      lvalue_p = clk_ordinary;\n+      from = TREE_TYPE (from);\n+    }\n+  else if (expr)\n+    lvalue_p = real_lvalue_p (expr);\n \n-  if (lvalue && related && at_least_as_qualified_p (to, from))\n+  if (lvalue_p && compatible_p)\n     {\n-      conv = build1 (IDENTITY_CONV, from, expr);\n+      /* [dcl.init.ref]\n \n-      if (same_type_p (TYPE_MAIN_VARIANT (to),\n-\t\t       TYPE_MAIN_VARIANT (from)))\n-\tconv = build_conv (REF_BIND, rto, conv);\n-      else\n-\t{\n-\t  conv = build_conv (REF_BIND, rto, conv);\n-\t  ICS_STD_RANK (conv) = STD_RANK;\n-\t}\n+\t If the intializer expression \n+\t \n+\t -- is an lvalue (but not an lvalue for a bit-field), and \"cv1 T1\"\n+\t    is reference-compatible with \"cv2 T2,\"\n+\t \n+\t the reference is bound directly to the initializer exprssion\n+\t lvalue.  */\n+      conv = build1 (IDENTITY_CONV, from, expr);\n+      conv = direct_reference_binding (rto, conv);\n+      if ((lvalue_p & clk_bitfield) != 0 \n+\t  && CP_TYPE_CONST_NON_VOLATILE_P (to))\n+\t/* For the purposes of overload resolution, we ignore the fact\n+\t   this expression is a bitfield. (In particular,\n+\t   [over.ics.ref] says specifically that a function with a\n+\t   non-const reference parameter is viable even if the\n+\t   argument is a bitfield.)\n+\n+\t   However, when we actually call the function we must create\n+\t   a temporary to which to bind the reference.  If the\n+\t   reference is volatile, or isn't const, then we cannot make\n+\t   a temporary, so we just issue an error when the conversion\n+\t   actually occurs.  */\n+\tNEED_TEMPORARY_P (conv) = 1;\n+      return conv;\n     }\n-  else\n-    conv = NULL_TREE;\n-\n-  if (! conv)\n+  else if (CLASS_TYPE_P (from) && !(flags & LOOKUP_NO_CONVERSION))\n     {\n-      conv = standard_conversion (to, rfrom, expr);\n+      /* [dcl.init.ref]\n+\n+\t If the initializer exprsesion\n+\n+\t -- has a class type (i.e., T2 is a class type) can be\n+\t    implicitly converted to an lvalue of type \"cv3 T3,\" where\n+\t    \"cv1 T1\" is reference-compatible with \"cv3 T3\".  (this\n+\t    conversion is selected by enumerating the applicable\n+\t    conversion functions (_over.match.ref_) and choosing the\n+\t    best one through overload resolution.  (_over.match_). \n+\n+        the reference is bound to the lvalue result of the conversion\n+\tin the second case.  */\n+      conv = convert_class_to_reference (to, from, expr);\n       if (conv)\n-\t{\n-\t  conv = build_conv (REF_BIND, rto, conv);\n+\treturn direct_reference_binding (rto, conv);\n+    }\n \n-\t  /* Bind directly to a base subobject of a class rvalue.  Do it\n-             after building the conversion for proper handling of ICS_RANK.  */\n-\t  if (TREE_CODE (TREE_OPERAND (conv, 0)) == BASE_CONV)\n-\t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n-\t}\n-      if (conv\n-\t  && ((! (CP_TYPE_CONST_NON_VOLATILE_P (to)\n-\t\t  && (flags & LOOKUP_NO_TEMP_BIND) == 0))\n-\t      /* If T1 is reference-related to T2, cv1 must be the same\n-\t\t cv-qualification as, or greater cv-qualification than,\n-\t\t cv2; otherwise, the program is ill-formed.  */\n-\t      || (related && !at_least_as_qualified_p (to, from))))\n-\tICS_BAD_FLAG (conv) = 1;\n+  /* [over.ics.rank]\n+     \n+     When a parameter of reference type is not bound directly to an\n+     argument expression, the conversion sequence is the one required\n+     to convert the argument expression to the underlying type of the\n+     reference according to _over.best.ics_.  Conceptually, this\n+     conversion sequence corresponds to copy-initializing a temporary\n+     of the underlying type with the argument expression.  Any\n+     difference in top-level cv-qualification is subsumed by the\n+     initialization itself and does not constitute a conversion.  */\n+\n+  /* [dcl.init.ref]\n+\n+     Otherwise, the reference shall be to a non-volatile const type.  */\n+  if (!CP_TYPE_CONST_NON_VOLATILE_P (to))\n+    return NULL_TREE;\n+\n+  /* [dcl.init.ref]\n+     \n+     If the initializer expression is an rvalue, with T2 a class type,\n+     and \"cv1 T1\" is reference-compatible with \"cv2 T2\", the reference\n+     is bound in one of the following ways:\n+     \n+     -- The reference is bound to the object represented by the rvalue\n+        or to a sub-object within that object.  \n+\n+     In this case, the implicit conversion sequence is supposed to be\n+     same as we would obtain by generating a temporary.  Fortunately,\n+     if the types are reference compatible, then this is either an\n+     identity conversion or the derived-to-base conversion, just as\n+     for direct binding.  */\n+  if (CLASS_TYPE_P (from) && compatible_p)\n+    {\n+      conv = build1 (IDENTITY_CONV, from, expr);\n+      return direct_reference_binding (rto, conv);\n     }\n \n+  /* [dcl.init.ref]\n+\n+     Otherwise, a temporary of type \"cv1 T1\" is created and\n+     initialized from the initializer expression using the rules for a\n+     non-reference copy initialization.  If T1 is reference-related to\n+     T2, cv1 must be the same cv-qualification as, or greater\n+     cv-qualification than, cv2; otherwise, the program is ill-formed.  */\n+  if (related_p && !at_least_as_qualified_p (to, from))\n+    return NULL_TREE;\n+\n+  conv = implicit_conversion (to, from, expr, flags);\n+  if (!conv)\n+    return NULL_TREE;\n+\n+  conv = build_conv (REF_BIND, rto, conv);\n+  /* This reference binding, unlike those above, requires the\n+     creation of a temporary.  */\n+  NEED_TEMPORARY_P (conv) = 1;\n+\n   return conv;\n }\n \n@@ -2885,7 +3159,8 @@ convert_like (convs, expr)\n {\n   if (ICS_BAD_FLAG (convs)\n       && TREE_CODE (convs) != USER_CONV\n-      && TREE_CODE (convs) != AMBIG_CONV)\n+      && TREE_CODE (convs) != AMBIG_CONV\n+      && TREE_CODE (convs) != REF_BIND)\n     {\n       tree t = convs; \n       for (; t; t = TREE_OPERAND (t, 0))\n@@ -2938,8 +3213,6 @@ convert_like (convs, expr)\n     case IDENTITY_CONV:\n       if (type_unknown_p (expr))\n \texpr = instantiate_type (TREE_TYPE (convs), expr, 1);\n-      if (TREE_READONLY_DECL_P (expr))\n-\texpr = decl_constant_value (expr);\n       return expr;\n     case AMBIG_CONV:\n       /* Call build_user_type_conversion again for the error.  */\n@@ -2954,13 +3227,25 @@ convert_like (convs, expr)\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n+  /* Convert a constant variable to its underlying value, unless we\n+     are about to bind it to a reference, in which case we need to\n+     leave it as an lvalue.  */\n+  if (TREE_READONLY_DECL_P (expr) && TREE_CODE (convs) != REF_BIND)\n+    expr = decl_constant_value (expr);\n+\n   switch (TREE_CODE (convs))\n     {\n     case RVALUE_CONV:\n       if (! IS_AGGR_TYPE (TREE_TYPE (convs)))\n \treturn expr;\n       /* else fall through */\n     case BASE_CONV:\n+      if (TREE_CODE (convs) == BASE_CONV\n+\t  && !NEED_TEMPORARY_P (convs))\n+\t/* We are going to bind a reference directly to a base-class\n+\t   subobject of EXPR.  We don't have to generate any code\n+\t   here.  */\n+\treturn expr;\n       {\n \ttree cvt_expr = build_user_type_conversion\n \t  (TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n@@ -2988,10 +3273,37 @@ convert_like (convs, expr)\n       }\n \n     case REF_BIND:\n-      return convert_to_reference\n-\t(TREE_TYPE (convs), expr,\n-\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION,\n-\t error_mark_node);\n+      {\n+\ttree ref_type = TREE_TYPE (convs);\n+\n+\t/* If necessary, create a temporary.  */\n+\tif (NEED_TEMPORARY_P (convs))\n+\t  {\n+\t    tree type = TREE_TYPE (TREE_OPERAND (convs, 0));\n+\t    tree slot = build_decl (VAR_DECL, NULL_TREE, type);\n+\t    DECL_ARTIFICIAL (slot) = 1;\n+\t    expr = build (TARGET_EXPR, type, slot, expr,\n+\t\t\t  NULL_TREE, NULL_TREE);\n+\t    TREE_SIDE_EFFECTS (expr) = 1;\n+\t  }\n+\n+\t/* Take the address of the thing to which we will bind the\n+\t   reference.  */\n+\texpr = build_unary_op (ADDR_EXPR, expr, 1);\n+\tif (expr == error_mark_node)\n+\t  return error_mark_node;\n+\n+\t/* Convert it to a pointer to the type referred to by the\n+\t   reference.  This will adjust the pointer if a derived to\n+\t   base conversion is being performed.  */\n+\texpr = cp_convert (build_pointer_type (TREE_TYPE (ref_type)), \n+\t\t\t   expr);\n+\t/* Convert the pointer to the desired reference type.  */\n+\texpr = build1 (NOP_EXPR, ref_type, expr);\n+\n+\treturn expr;\n+      }\n+\n     case LVALUE_CONV:\n       return decay_conversion (expr);\n \n@@ -3687,43 +3999,8 @@ maybe_handle_ref_bind (ics, target_type)\n {\n   if (TREE_CODE (*ics) == REF_BIND)\n     {\n-      /* [over.ics.rank] \n-\t \n-\t When a parameter of reference type binds directly\n-\t (_dcl.init.ref_) to an argument expression, the implicit\n-\t conversion sequence is the identity conversion, unless the\n-\t argument expression has a type that is a derived class of the\n-\t parameter type, in which case the implicit conversion\n-\t sequence is a derived-to-base Conversion.\n-\t \n-\t If the parameter binds directly to the result of applying a\n-\t conversion function to the argument expression, the implicit\n-\t conversion sequence is a user-defined conversion sequence\n-\t (_over.ics.user_), with the second standard conversion\n-\t sequence either an identity conversion or, if the conversion\n-\t function returns an entity of a type that is a derived class\n-\t of the parameter type, a derived-to-base Conversion.\n-\t \n-\t When a parameter of reference type is not bound directly to\n-\t an argument expression, the conversion sequence is the one\n-\t required to convert the argument expression to the underlying\n-\t type of the reference according to _over.best.ics_.\n-\t Conceptually, this conversion sequence corresponds to\n-\t copy-initializing a temporary of the underlying type with the\n-\t argument expression.  Any difference in top-level\n-\t cv-qualification is subsumed by the initialization itself and\n-\t does not constitute a conversion.  */\n-\n-      tree old_ics = *ics;\n-\n       *target_type = TREE_TYPE (TREE_TYPE (*ics));\n       *ics = TREE_OPERAND (*ics, 0);\n-      if (TREE_CODE (*ics) == IDENTITY_CONV\n-\t  && is_properly_derived_from (TREE_TYPE (*ics), *target_type))\n-\t*ics = build_conv (BASE_CONV, *target_type, *ics);\n-      ICS_USER_FLAG (*ics) = ICS_USER_FLAG (old_ics);\n-      ICS_BAD_FLAG (*ics) = ICS_BAD_FLAG (old_ics);\n-      \n       return 1;\n     }\n   \n@@ -4386,3 +4663,24 @@ can_convert_arg (to, from, arg)\n   tree t = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n   return (t && ! ICS_BAD_FLAG (t));\n }\n+\n+/* Convert EXPR to the indicated reference TYPE, in a way suitable for\n+   initializing a variable of that TYPE.  Return the converted\n+   expression.  */\n+\n+tree\n+initialize_reference (type, expr)\n+     tree type;\n+     tree expr;\n+{\n+  tree conv;\n+\n+  conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL);\n+  if (!conv || ICS_BAD_FLAG (conv))\n+    {\n+      cp_error (\"could not convert `%E' to `%T'\", expr, type);\n+      return error_mark_node;\n+    }\n+\n+  return convert_like (conv, expr);\n+}"}, {"sha": "50d28ca9f1d7f8f3ebcd2a38fd4c03518a775c2c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02111-1307, USA.  */\n       TREE_INDIRECT_USING (in NAMESPACE_DECL).\n       IDENTIFIER_MARKED (used by search routines).\n       LOCAL_BINDING_P (in CPLUS_BINDING)\n+      ICS_USER_FLAG (in _CONV)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -43,17 +44,21 @@ Boston, MA 02111-1307, USA.  */\n       C_DECLARED_LABEL_FLAG.\n       INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n       BASELINK_P (in TREE_LIST)\n+      ICS_ELLIPSIS_FLAG (in _CONV)\n    2: IDENTIFIER_OPNAME_P.\n       BINFO_VBASE_MARKED.\n       BINFO_FIELDS_MARKED.\n       TYPE_VIRTUAL_P.\n+      ICS_THIS_FLAG (in _CONV)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n       BINFO_PUSHDECLS_MARKED.\n       (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n+      ICS_BAD_FLAG (in _CONV)\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n+      NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n    5: Not used.\n    6: Not used.\n \n@@ -2140,6 +2145,14 @@ extern int flag_new_for_scope;\n enum tag_types { record_type, class_type, union_type, enum_type,\n \t\t   signature_type };\n \n+/* The various kinds of lvalues we distinguish.  */\n+typedef enum cp_lvalue_kind {\n+  clk_none = 0,     /* Things that are not an lvalue.  */\n+  clk_ordinary = 1, /* An ordinary lvalue.  */\n+  clk_class = 2,    /* An rvalue of class-type.  */\n+  clk_bitfield = 4, /* An lvalue for a bit-field.  */\n+} cp_lvalue_kind;\n+\n /* Zero means prototype weakly, as in ANSI C (no args means nothing).\n    Each language context defines how this variable should be set.  */\n extern int strict_prototype;\n@@ -2753,6 +2766,7 @@ extern int enforce_access                       PROTO((tree, tree));\n extern tree convert_default_arg                 PROTO((tree, tree, tree));\n extern tree convert_arg_to_ellipsis             PROTO((tree));\n extern int is_properly_derived_from             PROTO((tree, tree));\n+extern tree initialize_reference                PROTO((tree, tree));\n \n /* in class.c */\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n@@ -3363,7 +3377,7 @@ extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n extern int pod_type_p\t\t\t\tPROTO((tree));\n extern void unshare_base_binfos\t\t\tPROTO((tree));\n extern int member_p\t\t\t\tPROTO((tree));\n-extern int real_lvalue_p\t\t\tPROTO((tree));\n+extern cp_lvalue_kind real_lvalue_p\t\tPROTO((tree));\n extern tree build_min\t\t\t\tPVPROTO((enum tree_code, tree, ...));\n extern tree build_min_nt\t\t\tPVPROTO((enum tree_code, ...));\n extern tree min_tree_cons\t\t\tPROTO((tree, tree, tree));"}, {"sha": "60d73de03ea6b70dd8db9850522df7ba4bfaa9cf", "filename": "gcc/cp/error.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -1409,7 +1409,22 @@ dump_expr (t, nop)\n       break;\n \n     case AGGR_INIT_EXPR:\n-      OB_PUTID (TYPE_IDENTIFIER (TREE_TYPE (t)));\n+      {\n+\ttree fn = NULL_TREE;\n+\t\n+\tif (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n+\t  fn = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\n+\tif (fn && TREE_CODE (fn) == FUNCTION_DECL)\n+\t  {\n+\t    if (DECL_CONSTRUCTOR_P (fn))\n+\t      OB_PUTID (TYPE_IDENTIFIER (TREE_TYPE (t)));\n+\t    else\n+\t      dump_decl (fn, 0);\n+\t  }\n+\telse\n+\t  dump_expr (TREE_OPERAND (t, 0), 0);\n+      }\n       OB_PUTC ('(');\n       if (TREE_OPERAND (t, 1))\n \tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));"}, {"sha": "8469fe6ab1bca9c085d3d6a5a3bb6d90a36aeea1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -1177,6 +1177,10 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n \t   to run a new constructor; and catching an exception, where we\n \t   have already built up the constructor call so we could wrap it\n \t   in an exception region.  */;\n+      else if (TREE_CODE (init) == CONSTRUCTOR)\n+\t/* A brace-enclosed initializer has whatever type is\n+\t   required.  There's no need to convert it.  */\n+\t;\n       else\n \tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n "}, {"sha": "6cde6905c12910de95f9f613b83c25c65cb0a90a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -3150,6 +3150,12 @@ add_conversions (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Return a TREE_LIST containing all the non-hidden user-defined\n+   conversion functions for TYPE (and its base-classes).  The\n+   TREE_VALUE of each node is a FUNCTION_DECL or an OVERLOAD\n+   containing the conversion functions.  The TREE_PURPOSE is the BINFO\n+   from which the conversion functions in this node were selected.  */\n+\n tree\n lookup_conversions (type)\n      tree type;"}, {"sha": "c32bf8f399e853c85e753546d5caafc8d16971e5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 78, "deletions": 42, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -36,35 +36,37 @@ static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, tree, tree, tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static int avoid_overlap PROTO((tree, tree));\n-static int lvalue_p_1 PROTO((tree, int));\n+static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n static int equal_functions PROTO((tree, tree));\n static tree no_linkage_helper PROTO((tree));\n static tree build_srcloc PROTO((char *, int));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n-/* Returns non-zero if REF is an lvalue.  If\n-   TREAT_CLASS_RVALUES_AS_LVALUES is non-zero, rvalues of class type\n-   are considered lvalues.  */\n+/* If REF is an lvalue, returns the kind of lvalue that REF is.\n+   Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n+   non-zero, rvalues of class type are considered lvalues.  */\n \n-static int\n+static cp_lvalue_kind\n lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n      tree ref;\n      int treat_class_rvalues_as_lvalues;\n {\n+  cp_lvalue_kind op1_lvalue_kind = clk_none;\n+  cp_lvalue_kind op2_lvalue_kind = clk_none;\n+\n   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n-    return 1;\n+    return clk_ordinary;\n \n   if (ref == current_class_ptr && flag_this_is_variable <= 0)\n-    return 0;\n+    return clk_none;\n \n   switch (TREE_CODE (ref))\n     {\n       /* preincrements and predecrements are valid lvals, provided\n \t what they refer to are valid lvals.  */\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n-    case COMPONENT_REF:\n     case SAVE_EXPR:\n     case UNSAVE_EXPR:\n     case TRY_CATCH_EXPR:\n@@ -75,93 +77,122 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n       return lvalue_p_1 (TREE_OPERAND (ref, 0),\n \t\t\t treat_class_rvalues_as_lvalues);\n \n+    case COMPONENT_REF:\n+      op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n+      if (op1_lvalue_kind \n+\t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n+\t     situations.  */\n+\t  && TREE_CODE (TREE_OPERAND (ref, 1)) == FIELD_DECL\n+\t  && DECL_BIT_FIELD (TREE_OPERAND (ref, 1)))\n+\t{\n+\t  /* Clear the ordinary bit.  If this object was a class\n+\t     rvalue we want to preserve that information.  */\n+\t  op1_lvalue_kind &= ~clk_ordinary;\n+\t  /* The lvalue is for a btifield.  */\n+\t  op1_lvalue_kind |= clk_bitfield;\n+\t}\n+      return op1_lvalue_kind;\n+\n     case STRING_CST:\n-      return 1;\n+      return clk_ordinary;\n \n     case VAR_DECL:\n       if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n \t  && DECL_LANG_SPECIFIC (ref)\n \t  && DECL_IN_AGGR_P (ref))\n-\treturn 0;\n+\treturn clk_none;\n     case INDIRECT_REF:\n     case ARRAY_REF:\n     case PARM_DECL:\n     case RESULT_DECL:\n       if (TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n-\treturn 1;\n+\treturn clk_ordinary;\n       break;\n \n       /* A currently unresolved scope ref.  */\n     case SCOPE_REF:\n       my_friendly_abort (103);\n     case OFFSET_REF:\n       if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n-\treturn 1;\n-      return (lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t  treat_class_rvalues_as_lvalues)\n-\t      && lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t     treat_class_rvalues_as_lvalues));\n+\treturn clk_ordinary;\n+      /* Fall through.  */\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n+      op2_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n       break;\n \n     case COND_EXPR:\n-      return (lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t  treat_class_rvalues_as_lvalues)\n-\t      && lvalue_p_1 (TREE_OPERAND (ref, 2),\n-\t\t\t     treat_class_rvalues_as_lvalues));\n+      op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n+      op2_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 2),\n+\t\t\t\t    treat_class_rvalues_as_lvalues);\n+      break;\n \n     case MODIFY_EXPR:\n-      return 1;\n+      return clk_ordinary;\n \n     case COMPOUND_EXPR:\n       return lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t    treat_class_rvalues_as_lvalues);\n-\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-      return (lvalue_p_1 (TREE_OPERAND (ref, 0),\n-\t\t\t  treat_class_rvalues_as_lvalues)\n-\t      && lvalue_p_1 (TREE_OPERAND (ref, 1),\n-\t\t\t     treat_class_rvalues_as_lvalues));\n+\t\t\t treat_class_rvalues_as_lvalues);\n \n     case TARGET_EXPR:\n-      return treat_class_rvalues_as_lvalues;\n+      return treat_class_rvalues_as_lvalues ? clk_class : clk_none;\n \n     case CALL_EXPR:\n-      return (treat_class_rvalues_as_lvalues\n-\t      && IS_AGGR_TYPE (TREE_TYPE (ref)));\n+      return ((treat_class_rvalues_as_lvalues\n+\t       && IS_AGGR_TYPE (TREE_TYPE (ref)))\n+\t      ? clk_class : clk_none);\n \n     case FUNCTION_DECL:\n       /* All functions (except non-static-member functions) are\n \t lvalues.  */\n-      return !DECL_NONSTATIC_MEMBER_FUNCTION_P (ref);\n+      return (DECL_NONSTATIC_MEMBER_FUNCTION_P (ref) \n+\t      ? clk_none : clk_ordinary);\n \n     default:\n       break;\n     }\n \n-  return 0;\n+  /* If one operand is not an lvalue at all, then this expression is\n+     not an lvalue.  */\n+  if (!op1_lvalue_kind || !op2_lvalue_kind)\n+    return clk_none;\n+\n+  /* Otherwise, it's an lvalue, and it has all the odd properties\n+     contributed by either operand.  */\n+  op1_lvalue_kind = op1_lvalue_kind | op2_lvalue_kind;\n+  /* It's not an ordinary lvalue if it involves either a bit-field or\n+     a class rvalue.  */\n+  if ((op1_lvalue_kind & ~clk_ordinary) != clk_none)\n+    op1_lvalue_kind &= ~clk_ordinary;\n+  return op1_lvalue_kind;\n }\n \n-/* Return nonzero if REF is an lvalue valid for this language.\n-   Lvalues can be assigned, unless they have TREE_READONLY, or unless\n-   they are FUNCTION_DECLs.  Lvalues can have their address taken,\n-   unless they have DECL_REGISTER.  */\n+/* If REF is an lvalue, returns the kind of lvalue that REF is.\n+   Otherwise, returns clk_none.  Lvalues can be assigned, unless they\n+   have TREE_READONLY, or unless they are FUNCTION_DECLs.  Lvalues can\n+   have their address taken, unless they have DECL_REGISTER.  */\n \n-int\n+cp_lvalue_kind\n real_lvalue_p (ref)\n      tree ref;\n {\n   return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/0);\n }\n \n-/* This differs from real_lvalue_p in that class rvalues are considered\n-   lvalues.  */\n+/* This differs from real_lvalue_p in that class rvalues are\n+   considered lvalues.  */\n \n int\n lvalue_p (ref)\n      tree ref;\n {\n-  return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/1);\n+  return \n+    (lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/1) != clk_none);\n }\n \n /* Return nonzero if REF is an lvalue valid for this language;\n@@ -193,6 +224,11 @@ build_cplus_new (type, init)\n   tree slot;\n   tree rval;\n \n+  /* Make sure that we're not trying to create an instance of an\n+     abstract class.  */\n+  if (CLASSTYPE_ABSTRACT_VIRTUALS (type))\n+    abstract_virtuals_error (NULL_TREE, type);\n+\n   if (TREE_CODE (init) != CALL_EXPR && TREE_CODE (init) != AGGR_INIT_EXPR)\n     return convert (type, init);\n "}, {"sha": "7add55044596c71339f703454d6fd0a6406b7cf1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -7122,8 +7122,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \n       if (fndecl)\n \tsavew = warningcount, savee = errorcount;\n-      rhs = convert_to_reference (type, rhs, CONV_IMPLICIT, flags,\n-\t\t\t\t  exp ? exp : error_mark_node);\n+      rhs = initialize_reference (type, rhs);\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)"}, {"sha": "07f1021e2b51a4cd4c951ac4b522a5e6acd74288", "filename": "gcc/testsuite/g++.old-deja/g++.other/bitfld1.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbitfld1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbitfld1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbitfld1.C?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -1,8 +1,6 @@\n // Build don't link:\n // Based on a bug report by Stephen Vavasis <vavasis@CS.Cornell.EDU>\n \n-// excess errors test - XFAIL *-*-*\n-\n // declares template operator!=\n #include <utility>\n "}, {"sha": "f8dba7b47416f210325e5c49d33c47ff6fb8712e", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb76.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb76.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27b8d0cd535f663df34c8264ee48e3034a663c38/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb76.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb76.C?ref=27b8d0cd535f663df34c8264ee48e3034a663c38", "patch": "@@ -1,6 +1,5 @@\n //Build don't link:\n // the template operator!= interferes.  It should be in a namespace.\n-// excess errors test - XFAIL *-*-*\n \n #include <utility>\n "}]}