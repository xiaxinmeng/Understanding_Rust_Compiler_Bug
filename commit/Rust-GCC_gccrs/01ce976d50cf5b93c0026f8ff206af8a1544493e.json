{"sha": "01ce976d50cf5b93c0026f8ff206af8a1544493e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjZTk3NmQ1MGNmNWI5M2MwMDI2ZjhmZjIwNmFmOGExNTQ0NDkzZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-05-24T14:17:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-05-24T14:17:27Z"}, "message": "Update new-abi upcast algorithm.\n\n\t* inc/cxxabi.h (__class_type_info::__do_upcast): Change\n\tprototype and meaning of return value.\n\t(__si_class_type_info::__do_upcast): Likewise.\n\t(__vmi_class_type_info::__do_upcast): Likewise.\n\t* tinfo.cc (__class_type_info::__upcast_result): Replace\n\twhole2dst with part2dst. Adjust ctor.\n\t(__class_type_info::__do_upcast): Adjust call of worker function.\n\t(__class_type_info::__do_upcast): Adjust.\n\t(__si_class_type_info::__do_upcast): Adjust. Use parent's\n\t__do_upcast.\n\t(__vmi_class_type_info::__do_upcast): Likewise. Fix private\n\tvirtual base in diamond heirarchy bug.\n\nFrom-SVN: r34132", "tree": {"sha": "7a15c653bab43cdfe24d767be7f58578104e59ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a15c653bab43cdfe24d767be7f58578104e59ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01ce976d50cf5b93c0026f8ff206af8a1544493e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ce976d50cf5b93c0026f8ff206af8a1544493e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ce976d50cf5b93c0026f8ff206af8a1544493e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ce976d50cf5b93c0026f8ff206af8a1544493e/comments", "author": null, "committer": null, "parents": [{"sha": "0543d026a2a6366375b25b55dd318eb1cca6876c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0543d026a2a6366375b25b55dd318eb1cca6876c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0543d026a2a6366375b25b55dd318eb1cca6876c"}], "stats": {"total": 121, "additions": 64, "deletions": 57}, "files": [{"sha": "e6e13818ea979571848e9d813b3b2f4c75fa7f3a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce976d50cf5b93c0026f8ff206af8a1544493e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce976d50cf5b93c0026f8ff206af8a1544493e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=01ce976d50cf5b93c0026f8ff206af8a1544493e", "patch": "@@ -1,3 +1,19 @@\n+2000-05-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tUpdate new-abi upcast algorithm.\n+\t* inc/cxxabi.h (__class_type_info::__do_upcast): Change\n+\tprototype and meaning of return value.\n+\t(__si_class_type_info::__do_upcast): Likewise.\n+\t(__vmi_class_type_info::__do_upcast): Likewise.\n+\t* tinfo.cc (__class_type_info::__upcast_result): Replace\n+\twhole2dst with part2dst. Adjust ctor.\n+\t(__class_type_info::__do_upcast): Adjust call of worker function.\n+\t(__class_type_info::__do_upcast): Adjust.\n+\t(__si_class_type_info::__do_upcast): Adjust. Use parent's\n+\t__do_upcast.\n+\t(__vmi_class_type_info::__do_upcast): Likewise. Fix private\n+\tvirtual base in diamond heirarchy bug.\n+\n 2000-05-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (lang_decl_flags): Rename mutable_flag to uninlinable"}, {"sha": "c5eec5cac500d3251b563c7a92c961a641a7887a", "filename": "gcc/cp/inc/cxxabi.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce976d50cf5b93c0026f8ff206af8a1544493e/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce976d50cf5b93c0026f8ff206af8a1544493e/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=01ce976d50cf5b93c0026f8ff206af8a1544493e", "patch": "@@ -266,11 +266,9 @@ class __class_type_info\n \n \n public:\n-  /* Helper for upcast. See if DST is us, or one of our bases. ACCESS_PATH */\n-  /* gives the access from the start object. Return TRUE if we know the upcast */\n-  /* fails. */\n-  virtual bool __do_upcast (__sub_kind __access_path,\n-                            const __class_type_info *__dst,\n+  /* Helper for upcast. See if DST is us, or one of our bases. */\n+  /* Return false if not found, true if found. */\n+  virtual bool __do_upcast (const __class_type_info *__dst,\n                             const void *__obj,\n                             __upcast_result &__restrict __result) const;\n \n@@ -341,8 +339,7 @@ class __si_class_type_info\n                                            const void *__obj_ptr,\n                                            const __class_type_info *__src_type,\n                                            const void *__sub_ptr) const;\n-  virtual bool __do_upcast (__sub_kind __access_path,\n-                            const __class_type_info *__dst,\n+  virtual bool __do_upcast (const __class_type_info *__dst,\n                             const void *__obj,\n                             __upcast_result &__restrict __result) const;\n };\n@@ -391,8 +388,7 @@ class __vmi_class_type_info : public __class_type_info {\n                                            const void *__obj_ptr,\n                                            const __class_type_info *__src_type,\n                                            const void *__src_ptr) const;\n-  virtual bool __do_upcast (__sub_kind __access_path,\n-                            const __class_type_info *__dst,\n+  virtual bool __do_upcast (const __class_type_info *__dst,\n                             const void *__obj,\n                             __upcast_result &__restrict __result) const;\n };"}, {"sha": "375249c29a16f8d85357079d611a450c864645b0", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ce976d50cf5b93c0026f8ff206af8a1544493e/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ce976d50cf5b93c0026f8ff206af8a1544493e/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=01ce976d50cf5b93c0026f8ff206af8a1544493e", "patch": "@@ -662,15 +662,15 @@ __vmi_class_type_info::\n struct __class_type_info::__upcast_result\n {\n   const void *dst_ptr;        // pointer to caught object\n-  __sub_kind whole2dst;       // path from most derived object to target\n+  __sub_kind part2dst;        // path from current base to target\n   int src_details;            // hints about the source type heirarchy\n   const __class_type_info *base_type; // where we found the target,\n                               // if in vbase the __class_type_info of vbase\n                               // if a non-virtual base then 1\n                               // else NULL\n   public:\n   __upcast_result (int d)\n-    :dst_ptr (NULL), whole2dst (__unknown), src_details (d), base_type (NULL)\n+    :dst_ptr (NULL), part2dst (__unknown), src_details (d), base_type (NULL)\n     {}\n };\n \n@@ -709,10 +709,11 @@ __do_upcast (const __class_type_info *dst_type,\n {\n   __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);\n   \n-  if (__do_upcast (__contained_public, dst_type, *obj_ptr, result))\n+  __do_upcast (dst_type, *obj_ptr, result);\n+  if (!contained_public_p (result.part2dst))\n     return false;\n   *obj_ptr = const_cast <void *> (result.dst_ptr);\n-  return contained_public_p (result.whole2dst);\n+  return true;\n }\n \n inline __class_type_info::__sub_kind __class_type_info::\n@@ -1025,47 +1026,35 @@ __do_dyncast (ptrdiff_t src2dst,\n }\n \n bool __class_type_info::\n-__do_upcast (__sub_kind access_path,\n-             const __class_type_info *dst, const void *obj,\n+__do_upcast (const __class_type_info *dst, const void *obj,\n              __upcast_result &__restrict result) const\n {\n   if (*this == *dst)\n     {\n       result.dst_ptr = obj;\n       result.base_type = nonvirtual_base_type;\n-      result.whole2dst = access_path;\n-      return contained_nonpublic_p (access_path);\n+      result.part2dst = __contained_public;\n+      return true;\n     }\n   return false;\n }\n \n bool __si_class_type_info::\n-__do_upcast (__sub_kind access_path,\n-             const __class_type_info *dst, const void *obj_ptr,\n+__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n              __upcast_result &__restrict result) const\n {\n-  if (*this == *dst)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2dst = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n-  return base->__do_upcast (access_path, dst, obj_ptr, result);\n+  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n+    return true;\n+  \n+  return base->__do_upcast (dst, obj_ptr, result);\n }\n \n bool __vmi_class_type_info::\n-__do_upcast (__sub_kind access_path,\n-             const __class_type_info *dst, const void *obj_ptr,\n+__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n              __upcast_result &__restrict result) const\n {\n-  if (*this == *dst)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.base_type = nonvirtual_base_type;\n-      result.whole2dst = access_path;\n-      return contained_nonpublic_p (access_path);\n-    }\n+  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n+    return true;\n   \n   int src_details = result.src_details;\n   if (src_details & __flags_unknown_mask)\n@@ -1075,47 +1064,53 @@ __do_upcast (__sub_kind access_path,\n     {\n       __upcast_result result2 (src_details);\n       const void *base = obj_ptr;\n-      __sub_kind sub_access = access_path;\n       ptrdiff_t offset = vmi_bases[i].__offset ();\n       bool is_virtual = vmi_bases[i].__is_virtual_p ();\n+      bool is_public = vmi_bases[i].__is_public_p ();\n       \n-      if (!vmi_bases[i].__is_public_p ())\n-        {\n-          if (!(src_details & non_diamond_repeat_mask))\n-            // original cannot have an ambiguous base\n-            continue;\n-          sub_access = __sub_kind (sub_access & ~__contained_public_mask);\n-        }\n-      if (is_virtual)\n-    \t  sub_access = __sub_kind (sub_access | __contained_virtual_mask);\n+      if (!is_public && !(src_details & non_diamond_repeat_mask))\n+        // original cannot have an ambiguous base, so skip private bases\n+        continue;\n+\n       if (base)\n         base = convert_to_base (base, is_virtual, offset);\n       \n-      if (vmi_bases[i].base->__do_upcast (sub_access, dst, base, result2))\n-        return true; // must fail\n-      if (result2.base_type)\n+      if (vmi_bases[i].base->__do_upcast (dst, base, result2))\n         {\n           if (result2.base_type == nonvirtual_base_type && is_virtual)\n             result2.base_type = vmi_bases[i].base;\n+          if (contained_p (result2.part2dst) && !is_public)\n+            result2.part2dst = __sub_kind (result2.part2dst & ~__contained_public_mask);\n+          \n           if (!result.base_type)\n             {\n               result = result2;\n-              if (!(vmi_flags & non_diamond_repeat_mask))\n-                // cannot have an ambiguous other base\n-                return false;\n+              if (!contained_p (result.part2dst))\n+                return true; // found ambiguously\n+              \n+              if (result.part2dst & __contained_public_mask)\n+                {\n+                  if (!(vmi_flags & non_diamond_repeat_mask))\n+                    return true;  // cannot have an ambiguous other base\n+                }\n+              else\n+                {\n+                  if (!(vmi_flags & diamond_shaped_mask))\n+                    return true; // cannot have a more accessible base\n+                }\n             }\n           else if (result.dst_ptr != result2.dst_ptr)\n             {\n               // Found an ambiguity.\n \t      result.dst_ptr = NULL;\n-\t      result.whole2dst = __contained_ambig;\n+\t      result.part2dst = __contained_ambig;\n \t      return true;\n             }\n           else if (result.dst_ptr)\n             {\n               // Ok, found real object via a virtual path.\n-              result.whole2dst\n-                  = __sub_kind (result.whole2dst | result2.whole2dst);\n+              result.part2dst\n+                  = __sub_kind (result.part2dst | result2.part2dst);\n             }\n           else\n             {\n@@ -1127,13 +1122,13 @@ __do_upcast (__sub_kind access_path,\n                 {\n                   // Already ambiguous, not virtual or via different virtuals.\n                   // Cannot match.\n-                  result.whole2dst = __contained_ambig;\n+                  result.part2dst = __contained_ambig;\n                   return true;\n                 }\n             }\n         }\n     }\n-  return false;\n+  return result.part2dst != __unknown;\n }\n \n // this is the external interface to the dynamic cast machinery"}]}