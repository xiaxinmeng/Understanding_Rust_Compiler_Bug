{"sha": "b0e0b31f6fc59a5993329d7219d675ef068f2468", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBlMGIzMWY2ZmM1OWE1OTkzMzI5ZDcyMTlkNjc1ZWYwNjhmMjQ2OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-15T11:43:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-15T11:43:54Z"}, "message": "cp-tree.h: Revert previous change.\n\n\t* cp-tree.h: Revert previous change.\n\t(finish_struct_methods): Remove declaration.\n\t* class.c: Revert previous change.\n\t(maybe_warn_about_overly_private_class): New function.\n\t(finish_struct_methods): Declare here, and make static.  Remove\n\tunnecessary parameters.  Tidy slightly.  Use\n\tmaybe_warn_about_overly_private_class.\n\t(finish_struct_1): Adjust.  Remove check for private constructors,\n\tnow done elsewhere.\n\t(finish_struct): Adjust.\n\nFrom-SVN: r22426", "tree": {"sha": "d7bbdabdf3d8d6a3acef60207b6cc65f6eb82b61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7bbdabdf3d8d6a3acef60207b6cc65f6eb82b61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0e0b31f6fc59a5993329d7219d675ef068f2468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e0b31f6fc59a5993329d7219d675ef068f2468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e0b31f6fc59a5993329d7219d675ef068f2468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e0b31f6fc59a5993329d7219d675ef068f2468/comments", "author": null, "committer": null, "parents": [{"sha": "bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d"}], "stats": {"total": 352, "additions": 239, "deletions": 113}, "files": [{"sha": "2531b0edfb44bc2cc29b6299d799eb0c56cd7a3f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -1,3 +1,16 @@\n+1998-09-15  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h: Revert previous change.\n+\t(finish_struct_methods): Remove declaration.\n+\t* class.c: Revert previous change.\n+\t(maybe_warn_about_overly_private_class): New function.\n+\t(finish_struct_methods): Declare here, and make static.  Remove\n+\tunnecessary parameters.  Tidy slightly.  Use\n+\tmaybe_warn_about_overly_private_class. \n+\t(finish_struct_1): Adjust.  Remove check for private constructors,\n+\tnow done elsewhere.\n+\t(finish_struct): Adjust.\n+\t\n 1998-09-15  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* except.c (expand_start_catch_block): No need to check for new\n@@ -15,6 +28,14 @@\n \n 1998-09-14  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* cp-tree.h (lang_type): Add has_non_private_static_mem_fn.\n+\t(CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN): New macro, to access it.\n+\t* class.c (maybe_class_too_private_p): New function.\n+\t(finish_struct_methods): Use it.\n+\t(finish_struct_1): Likewise.\n+\t(finish_struct): Set CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN if\n+\tappropriate.\n+\t\n \t* pt.c (check_specialization_scope): Fix spelling error.\n \t(check_explicit_specialization): Remove code to handle explicit\n \tspecializations in class scope; they are now correctly diagnosed"}, {"sha": "8b5d418f9b520b87e1bebdb0a43481f996cc0c7f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 153, "deletions": 96, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -100,7 +100,8 @@ static void modify_all_indirect_vtables PROTO((tree, int, int, tree,\n \t\t\t\t\t       tree, tree));\n static void build_class_init_list PROTO((tree));\n static int finish_base_struct PROTO((tree, struct base_info *));\n-static int maybe_class_too_private_p PROTO((tree));\n+static void finish_struct_methods PROTO((tree));\n+static void maybe_warn_about_overly_private_class PROTO ((tree));\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -1898,32 +1899,145 @@ grow_method (fndecl, method_vec_ptr)\n     }\n }\n \n-/* Returns non-zero if T is the sort of class for which we should\n-   check issue warnings like \"all constructors are private\".  */\n+/* Issue warnings about T having private constructors, but no friends,\n+   and so forth.  \n \n-static int\n-maybe_class_too_private_p (t)\n-    tree t;\n+   HAS_NONPRIVATE_METHOD is nonzero if T has any non-private methods or\n+   static members.  HAS_NONPRIVATE_STATIC_FN is nonzero if T has any\n+   non-private static member functions.  */\n+\n+static void\n+maybe_warn_about_overly_private_class (t)\n+     tree t;\n {\n-  if (!warn_ctor_dtor_privacy)\n-    /* The user doesn't want to here these warnings.  */\n-    return 0;\n+  if (warn_ctor_dtor_privacy\n+      /* If the class has friends, those entities might create and\n+\t access instances, so we should not warn.  */\n+      && !(CLASSTYPE_FRIEND_CLASSES (t)\n+\t   || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))\n+      /* We will have warned when the template was declared; there's\n+\t no need to warn on every instantiation.  */\n+      && !CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n+    {\n+      /* We only issue one warning, if more than one applies, because\n+\t otherwise, on code like:\n+\n+\t   class A {\n+\t     // Oops - forgot `public:'\n+\t     A();\n+\t     A(const A&);\n+\t     ~A();\n+\t   };\n+\n+\t we warn several times about essentially the same problem.  */\n+\n+      int has_member_fn = 0;\n+      int has_nonprivate_method = 0;\n+      tree fn;\n+\n+      /* Check to see if all (non-constructor, non-destructor) member\n+\t functions are private.  (Since there are no friends or\n+\t non-private statics, we can't ever call any of the private\n+\t member functions.)  */\n+      for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+\t/* We're not interested in compiler-generated methods; they\n+\t   don't provide any way to call private members.  */\n+\tif (!DECL_ARTIFICIAL (fn)) \n+\t  {\n+\t    if (!TREE_PRIVATE (fn))\n+\t      {\n+\t\tif (DECL_STATIC_FUNCTION_P (fn)) \n+\t\t  /* A non-private static member function is just like a\n+\t\t     friend; it can create and invoke private member\n+\t\t     functions, and be accessed without a class\n+\t\t     instance.  */\n+\t\t  return;\n+\t\t\n+\t\thas_nonprivate_method = 1;\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      has_member_fn = 1;\n+\t  } \n \n-  if (CLASSTYPE_FRIEND_CLASSES (t) \n-      || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))\n-    /* The class has friends.  Maybe they can make use of the class,\n-       even though it's very private.  */\n-    return 0;\n+      if (!has_nonprivate_method && has_member_fn) \n+\t{\n+\t  int i;\n+\t  tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n+\t  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n+\t    if (TREE_VIA_PUBLIC (TREE_VEC_ELT (binfos, i))\n+\t\t|| TREE_VIA_PROTECTED (TREE_VEC_ELT (binfos, i)))\n+\t      {\n+\t\thas_nonprivate_method = 1;\n+\t\tbreak;\n+\t      }\n+\t  if (!has_nonprivate_method) \n+\t    {\n+\t      cp_warning (\"all member functions in class `%T' are private\", t);\n+\t      return;\n+\t    }\n+\t}\n \n-  if (CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN (t))\n-    /* The class has a non-private static member function.  Such a\n-       thing might be used, like a friend, to create instances of the\n-       class.  */\n-    return 0;\n+      /* Even if some of the member functions are non-private, the\n+\t class won't be useful for much if all the constructors or\n+\t destructors are private: such an object can never be created\n+\t or destroyed.  */\n+      if (TYPE_HAS_DESTRUCTOR (t))\n+\t{\n+\t  tree dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1);\n+\n+\t  if (TREE_PRIVATE (dtor))\n+\t    {\n+\t      cp_warning (\"`%#T' only defines a private destructor and has no friends\",\n+\t\t\t  t);\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (TYPE_HAS_CONSTRUCTOR (t))\n+\t{\n+\t  int nonprivate_ctor = 0;\n+\t  \n+\t  /* If a non-template class does not define a copy\n+\t     constructor, one is defined for it, enabling it to avoid\n+\t     this warning.  For a template class, this does not\n+\t     happen, and so we would normally get a warning on:\n \n-  return 1;\n+\t       template <class T> class C { private: C(); };  \n+\t  \n+\t     To avoid this asymmetry, we check TYPE_HAS_INIT_REF.  */ \n+\t  if (!TYPE_HAS_INIT_REF (t))\n+\t    nonprivate_ctor = 1;\n+\t  else \n+\t    for (fn = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n+\t\t fn;\n+\t\t fn = OVL_NEXT (fn)) \n+\t      {\n+\t\ttree ctor = OVL_CURRENT (fn);\n+\t\t/* Ideally, we wouldn't count copy constructors (or, in\n+\t\t   fact, any constructor that takes an argument of the\n+\t\t   class type as a parameter) because such things cannot\n+\t\t   be used to construct an instance of the class unless\n+\t\t   you already have one.  But, for now at least, we're\n+\t\t   more generous.  */\n+\t\tif (! TREE_PRIVATE (ctor))\n+\t\t  {\n+\t\t    nonprivate_ctor = 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\n+\t  if (nonprivate_ctor == 0)\n+\t    {\n+\t      cp_warning (\"`%#T' only defines private constructors and has no friends\",\n+\t\t\t  t);\n+\t      return;\n+\t    }\n+\t}\n+    }\n }\n \n+\n /* Warn about duplicate methods in fn_fields.  Also compact method\n    lists so that lookup can be made faster.\n \n@@ -1945,16 +2059,14 @@ maybe_class_too_private_p (t)\n    We also link each field which has shares a name with its baseclass\n    to the head of the list of fields for that base class.  This allows\n    us to reduce search time in places like `build_method_call' to\n-   consider only reasonably likely functions.  */\n+   consider only reasonably likely functions.   */\n \n-tree\n-finish_struct_methods (t, fn_fields, nonprivate_method)\n+static void\n+finish_struct_methods (t)\n      tree t;\n-     tree fn_fields;\n-     int nonprivate_method;\n {\n+  tree fn_fields;\n   tree method_vec;\n-  tree save_fn_fields = fn_fields;\n   tree ctor_name = constructor_name (t);\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n@@ -1972,8 +2084,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n      and the next few with type conversion operators (if any).  */\n-\n-  for (; fn_fields; fn_fields = TREE_CHAIN (fn_fields))\n+  for (fn_fields = TYPE_METHODS (t); fn_fields; \n+       fn_fields = TREE_CHAIN (fn_fields))\n     {\n       tree fn_name = DECL_NAME (fn_fields);\n \n@@ -2021,8 +2133,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tgrow_method (fn_fields, &method_vec);\n     }\n \n-  fn_fields = save_fn_fields;\n-  for (; fn_fields; fn_fields = TREE_CHAIN (fn_fields))\n+  for (fn_fields = TYPE_METHODS (t); fn_fields; \n+       fn_fields = TREE_CHAIN (fn_fields))\n     {\n       tree fn_name = DECL_NAME (fn_fields);\n \n@@ -2050,33 +2162,14 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   obstack_finish (&class_obstack);\n   CLASSTYPE_METHOD_VEC (t) = method_vec;\n \n-  if (nonprivate_method == 0 && maybe_class_too_private_p (t))\n-    {\n-      tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n-      for (i = 0; i < n_baseclasses; i++)\n-\tif (TREE_VIA_PUBLIC (TREE_VEC_ELT (binfos, i))\n-\t    || TREE_VIA_PROTECTED (TREE_VEC_ELT (binfos, i)))\n-\t  {\n-\t    nonprivate_method = 1;\n-\t    break;\n-\t  }\n-      if (nonprivate_method == 0)\n-\tcp_warning (\"all member functions in class `%T' are private\", t);\n-    }\n-\n-  /* Warn if all destructors are private (in which case this class is\n-     effectively unusable.  */\n-  if (TYPE_HAS_DESTRUCTOR (t))\n-    {\n-      tree dtor = TREE_VEC_ELT (method_vec, 1);\n-\n-      /* Wild parse errors can cause this to happen.  */\n-      if (dtor == NULL_TREE)\n-\tTYPE_HAS_DESTRUCTOR (t) = 0;\n-      else if (TREE_PRIVATE (dtor) && maybe_class_too_private_p (t))\n-\tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n-\t\t    t);\n-    }\n+  if (TYPE_HAS_DESTRUCTOR (t) && !TREE_VEC_ELT (method_vec, 1))\n+    /* We thought there was a destructor, but there wasn't.  Some\n+       parse errors cause this anomalous situation.  */\n+    TYPE_HAS_DESTRUCTOR (t) = 0;\n+    \n+  /* Issue warnings about private constructors and such.  If there are\n+     no methods, then some public defaults are generated.  */\n+  maybe_warn_about_overly_private_class (t); \n \n   /* Now for each member function (except for constructors and\n      destructors), compute where member functions of the same\n@@ -2102,8 +2195,6 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n       else\n \tobstack_free (current_obstack, baselink_vec);\n     }\n-\n-  return method_vec;\n }\n \n /* Emit error when a duplicate definition of a type is seen.  Patch up.  */\n@@ -3063,7 +3154,6 @@ finish_struct_1 (t, warn_anon)\n   int any_default_members = 0;\n   int const_sans_init = 0;\n   int ref_sans_init = 0;\n-  int nonprivate_method = 0;\n   tree access_decls = NULL_TREE;\n   int aggregate = 1;\n   int empty = 1;\n@@ -3165,8 +3255,6 @@ finish_struct_1 (t, warn_anon)\n     {\n       GNU_xref_member (current_class_name, x);\n \n-      nonprivate_method |= ! TREE_PRIVATE (x);\n-\n       /* If this was an evil function, don't keep it in class.  */\n       if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n \tcontinue;\n@@ -3538,9 +3626,6 @@ finish_struct_1 (t, warn_anon)\n   /* Synthesize any needed methods.  Note that methods will be synthesized\n      for anonymous unions; grok_x_components undoes that.  */\n \n-  if (! fn_fields)\n-    nonprivate_method = 1;\n-\n   if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t)\n       && !IS_SIGNATURE (t))\n     {\n@@ -3561,7 +3646,6 @@ finish_struct_1 (t, warn_anon)\n \t  if (DECL_VINDEX (dtor))\n \t    add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n \t\t\t\t  &has_virtual, dtor, t);\n-\t  nonprivate_method = 1;\n \t}\n     }\n \n@@ -3632,28 +3716,8 @@ finish_struct_1 (t, warn_anon)\n   if (fn_fields)\n     {\n       TYPE_METHODS (t) = fn_fields;\n-      method_vec = finish_struct_methods (t, fn_fields, nonprivate_method);\n-\n-      if (TYPE_HAS_CONSTRUCTOR (t)\n-\t  && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-\t  && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE)\n-\t{\n-\t  int nonprivate_ctor = 0;\n-\t  tree ctor;\n-\n-\t  for (ctor = TREE_VEC_ELT (method_vec, 0);\n-\t       ctor;\n-\t       ctor = OVL_NEXT (ctor))\n-\t    if (! TREE_PRIVATE (OVL_CURRENT (ctor)))\n-\t      {\n-\t\tnonprivate_ctor = 1;\n-\t\tbreak;\n-\t      }\n-\n-\t  if (nonprivate_ctor == 0 && maybe_class_too_private_p (t))\n-\t    cp_warning (\"`%#T' only defines private constructors and has no friends\",\n-\t\t\tt);\n-\t}\n+      finish_struct_methods (t);\n+      method_vec = CLASSTYPE_METHOD_VEC (t);\n     }\n   else\n     {\n@@ -4229,12 +4293,6 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t  TREE_PRIVATE (x) = access == access_private_node;\n \t  TREE_PROTECTED (x) = access == access_protected_node;\n \n-\t  if (!TREE_PRIVATE (x) \n-\t      && TREE_CODE (x) == FUNCTION_DECL \n-\t      && DECL_LANG_SPECIFIC (x)\n-\t      && DECL_STATIC_FUNCTION_P (x))\n-\t    CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN (t) = 1;\n-\n \t  if (TREE_CODE (x) == TEMPLATE_DECL)\n \t    {\n \t      TREE_PRIVATE (DECL_RESULT (x)) = TREE_PRIVATE (x);\n@@ -4363,8 +4421,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t    = tree_cons (NULL_TREE, d,\n \t\t\t DECL_TEMPLATE_INJECT (CLASSTYPE_TI_TEMPLATE (t)));\n \t}\n-      CLASSTYPE_METHOD_VEC (t)\n-\t= finish_struct_methods (t, TYPE_METHODS (t), 1);\n+      finish_struct_methods (t);\n       TYPE_SIZE (t) = integer_zero_node;\n     }      \n   else"}, {"sha": "1f4bc0e2774c5a53d116fe7cf97ad0a560ceac34", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -621,12 +621,11 @@ struct lang_type\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n-      unsigned has_non_private_static_mem_fn : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 10;\n+      unsigned dummy : 11;\n     } type_flags;\n \n   int n_ancestors;\n@@ -1452,10 +1451,6 @@ extern int flag_new_for_scope;\n #define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n   (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n-/* Nonzero if NODE has a non-private static member function.  */\n-#define CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->type_flags.has_non_private_static_mem_fn)\n-\n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n #define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assign_ref)\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_assign_ref)\n@@ -2414,7 +2409,6 @@ extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n extern tree finish_struct\t\t\tPROTO((tree, tree, tree, int));\n extern tree finish_struct_1\t\t\tPROTO((tree, int));\n-extern tree finish_struct_methods\t\tPROTO((tree, tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n extern void init_class_processing\t\tPROTO((void));\n extern int is_empty_class\t\t\tPROTO((tree));"}, {"sha": "b74e2640203fced44708fde24bced47de9afff48", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -80,7 +80,7 @@ public:\n \n // 04\n // local names (14.6.1 p 4)\n-template <class T10, int i> class Xfour {// ERROR - .*\n+template <class T10, int i> struct Xfour {// ERROR - .*\n   int T10; // ERROR - .*\n   void f(){\n     char T10; // ERROR - .*\n@@ -90,7 +90,7 @@ template <class T10, int i> class Xfour {// ERROR - .*\n \n // 05\n // using different tempate-parms for out-of-line defs\n-template <class T12, int i> class Xfive {\n+template <class T12, int i> struct Xfive {\n   void f();\n };\n \n@@ -189,7 +189,7 @@ public:\n // 13\n // member templates, non-type parameters\n template <long l>// ERROR - .*\n-class Xthirteen {\n+struct Xthirteen {\n   template <long l> long comp_ge(long test) {// ERROR - .\n     long local_value;\n     if (local_value > value) "}, {"sha": "0330d0bbd0a94896261715c040d6a7d71738a794", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem04.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem04.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem04.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem04.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -112,7 +112,7 @@ protected:\n \n // 20\n // local names (14.6.1 p 4) part two, variable names as template param\n-template <class T17, int i> class Xtwenty {\n+template <class T17, int i> struct Xtwenty {\n   void f(){\n     T17 my_type; //ok\n     for (int j = 0; j < 5; ++l)"}, {"sha": "77cc732090e619ca1d815a13a97b52509ee32ba4", "filename": "gcc/testsuite/g++.old-deja/g++.jason/tempcons.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftempcons.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftempcons.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftempcons.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -2,7 +2,7 @@\n // Build don't link:\n \n template <class T>\n-class A {\n+struct A {\n   int i;\n   Blarg () : i(0) { }\t\t// ERROR - \n };"}, {"sha": "4827c5645f2acf498ad480c56c1f76b5dae0d670", "filename": "gcc/testsuite/g++.old-deja/g++.other/warn3.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fwarn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fwarn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fwarn3.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -0,0 +1,54 @@\n+// Build don't link:\n+\n+class A {\n+};\n+\n+\n+class B {\n+public:\n+  void f();\n+\n+private:\n+  B (); \n+  B (const B&);\n+}; // WARNING - only private constructors\n+\n+\n+class C { \n+public: \n+  void f();\n+\n+private:\n+  ~C (); \n+}; // WARNING - only private destructors\n+\n+\n+class D {\n+private:\n+  void f(); \n+}; // WARNING - all member functions are private\n+\n+\n+template <class T>\n+class X {\n+private:\n+  ~X (); \n+}; // WARNING - only private destructors\n+\n+template class X<int>;\n+template class X<double>;\n+\n+\n+template <class T>\n+class Y {\n+private:\n+  Y (); \n+  Y (const Y&);\n+}; // WARNING - only private constructors\n+\n+\n+template <class T>\n+class Z {\n+private:\n+  void f(); \n+}; // WARNING - all member functions are private"}, {"sha": "431d41d64e8434350c4757c1a3ba63ff56a1c007", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass8.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -4,7 +4,7 @@ template <class T>\n class S\n {\n   template <class U>\n-  class S2 {\n+  struct S2 {\n     S2(const S2<U>& s2u) {}\n   };\n };"}, {"sha": "7358d7225f77dac8d0f647e424ab9854aab8d52f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp60.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp60.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp60.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp60.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -1,7 +1,7 @@\n // Build don't link:\n // GROUPS passed membertemplates\n template <class T>\n-class S\n+struct S\n {\n   S(const S<T>& x)  {}\n "}, {"sha": "8d674c9f127e355be9ae7fd4ee7f1989fb445cd4", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typedef1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypedef1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypedef1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypedef1.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -2,7 +2,7 @@\n // Build don't link:\n \n template <class T>\n-class A\n+struct A\n {\n   typedef enum\n   {"}, {"sha": "6c3130eafa52eb800e7f570c5c2ff67121c5559d", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb28.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -6,7 +6,7 @@ class a\n         vector<s> vs;\n         friend class b;\n };\n-class b\n+struct b\n {\n         vector<a> va;\n         operator vector< vector<s> >()"}, {"sha": "f1017a774a73f2a18e2e38ff3b40b5d7165dc355", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb29.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e0b31f6fc59a5993329d7219d675ef068f2468/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb29.C?ref=b0e0b31f6fc59a5993329d7219d675ef068f2468", "patch": "@@ -6,7 +6,7 @@ class a\n         vector<s> vs;\n         friend class b;\n };\n-class b\n+struct b\n {\n         vector<a> va;\n         operator vector< vector<s> >()"}]}