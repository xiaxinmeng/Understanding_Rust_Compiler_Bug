{"sha": "2882702b64846a135c57cad5ca83dc781d19aad8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg4MjcwMmI2NDg0NmExMzVjNTdjYWQ1Y2E4M2RjNzgxZDE5YWFkOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-17T17:57:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-17T17:57:15Z"}, "message": "rx: Split movsicc post-reload.\n\nThis will allow elimination of the compare.\n\nFrom-SVN: r168921", "tree": {"sha": "b26e850edd0abaaf97ada13ad508b9fd2a8d820d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b26e850edd0abaaf97ada13ad508b9fd2a8d820d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2882702b64846a135c57cad5ca83dc781d19aad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2882702b64846a135c57cad5ca83dc781d19aad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2882702b64846a135c57cad5ca83dc781d19aad8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2882702b64846a135c57cad5ca83dc781d19aad8/comments", "author": null, "committer": null, "parents": [{"sha": "6f7310f2b450fa98642b4a8e76a52ea3837ee66c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7310f2b450fa98642b4a8e76a52ea3837ee66c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7310f2b450fa98642b4a8e76a52ea3837ee66c"}], "stats": {"total": 111, "additions": 73, "deletions": 38}, "files": [{"sha": "d32b89ab24bbb32d5112927df95157935ab6ff67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2882702b64846a135c57cad5ca83dc781d19aad8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2882702b64846a135c57cad5ca83dc781d19aad8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2882702b64846a135c57cad5ca83dc781d19aad8", "patch": "@@ -1,5 +1,9 @@\n 2011-01-17  Richard Henderson  <rth@redhat.com>\n \n+\t* config/rx/rx.md (movsicc): Split after reload.\n+\t(*movsicc): Merge *movsieq and *movsine via match_operator.\n+\t(*stcc): New pattern.\n+\n \t* config/rx/rx.c (rx_float_compare_mode): Remove.\n \t* config/rx/rx.h (rx_float_compare_mode): Remove.\n \t* config/rx/rx.md (cstoresi4): Split after reload."}, {"sha": "4ffbfec94ed9672799fe69990fa2f4550f525e5e", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2882702b64846a135c57cad5ca83dc781d19aad8/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2882702b64846a135c57cad5ca83dc781d19aad8/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=2882702b64846a135c57cad5ca83dc781d19aad8", "patch": "@@ -744,47 +744,78 @@\n     [(set (match_operand:SI                  0 \"register_operand\")\n \t  (if_then_else:SI (match_operand:SI 1 \"comparison_operator\")\n \t\t\t   (match_operand:SI 2 \"nonmemory_operand\")\n-\t\t\t   (match_operand:SI 3 \"immediate_operand\")))\n-     (clobber (reg:CC CC_REG))])] ;; See cstoresi4\n+\t\t\t   (match_operand:SI 3 \"nonmemory_operand\")))\n+     (clobber (reg:CC CC_REG))])]\n   \"\"\n-  {\n-    if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)\n-      FAIL;\n-    if (! CONST_INT_P (operands[3]))\n-      FAIL;\n-  }\n-)\n+{\n+  /* ??? Support other conditions via cstore into a temporary?  */\n+  if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)\n+    FAIL;\n+  /* One operand must be a constant.  */\n+  if (!CONSTANT_P (operands[2]) && !CONSTANT_P (operands[3]))\n+    FAIL;\n+})\n \n-(define_insn \"*movsieq\"\n-  [(set (match_operand:SI                      0 \"register_operand\" \"=r,r,r\")\n-\t(if_then_else:SI (eq (match_operand:SI 3 \"register_operand\"  \"r,r,r\")\n-\t\t\t     (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n-\t\t\t (match_operand:SI     1 \"nonmemory_operand\" \"0,i,r\")\n-\t\t\t (match_operand:SI     2 \"immediate_operand\" \"i,i,i\")))\n-   (clobber (reg:CC CC_REG))] ;; See cstoresi4\n-  \"\"\n-  \"@\n-  cmp\\t%Q4, %Q3\\n\\tstnz\\t%2, %0\n-  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%2, %0\\n\\tstz\\t%1, %0\n-  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%1, %0\\n\\tstnz\\t%2, %0\"\n-  [(set_attr \"length\"  \"13,19,15\")\n-   (set_attr \"timings\" \"22,33,33\")]\n-)\n+(define_insn_and_split \"*movsicc\"\n+  [(set (match_operand:SI     0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:SI\n+\t  (match_operator 5 \"rx_z_comparison_operator\"\n+\t   [(match_operand:SI 3 \"register_operand\"  \"r,r\")\n+\t    (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ\")])\n+\t  (match_operand:SI   1 \"nonmemory_operand\" \"i,ri\")\n+\t  (match_operand:SI   2 \"nonmemory_operand\" \"ri,i\")))\n+   (clobber (reg:CC CC_REG))]\n+  \"CONSTANT_P (operands[1]) || CONSTANT_P (operands[2])\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx x, flags, op0, op1, op2;\n+  enum rtx_code cmp_code;\n \n-(define_insn \"*movsine\"\n-  [(set (match_operand:SI                      0 \"register_operand\" \"=r,r,r\")\n-\t(if_then_else:SI (ne (match_operand:SI 3 \"register_operand\"  \"r,r,r\")\n-\t\t\t     (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n-\t\t\t (match_operand:SI     1 \"nonmemory_operand\" \"0,i,r\")\n-\t\t\t (match_operand:SI     2 \"immediate_operand\" \"i,i,i\")))\n-   (clobber (reg:CC CC_REG))] ;; See cstoresi4\n-  \"\"\n-  \"@\n-  cmp\\t%Q4, %Q3\\n\\tstz\\t%2, %0\n-  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%2, %0\\n\\tstnz\\t%1, %0\n-  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%1, %0\\n\\tstz\\t%2, %0\"\n-  [(set_attr \"length\"  \"13,19,15\")\n-   (set_attr \"timings\" \"22,33,33\")]\n+  flags = gen_rtx_REG (CCmode, CC_REG);\n+  x = gen_rtx_COMPARE (CCmode, operands[3], operands[4]);\n+  emit_insn (gen_rtx_SET (VOIDmode, flags, x));\n+\n+  cmp_code = GET_CODE (operands[5]);\n+  op0 = operands[0];\n+  op1 = operands[1];\n+  op2 = operands[2];\n+\n+  /* If OP2 is the constant, reverse the sense of the move.  */\n+  if (!CONSTANT_P (operands[1]))\n+    {\n+      x = op1, op1 = op2, op2 = x;\n+      cmp_code = reverse_condition (cmp_code);\n+    }\n+\n+  /* If OP2 does not match the output, copy it into place.  We have allowed\n+     these alternatives so that the destination can legitimately be one of\n+     the comparison operands without increasing register pressure.  */\n+  if (!rtx_equal_p (op0, op2))\n+    emit_move_insn (op0, op2);\n+\n+  x = gen_rtx_fmt_ee (cmp_code, VOIDmode, flags, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (SImode, x, op1, op0);\n+  emit_insn (gen_rtx_SET (VOIDmode, op0, x));\n+  DONE;\n+})\n+\n+(define_insn \"*stcc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+r,r,r,r\")\n+\t(if_then_else:SI\n+\t  (match_operator 2 \"rx_z_comparison_operator\"\n+\t    [(reg CC_REG) (const_int 0)])\n+\t  (match_operand:SI 1 \"immediate_operand\" \"Sint08,Sint16,Sint24,i\")\n+\t  (match_dup 0)))]\n+  \"reload_completed\"\n+{\n+  if (GET_CODE (operands[2]) == EQ)\n+    return \"stz\\t%1, %0\";\n+  else\n+    return \"stnz\\t%1, %0\";\n+}\n+  [(set_attr \"length\" \"4,5,6,7\")]\n )\n \n ;; Arithmetic Instructions"}]}