{"sha": "01628e543b8867e4c4ca5724d4982caae7f0bc1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2MjhlNTQzYjg4NjdlNGM0Y2E1NzI0ZDQ5ODJjYWFlN2YwYmMxYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-07T20:42:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-07T20:42:37Z"}, "message": "cp-tree.h (COMPLETE_OR_OPEN_TYPE_P): New macro.\n\n\t* cp-tree.h (COMPLETE_OR_OPEN_TYPE_P): New macro.\n\t* init.c (build_offset_ref): Use it.\n\t* pt.c (maybe_process_partial_specialization): Use it.\n\t(instantiate_class_template): Use it.\n\t* search.c (lookup_base): Use it.\n\nFrom-SVN: r160398", "tree": {"sha": "162d7f5ea6f6051c882ece33106ad652f869918c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/162d7f5ea6f6051c882ece33106ad652f869918c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01628e543b8867e4c4ca5724d4982caae7f0bc1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01628e543b8867e4c4ca5724d4982caae7f0bc1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01628e543b8867e4c4ca5724d4982caae7f0bc1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01628e543b8867e4c4ca5724d4982caae7f0bc1a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55cdb6b69069481ecf19ff07d0ebb23208bc8162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55cdb6b69069481ecf19ff07d0ebb23208bc8162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55cdb6b69069481ecf19ff07d0ebb23208bc8162"}], "stats": {"total": 25, "additions": 16, "deletions": 9}, "files": [{"sha": "322023008968c70fb67eac8dcbbc28ceb4bfe3ff", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=01628e543b8867e4c4ca5724d4982caae7f0bc1a", "patch": "@@ -1,5 +1,11 @@\n 2010-06-07  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-tree.h (COMPLETE_OR_OPEN_TYPE_P): New macro.\n+\t* init.c (build_offset_ref): Use it.\n+\t* pt.c (maybe_process_partial_specialization): Use it.\n+\t(instantiate_class_template): Use it.\n+\t* search.c (lookup_base): Use it.\n+\n \t* pt.c (lookup_template_class): Don't mess with\n \tDECL_TEMPLATE_INSTANTIATIONS except for partial instantiations.\n "}, {"sha": "f507a21a78da1202d6a96c0e8351fc3bc9b3fc95", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=01628e543b8867e4c4ca5724d4982caae7f0bc1a", "patch": "@@ -1433,6 +1433,11 @@ struct GTY(()) lang_type {\n    starting the definition of this type has been seen.  */\n #define TYPE_BEING_DEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->being_defined)\n \n+/* Nonzero means that this type is either complete or being defined, so we\n+   can do lookup in it.  */\n+#define COMPLETE_OR_OPEN_TYPE_P(NODE) \\\n+  (COMPLETE_TYPE_P (NODE) || (CLASS_TYPE_P (NODE) && TYPE_BEING_DEFINED (NODE)))\n+\n /* Mark bits for repeated base checks.  */\n #define TYPE_MARKED_P(NODE) TREE_LANG_FLAG_6 (TYPE_CHECK (NODE))\n "}, {"sha": "66451b1e356daf4a0f12fd47496dda007c6058be", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=01628e543b8867e4c4ca5724d4982caae7f0bc1a", "patch": "@@ -1520,8 +1520,7 @@ build_offset_ref (tree type, tree member, bool address_p)\n   /* Callers should call mark_used before this point.  */\n   gcc_assert (!DECL_P (member) || TREE_USED (member));\n \n-  if (!COMPLETE_TYPE_P (complete_type (type))\n-      && !TYPE_BEING_DEFINED (type))\n+  if (!COMPLETE_OR_OPEN_TYPE_P (complete_type (type)))\n     {\n       error (\"incomplete type %qT does not have member %qD\", type, member);\n       return error_mark_node;"}, {"sha": "b62a9bc695f4f3020dde8c326c4cbfdd6839207e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=01628e543b8867e4c4ca5724d4982caae7f0bc1a", "patch": "@@ -891,7 +891,7 @@ maybe_process_partial_specialization (tree type)\n \t\t  *slot = GGC_NEW (spec_entry);\n \t\t  **slot = elt;\n \t\t}\n-\t      else if (COMPLETE_TYPE_P (inst) || TYPE_BEING_DEFINED (inst))\n+\t      else if (COMPLETE_OR_OPEN_TYPE_P (inst))\n \t\t/* But if we've had an implicit instantiation, that's a\n \t\t   problem ([temp.expl.spec]/6).  */\n \t\terror (\"specialization %qT after instantiation %qT\",\n@@ -7700,8 +7700,7 @@ instantiate_class_template (tree type)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TYPE_BEING_DEFINED (type)\n-      || COMPLETE_TYPE_P (type)\n+  if (COMPLETE_OR_OPEN_TYPE_P (type)\n       || uses_template_parms (type))\n     return type;\n \n@@ -7796,8 +7795,7 @@ instantiate_class_template (tree type)\n      instantiate it, and that lookup should instantiate the enclosing\n      class.  */\n   gcc_assert (!DECL_CLASS_SCOPE_P (TYPE_MAIN_DECL (pattern))\n-\t      || COMPLETE_TYPE_P (TYPE_CONTEXT (type))\n-\t      || TYPE_BEING_DEFINED (TYPE_CONTEXT (type)));\n+\t      || COMPLETE_OR_OPEN_TYPE_P (TYPE_CONTEXT (type)));\n \n   base_list = NULL_TREE;\n   if (BINFO_N_BASE_BINFOS (pbinfo))"}, {"sha": "d69d415cd60a5516ea08cf7b8a15024ed6b72035", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01628e543b8867e4c4ca5724d4982caae7f0bc1a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=01628e543b8867e4c4ca5724d4982caae7f0bc1a", "patch": "@@ -216,8 +216,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \n   /* If BASE is incomplete, it can't be a base of T--and instantiating it\n      might cause an error.  */\n-  if (t_binfo && CLASS_TYPE_P (base)\n-      && (COMPLETE_TYPE_P (base) || TYPE_BEING_DEFINED (base)))\n+  if (t_binfo && CLASS_TYPE_P (base) && COMPLETE_OR_OPEN_TYPE_P (base))\n     {\n       struct lookup_base_data_s data;\n "}]}