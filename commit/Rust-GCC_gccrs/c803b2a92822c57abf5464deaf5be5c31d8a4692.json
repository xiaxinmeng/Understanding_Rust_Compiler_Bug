{"sha": "c803b2a92822c57abf5464deaf5be5c31d8a4692", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwM2IyYTkyODIyYzU3YWJmNTQ2NGRlYWY1YmU1YzMxZDhhNDY5Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-01-12T11:43:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-01-12T11:43:13Z"}, "message": "re PR target/80846 (auto-vectorized AVX2 horizontal sum should narrow to 128b right away, to be more efficient for Ryzen and Intel)\n\n2018-01-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/80846\n\t* target.def (split_reduction): New target hook.\n\t* targhooks.c (default_split_reduction): New function.\n\t* targhooks.h (default_split_reduction): Declare.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): If the\n\ttarget requests first reduce vectors by combining low and high\n\tparts.\n\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Adjust.\n\t(get_vectype_for_scalar_type_and_size): Export.\n\t* tree-vectorizer.h (get_vectype_for_scalar_type_and_size): Declare.\n\n\t* doc/tm.texi.in (TARGET_VECTORIZE_SPLIT_REDUCTION): Document.\n\t* doc/tm.texi: Regenerate.\n\n\ti386/\n\t* config/i386/i386.c (ix86_split_reduction): Implement\n\tTARGET_VECTORIZE_SPLIT_REDUCTION.\n\n\t* gcc.target/i386/pr80846-1.c: New testcase.\n\t* gcc.target/i386/pr80846-2.c: Likewise.\n\nFrom-SVN: r256576", "tree": {"sha": "4a8bf4ce632240e45cdadcf69318f73f17a0f232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a8bf4ce632240e45cdadcf69318f73f17a0f232"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c803b2a92822c57abf5464deaf5be5c31d8a4692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c803b2a92822c57abf5464deaf5be5c31d8a4692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c803b2a92822c57abf5464deaf5be5c31d8a4692", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c803b2a92822c57abf5464deaf5be5c31d8a4692/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46336a0eab790e4f94dd7e7ecf9339a884c44746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46336a0eab790e4f94dd7e7ecf9339a884c44746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46336a0eab790e4f94dd7e7ecf9339a884c44746"}], "stats": {"total": 258, "additions": 231, "deletions": 27}, "files": [{"sha": "1f455875848eafc61560cf2b6e7f0aeab3c2f130", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -1,3 +1,20 @@\n+2018-01-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/80846\n+\t* target.def (split_reduction): New target hook.\n+\t* targhooks.c (default_split_reduction): New function.\n+\t* targhooks.h (default_split_reduction): Declare.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): If the\n+\ttarget requests first reduce vectors by combining low and high\n+\tparts.\n+\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Adjust.\n+\t(get_vectype_for_scalar_type_and_size): Export.\n+\t* tree-vectorizer.h (get_vectype_for_scalar_type_and_size): Declare.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_SPLIT_REDUCTION): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/i386/i386.c (ix86_split_reduction): Implement\n+\tTARGET_VECTORIZE_SPLIT_REDUCTION.\n+\n 2018-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/83368"}, {"sha": "5ee3be386df8b37a6025974d90f9a42bd026abbc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -49008,6 +49008,39 @@ ix86_preferred_simd_mode (scalar_mode mode)\n     }\n }\n \n+/* All CPUs prefer to avoid cross-lane operations so perform reductions\n+   upper against lower halves up to SSE reg size.  */\n+\n+static machine_mode\n+ix86_split_reduction (machine_mode mode)\n+{\n+  /* Reduce lowpart against highpart until we reach SSE reg width to\n+     avoid cross-lane operations.  */\n+  switch (mode)\n+    {\n+    case E_V8DImode:\n+    case E_V4DImode:\n+      return V2DImode;\n+    case E_V16SImode:\n+    case E_V8SImode:\n+      return V4SImode;\n+    case E_V32HImode:\n+    case E_V16HImode:\n+      return V8HImode;\n+    case E_V64QImode:\n+    case E_V32QImode:\n+      return V16QImode;\n+    case E_V16SFmode:\n+    case E_V8SFmode:\n+      return V4SFmode;\n+    case E_V8DFmode:\n+    case E_V4DFmode:\n+      return V2DFmode;\n+    default:\n+      return mode;\n+    }\n+}\n+\n /* If AVX is enabled then try vectorizing with both 256bit and 128bit\n    vectors.  If AVX512F is enabled then try vectorizing with 512bit,\n    256bit and 128bit vectors.  */\n@@ -50640,6 +50673,9 @@ ix86_run_selftests (void)\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE \\\n   ix86_preferred_simd_mode\n+#undef TARGET_VECTORIZE_SPLIT_REDUCTION\n+#define TARGET_VECTORIZE_SPLIT_REDUCTION \\\n+  ix86_split_reduction\n #undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n #define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n   ix86_autovectorize_vector_sizes"}, {"sha": "11b560b9c0767edf7e702f240487fce06fce9212", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -5873,6 +5873,13 @@ equal to @code{word_mode}, because the vectorizer can do some\n transformations even in absence of specialized @acronym{SIMD} hardware.\n @end deftypefn\n \n+@deftypefn {Target Hook} machine_mode TARGET_VECTORIZE_SPLIT_REDUCTION (machine_mode)\n+This hook should return the preferred mode to split the final reduction\n+step on @var{mode} to.  The reduction is then carried out reducing upper\n+against lower halves of vectors recursively until the specified mode is\n+reached.  The default is @var{mode} which means no splitting.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES (vector_sizes *@var{sizes})\n If the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is not\n the only one that is worth considering, this hook should add all suitable"}, {"sha": "0cd694a5448def3f5217de514474dfcd9ae929f5", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -4093,6 +4093,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n \n+@hook TARGET_VECTORIZE_SPLIT_REDUCTION\n+\n @hook TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n \n @hook TARGET_VECTORIZE_GET_MASK_MODE"}, {"sha": "0a4f5fe6ef6d625ee34b35764357c6408da111e8", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -1890,6 +1890,17 @@ transformations even in absence of specialized @acronym{SIMD} hardware.\",\n  (scalar_mode mode),\n  default_preferred_simd_mode)\n \n+/* Returns the preferred mode for splitting SIMD reductions to.  */\n+DEFHOOK\n+(split_reduction,\n+ \"This hook should return the preferred mode to split the final reduction\\n\\\n+step on @var{mode} to.  The reduction is then carried out reducing upper\\n\\\n+against lower halves of vectors recursively until the specified mode is\\n\\\n+reached.  The default is @var{mode} which means no splitting.\",\n+  machine_mode,\n+  (machine_mode),\n+  default_split_reduction)\n+\n /* Returns a mask of vector sizes to iterate over when auto-vectorizing\n    after processing the preferred one derived from preferred_simd_mode.  */\n DEFHOOK"}, {"sha": "5b60944a071f89db024d5de2201de6f3fc5bed1b", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -1283,6 +1283,14 @@ default_preferred_simd_mode (scalar_mode)\n   return word_mode;\n }\n \n+/* By default do not split reductions further.  */\n+\n+machine_mode\n+default_split_reduction (machine_mode mode)\n+{\n+  return mode;\n+}\n+\n /* By default only the size derived from the preferred vector mode\n    is tried.  */\n "}, {"sha": "f55fde773d18c8b4dd4eeb043bc62f2e61a3ad17", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -108,6 +108,7 @@ default_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t     const_tree,\n \t\t\t\t\t     int, bool);\n extern machine_mode default_preferred_simd_mode (scalar_mode mode);\n+extern machine_mode default_split_reduction (machine_mode);\n extern void default_autovectorize_vector_sizes (vector_sizes *);\n extern opt_machine_mode default_get_mask_mode (poly_uint64, poly_uint64);\n extern void *default_init_cost (struct loop *);"}, {"sha": "a91660ce4263c32bd920f878e7472a9cf304ef91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -1,3 +1,9 @@\n+2018-01-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/80846\n+\t* gcc.target/i386/pr80846-1.c: New testcase.\n+\t* gcc.target/i386/pr80846-2.c: Likewise.\n+\n 2018-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.c-torture/execute/20180112-1.c: New test."}, {"sha": "295bb7d0d5a3a13c6f788112fd58c04d0cd7ad09", "filename": "gcc/testsuite/gcc.target/i386/pr80846-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80846-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80846-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80846-1.c?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx512f\" } */\n+\n+int sumint(const int arr[]) {\n+    arr = __builtin_assume_aligned(arr, 64);\n+    int sum=0;\n+    for (int i=0 ; i<1024 ; i++)\n+      sum+=arr[i];\n+    return sum;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vextracti\" 2 } } */"}, {"sha": "df3535f4e37a907c24d88acd30e67f4051a5befe", "filename": "gcc/testsuite/gcc.target/i386/pr80846-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80846-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80846-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr80846-2.c?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx2\" } */\n+\n+int sumint(const int arr[]) {\n+    arr = __builtin_assume_aligned(arr, 64);\n+    int sum=0;\n+    for (int i=0 ; i<1024 ; i++)\n+      sum+=arr[i];\n+    return sum;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vextracti\" 1 } } */"}, {"sha": "c6fa5198055f9674c95d120f7d907637606d3c33", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 117, "deletions": 26, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -5062,12 +5062,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     }\n   else\n     {\n-      bool reduce_with_shift = have_whole_vector_shift (mode);\n-      int element_bitsize = tree_to_uhwi (bitsize);\n-      /* Enforced by vectorizable_reduction, which disallows SLP reductions\n-\t for variable-length vectors and also requires direct target support\n-\t for loop reductions.  */\n-      int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n+      bool reduce_with_shift;\n       tree vec_temp;\n \n       /* COND reductions all do the final reduction with MAX_EXPR\n@@ -5081,30 +5076,125 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t    code = MAX_EXPR;\n \t}\n \n-      /* Regardless of whether we have a whole vector shift, if we're\n-         emulating the operation via tree-vect-generic, we don't want\n-         to use it.  Only the first round of the reduction is likely\n-         to still be profitable via emulation.  */\n-      /* ??? It might be better to emit a reduction tree code here, so that\n-         tree-vect-generic can expand the first round via bit tricks.  */\n-      if (!VECTOR_MODE_P (mode))\n-        reduce_with_shift = false;\n+      /* See if the target wants to do the final (shift) reduction\n+\t in a vector mode of smaller size and first reduce upper/lower\n+\t halves against each other.  */\n+      enum machine_mode mode1 = mode;\n+      tree vectype1 = vectype;\n+      unsigned sz = tree_to_uhwi (TYPE_SIZE_UNIT (vectype));\n+      unsigned sz1 = sz;\n+      if (!slp_reduc\n+\t  && (mode1 = targetm.vectorize.split_reduction (mode)) != mode)\n+\tsz1 = GET_MODE_SIZE (mode1).to_constant ();\n+\n+      vectype1 = get_vectype_for_scalar_type_and_size (scalar_type, sz1);\n+      reduce_with_shift = have_whole_vector_shift (mode1);\n+      if (!VECTOR_MODE_P (mode1))\n+\treduce_with_shift = false;\n       else\n-        {\n-          optab optab = optab_for_tree_code (code, vectype, optab_default);\n-          if (optab_handler (optab, mode) == CODE_FOR_nothing)\n-            reduce_with_shift = false;\n-        }\n+\t{\n+\t  optab optab = optab_for_tree_code (code, vectype1, optab_default);\n+\t  if (optab_handler (optab, mode1) == CODE_FOR_nothing)\n+\t    reduce_with_shift = false;\n+\t}\n+\n+      /* First reduce the vector to the desired vector size we should\n+\t do shift reduction on by combining upper and lower halves.  */\n+      new_temp = new_phi_result;\n+      while (sz > sz1)\n+\t{\n+\t  gcc_assert (!slp_reduc);\n+\t  sz /= 2;\n+\t  vectype1 = get_vectype_for_scalar_type_and_size (scalar_type, sz);\n+\n+\t  /* The target has to make sure we support lowpart/highpart\n+\t     extraction, either via direct vector extract or through\n+\t     an integer mode punning.  */\n+\t  tree dst1, dst2;\n+\t  if (convert_optab_handler (vec_extract_optab,\n+\t\t\t\t     TYPE_MODE (TREE_TYPE (new_temp)),\n+\t\t\t\t     TYPE_MODE (vectype1))\n+\t      != CODE_FOR_nothing)\n+\t    {\n+\t      /* Extract sub-vectors directly once vec_extract becomes\n+\t\t a conversion optab.  */\n+\t      dst1 = make_ssa_name (vectype1);\n+\t      epilog_stmt\n+\t\t  = gimple_build_assign (dst1, BIT_FIELD_REF,\n+\t\t\t\t\t build3 (BIT_FIELD_REF, vectype1,\n+\t\t\t\t\t\t new_temp, TYPE_SIZE (vectype1),\n+\t\t\t\t\t\t bitsize_int (0)));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      dst2 =  make_ssa_name (vectype1);\n+\t      epilog_stmt\n+\t\t  = gimple_build_assign (dst2, BIT_FIELD_REF,\n+\t\t\t\t\t build3 (BIT_FIELD_REF, vectype1,\n+\t\t\t\t\t\t new_temp, TYPE_SIZE (vectype1),\n+\t\t\t\t\t\t bitsize_int (sz * BITS_PER_UNIT)));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Extract via punning to appropriately sized integer mode\n+\t\t vector.  */\n+\t      tree eltype = build_nonstandard_integer_type (sz * BITS_PER_UNIT,\n+\t\t\t\t\t\t\t    1);\n+\t      tree etype = build_vector_type (eltype, 2);\n+\t      gcc_assert (convert_optab_handler (vec_extract_optab,\n+\t\t\t\t\t\t TYPE_MODE (etype),\n+\t\t\t\t\t\t TYPE_MODE (eltype))\n+\t\t\t  != CODE_FOR_nothing);\n+\t      tree tem = make_ssa_name (etype);\n+\t      epilog_stmt = gimple_build_assign (tem, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t etype, new_temp));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      new_temp = tem;\n+\t      tem = make_ssa_name (eltype);\n+\t      epilog_stmt\n+\t\t  = gimple_build_assign (tem, BIT_FIELD_REF,\n+\t\t\t\t\t build3 (BIT_FIELD_REF, eltype,\n+\t\t\t\t\t\t new_temp, TYPE_SIZE (eltype),\n+\t\t\t\t\t\t bitsize_int (0)));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      dst1 = make_ssa_name (vectype1);\n+\t      epilog_stmt = gimple_build_assign (dst1, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t vectype1, tem));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      tem = make_ssa_name (eltype);\n+\t      epilog_stmt\n+\t\t  = gimple_build_assign (tem, BIT_FIELD_REF,\n+\t\t\t\t\t build3 (BIT_FIELD_REF, eltype,\n+\t\t\t\t\t\t new_temp, TYPE_SIZE (eltype),\n+\t\t\t\t\t\t bitsize_int (sz * BITS_PER_UNIT)));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      dst2 =  make_ssa_name (vectype1);\n+\t      epilog_stmt = gimple_build_assign (dst2, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t vectype1, tem));\n+\t      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t    }\n+\n+\t  new_temp = make_ssa_name (vectype1);\n+\t  epilog_stmt = gimple_build_assign (new_temp, code, dst1, dst2);\n+\t  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t}\n \n       if (reduce_with_shift && !slp_reduc)\n-        {\n-          int nelements = vec_size_in_bits / element_bitsize;\n+\t{\n+\t  int element_bitsize = tree_to_uhwi (bitsize);\n+\t  /* Enforced by vectorizable_reduction, which disallows SLP reductions\n+\t     for variable-length vectors and also requires direct target support\n+\t     for loop reductions.  */\n+\t  int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype1));\n+\t  int nelements = vec_size_in_bits / element_bitsize;\n \t  vec_perm_builder sel;\n \t  vec_perm_indices indices;\n \n           int elt_offset;\n \n-          tree zero_vec = build_zero_cst (vectype);\n+          tree zero_vec = build_zero_cst (vectype1);\n           /* Case 2: Create:\n              for (offset = nelements/2; offset >= 1; offset/=2)\n                 {\n@@ -5118,15 +5208,15 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n             dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Reduce using vector shifts\\n\");\n \n-          vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-          new_temp = new_phi_result;\n+\t  mode1 = TYPE_MODE (vectype1);\n+          vec_dest = vect_create_destination_var (scalar_dest, vectype1);\n           for (elt_offset = nelements / 2;\n                elt_offset >= 1;\n                elt_offset /= 2)\n             {\n \t      calc_vec_perm_mask_for_shift (elt_offset, nelements, &sel);\n \t      indices.new_vector (sel, 2, nelements);\n-\t      tree mask = vect_gen_perm_mask_any (vectype, indices);\n+\t      tree mask = vect_gen_perm_mask_any (vectype1, indices);\n \t      epilog_stmt = gimple_build_assign (vec_dest, VEC_PERM_EXPR,\n \t\t\t\t\t\t new_temp, zero_vec, mask);\n               new_name = make_ssa_name (vec_dest, epilog_stmt);\n@@ -5171,7 +5261,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n             dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Reduce using scalar code.\\n\");\n \n-          vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n+\t  int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype1));\n+\t  int element_bitsize = tree_to_uhwi (bitsize);\n           FOR_EACH_VEC_ELT (new_phis, i, new_phi)\n             {\n               int bit_offset;"}, {"sha": "50b35fc60af92a36cbba8544f5355f2ce194f9bc", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -9068,7 +9068,7 @@ free_stmt_vec_info (gimple *stmt)\n    Returns the vector type corresponding to SCALAR_TYPE  and SIZE as supported\n    by the target.  */\n \n-static tree\n+tree\n get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n {\n   tree orig_scalar_type = scalar_type;"}, {"sha": "129cde07cbf5b6be159c93630f2e07eb370813b3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c803b2a92822c57abf5464deaf5be5c31d8a4692/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c803b2a92822c57abf5464deaf5be5c31d8a4692", "patch": "@@ -1209,6 +1209,7 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n /* In tree-vect-stmts.c.  */\n extern poly_uint64 current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n+extern tree get_vectype_for_scalar_type_and_size (tree, poly_uint64);\n extern tree get_mask_type_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_is_simple_use (tree, vec_info *, gimple **,"}]}