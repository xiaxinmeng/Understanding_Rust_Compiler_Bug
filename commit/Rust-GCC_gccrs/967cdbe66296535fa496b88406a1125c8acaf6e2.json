{"sha": "967cdbe66296535fa496b88406a1125c8acaf6e2", "node_id": "C_kwDOANBUbNoAKDk2N2NkYmU2NjI5NjUzNWZhNDk2Yjg4NDA2YTExMjVjOGFjYWY2ZTI", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-12T21:46:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-05-06T20:29:49Z"}, "message": "c++: empty base constexpr adjustment [PR105245]\n\nWhile looking at PR105245 in stage 4, I wanted to reorganize the code a bit,\nbut it seemed prudent to defer that to stage 1.\n\n\tPR c++/105245\n\tPR c++/100111\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (cxx_eval_store_expression): Reorganize empty base\n\thandling.", "tree": {"sha": "8433a2067d4817f40c43363ae4ea2240784b5f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8433a2067d4817f40c43363ae4ea2240784b5f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/967cdbe66296535fa496b88406a1125c8acaf6e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967cdbe66296535fa496b88406a1125c8acaf6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967cdbe66296535fa496b88406a1125c8acaf6e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967cdbe66296535fa496b88406a1125c8acaf6e2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "469c76f0d94d03e29467a9d1e77cd3613f46ac2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469c76f0d94d03e29467a9d1e77cd3613f46ac2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469c76f0d94d03e29467a9d1e77cd3613f46ac2f"}], "stats": {"total": 67, "additions": 34, "deletions": 33}, "files": [{"sha": "6c204ab226549993af7a63b37a26f07d9196594f", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967cdbe66296535fa496b88406a1125c8acaf6e2/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967cdbe66296535fa496b88406a1125c8acaf6e2/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=967cdbe66296535fa496b88406a1125c8acaf6e2", "patch": "@@ -5718,6 +5718,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   releasing_vec ctors, indexes;\n   auto_vec<int> index_pos_hints;\n   bool activated_union_member_p = false;\n+  bool empty_base = false;\n   while (!refs->is_empty ())\n     {\n       if (*valp == NULL_TREE)\n@@ -5759,7 +5760,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       no_zero_init = CONSTRUCTOR_NO_CLEARING (*valp);\n \n       enum tree_code code = TREE_CODE (type);\n-      type = refs->pop();\n+      tree reftype = refs->pop();\n       tree index = refs->pop();\n \n       if (code == RECORD_TYPE && is_empty_field (index))\n@@ -5768,7 +5769,12 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t   fields, which confuses the middle-end.  The code below will notice\n \t   that we don't have a CONSTRUCTOR for our inner target and just\n \t   return init.  */\n-\tbreak;\n+\t{\n+\t  empty_base = true;\n+\t  break;\n+\t}\n+\n+      type = reftype;\n \n       if (code == UNION_TYPE && CONSTRUCTOR_NELTS (*valp)\n \t  && CONSTRUCTOR_ELT (*valp, 0)->index != index)\n@@ -5902,45 +5908,42 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t}\n     }\n \n+  if (*non_constant_p)\n+    return t;\n+\n   /* Don't share a CONSTRUCTOR that might be changed later.  */\n   init = unshare_constructor (init);\n \n-  if (*valp && TREE_CODE (*valp) == CONSTRUCTOR\n-      && TREE_CODE (init) == CONSTRUCTOR)\n+  gcc_checking_assert (!*valp || (same_type_ignoring_top_level_qualifiers_p\n+\t\t\t\t  (TREE_TYPE (*valp), type)));\n+  if (empty_base || !(same_type_ignoring_top_level_qualifiers_p\n+\t\t      (TREE_TYPE (init), type)))\n+    {\n+      /* For initialization of an empty base, the original target will be\n+       *(base*)this, evaluation of which resolves to the object\n+       argument, which has the derived type rather than the base type.  In\n+       this situation, just evaluate the initializer and return, since\n+       there's no actual data to store, and we didn't build a CONSTRUCTOR.  */\n+      empty_base = true;\n+      gcc_assert (is_empty_class (TREE_TYPE (init)));\n+      if (!*valp)\n+\t{\n+\t  /* But do make sure we have something in *valp.  */\n+\t  *valp = build_constructor (type, nullptr);\n+\t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n+\t}\n+    }\n+  else if (*valp && TREE_CODE (*valp) == CONSTRUCTOR\n+\t   && TREE_CODE (init) == CONSTRUCTOR)\n     {\n       /* An outer ctx->ctor might be pointing to *valp, so replace\n \t its contents.  */\n-      if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init),\n-\t\t\t\t\t\t      TREE_TYPE (*valp)))\n-\t{\n-\t  /* For initialization of an empty base, the original target will be\n-\t   *(base*)this, evaluation of which resolves to the object\n-\t   argument, which has the derived type rather than the base type.  In\n-\t   this situation, just evaluate the initializer and return, since\n-\t   there's no actual data to store.  */\n-\t  gcc_assert (is_empty_class (TREE_TYPE (init)));\n-\t  return lval ? target : init;\n-\t}\n       CONSTRUCTOR_ELTS (*valp) = CONSTRUCTOR_ELTS (init);\n       TREE_CONSTANT (*valp) = TREE_CONSTANT (init);\n       TREE_SIDE_EFFECTS (*valp) = TREE_SIDE_EFFECTS (init);\n       CONSTRUCTOR_NO_CLEARING (*valp)\n \t= CONSTRUCTOR_NO_CLEARING (init);\n     }\n-  else if (TREE_CODE (init) == CONSTRUCTOR\n-\t   && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init),\n-\t\t\t\t\t\t\t  type))\n-    {\n-      /* See above on initialization of empty bases.  */\n-      gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);\n-      if (!*valp)\n-\t{\n-\t  /* But do make sure we have something in *valp.  */\n-\t  *valp = build_constructor (type, nullptr);\n-\t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n-\t}\n-      return init;\n-    }\n   else\n     *valp = init;\n \n@@ -5958,7 +5961,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t   constructor of a delegating constructor).  Leave it up to the\n \t   caller that set 'this' to set TREE_READONLY appropriately.  */\n \tgcc_checking_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t\t     (TREE_TYPE (target), type));\n+\t\t\t     (TREE_TYPE (target), type) || empty_base);\n       else\n \tTREE_READONLY (*valp) = true;\n     }\n@@ -5980,9 +5983,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  CONSTRUCTOR_NO_CLEARING (elt) = false;\n       }\n \n-  if (*non_constant_p)\n-    return t;\n-  else if (lval)\n+  if (lval)\n     return target;\n   else\n     return init;"}]}