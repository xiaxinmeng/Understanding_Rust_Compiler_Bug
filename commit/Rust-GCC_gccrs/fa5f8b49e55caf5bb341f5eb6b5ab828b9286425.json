{"sha": "fa5f8b49e55caf5bb341f5eb6b5ab828b9286425", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1ZjhiNDllNTVjYWY1YmIzNDFmNWViNmI1YWI4MjhiOTI4NjQyNQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-06-08T14:33:40Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-16T16:53:13Z"}, "message": "rs6000: Red-black tree implementation for balanced tree search\n\n2021-06-08  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rbtree.c: New file.\n\t* config/rs6000/rbtree.h: New file.", "tree": {"sha": "1d467e95dbe5f797ffc58a99f176e47330b962d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d467e95dbe5f797ffc58a99f176e47330b962d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425/comments", "author": null, "committer": null, "parents": [{"sha": "e11b02f17206af70f72a82ff1167a2676d5b18c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11b02f17206af70f72a82ff1167a2676d5b18c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11b02f17206af70f72a82ff1167a2676d5b18c9"}], "stats": {"total": 294, "additions": 294, "deletions": 0}, "files": [{"sha": "37a559c1fbcf833defc379b4ba7d1da55f30776f", "filename": "gcc/config/rs6000/rbtree.c", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425/gcc%2Fconfig%2Frs6000%2Frbtree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425/gcc%2Fconfig%2Frs6000%2Frbtree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frbtree.c?ref=fa5f8b49e55caf5bb341f5eb6b5ab828b9286425", "patch": "@@ -0,0 +1,242 @@\n+/* Partial red-black tree implementation for rs6000-gen-builtins.c.\n+   Copyright (C) 2020-21 Free Software Foundation, Inc.\n+   Contributed by Bill Schmidt, IBM <wschmidt@linux.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"rbtree.h\"\n+\n+/* Initialize a red-black tree.  */\n+void\n+rbt_new (struct rbt_strings *t)\n+{\n+  t->rbt_nil = (rbt_string_node *) malloc (sizeof (rbt_string_node));\n+  t->rbt_nil->color = RBT_BLACK;\n+  t->rbt_root = t->rbt_nil;\n+}\n+\n+/* Create a new node to be inserted into the red-black tree.  An inserted\n+   node starts out red.  */\n+static struct rbt_string_node *\n+rbt_create_node (struct rbt_strings *t, char *str)\n+{\n+  struct rbt_string_node *nodeptr\n+    = (struct rbt_string_node *) malloc (sizeof (rbt_string_node));\n+  nodeptr->str = str;\n+  nodeptr->left = t->rbt_nil;\n+  nodeptr->right = t->rbt_nil;\n+  nodeptr->par = NULL;\n+  nodeptr->color = RBT_RED;\n+  return nodeptr;\n+}\n+\n+/* Perform a left-rotate operation on NODE in the red-black tree.  */\n+static void\n+rbt_left_rotate (struct rbt_strings *t, struct rbt_string_node *node)\n+{\n+  struct rbt_string_node *right = node->right;\n+  assert (right);\n+\n+  /* Turn RIGHT's left subtree into NODE's right subtree.  */\n+  node->right = right->left;\n+  if (right->left != t->rbt_nil)\n+    right->left->par = node;\n+\n+  /* Link NODE's parent to RIGHT.  */\n+  right->par = node->par;\n+\n+  if (node->par == t->rbt_nil)\n+    t->rbt_root = right;\n+  else if (node == node->par->left)\n+    node->par->left = right;\n+  else\n+    node->par->right = right;\n+\n+  /* Put NODE on RIGHT's left.  */\n+  right->left = node;\n+  node->par = right;\n+}\n+\n+/* Perform a right-rotate operation on NODE in the red-black tree.  */\n+static void\n+rbt_right_rotate (struct rbt_strings *t, struct rbt_string_node *node)\n+{\n+  struct rbt_string_node *left = node->left;\n+  assert (left);\n+\n+  /* Turn LEFT's right subtree into NODE's left subtree.  */\n+  node->left = left->right;\n+  if (left->right != t->rbt_nil)\n+    left->right->par = node;\n+\n+  /* Link NODE's parent to LEFT.  */\n+  left->par = node->par;\n+\n+  if (node->par == t->rbt_nil)\n+    t->rbt_root = left;\n+  else if (node == node->par->right)\n+    node->par->right = left;\n+  else\n+    node->par->left = left;\n+\n+  /* Put NODE on LEFT's right.  */\n+  left->right = node;\n+  node->par = left;\n+}\n+\n+/* Insert STR into the tree, returning 1 for success and 0 if STR already\n+   appears in the tree.  */\n+int\n+rbt_insert (struct rbt_strings *t, char *str)\n+{\n+  struct rbt_string_node *curr = t->rbt_root;\n+  struct rbt_string_node *trail = t->rbt_nil;\n+\n+  while (curr != t->rbt_nil)\n+    {\n+      trail = curr;\n+      int cmp = strcmp (str, curr->str);\n+      if (cmp < 0)\n+\tcurr = curr->left;\n+      else if (cmp > 0)\n+\tcurr = curr->right;\n+      else\n+\treturn 0;\n+    }\n+\n+  struct rbt_string_node *fresh = rbt_create_node (t, str);\n+  fresh->par = trail;\n+\n+  if (trail == t->rbt_nil)\n+    t->rbt_root = fresh;\n+  else if (strcmp (fresh->str, trail->str) < 0)\n+    trail->left = fresh;\n+  else\n+    trail->right = fresh;\n+\n+  fresh->left = t->rbt_nil;\n+  fresh->right = t->rbt_nil;\n+\n+  /* FRESH has now been inserted as a red leaf.  If we have invalidated\n+     one of the following preconditions, we must fix things up:\n+      (a) If a node is red, both of its children are black.\n+      (b) The root must be black.\n+     Note that only (a) or (b) applies at any given time during the\n+     process.  This algorithm works up the tree from NEW looking\n+     for a red child with a red parent, and cleaning that up.  If the\n+     root ends up red, it gets turned black at the end.  */\n+  curr = fresh;\n+  while (curr->par->color == RBT_RED)\n+    if (curr->par == curr->par->par->left)\n+      {\n+\tstruct rbt_string_node *uncle = curr->par->par->right;\n+\tif (uncle->color == RBT_RED)\n+\t  {\n+\t    curr->par->color = RBT_BLACK;\n+\t    uncle->color = RBT_BLACK;\n+\t    curr->par->par->color = RBT_RED;\n+\t    curr = curr->par->par;\n+\t  }\n+\telse if (curr == curr->par->right)\n+\t  {\n+\t    curr = curr->par;\n+\t    rbt_left_rotate (t, curr);\n+\t  }\n+\telse\n+\t  {\n+\t    curr->par->color = RBT_BLACK;\n+\t    curr->par->par->color = RBT_RED;\n+\t    rbt_right_rotate (t, curr->par->par);\n+\t  }\n+      }\n+    else /* curr->par == curr->par->par->right  */\n+      {\n+\t/* Gender-neutral formations are awkward, so let's be fair. ;-)\n+\t   (\"Parent-sibling\" is just awful.)  */\n+\tstruct rbt_string_node *aunt = curr->par->par->left;\n+\tif (aunt->color == RBT_RED)\n+\t  {\n+\t    curr->par->color = RBT_BLACK;\n+\t    aunt->color = RBT_BLACK;\n+\t    curr->par->par->color = RBT_RED;\n+\t    curr = curr->par->par;\n+\t  }\n+\telse if (curr == curr->par->left)\n+\t  {\n+\t    curr = curr->par;\n+\t    rbt_right_rotate (t, curr);\n+\t  }\n+\telse\n+\t  {\n+\t    curr->par->color = RBT_BLACK;\n+\t    curr->par->par->color = RBT_RED;\n+\t    rbt_left_rotate (t, curr->par->par);\n+\t  }\n+      }\n+\n+  t->rbt_root->color = RBT_BLACK;\n+  return 1;\n+}\n+\n+/* Return 1 if STR is in the red-black tree, else 0.  */\n+int\n+rbt_find (struct rbt_strings *t, char *str)\n+{\n+  struct rbt_string_node *curr = t->rbt_root;\n+\n+  while (curr != t->rbt_nil)\n+    {\n+      int cmp = strcmp (str, curr->str);\n+      if (cmp < 0)\n+\tcurr = curr->left;\n+      else if (cmp > 0)\n+\tcurr = curr->right;\n+      else\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Inorder dump of the binary search tree.  */\n+void\n+rbt_dump (struct rbt_strings *t, struct rbt_string_node *subtree)\n+{\n+  if (subtree != t->rbt_nil)\n+    {\n+      rbt_dump (t, subtree->left);\n+      fprintf (stderr, \"%s\\n\", subtree->str);\n+      rbt_dump (t, subtree->right);\n+    }\n+}\n+\n+/* Inorder call-back for iteration over the tree.  */\n+void\n+rbt_inorder_callback (struct rbt_strings *t, struct rbt_string_node *subtree,\n+\t\t      void (*fn) (char *))\n+{\n+  if (subtree != t->rbt_nil)\n+    {\n+      rbt_inorder_callback (t, subtree->left, fn);\n+      (*fn) (subtree->str);\n+      rbt_inorder_callback (t, subtree->right, fn);\n+    }\n+}"}, {"sha": "fab0001ffdea8c64b0b513b94232d116db21f6ff", "filename": "gcc/config/rs6000/rbtree.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425/gcc%2Fconfig%2Frs6000%2Frbtree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5f8b49e55caf5bb341f5eb6b5ab828b9286425/gcc%2Fconfig%2Frs6000%2Frbtree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frbtree.h?ref=fa5f8b49e55caf5bb341f5eb6b5ab828b9286425", "patch": "@@ -0,0 +1,52 @@\n+/* Partial red-black tree implementation for rs6000-gen-builtins.c.\n+   Copyright (C) 2020-21 Free Software Foundation, Inc.\n+   Contributed by Bill Schmidt, IBM <wschmidt@linux.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Red-black binary search tree on strings.  Presently we don't support\n+   deletes; only insert/find operations are implemented.  */\n+enum rbt_color\n+  {\n+    RBT_BLACK,\n+    RBT_RED\n+  };\n+\n+struct rbt_string_node {\n+  char *str;\n+  struct rbt_string_node *left;\n+  struct rbt_string_node *right;\n+  struct rbt_string_node *par;\n+  enum rbt_color color;\n+};\n+\n+/* Root and sentinel nodes of a red-black tree.\n+   rbt_nil points to a sentinel node, which is the parent of root\n+   and the child of every node without a \"real\" left or right child.\n+   rbt_root points to the root of the tree, if it exists yet.  The\n+   root and sentinel nodes are always black.  */\n+struct rbt_strings {\n+  struct rbt_string_node *rbt_nil;\n+  struct rbt_string_node *rbt_root;\n+};\n+\n+void rbt_new (struct rbt_strings *);\n+int rbt_insert (struct rbt_strings *, char *);\n+int rbt_find (struct rbt_strings *, char *);\n+void rbt_dump (struct rbt_strings *, struct rbt_string_node *);\n+void rbt_inorder_callback (struct rbt_strings *, struct rbt_string_node *,\n+\t\t\t   void (*) (char *));"}]}