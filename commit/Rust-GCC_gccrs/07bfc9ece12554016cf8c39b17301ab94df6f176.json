{"sha": "07bfc9ece12554016cf8c39b17301ab94df6f176", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiZmM5ZWNlMTI1NTQwMTZjZjhjMzliMTczMDFhYjk0ZGY2ZjE3Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-05-03T11:09:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-05-03T11:09:59Z"}, "message": "double-int.h (lshift): New overload without precision and arith argument.\n\n2013-05-03  Richard Biener  <rguenther@suse.de>\n\n\t* double-int.h (lshift): New overload without precision\n\tand arith argument.\n\t(operator *=, operator +=, operator -=): Move ...\n\t* double-int.c (operator *=, operator +=, operator -=): ... here\n\tand implement more efficiently.\n\t(mul_double_with_sign): Remove.\n\t(lshift_double): Adjust to take unsinged shift argument, push\n\tdispatching code to callers.\n\t(mul_double_wide_with_sign): Add early out for callers that\n\tare not interested in high parts or overflow.\n\t(lshift): New function.\n\t(lshift, rshift, alshift, arshift, llshift, lrshift): Add\n\tdispatch code here.\n\t(lrotate, rrotate): Use logical shifts.\n\t* expr.c (get_inner_reference): Use lshift.\n\t* fixed-value.c (do_fixed_divide): Likewise.\n\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Likewise.\n\t(indirect_refs_may_alias_p): Likewise.\n\t(stmt_kills_ref_p_1): Likewise.\n\nFrom-SVN: r198576", "tree": {"sha": "7d533f06f94bafb5dd09f062d0ef17a1ab83a989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d533f06f94bafb5dd09f062d0ef17a1ab83a989"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07bfc9ece12554016cf8c39b17301ab94df6f176", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07bfc9ece12554016cf8c39b17301ab94df6f176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07bfc9ece12554016cf8c39b17301ab94df6f176", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07bfc9ece12554016cf8c39b17301ab94df6f176/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7769bb64f35fea465d47288bcc8dae542257162f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7769bb64f35fea465d47288bcc8dae542257162f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7769bb64f35fea465d47288bcc8dae542257162f"}], "stats": {"total": 259, "additions": 151, "deletions": 108}, "files": [{"sha": "ad545ae6aa5eca41706eb2ac62c9539d5ed8d5e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -1,3 +1,26 @@\n+2013-05-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* double-int.h (lshift): New overload without precision\n+\tand arith argument.\n+\t(operator *=, operator +=, operator -=): Move ...\n+\t* double-int.c (operator *=, operator +=, operator -=): ... here\n+\tand implement more efficiently.\n+\t(mul_double_with_sign): Remove.\n+\t(lshift_double): Adjust to take unsinged shift argument, push\n+\tdispatching code to callers.\n+\t(mul_double_wide_with_sign): Add early out for callers that\n+\tare not interested in high parts or overflow.\n+\t(lshift): New function.\n+\t(lshift, rshift, alshift, arshift, llshift, lrshift): Add\n+\tdispatch code here.\n+\t(lrotate, rrotate): Use logical shifts.\n+\t* expr.c (get_inner_reference): Use lshift.\n+\t* fixed-value.c (do_fixed_divide): Likewise.\n+\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Likewise.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t(stmt_kills_ref_p_1): Likewise.\n+\n 2013-05-03  Vidya Praveen  <vidyapraveen@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (simd_fabd): Correct the description."}, {"sha": "b098f57b65cde9b3675b03b301df8e1327d85a65", "filename": "gcc/double-int.c", "status": "modified", "additions": 105, "deletions": 49, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -34,23 +34,14 @@ static int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n static int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n \n-static int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t bool);\n-\n static int mul_double_wide_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t      unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t      bool);\n \n #define mul_double(l1,h1,l2,h2,lv,hv) \\\n-  mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n-\n-static void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t   HOST_WIDE_INT, unsigned int,\n-\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n+  mul_double_wide_with_sign (l1, h1, l2, h2, lv, hv, NULL, NULL, false)\n \n static int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n@@ -158,25 +149,13 @@ neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n     }\n }\n \n-/* Multiply two doubleword integers with doubleword result.\n+/* Multiply two doubleword integers with quadword result.\n    Return nonzero if the operation overflows according to UNSIGNED_P.\n    Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-static int\n-mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n-\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n-\t\t      bool unsigned_p)\n-{\n-  unsigned HOST_WIDE_INT toplow;\n-  HOST_WIDE_INT tophigh;\n-\n-  return mul_double_wide_with_sign (l1, h1, l2, h2,\n-\t\t\t\t    lv, hv, &toplow, &tophigh,\n-\t\t\t\t    unsigned_p);\n-}\n+   The value is stored as four `HOST_WIDE_INT' pieces in *LV and *HV,\n+   *LW and *HW.\n+   If lw is NULL then only the low part and no overflow is computed.  */\n \n static int\n mul_double_wide_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n@@ -215,6 +194,11 @@ mul_double_wide_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n     }\n \n   decode (prod, lv, hv);\n+\n+  /* We are not interested in the wide part nor in overflow.  */\n+  if (lw == NULL)\n+    return 0;\n+\n   decode (prod + 4, lw, hw);\n \n   /* Unsigned overflow is immediate.  */\n@@ -306,17 +290,11 @@ rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \n static void\n lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t       HOST_WIDE_INT count, unsigned int prec,\n-\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, bool arith)\n+\t       unsigned HOST_WIDE_INT count, unsigned int prec,\n+\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT signmask;\n \n-  if (count < 0)\n-    {\n-      rshift_double (l1, h1, absu_hwi (count), prec, lv, hv, arith);\n-      return;\n-    }\n-\n   if (SHIFT_COUNT_TRUNCATED)\n     count %= prec;\n \n@@ -832,16 +810,26 @@ double_int::operator * (double_int b) const\n   return ret;\n }\n \n+/* Multiplies *this with B and returns a reference to *this.  */\n+\n+double_int &\n+double_int::operator *= (double_int b)\n+{\n+  mul_double (low, high, b.low, b.high, &low, &high);\n+  return *this;\n+}\n+\n /* Returns A * B. If the operation overflows according to UNSIGNED_P,\n    *OVERFLOW is set to nonzero.  */\n \n double_int\n double_int::mul_with_sign (double_int b, bool unsigned_p, bool *overflow) const\n {\n   const double_int &a = *this;\n-  double_int ret;\n-  *overflow = mul_double_with_sign (a.low, a.high, b.low, b.high,\n-                                    &ret.low, &ret.high, unsigned_p);\n+  double_int ret, tem;\n+  *overflow = mul_double_wide_with_sign (a.low, a.high, b.low, b.high,\n+\t\t\t\t\t &ret.low, &ret.high,\n+\t\t\t\t\t &tem.low, &tem.high, unsigned_p);\n   return ret;\n }\n \n@@ -869,6 +857,16 @@ double_int::operator + (double_int b) const\n   return ret;\n }\n \n+/* Adds B to *this and returns a reference to *this.  */\n+\n+double_int &\n+double_int::operator += (double_int b)\n+{\n+  add_double (low, high, b.low, b.high, &low, &high);\n+  return *this;\n+}\n+\n+\n /* Returns A + B. If the operation overflows according to UNSIGNED_P,\n    *OVERFLOW is set to nonzero.  */\n \n@@ -894,6 +892,17 @@ double_int::operator - (double_int b) const\n   return ret;\n }\n \n+/* Subtracts B from *this and returns a reference to *this.  */\n+\n+double_int &\n+double_int::operator -= (double_int b)\n+{\n+  neg_double (b.low, b.high, &b.low, &b.high);\n+  add_double (low, high, b.low, b.high, &low, &high);\n+  return *this;\n+}\n+\n+\n /* Returns A - B. If the operation overflows via inconsistent sign bits,\n    *OVERFLOW is set to nonzero.  */\n \n@@ -1076,16 +1085,49 @@ double_int::trailing_zeros () const\n   return bits;\n }\n \n+/* Shift A left by COUNT places.  */\n+\n+double_int\n+double_int::lshift (HOST_WIDE_INT count) const\n+{\n+  double_int ret;\n+\n+  gcc_checking_assert (count >= 0);\n+\n+  if (count >= HOST_BITS_PER_DOUBLE_INT)\n+    {\n+      /* Shifting by the host word size is undefined according to the\n+\t ANSI standard, so we must handle this as a special case.  */\n+      ret.high = 0;\n+      ret.low = 0;\n+    }\n+  else if (count >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      ret.high = low << (count - HOST_BITS_PER_WIDE_INT);\n+      ret.low = 0;\n+    }\n+  else\n+    {\n+      ret.high = (((unsigned HOST_WIDE_INT) high << count)\n+\t     | (low >> (HOST_BITS_PER_WIDE_INT - count - 1) >> 1));\n+      ret.low = low << count;\n+    }\n+\n+  return ret;\n+}\n+\n /* Shift A left by COUNT places keeping only PREC bits of result.  Shift\n    right if COUNT is negative.  ARITH true specifies arithmetic shifting;\n    otherwise use logical shift.  */\n \n double_int\n double_int::lshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const\n {\n-  const double_int &a = *this;\n   double_int ret;\n-  lshift_double (a.low, a.high, count, prec, &ret.low, &ret.high, arith);\n+  if (count > 0)\n+    lshift_double (low, high, count, prec, &ret.low, &ret.high);\n+  else\n+    rshift_double (low, high, absu_hwi (count), prec, &ret.low, &ret.high, arith);\n   return ret;\n }\n \n@@ -1096,9 +1138,11 @@ double_int::lshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const\n double_int\n double_int::rshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const\n {\n-  const double_int &a = *this;\n   double_int ret;\n-  lshift_double (a.low, a.high, -count, prec, &ret.low, &ret.high, arith);\n+  if (count > 0)\n+    rshift_double (low, high, count, prec, &ret.low, &ret.high, arith);\n+  else\n+    lshift_double (low, high, absu_hwi (count), prec, &ret.low, &ret.high);\n   return ret;\n }\n \n@@ -1109,7 +1153,10 @@ double_int\n double_int::alshift (HOST_WIDE_INT count, unsigned int prec) const\n {\n   double_int r;\n-  lshift_double (low, high, count, prec, &r.low, &r.high, true);\n+  if (count > 0)\n+    lshift_double (low, high, count, prec, &r.low, &r.high);\n+  else\n+    rshift_double (low, high, absu_hwi (count), prec, &r.low, &r.high, true);\n   return r;\n }\n \n@@ -1120,7 +1167,10 @@ double_int\n double_int::arshift (HOST_WIDE_INT count, unsigned int prec) const\n {\n   double_int r;\n-  lshift_double (low, high, -count, prec, &r.low, &r.high, true);\n+  if (count > 0)\n+    rshift_double (low, high, count, prec, &r.low, &r.high, true);\n+  else\n+    lshift_double (low, high, absu_hwi (count), prec, &r.low, &r.high);\n   return r;\n }\n \n@@ -1131,7 +1181,10 @@ double_int\n double_int::llshift (HOST_WIDE_INT count, unsigned int prec) const\n {\n   double_int r;\n-  lshift_double (low, high, count, prec, &r.low, &r.high, false);\n+  if (count > 0)\n+    lshift_double (low, high, count, prec, &r.low, &r.high);\n+  else\n+    rshift_double (low, high, absu_hwi (count), prec, &r.low, &r.high, false);\n   return r;\n }\n \n@@ -1142,7 +1195,10 @@ double_int\n double_int::lrshift (HOST_WIDE_INT count, unsigned int prec) const\n {\n   double_int r;\n-  lshift_double (low, high, -count, prec, &r.low, &r.high, false);\n+  if (count > 0)\n+    rshift_double (low, high, count, prec, &r.low, &r.high, false);\n+  else\n+    lshift_double (low, high, absu_hwi (count), prec, &r.low, &r.high);\n   return r;\n }\n \n@@ -1158,8 +1214,8 @@ double_int::lrotate (HOST_WIDE_INT count, unsigned int prec) const\n   if (count < 0)\n     count += prec;\n \n-  t1 = this->lshift (count, prec, false);\n-  t2 = this->rshift (prec - count, prec, false);\n+  t1 = this->llshift (count, prec);\n+  t2 = this->lrshift (prec - count, prec);\n \n   return t1 | t2;\n }\n@@ -1176,8 +1232,8 @@ double_int::rrotate (HOST_WIDE_INT count, unsigned int prec) const\n   if (count < 0)\n     count += prec;\n \n-  t1 = this->rshift (count, prec, false);\n-  t2 = this->lshift (prec - count, prec, false);\n+  t1 = this->lrshift (count, prec);\n+  t2 = this->llshift (prec - count, prec);\n \n   return t1 | t2;\n }"}, {"sha": "39929d2b5bf1ddbf2fed1e257703387eb9f7c77e", "filename": "gcc/double-int.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -128,6 +128,7 @@ struct double_int\n   double_int operator ^ (double_int) const;\n   double_int and_not (double_int) const;\n \n+  double_int lshift (HOST_WIDE_INT count) const;\n   double_int lshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const;\n   double_int rshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const;\n   double_int alshift (HOST_WIDE_INT count, unsigned int prec) const;\n@@ -257,27 +258,6 @@ double_int::operator -- ()\n   return *this;\n }\n \n-inline double_int &\n-double_int::operator *= (double_int b)\n-{\n-  *this = *this * b;\n-  return *this;\n-}\n-\n-inline double_int &\n-double_int::operator += (double_int b)\n-{\n-  *this = *this + b;\n-  return *this;\n-}\n-\n-inline double_int &\n-double_int::operator -= (double_int b)\n-{\n-  *this = *this - b;\n-  return *this;\n-}\n-\n inline double_int &\n double_int::operator &= (double_int b)\n {"}, {"sha": "acf282e7808784c2b449d8c7f88c2684d4cd5e7a", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -6704,9 +6704,8 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t      if (!integer_zerop (off))\n \t\t{\n \t\t  double_int boff, coff = mem_ref_offset (exp);\n-\t\t  boff = coff.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t       ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t       HOST_BITS_PER_DOUBLE_INT);\n+\t\t  boff = coff.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t      ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\t  bit_offset += boff;\n \t\t}\n \t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -6732,8 +6731,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n     {\n       double_int tem = tree_to_double_int (offset);\n       tem = tem.sext (TYPE_PRECISION (sizetype));\n-      tem = tem.alshift (BITS_PER_UNIT == 8 ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t HOST_BITS_PER_DOUBLE_INT);\n+      tem = tem.lshift (BITS_PER_UNIT == 8 ? 3 : exact_log2 (BITS_PER_UNIT));\n       tem += bit_offset;\n       if (tem.fits_shwi ())\n \t{"}, {"sha": "8ba78769c791babf1c937cc6a6567d9b9b4133d8", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -569,14 +569,14 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t  int leftmost_mod = (mod.high < 0);\n \n \t  /* Shift left mod by 1 bit.  */\n-\t  mod = mod.llshift (1, HOST_BITS_PER_DOUBLE_INT);\n+\t  mod = mod.lshift (1);\n \n \t  /* Test the leftmost bit of s to add to mod.  */\n \t  if (s.high < 0)\n \t    mod.low += 1;\n \n \t  /* Shift left quo_s by 1 bit.  */\n-\t  quo_s = quo_s.llshift (1, HOST_BITS_PER_DOUBLE_INT);\n+\t  quo_s = quo_s.lshift (1);\n \n \t  /* Try to calculate (mod - pos_b).  */\n \t  temp = mod - pos_b;\n@@ -588,7 +588,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t    }\n \n \t  /* Shift left s by 1 bit.  */\n-\t  s = s.llshift (1, HOST_BITS_PER_DOUBLE_INT);\n+\t  s = s.lshift (1);\n \n \t}\n "}, {"sha": "57aae95a07490d5c5d7eaaa9aafdf855636784a3", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -433,9 +433,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    if (this_offset && TREE_CODE (this_offset) == INTEGER_CST)\n \t      {\n \t\tdouble_int doffset = tree_to_double_int (this_offset);\n-\t\tdoffset = doffset.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t\t   HOST_BITS_PER_DOUBLE_INT);\n+\t\tdoffset = doffset.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t\t  ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\tdoffset += tree_to_double_int (DECL_FIELD_BIT_OFFSET (field));\n \t\tbit_offset = bit_offset + doffset;\n \n@@ -501,9 +500,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t  = (TREE_INT_CST (index) - TREE_INT_CST (low_bound))\n \t\t    .sext (TYPE_PRECISION (TREE_TYPE (index)));\n \t\tdoffset *= tree_to_double_int (unit_size);\n-\t\tdoffset = doffset.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t\t   HOST_BITS_PER_DOUBLE_INT);\n+\t\tdoffset = doffset.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t\t  ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\tbit_offset = bit_offset + doffset;\n \n \t\t/* An array ref with a constant index up in the structure\n@@ -552,9 +550,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t      else\n \t\t{\n \t\t  double_int off = mem_ref_offset (exp);\n-\t\t  off = off.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t     ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t     HOST_BITS_PER_DOUBLE_INT);\n+\t\t  off = off.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\t  off = off + bit_offset;\n \t\t  if (off.fits_shwi ())\n \t\t    {\n@@ -583,9 +580,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t      else\n \t\t{\n \t\t  double_int off = mem_ref_offset (exp);\n-\t\t  off = off.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t     ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t     HOST_BITS_PER_DOUBLE_INT);\n+\t\t  off = off.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\t  off += bit_offset;\n \t\t  if (off.fits_shwi ())\n \t\t    {"}, {"sha": "971a34763d8c36b3bec3becc02795e576b069763", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bfc9ece12554016cf8c39b17301ab94df6f176/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=07bfc9ece12554016cf8c39b17301ab94df6f176", "patch": "@@ -882,9 +882,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   /* The offset embedded in MEM_REFs can be negative.  Bias them\n      so that the resulting offset adjustment is positive.  */\n   moff = mem_ref_offset (base1);\n-  moff = moff.alshift (BITS_PER_UNIT == 8\n-\t\t       ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t       HOST_BITS_PER_DOUBLE_INT);\n+  moff = moff.lshift (BITS_PER_UNIT == 8 ? 3 : exact_log2 (BITS_PER_UNIT));\n   if (moff.is_negative ())\n     offset2p += (-moff).low;\n   else\n@@ -960,9 +958,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       || TREE_CODE (dbase2) == TARGET_MEM_REF)\n     {\n       double_int moff = mem_ref_offset (dbase2);\n-      moff = moff.alshift (BITS_PER_UNIT == 8\n-\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t   HOST_BITS_PER_DOUBLE_INT);\n+      moff = moff.lshift (BITS_PER_UNIT == 8 ? 3 : exact_log2 (BITS_PER_UNIT));\n       if (moff.is_negative ())\n \tdoffset1 -= (-moff).low;\n       else\n@@ -1056,17 +1052,13 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       /* The offset embedded in MEM_REFs can be negative.  Bias them\n \t so that the resulting offset adjustment is positive.  */\n       moff = mem_ref_offset (base1);\n-      moff = moff.alshift (BITS_PER_UNIT == 8\n-\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t   HOST_BITS_PER_DOUBLE_INT);\n+      moff = moff.lshift (BITS_PER_UNIT == 8 ? 3 : exact_log2 (BITS_PER_UNIT));\n       if (moff.is_negative ())\n \toffset2 += (-moff).low;\n       else\n \toffset1 += moff.low;\n       moff = mem_ref_offset (base2);\n-      moff = moff.alshift (BITS_PER_UNIT == 8\n-\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t   HOST_BITS_PER_DOUBLE_INT);\n+      moff = moff.lshift (BITS_PER_UNIT == 8 ? 3 : exact_log2 (BITS_PER_UNIT));\n       if (moff.is_negative ())\n \toffset1 += (-moff).low;\n       else\n@@ -2014,14 +2006,12 @@ stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n \t\t\t\t       TREE_OPERAND (ref->base, 0)))\n \t\t{\n \t\t  double_int off1 = mem_ref_offset (base);\n-\t\t  off1 = off1.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t       ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t       HOST_BITS_PER_DOUBLE_INT);\n+\t\t  off1 = off1.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t      ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\t  off1 = off1 + double_int::from_shwi (offset);\n \t\t  double_int off2 = mem_ref_offset (ref->base);\n-\t\t  off2 = off2.alshift (BITS_PER_UNIT == 8\n-\t\t\t\t       ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t       HOST_BITS_PER_DOUBLE_INT);\n+\t\t  off2 = off2.lshift (BITS_PER_UNIT == 8\n+\t\t\t\t      ? 3 : exact_log2 (BITS_PER_UNIT));\n \t\t  off2 = off2 + double_int::from_shwi (ref_offset);\n \t\t  if (off1.fits_shwi () && off2.fits_shwi ())\n \t\t    {"}]}