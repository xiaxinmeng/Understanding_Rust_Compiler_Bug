{"sha": "b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "node_id": "C_kwDOANBUbNoAKGI2ZDVkNzJiZDBiNzFhYzk2YThiMmVlNTM3MzY3YzQ2MTA3ZGNiNzM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-04T08:37:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-04T08:37:14Z"}, "message": "openmp: Add begin declare target support\n\nThe following patch adds support for the begin declare target construct,\nwhich is another spelling for declare target construct without clauses\n(where it needs paired end declare target), but unlike that one accepts\nclauses.\n\nThis is an OpenMP 5.1 feature, implemented with 5.2 clarification because\nin 5.1 we had a restriction in the declare target chapter shared by\ndeclare target and begin declare target that if there are any clauses\nspecified at least one of them needs to be to or link.  But that\nwas of course meant just for declare target and not begin declare target,\nbecause begin declare target doesn't even allow to/link/enter clauses.\nIn addition to that, the patch also makes device_type clause duplication\nan error (as stated in 5.1) and similarly makes declare target with\njust device_type clause an error rather than warning.\n\nWhat this patch doesn't do is:\n1) OpenMP 5.1 also added an indirect clause, we don't support that\n   neither on declare target nor begin declare target\n   and I couldn't find it in our features pages (neither libgomp.texi\n   nor web)\n2) I think device_type(nohost)/device_type(host) support can't work for\n   variables (in 5.0 it only talked about procedures so this could be\n   also thought as 5.1 feature that we should just add to the list\n   and implement)\n3) I don't see any use of the \"omp declare target nohost\" attribute, so\n   I'm not sure if device_type(nohost) works at all\n\n2022-10-04  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c-family/\n\t* c-omp.cc (c_omp_directives): Uncomment begin declare target\n\tentry.\ngcc/c/\n\t* c-lang.h (struct c_omp_declare_target_attr): New type.\n\t(current_omp_declare_target_attribute): Change type from\n\tint to vec<c_omp_declare_target_attr, va_gc> *.\n\t* c-parser.cc (c_parser_translation_unit): Adjust for that change.\n\tIf last pushed directive was begin declare target, use different\n\twording and simplify format strings for easier translations.\n\t(c_parser_omp_clause_device_type): Uncomment\n\tcheck_no_duplicate_clause call.\n\t(c_parser_omp_declare_target): Adjust for the\n\tcurrent_omp_declare_target_attribute type change, push { -1 }.\n\tUse error_at rather than warning_at for declare target with\n\tonly device_type clauses.\n\t(OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK): Define.\n\t(c_parser_omp_begin): Add begin declare target support.\n\t(c_parser_omp_end): Adjust for the\n\tcurrent_omp_declare_target_attribute type change, adjust\n\tdiagnostics wording and simplify format strings for easier\n\ttranslations.\n\t* c-decl.cc (current_omp_declare_target_attribute): Change type from\n\tint to vec<c_omp_declare_target_attr, va_gc> *.\n\t(c_decl_attributes): Adjust for the\n\tcurrent_omp_declare_target_attribute type change.  If device_type\n\twas present on begin declare target, add \"omp declare target host\"\n\tand/or \"omp declare target nohost\" attributes.\ngcc/cp/\n\t* cp-tree.h (struct omp_declare_target_attr): Rename to ...\n\t(cp_omp_declare_target_attr): ... this.  Add device_type member.\n\t(omp_begin_assumes_data): Rename to ...\n\t(cp_omp_begin_assumes_data): ... this.\n\t(struct saved_scope): Change types of omp_declare_target_attribute\n\tand omp_begin_assumes.\n\t* parser.cc (cp_parser_omp_clause_device_type): Uncomment\n\tcheck_no_duplicate_clause call.\n\t(cp_parser_omp_all_clauses): Fix up pasto, c_name for OMP_CLAUSE_LINK\n\tshould be \"link\" rather than \"to\".\n\t(cp_parser_omp_declare_target): Adjust for omp_declare_target_attr\n\tto cp_omp_declare_target_attr changes, push -1 as device_type.  Use\n\terror_at rather than warning_at for declare target with only\n\tdevice_type clauses.\n\t(OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK): Define.\n\t(cp_parser_omp_begin): Add begin declare target support.  Adjust\n\tfor omp_begin_assumes_data to cp_omp_begin_assumes_data change.\n\t(cp_parser_omp_end): Adjust for the\n\tomp_declare_target_attr to cp_omp_declare_target_attr and\n\tomp_begin_assumes_data to cp_omp_begin_assumes_data type changes,\n\tadjust diagnostics wording and simplify format strings for easier\n\ttranslations.\n\t* semantics.cc (finish_translation_unit): Likewise.\n\t* decl2.cc (cplus_decl_attributes): If device_type was present on\n\tbegin declare target, add \"omp declare target host\" and/or\n\t\"omp declare target nohost\" attributes.\ngcc/testsuite/\n\t* c-c++-common/gomp/declare-target-4.c: Move tests that are now\n\trejected into declare-target-7.c.\n\t* c-c++-common/gomp/declare-target-6.c: Adjust expected diagnostics.\n\t* c-c++-common/gomp/declare-target-7.c: New test.\n\t* c-c++-common/gomp/begin-declare-target-1.c: New test.\n\t* c-c++-common/gomp/begin-declare-target-2.c: New test.\n\t* c-c++-common/gomp/begin-declare-target-3.c: New test.\n\t* c-c++-common/gomp/begin-declare-target-4.c: New test.\n\t* g++.dg/gomp/attrs-9.C: Add begin declare target tests.\n\t* g++.dg/gomp/attrs-18.C: New test.\nlibgomp/\n\t* libgomp.texi (Support begin/end declare target syntax in C/C++):\n\tMark as implemented.", "tree": {"sha": "c65b16d4db14beffbbcd2161d871d096bcd60c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c65b16d4db14beffbbcd2161d871d096bcd60c2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7df3693f745eb909aacd710613811e5951e8af3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df3693f745eb909aacd710613811e5951e8af3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df3693f745eb909aacd710613811e5951e8af3b"}], "stats": {"total": 403, "additions": 328, "deletions": 75}, "files": [{"sha": "5bb10355751ad6d3f09b4a9f194d0bfaaa7b2f2e", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -3112,8 +3112,8 @@ const struct c_omp_directive c_omp_directives[] = {\n     C_OMP_DIR_STANDALONE, false },\n   { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n     C_OMP_DIR_INFORMATIONAL, false },\n-  /* { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n-    C_OMP_DIR_DECLARATIVE, false }, */\n+  { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_DECLARATIVE, false },\n   /* { \"begin\", \"declare\", \"variant\", PRAGMA_OMP_BEGIN,\n     C_OMP_DIR_DECLARATIVE, false }, */\n   /* { \"begin\", \"metadirective\", nullptr, PRAGMA_OMP_BEGIN,"}, {"sha": "ffa63dcd8d2140eca9a027da41f21e29206b5154", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -153,9 +153,9 @@ static int warn_about_return_type;\n \n static bool undef_nested_function;\n \n-/* If non-zero, implicit \"omp declare target\" attribute is added into the\n-   attribute lists.  */\n-int current_omp_declare_target_attribute;\n+/* Vector of implicit \"omp declare target\" attributes to be added into\n+   the attribute lists.  */\n+vec<c_omp_declare_target_attr, va_gc> *current_omp_declare_target_attribute;\n \n /* If non-zero, we are inside of\n    #pragma omp begin assumes ... #pragma omp end assumes region.  */\n@@ -5105,7 +5105,7 @@ static tree\n c_decl_attributes (tree *node, tree attributes, int flags)\n {\n   /* Add implicit \"omp declare target\" attribute if requested.  */\n-  if (current_omp_declare_target_attribute\n+  if (vec_safe_length (current_omp_declare_target_attribute)\n       && ((VAR_P (*node) && is_global_var (*node))\n \t  || TREE_CODE (*node) == FUNCTION_DECL))\n     {\n@@ -5119,6 +5119,22 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \t  attributes = tree_cons (get_identifier (\"omp declare target block\"),\n \t\t\t\t  NULL_TREE, attributes);\n \t}\n+      if (TREE_CODE (*node) == FUNCTION_DECL)\n+\t{\n+\t  int device_type\n+\t    = current_omp_declare_target_attribute->last ().device_type;\n+\t  device_type = MAX (device_type, 0);\n+\t  if ((device_type & OMP_CLAUSE_DEVICE_TYPE_HOST) != 0\n+\t      && !lookup_attribute (\"omp declare target host\", attributes))\n+\t    attributes\n+\t      = tree_cons (get_identifier (\"omp declare target host\"),\n+\t\t\t   NULL_TREE, attributes);\n+\t  if ((device_type & OMP_CLAUSE_DEVICE_TYPE_NOHOST) != 0\n+\t      && !lookup_attribute (\"omp declare target nohost\", attributes))\n+\t    attributes\n+\t      = tree_cons (get_identifier (\"omp declare target nohost\"),\n+\t\t\t   NULL_TREE, attributes);\n+\t}\n     }\n \n   /* Look up the current declaration with all the attributes merged"}, {"sha": "49a5ec3d0482b398106815ce552a853fa80a10ac", "filename": "gcc/c/c-lang.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc%2Fc-lang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc%2Fc-lang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.h?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -60,9 +60,14 @@ struct GTY(()) language_function {\n   int warn_about_return_type;\n };\n \n+struct GTY(()) c_omp_declare_target_attr {\n+  int device_type;\n+};\n+\n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n-extern GTY(()) int current_omp_declare_target_attribute;\n+extern GTY(()) vec<c_omp_declare_target_attr, va_gc>\n+  *current_omp_declare_target_attribute;\n /* Similarly whether we are in between #pragma omp begin assumes and\n    #pragma omp end assumes (and how many times when nested).  */\n extern GTY(()) int current_omp_begin_assumes;"}, {"sha": "f6a94ba31d81de62cef62c26303c878d501d7455", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -1675,18 +1675,22 @@ c_parser_translation_unit (c_parser *parser)\n     if (DECL_SIZE (decl) == NULL_TREE && TREE_TYPE (decl) != error_mark_node)\n       error (\"storage size of %q+D isn%'t known\", decl);\n \n-  if (current_omp_declare_target_attribute)\n+  if (vec_safe_length (current_omp_declare_target_attribute))\n     {\n+      c_omp_declare_target_attr\n+\ta = current_omp_declare_target_attribute->pop ();\n       if (!errorcount)\n-        error (\"%<#pragma omp declare target%> without corresponding \"\n-\t       \"%<#pragma omp end declare target%>\");\n-      current_omp_declare_target_attribute = 0;\n+\terror (\"%qs without corresponding %qs\",\n+\t       a.device_type >= 0 ? \"#pragma omp begin declare target\"\n+\t\t\t\t  : \"#pragma omp declare target\",\n+\t       \"#pragma omp end declare target\");\n+      vec_safe_truncate (current_omp_declare_target_attribute, 0);\n     }\n   if (current_omp_begin_assumes)\n     {\n       if (!errorcount)\n-\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n-\t       \"%<#pragma omp end assumes%>\");\n+\terror (\"%qs without corresponding %qs\",\n+\t       \"#pragma omp begin assumes\", \"#pragma omp end assumes\");\n       current_omp_begin_assumes = 0;\n     }\n }\n@@ -16818,8 +16822,8 @@ c_parser_omp_clause_device_type (c_parser *parser, tree list)\n   else\n     goto invalid_kind;\n \n-  /* check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE_TYPE,\n-\t\t\t\t\"device_type\");  */\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE_TYPE,\n+\t\t\t     \"device_type\");\n   c_parser_consume_token (parser);\n   parens.skip_until_found_close (parser);\n   c = build_omp_clause (clause_loc, OMP_CLAUSE_DEVICE_TYPE);\n@@ -22351,7 +22355,8 @@ c_parser_omp_declare_target (c_parser *parser)\n   else\n     {\n       c_parser_skip_to_pragma_eol (parser);\n-      current_omp_declare_target_attribute++;\n+      c_omp_declare_target_attr attr = { -1 };\n+      vec_safe_push (current_omp_declare_target_attribute, attr);\n       return;\n     }\n   for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n@@ -22429,12 +22434,17 @@ c_parser_omp_declare_target (c_parser *parser)\n \t}\n     }\n   if (device_type && only_device_type)\n-    warning_at (OMP_CLAUSE_LOCATION (clauses), 0,\n-\t\t\"directive with only %<device_type%> clauses ignored\");\n+    error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t      \"directive with only %<device_type%> clause\");\n }\n \n /* OpenMP 5.1\n-   #pragma omp begin assumes clauses[optseq] new-line  */\n+   #pragma omp begin assumes clauses[optseq] new-line\n+\n+   #pragma omp begin declare target clauses[optseq] new-line  */\n+\n+#define OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE_TYPE)\n \n static void\n c_parser_omp_begin (c_parser *parser)\n@@ -22443,15 +22453,41 @@ c_parser_omp_begin (c_parser *parser)\n   c_parser_consume_pragma (parser);\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-  if (strcmp (p, \"assumes\") == 0)\n+  if (strcmp (p, \"declare\") == 0)\n+    {\n+      c_parser_consume_token (parser);\n+      p = \"\";\n+      if (c_parser_next_token_is (parser, CPP_NAME))\n+\tp = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"target\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  tree clauses\n+\t    = c_parser_omp_all_clauses (parser,\n+\t\t\t\t\tOMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma omp begin declare target\");\n+\t  int device_type = 0;\n+\t  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEVICE_TYPE)\n+\t      device_type |= OMP_CLAUSE_DEVICE_TYPE_KIND (c);\n+\t  c_omp_declare_target_attr attr = { device_type };\n+\t  vec_safe_push (current_omp_declare_target_attribute, attr);\n+\t}\n+      else\n+\t{\n+\t  c_parser_error (parser, \"expected %<target%>\");\n+\t  c_parser_skip_to_pragma_eol (parser);\n+\t}\n+    }\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n       c_parser_consume_token (parser);\n       c_parser_omp_assumption_clauses (parser, false);\n       current_omp_begin_assumes++;\n     }\n   else\n     {\n-      c_parser_error (parser, \"expected %<assumes%>\");\n+      c_parser_error (parser, \"expected %<declare target%> or %<assumes%>\");\n       c_parser_skip_to_pragma_eol (parser);\n     }\n }\n@@ -22484,19 +22520,20 @@ c_parser_omp_end (c_parser *parser)\n \t  return;\n \t}\n       c_parser_skip_to_pragma_eol (parser);\n-      if (!current_omp_declare_target_attribute)\n+      if (!vec_safe_length (current_omp_declare_target_attribute))\n \terror_at (loc, \"%<#pragma omp end declare target%> without \"\n-\t\t       \"corresponding %<#pragma omp declare target%>\");\n+\t\t       \"corresponding %<#pragma omp declare target%> or \"\n+\t\t       \"%<#pragma omp begin declare target%>\");\n       else\n-\tcurrent_omp_declare_target_attribute--;\n+\tcurrent_omp_declare_target_attribute->pop ();\n     }\n   else if (strcmp (p, \"assumes\") == 0)\n     {\n       c_parser_consume_token (parser);\n       c_parser_skip_to_pragma_eol (parser);\n       if (!current_omp_begin_assumes)\n-\terror_at (loc, \"%<#pragma omp end assumes%> without \"\n-\t\t       \"corresponding %<#pragma omp begin assumes%>\");\n+\terror_at (loc, \"%qs without corresponding %qs\",\n+\t\t  \"#pragma omp end assumes\", \"#pragma omp begin assumes\");\n       else\n \tcurrent_omp_begin_assumes--;\n     }"}, {"sha": "8cf97075073aeb61c285b6dbcaef03319e64dbaa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -1817,11 +1817,12 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n };\n \n \f\n-struct GTY(()) omp_declare_target_attr {\n+struct GTY(()) cp_omp_declare_target_attr {\n   bool attr_syntax;\n+  int device_type;\n };\n \n-struct GTY(()) omp_begin_assumes_data {\n+struct GTY(()) cp_omp_begin_assumes_data {\n   bool attr_syntax;\n };\n \n@@ -1871,8 +1872,8 @@ struct GTY(()) saved_scope {\n   cp_binding_level *bindings;\n \n   hash_map<tree, tree> *GTY((skip)) x_local_specializations;\n-  vec<omp_declare_target_attr, va_gc> *omp_declare_target_attribute;\n-  vec<omp_begin_assumes_data, va_gc> *omp_begin_assumes;\n+  vec<cp_omp_declare_target_attr, va_gc> *omp_declare_target_attribute;\n+  vec<cp_omp_begin_assumes_data, va_gc> *omp_begin_assumes;\n \n   struct saved_scope *prev;\n };"}, {"sha": "e6779268ad42145ab01516a9712705ac7e6bf9f2", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -1652,17 +1652,40 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n \t  && DECL_CLASS_SCOPE_P (*decl))\n \terror (\"%q+D static data member inside of declare target directive\",\n \t       *decl);\n-      else if (VAR_P (*decl)\n-\t       && (processing_template_decl\n-\t\t   || !omp_mappable_type (TREE_TYPE (*decl))))\n-\tattributes = tree_cons (get_identifier (\"omp declare target implicit\"),\n-\t\t\t\tNULL_TREE, attributes);\n       else\n \t{\n-\t  attributes = tree_cons (get_identifier (\"omp declare target\"),\n-\t\t\t\t  NULL_TREE, attributes);\n-\t  attributes = tree_cons (get_identifier (\"omp declare target block\"),\n-\t\t\t\t  NULL_TREE, attributes);\n+\t  if (VAR_P (*decl)\n+\t      && (processing_template_decl\n+\t\t  || !omp_mappable_type (TREE_TYPE (*decl))))\n+\t    attributes\n+\t      = tree_cons (get_identifier (\"omp declare target implicit\"),\n+\t\t\t   NULL_TREE, attributes);\n+\t  else\n+\t    {\n+\t      attributes = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t\t\t      NULL_TREE, attributes);\n+\t      attributes\n+\t\t= tree_cons (get_identifier (\"omp declare target block\"),\n+\t\t\t     NULL_TREE, attributes);\n+\t    }\n+\t  if (TREE_CODE (*decl) == FUNCTION_DECL)\n+\t    {\n+\t      cp_omp_declare_target_attr &last\n+\t\t= scope_chain->omp_declare_target_attribute->last ();\n+\t      int device_type = MAX (last.device_type, 0);\n+\t      if ((device_type & OMP_CLAUSE_DEVICE_TYPE_HOST) != 0\n+\t\t  && !lookup_attribute (\"omp declare target host\",\n+\t\t\t\t\tattributes))\n+\t\tattributes\n+\t\t  = tree_cons (get_identifier (\"omp declare target host\"),\n+\t\t\t       NULL_TREE, attributes);\n+\t      if ((device_type & OMP_CLAUSE_DEVICE_TYPE_NOHOST) != 0\n+\t\t  && !lookup_attribute (\"omp declare target nohost\",\n+\t\t\t\t\tattributes))\n+\t\tattributes\n+\t\t  = tree_cons (get_identifier (\"omp declare target nohost\"),\n+\t\t\t       NULL_TREE, attributes);\n+\t    }\n \t}\n     }\n "}, {"sha": "7b416352ef815ab4242ace8a981c925b71f6faef", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -40142,8 +40142,8 @@ cp_parser_omp_clause_device_type (cp_parser *parser, tree list,\n     goto resync_fail;\n \n   c = build_omp_clause (location, OMP_CLAUSE_DEVICE_TYPE);\n-  /* check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE_TYPE, \"device_type\",\n-\t\t\t\tlocation);  */\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE_TYPE, \"device_type\",\n+\t\t\t     location);\n   OMP_CLAUSE_DEVICE_TYPE_KIND (c) = kind;\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n@@ -40667,7 +40667,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINK:\n \t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LINK, clauses);\n-\t  c_name = \"to\";\n+\t  c_name = \"link\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_TO:\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LINK)) != 0)\n@@ -46564,8 +46564,8 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n     }\n   else\n     {\n-      struct omp_declare_target_attr a\n-\t= { parser->lexer->in_omp_attribute_pragma };\n+      cp_omp_declare_target_attr a\n+\t= { parser->lexer->in_omp_attribute_pragma, -1 };\n       vec_safe_push (scope_chain->omp_declare_target_attribute, a);\n       cp_parser_require_pragma_eol (parser, pragma_tok);\n       return;\n@@ -46590,12 +46590,17 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n \t\t\t\t\t  device_type);\n     }\n   if (device_type && only_device_type)\n-    warning_at (OMP_CLAUSE_LOCATION (clauses), 0,\n-\t\t\"directive with only %<device_type%> clauses ignored\");\n+    error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t      \"directive with only %<device_type%> clause\");\n }\n \n /* OpenMP 5.1\n-   #pragma omp begin assumes clauses[optseq] new-line  */\n+   # pragma omp begin assumes clauses[optseq] new-line\n+\n+   # pragma omp begin declare target clauses[optseq] new-line  */\n+\n+#define OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEVICE_TYPE)\n \n static void\n cp_parser_omp_begin (cp_parser *parser, cp_token *pragma_tok)\n@@ -46607,16 +46612,47 @@ cp_parser_omp_begin (cp_parser *parser, cp_token *pragma_tok)\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       p = IDENTIFIER_POINTER (id);\n     }\n-  if (strcmp (p, \"assumes\") == 0)\n+  if (strcmp (p, \"declare\") == 0)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      p = \"\";\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t{\n+\t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t  p = IDENTIFIER_POINTER (id);\n+\t}\n+      if (strcmp (p, \"target\") == 0)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  tree clauses\n+\t    = cp_parser_omp_all_clauses (parser,\n+\t\t\t\t\t OMP_BEGIN_DECLARE_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma omp begin declare target\",\n+\t\t\t\t\t pragma_tok);\n+\t  int device_type = 0;\n+\t  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEVICE_TYPE)\n+\t      device_type |= OMP_CLAUSE_DEVICE_TYPE_KIND (c);\n+\t  cp_omp_declare_target_attr a\n+\t    = { in_omp_attribute_pragma, device_type };\n+\t  vec_safe_push (scope_chain->omp_declare_target_attribute, a);\n+\t}\n+      else\n+\t{\n+\t  cp_parser_error (parser, \"expected %<target%>\");\n+\t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\t}\n+    }\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n       cp_lexer_consume_token (parser->lexer);\n       cp_parser_omp_assumption_clauses (parser, pragma_tok, false);\n-      struct omp_begin_assumes_data a = { in_omp_attribute_pragma };\n+      cp_omp_begin_assumes_data a = { in_omp_attribute_pragma };\n       vec_safe_push (scope_chain->omp_begin_assumes, a);\n     }\n   else\n     {\n-      cp_parser_error (parser, \"expected %<assumes%>\");\n+      cp_parser_error (parser, \"expected %<declare target%> or %<assumes%>\");\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n     }\n }\n@@ -46658,21 +46694,28 @@ cp_parser_omp_end (cp_parser *parser, cp_token *pragma_tok)\n       if (!vec_safe_length (scope_chain->omp_declare_target_attribute))\n \terror_at (pragma_tok->location,\n \t\t  \"%<#pragma omp end declare target%> without corresponding \"\n-\t\t  \"%<#pragma omp declare target%>\");\n+\t\t  \"%<#pragma omp declare target%> or \"\n+\t\t  \"%<#pragma omp begin declare target%>\");\n       else\n \t{\n-\t  omp_declare_target_attr\n+\t  cp_omp_declare_target_attr\n \t    a = scope_chain->omp_declare_target_attribute->pop ();\n \t  if (a.attr_syntax != in_omp_attribute_pragma)\n \t    {\n \t      if (a.attr_syntax)\n \t\terror_at (pragma_tok->location,\n-\t\t\t  \"%<declare target%> in attribute syntax terminated \"\n-\t\t\t  \"with %<end declare target%> in pragma syntax\");\n+\t\t\t  \"%qs in attribute syntax terminated \"\n+\t\t\t  \"with %qs in pragma syntax\",\n+\t\t\t  a.device_type >= 0 ? \"begin declare target\"\n+\t\t\t\t\t     : \"declare target\",\n+\t\t\t  \"end declare target\");\n \t      else\n \t\terror_at (pragma_tok->location,\n-\t\t\t  \"%<declare target%> in pragma syntax terminated \"\n-\t\t\t  \"with %<end declare target%> in attribute syntax\");\n+\t\t\t  \"%qs in pragma syntax terminated \"\n+\t\t\t  \"with %qs in attribute syntax\",\n+\t\t\t  a.device_type >= 0 ? \"begin declare target\"\n+\t\t\t\t\t     : \"declare target\",\n+\t\t\t  \"end declare target\");\n \t    }\n \t}\n     }\n@@ -46682,22 +46725,24 @@ cp_parser_omp_end (cp_parser *parser, cp_token *pragma_tok)\n       cp_parser_require_pragma_eol (parser, pragma_tok);\n       if (!vec_safe_length (scope_chain->omp_begin_assumes))\n \terror_at (pragma_tok->location,\n-\t\t  \"%<#pragma omp end assumes%> without corresponding \"\n-\t\t  \"%<#pragma omp begin assumes%>\");\n+\t\t  \"%qs without corresponding %qs\",\n+\t\t  \"#pragma omp end assumes\", \"#pragma omp begin assumes\");\n       else\n \t{\n-\t  omp_begin_assumes_data\n+\t  cp_omp_begin_assumes_data\n \t    a = scope_chain->omp_begin_assumes->pop ();\n \t  if (a.attr_syntax != in_omp_attribute_pragma)\n \t    {\n \t      if (a.attr_syntax)\n \t\terror_at (pragma_tok->location,\n-\t\t\t  \"%<begin assumes%> in attribute syntax terminated \"\n-\t\t\t  \"with %<end assumes%> in pragma syntax\");\n+\t\t\t  \"%qs in attribute syntax terminated \"\n+\t\t\t  \"with %qs in pragma syntax\",\n+\t\t\t  \"begin assumes\", \"end assumes\");\n \t      else\n \t\terror_at (pragma_tok->location,\n-\t\t\t  \"%<begin assumes%> in pragma syntax terminated \"\n-\t\t\t  \"with %<end assumes%> in attribute syntax\");\n+\t\t\t  \"%qs in pragma syntax terminated \"\n+\t\t\t  \"with %qs in attribute syntax\",\n+\t\t\t  \"begin assumes\", \"end assumes\");\n \t    }\n \t}\n     }"}, {"sha": "30cf2f99a558246114f6b32a1d350fd36573a4ff", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -3360,16 +3360,20 @@ finish_translation_unit (void)\n \n   if (vec_safe_length (scope_chain->omp_declare_target_attribute))\n     {\n+      cp_omp_declare_target_attr\n+\ta = scope_chain->omp_declare_target_attribute->pop ();\n       if (!errorcount)\n-\terror (\"%<#pragma omp declare target%> without corresponding \"\n-\t       \"%<#pragma omp end declare target%>\");\n+\terror (\"%qs without corresponding %qs\",\n+\t       a.device_type >= 0 ? \"#pragma omp begin declare target\"\n+\t\t\t\t  : \"#pragma omp declare target\",\n+\t       \"#pragma omp end declare target\");\n       vec_safe_truncate (scope_chain->omp_declare_target_attribute, 0);\n     }\n   if (vec_safe_length (scope_chain->omp_begin_assumes))\n     {\n       if (!errorcount)\n-\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n-\t       \"%<#pragma omp end assumes%>\");\n+\terror (\"%qs without corresponding %qs\",\n+\t       \"#pragma omp begin assumes\", \"#pragma omp end assumes\");\n       vec_safe_truncate (scope_chain->omp_begin_assumes, 0);\n     }\n }"}, {"sha": "fd8cabaef0a73dbcb8033fb0d01bb1088c6746f3", "filename": "gcc/testsuite/c-c++-common/gomp/begin-declare-target-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-1.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+extern int a;\n+#pragma omp begin declare target device_type (host)\n+int b;\n+#pragma omp begin declare target device_type (any)\n+char d;\n+#pragma omp end declare target\n+#pragma omp end declare target\n+#pragma omp begin declare target\n+long c;\n+#pragma omp end declare target\n+#pragma omp declare target\n+int foo (void) { return 0; }\n+#pragma omp begin declare target device_type (any)\n+int bar (void) { return 0; }\n+#pragma omp end declare target\n+#pragma omp end declare target\n+#pragma omp begin declare target device_type (any)\n+int baz (void) { return 0; }\n+#pragma omp declare target\n+int qux (void) { return 0; }\n+#pragma omp end declare target\n+#pragma omp end declare target"}, {"sha": "2bc72cf4621464ec2f40b83d432fabd32947c8d2", "filename": "gcc/testsuite/c-c++-common/gomp/begin-declare-target-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-2.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+extern int a;\n+#pragma omp begin declare target\n+#pragma omp declare target to (a)\n+#pragma omp end declare target\n+int b;\n+#pragma omp begin declare target to (b)\t\t/* { dg-error \"'to' is not valid for '#pragma omp begin declare target'\" } */\n+#pragma omp end declare target\n+int c;\n+#pragma omp begin declare target link (c)\t/* { dg-error \"'link' is not valid for '#pragma omp begin declare target'\" } */\n+#pragma omp end declare target\n+int m;\n+#pragma omp begin declare target device_type (host) device_type (any)\t/* { dg-error \"too many 'device_type' clauses\" } */\n+#pragma omp end declare target\n+#pragma omp begin declare target\n+#pragma omp end declare target to (p)\t\t/* { dg-error \"expected end of line before .to.\" } */"}, {"sha": "ac4d4d9e98e6db438dbcea4d19f2d22bda7918e7", "filename": "gcc/testsuite/c-c++-common/gomp/begin-declare-target-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-3.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+#pragma omp begin declare target\n+int a[] = { 1, 2, 3 };\n+extern int b[];\t\t\t/* { dg-error \"'b' in declare target directive does not have mappable type\" } */\n+extern int c[];\t\t\t/* { dg-error \"'c' in declare target directive does not have mappable type\" } */\n+extern int d[];\t\t\t/* { dg-error \"'d' in declare target directive does not have mappable type\" } */\n+int d[3];\n+#pragma omp end declare target\n+int c[3];\n+#pragma omp begin declare target device_type (host)\n+int e[] = { 1, 2, 3 };\n+extern int f[];\t\t\t/* { dg-error \"'f' in declare target directive does not have mappable type\" } */\n+extern int g[];\t\t\t/* { dg-error \"'g' in declare target directive does not have mappable type\" } */\n+extern int h[];\t\t\t/* { dg-error \"'h' in declare target directive does not have mappable type\" } */\n+int h[3];\n+#pragma omp end declare target\n+int g[3];"}, {"sha": "d275f73074830e12bb7f870bab77ea832e53dfca", "filename": "gcc/testsuite/c-c++-common/gomp/begin-declare-target-4.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-declare-target-4.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp begin declare target\n+void foo (void);\t/* { dg-error \"'#pragma omp begin declare target' without corresponding '#pragma omp end declare target'\" } */"}, {"sha": "a6bd1286ef17f7739a3a52431d78d03a9357d10d", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-4.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-4.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -1,8 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-fopenmp\" } */\n \n-#pragma omp declare target device_type (any)\t\t/* { dg-warning \"directive with only 'device_type' clauses ignored\" } */\n-\n void f1 (void) {}\n void f2 (void);\n #pragma omp declare target to (f1) device_type (any) to (f2)\n@@ -38,7 +36,3 @@ void f13 (void) {}\n void f14 (void) {}\n #pragma omp declare target device_type (nohost) to (f14)\n #pragma omp declare target device_type (any) to (f14)\n-void f15 (void) {}\n-#pragma omp declare target device_type (host) to (f15) device_type (nohost)\n-void f16 (void) {}\n-#pragma omp declare target device_type (any) to (f15) device_type (any)"}, {"sha": "ba323e2a6f6e7c222df12bb8ee9c5b735957019e", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -1,2 +1,2 @@\n-#pragma omp end declare target\t/* { dg-error \"'#pragma omp end declare target' without corresponding '#pragma omp declare target'\" } */\n+#pragma omp end declare target\t/* { dg-error \"'#pragma omp end declare target' without corresponding '#pragma omp declare target' or '#pragma omp begin declare target'\" } */\n void foo (void);"}, {"sha": "747000a74b967fd721f4ca831d598f9a0137c829", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-7.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-7.c?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+#pragma omp declare target device_type (any)\t\t/* { dg-error \"directive with only 'device_type' clause\" } */\n+\n+void f1 (void) {}\n+#pragma omp declare target device_type (host) to (f1) device_type (nohost)\t/* { dg-error \"too many 'device_type' clauses\" } */\n+#pragma omp declare target device_type (any) to (f1) device_type (any)\t\t/* { dg-error \"too many 'device_type' clauses\" } */"}, {"sha": "6858f3f359f236305b60f370d851f99a6d2f8475", "filename": "gcc/testsuite/g++.dg/gomp/attrs-18.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-18.C?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile { target c++11 } }\n+\n+#pragma omp begin declare target\n+#pragma omp begin declare target device_type (any)\n+[[omp::directive (begin declare target, device_type (host))]];\n+int a;\n+[[omp::directive (end declare target)]];\n+#pragma omp end declare target\n+#pragma omp end declare target\n+[[omp::directive (begin declare target device_type (nohost))]];\n+int b;\n+#pragma omp end declare target\t\t// { dg-error \"'begin declare target' in attribute syntax terminated with 'end declare target' in pragma syntax\" }\n+#pragma omp begin declare target\n+int c;\n+[[omp::directive (end declare target)]];// { dg-error \"'begin declare target' in pragma syntax terminated with 'end declare target' in attribute syntax\" }\n+#pragma omp begin declare target device_type (host)\n+[[omp::directive (begin declare target)]];\n+int d;\n+#pragma omp end declare target\t\t// { dg-error \"'begin declare target' in attribute syntax terminated with 'end declare target' in pragma syntax\" }\n+#pragma omp begin declare target\n+int e;\n+[[omp::directive (end declare target)]];// { dg-error \"'begin declare target' in pragma syntax terminated with 'end declare target' in attribute syntax\" }\n+#pragma omp end declare target\n+[[omp::directive (begin declare target device_type (any))]];\n+[[omp::directive (begin declare target)]];\n+int f;\n+#pragma omp end declare target\t\t// { dg-error \"'begin declare target' in attribute syntax terminated with 'end declare target' in pragma syntax\" }\n+#pragma omp begin declare target\n+int g;\n+[[omp::directive (end declare target)]];// { dg-error \"'begin declare target' in pragma syntax terminated with 'end declare target' in attribute syntax\" }\n+[[omp::directive (end declare target)]];\n+[[omp::directive (begin declare target)]];\n+#pragma omp begin declare target\n+int h;\n+#pragma omp end declare target\n+#pragma omp end declare target\t\t// { dg-error \"'begin declare target' in attribute syntax terminated with 'end declare target' in pragma syntax\" }\n+#pragma omp begin declare target\n+[[omp::directive (begin declare target)]];\n+int i;\n+[[omp::directive (end declare target)]];\n+[[omp::directive (end declare target)]];// { dg-error \"'begin declare target' in pragma syntax terminated with 'end declare target' in attribute syntax\" }"}, {"sha": "cf7cef46b7073df1df43dc37960188c67f39529c", "filename": "gcc/testsuite/g++.dg/gomp/attrs-9.C", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -14,6 +14,21 @@ int b, c, e;\n int d;\n [[omp::directive (end declare target)]];\n [[omp::directive (end declare target)]];\n+[[omp::directive (begin declare target, device_type (any))]];\n+[[omp::directive (begin declare target)]];\n+int f;\n+[[omp::directive (end declare target)]];\n+[[omp::directive (end declare target)]];\n+[[omp::directive (begin declare target device_type (host))]];\n+[[omp::directive (declare target)]];\n+int g;\n+[[omp::directive (end declare target)]];\n+[[omp::directive (end declare target)]];\n+[[omp::directive (declare target)]];\n+[[omp::directive (begin declare target, device_type (nohost))]];\n+int h;\n+[[omp::directive (end declare target)]];\n+[[omp::directive (end declare target)]];\n [[omp::directive (nothing)]];\n [[omp::directive (begin assumes no_openmp no_openmp_routines no_parallelism\n \t\t\t\tabsent (atomic, barrier, cancel, cancellation point)"}, {"sha": "d170594921f725bd3bb29c96f2e30cb50d910b5a", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d5d72bd0b71ac96a8b2ee537367c46107dcb73/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=b6d5d72bd0b71ac96a8b2ee537367c46107dcb73", "patch": "@@ -345,7 +345,7 @@ The OpenMP 4.5 specification is fully supported.\n @item Support of structured block sequences in C/C++ @tab Y @tab\n @item @code{unconstrained} and @code{reproducible} modifiers on @code{order}\n       clause @tab Y @tab\n-@item Support @code{begin/end declare target} syntax in C/C++ @tab N @tab\n+@item Support @code{begin/end declare target} syntax in C/C++ @tab Y @tab\n @item Pointer predetermined firstprivate getting initialized\n to address of matching mapped list item per 5.1, Sect. 2.21.7.2 @tab N @tab\n @item For Fortran, diagnose placing declarative before/between @code{USE},"}]}