{"sha": "aa2192f89e15c5586205d0ef5083cb39bf676a43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyMTkyZjg5ZTE1YzU1ODYyMDVkMGVmNTA4M2NiMzliZjY3NmE0Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2006-01-31T16:58:47Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2006-01-31T16:58:47Z"}, "message": "* gcc/config/m68k/lb1sf68.asm: Use moveq to load small constants.\n\nFrom-SVN: r110440", "tree": {"sha": "fb9a1e020fee5c46714f9335880a388aa0a76cc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb9a1e020fee5c46714f9335880a388aa0a76cc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa2192f89e15c5586205d0ef5083cb39bf676a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2192f89e15c5586205d0ef5083cb39bf676a43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2192f89e15c5586205d0ef5083cb39bf676a43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2192f89e15c5586205d0ef5083cb39bf676a43/comments", "author": null, "committer": null, "parents": [{"sha": "ee9631816531f0ef9005558cec7d10ea5ee6a074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9631816531f0ef9005558cec7d10ea5ee6a074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9631816531f0ef9005558cec7d10ea5ee6a074"}], "stats": {"total": 92, "additions": 48, "deletions": 44}, "files": [{"sha": "d26968f30f512bb42cf5803b77fde24ab7dacaf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2192f89e15c5586205d0ef5083cb39bf676a43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2192f89e15c5586205d0ef5083cb39bf676a43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa2192f89e15c5586205d0ef5083cb39bf676a43", "patch": "@@ -1,3 +1,7 @@\n+2006-01-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcc/config/m68k/lb1sf68.asm: Use moveq to load small constants.\n+\n 2006-01-31  Richard Guenther  <rguenther@suse.de>\n \n \t* doc/invoke.texi (-msselibm): Document."}, {"sha": "bc645b80442e2da4ae64b42f6eefdcfc11b7bcaf", "filename": "gcc/config/m68k/lb1sf68.asm", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2192f89e15c5586205d0ef5083cb39bf676a43/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2192f89e15c5586205d0ef5083cb39bf676a43/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm?ref=aa2192f89e15c5586205d0ef5083cb39bf676a43", "patch": "@@ -1124,7 +1124,7 @@ Ladddf$5:\n \tswap\td0\t\t|\n \tbra\tLadddf$ret\n 1:\n-\tmovew\tIMM (ADD),d5\n+\tmoveq\tIMM (ADD),d5\n \tbra\tLd$overflow\n \n Lsubdf$0:\n@@ -1296,7 +1296,7 @@ Ladddf$a:\n \tmovel\ta6@(8),d0\n \tmovel\ta6@(12),d1\n 1:\n-\tmovew\tIMM (ADD),d5\n+\tmoveq\tIMM (ADD),d5\n | Check for NaN and +/-INFINITY.\n \tmovel\td0,d7         \t\t|\n \tandl\tIMM (0x80000000),d7\t|\n@@ -1352,7 +1352,7 @@ Ladddf$ret$den:\n \tbra\tLadddf$ret\n \n Ladddf$nf:\n-\tmovew\tIMM (ADD),d5\n+\tmoveq\tIMM (ADD),d5\n | This could be faster but it is not worth the effort, since it is not\n | executed very often. We sacrifice speed for clarity here.\n \tmovel\ta6@(8),d0\t| get the numbers back (remember that we\n@@ -1628,7 +1628,7 @@ Lmuldf$2:\t\t\t\t|\n \t\n | Now round, check for over- and underflow, and exit.\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \n \tbtst\tIMM (DBL_MANT_DIG+1-32),d0\n \tbeq\tLround$exit\n@@ -1647,18 +1647,18 @@ Lmuldf$2:\t\t\t\t|\n \tbra\tLround$exit\n \n Lmuldf$inop:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \tbra\tLd$inop\n \n Lmuldf$b$nf:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n \ttstl\td3\t\t| we know d2 == 0x7ff00000, so check d3\n \tbne\tLd$inop\t\t| if d3 <> 0 b is NaN\n \tbra\tLd$overflow\t| else we have overflow (since a is finite)\n \n Lmuldf$a$nf:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n \ttstl\td1\t\t| we know d0 == 0x7ff00000, so check d1\n \tbne\tLd$inop\t\t| if d1 <> 0 a is NaN\n@@ -1667,7 +1667,7 @@ Lmuldf$a$nf:\n | If either number is zero return zero, unless the other is +/-INFINITY or\n | NaN, in which case we return NaN.\n Lmuldf$b$0:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n #ifndef __mcoldfire__\n \texg\td2,d0\t\t| put b (==0) into d0-d1\n \texg\td3,d1\t\t| and a (with sign bit cleared) into d2-d3\n@@ -1948,18 +1948,18 @@ Ldivdf$2:\t\t\t|\n 1:\n | Now round, check for over- and underflow, and exit.\n \tmovel\ta0,d7\t\t| restore sign bit to d7\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbra\tLround$exit\n \n Ldivdf$inop:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbra\tLd$inop\n \n Ldivdf$a$0:\n | If a is zero check to see whether b is zero also. In that case return\n | NaN; then check if b is NaN, and return NaN also in that case. Else\n | return zero.\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbclr\tIMM (31),d2\t|\n \tmovel\td2,d4\t\t| \n \torl\td3,d4\t\t| \n@@ -1984,7 +1984,7 @@ Ldivdf$a$0:\n \trts\t\t\t| \t\n \n Ldivdf$b$0:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n | If we got here a is not zero. Check if a is NaN; in that case return NaN,\n | else return +/-INFINITY. Remember that a is in d0 with the sign bit \n | cleared already.\n@@ -1996,14 +1996,14 @@ Ldivdf$b$0:\n \tbra\tLd$div$0\t| else signal DIVIDE_BY_ZERO\n \n Ldivdf$b$nf:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n | If d2 == 0x7ff00000 we have to check d3.\n \ttstl\td3\t\t|\n \tbne\tLd$inop\t\t| if d3 <> 0, b is NaN\n \tbra\tLd$underflow\t| else b is +/-INFINITY, so signal underflow\n \n Ldivdf$a$nf:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n | If d0 == 0x7ff00000 we have to check d1.\n \ttstl\td1\t\t|\n \tbne\tLd$inop\t\t| if d1 <> 0, a is NaN\n@@ -2185,7 +2185,7 @@ SYM (__negdf2):\n \tlink\ta6,IMM (-24)\n \tmoveml\td2-d7,sp@\n #endif\n-\tmovew\tIMM (NEGATE),d5\n+\tmoveq\tIMM (NEGATE),d5\n \tmovel\ta6@(8),d0\t| get number to negate in d0-d1\n \tmovel\ta6@(12),d1\t|\n \tbchg\tIMM (31),d0\t| negate\n@@ -2233,7 +2233,7 @@ SYM (__cmpdf2_internal):\n \tlink\ta6,IMM (-24)\n \tmoveml\td2-d7,sp@\n #endif\n-\tmovew\tIMM (COMPARE),d5\n+\tmoveq\tIMM (COMPARE),d5\n \tmovel\ta6@(8),d0\t| get first operand\n \tmovel\ta6@(12),d1\t|\n \tmovel\ta6@(16),d2\t| get second operand\n@@ -2344,7 +2344,7 @@ Lcmpdf$b$nf:\n \n Lcmpd$inop:\n \tmovl\ta6@(24),d0\n-\tmovew\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n+\tmoveq\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n \tmoveq\tIMM (DOUBLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n \n@@ -2517,7 +2517,7 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity\n Lf$den:\n | Return and signal a denormalized number\n \torl\td7,d0\n-\tmovew\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n+\tmoveq\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n \tmoveq\tIMM (SINGLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n \n@@ -2526,29 +2526,29 @@ Lf$overflow:\n | Return a properly signed INFINITY and set the exception flags \n \tmovel\tIMM (INFINITY),d0\n \torl\td7,d0\n-\tmovew\tIMM (INEXACT_RESULT+OVERFLOW),d7\n+\tmoveq\tIMM (INEXACT_RESULT+OVERFLOW),d7\n \tmoveq\tIMM (SINGLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n \n Lf$underflow:\n | Return 0 and set the exception flags \n-\tmovel\tIMM (0),d0\n-\tmovew\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n+\tmoveq\tIMM (0),d0\n+\tmoveq\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n \tmoveq\tIMM (SINGLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n \n Lf$inop:\n | Return a quiet NaN and set the exception flags\n \tmovel\tIMM (QUIET_NaN),d0\n-\tmovew\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n+\tmoveq\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n \tmoveq\tIMM (SINGLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n \n Lf$div$0:\n | Return a properly signed INFINITY and set the exception flags\n \tmovel\tIMM (INFINITY),d0\n \torl\td7,d0\n-\tmovew\tIMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7\n+\tmoveq\tIMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7\n \tmoveq\tIMM (SINGLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n \n@@ -2862,7 +2862,7 @@ Laddsf$4:\n \torl\td2,d0\n \tbra\tLaddsf$ret\n 1:\n-\tmovew\tIMM (ADD),d5\n+\tmoveq\tIMM (ADD),d5\n \tbra\tLf$overflow\n \n Lsubsf$0:\n@@ -2982,7 +2982,7 @@ Laddsf$a:\n | Return a (if b is zero).\n \tmovel\ta6@(8),d0\n 1:\n-\tmovew\tIMM (ADD),d5\n+\tmoveq\tIMM (ADD),d5\n | We have to check for NaN and +/-infty.\n \tmovel\td0,d7\n \tandl\tIMM (0x80000000),d7\t| put sign in d7\n@@ -3028,7 +3028,7 @@ Laddsf$ret$den:\n | NaN, but if it is finite we return INFINITY with the corresponding sign.\n \n Laddsf$nf:\n-\tmovew\tIMM (ADD),d5\n+\tmoveq\tIMM (ADD),d5\n | This could be faster but it is not worth the effort, since it is not\n | executed very often. We sacrifice speed for clarity here.\n \tmovel\ta6@(8),d0\t| get the numbers back (remember that we\n@@ -3149,7 +3149,7 @@ Lmulsf$2:\t\t\t|\n \tlsll\tIMM (31-FLT_MANT_DIG+1),d6\t\t\n \n | Start the loop (we loop #FLT_MANT_DIG times):\n-\tmovew\tIMM (FLT_MANT_DIG-1),d3\t\n+\tmoveq\tIMM (FLT_MANT_DIG-1),d3\t\n 1:\taddl\td1,d1\t\t| shift sum \n \taddxl\td0,d0\n \tlsll\tIMM (1),d6\t| get bit bn\n@@ -3192,7 +3192,7 @@ Lmulsf$2:\t\t\t|\n \torl\td3,d0\n #endif\n \n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \t\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\n \tbeq\tLround$exit\n@@ -3211,15 +3211,15 @@ Lmulsf$2:\t\t\t|\n \tbra\tLround$exit\n \n Lmulsf$inop:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \tbra\tLf$inop\n \n Lmulsf$overflow:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n \tbra\tLf$overflow\n \n Lmulsf$inf:\n-\tmovew\tIMM (MULTIPLY),d5\n+\tmoveq\tIMM (MULTIPLY),d5\n | If either is NaN return NaN; else both are (maybe infinite) numbers, so\n | return INFINITY with the correct sign (which is in d7).\n \tcmpl\td6,d1\t\t| is b NaN?\n@@ -3274,7 +3274,7 @@ Lmulsf$b$den:\n #ifndef __mcoldfire__\n \tsubw\tIMM (1),d3\t| and adjust exponent\n #else\n-\tsubl\tIMM (1),d3\t| and adjust exponent\n+\tsubql\tIMM (1),d3\t| and adjust exponent\n #endif\n \tbtst\tIMM (FLT_MANT_DIG-1),d1\n \tbne\tLmulsf$2\t|\n@@ -3360,7 +3360,7 @@ Ldivsf$2:\t\t\t|\n \tmovel\tIMM (0),d6\t| \n \tmovel\td6,d7\n \n-\tmovew\tIMM (FLT_MANT_DIG+1),d3\n+\tmoveq\tIMM (FLT_MANT_DIG+1),d3\n 1:\tcmpl\td0,d1\t\t| is a < b?\n \tbhi\t2f\t\t|\n \tbset\td3,d6\t\t| set a bit in d6\n@@ -3375,7 +3375,7 @@ Ldivsf$2:\t\t\t|\n #endif\n \n | Now we keep going to set the sticky bit ...\n-\tmovew\tIMM (FLT_MANT_DIG),d3\n+\tmoveq\tIMM (FLT_MANT_DIG),d3\n 1:\tcmpl\td0,d1\n \tble\t2f\n \taddl\td0,d0\n@@ -3413,23 +3413,23 @@ Ldivsf$2:\t\t\t|\n #endif\n 1:\n | Now round, check for over- and underflow, and exit.\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbra\tLround$exit\n \n Ldivsf$inop:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbra\tLf$inop\n \n Ldivsf$overflow:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbra\tLf$overflow\n \n Ldivsf$underflow:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n \tbra\tLf$underflow\n \n Ldivsf$a$0:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n | If a is zero check to see whether b is zero also. In that case return\n | NaN; then check if b is NaN, and return NaN also in that case. Else\n | return zero.\n@@ -3451,7 +3451,7 @@ Ldivsf$a$0:\n \trts\t\t\t\t| \n \t\n Ldivsf$b$0:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n | If we got here a is not zero. Check if a is NaN; in that case return NaN,\n | else return +/-INFINITY. Remember that a is in d0 with the sign bit \n | cleared already.\n@@ -3460,7 +3460,7 @@ Ldivsf$b$0:\n \tbra\tLf$div$0\t\t| else signal DIVIDE_BY_ZERO\n \n Ldivsf$inf:\n-\tmovew\tIMM (DIVIDE),d5\n+\tmoveq\tIMM (DIVIDE),d5\n | If a is INFINITY we have to check b\n \tcmpl\tIMM (INFINITY),d1\t| compare b with INFINITY \n \tbge\tLf$inop\t\t\t| if b is NaN or INFINITY return NaN\n@@ -3618,7 +3618,7 @@ SYM (__negsf2):\n \tlink\ta6,IMM (-24)\n \tmoveml\td2-d7,sp@\n #endif\n-\tmovew\tIMM (NEGATE),d5\n+\tmoveq\tIMM (NEGATE),d5\n \tmovel\ta6@(8),d0\t| get number to negate in d0\n \tbchg\tIMM (31),d0\t| negate\n \tmovel\td0,d1\t\t| make a positive copy\n@@ -3662,7 +3662,7 @@ SYM (__cmpsf2_internal):\n \tlink\ta6,IMM (-24)\n \tmoveml\td2-d7,sp@\n #endif\n-\tmovew\tIMM (COMPARE),d5\n+\tmoveq\tIMM (COMPARE),d5\n \tmovel\ta6@(8),d0\t| get first operand\n \tmovel\ta6@(12),d1\t| get second operand\n | Check if either is NaN, and in that case return garbage and signal\n@@ -3746,7 +3746,7 @@ Lcmpsf$b$0:\n \n Lcmpf$inop:\n \tmovl\ta6@(16),d0\n-\tmovew\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n+\tmoveq\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n \tmoveq\tIMM (SINGLE_FLOAT),d6\n \tPICJUMP\t$_exception_handler\n "}]}