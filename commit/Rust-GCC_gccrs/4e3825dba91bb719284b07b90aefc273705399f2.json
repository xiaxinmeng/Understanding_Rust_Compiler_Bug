{"sha": "4e3825dba91bb719284b07b90aefc273705399f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUzODI1ZGJhOTFiYjcxOTI4NGIwN2I5MGFlZmMyNzM3MDUzOTlmMg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-04-26T19:35:04Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-04-26T19:35:04Z"}, "message": "Expand from SSA.\n\ngcc/\n        Expand from SSA.\n\t* builtins.c (fold_builtin_next_arg): Handle SSA names.\n\t* tree-ssa-copyrename.c (rename_ssa_copies): Use ssa_name() directly.\n\t* tree-ssa-coalesce.c (create_outofssa_var_map): Mark only useful\n\tSSA names. \n\t(compare_pairs): Swap cost comparison.\n\t(coalesce_ssa_name): Don't use change_partition_var.\n\t* tree-nrv.c (struct nrv_data): Add modified member.\n\t(finalize_nrv_r): Set it.\n\t(tree_nrv): Use it to update statements.\n\t(pass_nrv): Require PROP_ssa.\n\t* tree-mudflap.c (mf_decl_cache_locals,\n\tmf_build_check_statement_for): Use make_rename_temp.\n\t(pass_mudflap_2): Require PROP_ssa, run ssa update at finish.\n\t* alias.c (find_base_decl): Handle SSA names.\n\t* emit-rtl (set_reg_attrs_for_parm): Make non-static.\n\t(component_ref_for_mem_expr): Don't leak SSA names into RTL.\n\t* rtl.h (set_reg_attrs_for_parm): Declare.\n\t* tree-optimize.c (pass_cleanup_cfg_post_optimizing): Rename\n\tto \"optimized\", remove unused locals at finish.\n\t(execute_free_datastructures): Make global, call\n\tdelete_tree_cfg_annotations.\n\t(execute_free_cfg_annotations): Don't call\n\tdelete_tree_cfg_annotations.\n\n\t* ssaexpand.h: New file.\n\t* expr.c (toplevel): Include ssaexpand.h.\n\t(expand_assignment): Handle SSA names the same as register\n\tvariables.\n\t(expand_expr_real_1): Expand SSA names.\n\t* cfgexpand.c (toplevel): Include ssaexpand.h.\n\t(SA): New global variable.\n\t(gimple_cond_pred_to_tree): Fold TERed comparisons into predicates.\n\t(SSAVAR): New macro.\n\t(set_rtl): New helper function.\n\t(add_stack_var): Deal with SSA names, use set_rtl.\n\t(expand_one_stack_var_at): Likewise.\n\t(expand_one_stack_var): Deal with SSA names.\n\t(stack_var_size_cmp): Use code (SSA_NAME / DECL) as tie breaker\n\tbefore unique numbers.\n\t(expand_stack_vars): Use set_rtl.\n\t(expand_one_var): Accept SSA names, add asserts for them, feed them\n\tto above subroutines.\n\t(expand_used_vars): Expand all partitions (without default defs),\n\tthen only the local decls (ignoring those expanded already).\n\t(expand_gimple_cond): Remove edges when jumpif() expands an\n\tunconditional jump.\n\t(expand_gimple_basic_block): Don't clear EDGE_EXECUTABLE here,\n\tor remove abnormal edges.  Ignore insns setting the LHS of a TERed\n\tSSA name.\n\t(gimple_expand_cfg): Call into rewrite_out_of_ssa, initialize\n\tmembers of SA; deal with PARM_DECL partitions here; expand\n\tall PHI nodes, free tree datastructures and SA.  Commit instructions\n\ton edges, clear EDGE_EXECUTABLE and remove abnormal edges here.\n\t(pass_expand): Require and destroy PROP_ssa, verify SSA form, flow\n\tinfo and statements at start, collect garbage at finish.\n\t* tree-ssa-live.h (struct _var_map): Remove partition_to_var member.\n\t(VAR_ANN_PARTITION) Remove.\n\t(change_partition_var): Don't declare.\n\t(partition_to_var): Always return SSA names.\n\t(var_to_partition): Only accept SSA names.\n\t(register_ssa_partition): Only check argument.\n\t* tree-ssa-live.c (init_var_map): Don't allocate partition_to_var\n\tmember.\n\t(delete_var_map): Don't free it.\n\t(var_union): Only accept SSA names, simplify.\n\t(partition_view_init): Mark only useful SSA names as used.\n\t(partition_view_fini): Only deal with SSA names.\n\t(change_partition_var): Remove.\n\t(dump_var_map): Use ssa_name instead of partition_to_var member.\n\t* tree-ssa.c (delete_tree_ssa): Don't remove PHI nodes on RTL\n\tbasic blocks.\n\t* tree-outof-ssa.c (toplevel): Include ssaexpand.h and expr.h.\n\t(struct _elim_graph): New member const_dests; nodes member vector of\n\tints.\n\t(set_location_for_edge): New static helper.\n\t(create_temp): Remove.\n\t(insert_partition_copy_on_edge, insert_part_to_rtx_on_edge,\n\tinsert_value_copy_on_edge, insert_rtx_to_part_on_edge): New\n\tfunctions.\n\t(new_elim_graph): Allocate const_dests member.\n\t(clean_elim_graph): Truncate const_dests member.\n\t(delete_elim_graph): Free const_dests member.\n\t(elim_graph_size): Adapt to new type of nodes member.\n\t(elim_graph_add_node): Likewise.\n\t(eliminate_name): Likewise.\n\t(eliminate_build): Don't take basic block argument, deal only with\n\tpartition numbers, not variables.\n\t(get_temp_reg): New static helper.\n\t(elim_create): Use it, deal with RTL temporaries instead of trees.\n\t(eliminate_phi): Adjust all calls to new signature.\n\t(assign_vars, replace_use_variable, replace_def_variable): Remove.\n\t(rewrite_trees): Only do checking.\n\t(edge_leader, stmt_list, leader_has_match, leader_match): Remove.\n\t(same_stmt_list_p, identical_copies_p, identical_stmt_lists_p,\n\tinit_analyze_edges_for_bb, fini_analyze_edges_for_bb,\n\tcontains_tree_r, MAX_STMTS_IN_LATCH,\n\tprocess_single_block_loop_latch, analyze_edges_for_bb,\n\tperform_edge_inserts): Remove.\n\t(expand_phi_nodes): New global function.\n\t(remove_ssa_form): Take ssaexpand parameter.  Don't call removed\n\tfunctions, initialize new parameter, remember partitions having a\n\tdefault def.\n\t(finish_out_of_ssa): New global function.\n\t(rewrite_out_of_ssa): Make global.  Adjust call to remove_ssa_form,\n\tdon't reset in_ssa_p here, don't disable TER when mudflap.\n\t(pass_del_ssa): Remove.\n\t* tree-flow.h (struct var_ann_d): Remove out_of_ssa_tag and\n\tpartition members.\n\t(execute_free_datastructures): Declare.\n\t* Makefile.in (SSAEXPAND_H): New variable.\n\t(tree-outof-ssa.o, expr.o, cfgexpand.o): Depend on SSAEXPAND_H.\n\t* basic-block.h (commit_one_edge_insertion): Declare.\n\t* passes.c (init_optimization_passes): Move pass_nrv and\n\tpass_mudflap2 before pass_cleanup_cfg_post_optimizing, remove\n\tpass_del_ssa, pass_free_datastructures, pass_free_cfg_annotations.\n\t* cfgrtl.c (commit_one_edge_insertion): Make global, don't declare.\n\t(redirect_branch_edge): Deal with super block when expanding, split\n\tout jump patching itself into ...\n\t(patch_jump_insn): ... here, new static helper.\n\ntestsuite/\n\n\tExpand from SSA.\n\t* gcc.dg/tree-ssa/20030728-1.c: Use -rtl-expand-details dump and\n\tchange regexps.\n\t* gcc.target/i386/pr37248-1.c: Modified.\n\t* gcc.target/i386/pr37248-3.c: Modified.\n\t* gcc.target/i386/pr37248-2.c: Modified.\n\t* gnat.dg/aliasing1.adb: Modified.\n\t* gnat.dg/pack9.adb: Modified.\n\t* gnat.dg/aliasing2.adb: Modified.\n\t* gcc.dg/strict-overflow-2.c: Modified.\n\t* gcc.dg/autopar/reduc-1char.c: Modified.\n\t* gcc.dg/autopar/reduc-2char.c: Modified.\n\t* gcc.dg/autopar/reduc-1.c: Modified.\n\t* gcc.dg/autopar/reduc-2.c: Modified.\n\t* gcc.dg/autopar/reduc-3.c: Modified.\n\t* gcc.dg/autopar/reduc-6.c: Modified.\n\t* gcc.dg/autopar/reduc-7.c: Modified.\n\t* gcc.dg/autopar/reduc-8.c: Modified.\n\t* gcc.dg/autopar/reduc-9.c: Modified.\n\t* gcc.dg/autopar/reduc-1short.c: Modified.\n\t* gcc.dg/autopar/reduc-2short.c: Modified.\n\t* gcc.dg/autopar/parallelization-1.c: Modified.\n\t* gcc.dg/strict-overflow-4.c: Modified.\n\t* gcc.dg/strict-overflow-6.c: Modified.\n\t* gcc.dg/gomp/combined-1.c: Modified.\n\t* gcc.dg/no-strict-overflow-1.c: Modified.\n\t* gcc.dg/no-strict-overflow-3.c: Modified.\n\t* gcc.dg/no-strict-overflow-5.c: Modified.\n\t* gcc.dg/tree-ssa/reassoc-13.c: Modified.\n\t* gcc.dg/tree-ssa/pr18134.c: Modified.\n\t* gcc.dg/tree-ssa/20030824-1.c: Modified.\n\t* gcc.dg/tree-ssa/vector-2.c: Modified.\n\t* gcc.dg/tree-ssa/forwprop-9.c: Modified.\n\t* gcc.dg/tree-ssa/loop-21.c: Modified.\n\t* gcc.dg/tree-ssa/20030824-2.c: Modified.\n\t* gcc.dg/tree-ssa/vector-3.c: Modified.\n\t* gcc.dg/tree-ssa/asm-3.c: Modified.\n\t* gcc.dg/tree-ssa/pr23294.c: Modified.\n\t* gcc.dg/tree-ssa/loop-22.c: Modified.\n\t* gcc.dg/tree-ssa/loop-15.c: Modified.\n\t* gcc.dg/tree-ssa/prefetch-4.c: Modified.\n\t* gcc.dg/tree-ssa/pr22051-1.c: Modified.\n\t* gcc.dg/tree-ssa/pr20139.c: Modified.\n\t* gcc.dg/tree-ssa/scev-cast.c: Modified.\n\t* gcc.dg/tree-ssa/pr22051-2.c: Modified.\n\t* gcc.dg/tree-ssa/reassoc-1.c: Modified.\n\t* gcc.dg/tree-ssa/loop-5.c: Modified.\n\t* gcc.dg/tree-ssa/pr19431.c: Modified.\n\t* gcc.dg/tree-ssa/pr32044.c: Modified.\n\t* gcc.dg/tree-ssa/prefetch-7.c: Modified.\n\t* gcc.dg/tree-ssa/loop-19.c: Modified.\n\t* gcc.dg/tree-ssa/loop-28.c: Modified.\n\t* gcc.dg/tree-ssa/ssa-pre-15.c: Modified.\n\t* gcc.dg/tree-ssa/divide-1.c: Modified.\n\t* gcc.dg/tree-ssa/inline-1.c: Modified.\n\t* gcc.dg/tree-ssa/divide-3.c: Modified.\n\t* gcc.dg/tree-ssa/pr30978.c: Modified.\n\t* gcc.dg/tree-ssa/alias-6.c: Modified.\n\t* gcc.dg/tree-ssa/divide-4.c: Modified.\n\t* gcc.dg/tree-ssa/alias-11.c: Modified.\n\t* gcc.dg/no-strict-overflow-7.c: Modified.\n\t* gcc.dg/strict-overflow-1.c: Modified.\n\t* gcc.dg/pr15784-4.c: Modified.\n\t* gcc.dg/pr34263.c: Modified.\n\t* gcc.dg/strict-overflow-3.c: Modified.\n\t* gcc.dg/tree-prof/stringop-1.c: Modified.\n\t* gcc.dg/tree-prof/val-prof-1.c: Modified.\n\t* gcc.dg/tree-prof/val-prof-2.c: Modified.\n\t* gcc.dg/tree-prof/val-prof-3.c: Modified.\n\t* gcc.dg/tree-prof/val-prof-4.c: Modified.\n\t* gcc.dg/no-strict-overflow-2.c: Modified.\n\t* gcc.dg/no-strict-overflow-4.c: Modified.\n\t* gcc.dg/no-strict-overflow-6.c: Modified.\n\t* g++.dg/tree-ssa/pr27090.C: Modified.\n\t* g++.dg/tree-ssa/tmmti-2.C: Modified.\n\t* g++.dg/tree-ssa/ptrmemfield.C: Modified.\n\t* g++.dg/tree-ssa/pr19807.C: Modified.\n\t* g++.dg/opt/pr30965.C: Modified.\n\t* g++.dg/init/new17.C: Modified.\n\t* gfortran.dg/whole_file_6.f90: Modified.\n\t* gfortran.dg/whole_file_5.f90: Modified.\n\t* gfortran.dg/reassoc_1.f90: Modified.\n\t* gfortran.dg/reassoc_3.f90: Modified.\n\nFrom-SVN: r146817", "tree": {"sha": "8d709f227ad75b658f3487e9483a960234342733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d709f227ad75b658f3487e9483a960234342733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e3825dba91bb719284b07b90aefc273705399f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3825dba91bb719284b07b90aefc273705399f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e3825dba91bb719284b07b90aefc273705399f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3825dba91bb719284b07b90aefc273705399f2/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5846213b872f73949db3a85c7da529aa8941dd99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5846213b872f73949db3a85c7da529aa8941dd99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5846213b872f73949db3a85c7da529aa8941dd99"}], "stats": {"total": 2432, "additions": 1152, "deletions": 1280}, "files": [{"sha": "ade6bbf149b9dbf744c82852bbb5f721fdc1b56e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,3 +1,126 @@\n+2009-04-26  Michael Matz  <matz@suse.de>\n+\n+\tExpand from SSA.\n+\t* builtins.c (fold_builtin_next_arg): Handle SSA names.\n+\t* tree-ssa-copyrename.c (rename_ssa_copies): Use ssa_name() directly.\n+\t* tree-ssa-coalesce.c (create_outofssa_var_map): Mark only useful\n+\tSSA names. \n+\t(compare_pairs): Swap cost comparison.\n+\t(coalesce_ssa_name): Don't use change_partition_var.\n+\t* tree-nrv.c (struct nrv_data): Add modified member.\n+\t(finalize_nrv_r): Set it.\n+\t(tree_nrv): Use it to update statements.\n+\t(pass_nrv): Require PROP_ssa.\n+\t* tree-mudflap.c (mf_decl_cache_locals,\n+\tmf_build_check_statement_for): Use make_rename_temp.\n+\t(pass_mudflap_2): Require PROP_ssa, run ssa update at finish.\n+\t* alias.c (find_base_decl): Handle SSA names.\n+\t* emit-rtl (set_reg_attrs_for_parm): Make non-static.\n+\t(component_ref_for_mem_expr): Don't leak SSA names into RTL.\n+\t* rtl.h (set_reg_attrs_for_parm): Declare.\n+\t* tree-optimize.c (pass_cleanup_cfg_post_optimizing): Rename\n+\tto \"optimized\", remove unused locals at finish.\n+\t(execute_free_datastructures): Make global, call\n+\tdelete_tree_cfg_annotations.\n+\t(execute_free_cfg_annotations): Don't call\n+\tdelete_tree_cfg_annotations.\n+\n+\t* ssaexpand.h: New file.\n+\t* expr.c (toplevel): Include ssaexpand.h.\n+\t(expand_assignment): Handle SSA names the same as register\n+\tvariables.\n+\t(expand_expr_real_1): Expand SSA names.\n+\t* cfgexpand.c (toplevel): Include ssaexpand.h.\n+\t(SA): New global variable.\n+\t(gimple_cond_pred_to_tree): Fold TERed comparisons into predicates.\n+\t(SSAVAR): New macro.\n+\t(set_rtl): New helper function.\n+\t(add_stack_var): Deal with SSA names, use set_rtl.\n+\t(expand_one_stack_var_at): Likewise.\n+\t(expand_one_stack_var): Deal with SSA names.\n+\t(stack_var_size_cmp): Use code (SSA_NAME / DECL) as tie breaker\n+\tbefore unique numbers.\n+\t(expand_stack_vars): Use set_rtl.\n+\t(expand_one_var): Accept SSA names, add asserts for them, feed them\n+\tto above subroutines.\n+\t(expand_used_vars): Expand all partitions (without default defs),\n+\tthen only the local decls (ignoring those expanded already).\n+\t(expand_gimple_cond): Remove edges when jumpif() expands an\n+\tunconditional jump.\n+\t(expand_gimple_basic_block): Don't clear EDGE_EXECUTABLE here,\n+\tor remove abnormal edges.  Ignore insns setting the LHS of a TERed\n+\tSSA name.\n+\t(gimple_expand_cfg): Call into rewrite_out_of_ssa, initialize\n+\tmembers of SA; deal with PARM_DECL partitions here; expand\n+\tall PHI nodes, free tree datastructures and SA.  Commit instructions\n+\ton edges, clear EDGE_EXECUTABLE and remove abnormal edges here.\n+\t(pass_expand): Require and destroy PROP_ssa, verify SSA form, flow\n+\tinfo and statements at start, collect garbage at finish.\n+\t* tree-ssa-live.h (struct _var_map): Remove partition_to_var member.\n+\t(VAR_ANN_PARTITION) Remove.\n+\t(change_partition_var): Don't declare.\n+\t(partition_to_var): Always return SSA names.\n+\t(var_to_partition): Only accept SSA names.\n+\t(register_ssa_partition): Only check argument.\n+\t* tree-ssa-live.c (init_var_map): Don't allocate partition_to_var\n+\tmember.\n+\t(delete_var_map): Don't free it.\n+\t(var_union): Only accept SSA names, simplify.\n+\t(partition_view_init): Mark only useful SSA names as used.\n+\t(partition_view_fini): Only deal with SSA names.\n+\t(change_partition_var): Remove.\n+\t(dump_var_map): Use ssa_name instead of partition_to_var member.\n+\t* tree-ssa.c (delete_tree_ssa): Don't remove PHI nodes on RTL\n+\tbasic blocks.\n+\t* tree-outof-ssa.c (toplevel): Include ssaexpand.h and expr.h.\n+\t(struct _elim_graph): New member const_dests; nodes member vector of\n+\tints.\n+\t(set_location_for_edge): New static helper.\n+\t(create_temp): Remove.\n+\t(insert_partition_copy_on_edge, insert_part_to_rtx_on_edge,\n+\tinsert_value_copy_on_edge, insert_rtx_to_part_on_edge): New\n+\tfunctions.\n+\t(new_elim_graph): Allocate const_dests member.\n+\t(clean_elim_graph): Truncate const_dests member.\n+\t(delete_elim_graph): Free const_dests member.\n+\t(elim_graph_size): Adapt to new type of nodes member.\n+\t(elim_graph_add_node): Likewise.\n+\t(eliminate_name): Likewise.\n+\t(eliminate_build): Don't take basic block argument, deal only with\n+\tpartition numbers, not variables.\n+\t(get_temp_reg): New static helper.\n+\t(elim_create): Use it, deal with RTL temporaries instead of trees.\n+\t(eliminate_phi): Adjust all calls to new signature.\n+\t(assign_vars, replace_use_variable, replace_def_variable): Remove.\n+\t(rewrite_trees): Only do checking.\n+\t(edge_leader, stmt_list, leader_has_match, leader_match): Remove.\n+\t(same_stmt_list_p, identical_copies_p, identical_stmt_lists_p,\n+\tinit_analyze_edges_for_bb, fini_analyze_edges_for_bb,\n+\tcontains_tree_r, MAX_STMTS_IN_LATCH,\n+\tprocess_single_block_loop_latch, analyze_edges_for_bb,\n+\tperform_edge_inserts): Remove.\n+\t(expand_phi_nodes): New global function.\n+\t(remove_ssa_form): Take ssaexpand parameter.  Don't call removed\n+\tfunctions, initialize new parameter, remember partitions having a\n+\tdefault def.\n+\t(finish_out_of_ssa): New global function.\n+\t(rewrite_out_of_ssa): Make global.  Adjust call to remove_ssa_form,\n+\tdon't reset in_ssa_p here, don't disable TER when mudflap.\n+\t(pass_del_ssa): Remove.\n+\t* tree-flow.h (struct var_ann_d): Remove out_of_ssa_tag and\n+\tpartition members.\n+\t(execute_free_datastructures): Declare.\n+\t* Makefile.in (SSAEXPAND_H): New variable.\n+\t(tree-outof-ssa.o, expr.o, cfgexpand.o): Depend on SSAEXPAND_H.\n+\t* basic-block.h (commit_one_edge_insertion): Declare.\n+\t* passes.c (init_optimization_passes): Move pass_nrv and\n+\tpass_mudflap2 before pass_cleanup_cfg_post_optimizing, remove\n+\tpass_del_ssa, pass_free_datastructures, pass_free_cfg_annotations.\n+\t* cfgrtl.c (commit_one_edge_insertion): Make global, don't declare.\n+\t(redirect_branch_edge): Deal with super block when expanding, split\n+\tout jump patching itself into ...\n+\t(patch_jump_insn): ... here, new static helper.\n+\n 2009-04-26  Michael Matz  <matz@suse.de>\n \n \t* tree-ssa-copyrename.c (rename_ssa_copies): Don't iterate"}, {"sha": "e01f0fba982a74cf3652af4e0dc19486c0c2663b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -864,6 +864,7 @@ TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H) \\\n \t\ttree-ssa-alias.h\n TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H) vecprim.h\n+SSAEXPAND_H = ssaexpand.h $(TREE_SSA_LIVE_H)\n PRETTY_PRINT_H = pretty-print.h $(INPUT_H) $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H) options.h\n C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n@@ -2106,7 +2107,7 @@ tree-ssa-coalesce.o : tree-ssa-coalesce.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(TREE_PASS_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) $(BITMAP_H) $(GGC_H) \\\n-   $(TOPLEV_H)\n+   $(TOPLEV_H) $(EXPR_H) $(SSAEXPAND_H)\n tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) domwalk.h $(FLAGS_H) \\\n@@ -2532,7 +2533,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    typeclass.h hard-reg-set.h $(TOPLEV_H) hard-reg-set.h $(EXCEPT_H) reload.h \\\n    $(GGC_H) langhooks.h intl.h $(TM_P_H) $(REAL_H) $(TARGET_H) \\\n    tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \\\n-   $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) vecprim.h\n+   $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) vecprim.h $(SSAEXPAND_H)\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n    langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H)\n@@ -2804,7 +2805,7 @@ cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(TREE_PASS_H) $(RTL_H) \\\n    $(DIAGNOSTIC_H) $(TOPLEV_H) $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H) \\\n-   value-prof.h $(TREE_INLINE_H) $(TARGET_H)\n+   value-prof.h $(TREE_INLINE_H) $(TARGET_H) $(SSAEXPAND_H)\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(TOPLEV_H) $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) insn-config.h $(EXPR_H) \\"}, {"sha": "794df75504018f7559ccbba7e0ed9d2c5743643b", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -435,6 +435,9 @@ find_base_decl (tree t)\n   if (t == 0 || t == error_mark_node || ! POINTER_TYPE_P (TREE_TYPE (t)))\n     return 0;\n \n+  if (TREE_CODE (t) == SSA_NAME)\n+    t = SSA_NAME_VAR (t);\n+\n   /* If this is a declaration, return it.  If T is based on a restrict\n      qualified decl, return that decl.  */\n   if (DECL_P (t))"}, {"sha": "3f7e872374ccdbd6c62c25588d297d0ae1951fba", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -502,6 +502,7 @@ extern void update_bb_for_insn (basic_block);\n extern void insert_insn_on_edge (rtx, edge);\n basic_block split_edge_and_insert (edge, rtx);\n \n+extern void commit_one_edge_insertion (edge e);\n extern void commit_edge_insertions (void);\n \n extern void remove_fake_edges (void);"}, {"sha": "8621e0db5115e7dcad4e99837886fa0f101e56ff", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -11801,6 +11801,9 @@ fold_builtin_next_arg (tree exp, bool va_start_p)\n       arg = CALL_EXPR_ARG (exp, 0);\n     }\n \n+  if (TREE_CODE (arg) == SSA_NAME)\n+    arg = SSA_NAME_VAR (arg);\n+\n   /* We destructively modify the call to be __builtin_va_start (ap, 0)\n      or __builtin_next_arg (0) the first time we see it, after checking \n      the arguments and if needed issuing a warning.  */"}, {"sha": "a5765f81c47c89f35539a6cae02ee70b54379782", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 245, "deletions": 71, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -42,8 +42,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"value-prof.h\"\n #include \"target.h\"\n+#include \"ssaexpand.h\"\n \n \n+/* This variable holds information helping the rewriting of SSA trees\n+   into RTL.  */\n+struct ssaexpand SA;\n+\n /* Return an expression tree corresponding to the RHS of GIMPLE\n    statement STMT.  */\n \n@@ -78,8 +83,22 @@ gimple_assign_rhs_to_tree (gimple stmt)\n static tree\n gimple_cond_pred_to_tree (gimple stmt)\n {\n+  /* We're sometimes presented with such code:\n+       D.123_1 = x < y;\n+       if (D.123_1 != 0)\n+         ...\n+     This would expand to two comparisons which then later might\n+     be cleaned up by combine.  But some pattern matchers like if-conversion\n+     work better when there's only one compare, so make up for this\n+     here as special exception if TER would have made the same change.  */\n+  tree lhs = gimple_cond_lhs (stmt);\n+  if (SA.values\n+      && TREE_CODE (lhs) == SSA_NAME\n+      && SA.values[SSA_NAME_VERSION (lhs)])\n+    lhs = gimple_assign_rhs_to_tree (SA.values[SSA_NAME_VERSION (lhs)]);\n+\n   return build2 (gimple_cond_code (stmt), boolean_type_node,\n-\t\t gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n+\t\t lhs, gimple_cond_rhs (stmt));\n }\n \n /* Helper for gimple_to_tree.  Set EXPR_LOCATION for every expression\n@@ -423,6 +442,23 @@ add_reg_br_prob_note (rtx last, int probability)\n #define STACK_ALIGNMENT_NEEDED 1\n #endif\n \n+#define SSAVAR(x) (TREE_CODE (x) == SSA_NAME ? SSA_NAME_VAR (x) : x)\n+\n+/* Associate declaration T with storage space X.  If T is no\n+   SSA name this is exactly SET_DECL_RTL, otherwise make the\n+   partition of T associated with X.  */\n+static inline void\n+set_rtl (tree t, rtx x)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    {\n+      SA.partition_to_pseudo[var_to_partition (SA.map, t)] = x;\n+      if (x && !MEM_P (x))\n+\tset_reg_attrs_for_decl_rtl (SSA_NAME_VAR (t), x);\n+    }\n+  else\n+    SET_DECL_RTL (t, x);\n+}\n \n /* This structure holds data relevant to one variable that will be\n    placed in a stack slot.  */\n@@ -561,15 +597,15 @@ add_stack_var (tree decl)\n     }\n   stack_vars[stack_vars_num].decl = decl;\n   stack_vars[stack_vars_num].offset = 0;\n-  stack_vars[stack_vars_num].size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n-  stack_vars[stack_vars_num].alignb = get_decl_align_unit (decl);\n+  stack_vars[stack_vars_num].size = tree_low_cst (DECL_SIZE_UNIT (SSAVAR (decl)), 1);\n+  stack_vars[stack_vars_num].alignb = get_decl_align_unit (SSAVAR (decl));\n \n   /* All variables are initially in their own partition.  */\n   stack_vars[stack_vars_num].representative = stack_vars_num;\n   stack_vars[stack_vars_num].next = EOC;\n \n   /* Ensure that this decl doesn't get put onto the list twice.  */\n-  SET_DECL_RTL (decl, pc_rtx);\n+  set_rtl (decl, pc_rtx);\n \n   stack_vars_num++;\n }\n@@ -688,22 +724,37 @@ add_alias_set_conflicts (void)\n }\n \n /* A subroutine of partition_stack_vars.  A comparison function for qsort,\n-   sorting an array of indices by the size of the object.  */\n+   sorting an array of indices by the size and type of the object.  */\n \n static int\n stack_var_size_cmp (const void *a, const void *b)\n {\n   HOST_WIDE_INT sa = stack_vars[*(const size_t *)a].size;\n   HOST_WIDE_INT sb = stack_vars[*(const size_t *)b].size;\n-  unsigned int uida = DECL_UID (stack_vars[*(const size_t *)a].decl);\n-  unsigned int uidb = DECL_UID (stack_vars[*(const size_t *)b].decl);\n+  tree decla, declb;\n+  unsigned int uida, uidb;\n \n   if (sa < sb)\n     return -1;\n   if (sa > sb)\n     return 1;\n-  /* For stack variables of the same size use the uid of the decl\n-     to make the sort stable.  */\n+  decla = stack_vars[*(const size_t *)a].decl;\n+  declb = stack_vars[*(const size_t *)b].decl;\n+  /* For stack variables of the same size use and id of the decls\n+     to make the sort stable.  Two SSA names are compared by their\n+     version, SSA names come before non-SSA names, and two normal\n+     decls are compared by their DECL_UID.  */\n+  if (TREE_CODE (decla) == SSA_NAME)\n+    {\n+      if (TREE_CODE (declb) == SSA_NAME)\n+\tuida = SSA_NAME_VERSION (decla), uidb = SSA_NAME_VERSION (declb);\n+      else\n+\treturn -1;\n+    }\n+  else if (TREE_CODE (declb) == SSA_NAME)\n+    return 1;\n+  else\n+    uida = DECL_UID (decla), uidb = DECL_UID (declb);\n   if (uida < uidb)\n     return -1;\n   if (uida > uidb)\n@@ -874,21 +925,27 @@ expand_one_stack_var_at (tree decl, HOST_WIDE_INT offset)\n   gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n \n   x = plus_constant (virtual_stack_vars_rtx, offset);\n-  x = gen_rtx_MEM (DECL_MODE (decl), x);\n-\n-  /* Set alignment we actually gave this decl.  */\n-  offset -= frame_phase;\n-  align = offset & -offset;\n-  align *= BITS_PER_UNIT;\n-  if (align == 0)\n-    align = STACK_BOUNDARY;\n-  else if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n-    align = MAX_SUPPORTED_STACK_ALIGNMENT;\n-  DECL_ALIGN (decl) = align;\n-  DECL_USER_ALIGN (decl) = 0;\n+  x = gen_rtx_MEM (DECL_MODE (SSAVAR (decl)), x);\n \n-  set_mem_attributes (x, decl, true);\n-  SET_DECL_RTL (decl, x);\n+  if (TREE_CODE (decl) != SSA_NAME)\n+    {\n+      /* Set alignment we actually gave this decl if it isn't an SSA name.\n+         If it is we generate stack slots only accidentally so it isn't as\n+\t important, we'll simply use the alignment that is already set.  */\n+      offset -= frame_phase;\n+      align = offset & -offset;\n+      align *= BITS_PER_UNIT;\n+      if (align == 0)\n+\talign = STACK_BOUNDARY;\n+      else if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n+\talign = MAX_SUPPORTED_STACK_ALIGNMENT;\n+\n+      DECL_ALIGN (decl) = align;\n+      DECL_USER_ALIGN (decl) = 0;\n+    }\n+\n+  set_mem_attributes (x, SSAVAR (decl), true);\n+  set_rtl (decl, x);\n }\n \n /* A subroutine of expand_used_vars.  Give each partition representative\n@@ -912,7 +969,9 @@ expand_stack_vars (bool (*pred) (tree))\n \n       /* Skip variables that have already had rtl assigned.  See also\n \t add_stack_var where we perpetrate this pc_rtx hack.  */\n-      if (DECL_RTL (stack_vars[i].decl) != pc_rtx)\n+      if ((TREE_CODE (stack_vars[i].decl) == SSA_NAME\n+\t   ? SA.partition_to_pseudo[var_to_partition (SA.map, stack_vars[i].decl)]\n+\t   : DECL_RTL (stack_vars[i].decl)) != pc_rtx)\n \tcontinue;\n \n       /* Check the predicate to see whether this variable should be\n@@ -951,7 +1010,7 @@ account_stack_vars (void)\n \n       size += stack_vars[i].size;\n       for (j = i; j != EOC; j = stack_vars[j].next)\n-\tSET_DECL_RTL (stack_vars[j].decl, NULL);\n+\tset_rtl (stack_vars[j].decl, NULL);\n     }\n   return size;\n }\n@@ -964,8 +1023,8 @@ expand_one_stack_var (tree var)\n {\n   HOST_WIDE_INT size, offset, align;\n \n-  size = tree_low_cst (DECL_SIZE_UNIT (var), 1);\n-  align = get_decl_align_unit (var);\n+  size = tree_low_cst (DECL_SIZE_UNIT (SSAVAR (var)), 1);\n+  align = get_decl_align_unit (SSAVAR (var));\n   offset = alloc_stack_frame_space (size, align);\n \n   expand_one_stack_var_at (var, offset);\n@@ -986,20 +1045,21 @@ expand_one_hard_reg_var (tree var)\n static void\n expand_one_register_var (tree var)\n {\n-  tree type = TREE_TYPE (var);\n+  tree decl = SSAVAR (var);\n+  tree type = TREE_TYPE (decl);\n   int unsignedp = TYPE_UNSIGNED (type);\n   enum machine_mode reg_mode\n-    = promote_mode (type, DECL_MODE (var), &unsignedp, 0);\n+    = promote_mode (type, DECL_MODE (decl), &unsignedp, 0);\n   rtx x = gen_reg_rtx (reg_mode);\n \n-  SET_DECL_RTL (var, x);\n+  set_rtl (var, x);\n \n   /* Note if the object is a user variable.  */\n-  if (!DECL_ARTIFICIAL (var))\n-      mark_user_reg (x);\n+  if (!DECL_ARTIFICIAL (decl))\n+    mark_user_reg (x);\n \n   if (POINTER_TYPE_P (type))\n-    mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (var))));\n+    mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (type)));\n }\n \n /* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL that\n@@ -1067,6 +1127,9 @@ defer_stack_allocation (tree var, bool toplevel)\n static HOST_WIDE_INT\n expand_one_var (tree var, bool toplevel, bool really_expand)\n {\n+  tree origvar = var;\n+  var = SSAVAR (var);\n+\n   if (SUPPORTS_STACK_ALIGNMENT\n       && TREE_TYPE (var) != error_mark_node\n       && TREE_CODE (var) == VAR_DECL)\n@@ -1092,7 +1155,18 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \t}\n     }\n \n-  if (TREE_CODE (var) != VAR_DECL)\n+  if (TREE_CODE (origvar) == SSA_NAME)\n+    {\n+      gcc_assert (TREE_CODE (var) != VAR_DECL\n+\t\t  || (!DECL_EXTERNAL (var)\n+\t\t      && !DECL_HAS_VALUE_EXPR_P (var)\n+\t\t      && !TREE_STATIC (var)\n+\t\t      && !DECL_RTL_SET_P (var)\n+\t\t      && TREE_TYPE (var) != error_mark_node\n+\t\t      && !DECL_HARD_REGISTER (var)\n+\t\t      && really_expand));\n+    }\n+  if (TREE_CODE (var) != VAR_DECL && TREE_CODE (origvar) != SSA_NAME)\n     ;\n   else if (DECL_EXTERNAL (var))\n     ;\n@@ -1107,22 +1181,22 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n       if (really_expand)\n         expand_one_error_var (var);\n     }\n-  else if (DECL_HARD_REGISTER (var))\n+  else if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n     {\n       if (really_expand)\n         expand_one_hard_reg_var (var);\n     }\n   else if (use_register_for_decl (var))\n     {\n       if (really_expand)\n-        expand_one_register_var (var);\n+        expand_one_register_var (origvar);\n     }\n   else if (defer_stack_allocation (var, toplevel))\n-    add_stack_var (var);\n+    add_stack_var (origvar);\n   else\n     {\n       if (really_expand)\n-        expand_one_stack_var (var);\n+        expand_one_stack_var (origvar);\n       return tree_low_cst (DECL_SIZE_UNIT (var), 1);\n     }\n   return 0;\n@@ -1441,6 +1515,7 @@ static void\n expand_used_vars (void)\n {\n   tree t, next, outer_block = DECL_INITIAL (current_function_decl);\n+  unsigned i;\n \n   /* Compute the phase of the stack frame for this function.  */\n   {\n@@ -1451,6 +1526,28 @@ expand_used_vars (void)\n \n   init_vars_expansion ();\n \n+  for (i = 0; i < SA.map->num_partitions; i++)\n+    {\n+      tree var = partition_to_var (SA.map, i);\n+\n+      gcc_assert (is_gimple_reg (var));\n+      if (TREE_CODE (SSA_NAME_VAR (var)) == VAR_DECL)\n+\texpand_one_var (var, true, true);\n+      else\n+\t{\n+\t  /* This is a PARM_DECL or RESULT_DECL.  For those partitions that\n+\t     contain the default def (representing the parm or result itself)\n+\t     we don't do anything here.  But those which don't contain the\n+\t     default def (representing a temporary based on the parm/result)\n+\t     we need to allocate space just like for normal VAR_DECLs.  */\n+\t  if (!bitmap_bit_p (SA.partition_has_default_def, i))\n+\t    {\n+\t      expand_one_var (var, true, true);\n+\t      gcc_assert (SA.partition_to_pseudo[i]);\n+\t    }\n+\t}\n+    }\n+\n   /* At this point all variables on the local_decls with TREE_USED\n      set are not associated with any block scope.  Lay them out.  */\n   t = cfun->local_decls;\n@@ -1462,19 +1559,15 @@ expand_used_vars (void)\n \n       next = TREE_CHAIN (t);\n \n+      /* Expanded above already.  */\n+      if (is_gimple_reg (var))\n+\t;\n       /* We didn't set a block for static or extern because it's hard\n \t to tell the difference between a global variable (re)declared\n \t in a local scope, and one that's really declared there to\n \t begin with.  And it doesn't really matter much, since we're\n \t not giving them stack space.  Expand them now.  */\n-      if (TREE_STATIC (var) || DECL_EXTERNAL (var))\n-\texpand_now = true;\n-\n-      /* Any variable that could have been hoisted into an SSA_NAME\n-\t will have been propagated anywhere the optimizers chose,\n-\t i.e. not confined to their original block.  Allocate them\n-\t as if they were defined in the outermost scope.  */\n-      else if (is_gimple_reg (var))\n+      else if (TREE_STATIC (var) || DECL_EXTERNAL (var))\n \texpand_now = true;\n \n       /* If the variable is not associated with any block, then it\n@@ -1674,6 +1767,19 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       true_edge->goto_block = NULL;\n       false_edge->flags |= EDGE_FALLTHRU;\n       ggc_free (pred);\n+      /* Special case: when jumpif decides that the condition is\n+         trivial it emits an unconditional jump (and the necessary\n+\t barrier).  But we still have two edges, the fallthru one is\n+\t wrong.  purge_dead_edges would clean this up later.  Unfortunately\n+\t we have to insert insns (and split edges) before\n+\t find_many_sub_basic_blocks and hence before purge_dead_edges.\n+\t But splitting edges might create new blocks which depend on the\n+\t fact that if there are two edges there's no barrier.  So the\n+\t barrier would get lost and verify_flow_info would ICE.  Instead\n+\t of auditing all edge splitters to care for the barrier (which\n+\t normally isn't there in a cleaned CFG), fix it here.  */\n+      if (BARRIER_P (get_last_insn ()))\n+\tremove_edge (false_edge);\n       return NULL;\n     }\n   if (true_edge->dest == bb->next_bb)\n@@ -1690,6 +1796,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       false_edge->goto_block = NULL;\n       true_edge->flags |= EDGE_FALLTHRU;\n       ggc_free (pred);\n+      if (BARRIER_P (get_last_insn ()))\n+\tremove_edge (true_edge);\n       return NULL;\n     }\n \n@@ -1932,20 +2040,6 @@ expand_gimple_basic_block (basic_block bb)\n \n   NOTE_BASIC_BLOCK (note) = bb;\n \n-  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n-    {\n-      /* Clear EDGE_EXECUTABLE.  This flag is never used in the backend.  */\n-      e->flags &= ~EDGE_EXECUTABLE;\n-\n-      /* At the moment not all abnormal edges match the RTL representation.\n-\t It is safe to remove them here as find_many_sub_basic_blocks will\n-\t rediscover them.  In the future we should get this fixed properly.  */\n-      if (e->flags & EDGE_ABNORMAL)\n-\tremove_edge (e);\n-      else\n-\tei_next (&ei);\n-    }\n-\n   for (; !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n@@ -1975,7 +2069,19 @@ expand_gimple_basic_block (basic_block bb)\n \t    }\n \t  else if (gimple_code (stmt) != GIMPLE_CHANGE_DYNAMIC_TYPE)\n \t    {\n-\t      tree stmt_tree = gimple_to_tree (stmt);\n+\t      def_operand_p def_p;\n+\t      tree stmt_tree;\n+\t      def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);\n+\n+\t      if (def_p != NULL)\n+\t\t{\n+\t\t  /* Ignore this stmt if it is in the list of\n+\t\t     replaceable expressions.  */\n+\t\t  if (SA.values\n+\t\t      && SA.values[SSA_NAME_VERSION (DEF_FROM_PTR (def_p))])\n+\t\t    continue;\n+\t\t}\n+\t      stmt_tree = gimple_to_tree (stmt);\n \t      last = get_last_insn ();\n \t      expand_expr_stmt (stmt_tree);\n \t      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n@@ -2286,6 +2392,11 @@ gimple_expand_cfg (void)\n   sbitmap blocks;\n   edge_iterator ei;\n   edge e;\n+  unsigned i;\n+\n+  rewrite_out_of_ssa (&SA);\n+  SA.partition_to_pseudo = (rtx *)xcalloc (SA.map->num_partitions,\n+\t\t\t\t\t   sizeof (rtx));\n \n   /* Some backends want to know that we are expanding to RTL.  */\n   currently_expanding_to_rtl = 1;\n@@ -2339,6 +2450,29 @@ gimple_expand_cfg (void)\n   /* Set up parameters and prepare for return, for the function.  */\n   expand_function_start (current_function_decl);\n \n+  /* Now that we also have the parameter RTXs, copy them over to our\n+     partitions.  */\n+  for (i = 0; i < SA.map->num_partitions; i++)\n+    {\n+      tree var = SSA_NAME_VAR (partition_to_var (SA.map, i));\n+\n+      if (TREE_CODE (var) != VAR_DECL\n+\t  && !SA.partition_to_pseudo[i])\n+\tSA.partition_to_pseudo[i] = DECL_RTL_IF_SET (var);\n+      gcc_assert (SA.partition_to_pseudo[i]);\n+      /* Some RTL parts really want to look at DECL_RTL(x) when x\n+         was a decl marked in REG_ATTR or MEM_ATTR.  We could use\n+\t SET_DECL_RTL here making this available, but that would mean\n+\t to select one of the potentially many RTLs for one DECL.  Instead\n+\t of doing that we simply reset the MEM_EXPR of the RTL in question,\n+\t then nobody can get at it and hence nobody can call DECL_RTL on it.  */\n+      if (!DECL_RTL_SET_P (var))\n+\t{\n+\t  if (MEM_P (SA.partition_to_pseudo[i]))\n+\t    set_mem_expr (SA.partition_to_pseudo[i], NULL);\n+\t}\n+    }\n+\n   /* If this function is `main', emit a call to `__main'\n      to run global initializers, etc.  */\n   if (DECL_NAME (current_function_decl)\n@@ -2368,20 +2502,25 @@ gimple_expand_cfg (void)\n       gcc_assert (crtl->parm_stack_boundary <= INCOMING_STACK_BOUNDARY);\n     }\n \n+  expand_phi_nodes (&SA);\n+\n   /* Register rtl specific functions for cfg.  */\n   rtl_register_cfg_hooks ();\n \n   init_block = construct_init_block ();\n \n   /* Clear EDGE_EXECUTABLE on the entry edge(s).  It is cleaned from the\n-     remaining edges in expand_gimple_basic_block.  */\n+     remaining edges later.  */\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     e->flags &= ~EDGE_EXECUTABLE;\n \n   lab_rtx_for_bb = pointer_map_create ();\n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n     bb = expand_gimple_basic_block (bb);\n \n+  execute_free_datastructures ();\n+  finish_out_of_ssa (&SA);\n+\n   /* Expansion is used by optimization passes too, set maybe_hot_insn_p\n      conservatively to true until they are all profile aware.  */\n   pointer_map_destroy (lab_rtx_for_bb);\n@@ -2391,21 +2530,55 @@ gimple_expand_cfg (void)\n   set_curr_insn_block (DECL_INITIAL (current_function_decl));\n   insn_locators_finalize ();\n \n-  /* We're done expanding trees to RTL.  */\n-  currently_expanding_to_rtl = 0;\n-\n   /* Convert tree EH labels to RTL EH labels and zap the tree EH table.  */\n   convert_from_eh_region_ranges ();\n   set_eh_throw_stmt_table (cfun, NULL);\n \n   rebuild_jump_labels (get_insns ());\n   find_exception_handler_labels ();\n \n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t{\n+\t  if (e->insns.r)\n+\t    commit_one_edge_insertion (e);\n+\t  else\n+\t    ei_next (&ei);\n+\t}\n+    }\n+\n+  /* We're done expanding trees to RTL.  */\n+  currently_expanding_to_rtl = 0;\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR, next_bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t{\n+\t  /* Clear EDGE_EXECUTABLE.  This flag is never used in the backend.  */\n+\t  e->flags &= ~EDGE_EXECUTABLE;\n+\n+\t  /* At the moment not all abnormal edges match the RTL\n+\t     representation.  It is safe to remove them here as\n+\t     find_many_sub_basic_blocks will rediscover them.\n+\t     In the future we should get this fixed properly.  */\n+\t  if ((e->flags & EDGE_ABNORMAL)\n+\t      && !(e->flags & EDGE_SIBCALL))\n+\t    remove_edge (e);\n+\t  else\n+\t    ei_next (&ei);\n+\t}\n+    }\n+\n   blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_ones (blocks);\n   find_many_sub_basic_blocks (blocks);\n-  purge_all_dead_edges ();\n   sbitmap_free (blocks);\n+  purge_all_dead_edges ();\n \n   compact_blocks ();\n \n@@ -2470,11 +2643,12 @@ struct rtl_opt_pass pass_expand =\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n   TV_EXPAND,\t\t\t\t/* tv_id */\n-  /* ??? If TER is enabled, we actually receive GENERIC.  */\n-  PROP_gimple_leh | PROP_cfg,           /* properties_required */\n+  PROP_ssa | PROP_gimple_leh | PROP_cfg,/* properties_required */\n   PROP_rtl,                             /* properties_provided */\n-  PROP_trees,\t\t\t\t/* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func,                       /* todo_flags_finish */\n+  PROP_ssa | PROP_trees,\t\t/* properties_destroyed */\n+  TODO_verify_ssa | TODO_verify_flow\n+    | TODO_verify_stmts,\t\t/* todo_flags_start */\n+  TODO_dump_func\n+  | TODO_ggc_collect\t\t\t/* todo_flags_finish */\n  }\n };"}, {"sha": "36bc865916be3cd66a77eeb45a219a10b926cecd", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -64,7 +64,6 @@ along with GCC; see the file COPYING3.  If not see\n \n static int can_delete_note_p (const_rtx);\n static int can_delete_label_p (const_rtx);\n-static void commit_one_edge_insertion (edge);\n static basic_block rtl_split_edge (edge);\n static bool rtl_move_block_after (basic_block, basic_block);\n static int rtl_verify_flow_info (void);\n@@ -856,31 +855,25 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   return e;\n }\n \n-/* Redirect edge representing branch of (un)conditional jump or tablejump,\n-   NULL on failure  */\n-static edge\n-redirect_branch_edge (edge e, basic_block target)\n+/* Subroutine of redirect_branch_edge that tries to patch the jump\n+   instruction INSN so that it reaches block NEW.  Do this\n+   only when it originally reached block OLD.  Return true if this\n+   worked or the original target wasn't OLD, return false if redirection\n+   doesn't work.  */\n+\n+static bool\n+patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n {\n   rtx tmp;\n-  rtx old_label = BB_HEAD (e->dest);\n-  basic_block src = e->src;\n-  rtx insn = BB_END (src);\n-\n-  /* We can only redirect non-fallthru edges of jump insn.  */\n-  if (e->flags & EDGE_FALLTHRU)\n-    return NULL;\n-  else if (!JUMP_P (insn))\n-    return NULL;\n-\n   /* Recognize a tablejump and adjust all matching cases.  */\n   if (tablejump_p (insn, NULL, &tmp))\n     {\n       rtvec vec;\n       int j;\n-      rtx new_label = block_label (target);\n+      rtx new_label = block_label (new_bb);\n \n-      if (target == EXIT_BLOCK_PTR)\n-\treturn NULL;\n+      if (new_bb == EXIT_BLOCK_PTR)\n+\treturn false;\n       if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n \tvec = XVEC (PATTERN (tmp), 0);\n       else\n@@ -915,20 +908,55 @@ redirect_branch_edge (edge e, basic_block target)\n       if (computed_jump_p (insn)\n \t  /* A return instruction can't be redirected.  */\n \t  || returnjump_p (insn))\n-\treturn NULL;\n-\n-      /* If the insn doesn't go where we think, we're confused.  */\n-      gcc_assert (JUMP_LABEL (insn) == old_label);\n+\treturn false;\n \n-      /* If the substitution doesn't succeed, die.  This can happen\n-\t if the back end emitted unrecognizable instructions or if\n-\t target is exit block on some arches.  */\n-      if (!redirect_jump (insn, block_label (target), 0))\n+      if (!currently_expanding_to_rtl || JUMP_LABEL (insn) == old_label)\n \t{\n-\t  gcc_assert (target == EXIT_BLOCK_PTR);\n-\t  return NULL;\n+\t  /* If the insn doesn't go where we think, we're confused.  */\n+\t  gcc_assert (JUMP_LABEL (insn) == old_label);\n+\n+\t  /* If the substitution doesn't succeed, die.  This can happen\n+\t     if the back end emitted unrecognizable instructions or if\n+\t     target is exit block on some arches.  */\n+\t  if (!redirect_jump (insn, block_label (new_bb), 0))\n+\t    {\n+\t      gcc_assert (new_bb == EXIT_BLOCK_PTR);\n+\t      return false;\n+\t    }\n \t}\n     }\n+  return true;\n+}\n+\n+\n+/* Redirect edge representing branch of (un)conditional jump or tablejump,\n+   NULL on failure  */\n+static edge\n+redirect_branch_edge (edge e, basic_block target)\n+{\n+  rtx old_label = BB_HEAD (e->dest);\n+  basic_block src = e->src;\n+  rtx insn = BB_END (src);\n+\n+  /* We can only redirect non-fallthru edges of jump insn.  */\n+  if (e->flags & EDGE_FALLTHRU)\n+    return NULL;\n+  else if (!JUMP_P (insn) && !currently_expanding_to_rtl)\n+    return NULL;\n+\n+  if (!currently_expanding_to_rtl)\n+    {\n+      if (!patch_jump_insn (insn, old_label, target))\n+\treturn NULL;\n+    }\n+  else\n+    /* When expanding this BB might actually contain multiple\n+       jumps (i.e. not yet split by find_many_sub_basic_blocks).\n+       Redirect all of those that match our label.  */\n+    for (insn = BB_HEAD (src); insn != NEXT_INSN (BB_END (src));\n+\t insn = NEXT_INSN (insn))\n+      if (JUMP_P (insn) && !patch_jump_insn (insn, old_label, target))\n+\treturn NULL;\n \n   if (dump_file)\n     fprintf (dump_file, \"Edge %i->%i redirected to %i\\n\",\n@@ -1313,7 +1341,7 @@ insert_insn_on_edge (rtx pattern, edge e)\n \n /* Update the CFG for the instructions queued on edge E.  */\n \n-static void\n+void\n commit_one_edge_insertion (edge e)\n {\n   rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;"}, {"sha": "916774c659d5fb165049e2edeb606aa339a71242", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1028,7 +1028,7 @@ set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n /* Set the REG_ATTRS for registers in value X, given that X represents\n    decl T.  */\n \n-static void\n+void\n set_reg_attrs_for_decl_rtl (tree t, rtx x)\n {\n   if (GET_CODE (x) == SUBREG)\n@@ -1449,7 +1449,10 @@ component_ref_for_mem_expr (tree ref)\n \tinner = NULL_TREE;\n     }\n \n-  if (inner == TREE_OPERAND (ref, 0))\n+  if (inner == TREE_OPERAND (ref, 0)\n+      /* Don't leak SSA-names in the third operand.  */\n+      && (!TREE_OPERAND (ref, 2)\n+\t  || TREE_CODE (TREE_OPERAND (ref, 2)) != SSA_NAME))\n     return ref;\n   else\n     return build3 (COMPONENT_REF, TREE_TYPE (ref), inner,"}, {"sha": "cf818429ef18845c3866806e3906b17b4032e083", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"diagnostic.h\"\n+#include \"ssaexpand.h\"\n \n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n@@ -4284,12 +4285,13 @@ expand_assignment (tree to, tree from, bool nontemporal)\n      Don't do this if TO is a VAR_DECL or PARM_DECL whose DECL_RTL is REG\n      since it might be a promoted variable where the zero- or sign- extension\n      needs to be done.  Handling this in the normal way is safe because no\n-     computation is done before the call.  */\n+     computation is done before the call.  The same is true for SSA names.  */\n   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)\n       && COMPLETE_TYPE_P (TREE_TYPE (from))\n       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST\n-      && ! ((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)\n-\t    && REG_P (DECL_RTL (to))))\n+      && ! (((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)\n+\t     && REG_P (DECL_RTL (to)))\n+\t    || TREE_CODE (to) == SSA_NAME))\n     {\n       rtx value;\n \n@@ -7223,8 +7225,21 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       }\n \n     case SSA_NAME:\n-      return expand_expr_real_1 (SSA_NAME_VAR (exp), target, tmode, modifier,\n-\t\t\t\t NULL);\n+      /* ??? ivopts calls expander, without any preparation from\n+         out-of-ssa.  So fake instructions as if this was an access to the\n+\t base variable.  This unnecessarily allocates a pseudo, see how we can\n+\t reuse it, if partition base vars have it set already.  */\n+      if (!currently_expanding_to_rtl)\n+\treturn expand_expr_real_1 (SSA_NAME_VAR (exp), target, tmode, modifier, NULL);\n+      {\n+\tgimple g = get_gimple_for_ssa_name (exp);\n+\tif (g)\n+\t  return expand_expr_real_1 (gimple_assign_rhs_to_tree (g), target,\n+\t\t\t\t     tmode, modifier, NULL);\n+      }\n+      decl_rtl = get_rtx_for_ssa_name (exp);\n+      exp = SSA_NAME_VAR (exp);\n+      goto expand_decl_rtl;\n \n     case PARM_DECL:\n     case VAR_DECL:\n@@ -7250,6 +7265,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case FUNCTION_DECL:\n     case RESULT_DECL:\n       decl_rtl = DECL_RTL (exp);\n+    expand_decl_rtl:\n       gcc_assert (decl_rtl);\n       decl_rtl = copy_rtx (decl_rtl);\n "}, {"sha": "fbcdc9e1b5742326943f629e65c5695022def621", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -707,17 +707,17 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_local_pure_const);\n     }\n   NEXT_PASS (pass_cleanup_eh);\n-  NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n+  NEXT_PASS (pass_mudflap_2);\n   NEXT_PASS (pass_mark_used_blocks);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n-\n   NEXT_PASS (pass_warn_function_noreturn);\n-  NEXT_PASS (pass_free_datastructures);\n-  NEXT_PASS (pass_mudflap_2);\n \n-  NEXT_PASS (pass_free_cfg_annotations);\n+/*  NEXT_PASS (pass_del_ssa);\n+  NEXT_PASS (pass_free_datastructures);\n+  NEXT_PASS (pass_free_cfg_annotations);*/\n   NEXT_PASS (pass_expand);\n+\n   NEXT_PASS (pass_rest_of_compilation);\n     {\n       struct opt_pass **p = &pass_rest_of_compilation.pass.sub;"}, {"sha": "9941a9736f623897d782bc7a1934360330fc975b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1491,6 +1491,7 @@ extern rtx gen_int_mode (HOST_WIDE_INT, enum machine_mode);\n extern rtx emit_copy_of_insn_after (rtx, rtx);\n extern void set_reg_attrs_from_value (rtx, rtx);\n extern void set_reg_attrs_for_parm (rtx, rtx);\n+extern void set_reg_attrs_for_decl_rtl (tree t, rtx x);\n extern void adjust_reg_mode (rtx, enum machine_mode);\n extern int mem_expr_equal_p (const_tree, const_tree);\n "}, {"sha": "a42282d582f9bda47ac0cacefd279305c86d3aac", "filename": "gcc/ssaexpand.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fssaexpand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Fssaexpand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssaexpand.h?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -0,0 +1,80 @@\n+/* Routines for expanding from SSA form to RTL.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef _SSAEXPAND_H\n+#define _SSAEXPAND_H 1\n+\n+#include \"tree-ssa-live.h\"\n+\n+/* This structure (of which only a singleton SA exists) is used to\n+   pass around information between the outof-SSA functions, cfgexpand\n+   and expand itself.  */\n+struct ssaexpand\n+{\n+  /* The computed partitions of SSA names are stored here.  */\n+  var_map map;\n+\n+  /* For a SSA name version V values[V] contains the gimple statement\n+     defining it iff TER decided that it should be forwarded, NULL\n+     otherwise.  */\n+  gimple *values;\n+\n+  /* For a partition number I partition_to_pseudo[I] contains the\n+     RTL expression of the allocated space of it (either a MEM or\n+     a pseudos REG).  */\n+  rtx *partition_to_pseudo;\n+\n+  /* If partition I contains an SSA name that has a default def,\n+     bit I will be set in this bitmap.  */\n+  bitmap partition_has_default_def;\n+};\n+\n+/* This is the singleton described above.  */\n+extern struct ssaexpand SA;\n+\n+/* Returns the RTX expression representing the storage of the outof-SSA\n+   partition that the SSA name EXP is a member of.  */\n+static inline rtx\n+get_rtx_for_ssa_name (tree exp)\n+{\n+  int p = partition_find (SA.map->var_partition, SSA_NAME_VERSION (exp));\n+  if (SA.map->partition_to_view)\n+    p = SA.map->partition_to_view[p];\n+  gcc_assert (p != NO_PARTITION);\n+  return SA.partition_to_pseudo[p];\n+}\n+\n+/* If TER decided to forward the definition of SSA name EXP this function\n+   returns the defining statement, otherwise NULL.  */\n+static inline gimple\n+get_gimple_for_ssa_name (tree exp)\n+{\n+  int v = SSA_NAME_VERSION (exp);\n+  if (SA.values)\n+    return SA.values[v];\n+  return NULL;\n+}\n+\n+/* In tree-outof-ssa.c.  */\n+void finish_out_of_ssa (struct ssaexpand *sa);\n+unsigned int rewrite_out_of_ssa (struct ssaexpand *sa);\n+void expand_phi_nodes (struct ssaexpand *sa);\n+\n+#endif"}, {"sha": "4e1816a8ade45ee50896be23f8fb7205fc5da623", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,3 +1,89 @@\n+2009-04-26  Michael Matz  <matz@suse.de>\n+\n+\tExpand from SSA.\n+\t* gcc.dg/tree-ssa/20030728-1.c: Use -rtl-expand-details dump and\n+\tchange regexps.\n+\t* gcc.target/i386/pr37248-1.c: Modified.\n+\t* gcc.target/i386/pr37248-3.c: Modified.\n+\t* gcc.target/i386/pr37248-2.c: Modified.\n+\t* gnat.dg/aliasing1.adb: Modified.\n+\t* gnat.dg/pack9.adb: Modified.\n+\t* gnat.dg/aliasing2.adb: Modified.\n+\t* gcc.dg/strict-overflow-2.c: Modified.\n+\t* gcc.dg/autopar/reduc-1char.c: Modified.\n+\t* gcc.dg/autopar/reduc-2char.c: Modified.\n+\t* gcc.dg/autopar/reduc-1.c: Modified.\n+\t* gcc.dg/autopar/reduc-2.c: Modified.\n+\t* gcc.dg/autopar/reduc-3.c: Modified.\n+\t* gcc.dg/autopar/reduc-6.c: Modified.\n+\t* gcc.dg/autopar/reduc-7.c: Modified.\n+\t* gcc.dg/autopar/reduc-8.c: Modified.\n+\t* gcc.dg/autopar/reduc-9.c: Modified.\n+\t* gcc.dg/autopar/reduc-1short.c: Modified.\n+\t* gcc.dg/autopar/reduc-2short.c: Modified.\n+\t* gcc.dg/autopar/parallelization-1.c: Modified.\n+\t* gcc.dg/strict-overflow-4.c: Modified.\n+\t* gcc.dg/strict-overflow-6.c: Modified.\n+\t* gcc.dg/gomp/combined-1.c: Modified.\n+\t* gcc.dg/no-strict-overflow-1.c: Modified.\n+\t* gcc.dg/no-strict-overflow-3.c: Modified.\n+\t* gcc.dg/no-strict-overflow-5.c: Modified.\n+\t* gcc.dg/tree-ssa/reassoc-13.c: Modified.\n+\t* gcc.dg/tree-ssa/pr18134.c: Modified.\n+\t* gcc.dg/tree-ssa/20030824-1.c: Modified.\n+\t* gcc.dg/tree-ssa/vector-2.c: Modified.\n+\t* gcc.dg/tree-ssa/forwprop-9.c: Modified.\n+\t* gcc.dg/tree-ssa/loop-21.c: Modified.\n+\t* gcc.dg/tree-ssa/20030824-2.c: Modified.\n+\t* gcc.dg/tree-ssa/vector-3.c: Modified.\n+\t* gcc.dg/tree-ssa/asm-3.c: Modified.\n+\t* gcc.dg/tree-ssa/pr23294.c: Modified.\n+\t* gcc.dg/tree-ssa/loop-22.c: Modified.\n+\t* gcc.dg/tree-ssa/loop-15.c: Modified.\n+\t* gcc.dg/tree-ssa/prefetch-4.c: Modified.\n+\t* gcc.dg/tree-ssa/pr22051-1.c: Modified.\n+\t* gcc.dg/tree-ssa/pr20139.c: Modified.\n+\t* gcc.dg/tree-ssa/scev-cast.c: Modified.\n+\t* gcc.dg/tree-ssa/pr22051-2.c: Modified.\n+\t* gcc.dg/tree-ssa/reassoc-1.c: Modified.\n+\t* gcc.dg/tree-ssa/loop-5.c: Modified.\n+\t* gcc.dg/tree-ssa/pr19431.c: Modified.\n+\t* gcc.dg/tree-ssa/pr32044.c: Modified.\n+\t* gcc.dg/tree-ssa/prefetch-7.c: Modified.\n+\t* gcc.dg/tree-ssa/loop-19.c: Modified.\n+\t* gcc.dg/tree-ssa/loop-28.c: Modified.\n+\t* gcc.dg/tree-ssa/ssa-pre-15.c: Modified.\n+\t* gcc.dg/tree-ssa/divide-1.c: Modified.\n+\t* gcc.dg/tree-ssa/inline-1.c: Modified.\n+\t* gcc.dg/tree-ssa/divide-3.c: Modified.\n+\t* gcc.dg/tree-ssa/pr30978.c: Modified.\n+\t* gcc.dg/tree-ssa/alias-6.c: Modified.\n+\t* gcc.dg/tree-ssa/divide-4.c: Modified.\n+\t* gcc.dg/tree-ssa/alias-11.c: Modified.\n+\t* gcc.dg/no-strict-overflow-7.c: Modified.\n+\t* gcc.dg/strict-overflow-1.c: Modified.\n+\t* gcc.dg/pr15784-4.c: Modified.\n+\t* gcc.dg/pr34263.c: Modified.\n+\t* gcc.dg/strict-overflow-3.c: Modified.\n+\t* gcc.dg/tree-prof/stringop-1.c: Modified.\n+\t* gcc.dg/tree-prof/val-prof-1.c: Modified.\n+\t* gcc.dg/tree-prof/val-prof-2.c: Modified.\n+\t* gcc.dg/tree-prof/val-prof-3.c: Modified.\n+\t* gcc.dg/tree-prof/val-prof-4.c: Modified.\n+\t* gcc.dg/no-strict-overflow-2.c: Modified.\n+\t* gcc.dg/no-strict-overflow-4.c: Modified.\n+\t* gcc.dg/no-strict-overflow-6.c: Modified.\n+\t* g++.dg/tree-ssa/pr27090.C: Modified.\n+\t* g++.dg/tree-ssa/tmmti-2.C: Modified.\n+\t* g++.dg/tree-ssa/ptrmemfield.C: Modified.\n+\t* g++.dg/tree-ssa/pr19807.C: Modified.\n+\t* g++.dg/opt/pr30965.C: Modified.\n+\t* g++.dg/init/new17.C: Modified.\n+\t* gfortran.dg/whole_file_6.f90: Modified.\n+\t* gfortran.dg/whole_file_5.f90: Modified.\n+\t* gfortran.dg/reassoc_1.f90: Modified.\n+\t* gfortran.dg/reassoc_3.f90: Modified.\n+\n 2009-04-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/39893"}, {"sha": "42b9f077a1f5add675e55a79f152a92c3dde946b", "filename": "gcc/testsuite/g++.dg/init/new17.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-options \"-O2 -fstrict-aliasing -fdump-tree-final_cleanup\" }\n+// { dg-options \"-O2 -fstrict-aliasing -fdump-tree-optimized\" }\n \n // Test that placement new does not introduce an unnecessary memory\n // barrier.\n@@ -33,5 +33,5 @@ void foo(Vector<float, 3> *m)\n   *m = v;\n }\n \n-// { dg-final { scan-tree-dump-times \"= 0\\.0\" 1 \"final_cleanup\" } }\n-// { dg-final { cleanup-tree-dump \"final_cleanup\" } }\n+// { dg-final { scan-tree-dump-times \"= 0\\.0\" 1 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "91bb55c05d8b61bdc44dbf48e374858c881d843e", "filename": "gcc/testsuite/g++.dg/opt/pr30965.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr30965.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr30965.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr30965.C?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -16,5 +16,5 @@ extern void assign( long& variable, long v )\n }\n \n /* { dg-final { scan-tree-dump-times \";; Function\" 2 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"variable = v\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"variable_..D. = v_..D.\" 2 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bba79a9d150def9cb0dd4eb5ae8f66a6a831f725", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr19807.C", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -19,6 +19,12 @@ void bar(int i)\n }\n \n /* { dg-final { scan-tree-dump-times \"&a\\\\\\[2\\\\\\]\" 3 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"&a\\\\\\[.* \\\\+ -1\\\\\\]\" 1 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"&a\\\\\\[.* \\\\+ 1\\\\\\]\" 1 \"optimized\" } } */\n+\n+/* We want &a[D.bla + 1] and &a[D.foo - 1] in the final code, but\n+   tuples mean that the offset is calculated in a separate instruction.\n+   Simply test for the existence of +1 and -1 once, which also ensures\n+   the above.  If the addition/subtraction would be applied to the\n+   pointer we would instead see +-4 (or 8, depending on sizeof(int)).  */\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+ -1;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+ 1;\" 1 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "0fb46f35db70fcf194c858c23413987a13a87320", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr27090.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27090.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27090.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27090.C?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -17,5 +17,5 @@ int foo(Foo& f)\n         return f.get();\n }\n \n-/* { dg-final { scan-tree-dump \"return f->x;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"f_..D.->x;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c32ebba0002ec1aac4ada6a574a13e893c7fdf41", "filename": "gcc/testsuite/g++.dg/tree-ssa/ptrmemfield.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fptrmemfield.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fptrmemfield.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fptrmemfield.C?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-// { dg-options \"-O2 -fdump-tree-final_cleanup\" }\n+// { dg-options \"-O2 -fdump-tree-optimized\" }\n \n \n struct f\n@@ -20,8 +20,8 @@ int h(void)\n }\n \n /* We should have no cast to offset_type. */\n-/* { dg-final { scan-tree-dump-times \"offset_type\" 0 \"final_cleanup\"} } */\n+/* { dg-final { scan-tree-dump-times \"offset_type\" 0 \"optimized\"} } */\n // And we should optimized this code to just return 0\n-/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"final_cleanup\"} } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "808b5ab275dec4c2a9a7bf66afaeb1ef7a5fc2db", "filename": "gcc/testsuite/g++.dg/tree-ssa/tmmti-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ftmmti-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ftmmti-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ftmmti-2.C?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -3,7 +3,7 @@\n \n int a[4][8];\n \n-int foo(int i)\n+int foo(long i)\n {\n \treturn *(&a[0][0] + i*8); // a[i][0]\n }\n@@ -12,7 +12,7 @@ struct Foo { double x, y; };\n \n Foo b[4];\n \n-double bar(int i)\n+double bar(long i)\n {\n \treturn *(&b[0].x + i*2); // b[i].x\n }"}, {"sha": "f71d6d53343796d1f8ff8285beca277dc2fd9233", "filename": "gcc/testsuite/gcc.dg/autopar/parallelization-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fparallelization-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fparallelization-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fparallelization-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n void abort (void);\n \n@@ -28,6 +28,6 @@ int main(void)\n /* Check that the first loop in parloop got parallelized.  */\n \n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops\" } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c8b624c8c5be400e0db16898e1fa511fbe24f48f", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -54,5 +54,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 3 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "e3c73ba0d5717a2f6d4244ffe4a735025dc8cdd2", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-1char.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1char.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -49,5 +49,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 3 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "10f1401d5c9cc477a9084476cc5e1f49752eb064", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-1short.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-1short.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -49,5 +49,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 3 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "8a0338f1c6a01cc3978c4c4851b68af6d04035b0", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -51,5 +51,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 3 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 3 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "0372dc6a2b2d47b756de5803a0b27fd69369c237", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-2char.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2char.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -49,6 +49,6 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 2 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n \n "}, {"sha": "4f37e8641928e42f7a806fa1879fe913db90d16c", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-2short.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-2short.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -48,5 +48,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 2 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "0ec3aaa8102a831e6306dfa8791617bba72ac9f3", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -39,5 +39,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 1 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "f6d503c9be4355f5cc3f656fbb54fdc61f9641ef", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-6.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdarg.h>\n #include <stdlib.h>\n@@ -52,4 +52,4 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 0 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"FAILED: it is not a part of reduction\" 3 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f25b03abb6d48ac31b80eda2af155c24524527aa", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-7.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdlib.h>\n \n@@ -78,5 +78,5 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 2 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "801561da87d114743ea9c776d7765ed17cff84f7", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-8.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdlib.h>\n \n@@ -77,4 +77,4 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 2 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "2bc04ccfc74100e9b9c5cb18f7f9938218124ca3", "filename": "gcc/testsuite/gcc.dg/autopar/reduc-9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Freduc-9.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n \n #include <stdlib.h>\n \n@@ -77,4 +77,4 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Detected reduction\" 2 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 2 \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7e2346572a2472b8e82a7d533259009647bfe7a5", "filename": "gcc/testsuite/gcc.dg/gomp/combined-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fopenmp -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O1 -fopenmp -fdump-tree-optimized\" } */\n \n int a[10];\n int foo (void)\n@@ -20,5 +20,5 @@ int foo (void)\n       }\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin_GOMP_parallel_loop_runtime_start\" 3 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_GOMP_parallel_loop_runtime_start\" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b83b3ae80d3237840e3190100960f53bbdd765e0", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-1.c.  */\n \n@@ -12,5 +12,5 @@ foo (int i)\n   return i - 5 < 10;\n }\n \n-/* { dg-final { scan-tree-dump \"-[ ]*5\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump \"-[ ]*5\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "aec8960ad523ced6a97efdace82ecc02e9d9542e", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-2.c.  */\n \n@@ -12,5 +12,5 @@ foo (int i)\n   return (i * 100) / 10;\n }\n \n-/* { dg-final { scan-tree-dump \"100\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump \"100\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e34e9183c0c6232ef1fcc365231ada5fd4ccaa33", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-3.c.  */\n \n@@ -12,5 +12,5 @@ foo (int i, int j)\n   return i + 100 < j + 1000;\n }\n \n-/* { dg-final { scan-tree-dump \"1000\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump \"1000\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "32d35c4cb4bc750dbc8f1adc15a6d5f6539c5c78", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-4.c.  */\n \n@@ -14,6 +14,6 @@ foo (int i)\n \n /* We expect to see \"<bb N>\"; confirm that, so that we know to count\n    it in the real test.  */\n-/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"final_cleanup\" } } */\n-/* { dg-final { scan-tree-dump-times \">|<\" 3 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \">|<\" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a63bf342b569c52cec3e45a99d1d2a5215fe1849", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-5.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-5.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Dual of strict-overflow-5.c.  */\n \n@@ -16,5 +16,5 @@ int foo (int i)\n   return r;\n }\n \n-/* { dg-final { scan-tree-dump-times \"r = 3\" 0 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"r = 3\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "43200bb20bc4bcdc726d4018c19123697a4f115b", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-6.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-6.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  */\n \n@@ -17,5 +17,5 @@ foo ()\n   return bits;\n }\n \n-/* { dg-final { scan-tree-dump \"return bits\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump \"return bits\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c237af9840759eaa782668288a647c37e94c797d", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-7.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-6.c.  */\n \n@@ -12,5 +12,5 @@ foo (char* p)\n   return p + 1000 < p;\n }\n \n-/* { dg-final { scan-tree-dump \"\\[+\\]\\[ \\]*1000\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump \"\\[+\\]\\[ \\]*1000\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6549c72055556062cb06a032d1db7405d81da020", "filename": "gcc/testsuite/gcc.dg/pr15784-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-4.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -8,6 +8,6 @@ int b (int x) {\n \treturn -x -1; /* ~x */\n }\n \n-/* { dg-final { scan-tree-dump \"~x;\" \"optimized\" } } */\n-/* { dg-final { scan-tree-dump \"-x;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"~x_..D.;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"-x_..D.;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d389eade88e4c9144823177bd72fcf01874280ef", "filename": "gcc/testsuite/gcc.dg/pr34263.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34263.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34263.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34263.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -54,6 +54,6 @@ int look( struct s *p, struct s **pp )\n     return( 1 );\n }\n \n-/* { dg-final { scan-tree-dump \"Cleaned-up latch block of loop with single BB\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"Cleaned-up latch block of loop with single BB\" \"optimized\" { xfail { *-*-* } } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "f37dbd54f7f0f67d1401219f48fa14d793ee2003", "filename": "gcc/testsuite/gcc.dg/strict-overflow-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of no-strict-overflow-1.c.  */\n \n@@ -12,5 +12,5 @@ foo (int i)\n   return i - 5 < 10;\n }\n \n-/* { dg-final { scan-tree-dump-not \"-[ ]*5\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-not \"-\\[ \\]*5\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fd2dc69204d5451c413e709893ebb5c608b37c48", "filename": "gcc/testsuite/gcc.dg/strict-overflow-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of no-strict-overflow-2.c.  */\n \n@@ -12,5 +12,5 @@ foo (int i)\n   return (i * 100) / 10;\n }\n \n-/* { dg-final { scan-tree-dump-not \"100\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-not \"100\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bdde003a14dcc4764f65e35a7ca9f2cd8cefd1d3", "filename": "gcc/testsuite/gcc.dg/strict-overflow-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of no-strict-overflow-3.c.  */\n \n@@ -12,5 +12,5 @@ foo (int i, int j)\n   return i + 100 < j + 1000;\n }\n \n-/* { dg-final { scan-tree-dump-not \"1000\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-not \"1000\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1a8c4ed433034e104c0807dc2af0c04252f2f338", "filename": "gcc/testsuite/gcc.dg/strict-overflow-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of no-strict-overflow-4.c.  */\n \n@@ -14,6 +14,6 @@ foo (int i)\n \n /* We expect to see \"<bb N>\"; confirm that, so that we know to count\n    it in the real test.  */\n-/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"final_cleanup\" } } */\n-/* { dg-final { scan-tree-dump-times \">|<\" 2 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \">|<\" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d8251f4cf1945f47e3bece97943bb96e093b9763", "filename": "gcc/testsuite/gcc.dg/strict-overflow-6.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-6.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* Source: Ian Lance Taylor.  Dual of no-strict-overflow-7.c.  */\n \n@@ -12,5 +12,5 @@ foo (char* p)\n   return p + 1000 < p;\n }\n \n-/* { dg-final { scan-tree-dump-not \"\\[+\\]\\[ \\]*1000\" \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-not \"\\[+\\]\\[ \\]*1000\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d32a6cedc7a64630b254bd686b5f9534aeabb19e", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -16,6 +16,7 @@ main()\n /* { dg-final-use { scan-tree-dump \"Single value 4 stringop\" \"tree_profile\"} } */\n /* Really this ought to simplify into assignment, but we are not there yet.  */\n /* a[0] = b[0] is what we fold the resulting memcpy into.  */\n-/* { dg-final-use { scan-tree-dump \"a.0. = b.0.\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"a.0. = \" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"= b.0.\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "4d9cb1b9969b65ce05bc7415dc1f1d7da5c4b3de", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -16,7 +16,7 @@ main ()\n   return 0;\n }\n /* { dg-final-use { scan-tree-dump \"Div.mod by constant n=257 transformation on insn\" \"tree_profile\"} } */\n-/* { dg-final-use { scan-tree-dump \"if \\\\(n != 257\\\\)\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* != 257\\\\)\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "30a92c0157fc3992138595e71fad0ddb0f3bcbd9", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -26,7 +26,7 @@ main ()\n /* { dg-final-use { scan-tree-dump \"Mod power of 2 transformation on insn\" \"tree_profile\"} } */\n /* This is part of code checking that n is power of 2, so we are sure that the transformation\n    didn't get optimized out.  */\n-/* { dg-final-use { scan-tree-dump \"n \\\\+ 0xffff\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"n_\\[0-9\\]* \\\\+ 0xffff\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "ad32a44b32de7032efb7d383aa00476536341a18", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -26,7 +26,7 @@ main ()\n /* { dg-final-use { scan-tree-dump \"Mod subtract transformation on insn\" \"tree_profile\"} } */\n /* This is part of code checking that n is greater than the divisor so we are sure that it\n    didn't get optimized out.  */\n-/* { dg-final-use { scan-tree-dump \"if \\\\(n \\\\>\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* \\\\>\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "fdc2b0c6d65ffafa96b05e0660b58be7d250975f", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -26,7 +26,7 @@ main ()\n /* { dg-final-use { scan-tree-dump \"Mod subtract transformation on insn\" \"tree_profile\"} } */\n /* This is part of code checking that n is greater than the divisor so we are sure that it\n    didn't get optimized out.  */\n-/* { dg-final-use { scan-tree-dump \"if \\\\(n \\\\>\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* \\\\>\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "f884736a1c935a6f0484be3e77cf96441e748196", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030728-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fdump-rtl-expand-details\" } */\n     \n \n union tree_node;\n@@ -42,6 +42,6 @@ objects_must_conflict_p (t1, t2)\n }\n \n /* There should be two assignments of variables to the value zero.  */\n-/* { dg-final { scan-tree-dump-times \" = 0\" 2 \"final_cleanup\"} } */\n+/* { dg-final { scan-rtl-dump-times \"PART.. = 0\" 2 \"expand\"} } */\n  \n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "e5988bd79980af7f4b613a53dd415fdc94122e03", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030824-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -19,5 +19,5 @@ int foo (int x, int y)\n }\n \n /* The addition should be optimized into 'y+x'.  */\n-/* { dg-final { scan-tree-dump-times \"\\[xy\\] \\\\+ \\[xy]\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"\\[xy\\]_..D. \\\\+ \\[xy]_..D.\" 1 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1234aeb34d1c31a17c7011abfafbd6be2363b942", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030824-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030824-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -19,5 +19,5 @@ int foo (int x, int y)\n }\n \n /* This function should be optimized into 'return y+x'.  */\n-/* { dg-final { scan-tree-dump-times \"return \\[xy\\] \\\\+ \\[xy\\]\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"\\[xy\\]_..D. \\\\+ \\[xy]_..D.\" 1 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d4ce34bd8cb327d6cab5c5121acb3f8ebeb1c69d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-11.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-11.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -14,6 +14,8 @@ int bar(void)\n   return a[0] + *p.a;\n }\n \n-/* { dg-final { scan-tree-dump \"return \\\\*p\\\\.a \\\\\\+ a.0.;\" \"optimized\" } } */\n+/* We need to have both: a load from \"a[0]\" and a load from \"*p.a\",\n+   the latter can be an ssa temporary.  */\n+/* { dg-final { scan-tree-dump \"= a.0.;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"= \\\\*\\[pD\\]\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n-"}, {"sha": "bcc011898faba07c997a9aa3e0c4a97212a338de", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-6.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-6.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -14,6 +14,8 @@ int bar(void)\n   return a[0] + *p.a;\n }\n \n-/* { dg-final { scan-tree-dump \"return \\\\*p\\\\.a \\\\\\+ a.0.;\" \"optimized\" } } */\n+/* We need to have both: a load from \"a[0]\" and a load from \"*p.a\",\n+   the latter can be an ssa temporary.  */\n+/* { dg-final { scan-tree-dump \"= a.0.;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"= \\\\*\\[pD\\]\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n-"}, {"sha": "e35d179c5478335c3cf7682d1d6ca5a8d3f79d8d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/asm-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasm-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasm-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasm-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -27,6 +27,6 @@ void test(void)\n /* { dg-final { scan-tree-dump-times \"hardreg\" 3 \"optimized\" } } */\n \n /* In particular, hardreg should *not* appear in the call to bar.  */\n-/* { dg-final { scan-tree-dump-times \"bar \\[(\\]t\\[)\\]\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"bar \\[(\\]t_.\\[)\\]\" 1 \"optimized\" } } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "66bc3745bcc7855f1f102fbf2b0fc843e187ae1b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -7,8 +7,8 @@ int f(int a)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"-a / 10\" 0 \"optimized\"} } */\n-/* { dg-final { scan-tree-dump-times \"a / -10\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"-a\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"a_..D. / -10\" 1 \"optimized\"} } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "12fa09b9536c75799f58488a22fe750ad4770938", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -6,8 +6,8 @@ int f(int a)\n   return -(a/10);\n }\n \n-/* { dg-final { scan-tree-dump-times \"a / 10\" 0 \"optimized\"} } */\n-/* { dg-final { scan-tree-dump-times \"a / -10\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"a_\\[0-9()D\\]* / 10\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"a_..D. / -10\" 1 \"optimized\"} } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "734acad69a7ca48f563184dbfa64198927f163f5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-4.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -6,8 +6,8 @@ int f(int a)\n   return -(-a/10);\n }\n \n-/* { dg-final { scan-tree-dump-times \"-a / 10\" 0 \"optimized\"} } */\n-/* { dg-final { scan-tree-dump-times \"a / 10\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"-a\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"a_..D. / 10\" 1 \"optimized\"} } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "cc583e293f80bcd8c806aa744c26b7dc6e359e5c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-9.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-9.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-final_cleanup -fdump-tree-fre -W -Wall -fno-early-inlining\" } */\n+/* { dg-options \"-O1 -fdump-tree-optimized -fdump-tree-fre -W -Wall -fno-early-inlining\" } */\n \n int b;\n unsigned a;\n@@ -15,7 +15,7 @@ void f(void)\n \n /* We should have converted the assignments to two = 1.  FRE does this.  */\n \n-/* { dg-final { scan-tree-dump-times \" = 1\" 2 \"final_cleanup\"} } */\n+/* { dg-final { scan-tree-dump-times \" = 1\" 2 \"optimized\"} } */\n /* { dg-final { scan-tree-dump-not \" = a;\" \"fre\"} } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "030181404d18bfd5ddc30b54c2ca0030401e36c5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n \n typedef struct {\n@@ -20,6 +20,6 @@ interval foo (interval a, interval b, interval c)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"\\\\(struct interval\\\\)\" 0 \"final_cleanup\"} } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\(struct interval\\\\)\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "aa0747b6e7e58de6e8f65a553cabfbc5a72f6fcc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -20,7 +20,7 @@ int bla(void)\n \n /* Since the loop is removed, there should be no addition.  */\n /* { dg-final { scan-tree-dump-times \"\\\\+\" 0 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"n \\\\* n\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"n_. \\\\* n_.\" 1 \"optimized\" } } */\n \n /* The if from the loop header copying remains in the code.  */\n /* { dg-final { scan-tree-dump-times \"if \" 1 \"optimized\" } } */"}, {"sha": "9ec893298a10bd0eea44b8bab2c617d6b7880fa6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-19.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -6,7 +6,7 @@\n \n /* { dg-do compile { target { i?86-*-* || { x86_64-*-* || powerpc_hard_double } } } } */\n /* { dg-require-effective-target nonpic } */\n-/* { dg-options \"-O3 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n \n # define N      2000000\n static double   a[N],c[N];\n@@ -22,7 +22,7 @@ void tuned_STREAM_Copy()\n    However, due to a bug in jump threading, we end up peeling one iteration from\n    the loop, which creates an additional occurence.  */\n \n-/* { dg-final { scan-tree-dump-times \"MEM.(base: &|symbol: )a,\" 2 \"final_cleanup\" } } */\n-/* { dg-final { scan-tree-dump-times \"MEM.(base: &|symbol: )c,\" 2 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM.(base: &|symbol: )a,\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM.(base: &|symbol: )c,\" 2 \"optimized\" } } */\n \n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f53407d9b026ba1cb615805cf7195652186d2481", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-21.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-21.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,7 +1,7 @@\n /* PR tree-optimization/30322 */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n extern void op( int, int);\n void foo(int f0, int f1, int e0, int e1)\n@@ -13,5 +13,5 @@ void foo(int f0, int f1, int e0, int e1)\n       op(i0, i1);\n }\n \n-/* { dg-final { scan-tree-dump-times \"~\" 0 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"~\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fa7da712b6aab8db75c7536dbaef3a5bba531119", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-22.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-22.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n int a[100];\n \n@@ -13,5 +13,5 @@ void test (int n)\n /* We used to replace the exit test \"i < n\" by \"i != ((n-1)/3) * 3 + 1\".  Although\n    correct, this transformation is obviously harmful.  */\n \n-/* { dg-final { scan-tree-dump-times \"/\" 0 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"/\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "77d0c47dc956cca1a8b0608f3425cdaa91631626", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-28.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-28.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-require-effective-target ilp32 } */\n-/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-final_cleanup -fdump-tree-aprefetch --param max-unrolled-insns=1000\" } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-optimized -fdump-tree-aprefetch --param max-unrolled-insns=1000\" } */\n \n char x[100000];\n \n@@ -15,10 +15,10 @@ void foo(int n)\n /* There should be 64 MEMs in the unrolled loop and one more in the copy of the loop\n    for the rest of the iterations.  */\n \n-/* { dg-final { scan-tree-dump-times \"MEM\" 65 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\" 65 \"optimized\" } } */\n \n /* There should be no i_a = i_b assignments.  */\n /* { dg-final { scan-tree-dump-times \"i_.*= i_\\[0-9\\]*;\" 0 \"aprefetch\" } } */\n \n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "a8db74afe14b6fff568784a3bd96b7ec85e79443", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-5.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -19,7 +19,9 @@ void xxx(void)\n /* Only iter variable should remain.  */\n \n /* { dg-final { scan-tree-dump-times \"int iter\" 1 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"jter\" 0 \"optimized\" } } */\n+\n+/* And jter shouldn't be an induction variable anymore (no PHI node).  */\n+/* { dg-final { scan-tree-dump-times \"jter_\\[0-9\\]* = PHI\" 0 \"optimized\" } } */\n \n /* And the use of jter should be replaced by iter + 2 */\n "}, {"sha": "783d598a0ed36bcbcbeb6a90c636aa7ce48c1d4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18134.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18134.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18134.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18134.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -17,7 +17,7 @@ return 0;\n \n /* Everything should have been cleaned up leaving a simple\n    return statement.  */\n-/* { dg-final { scan-tree-dump-times \"return.*a != 0\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= a_..D. != 0\" 1 \"optimized\" } } */\n \n /* There should not be any abnormal edges as DOM removed the\n    computed gotos.  */"}, {"sha": "1c87acbdddac8834faa5778c13286b611a88b117", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19431.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -24,6 +24,6 @@ int f(int k, int i1, int j1)\n   return *f1;\n }\n \n-/* { dg-final { scan-tree-dump \"i1 = j1\" \"optimized\" } } */\n-/* { dg-final { scan-tree-dump \"return i1;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"i1_. = PHI <i1_\\[^,\\]*, j1_\\[^>\\]*>\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"return i1_.;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "016ad004ee8939221e995cef58a5bc64a6163340", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20139.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20139.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20139.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20139.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -3,7 +3,7 @@\n    that the optimization happens at tree level.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n extern double fabs (double);\n extern void link_error (void);\n@@ -19,5 +19,5 @@ foo (double x)\n     link_error ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "73bda118fe58ce81334603812c94ba9055e46021", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22051-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22051-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22051-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22051-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -17,7 +17,7 @@ foo()\n /* The cast to a function pointer type must remain after all optimizations\n    are complete so that function pointer canonicalization works on those\n    targets which require it.  */\n-/* { dg-final { scan-tree-dump-times \"if \\\\(\\\\(void \\\\(\\\\*<.*>\\\\) \\\\(void\\\\)\\\\) p\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\(void \\\\(\\\\*<.*>\\\\) \\\\(void\\\\)\\\\) p_\" 1 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n \n "}, {"sha": "bcbbb73c659bbfec3ef78609f2ad0814a219cc5a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22051-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22051-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22051-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22051-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -20,6 +20,6 @@ foo()\n /* The cast to an int type must remain after all optimizations are complete\n    so that we do not try to canonicalize a function pointer for the\n    comparison when no such canonicalization is wanted.  */\n-/* { dg-final { scan-tree-dump-times \"if \\\\(\\\\(int\\\\).*q\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"r_. = \\\\(int\\\\) q\" 1 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "ed890fa55146b9cc8a53f634e843e9eafb566be7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23294.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23294.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23294.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23294.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -31,7 +31,7 @@ int f6(int a, int b)\n   return 6*a - 2*b;\n }\n \n-/* { dg-final { scan-tree-dump-times \"a \\\\\\* 5\" 3 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\\\) \\\\\\* 2\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"a_..D. \\\\\\* 5\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\\\* 2\" 3 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-not \"\\\\\\* 6\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3329383cbe89edb8a8b3aa28d3d9cc62d03bb44f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr30978.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30978.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30978.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30978.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -10,5 +10,5 @@ int foo(int a)\n   return e;\n }\n \n-/* { dg-final { scan-tree-dump \"return a > 0;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"e_. = a_..D. > 0;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "940a0362943379e4fa9fcc302aa9b6c497f8023c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr32044.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-empty -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fdump-tree-empty -fdump-tree-optimized\" } */\n \n int foo (int n)\n {\n@@ -48,8 +48,8 @@ int baz (int n)\n \n /* There should be no division/modulo in the final dump (division and modulo\n    by 64 are done using bit operations).  */\n-/* { dg-final { scan-tree-dump-times \"/\" 0 \"final_cleanup\" } } */\n-/* { dg-final { scan-tree-dump-times \"%\" 0 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"/\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"%\" 0 \"optimized\" } } */\n \n /* { dg-final { cleanup-tree-dump \"empty\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bff4b9fbf127f0d0cf9b6f4d55cfa12ceede9e28", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-4.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -2,7 +2,7 @@\n \n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-require-effective-target ilp32 } */\n-/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-optimized\" } */\n \n int xxx[20];\n \n@@ -14,5 +14,5 @@ void foo (int n)\n     xxx[i] = i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"prefetch\" 0 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"prefetch\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3024bed1b71b3834f7e433eb60269079922b33db", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-7.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-require-effective-target ilp32 } */\n-/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse --param simultaneous-prefetches=100 --param max-unrolled-insns=1 -fdump-tree-aprefetch-details -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse --param simultaneous-prefetches=100 --param max-unrolled-insns=1 -fdump-tree-aprefetch-details -fdump-tree-optimized\" } */\n \n #define K 1000000\n int a[K], b[K];\n@@ -45,9 +45,9 @@ void test(int *p)\n /* { dg-final { scan-tree-dump-times \"Issued nontemporal prefetch\" 3 \"aprefetch\" } } */\n /* { dg-final { scan-tree-dump-times \"nontemporal store\" 2 \"aprefetch\" } } */\n \n-/* { dg-final { scan-tree-dump-times \"builtin_prefetch\" 8 \"final_cleanup\" } } */\n-/* { dg-final { scan-tree-dump-times \"=\\\\{nt\\\\}\" 2 \"final_cleanup\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin_ia32_mfence\" 2 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"builtin_prefetch\" 8 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"=\\\\{nt\\\\}\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_ia32_mfence\" 2 \"optimized\" } } */\n \n /* { dg-final { scan-assembler-times \"prefetchw\" 5 } } */\n /* { dg-final { scan-assembler-times \"prefetcht\" 1 } } */\n@@ -56,4 +56,4 @@ void test(int *p)\n /* { dg-final { scan-assembler-times \"mfence\" 2 } } */\n \n /* { dg-final { cleanup-tree-dump \"aprefetch\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ea5e4a77b11438a80a1fcd203cd02c36cfaa6ccf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -14,5 +14,6 @@ int main(void)\n   printf (\"%d %d\\n\", e, f);\n }\n \n-/* { dg-final { scan-tree-dump-times \"b \\\\\\+ a\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"b.._. \\\\\\+ a.._.\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \" \\\\\\+ \" 2 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f05401cba1fc05eace99cc9f700d614abf9becf6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-13.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -10,6 +10,6 @@ double foo(double a)\n }\n \n /* { dg-final { scan-tree-dump-not \"\\\\\\+ 0.0\" \"reassoc1\" } } */\n-/* { dg-final { scan-tree-dump \"return a;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"return a_..D.;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"reassoc1\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "2cf245460ee1fc601e97be981d63e2acb6bcd56c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-cast.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-cast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-cast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-cast.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -20,7 +20,7 @@ void tst(void)\n     blau ((unsigned char) i); /* This one is necessary.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"\\\\(int\\\\) \\\\(unsigned char\\\\)\" 1 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\(int\\\\) \\\\(char\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\(unsigned char\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\(char\\\\)\" 1 \"optimized\" } } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ed3b2f7840fb0df74b6c461005cb08173d070daf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-15.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-15.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-rtl-expand-details\" } */\n \n /* Verify we PRE the strlen call, as strlen(\"\") folds to zero.  */\n \n@@ -12,5 +12,5 @@ __SIZE_TYPE__ mystrlen (const char *s)\n   return strlen(s);\n }\n \n-/* { dg-final { scan-tree-dump \"= 0;\" \"optimized\" } } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final { scan-rtl-dump \"PART.. = 0\" \"expand\" } } */\n+/* { dg-final { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "cb680937a2fd637ca775bd1eaca739e651047c1b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vector-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-w -O1 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-w -O1 -fdump-tree-optimized\" } */\n \n #define vector __attribute__(( vector_size(16) ))\n \n@@ -16,7 +16,7 @@ float f(vector float a, int b, vector float c)\n }\n \n /* We should be able to optimize this to just \"return 0.0;\" */\n-/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 0 \"final_cleanup\"} } */\n-/* { dg-final { scan-tree-dump-times \"0.0\" 1 \"final_cleanup\"} } */\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"0.0\" 1 \"optimized\"} } */\n \n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "15a700c658e86f8aa16ac01c66e6d80f678e8a8f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vector-3.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-w -O1 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-w -O1 -fdump-tree-optimized\" } */\n \n #define vector __attribute((vector_size(16) ))\n vector float a;\n@@ -13,8 +13,8 @@ float f(float b)\n }\n \n /* We should be able to optimize this to just \"return 0.0;\" */\n-/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 0 \"final_cleanup\"} } */\n-/* { dg-final { scan-tree-dump-times \"0.0\" 1 \"final_cleanup\"} } */\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"0.0\" 1 \"optimized\"} } */\n \n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "4107fd6e2cd88722db6786dd64a7d317d490a764", "filename": "gcc/testsuite/gcc.target/i386/pr37248-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-1.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -15,5 +15,6 @@ foo (struct S x)\n   return x.a && x.b && x.c;\n }\n \n-/* { dg-final { scan-tree-dump \"& 7\\[^\\n\\t\\]*== 7\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"& 7;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"== 7;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "0265a8ac64fe84911d86b41316dfdbb605e6d9ed", "filename": "gcc/testsuite/gcc.target/i386/pr37248-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-2.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -19,5 +19,6 @@ foo (struct S x)\n   return x.a && x.g && x.b && x.f && x.c && x.e;\n }\n \n-/* { dg-final { scan-tree-dump \"& (3758096391|0x0e0000007)\\[^\\n\\t\\]*== (3758096391|0x0e0000007)\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"& (3758096391|0x0e0000007);\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"== (3758096391|0x0e0000007);\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "309184ba045bd936034f9fc779d297b78fd890b3", "filename": "gcc/testsuite/gcc.target/i386/pr37248-3.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr37248-3.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -21,5 +21,6 @@ foo (struct S x)\n   return x.a && x.i && x.b && x.h && x.c && x.g && x.e == 131;\n }\n \n-/* { dg-final { scan-tree-dump \"& (3766484487|0x0e07ffe07)\\[^\\n\\t\\]*== (3758163463|0x0e0010607)\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"& (3766484487|0x0e07ffe07);\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"== (3758163463|0x0e0010607);\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3857dedf71eaf976fc3990e27039d648ce3baf0d", "filename": "gcc/testsuite/gfortran.dg/reassoc_1.f90", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_1.f90?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -7,5 +7,7 @@ function test(b)\n   test = a\n end\n \n-! { dg-final { scan-tree-dump \"\\\\\\+ 5.*\\\\\\)\\\\\\) - 5\" \"optimized\" } }\n+! We need an explicit +5 and -5, and an intermediate ((bla)) expression\n+! (the reassoc barrier).  Make use of \".\" matching lineends.\n+! { dg-final { scan-tree-dump \"\\\\\\+ 5.*\\\\\\)\\\\\\).* - 5\" \"optimized\" } }\n ! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "84a33972270cdb3a166d5205945a72a5e682c3c7", "filename": "gcc/testsuite/gfortran.dg/reassoc_3.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_3.f90?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -14,6 +14,7 @@ function test(a)\n end\n \n ! { dg-final { scan-tree-dump \"b = 5\" \"original\" } }\n-! { dg-final { scan-tree-dump \"return .a\" \"optimized\" } }\n+! { dg-final { scan-tree-dump \"c_. = .a\" \"optimized\" } }\n+! { dg-final { scan-tree-dump \"return c_.;\" \"optimized\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n ! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "898b4e6848ec853622115a2656824e76586d0ebe", "filename": "gcc/testsuite/gfortran.dg/whole_file_5.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_5.f90?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -16,3 +16,4 @@ PROGRAM main\n END PROGRAM\n \n ! { dg-final { scan-tree-dump-times \"= f\\(\\)\" 0 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "157cfa115262d914a371db46f28fc9de5b133a1f", "filename": "gcc/testsuite/gfortran.dg/whole_file_6.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_6.f90?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -16,3 +16,4 @@ INTEGER FUNCTION f()\n END FUNCTION\n \n ! { dg-final { scan-tree-dump-times \"= f\\(\\)\" 0 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "b2b7d123b1fbcc1e1e0a85b0dd7a41d7917b1ba6", "filename": "gcc/testsuite/gnat.dg/aliasing1.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing1.adb?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n -- { dg-do compile }\n--- { dg-options \"-O2 -gnatp -fdump-tree-final_cleanup\" }\n+-- { dg-options \"-O2 -gnatp -fdump-tree-optimized\" }\n \n -- The raise statement must be optimized away by\n -- virtue of DECL_NONADDRESSABLE_P set on R.I.\n@@ -18,5 +18,5 @@ package body Aliasing1 is\n \n end Aliasing1;\n \n--- { dg-final { scan-tree-dump-not \"__gnat_rcheck\" \"final_cleanup\" } }\n--- { dg-final { cleanup-tree-dump \"final_cleanup\" } }\n+-- { dg-final { scan-tree-dump-not \"__gnat_rcheck\" \"optimized\" } }\n+-- { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "065cee02f7d8d75b0e8268c2f24b9bb6ec61c27d", "filename": "gcc/testsuite/gnat.dg/aliasing2.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faliasing2.adb?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n -- { dg-do compile }\n--- { dg-options \"-O2 -gnatp -fdump-tree-final_cleanup\" }\n+-- { dg-options \"-O2 -gnatp -fdump-tree-optimized\" }\n \n -- The raise statement must be optimized away by\n -- virtue of TYPE_NONALIASED_COMPONENT set on A.\n@@ -18,5 +18,5 @@ package body Aliasing2 is\n \n end Aliasing2;\n \n--- { dg-final { scan-tree-dump-not \"__gnat_rcheck\" \"final_cleanup\" } }\n--- { dg-final { cleanup-tree-dump \"final_cleanup\" } }\n+-- { dg-final { scan-tree-dump-not \"__gnat_rcheck\" \"optimized\" } }\n+-- { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "64d71b11cc97bb8e01b350c5b9b0f92f4b2347d2", "filename": "gcc/testsuite/gnat.dg/pack9.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgnat.dg%2Fpack9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftestsuite%2Fgnat.dg%2Fpack9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fpack9.adb?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -1,5 +1,5 @@\n -- { dg-do compile }\n--- { dg-options \"-O2 -gnatp -cargs --param sra-max-structure-size=24 --param sra-max-structure-count=6 -fdump-tree-final_cleanup\" }\n+-- { dg-options \"-O2 -gnatp -cargs --param sra-max-structure-size=24 --param sra-max-structure-count=6 -fdump-tree-optimized\" }\n \n package body Pack9 is\n \n@@ -14,5 +14,5 @@ package body Pack9 is\n \n end Pack9;\n \n--- { dg-final { scan-tree-dump-not \"__gnat_rcheck\" \"final_cleanup\" } }\n--- { dg-final { cleanup-tree-dump \"final_cleanup\" } }\n+-- { dg-final { scan-tree-dump-not \"__gnat_rcheck\" \"optimized\" } }\n+-- { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "d302cd2d5fc9566c29eb577ad3c0282cf8aaf5b9", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -199,10 +199,6 @@ enum noalias_state {\n struct GTY(()) var_ann_d {\n   struct tree_ann_common_d common;\n \n-  /* Used by the out of SSA pass to determine whether this variable has\n-     been seen yet or not.  */\n-  unsigned out_of_ssa_tag : 1;\n-\n   /* Used when building base variable structures in a var_map.  */\n   unsigned base_var_processed : 1;\n \n@@ -224,10 +220,6 @@ struct GTY(()) var_ann_d {\n      information on each attribute.  */\n   ENUM_BITFIELD (noalias_state) noalias_state : 2;\n \n-  /* Used when going out of SSA form to indicate which partition this\n-     variable represents storage for.  */\n-  unsigned partition;\n-\n   /* Used by var_map for the base index of ssa base variables.  */\n   unsigned base_index;\n \n@@ -960,6 +952,7 @@ rtx addr_for_mem_ref (struct mem_address *, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);\n \n+unsigned int execute_free_datastructures (void);\n unsigned int execute_fixup_cfg (void);\n \n #include \"tree-flow-inline.h\""}, {"sha": "e2116e5a3804e23c85f25453e5e9b7c6e6e47154", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -459,11 +459,11 @@ mf_decl_cache_locals (void)\n \n   /* Build the cache vars.  */\n   mf_cache_shift_decl_l\n-    = mf_mark (create_tmp_var (TREE_TYPE (mf_cache_shift_decl),\n+    = mf_mark (make_rename_temp (TREE_TYPE (mf_cache_shift_decl),\n                                \"__mf_lookup_shift_l\"));\n \n   mf_cache_mask_decl_l\n-    = mf_mark (create_tmp_var (TREE_TYPE (mf_cache_mask_decl),\n+    = mf_mark (make_rename_temp (TREE_TYPE (mf_cache_mask_decl),\n                                \"__mf_lookup_mask_l\"));\n \n   /* Build initialization nodes for the cache vars.  We just load the\n@@ -546,9 +546,9 @@ mf_build_check_statement_for (tree base, tree limit,\n     }\n \n   /* Build our local variables.  */\n-  mf_elem = create_tmp_var (mf_cache_structptr_type, \"__mf_elem\");\n-  mf_base = create_tmp_var (mf_uintptr_type, \"__mf_base\");\n-  mf_limit = create_tmp_var (mf_uintptr_type, \"__mf_limit\");\n+  mf_elem = make_rename_temp (mf_cache_structptr_type, \"__mf_elem\");\n+  mf_base = make_rename_temp (mf_uintptr_type, \"__mf_base\");\n+  mf_limit = make_rename_temp (mf_uintptr_type, \"__mf_limit\");\n \n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n   seq = gimple_seq_alloc ();\n@@ -627,7 +627,7 @@ mf_build_check_statement_for (tree base, tree limit,\n   t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, u);\n   t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n   gimple_seq_add_seq (&seq, stmts);\n-  cond = create_tmp_var (boolean_type_node, \"__mf_unlikely_cond\");\n+  cond = make_rename_temp (boolean_type_node, \"__mf_unlikely_cond\");\n   g = gimple_build_assign  (cond, t);\n   gimple_set_location (g, location);\n   gimple_seq_add_stmt (&seq, g);\n@@ -1366,12 +1366,12 @@ struct gimple_opt_pass pass_mudflap_2 =\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n   TV_NONE,                              /* tv_id */\n-  PROP_gimple_leh,                      /* properties_required */\n+  PROP_ssa | PROP_cfg | PROP_gimple_leh,/* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n   TODO_verify_flow | TODO_verify_stmts\n-  | TODO_dump_func                      /* todo_flags_finish */\n+  | TODO_dump_func | TODO_update_ssa    /* todo_flags_finish */\n  }\n };\n "}, {"sha": "07245cd6d7b71abe2c1e8c7b3f86bdb874fa9ee4", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -56,6 +56,7 @@ struct nrv_data\n   /* This is the function's RESULT_DECL.  We will replace all occurrences\n      of VAR with RESULT_DECL when we apply this optimization.  */\n   tree result;\n+  int modified;\n };\n \n static tree finalize_nrv_r (tree *, int *, void *);\n@@ -83,7 +84,10 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n \n   /* Otherwise replace all occurrences of VAR with RESULT.  */\n   else if (*tp == dp->var)\n-    *tp = dp->result;\n+    {\n+      *tp = dp->result;\n+      dp->modified = 1;\n+    }\n \n   /* Keep iterating.  */\n   return NULL_TREE;\n@@ -229,13 +233,19 @@ tree_nrv (void)\n \t  if (gimple_assign_copy_p (stmt)\n \t      && gimple_assign_lhs (stmt) == result\n \t      && gimple_assign_rhs1 (stmt) == found)\n-\t    gsi_remove (&gsi, true);\n+\t    {\n+\t      unlink_stmt_vdef (stmt);\n+\t      gsi_remove (&gsi, true);\n+\t    }\n \t  else\n \t    {\n \t      struct walk_stmt_info wi;\n \t      memset (&wi, 0, sizeof (wi));\n \t      wi.info = &data;\n+\t      data.modified = 0;\n \t      walk_gimple_op (stmt, finalize_nrv_r, &wi);\n+\t      if (data.modified)\n+\t\tupdate_stmt (stmt);\n \t      gsi_next (&gsi);\n \t    }\n \t}\n@@ -263,7 +273,7 @@ struct gimple_opt_pass pass_nrv =\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   TV_TREE_NRV,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n+  PROP_ssa | PROP_cfg,\t\t\t\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */"}, {"sha": "7b4913c5bf741a517bb67515915b067f92f65fd4", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -201,7 +201,7 @@ struct gimple_opt_pass pass_cleanup_cfg_post_optimizing =\n {\n  {\n   GIMPLE_PASS,\n-  \"final_cleanup\",\t\t\t/* name */\n+  \"optimized\",\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n   execute_cleanup_cfg_post_optimizing,\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n@@ -213,13 +213,14 @@ struct gimple_opt_pass pass_cleanup_cfg_post_optimizing =\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func\t\t\t/* todo_flags_finish */\n+    | TODO_remove_unused_locals\n  }\n };\n \n /* Pass: do the actions required to finish with tree-ssa optimization\n    passes.  */\n \n-static unsigned int\n+unsigned int\n execute_free_datastructures (void)\n {\n   free_dominance_info (CDI_DOMINATORS);\n@@ -228,6 +229,10 @@ execute_free_datastructures (void)\n   /* Remove the ssa structures.  */\n   if (cfun->gimple_df)\n     delete_tree_ssa ();\n+\n+  /* And get rid of annotations we no longer need.  */\n+  delete_tree_cfg_annotations ();\n+\n   return 0;\n }\n \n@@ -254,9 +259,6 @@ struct gimple_opt_pass pass_free_datastructures =\n static unsigned int\n execute_free_cfg_annotations (void)\n {\n-  /* And get rid of annotations we no longer need.  */\n-  delete_tree_cfg_annotations ();\n-\n   return 0;\n }\n "}, {"sha": "59958f50fd12785cb11cf76e1294a8c75c71cb76", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 266, "deletions": 838, "changes": 1104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -30,9 +30,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"timevar.h\"\n #include \"tree-dump.h\"\n-#include \"tree-ssa-live.h\"\n #include \"tree-pass.h\"\n #include \"toplev.h\"\n+#include \"expr.h\"\n+#include \"ssaexpand.h\"\n \n \n /* Used to hold all the components required to do SSA PHI elimination.\n@@ -61,7 +62,7 @@ typedef struct _elim_graph {\n   int size;\n \n   /* List of nodes in the elimination graph.  */\n-  VEC(tree,heap) *nodes;\n+  VEC(int,heap) *nodes;\n \n   /*  The predecessor and successor edge list.  */\n   VEC(int,heap) *edge_list;\n@@ -79,85 +80,176 @@ typedef struct _elim_graph {\n   edge e;\n \n   /* List of constant copies to emit.  These are pushed on in pairs.  */\n+  VEC(int,heap) *const_dests;\n   VEC(tree,heap) *const_copies;\n } *elim_graph;\n \n \n-/* Create a temporary variable based on the type of variable T.  Use T's name\n-   as the prefix.  */\n+/* For an edge E find out a good source location to associate with\n+   instructions inserted on edge E.  If E has an implicit goto set,\n+   use its location.  Otherwise search instructions in predecessors\n+   of E for a location, and use that one.  That makes sense because\n+   we insert on edges for PHI nodes, and effects of PHIs happen on\n+   the end of the predecessor conceptually.  */\n \n-static tree\n-create_temp (tree t)\n+static void\n+set_location_for_edge (edge e)\n {\n-  tree tmp;\n-  const char *name = NULL;\n-  tree type;\n-\n-  if (TREE_CODE (t) == SSA_NAME)\n-    t = SSA_NAME_VAR (t);\n-\n-  gcc_assert (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL);\n+  if (e->goto_locus)\n+    {\n+      set_curr_insn_source_location (e->goto_locus);\n+      set_curr_insn_block (e->goto_block);\n+    }\n+  else\n+    {\n+      basic_block bb = e->src;\n+      gimple_stmt_iterator gsi;\n \n-  type = TREE_TYPE (t);\n-  tmp = DECL_NAME (t);\n-  if (tmp)\n-    name = IDENTIFIER_POINTER (tmp);\n+      do\n+\t{\n+\t  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      if (gimple_has_location (stmt) || gimple_block (stmt))\n+\t\t{\n+\t\t  set_curr_insn_source_location (gimple_location (stmt));\n+\t\t  set_curr_insn_block (gimple_block (stmt));\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  /* Nothing found in this basic block.  Make a half-assed attempt\n+\t     to continue with another block.  */\n+\t  if (single_pred_p (bb))\n+\t    bb = single_pred (bb);\n+\t  else\n+\t    bb = e->src;\n+\t}\n+      while (bb != e->src);\n+    }\n+}\n \n-  if (name == NULL)\n-    name = \"temp\";\n-  tmp = create_tmp_var (type, name);\n+/* Insert a copy instruction from partition SRC to DEST onto edge E.  */\n \n-  if (DECL_DEBUG_EXPR_IS_FROM (t) && DECL_DEBUG_EXPR (t))\n+static void\n+insert_partition_copy_on_edge (edge e, int dest, int src)\n+{\n+  rtx seq;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      SET_DECL_DEBUG_EXPR (tmp, DECL_DEBUG_EXPR (t));  \n-      DECL_DEBUG_EXPR_IS_FROM (tmp) = 1;\n+      fprintf (dump_file,\n+\t       \"Inserting a partition copy on edge BB%d->BB%d :\"\n+\t       \"PART.%d = PART.%d\",\n+\t       e->src->index,\n+\t       e->dest->index, dest, src);\n+      fprintf (dump_file, \"\\n\");\n     }\n-  else if (!DECL_IGNORED_P (t))\n+\n+  gcc_assert (SA.partition_to_pseudo[dest]);\n+  gcc_assert (SA.partition_to_pseudo[src]);\n+\n+  set_location_for_edge (e);\n+\n+  /* Partition copy between same base variables only, so it's the same mode,\n+     hence we can use emit_move_insn.  */\n+  start_sequence ();\n+  emit_move_insn (SA.partition_to_pseudo[dest], SA.partition_to_pseudo[src]);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  insert_insn_on_edge (seq, e);\n+}\n+\n+/* Insert a copy instruction from expression SRC to partition DEST\n+   onto edge E.  */\n+\n+static void\n+insert_value_copy_on_edge (edge e, int dest, tree src)\n+{\n+  rtx seq, x;\n+  enum machine_mode mode;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      SET_DECL_DEBUG_EXPR (tmp, t);\n-      DECL_DEBUG_EXPR_IS_FROM (tmp) = 1;\n+      fprintf (dump_file,\n+\t       \"Inserting a value copy on edge BB%d->BB%d : PART.%d = \",\n+\t       e->src->index,\n+\t       e->dest->index, dest);\n+      print_generic_expr (dump_file, src, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n     }\n-  DECL_ARTIFICIAL (tmp) = DECL_ARTIFICIAL (t);\n-  DECL_IGNORED_P (tmp) = DECL_IGNORED_P (t);\n-  DECL_GIMPLE_REG_P (tmp) = DECL_GIMPLE_REG_P (t);\n-  add_referenced_var (tmp);\n \n-  /* We should never have copied variables in non-automatic storage\n-     or variables that have their address taken.  So it is pointless\n-     to try to copy call-clobber state here.  */\n-  gcc_assert (!may_be_aliased (t) && !is_global_var (t));\n+  gcc_assert (SA.partition_to_pseudo[dest]);\n \n-  return tmp;\n-}\n+  set_location_for_edge (e);\n+\n+  start_sequence ();\n+  mode = GET_MODE (SA.partition_to_pseudo[dest]);\n+  x = expand_expr (src, SA.partition_to_pseudo[dest], mode, EXPAND_NORMAL);\n+  if (GET_MODE (x) != mode)\n+    x = convert_to_mode (mode, x, TYPE_UNSIGNED (TREE_TYPE (src)));\n+  if (x != SA.partition_to_pseudo[dest])\n+    emit_move_insn (SA.partition_to_pseudo[dest], x);\n+  seq = get_insns ();\n+  end_sequence ();\n \n+  insert_insn_on_edge (seq, e);\n+}\n \n-/* This helper function fill insert a copy from a constant or variable SRC to \n-   variable DEST on edge E.  */\n+/* Insert a copy instruction from RTL expression SRC to partition DEST\n+   onto edge E.  */\n \n static void\n-insert_copy_on_edge (edge e, tree dest, tree src)\n+insert_rtx_to_part_on_edge (edge e, int dest, rtx src)\n {\n-  gimple copy;\n+  rtx seq;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file,\n+\t       \"Inserting a temp copy on edge BB%d->BB%d : PART.%d = \",\n+\t       e->src->index,\n+\t       e->dest->index, dest);\n+      print_simple_rtl (dump_file, src);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n-  copy = gimple_build_assign (dest, src);\n-  set_is_used (dest);\n+  gcc_assert (SA.partition_to_pseudo[dest]);\n+  set_location_for_edge (e);\n \n-  if (TREE_CODE (src) == ADDR_EXPR)\n-    src = TREE_OPERAND (src, 0);\n-  if (TREE_CODE (src) == VAR_DECL || TREE_CODE (src) == PARM_DECL)\n-    set_is_used (src);\n+  start_sequence ();\n+  gcc_assert (GET_MODE (src) == GET_MODE (SA.partition_to_pseudo[dest]));\n+  emit_move_insn (SA.partition_to_pseudo[dest], src);\n+  seq = get_insns ();\n+  end_sequence ();\n \n+  insert_insn_on_edge (seq, e);\n+}\n+\n+/* Insert a copy instruction from partition SRC to RTL lvalue DEST\n+   onto edge E.  */\n+\n+static void\n+insert_part_to_rtx_on_edge (edge e, rtx dest, int src)\n+{\n+  rtx seq;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file,\n-\t       \"Inserting a copy on edge BB%d->BB%d :\",\n+\t       \"Inserting a temp copy on edge BB%d->BB%d : \",\n \t       e->src->index,\n \t       e->dest->index);\n-      print_gimple_stmt (dump_file, copy, 0, dump_flags);\n-      fprintf (dump_file, \"\\n\");\n+      print_simple_rtl (dump_file, dest);\n+      fprintf (dump_file, \"= PART.%d\\n\", src);\n     }\n \n-  gsi_insert_on_edge (e, copy);\n+  gcc_assert (SA.partition_to_pseudo[src]);\n+  set_location_for_edge (e);\n+\n+  start_sequence ();\n+  gcc_assert (GET_MODE (dest) == GET_MODE (SA.partition_to_pseudo[src]));\n+  emit_move_insn (dest, SA.partition_to_pseudo[src]);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  insert_insn_on_edge (seq, e);\n }\n \n \n@@ -169,7 +261,8 @@ new_elim_graph (int size)\n {\n   elim_graph g = (elim_graph) xmalloc (sizeof (struct _elim_graph));\n \n-  g->nodes = VEC_alloc (tree, heap, 30);\n+  g->nodes = VEC_alloc (int, heap, 30);\n+  g->const_dests = VEC_alloc (int, heap, 20);\n   g->const_copies = VEC_alloc (tree, heap, 20);\n   g->edge_list = VEC_alloc (int, heap, 20);\n   g->stack = VEC_alloc (int, heap, 30);\n@@ -185,7 +278,7 @@ new_elim_graph (int size)\n static inline void\n clear_elim_graph (elim_graph g)\n {\n-  VEC_truncate (tree, g->nodes, 0);\n+  VEC_truncate (int, g->nodes, 0);\n   VEC_truncate (int, g->edge_list, 0);\n }\n \n@@ -199,7 +292,8 @@ delete_elim_graph (elim_graph g)\n   VEC_free (int, heap, g->stack);\n   VEC_free (int, heap, g->edge_list);\n   VEC_free (tree, heap, g->const_copies);\n-  VEC_free (tree, heap, g->nodes);\n+  VEC_free (int, heap, g->const_dests);\n+  VEC_free (int, heap, g->nodes);\n   free (g);\n }\n \n@@ -209,22 +303,22 @@ delete_elim_graph (elim_graph g)\n static inline int\n elim_graph_size (elim_graph g)\n {\n-  return VEC_length (tree, g->nodes);\n+  return VEC_length (int, g->nodes);\n }\n \n \n /* Add NODE to graph G, if it doesn't exist already.  */\n \n static inline void \n-elim_graph_add_node (elim_graph g, tree node)\n+elim_graph_add_node (elim_graph g, int node)\n {\n   int x;\n-  tree t;\n+  int t;\n \n-  for (x = 0; VEC_iterate (tree, g->nodes, x, t); x++)\n+  for (x = 0; VEC_iterate (int, g->nodes, x, t); x++)\n     if (t == node)\n       return;\n-  VEC_safe_push (tree, heap, g->nodes, node);\n+  VEC_safe_push (int, heap, g->nodes, node);\n }\n \n \n@@ -299,7 +393,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Add T to elimination graph G.  */\n \n static inline void\n-eliminate_name (elim_graph g, tree T)\n+eliminate_name (elim_graph g, int T)\n {\n   elim_graph_add_node (g, T);\n }\n@@ -309,22 +403,21 @@ eliminate_name (elim_graph g, tree T)\n    G->e.  */\n \n static void\n-eliminate_build (elim_graph g, basic_block B)\n+eliminate_build (elim_graph g)\n {\n-  tree T0, Ti;\n+  tree Ti;\n   int p0, pi;\n   gimple_stmt_iterator gsi;\n \n   clear_elim_graph (g);\n   \n-  for (gsi = gsi_start_phis (B); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gsi = gsi_start_phis (g->e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n \n-      T0 = var_to_partition_to_var (g->map, gimple_phi_result (phi));\n-      \n+      p0 = var_to_partition (g->map, gimple_phi_result (phi));\n       /* Ignore results which are not in partitions.  */\n-      if (T0 == NULL_TREE)\n+      if (p0 == NO_PARTITION)\n \tcontinue;\n \n       Ti = PHI_ARG_DEF (phi, g->e->dest_idx);\n@@ -338,18 +431,16 @@ eliminate_build (elim_graph g, basic_block B)\n         {\n \t  /* Save constant copies until all other copies have been emitted\n \t     on this edge.  */\n-\t  VEC_safe_push (tree, heap, g->const_copies, T0);\n+\t  VEC_safe_push (int, heap, g->const_dests, p0);\n \t  VEC_safe_push (tree, heap, g->const_copies, Ti);\n \t}\n       else\n         {\n-\t  Ti = var_to_partition_to_var (g->map, Ti);\n-\t  if (T0 != Ti)\n+\t  pi = var_to_partition (g->map, Ti);\n+\t  if (p0 != pi)\n \t    {\n-\t      eliminate_name (g, T0);\n-\t      eliminate_name (g, Ti);\n-\t      p0 = var_to_partition (g->map, T0);\n-\t      pi = var_to_partition (g->map, Ti);\n+\t      eliminate_name (g, p0);\n+\t      eliminate_name (g, pi);\n \t      elim_graph_add_edge (g, p0, pi);\n \t    }\n \t}\n@@ -399,32 +490,46 @@ elim_backward (elim_graph g, int T)\n       if (!TEST_BIT (g->visited, P))\n         {\n \t  elim_backward (g, P);\n-\t  insert_copy_on_edge (g->e, \n-\t\t\t       partition_to_var (g->map, P), \n-\t\t\t       partition_to_var (g->map, T));\n+\t  insert_partition_copy_on_edge (g->e, P, T);\n \t}\n     });\n }\n \n+/* Allocate a new pseudo register usable for storing values sitting\n+   in NAME (a decl or SSA name), i.e. with matching mode and attributes.  */\n+\n+static rtx\n+get_temp_reg (tree name)\n+{\n+  tree var = TREE_CODE (name) == SSA_NAME ? SSA_NAME_VAR (name) : name;\n+  tree type = TREE_TYPE (var);\n+  int unsignedp = TYPE_UNSIGNED (type);\n+  enum machine_mode reg_mode\n+    = promote_mode (type, DECL_MODE (var), &unsignedp, 0);\n+  rtx x = gen_reg_rtx (reg_mode);\n+  if (POINTER_TYPE_P (type))\n+    mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (var))));\n+  return x;\n+}\n+\n /* Insert required copies for T in graph G.  Check for a strongly connected \n    region, and create a temporary to break the cycle if one is found.  */\n \n static void \n elim_create (elim_graph g, int T)\n {\n-  tree U;\n   int P, S;\n \n   if (elim_unvisited_predecessor (g, T))\n     {\n-      U = create_temp (partition_to_var (g->map, T));\n-      insert_copy_on_edge (g->e, U, partition_to_var (g->map, T));\n+      rtx U = get_temp_reg (partition_to_var (g->map, T));\n+      insert_part_to_rtx_on_edge (g->e, U, T);\n       FOR_EACH_ELIM_GRAPH_PRED (g, T, P, \n \t{\n \t  if (!TEST_BIT (g->visited, P))\n \t    {\n \t      elim_backward (g, P);\n-\t      insert_copy_on_edge (g->e, partition_to_var (g->map, P), U);\n+\t      insert_rtx_to_part_on_edge (g->e, P, U);\n \t    }\n \t});\n     }\n@@ -434,12 +539,9 @@ elim_create (elim_graph g, int T)\n       if (S != -1)\n \t{\n \t  SET_BIT (g->visited, T);\n-\t  insert_copy_on_edge (g->e, \n-\t\t\t       partition_to_var (g->map, T), \n-\t\t\t       partition_to_var (g->map, S));\n+\t  insert_partition_copy_on_edge (g->e, T, S);\n \t}\n     }\n-  \n }\n \n \n@@ -449,7 +551,6 @@ static void\n eliminate_phi (edge e, elim_graph g)\n {\n   int x;\n-  basic_block B = e->dest;\n \n   gcc_assert (VEC_length (tree, g->const_copies) == 0);\n \n@@ -459,20 +560,19 @@ eliminate_phi (edge e, elim_graph g)\n \n   g->e = e;\n \n-  eliminate_build (g, B);\n+  eliminate_build (g);\n \n   if (elim_graph_size (g) != 0)\n     {\n-      tree var;\n+      int part;\n \n       sbitmap_zero (g->visited);\n       VEC_truncate (int, g->stack, 0);\n \n-      for (x = 0; VEC_iterate (tree, g->nodes, x, var); x++)\n+      for (x = 0; VEC_iterate (int, g->nodes, x, part); x++)\n         {\n-\t  int p = var_to_partition (g->map, var);\n-\t  if (!TEST_BIT (g->visited, p))\n-\t    elim_forward (g, p);\n+\t  if (!TEST_BIT (g->visited, part))\n+\t    elim_forward (g, part);\n \t}\n        \n       sbitmap_zero (g->visited);\n@@ -487,121 +587,15 @@ eliminate_phi (edge e, elim_graph g)\n   /* If there are any pending constant copies, issue them now.  */\n   while (VEC_length (tree, g->const_copies) > 0)\n     {\n-      tree src, dest;\n+      int dest;\n+      tree src;\n       src = VEC_pop (tree, g->const_copies);\n-      dest = VEC_pop (tree, g->const_copies);\n-      insert_copy_on_edge (e, dest, src);\n+      dest = VEC_pop (int, g->const_dests);\n+      insert_value_copy_on_edge (e, dest, src);\n     }\n }\n \n \n-/* Take the ssa-name var_map MAP, and assign real variables to each \n-   partition.  */\n-\n-static void\n-assign_vars (var_map map)\n-{\n-  int x, num;\n-  tree var, root;\n-  var_ann_t ann;\n-\n-  num = num_var_partitions (map);\n-  for (x = 0; x < num; x++)\n-    {\n-      var = partition_to_var (map, x);\n-      if (TREE_CODE (var) != SSA_NAME)\n-\t{\n-\t  ann = var_ann (var);\n-\t  /* It must already be coalesced.  */\n-\t  gcc_assert (ann->out_of_ssa_tag == 1);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"partition %d already has variable \", x);\n-\t      print_generic_expr (dump_file, var, TDF_SLIM);\n-\t      fprintf (dump_file, \" assigned to it.\\n\");\n-\t    }\n-\t}\n-      else\n-        {\n-\t  root = SSA_NAME_VAR (var);\n-\t  ann = var_ann (root);\n-\t  /* If ROOT is already associated, create a new one.  */\n-\t  if (ann->out_of_ssa_tag)\n-\t    {\n-\t      root = create_temp (root);\n-\t      ann = var_ann (root);\n-\t    }\n-\t  /* ROOT has not been coalesced yet, so use it.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Partition %d is assigned to var \", x);\n-\t      print_generic_stmt (dump_file, root, TDF_SLIM);\n-\t    }\n-\t  change_partition_var (map, root, x);\n-\t}\n-    }\n-}\n-\n-\n-/* Replace use operand P with whatever variable it has been rewritten to based \n-   on the partitions in MAP.  EXPR is an optional expression vector over SSA \n-   versions which is used to replace P with an expression instead of a variable.\n-   If the stmt is changed, return true.  */ \n-\n-static inline bool\n-replace_use_variable (var_map map, use_operand_p p, gimple *expr)\n-{\n-  tree new_var;\n-  tree var = USE_FROM_PTR (p);\n-\n-  /* Check if we are replacing this variable with an expression.  */\n-  if (expr)\n-    {\n-      int version = SSA_NAME_VERSION (var);\n-      if (expr[version])\n-        {\n-\t  SET_USE (p, gimple_assign_rhs_to_tree (expr[version]));\n-\t  return true;\n-\t}\n-    }\n-\n-  new_var = var_to_partition_to_var (map, var);\n-  if (new_var)\n-    {\n-      SET_USE (p, new_var);\n-      set_is_used (new_var);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-\n-/* Replace def operand DEF_P with whatever variable it has been rewritten to \n-   based on the partitions in MAP.  EXPR is an optional expression vector over\n-   SSA versions which is used to replace DEF_P with an expression instead of a \n-   variable.  If the stmt is changed, return true.  */ \n-\n-static inline bool\n-replace_def_variable (var_map map, def_operand_p def_p, tree *expr)\n-{\n-  tree new_var;\n-  tree var = DEF_FROM_PTR (def_p);\n-\n-  /* Do nothing if we are replacing this variable with an expression.  */\n-  if (expr && expr[SSA_NAME_VERSION (var)])\n-    return true;\n-\n-  new_var = var_to_partition_to_var (map, var);\n-  if (new_var)\n-    {\n-      SET_DEF (def_p, new_var);\n-      set_is_used (new_var);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-\n /* Remove each argument from PHI.  If an arg was the last use of an SSA_NAME, \n    check to see if this allows another PHI node to be removed.  */\n \n@@ -704,21 +698,16 @@ eliminate_useless_phis (void)\n    variable.  */\n \n static void\n-rewrite_trees (var_map map, gimple *values)\n+rewrite_trees (var_map map)\n {\n-  elim_graph g;\n-  basic_block bb;\n-  gimple_stmt_iterator gsi;\n-  edge e;\n-  gimple_seq phi;\n-  bool changed;\n- \n #ifdef ENABLE_CHECKING\n+  basic_block bb;\n   /* Search for PHIs where the destination has no partition, but one\n      or more arguments has a partition.  This should not happen and can\n      create incorrect code.  */\n   FOR_EACH_BB (bb)\n     {\n+      gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple phi = gsi_stmt (gsi);\n@@ -744,593 +733,54 @@ rewrite_trees (var_map map, gimple *values)\n \t}\n     }\n #endif\n-\n-  /* Replace PHI nodes with any required copies.  */\n-  g = new_elim_graph (map->num_partitions);\n-  g->map = map;\n-  FOR_EACH_BB (bb)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  use_operand_p use_p, copy_use_p;\n-\t  def_operand_p def_p;\n-\t  bool remove = false, is_copy = false;\n-\t  int num_uses = 0;\n-\t  ssa_op_iter iter;\n-\n-\t  changed = false;\n-\n-\t  if (gimple_assign_copy_p (stmt))\n-\t    is_copy = true;\n-\n-\t  copy_use_p = NULL_USE_OPERAND_P;\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      if (replace_use_variable (map, use_p, values))\n-\t\tchanged = true;\n-\t      copy_use_p = use_p;\n-\t      num_uses++;\n-\t    }\n-\n-\t  if (num_uses != 1)\n-\t    is_copy = false;\n-\n-\t  def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);\n-\n-\t  if (def_p != NULL)\n-\t    {\n-\t      /* Mark this stmt for removal if it is the list of replaceable \n-\t\t expressions.  */\n-\t      if (values && values[SSA_NAME_VERSION (DEF_FROM_PTR (def_p))])\n-\t\tremove = true;\n-\t      else\n-\t\t{\n-\t\t  if (replace_def_variable (map, def_p, NULL))\n-\t\t    changed = true;\n-\t\t  /* If both SSA_NAMEs coalesce to the same variable,\n-\t\t     mark the now redundant copy for removal.  */\n-\t\t  if (is_copy)\n-\t\t    {\n-\t\t      gcc_assert (copy_use_p != NULL_USE_OPERAND_P);\n-\t\t      if (DEF_FROM_PTR (def_p) == USE_FROM_PTR (copy_use_p))\n-\t\t\tremove = true;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n-\t      if (replace_def_variable (map, def_p, NULL))\n-\t\tchanged = true;\n-\n-\t  /* Remove any stmts marked for removal.  */\n-\t  if (remove)\n-\t    gsi_remove (&gsi, true);\n-\t  else\n-\t    {\n-\t      if (changed)\n-\t\tif (maybe_clean_or_replace_eh_stmt (stmt, stmt))\n-\t\t  gimple_purge_dead_eh_edges (bb);\n-\t      gsi_next (&gsi);\n-\t    }\n-\t}\n-\n-      phi = phi_nodes (bb);\n-      if (phi)\n-        {\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    eliminate_phi (e, g);\n-\t}\n-    }\n-\n-  delete_elim_graph (g);\n-}\n-\n-/* These are the local work structures used to determine the best place to \n-   insert the copies that were placed on edges by the SSA->normal pass..  */\n-static VEC(edge,heap) *edge_leader;\n-static VEC(gimple_seq,heap) *stmt_list;\n-static bitmap leader_has_match = NULL;\n-static edge leader_match = NULL;\n-\n-\n-/* Pass this function to make_forwarder_block so that all the edges with\n-   matching PENDING_STMT lists to 'curr_stmt_list' get redirected.  E is the\n-   edge to test for a match.  */\n-\n-static inline bool \n-same_stmt_list_p (edge e)\n-{\n-  return (e->aux == (PTR) leader_match) ? true : false;\n }\n \n+/* Given the out-of-ssa info object SA (with prepared partitions)\n+   eliminate all phi nodes in all basic blocks.  Afterwards no\n+   basic block will have phi nodes anymore and there are possibly\n+   some RTL instructions inserted on edges.  */\n \n-/* Return TRUE if S1 and S2 are equivalent copies.  */\n-\n-static inline bool\n-identical_copies_p (const_gimple s1, const_gimple s2)\n-{\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (is_gimple_assign (s1));\n-  gcc_assert (is_gimple_assign (s2));\n-  gcc_assert (DECL_P (gimple_assign_lhs (s1)));\n-  gcc_assert (DECL_P (gimple_assign_lhs (s2)));\n-#endif\n-\n-  if (gimple_assign_lhs (s1) != gimple_assign_lhs (s2))\n-    return false;\n-\n-  if (gimple_assign_rhs1 (s1) != gimple_assign_rhs1 (s2))\n-    return false;\n-\n-  return true;\n-}\n-\n-\n-/* Compare the PENDING_STMT list for edges E1 and E2. Return true if the lists\n-   contain the same sequence of copies.  */\n-\n-static inline bool \n-identical_stmt_lists_p (const_edge e1, const_edge e2)\n-{\n-  gimple_seq t1 = PENDING_STMT (e1);\n-  gimple_seq t2 = PENDING_STMT (e2);\n-  gimple_stmt_iterator gsi1, gsi2;\n-\n-  for (gsi1 = gsi_start (t1), gsi2 = gsi_start (t2);\n-       !gsi_end_p (gsi1) && !gsi_end_p (gsi2); \n-       gsi_next (&gsi1), gsi_next (&gsi2))\n-    {\n-      if (!identical_copies_p (gsi_stmt (gsi1), gsi_stmt (gsi2)))\n-        break;\n-    }\n-\n-  if (!gsi_end_p (gsi1) || !gsi_end_p (gsi2))\n-    return false;\n-\n-  return true;\n-}\n-\n-\n-/* Allocate data structures used in analyze_edges_for_bb.   */\n-\n-static void\n-init_analyze_edges_for_bb (void)\n-{\n-  edge_leader = VEC_alloc (edge, heap, 25);\n-  stmt_list = VEC_alloc (gimple_seq, heap, 25);\n-  leader_has_match = BITMAP_ALLOC (NULL);\n-}\n-\n-\n-/* Free data structures used in analyze_edges_for_bb.   */\n-\n-static void\n-fini_analyze_edges_for_bb (void)\n-{\n-  VEC_free (edge, heap, edge_leader);\n-  VEC_free (gimple_seq, heap, stmt_list);\n-  BITMAP_FREE (leader_has_match);\n-}\n-\n-/* A helper function to be called via walk_tree.  Return DATA if it is\n-  contained in subtree TP.  */\n- \n-static tree\n-contains_tree_r (tree * tp, int *walk_subtrees, void *data)\n-{\n-  if (*tp == data)\n-    {\n-      *walk_subtrees = 0;\n-      return (tree) data;\n-    }\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* A threshold for the number of insns contained in the latch block.\n-   It is used to prevent blowing the loop with too many copies from\n-   the latch.  */\n-#define MAX_STMTS_IN_LATCH 2\n-\n-/* Return TRUE if the stmts on SINGLE-EDGE can be moved to the\n-   body of the loop.  This should be permitted only if SINGLE-EDGE is a\n-   single-basic-block latch edge and thus cleaning the latch will help\n-   to create a single-basic-block loop.  Otherwise return FALSE.  */\n-\n-static bool\n-process_single_block_loop_latch (edge single_edge)\n-{\n-  gimple_seq stmts;\n-  basic_block b_exit, b_pheader, b_loop = single_edge->src;\n-  edge_iterator ei;\n-  edge e;\n-  gimple_stmt_iterator gsi, gsi_exit;\n-  gimple_stmt_iterator tsi;\n-  tree expr;\n-  gimple stmt;\n-  unsigned int count = 0;\n-\n-  if (single_edge == NULL || (single_edge->dest != single_edge->src)\n-      || (EDGE_COUNT (b_loop->succs) != 2)\n-      || (EDGE_COUNT (b_loop->preds) != 2))\n-    return false;\n-\n-  /* Get the stmts on the latch edge.  */\n-  stmts = PENDING_STMT (single_edge);\n-\n-  /* Find the successor edge which is not the latch edge.  */\n-  FOR_EACH_EDGE (e, ei, b_loop->succs) \n-   if (e->dest != b_loop)\n-    break;\n-\n-  b_exit = e->dest;\n-\n-  /* Check that the exit block has only the loop as a predecessor,\n-     and that there are no pending stmts on that edge as well.   */\n-  if (EDGE_COUNT (b_exit->preds) != 1 || PENDING_STMT (e))\n-    return false;\n-\n-  /* Find the predecessor edge which is not the latch edge.  */\n-  FOR_EACH_EDGE (e, ei, b_loop->preds) \n-   if (e->src != b_loop)\n-    break;\n-\n-  b_pheader = e->src;\n-\n-  if (b_exit == b_pheader || b_exit == b_loop || b_pheader == b_loop)\n-    return false;\n-\n-  gsi_exit = gsi_after_labels (b_exit);\n-\n-  /* Get the last stmt in the loop body.  */\n-  gsi = gsi_last_bb (single_edge->src);\n-  stmt = gsi_stmt (gsi);\n-\n-  if (gimple_code (stmt) != GIMPLE_COND)\n-    return false;\n-\n-\n-  expr = build2 (gimple_cond_code (stmt), boolean_type_node,\n-                 gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n-  /* Iterate over the insns on the latch and count them.  */\n-  for (tsi = gsi_start (stmts); !gsi_end_p (tsi); gsi_next (&tsi))\n-    {\n-      gimple stmt1 = gsi_stmt (tsi);\n-      tree var;\n-\n-      count++;\n-      /* Check that the condition does not contain any new definition\n-         created in the latch as the stmts from the latch intended\n-         to precede it.  */\n-      if (gimple_code (stmt1) != GIMPLE_ASSIGN)\n-        return false;\n-      var = gimple_assign_lhs (stmt1);\n-      if (TREE_THIS_VOLATILE (var)\n-\t  || TYPE_VOLATILE (TREE_TYPE (var))\n-\t  || walk_tree (&expr, contains_tree_r, var, NULL))\n-\treturn false;\n-    }\n-  /* Check that the latch does not contain more than MAX_STMTS_IN_LATCH\n-     insns.  The purpose of this restriction is to prevent blowing the\n-     loop with too many copies from the latch.  */\n-  if (count > MAX_STMTS_IN_LATCH)\n-    return false;\n-\n-  /* Apply the transformation - clean up the latch block:  \n-\n-     var = something; \n-     L1:\n-     x1 = expr;\n-     if (cond) goto L2 else goto L3;\n-     L2:\n-     var = x1;\n-     goto L1\n-     L3:\n-     ...\n-\n-     ==>\n-\n-     var = something;\n-     L1:\n-     x1 = expr;\n-     tmp_var = var;\n-     var = x1;\n-     if (cond) goto L1 else goto L2;\n-     L2:\n-     var = tmp_var;\n-     ... \n-   */\n-  for (tsi = gsi_start (stmts); !gsi_end_p (tsi); gsi_next (&tsi))\n-    {\n-      gimple stmt1 = gsi_stmt (tsi);\n-      tree var, tmp_var;\n-      gimple copy;\n-\n-      /* Create a new variable to load back the value of var in case\n-         we exit the loop.  */\n-      var = gimple_assign_lhs (stmt1);\n-      tmp_var = create_temp (var);\n-      copy = gimple_build_assign (tmp_var, var);\n-      set_is_used (tmp_var);\n-      gsi_insert_before (&gsi, copy, GSI_SAME_STMT);\n-      copy = gimple_build_assign (var, tmp_var);\n-      gsi_insert_before (&gsi_exit, copy, GSI_SAME_STMT);\n-    }\n-\n-  PENDING_STMT (single_edge) = 0;\n-  /* Insert the new stmts to the loop body.  */\n-  gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n-\n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\nCleaned-up latch block of loop with single BB: %d\\n\\n\",\n-\t     single_edge->dest->index);\n-\n-  return true;\n-}\n-\n-/* Look at all the incoming edges to block BB, and decide where the best place\n-   to insert the stmts on each edge are, and perform those insertions.  */\n-\n-static void\n-analyze_edges_for_bb (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  int count;\n-  unsigned int x;\n-  bool have_opportunity;\n-  gimple_stmt_iterator gsi;\n-  gimple stmt;\n-  edge single_edge = NULL;\n-  bool is_label;\n-  edge leader;\n-\n-  count = 0;\n-\n-  /* Blocks which contain at least one abnormal edge cannot use \n-     make_forwarder_block.  Look for these blocks, and commit any PENDING_STMTs\n-     found on edges in these block.  */\n-  have_opportunity = true;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_ABNORMAL)\n-      {\n-        have_opportunity = false;\n-\tbreak;\n-      }\n-\n-  if (!have_opportunity)\n-    {\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (PENDING_STMT (e))\n-\t  gsi_commit_one_edge_insert (e, NULL);\n-      return;\n-    }\n-\n-  /* Find out how many edges there are with interesting pending stmts on them.  \n-     Commit the stmts on edges we are not interested in.  */\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      if (PENDING_STMT (e))\n-        {\n-\t  gcc_assert (!(e->flags & EDGE_ABNORMAL));\n-\t  if (e->flags & EDGE_FALLTHRU)\n-\t    {\n-\t      gsi = gsi_start_bb (e->src);\n-\t      if (!gsi_end_p (gsi))\n-\t        {\n-\t\t  stmt = gsi_stmt (gsi);\n-\t\t  gsi_next (&gsi);\n-\t\t  gcc_assert (stmt != NULL);\n-\t\t  is_label = (gimple_code (stmt) == GIMPLE_LABEL);\n-\t\t  /* Punt if it has non-label stmts, or isn't local.  */\n-\t\t  if (!is_label\n-\t\t      || DECL_NONLOCAL (gimple_label_label (stmt)) \n-\t\t      || !gsi_end_p (gsi))\n-\t\t    {\n-\t\t      gsi_commit_one_edge_insert (e, NULL);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  single_edge = e;\n-\t  count++;\n-\t}\n-    }\n-\n-  /* If there aren't at least 2 edges, no sharing will happen.  */\n-  if (count < 2)\n-    {\n-      if (single_edge)\n-      {\n-       /* Add stmts to the edge unless processed specially as a\n-          single-block loop latch edge. */\n-       if (!process_single_block_loop_latch (single_edge))\n-         gsi_commit_one_edge_insert (single_edge, NULL);\n-      }\n-      return;\n-    }\n-\n-  /* Ensure that we have empty worklists.  */\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (VEC_length (edge, edge_leader) == 0);\n-  gcc_assert (VEC_length (gimple_seq, stmt_list) == 0);\n-  gcc_assert (bitmap_empty_p (leader_has_match));\n-#endif\n-\n-  /* Find the \"leader\" block for each set of unique stmt lists.  Preference is\n-     given to FALLTHRU blocks since they would need a GOTO to arrive at another\n-     block.  The leader edge destination is the block which all the other edges\n-     with the same stmt list will be redirected to.  */\n-  have_opportunity = false;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      if (PENDING_STMT (e))\n-\t{\n-\t  bool found = false;\n-\n-\t  /* Look for the same stmt list in edge leaders list.  */\n-\t  for (x = 0; VEC_iterate (edge, edge_leader, x, leader); x++)\n-\t    {\n-\t      if (identical_stmt_lists_p (leader, e))\n-\t\t{\n-\t\t  /* Give this edge the same stmt list pointer.  */\n-\t\t  PENDING_STMT (e) = NULL;\n-\t\t  e->aux = leader;\n-\t\t  bitmap_set_bit (leader_has_match, x);\n-\t\t  have_opportunity = found = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  /* If no similar stmt list, add this edge to the leader list.  */\n-\t  if (!found)\n-\t    {\n-\t      VEC_safe_push (edge, heap, edge_leader, e);\n-\t      VEC_safe_push (gimple_seq, heap, stmt_list, PENDING_STMT (e));\n-\t    }\n-\t}\n-     }\n-\n-  /* If there are no similar lists, just issue the stmts.  */\n-  if (!have_opportunity)\n-    {\n-      for (x = 0; VEC_iterate (edge, edge_leader, x, leader); x++)\n-\tgsi_commit_one_edge_insert (leader, NULL);\n-      VEC_truncate (edge, edge_leader, 0);\n-      VEC_truncate (gimple_seq, stmt_list, 0);\n-      bitmap_clear (leader_has_match);\n-      return;\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\nOpportunities in BB %d for stmt/block reduction:\\n\",\n-\t     bb->index);\n-  \n-  /* For each common list, create a forwarding block and issue the stmt's\n-     in that block.  */\n-  for (x = 0; VEC_iterate (edge, edge_leader, x, leader); x++)\n-    if (bitmap_bit_p (leader_has_match, x))\n-      {\n-\tedge new_edge;\n-\tgimple_stmt_iterator gsi;\n-\tgimple_seq curr_stmt_list;\n-\n-\tleader_match = leader;\n-\n-\t/* The tree_* cfg manipulation routines use the PENDING_EDGE field\n-\t   for various PHI manipulations, so it gets cleared when calls are \n-\t   made to make_forwarder_block(). So make sure the edge is clear, \n-\t   and use the saved stmt list.  */\n-\tPENDING_STMT (leader) = NULL;\n-\tleader->aux = leader;\n-\tcurr_stmt_list = VEC_index (gimple_seq, stmt_list, x);\n-\n-        new_edge = make_forwarder_block (leader->dest, same_stmt_list_p, \n-\t\t\t\t\t NULL);\n-\tbb = new_edge->dest;\n-\tif (dump_file)\n-\t  {\n-\t    fprintf (dump_file, \"Splitting BB %d for Common stmt list.  \", \n-\t\t     leader->dest->index);\n-\t    fprintf (dump_file, \"Original block is now BB%d.\\n\", bb->index);\n-\t    print_gimple_seq (dump_file, curr_stmt_list, 0, TDF_VOPS);\n-\t  }\n-\n-\tFOR_EACH_EDGE (e, ei, new_edge->src->preds)\n-\t  {\n-\t    e->aux = NULL;\n-\t    if (dump_file)\n-\t      fprintf (dump_file, \"  Edge (%d->%d) lands here.\\n\", \n-\t\t       e->src->index, e->dest->index);\n-\t  }\n-\n-\tgsi = gsi_last_bb (leader->dest);\n-\tgsi_insert_seq_after (&gsi, curr_stmt_list, GSI_NEW_STMT);\n-\n-\tleader_match = NULL;\n-\t/* We should never get a new block now.  */\n-      }\n-    else\n-      {\n-\tPENDING_STMT (leader) = VEC_index (gimple_seq, stmt_list, x);\n-\tgsi_commit_one_edge_insert (leader, NULL);\n-      }\n-\n-   \n-  /* Clear the working data structures.  */\n-  VEC_truncate (edge, edge_leader, 0);\n-  VEC_truncate (gimple_seq, stmt_list, 0);\n-  bitmap_clear (leader_has_match);\n-}\n-\n-\n-/* This function will analyze the insertions which were performed on edges,\n-   and decide whether they should be left on that edge, or whether it is more\n-   efficient to emit some subset of them in a single block.  All stmts are\n-   inserted somewhere.  */\n-\n-static void\n-perform_edge_inserts (void)\n+void\n+expand_phi_nodes (struct ssaexpand *sa)\n {\n   basic_block bb;\n+  elim_graph g = new_elim_graph (sa->map->num_partitions);\n+  g->map = sa->map;\n \n-  if (dump_file)\n-    fprintf(dump_file, \"Analyzing Edge Insertions.\\n\");\n-\n-  /* analyze_edges_for_bb calls make_forwarder_block, which tries to\n-     incrementally update the dominator information.  Since we don't\n-     need dominator information after this pass, go ahead and free the\n-     dominator information.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n-\n-  /* Allocate data structures used in analyze_edges_for_bb.   */\n-  init_analyze_edges_for_bb ();\n-\n-  FOR_EACH_BB (bb)\n-    analyze_edges_for_bb (bb);\n-\n-  analyze_edges_for_bb (EXIT_BLOCK_PTR);\n-\n-  /* Free data structures used in analyze_edges_for_bb.   */\n-  fini_analyze_edges_for_bb ();\n-\n-#ifdef ENABLE_CHECKING\n-  {\n-    edge_iterator ei;\n-    edge e;\n-    FOR_EACH_BB (bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR, next_bb)\n+    if (!gimple_seq_empty_p (phi_nodes (bb)))\n       {\n+\tedge e;\n+\tedge_iterator ei;\n \tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  eliminate_phi (e, g);\n+\tset_phi_nodes (bb, NULL);\n+\t/* We can't redirect EH edges in RTL land, so we need to do this\n+\t   here.  Redirection happens only when splitting is necessary,\n+\t   which it is only for critical edges, normally.  For EH edges\n+\t   it might also be necessary when the successor has more than\n+\t   one predecessor.  In that case the edge is either required to\n+\t   be fallthru (which EH edges aren't), or the predecessor needs\n+\t   to end with a jump (which again, isn't the case with EH edges).\n+\t   Hence, split all EH edges on which we inserted instructions\n+\t   and whose successor has multiple predecessors.  */\n+\tfor (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n \t  {\n-\t    if (PENDING_STMT (e))\n-\t      error (\" Pending stmts not issued on PRED edge (%d, %d)\\n\", \n-\t\t     e->src->index, e->dest->index);\n+\t    if (e->insns.r && (e->flags & EDGE_EH)\n+\t\t&& !single_pred_p (e->dest))\n+\t      {\n+\t\trtx insns = e->insns.r;\n+\t\tbasic_block bb;\n+\t\te->insns.r = NULL_RTX;\n+\t\tbb = split_edge (e);\n+\t\tsingle_pred_edge (bb)->insns.r = insns;\n+\t      }\n+\t    else\n+\t      ei_next (&ei);\n \t  }\n-\tFOR_EACH_EDGE (e, ei, bb->succs)\n-\t  {\n-\t    if (PENDING_STMT (e))\n-\t      error (\" Pending stmts not issued on SUCC edge (%d, %d)\\n\", \n-\t\t     e->src->index, e->dest->index);\n-\t  }\n-      }\n-    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-      {\n-\tif (PENDING_STMT (e))\n-\t  error (\" Pending stmts not issued on ENTRY edge (%d, %d)\\n\", \n-\t\t e->src->index, e->dest->index);\n-      }\n-    FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-      {\n-\tif (PENDING_STMT (e))\n-\t  error (\" Pending stmts not issued on EXIT edge (%d, %d)\\n\", \n-\t\t e->src->index, e->dest->index);\n       }\n-  }\n-#endif\n+\n+  delete_elim_graph (g);\n }\n \n \n@@ -1339,12 +789,11 @@ perform_edge_inserts (void)\n    should also be used.  */\n \n static void\n-remove_ssa_form (bool perform_ter)\n+remove_ssa_form (bool perform_ter, struct ssaexpand *sa)\n {\n-  basic_block bb;\n   gimple *values = NULL;\n   var_map map;\n-  gimple_stmt_iterator gsi;\n+  unsigned i;\n \n   map = coalesce_ssa_name ();\n \n@@ -1365,29 +814,21 @@ remove_ssa_form (bool perform_ter)\n \tdump_replaceable_exprs (dump_file, values);\n     }\n \n-  /* Assign real variables to the partitions now.  */\n-  assign_vars (map);\n+  rewrite_trees (map);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  sa->map = map;\n+  sa->values = values;\n+  sa->partition_has_default_def = BITMAP_ALLOC (NULL);\n+  for (i = 1; i < num_ssa_names; i++)\n     {\n-      fprintf (dump_file, \"After Base variable replacement:\\n\");\n-      dump_var_map (dump_file, map);\n+      tree t = ssa_name (i);\n+      if (t && SSA_NAME_IS_DEFAULT_DEF (t))\n+\t{\n+\t  int p = var_to_partition (map, t);\n+\t  if (p != NO_PARTITION)\n+\t    bitmap_set_bit (sa->partition_has_default_def, p);\n+\t}\n     }\n-\n-  rewrite_trees (map, values);\n-\n-  if (values)\n-    free (values);\n-\n-  /* Remove PHI nodes which have been translated back to real variables.  */\n-  FOR_EACH_BB (bb)\n-    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);)\n-      remove_phi_node (&gsi, true);\n-\n-  /* If any copies were inserted on edges, analyze and insert them now.  */\n-  perform_edge_inserts ();\n-\n-  delete_var_map (map);\n }\n \n \n@@ -1477,12 +918,26 @@ insert_backedge_copies (void)\n     }\n }\n \n+/* Free all memory associated with going out of SSA form.  SA is\n+   the outof-SSA info object.  */\n+\n+void\n+finish_out_of_ssa (struct ssaexpand *sa)\n+{\n+  free (sa->partition_to_pseudo);\n+  if (sa->values)\n+    free (sa->values);\n+  delete_var_map (sa->map);\n+  BITMAP_FREE (sa->partition_has_default_def);\n+  memset (sa, 0, sizeof *sa);\n+}\n+\n /* Take the current function out of SSA form, translating PHIs as described in\n    R. Morgan, ``Building an Optimizing Compiler'',\n    Butterworth-Heinemann, Boston, MA, 1998. pp 176-186.  */\n \n-static unsigned int\n-rewrite_out_of_ssa (void)\n+unsigned int\n+rewrite_out_of_ssa (struct ssaexpand *sa)\n {\n   /* If elimination of a PHI requires inserting a copy on a backedge,\n      then we will have to split the backedge which has numerous\n@@ -1499,37 +954,10 @@ rewrite_out_of_ssa (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     gimple_dump_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  remove_ssa_form (flag_tree_ter && !flag_mudflap);\n+  remove_ssa_form (flag_tree_ter, sa);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     gimple_dump_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  cfun->gimple_df->in_ssa_p = false;\n   return 0;\n }\n-\n-\n-/* Define the parameters of the out of SSA pass.  */\n-\n-struct gimple_opt_pass pass_del_ssa = \n-{\n- {\n-  GIMPLE_PASS,\n-  \"optimized\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  rewrite_out_of_ssa,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_SSA_TO_NORMAL,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  /* ??? If TER is enabled, we also kill gimple.  */\n-  PROP_ssa,\t\t\t\t/* properties_destroyed */\n-  TODO_verify_ssa | TODO_verify_flow\n-    | TODO_verify_stmts,\t\t/* todo_flags_start */\n-  TODO_dump_func\n-  | TODO_ggc_collect\n-  | TODO_remove_unused_locals\t\t/* todo_flags_finish */\n- }\n-};"}, {"sha": "ab18bcad4b1185b234ca1107e2a9d174d3608ed1", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -314,7 +314,7 @@ compare_pairs (const void *p1, const void *p2)\n   const_coalesce_pair_p const *const pp2 = (const_coalesce_pair_p const *) p2;\n   int result;\n \n-  result = (* pp2)->cost - (* pp1)->cost;\n+  result = (* pp1)->cost - (* pp2)->cost;\n   /* Since qsort does not guarantee stability we use the elements\n      as a secondary key.  This provides us with independence from\n      the host's implementation of the sorting algorithm.  */\n@@ -1126,8 +1126,8 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n   first = NULL_TREE;\n   for (i = 1; i < num_ssa_names; i++)\n     {\n-      var = map->partition_to_var[i];\n-      if (var != NULL_TREE)\n+      var = ssa_name (i);\n+      if (var != NULL_TREE && is_gimple_reg (var))\n         {\n \t  /* Add coalesces between all the result decls.  */\n \t  if (TREE_CODE (SSA_NAME_VAR (var)) == RESULT_DECL)\n@@ -1148,7 +1148,8 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t  /* Mark any default_def variables as being in the coalesce list\n \t     since they will have to be coalesced with the base variable.  If\n \t     not marked as present, they won't be in the coalesce view. */\n-\t  if (gimple_default_def (cfun, SSA_NAME_VAR (var)) == var)\n+\t  if (gimple_default_def (cfun, SSA_NAME_VAR (var)) == var\n+\t      && !has_zero_uses (var))\n \t    bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (var));\n \t}\n     }\n@@ -1329,7 +1330,6 @@ eq_ssa_name_by_var (const void *p1, const void *p2)\n extern var_map\n coalesce_ssa_name (void)\n {\n-  unsigned num, x;\n   tree_live_info_p liveinfo;\n   ssa_conflicts_p graph;\n   coalesce_list_p cl;\n@@ -1406,31 +1406,6 @@ coalesce_ssa_name (void)\n   /* First, coalesce all live on entry variables to their base variable. \n      This will ensure the first use is coming from the correct location.  */\n \n-  num = num_var_partitions (map);\n-  for (x = 0 ; x < num; x++)\n-    {\n-      tree var = partition_to_var (map, x);\n-      tree root;\n-\n-      if (TREE_CODE (var) != SSA_NAME)\n-\tcontinue;\n-\n-      root = SSA_NAME_VAR (var);\n-      if (gimple_default_def (cfun, root) == var)\n-        {\n-\t  /* This root variable should have not already been assigned\n-\t     to another partition which is not coalesced with this one.  */\n-\t  gcc_assert (!var_ann (root)->out_of_ssa_tag);\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      print_exprs (dump_file, \"Must coalesce \", var,\n-\t\t\t   \" with the root variable \", root, \".\\n\");\n-\t    }\n-\t  change_partition_var (map, root, x);\n-\t}\n-    }\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);\n "}, {"sha": "0ac02bab04cc369626a3e00a7a15c5f9f978df50", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -344,7 +344,7 @@ rename_ssa_copies (void)\n       part_var = partition_to_var (map, x);\n       if (!part_var)\n         continue;\n-      var = map->partition_to_var[x];\n+      var = ssa_name (x);\n       if (debug)\n         {\n \t  if (SSA_NAME_VAR (var) != SSA_NAME_VAR (part_var))"}, {"sha": "0673fab851f268b06c3f33dcad79be285bd43325", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 9, "deletions": 66, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -136,9 +136,6 @@ init_var_map (int size)\n \n   map = (var_map) xmalloc (sizeof (struct _var_map));\n   map->var_partition = partition_new (size);\n-  map->partition_to_var \n-\t      = (tree *)xmalloc (size * sizeof (tree));\n-  memset (map->partition_to_var, 0, size * sizeof (tree));\n \n   map->partition_to_view = NULL;\n   map->view_to_partition = NULL;\n@@ -157,7 +154,6 @@ void\n delete_var_map (var_map map)\n {\n   var_map_base_fini (map);\n-  free (map->partition_to_var);\n   partition_delete (map->var_partition);\n   if (map->partition_to_view)\n     free (map->partition_to_view);\n@@ -175,41 +171,16 @@ int\n var_union (var_map map, tree var1, tree var2)\n {\n   int p1, p2, p3;\n-  tree root_var = NULL_TREE;\n-  tree other_var = NULL_TREE;\n+\n+  gcc_assert (TREE_CODE (var1) == SSA_NAME);\n+  gcc_assert (TREE_CODE (var2) == SSA_NAME);\n \n   /* This is independent of partition_to_view. If partition_to_view is \n      on, then whichever one of these partitions is absorbed will never have a\n      dereference into the partition_to_view array any more.  */\n \n-  if (TREE_CODE (var1) == SSA_NAME)\n-    p1 = partition_find (map->var_partition, SSA_NAME_VERSION (var1));\n-  else\n-    {\n-      p1 = var_to_partition (map, var1);\n-      if (map->view_to_partition)\n-        p1 = map->view_to_partition[p1];\n-      root_var = var1;\n-    }\n-  \n-  if (TREE_CODE (var2) == SSA_NAME)\n-    p2 = partition_find (map->var_partition, SSA_NAME_VERSION (var2));\n-  else\n-    {\n-      p2 = var_to_partition (map, var2);\n-      if (map->view_to_partition)\n-        p2 = map->view_to_partition[p2];\n-\n-      /* If there is no root_var set, or it's not a user variable, set the\n-\t root_var to this one.  */\n-      if (!root_var || (DECL_P (root_var) && DECL_IGNORED_P (root_var)))\n-        {\n-\t  other_var = root_var;\n-\t  root_var = var2;\n-\t}\n-      else \n-\tother_var = var2;\n-    }\n+  p1 = partition_find (map->var_partition, SSA_NAME_VERSION (var1));\n+  p2 = partition_find (map->var_partition, SSA_NAME_VERSION (var2));\n \n   gcc_assert (p1 != NO_PARTITION);\n   gcc_assert (p2 != NO_PARTITION);\n@@ -222,11 +193,6 @@ var_union (var_map map, tree var1, tree var2)\n   if (map->partition_to_view)\n     p3 = map->partition_to_view[p3];\n \n-  if (root_var)\n-    change_partition_var (map, root_var, p3);\n-  if (other_var)\n-    change_partition_var (map, other_var, p3);\n-\n   return p3;\n }\n \n@@ -278,7 +244,9 @@ partition_view_init (var_map map)\n   for (x = 0; x < map->partition_size; x++)\n     {\n       tmp = partition_find (map->var_partition, x);\n-      if (map->partition_to_var[tmp] != NULL_TREE && !bitmap_bit_p (used, tmp))\n+      if (ssa_name (tmp) != NULL_TREE && is_gimple_reg (ssa_name (tmp))\n+\t  && (!has_zero_uses (ssa_name (tmp))\n+\t      || !SSA_NAME_IS_DEFAULT_DEF (ssa_name (tmp))))\n \tbitmap_set_bit (used, tmp);\n     }\n \n@@ -297,7 +265,6 @@ partition_view_fini (var_map map, bitmap selected)\n {\n   bitmap_iterator bi;\n   unsigned count, i, x, limit;\n-  tree var;\n \n   gcc_assert (selected);\n \n@@ -317,11 +284,6 @@ partition_view_fini (var_map map, bitmap selected)\n \t{\n \t  map->partition_to_view[x] = i;\n \t  map->view_to_partition[i] = x;\n-\t  var = map->partition_to_var[x];\n-\t  /* If any one of the members of a partition is not an SSA_NAME, make\n-\t     sure it is the representative.  */\n-\t  if (TREE_CODE (var) != SSA_NAME)\n-\t    change_partition_var (map, var, i);\n \t  i++;\n \t}\n       gcc_assert (i == count);\n@@ -379,25 +341,6 @@ partition_view_bitmap (var_map map, bitmap only, bool want_bases)\n }\n \n \n-/* This function is used to change the representative variable in MAP for VAR's \n-   partition to a regular non-ssa variable.  This allows partitions to be \n-   mapped back to real variables.  */\n-  \n-void \n-change_partition_var (var_map map, tree var, int part)\n-{\n-  var_ann_t ann;\n-\n-  gcc_assert (TREE_CODE (var) != SSA_NAME);\n-\n-  ann = var_ann (var);\n-  ann->out_of_ssa_tag = 1;\n-  VAR_ANN_PARTITION (ann) = part;\n-  if (map->view_to_partition)\n-    map->partition_to_var[map->view_to_partition[part]] = var;\n-}\n-\n-\n static inline void mark_all_vars_used (tree *, void *data);\n \n /* Helper function for mark_all_vars_used, called via walk_tree.  */\n@@ -1105,7 +1048,7 @@ dump_var_map (FILE *f, var_map map)\n       else\n \tp = x;\n \n-      if (map->partition_to_var[p] == NULL_TREE)\n+      if (ssa_name (p) == NULL_TREE)\n         continue;\n \n       t = 0;"}, {"sha": "8cab755d9b8794730c423aa0caebf71ec0eb508c", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -60,9 +60,6 @@ typedef struct _var_map\n   int *partition_to_view;\n   int *view_to_partition;\n \n-  /* Mapping of partition numbers to variables.  */\n-  tree *partition_to_var;\n-\n   /* Current number of partitions in var_map based on the current view.  */\n   unsigned int num_partitions;\n \n@@ -80,8 +77,6 @@ typedef struct _var_map\n } *var_map;\n \n \n-/* Partition number of a  non ssa-name variable.  */\n-#define VAR_ANN_PARTITION(ann) (ann->partition)\n /* Index to the basevar table of a non ssa-name variable.  */\n #define VAR_ANN_BASE_INDEX(ann) (ann->base_index)\n \n@@ -93,7 +88,6 @@ extern var_map init_var_map (int);\n extern void delete_var_map (var_map);\n extern void dump_var_map (FILE *, var_map);\n extern int var_union (var_map, tree, tree);\n-extern void change_partition_var (var_map, tree, int);\n extern void partition_view_normal (var_map, bool);\n extern void partition_view_bitmap (var_map, bitmap, bool);\n #ifdef ENABLE_CHECKING\n@@ -116,10 +110,12 @@ num_var_partitions (var_map map)\n static inline tree\n partition_to_var (var_map map, int i)\n {\n+  tree name;\n   if (map->view_to_partition)\n     i = map->view_to_partition[i];\n   i = partition_find (map->var_partition, i);\n-  return map->partition_to_var[i];\n+  name = ssa_name (i);\n+  return name;\n }\n \n \n@@ -146,23 +142,12 @@ version_to_var (var_map map, int version)\n static inline int\n var_to_partition (var_map map, tree var)\n {\n-  var_ann_t ann;\n   int part;\n \n-  if (TREE_CODE (var) == SSA_NAME)\n-    {\n-      part = partition_find (map->var_partition, SSA_NAME_VERSION (var));\n-      if (map->partition_to_view)\n-\tpart = map->partition_to_view[part];\n-    }\n-  else\n-    {\n-      ann = var_ann (var);\n-      if (ann && ann->out_of_ssa_tag)\n-\tpart = VAR_ANN_PARTITION (ann);\n-      else\n-        part = NO_PARTITION;\n-    }\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+  part = partition_find (map->var_partition, SSA_NAME_VERSION (var));\n+  if (map->partition_to_view)\n+    part = map->partition_to_view[part];\n   return part;\n }\n \n@@ -207,17 +192,11 @@ num_basevars (var_map map)\n    partitions may be filtered out by a view later.  */ \n \n static inline void\n-register_ssa_partition (var_map map, tree ssa_var)\n+register_ssa_partition (var_map map ATTRIBUTE_UNUSED, tree ssa_var)\n {\n-  int version;\n-\n #if defined ENABLE_CHECKING\n   register_ssa_partition_check (ssa_var);\n #endif\n-\n-  version = SSA_NAME_VERSION (ssa_var);\n-  if (map->partition_to_var[version] == NULL_TREE)\n-    map->partition_to_var[version] = ssa_var;\n }\n \n "}, {"sha": "ddf52022b54828935710ed2633ba8bd10194e608", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e3825dba91bb719284b07b90aefc273705399f2/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=4e3825dba91bb719284b07b90aefc273705399f2", "patch": "@@ -844,7 +844,8 @@ delete_tree_ssa (void)\n \n \t  gimple_set_modified (stmt, true);\n \t}\n-      set_phi_nodes (bb, NULL);\n+      if (!(bb->flags & BB_RTL))\n+\tset_phi_nodes (bb, NULL);\n     }\n \n   /* Remove annotations from every referenced local variable.  */"}]}