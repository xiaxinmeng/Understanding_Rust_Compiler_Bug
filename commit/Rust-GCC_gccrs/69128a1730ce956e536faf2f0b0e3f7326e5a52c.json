{"sha": "69128a1730ce956e536faf2f0b0e3f7326e5a52c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkxMjhhMTczMGNlOTU2ZTUzNmZhZjJmMGIwZTNmNzMyNmU1YTUyYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-04-06T22:30:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-04-06T22:30:05Z"}, "message": "re PR middle-end/85196 (ICE in extract_insn, at recog.c:2311: unrecognizable insn)\n\n\tPR target/85196\n\t* config/sparc/sparc.c (sparc_expand_move): Deal with symbolic operands\n\tbased on LABEL_REF.  Remove useless assertion.\n\t(pic_address_needs_scratch): Fix formatting.\n\t(sparc_legitimize_pic_address): Minor tweaks.\n\t(sparc_delegitimize_address): Adjust assertion accordingly.\n\t* config/sparc/sparc.md (movsi_pic_label_ref): Change label_ref_operand\n\tinto symbolic_operand.\n\t(movsi_high_pic_label_ref): Likewise.\n\t(movsi_lo_sum_pic_label_ref): Likewise.\n\t(movdi_pic_label_ref): Likewise.\n\t(movdi_high_pic_label_ref): Likewise.\n\t(movdi_lo_sum_pic_label_ref): Likewise.\n\nFrom-SVN: r259194", "tree": {"sha": "2a197d72f1c10b72cf68e89772fd4694ca795363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a197d72f1c10b72cf68e89772fd4694ca795363"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69128a1730ce956e536faf2f0b0e3f7326e5a52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69128a1730ce956e536faf2f0b0e3f7326e5a52c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69128a1730ce956e536faf2f0b0e3f7326e5a52c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69128a1730ce956e536faf2f0b0e3f7326e5a52c/comments", "author": null, "committer": null, "parents": [{"sha": "5f690e68cb2f92414a77336f9992649f17a86ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f690e68cb2f92414a77336f9992649f17a86ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f690e68cb2f92414a77336f9992649f17a86ee0"}], "stats": {"total": 157, "additions": 137, "deletions": 20}, "files": [{"sha": "f5273744037695d0097183e2258a42cd0979b1e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69128a1730ce956e536faf2f0b0e3f7326e5a52c", "patch": "@@ -1,3 +1,19 @@\n+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/85196\n+\t* config/sparc/sparc.c (sparc_expand_move): Deal with symbolic operands\n+\tbased on LABEL_REF.  Remove useless assertion.\n+\t(pic_address_needs_scratch): Fix formatting.\n+\t(sparc_legitimize_pic_address): Minor tweaks.\n+\t(sparc_delegitimize_address): Adjust assertion accordingly.\n+\t* config/sparc/sparc.md (movsi_pic_label_ref): Change label_ref_operand\n+\tinto symbolic_operand.\n+\t(movsi_high_pic_label_ref): Likewise.\n+\t(movsi_lo_sum_pic_label_ref): Likewise.\n+\t(movdi_pic_label_ref): Likewise.\n+\t(movdi_high_pic_label_ref): Likewise.\n+\t(movdi_lo_sum_pic_label_ref): Likewise.\n+\n 2018-04-06  Amaan Cheval  <amaan.cheval@gmail.com>\n \n \t* config.gcc (x86_64-*-rtems*): Add rtems.h to tm_file for"}, {"sha": "4026d4933d8df3c40c001ff0c39e700ab03dd7a2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=69128a1730ce956e536faf2f0b0e3f7326e5a52c", "patch": "@@ -2236,7 +2236,7 @@ sparc_expand_move (machine_mode mode, rtx *operands)\n \t}\n     }\n \n-  /* Fixup TLS cases.  */\n+  /* Fix up TLS cases.  */\n   if (TARGET_HAVE_TLS\n       && CONSTANT_P (operands[1])\n       && sparc_tls_referenced_p (operands [1]))\n@@ -2245,15 +2245,20 @@ sparc_expand_move (machine_mode mode, rtx *operands)\n       return false;\n     }\n \n-  /* Fixup PIC cases.  */\n+  /* Fix up PIC cases.  */\n   if (flag_pic && CONSTANT_P (operands[1]))\n     {\n       if (pic_address_needs_scratch (operands[1]))\n \toperands[1] = sparc_legitimize_pic_address (operands[1], NULL_RTX);\n \n       /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */\n-      if (GET_CODE (operands[1]) == LABEL_REF\n-\t  && can_use_mov_pic_label_ref (operands[1]))\n+      if ((GET_CODE (operands[1]) == LABEL_REF\n+\t   && can_use_mov_pic_label_ref (operands[1]))\n+\t  || (GET_CODE (operands[1]) == CONST\n+\t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n+\t      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT\n+\t      && can_use_mov_pic_label_ref (XEXP (XEXP (operands[1], 0), 0))))\n \t{\n \t  if (mode == SImode)\n \t    {\n@@ -2263,7 +2268,6 @@ sparc_expand_move (machine_mode mode, rtx *operands)\n \n \t  if (mode == DImode)\n \t    {\n-\t      gcc_assert (TARGET_ARCH64);\n \t      emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));\n \t      return true;\n \t    }\n@@ -4280,10 +4284,11 @@ int\n pic_address_needs_scratch (rtx x)\n {\n   /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n-  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n+  if (GET_CODE (x) == CONST\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))\n+      && !SMALL_INT (XEXP (XEXP (x, 0), 1)))\n     return 1;\n \n   return 0;\n@@ -4750,16 +4755,15 @@ sparc_legitimize_tls_address (rtx addr)\n static rtx\n sparc_legitimize_pic_address (rtx orig, rtx reg)\n {\n-  bool gotdata_op = false;\n-\n   if (GET_CODE (orig) == SYMBOL_REF\n       /* See the comment in sparc_expand_move.  */\n       || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))\n     {\n+      bool gotdata_op = false;\n       rtx pic_ref, address;\n       rtx_insn *insn;\n \n-      if (reg == 0)\n+      if (!reg)\n \t{\n \t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n@@ -4770,8 +4774,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n \t  /* If not during reload, allocate another temp reg here for loading\n \t     in the address, so that these instructions can be optimized\n \t     properly.  */\n-\t  rtx temp_reg = (! can_create_pseudo_p ()\n-\t\t\t  ? reg : gen_reg_rtx (Pmode));\n+\t  rtx temp_reg = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : reg;\n \n \t  /* Must put the SYMBOL_REF inside an UNSPEC here so that cse\n \t     won't get confused into thinking that these two instructions\n@@ -4787,6 +4790,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n \t      emit_insn (gen_movsi_high_pic (temp_reg, orig));\n \t      emit_insn (gen_movsi_lo_sum_pic (temp_reg, temp_reg, orig));\n \t    }\n+\n \t  address = temp_reg;\n \t  gotdata_op = true;\n \t}\n@@ -4827,7 +4831,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n \t  && sparc_pic_register_p (XEXP (XEXP (orig, 0), 0)))\n \treturn orig;\n \n-      if (reg == 0)\n+      if (!reg)\n \t{\n \t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n@@ -4935,7 +4939,11 @@ sparc_delegitimize_address (rtx x)\n       && XINT (XEXP (XEXP (x, 1), 1), 1) == UNSPEC_MOVE_PIC_LABEL)\n     {\n       x = XVECEXP (XEXP (XEXP (x, 1), 1), 0, 0);\n-      gcc_assert (GET_CODE (x) == LABEL_REF);\n+      gcc_assert (GET_CODE (x) == LABEL_REF\n+\t\t  || (GET_CODE (x) == CONST\n+\t\t      && GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n+\t\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT));\n     }\n \n   return x;"}, {"sha": "df769405190388ca4e684fff9e2dc5a3bee653e5", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=69128a1730ce956e536faf2f0b0e3f7326e5a52c", "patch": "@@ -1758,7 +1758,7 @@\n \n (define_expand \"movsi_pic_label_ref\"\n   [(set (match_dup 3) (high:SI\n-     (unspec:SI [(match_operand:SI 1 \"label_ref_operand\" \"\")\n+     (unspec:SI [(match_operand:SI 1 \"symbolic_operand\" \"\")\n \t\t (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))\n    (set (match_dup 4) (lo_sum:SI (match_dup 3)\n      (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))\n@@ -1784,15 +1784,15 @@\n (define_insn \"*movsi_high_pic_label_ref\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n       (high:SI\n-        (unspec:SI [(match_operand:SI 1 \"label_ref_operand\" \"\")\n+        (unspec:SI [(match_operand:SI 1 \"symbolic_operand\" \"\")\n \t\t    (match_operand:SI 2 \"\" \"\")] UNSPEC_MOVE_PIC_LABEL)))]\n   \"flag_pic\"\n   \"sethi\\t%%hi(%a2-(%a1-.)), %0\")\n \n (define_insn \"*movsi_lo_sum_pic_label_ref\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n       (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-        (unspec:SI [(match_operand:SI 2 \"label_ref_operand\" \"\")\n+        (unspec:SI [(match_operand:SI 2 \"symbolic_operand\" \"\")\n \t\t    (match_operand:SI 3 \"\" \"\")] UNSPEC_MOVE_PIC_LABEL)))]\n   \"flag_pic\"\n   \"or\\t%1, %%lo(%a3-(%a2-.)), %0\")\n@@ -1896,7 +1896,7 @@ visl\")\n \n (define_expand \"movdi_pic_label_ref\"\n   [(set (match_dup 3) (high:DI\n-     (unspec:DI [(match_operand:DI 1 \"label_ref_operand\" \"\")\n+     (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")\n                  (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))\n    (set (match_dup 4) (lo_sum:DI (match_dup 3)\n      (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))\n@@ -1922,15 +1922,15 @@ visl\")\n (define_insn \"*movdi_high_pic_label_ref\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI\n-          (unspec:DI [(match_operand:DI 1 \"label_ref_operand\" \"\")\n+          (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")\n                       (match_operand:DI 2 \"\" \"\")] UNSPEC_MOVE_PIC_LABEL)))]\n   \"TARGET_ARCH64 && flag_pic\"\n   \"sethi\\t%%hi(%a2-(%a1-.)), %0\")\n \n (define_insn \"*movdi_lo_sum_pic_label_ref\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n       (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-        (unspec:DI [(match_operand:DI 2 \"label_ref_operand\" \"\")\n+        (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")\n                     (match_operand:DI 3 \"\" \"\")] UNSPEC_MOVE_PIC_LABEL)))]\n   \"TARGET_ARCH64 && flag_pic\"\n   \"or\\t%1, %%lo(%a3-(%a2-.)), %0\")"}, {"sha": "dad3874ff95fb3bfbf80f8329705c85cd7cbfd74", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69128a1730ce956e536faf2f0b0e3f7326e5a52c", "patch": "@@ -1,3 +1,7 @@\n+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* g++.dg/opt/pr85196.C: New test.\n+\n 2018-04-06  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/84269"}, {"sha": "04d7abde4fa759ec6d8416e8bce59a1ad84e55a8", "filename": "gcc/testsuite/g++.dg/opt/pr85196.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr85196.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69128a1730ce956e536faf2f0b0e3f7326e5a52c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr85196.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr85196.C?ref=69128a1730ce956e536faf2f0b0e3f7326e5a52c", "patch": "@@ -0,0 +1,89 @@\n+// PR target/85196\n+// Testcase by Rainer Orth <ro@gcc.gnu.org>\n+\n+// { dg-do compile }\n+// { dg-options \"-O -fpermissive -w\" }\n+// { dg-additional-options \"-fPIC\" { target fpic } }\n+\n+class a;\n+template <typename> class b;\n+template <typename k> class d : public b<k> {};\n+class e {};\n+void f(int);\n+template <class> class g {\n+public:\n+  h();\n+  a i();\n+};\n+template <> class b<e> : public g<e> {};\n+typedef (*j)(d<e>);\n+template <class k> class l {\n+public:\n+  k operator->() { return 0; }\n+};\n+enum m { n, aa, o, ab, q, p };\n+inline s(m ac) {\n+  switch (ac) {\n+  case n:\n+  case aa:\n+  case p:\n+    return 1;\n+  case o:\n+  case ab:\n+    return 2;\n+  }\n+}\n+class D {\n+  int ad;\n+\n+public:\n+  *ae() { return &ad; }\n+};\n+class a {\n+  l<D *> af;\n+\n+public:\n+  *r() { return af->ae(); }\n+  t(int *c) {\n+    int *w = af->ae();\n+    return w == c;\n+  }\n+};\n+class F : a {\n+public:\n+  static int ah[];\n+  static e v(F *);\n+  unsigned long ai() const;\n+};\n+inline unsigned long F::ai() const {\n+  m aj = r() - &ah[0];\n+  return s(aj);\n+}\n+inline e F::v(F *ak) {\n+  long al = ak->ai();\n+  f(al);\n+}\n+template <typename> am() { return q; }\n+class an : F {\n+public:\n+  static ao(d<e> u) {\n+    int *ap;\n+    m aq = am<unsigned>();\n+    ap = &ah[aq];\n+    return u.h() && u.i().t(ap);\n+  }\n+  template <e ar(F *)> static as() {\n+    F at;\n+    ar(&at);\n+  }\n+  template <e ar(F *)> static au(int *, unsigned, e *) {\n+    j av = ao;\n+    d<e> aw;\n+    if (av(aw))\n+      as<ar>();\n+  }\n+};\n+int *ax;\n+int ay;\n+e az;\n+ba() { an::au<an::v>(ax, ay, &az); }"}]}