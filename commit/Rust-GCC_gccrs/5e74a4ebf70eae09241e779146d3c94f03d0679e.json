{"sha": "5e74a4ebf70eae09241e779146d3c94f03d0679e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3NGE0ZWJmNzBlYWUwOTI0MWU3NzkxNDZkM2M5NGYwM2QwNjc5ZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2004-11-08T18:03:01Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-11-08T18:03:01Z"}, "message": "re PR java/16843 (gcjh generated headers don't define final constants)\n\n\tPR java/16843:\n\t* gjavah.c (HANDLE_END_FIELD): Call print_field_info when\n\tgenerating a JNI header.\n\t(print_field_info): Handle JNI headers.\n\t(jni_print_float): Likewise.\n\t(jni_print_double): Likewise.\n\nFrom-SVN: r90277", "tree": {"sha": "3e59680ae3030d5ec283c86091be2fdc82c84ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e59680ae3030d5ec283c86091be2fdc82c84ff1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e74a4ebf70eae09241e779146d3c94f03d0679e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e74a4ebf70eae09241e779146d3c94f03d0679e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e74a4ebf70eae09241e779146d3c94f03d0679e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e74a4ebf70eae09241e779146d3c94f03d0679e/comments", "author": null, "committer": null, "parents": [{"sha": "15fb0dbeb707ea75243d97eab9270b51bf446c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fb0dbeb707ea75243d97eab9270b51bf446c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15fb0dbeb707ea75243d97eab9270b51bf446c94"}], "stats": {"total": 96, "additions": 72, "deletions": 24}, "files": [{"sha": "7b4ba0d01df7da1730e909c09bd69072f48f5615", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e74a4ebf70eae09241e779146d3c94f03d0679e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e74a4ebf70eae09241e779146d3c94f03d0679e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5e74a4ebf70eae09241e779146d3c94f03d0679e", "patch": "@@ -1,3 +1,12 @@\n+2004-11-08  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR java/16843:\n+\t* gjavah.c (HANDLE_END_FIELD): Call print_field_info when\n+\tgenerating a JNI header.\n+\t(print_field_info): Handle JNI headers.\n+\t(jni_print_float): Likewise.\n+\t(jni_print_double): Likewise.\n+\n 2004-11-08  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* decl.c (end_java_method): Remove duplicated code."}, {"sha": "2604f5eee88f240fa812e8b6c678a5f7f00e8aed", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 63, "deletions": 24, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e74a4ebf70eae09241e779146d3c94f03d0679e/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e74a4ebf70eae09241e779146d3c94f03d0679e/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=5e74a4ebf70eae09241e779146d3c94f03d0679e", "patch": "@@ -187,7 +187,7 @@ static int method_pass;\n #define HANDLE_END_FIELD()\t\t\t\t\t\t      \\\n   if (field_pass)\t\t\t\t\t\t\t      \\\n     {\t\t\t\t\t\t\t\t\t      \\\n-      if (out && ! stubs && ! flag_jni)\t\t\t\t\t      \\\n+      if (out && ! stubs)\t\t\t\t\t\t      \\\n \tprint_field_info (out, jcf, current_field_name,\t\t\t      \\\n \t\t\t  current_field_signature,\t\t\t      \\\n  \t\t\t  current_field_flags);\t\t\t\t      \\\n@@ -278,7 +278,7 @@ jni_print_float (FILE *stream, jfloat f)\n      work in data initializers.  FIXME.  */\n   if (JFLOAT_FINITE (f))\n     {\n-      fputs (\" = \", stream);\n+      fputs (flag_jni ? \" \" : \" = \", out);\n       if (f.negative)\n \tputc ('-', stream);\n       if (f.exponent)\n@@ -292,7 +292,8 @@ jni_print_float (FILE *stream, jfloat f)\n \t\t ((unsigned int)f.mantissa) << 1,\n \t\t f.exponent + 1 - JFLOAT_EXP_BIAS);\n     }\n-  fputs (\";\\n\", stream);\n+  if (! flag_jni)\n+    fputs (\";\\n\", stream);\n }\n \n /* Print a double-precision float, suitable for parsing by g++.  */\n@@ -303,7 +304,7 @@ jni_print_double (FILE *stream, jdouble f)\n      work in data initializers.  FIXME.  */\n   if (JDOUBLE_FINITE (f))\n     {\n-      fputs (\" = \", stream);\n+      fputs (flag_jni ? \" \" : \" = \", out);\n       if (f.negative)\n \tputc ('-', stream);\n       if (f.exponent)\n@@ -317,7 +318,7 @@ jni_print_double (FILE *stream, jdouble f)\n \t\t f.mantissa0, f.mantissa1,\n \t\t f.exponent + 1 - JDOUBLE_EXP_BIAS);\n     }\n-  fputs (\";\\n\", stream);\n+  fputs (flag_jni ? \"\\n\" : \";\\n\", stream);\n }\n \n /* Print a character, appropriately mangled for JNI.  */\n@@ -725,18 +726,47 @@ print_field_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n {\n   char *override = NULL;\n \n-  generate_access (stream, flags);\n+  if (! flag_jni)\n+    generate_access (stream, flags);\n   if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n     {\n       fprintf (stream, \"<not a UTF8 constant>\");\n       found_error = 1;\n       return;\n     }\n \n-  fputs (\"  \", out);\n+  if (flag_jni)\n+    {\n+      /* For JNI we only want to print real constants.  */\n+      int val;\n+      if (! (flags & ACC_STATIC)\n+\t  || ! (flags & ACC_FINAL)\n+\t  || current_field_value <= 0)\n+\treturn;\n+      val = JPOOL_TAG (jcf, current_field_value);\n+      if (val != CONSTANT_Integer && val != CONSTANT_Long\n+\t  && val != CONSTANT_Float && val != CONSTANT_Double)\n+\treturn;\n+    }\n+  else\n+    {\n+      /* Initial indentation.  */\n+      fputs (\"  \", stream);\n+    }\n+\n   if ((flags & ACC_STATIC))\n     {\n-      fputs (\"static \", out);\n+      if (flag_jni)\n+\t{\n+\t  print_cxx_classname (stream, \"#undef \", jcf, jcf->this_class, 1);\n+\t  fputs (\"_\", stream);\n+\t  print_field_name (stream, jcf, name_index, 0);\n+\t  fputs (\"\\n\", stream);\n+\t  print_cxx_classname (stream, \"#define \", jcf, jcf->this_class, 1);\n+\t  fputs (\"_\", stream);\n+\t}\n+      else\n+\tfputs (\"static \", stream);\n \n       if ((flags & ACC_FINAL) && current_field_value > 0)\n \t{\n@@ -749,9 +779,10 @@ print_field_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n \t      {\n \t\tjint num;\n \t\tint most_negative = 0;\n-\t\tfputs (\"const jint \", out);\n-\t\tprint_field_name (out, jcf, name_index, 0);\n-\t\tfputs (\" = \", out);\n+\t\tif (! flag_jni)\n+\t\t  fputs (\"const jint \", stream);\n+\t\tprint_field_name (stream, jcf, name_index, 0);\n+\t\tfputs (flag_jni ? \" \" : \" = \", stream);\n \t\tnum = JPOOL_INT (jcf, current_field_value);\n \t\t/* We single out the most negative number to print\n \t\t   specially.  This avoids later warnings from g++.  */\n@@ -761,16 +792,19 @@ print_field_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n \t\t    ++num;\n \t\t  }\n \t\tformat_int (buffer, (jlong) num, 10);\n-\t\tfprintf (out, \"%sL%s;\\n\", buffer, most_negative ? \" - 1\" : \"\");\n+\t\tfprintf (stream, \"%sL%s%s\\n\", buffer,\n+\t\t\t most_negative ? \" - 1\" : \"\",\n+\t\t\t flag_jni ? \"\" : \";\");\n \t      }\n \t      break;\n \t    case CONSTANT_Long:\n \t      {\n \t\tjlong num;\n \t\tint most_negative = 0;\n-\t\tfputs (\"const jlong \", out);\n-\t\tprint_field_name (out, jcf, name_index, 0);\n-\t\tfputs (\" = \", out);\n+\t\tif (! flag_jni)\n+\t\t  fputs (\"const jlong \", stream);\n+\t\tprint_field_name (stream, jcf, name_index, 0);\n+\t\tfputs (flag_jni ? \" \" : \" = \", stream);\n \t\tnum = JPOOL_LONG (jcf, current_field_value);\n \t\t/* We single out the most negative number to print\n                    specially..  This avoids later warnings from g++.  */\n@@ -780,23 +814,27 @@ print_field_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n \t\t    ++num;\n \t\t  }\n \t\tformat_int (buffer, num, 10);\n-\t\tfprintf (out, \"%sLL%s;\\n\", buffer, most_negative ? \" - 1\" :\"\");\n+\t\tfprintf (stream, \"%sLL%s%s\\n\", buffer,\n+\t\t\t most_negative ? \" - 1\" :\"\",\n+\t\t\t flag_jni ? \"\" : \";\");\n \t      }\n \t      break;\n \t    case CONSTANT_Float:\n \t      {\n \t\tjfloat fnum = JPOOL_FLOAT (jcf, current_field_value);\n-\t\tfputs (\"const jfloat \", out);\n-\t\tprint_field_name (out, jcf, name_index, 0);\n-\t\tjni_print_float (out, fnum);\n+\t\tif (! flag_jni)\n+\t\t  fputs (\"const jfloat \", stream);\n+\t\tprint_field_name (stream, jcf, name_index, 0);\n+\t\tjni_print_float (stream, fnum);\n \t      }\n \t      break;\n \t    case CONSTANT_Double:\n \t      {\n \t\tjdouble dnum = JPOOL_DOUBLE (jcf, current_field_value);\n-\t\tfputs (\"const jdouble \", out);\n-\t\tprint_field_name (out, jcf, name_index, 0);\n-\t\tjni_print_double (out, dnum);\n+\t\tif (! flag_jni)\n+\t\t  fputs (\"const jdouble \", stream);\n+\t\tprint_field_name (stream, jcf, name_index, 0);\n+\t\tjni_print_double (stream, dnum);\n \t      }\n \t      break;\n \t    default:\n@@ -811,9 +849,10 @@ print_field_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n \t}\n     }\n \n+  /* assert (! flag_jni);  */\n   override = get_field_name (jcf, name_index, flags);\n-  print_c_decl (out, jcf, name_index, sig_index, 0, override, flags);\n-  fputs (\";\\n\", out);\n+  print_c_decl (stream, jcf, name_index, sig_index, 0, override, flags);\n+  fputs (\";\\n\", stream);\n \n   if (override)\n     free (override);"}]}