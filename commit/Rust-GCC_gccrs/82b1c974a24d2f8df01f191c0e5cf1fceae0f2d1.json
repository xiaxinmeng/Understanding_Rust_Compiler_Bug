{"sha": "82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJiMWM5NzRhMjRkMmY4ZGYwMWYxOTFjMGU1Y2YxZmNlYWUwZjJkMQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-05-11T20:01:01Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-05-11T20:01:01Z"}, "message": "s390.c (s390_function_arg_float): New function.\n\n\t* config/s390/s390.c (s390_function_arg_float): New function.\n\t(s390_function_arg_pass_by_reference): Use it.\n\t(s390_function_arg_advance): Likewise.\n\t(s390_function_arg): Likewise.\n\t(s390_va_arg): Likewise\n\nFrom-SVN: r66696", "tree": {"sha": "63a6d755047fc981fc49f915dcb37d82d94d5fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63a6d755047fc981fc49f915dcb37d82d94d5fc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1/comments", "author": null, "committer": null, "parents": [{"sha": "6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a"}], "stats": {"total": 68, "additions": 60, "deletions": 8}, "files": [{"sha": "6ff7d82183b201c74fcf9c753de3ed56dcc9dca1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1", "patch": "@@ -1,3 +1,11 @@\n+2003-05-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_function_arg_float): New function.\n+\t(s390_function_arg_pass_by_reference): Use it.\n+\t(s390_function_arg_advance): Likewise.\n+\t(s390_function_arg): Likewise.\n+\t(s390_va_arg): Likewise\n+\n 2003-05-11  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* coverage.h (coverage_counter_alloc): New function."}, {"sha": "4c290a4ac4343ae5a0574b68f87dcc72a14140a8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=82b1c974a24d2f8df01f191c0e5cf1fceae0f2d1", "patch": "@@ -211,6 +211,7 @@ static rtx restore_fpr PARAMS ((rtx, int, int));\n static rtx save_gprs PARAMS ((rtx, int, int, int));\n static rtx restore_gprs PARAMS ((rtx, int, int, int));\n static int s390_function_arg_size PARAMS ((enum machine_mode, tree));\n+static bool s390_function_arg_float PARAMS ((enum machine_mode, tree));\n static struct machine_function * s390_init_machine_status PARAMS ((void));\n  \n /* Return true if SET either doesn't set the CC register, or else\n@@ -5699,6 +5700,48 @@ s390_function_arg_size (mode, type)\n   abort ();\n }\n \n+/* Return true if a function argument of type TYPE and mode MODE\n+   is to be passed in a floating-point register, if available.  */\n+\n+static bool\n+s390_function_arg_float (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  /* Soft-float changes the ABI: no floating-point registers are used.  */\n+  if (TARGET_SOFT_FLOAT)\n+    return false;\n+\n+  /* No type info available for some library calls ...  */\n+  if (!type)\n+    return mode == SFmode || mode == DFmode;\n+\n+  /* The ABI says that record types with a single member are treated\n+     just like that member would be.  */\n+  while (TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      tree field, single = NULL_TREE;\n+\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\n+\t  if (single == NULL_TREE)\n+\t    single = TREE_TYPE (field);\n+\t  else\n+\t    return false;\n+\t}\n+\n+      if (single == NULL_TREE)\n+\treturn false;\n+      else\n+\ttype = single;\n+    }\n+\n+  return TREE_CODE (type) == REAL_TYPE;\n+}\n+\n /* Return 1 if a function argument of type TYPE and mode MODE\n    is to be passed by reference.  The ABI specifies that only\n    structures of size 1, 2, 4, or 8 bytes are passed by value,\n@@ -5715,14 +5758,15 @@ s390_function_arg_pass_by_reference (mode, type)\n   if (type)\n     {\n       if (AGGREGATE_TYPE_P (type) &&\n-          size != 1 && size != 2 && size != 4 && size != 8)\n+          size != 1 && size != 2 && size != 4 && size != 8\n+\t  && !s390_function_arg_float (mode, type))\n         return 1;\n \n       if (TREE_CODE (type) == COMPLEX_TYPE)\n         return 1;\n     }\n+    \n   return 0;\n-\n }\n \n /* Update the data in CUM to advance over an argument of mode MODE and\n@@ -5738,13 +5782,13 @@ s390_function_arg_advance (cum, mode, type, named)\n      tree type;\n      int named ATTRIBUTE_UNUSED;\n {\n-  if (! TARGET_SOFT_FLOAT && (mode == DFmode || mode == SFmode))\n+  if (s390_function_arg_pass_by_reference (mode, type))\n     {\n-      cum->fprs++;\n+      cum->gprs += 1;\n     }\n-  else if (s390_function_arg_pass_by_reference (mode, type))\n+  else if (s390_function_arg_float (mode, type))\n     {\n-      cum->gprs += 1;\n+      cum->fprs += 1;\n     }\n   else\n     {\n@@ -5782,7 +5826,7 @@ s390_function_arg (cum, mode, type, named)\n   if (s390_function_arg_pass_by_reference (mode, type))\n       return 0;\n \n-  if (! TARGET_SOFT_FLOAT && (mode == DFmode || mode == SFmode))\n+  if (s390_function_arg_float (mode, type))\n     {\n       if (cum->fprs + 1 > (TARGET_64BIT? 4 : 2))\n \treturn 0;\n@@ -5996,7 +6040,7 @@ s390_va_arg (valist, type)\n       size = UNITS_PER_WORD;\n       max_reg = 4;\n     }\n-  else if (FLOAT_TYPE_P (type) && ! TARGET_SOFT_FLOAT)\n+  else if (s390_function_arg_float (TYPE_MODE (type), type))\n     {\n       if (TARGET_DEBUG_ARG)\n \t{"}]}