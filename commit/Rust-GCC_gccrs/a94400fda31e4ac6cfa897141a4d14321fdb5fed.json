{"sha": "a94400fda31e4ac6cfa897141a4d14321fdb5fed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0NDAwZmRhMzFlNGFjNmNmYTg5NzE0MWE0ZDE0MzIxZmRiNWZlZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-21T00:39:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-21T00:39:22Z"}, "message": "re PR tree-optimization/14846 ([tree-ssa] don't use a shift in A & CST_POWER_OF_2 == 0 until very late in tree-ssa optimizations)\n\n\tPR tree-optimization/14846\n\t* fold-const.c (fold_single_bit_test_into_sign_test): New,\n\tsplit out from ...\n\t(fold_single_bit_test): ... here.\n\t(fold_binary): Call fold_single_bit_test_into_sign_test\n\tinstead of fold_single_bit_test.\n\nFrom-SVN: r98482", "tree": {"sha": "7f6dbf48062abdd588564dcc5342bfd66ed62f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f6dbf48062abdd588564dcc5342bfd66ed62f54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a94400fda31e4ac6cfa897141a4d14321fdb5fed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94400fda31e4ac6cfa897141a4d14321fdb5fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94400fda31e4ac6cfa897141a4d14321fdb5fed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94400fda31e4ac6cfa897141a4d14321fdb5fed/comments", "author": null, "committer": null, "parents": [{"sha": "fcda200251c29f9c6c574b9b1db0523021df9578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcda200251c29f9c6c574b9b1db0523021df9578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcda200251c29f9c6c574b9b1db0523021df9578"}], "stats": {"total": 71, "additions": 53, "deletions": 18}, "files": [{"sha": "e29e4c327bfc9f58838f9d5d419382f135ec07f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94400fda31e4ac6cfa897141a4d14321fdb5fed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94400fda31e4ac6cfa897141a4d14321fdb5fed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a94400fda31e4ac6cfa897141a4d14321fdb5fed", "patch": "@@ -1,3 +1,12 @@\n+2005-04-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR tree-optimization/14846\n+\t* fold-const.c (fold_single_bit_test_into_sign_test): New,\n+\tsplit out from ...\n+\t(fold_single_bit_test): ... here.\n+\t(fold_binary): Call fold_single_bit_test_into_sign_test\n+\tinstead of fold_single_bit_test.\n+\n 2005-04-20  James E Wilson  <wilson@specifixinc.com>\n \n \tPR c++/20805"}, {"sha": "af1af3382adac70d3b13355c9e9c1f099eebc1db", "filename": "gcc/fold-const.c", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94400fda31e4ac6cfa897141a4d14321fdb5fed/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94400fda31e4ac6cfa897141a4d14321fdb5fed/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a94400fda31e4ac6cfa897141a4d14321fdb5fed", "patch": "@@ -5929,30 +5929,23 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \n \n /* If CODE with arguments ARG0 and ARG1 represents a single bit\n-   equality/inequality test, then return a simplified form of\n-   the test using shifts and logical operations.  Otherwise return\n-   NULL.  TYPE is the desired result type.  */\n+   equality/inequality test, then return a simplified form of the test\n+   using a sign testing.  Otherwise return NULL.  TYPE is the desired\n+   result type.  */\n \n-tree\n-fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n-\t\t      tree result_type)\n+static tree\n+fold_single_bit_test_into_sign_test (enum tree_code code, tree arg0, tree arg1,\n+\t\t\t\t     tree result_type)\n {\n   /* If this is testing a single bit, we can optimize the test.  */\n   if ((code == NE_EXPR || code == EQ_EXPR)\n       && TREE_CODE (arg0) == BIT_AND_EXPR && integer_zerop (arg1)\n       && integer_pow2p (TREE_OPERAND (arg0, 1)))\n     {\n-      tree inner = TREE_OPERAND (arg0, 0);\n-      tree type = TREE_TYPE (arg0);\n-      int bitnum = tree_log2 (TREE_OPERAND (arg0, 1));\n-      enum machine_mode operand_mode = TYPE_MODE (type);\n-      int ops_unsigned;\n-      tree signed_type, unsigned_type, intermediate_type;\n-      tree arg00;\n-\n       /* If we have (A & C) != 0 where C is the sign bit of A, convert\n \t this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */\n-      arg00 = sign_bit_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n+      tree arg00 = sign_bit_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n+\n       if (arg00 != NULL_TREE\n \t  /* This is only a win if casting to a signed type is cheap,\n \t     i.e. when arg00's type is not a partial mode.  */\n@@ -5964,6 +5957,39 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t\t      result_type, fold_convert (stype, arg00),\n \t\t\t      fold_convert (stype, integer_zero_node));\n \t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* If CODE with arguments ARG0 and ARG1 represents a single bit\n+   equality/inequality test, then return a simplified form of\n+   the test using shifts and logical operations.  Otherwise return\n+   NULL.  TYPE is the desired result type.  */\n+\n+tree\n+fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n+\t\t      tree result_type)\n+{\n+  /* If this is testing a single bit, we can optimize the test.  */\n+  if ((code == NE_EXPR || code == EQ_EXPR)\n+      && TREE_CODE (arg0) == BIT_AND_EXPR && integer_zerop (arg1)\n+      && integer_pow2p (TREE_OPERAND (arg0, 1)))\n+    {\n+      tree inner = TREE_OPERAND (arg0, 0);\n+      tree type = TREE_TYPE (arg0);\n+      int bitnum = tree_log2 (TREE_OPERAND (arg0, 1));\n+      enum machine_mode operand_mode = TYPE_MODE (type);\n+      int ops_unsigned;\n+      tree signed_type, unsigned_type, intermediate_type;\n+      tree tem;\n+\n+      /* First, see if we can fold the single bit test into a sign-bit\n+\t test.  */\n+      tem = fold_single_bit_test_into_sign_test (code, arg0, arg1,\n+\t\t\t\t\t\t result_type);\n+      if (tem)\n+\treturn tem;\n \n       /* Otherwise we have (A & C) != 0 where C is a single bit,\n \t convert that into ((A >> C2) & 1).  Where C2 = log2(C).\n@@ -9447,9 +9473,9 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t    arg0, fold_convert (TREE_TYPE (arg0),\n \t\t\t\t\t\tinteger_zero_node));\n \n-      /* If we have (A & C) != 0 or (A & C) == 0 and C is a power of\n-\t 2, then fold the expression into shifts and logical operations.  */\n-      tem = fold_single_bit_test (code, arg0, arg1, type);\n+      /* If we have (A & C) != 0 or (A & C) == 0 and C is the sign\n+\t bit, then fold the expression into A < 0 or A >= 0.  */\n+      tem = fold_single_bit_test_into_sign_test (code, arg0, arg1, type);\n       if (tem)\n \treturn tem;\n "}]}