{"sha": "46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZmN2I4MGVjNDFiNjgwZGU5MzE2ZGJkYjNjOWNmZTM3NmQ4ZTg4Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-27T15:08:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-27T15:08:23Z"}, "message": "compiler: let initializers hold addresses of fields\n    \n    The runtime.dbgvars initializer looks like\n    \n    var dbgvars = []dbgVar{\n            {\"allocfreetrace\", &debug.allocfreetrace},\n    }\n    \n    Because the field address was not recognized as valid for a static\n    initializer, the variable was initialized at runtime.  Normally that\n    would be fine, but for the runtime package it meant that dbgvars was\n    not initialized when it was read by parsedebugvars.  That meant that\n    the GODEBUG environment variable did nothing.\n    \n    Fixing that revealed that the static initializer checks had to be more\n    careful about interface types, just like the existing is_constant\n    methods.\n    \n    Reviewed-on: https://go-review.googlesource.com/35891\n\nFrom-SVN: r244982", "tree": {"sha": "a7ccb6363b9382bcc300d5b7ef9a3e7533e048d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7ccb6363b9382bcc300d5b7ef9a3e7533e048d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/comments", "author": null, "committer": null, "parents": [{"sha": "42f20102eff9b4e5cfad7cd21505a204df085418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f20102eff9b4e5cfad7cd21505a204df085418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f20102eff9b4e5cfad7cd21505a204df085418"}], "stats": {"total": 112, "additions": 85, "deletions": 27}, "files": [{"sha": "532cf1e9929a742b33014d379e4fece30a83348d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "patch": "@@ -1,4 +1,4 @@\n-2c62d5223e814887801b1540162c72b90299d910\n+7fa4eb4b7a32953c2e838f1b0c684a6733172b43\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "fee3203714f4fbd4c97b6173b39e188314587833", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "patch": "@@ -3878,33 +3878,52 @@ Unary_expression::do_is_static_initializer() const\n   if (this->op_ == OPERATOR_MULT)\n     return false;\n   else if (this->op_ == OPERATOR_AND)\n-    {\n-      // The address of a global variable can used as a static\n-      // initializer.\n-      Var_expression* ve = this->expr_->var_expression();\n-      if (ve != NULL)\n-\t{\n-\t  Named_object* no = ve->named_object();\n-\t  return no->is_variable() && no->var_value()->is_global();\n-\t}\n+    return Unary_expression::base_is_static_initializer(this->expr_);\n+  else\n+    return this->expr_->is_static_initializer();\n+}\n \n-      // The address of a composite literal can be used as a static\n-      // initializer if the composite literal is itself usable as a\n-      // static initializer.\n-      if (this->expr_->is_composite_literal()\n-\t  && this->expr_->is_static_initializer())\n-\treturn true;\n+// Return whether the address of EXPR can be used as a static\n+// initializer.\n \n-      // The address of a string constant can be used as a static\n-      // initializer.  This can not be written in Go itself but this\n-      // is used when building a type descriptor.\n-      if (this->expr_->string_expression() != NULL)\n-\treturn true;\n+bool\n+Unary_expression::base_is_static_initializer(Expression* expr)\n+{\n+  // The address of a field reference can be a static initializer if\n+  // the base can be a static initializer.\n+  Field_reference_expression* fre = expr->field_reference_expression();\n+  if (fre != NULL)\n+    return Unary_expression::base_is_static_initializer(fre->expr());\n+\n+  // The address of an index expression can be a static initializer if\n+  // the base can be a static initializer and the index is constant.\n+  Array_index_expression* aind = expr->array_index_expression();\n+  if (aind != NULL)\n+    return (aind->end() == NULL\n+\t    && aind->start()->is_constant()\n+\t    && Unary_expression::base_is_static_initializer(aind->array()));\n+\n+  // The address of a global variable can be a static initializer.\n+  Var_expression* ve = expr->var_expression();\n+  if (ve != NULL)\n+    {\n+      Named_object* no = ve->named_object();\n+      return no->is_variable() && no->var_value()->is_global();\n+    }\n+\n+  // The address of a composite literal can be used as a static\n+  // initializer if the composite literal is itself usable as a\n+  // static initializer.\n+  if (expr->is_composite_literal() && expr->is_static_initializer())\n+    return true;\n \n-      return false;\n-    }\n-  else\n-    return this->expr_->is_static_initializer();\n+  // The address of a string constant can be used as a static\n+  // initializer.  This can not be written in Go itself but this is\n+  // used when building a type descriptor.\n+  if (expr->string_expression() != NULL)\n+    return true;\n+\n+  return false;\n }\n \n // Apply unary opcode OP to UNC, setting NC.  Return true if this\n@@ -12460,6 +12479,17 @@ Struct_construction_expression::do_is_static_initializer() const\n       if (*pv != NULL && !(*pv)->is_static_initializer())\n \treturn false;\n     }\n+\n+  const Struct_field_list* fields = this->type_->struct_type()->fields();\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    {\n+      // There are no constant constructors for interfaces.\n+      if (pf->type()->interface_type() != NULL)\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n@@ -12550,7 +12580,7 @@ Struct_construction_expression::do_flatten(Gogo*, Named_object*,\n     return this;\n \n   // If this is a constant struct, we don't need temporaries.\n-  if (this->is_constant_struct())\n+  if (this->is_constant_struct() || this->is_static_initializer())\n     return this;\n \n   Location loc = this->location();\n@@ -12701,6 +12731,11 @@ Array_construction_expression::do_is_static_initializer() const\n {\n   if (this->vals() == NULL)\n     return true;\n+\n+  // There are no constant constructors for interfaces.\n+  if (this->type_->array_type()->element_type()->interface_type() != NULL)\n+    return false;\n+\n   for (Expression_list::const_iterator pv = this->vals()->begin();\n        pv != this->vals()->end();\n        ++pv)\n@@ -12765,7 +12800,7 @@ Array_construction_expression::do_flatten(Gogo*, Named_object*,\n     return this;\n \n   // If this is a constant array, we don't need temporaries.\n-  if (this->is_constant_array())\n+  if (this->is_constant_array() || this->is_static_initializer())\n     return this;\n \n   Location loc = this->location();"}, {"sha": "adf9eabe152885f70ebe6e0df030a20af8f1d85c", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f7b80ec41b680de9316dbdb3c9cfe376d8e88b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=46f7b80ec41b680de9316dbdb3c9cfe376d8e88b", "patch": "@@ -1842,6 +1842,9 @@ class Unary_expression : public Expression\n   { this->issue_nil_check_ = (this->op_ == OPERATOR_MULT); }\n \n  private:\n+  static bool\n+  base_is_static_initializer(Expression*);\n+\n   // The unary operator to apply.\n   Operator op_;\n   // Normally true.  False if this is an address expression which does\n@@ -2640,6 +2643,26 @@ class Array_index_expression : public Expression\n   array() const\n   { return this->array_; }\n \n+  // Return the index of a simple index expression, or the start index\n+  // of a slice expression.\n+  Expression*\n+  start()\n+  { return this->start_; }\n+\n+  const Expression*\n+  start() const\n+  { return this->start_; }\n+\n+  // Return the end index of a slice expression.  This is NULL for a\n+  // simple index expression.\n+  Expression*\n+  end()\n+  { return this->end_; }\n+\n+  const Expression*\n+  end() const\n+  { return this->end_; }\n+\n  protected:\n   int\n   do_traverse(Traverse*);"}]}