{"sha": "54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5OTQyNTNkM2ZjMDBiY2I3ZDNlOTM1OWZmMzFhODFjMGU0NTQzYQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-10-17T15:59:25Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-10-17T15:59:25Z"}, "message": "bitmap.c (bitmap_head::dump): New.\n\n\t* bitmap.c (bitmap_head::dump): New.\n\t* bitmap.h (bitmap_head): Add dump().\n\t* gimple-ssa-evrp-analyze.c\n\t(evrp_range_analyzer::try_find_new_range): Adjust for value_range API.\n\t(evrp_range_analyzer::set_ssa_range_info): Same.\n\t(evrp_range_analyzer::record_ranges_from_phis): Same.\n\t(evrp_range_analyzer::record_ranges_from_stmt): Same.\n\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Same.\n\t* gimple-ssa-sprintf.c (get_int_range): Same.\n\t(format_integer): Same.\n\t(sprintf_dom_walker::handle_gimple_call): Same.\n\t* ipa-cp.c (ipcp_vr_lattice::meet_with_1): Same.\n\t(ipcp_vr_lattice::top_p): Same.\n\t(ipcp_vr_lattice::bottom_p): Same.\n\t(ipcp_vr_lattice::set_to_bottom): Same.\n\t(ipa_vr_operation_and_type_effects): Same.\n\t(propagate_vr_across_jump_function): Same.\n\t(ipcp_store_vr_results): Same.\n\t* ipa-prop.c (struct ipa_vr_ggc_hash_traits): Same.\n\t(ipa_print_node_jump_functions_for_edge): Same.\n\t(ipa_get_value_range): Same.\n\t(ipa_compute_jump_functions_for_edge): Same.\n\t(ipa_write_jump_function): Same.\n\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Same.\n\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n\tSame.\n\t* vr-values.c (set_value_range_to_nonnegative): Same.\n\t(set_value_range_to_truthvalue): Same.\n\t(vr_values::get_value_range): Same.\n\t(vr_values::set_defs_to_varying): Same.\n\t(vr_values::update_value_range): Same.\n\t(symbolic_range_based_on_p): Same.\n\t(vr_values::op_with_boolean_value_range_p): Same.\n\t(vr_values::extract_range_for_var_from_comparison_expr): Same.\n\t(vr_values::extract_range_from_ssa_name): Same.\n\t(vr_values::extract_range_from_binary_expr): Same.\n\t(vr_values::extract_range_from_unary_expr): Same.\n\t(vr_values::extract_range_from_cond_expr): Same.\n\t(vr_values::extract_range_from_comparison): Same.\n\t(vr_values::check_for_binary_op_overflow): Same.\n\t(vr_values::extract_range_basic): Same.\n\t(vr_values::extract_range_from_assignment): Same.\n\t(compare_ranges): Same.\n\t(compare_range_with_value): Same.\n\t(vr_values::adjust_range_with_scev): Same.\n\t(vrp_valueize): Same.\n\t(vrp_valueize_1): Same.\n\t(vr_values::get_vr_for_comparison): Same.\n\t(vr_values::compare_name_with_value): Same.\n\t(vr_values::compare_names): Same.\n\t(vr_values::vrp_evaluate_conditional): Same.\n\t(find_case_label_ranges): Same.\n\t(vr_values::vrp_visit_switch_stmt): Same.\n\t(vr_values::extract_range_from_phi_node): Same.\n\t(vr_values::simplify_div_or_mod_using_ranges): Same.\n\t(vr_values::simplify_bit_ops_using_ranges): Same.\n\t(test_for_singularity): Same.\n\t(range_fits_type_p): Same.\n\t(vr_values::simplify_cond_using_ranges_1): Same.\n\t(vr_values::simplify_switch_using_ranges): Same.\n\t(vr_values::simplify_float_conversion_using_ranges): Same.\n\t(vr_values::two_valued_val_range_p): Same.\n\t(vr_values::add_equivalence): Move to value_range::equiv_add.\n\t* vr-values.h (vr_values::add_equivalence): Remove.\n\t(VR_INITIALIZER): Remove.\n\t* tree-vrp.c (value_range::set): New.\n\t(value_range::equiv_add): New.\n\t(value_range::value_range): New.\n\t(value_range::deep_copy): New.\n\t(value_range::check): New.\n\t(value_range::equal_p): New.\n\t(value_range::ignore_equivs_equal_p): New.\n\t(value_range::operator==): New.\n\t(value_range::operator!=): New.\n\t(value_range::symbolic_p): New.\n\t(value_range::numeric_p): New.\n\t(value_range::set_undefined): New.\n\t(value_range::set_varying): New.\n\t(value_range::may_contain_p): New.\n\t(value_range::equiv_clear): New.\n\t(value_range::singleton_p): New.\n\t(value_range::intersect): New.\n\t(value_range::dump): New.\n\t(value_range::set_and_canonicalize): New.\n\t(set_value_range): Adjust for value_range API.\n\t(set_value_range_to_undefined): Same.\n\t(set_value_range_to_varying): Same.\n\t(set_and_canonicalize_value_range): Same.\n\t(set_value_range_to_nonnull): Same.\n\t(set_value_range_to_null): Same.\n\t(range_is_null): Same.\n\t(range_is_nonnull): Same.\n\t(range_int_cst_p): Same.\n\t(range_int_cst_singleton_p): Same.\n\t(symbolic_range_p): Same.\n\t(range_includes_zero_p): Same.\n\t(value_range_constant_singleton): Same.\n\t(vrp_set_zero_nonzero_bits): Same.\n\t(ranges_from_anti_range): Same.\n\t(extract_range_into_wide_ints): Same.\n\t(extract_range_from_multiplicative_op): Same.\n\t(set_value_range_with_overflow): Same.\n\t(extract_range_from_binary_expr_1): Same.\n\t(extract_range_from_unary_expr): Same.\n\t(dump_value_range): Same.\n\t(debug_value_range): Same.\n\t(vrp_prop::check_array_ref): Same.\n\t(vrp_prop::check_mem_ref): Same.\n\t(vrp_prop::vrp_initialize): Same.\n\t(vrp_prop::visit_stmt): Same.\n\t(intersect_ranges): Same.\n\t(vrp_prop::visit_phi): Same.\n\t(vrp_prop::vrp_finalize): Same.\n\t(determine_value_range_1): Same.\n\t(determine_value_range): Same.\n\t(vrp_intersect_ranges_1): Rename to...\n\t(vrp_intersect_1): this.\n\t(vrp_intersect_ranges): Rename to...\n\t(value_range::intersect_helper): ...this.\n\t(vrp_meet_1): Rename to...\n\t(value_range::union_helper): ...this.\n\t(vrp_meet): Rename to...\n\t(value_range::union_): ...this.\n\t(copy_value_range): Remove.\n\t* tree-vrp.h (struct value_range): Rewrite into a proper class.\n\t(value_range::vrtype): New.\n\t(value_range::type): New.\n\t(value_range::equiv): New.\n\t(value_range::min): New.\n\t(value_range::max): New.\n\t(value_range::varying_p): New.\n\t(value_range::undefined_p): New.\n\t(value_range::null_p): New.\n\t(value_range::equiv_add): New.\n\t(copy_value_range): Remove.\n\nFrom-SVN: r265241", "tree": {"sha": "416281f18a0c359b4d87a5aeac398be374184fb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/416281f18a0c359b4d87a5aeac398be374184fb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "033eb5671769a4c681a44aad08a454e667e08502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/033eb5671769a4c681a44aad08a454e667e08502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/033eb5671769a4c681a44aad08a454e667e08502"}], "stats": {"total": 2230, "additions": 1272, "deletions": 958}, "files": [{"sha": "4cfd8210ffbe0edecc86612881baef1a09d7b1a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -1,3 +1,141 @@\n+2018-10-09  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* bitmap.c (bitmap_head::dump): New.\n+\t* bitmap.h (bitmap_head): Add dump().\n+\t* gimple-ssa-evrp-analyze.c\n+\t(evrp_range_analyzer::try_find_new_range): Adjust for value_range API.\n+\t(evrp_range_analyzer::set_ssa_range_info): Same.\n+\t(evrp_range_analyzer::record_ranges_from_phis): Same.\n+\t(evrp_range_analyzer::record_ranges_from_stmt): Same.\n+\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Same.\n+\t* gimple-ssa-sprintf.c (get_int_range): Same.\n+\t(format_integer): Same.\n+\t(sprintf_dom_walker::handle_gimple_call): Same.\n+\t* ipa-cp.c (ipcp_vr_lattice::meet_with_1): Same.\n+\t(ipcp_vr_lattice::top_p): Same.\n+\t(ipcp_vr_lattice::bottom_p): Same.\n+\t(ipcp_vr_lattice::set_to_bottom): Same.\n+\t(ipa_vr_operation_and_type_effects): Same.\n+\t(propagate_vr_across_jump_function): Same.\n+\t(ipcp_store_vr_results): Same.\n+\t* ipa-prop.c (struct ipa_vr_ggc_hash_traits): Same.\n+\t(ipa_print_node_jump_functions_for_edge): Same.\n+\t(ipa_get_value_range): Same.\n+\t(ipa_compute_jump_functions_for_edge): Same.\n+\t(ipa_write_jump_function): Same.\n+\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Same.\n+\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n+\tSame.\n+\t* vr-values.c (set_value_range_to_nonnegative): Same.\n+\t(set_value_range_to_truthvalue): Same.\n+\t(vr_values::get_value_range): Same.\n+\t(vr_values::set_defs_to_varying): Same.\n+\t(vr_values::update_value_range): Same.\n+\t(symbolic_range_based_on_p): Same.\n+\t(vr_values::op_with_boolean_value_range_p): Same.\n+\t(vr_values::extract_range_for_var_from_comparison_expr): Same.\n+\t(vr_values::extract_range_from_ssa_name): Same.\n+\t(vr_values::extract_range_from_binary_expr): Same.\n+\t(vr_values::extract_range_from_unary_expr): Same.\n+\t(vr_values::extract_range_from_cond_expr): Same.\n+\t(vr_values::extract_range_from_comparison): Same.\n+\t(vr_values::check_for_binary_op_overflow): Same.\n+\t(vr_values::extract_range_basic): Same.\n+\t(vr_values::extract_range_from_assignment): Same.\n+\t(compare_ranges): Same.\n+\t(compare_range_with_value): Same.\n+\t(vr_values::adjust_range_with_scev): Same.\n+\t(vrp_valueize): Same.\n+\t(vrp_valueize_1): Same.\n+\t(vr_values::get_vr_for_comparison): Same.\n+\t(vr_values::compare_name_with_value): Same.\n+\t(vr_values::compare_names): Same.\n+\t(vr_values::vrp_evaluate_conditional): Same.\n+\t(find_case_label_ranges): Same.\n+\t(vr_values::vrp_visit_switch_stmt): Same.\n+\t(vr_values::extract_range_from_phi_node): Same.\n+\t(vr_values::simplify_div_or_mod_using_ranges): Same.\n+\t(vr_values::simplify_bit_ops_using_ranges): Same.\n+\t(test_for_singularity): Same.\n+\t(range_fits_type_p): Same.\n+\t(vr_values::simplify_cond_using_ranges_1): Same.\n+\t(vr_values::simplify_switch_using_ranges): Same.\n+\t(vr_values::simplify_float_conversion_using_ranges): Same.\n+\t(vr_values::two_valued_val_range_p): Same.\n+\t(vr_values::add_equivalence): Move to value_range::equiv_add.\n+\t* vr-values.h (vr_values::add_equivalence): Remove.\n+\t(VR_INITIALIZER): Remove.\n+\t* tree-vrp.c (value_range::set): New.\n+\t(value_range::equiv_add): New.\n+\t(value_range::value_range): New.\n+\t(value_range::deep_copy): New.\n+\t(value_range::check): New.\n+\t(value_range::equal_p): New.\n+\t(value_range::ignore_equivs_equal_p): New.\n+\t(value_range::operator==): New.\n+\t(value_range::operator!=): New.\n+\t(value_range::symbolic_p): New.\n+\t(value_range::numeric_p): New.\n+\t(value_range::set_undefined): New.\n+\t(value_range::set_varying): New.\n+\t(value_range::may_contain_p): New.\n+\t(value_range::equiv_clear): New.\n+\t(value_range::singleton_p): New.\n+\t(value_range::intersect): New.\n+\t(value_range::dump): New.\n+\t(value_range::set_and_canonicalize): New.\n+\t(set_value_range): Adjust for value_range API.\n+\t(set_value_range_to_undefined): Same.\n+\t(set_value_range_to_varying): Same.\n+\t(set_and_canonicalize_value_range): Same.\n+\t(set_value_range_to_nonnull): Same.\n+\t(set_value_range_to_null): Same.\n+\t(range_is_null): Same.\n+\t(range_is_nonnull): Same.\n+\t(range_int_cst_p): Same.\n+\t(range_int_cst_singleton_p): Same.\n+\t(symbolic_range_p): Same.\n+\t(range_includes_zero_p): Same.\n+\t(value_range_constant_singleton): Same.\n+\t(vrp_set_zero_nonzero_bits): Same.\n+\t(ranges_from_anti_range): Same.\n+\t(extract_range_into_wide_ints): Same.\n+\t(extract_range_from_multiplicative_op): Same.\n+\t(set_value_range_with_overflow): Same.\n+\t(extract_range_from_binary_expr_1): Same.\n+\t(extract_range_from_unary_expr): Same.\n+\t(dump_value_range): Same.\n+\t(debug_value_range): Same.\n+\t(vrp_prop::check_array_ref): Same.\n+\t(vrp_prop::check_mem_ref): Same.\n+\t(vrp_prop::vrp_initialize): Same.\n+\t(vrp_prop::visit_stmt): Same.\n+\t(intersect_ranges): Same.\n+\t(vrp_prop::visit_phi): Same.\n+\t(vrp_prop::vrp_finalize): Same.\n+\t(determine_value_range_1): Same.\n+\t(determine_value_range): Same.\n+\t(vrp_intersect_ranges_1): Rename to...\n+\t(vrp_intersect_1): this.\n+\t(vrp_intersect_ranges): Rename to...\n+\t(value_range::intersect_helper): ...this.\n+\t(vrp_meet_1): Rename to...\n+\t(value_range::union_helper): ...this.\n+\t(vrp_meet): Rename to...\n+\t(value_range::union_): ...this.\n+\t(copy_value_range): Remove.\n+\t* tree-vrp.h (struct value_range): Rewrite into a proper class.\n+\t(value_range::vrtype): New.\n+\t(value_range::type): New.\n+\t(value_range::equiv): New.\n+\t(value_range::min): New.\n+\t(value_range::max): New.\n+\t(value_range::varying_p): New.\n+\t(value_range::undefined_p): New.\n+\t(value_range::null_p): New.\n+\t(value_range::equiv_add): New.\n+\t(copy_value_range): Remove.\n+\n 2018-10-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (SELFTEST_TARGETS): New."}, {"sha": "538c4143cbe7928fbdca13a08f714e95e675d6cf", "filename": "gcc/bitmap.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -2164,6 +2164,12 @@ debug (const bitmap_head *ptr)\n     fprintf (stderr, \"<nil>\\n\");\n }\n \n+void\n+bitmap_head::dump ()\n+{\n+  debug (this);\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "57ae4a61086ee44b63d08ee6dafc3ade9169e8e8", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -243,6 +243,7 @@ struct GTY(()) bitmap_head {\n   bitmap_element * GTY((skip(\"\"))) current; /* Last element looked at.  */\n   bitmap_obstack *obstack;\t\t/* Obstack to allocate elements from.\n \t\t\t\t\t   If NULL, then use GGC allocation.  */\n+  void dump ();\n };\n \n /* Global data */"}, {"sha": "f64b3d4065b3f3977dbfe15587c4f49d5fabfb5d", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -3139,7 +3139,7 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n     return NULL_RTX;\n \n   wide_int min, max;\n-  enum value_range_type rng = get_range_info (bound, &min, &max);\n+  enum value_range_kind rng = get_range_info (bound, &min, &max);\n   if (rng != VR_RANGE)\n     return NULL_RTX;\n \n@@ -3227,7 +3227,7 @@ determine_block_size (tree len, rtx len_rtx,\n   else\n     {\n       wide_int min, max;\n-      enum value_range_type range_type = VR_UNDEFINED;\n+      enum value_range_kind range_type = VR_UNDEFINED;\n \n       /* Determine bounds from the type.  */\n       if (tree_fits_uhwi_p (TYPE_MIN_VALUE (TREE_TYPE (len))))\n@@ -3629,7 +3629,7 @@ compute_objsize (tree dest, int ostype)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (off)))\n \t    {\n \t      wide_int min, max;\n-\t      enum value_range_type rng = get_range_info (off, &min, &max);\n+\t      enum value_range_kind rng = get_range_info (off, &min, &max);\n \n \t      if (rng == VR_RANGE)\n \t\t{"}, {"sha": "8978d3b42fdeaa19aa5162d15c963d09ceed80c9", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -1255,7 +1255,7 @@ get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n   bool integral = INTEGRAL_TYPE_P (exptype);\n \n   wide_int min, max;\n-  enum value_range_type range_type;\n+  enum value_range_kind range_type;\n \n   if (integral)\n     range_type = determine_value_range (exp, &min, &max);"}, {"sha": "271cce8e20f1a7cb6a1d9bee34e4092b91f079a2", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -46,6 +46,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef int64_t gcov_type;\n typedef uint64_t gcov_type_unsigned;\n \n+struct bitmap_obstack;\n struct bitmap_head;\n typedef struct bitmap_head *bitmap;\n typedef const struct bitmap_head *const_bitmap;"}, {"sha": "4977eef981021c423b913bc1c8bc1b47df5939f1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -9255,7 +9255,7 @@ bool\n expr_not_equal_to (tree t, const wide_int &w)\n {\n   wide_int min, max, nz;\n-  value_range_type rtype;\n+  value_range_kind rtype;\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:"}, {"sha": "fd48bbf9af4182f9d4f97d59ffa36596ab2ee141", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -649,7 +649,7 @@ size_must_be_zero_p (tree size)\n     return false;\n \n   wide_int min, max;\n-  enum value_range_type rtype = get_range_info (size, &min, &max);\n+  enum value_range_kind rtype = get_range_info (size, &min, &max);\n   if (rtype != VR_ANTI_RANGE)\n     return false;\n "}, {"sha": "7dfec9120ab8ea020e49ed7bdcccc2eaa3b838b6", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -2123,7 +2123,7 @@ dump_ssaname_info (pretty_printer *buffer, tree node, int spc)\n       && SSA_NAME_RANGE_INFO (node))\n     {\n       wide_int min, max, nonzero_bits;\n-      value_range_type range_type = get_range_info (node, &min, &max);\n+      value_range_kind range_type = get_range_info (node, &min, &max);\n \n       if (range_type == VR_VARYING)\n \tpp_printf (buffer, \"# RANGE VR_VARYING\");"}, {"sha": "83917f5eb0ad91a91f91b07f2d83646eef72b6e0", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -82,19 +82,19 @@ value_range *\n evrp_range_analyzer::try_find_new_range (tree name,\n \t\t\t\t    tree op, tree_code code, tree limit)\n {\n-  value_range vr = VR_INITIALIZER;\n+  value_range vr;\n   value_range *old_vr = get_value_range (name);\n \n   /* Discover VR when condition is true.  */\n   vr_values->extract_range_for_var_from_comparison_expr (name, code, op,\n \t\t\t\t\t\t\t limit, &vr);\n   /* If we found any usable VR, set the VR to ssa_name and create a\n      PUSH old value in the stack with the old VR.  */\n-  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+  if (!vr.undefined_p () && !vr.varying_p ())\n     {\n-      if (old_vr->type == vr.type\n-\t  && vrp_operand_equal_p (old_vr->min, vr.min)\n-\t  && vrp_operand_equal_p (old_vr->max, vr.max))\n+      if (old_vr->kind () == vr.kind ()\n+\t  && vrp_operand_equal_p (old_vr->min (), vr.min ())\n+\t  && vrp_operand_equal_p (old_vr->max (), vr.max ()))\n \treturn NULL;\n       value_range *new_vr = vr_values->allocate_value_range ();\n       *new_vr = vr;\n@@ -110,13 +110,10 @@ evrp_range_analyzer::set_ssa_range_info (tree lhs, value_range *vr)\n   /* Set the SSA with the value range.  */\n   if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n     {\n-      if ((vr->type == VR_RANGE\n-\t   || vr->type == VR_ANTI_RANGE)\n-\t  && (TREE_CODE (vr->min) == INTEGER_CST)\n-\t  && (TREE_CODE (vr->max) == INTEGER_CST))\n-\tset_range_info (lhs, vr->type,\n-\t\t\twi::to_wide (vr->min),\n-\t\t\twi::to_wide (vr->max));\n+      if (vr->constant_p ())\n+\tset_range_info (lhs, vr->kind (),\n+\t\t\twi::to_wide (vr->min ()),\n+\t\t\twi::to_wide (vr->max ()));\n     }\n   else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n \t   && range_includes_zero_p (vr) == 0)\n@@ -241,7 +238,7 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n       if (virtual_operand_p (lhs))\n \tcontinue;\n \n-      value_range vr_result = VR_INITIALIZER;\n+      value_range vr_result;\n       bool interesting = stmt_interesting_for_vrp (phi);\n       if (!has_unvisited_preds && interesting)\n \tvr_values->extract_range_from_phi_node (phi, &vr_result);\n@@ -284,7 +281,7 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n   else if (stmt_interesting_for_vrp (stmt))\n     {\n       edge taken_edge;\n-      value_range vr = VR_INITIALIZER;\n+      value_range vr;\n       vr_values->extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n       if (output)\n \t{\n@@ -315,7 +312,7 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \t\t bitmaps.  Ugh.  */\n \t      value_range *new_vr = vr_values->allocate_value_range ();\n \t      *new_vr = vr;\n-\t      new_vr->equiv = NULL;\n+\t      new_vr->equiv_clear ();\n \t      push_value_range (output, new_vr);\n \t    }\n \t}"}, {"sha": "b075c1051d8c0dd4862337f7b918d3a5f77ab818", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -161,8 +161,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t      value_range *vr = evrp_range_analyzer.get_value_range (output);\n \n \t      /* Mark stmts whose output we fully propagate for removal.  */\n-\t      if ((vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE)\n-\t\t  && (val = value_range_constant_singleton (vr))\n+\t      if ((val = value_range_constant_singleton (vr))\n \t\t  && may_propagate_copy (output, val)\n \t\t  && !stmt_could_throw_p (stmt)\n \t\t  && !gimple_has_side_effects (stmt))"}, {"sha": "90f028d50bdbf48dbaf4adb4c6e89aae175ac33c", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -1052,9 +1052,7 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t{\n \t  /* Try to determine the range of values of the integer argument.  */\n \t  value_range *vr = vr_values->get_value_range (arg);\n-\t  if (vr->type == VR_RANGE\n-\t      && TREE_CODE (vr->min) == INTEGER_CST\n-\t      && TREE_CODE (vr->max) == INTEGER_CST)\n+\t  if (range_int_cst_p (vr))\n \t    {\n \t      HOST_WIDE_INT type_min\n \t\t= (TYPE_UNSIGNED (argtype)\n@@ -1063,8 +1061,8 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \n \t      HOST_WIDE_INT type_max = tree_to_uhwi (TYPE_MAX_VALUE (argtype));\n \n-\t      *pmin = TREE_INT_CST_LOW (vr->min);\n-\t      *pmax = TREE_INT_CST_LOW (vr->max);\n+\t      *pmin = TREE_INT_CST_LOW (vr->min ());\n+\t      *pmax = TREE_INT_CST_LOW (vr->max ());\n \n \t      if (*pmin < *pmax)\n \t\t{\n@@ -1354,12 +1352,10 @@ format_integer (const directive &dir, tree arg, vr_values *vr_values)\n       /* Try to determine the range of values of the integer argument\n \t (range information is not available for pointers).  */\n       value_range *vr = vr_values->get_value_range (arg);\n-      if (vr->type == VR_RANGE\n-\t  && TREE_CODE (vr->min) == INTEGER_CST\n-\t  && TREE_CODE (vr->max) == INTEGER_CST)\n+      if (range_int_cst_p (vr))\n \t{\n-\t  argmin = vr->min;\n-\t  argmax = vr->max;\n+\t  argmin = vr->min ();\n+\t  argmax = vr->max ();\n \n \t  /* Set KNOWNRANGE if the argument is in a known subrange\n \t     of the directive's type and neither width nor precision\n@@ -1372,12 +1368,11 @@ format_integer (const directive &dir, tree arg, vr_values *vr_values)\n \t  res.argmin = argmin;\n \t  res.argmax = argmax;\n \t}\n-      else if (vr->type == VR_ANTI_RANGE)\n+      else if (vr->kind () == VR_ANTI_RANGE)\n \t{\n \t  /* Handle anti-ranges if/when bug 71690 is resolved.  */\n \t}\n-      else if (vr->type == VR_VARYING\n-\t       || vr->type == VR_UNDEFINED)\n+      else if (vr->varying_p () || vr->undefined_p ())\n \t{\n \t  /* The argument here may be the result of promoting the actual\n \t     argument to int.  Try to determine the type of the actual\n@@ -3903,12 +3898,10 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t     and use the greater of the two at level 1 and the smaller\n \t     of them at level 2.  */\n \t  value_range *vr = evrp_range_analyzer.get_value_range (size);\n-\t  if (vr->type == VR_RANGE\n-\t      && TREE_CODE (vr->min) == INTEGER_CST\n-\t      && TREE_CODE (vr->max) == INTEGER_CST)\n+\t  if (range_int_cst_p (vr))\n \t    dstsize = (warn_level < 2\n-\t\t       ? TREE_INT_CST_LOW (vr->max)\n-\t\t       : TREE_INT_CST_LOW (vr->min));\n+\t\t       ? TREE_INT_CST_LOW (vr->max ())\n+\t\t       : TREE_INT_CST_LOW (vr->min ()));\n \n \t  /* The destination size is not constant.  If the function is\n \t     bounded (e.g., snprintf) a lower bound of zero doesn't"}, {"sha": "9d2d68ad54bc859f1deca56aeda67b4d29939d9e", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -272,7 +272,7 @@ alloca_call_type_by_arg (tree arg, tree arg_casted, edge e,\n       && TREE_CODE (limit) == SSA_NAME)\n     {\n       wide_int min, max;\n-      value_range_type range_type = get_range_info (limit, &min, &max);\n+      value_range_kind range_type = get_range_info (limit, &min, &max);\n \n       if (range_type == VR_UNDEFINED || range_type == VR_VARYING)\n \treturn alloca_type_and_limit (ALLOCA_BOUND_UNKNOWN);\n@@ -364,7 +364,7 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n   // Check the range info if available.\n   if (TREE_CODE (len) == SSA_NAME)\n     {\n-      value_range_type range_type = get_range_info (len, &min, &max);\n+      value_range_kind range_type = get_range_info (len, &min, &max);\n       if (range_type == VR_RANGE)\n \t{\n \t  if (wi::leu_p (max, max_size))"}, {"sha": "e3cbf42f2d97750601273b84c5a406bbc63b2a8b", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -312,7 +312,7 @@ builtin_memref::extend_offset_range (tree offset)\n   if (TREE_CODE (offset) == SSA_NAME)\n     {\n       wide_int min, max;\n-      value_range_type rng = get_range_info (offset, &min, &max);\n+      value_range_kind rng = get_range_info (offset, &min, &max);\n       if (rng == VR_RANGE)\n \t{\n \t  offrange[0] += offset_int::from (min, SIGNED);"}, {"sha": "4471bae11c7c118f035105071da332d02e9d6f93", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -314,7 +314,7 @@ class ipcp_vr_lattice\n   inline bool set_to_bottom ();\n   bool meet_with (const value_range *p_vr);\n   bool meet_with (const ipcp_vr_lattice &other);\n-  void init () { m_vr.type = VR_UNDEFINED; }\n+  void init () { gcc_assert (m_vr.undefined_p ()); }\n   void print (FILE * f);\n \n private:\n@@ -914,36 +914,29 @@ ipcp_vr_lattice::meet_with (const value_range *p_vr)\n   return meet_with_1 (p_vr);\n }\n \n-/* Meet the current value of the lattice with value ranfge described by\n-   OTHER_VR lattice.  */\n+/* Meet the current value of the lattice with value range described by\n+   OTHER_VR lattice.  Return TRUE if anything changed.  */\n \n bool\n ipcp_vr_lattice::meet_with_1 (const value_range *other_vr)\n {\n-  tree min = m_vr.min, max = m_vr.max;\n-  value_range_type type = m_vr.type;\n-\n   if (bottom_p ())\n     return false;\n \n-  if (other_vr->type == VR_VARYING)\n+  if (other_vr->varying_p ())\n     return set_to_bottom ();\n \n-  vrp_meet (&m_vr, other_vr);\n-  if (type != m_vr.type\n-      || min != m_vr.min\n-      || max != m_vr.max)\n-    return true;\n-  else\n-    return false;\n+  value_range save (m_vr);\n+  m_vr.union_ (other_vr);\n+  return !m_vr.ignore_equivs_equal_p (save);\n }\n \n /* Return true if value range information in the lattice is yet unknown.  */\n \n bool\n ipcp_vr_lattice::top_p () const\n {\n-  return m_vr.type == VR_UNDEFINED;\n+  return m_vr.undefined_p ();\n }\n \n /* Return true if value range information in the lattice is known to be\n@@ -952,7 +945,7 @@ ipcp_vr_lattice::top_p () const\n bool\n ipcp_vr_lattice::bottom_p () const\n {\n-  return m_vr.type == VR_VARYING;\n+  return m_vr.varying_p ();\n }\n \n /* Set value range information in the lattice to bottom.  Return true if it\n@@ -961,9 +954,9 @@ ipcp_vr_lattice::bottom_p () const\n bool\n ipcp_vr_lattice::set_to_bottom ()\n {\n-  if (m_vr.type == VR_VARYING)\n+  if (m_vr.varying_p ())\n     return false;\n-  m_vr.type = VR_VARYING;\n+  m_vr.set_varying ();\n   return true;\n }\n \n@@ -1882,12 +1875,11 @@ ipa_vr_operation_and_type_effects (value_range *dst_vr, value_range *src_vr,\n \t\t\t\t   enum tree_code operation,\n \t\t\t\t   tree dst_type, tree src_type)\n {\n-  memset (dst_vr, 0, sizeof (*dst_vr));\n+  *dst_vr = value_range ();\n   extract_range_from_unary_expr (dst_vr, operation, dst_type, src_vr, src_type);\n-  if (dst_vr->type == VR_RANGE || dst_vr->type == VR_ANTI_RANGE)\n-    return true;\n-  else\n+  if (dst_vr->varying_p () || dst_vr->undefined_p ())\n     return false;\n+  return true;\n }\n \n /* Propagate value range across jump function JFUNC that is associated with\n@@ -1940,11 +1932,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t  if (TREE_OVERFLOW_P (val))\n \t    val = drop_tree_overflow (val);\n \n-\t  value_range tmpvr;\n-\t  memset (&tmpvr, 0, sizeof (tmpvr));\n-\t  tmpvr.type = VR_RANGE;\n-\t  tmpvr.min = val;\n-\t  tmpvr.max = val;\n+\t  value_range tmpvr (VR_RANGE, val, val);\n \t  return dest_lat->meet_with (&tmpvr);\n \t}\n     }\n@@ -1953,7 +1941,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n   if (jfunc->m_vr\n       && ipa_vr_operation_and_type_effects (&vr, jfunc->m_vr, NOP_EXPR,\n \t\t\t\t\t    param_type,\n-\t\t\t\t\t    TREE_TYPE (jfunc->m_vr->min)))\n+\t\t\t\t\t    jfunc->m_vr->type ()))\n     return dest_lat->meet_with (&vr);\n   else\n     return dest_lat->set_to_bottom ();\n@@ -5028,9 +5016,9 @@ ipcp_store_vr_results (void)\n \t      && !plats->m_value_range.top_p ())\n \t    {\n \t      vr.known = true;\n-\t      vr.type = plats->m_value_range.m_vr.type;\n-\t      vr.min = wi::to_wide (plats->m_value_range.m_vr.min);\n-\t      vr.max = wi::to_wide (plats->m_value_range.m_vr.max);\n+\t      vr.type = plats->m_value_range.m_vr.kind ();\n+\t      vr.min = wi::to_wide (plats->m_value_range.m_vr.min ());\n+\t      vr.max = wi::to_wide (plats->m_value_range.m_vr.max ());\n \t    }\n \t  else\n \t    {"}, {"sha": "1e40997c92c1d3c0f78e05a319fc27e49a53ce01", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -113,16 +113,16 @@ struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range *>\n   static hashval_t\n   hash (const value_range *p)\n     {\n-      gcc_checking_assert (!p->equiv);\n-      inchash::hash hstate (p->type);\n-      hstate.add_ptr (p->min);\n-      hstate.add_ptr (p->max);\n+      gcc_checking_assert (!p->equiv ());\n+      inchash::hash hstate (p->kind ());\n+      hstate.add_ptr (p->min ());\n+      hstate.add_ptr (p->max ());\n       return hstate.end ();\n     }\n   static bool\n   equal (const value_range *a, const value_range *b)\n     {\n-      return a->type == b->type && a->min == b->min && a->max == b->max;\n+      return a->ignore_equivs_equal_p (*b);\n     }\n   static void\n   mark_empty (value_range *&p)\n@@ -398,10 +398,10 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t{\n \t  fprintf (f, \"         VR  \");\n \t  fprintf (f, \"%s[\",\n-\t\t   (jump_func->m_vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n-\t  print_decs (wi::to_wide (jump_func->m_vr->min), f);\n+\t\t   (jump_func->m_vr->kind () == VR_ANTI_RANGE) ? \"~\" : \"\");\n+\t  print_decs (wi::to_wide (jump_func->m_vr->min ()), f);\n \t  fprintf (f, \", \");\n-\t  print_decs (wi::to_wide (jump_func->m_vr->max), f);\n+\t  print_decs (wi::to_wide (jump_func->m_vr->max ()), f);\n \t  fprintf (f, \"]\\n\");\n \t}\n       else\n@@ -1789,13 +1789,9 @@ ipa_get_value_range (value_range *tmp)\n    value_ranges.  */\n \n static value_range *\n-ipa_get_value_range (enum value_range_type type, tree min, tree max)\n+ipa_get_value_range (enum value_range_kind type, tree min, tree max)\n {\n-  value_range tmp;\n-  tmp.type = type;\n-  tmp.min = min;\n-  tmp.max = max;\n-  tmp.equiv = NULL;\n+  value_range tmp (type, min, max);\n   return ipa_get_value_range (&tmp);\n }\n \n@@ -1804,7 +1800,7 @@ ipa_get_value_range (enum value_range_type type, tree min, tree max)\n    same value_range structures.  */\n \n static void\n-ipa_set_jfunc_vr (ipa_jump_func *jf, enum value_range_type type,\n+ipa_set_jfunc_vr (ipa_jump_func *jf, enum value_range_kind type,\n \t\t  tree min, tree max)\n {\n   jf->m_vr = ipa_get_value_range (type, min, max);\n@@ -1884,22 +1880,19 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n       else\n \t{\n \t  wide_int min, max;\n-\t  value_range_type type;\n+\t  value_range_kind type;\n \t  if (TREE_CODE (arg) == SSA_NAME\n \t      && param_type\n \t      && (type = get_range_info (arg, &min, &max))\n \t      && (type == VR_RANGE || type == VR_ANTI_RANGE))\n \t    {\n-\t      value_range tmpvr,resvr;\n-\n-\t      tmpvr.type = type;\n-\t      tmpvr.min = wide_int_to_tree (TREE_TYPE (arg), min);\n-\t      tmpvr.max = wide_int_to_tree (TREE_TYPE (arg), max);\n-\t      tmpvr.equiv = NULL;\n-\t      memset (&resvr, 0, sizeof (resvr));\n+\t      value_range resvr;\n+\t      value_range tmpvr (type,\n+\t\t\t\t wide_int_to_tree (TREE_TYPE (arg), min),\n+\t\t\t\t wide_int_to_tree (TREE_TYPE (arg), max));\n \t      extract_range_from_unary_expr (&resvr, NOP_EXPR, param_type,\n \t\t\t\t\t     &tmpvr, TREE_TYPE (arg));\n-\t      if (resvr.type == VR_RANGE || resvr.type == VR_ANTI_RANGE)\n+\t      if (!resvr.undefined_p () && !resvr.varying_p ())\n \t\tipa_set_jfunc_vr (jfunc, &resvr);\n \t      else\n \t\tgcc_assert (!jfunc->m_vr);\n@@ -4126,9 +4119,9 @@ ipa_write_jump_function (struct output_block *ob,\n   if (jump_func->m_vr)\n     {\n       streamer_write_enum (ob->main_stream, value_rang_type,\n-\t\t\t   VR_LAST, jump_func->m_vr->type);\n-      stream_write_tree (ob, jump_func->m_vr->min, true);\n-      stream_write_tree (ob, jump_func->m_vr->max, true);\n+\t\t\t   VR_LAST, jump_func->m_vr->kind ());\n+      stream_write_tree (ob, jump_func->m_vr->min (), true);\n+      stream_write_tree (ob, jump_func->m_vr->max (), true);\n     }\n }\n \n@@ -4216,7 +4209,7 @@ ipa_read_jump_function (struct lto_input_block *ib,\n   bool vr_known = bp_unpack_value (&vr_bp, 1);\n   if (vr_known)\n     {\n-      enum value_range_type type = streamer_read_enum (ib, value_range_type,\n+      enum value_range_kind type = streamer_read_enum (ib, value_range_kind,\n \t\t\t\t\t\t       VR_LAST);\n       tree min = stream_read_tree (ib, data_in);\n       tree max = stream_read_tree (ib, data_in);\n@@ -4647,7 +4640,7 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n \t  parm_vr->known = bp_unpack_value (&bp, 1);\n \t  if (parm_vr->known)\n \t    {\n-\t      parm_vr->type = streamer_read_enum (ib, value_range_type,\n+\t      parm_vr->type = streamer_read_enum (ib, value_range_kind,\n \t\t\t\t\t\t  VR_LAST);\n \t      parm_vr->min = streamer_read_wide_int (ib);\n \t      parm_vr->max = streamer_read_wide_int (ib);"}, {"sha": "8a53bb89f3fe7acb02d7279e728523bca5f0860d", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -160,7 +160,7 @@ struct GTY(()) ipa_vr\n {\n   /* The data fields below are valid only if known is true.  */\n   bool known;\n-  enum value_range_type type;\n+  enum value_range_kind type;\n   wide_int min;\n   wide_int max;\n };"}, {"sha": "66e780d635a1ada389e2d6f3c079901ed6e57f0d", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -721,7 +721,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\tif (TREE_CODE (tmp_var) != SSA_NAME)\n \t\t  return false;\n \t\twide_int var_min, var_max;\n-\t\tvalue_range_type vr_type = get_range_info (tmp_var, &var_min,\n+\t\tvalue_range_kind vr_type = get_range_info (tmp_var, &var_min,\n \t\t\t\t\t\t\t   &var_max);\n \t\twide_int var_nonzero = get_nonzero_bits (tmp_var);\n \t\tsignop sgn = TYPE_SIGN (itype);"}, {"sha": "c50618dc8097cc9bb6e3a658fcbc918a621d9cb5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -882,33 +882,35 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n \treturn NULL_TREE;\n \n       value_range *vr = x_vr_values->get_value_range (op);\n-      if ((vr->type != VR_RANGE && vr->type != VR_ANTI_RANGE)\n-\t  || symbolic_range_p (vr))\n+      if (vr->undefined_p ()\n+\t  || vr->varying_p ()\n+\t  || vr->symbolic_p ())\n \treturn NULL_TREE;\n \n-      if (vr->type == VR_RANGE)\n+      if (vr->kind () == VR_RANGE)\n \t{\n \t  size_t i, j;\n \n-\t  find_case_label_range (switch_stmt, vr->min, vr->max, &i, &j);\n+\t  find_case_label_range (switch_stmt, vr->min (), vr->max (), &i, &j);\n \n \t  if (i == j)\n \t    {\n \t      tree label = gimple_switch_label (switch_stmt, i);\n+\t      tree singleton;\n \n \t      if (CASE_HIGH (label) != NULL_TREE\n-\t\t  ? (tree_int_cst_compare (CASE_LOW (label), vr->min) <= 0\n-\t\t     && tree_int_cst_compare (CASE_HIGH (label), vr->max) >= 0)\n-\t\t  : (tree_int_cst_equal (CASE_LOW (label), vr->min)\n-\t\t     && tree_int_cst_equal (vr->min, vr->max)))\n+\t\t  ? (tree_int_cst_compare (CASE_LOW (label), vr->min ()) <= 0\n+\t\t     && tree_int_cst_compare (CASE_HIGH (label), vr->max ()) >= 0)\n+\t\t  : (vr->singleton_p (&singleton)\n+\t\t     && tree_int_cst_equal (CASE_LOW (label), singleton)))\n \t\treturn label;\n \n \t      if (i > j)\n \t\treturn gimple_switch_label (switch_stmt, 0);\n \t    }\n \t}\n \n-      if (vr->type == VR_ANTI_RANGE)\n+      if (vr->kind () == VR_ANTI_RANGE)\n           {\n             unsigned n = gimple_switch_num_labels (switch_stmt);\n             tree min_label = gimple_switch_label (switch_stmt, 1);\n@@ -917,10 +919,10 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n             /* The default label will be taken only if the anti-range of the\n                operand is entirely outside the bounds of all the (non-default)\n                case labels.  */\n-            if (tree_int_cst_compare (vr->min, CASE_LOW (min_label)) <= 0\n+            if (tree_int_cst_compare (vr->min (), CASE_LOW (min_label)) <= 0\n                 && (CASE_HIGH (max_label) != NULL_TREE\n-                    ? tree_int_cst_compare (vr->max, CASE_HIGH (max_label)) >= 0\n-                    : tree_int_cst_compare (vr->max, CASE_LOW (max_label)) >= 0))\n+                    ? tree_int_cst_compare (vr->max (), CASE_HIGH (max_label)) >= 0\n+                    : tree_int_cst_compare (vr->max (), CASE_LOW (max_label)) >= 0))\n             return gimple_switch_label (switch_stmt, 0);\n           }\n \treturn NULL_TREE;\n@@ -936,11 +938,12 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n \t{\n \t  edge dummy_e;\n \t  tree dummy_tree;\n-\t  value_range new_vr = VR_INITIALIZER;\n+\t  value_range new_vr;\n \t  x_vr_values->extract_range_from_stmt (stmt, &dummy_e,\n \t\t\t\t\t      &dummy_tree, &new_vr);\n-\t  if (range_int_cst_singleton_p (&new_vr))\n-\t    return new_vr.min;\n+\t  tree singleton;\n+\t  if (new_vr.singleton_p (&singleton))\n+\t    return singleton;\n \t}\n     }\n   return NULL;"}, {"sha": "e2bc936ed52b9fb2f3cb675f564df8c1958ac812", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -353,7 +353,7 @@ determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n   mpz_t minm, maxm;\n   basic_block bb;\n   wide_int minv, maxv;\n-  enum value_range_type rtype = VR_VARYING;\n+  enum value_range_kind rtype = VR_VARYING;\n \n   /* If the expression is a constant, we know its value exactly.  */\n   if (integer_zerop (var))\n@@ -4673,7 +4673,7 @@ scev_var_range_cant_overflow (tree var, tree step, struct loop *loop)\n {\n   tree type;\n   wide_int minv, maxv, diff, step_wi;\n-  enum value_range_type rtype;\n+  enum value_range_kind rtype;\n \n   if (TREE_CODE (step) != INTEGER_CST || !INTEGRAL_TYPE_P (TREE_TYPE (var)))\n     return false;"}, {"sha": "2db2823553ba455dd2914857aba422e52e7f391c", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -1200,7 +1200,7 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n       else if (TREE_CODE (bound) == SSA_NAME)\n \t{\n \t  wide_int minbound, maxbound;\n-\t  value_range_type rng = get_range_info (bound, &minbound, &maxbound);\n+\t  value_range_kind rng = get_range_info (bound, &minbound, &maxbound);\n \t  if (rng == VR_RANGE)\n \t    {\n \t      /* For a bound in a known range, adjust the range determined\n@@ -1856,7 +1856,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n     cntrange[0] = cntrange[1] = wi::to_wide (cnt);\n   else if (TREE_CODE (cnt) == SSA_NAME)\n     {\n-      enum value_range_type rng = get_range_info (cnt, cntrange, cntrange + 1);\n+      enum value_range_kind rng = get_range_info (cnt, cntrange, cntrange + 1);\n       if (rng == VR_RANGE)\n \t;\n       else if (rng == VR_ANTI_RANGE)\n@@ -3682,7 +3682,7 @@ strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n \t\t\t   if we don't have anything better.  */\n \t\t\twide_int min, max;\n \t\t\ttree type = TREE_TYPE (lhs);\n-\t\t\tenum value_range_type vr\n+\t\t\tenum value_range_kind vr\n \t\t\t  = get_range_info (lhs, &min, &max);\n \t\t\tif (vr == VR_VARYING\n \t\t\t    || (vr == VR_RANGE"}, {"sha": "0b1f9733fdd3a552eb4020f1a9422f9cda2a8a5d", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -166,7 +166,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t     away in the VR stack.  */\n \t  vr_values *vr_values = evrp_range_analyzer->get_vr_values ();\n \t  value_range *new_vr = vr_values->allocate_value_range ();\n-\t  memset (new_vr, 0, sizeof (value_range));\n+\t  *new_vr = value_range ();\n \n \t  /* There are three cases to consider:\n \n@@ -179,7 +179,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t       Otherwise set NEW_VR to varying.  This may be overly\n \t       conservative.  */\n \t  if (TREE_CODE (src) == SSA_NAME)\n-\t    copy_value_range (new_vr, vr_values->get_value_range (src));\n+\t    new_vr->deep_copy (vr_values->get_value_range (src));\n \t  else if (TREE_CODE (src) == INTEGER_CST)\n \t    set_value_range_to_value (new_vr, src,  NULL);\n \t  else"}, {"sha": "66b2941fbf5af5359efee50b08ef826b941d1075", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -331,7 +331,7 @@ make_ssa_name_fn (struct function *fn, tree var, gimple *stmt,\n    NAME.  */\n \n void\n-set_range_info_raw (tree name, enum value_range_type range_type,\n+set_range_info_raw (tree name, enum value_range_kind range_type,\n \t\t    const wide_int_ref &min, const wide_int_ref &max)\n {\n   gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n@@ -372,7 +372,7 @@ set_range_info_raw (tree name, enum value_range_type range_type,\n    NAME while making sure we don't store useless range info.  */\n \n void\n-set_range_info (tree name, enum value_range_type range_type,\n+set_range_info (tree name, enum value_range_kind range_type,\n \t\tconst wide_int_ref &min, const wide_int_ref &max)\n {\n   gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n@@ -397,11 +397,11 @@ set_range_info (tree name, enum value_range_type range_type,\n }\n \n \n-/* Gets range information MIN, MAX and returns enum value_range_type\n-   corresponding to tree ssa_name NAME.  enum value_range_type returned\n+/* Gets range information MIN, MAX and returns enum value_range_kind\n+   corresponding to tree ssa_name NAME.  enum value_range_kind returned\n    is used to determine if MIN and MAX are valid values.  */\n \n-enum value_range_type\n+enum value_range_kind\n get_range_info (const_tree name, wide_int *min, wide_int *max)\n {\n   gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n@@ -727,7 +727,7 @@ duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)\n /* Creates a duplicate of the range_info_def at RANGE_INFO of type\n    RANGE_TYPE for use by the SSA name NAME.  */\n void\n-duplicate_ssa_name_range_info (tree name, enum value_range_type range_type,\n+duplicate_ssa_name_range_info (tree name, enum value_range_kind range_type,\n \t\t\t       struct range_info_def *range_info)\n {\n   struct range_info_def *new_range_info;"}, {"sha": "18a001a5461651336af288b942f2a234761fa0de", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -67,13 +67,13 @@ struct GTY ((variable_size)) range_info_def {\n     if (VAR)\n \n /* Sets the value range to SSA.  */\n-extern void set_range_info (tree, enum value_range_type, const wide_int_ref &,\n+extern void set_range_info (tree, enum value_range_kind, const wide_int_ref &,\n \t\t\t    const wide_int_ref &);\n-extern void set_range_info_raw (tree, enum value_range_type,\n+extern void set_range_info_raw (tree, enum value_range_kind,\n \t\t\t\tconst wide_int_ref &,\n \t\t\t\tconst wide_int_ref &);\n /* Gets the value range from SSA.  */\n-extern enum value_range_type get_range_info (const_tree, wide_int *,\n+extern enum value_range_kind get_range_info (const_tree, wide_int *,\n \t\t\t\t\t     wide_int *);\n extern void set_nonzero_bits (tree, const wide_int_ref &);\n extern wide_int get_nonzero_bits (const_tree);\n@@ -97,7 +97,7 @@ extern bool get_ptr_nonnull (const_tree);\n extern tree copy_ssa_name_fn (struct function *, tree, gimple *);\n extern void duplicate_ssa_name_ptr_info (tree, struct ptr_info_def *);\n extern tree duplicate_ssa_name_fn (struct function *, tree, gimple *);\n-extern void duplicate_ssa_name_range_info (tree, enum value_range_type,\n+extern void duplicate_ssa_name_range_info (tree, enum value_range_kind,\n \t\t\t\t\t   struct range_info_def *);\n extern void reset_flow_sensitive_info (tree);\n extern void reset_flow_sensitive_info_in_bb (basic_block);"}, {"sha": "2be94566270a5997f4a7438913bcaad3561b0467", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -53,7 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n static bool\n vect_get_range_info (tree var, wide_int *min_value, wide_int *max_value)\n {\n-  value_range_type vr_type = get_range_info (var, min_value, max_value);\n+  value_range_kind vr_type = get_range_info (var, min_value, max_value);\n   wide_int nonzero = get_nonzero_bits (var);\n   signop sgn = TYPE_SIGN (TREE_TYPE (var));\n   if (intersect_range_with_nonzero_bits (vr_type, min_value, max_value,"}, {"sha": "d3276397d8bde4642d1dc6e2ad6606d1080fd9af", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 593, "deletions": 433, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -73,6 +73,303 @@ along with GCC; see the file COPYING3.  If not see\n    for still active basic-blocks.  */\n static sbitmap *live;\n \n+/* Initialize value_range.  */\n+\n+void\n+value_range::set (enum value_range_kind kind, tree min, tree max,\n+\t\t  bitmap equiv)\n+{\n+  m_kind = kind;\n+  m_min = min;\n+  m_max = max;\n+\n+  /* Since updating the equivalence set involves deep copying the\n+     bitmaps, only do it if absolutely necessary.\n+\n+     All equivalence bitmaps are allocated from the same obstack.  So\n+     we can use the obstack associated with EQUIV to allocate vr->equiv.  */\n+  if (m_equiv == NULL\n+      && equiv != NULL)\n+    m_equiv = BITMAP_ALLOC (equiv->obstack);\n+\n+  if (equiv != m_equiv)\n+    {\n+      if (equiv && !bitmap_empty_p (equiv))\n+\tbitmap_copy (m_equiv, equiv);\n+      else\n+\tbitmap_clear (m_equiv);\n+    }\n+  if (flag_checking)\n+    check ();\n+}\n+\n+value_range::value_range (value_range_kind kind, tree min, tree max,\n+\t\t\t  bitmap equiv)\n+{\n+  m_equiv = NULL;\n+  set (kind, min, max, equiv);\n+}\n+\n+/* Like above, but keep the equivalences intact.  */\n+\n+void\n+value_range::update (value_range_kind kind, tree min, tree max)\n+{\n+  set (kind, min, max, m_equiv);\n+}\n+\n+/* Copy value_range in FROM into THIS while avoiding bitmap sharing.\n+\n+   Note: The code that avoids the bitmap sharing looks at the existing\n+   this->m_equiv, so this function cannot be used to initalize an\n+   object.  Use the constructors for initialization.  */\n+\n+void\n+value_range::deep_copy (const value_range *from)\n+{\n+  set (from->m_kind, from->min (), from->max (), from->m_equiv);\n+}\n+\n+/* Check the validity of the range.  */\n+\n+void\n+value_range::check ()\n+{\n+  switch (m_kind)\n+    {\n+    case VR_RANGE:\n+    case VR_ANTI_RANGE:\n+      {\n+\tint cmp;\n+\n+\tgcc_assert (m_min && m_max);\n+\n+\tgcc_assert (!TREE_OVERFLOW_P (m_min) && !TREE_OVERFLOW_P (m_max));\n+\n+\t/* Creating ~[-MIN, +MAX] is stupid because that would be\n+\t   the empty set.  */\n+\tif (INTEGRAL_TYPE_P (TREE_TYPE (m_min)) && m_kind == VR_ANTI_RANGE)\n+\t  gcc_assert (!vrp_val_is_min (m_min) || !vrp_val_is_max (m_max));\n+\n+\tcmp = compare_values (m_min, m_max);\n+\tgcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n+\tbreak;\n+      }\n+    case VR_UNDEFINED:\n+    case VR_VARYING:\n+      gcc_assert (!m_min && !m_max);\n+      gcc_assert (!m_equiv || bitmap_empty_p (m_equiv));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Returns TRUE if THIS == OTHER.  Ignores the equivalence bitmap if\n+   IGNORE_EQUIVS is TRUE.  */\n+\n+bool\n+value_range::equal_p (const value_range &other, bool ignore_equivs) const\n+{\n+  return (m_kind == other.m_kind\n+\t  && vrp_operand_equal_p (m_min, other.m_min)\n+\t  && vrp_operand_equal_p (m_max, other.m_max)\n+\t  && (ignore_equivs\n+\t      || vrp_bitmap_equal_p (m_equiv, other.m_equiv)));\n+}\n+\n+/* Return equality while ignoring equivalence bitmap.  */\n+\n+bool\n+value_range::ignore_equivs_equal_p (const value_range &other) const\n+{\n+  return equal_p (other, /*ignore_equivs=*/true);\n+}\n+\n+bool\n+value_range::operator== (const value_range &other) const\n+{\n+  return equal_p (other, /*ignore_equivs=*/false);\n+}\n+\n+bool\n+value_range::operator!= (const value_range &other) const\n+{\n+  return !(*this == other);\n+}\n+\n+/* Return TRUE if this is a symbolic range.  */\n+\n+bool\n+value_range::symbolic_p () const\n+{\n+  return (!varying_p ()\n+\t  && !undefined_p ()\n+\t  && (!is_gimple_min_invariant (m_min)\n+\t      || !is_gimple_min_invariant (m_max)));\n+}\n+\n+/* NOTE: This is not the inverse of symbolic_p because the range\n+   could also be varying or undefined.  Ideally they should be inverse\n+   of each other, with varying only applying to symbolics.  Varying of\n+   constants would be represented as [-MIN, +MAX].  */\n+\n+bool\n+value_range::constant_p () const\n+{\n+  return (!varying_p ()\n+\t  && !undefined_p ()\n+\t  && TREE_CODE (m_min) == INTEGER_CST\n+\t  && TREE_CODE (m_max) == INTEGER_CST);\n+}\n+\n+void\n+value_range::set_undefined ()\n+{\n+  equiv_clear ();\n+  *this = value_range (VR_UNDEFINED, NULL, NULL, NULL);\n+}\n+\n+void\n+value_range::set_varying ()\n+{\n+  equiv_clear ();\n+  *this = value_range (VR_VARYING, NULL, NULL, NULL);\n+}\n+\n+/* Return TRUE if it is possible that range contains VAL.  */\n+\n+bool\n+value_range::may_contain_p (tree val) const\n+{\n+  if (varying_p ())\n+    return true;\n+\n+  if (undefined_p ())\n+    return true;\n+\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      int res = value_inside_range (val, m_min, m_max);\n+      return res == 0 || res == -2;\n+    }\n+  return value_inside_range (val, m_min, m_max) != 0;\n+}\n+\n+void\n+value_range::equiv_clear ()\n+{\n+  if (m_equiv)\n+    bitmap_clear (m_equiv);\n+}\n+\n+/* Add VAR and VAR's equivalence set (VAR_VR) to the equivalence\n+   bitmap.  If no equivalence table has been created, OBSTACK is the\n+   obstack to use (NULL for the default obstack).\n+\n+   This is the central point where equivalence processing can be\n+   turned on/off.  */\n+\n+void\n+value_range::equiv_add (const_tree var,\n+\t\t\tconst value_range *var_vr,\n+\t\t\tbitmap_obstack *obstack)\n+{\n+  if (!m_equiv)\n+    m_equiv = BITMAP_ALLOC (obstack);\n+  unsigned ver = SSA_NAME_VERSION (var);\n+  bitmap_set_bit (m_equiv, ver);\n+  if (var_vr && var_vr->m_equiv)\n+    bitmap_ior_into (m_equiv, var_vr->m_equiv);\n+}\n+\n+/* If range is a singleton, place it in RESULT and return TRUE.\n+   Note: A singleton can be any gimple invariant, not just constants.\n+   So, [&x, &x] counts as a singleton.  */\n+\n+bool\n+value_range::singleton_p (tree *result) const\n+{\n+  if (m_kind == VR_RANGE\n+      && vrp_operand_equal_p (m_min, m_max)\n+      && is_gimple_min_invariant (m_min))\n+    {\n+      if (result)\n+        *result = m_min;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+tree\n+value_range::type () const\n+{\n+  /* Types are only valid for VR_RANGE and VR_ANTI_RANGE, which are\n+     known to have non-zero min/max.  */\n+  gcc_assert (m_min);\n+  return TREE_TYPE (m_min);\n+}\n+\n+/* Dump value range to FILE.  */\n+\n+void\n+value_range::dump (FILE *file) const\n+{\n+  if (undefined_p ())\n+    fprintf (file, \"UNDEFINED\");\n+  else if (m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n+    {\n+      tree type = TREE_TYPE (min ());\n+\n+      fprintf (file, \"%s[\", (m_kind == VR_ANTI_RANGE) ? \"~\" : \"\");\n+\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && !TYPE_UNSIGNED (type)\n+\t  && vrp_val_is_min (min ()))\n+\tfprintf (file, \"-INF\");\n+      else\n+\tprint_generic_expr (file, min ());\n+\n+      fprintf (file, \", \");\n+\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && vrp_val_is_max (max ()))\n+\tfprintf (file, \"+INF\");\n+      else\n+\tprint_generic_expr (file, max ());\n+\n+      fprintf (file, \"]\");\n+\n+      if (m_equiv)\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned i, c = 0;\n+\n+\t  fprintf (file, \"  EQUIVALENCES: { \");\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (m_equiv, 0, i, bi)\n+\t    {\n+\t      print_generic_expr (file, ssa_name (i));\n+\t      fprintf (file, \" \");\n+\t      c++;\n+\t    }\n+\n+\t  fprintf (file, \"} (%u elements)\", c);\n+\t}\n+    }\n+  else if (varying_p ())\n+    fprintf (file, \"VARYING\");\n+  else\n+    fprintf (file, \"INVALID RANGE\");\n+}\n+\n+void\n+value_range::dump () const\n+{\n+  dump_value_range (stderr, this);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n /* Return true if the SSA name NAME is live on the edge E.  */\n \n static bool\n@@ -175,8 +472,8 @@ vrp_val_is_min (const_tree val)\n \n    SGN gives the sign of the values described by the range.  */\n \n-enum value_range_type\n-intersect_range_with_nonzero_bits (enum value_range_type vr_type,\n+enum value_range_kind\n+intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n \t\t\t\t   wide_int *min, wide_int *max,\n \t\t\t\t   const wide_int &nonzero_bits,\n \t\t\t\t   signop sgn)\n@@ -245,78 +542,29 @@ intersect_range_with_nonzero_bits (enum value_range_type vr_type,\n static inline void\n set_value_range_to_undefined (value_range *vr)\n {\n-  vr->type = VR_UNDEFINED;\n-  vr->min = vr->max = NULL_TREE;\n-  if (vr->equiv)\n-    bitmap_clear (vr->equiv);\n+  vr->set_undefined ();\n }\n \n /* Set value range VR to VR_VARYING.  */\n \n void\n set_value_range_to_varying (value_range *vr)\n {\n-  vr->type = VR_VARYING;\n-  vr->min = vr->max = NULL_TREE;\n-  if (vr->equiv)\n-    bitmap_clear (vr->equiv);\n+  vr->set_varying ();\n }\n \n /* Set value range VR to {T, MIN, MAX, EQUIV}.  */\n \n void\n-set_value_range (value_range *vr, enum value_range_type t, tree min,\n-\t\t tree max, bitmap equiv)\n+set_value_range (value_range *vr, enum value_range_kind kind,\n+\t\t tree min, tree max, bitmap equiv)\n {\n-  /* Check the validity of the range.  */\n-  if (flag_checking\n-      && (t == VR_RANGE || t == VR_ANTI_RANGE))\n-    {\n-      int cmp;\n-\n-      gcc_assert (min && max);\n-\n-      gcc_assert (!TREE_OVERFLOW_P (min) && !TREE_OVERFLOW_P (max));\n-\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (min)) && t == VR_ANTI_RANGE)\n-\tgcc_assert (!vrp_val_is_min (min) || !vrp_val_is_max (max));\n-\n-      cmp = compare_values (min, max);\n-      gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n-    }\n-\n-  if (flag_checking\n-      && (t == VR_UNDEFINED || t == VR_VARYING))\n-    {\n-      gcc_assert (min == NULL_TREE && max == NULL_TREE);\n-      gcc_assert (equiv == NULL || bitmap_empty_p (equiv));\n-    }\n-\n-  vr->type = t;\n-  vr->min = min;\n-  vr->max = max;\n-\n-  /* Since updating the equivalence set involves deep copying the\n-     bitmaps, only do it if absolutely necessary.\n-\n-     All equivalence bitmaps are allocated from the same obstack.  So\n-     we can use the obstack associated with EQUIV to allocate vr->equiv.  */\n-  if (vr->equiv == NULL\n-      && equiv != NULL)\n-    vr->equiv = BITMAP_ALLOC (equiv->obstack);\n-\n-  if (equiv != vr->equiv)\n-    {\n-      if (equiv && !bitmap_empty_p (equiv))\n-\tbitmap_copy (vr->equiv, equiv);\n-      else\n-\tbitmap_clear (vr->equiv);\n-    }\n+  *vr = value_range (kind, min, max, equiv);\n }\n \n \n-/* Set value range VR to the canonical form of {T, MIN, MAX, EQUIV}.\n-   This means adjusting T, MIN and MAX representing the case of a\n+/* Set value range to the canonical form of {VRTYPE, MIN, MAX, EQUIV}.\n+   This means adjusting VRTYPE, MIN and MAX representing the case of a\n    wrapping range with MAX < MIN covering [MIN, type_max] U [type_min, MAX]\n    as anti-rage ~[MAX+1, MIN-1].  Likewise for wrapping anti-ranges.\n    In corner cases where MAX+1 or MIN-1 wraps this will fall back\n@@ -325,26 +573,26 @@ set_value_range (value_range *vr, enum value_range_type t, tree min,\n    extract ranges from var + CST op limit.  */\n \n void\n-set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,\n-\t\t\t\t  tree min, tree max, bitmap equiv)\n+value_range::set_and_canonicalize (enum value_range_kind kind,\n+\t\t\t\t   tree min, tree max, bitmap equiv)\n {\n   /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n-  if (t == VR_UNDEFINED)\n+  if (kind == VR_UNDEFINED)\n     {\n-      set_value_range_to_undefined (vr);\n+      set_undefined ();\n       return;\n     }\n-  else if (t == VR_VARYING)\n+  else if (kind == VR_VARYING)\n     {\n-      set_value_range_to_varying (vr);\n+      set_varying ();\n       return;\n     }\n \n   /* Nothing to canonicalize for symbolic ranges.  */\n   if (TREE_CODE (min) != INTEGER_CST\n       || TREE_CODE (max) != INTEGER_CST)\n     {\n-      set_value_range (vr, t, min, max, equiv);\n+      set_value_range (this, kind, min, max, equiv);\n       return;\n     }\n \n@@ -359,7 +607,7 @@ set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,\n \t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n       if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n \t{\n-\t  set_value_range_to_varying (vr);\n+\t  set_varying ();\n \t  return;\n \t}\n \n@@ -373,15 +621,15 @@ set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,\n \t to varying in this case.  */\n       if (tree_int_cst_lt (max, min))\n \t{\n-\t  set_value_range_to_varying (vr);\n+\t  set_varying ();\n \t  return;\n \t}\n \n-      t = t == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n+      kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n     }\n \n   /* Anti-ranges that can be represented as ranges should be so.  */\n-  if (t == VR_ANTI_RANGE)\n+  if (kind == VR_ANTI_RANGE)\n     {\n       /* For -fstrict-enums we may receive out-of-range ranges so consider\n          values < -INF and values > INF as -INF/INF as well.  */\n@@ -395,7 +643,7 @@ set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,\n \t{\n \t  /* We cannot deal with empty ranges, drop to varying.\n \t     ???  This could be VR_UNDEFINED instead.  */\n-\t  set_value_range_to_varying (vr);\n+\t  set_varying ();\n \t  return;\n \t}\n       else if (TYPE_PRECISION (TREE_TYPE (min)) == 1\n@@ -407,7 +655,7 @@ set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,\n \t    min = max = vrp_val_max (TREE_TYPE (min));\n \t  else\n \t    min = max = vrp_val_min (TREE_TYPE (min));\n-\t  t = VR_RANGE;\n+\t  kind = VR_RANGE;\n \t}\n       else if (is_min\n \t       /* As a special exception preserve non-null ranges.  */\n@@ -417,30 +665,22 @@ set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,\n \t  tree one = build_int_cst (TREE_TYPE (max), 1);\n \t  min = int_const_binop (PLUS_EXPR, max, one);\n \t  max = vrp_val_max (TREE_TYPE (max));\n-\t  t = VR_RANGE;\n+\t  kind = VR_RANGE;\n         }\n       else if (is_max)\n         {\n \t  tree one = build_int_cst (TREE_TYPE (min), 1);\n \t  max = int_const_binop (MINUS_EXPR, min, one);\n \t  min = vrp_val_min (TREE_TYPE (min));\n-\t  t = VR_RANGE;\n+\t  kind = VR_RANGE;\n         }\n     }\n \n   /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n      to make sure VRP iteration terminates, otherwise we can get into\n      oscillations.  */\n \n-  set_value_range (vr, t, min, max, equiv);\n-}\n-\n-/* Copy value range FROM into value range TO.  */\n-\n-void\n-copy_value_range (value_range *to, const value_range *from)\n-{\n-  set_value_range (to, from->type, from->min, from->max, from->equiv);\n+  set_value_range (this, kind, min, max, equiv);\n }\n \n /* Set value range VR to a single value.  This function is only called\n@@ -462,7 +702,7 @@ void\n set_value_range_to_nonnull (value_range *vr, tree type)\n {\n   tree zero = build_int_cst (type, 0);\n-  set_value_range (vr, VR_ANTI_RANGE, zero, zero, vr->equiv);\n+  vr->update (VR_ANTI_RANGE, zero, zero);\n }\n \n \n@@ -471,7 +711,7 @@ set_value_range_to_nonnull (value_range *vr, tree type)\n void\n set_value_range_to_null (value_range *vr, tree type)\n {\n-  set_value_range_to_value (vr, build_int_cst (type, 0), vr->equiv);\n+  set_value_range_to_value (vr, build_int_cst (type, 0), vr->equiv ());\n }\n \n /* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */\n@@ -503,9 +743,15 @@ vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n static inline bool\n range_is_null (const value_range *vr)\n {\n-  return vr->type == VR_RANGE\n-\t && integer_zerop (vr->min)\n-\t && integer_zerop (vr->max);\n+  return vr->null_p ();\n+}\n+\n+static inline bool\n+range_is_nonnull (const value_range *vr)\n+{\n+  return (vr->kind () == VR_ANTI_RANGE\n+\t  && vr->min () == vr->max ()\n+\t  && integer_zerop (vr->min ()));\n }\n \n /* Return true if max and min of VR are INTEGER_CST.  It's not necessary\n@@ -514,9 +760,9 @@ range_is_null (const value_range *vr)\n bool\n range_int_cst_p (const value_range *vr)\n {\n-  return (vr->type == VR_RANGE\n-\t  && TREE_CODE (vr->max) == INTEGER_CST\n-\t  && TREE_CODE (vr->min) == INTEGER_CST);\n+  return (vr->kind () == VR_RANGE\n+\t  && TREE_CODE (vr->min ()) == INTEGER_CST\n+\t  && TREE_CODE (vr->max ()) == INTEGER_CST);\n }\n \n /* Return true if VR is a INTEGER_CST singleton.  */\n@@ -525,16 +771,7 @@ bool\n range_int_cst_singleton_p (const value_range *vr)\n {\n   return (range_int_cst_p (vr)\n-\t  && tree_int_cst_equal (vr->min, vr->max));\n-}\n-\n-/* Return true if value range VR involves at least one symbol.  */\n-\n-bool\n-symbolic_range_p (const value_range *vr)\n-{\n-  return (!is_gimple_min_invariant (vr->min)\n-          || !is_gimple_min_invariant (vr->max));\n+\t  && tree_int_cst_equal (vr->min (), vr->max ()));\n }\n \n /* Return the single symbol (an SSA_NAME) contained in T if any, or NULL_TREE\n@@ -849,34 +1086,25 @@ value_inside_range (tree val, tree min, tree max)\n bool\n range_includes_zero_p (const value_range *vr)\n {\n-  if (vr->type == VR_VARYING)\n-    return true;\n-\n-  /* Ughh, we don't know.  We choose not to optimize.  */\n-  if (vr->type == VR_UNDEFINED)\n+  if (vr->varying_p () || vr->undefined_p ())\n     return true;\n-\n-  tree zero = build_int_cst (TREE_TYPE (vr->min), 0);\n-  if (vr->type == VR_ANTI_RANGE)\n-    {\n-      int res = value_inside_range (zero, vr->min, vr->max);\n-      return res == 0 || res == -2;\n-    }\n-  return value_inside_range (zero, vr->min, vr->max) != 0;\n+  tree zero = build_int_cst (vr->type (), 0);\n+  return vr->may_contain_p (zero);\n }\n \n-/* If *VR has a value rante that is a single constant value return that,\n-   otherwise return NULL_TREE.  */\n+/* If *VR has a value range that is a single constant value return that,\n+   otherwise return NULL_TREE.\n+\n+   ?? This actually returns TRUE for [&x, &x], so perhaps \"constant\"\n+   is not the best name.  */\n \n tree\n value_range_constant_singleton (const value_range *vr)\n {\n-  if (vr->type == VR_RANGE\n-      && vrp_operand_equal_p (vr->min, vr->max)\n-      && is_gimple_min_invariant (vr->min))\n-    return vr->min;\n-\n-  return NULL_TREE;\n+  tree result = NULL;\n+  if (vr->singleton_p (&result))\n+    return result;\n+  return NULL;\n }\n \n /* Value range wrapper for wide_int_range_set_zero_nonzero_bits.\n@@ -899,8 +1127,8 @@ vrp_set_zero_nonzero_bits (const tree expr_type,\n       return false;\n     }\n   wide_int_range_set_zero_nonzero_bits (TYPE_SIGN (expr_type),\n-\t\t\t\t\twi::to_wide (vr->min),\n-\t\t\t\t\twi::to_wide (vr->max),\n+\t\t\t\t\twi::to_wide (vr->min ()),\n+\t\t\t\t\twi::to_wide (vr->max ()),\n \t\t\t\t\t*may_be_nonzero, *must_be_nonzero);\n   return true;\n }\n@@ -914,40 +1142,36 @@ static bool\n ranges_from_anti_range (const value_range *ar,\n \t\t\tvalue_range *vr0, value_range *vr1)\n {\n-  tree type = TREE_TYPE (ar->min);\n+  tree type = ar->type ();\n \n-  vr0->type = VR_UNDEFINED;\n-  vr1->type = VR_UNDEFINED;\n+  vr0->set_undefined ();\n+  vr1->set_undefined ();\n \n   /* As a future improvement, we could handle ~[0, A] as: [-INF, -1] U\n      [A+1, +INF].  Not sure if this helps in practice, though.  */\n \n-  if (ar->type != VR_ANTI_RANGE\n-      || TREE_CODE (ar->min) != INTEGER_CST\n-      || TREE_CODE (ar->max) != INTEGER_CST\n+  if (ar->kind () != VR_ANTI_RANGE\n+      || TREE_CODE (ar->min ()) != INTEGER_CST\n+      || TREE_CODE (ar->max ()) != INTEGER_CST\n       || !vrp_val_min (type)\n       || !vrp_val_max (type))\n     return false;\n \n-  if (!vrp_val_is_min (ar->min))\n-    {\n-      vr0->type = VR_RANGE;\n-      vr0->min = vrp_val_min (type);\n-      vr0->max = wide_int_to_tree (type, wi::to_wide (ar->min) - 1);\n-    }\n-  if (!vrp_val_is_max (ar->max))\n-    {\n-      vr1->type = VR_RANGE;\n-      vr1->min = wide_int_to_tree (type, wi::to_wide (ar->max) + 1);\n-      vr1->max = vrp_val_max (type);\n-    }\n-  if (vr0->type == VR_UNDEFINED)\n+  if (!vrp_val_is_min (ar->min ()))\n+    *vr0 = value_range (VR_RANGE,\n+\t\t\tvrp_val_min (type),\n+\t\t\twide_int_to_tree (type, wi::to_wide (ar->min ()) - 1));\n+  if (!vrp_val_is_max (ar->max ()))\n+    *vr1 = value_range (VR_RANGE,\n+\t\t\twide_int_to_tree (type, wi::to_wide (ar->max ()) + 1),\n+\t\t\tvrp_val_max (type));\n+  if (vr0->undefined_p ())\n     {\n       *vr0 = *vr1;\n-      vr1->type = VR_UNDEFINED;\n+      vr1->set_undefined ();\n     }\n \n-  return vr0->type != VR_UNDEFINED;\n+  return !vr0->undefined_p ();\n }\n \n /* Extract the components of a value range into a pair of wide ints in\n@@ -961,13 +1185,11 @@ extract_range_into_wide_ints (const value_range *vr,\n \t\t\t      signop sign, unsigned prec,\n \t\t\t      wide_int &wmin, wide_int &wmax)\n {\n-  if ((vr->type == VR_RANGE\n-       || vr->type == VR_ANTI_RANGE)\n-      && TREE_CODE (vr->min) == INTEGER_CST\n-      && TREE_CODE (vr->max) == INTEGER_CST)\n+  gcc_assert (vr->kind () != VR_ANTI_RANGE || vr->symbolic_p ());\n+  if (range_int_cst_p (vr))\n     {\n-      wmin = wi::to_wide (vr->min);\n-      wmax = wi::to_wide (vr->max);\n+      wmin = wi::to_wide (vr->min ());\n+      wmax = wi::to_wide (vr->max ());\n     }\n   else\n     {\n@@ -994,24 +1216,25 @@ extract_range_from_multiplicative_op (value_range *vr,\n \t      || code == ROUND_DIV_EXPR\n \t      || code == RSHIFT_EXPR\n \t      || code == LSHIFT_EXPR);\n-  gcc_assert (vr0->type == VR_RANGE && vr0->type == vr1->type);\n+  gcc_assert (vr0->kind () == VR_RANGE\n+\t      && vr0->kind () == vr1->kind ());\n \n-  tree type = TREE_TYPE (vr0->min);\n+  tree type = vr0->type ();\n   wide_int res_lb, res_ub;\n-  wide_int vr0_lb = wi::to_wide (vr0->min);\n-  wide_int vr0_ub = wi::to_wide (vr0->max);\n-  wide_int vr1_lb = wi::to_wide (vr1->min);\n-  wide_int vr1_ub = wi::to_wide (vr1->max);\n+  wide_int vr0_lb = wi::to_wide (vr0->min ());\n+  wide_int vr0_ub = wi::to_wide (vr0->max ());\n+  wide_int vr1_lb = wi::to_wide (vr1->min ());\n+  wide_int vr1_ub = wi::to_wide (vr1->max ());\n   bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (type);\n   unsigned prec = TYPE_PRECISION (type);\n \n   if (wide_int_range_multiplicative_op (res_lb, res_ub,\n \t\t\t\t\tcode, TYPE_SIGN (type), prec,\n \t\t\t\t\tvr0_lb, vr0_ub, vr1_lb, vr1_ub,\n \t\t\t\t\toverflow_undefined))\n-    set_and_canonicalize_value_range (vr, VR_RANGE,\n-\t\t\t\t      wide_int_to_tree (type, res_lb),\n-\t\t\t\t      wide_int_to_tree (type, res_ub), NULL);\n+    vr->set_and_canonicalize (VR_RANGE,\n+\t\t\t      wide_int_to_tree (type, res_lb),\n+\t\t\t      wide_int_to_tree (type, res_ub), NULL);\n   else\n     set_value_range_to_varying (vr);\n }\n@@ -1113,8 +1336,6 @@ set_value_range_with_overflow (value_range &vr,\n {\n   const signop sgn = TYPE_SIGN (type);\n   const unsigned int prec = TYPE_PRECISION (type);\n-  vr.type = VR_RANGE;\n-  vr.equiv = NULL;\n \n   /* For one bit precision if max < min, then the swapped\n      range covers all values.  */\n@@ -1132,10 +1353,18 @@ set_value_range_with_overflow (value_range &vr,\n       wide_int tmax = wide_int::from (wmax, prec, sgn);\n       if ((min_ovf != wi::OVF_NONE) == (max_ovf != wi::OVF_NONE))\n \t{\n-\t  /* No overflow or both overflow or underflow.  The\n-\t     range kind stays VR_RANGE.  */\n-\t  vr.min = wide_int_to_tree (type, tmin);\n-\t  vr.max = wide_int_to_tree (type, tmax);\n+\t  /* If the limits are swapped, we wrapped around and cover\n+\t     the entire range.  We have a similar check at the end of\n+\t     extract_range_from_binary_expr_1.  */\n+\t  if (wi::gt_p (tmin, tmax, sgn))\n+\t    vr.set_varying ();\n+\t  else\n+\t    /* No overflow or both overflow or underflow.  The\n+\t       range kind stays VR_RANGE.  */\n+\t    vr = value_range (VR_RANGE,\n+\t\t\t      wide_int_to_tree (type, tmin),\n+\t\t\t      wide_int_to_tree (type, tmax));\n+\t  return;\n \t}\n       else if ((min_ovf == wi::OVF_UNDERFLOW && max_ovf == wi::OVF_NONE)\n \t       || (max_ovf == wi::OVF_OVERFLOW && min_ovf == wi::OVF_NONE))\n@@ -1144,7 +1373,6 @@ set_value_range_with_overflow (value_range &vr,\n \t     changes to VR_ANTI_RANGE.  */\n \t  bool covers = false;\n \t  wide_int tem = tmin;\n-\t  vr.type = VR_ANTI_RANGE;\n \t  tmin = tmax + 1;\n \t  if (wi::cmp (tmin, tmax, sgn) < 0)\n \t    covers = true;\n@@ -1159,8 +1387,10 @@ set_value_range_with_overflow (value_range &vr,\n \t      set_value_range_to_varying (&vr);\n \t      return;\n \t    }\n-\t  vr.min = wide_int_to_tree (type, tmin);\n-\t  vr.max = wide_int_to_tree (type, tmax);\n+\t  vr = value_range (VR_ANTI_RANGE,\n+\t\t\t    wide_int_to_tree (type, tmin),\n+\t\t\t    wide_int_to_tree (type, tmax));\n+\t  return;\n \t}\n       else\n \t{\n@@ -1175,19 +1405,21 @@ set_value_range_with_overflow (value_range &vr,\n \t value.  */\n       wide_int type_min = wi::min_value (prec, sgn);\n       wide_int type_max = wi::max_value (prec, sgn);\n+      tree min, max;\n       if (min_ovf == wi::OVF_UNDERFLOW)\n-\tvr.min = wide_int_to_tree (type, type_min);\n+\tmin = wide_int_to_tree (type, type_min);\n       else if (min_ovf == wi::OVF_OVERFLOW)\n-\tvr.min = wide_int_to_tree (type, type_max);\n+\tmin = wide_int_to_tree (type, type_max);\n       else\n-\tvr.min = wide_int_to_tree (type, wmin);\n+\tmin = wide_int_to_tree (type, wmin);\n \n       if (max_ovf == wi::OVF_UNDERFLOW)\n-\tvr.max = wide_int_to_tree (type, type_min);\n+\tmax = wide_int_to_tree (type, type_min);\n       else if (max_ovf == wi::OVF_OVERFLOW)\n-\tvr.max = wide_int_to_tree (type, type_max);\n+\tmax = wide_int_to_tree (type, type_max);\n       else\n-\tvr.max = wide_int_to_tree (type, wmax);\n+\tmax = wide_int_to_tree (type, wmax);\n+      vr = value_range (VR_RANGE, min, max);\n     }\n }\n \n@@ -1204,8 +1436,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n   signop sign = TYPE_SIGN (expr_type);\n   unsigned int prec = TYPE_PRECISION (expr_type);\n   value_range vr0 = *vr0_, vr1 = *vr1_;\n-  value_range vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;\n-  enum value_range_type type;\n+  value_range vrtem0, vrtem1;\n+  enum value_range_kind type;\n   tree min = NULL_TREE, max = NULL_TREE;\n   int cmp;\n \n@@ -1241,7 +1473,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n     }\n \n   /* If both ranges are UNDEFINED, so is the result.  */\n-  if (vr0.type == VR_UNDEFINED && vr1.type == VR_UNDEFINED)\n+  if (vr0.undefined_p () && vr1.undefined_p ())\n     {\n       set_value_range_to_undefined (vr);\n       return;\n@@ -1250,56 +1482,52 @@ extract_range_from_binary_expr_1 (value_range *vr,\n      code.  At some point we may want to special-case operations that\n      have UNDEFINED result for all or some value-ranges of the not UNDEFINED\n      operand.  */\n-  else if (vr0.type == VR_UNDEFINED)\n+  else if (vr0.undefined_p ())\n     set_value_range_to_varying (&vr0);\n-  else if (vr1.type == VR_UNDEFINED)\n+  else if (vr1.undefined_p ())\n     set_value_range_to_varying (&vr1);\n \n   /* We get imprecise results from ranges_from_anti_range when\n      code is EXACT_DIV_EXPR.  We could mask out bits in the resulting\n-     range, but then we also need to hack up vrp_meet.  It's just\n+     range, but then we also need to hack up vrp_union.  It's just\n      easier to special case when vr0 is ~[0,0] for EXACT_DIV_EXPR.  */\n-  if (code == EXACT_DIV_EXPR\n-      && vr0.type == VR_ANTI_RANGE\n-      && vr0.min == vr0.max\n-      && integer_zerop (vr0.min))\n+  if (code == EXACT_DIV_EXPR && range_is_nonnull (&vr0))\n     {\n       set_value_range_to_nonnull (vr, expr_type);\n       return;\n     }\n \n   /* Now canonicalize anti-ranges to ranges when they are not symbolic\n      and express ~[] op X as ([]' op X) U ([]'' op X).  */\n-  if (vr0.type == VR_ANTI_RANGE\n+  if (vr0.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n     {\n       extract_range_from_binary_expr_1 (vr, code, expr_type, &vrtem0, vr1_);\n-      if (vrtem1.type != VR_UNDEFINED)\n+      if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range vrres = VR_INITIALIZER;\n-\t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\n-\t\t\t\t\t    &vrtem1, vr1_);\n-\t  vrp_meet (vr, &vrres);\n+\t  value_range vrres;\n+\t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\t\t\t\t\t    &vrtem1, vr1_);\n+\t  vr->union_ (&vrres);\n \t}\n       return;\n     }\n   /* Likewise for X op ~[].  */\n-  if (vr1.type == VR_ANTI_RANGE\n+  if (vr1.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr1, &vrtem0, &vrtem1))\n     {\n       extract_range_from_binary_expr_1 (vr, code, expr_type, vr0_, &vrtem0);\n-      if (vrtem1.type != VR_UNDEFINED)\n+      if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range vrres = VR_INITIALIZER;\n+\t  value_range vrres;\n \t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\n \t\t\t\t\t    vr0_, &vrtem1);\n-\t  vrp_meet (vr, &vrres);\n+\t  vr->union_ (&vrres);\n \t}\n       return;\n     }\n \n   /* The type of the resulting value range defaults to VR0.TYPE.  */\n-  type = vr0.type;\n+  type = vr0.kind ();\n \n   /* Refuse to operate on VARYING ranges, ranges of different kinds\n      and symbolic ranges.  As an exception, we allow BIT_{AND,IOR}\n@@ -1322,11 +1550,11 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       && code != MINUS_EXPR\n       && code != RSHIFT_EXPR\n       && code != POINTER_PLUS_EXPR\n-      && (vr0.type == VR_VARYING\n-\t  || vr1.type == VR_VARYING\n-\t  || vr0.type != vr1.type\n-\t  || symbolic_range_p (&vr0)\n-\t  || symbolic_range_p (&vr1)))\n+      && (vr0.varying_p ()\n+\t  || vr1.varying_p ()\n+\t  || vr0.kind () != vr1.kind ()\n+\t  || vr0.symbolic_p ()\n+\t  || vr1.symbolic_p ()))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -1384,24 +1612,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       /* This will normalize things such that calculating\n \t [0,0] - VR_VARYING is not dropped to varying, but is\n \t calculated as [MIN+1, MAX].  */\n-      if (vr0.type == VR_VARYING)\n-\t{\n-\t  vr0.type = VR_RANGE;\n-\t  vr0.min = vrp_val_min (expr_type);\n-\t  vr0.max = vrp_val_max (expr_type);\n-\t}\n-      if (vr1.type == VR_VARYING)\n-\t{\n-\t  vr1.type = VR_RANGE;\n-\t  vr1.min = vrp_val_min (expr_type);\n-\t  vr1.max = vrp_val_max (expr_type);\n-\t}\n+      if (vr0.varying_p ())\n+\tvr0.update (VR_RANGE,\n+\t\t    vrp_val_min (expr_type),\n+\t\t    vrp_val_max (expr_type));\n+      if (vr1.varying_p ())\n+\tvr1.update (VR_RANGE,\n+\t\t    vrp_val_min (expr_type),\n+\t\t    vrp_val_max (expr_type));\n \n       const bool minus_p = (code == MINUS_EXPR);\n-      tree min_op0 = vr0.min;\n-      tree min_op1 = minus_p ? vr1.max : vr1.min;\n-      tree max_op0 = vr0.max;\n-      tree max_op1 = minus_p ? vr1.min : vr1.max;\n+      tree min_op0 = vr0.min ();\n+      tree min_op1 = minus_p ? vr1.max () : vr1.min ();\n+      tree max_op0 = vr0.max ();\n+      tree max_op1 = minus_p ? vr1.min () : vr1.max ();\n       tree sym_min_op0 = NULL_TREE;\n       tree sym_min_op1 = NULL_TREE;\n       tree sym_max_op0 = NULL_TREE;\n@@ -1414,7 +1638,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t single-symbolic ranges, try to compute the precise resulting range,\n \t but only if we know that this resulting range will also be constant\n \t or single-symbolic.  */\n-      if (vr0.type == VR_RANGE && vr1.type == VR_RANGE\n+      if (vr0.kind () == VR_RANGE && vr1.kind () == VR_RANGE\n \t  && (TREE_CODE (min_op0) == INTEGER_CST\n \t      || (sym_min_op0\n \t\t  = get_single_symbol (min_op0, &neg_min_op0, &min_op0)))\n@@ -1454,21 +1678,19 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  /* Adjust the range for possible overflow.  */\n \t  set_value_range_with_overflow (*vr, expr_type,\n \t\t\t\t\t wmin, wmax, min_ovf, max_ovf);\n-\t  if (vr->type == VR_VARYING)\n+\t  if (vr->varying_p ())\n \t    return;\n \n \t  /* Build the symbolic bounds if needed.  */\n-\t  adjust_symbolic_bound (vr->min, code, expr_type,\n+\t  min = vr->min ();\n+\t  max = vr->max ();\n+\t  adjust_symbolic_bound (min, code, expr_type,\n \t\t\t\t sym_min_op0, sym_min_op1,\n \t\t\t\t neg_min_op0, neg_min_op1);\n-\t  adjust_symbolic_bound (vr->max, code, expr_type,\n+\t  adjust_symbolic_bound (max, code, expr_type,\n \t\t\t\t sym_max_op0, sym_max_op1,\n \t\t\t\t neg_max_op0, neg_max_op1);\n-\t  /* ?? It would probably be cleaner to eliminate min/max/type\n-\t     entirely and hold these values in VR directly.  */\n-\t  min = vr->min;\n-\t  max = vr->max;\n-\t  type = vr->type;\n+\t  type = vr->kind ();\n \t}\n       else\n \t{\n@@ -1498,9 +1720,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n       if (wide_int_range_min_max (wmin, wmax, code, sign, prec,\n \t\t\t\t  vr0_min, vr0_max, vr1_min, vr1_max))\n-\tset_value_range (vr, VR_RANGE,\n-\t\t\t wide_int_to_tree (expr_type, wmin),\n-\t\t\t wide_int_to_tree (expr_type, wmax), NULL);\n+\tvr->update (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n+\t\t    wide_int_to_tree (expr_type, wmax));\n       else\n \tset_value_range_to_varying (vr);\n       return;\n@@ -1520,22 +1741,21 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t   || code == LSHIFT_EXPR)\n     {\n       if (range_int_cst_p (&vr1)\n-\t  && !wide_int_range_shift_undefined_p (TYPE_SIGN (TREE_TYPE (vr1.min)),\n-\t\t\t\t\t\tprec,\n-\t\t\t\t\t\twi::to_wide (vr1.min),\n-\t\t\t\t\t\twi::to_wide (vr1.max)))\n+\t  && !wide_int_range_shift_undefined_p\n+\t\t(TYPE_SIGN (TREE_TYPE (vr1.min ())),\n+\t\t prec,\n+\t\t wi::to_wide (vr1.min ()),\n+\t\t wi::to_wide (vr1.max ())))\n \t{\n \t  if (code == RSHIFT_EXPR)\n \t    {\n \t      /* Even if vr0 is VARYING or otherwise not usable, we can derive\n \t\t useful ranges just from the shift count.  E.g.\n \t\t x >> 63 for signed 64-bit x is always [-1, 0].  */\n-\t      if (vr0.type != VR_RANGE || symbolic_range_p (&vr0))\n-\t\t{\n-\t\t  vr0.type = type = VR_RANGE;\n-\t\t  vr0.min = vrp_val_min (expr_type);\n-\t\t  vr0.max = vrp_val_max (expr_type);\n-\t\t}\n+\t      if (vr0.kind () != VR_RANGE || vr0.symbolic_p ())\n+\t\tvr0.update (VR_RANGE,\n+\t\t\t    vrp_val_min (expr_type),\n+\t\t\t    vrp_val_max (expr_type));\n \t      extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n \t      return;\n \t    }\n@@ -1544,16 +1764,15 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t    {\n \t      wide_int res_lb, res_ub;\n \t      if (wide_int_range_lshift (res_lb, res_ub, sign, prec,\n-\t\t\t\t\t wi::to_wide (vr0.min),\n-\t\t\t\t\t wi::to_wide (vr0.max),\n-\t\t\t\t\t wi::to_wide (vr1.min),\n-\t\t\t\t\t wi::to_wide (vr1.max),\n+\t\t\t\t\t wi::to_wide (vr0.min ()),\n+\t\t\t\t\t wi::to_wide (vr0.max ()),\n+\t\t\t\t\t wi::to_wide (vr1.min ()),\n+\t\t\t\t\t wi::to_wide (vr1.max ()),\n \t\t\t\t\t TYPE_OVERFLOW_UNDEFINED (expr_type)))\n \t\t{\n \t\t  min = wide_int_to_tree (expr_type, res_lb);\n \t\t  max = wide_int_to_tree (expr_type, res_ub);\n-\t\t  set_and_canonicalize_value_range (vr, VR_RANGE,\n-\t\t\t\t\t\t    min, max, NULL);\n+\t\t  vr->set_and_canonicalize (VR_RANGE, min, max, NULL);\n \t\t  return;\n \t\t}\n \t    }\n@@ -1603,11 +1822,11 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t       wide_int_to_tree (expr_type, wmax), NULL);\n       if (extra_range_p)\n \t{\n-\t  value_range extra_range = VR_INITIALIZER;\n+\t  value_range extra_range;\n \t  set_value_range (&extra_range, VR_RANGE,\n \t\t\t   wide_int_to_tree (expr_type, extra_min),\n \t\t\t   wide_int_to_tree (expr_type, extra_max), NULL);\n-\t  vrp_meet (vr, &extra_range);\n+\t  vr->union_ (&extra_range);\n \t}\n       return;\n     }\n@@ -1740,7 +1959,8 @@ extract_range_from_unary_expr (value_range *vr,\n {\n   signop sign = TYPE_SIGN (type);\n   unsigned int prec = TYPE_PRECISION (type);\n-  value_range vr0 = *vr0_, vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;\n+  value_range vr0 = *vr0_;\n+  value_range vrtem0, vrtem1;\n \n   /* VRP only operates on integral and pointer types.  */\n   if (!(INTEGRAL_TYPE_P (op0_type)\n@@ -1753,7 +1973,7 @@ extract_range_from_unary_expr (value_range *vr,\n     }\n \n   /* If VR0 is UNDEFINED, so is the result.  */\n-  if (vr0.type == VR_UNDEFINED)\n+  if (vr0.undefined_p ())\n     {\n       set_value_range_to_undefined (vr);\n       return;\n@@ -1763,14 +1983,14 @@ extract_range_from_unary_expr (value_range *vr,\n   if (code == PAREN_EXPR || code == OBJ_TYPE_REF)\n     {\n       /* PAREN_EXPR and OBJ_TYPE_REF are simple copies.  */\n-      copy_value_range (vr, &vr0);\n+      vr->deep_copy (&vr0);\n       return;\n     }\n   else if (code == NEGATE_EXPR)\n     {\n       /* -X is simply 0 - X, so re-use existing code that also handles\n          anti-ranges fine.  */\n-      value_range zero = VR_INITIALIZER;\n+      value_range zero;\n       set_value_range_to_value (&zero, build_int_cst (type, 0), NULL);\n       extract_range_from_binary_expr_1 (vr, MINUS_EXPR, type, &zero, &vr0);\n       return;\n@@ -1779,7 +1999,7 @@ extract_range_from_unary_expr (value_range *vr,\n     {\n       /* ~X is simply -1 - X, so re-use existing code that also handles\n          anti-ranges fine.  */\n-      value_range minusone = VR_INITIALIZER;\n+      value_range minusone;\n       set_value_range_to_value (&minusone, build_int_cst (type, -1), NULL);\n       extract_range_from_binary_expr_1 (vr, MINUS_EXPR,\n \t\t\t\t\ttype, &minusone, &vr0);\n@@ -1788,16 +2008,16 @@ extract_range_from_unary_expr (value_range *vr,\n \n   /* Now canonicalize anti-ranges to ranges when they are not symbolic\n      and express op ~[]  as (op []') U (op []'').  */\n-  if (vr0.type == VR_ANTI_RANGE\n+  if (vr0.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n     {\n       extract_range_from_unary_expr (vr, code, type, &vrtem0, op0_type);\n-      if (vrtem1.type != VR_UNDEFINED)\n+      if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range vrres = VR_INITIALIZER;\n+\t  value_range vrres;\n \t  extract_range_from_unary_expr (&vrres, code, type,\n \t\t\t\t\t &vrtem1, op0_type);\n-\t  vrp_meet (vr, &vrres);\n+\t  vr->union_ (&vrres);\n \t}\n       return;\n     }\n@@ -1829,8 +2049,8 @@ extract_range_from_unary_expr (value_range *vr,\n \t pointer anti-ranges.  Any remaining anti-ranges at this point\n \t will be integer conversions from SSA names that will be\n \t normalized into VARYING.  For instance: ~[x_55, x_55].  */\n-      gcc_assert (vr0.type != VR_ANTI_RANGE\n-\t\t  || TREE_CODE (vr0.min) != INTEGER_CST);\n+      gcc_assert (vr0.kind () != VR_ANTI_RANGE\n+\t\t  || TREE_CODE (vr0.min ()) != INTEGER_CST);\n \n       /* NOTES: Previously we were returning VARYING for all symbolics, but\n \t we can do better by treating them as [-MIN, +MAX].  For\n@@ -1853,7 +2073,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t{\n \t  tree min = wide_int_to_tree (outer_type, wmin);\n \t  tree max = wide_int_to_tree (outer_type, wmax);\n-\t  set_and_canonicalize_value_range (vr, VR_RANGE, min, max, NULL);\n+\t  vr->set_and_canonicalize (VR_RANGE, min, max, NULL);\n \t}\n       else\n \tset_value_range_to_varying (vr);\n@@ -1887,76 +2107,21 @@ void dump_all_value_ranges (FILE *);\n void dump_vr_equiv (FILE *, bitmap);\n void debug_vr_equiv (bitmap);\n \n-\n-/* Dump value range VR to FILE.  */\n-\n void\n dump_value_range (FILE *file, const value_range *vr)\n {\n-  if (vr == NULL)\n+  if (!vr)\n     fprintf (file, \"[]\");\n-  else if (vr->type == VR_UNDEFINED)\n-    fprintf (file, \"UNDEFINED\");\n-  else if (vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE)\n-    {\n-      tree type = TREE_TYPE (vr->min);\n-\n-      fprintf (file, \"%s[\", (vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n-\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && !TYPE_UNSIGNED (type)\n-\t  && vrp_val_is_min (vr->min))\n-\tfprintf (file, \"-INF\");\n-      else\n-\tprint_generic_expr (file, vr->min);\n-\n-      fprintf (file, \", \");\n-\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && vrp_val_is_max (vr->max))\n-\tfprintf (file, \"+INF\");\n-      else\n-\tprint_generic_expr (file, vr->max);\n-\n-      fprintf (file, \"]\");\n-\n-      if (vr->equiv)\n-\t{\n-\t  bitmap_iterator bi;\n-\t  unsigned i, c = 0;\n-\n-\t  fprintf (file, \"  EQUIVALENCES: { \");\n-\n-\t  EXECUTE_IF_SET_IN_BITMAP (vr->equiv, 0, i, bi)\n-\t    {\n-\t      print_generic_expr (file, ssa_name (i));\n-\t      fprintf (file, \" \");\n-\t      c++;\n-\t    }\n-\n-\t  fprintf (file, \"} (%u elements)\", c);\n-\t}\n-    }\n-  else if (vr->type == VR_VARYING)\n-    fprintf (file, \"VARYING\");\n   else\n-    fprintf (file, \"INVALID RANGE\");\n+    vr->dump (file);\n }\n \n-\n /* Dump value range VR to stderr.  */\n \n DEBUG_FUNCTION void\n debug_value_range (const value_range *vr)\n {\n-  dump_value_range (stderr, vr);\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-void\n-value_range::dump () const\n-{\n-  debug_value_range (this);\n+  vr->dump ();\n }\n \n \n@@ -4200,14 +4365,14 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n   if (TREE_CODE (low_sub) == SSA_NAME)\n     {\n       vr = get_value_range (low_sub);\n-      if (vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE)\n+      if (!vr->undefined_p () && !vr->varying_p ())\n         {\n-          low_sub = vr->type == VR_RANGE ? vr->max : vr->min;\n-          up_sub = vr->type == VR_RANGE ? vr->min : vr->max;\n+          low_sub = vr->kind () == VR_RANGE ? vr->max () : vr->min ();\n+          up_sub = vr->kind () == VR_RANGE ? vr->min () : vr->max ();\n         }\n     }\n \n-  if (vr && vr->type == VR_ANTI_RANGE)\n+  if (vr && vr->kind () == VR_ANTI_RANGE)\n     {\n       if (up_bound\n \t  && TREE_CODE (up_sub) == INTEGER_CST\n@@ -4335,21 +4500,20 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n \tbreak;\n \n       vr = get_value_range (varoff);\n-      if (!vr || vr->type == VR_UNDEFINED || !vr->min || !vr->max)\n+      if (!vr || vr->undefined_p () || vr->varying_p ())\n \tbreak;\n \n-      if (TREE_CODE (vr->min) != INTEGER_CST\n-          || TREE_CODE (vr->max) != INTEGER_CST)\n+      if (!vr->constant_p ())\n         break;\n \n-      if (vr->type == VR_RANGE)\n+      if (vr->kind () == VR_RANGE)\n \t{\n-\t  if (tree_int_cst_lt (vr->min, vr->max))\n+\t  if (tree_int_cst_lt (vr->min (), vr->max ()))\n \t    {\n \t      offset_int min\n-\t\t= wi::to_offset (fold_convert (ptrdiff_type_node, vr->min));\n+\t\t= wi::to_offset (fold_convert (ptrdiff_type_node, vr->min ()));\n \t      offset_int max\n-\t\t= wi::to_offset (fold_convert (ptrdiff_type_node, vr->max));\n+\t\t= wi::to_offset (fold_convert (ptrdiff_type_node, vr->max ()));\n \t      if (min < max)\n \t\t{\n \t\t  offrange[0] += min;\n@@ -5121,8 +5285,8 @@ find_case_label_range (gswitch *stmt, tree min, tree max, size_t *min_idx,\n enum ssa_prop_result\n vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n {\n-  value_range vr = VR_INITIALIZER;\n   tree lhs = gimple_get_lhs (stmt);\n+  value_range vr;\n   extract_range_from_stmt (stmt, taken_edge_p, output_p, &vr);\n \n   if (*output_p)\n@@ -5138,7 +5302,7 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  if (vr.type == VR_VARYING)\n+\t  if (vr.varying_p ())\n \t    return SSA_PROP_VARYING;\n \n \t  return SSA_PROP_INTERESTING;\n@@ -5191,17 +5355,14 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t\t   SSA_PROP_NOT_INTERESTING.  If there are no\n \t\t   {REAL,IMAG}PART_EXPR uses at all,\n \t\t   return SSA_PROP_VARYING.  */\n-\t\tvalue_range new_vr = VR_INITIALIZER;\n+\t\tvalue_range new_vr;\n \t\textract_range_basic (&new_vr, use_stmt);\n \t\tconst value_range *old_vr = get_value_range (use_lhs);\n-\t\tif (old_vr->type != new_vr.type\n-\t\t    || !vrp_operand_equal_p (old_vr->min, new_vr.min)\n-\t\t    || !vrp_operand_equal_p (old_vr->max, new_vr.max)\n-\t\t    || !vrp_bitmap_equal_p (old_vr->equiv, new_vr.equiv))\n+\t\tif (*old_vr != new_vr)\n \t\t  res = SSA_PROP_INTERESTING;\n \t\telse\n \t\t  res = SSA_PROP_NOT_INTERESTING;\n-\t\tBITMAP_FREE (new_vr.equiv);\n+\t\tnew_vr.equiv_clear ();\n \t\tif (res == SSA_PROP_INTERESTING)\n \t\t  {\n \t\t    *output_p = lhs;\n@@ -5229,9 +5390,9 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n    possible such range.  The resulting range is not canonicalized.  */\n \n static void\n-union_ranges (enum value_range_type *vr0type,\n+union_ranges (enum value_range_kind *vr0type,\n \t      tree *vr0min, tree *vr0max,\n-\t      enum value_range_type vr1type,\n+\t      enum value_range_kind vr1type,\n \t      tree vr1min, tree vr1max)\n {\n   bool mineq = vrp_operand_equal_p (*vr0min, vr1min);\n@@ -5500,9 +5661,9 @@ union_ranges (enum value_range_type *vr0type,\n    possible such range.  The resulting range is not canonicalized.  */\n \n static void\n-intersect_ranges (enum value_range_type *vr0type,\n+intersect_ranges (enum value_range_kind *vr0type,\n \t\t  tree *vr0min, tree *vr0max,\n-\t\t  enum value_range_type vr1type,\n+\t\t  enum value_range_kind vr1type,\n \t\t  tree vr1min, tree vr1max)\n {\n   bool mineq = vrp_operand_equal_p (*vr0min, vr1min);\n@@ -5812,87 +5973,86 @@ intersect_ranges (enum value_range_type *vr0type,\n       *vr0min = vr1min;\n       *vr0max = vr1max;\n     }\n-\n-  return;\n }\n \n \n /* Intersect the two value-ranges *VR0 and *VR1 and store the result\n    in *VR0.  This may not be the smallest possible such range.  */\n \n-static void\n-vrp_intersect_ranges_1 (value_range *vr0, const value_range *vr1)\n+void\n+value_range::intersect_helper (value_range *vr0, const value_range *vr1)\n {\n-  value_range saved;\n-\n   /* If either range is VR_VARYING the other one wins.  */\n-  if (vr1->type == VR_VARYING)\n+  if (vr1->varying_p ())\n     return;\n-  if (vr0->type == VR_VARYING)\n+  if (vr0->varying_p ())\n     {\n-      copy_value_range (vr0, vr1);\n+      vr0->deep_copy (vr1);\n       return;\n     }\n \n   /* When either range is VR_UNDEFINED the resulting range is\n      VR_UNDEFINED, too.  */\n-  if (vr0->type == VR_UNDEFINED)\n+  if (vr0->undefined_p ())\n     return;\n-  if (vr1->type == VR_UNDEFINED)\n+  if (vr1->undefined_p ())\n     {\n       set_value_range_to_undefined (vr0);\n       return;\n     }\n \n   /* Save the original vr0 so we can return it as conservative intersection\n      result when our worker turns things to varying.  */\n-  saved = *vr0;\n-  intersect_ranges (&vr0->type, &vr0->min, &vr0->max,\n-\t\t    vr1->type, vr1->min, vr1->max);\n+  value_range saved (*vr0);\n+\n+  value_range_kind vr0type = vr0->kind ();\n+  tree vr0min = vr0->min ();\n+  tree vr0max = vr0->max ();\n+  intersect_ranges (&vr0type, &vr0min, &vr0max,\n+\t\t    vr1->kind (), vr1->min (), vr1->max ());\n   /* Make sure to canonicalize the result though as the inversion of a\n      VR_RANGE can still be a VR_RANGE.  */\n-  set_and_canonicalize_value_range (vr0, vr0->type,\n-\t\t\t\t    vr0->min, vr0->max, vr0->equiv);\n+  vr0->set_and_canonicalize (vr0type, vr0min, vr0max, vr0->m_equiv);\n   /* If that failed, use the saved original VR0.  */\n-  if (vr0->type == VR_VARYING)\n+  if (vr0->varying_p ())\n     {\n       *vr0 = saved;\n       return;\n     }\n   /* If the result is VR_UNDEFINED there is no need to mess with\n      the equivalencies.  */\n-  if (vr0->type == VR_UNDEFINED)\n+  if (vr0->undefined_p ())\n     return;\n \n   /* The resulting set of equivalences for range intersection is the union of\n      the two sets.  */\n-  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n-    bitmap_ior_into (vr0->equiv, vr1->equiv);\n-  else if (vr1->equiv && !vr0->equiv)\n+  if (vr0->m_equiv && vr1->m_equiv && vr0->m_equiv != vr1->m_equiv)\n+    bitmap_ior_into (vr0->m_equiv, vr1->m_equiv);\n+  else if (vr1->m_equiv && !vr0->m_equiv)\n     {\n       /* All equivalence bitmaps are allocated from the same obstack.  So\n \t we can use the obstack associated with VR to allocate vr0->equiv.  */\n-      vr0->equiv = BITMAP_ALLOC (vr1->equiv->obstack);\n-      bitmap_copy (vr0->equiv, vr1->equiv);\n+      vr0->m_equiv = BITMAP_ALLOC (vr1->m_equiv->obstack);\n+      bitmap_copy (m_equiv, vr1->m_equiv);\n     }\n }\n \n void\n-vrp_intersect_ranges (value_range *vr0, const value_range *vr1)\n+value_range::intersect (const value_range *other)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Intersecting\\n  \");\n-      dump_value_range (dump_file, vr0);\n+      dump_value_range (dump_file, this);\n       fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, vr1);\n+      dump_value_range (dump_file, other);\n       fprintf (dump_file, \"\\n\");\n     }\n-  vrp_intersect_ranges_1 (vr0, vr1);\n+  intersect_helper (this, other);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, vr0);\n+      dump_value_range (dump_file, this);\n       fprintf (dump_file, \"\\n\");\n     }\n }\n@@ -5901,92 +6061,93 @@ vrp_intersect_ranges (value_range *vr0, const value_range *vr1)\n    VR1, store in VR0 a range that contains both VR0 and VR1.  This\n    may not be the smallest possible such range.  */\n \n-static void\n-vrp_meet_1 (value_range *vr0, const value_range *vr1)\n+void\n+value_range::union_helper (value_range *vr0, const value_range *vr1)\n {\n-  value_range saved;\n-\n-  if (vr0->type == VR_UNDEFINED)\n+  if (vr1->undefined_p ())\n     {\n-      set_value_range (vr0, vr1->type, vr1->min, vr1->max, vr1->equiv);\n+      /* VR0 already has the resulting range.  */\n       return;\n     }\n \n-  if (vr1->type == VR_UNDEFINED)\n+  if (vr0->undefined_p ())\n     {\n-      /* VR0 already has the resulting range.  */\n+      vr0->deep_copy (vr1);\n       return;\n     }\n \n-  if (vr0->type == VR_VARYING)\n+  if (vr0->varying_p ())\n     {\n       /* Nothing to do.  VR0 already has the resulting range.  */\n       return;\n     }\n \n-  if (vr1->type == VR_VARYING)\n+  if (vr1->varying_p ())\n     {\n       set_value_range_to_varying (vr0);\n       return;\n     }\n \n-  saved = *vr0;\n-  union_ranges (&vr0->type, &vr0->min, &vr0->max,\n-\t\tvr1->type, vr1->min, vr1->max);\n-  if (vr0->type == VR_VARYING)\n+  value_range saved (*vr0);\n+  value_range_kind vr0type = vr0->kind ();\n+  tree vr0min = vr0->min ();\n+  tree vr0max = vr0->max ();\n+  union_ranges (&vr0type, &vr0min, &vr0max,\n+\t\tvr1->kind (), vr1->min (), vr1->max ());\n+  *vr0 = value_range (vr0type, vr0min, vr0max);\n+  if (vr0->varying_p ())\n     {\n       /* Failed to find an efficient meet.  Before giving up and setting\n \t the result to VARYING, see if we can at least derive a useful\n \t anti-range.  */\n       if (range_includes_zero_p (&saved) == 0\n \t  && range_includes_zero_p (vr1) == 0)\n \t{\n-\t  set_value_range_to_nonnull (vr0, TREE_TYPE (saved.min));\n+\t  set_value_range_to_nonnull (vr0, saved.type ());\n \n \t  /* Since this meet operation did not result from the meeting of\n \t     two equivalent names, VR0 cannot have any equivalences.  */\n-\t  if (vr0->equiv)\n-\t    bitmap_clear (vr0->equiv);\n+\t  if (vr0->m_equiv)\n+\t    bitmap_clear (vr0->m_equiv);\n \t  return;\n \t}\n \n       set_value_range_to_varying (vr0);\n       return;\n     }\n-  set_and_canonicalize_value_range (vr0, vr0->type, vr0->min, vr0->max,\n-\t\t\t\t    vr0->equiv);\n-  if (vr0->type == VR_VARYING)\n+  vr0->set_and_canonicalize (vr0->kind (), vr0->min (), vr0->max (),\n+\t\t\t     vr0->equiv ());\n+  if (vr0->varying_p ())\n     return;\n \n   /* The resulting set of equivalences is always the intersection of\n      the two sets.  */\n-  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n-    bitmap_and_into (vr0->equiv, vr1->equiv);\n-  else if (vr0->equiv && !vr1->equiv)\n-    bitmap_clear (vr0->equiv);\n+  if (vr0->m_equiv && vr1->m_equiv && vr0->m_equiv != vr1->m_equiv)\n+    bitmap_and_into (vr0->m_equiv, vr1->m_equiv);\n+  else if (vr0->m_equiv && !vr1->m_equiv)\n+    bitmap_clear (vr0->m_equiv);\n }\n \n void\n-vrp_meet (value_range *vr0, const value_range *vr1)\n+value_range::union_ (const value_range *other)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Meeting\\n  \");\n-      dump_value_range (dump_file, vr0);\n+      dump_value_range (dump_file, this);\n       fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, vr1);\n+      dump_value_range (dump_file, other);\n       fprintf (dump_file, \"\\n\");\n     }\n-  vrp_meet_1 (vr0, vr1);\n+  union_helper (this, other);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, vr0);\n+      dump_value_range (dump_file, this);\n       fprintf (dump_file, \"\\n\");\n     }\n }\n \n-\n /* Visit all arguments for PHI node PHI that flow through executable\n    edges.  If a valid value range can be derived from all the incoming\n    value ranges, set a new range for the LHS of PHI.  */\n@@ -5995,7 +6156,7 @@ enum ssa_prop_result\n vrp_prop::visit_phi (gphi *phi)\n {\n   tree lhs = PHI_RESULT (phi);\n-  value_range vr_result = VR_INITIALIZER;\n+  value_range vr_result;\n   extract_range_from_phi_node (phi, &vr_result);\n   if (update_value_range (lhs, &vr_result))\n     {\n@@ -6008,7 +6169,7 @@ vrp_prop::visit_phi (gphi *phi)\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      if (vr_result.type == VR_VARYING)\n+      if (vr_result.varying_p ())\n \treturn SSA_PROP_VARYING;\n \n       return SSA_PROP_INTERESTING;\n@@ -6192,16 +6353,17 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n       op = lhs_of_dominating_assert (op, bb, stmt);\n \n       const value_range *vr = vr_values->get_value_range (op);\n-      if ((vr->type != VR_RANGE && vr->type != VR_ANTI_RANGE)\n-\t  || symbolic_range_p (vr))\n+      if (vr->undefined_p ()\n+\t  || vr->varying_p ()\n+\t  || vr->symbolic_p ())\n \treturn NULL_TREE;\n \n-      if (vr->type == VR_RANGE)\n+      if (vr->kind () == VR_RANGE)\n \t{\n \t  size_t i, j;\n \t  /* Get the range of labels that contain a part of the operand's\n \t     value range.  */\n-\t  find_case_label_range (switch_stmt, vr->min, vr->max, &i, &j);\n+\t  find_case_label_range (switch_stmt, vr->min (), vr->max (), &i, &j);\n \n \t  /* Is there only one such label?  */\n \t  if (i == j)\n@@ -6211,10 +6373,11 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t      /* The i'th label will be taken only if the value range of the\n \t\t operand is entirely within the bounds of this label.  */\n \t      if (CASE_HIGH (label) != NULL_TREE\n-\t\t  ? (tree_int_cst_compare (CASE_LOW (label), vr->min) <= 0\n-\t\t     && tree_int_cst_compare (CASE_HIGH (label), vr->max) >= 0)\n-\t\t  : (tree_int_cst_equal (CASE_LOW (label), vr->min)\n-\t\t     && tree_int_cst_equal (vr->min, vr->max)))\n+\t\t  ? (tree_int_cst_compare (CASE_LOW (label), vr->min ()) <= 0\n+\t\t     && tree_int_cst_compare (CASE_HIGH (label),\n+\t\t\t\t\t      vr->max ()) >= 0)\n+\t\t  : (tree_int_cst_equal (CASE_LOW (label), vr->min ())\n+\t\t     && tree_int_cst_equal (vr->min (), vr->max ())))\n \t\treturn label;\n \t    }\n \n@@ -6224,7 +6387,7 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t    return gimple_switch_label (switch_stmt, 0);\n \t}\n \n-      if (vr->type == VR_ANTI_RANGE)\n+      if (vr->kind () == VR_ANTI_RANGE)\n \t{\n \t  unsigned n = gimple_switch_num_labels (switch_stmt);\n \t  tree min_label = gimple_switch_label (switch_stmt, 1);\n@@ -6233,10 +6396,12 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t  /* The default label will be taken only if the anti-range of the\n \t     operand is entirely outside the bounds of all the (non-default)\n \t     case labels.  */\n-\t  if (tree_int_cst_compare (vr->min, CASE_LOW (min_label)) <= 0\n+\t  if (tree_int_cst_compare (vr->min (), CASE_LOW (min_label)) <= 0\n \t      && (CASE_HIGH (max_label) != NULL_TREE\n-\t\t  ? tree_int_cst_compare (vr->max, CASE_HIGH (max_label)) >= 0\n-\t\t  : tree_int_cst_compare (vr->max, CASE_LOW (max_label)) >= 0))\n+\t\t  ? tree_int_cst_compare (vr->max (),\n+\t\t\t\t\t  CASE_HIGH (max_label)) >= 0\n+\t\t  : tree_int_cst_compare (vr->max (),\n+\t\t\t\t\t  CASE_LOW (max_label)) >= 0))\n \t  return gimple_switch_label (switch_stmt, 0);\n \t}\n \n@@ -6253,11 +6418,12 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t{\n \t  edge dummy_e;\n \t  tree dummy_tree;\n-\t  value_range new_vr = VR_INITIALIZER;\n+\t  value_range new_vr;\n \t  vr_values->extract_range_from_stmt (stmt, &dummy_e,\n \t\t\t\t\t      &dummy_tree, &new_vr);\n-\t  if (range_int_cst_singleton_p (&new_vr))\n-\t    return new_vr.min;\n+\t  tree singleton;\n+\t  if (new_vr.singleton_p (&singleton))\n+\t    return singleton;\n \t}\n     }\n \n@@ -6429,20 +6595,16 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n \tcontinue;\n \n       const value_range *vr = get_value_range (name);\n-      if (!name\n-\t  || (vr->type == VR_VARYING)\n-\t  || (vr->type == VR_UNDEFINED)\n-\t  || (TREE_CODE (vr->min) != INTEGER_CST)\n-\t  || (TREE_CODE (vr->max) != INTEGER_CST))\n+      if (!name || !vr->constant_p ())\n \tcontinue;\n \n       if (POINTER_TYPE_P (TREE_TYPE (name))\n \t  && range_includes_zero_p (vr) == 0)\n \tset_ptr_nonnull (name);\n       else if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-\tset_range_info (name, vr->type,\n-\t\t\twi::to_wide (vr->min),\n-\t\t\twi::to_wide (vr->max));\n+\tset_range_info (name, vr->kind (),\n+\t\t\twi::to_wide (vr->min ()),\n+\t\t\twi::to_wide (vr->max ()));\n     }\n \n   /* If we're checking array refs, we want to merge information on\n@@ -6634,15 +6796,15 @@ determine_value_range_1 (value_range *vr, tree expr)\n {\n   if (BINARY_CLASS_P (expr))\n     {\n-      value_range vr0 = VR_INITIALIZER, vr1 = VR_INITIALIZER;\n+      value_range vr0, vr1;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       determine_value_range_1 (&vr1, TREE_OPERAND (expr, 1));\n       extract_range_from_binary_expr_1 (vr, TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t\t\t&vr0, &vr1);\n     }\n   else if (UNARY_CLASS_P (expr))\n     {\n-      value_range vr0 = VR_INITIALIZER;\n+      value_range vr0;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       extract_range_from_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t\t     &vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));\n@@ -6651,7 +6813,7 @@ determine_value_range_1 (value_range *vr, tree expr)\n     set_value_range_to_value (vr, expr, NULL);\n   else\n     {\n-      value_range_type kind;\n+      value_range_kind kind;\n       wide_int min, max;\n       /* For SSA names try to extract range info computed by VRP.  Otherwise\n \t fall back to varying.  */\n@@ -6668,18 +6830,16 @@ determine_value_range_1 (value_range *vr, tree expr)\n /* Compute a value-range for EXPR and set it in *MIN and *MAX.  Return\n    the determined range type.  */\n \n-value_range_type\n+value_range_kind\n determine_value_range (tree expr, wide_int *min, wide_int *max)\n {\n-  value_range vr = VR_INITIALIZER;\n+  value_range vr;\n   determine_value_range_1 (&vr, expr);\n-  if ((vr.type == VR_RANGE\n-       || vr.type == VR_ANTI_RANGE)\n-      && !symbolic_range_p (&vr))\n+  if (vr.constant_p ())\n     {\n-      *min = wi::to_wide (vr.min);\n-      *max = wi::to_wide (vr.max);\n-      return vr.type;\n+      *min = wi::to_wide (vr.min ());\n+      *max = wi::to_wide (vr.max ());\n+      return vr.kind ();\n     }\n \n   return VR_VARYING;"}, {"sha": "c251329a195fe8def91998562c2dccd2f09bf8fa", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 130, "deletions": 34, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -20,42 +20,143 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_VRP_H\n #define GCC_TREE_VRP_H\n \n-/* Type of value ranges.  See value_range below for a\n-   description of these types.  */\n-enum value_range_type { VR_UNDEFINED, VR_RANGE,\n-\t\t\tVR_ANTI_RANGE, VR_VARYING, VR_LAST };\n+/* Types of value ranges.  */\n+enum value_range_kind\n+{\n+  /* Empty range.  */\n+  VR_UNDEFINED,\n+  /* Range spans the entire domain.  */\n+  VR_VARYING,\n+  /* Range is [MIN, MAX].  */\n+  VR_RANGE,\n+  /* Range is ~[MIN, MAX].  */\n+  VR_ANTI_RANGE,\n+  /* Range is a nice guy.  */\n+  VR_LAST\n+};\n \n /* Range of values that can be associated with an SSA_NAME after VRP\n    has executed.  */\n-struct GTY((for_user)) value_range\n+class GTY((for_user)) value_range\n {\n-  /* Lattice value represented by this range.  */\n-  enum value_range_type type;\n+ public:\n+  value_range ();\n+  value_range (value_range_kind, tree, tree, bitmap = NULL);\n+  void update (value_range_kind, tree, tree);\n+  bool operator== (const value_range &) const;\n+  bool operator!= (const value_range &) const;\n+  void intersect (const value_range *);\n+  void union_ (const value_range *);\n+\n+  /* Types of value ranges.  */\n+  bool undefined_p () const;\n+  bool varying_p () const;\n+  bool symbolic_p () const;\n+  bool constant_p () const;\n+  void set_undefined ();\n+  void set_varying ();\n+\n+  /* Equivalence bitmap methods.  */\n+  bitmap equiv () const;\n+  void equiv_clear ();\n+  void equiv_add (const_tree, const value_range *, bitmap_obstack * = NULL);\n+\n+  /* Misc methods.  */\n+  tree type () const;\n+  bool null_p () const;\n+  bool may_contain_p (tree) const;\n+  bool singleton_p (tree *result = NULL) const;\n+  void deep_copy (const value_range *);\n+  bool ignore_equivs_equal_p (const value_range &) const;\n+  void set_and_canonicalize (enum value_range_kind, tree, tree, bitmap);\n+  void dump (FILE *) const;\n+  void dump () const;\n+\n+  enum value_range_kind kind () const;\n+  tree min () const;\n+  tree max () const;\n+\n+ private:\n+  void set (value_range_kind, tree, tree, bitmap);\n+  void check ();\n+  bool equal_p (const value_range &, bool ignore_equivs) const;\n+  void intersect_helper (value_range *, const value_range *);\n+  void union_helper (value_range *, const value_range *);\n+\n+  enum value_range_kind m_kind;\n+ public:\n+  /* These should be private, but GTY is a piece of crap.  */\n+  tree m_min;\n+  tree m_max;\n+  /* Set of SSA names whose value ranges are equivalent to this one.\n+     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n+  bitmap m_equiv;\n+};\n \n-  /* Minimum and maximum values represented by this range.  These\n-     values should be interpreted as follows:\n+inline\n+value_range::value_range ()\n+{\n+  m_kind = VR_UNDEFINED;\n+  m_min = m_max = NULL;\n+  m_equiv = NULL;\n+}\n \n-\t- If TYPE is VR_UNDEFINED or VR_VARYING then MIN and MAX must\n-\t  be NULL.\n+/* Return the kind of this range.  */\n \n-\t- If TYPE == VR_RANGE then MIN holds the minimum value and\n-\t  MAX holds the maximum value of the range [MIN, MAX].\n+inline value_range_kind\n+value_range::kind () const\n+{\n+  return m_kind;\n+}\n \n-\t- If TYPE == ANTI_RANGE the variable is known to NOT\n-\t  take any values in the range [MIN, MAX].  */\n-  tree min;\n-  tree max;\n+inline bitmap\n+value_range::equiv () const\n+{\n+  return m_equiv;\n+}\n \n-  /* Set of SSA names whose value ranges are equivalent to this one.\n-     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n-  bitmap equiv;\n+/* Return the lower bound.  */\n \n-  /* Dump value range to stderr.  */\n-  void dump () const;\n-};\n+inline tree\n+value_range::min () const\n+{\n+  return m_min;\n+}\n+\n+/* Return the upper bound.  */\n+\n+inline tree\n+value_range::max () const\n+{\n+  return m_max;\n+}\n+\n+/* Return TRUE if range spans the entire possible domain.  */\n+\n+inline bool\n+value_range::varying_p () const\n+{\n+  return m_kind == VR_VARYING;\n+}\n+\n+/* Return TRUE if range is undefined (essentially the empty set).  */\n+\n+inline bool\n+value_range::undefined_p () const\n+{\n+  return m_kind == VR_UNDEFINED;\n+}\n+\n+/* Return TRUE if range is the constant zero.  */\n+\n+inline bool\n+value_range::null_p () const\n+{\n+  return (m_kind == VR_RANGE\n+\t  && integer_zerop (m_min)\n+\t  && integer_zerop (m_max));\n+}\n \n-extern void vrp_intersect_ranges (value_range *vr0, const value_range *vr1);\n-extern void vrp_meet (value_range *vr0, const value_range *vr1);\n extern void dump_value_range (FILE *, const value_range *);\n extern void extract_range_from_unary_expr (value_range *vr,\n \t\t\t\t\t   enum tree_code code,\n@@ -64,8 +165,8 @@ extern void extract_range_from_unary_expr (value_range *vr,\n \t\t\t\t\t   tree op0_type);\n \n extern bool vrp_operand_equal_p (const_tree, const_tree);\n-extern enum value_range_type intersect_range_with_nonzero_bits\n-  (enum value_range_type, wide_int *, wide_int *, const wide_int &, signop);\n+extern enum value_range_kind intersect_range_with_nonzero_bits\n+  (enum value_range_kind, wide_int *, wide_int *, const wide_int &, signop);\n \n struct assert_info\n {\n@@ -90,19 +191,14 @@ extern bool range_includes_zero_p (const value_range *);\n extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n \n extern void set_value_range_to_nonnull (value_range *, tree);\n-extern void set_value_range (value_range *, enum value_range_type, tree,\n+extern void set_value_range (value_range *, enum value_range_kind, tree,\n \t\t\t     tree, bitmap);\n-extern void set_and_canonicalize_value_range (value_range *,\n-\t\t\t\t\t      enum value_range_type,\n-\t\t\t\t\t      tree, tree, bitmap);\n extern bool vrp_bitmap_equal_p (const_bitmap, const_bitmap);\n extern tree value_range_constant_singleton (const value_range *);\n-extern bool symbolic_range_p (const value_range *);\n extern int compare_values (tree, tree);\n extern int compare_values_warnv (tree, tree, bool *);\n extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n-extern void copy_value_range (value_range *, const value_range *);\n extern void set_value_range_to_value (value_range *, tree, bitmap);\n extern void extract_range_from_binary_expr_1 (value_range *, enum tree_code,\n \t\t\t\t\t      tree, const value_range *,\n@@ -121,5 +217,5 @@ extern bool range_int_cst_singleton_p (const value_range *);\n extern int value_inside_range (tree, tree, tree);\n extern tree get_single_symbol (tree, bool *, tree *);\n extern void maybe_set_nonzero_bits (edge, tree);\n-extern value_range_type determine_value_range (tree, wide_int *, wide_int *);\n+extern value_range_kind determine_value_range (tree, wide_int *, wide_int *);\n #endif /* GCC_TREE_VRP_H */"}, {"sha": "8c9fd159146883bcc4c52209ee9860bf49cfdaf1", "filename": "gcc/vr-values.c", "status": "modified", "additions": 290, "deletions": 348, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -55,7 +55,7 @@ static inline void\n set_value_range_to_nonnegative (value_range *vr, tree type)\n {\n   tree zero = build_int_cst (type, 0);\n-  set_value_range (vr, VR_RANGE, zero, vrp_val_max (type), vr->equiv);\n+  vr->update (VR_RANGE, zero, vrp_val_max (type));\n }\n \n /* Set value range VR to a range of a truthvalue of type TYPE.  */\n@@ -66,9 +66,7 @@ set_value_range_to_truthvalue (value_range *vr, tree type)\n   if (TYPE_PRECISION (type) == 1)\n     set_value_range_to_varying (vr);\n   else\n-    set_value_range (vr, VR_RANGE,\n-\t\t     build_int_cst (type, 0), build_int_cst (type, 1),\n-\t\t     vr->equiv);\n+    vr->update (VR_RANGE, build_int_cst (type, 0), build_int_cst (type, 1));\n }\n \n \n@@ -80,8 +78,7 @@ set_value_range_to_truthvalue (value_range *vr, tree type)\n value_range *\n vr_values::get_value_range (const_tree var)\n {\n-  static const value_range vr_const_varying\n-    = { VR_VARYING, NULL_TREE, NULL_TREE, NULL };\n+  static const value_range vr_const_varying (VR_VARYING, NULL, NULL);\n   value_range *vr;\n   tree sym;\n   unsigned ver = SSA_NAME_VERSION (var);\n@@ -106,10 +103,7 @@ vr_values::get_value_range (const_tree var)\n \n   /* Create a default value range.  */\n   vr_value[ver] = vr = vrp_value_range_pool.allocate ();\n-  memset (vr, 0, sizeof (*vr));\n-\n-  /* Defer allocating the equivalence set.  */\n-  vr->equiv = NULL;\n+  vr->set_undefined ();\n \n   /* If VAR is a default definition of a parameter, the variable can\n      take any value in VAR's type.  */\n@@ -128,7 +122,7 @@ vr_values::get_value_range (const_tree var)\n \t  else if (INTEGRAL_TYPE_P (TREE_TYPE (sym)))\n \t    {\n \t      wide_int min, max;\n-\t      value_range_type rtype = get_range_info (var, &min, &max);\n+\t      value_range_kind rtype = get_range_info (var, &min, &max);\n \t      if (rtype == VR_RANGE || rtype == VR_ANTI_RANGE)\n \t\tset_value_range (vr, rtype,\n \t\t\t\t wide_int_to_tree (TREE_TYPE (var), min),\n@@ -159,7 +153,7 @@ vr_values::set_defs_to_varying (gimple *stmt)\n     {\n       value_range *vr = get_value_range (def);\n       /* Avoid writing to vr_const_varying get_value_range may return.  */\n-      if (vr->type != VR_VARYING)\n+      if (!vr->varying_p ())\n \tset_value_range_to_varying (vr);\n     }\n }\n@@ -185,24 +179,21 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n   if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n     {\n       wide_int min, max;\n-      value_range_type rtype = get_range_info (var, &min, &max);\n+      value_range_kind rtype = get_range_info (var, &min, &max);\n       if (rtype == VR_RANGE || rtype == VR_ANTI_RANGE)\n \t{\n \t  tree nr_min, nr_max;\n \t  nr_min = wide_int_to_tree (TREE_TYPE (var), min);\n \t  nr_max = wide_int_to_tree (TREE_TYPE (var), max);\n-\t  value_range nr = VR_INITIALIZER;\n-\t  set_and_canonicalize_value_range (&nr, rtype, nr_min, nr_max, NULL);\n-\t  vrp_intersect_ranges (new_vr, &nr);\n+\t  value_range nr;\n+\t  nr.set_and_canonicalize (rtype, nr_min, nr_max, NULL);\n+\t  new_vr->intersect (&nr);\n \t}\n     }\n \n   /* Update the value range, if necessary.  */\n   old_vr = get_value_range (var);\n-  is_new = old_vr->type != new_vr->type\n-\t   || !vrp_operand_equal_p (old_vr->min, new_vr->min)\n-\t   || !vrp_operand_equal_p (old_vr->max, new_vr->max)\n-\t   || !vrp_bitmap_equal_p (old_vr->equiv, new_vr->equiv);\n+  is_new = *old_vr != *new_vr;\n \n   if (is_new)\n     {\n@@ -212,40 +203,22 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n \t the same.  We may not have is_new when transitioning to\n \t UNDEFINED.  If old_vr->type is VARYING, we shouldn't be\n \t called.  */\n-      if (new_vr->type == VR_UNDEFINED)\n+      if (new_vr->undefined_p ())\n \t{\n-\t  BITMAP_FREE (new_vr->equiv);\n \t  set_value_range_to_varying (old_vr);\n \t  set_value_range_to_varying (new_vr);\n \t  return true;\n \t}\n       else\n-\tset_value_range (old_vr, new_vr->type, new_vr->min, new_vr->max,\n-\t\t\t new_vr->equiv);\n+\tset_value_range (old_vr, new_vr->kind (),\n+\t\t\t new_vr->min (), new_vr->max (), new_vr->equiv ());\n     }\n \n-  BITMAP_FREE (new_vr->equiv);\n+  new_vr->equiv_clear ();\n \n   return is_new;\n }\n \n-\n-/* Add VAR and VAR's equivalence set to EQUIV.  This is the central\n-   point where equivalence processing can be turned on/off.  */\n-\n-void\n-vr_values::add_equivalence (bitmap *equiv, const_tree var)\n-{\n-  unsigned ver = SSA_NAME_VERSION (var);\n-  value_range *vr = get_value_range (var);\n-\n-  if (*equiv == NULL)\n-    *equiv = BITMAP_ALLOC (&vrp_equiv_obstack);\n-  bitmap_set_bit (*equiv, ver);\n-  if (vr && vr->equiv)\n-    bitmap_ior_into (*equiv, vr->equiv);\n-}\n-\n /* Return true if value range VR involves exactly one symbol SYM.  */\n \n static bool\n@@ -254,16 +227,16 @@ symbolic_range_based_on_p (value_range *vr, const_tree sym)\n   bool neg, min_has_symbol, max_has_symbol;\n   tree inv;\n \n-  if (is_gimple_min_invariant (vr->min))\n+  if (is_gimple_min_invariant (vr->min ()))\n     min_has_symbol = false;\n-  else if (get_single_symbol (vr->min, &neg, &inv) == sym)\n+  else if (get_single_symbol (vr->min (), &neg, &inv) == sym)\n     min_has_symbol = true;\n   else\n     return false;\n \n-  if (is_gimple_min_invariant (vr->max))\n+  if (is_gimple_min_invariant (vr->max ()))\n     max_has_symbol = false;\n-  else if (get_single_symbol (vr->max, &neg, &inv) == sym)\n+  else if (get_single_symbol (vr->max (), &neg, &inv) == sym)\n     max_has_symbol = true;\n   else\n     return false;\n@@ -403,9 +376,9 @@ vr_values::op_with_boolean_value_range_p (tree op)\n     return false;\n \n   vr = get_value_range (op);\n-  return (vr->type == VR_RANGE\n-\t  && integer_zerop (vr->min)\n-\t  && integer_onep (vr->max));\n+  return (vr->kind () == VR_RANGE\n+\t  && integer_zerop (vr->min ())\n+\t  && integer_onep (vr->max ()));\n }\n \n /* Extract value range information for VAR when (OP COND_CODE LIMIT) is\n@@ -438,21 +411,22 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \n   /* LIMIT's range is only interesting if it has any useful information.  */\n   if (! limit_vr\n-      || limit_vr->type == VR_UNDEFINED\n-      || limit_vr->type == VR_VARYING\n-      || (symbolic_range_p (limit_vr)\n-\t  && ! (limit_vr->type == VR_RANGE\n-\t\t&& (limit_vr->min == limit_vr->max\n-\t\t    || operand_equal_p (limit_vr->min, limit_vr->max, 0)))))\n+      || limit_vr->undefined_p ()\n+      || limit_vr->varying_p ()\n+      || (limit_vr->symbolic_p ()\n+\t  && ! (limit_vr->kind () == VR_RANGE\n+\t\t&& (limit_vr->min () == limit_vr->max ()\n+\t\t    || operand_equal_p (limit_vr->min (),\n+\t\t\t\t\tlimit_vr->max (), 0)))))\n     limit_vr = NULL;\n \n   /* Initially, the new range has the same set of equivalences of\n      VAR's range.  This will be revised before returning the final\n      value.  Since assertions may be chained via mutually exclusive\n      predicates, we will need to trim the set of equivalences before\n      we are done.  */\n-  gcc_assert (vr_p->equiv == NULL);\n-  add_equivalence (&vr_p->equiv, var);\n+  gcc_assert (vr_p->equiv () == NULL);\n+  vr_p->equiv_add (var, get_value_range (var), &vrp_equiv_obstack);\n \n   /* Extract a new range based on the asserted comparison for VAR and\n      LIMIT's value range.  Notice that if LIMIT has an anti-range, we\n@@ -488,26 +462,24 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n       max = force_fit_type (TREE_TYPE (var), wi::to_widest (max), 0, false);\n \n       /* We can transform a max, min range to an anti-range or\n-         vice-versa.  Use set_and_canonicalize_value_range which does\n-\t this for us.  */\n+         vice-versa.  Use set_and_canonicalize which does this for\n+         us.  */\n       if (cond_code == LE_EXPR)\n-        set_and_canonicalize_value_range (vr_p, VR_RANGE,\n-\t\t\t\t\t  min, max, vr_p->equiv);\n+        vr_p->set_and_canonicalize (VR_RANGE, min, max, vr_p->equiv ());\n       else if (cond_code == GT_EXPR)\n-        set_and_canonicalize_value_range (vr_p, VR_ANTI_RANGE,\n-\t\t\t\t\t  min, max, vr_p->equiv);\n+        vr_p->set_and_canonicalize (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n       else\n \tgcc_unreachable ();\n     }\n   else if (cond_code == EQ_EXPR)\n     {\n-      enum value_range_type range_type;\n+      enum value_range_kind range_type;\n \n       if (limit_vr)\n \t{\n-\t  range_type = limit_vr->type;\n-\t  min = limit_vr->min;\n-\t  max = limit_vr->max;\n+\t  range_type = limit_vr->kind ();\n+\t  min = limit_vr->min ();\n+\t  max = limit_vr->max ();\n \t}\n       else\n \t{\n@@ -516,13 +488,13 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t  max = limit;\n \t}\n \n-      set_value_range (vr_p, range_type, min, max, vr_p->equiv);\n+      vr_p->update (range_type, min, max);\n \n       /* When asserting the equality VAR == LIMIT and LIMIT is another\n \t SSA name, the new range will also inherit the equivalence set\n \t from LIMIT.  */\n       if (TREE_CODE (limit) == SSA_NAME)\n-\tadd_equivalence (&vr_p->equiv, limit);\n+\tvr_p->equiv_add (limit, get_value_range (limit), &vrp_equiv_obstack);\n     }\n   else if (cond_code == NE_EXPR)\n     {\n@@ -547,11 +519,11 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t (i.e., LIMIT_VR->MIN == LIMIT_VR->MAX).  In that case,\n \t build the anti-range ~[LIMIT_VR->MIN, LIMIT_VR->MAX].  */\n       if (limit_vr\n-\t  && limit_vr->type == VR_RANGE\n-\t  && compare_values (limit_vr->min, limit_vr->max) == 0)\n+\t  && limit_vr->kind () == VR_RANGE\n+\t  && compare_values (limit_vr->min (), limit_vr->max ()) == 0)\n \t{\n-\t  min = limit_vr->min;\n-\t  max = limit_vr->max;\n+\t  min = limit_vr->min ();\n+\t  max = limit_vr->max ();\n \t}\n       else\n \t{\n@@ -567,21 +539,20 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t  && vrp_val_is_max (max))\n \tmin = max = limit;\n \n-      set_and_canonicalize_value_range (vr_p, VR_ANTI_RANGE,\n-\t\t\t\t\tmin, max, vr_p->equiv);\n+      vr_p->set_and_canonicalize (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n     }\n   else if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n     {\n       min = TYPE_MIN_VALUE (type);\n \n-      if (limit_vr == NULL || limit_vr->type == VR_ANTI_RANGE)\n+      if (limit_vr == NULL || limit_vr->kind () == VR_ANTI_RANGE)\n \tmax = limit;\n       else\n \t{\n \t  /* If LIMIT_VR is of the form [N1, N2], we need to build the\n \t     range [MIN, N2] for LE_EXPR and [MIN, N2 - 1] for\n \t     LT_EXPR.  */\n-\t  max = limit_vr->max;\n+\t  max = limit_vr->max ();\n \t}\n \n       /* If the maximum value forces us to be out of bounds, simply punt.\n@@ -607,21 +578,21 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\tTREE_NO_WARNING (max) = 1;\n \t    }\n \n-\t  set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t  vr_p->update (VR_RANGE, min, max);\n \t}\n     }\n   else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n     {\n       max = TYPE_MAX_VALUE (type);\n \n-      if (limit_vr == NULL || limit_vr->type == VR_ANTI_RANGE)\n+      if (limit_vr == NULL || limit_vr->kind () == VR_ANTI_RANGE)\n \tmin = limit;\n       else\n \t{\n \t  /* If LIMIT_VR is of the form [N1, N2], we need to build the\n \t     range [N1, MAX] for GE_EXPR and [N1 + 1, MAX] for\n \t     GT_EXPR.  */\n-\t  min = limit_vr->min;\n+\t  min = limit_vr->min ();\n \t}\n \n       /* If the minimum value forces us to be out of bounds, simply punt.\n@@ -647,14 +618,14 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\tTREE_NO_WARNING (min) = 1;\n \t    }\n \n-\t  set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t  vr_p->update (VR_RANGE, min, max);\n \t}\n     }\n   else\n     gcc_unreachable ();\n \n   /* Finally intersect the new range with what we already know about var.  */\n-  vrp_intersect_ranges (vr_p, get_value_range (var));\n+  vr_p->intersect (get_value_range (var));\n }\n \n /* Extract value range information from an ASSERT_EXPR EXPR and store\n@@ -711,12 +682,12 @@ vr_values::extract_range_from_ssa_name (value_range *vr, tree var)\n {\n   value_range *var_vr = get_value_range (var);\n \n-  if (var_vr->type != VR_VARYING)\n-    copy_value_range (vr, var_vr);\n+  if (!var_vr->varying_p ())\n+    vr->deep_copy (var_vr);\n   else\n     set_value_range (vr, VR_RANGE, var, var, NULL);\n \n-  add_equivalence (&vr->equiv, var);\n+  vr->equiv_add (var, get_value_range (var), &vrp_equiv_obstack);\n }\n \n /* Extract range information from a binary expression OP0 CODE OP1 based on\n@@ -728,11 +699,9 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \t\t\t\t\t   enum tree_code code,\n \t\t\t\t\t   tree expr_type, tree op0, tree op1)\n {\n-  value_range vr0 = VR_INITIALIZER;\n-  value_range vr1 = VR_INITIALIZER;\n-\n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n+  value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n@@ -752,18 +721,14 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n   if (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0)))\n     {\n-      if (vr0.type == VR_VARYING && vr1.type != VR_VARYING)\n-\t{\n-\t  vr0.type = VR_RANGE;\n-\t  vr0.min = vrp_val_min (expr_type);\n-\t  vr0.max = vrp_val_max (expr_type);\n-\t}\n-      else if (vr1.type == VR_VARYING && vr0.type != VR_VARYING)\n-\t{\n-\t  vr1.type = VR_RANGE;\n-\t  vr1.min = vrp_val_min (expr_type);\n-\t  vr1.max = vrp_val_max (expr_type);\n-\t}\n+      if (vr0.varying_p () && !vr1.varying_p ())\n+\tvr0 = value_range (VR_RANGE,\n+\t\t\t   vrp_val_min (expr_type),\n+\t\t\t   vrp_val_max (expr_type));\n+      else if (vr1.varying_p () && !vr0.varying_p ())\n+\tvr1 = value_range (VR_RANGE,\n+\t\t\t   vrp_val_min (expr_type),\n+\t\t\t   vrp_val_max (expr_type));\n     }\n \n   extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &vr1);\n@@ -773,7 +738,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n      n = def - arg\n      Here the range for n can be set to [0, PTRDIFF_MAX - 1]. */\n \n-  if (vr->type == VR_VARYING\n+  if (vr->varying_p ()\n       && code == POINTER_DIFF_EXPR\n       && TREE_CODE (op0) == SSA_NAME\n       && TREE_CODE (op1) == SSA_NAME)\n@@ -806,21 +771,21 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n      symbolic comparison.  When a bound of the range of the first operand\n      is invariant, we set the corresponding bound of the new range to INF\n      in order to avoid recursing on the range of the second operand.  */\n-  if (vr->type == VR_VARYING\n+  if (vr->varying_p ()\n       && (code == PLUS_EXPR || code == MINUS_EXPR)\n       && TREE_CODE (op1) == SSA_NAME\n-      && vr0.type == VR_RANGE\n+      && vr0.kind () == VR_RANGE\n       && symbolic_range_based_on_p (&vr0, op1))\n     {\n       const bool minus_p = (code == MINUS_EXPR);\n-      value_range n_vr1 = VR_INITIALIZER;\n+      value_range n_vr1;\n \n       /* Try with VR0 and [-INF, OP1].  */\n-      if (is_gimple_min_invariant (minus_p ? vr0.max : vr0.min))\n+      if (is_gimple_min_invariant (minus_p ? vr0.max () : vr0.min ()))\n \tset_value_range (&n_vr1, VR_RANGE, vrp_val_min (expr_type), op1, NULL);\n \n       /* Try with VR0 and [OP1, +INF].  */\n-      else if (is_gimple_min_invariant (minus_p ? vr0.min : vr0.max))\n+      else if (is_gimple_min_invariant (minus_p ? vr0.min () : vr0.max ()))\n \tset_value_range (&n_vr1, VR_RANGE, op1, vrp_val_max (expr_type), NULL);\n \n       /* Try with VR0 and [OP1, OP1].  */\n@@ -830,21 +795,21 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n       extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &n_vr1);\n     }\n \n-  if (vr->type == VR_VARYING\n+  if (vr->varying_p ()\n       && (code == PLUS_EXPR || code == MINUS_EXPR)\n       && TREE_CODE (op0) == SSA_NAME\n-      && vr1.type == VR_RANGE\n+      && vr1.kind () == VR_RANGE\n       && symbolic_range_based_on_p (&vr1, op0))\n     {\n       const bool minus_p = (code == MINUS_EXPR);\n-      value_range n_vr0 = VR_INITIALIZER;\n+      value_range n_vr0;\n \n       /* Try with [-INF, OP0] and VR1.  */\n-      if (is_gimple_min_invariant (minus_p ? vr1.max : vr1.min))\n+      if (is_gimple_min_invariant (minus_p ? vr1.max () : vr1.min ()))\n \tset_value_range (&n_vr0, VR_RANGE, vrp_val_min (expr_type), op0, NULL);\n \n       /* Try with [OP0, +INF] and VR1.  */\n-      else if (is_gimple_min_invariant (minus_p ? vr1.min : vr1.max))\n+      else if (is_gimple_min_invariant (minus_p ? vr1.min (): vr1.max ()))\n \tset_value_range (&n_vr0, VR_RANGE, op0, vrp_val_max (expr_type), NULL);\n \n       /* Try with [OP0, OP0] and VR1.  */\n@@ -858,15 +823,15 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n      op1's range is ~[op0,op0] or vice-versa, then we\n      can derive a non-null range.  This happens often for\n      pointer subtraction.  */\n-  if (vr->type == VR_VARYING\n+  if (vr->varying_p ()\n       && (code == MINUS_EXPR || code == POINTER_DIFF_EXPR)\n       && TREE_CODE (op0) == SSA_NAME\n-      && ((vr0.type == VR_ANTI_RANGE\n-\t   && vr0.min == op1\n-\t   && vr0.min == vr0.max)\n-\t  || (vr1.type == VR_ANTI_RANGE\n-\t      && vr1.min == op0\n-\t      && vr1.min == vr1.max)))\n+      && ((vr0.kind () == VR_ANTI_RANGE\n+\t   && vr0.min () == op1\n+\t   && vr0.min () == vr0.max ())\n+\t  || (vr1.kind () == VR_ANTI_RANGE\n+\t      && vr1.min () == op0\n+\t      && vr1.min () == vr1.max ())))\n       set_value_range_to_nonnull (vr, expr_type);\n }\n \n@@ -878,7 +843,7 @@ void\n vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n \t\t\t\t\t  tree type, tree op0)\n {\n-  value_range vr0 = VR_INITIALIZER;\n+  value_range vr0;\n \n   /* Get value ranges for the operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n@@ -899,21 +864,19 @@ vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n void\n vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n {\n-  tree op0, op1;\n-  value_range vr0 = VR_INITIALIZER;\n-  value_range vr1 = VR_INITIALIZER;\n-\n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n-  op0 = gimple_assign_rhs2 (stmt);\n+  tree op0 = gimple_assign_rhs2 (stmt);\n+  value_range vr0;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n     set_value_range_to_varying (&vr0);\n \n-  op1 = gimple_assign_rhs3 (stmt);\n+  tree op1 = gimple_assign_rhs3 (stmt);\n+  value_range vr1;\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n@@ -922,8 +885,8 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n     set_value_range_to_varying (&vr1);\n \n   /* The resulting value range is the union of the operand ranges */\n-  copy_value_range (vr, &vr0);\n-  vrp_meet (vr, &vr1);\n+  vr->deep_copy (&vr0);\n+  vr->union_ (&vr1);\n }\n \n \n@@ -946,9 +909,9 @@ vr_values::extract_range_from_comparison (value_range *vr, enum tree_code code,\n \t type.  */\n       val = fold_convert (type, val);\n       if (is_gimple_min_invariant (val))\n-\tset_value_range_to_value (vr, val, vr->equiv);\n+\tset_value_range_to_value (vr, val, vr->equiv ());\n       else\n-\tset_value_range (vr, VR_RANGE, val, val, vr->equiv);\n+\tvr->update (VR_RANGE, val, val);\n     }\n   else\n     /* The result of a comparison is always true or false.  */\n@@ -965,8 +928,7 @@ bool\n vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n \t\t\t\t\t tree op0, tree op1, bool *ovf)\n {\n-  value_range vr0 = VR_INITIALIZER;\n-  value_range vr1 = VR_INITIALIZER;\n+  value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *get_value_range (op0);\n   else if (TREE_CODE (op0) == INTEGER_CST)\n@@ -981,29 +943,31 @@ vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n   else\n     set_value_range_to_varying (&vr1);\n \n+  tree vr0min = vr0.min (), vr0max = vr0.max ();\n+  tree vr1min = vr1.min (), vr1max = vr1.max ();\n   if (!range_int_cst_p (&vr0)\n-      || TREE_OVERFLOW (vr0.min)\n-      || TREE_OVERFLOW (vr0.max))\n+      || TREE_OVERFLOW (vr0min)\n+      || TREE_OVERFLOW (vr0max))\n     {\n-      vr0.min = vrp_val_min (TREE_TYPE (op0));\n-      vr0.max = vrp_val_max (TREE_TYPE (op0));\n+      vr0min = vrp_val_min (TREE_TYPE (op0));\n+      vr0max = vrp_val_max (TREE_TYPE (op0));\n     }\n   if (!range_int_cst_p (&vr1)\n-      || TREE_OVERFLOW (vr1.min)\n-      || TREE_OVERFLOW (vr1.max))\n+      || TREE_OVERFLOW (vr1min)\n+      || TREE_OVERFLOW (vr1max))\n     {\n-      vr1.min = vrp_val_min (TREE_TYPE (op1));\n-      vr1.max = vrp_val_max (TREE_TYPE (op1));\n+      vr1min = vrp_val_min (TREE_TYPE (op1));\n+      vr1max = vrp_val_max (TREE_TYPE (op1));\n     }\n-  *ovf = arith_overflowed_p (subcode, type, vr0.min,\n-\t\t\t     subcode == MINUS_EXPR ? vr1.max : vr1.min);\n-  if (arith_overflowed_p (subcode, type, vr0.max,\n-\t\t\t  subcode == MINUS_EXPR ? vr1.min : vr1.max) != *ovf)\n+  *ovf = arith_overflowed_p (subcode, type, vr0min,\n+\t\t\t     subcode == MINUS_EXPR ? vr1max : vr1min);\n+  if (arith_overflowed_p (subcode, type, vr0max,\n+\t\t\t  subcode == MINUS_EXPR ? vr1min : vr1max) != *ovf)\n     return false;\n   if (subcode == MULT_EXPR)\n     {\n-      if (arith_overflowed_p (subcode, type, vr0.min, vr1.max) != *ovf\n-\t  || arith_overflowed_p (subcode, type, vr0.max, vr1.min) != *ovf)\n+      if (arith_overflowed_p (subcode, type, vr0min, vr1max) != *ovf\n+\t  || arith_overflowed_p (subcode, type, vr0max, vr1min) != *ovf)\n \treturn false;\n     }\n   if (*ovf)\n@@ -1016,10 +980,10 @@ vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n       widest_int wmin, wmax;\n       widest_int w[4];\n       int i;\n-      w[0] = wi::to_widest (vr0.min);\n-      w[1] = wi::to_widest (vr0.max);\n-      w[2] = wi::to_widest (vr1.min);\n-      w[3] = wi::to_widest (vr1.max);\n+      w[0] = wi::to_widest (vr0min);\n+      w[1] = wi::to_widest (vr0max);\n+      w[2] = wi::to_widest (vr1min);\n+      w[3] = wi::to_widest (vr1max);\n       for (i = 0; i < 4; i++)\n \t{\n \t  widest_int wt;\n@@ -1113,11 +1077,11 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\tmini = 1;\n \t      /* If some high bits are known to be zero,\n \t\t we can decrease the maximum.  */\n-\t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n-\t\t  && !operand_less_p (vr0->min,\n-\t\t\t\t      build_zero_cst (TREE_TYPE (vr0->min))))\n-\t\tmaxi = tree_floor_log2 (vr0->max) + 1;\n+\t      if (vr0->kind () == VR_RANGE\n+\t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST\n+\t\t  && !operand_less_p (vr0->min (),\n+\t\t\t\t      build_zero_cst (TREE_TYPE (vr0->min ()))))\n+\t\tmaxi = tree_floor_log2 (vr0->max ()) + 1;\n \t    }\n \t  goto bitop_builtin;\n \t  /* __builtin_parity* returns [0, 1].  */\n@@ -1148,15 +1112,15 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t      value_range *vr0 = get_value_range (arg);\n \t      /* From clz of VR_RANGE minimum we can compute\n \t\t result maximum.  */\n-\t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->min) == INTEGER_CST)\n+\t      if (vr0->kind () == VR_RANGE\n+\t\t  && TREE_CODE (vr0->min ()) == INTEGER_CST)\n \t\t{\n-\t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min);\n+\t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min ());\n \t\t  if (maxi != prec)\n \t\t    mini = 0;\n \t\t}\n-\t      else if (vr0->type == VR_ANTI_RANGE\n-\t\t       && integer_zerop (vr0->min))\n+\t      else if (vr0->kind () == VR_ANTI_RANGE\n+\t\t       && integer_zerop (vr0->min ()))\n \t\t{\n \t\t  maxi = prec - 1;\n \t\t  mini = 0;\n@@ -1165,10 +1129,10 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\tbreak;\n \t      /* From clz of VR_RANGE maximum we can compute\n \t\t result minimum.  */\n-\t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max) == INTEGER_CST)\n+\t      if (vr0->kind () == VR_RANGE\n+\t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST)\n \t\t{\n-\t\t  mini = prec - 1 - tree_floor_log2 (vr0->max);\n+\t\t  mini = prec - 1 - tree_floor_log2 (vr0->max ());\n \t\t  if (mini == prec)\n \t\t    break;\n \t\t}\n@@ -1204,20 +1168,20 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t    {\n \t      value_range *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then use [0, prec - 1].  */\n-\t      if ((vr0->type == VR_RANGE\n-\t\t   && integer_nonzerop (vr0->min))\n-\t\t  || (vr0->type == VR_ANTI_RANGE\n-\t\t      && integer_zerop (vr0->min)))\n+\t      if ((vr0->kind () == VR_RANGE\n+\t\t   && integer_nonzerop (vr0->min ()))\n+\t\t  || (vr0->kind () == VR_ANTI_RANGE\n+\t\t      && integer_zerop (vr0->min ())))\n \t\t{\n \t\t  mini = 0;\n \t\t  maxi = prec - 1;\n \t\t}\n \t      /* If some high bits are known to be zero,\n \t\t we can decrease the result maximum.  */\n-\t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max) == INTEGER_CST)\n+\t      if (vr0->kind () == VR_RANGE\n+\t\t  && TREE_CODE (vr0->max ()) == INTEGER_CST)\n \t\t{\n-\t\t  maxi = tree_floor_log2 (vr0->max);\n+\t\t  maxi = tree_floor_log2 (vr0->max ());\n \t\t  /* For vr0 [0, 0] give up.  */\n \t\t  if (maxi == -1)\n \t\t    break;\n@@ -1302,9 +1266,9 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t     this should have been already folded and if not, it\n \t     wasn't folded because of overflow.  Avoid removing the\n \t     UBSAN_CHECK_* calls in that case.  */\n-\t  if (vr->type == VR_RANGE\n-\t      && (vr->min == vr->max\n-\t\t  || operand_equal_p (vr->min, vr->max, 0)))\n+\t  if (vr->kind () == VR_RANGE\n+\t      && (vr->min () == vr->max ()\n+\t\t  || operand_equal_p (vr->min (), vr->max (), 0)))\n \t    set_value_range_to_varying (vr);\n \t  return;\n \t}\n@@ -1381,8 +1345,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      value_range vr0 = VR_INITIALIZER;\n-\t\t      value_range vr1 = VR_INITIALIZER;\n+\t\t      value_range vr0, vr1;\n \t\t      bool saved_flag_wrapv = flag_wrapv;\n \t\t      /* Pretend the arithmetics is wrapping.  If there is\n \t\t\t any overflow, IMAGPART_EXPR will be set.  */\n@@ -1444,7 +1407,7 @@ vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n   else\n     set_value_range_to_varying (vr);\n \n-  if (vr->type == VR_VARYING)\n+  if (vr->varying_p ())\n     extract_range_basic (vr, stmt);\n }\n \n@@ -1467,18 +1430,18 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n \t\tbool *strict_overflow_p)\n {\n   /* VARYING or UNDEFINED ranges cannot be compared.  */\n-  if (vr0->type == VR_VARYING\n-      || vr0->type == VR_UNDEFINED\n-      || vr1->type == VR_VARYING\n-      || vr1->type == VR_UNDEFINED)\n+  if (vr0->varying_p ()\n+      || vr0->undefined_p ()\n+      || vr1->varying_p ()\n+      || vr1->undefined_p ())\n     return NULL_TREE;\n \n   /* Anti-ranges need to be handled separately.  */\n-  if (vr0->type == VR_ANTI_RANGE || vr1->type == VR_ANTI_RANGE)\n+  if (vr0->kind () == VR_ANTI_RANGE || vr1->kind () == VR_ANTI_RANGE)\n     {\n       /* If both are anti-ranges, then we cannot compute any\n \t comparison.  */\n-      if (vr0->type == VR_ANTI_RANGE && vr1->type == VR_ANTI_RANGE)\n+      if (vr0->kind () == VR_ANTI_RANGE && vr1->kind () == VR_ANTI_RANGE)\n \treturn NULL_TREE;\n \n       /* These comparisons are never statically computable.  */\n@@ -1490,7 +1453,7 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n \n       /* Equality can be computed only between a range and an\n \t anti-range.  ~[VAL1, VAL2] == [VAL1, VAL2] is always false.  */\n-      if (vr0->type == VR_RANGE)\n+      if (vr0->kind () == VR_RANGE)\n \t{\n \t  /* To simplify processing, make VR0 the anti-range.  */\n \t  value_range *tmp = vr0;\n@@ -1500,8 +1463,8 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n \n       gcc_assert (comp == NE_EXPR || comp == EQ_EXPR);\n \n-      if (compare_values_warnv (vr0->min, vr1->min, strict_overflow_p) == 0\n-\t  && compare_values_warnv (vr0->max, vr1->max, strict_overflow_p) == 0)\n+      if (compare_values_warnv (vr0->min (), vr1->min (), strict_overflow_p) == 0\n+\t  && compare_values_warnv (vr0->max (), vr1->max (), strict_overflow_p) == 0)\n \treturn (comp == NE_EXPR) ? boolean_true_node : boolean_false_node;\n \n       return NULL_TREE;\n@@ -1519,22 +1482,22 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n     {\n       /* Equality may only be computed if both ranges represent\n \t exactly one value.  */\n-      if (compare_values_warnv (vr0->min, vr0->max, strict_overflow_p) == 0\n-\t  && compare_values_warnv (vr1->min, vr1->max, strict_overflow_p) == 0)\n+      if (compare_values_warnv (vr0->min (), vr0->max (), strict_overflow_p) == 0\n+\t  && compare_values_warnv (vr1->min (), vr1->max (), strict_overflow_p) == 0)\n \t{\n-\t  int cmp_min = compare_values_warnv (vr0->min, vr1->min,\n+\t  int cmp_min = compare_values_warnv (vr0->min (), vr1->min (),\n \t\t\t\t\t      strict_overflow_p);\n-\t  int cmp_max = compare_values_warnv (vr0->max, vr1->max,\n+\t  int cmp_max = compare_values_warnv (vr0->max (), vr1->max (),\n \t\t\t\t\t      strict_overflow_p);\n \t  if (cmp_min == 0 && cmp_max == 0)\n \t    return boolean_true_node;\n \t  else if (cmp_min != -2 && cmp_max != -2)\n \t    return boolean_false_node;\n \t}\n       /* If [V0_MIN, V1_MAX] < [V1_MIN, V1_MAX] then V0 != V1.  */\n-      else if (compare_values_warnv (vr0->min, vr1->max,\n+      else if (compare_values_warnv (vr0->min (), vr1->max (),\n \t\t\t\t     strict_overflow_p) == 1\n-\t       || compare_values_warnv (vr1->min, vr0->max,\n+\t       || compare_values_warnv (vr1->min (), vr0->max (),\n \t\t\t\t\tstrict_overflow_p) == 1)\n \treturn boolean_false_node;\n \n@@ -1549,20 +1512,20 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n \t make sure that both comparisons yield similar results to\n \t avoid comparing values that cannot be compared at\n \t compile-time.  */\n-      cmp1 = compare_values_warnv (vr0->max, vr1->min, strict_overflow_p);\n-      cmp2 = compare_values_warnv (vr0->min, vr1->max, strict_overflow_p);\n+      cmp1 = compare_values_warnv (vr0->max (), vr1->min (), strict_overflow_p);\n+      cmp2 = compare_values_warnv (vr0->min (), vr1->max (), strict_overflow_p);\n       if ((cmp1 == -1 && cmp2 == -1) || (cmp1 == 1 && cmp2 == 1))\n \treturn boolean_true_node;\n \n       /* If VR0 and VR1 represent a single value and are identical,\n \t return false.  */\n-      else if (compare_values_warnv (vr0->min, vr0->max,\n+      else if (compare_values_warnv (vr0->min (), vr0->max (),\n \t\t\t\t     strict_overflow_p) == 0\n-\t       && compare_values_warnv (vr1->min, vr1->max,\n+\t       && compare_values_warnv (vr1->min (), vr1->max (),\n \t\t\t\t\tstrict_overflow_p) == 0\n-\t       && compare_values_warnv (vr0->min, vr1->min,\n+\t       && compare_values_warnv (vr0->min (), vr1->min (),\n \t\t\t\t\tstrict_overflow_p) == 0\n-\t       && compare_values_warnv (vr0->max, vr1->max,\n+\t       && compare_values_warnv (vr0->max (), vr1->max (),\n \t\t\t\t\tstrict_overflow_p) == 0)\n \treturn boolean_false_node;\n \n@@ -1575,13 +1538,13 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n       int tst;\n \n       /* If VR0 is to the left of VR1, return true.  */\n-      tst = compare_values_warnv (vr0->max, vr1->min, strict_overflow_p);\n+      tst = compare_values_warnv (vr0->max (), vr1->min (), strict_overflow_p);\n       if ((comp == LT_EXPR && tst == -1)\n \t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n \treturn boolean_true_node;\n \n       /* If VR0 is to the right of VR1, return false.  */\n-      tst = compare_values_warnv (vr0->min, vr1->max, strict_overflow_p);\n+      tst = compare_values_warnv (vr0->min (), vr1->max (), strict_overflow_p);\n       if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n \t  || (comp == LE_EXPR && tst == 1))\n \treturn boolean_false_node;\n@@ -1605,11 +1568,11 @@ static tree\n compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n \t\t\t  bool *strict_overflow_p)\n {\n-  if (vr->type == VR_VARYING || vr->type == VR_UNDEFINED)\n+  if (vr->varying_p () || vr->undefined_p ())\n     return NULL_TREE;\n \n   /* Anti-ranges need to be handled separately.  */\n-  if (vr->type == VR_ANTI_RANGE)\n+  if (vr->kind () == VR_ANTI_RANGE)\n     {\n       /* For anti-ranges, the only predicates that we can compute at\n \t compile time are equality and inequality.  */\n@@ -1620,7 +1583,7 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n \treturn NULL_TREE;\n \n       /* ~[VAL_1, VAL_2] OP VAL is known if VAL_1 <= VAL <= VAL_2.  */\n-      if (value_inside_range (val, vr->min, vr->max) == 1)\n+      if (value_inside_range (val, vr->min (), vr->max ()) == 1)\n \treturn (comp == NE_EXPR) ? boolean_true_node : boolean_false_node;\n \n       return NULL_TREE;\n@@ -1630,31 +1593,31 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n     {\n       /* EQ_EXPR may only be computed if VR represents exactly\n \t one value.  */\n-      if (compare_values_warnv (vr->min, vr->max, strict_overflow_p) == 0)\n+      if (compare_values_warnv (vr->min (), vr->max (), strict_overflow_p) == 0)\n \t{\n-\t  int cmp = compare_values_warnv (vr->min, val, strict_overflow_p);\n+\t  int cmp = compare_values_warnv (vr->min (), val, strict_overflow_p);\n \t  if (cmp == 0)\n \t    return boolean_true_node;\n \t  else if (cmp == -1 || cmp == 1 || cmp == 2)\n \t    return boolean_false_node;\n \t}\n-      else if (compare_values_warnv (val, vr->min, strict_overflow_p) == -1\n-\t       || compare_values_warnv (vr->max, val, strict_overflow_p) == -1)\n+      else if (compare_values_warnv (val, vr->min (), strict_overflow_p) == -1\n+\t       || compare_values_warnv (vr->max (), val, strict_overflow_p) == -1)\n \treturn boolean_false_node;\n \n       return NULL_TREE;\n     }\n   else if (comp == NE_EXPR)\n     {\n       /* If VAL is not inside VR, then they are always different.  */\n-      if (compare_values_warnv (vr->max, val, strict_overflow_p) == -1\n-\t  || compare_values_warnv (vr->min, val, strict_overflow_p) == 1)\n+      if (compare_values_warnv (vr->max (), val, strict_overflow_p) == -1\n+\t  || compare_values_warnv (vr->min (), val, strict_overflow_p) == 1)\n \treturn boolean_true_node;\n \n       /* If VR represents exactly one value equal to VAL, then return\n \t false.  */\n-      if (compare_values_warnv (vr->min, vr->max, strict_overflow_p) == 0\n-\t  && compare_values_warnv (vr->min, val, strict_overflow_p) == 0)\n+      if (compare_values_warnv (vr->min (), vr->max (), strict_overflow_p) == 0\n+\t  && compare_values_warnv (vr->min (), val, strict_overflow_p) == 0)\n \treturn boolean_false_node;\n \n       /* Otherwise, they may or may not be different.  */\n@@ -1665,13 +1628,13 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n       int tst;\n \n       /* If VR is to the left of VAL, return true.  */\n-      tst = compare_values_warnv (vr->max, val, strict_overflow_p);\n+      tst = compare_values_warnv (vr->max (), val, strict_overflow_p);\n       if ((comp == LT_EXPR && tst == -1)\n \t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n \treturn boolean_true_node;\n \n       /* If VR is to the right of VAL, return false.  */\n-      tst = compare_values_warnv (vr->min, val, strict_overflow_p);\n+      tst = compare_values_warnv (vr->min (), val, strict_overflow_p);\n       if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n \t  || (comp == LE_EXPR && tst == 1))\n \treturn boolean_false_node;\n@@ -1684,13 +1647,13 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n       int tst;\n \n       /* If VR is to the right of VAL, return true.  */\n-      tst = compare_values_warnv (vr->min, val, strict_overflow_p);\n+      tst = compare_values_warnv (vr->min (), val, strict_overflow_p);\n       if ((comp == GT_EXPR && tst == 1)\n \t  || (comp == GE_EXPR && (tst == 0 || tst == 1)))\n \treturn boolean_true_node;\n \n       /* If VR is to the left of VAL, return false.  */\n-      tst = compare_values_warnv (vr->max, val, strict_overflow_p);\n+      tst = compare_values_warnv (vr->max (), val, strict_overflow_p);\n       if ((comp == GT_EXPR && (tst == -1 || tst == 0))\n \t  || (comp == GE_EXPR && tst == -1))\n \treturn boolean_false_node;\n@@ -1714,15 +1677,15 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n \n   /* TODO.  Don't adjust anti-ranges.  An anti-range may provide\n      better opportunities than a regular range, but I'm not sure.  */\n-  if (vr->type == VR_ANTI_RANGE)\n+  if (vr->kind () == VR_ANTI_RANGE)\n     return;\n \n   chrec = instantiate_parameters (loop, analyze_scalar_evolution (loop, var));\n \n   /* Like in PR19590, scev can return a constant function.  */\n   if (is_gimple_min_invariant (chrec))\n     {\n-      set_value_range_to_value (vr, chrec, vr->equiv);\n+      set_value_range_to_value (vr, chrec, vr->equiv ());\n       return;\n     }\n \n@@ -1771,15 +1734,15 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n   if (TREE_CODE (step) == INTEGER_CST\n       && is_gimple_val (init)\n       && (TREE_CODE (init) != SSA_NAME\n-\t  || get_value_range (init)->type == VR_RANGE))\n+\t  || get_value_range (init)->kind () == VR_RANGE))\n     {\n       widest_int nit;\n \n       /* We are only entering here for loop header PHI nodes, so using\n \t the number of latch executions is the correct thing to use.  */\n       if (max_loop_iterations (loop, &nit))\n \t{\n-\t  value_range maxvr = VR_INITIALIZER;\n+\t  value_range maxvr;\n \t  signop sgn = TYPE_SIGN (TREE_TYPE (step));\n \t  wi::overflow_type overflow;\n \n@@ -1799,9 +1762,9 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t      extract_range_from_binary_expr (&maxvr, PLUS_EXPR,\n \t\t\t\t\t      TREE_TYPE (init), init, tem);\n \t      /* Likewise if the addition did.  */\n-\t      if (maxvr.type == VR_RANGE)\n+\t      if (maxvr.kind () == VR_RANGE)\n \t\t{\n-\t\t  value_range initvr = VR_INITIALIZER;\n+\t\t  value_range initvr;\n \n \t\t  if (TREE_CODE (init) == SSA_NAME)\n \t\t    initvr = *(get_value_range (init));\n@@ -1815,19 +1778,19 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t\t     because the loop may exit immediately.  Overflow could\n \t\t     happen in the plus expression in this case.  */\n \t\t  if ((dir == EV_DIR_DECREASES\n-\t\t       && compare_values (maxvr.min, initvr.min) != -1)\n+\t\t       && compare_values (maxvr.min (), initvr.min ()) != -1)\n \t\t      || (dir == EV_DIR_GROWS\n-\t\t\t  && compare_values (maxvr.max, initvr.max) != 1))\n+\t\t\t  && compare_values (maxvr.max (), initvr.max ()) != 1))\n \t\t    return;\n \n-\t\t  tmin = maxvr.min;\n-\t\t  tmax = maxvr.max;\n+\t\t  tmin = maxvr.min ();\n+\t\t  tmax = maxvr.max ();\n \t\t}\n \t    }\n \t}\n     }\n \n-  if (vr->type == VR_VARYING || vr->type == VR_UNDEFINED)\n+  if (vr->varying_p () || vr->undefined_p ())\n     {\n       min = tmin;\n       max = tmax;\n@@ -1840,15 +1803,15 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n       else\n \tmin = init;\n     }\n-  else if (vr->type == VR_RANGE)\n+  else if (vr->kind () == VR_RANGE)\n     {\n-      min = vr->min;\n-      max = vr->max;\n+      min = vr->min ();\n+      max = vr->max ();\n \n       if (dir == EV_DIR_DECREASES)\n \t{\n-\t  /* INIT is the maximum value.  If INIT is lower than VR->MAX\n-\t     but no smaller than VR->MIN, set VR->MAX to INIT.  */\n+\t  /* INIT is the maximum value.  If INIT is lower than VR->MAX ()\n+\t     but no smaller than VR->MIN (), set VR->MAX () to INIT.  */\n \t  if (compare_values (init, max) == -1)\n \t    max = init;\n \n@@ -1860,7 +1823,7 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t}\n       else\n \t{\n-\t  /* If INIT is bigger than VR->MIN, set VR->MIN to INIT.  */\n+\t  /* If INIT is bigger than VR->MIN (), set VR->MIN () to INIT.  */\n \t  if (compare_values (init, min) == 1)\n \t    min = init;\n \n@@ -1886,7 +1849,7 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n   if (TREE_OVERFLOW_P (max))\n     max = drop_tree_overflow (max);\n \n-  set_value_range (vr, VR_RANGE, min, max, vr->equiv);\n+  vr->update (VR_RANGE, min, max);\n }\n \n /* Dump value ranges of all SSA_NAMEs to FILE.  */\n@@ -1957,11 +1920,11 @@ vrp_valueize (tree name)\n   if (TREE_CODE (name) == SSA_NAME)\n     {\n       value_range *vr = x_vr_values->get_value_range (name);\n-      if (vr->type == VR_RANGE\n-\t  && (TREE_CODE (vr->min) == SSA_NAME\n-\t      || is_gimple_min_invariant (vr->min))\n-\t  && vrp_operand_equal_p (vr->min, vr->max))\n-\treturn vr->min;\n+      if (vr->kind () == VR_RANGE\n+\t  && (TREE_CODE (vr->min ()) == SSA_NAME\n+\t      || is_gimple_min_invariant (vr->min ()))\n+\t  && vrp_operand_equal_p (vr->min (), vr->max ()))\n+\treturn vr->min ();\n     }\n   return name;\n }\n@@ -1982,8 +1945,9 @@ vrp_valueize_1 (tree name)\n \t  && prop_simulate_again_p (def_stmt))\n \treturn NULL_TREE;\n       value_range *vr = x_vr_values->get_value_range (name);\n-      if (range_int_cst_singleton_p (vr))\n-\treturn vr->min;\n+      tree singleton;\n+      if (vr->singleton_p (&singleton))\n+\treturn singleton;\n     }\n   return name;\n }\n@@ -2066,12 +2030,8 @@ vr_values::get_vr_for_comparison (int i)\n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n      have N_i in their ranges.  */\n-  if (vr.type == VR_VARYING || vr.type == VR_UNDEFINED)\n-    {\n-      vr.type = VR_RANGE;\n-      vr.min = ssa_name (i);\n-      vr.max = ssa_name (i);\n-    }\n+  if (vr.varying_p () || vr.undefined_p ())\n+    vr = value_range (VR_RANGE, ssa_name (i), ssa_name (i), NULL);\n \n   return vr;\n }\n@@ -2094,7 +2054,7 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n   value_range equiv_vr;\n \n   /* Get the set of equivalences for VAR.  */\n-  e = get_value_range (var)->equiv;\n+  e = get_value_range (var)->equiv ();\n \n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n@@ -2180,8 +2140,8 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n-  e1 = get_value_range (n1)->equiv;\n-  e2 = get_value_range (n2)->equiv;\n+  e1 = get_value_range (n1)->equiv ();\n+  e2 = get_value_range (n2)->equiv ();\n \n   /* Use the fake bitmaps if e1 or e2 are not available.  */\n   if (s_obstack == NULL)\n@@ -2440,10 +2400,10 @@ vr_values::vrp_evaluate_conditional (tree_code code, tree op0,\n       tree type = TREE_TYPE (op0);\n       value_range *vr0 = get_value_range (op0);\n \n-      if (vr0->type == VR_RANGE\n+      if (vr0->kind () == VR_RANGE\n \t  && INTEGRAL_TYPE_P (type)\n-\t  && vrp_val_is_min (vr0->min)\n-\t  && vrp_val_is_max (vr0->max)\n+\t  && vrp_val_is_min (vr0->min ())\n+\t  && vrp_val_is_max (vr0->max ())\n \t  && is_gimple_min_invariant (op1))\n \t{\n \t  location_t location;\n@@ -2572,17 +2532,17 @@ find_case_label_ranges (gswitch *stmt, value_range *vr, size_t *min_idx1,\n   unsigned int n = gimple_switch_num_labels (stmt);\n   bool take_default;\n   tree case_low, case_high;\n-  tree min = vr->min, max = vr->max;\n+  tree min = vr->min (), max = vr->max ();\n \n-  gcc_checking_assert (vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE);\n+  gcc_checking_assert (!vr->varying_p () && !vr->undefined_p ());\n \n   take_default = !find_case_label_range (stmt, min, max, &i, &j);\n \n   /* Set second range to emtpy.  */\n   *min_idx2 = 1;\n   *max_idx2 = 0;\n \n-  if (vr->type == VR_RANGE)\n+  if (vr->kind () == VR_RANGE)\n     {\n       *min_idx1 = i;\n       *max_idx1 = j;\n@@ -2663,9 +2623,9 @@ vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if ((vr->type != VR_RANGE\n-       && vr->type != VR_ANTI_RANGE)\n-      || symbolic_range_p (vr))\n+  if (vr->undefined_p ()\n+      || vr->varying_p ()\n+      || vr->symbolic_p ())\n     return;\n \n   /* Find the single edge that is taken from the switch expression.  */\n@@ -2809,40 +2769,24 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t\t See PR53465 and PR54767.  */\n \t      if (e->flags & EDGE_DFS_BACK)\n \t\t{\n-\t\t  if (vr_arg.type == VR_RANGE\n-\t\t      || vr_arg.type == VR_ANTI_RANGE)\n+\t\t  if (!vr_arg.varying_p () && !vr_arg.undefined_p ())\n \t\t    {\n-\t\t      vr_arg.equiv = NULL;\n-\t\t      if (symbolic_range_p (&vr_arg))\n-\t\t\t{\n-\t\t\t  vr_arg.type = VR_VARYING;\n-\t\t\t  vr_arg.min = NULL_TREE;\n-\t\t\t  vr_arg.max = NULL_TREE;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* If the non-backedge arguments range is VR_VARYING then\n-\t\t     we can still try recording a simple equivalence.  */\n-\t\t  if (vr_arg.type == VR_VARYING)\n-\t\t    {\n-\t\t      vr_arg.type = VR_RANGE;\n-\t\t      vr_arg.min = arg;\n-\t\t      vr_arg.max = arg;\n-\t\t      vr_arg.equiv = NULL;\n+\t\t      vr_arg.equiv_clear ();\n+\t\t      if (vr_arg.symbolic_p ())\n+\t\t\tvr_arg.set_varying ();\n \t\t    }\n \t\t}\n+\t      /* If the non-backedge arguments range is VR_VARYING then\n+\t\t we can still try recording a simple equivalence.  */\n+\t      else if (vr_arg.varying_p ())\n+\t\tvr_arg = value_range (VR_RANGE, arg, arg, NULL);\n \t    }\n \t  else\n \t    {\n \t      if (TREE_OVERFLOW_P (arg))\n \t\targ = drop_tree_overflow (arg);\n \n-\t      vr_arg.type = VR_RANGE;\n-\t      vr_arg.min = arg;\n-\t      vr_arg.max = arg;\n-\t      vr_arg.equiv = NULL;\n+\t      vr_arg = value_range (VR_RANGE, arg, arg);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2855,19 +2799,19 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t    }\n \n \t  if (first)\n-\t    copy_value_range (vr_result, &vr_arg);\n+\t    vr_result->deep_copy (&vr_arg);\n \t  else\n-\t    vrp_meet (vr_result, &vr_arg);\n+\t    vr_result->union_ (&vr_arg);\n \t  first = false;\n \n-\t  if (vr_result->type == VR_VARYING)\n+\t  if (vr_result->varying_p ())\n \t    break;\n \t}\n     }\n \n-  if (vr_result->type == VR_VARYING)\n+  if (vr_result->varying_p ())\n     goto varying;\n-  else if (vr_result->type == VR_UNDEFINED)\n+  else if (vr_result->undefined_p ())\n     goto update_range;\n \n   old_edges = vr_phi_edge_counts[SSA_NAME_VERSION (lhs)];\n@@ -2883,21 +2827,21 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n   if (edges > 0\n       && gimple_phi_num_args (phi) > 1\n       && edges == old_edges\n-      && lhs_vr->type != VR_UNDEFINED\n+      && !lhs_vr->undefined_p ()\n       && may_simulate_backedge_again)\n     {\n       /* Compare old and new ranges, fall back to varying if the\n          values are not comparable.  */\n-      int cmp_min = compare_values (lhs_vr->min, vr_result->min);\n+      int cmp_min = compare_values (lhs_vr->min (), vr_result->min ());\n       if (cmp_min == -2)\n \tgoto varying;\n-      int cmp_max = compare_values (lhs_vr->max, vr_result->max);\n+      int cmp_max = compare_values (lhs_vr->max (), vr_result->max ());\n       if (cmp_max == -2)\n \tgoto varying;\n \n       /* For non VR_RANGE or for pointers fall back to varying if\n \t the range changed.  */\n-      if ((lhs_vr->type != VR_RANGE || vr_result->type != VR_RANGE\n+      if ((lhs_vr->kind () != VR_RANGE || vr_result->kind () != VR_RANGE\n \t   || POINTER_TYPE_P (TREE_TYPE (lhs)))\n \t  && (cmp_min != 0 || cmp_max != 0))\n \tgoto varying;\n@@ -2910,24 +2854,27 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t times to reach -INF.  Going to -INF + 1 also lets the following\n \t iteration compute whether there will be any overflow, at the\n \t expense of one additional iteration.  */\n+      tree new_min = vr_result->min ();\n+      tree new_max = vr_result->max ();\n       if (cmp_min < 0)\n-\tvr_result->min = lhs_vr->min;\n+\tnew_min = lhs_vr->min ();\n       else if (cmp_min > 0\n-\t       && !vrp_val_is_min (vr_result->min))\n-\tvr_result->min\n-\t  = int_const_binop (PLUS_EXPR,\n-\t\t\t     vrp_val_min (TREE_TYPE (vr_result->min)),\n-\t\t\t     build_int_cst (TREE_TYPE (vr_result->min), 1));\n+\t       && !vrp_val_is_min (vr_result->min ()))\n+\tnew_min = int_const_binop (PLUS_EXPR,\n+\t\t\t\t   vrp_val_min (vr_result->type ()),\n+\t\t\t\t   build_int_cst (vr_result->type (), 1));\n \n       /* Similarly for the maximum value.  */\n       if (cmp_max > 0)\n-\tvr_result->max = lhs_vr->max;\n+\tnew_max = lhs_vr->max ();\n       else if (cmp_max < 0\n-\t       && !vrp_val_is_max (vr_result->max))\n-\tvr_result->max\n-\t  = int_const_binop (MINUS_EXPR,\n-\t\t\t     vrp_val_max (TREE_TYPE (vr_result->min)),\n-\t\t\t     build_int_cst (TREE_TYPE (vr_result->min), 1));\n+\t       && !vrp_val_is_max (vr_result->max ()))\n+\tnew_max = int_const_binop (MINUS_EXPR,\n+\t\t\t\t   vrp_val_max (vr_result->type ()),\n+\t\t\t\t   build_int_cst (vr_result->type (), 1));\n+\n+      *vr_result = value_range (vr_result->kind (), new_min, new_max,\n+\t\t\t\tvr_result->equiv ());\n \n       /* If we dropped either bound to +-INF then if this is a loop\n \t PHI node SCEV may known more about its value-range.  */\n@@ -2957,9 +2904,9 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n   /* If we will end up with a (-INF, +INF) range, set it to\n      VARYING.  Same if the previous max value was invalid for\n      the type and we end up with vr_result.min > vr_result.max.  */\n-  if ((vr_result->type == VR_RANGE || vr_result->type == VR_ANTI_RANGE)\n-      && !((vrp_val_is_max (vr_result->max) && vrp_val_is_min (vr_result->min))\n-\t   || compare_values (vr_result->min, vr_result->max) > 0))\n+  if ((!vr_result->varying_p () && !vr_result->undefined_p ())\n+      && !((vrp_val_is_max (vr_result->max ()) && vrp_val_is_min (vr_result->min ()))\n+\t   || compare_values (vr_result->min (), vr_result->max ()) > 0))\n     ;\n   else\n     set_value_range_to_varying (vr_result);\n@@ -3071,8 +3018,8 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n       vr = get_value_range (op0);\n       if (range_int_cst_p (vr))\n \t{\n-\t  op0min = vr->min;\n-\t  op0max = vr->max;\n+\t  op0min = vr->min ();\n+\t  op0max = vr->max ();\n \t}\n     }\n \n@@ -3081,7 +3028,7 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n     {\n       value_range *vr1 = get_value_range (op1);\n       if (range_int_cst_p (vr1))\n-\top1min = vr1->min;\n+\top1min = vr1->min ();\n     }\n   if (rhs_code == TRUNC_MOD_EXPR\n       && TREE_CODE (op1min) == INTEGER_CST\n@@ -3285,8 +3232,7 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op = NULL_TREE;\n-  value_range vr0 = VR_INITIALIZER;\n-  value_range vr1 = VR_INITIALIZER;\n+  value_range vr0, vr1;\n   wide_int may_be_nonzero0, may_be_nonzero1;\n   wide_int must_be_nonzero0, must_be_nonzero1;\n   wide_int mask;\n@@ -3405,10 +3351,10 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n      value range information we have for op0.  */\n   if (min && max)\n     {\n-      if (compare_values (vr->min, min) == 1)\n-\tmin = vr->min;\n-      if (compare_values (vr->max, max) == -1)\n-\tmax = vr->max;\n+      if (compare_values (vr->min (), min) == 1)\n+\tmin = vr->min ();\n+      if (compare_values (vr->max (), max) == -1)\n+\tmax = vr->max ();\n \n       /* If the new min/max values have converged to a single value,\n \t then there is only one value which can satisfy the condition,\n@@ -3431,42 +3377,40 @@ range_fits_type_p (value_range *vr, unsigned dest_precision, signop dest_sgn)\n   signop src_sgn;\n \n   /* We can only handle integral and pointer types.  */\n-  src_type = TREE_TYPE (vr->min);\n+  src_type = vr->type ();\n   if (!INTEGRAL_TYPE_P (src_type)\n       && !POINTER_TYPE_P (src_type))\n     return false;\n \n   /* An extension is fine unless VR is SIGNED and dest_sgn is UNSIGNED,\n      and so is an identity transform.  */\n-  src_precision = TYPE_PRECISION (TREE_TYPE (vr->min));\n+  src_precision = TYPE_PRECISION (vr->type ());\n   src_sgn = TYPE_SIGN (src_type);\n   if ((src_precision < dest_precision\n        && !(dest_sgn == UNSIGNED && src_sgn == SIGNED))\n       || (src_precision == dest_precision && src_sgn == dest_sgn))\n     return true;\n \n   /* Now we can only handle ranges with constant bounds.  */\n-  if (vr->type != VR_RANGE\n-      || TREE_CODE (vr->min) != INTEGER_CST\n-      || TREE_CODE (vr->max) != INTEGER_CST)\n+  if (!range_int_cst_p (vr))\n     return false;\n \n   /* For sign changes, the MSB of the wide_int has to be clear.\n      An unsigned value with its MSB set cannot be represented by\n      a signed wide_int, while a negative value cannot be represented\n      by an unsigned wide_int.  */\n   if (src_sgn != dest_sgn\n-      && (wi::lts_p (wi::to_wide (vr->min), 0)\n-\t  || wi::lts_p (wi::to_wide (vr->max), 0)))\n+      && (wi::lts_p (wi::to_wide (vr->min ()), 0)\n+\t  || wi::lts_p (wi::to_wide (vr->max ()), 0)))\n     return false;\n \n   /* Then we can perform the conversion on both ends and compare\n      the result for equality.  */\n-  tem = wi::ext (wi::to_widest (vr->min), dest_precision, dest_sgn);\n-  if (tem != wi::to_widest (vr->min))\n+  tem = wi::ext (wi::to_widest (vr->min ()), dest_precision, dest_sgn);\n+  if (tem != wi::to_widest (vr->min ()))\n     return false;\n-  tem = wi::ext (wi::to_widest (vr->max), dest_precision, dest_sgn);\n-  if (tem != wi::to_widest (vr->max))\n+  tem = wi::ext (wi::to_widest (vr->max ()), dest_precision, dest_sgn);\n+  if (tem != wi::to_widest (vr->max ()))\n     return false;\n \n   return true;\n@@ -3493,7 +3437,7 @@ vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n \n       /* If we have range information for OP0, then we might be\n \t able to simplify this conditional. */\n-      if (vr->type == VR_RANGE)\n+      if (vr->kind () == VR_RANGE)\n \t{\n \t  tree new_tree = test_for_singularity (cond_code, op0, op1, vr);\n \t  if (new_tree)\n@@ -3636,9 +3580,9 @@ vr_values::simplify_switch_using_ranges (gswitch *stmt)\n       vr = get_value_range (op);\n \n       /* We can only handle integer ranges.  */\n-      if ((vr->type != VR_RANGE\n-\t   && vr->type != VR_ANTI_RANGE)\n-\t  || symbolic_range_p (vr))\n+      if (vr->varying_p ()\n+\t  || vr->undefined_p ()\n+\t  || vr->symbolic_p ())\n \treturn false;\n \n       /* Find case label for min/max of the value range.  */\n@@ -3666,18 +3610,18 @@ vr_values::simplify_switch_using_ranges (gswitch *stmt)\n      value range.  */\n   size_t min_idx = 1, max_idx = 0;\n   if (vr != NULL)\n-    find_case_label_range (stmt, vr->min, vr->max, &min_idx, &max_idx);\n+    find_case_label_range (stmt, vr->min (), vr->max (), &min_idx, &max_idx);\n   if (min_idx <= max_idx)\n     {\n       tree min_label = gimple_switch_label (stmt, min_idx);\n       tree max_label = gimple_switch_label (stmt, max_idx);\n \n       /* Avoid changing the type of the case labels when truncating.  */\n       tree case_label_type = TREE_TYPE (CASE_LOW (min_label));\n-      tree vr_min = fold_convert (case_label_type, vr->min);\n-      tree vr_max = fold_convert (case_label_type, vr->max);\n+      tree vr_min = fold_convert (case_label_type, vr->min ());\n+      tree vr_max = fold_convert (case_label_type, vr->max ());\n \n-      if (vr->type == VR_RANGE)\n+      if (vr->kind () == VR_RANGE)\n \t{\n \t  /* If OP's value range is [2,8] and the low label range is\n \t     0 ... 3, truncate the label's range to 2 .. 3.  */\n@@ -3693,7 +3637,7 @@ vr_values::simplify_switch_using_ranges (gswitch *stmt)\n \t      && tree_int_cst_compare (CASE_HIGH (max_label), vr_max) > 0)\n \t    CASE_HIGH (max_label) = vr_max;\n \t}\n-      else if (vr->type == VR_ANTI_RANGE)\n+      else if (vr->kind () == VR_ANTI_RANGE)\n \t{\n \t  tree one_cst = build_one_cst (case_label_type);\n \n@@ -3930,9 +3874,7 @@ vr_values::simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n   gassign *conv;\n \n   /* We can only handle constant ranges.  */\n-  if (vr->type != VR_RANGE\n-      || TREE_CODE (vr->min) != INTEGER_CST\n-      || TREE_CODE (vr->max) != INTEGER_CST)\n+  if (!range_int_cst_p (vr))\n     return false;\n \n   /* First check if we can use a signed type in place of an unsigned.  */\n@@ -4088,26 +4030,26 @@ bool\n vr_values::two_valued_val_range_p (tree var, tree *a, tree *b)\n {\n   value_range *vr = get_value_range (var);\n-  if ((vr->type != VR_RANGE\n-       && vr->type != VR_ANTI_RANGE)\n-      || TREE_CODE (vr->min) != INTEGER_CST\n-      || TREE_CODE (vr->max) != INTEGER_CST)\n+  if (vr->varying_p ()\n+      || vr->undefined_p ()\n+      || TREE_CODE (vr->min ()) != INTEGER_CST\n+      || TREE_CODE (vr->max ()) != INTEGER_CST)\n     return false;\n \n-  if (vr->type == VR_RANGE\n-      && wi::to_wide (vr->max) - wi::to_wide (vr->min) == 1)\n+  if (vr->kind () == VR_RANGE\n+      && wi::to_wide (vr->max ()) - wi::to_wide (vr->min ()) == 1)\n     {\n-      *a = vr->min;\n-      *b = vr->max;\n+      *a = vr->min ();\n+      *b = vr->max ();\n       return true;\n     }\n \n   /* ~[TYPE_MIN + 1, TYPE_MAX - 1] */\n-  if (vr->type == VR_ANTI_RANGE\n-      && (wi::to_wide (vr->min)\n+  if (vr->kind () == VR_ANTI_RANGE\n+      && (wi::to_wide (vr->min ())\n \t  - wi::to_wide (vrp_val_min (TREE_TYPE (var)))) == 1\n       && (wi::to_wide (vrp_val_max (TREE_TYPE (var)))\n-\t  - wi::to_wide (vr->max)) == 1)\n+\t  - wi::to_wide (vr->max ())) == 1)\n     {\n       *a = vrp_val_min (TREE_TYPE (var));\n       *b = vrp_val_max (TREE_TYPE (var));"}, {"sha": "6ff461bd1e732d80ea8219be845160d88436d706", "filename": "gcc/vr-values.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54994253d3fc00bcb7d3e9359ff31a81c0e4543a/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=54994253d3fc00bcb7d3e9359ff31a81c0e4543a", "patch": "@@ -72,7 +72,6 @@ class vr_values\n   void cleanup_edges_and_switches (void);\n \n  private:\n-  void add_equivalence (bitmap *, const_tree);\n   bool vrp_stmt_computes_nonzero (gimple *);\n   bool op_with_boolean_value_range_p (tree);\n   bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n@@ -142,7 +141,5 @@ class vr_values\n   vec<switch_update> to_update_switch_stmts;\n };\n \n-#define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }\n-\n extern tree get_output_for_vrp (gimple *);\n #endif /* GCC_VR_VALUES_H */"}]}