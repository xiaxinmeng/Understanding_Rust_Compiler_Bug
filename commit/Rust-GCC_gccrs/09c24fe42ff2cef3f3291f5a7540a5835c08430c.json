{"sha": "09c24fe42ff2cef3f3291f5a7540a5835c08430c", "node_id": "C_kwDOANBUbNoAKDA5YzI0ZmU0MmZmMmNlZjNmMzI5MWY1YTc1NDBhNTgzNWMwODQzMGM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-19T00:32:22Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-19T00:32:22Z"}, "message": "c++: implicit dummy object in requires clause [PR103198]\n\nIn the testcase below satisfaction misbehaves for f and g ultimately\nbecause find_template_parameters fails to notice that the constraint\n'val.x' depends on the template parms of the class template.  In\ncontrast, satisfaction works just fine for h.\n\nThe problem seems to come down to a difference in how any_template_parm_r\nhandles 'this' vs a dummy object: it walks the TREE_TYPE of the former\nbut not the latter, and this causes us to miss the tparm dependencies in\nf/g's constraints since in their case the implicit object parm through\nwhich we access 'val' is a dummy object.  (For h, since we know it's a\nnon-static member function when parsing its trailing constraints, the\nimplicit object parm is 'this', not a dummy object.)\n\nThis patch fixes this inconsistency by making any_template_parm_r walk\ninto the TREE_TYPE of a dummy object, like it already does for 'this'.\n\n\tPR c++/103198\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (any_template_parm_r): Walk the TREE_TYPE of a dummy\n\tobject.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-this1.C: New test.", "tree": {"sha": "da0cb36050d900c15d02daf7c4836de4d5d83b9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da0cb36050d900c15d02daf7c4836de4d5d83b9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09c24fe42ff2cef3f3291f5a7540a5835c08430c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09c24fe42ff2cef3f3291f5a7540a5835c08430c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09c24fe42ff2cef3f3291f5a7540a5835c08430c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09c24fe42ff2cef3f3291f5a7540a5835c08430c/comments", "author": null, "committer": null, "parents": [{"sha": "483092d3d996c52a16519261ecf4236ab1a2d99c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483092d3d996c52a16519261ecf4236ab1a2d99c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483092d3d996c52a16519261ecf4236ab1a2d99c"}], "stats": {"total": 35, "additions": 35, "deletions": 0}, "files": [{"sha": "6a2a937764842d72ef3b2e14d682b447f688e885", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09c24fe42ff2cef3f3291f5a7540a5835c08430c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09c24fe42ff2cef3f3291f5a7540a5835c08430c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=09c24fe42ff2cef3f3291f5a7540a5835c08430c", "patch": "@@ -10766,6 +10766,11 @@ any_template_parm_r (tree t, void *data)\n \tWALK_SUBTREE (TREE_TYPE (t));\n       break;\n \n+    case CONVERT_EXPR:\n+      if (is_dummy_object (t))\n+\tWALK_SUBTREE (TREE_TYPE (t));\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "d717028201a1c5b8dbfd2ade6497aea385657b38", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-this1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09c24fe42ff2cef3f3291f5a7540a5835c08430c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-this1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09c24fe42ff2cef3f3291f5a7540a5835c08430c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-this1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-this1.C?ref=09c24fe42ff2cef3f3291f5a7540a5835c08430c", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/103198\n+// { dg-do compile { target c++20 } }\n+\n+template<class T, class = void>\n+struct A {\n+  T val;\n+\n+  template<class U>\n+    requires requires { val.x; }\n+  void f(U);\n+\n+  static void g(int)\n+    requires requires { val.x; };\n+\n+  void h(int)\n+    requires requires { val.x; };\n+};\n+\n+struct B { int x; };\n+struct C { };\n+\n+int main() {\n+  A<B>().f(0);\n+  A<B>().g(0);\n+  A<B>().h(0);\n+\n+  A<C>().f(0); // { dg-error \"no match\" }\n+  A<C>().g(0); // { dg-error \"no match\" }\n+  A<C>().h(0); // { dg-error \"no match\" }\n+}"}]}