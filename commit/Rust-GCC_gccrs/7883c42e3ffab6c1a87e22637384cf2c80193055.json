{"sha": "7883c42e3ffab6c1a87e22637384cf2c80193055", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg4M2M0MmUzZmZhYjZjMWE4N2UyMjYzNzM4NGNmMmM4MDE5MzA1NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-29T09:36:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-29T09:36:34Z"}, "message": "[Ada] Factor out worker procedure for -gnatR\n\nThis extracts a worker procedure for printing the layout of a single component\nfrom List_Record_Layout so as to make the next change more readable.\n\n2018-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* repinfo.adb (List_Component_Layout): New procedure extracted from...\n\t(List_Record_Layout): ...here.  Invoke it.\n\nFrom-SVN: r260867", "tree": {"sha": "b7cb546dc77a4820c754bd41dc9f540f90d6229f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7cb546dc77a4820c754bd41dc9f540f90d6229f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7883c42e3ffab6c1a87e22637384cf2c80193055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7883c42e3ffab6c1a87e22637384cf2c80193055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7883c42e3ffab6c1a87e22637384cf2c80193055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7883c42e3ffab6c1a87e22637384cf2c80193055/comments", "author": null, "committer": null, "parents": [{"sha": "76b382d9a042b307efa3d87c68b692c2c51d3197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b382d9a042b307efa3d87c68b692c2c51d3197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b382d9a042b307efa3d87c68b692c2c51d3197"}], "stats": {"total": 251, "additions": 134, "deletions": 117}, "files": [{"sha": "fdc940eef212b7d13a445896d3db428865efce42", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7883c42e3ffab6c1a87e22637384cf2c80193055/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7883c42e3ffab6c1a87e22637384cf2c80193055/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7883c42e3ffab6c1a87e22637384cf2c80193055", "patch": "@@ -1,3 +1,8 @@\n+2018-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* repinfo.adb (List_Component_Layout): New procedure extracted from...\n+\t(List_Record_Layout): ...here.  Invoke it.\n+\n 2018-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* repinfo.adb (Write_Unknown_Val): New procedure."}, {"sha": "071abbb1830d6fc24d4c40e5736d56dbef564b26", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 129, "deletions": 117, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7883c42e3ffab6c1a87e22637384cf2c80193055/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7883c42e3ffab6c1a87e22637384cf2c80193055/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=7883c42e3ffab6c1a87e22637384cf2c80193055", "patch": "@@ -891,6 +891,13 @@ package body Repinfo is\n          Prefix_Length      : Natural := 0);\n       --  Internal recursive procedure to compute the max length\n \n+      procedure List_Component_Layout\n+        (Ent                : Entity_Id;\n+         Starting_Position  : Uint := Uint_0;\n+         Starting_First_Bit : Uint := Uint_0;\n+         Prefix             : String := \"\");\n+      --  Procedure to display the layout of a single component\n+\n       procedure List_Record_Layout\n         (Ent                : Entity_Id;\n          Starting_Position  : Uint := Uint_0;\n@@ -1002,6 +1009,126 @@ package body Repinfo is\n          end loop;\n       end Compute_Max_Length;\n \n+      ---------------------------\n+      -- List_Component_Layout --\n+      ---------------------------\n+\n+      procedure List_Component_Layout\n+        (Ent                : Entity_Id;\n+         Starting_Position  : Uint := Uint_0;\n+         Starting_First_Bit : Uint := Uint_0;\n+         Prefix             : String := \"\")\n+      is\n+         Esiz  : constant Uint := Esize (Ent);\n+         Npos  : constant Uint := Normalized_Position (Ent);\n+         Fbit  : constant Uint := Normalized_First_Bit (Ent);\n+         Spos  : Uint;\n+         Sbit  : Uint;\n+         Lbit  : Uint;\n+\n+      begin\n+         Write_Str (\"   \");\n+         Write_Str (Prefix);\n+         Write_Str (Name_Buffer (1 .. Name_Len));\n+         Spaces (Max_Name_Length - Prefix'Length - Name_Len);\n+         Write_Str (\" at \");\n+\n+         if Known_Static_Normalized_Position (Ent) then\n+            Spos := Starting_Position  + Npos;\n+            Sbit := Starting_First_Bit + Fbit;\n+\n+            if Sbit >= SSU then\n+               Spos := Spos + 1;\n+            end if;\n+\n+            UI_Image (Spos);\n+            Spaces (Max_Spos_Length - UI_Image_Length);\n+            Write_Str (UI_Image_Buffer (1 .. UI_Image_Length));\n+\n+         elsif Known_Normalized_Position (Ent)\n+           and then List_Representation_Info = 3\n+         then\n+            Spaces (Max_Spos_Length - 2);\n+\n+            if Starting_Position /= Uint_0 then\n+               UI_Write (Starting_Position);\n+               Write_Str (\" + \");\n+            end if;\n+\n+            Write_Val (Npos);\n+\n+         else\n+            Write_Unknown_Val;\n+         end if;\n+\n+         Write_Str (\" range  \");\n+         Sbit := Starting_First_Bit + Fbit;\n+\n+         if Sbit >= SSU then\n+            Sbit := Sbit - SSU;\n+         end if;\n+\n+         UI_Write (Sbit);\n+         Write_Str (\" .. \");\n+\n+         --  Allowing Uint_0 here is an annoying special case. Really\n+         --  this should be a fine Esize value but currently it means\n+         --  unknown, except that we know after gigi has back annotated\n+         --  that a size of zero is real, since otherwise gigi back\n+         --  annotates using No_Uint as the value to indicate unknown.\n+\n+         if (Esize (Ent) = Uint_0 or else Known_Static_Esize (Ent))\n+           and then Known_Static_Normalized_First_Bit (Ent)\n+         then\n+            Lbit := Sbit + Esiz - 1;\n+\n+            if Lbit < 10 then\n+               Write_Char (' ');\n+            end if;\n+\n+            UI_Write (Lbit);\n+\n+         --  The test for Esize (Ent) not Uint_0 here is an annoying\n+         --  special case. Officially a value of zero for Esize means\n+         --  unknown, but here we use the fact that we know that gigi\n+         --  annotates Esize with No_Uint, not Uint_0. Really everyone\n+         --  should use No_Uint???\n+\n+         elsif List_Representation_Info < 3\n+           or else (Esize (Ent) /= Uint_0 and then Unknown_Esize (Ent))\n+         then\n+            Write_Unknown_Val;\n+\n+         --  List_Representation >= 3 and Known_Esize (Ent)\n+\n+         else\n+            Write_Val (Esiz, Paren => True);\n+\n+            --  If in front end layout mode, then dynamic size is stored\n+            --  in storage units, so renormalize for output\n+\n+            if not Back_End_Layout then\n+               Write_Str (\" * \");\n+               Write_Int (SSU);\n+            end if;\n+\n+            --  Add appropriate first bit offset\n+\n+            if Sbit = 0 then\n+               Write_Str (\" - 1\");\n+\n+            elsif Sbit = 1 then\n+               null;\n+\n+            else\n+               Write_Str (\" + \");\n+               Write_Int (UI_To_Int (Sbit) - 1);\n+            end if;\n+         end if;\n+\n+         Write_Line (\";\");\n+      end List_Component_Layout;\n+\n       ------------------------\n       -- List_Record_Layout --\n       ------------------------\n@@ -1036,12 +1163,10 @@ package body Repinfo is\n \n             declare\n                Ctyp : constant Entity_Id := Underlying_Type (Etype (Comp));\n-               Esiz : constant Uint      := Esize (Comp);\n                Npos : constant Uint      := Normalized_Position (Comp);\n                Fbit : constant Uint      := Normalized_First_Bit (Comp);\n                Spos : Uint;\n                Sbit : Uint;\n-               Lbit : Uint;\n \n             begin\n                Get_Decoded_Name_String (Chars (Comp));\n@@ -1069,121 +1194,8 @@ package body Repinfo is\n                   goto Continue;\n                end if;\n \n-               Write_Str (\"   \");\n-               Write_Str (Prefix);\n-               Write_Str (Name_Buffer (1 .. Name_Len));\n-\n-               for J in 1 .. Max_Name_Length -  Prefix'Length - Name_Len loop\n-                  Write_Char (' ');\n-               end loop;\n-\n-               Write_Str (\" at \");\n-\n-               if Known_Static_Normalized_Position (Comp) then\n-                  Spos := Starting_Position  + Npos;\n-                  Sbit := Starting_First_Bit + Fbit;\n-\n-                  if Sbit >= SSU then\n-                     Spos := Spos + 1;\n-                  end if;\n-\n-                  UI_Image (Spos);\n-                  Spaces (Max_Spos_Length - UI_Image_Length);\n-                  Write_Str (UI_Image_Buffer (1 .. UI_Image_Length));\n-\n-               elsif Known_Normalized_Position (Comp)\n-                 and then List_Representation_Info = 3\n-               then\n-                  Spaces (Max_Spos_Length - 2);\n-\n-                  if Starting_Position /= Uint_0 then\n-                     UI_Write (Starting_Position);\n-                     Write_Str (\" + \");\n-                  end if;\n-\n-                  Write_Val (Npos);\n-\n-               else\n-                  --  For the packed case, we don't know the bit positions if\n-                  --  we don't know the starting position.\n-\n-                  if Is_Packed (Ent) then\n-                     Write_Line (\"?? range  ? .. ??;\");\n-                     goto Continue;\n-\n-                  --  Otherwise we can continue\n-\n-                  else\n-                     Write_Unknown_Val;\n-                  end if;\n-               end if;\n-\n-               Write_Str (\" range  \");\n-               Sbit := Starting_First_Bit + Fbit;\n-\n-               if Sbit >= SSU then\n-                  Sbit := Sbit - SSU;\n-               end if;\n-\n-               UI_Write (Sbit);\n-               Write_Str (\" .. \");\n-\n-               --  Allowing Uint_0 here is an annoying special case. Really\n-               --  this should be a fine Esize value but currently it means\n-               --  unknown, except that we know after gigi has back annotated\n-               --  that a size of zero is real, since otherwise gigi back\n-               --  annotates using No_Uint as the value to indicate unknown.\n-\n-               if (Esize (Comp) = Uint_0 or else Known_Static_Esize (Comp))\n-                 and then Known_Static_Normalized_First_Bit (Comp)\n-               then\n-                  Lbit := Sbit + Esiz - 1;\n-\n-                  if Lbit < 10 then\n-                     Write_Char (' ');\n-                  end if;\n-\n-                  UI_Write (Lbit);\n-\n-               --  The test for Esize (Comp) not Uint_0 here is an annoying\n-               --  special case. Officially a value of zero for Esize means\n-               --  unknown, but here we use the fact that we know that gigi\n-               --  annotates Esize with No_Uint, not Uint_0. Really everyone\n-               --  should use No_Uint???\n-\n-               elsif List_Representation_Info < 3\n-                 or else (Esize (Comp) /= Uint_0 and then Unknown_Esize (Comp))\n-               then\n-                  Write_Unknown_Val;\n-\n-               --  List_Representation >= 3 and Known_Esize (Comp)\n-\n-               else\n-                  Write_Val (Esiz, Paren => True);\n-\n-                  --  If in front end layout mode, then dynamic size is stored\n-                  --  in storage units, so renormalize for output\n-\n-                  if not Back_End_Layout then\n-                     Write_Str (\" * \");\n-                     Write_Int (SSU);\n-                  end if;\n-\n-                  --  Add appropriate first bit offset\n-\n-                  if Sbit = 0 then\n-                     Write_Str (\" - 1\");\n-\n-                  elsif Sbit = 1 then\n-                     null;\n-\n-                  else\n-                     Write_Str (\" + \");\n-                     Write_Int (UI_To_Int (Sbit) - 1);\n-                  end if;\n-               end if;\n-\n-               Write_Line (\";\");\n+               List_Component_Layout (Comp,\n+                 Starting_Position, Starting_First_Bit, Prefix);\n             end;\n \n          <<Continue>>"}]}