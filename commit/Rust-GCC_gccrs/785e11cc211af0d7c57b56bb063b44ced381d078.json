{"sha": "785e11cc211af0d7c57b56bb063b44ced381d078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg1ZTExY2MyMTFhZjBkN2M1N2I1NmJiMDYzYjQ0Y2VkMzgxZDA3OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-17T06:37:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-17T06:37:06Z"}, "message": "Update to current master source.\n\nFrom-SVN: r167972", "tree": {"sha": "b113b8918f9eb221f65ad5d9ea88ce8ec1b900cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b113b8918f9eb221f65ad5d9ea88ce8ec1b900cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/785e11cc211af0d7c57b56bb063b44ced381d078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785e11cc211af0d7c57b56bb063b44ced381d078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/785e11cc211af0d7c57b56bb063b44ced381d078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785e11cc211af0d7c57b56bb063b44ced381d078/comments", "author": null, "committer": null, "parents": [{"sha": "2bc4b68293dad5d923b6800b79d45103afcc63c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc4b68293dad5d923b6800b79d45103afcc63c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc4b68293dad5d923b6800b79d45103afcc63c6"}], "stats": {"total": 411, "additions": 159, "deletions": 252}, "files": [{"sha": "2c041cd773c9dc1b8e890b50eed5bd594957652d", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 159, "deletions": 252, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/785e11cc211af0d7c57b56bb063b44ced381d078/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/785e11cc211af0d7c57b56bb063b44ced381d078/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=785e11cc211af0d7c57b56bb063b44ced381d078", "patch": "@@ -89,114 +89,83 @@ var (\n \tErrBadBackslash        = Error(\"illegal backslash escape\")\n )\n \n-// An instruction executed by the NFA\n-type instr interface {\n-\tkind() int   // the type of this instruction: _CHAR, _ANY, etc.\n-\tnext() instr // the instruction to execute after this one\n-\tsetNext(i instr)\n-\tindex() int\n-\tsetIndex(i int)\n-\tprint()\n-}\n+const (\n+\tiStart     = iota // beginning of program\n+\tiEnd              // end of program: success\n+\tiBOT              // '^' beginning of text\n+\tiEOT              // '$' end of text\n+\tiChar             // 'a' regular character\n+\tiCharClass        // [a-z] character class\n+\tiAny              // '.' any character including newline\n+\tiNotNL            // [^\\n] special case: any character but newline\n+\tiBra              // '(' parenthesized expression: 2*braNum for left, 2*braNum+1 for right\n+\tiAlt              // '|' alternation\n+\tiNop              // do nothing; makes it easy to link without patching\n+)\n \n-// Fields and methods common to all instructions\n-type common struct {\n-\t_next  instr\n-\t_index int\n+// An instruction executed by the NFA\n+type instr struct {\n+\tkind  int    // the type of this instruction: iChar, iAny, etc.\n+\tindex int    // used only in debugging; could be eliminated\n+\tnext  *instr // the instruction to execute after this one\n+\t// Special fields valid only for some items.\n+\tchar   int        // iChar\n+\tbraNum int        // iBra, iEbra\n+\tcclass *charClass // iCharClass\n+\tleft   *instr     // iAlt, other branch\n+}\n+\n+func (i *instr) print() {\n+\tswitch i.kind {\n+\tcase iStart:\n+\t\tprint(\"start\")\n+\tcase iEnd:\n+\t\tprint(\"end\")\n+\tcase iBOT:\n+\t\tprint(\"bot\")\n+\tcase iEOT:\n+\t\tprint(\"eot\")\n+\tcase iChar:\n+\t\tprint(\"char \", string(i.char))\n+\tcase iCharClass:\n+\t\ti.cclass.print()\n+\tcase iAny:\n+\t\tprint(\"any\")\n+\tcase iNotNL:\n+\t\tprint(\"notnl\")\n+\tcase iBra:\n+\t\tif i.braNum&1 == 0 {\n+\t\t\tprint(\"bra\", i.braNum/2)\n+\t\t} else {\n+\t\t\tprint(\"ebra\", i.braNum/2)\n+\t\t}\n+\tcase iAlt:\n+\t\tprint(\"alt(\", i.left.index, \")\")\n+\tcase iNop:\n+\t\tprint(\"nop\")\n+\t}\n }\n \n-func (c *common) next() instr     { return c._next }\n-func (c *common) setNext(i instr) { c._next = i }\n-func (c *common) index() int      { return c._index }\n-func (c *common) setIndex(i int)  { c._index = i }\n-\n // Regexp is the representation of a compiled regular expression.\n // The public interface is entirely through methods.\n type Regexp struct {\n \texpr        string // the original expression\n \tprefix      string // initial plain text string\n \tprefixBytes []byte // initial plain text bytes\n-\tinst        []instr\n-\tstart       instr // first instruction of machine\n-\tprefixStart instr // where to start if there is a prefix\n-\tnbra        int   // number of brackets in expression, for subexpressions\n-}\n-\n-const (\n-\t_START     = iota // beginning of program\n-\t_END              // end of program: success\n-\t_BOT              // '^' beginning of text\n-\t_EOT              // '$' end of text\n-\t_CHAR             // 'a' regular character\n-\t_CHARCLASS        // [a-z] character class\n-\t_ANY              // '.' any character including newline\n-\t_NOTNL            // [^\\n] special case: any character but newline\n-\t_BRA              // '(' parenthesized expression\n-\t_EBRA             // ')'; end of '(' parenthesized expression\n-\t_ALT              // '|' alternation\n-\t_NOP              // do nothing; makes it easy to link without patching\n-)\n-\n-// --- START start of program\n-type _Start struct {\n-\tcommon\n-}\n-\n-func (start *_Start) kind() int { return _START }\n-func (start *_Start) print()    { print(\"start\") }\n-\n-// --- END end of program\n-type _End struct {\n-\tcommon\n-}\n-\n-func (end *_End) kind() int { return _END }\n-func (end *_End) print()    { print(\"end\") }\n-\n-// --- BOT beginning of text\n-type _Bot struct {\n-\tcommon\n-}\n-\n-func (bot *_Bot) kind() int { return _BOT }\n-func (bot *_Bot) print()    { print(\"bot\") }\n-\n-// --- EOT end of text\n-type _Eot struct {\n-\tcommon\n-}\n-\n-func (eot *_Eot) kind() int { return _EOT }\n-func (eot *_Eot) print()    { print(\"eot\") }\n-\n-// --- CHAR a regular character\n-type _Char struct {\n-\tcommon\n-\tchar int\n+\tinst        []*instr\n+\tstart       *instr // first instruction of machine\n+\tprefixStart *instr // where to start if there is a prefix\n+\tnbra        int    // number of brackets in expression, for subexpressions\n }\n \n-func (char *_Char) kind() int { return _CHAR }\n-func (char *_Char) print()    { print(\"char \", string(char.char)) }\n-\n-func newChar(char int) *_Char {\n-\tc := new(_Char)\n-\tc.char = char\n-\treturn c\n-}\n-\n-// --- CHARCLASS [a-z]\n-\n-type _CharClass struct {\n-\tcommon\n+type charClass struct {\n \tnegate bool // is character class negated? ([^a-z])\n \t// slice of int, stored pairwise: [a-z] is (a,z); x is (x,x):\n \tranges     []int\n \tcmin, cmax int\n }\n \n-func (cclass *_CharClass) kind() int { return _CHARCLASS }\n-\n-func (cclass *_CharClass) print() {\n+func (cclass *charClass) print() {\n \tprint(\"charclass\")\n \tif cclass.negate {\n \t\tprint(\" (negated)\")\n@@ -212,7 +181,7 @@ func (cclass *_CharClass) print() {\n \t}\n }\n \n-func (cclass *_CharClass) addRange(a, b int) {\n+func (cclass *charClass) addRange(a, b int) {\n \t// range is a through b inclusive\n \tcclass.ranges = append(cclass.ranges, a, b)\n \tif a < cclass.cmin {\n@@ -223,7 +192,7 @@ func (cclass *_CharClass) addRange(a, b int) {\n \t}\n }\n \n-func (cclass *_CharClass) matches(c int) bool {\n+func (cclass *charClass) matches(c int) bool {\n \tif c < cclass.cmin || c > cclass.cmax {\n \t\treturn cclass.negate\n \t}\n@@ -236,67 +205,17 @@ func (cclass *_CharClass) matches(c int) bool {\n \treturn cclass.negate\n }\n \n-func newCharClass() *_CharClass {\n-\tc := new(_CharClass)\n-\tc.ranges = make([]int, 0, 4)\n-\tc.cmin = 0x10FFFF + 1 // MaxRune + 1\n-\tc.cmax = -1\n-\treturn c\n-}\n-\n-// --- ANY any character\n-type _Any struct {\n-\tcommon\n-}\n-\n-func (any *_Any) kind() int { return _ANY }\n-func (any *_Any) print()    { print(\"any\") }\n-\n-// --- NOTNL any character but newline\n-type _NotNl struct {\n-\tcommon\n-}\n-\n-func (notnl *_NotNl) kind() int { return _NOTNL }\n-func (notnl *_NotNl) print()    { print(\"notnl\") }\n-\n-// --- BRA parenthesized expression\n-type _Bra struct {\n-\tcommon\n-\tn int // subexpression number\n-}\n-\n-func (bra *_Bra) kind() int { return _BRA }\n-func (bra *_Bra) print()    { print(\"bra\", bra.n) }\n-\n-// --- EBRA end of parenthesized expression\n-type _Ebra struct {\n-\tcommon\n-\tn int // subexpression number\n-}\n-\n-func (ebra *_Ebra) kind() int { return _EBRA }\n-func (ebra *_Ebra) print()    { print(\"ebra \", ebra.n) }\n-\n-// --- ALT alternation\n-type _Alt struct {\n-\tcommon\n-\tleft instr // other branch\n-}\n-\n-func (alt *_Alt) kind() int { return _ALT }\n-func (alt *_Alt) print()    { print(\"alt(\", alt.left.index(), \")\") }\n-\n-// --- NOP no operation\n-type _Nop struct {\n-\tcommon\n+func newCharClass() *instr {\n+\ti := &instr{kind: iCharClass}\n+\ti.cclass = new(charClass)\n+\ti.cclass.ranges = make([]int, 0, 4)\n+\ti.cclass.cmin = 0x10FFFF + 1 // MaxRune + 1\n+\ti.cclass.cmax = -1\n+\treturn i\n }\n \n-func (nop *_Nop) kind() int { return _NOP }\n-func (nop *_Nop) print()    { print(\"nop\") }\n-\n-func (re *Regexp) add(i instr) instr {\n-\ti.setIndex(len(re.inst))\n+func (re *Regexp) add(i *instr) *instr {\n+\ti.index = len(re.inst)\n \tre.inst = append(re.inst, i)\n \treturn i\n }\n@@ -364,8 +283,9 @@ func escape(c int) int {\n \treturn -1\n }\n \n-func (p *parser) charClass() instr {\n-\tcc := newCharClass()\n+func (p *parser) charClass() *instr {\n+\ti := newCharClass()\n+\tcc := i.cclass\n \tif p.c() == '^' {\n \t\tcc.negate = true\n \t\tp.nextc()\n@@ -380,18 +300,18 @@ func (p *parser) charClass() instr {\n \t\t\t// Is it [^\\n]?\n \t\t\tif cc.negate && len(cc.ranges) == 2 &&\n \t\t\t\tcc.ranges[0] == '\\n' && cc.ranges[1] == '\\n' {\n-\t\t\t\tnl := new(_NotNl)\n+\t\t\t\tnl := &instr{kind: iNotNL}\n \t\t\t\tp.re.add(nl)\n \t\t\t\treturn nl\n \t\t\t}\n \t\t\t// Special common case: \"[a]\" -> \"a\"\n \t\t\tif !cc.negate && len(cc.ranges) == 2 && cc.ranges[0] == cc.ranges[1] {\n-\t\t\t\tc := newChar(cc.ranges[0])\n+\t\t\t\tc := &instr{kind: iChar, char: cc.ranges[0]}\n \t\t\t\tp.re.add(c)\n \t\t\t\treturn c\n \t\t\t}\n-\t\t\tp.re.add(cc)\n-\t\t\treturn cc\n+\t\t\tp.re.add(i)\n+\t\t\treturn i\n \t\tcase '-': // do this before backslash processing\n \t\t\tp.error(ErrBadRange)\n \t\tcase '\\\\':\n@@ -428,7 +348,7 @@ func (p *parser) charClass() instr {\n \treturn nil\n }\n \n-func (p *parser) term() (start, end instr) {\n+func (p *parser) term() (start, end *instr) {\n \tswitch c := p.c(); c {\n \tcase '|', endOfFile:\n \t\treturn nil, nil\n@@ -443,15 +363,15 @@ func (p *parser) term() (start, end instr) {\n \t\tp.error(ErrUnmatchedRbkt)\n \tcase '^':\n \t\tp.nextc()\n-\t\tstart = p.re.add(new(_Bot))\n+\t\tstart = p.re.add(&instr{kind: iBOT})\n \t\treturn start, start\n \tcase '$':\n \t\tp.nextc()\n-\t\tstart = p.re.add(new(_Eot))\n+\t\tstart = p.re.add(&instr{kind: iEOT})\n \t\treturn start, start\n \tcase '.':\n \t\tp.nextc()\n-\t\tstart = p.re.add(new(_Any))\n+\t\tstart = p.re.add(&instr{kind: iAny})\n \t\treturn start, start\n \tcase '[':\n \t\tp.nextc()\n@@ -472,22 +392,20 @@ func (p *parser) term() (start, end instr) {\n \t\t}\n \t\tp.nlpar--\n \t\tp.nextc()\n-\t\tbra := new(_Bra)\n+\t\tbra := &instr{kind: iBra, braNum: 2 * nbra}\n \t\tp.re.add(bra)\n-\t\tebra := new(_Ebra)\n+\t\tebra := &instr{kind: iBra, braNum: 2*nbra + 1}\n \t\tp.re.add(ebra)\n-\t\tbra.n = nbra\n-\t\tebra.n = nbra\n \t\tif start == nil {\n \t\t\tif end == nil {\n \t\t\t\tp.error(ErrInternal)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tstart = ebra\n \t\t} else {\n-\t\t\tend.setNext(ebra)\n+\t\t\tend.next = ebra\n \t\t}\n-\t\tbra.setNext(start)\n+\t\tbra.next = start\n \t\treturn bra, ebra\n \tcase '\\\\':\n \t\tc = p.nextc()\n@@ -504,43 +422,43 @@ func (p *parser) term() (start, end instr) {\n \t\tfallthrough\n \tdefault:\n \t\tp.nextc()\n-\t\tstart = newChar(c)\n+\t\tstart = &instr{kind: iChar, char: c}\n \t\tp.re.add(start)\n \t\treturn start, start\n \t}\n \tpanic(\"unreachable\")\n }\n \n-func (p *parser) closure() (start, end instr) {\n+func (p *parser) closure() (start, end *instr) {\n \tstart, end = p.term()\n \tif start == nil {\n \t\treturn\n \t}\n \tswitch p.c() {\n \tcase '*':\n \t\t// (start,end)*:\n-\t\talt := new(_Alt)\n+\t\talt := &instr{kind: iAlt}\n \t\tp.re.add(alt)\n-\t\tend.setNext(alt) // after end, do alt\n+\t\tend.next = alt   // after end, do alt\n \t\talt.left = start // alternate brach: return to start\n \t\tstart = alt      // alt becomes new (start, end)\n \t\tend = alt\n \tcase '+':\n \t\t// (start,end)+:\n-\t\talt := new(_Alt)\n+\t\talt := &instr{kind: iAlt}\n \t\tp.re.add(alt)\n-\t\tend.setNext(alt) // after end, do alt\n+\t\tend.next = alt   // after end, do alt\n \t\talt.left = start // alternate brach: return to start\n \t\tend = alt        // start is unchanged; end is alt\n \tcase '?':\n \t\t// (start,end)?:\n-\t\talt := new(_Alt)\n+\t\talt := &instr{kind: iAlt}\n \t\tp.re.add(alt)\n-\t\tnop := new(_Nop)\n+\t\tnop := &instr{kind: iNop}\n \t\tp.re.add(nop)\n \t\talt.left = start // alternate branch is start\n-\t\talt.setNext(nop) // follow on to nop\n-\t\tend.setNext(nop) // after end, go to nop\n+\t\talt.next = nop   // follow on to nop\n+\t\tend.next = nop   // after end, go to nop\n \t\tstart = alt      // start is now alt\n \t\tend = nop        // end is nop pointed to by both branches\n \tdefault:\n@@ -553,27 +471,27 @@ func (p *parser) closure() (start, end instr) {\n \treturn\n }\n \n-func (p *parser) concatenation() (start, end instr) {\n+func (p *parser) concatenation() (start, end *instr) {\n \tfor {\n \t\tnstart, nend := p.closure()\n \t\tswitch {\n \t\tcase nstart == nil: // end of this concatenation\n \t\t\tif start == nil { // this is the empty string\n-\t\t\t\tnop := p.re.add(new(_Nop))\n+\t\t\t\tnop := p.re.add(&instr{kind: iNop})\n \t\t\t\treturn nop, nop\n \t\t\t}\n \t\t\treturn\n \t\tcase start == nil: // this is first element of concatenation\n \t\t\tstart, end = nstart, nend\n \t\tdefault:\n-\t\t\tend.setNext(nstart)\n+\t\t\tend.next = nstart\n \t\t\tend = nend\n \t\t}\n \t}\n \tpanic(\"unreachable\")\n }\n \n-func (p *parser) regexp() (start, end instr) {\n+func (p *parser) regexp() (start, end *instr) {\n \tstart, end = p.concatenation()\n \tfor {\n \t\tswitch p.c() {\n@@ -582,60 +500,59 @@ func (p *parser) regexp() (start, end instr) {\n \t\tcase '|':\n \t\t\tp.nextc()\n \t\t\tnstart, nend := p.concatenation()\n-\t\t\talt := new(_Alt)\n+\t\t\talt := &instr{kind: iAlt}\n \t\t\tp.re.add(alt)\n \t\t\talt.left = start\n-\t\t\talt.setNext(nstart)\n-\t\t\tnop := new(_Nop)\n+\t\t\talt.next = nstart\n+\t\t\tnop := &instr{kind: iNop}\n \t\t\tp.re.add(nop)\n-\t\t\tend.setNext(nop)\n-\t\t\tnend.setNext(nop)\n+\t\t\tend.next = nop\n+\t\t\tnend.next = nop\n \t\t\tstart, end = alt, nop\n \t\t}\n \t}\n \tpanic(\"unreachable\")\n }\n \n-func unNop(i instr) instr {\n-\tfor i.kind() == _NOP {\n-\t\ti = i.next()\n+func unNop(i *instr) *instr {\n+\tfor i.kind == iNop {\n+\t\ti = i.next\n \t}\n \treturn i\n }\n \n func (re *Regexp) eliminateNops() {\n \tfor _, inst := range re.inst {\n-\t\tif inst.kind() == _END {\n+\t\tif inst.kind == iEnd {\n \t\t\tcontinue\n \t\t}\n-\t\tinst.setNext(unNop(inst.next()))\n-\t\tif inst.kind() == _ALT {\n-\t\t\talt := inst.(*_Alt)\n-\t\t\talt.left = unNop(alt.left)\n+\t\tinst.next = unNop(inst.next)\n+\t\tif inst.kind == iAlt {\n+\t\t\tinst.left = unNop(inst.left)\n \t\t}\n \t}\n }\n \n func (re *Regexp) dump() {\n \tprint(\"prefix <\", re.prefix, \">\\n\")\n \tfor _, inst := range re.inst {\n-\t\tprint(inst.index(), \": \")\n+\t\tprint(inst.index, \": \")\n \t\tinst.print()\n-\t\tif inst.kind() != _END {\n-\t\t\tprint(\" -> \", inst.next().index())\n+\t\tif inst.kind != iEnd {\n+\t\t\tprint(\" -> \", inst.next.index)\n \t\t}\n \t\tprint(\"\\n\")\n \t}\n }\n \n func (re *Regexp) doParse() {\n \tp := newParser(re)\n-\tstart := new(_Start)\n+\tstart := &instr{kind: iStart}\n \tre.add(start)\n \ts, e := p.regexp()\n-\tstart.setNext(s)\n+\tstart.next = s\n \tre.start = start\n-\te.setNext(re.add(new(_End)))\n+\te.next = re.add(&instr{kind: iEnd})\n \n \tif debug {\n \t\tre.dump()\n@@ -659,27 +576,25 @@ func (re *Regexp) doParse() {\n func (re *Regexp) setPrefix() {\n \tvar b []byte\n \tvar utf = make([]byte, utf8.UTFMax)\n+\tvar inst *instr\n \t// First instruction is start; skip that.\n-\ti := re.inst[0].next().index()\n Loop:\n-\tfor i < len(re.inst) {\n-\t\tinst := re.inst[i]\n+\tfor inst = re.inst[0].next; inst.kind != iEnd; inst = inst.next {\n \t\t// stop if this is not a char\n-\t\tif inst.kind() != _CHAR {\n+\t\tif inst.kind != iChar {\n \t\t\tbreak\n \t\t}\n \t\t// stop if this char can be followed by a match for an empty string,\n \t\t// which includes closures, ^, and $.\n-\t\tswitch re.inst[inst.next().index()].kind() {\n-\t\tcase _BOT, _EOT, _ALT:\n+\t\tswitch inst.next.kind {\n+\t\tcase iBOT, iEOT, iAlt:\n \t\t\tbreak Loop\n \t\t}\n-\t\tn := utf8.EncodeRune(inst.(*_Char).char, utf)\n-\t\tb = bytes.Add(b, utf[0:n])\n-\t\ti = inst.next().index()\n+\t\tn := utf8.EncodeRune(inst.char, utf)\n+\t\tb = append(b, utf[0:n]...)\n \t}\n \t// point prefixStart instruction to first non-CHAR after prefix\n-\tre.prefixStart = re.inst[i]\n+\tre.prefixStart = inst\n \tre.prefixBytes = b\n \tre.prefix = string(b)\n }\n@@ -696,7 +611,7 @@ func Compile(str string) (regexp *Regexp, error os.Error) {\n \t\t}\n \t}()\n \tregexp.expr = str\n-\tregexp.inst = make([]instr, 0, 10)\n+\tregexp.inst = make([]*instr, 0, 10)\n \tregexp.doParse()\n \treturn\n }\n@@ -772,52 +687,45 @@ func (a *matchArena) noMatch() *matchVec {\n }\n \n type state struct {\n-\tinst     instr // next instruction to execute\n-\tprefixed bool  // this match began with a fixed prefix\n+\tinst     *instr // next instruction to execute\n+\tprefixed bool   // this match began with a fixed prefix\n \tmatch    *matchVec\n }\n \n // Append new state to to-do list.  Leftmost-longest wins so avoid\n // adding a state that's already active.  The matchVec will be inc-ref'ed\n // if it is assigned to a state.\n-func (a *matchArena) addState(s []state, inst instr, prefixed bool, match *matchVec, pos, end int) []state {\n-\tswitch inst.kind() {\n-\tcase _BOT:\n+func (a *matchArena) addState(s []state, inst *instr, prefixed bool, match *matchVec, pos, end int) []state {\n+\tswitch inst.kind {\n+\tcase iBOT:\n \t\tif pos == 0 {\n-\t\t\ts = a.addState(s, inst.next(), prefixed, match, pos, end)\n+\t\t\ts = a.addState(s, inst.next, prefixed, match, pos, end)\n \t\t}\n \t\treturn s\n-\tcase _EOT:\n+\tcase iEOT:\n \t\tif pos == end {\n-\t\t\ts = a.addState(s, inst.next(), prefixed, match, pos, end)\n+\t\t\ts = a.addState(s, inst.next, prefixed, match, pos, end)\n \t\t}\n \t\treturn s\n-\tcase _BRA:\n-\t\tn := inst.(*_Bra).n\n-\t\tmatch.m[2*n] = pos\n-\t\ts = a.addState(s, inst.next(), prefixed, match, pos, end)\n-\t\treturn s\n-\tcase _EBRA:\n-\t\tn := inst.(*_Ebra).n\n-\t\tmatch.m[2*n+1] = pos\n-\t\ts = a.addState(s, inst.next(), prefixed, match, pos, end)\n+\tcase iBra:\n+\t\tmatch.m[inst.braNum] = pos\n+\t\ts = a.addState(s, inst.next, prefixed, match, pos, end)\n \t\treturn s\n \t}\n-\tindex := inst.index()\n \tl := len(s)\n \t// States are inserted in order so it's sufficient to see if we have the same\n \t// instruction; no need to see if existing match is earlier (it is).\n \tfor i := 0; i < l; i++ {\n-\t\tif s[i].inst.index() == index {\n+\t\tif s[i].inst == inst {\n \t\t\treturn s\n \t\t}\n \t}\n \ts = append(s, state{inst, prefixed, match})\n \tmatch.ref++\n-\tif inst.kind() == _ALT {\n-\t\ts = a.addState(s, inst.(*_Alt).left, prefixed, a.copy(match), pos, end)\n+\tif inst.kind == iAlt {\n+\t\ts = a.addState(s, inst.left, prefixed, a.copy(match), pos, end)\n \t\t// give other branch a copy of this match vector\n-\t\ts = a.addState(s, inst.next(), prefixed, a.copy(match), pos, end)\n+\t\ts = a.addState(s, inst.next, prefixed, a.copy(match), pos, end)\n \t}\n \treturn s\n }\n@@ -860,7 +768,7 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {\n \t\t\t\ts[out] = arena.addState(s[out], re.prefixStart, true, match, pos, end)\n \t\t\t\tprefixed = false // next iteration should start at beginning of machine.\n \t\t\t} else {\n-\t\t\t\ts[out] = arena.addState(s[out], re.start.next(), false, match, pos, end)\n+\t\t\t\ts[out] = arena.addState(s[out], re.start.next, false, match, pos, end)\n \t\t\t}\n \t\t\tarena.free(match) // if addState saved it, ref was incremented\n \t\t}\n@@ -886,29 +794,28 @@ func (re *Regexp) doExecute(str string, bytestr []byte, pos int) []int {\n \t\t}\n \t\tpos += charwidth\n \t\tfor _, st := range s[in] {\n-\t\t\tswitch st.inst.kind() {\n-\t\t\tcase _BOT:\n-\t\t\tcase _EOT:\n-\t\t\tcase _CHAR:\n-\t\t\t\tif c == st.inst.(*_Char).char {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next(), st.prefixed, st.match, pos, end)\n+\t\t\tswitch st.inst.kind {\n+\t\t\tcase iBOT:\n+\t\t\tcase iEOT:\n+\t\t\tcase iChar:\n+\t\t\t\tif c == st.inst.char {\n+\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match, pos, end)\n \t\t\t\t}\n-\t\t\tcase _CHARCLASS:\n-\t\t\t\tif st.inst.(*_CharClass).matches(c) {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next(), st.prefixed, st.match, pos, end)\n+\t\t\tcase iCharClass:\n+\t\t\t\tif st.inst.cclass.matches(c) {\n+\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match, pos, end)\n \t\t\t\t}\n-\t\t\tcase _ANY:\n+\t\t\tcase iAny:\n \t\t\t\tif c != endOfFile {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next(), st.prefixed, st.match, pos, end)\n+\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match, pos, end)\n \t\t\t\t}\n-\t\t\tcase _NOTNL:\n+\t\t\tcase iNotNL:\n \t\t\t\tif c != endOfFile && c != '\\n' {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next(), st.prefixed, st.match, pos, end)\n+\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match, pos, end)\n \t\t\t\t}\n-\t\t\tcase _BRA:\n-\t\t\tcase _EBRA:\n-\t\t\tcase _ALT:\n-\t\t\tcase _END:\n+\t\t\tcase iBra:\n+\t\t\tcase iAlt:\n+\t\t\tcase iEnd:\n \t\t\t\t// choose leftmost longest\n \t\t\t\tif !found || // first\n \t\t\t\t\tst.match.m[0] < final.match.m[0] || // leftmost"}]}