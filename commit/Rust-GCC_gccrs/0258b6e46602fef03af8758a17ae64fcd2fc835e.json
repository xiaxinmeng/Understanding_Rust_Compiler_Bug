{"sha": "0258b6e46602fef03af8758a17ae64fcd2fc835e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI1OGI2ZTQ2NjAyZmVmMDNhZjg3NThhMTdhZTY0ZmNkMmZjODM1ZQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2013-07-15T17:23:49Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2013-07-15T17:23:49Z"}, "message": "acinclude.m4 (LIBITM_CHECK_AS_HTM): New.\n\nlibitm/\n        * acinclude.m4 (LIBITM_CHECK_AS_HTM): New.\n        * configure.ac: Use it.\n\t(AC_CHECK_HEADERS): Check for sys/auxv.h.\n\t(AC_CHECK_FUNCS): Check for getauxval.\n        * config.h.in, configure: Rebuild.\n\t* configure.tgt (target_cpu): Add -mhtm to XCFLAGS.\n\t* config/powerpc/target.h: Include sys/auxv.h and htmintrin.h.\n\t(USE_HTM_FASTPATH): Define.\n\t(_TBEGIN_STARTED, _TBEGIN_INDETERMINATE, _TBEGIN_PERSISTENT,\n\t_HTM_RETRIES) New macros.\n\t(htm_abort, htm_abort_should_retry, htm_available, htm_begin, htm_init,\n\thtm_begin_success, htm_commit, htm_transaction_active): New functions.\n\ngcc/\n\t* config.gcc (powerpc*-*-*): Install htmintrin.h and htmxlintrin.h.\n\t* config/rs6000/t-rs6000 (MD_INCLUDES): Add htm.md.\n\t* config/rs6000/rs6000.opt: Add -mhtm option.\n\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add OPTION_MASK_HTM.\n\t(ISA_2_7_MASKS_SERVER): Add OPTION_MASK_HTM.\n\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Define\n\t__HTM__ if the HTM instructions are available.\n\t* config/rs6000/predicates.md (u3bit_cint_operand, u10bit_cint_operand,\n\thtm_spr_reg_operand): New define_predicates.\n\t* config/rs6000/rs6000.md (define_attr \"type\"): Add htm.\n\t(TFHAR_REGNO, TFIAR_REGNO, TEXASR_REGNO): New define_constants.\n\tInclude htm.md.\n\t* config/rs6000/rs6000-builtin.def (BU_HTM_0, BU_HTM_1, BU_HTM_2,\n\tBU_HTM_3, BU_HTM_SPR0, BU_HTM_SPR1): Add support macros for defining\n\tHTM builtin functions.\n\t* config/rs6000/rs6000.c (RS6000_BUILTIN_H): New macro.\n\t(rs6000_reg_names, alt_reg_names): Add HTM SPR register names.\n\t(rs6000_init_hard_regno_mode_ok): Add support for HTM instructions.\n\t(rs6000_builtin_mask_calculate): Likewise.\n\t(rs6000_option_override_internal): Likewise.\n\t(bdesc_htm): Add new HTM builtin support.\n\t(htm_spr_num): New function.\n\t(htm_spr_regno): Likewise.\n\t(rs6000_htm_spr_icode): Likewise.\n\t(htm_expand_builtin): Likewise.\n\t(htm_init_builtins): Likewise.\n\t(rs6000_expand_builtin): Add support for HTM builtin functions.\n\t(rs6000_init_builtins): Likewise.\n\t(rs6000_invalid_builtin, rs6000_opt_mask): Add support for -mhtm option.\n\t* config/rs6000/rs6000.h (ASM_CPU_SPEC): Add support for -mhtm.\n\t(TARGET_HTM, MASK_HTM): Define macros.\n\t(FIRST_PSEUDO_REGISTER): Adjust for new HTM SPR registers.\n\t(FIXED_REGISTERS): Likewise.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(CALL_REALLY_USED_REGISTERS): Likewise.\n\t(REG_ALLOC_ORDER): Likewise.\n\t(enum reg_class): Likewise.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(REGISTER_NAMES): Likewise.\n\t(ADDITIONAL_REGISTER_NAMES): Likewise.\n\t(RS6000_BTC_SPR, RS6000_BTC_VOID, RS6000_BTC_32BIT, RS6000_BTC_64BIT,\n\tRS6000_BTC_MISC_MASK, RS6000_BTM_HTM): New macros.\n\t(RS6000_BTM_COMMON): Add RS6000_BTM_HTM.\n\t* config/rs6000/htm.md: New file.\n\t* config/rs6000/htmintrin.h: New file.\n\t* config/rs6000/htmxlintrin.h: New file.\n\ngcc/testsuite/\n        * lib/target-supports.exp (check_effective_target_powerpc_htm_ok): New\n        function to test if HTM is available.\n\t* gcc.target/powerpc/htm-xl-intrin-1.c: New test.\n\t* gcc.target/powerpc/htm-builtin-1.c: New test.\n\nFrom-SVN: r200960", "tree": {"sha": "88f5fb8e9a6df31ace484371036e954708d4c22a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88f5fb8e9a6df31ace484371036e954708d4c22a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0258b6e46602fef03af8758a17ae64fcd2fc835e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0258b6e46602fef03af8758a17ae64fcd2fc835e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0258b6e46602fef03af8758a17ae64fcd2fc835e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0258b6e46602fef03af8758a17ae64fcd2fc835e/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87dd8ab0f25e4366beb4c9b2b4699c9bd980ddec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87dd8ab0f25e4366beb4c9b2b4699c9bd980ddec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87dd8ab0f25e4366beb4c9b2b4699c9bd980ddec"}], "stats": {"total": 1571, "additions": 1548, "deletions": 23}, "files": [{"sha": "d9c58e9e0cf9f849101e5537706aa42418e93c63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -1,3 +1,53 @@\n+2013-07-15  Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* config.gcc (powerpc*-*-*): Install htmintrin.h and htmxlintrin.h.\n+\t* config/rs6000/t-rs6000 (MD_INCLUDES): Add htm.md.\n+\t* config/rs6000/rs6000.opt: Add -mhtm option.\n+\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add OPTION_MASK_HTM.\n+\t(ISA_2_7_MASKS_SERVER): Add OPTION_MASK_HTM.\n+\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Define\n+\t__HTM__ if the HTM instructions are available.\n+\t* config/rs6000/predicates.md (u3bit_cint_operand, u10bit_cint_operand,\n+\thtm_spr_reg_operand): New define_predicates.\n+\t* config/rs6000/rs6000.md (define_attr \"type\"): Add htm.\n+\t(TFHAR_REGNO, TFIAR_REGNO, TEXASR_REGNO): New define_constants.\n+\tInclude htm.md.\n+\t* config/rs6000/rs6000-builtin.def (BU_HTM_0, BU_HTM_1, BU_HTM_2,\n+\tBU_HTM_3, BU_HTM_SPR0, BU_HTM_SPR1): Add support macros for defining\n+\tHTM builtin functions.\n+\t* config/rs6000/rs6000.c (RS6000_BUILTIN_H): New macro.\n+\t(rs6000_reg_names, alt_reg_names): Add HTM SPR register names.\n+\t(rs6000_init_hard_regno_mode_ok): Add support for HTM instructions.\n+\t(rs6000_builtin_mask_calculate): Likewise.\n+\t(rs6000_option_override_internal): Likewise.\n+\t(bdesc_htm): Add new HTM builtin support.\n+\t(htm_spr_num): New function.\n+\t(htm_spr_regno): Likewise.\n+\t(rs6000_htm_spr_icode): Likewise.\n+\t(htm_expand_builtin): Likewise.\n+\t(htm_init_builtins): Likewise.\n+\t(rs6000_expand_builtin): Add support for HTM builtin functions.\n+\t(rs6000_init_builtins): Likewise.\n+\t(rs6000_invalid_builtin, rs6000_opt_mask): Add support for -mhtm option.\n+\t* config/rs6000/rs6000.h (ASM_CPU_SPEC): Add support for -mhtm.\n+\t(TARGET_HTM, MASK_HTM): Define macros.\n+\t(FIRST_PSEUDO_REGISTER): Adjust for new HTM SPR registers.\n+\t(FIXED_REGISTERS): Likewise.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(CALL_REALLY_USED_REGISTERS): Likewise.\n+\t(REG_ALLOC_ORDER): Likewise.\n+\t(enum reg_class): Likewise.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(REGISTER_NAMES): Likewise.\n+\t(ADDITIONAL_REGISTER_NAMES): Likewise.\n+\t(RS6000_BTC_SPR, RS6000_BTC_VOID, RS6000_BTC_32BIT, RS6000_BTC_64BIT,\n+\tRS6000_BTC_MISC_MASK, RS6000_BTM_HTM): New macros.\n+\t(RS6000_BTM_COMMON): Add RS6000_BTM_HTM.\n+\t* config/rs6000/htm.md: New file.\n+\t* config/rs6000/htmintrin.h: New file.\n+\t* config/rs6000/htmxlintrin.h: New file.\n+\n 2013-07-15  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_symbol_type):"}, {"sha": "e1b688fd43488323eab9a7b5135a5ef42be7c744", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -421,7 +421,7 @@ picochip-*-*)\n         ;;\n powerpc*-*-*)\n \tcpu_type=rs6000\n-\textra_headers=\"ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h\"\n+\textra_headers=\"ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h\"\n \tneed_64bit_hwint=yes\n \tcase x$with_cpu in\n \t    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[345678]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|Xe6500)"}, {"sha": "e8ec91aef71d50c4e01a15f4963747f0fd32fbcb", "filename": "gcc/config/rs6000/htm.md", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fhtm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fhtm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhtm.md?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -0,0 +1,366 @@\n+;; Hardware Transactional Memory (HTM) patterns.\n+;; Copyright (C) 2013 Free Software Foundation, Inc.\n+;; Contributed by Peter Bergner <bergner@vnet.ibm.com>.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_constants\n+  [(TFHAR_SPR\t\t128)\n+   (TFIAR_SPR\t\t129)\n+   (TEXASR_SPR\t\t130)\n+   (TEXASRU_SPR\t\t131)\n+   (MAX_HTM_OPERANDS\t4)\n+  ])\n+\n+;;\n+;; UNSPEC_VOLATILE usage\n+;;\n+\n+(define_c_enum \"unspecv\"\n+  [UNSPECV_HTM_TABORT\n+   UNSPECV_HTM_TABORTDC\n+   UNSPECV_HTM_TABORTDCI\n+   UNSPECV_HTM_TABORTWC\n+   UNSPECV_HTM_TABORTWCI\n+   UNSPECV_HTM_TBEGIN\n+   UNSPECV_HTM_TCHECK\n+   UNSPECV_HTM_TEND\n+   UNSPECV_HTM_TRECHKPT\n+   UNSPECV_HTM_TRECLAIM\n+   UNSPECV_HTM_TSR\n+   UNSPECV_HTM_MFSPR\n+   UNSPECV_HTM_MTSPR\n+  ])\n+\n+\n+(define_expand \"tabort\"\n+  [(set (match_dup 2)\n+\t(unspec_volatile:CC [(match_operand:SI 1 \"int_reg_operand\" \"\")]\n+\t\t\t    UNSPECV_HTM_TABORT))\n+   (set (match_dup 3)\n+\t(eq:SI (match_dup 2)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 3)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tabort_internal\"\n+  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand:SI 0 \"int_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TABORT))]\n+  \"TARGET_HTM\"\n+  \"tabort. %0\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tabortdc\"\n+  [(set (match_dup 4)\n+\t(unspec_volatile:CC [(match_operand 1 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand:SI 3 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TABORTDC))\n+   (set (match_dup 5)\n+\t(eq:SI (match_dup 4)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 5)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[5] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tabortdc_internal\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TABORTDC))]\n+  \"TARGET_HTM\"\n+  \"tabortdc. %0,%1,%2\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tabortdci\"\n+  [(set (match_dup 4)\n+\t(unspec_volatile:CC [(match_operand 1 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"s5bit_cint_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TABORTDCI))\n+   (set (match_dup 5)\n+\t(eq:SI (match_dup 4)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 5)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[5] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tabortdci_internal\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand 2 \"s5bit_cint_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TABORTDCI))]\n+  \"TARGET_HTM\"\n+  \"tabortdci. %0,%1,%2\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tabortwc\"\n+  [(set (match_dup 4)\n+\t(unspec_volatile:CC [(match_operand 1 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand:SI 3 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TABORTWC))\n+   (set (match_dup 5)\n+\t(eq:SI (match_dup 4)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 5)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[5] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tabortwc_internal\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TABORTWC))]\n+  \"TARGET_HTM\"\n+  \"tabortwc. %0,%1,%2\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tabortwci\"\n+  [(set (match_dup 4)\n+\t(unspec_volatile:CC [(match_operand 1 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"s5bit_cint_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TABORTWCI))\n+   (set (match_dup 5)\n+\t(eq:SI (match_dup 4)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 5)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[4] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[5] = gen_reg_rtx (SImode);\n+})\n+\n+(define_expand \"ttest\"\n+  [(set (match_dup 1)\n+\t(unspec_volatile:CC [(const_int 0)\n+\t\t\t     (reg:SI 0)\n+\t\t\t     (const_int 0)]\n+\t\t\t    UNSPECV_HTM_TABORTWCI))\n+   (set (subreg:CC (match_dup 2) 0) (match_dup 1))\n+   (set (match_dup 3) (lshiftrt:SI (match_dup 2) (const_int 24)))\n+   (parallel [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t\t   (and:SI (match_dup 3) (const_int 15)))\n+              (clobber (scratch:CC))])]\n+  \"TARGET_HTM\"\n+{\n+  operands[1] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[2] = gen_reg_rtx (SImode);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tabortwci_internal\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"u5bit_cint_operand\" \"n\")\n+\t\t\t     (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand 2 \"s5bit_cint_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TABORTWCI))]\n+  \"TARGET_HTM\"\n+  \"tabortwci. %0,%1,%2\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tbegin\"\n+  [(set (match_dup 2)\n+\t(unspec_volatile:CC [(match_operand 1 \"const_0_to_1_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TBEGIN))\n+   (set (match_dup 3)\n+\t(eq:SI (match_dup 2)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 3)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tbegin_internal\"\n+  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"const_0_to_1_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TBEGIN))]\n+  \"TARGET_HTM\"\n+  \"tbegin. %0\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tcheck\"\n+  [(set (match_dup 2)\n+\t(unspec_volatile:CC [(match_operand 1 \"u3bit_cint_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TCHECK))\n+   (set (match_dup 3)\n+\t(eq:SI (match_dup 2)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 3)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tcheck_internal\"\n+  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"u3bit_cint_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TCHECK))]\n+  \"TARGET_HTM\"\n+  \"tcheck. %0\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tend\"\n+  [(set (match_dup 2)\n+\t(unspec_volatile:CC [(match_operand 1 \"const_0_to_1_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TEND))\n+   (set (match_dup 3)\n+\t(eq:SI (match_dup 2)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 3)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tend_internal\"\n+  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"const_0_to_1_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TEND))]\n+  \"TARGET_HTM\"\n+  \"tend. %0\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"trechkpt\"\n+  [(set (match_dup 1)\n+\t(unspec_volatile:CC [(const_int 0)]\n+\t\t\t    UNSPECV_HTM_TRECHKPT))\n+   (set (match_dup 2)\n+\t(eq:SI (match_dup 1)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 2)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[1] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[2] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*trechkpt_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(const_int 0)]\n+\t\t\t    UNSPECV_HTM_TRECHKPT))]\n+  \"TARGET_HTM\"\n+  \"trechkpt.\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"treclaim\"\n+  [(set (match_dup 2)\n+\t(unspec_volatile:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TRECLAIM))\n+   (set (match_dup 3)\n+\t(eq:SI (match_dup 2)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 3)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*treclaim_internal\"\n+  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")]\n+\t\t\t    UNSPECV_HTM_TRECLAIM))]\n+  \"TARGET_HTM\"\n+  \"treclaim. %0\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"tsr\"\n+  [(set (match_dup 2)\n+\t(unspec_volatile:CC [(match_operand 1 \"const_0_to_1_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TSR))\n+   (set (match_dup 3)\n+\t(eq:SI (match_dup 2)\n+\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(minus:SI (const_int 1) (match_dup 3)))]\n+  \"TARGET_HTM\"\n+{\n+  operands[2] = gen_rtx_REG (CCmode, CR0_REGNO);\n+  operands[3] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*tsr_internal\"\n+  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=x\")\n+\t(unspec_volatile:CC [(match_operand 0 \"const_0_to_1_operand\" \"n\")]\n+\t\t\t    UNSPECV_HTM_TSR))]\n+  \"TARGET_HTM\"\n+  \"tsr. %0\"\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"htm_mfspr_<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+        (unspec_volatile:P [(match_operand 1 \"u10bit_cint_operand\" \"n\")\n+\t\t\t    (match_operand:P 2 \"htm_spr_reg_operand\" \"\")]\n+\t\t\t   UNSPECV_HTM_MFSPR))]\n+  \"TARGET_HTM\"\n+  \"mfspr %0,%1\";\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"htm_mtspr_<mode>\"\n+  [(set (match_operand:P 2 \"htm_spr_reg_operand\" \"\")\n+        (unspec_volatile:P [(match_operand:P 0 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand 1 \"u10bit_cint_operand\" \"n\")]\n+                           UNSPECV_HTM_MTSPR))]\n+  \"TARGET_HTM\"\n+  \"mtspr %1,%0\";\n+  [(set_attr \"type\" \"htm\")\n+   (set_attr \"length\" \"4\")])"}, {"sha": "10f3e2e40a20dc970d6b794ecf4393d3ed6b24f9", "filename": "gcc/config/rs6000/htmintrin.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fhtmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fhtmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhtmintrin.h?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -0,0 +1,131 @@\n+/* Hardware Transactional Memory (HTM) intrinsics.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Peter Bergner <bergner@vnet.ibm.com>.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __HTM__\n+# error \"HTM instruction set not enabled\"\n+#endif /* __HTM__ */\n+\n+#ifndef _HTMINTRIN_H\n+#define _HTMINTRIN_H\n+\n+#include <stdint.h>\n+\n+typedef uint64_t texasr_t;\n+typedef uint32_t texasru_t;\n+typedef uint32_t texasrl_t;\n+typedef uintptr_t tfiar_t;\n+typedef uintptr_t tfhar_t;\n+\n+#define _HTM_STATE(CR0) ((CR0 >> 1) & 0x3)\n+#define _HTM_NONTRANSACTIONAL 0x0\n+#define _HTM_SUSPENDED        0x1\n+#define _HTM_TRANSACTIONAL    0x2\n+\n+/* The following macros use the IBM bit numbering for BITNUM\n+   as used in the ISA documentation.  */\n+\n+#define _TEXASR_EXTRACT_BITS(TEXASR,BITNUM,SIZE) \\\n+  (((TEXASR) >> (63-(BITNUM))) & ((1<<(SIZE))-1))\n+#define _TEXASRU_EXTRACT_BITS(TEXASR,BITNUM,SIZE) \\\n+  (((TEXASR) >> (31-(BITNUM))) & ((1<<(SIZE))-1))\n+\n+#define _TEXASR_FAILURE_CODE(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 7, 8)\n+#define _TEXASRU_FAILURE_CODE(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 7, 8)\n+\n+#define _TEXASR_FAILURE_PERSISTENT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 7, 1)\n+#define _TEXASRU_FAILURE_PERSISTENT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 7, 1)\n+\n+#define _TEXASR_DISALLOWED(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 8, 1)\n+#define _TEXASRU_DISALLOWED(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 8, 1)\n+\n+#define _TEXASR_NESTING_OVERFLOW(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 9, 1)\n+#define _TEXASRU_NESTING_OVERFLOW(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 9, 1)\n+\n+#define _TEXASR_FOOTPRINT_OVERFLOW(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 10, 1)\n+#define _TEXASRU_FOOTPRINT_OVERFLOW(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 10, 1)\n+\n+#define _TEXASR_SELF_INDUCED_CONFLICT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 11, 1)\n+#define _TEXASRU_SELF_INDUCED_CONFLICT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 11, 1)\n+\n+#define _TEXASR_NON_TRANSACTIONAL_CONFLICT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 12, 1)\n+#define _TEXASRU_NON_TRANSACTIONAL_CONFLICT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 12, 1)\n+\n+#define _TEXASR_TRANSACTION_CONFLICT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 13, 1)\n+#define _TEXASRU_TRANSACTION_CONFLICT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 13, 1)\n+\n+#define _TEXASR_TRANSLATION_INVALIDATION_CONFLICT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 14, 1)\n+#define _TEXASRU_TRANSLATION_INVALIDATION_CONFLICT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 14, 1)\n+\n+#define _TEXASR_IMPLEMENTAION_SPECIFIC(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 15, 1)\n+#define _TEXASRU_IMPLEMENTAION_SPECIFIC(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 15, 1)\n+\n+#define _TEXASR_INSRUCTION_FETCH_CONFLICT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 16, 1)\n+#define _TEXASRU_INSRUCTION_FETCH_CONFLICT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 16, 1)\n+\n+#define _TEXASR_ABORT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 31, 1)\n+#define _TEXASRU_ABORT(TEXASRU) \\\n+  _TEXASRU_EXTRACT_BITS(TEXASRU, 31, 1)\n+\n+\n+#define _TEXASR_SUSPENDED(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 32, 1)\n+\n+#define _TEXASR_PRIVILEGE(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 35, 2)\n+\n+#define _TEXASR_FAILURE_SUMMARY(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 36, 1)\n+\n+#define _TEXASR_TFIAR_EXACT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 37, 1)\n+\n+#define _TEXASR_ROT(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 38, 1)\n+\n+#define _TEXASR_TRANSACTION_LEVEL(TEXASR) \\\n+  _TEXASR_EXTRACT_BITS(TEXASR, 63, 12)\n+\n+#endif /* _HTMINTRIN_H */"}, {"sha": "c2077d2a3708786b9dbd9df1d8d1ecf32faaae70", "filename": "gcc/config/rs6000/htmxlintrin.h", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fhtmxlintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fhtmxlintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhtmxlintrin.h?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -0,0 +1,208 @@\n+/* XL compiler Hardware Transactional Memory (HTM) execution intrinsics.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Peter Bergner <bergner@vnet.ibm.com>.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __HTM__\n+# error \"HTM instruction set not enabled\"\n+#endif /* __HTM__ */\n+\n+#ifndef _HTMXLINTRIN_H\n+#define _HTMXLINTRIN_H\n+\n+#include <stdint.h>\n+#include <htmintrin.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define _TEXASR_PTR(TM_BUF) \\\n+  ((texasr_t *)((TM_BUF)+0))\n+#define _TEXASRU_PTR(TM_BUF) \\\n+  ((texasru_t *)((TM_BUF)+0))\n+#define _TEXASRL_PTR(TM_BUF) \\\n+  ((texasrl_t *)((TM_BUF)+4))\n+#define _TFIAR_PTR(TM_BUF) \\\n+  ((tfiar_t *)((TM_BUF)+8))\n+\n+typedef char TM_buff_type[16];\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_simple_begin (void)\n+{\n+  if (__builtin_expect (__builtin_tbegin (0), 1))\n+    return 1;\n+  return 0;\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_begin (void* const TM_buff)\n+{\n+  *_TEXASRL_PTR (TM_buff) = 0;\n+  if (__builtin_expect (__builtin_tbegin (0), 1))\n+    return 1;\n+#ifdef __powerpc64__\n+  *_TEXASR_PTR (TM_buff) = __builtin_get_texasr ();\n+#else\n+  *_TEXASRU_PTR (TM_buff) = __builtin_get_texasru ();\n+  *_TEXASRL_PTR (TM_buff) = __builtin_get_texasr ();\n+#endif\n+  *_TFIAR_PTR (TM_buff) = __builtin_get_tfiar ();\n+  return 0;\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_end (void)\n+{\n+  if (__builtin_expect (__builtin_tend (0), 1))\n+    return 1;\n+  return 0;\n+}\n+\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_abort (void)\n+{\n+  __builtin_tabort (0);\n+}\n+\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_named_abort (unsigned char const code)\n+{\n+  __builtin_tabort (code);\n+}\n+\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_resume (void)\n+{\n+  __builtin_tresume ();\n+}\n+\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_suspend (void)\n+{\n+  __builtin_tsuspend ();\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_user_abort (void* const TM_buff)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+  return _TEXASRU_ABORT (texasru);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_named_user_abort (void* const TM_buff, unsigned char *code)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+\n+  *code = _TEXASRU_FAILURE_CODE (texasru);\n+  return _TEXASRU_ABORT (texasru);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_illegal (void* const TM_buff)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+  return _TEXASRU_DISALLOWED (texasru);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_footprint_exceeded (void* const TM_buff)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+  return _TEXASRU_FOOTPRINT_OVERFLOW (texasru);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_nesting_depth (void* const TM_buff)\n+{\n+  texasrl_t texasrl;\n+\n+  if (_HTM_STATE (__builtin_ttest ()) == _HTM_NONTRANSACTIONAL)\n+    {\n+      texasrl = *_TEXASRL_PTR (TM_buff);\n+      if (!_TEXASR_FAILURE_SUMMARY (texasrl))\n+        texasrl = 0;\n+    }\n+  else\n+    texasrl = (texasrl_t) __builtin_get_texasr ();\n+\n+  return _TEXASR_TRANSACTION_LEVEL (texasrl);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_nested_too_deep(void* const TM_buff)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+  return _TEXASRU_NESTING_OVERFLOW (texasru);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_conflict(void* const TM_buff)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+  /* Return TEXASR bits 11 (Self-Induced Conflict) through\n+     14 (Translation Invalidation Conflict).  */\n+  return (_TEXASRU_EXTRACT_BITS (texasru, 14, 4)) ? 1 : 0;\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_failure_persistent(void* const TM_buff)\n+{\n+  texasru_t texasru = *_TEXASRU_PTR (TM_buff);\n+  return _TEXASRU_FAILURE_PERSISTENT (texasru);\n+}\n+\n+extern __inline long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_failure_address(void* const TM_buff)\n+{\n+  return *_TFIAR_PTR (TM_buff);\n+}\n+\n+extern __inline long long\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_failure_code(void* const TM_buff)\n+{\n+  return *_TEXASR_PTR (TM_buff);\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* _HTMXLINTRIN_H */"}, {"sha": "18912f15a4a9a944c7d7e6990b6f19d3171659ae", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -124,6 +124,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) >= -16 && INTVAL (op) <= 15\")))\n \n+;; Return 1 if op is a unsigned 3-bit constant integer.\n+(define_predicate \"u3bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 7\")))\n+\n ;; Return 1 if op is a unsigned 5-bit constant integer.\n (define_predicate \"u5bit_cint_operand\"\n   (and (match_code \"const_int\")\n@@ -135,6 +140,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) >= -128 && INTVAL (op) <= 127\")))\n \n+;; Return 1 if op is a unsigned 10-bit constant integer.\n+(define_predicate \"u10bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 1023\")))\n+\n ;; Return 1 if op is a constant integer that can fit in a D field.\n (define_predicate \"short_cint_operand\"\n   (and (match_code \"const_int\")\n@@ -226,6 +236,33 @@\n   return (REGNO (op) != FIRST_GPR_REGNO);\n })\n \n+;; Return 1 if op is a HTM specific SPR register.\n+(define_predicate \"htm_spr_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (!TARGET_HTM)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  switch (REGNO (op))\n+    {\n+      case TFHAR_REGNO:\n+      case TFIAR_REGNO:\n+      case TEXASR_REGNO:\n+\treturn 1;\n+      default:\n+\tbreak;\n+    }\n+  \n+  /* Unknown SPR.  */\n+  return 0;\n+})\n+\n ;; Return 1 if op is a general purpose register that is an even register\n ;; which suitable for a load/store quad operation\n (define_predicate \"quad_int_reg_operand\""}, {"sha": "672604406d5c2df690233aac3d10e9e02e6c8860", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -30,6 +30,7 @@\n    RS6000_BUILTIN_A -- ABS builtins\n    RS6000_BUILTIN_D -- DST builtins\n    RS6000_BUILTIN_E -- SPE EVSEL builtins.\n+   RS6000_BUILTIN_H -- HTM builtins\n    RS6000_BUILTIN_P -- Altivec, VSX, ISA 2.07 vector predicate builtins\n    RS6000_BUILTIN_Q -- Paired floating point VSX predicate builtins\n    RS6000_BUILTIN_S -- SPE predicate builtins\n@@ -66,6 +67,10 @@\n   #error \"RS6000_BUILTIN_E is not defined.\"\n #endif\n \n+#ifndef RS6000_BUILTIN_H\n+  #error \"RS6000_BUILTIN_H is not defined.\"\n+#endif\n+\n #ifndef RS6000_BUILTIN_P\n   #error \"RS6000_BUILTIN_P is not defined.\"\n #endif\n@@ -403,6 +408,56 @@\n \t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n \n+/* HTM convenience macros.  */\n+#define BU_HTM_0(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_HTM,\t\t\t/* MASK */\t\\\n+\t\t    RS6000_BTC_ ## ATTR,\t\t/* ATTR */\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_HTM_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_HTM,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_HTM_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_HTM,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_HTM_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_HTM,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_HTM_SPR0(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_HTM,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_SPR),\t\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_HTM_SPR1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_H (HTM_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_HTM,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_SPR\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_VOID),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n /* SPE convenience macros.  */\n #define BU_SPE_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n   RS6000_BUILTIN_1 (SPE_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n@@ -1366,6 +1421,33 @@ BU_CRYPTO_OVERLOAD_2 (VPMSUM,\t \"vpmsum\")\n BU_CRYPTO_OVERLOAD_3 (VPERMXOR,\t \"vpermxor\")\n BU_CRYPTO_OVERLOAD_3 (VSHASIGMA, \"vshasigma\")\n \n+\f\n+/* HTM functions.  */\n+BU_HTM_1  (TABORT,\t\"tabort\",\tMISC,\ttabort)\n+BU_HTM_3  (TABORTDC,\t\"tabortdc\",\tMISC,\ttabortdc)\n+BU_HTM_3  (TABORTDCI,\t\"tabortdci\",\tMISC,\ttabortdci)\n+BU_HTM_3  (TABORTWC,\t\"tabortwc\",\tMISC,\ttabortwc)\n+BU_HTM_3  (TABORTWCI,\t\"tabortwci\",\tMISC,\ttabortwci)\n+BU_HTM_1  (TBEGIN,\t\"tbegin\",\tMISC,\ttbegin)\n+BU_HTM_1  (TCHECK,\t\"tcheck\",\tMISC,\ttcheck)\n+BU_HTM_1  (TEND,\t\"tend\",\t\tMISC,\ttend)\n+BU_HTM_0  (TENDALL,\t\"tendall\",\tMISC,\ttend)\n+BU_HTM_0  (TRECHKPT,\t\"trechkpt\",\tMISC,\ttrechkpt)\n+BU_HTM_1  (TRECLAIM,\t\"treclaim\",\tMISC,\ttreclaim)\n+BU_HTM_0  (TRESUME,\t\"tresume\",\tMISC,\ttsr)\n+BU_HTM_0  (TSUSPEND,\t\"tsuspend\",\tMISC,\ttsr)\n+BU_HTM_1  (TSR,\t\t\"tsr\",\t\tMISC,\ttsr)\n+BU_HTM_0  (TTEST,\t\"ttest\",\tMISC,\tttest)\n+\n+BU_HTM_SPR0 (GET_TFHAR,\t\t\"get_tfhar\",\tMISC,\tnothing)\n+BU_HTM_SPR1 (SET_TFHAR,\t\t\"set_tfhar\",\tMISC,\tnothing)\n+BU_HTM_SPR0 (GET_TFIAR,\t\t\"get_tfiar\",\tMISC,\tnothing)\n+BU_HTM_SPR1 (SET_TFIAR,\t\t\"set_tfiar\",\tMISC,\tnothing)\n+BU_HTM_SPR0 (GET_TEXASR,\t\"get_texasr\",\tMISC,\tnothing)\n+BU_HTM_SPR1 (SET_TEXASR,\t\"set_texasr\",\tMISC,\tnothing)\n+BU_HTM_SPR0 (GET_TEXASRU,\t\"get_texasru\",\tMISC,\tnothing)\n+BU_HTM_SPR1 (SET_TEXASRU,\t\"set_texasru\",\tMISC,\tnothing)\n+\n \f\n /* 3 argument paired floating point builtins.  */\n BU_PAIRED_3 (MSUB,            \"msub\",           FP, \tfmsv2sf4)\n@@ -1665,10 +1747,10 @@ BU_SPECIAL_X (RS6000_BUILTIN_RSQRTF, \"__builtin_rsqrtf\", RS6000_BTM_FRSQRTES,\n \t      RS6000_BTC_FP)\n \n BU_SPECIAL_X (RS6000_BUILTIN_GET_TB, \"__builtin_ppc_get_timebase\",\n-\t     RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n+\t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n \n BU_SPECIAL_X (RS6000_BUILTIN_MFTB, \"__builtin_ppc_mftb\",\n-\t     RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n+\t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n \n /* Darwin CfString builtin.  */\n BU_SPECIAL_X (RS6000_BUILTIN_CFSTRING, \"__builtin_cfstring\", RS6000_BTM_ALWAYS,"}, {"sha": "d58e6865193e65e5b62bb64648c5e183d3bca4d0", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -333,6 +333,8 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n     }\n   if ((flags & OPTION_MASK_VSX) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__VSX__\");\n+  if ((flags & OPTION_MASK_HTM) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__HTM__\");\n   if ((flags & OPTION_MASK_P8_VECTOR) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__POWER8_VECTOR__\");\n   if ((flags & OPTION_MASK_CRYPTO) != 0)"}, {"sha": "c177512ddfdcb536dfb6ad0e9112d548d3cd0027", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -51,6 +51,7 @@\n \t\t\t\t | OPTION_MASK_P8_VECTOR\t\t\\\n \t\t\t\t | OPTION_MASK_CRYPTO\t\t\t\\\n \t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n+\t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_QUAD_MEMORY)\n \n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)\n@@ -74,6 +75,7 @@\n \t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n \t\t\t\t | OPTION_MASK_DLMZB\t\t\t\\\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n+\t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFCRF\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFPGPR\t\t\t\\"}, {"sha": "742a530effa464e431db6b3f589150b62bae245f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 347, "deletions": 5, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -910,6 +910,7 @@ struct processor_costs ppca2_cost = {\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -933,6 +934,9 @@ struct processor_costs ppca2_cost = {\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)  \\\n   { NAME, ICODE, MASK, ATTR },\n \n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)  \\\n+  { NAME, ICODE, MASK, ATTR },\n+\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)  \\\n   { NAME, ICODE, MASK, ATTR },\n \n@@ -963,6 +967,7 @@ static const struct rs6000_builtin_info_type rs6000_builtin_info[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -1003,6 +1008,7 @@ static void rs6000_common_init_builtins (void);\n static void paired_init_builtins (void);\n static rtx paired_expand_predicate_builtin (enum insn_code, tree, rtx);\n static void spe_init_builtins (void);\n+static void htm_init_builtins (void);\n static rtx spe_expand_predicate_builtin (enum insn_code, tree, rtx);\n static rtx spe_expand_evsel_builtin (enum insn_code, tree, rtx);\n static int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n@@ -1130,7 +1136,9 @@ char rs6000_reg_names[][8] =\n       /* SPE registers.  */\n       \"spe_acc\", \"spefscr\",\n       /* Soft frame pointer.  */\n-      \"sfp\"\n+      \"sfp\",\n+      /* HTM SPR registers.  */\n+      \"tfhar\", \"tfiar\", \"texasr\"\n };\n \n #ifdef TARGET_REGNAMES\n@@ -1156,7 +1164,9 @@ static const char alt_reg_names[][8] =\n   /* SPE registers.  */\n   \"spe_acc\", \"spefscr\",\n   /* Soft frame pointer.  */\n-  \"sfp\"\n+  \"sfp\",\n+  /* HTM SPR registers.  */\n+  \"tfhar\", \"tfiar\", \"texasr\"\n };\n #endif\n \n@@ -2190,6 +2200,9 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   rs6000_regno_regclass[VSCR_REGNO] = VRSAVE_REGS;\n   rs6000_regno_regclass[SPE_ACC_REGNO] = SPE_ACC_REGS;\n   rs6000_regno_regclass[SPEFSCR_REGNO] = SPEFSCR_REGS;\n+  rs6000_regno_regclass[TFHAR_REGNO] = SPR_REGS;\n+  rs6000_regno_regclass[TFIAR_REGNO] = SPR_REGS;\n+  rs6000_regno_regclass[TEXASR_REGNO] = SPR_REGS;\n   rs6000_regno_regclass[ARG_POINTER_REGNUM] = BASE_REGS;\n   rs6000_regno_regclass[FRAME_POINTER_REGNUM] = BASE_REGS;\n \n@@ -2711,7 +2724,8 @@ rs6000_builtin_mask_calculate (void)\n \t  | ((TARGET_POPCNTD)\t\t    ? RS6000_BTM_POPCNTD   : 0)\n \t  | ((rs6000_cpu == PROCESSOR_CELL) ? RS6000_BTM_CELL      : 0)\n \t  | ((TARGET_P8_VECTOR)\t\t    ? RS6000_BTM_P8_VECTOR : 0)\n-\t  | ((TARGET_CRYPTO)\t\t    ? RS6000_BTM_CRYPTO\t   : 0));\n+\t  | ((TARGET_CRYPTO)\t\t    ? RS6000_BTM_CRYPTO\t   : 0)\n+\t  | ((TARGET_HTM)\t\t    ? RS6000_BTM_HTM\t   : 0));\n }\n \n /* Override command line options.  Mostly we process the processor type and\n@@ -2985,7 +2999,7 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* For the newer switches (vsx, dfp, etc.) set some of the older options,\n      unless the user explicitly used the -mno-<option> to disable the code.  */\n-  if (TARGET_P8_VECTOR || TARGET_DIRECT_MOVE || TARGET_CRYPTO)\n+  if (TARGET_P8_VECTOR || TARGET_DIRECT_MOVE || TARGET_CRYPTO || TARGET_HTM)\n     rs6000_isa_flags |= (ISA_2_7_MASKS_SERVER & ~rs6000_isa_flags_explicit);\n   else if (TARGET_VSX)\n     rs6000_isa_flags |= (ISA_2_6_MASKS_SERVER & ~rs6000_isa_flags_explicit);\n@@ -10144,6 +10158,7 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10157,6 +10172,7 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -10175,6 +10191,7 @@ static const struct builtin_description bdesc_3arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10188,6 +10205,7 @@ static const struct builtin_description bdesc_3arg[] =\n   { MASK, ICODE, NAME, ENUM },\n \n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -10206,6 +10224,7 @@ static const struct builtin_description bdesc_dst[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10219,6 +10238,7 @@ static const struct builtin_description bdesc_dst[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -10235,6 +10255,7 @@ static const struct builtin_description bdesc_2arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10246,6 +10267,7 @@ static const struct builtin_description bdesc_2arg[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) \\\n   { MASK, ICODE, NAME, ENUM },\n \n@@ -10267,6 +10289,7 @@ static const struct builtin_description bdesc_altivec_preds[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10278,6 +10301,7 @@ static const struct builtin_description bdesc_altivec_preds[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE) \\\n@@ -10297,6 +10321,7 @@ static const struct builtin_description bdesc_spe_predicates[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10310,6 +10335,7 @@ static const struct builtin_description bdesc_spe_predicates[] =\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE) \\\n   { MASK, ICODE, NAME, ENUM },\n \n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -10327,6 +10353,7 @@ static const struct builtin_description bdesc_spe_evsel[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10338,6 +10365,7 @@ static const struct builtin_description bdesc_spe_evsel[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE) \\\n   { MASK, ICODE, NAME, ENUM },\n@@ -10358,6 +10386,7 @@ static const struct builtin_description bdesc_paired_preds[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10371,6 +10400,7 @@ static const struct builtin_description bdesc_paired_preds[] =\n \n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -10388,8 +10418,9 @@ static const struct builtin_description bdesc_abs[] =\n #undef RS6000_BUILTIN_2\n #undef RS6000_BUILTIN_3\n #undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_E\n #undef RS6000_BUILTIN_D\n+#undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -10403,6 +10434,7 @@ static const struct builtin_description bdesc_abs[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -10413,17 +10445,49 @@ static const struct builtin_description bdesc_1arg[] =\n #include \"rs6000-builtin.def\"\n };\n \n+/* HTM builtins.  */\n #undef RS6000_BUILTIN_1\n #undef RS6000_BUILTIN_2\n #undef RS6000_BUILTIN_3\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n #undef RS6000_BUILTIN_X\n \n+#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) \\\n+  { MASK, ICODE, NAME, ENUM },\n+\n+#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n+\n+static const struct builtin_description bdesc_htm[] =\n+{\n+#include \"rs6000-builtin.def\"\n+};\n+\n+#undef RS6000_BUILTIN_1\n+#undef RS6000_BUILTIN_2\n+#undef RS6000_BUILTIN_3\n+#undef RS6000_BUILTIN_A\n+#undef RS6000_BUILTIN_D\n+#undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_P\n+#undef RS6000_BUILTIN_Q\n+#undef RS6000_BUILTIN_S\n+\n /* Return true if a builtin function is overloaded.  */\n bool\n rs6000_overloaded_builtin_p (enum rs6000_builtins fncode)\n@@ -10893,6 +10957,197 @@ altivec_expand_stv_builtin (enum insn_code icode, tree exp)\n   return NULL_RTX;\n }\n \n+/* Return the appropriate SPR number associated with the given builtin.  */\n+static inline HOST_WIDE_INT\n+htm_spr_num (enum rs6000_builtins code)\n+{\n+  if (code == HTM_BUILTIN_GET_TFHAR\n+      || code == HTM_BUILTIN_SET_TFHAR)\n+    return TFHAR_SPR;\n+  else if (code == HTM_BUILTIN_GET_TFIAR\n+\t   || code == HTM_BUILTIN_SET_TFIAR)\n+    return TFIAR_SPR;\n+  else if (code == HTM_BUILTIN_GET_TEXASR\n+\t   || code == HTM_BUILTIN_SET_TEXASR)\n+    return TEXASR_SPR;\n+  gcc_assert (code == HTM_BUILTIN_GET_TEXASRU\n+\t      || code == HTM_BUILTIN_SET_TEXASRU);\n+  return TEXASRU_SPR;\n+}\n+\n+/* Return the appropriate SPR regno associated with the given builtin.  */\n+static inline HOST_WIDE_INT\n+htm_spr_regno (enum rs6000_builtins code)\n+{\n+  if (code == HTM_BUILTIN_GET_TFHAR\n+      || code == HTM_BUILTIN_SET_TFHAR)\n+    return TFHAR_REGNO;\n+  else if (code == HTM_BUILTIN_GET_TFIAR\n+\t   || code == HTM_BUILTIN_SET_TFIAR)\n+    return TFIAR_REGNO;\n+  gcc_assert (code == HTM_BUILTIN_GET_TEXASR\n+\t      || code == HTM_BUILTIN_SET_TEXASR\n+\t      || code == HTM_BUILTIN_GET_TEXASRU\n+\t      || code == HTM_BUILTIN_SET_TEXASRU);\n+  return TEXASR_REGNO;\n+}\n+\n+/* Return the correct ICODE value depending on whether we are\n+   setting or reading the HTM SPRs.  */\n+static inline enum insn_code\n+rs6000_htm_spr_icode (bool nonvoid)\n+{\n+  if (nonvoid)\n+    return (TARGET_64BIT) ? CODE_FOR_htm_mfspr_di : CODE_FOR_htm_mfspr_si;\n+  else\n+    return (TARGET_64BIT) ? CODE_FOR_htm_mtspr_di : CODE_FOR_htm_mtspr_si;\n+}\n+\n+/* Expand the HTM builtin in EXP and store the result in TARGET.\n+   Store true in *EXPANDEDP if we found a builtin to expand.  */\n+static rtx\n+htm_expand_builtin (tree exp, rtx target, bool * expandedp)\n+{\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  bool nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n+  enum rs6000_builtins fcode = (enum rs6000_builtins) DECL_FUNCTION_CODE (fndecl);\n+  const struct builtin_description *d;\n+  size_t i;\n+\n+  *expandedp = false;\n+\n+  /* Expand the HTM builtins.  */\n+  d = bdesc_htm;\n+  for (i = 0; i < ARRAY_SIZE (bdesc_htm); i++, d++)\n+    if (d->code == fcode)\n+      {\n+\trtx op[MAX_HTM_OPERANDS], pat;\n+\tint nopnds = 0;\n+\ttree arg;\n+\tcall_expr_arg_iterator iter;\n+\tunsigned attr = rs6000_builtin_info[fcode].attr;\n+\tenum insn_code icode = d->icode;\n+\n+\tif (attr & RS6000_BTC_SPR)\n+\t  icode = rs6000_htm_spr_icode (nonvoid);\n+\n+\tif (nonvoid)\n+\t  {\n+\t    enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+\t    if (!target\n+\t\t|| GET_MODE (target) != tmode\n+\t\t|| !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+\t      target = gen_reg_rtx (tmode);\n+\t    op[nopnds++] = target;\n+\t  }\n+\n+\tFOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+\t{\n+\t  const struct insn_operand_data *insn_op;\n+\n+\t  if (arg == error_mark_node || nopnds >= MAX_HTM_OPERANDS)\n+\t    return NULL_RTX;\n+\n+\t  insn_op = &insn_data[icode].operand[nopnds];\n+\n+\t  op[nopnds] = expand_normal (arg);\n+\n+\t  if (!(*insn_op->predicate) (op[nopnds], insn_op->mode))\n+\t    {\n+\t      if (!strcmp (insn_op->constraint, \"n\"))\n+\t\t{\n+\t\t  int arg_num = (nonvoid) ? nopnds : nopnds + 1;\n+\t\t  if (!CONST_INT_P (op[nopnds]))\n+\t\t    error (\"argument %d must be an unsigned literal\", arg_num);\n+\t\t  else\n+\t\t    error (\"argument %d is an unsigned literal that is \"\n+\t\t\t   \"out of range\", arg_num);\n+\t\t  return const0_rtx;\n+\t\t}\n+\t      op[nopnds] = copy_to_mode_reg (insn_op->mode, op[nopnds]);\n+\t    }\n+\n+\t  nopnds++;\n+\t}\n+\n+\t/* Handle the builtins for extended mnemonics.  These accept\n+\t   no arguments, but map to builtins that take arguments.  */\n+\tswitch (fcode)\n+\t  {\n+\t  case HTM_BUILTIN_TENDALL:  /* Alias for: tend. 1  */\n+\t  case HTM_BUILTIN_TRESUME:  /* Alias for: tsr. 1  */\n+\t    op[nopnds++] = GEN_INT (1);\n+#ifdef ENABLE_CHECKING\n+\t    attr |= RS6000_BTC_UNARY;\n+#endif\n+\t    break;\n+\t  case HTM_BUILTIN_TSUSPEND: /* Alias for: tsr. 0  */\n+\t    op[nopnds++] = GEN_INT (0);\n+#ifdef ENABLE_CHECKING\n+\t    attr |= RS6000_BTC_UNARY;\n+#endif\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+\t/* If this builtin accesses SPRs, then pass in the appropriate\n+\t   SPR number and SPR regno as the last two operands.  */\n+\tif (attr & RS6000_BTC_SPR)\n+\t  {\n+\t    op[nopnds++] = gen_rtx_CONST_INT (Pmode, htm_spr_num (fcode));\n+\t    op[nopnds++] = gen_rtx_REG (Pmode, htm_spr_regno (fcode));\n+\t  }\n+\n+#ifdef ENABLE_CHECKING\n+\tint expected_nopnds = 0;\n+\tif ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_UNARY)\n+\t  expected_nopnds = 1;\n+\telse if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_BINARY)\n+\t  expected_nopnds = 2;\n+\telse if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_TERNARY)\n+\t  expected_nopnds = 3;\n+\tif (!(attr & RS6000_BTC_VOID))\n+\t  expected_nopnds += 1;\n+\tif (attr & RS6000_BTC_SPR)\n+\t  expected_nopnds += 2;\n+\n+\tgcc_assert (nopnds == expected_nopnds && nopnds <= MAX_HTM_OPERANDS);\n+#endif\n+\n+\tswitch (nopnds)\n+\t  {\n+\t  case 0:\n+\t    pat = GEN_FCN (icode) (NULL_RTX);\n+\t    break;\n+\t  case 1:\n+\t    pat = GEN_FCN (icode) (op[0]);\n+\t    break;\n+\t  case 2:\n+\t    pat = GEN_FCN (icode) (op[0], op[1]);\n+\t    break;\n+\t  case 3:\n+\t    pat = GEN_FCN (icode) (op[0], op[1], op[2]);\n+\t    break;\n+\t  case 4:\n+\t    pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3]);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tif (!pat)\n+\t  return NULL_RTX;\n+\temit_insn (pat);\n+\n+\t*expandedp = true;\n+\tif (nonvoid)\n+\t  return target;\n+\treturn const0_rtx;\n+      }\n+\n+  return NULL_RTX;\n+}\n+\n static rtx\n rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n {\n@@ -11974,6 +12229,8 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n     error (\"Builtin function %s is only valid for the cell processor\", name);\n   else if ((fnmask & RS6000_BTM_VSX) != 0)\n     error (\"Builtin function %s requires the -mvsx option\", name);\n+  else if ((fnmask & RS6000_BTM_HTM) != 0)\n+    error (\"Builtin function %s requires the -mhtm option\", name);\n   else if ((fnmask & RS6000_BTM_ALTIVEC) != 0)\n     error (\"Builtin function %s requires the -maltivec option\", name);\n   else if ((fnmask & RS6000_BTM_PAIRED) != 0)\n@@ -12150,6 +12407,13 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     {\n       ret = paired_expand_builtin (exp, target, &success);\n \n+      if (success)\n+\treturn ret;\n+    }  \n+  if (TARGET_HTM)\n+    {\n+      ret = htm_expand_builtin (exp, target, &success);\n+\n       if (success)\n \treturn ret;\n     }  \n@@ -12335,6 +12599,9 @@ rs6000_init_builtins (void)\n     spe_init_builtins ();\n   if (TARGET_EXTRA_BUILTINS)\n     altivec_init_builtins ();\n+  if (TARGET_HTM)\n+    htm_init_builtins ();\n+\n   if (TARGET_EXTRA_BUILTINS || TARGET_SPE || TARGET_PAIRED_FLOAT)\n     rs6000_common_init_builtins ();\n \n@@ -13074,6 +13341,79 @@ altivec_init_builtins (void)\n   def_builtin (\"__builtin_vec_ext_v2di\", ftype, VSX_BUILTIN_VEC_EXT_V2DI);\n }\n \n+static void\n+htm_init_builtins (void)\n+{\n+  HOST_WIDE_INT builtin_mask = rs6000_builtin_mask;\n+  const struct builtin_description *d;\n+  size_t i;\n+\n+  d = bdesc_htm;\n+  for (i = 0; i < ARRAY_SIZE (bdesc_htm); i++, d++)\n+    {\n+      tree op[MAX_HTM_OPERANDS], type;\n+      HOST_WIDE_INT mask = d->mask;\n+      unsigned attr = rs6000_builtin_info[d->code].attr;\n+      bool void_func = (attr & RS6000_BTC_VOID);\n+      int attr_args = (attr & RS6000_BTC_TYPE_MASK);\n+      int nopnds = 0;\n+      tree argtype = (attr & RS6000_BTC_SPR) ? long_unsigned_type_node\n+\t\t\t\t\t     : unsigned_type_node;\n+\n+      if ((mask & builtin_mask) != mask)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"htm_builtin, skip binary %s\\n\", d->name);\n+\t  continue;\n+\t}\n+\n+      if (d->name == 0)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"htm_builtin, bdesc_htm[%ld] no name\\n\",\n+\t\t     (long unsigned) i);\n+\t  continue;\n+\t}\n+\n+      op[nopnds++] = (void_func) ? void_type_node : argtype;\n+\n+      if (attr_args == RS6000_BTC_UNARY)\n+\top[nopnds++] = argtype;\n+      else if (attr_args == RS6000_BTC_BINARY)\n+\t{\n+\t  op[nopnds++] = argtype;\n+\t  op[nopnds++] = argtype;\n+\t}\n+      else if (attr_args == RS6000_BTC_TERNARY)\n+\t{\n+\t  op[nopnds++] = argtype;\n+\t  op[nopnds++] = argtype;\n+\t  op[nopnds++] = argtype;\n+\t}\n+\n+      switch (nopnds)\n+\t{\n+\tcase 1:\n+\t  type = build_function_type_list (op[0], NULL_TREE);\n+\t  break;\n+\tcase 2:\n+\t  type = build_function_type_list (op[0], op[1], NULL_TREE);\n+\t  break;\n+\tcase 3:\n+\t  type = build_function_type_list (op[0], op[1], op[2], NULL_TREE);\n+\t  break;\n+\tcase 4:\n+\t  type = build_function_type_list (op[0], op[1], op[2], op[3],\n+\t\t\t\t\t   NULL_TREE);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      def_builtin (d->name, type, d->code);\n+    }\n+}\n+\n /* Hash function for builtin functions with up to 3 arguments and a return\n    type.  */\n static unsigned\n@@ -28777,6 +29117,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"dlmzb\",\t\t\tOPTION_MASK_DLMZB,\t\tfalse, true  },\n   { \"fprnd\",\t\t\tOPTION_MASK_FPRND,\t\tfalse, true  },\n   { \"hard-dfp\",\t\t\tOPTION_MASK_DFP,\t\tfalse, true  },\n+  { \"htm\",\t\t\tOPTION_MASK_HTM,\t\tfalse, true  },\n   { \"isel\",\t\t\tOPTION_MASK_ISEL,\t\tfalse, true  },\n   { \"mfcrf\",\t\t\tOPTION_MASK_MFCRF,\t\tfalse, true  },\n   { \"mfpgpr\",\t\t\tOPTION_MASK_MFPGPR,\t\tfalse, true  },\n@@ -28836,6 +29177,7 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n   { \"cell\",\t\t RS6000_BTM_CELL,\tfalse, false },\n   { \"power8-vector\",\t RS6000_BTM_P8_VECTOR,\tfalse, false },\n   { \"crypto\",\t\t RS6000_BTM_CRYPTO,\tfalse, false },\n+  { \"htm\",\t\t RS6000_BTM_HTM,\tfalse, false },\n };\n \n /* Option variables that we want to support inside attribute((target)) and"}, {"sha": "6e2d9166f33eafeb4b3fb0c925c8e5f27e81616e", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -164,7 +164,7 @@\n %{mcpu=e6500: -me6500} \\\n %{maltivec: -maltivec} \\\n %{mvsx: -mvsx %{!maltivec: -maltivec} %{!mcpu*: %(asm_cpu_power7)}} \\\n-%{mpower8-vector|mcrypto|mdirect-move: %{!mcpu*: %(asm_cpu_power8)}} \\\n+%{mpower8-vector|mcrypto|mdirect-move|mhtm: %{!mcpu*: %(asm_cpu_power8)}} \\\n -many\"\n \n #define CPP_DEFAULT_SPEC \"\"\n@@ -285,9 +285,11 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #ifndef HAVE_AS_POWER8\n #undef  TARGET_DIRECT_MOVE\n #undef  TARGET_CRYPTO\n+#undef  TARGET_HTM\n #undef  TARGET_P8_VECTOR\n #define TARGET_DIRECT_MOVE 0\n #define TARGET_CRYPTO 0\n+#define TARGET_HTM 0\n #define TARGET_P8_VECTOR 0\n #endif\n \n@@ -543,6 +545,7 @@ extern int rs6000_vector_align[];\n #define MASK_FPRND\t\t\tOPTION_MASK_FPRND\n #define MASK_P8_FUSION\t\t\tOPTION_MASK_P8_FUSION\n #define MASK_HARD_FLOAT\t\t\tOPTION_MASK_HARD_FLOAT\n+#define MASK_HTM\t\t\tOPTION_MASK_HTM\n #define MASK_ISEL\t\t\tOPTION_MASK_ISEL\n #define MASK_MFCRF\t\t\tOPTION_MASK_MFCRF\n #define MASK_MFPGPR\t\t\tOPTION_MASK_MFPGPR\n@@ -891,7 +894,7 @@ enum data_align { align_abi, align_opt, align_both };\n    Another pseudo (not included in DWARF_FRAME_REGISTERS) is soft frame\n    pointer, which is eventually eliminated in favor of SP or FP.  */\n \n-#define FIRST_PSEUDO_REGISTER 114\n+#define FIRST_PSEUDO_REGISTER 117\n \n /* This must be included for pre gcc 3.0 glibc compatibility.  */\n #define PRE_GCC3_DWARF_FRAME_REGISTERS 77\n@@ -953,7 +956,7 @@ enum data_align { align_abi, align_opt, align_both };\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    1, 1\t\t\t\t\t\t   \\\n-   , 1, 1, 1                                       \\\n+   , 1, 1, 1, 1, 1, 1\t\t\t\t   \\\n }\n \n /* 1 for registers not available across function calls.\n@@ -973,7 +976,7 @@ enum data_align { align_abi, align_opt, align_both };\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    1, 1\t\t\t\t\t\t   \\\n-   , 1, 1, 1                                       \\\n+   , 1, 1, 1, 1, 1, 1\t\t\t\t   \\\n }\n \n /* Like `CALL_USED_REGISTERS' except this macro doesn't require that\n@@ -992,7 +995,7 @@ enum data_align { align_abi, align_opt, align_both };\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0\t\t\t\t\t\t   \\\n-   , 0, 0, 0                                       \\\n+   , 0, 0, 0, 0, 0, 0\t\t\t\t   \\\n }\n \n #define TOTAL_ALTIVEC_REGS\t(LAST_ALTIVEC_REGNO - FIRST_ALTIVEC_REGNO + 1)\n@@ -1031,6 +1034,9 @@ enum data_align { align_abi, align_opt, align_both };\n \tvrsave, vscr\t(fixed)\n \tspe_acc, spefscr (fixed)\n \tsfp\t\t(fixed)\n+\ttfhar\t\t(fixed)\n+\ttfiar\t\t(fixed)\n+\ttexasr\t\t(fixed)\n */\n \n #if FIXED_R2 == 1\n@@ -1072,7 +1078,7 @@ enum data_align { align_abi, align_opt, align_both };\n    96, 95, 94, 93, 92, 91,\t\t\t\t\t\\\n    108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97,\t\\\n    109, 110,\t\t\t\t\t\t\t\\\n-   111, 112, 113\t\t\t\t\t\t\\\n+   111, 112, 113, 114, 115, 116\t\t\t\t\t\\\n }\n \n /* True if register is floating-point.  */\n@@ -1299,6 +1305,7 @@ enum reg_class\n   VSCR_REGS,\n   SPE_ACC_REGS,\n   SPEFSCR_REGS,\n+  SPR_REGS,\n   NON_SPECIAL_REGS,\n   LINK_REGS,\n   CTR_REGS,\n@@ -1329,6 +1336,7 @@ enum reg_class\n   \"VSCR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"SPE_ACC_REGS\",                                                       \\\n   \"SPEFSCR_REGS\",                                                       \\\n+  \"SPR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"NON_SPECIAL_REGS\",\t\t\t\t\t\t\t\\\n   \"LINK_REGS\",\t\t\t\t\t\t\t\t\\\n   \"CTR_REGS\",\t\t\t\t\t\t\t\t\\\n@@ -1358,6 +1366,7 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00004000 }, /* VSCR_REGS */\t     \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00008000 }, /* SPE_ACC_REGS */     \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00010000 }, /* SPEFSCR_REGS */     \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00040000 }, /* SPR_REGS */     \\\n   { 0xffffffff, 0xffffffff, 0x00000008, 0x00020000 }, /* NON_SPECIAL_REGS */ \\\n   { 0x00000000, 0x00000000, 0x00000002, 0x00000000 }, /* LINK_REGS */\t     \\\n   { 0x00000000, 0x00000000, 0x00000004, 0x00000000 }, /* CTR_REGS */\t     \\\n@@ -1368,7 +1377,7 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000ff0, 0x00000000 }, /* CR_REGS */\t     \\\n   { 0xffffffff, 0x00000000, 0x00000ffe, 0x00020000 }, /* NON_FLOAT_REGS */   \\\n   { 0x00000000, 0x00000000, 0x00001000, 0x00000000 }, /* CA_REGS */\t     \\\n-  { 0xffffffff, 0xffffffff, 0xfffffffe, 0x0003ffff }  /* ALL_REGS */\t     \\\n+  { 0xffffffff, 0xffffffff, 0xfffffffe, 0x0007ffff }  /* ALL_REGS */\t     \\\n }\n \n /* The same information, inverted:\n@@ -2282,6 +2291,9 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   &rs6000_reg_names[111][0],\t/* spe_acc */\t\t\t\t\\\n   &rs6000_reg_names[112][0],\t/* spefscr */\t\t\t\t\\\n   &rs6000_reg_names[113][0],\t/* sfp  */\t\t\t\t\\\n+  &rs6000_reg_names[114][0],\t/* tfhar  */\t\t\t\t\\\n+  &rs6000_reg_names[115][0],\t/* tfiar  */\t\t\t\t\\\n+  &rs6000_reg_names[116][0],\t/* texasr  */\t\t\t\t\\\n }\n \n /* Table of additional register names to use in user input.  */\n@@ -2335,7 +2347,9 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"vs48\", 93}, {\"vs49\", 94}, {\"vs50\", 95}, {\"vs51\", 96},       \\\n   {\"vs52\", 97}, {\"vs53\", 98}, {\"vs54\", 99}, {\"vs55\", 100},\t\\\n   {\"vs56\", 101},{\"vs57\", 102},{\"vs58\", 103},{\"vs59\", 104},      \\\n-  {\"vs60\", 105},{\"vs61\", 106},{\"vs62\", 107},{\"vs63\", 108} }\n+  {\"vs60\", 105},{\"vs61\", 106},{\"vs62\", 107},{\"vs63\", 108},\t\\\n+  /* Transactional Memory Facility (HTM) Registers.  */\t\t\\\n+  {\"tfhar\",  114}, {\"tfiar\",  115}, {\"texasr\",  116} }\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n@@ -2424,7 +2438,12 @@ extern int frame_pointer_needed;\n #define RS6000_BTC_ATTR_MASK\t0x00000700\t/* Mask of the attributes.  */\n \n /* Miscellaneous information.  */\n-#define RS6000_BTC_OVERLOADED\t0x4000000\t/* function is overloaded.  */\n+#define RS6000_BTC_SPR\t\t0x01000000\t/* function references SPRs.  */\n+#define RS6000_BTC_VOID\t\t0x02000000\t/* function has no return value.  */\n+#define RS6000_BTC_OVERLOADED\t0x04000000\t/* function is overloaded.  */\n+#define RS6000_BTC_32BIT\t0x08000000\t/* function references SPRs.  */\n+#define RS6000_BTC_64BIT\t0x10000000\t/* function references SPRs.  */\n+#define RS6000_BTC_MISC_MASK\t0x1f000000\t/* Mask of the misc info.  */\n \n /* Convenience macros to document the instruction type.  */\n #define RS6000_BTC_MEM\t\tRS6000_BTC_MISC\t/* load/store touches mem.  */\n@@ -2438,6 +2457,7 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_VSX\t\tMASK_VSX\t/* VSX (vector/scalar).  */\n #define RS6000_BTM_P8_VECTOR\tMASK_P8_VECTOR\t/* ISA 2.07 vector.  */\n #define RS6000_BTM_CRYPTO\tMASK_CRYPTO\t/* crypto funcs.  */\n+#define RS6000_BTM_HTM\t\tMASK_HTM\t/* hardware TM funcs.  */\n #define RS6000_BTM_SPE\t\tMASK_STRING\t/* E500 */\n #define RS6000_BTM_PAIRED\tMASK_MULHW\t/* 750CL paired insns.  */\n #define RS6000_BTM_FRE\t\tMASK_POPCNTB\t/* FRE instruction.  */\n@@ -2455,6 +2475,7 @@ extern int frame_pointer_needed;\n \t\t\t\t | RS6000_BTM_FRES\t\t\t\\\n \t\t\t\t | RS6000_BTM_FRSQRTE\t\t\t\\\n \t\t\t\t | RS6000_BTM_FRSQRTES\t\t\t\\\n+\t\t\t\t | RS6000_BTM_HTM\t\t\t\\\n \t\t\t\t | RS6000_BTM_POPCNTD\t\t\t\\\n \t\t\t\t | RS6000_BTM_CELL)\n \n@@ -2466,6 +2487,7 @@ extern int frame_pointer_needed;\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S\n@@ -2477,6 +2499,7 @@ extern int frame_pointer_needed;\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_E(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_S(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n@@ -2495,6 +2518,7 @@ enum rs6000_builtins\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_E\n+#undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_S"}, {"sha": "372c8138fc6b74d7bc14cc1d07cda5416a4f3c98", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -53,6 +53,9 @@\n    (SPE_ACC_REGNO\t\t111)\n    (SPEFSCR_REGNO\t\t112)\n    (FRAME_POINTER_REGNUM\t113)\n+   (TFHAR_REGNO\t\t\t114)\n+   (TFIAR_REGNO\t\t\t115)\n+   (TEXASR_REGNO\t\t116)\n \n    ; ABI defined stack offsets for storing the TOC pointer with AIX calls.\n    (TOC_SAVE_OFFSET_32BIT\t20)\n@@ -153,7 +156,7 @@\n \f\n ;; Define an insn type attribute.  This is used in function unit delay\n ;; computations.\n-(define_attr \"type\" \"integer,two,three,load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,store,store_ux,store_u,fpload,fpload_ux,fpload_u,fpstore,fpstore_ux,fpstore_u,vecload,vecstore,imul,imul2,imul3,lmul,idiv,ldiv,insert_word,branch,cmp,fast_compare,compare,var_delayed_compare,delayed_compare,imul_compare,lmul_compare,fpcompare,cr_logical,delayed_cr,mfcr,mfcrf,mtcr,mfjmpr,mtjmpr,fp,fpsimple,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg,brinc,vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,vecfloat,vecfdiv,vecdouble,isync,sync,load_l,store_c,shift,trap,insert_dword,var_shift_rotate,cntlz,exts,mffgpr,mftgpr,isel,popcnt,crypto\"\n+(define_attr \"type\" \"integer,two,three,load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,store,store_ux,store_u,fpload,fpload_ux,fpload_u,fpstore,fpstore_ux,fpstore_u,vecload,vecstore,imul,imul2,imul3,lmul,idiv,ldiv,insert_word,branch,cmp,fast_compare,compare,var_delayed_compare,delayed_compare,imul_compare,lmul_compare,fpcompare,cr_logical,delayed_cr,mfcr,mfcrf,mtcr,mfjmpr,mtjmpr,fp,fpsimple,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg,brinc,vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,vecfloat,vecfdiv,vecdouble,isync,sync,load_l,store_c,shift,trap,insert_dword,var_shift_rotate,cntlz,exts,mffgpr,mftgpr,isel,popcnt,crypto,htm\"\n   (const_string \"integer\"))\n \n ;; Define floating point instruction sub-types for use with Xfpu.md\n@@ -15307,3 +15310,4 @@\n (include \"dfp.md\")\n (include \"paired.md\")\n (include \"crypto.md\")\n+(include \"htm.md\")"}, {"sha": "f36e47580314ceafc6f95bc059583625a648598f", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -539,6 +539,10 @@ mdirect-move\n Target Report Mask(DIRECT_MOVE) Var(rs6000_isa_flags)\n Use ISA 2.07 direct move between GPR & VSX register instructions\n \n+mhtm\n+Target Report Mask(HTM) Var(rs6000_isa_flags)\n+Use ISA 2.07 transactional memory (HTM) instructions\n+\n mquad-memory\n Target Report Mask(QUAD_MEMORY) Var(rs6000_isa_flags)\n Generate the quad word memory instructions (lq/stq/lqarx/stqcx)."}, {"sha": "81372dfb140322ae5cc582c67c668389201d8740", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -72,6 +72,7 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/vsx.md \\\n \t$(srcdir)/config/rs6000/altivec.md \\\n \t$(srcdir)/config/rs6000/crypto.md \\\n+\t$(srcdir)/config/rs6000/htm.md \\\n \t$(srcdir)/config/rs6000/spe.md \\\n \t$(srcdir)/config/rs6000/dfp.md \\\n \t$(srcdir)/config/rs6000/paired.md"}, {"sha": "817d2dcc4d0cef5ec469491f36aac83c6c3ded23", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -1,3 +1,10 @@\n+2013-07-15  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_powerpc_htm_ok): New\n+\tfunction to test if HTM is available.\n+\t* gcc.target/powerpc/htm-xl-intrin-1.c: New test.\n+\t* gcc.target/powerpc/htm-builtin-1.c: New test.\n+\n 2013-07-15  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray_lib_realloc_1.f90: New."}, {"sha": "e58816a7f0f695ff61136ba99d8103a18be1e82c", "filename": "gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fhtm-builtin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fhtm-builtin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fhtm-builtin-1.c?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_htm_ok } */\n+/* { dg-options \"-O2 -mhtm\" } */\n+\n+/* { dg-final { scan-assembler-times \"tbegin\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tend\\\\.\" 2 } } */\n+/* { dg-final { scan-assembler-times \"tabort\\\\.\" 2 } } */\n+/* { dg-final { scan-assembler-times \"tabortdc\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tabortdci\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tabortwc\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tabortwci\\\\.\" 2 } } */\n+/* { dg-final { scan-assembler-times \"tcheck\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"trechkpt\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"treclaim\\\\.\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tsr\\\\.\" 3 } } */\n+/* { dg-final { scan-assembler-times \"mfspr\" 4 } } */\n+/* { dg-final { scan-assembler-times \"mtspr\" 4 } } */\n+\n+void use_builtins (long *p, char code, long *a, long *b)\n+{\n+  p[0] = __builtin_tbegin (0);\n+  p[1] = __builtin_tend (0);\n+  p[2] = __builtin_tendall ();\n+  p[3] = __builtin_tabort (0);\n+  p[4] = __builtin_tabort (code);\n+\n+  p[5] = __builtin_tabortdc (0xf, a[5], b[5]);\n+  p[6] = __builtin_tabortdci (0xf, a[6], 13);\n+  p[7] = __builtin_tabortwc (0xf, a[7], b[7]);\n+  p[8] = __builtin_tabortwci (0xf, a[8], 13);\n+\n+  p[9] = __builtin_tcheck (5);\n+  p[10] = __builtin_trechkpt ();\n+  p[11] = __builtin_treclaim (0);\n+  p[12] = __builtin_tresume ();\n+  p[13] = __builtin_tsuspend ();\n+  p[14] = __builtin_tsr (0);\n+  p[15] = __builtin_ttest (); /* This expands to a tabortwci.  */\n+\n+\n+  p[16] = __builtin_get_texasr ();\n+  p[17] = __builtin_get_texasru ();\n+  p[18] = __builtin_get_tfhar ();\n+  p[19] = __builtin_get_tfiar ();\n+\n+  __builtin_set_texasr (a[20]);\n+  __builtin_set_texasru (a[21]);\n+  __builtin_set_tfhar (a[22]);\n+  __builtin_set_tfiar (a[23]);\n+}"}, {"sha": "5e92814b77e31e147f80ef7d657f755dc0983749", "filename": "gcc/testsuite/gcc.target/powerpc/htm-xl-intrin-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fhtm-xl-intrin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fhtm-xl-intrin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fhtm-xl-intrin-1.c?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -0,0 +1,32 @@\n+/* This checks the availability of the XL compiler intrinsics for\n+   transactional execution with the expected prototypes.  */\n+\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_htm_ok } */\n+/* { dg-options \"-O2 -mhtm\" } */\n+\n+#include <htmxlintrin.h>\n+\n+void\n+foo (void *TM_buff, long *result, unsigned char *code)\n+{\n+  *result++ = __TM_simple_begin ();\n+  *result++ = __TM_begin (TM_buff);\n+  *result++ = __TM_end ();\n+  __TM_abort ();\n+  __TM_named_abort (*code);\n+  __TM_resume ();\n+  __TM_suspend ();\n+  *result++ = __TM_is_user_abort (TM_buff);\n+  *result++ = __TM_is_named_user_abort (TM_buff, code);\n+  *result++ = __TM_is_illegal (TM_buff);\n+  *result++ = __TM_is_footprint_exceeded (TM_buff);\n+  *result++ = __TM_nesting_depth (TM_buff);\n+  *result++ = __TM_is_nested_too_deep (TM_buff);\n+  *result++ = __TM_is_conflict (TM_buff);\n+  *result++ = __TM_is_failure_persistent (TM_buff);\n+  *result++ = __TM_failure_address (TM_buff);\n+  *result++ = __TM_failure_code (TM_buff);\n+}\n+"}, {"sha": "936c97af9067f484a889a216a3cdff8efb3bace5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -2839,6 +2839,27 @@ proc check_effective_target_powerpc_vsx_ok { } {\n     }\n }\n \n+# Return 1 if this is a PowerPC target supporting -mhtm\n+\n+proc check_effective_target_powerpc_htm_ok { } {\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget rs6000-*-*] } {\n+\t# HTM is not supported on AIX yet.\n+\tif { [istarget powerpc*-*-aix*] } {\n+\t    return 0\n+\t}\n+\treturn [check_no_compiler_messages powerpc_htm_ok object {\n+\t    int main (void) {\n+\t\tasm volatile (\"tbegin. 0\");\n+\t\treturn 0;\n+\t    }\n+\t} \"-mhtm\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n # Return 1 if this is a PowerPC target supporting -mcpu=cell.\n \n proc check_effective_target_powerpc_ppu_ok { } {"}, {"sha": "6b8ac0be157de4b47bd603aa5f2f8f15d06c5f14", "filename": "libitm/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -1,3 +1,18 @@\n+2013-07-15  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* acinclude.m4 (LIBITM_CHECK_AS_HTM): New.\n+\t* configure.ac: Use it.\n+\t(AC_CHECK_HEADERS): Check for sys/auxv.h.\n+\t(AC_CHECK_FUNCS): Check for getauxval.\n+\t* config.h.in, configure: Rebuild.\n+\t* configure.tgt (target_cpu): Add -mhtm to XCFLAGS.\n+\t* config/powerpc/target.h: Include sys/auxv.h and htmintrin.h.\n+\t(USE_HTM_FASTPATH): Define.\n+\t(_TBEGIN_STARTED, _TBEGIN_INDETERMINATE, _TBEGIN_PERSISTENT,\n+\t_HTM_RETRIES) New macros.\n+\t(htm_abort, htm_abort_should_retry, htm_available, htm_begin, htm_init,\n+\thtm_begin_success, htm_commit, htm_transaction_active): New functions.\n+\n 2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/target.h: Include htmintrin.h."}, {"sha": "eacf8d4538310c70e3291b948c72619eb7026039", "filename": "libitm/acinclude.m4", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Facinclude.m4?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -123,6 +123,20 @@ i[[34567]]86 | x86_64)\n   ;;\n esac])\n \n+dnl Check if as supports HTM instructions.\n+AC_DEFUN([LIBITM_CHECK_AS_HTM], [\n+case \"${target_cpu}\" in\n+powerpc*)\n+  AC_CACHE_CHECK([if the assembler supports HTM], libitm_cv_as_htm, [\n+    AC_TRY_COMPILE([], [asm(\"tbegin. 0; tend. 0\");],\n+\t\t   [libitm_cv_as_htm=yes], [libitm_cv_as_htm=no])\n+  ])\n+  if test x$libitm_cv_as_htm = xyes; then\n+    AC_DEFINE(HAVE_AS_HTM, 1, [Define to 1 if the assembler supports HTM.])\n+  fi\n+  ;;\n+esac])\n+\n sinclude(../libtool.m4)\n dnl The lines below arrange for aclocal not to bring an installed\n dnl libtool.m4 into aclocal.m4, while still arranging for automake to"}, {"sha": "26972c7e43e5b5ccb858001e49efd618057e8ca8", "filename": "libitm/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig.h.in?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -12,6 +12,9 @@\n /* Define if your assembler supports .cfi_* directives. */\n #undef HAVE_AS_CFI_PSEUDO_OP\n \n+/* Define to 1 if the assembler supports HTM. */\n+#undef HAVE_AS_HTM\n+\n /* Define to 1 if the assembler supports RTM. */\n #undef HAVE_AS_RTM\n \n@@ -36,6 +39,9 @@\n /* Define to 1 if target has a weakref that works like the ELF one. */\n #undef HAVE_ELF_STYLE_WEAKREF\n \n+/* Define to 1 if you have the `getauxval' function. */\n+#undef HAVE_GETAUXVAL\n+\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n@@ -81,6 +87,9 @@\n /* Define to 1 if the target supports __sync_*_compare_and_swap */\n #undef HAVE_SYNC_BUILTINS\n \n+/* Define to 1 if you have the <sys/auxv.h> header file. */\n+#undef HAVE_SYS_AUXV_H\n+\n /* Define to 1 if you have the <sys/stat.h> header file. */\n #undef HAVE_SYS_STAT_H\n "}, {"sha": "cf01a57248d08072de82e4f0f69bfabd74d16b19", "filename": "libitm/config/powerpc/target.h", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfig%2Fpowerpc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfig%2Fpowerpc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fpowerpc%2Ftarget.h?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -22,6 +22,10 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#ifdef HAVE_SYS_AUXV_H\n+#include <sys/auxv.h>\n+#endif\n+\n namespace GTM HIDDEN {\n \n typedef int v128 __attribute__((vector_size(16), may_alias, aligned(16)));\n@@ -55,4 +59,82 @@ cpu_relax (void)\n   __asm volatile (\"\" : : : \"memory\");\n }\n \n+// Use HTM if it is supported by the system.\n+// See gtm_thread::begin_transaction for how these functions are used.\n+#if defined (__linux__) \\\n+    && defined (HAVE_AS_HTM) \\\n+    && defined (HAVE_GETAUXVAL) \\\n+    && defined (AT_HWCAP2) \\\n+    && defined (PPC_FEATURE2_HAS_HTM)\n+\n+#include <htmintrin.h>\n+\n+#define USE_HTM_FASTPATH\n+\n+#define _TBEGIN_STARTED       0\n+#define _TBEGIN_INDETERMINATE 1\n+#define _TBEGIN_PERSISTENT    2\n+\n+/* Number of retries for transient failures.  */\n+#define _HTM_RETRIES 10\n+\n+static inline bool\n+htm_available (void)\n+{\n+  return (getauxval (AT_HWCAP2) & PPC_FEATURE2_HAS_HTM) ? true : false;\n+}\n+\n+static inline uint32_t\n+htm_init (void)\n+{\n+  // Maximum number of times we try to execute a transaction\n+  // as a HW transaction.\n+  return htm_available () ? _HTM_RETRIES : 0;\n+}\n+\n+static inline uint32_t\n+htm_begin (void)\n+{\n+  if (__builtin_expect (__builtin_tbegin (0), 1))\n+    return _TBEGIN_STARTED;\n+\n+  if (_TEXASRU_FAILURE_PERSISTENT (__builtin_get_texasru ()))\n+    return _TBEGIN_PERSISTENT;\n+\n+  return _TBEGIN_INDETERMINATE;\n+}\n+\n+static inline bool\n+htm_begin_success (uint32_t begin_ret)\n+{\n+  return begin_ret == _TBEGIN_STARTED;\n+}\n+\n+static inline void\n+htm_commit (void)\n+{\n+  __builtin_tend (0);\n+}\n+\n+static inline void\n+htm_abort (void)\n+{\n+  __builtin_tabort (0);\n+}\n+\n+static inline bool\n+htm_abort_should_retry (uint32_t begin_ret)\n+{\n+  return begin_ret != _TBEGIN_PERSISTENT;\n+}\n+\n+/* Returns true iff a hardware transaction is currently being executed.  */\n+static inline bool\n+htm_transaction_active (void)\n+{\n+  return (_HTM_STATE (__builtin_ttest ()) == _HTM_TRANSACTIONAL);\n+}\n+\n+#endif\n+\n } // namespace GTM"}, {"sha": "7b3c0692e8f77d5d4f2e1c16ada32cb6859f7658", "filename": "libitm/configure", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -15349,7 +15349,7 @@ $as_echo \"#define STRING_WITH_STRINGS 1\" >>confdefs.h\n \n fi\n \n-for ac_header in unistd.h semaphore.h sys/time.h malloc.h\n+for ac_header in unistd.h semaphore.h sys/time.h sys/auxv.h malloc.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n@@ -16184,7 +16184,7 @@ rm -f core conftest.err conftest.$ac_objext \\\n     conftest$ac_exeext conftest.$ac_ext\n \n # Check for functions needed.\n-for ac_func in strtoull memalign posix_memalign\n+for ac_func in strtoull memalign posix_memalign getauxval\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n@@ -17364,6 +17364,43 @@ $as_echo \"#define HAVE_AS_RTM 1\" >>confdefs.h\n   ;;\n esac\n \n+case \"${target_cpu}\" in\n+powerpc*)\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if the assembler supports HTM\" >&5\n+$as_echo_n \"checking if the assembler supports HTM... \" >&6; }\n+if test \"${libitm_cv_as_htm+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+asm(\"tbegin. 0; tend. 0\");\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libitm_cv_as_htm=yes\n+else\n+  libitm_cv_as_htm=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libitm_cv_as_htm\" >&5\n+$as_echo \"$libitm_cv_as_htm\" >&6; }\n+  if test x$libitm_cv_as_htm = xyes; then\n+\n+$as_echo \"#define HAVE_AS_HTM 1\" >>confdefs.h\n+\n+  fi\n+  ;;\n+esac\n+\n \n   { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether weak refs work like ELF\" >&5\n $as_echo_n \"checking whether weak refs work like ELF... \" >&6; }"}, {"sha": "584a23bee200caede5406d908bb0a87e48412ca6", "filename": "libitm/configure.ac", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.ac?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -160,7 +160,7 @@ AC_SUBST(libtool_VERSION)\n AC_STDC_HEADERS\n AC_HEADER_TIME\n ACX_HEADER_STRING\n-AC_CHECK_HEADERS(unistd.h semaphore.h sys/time.h malloc.h)\n+AC_CHECK_HEADERS(unistd.h semaphore.h sys/time.h sys/auxv.h malloc.h)\n \n GCC_HEADER_STDINT(gstdint.h)\n \n@@ -193,7 +193,7 @@ AC_LINK_IFELSE(\n    [AC_MSG_ERROR([Pthreads are required to build libitm])])])\n \n # Check for functions needed.\n-AC_CHECK_FUNCS(strtoull memalign posix_memalign)\n+AC_CHECK_FUNCS(strtoull memalign posix_memalign getauxval)\n \n # Check for broken semaphore implementation on darwin.\n # sem_init returns: sem_init error: Function not implemented.\n@@ -245,6 +245,7 @@ LIBITM_CHECK_SYNC_BUILTINS\n LIBITM_CHECK_64BIT_SYNC_BUILTINS\n LIBITM_CHECK_AS_AVX\n LIBITM_CHECK_AS_RTM\n+LIBITM_CHECK_AS_HTM\n \n GCC_CHECK_ELF_STYLE_WEAKREF\n "}, {"sha": "d8f3ca52876a15be7f7ac03a4561dedef70a2587", "filename": "libitm/configure.tgt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0258b6e46602fef03af8758a17ae64fcd2fc835e/libitm%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.tgt?ref=0258b6e46602fef03af8758a17ae64fcd2fc835e", "patch": "@@ -47,7 +47,10 @@ fi\n # work out any special compilation flags as necessary.\n case \"${target_cpu}\" in\n   alpha*)\t\tARCH=alpha ;;\n-  rs6000 | powerpc*)\tARCH=powerpc ;;\n+  rs6000 | powerpc*)\n+\tXCFLAGS=\"${XCFLAGS} -mhtm\"\n+\tARCH=powerpc\n+\t;;\n \n   arm*)\t\tARCH=arm ;;\n "}]}