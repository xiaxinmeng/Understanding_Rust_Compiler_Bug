{"sha": "ed431431e069b59a1cfdd877134873248d8c93a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ0MzE0MzFlMDY5YjU5YTFjZmRkODc3MTM0ODczMjQ4ZDhjOTNhNg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2020-11-23T23:28:58Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2020-11-23T23:28:58Z"}, "message": "c: Allow comparison of pointers to complete and incomplete types for C11 [PR95630]\n\nAs noted in bug 95630, C11 removed a restriction in C99 on comparing\npointers to compatible complete and incomplete types (this was one of\nthe changes in N1439, which was largely a terminological change to\nmake incomplete types a subset of object types rather than a different\nkind of type).  Implement that change by using pedwarn_c99 with\nOPT_Wpedantic for this diagnostic.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/c/\n2020-11-23  Joseph Myers  <joseph@codesourcery.com>\n\n\tPR c/95630\n\t* c-typeck.c (build_binary_op): Use pedwarn_c99 with OPT_Wpedantic\n\tfor comparisons of complete and incomplete pointers.\n\ngcc/testsuite/\n2020-11-23  Joseph Myers  <joseph@codesourcery.com>\n\n\tPR c/95630\n\t* gcc.dg/c11-compare-incomplete-1.c,\n\tgcc.dg/c11-compare-incomplete-2.c,\n\tgcc.dg/c99-compare-incomplete-1.c,\n\tgcc.dg/c99-compare-incomplete-2.c: New tests.", "tree": {"sha": "c5e49f7264198cab2d44f1c950e37b9798542820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5e49f7264198cab2d44f1c950e37b9798542820"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed431431e069b59a1cfdd877134873248d8c93a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed431431e069b59a1cfdd877134873248d8c93a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed431431e069b59a1cfdd877134873248d8c93a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed431431e069b59a1cfdd877134873248d8c93a6/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38a33a2745cf9f5ce1d71162185fe39fa5f3701"}], "stats": {"total": 212, "additions": 210, "deletions": 2}, "files": [{"sha": "cdc491a25fd631460ac04129c377398730b6720d", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=ed431431e069b59a1cfdd877134873248d8c93a6", "patch": "@@ -12266,8 +12266,8 @@ build_binary_op (location_t location, enum tree_code code,\n \t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n \t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n-\t\tpedwarn (location, 0,\n-\t\t\t \"comparison of complete and incomplete pointers\");\n+\t\tpedwarn_c99 (location, OPT_Wpedantic,\n+\t\t\t     \"comparison of complete and incomplete pointers\");\n \t      else if (TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t\tpedwarn (location, OPT_Wpedantic, \"ISO C forbids \"\n \t\t\t \"ordered comparisons of pointers to functions\");"}, {"sha": "b1c05cf221e31c4249d30d6cf9c0e601cec3545e", "filename": "gcc/testsuite/gcc.dg/c11-compare-incomplete-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-compare-incomplete-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-compare-incomplete-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-compare-incomplete-1.c?ref=ed431431e069b59a1cfdd877134873248d8c93a6", "patch": "@@ -0,0 +1,52 @@\n+/* Test comparisons of pointers to complete and incomplete types are\n+   accepted in C11 mode.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+int\n+f (int (*p)[], int (*q)[3])\n+{\n+  return p < q;\n+}\n+\n+int\n+f2 (int (*p)[], int (*q)[3])\n+{\n+  return p <= q;\n+}\n+\n+int\n+f3 (int (*p)[], int (*q)[3])\n+{\n+  return p > q;\n+}\n+\n+int\n+f4 (int (*p)[], int (*q)[3])\n+{\n+  return p >= q;\n+}\n+\n+int\n+g (int (*p)[], int (*q)[3])\n+{\n+  return q < p;\n+}\n+\n+int\n+g2 (int (*p)[], int (*q)[3])\n+{\n+  return q <= p;\n+}\n+\n+int\n+g3 (int (*p)[], int (*q)[3])\n+{\n+  return q > p;\n+}\n+\n+int\n+g4 (int (*p)[], int (*q)[3])\n+{\n+  return q >= p;\n+}"}, {"sha": "8e809e87e9a0659f8be8413473f03cdc80888593", "filename": "gcc/testsuite/gcc.dg/c11-compare-incomplete-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-compare-incomplete-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-compare-incomplete-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-compare-incomplete-2.c?ref=ed431431e069b59a1cfdd877134873248d8c93a6", "patch": "@@ -0,0 +1,52 @@\n+/* Test comparisons of pointers to complete and incomplete types are\n+   diagnosed in C11 mode with -Wc99-c11-compat.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors -Wc99-c11-compat\" } */\n+\n+int\n+f (int (*p)[], int (*q)[3])\n+{\n+  return p < q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+f2 (int (*p)[], int (*q)[3])\n+{\n+  return p <= q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+f3 (int (*p)[], int (*q)[3])\n+{\n+  return p > q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+f4 (int (*p)[], int (*q)[3])\n+{\n+  return p >= q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g (int (*p)[], int (*q)[3])\n+{\n+  return q < p; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g2 (int (*p)[], int (*q)[3])\n+{\n+  return q <= p; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g3 (int (*p)[], int (*q)[3])\n+{\n+  return q > p; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g4 (int (*p)[], int (*q)[3])\n+{\n+  return q >= p; /* { dg-warning \"complete and incomplete\" } */\n+}"}, {"sha": "dfafc39145e454f7b79a7851cfa5de870248ab49", "filename": "gcc/testsuite/gcc.dg/c99-compare-incomplete-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-compare-incomplete-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-compare-incomplete-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-compare-incomplete-1.c?ref=ed431431e069b59a1cfdd877134873248d8c93a6", "patch": "@@ -0,0 +1,52 @@\n+/* Test comparisons of pointers to complete and incomplete types are\n+   diagnosed in C99 mode: -pedantic.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic\" } */\n+\n+int\n+f (int (*p)[], int (*q)[3])\n+{\n+  return p < q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+f2 (int (*p)[], int (*q)[3])\n+{\n+  return p <= q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+f3 (int (*p)[], int (*q)[3])\n+{\n+  return p > q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+f4 (int (*p)[], int (*q)[3])\n+{\n+  return p >= q; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g (int (*p)[], int (*q)[3])\n+{\n+  return q < p; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g2 (int (*p)[], int (*q)[3])\n+{\n+  return q <= p; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g3 (int (*p)[], int (*q)[3])\n+{\n+  return q > p; /* { dg-warning \"complete and incomplete\" } */\n+}\n+\n+int\n+g4 (int (*p)[], int (*q)[3])\n+{\n+  return q >= p; /* { dg-warning \"complete and incomplete\" } */\n+}"}, {"sha": "5ae7f303e079259715c60e42dbc2217b88432629", "filename": "gcc/testsuite/gcc.dg/c99-compare-incomplete-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-compare-incomplete-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed431431e069b59a1cfdd877134873248d8c93a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-compare-incomplete-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-compare-incomplete-2.c?ref=ed431431e069b59a1cfdd877134873248d8c93a6", "patch": "@@ -0,0 +1,52 @@\n+/* Test comparisons of pointers to complete and incomplete types are\n+   diagnosed in C99 mode: -pedantic-errors.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+int\n+f (int (*p)[], int (*q)[3])\n+{\n+  return p < q; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+f2 (int (*p)[], int (*q)[3])\n+{\n+  return p <= q; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+f3 (int (*p)[], int (*q)[3])\n+{\n+  return p > q; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+f4 (int (*p)[], int (*q)[3])\n+{\n+  return p >= q; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+g (int (*p)[], int (*q)[3])\n+{\n+  return q < p; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+g2 (int (*p)[], int (*q)[3])\n+{\n+  return q <= p; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+g3 (int (*p)[], int (*q)[3])\n+{\n+  return q > p; /* { dg-error \"complete and incomplete\" } */\n+}\n+\n+int\n+g4 (int (*p)[], int (*q)[3])\n+{\n+  return q >= p; /* { dg-error \"complete and incomplete\" } */\n+}"}]}