{"sha": "99fa8911490c35ac4ebf39dfdba2783f49e45fca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlmYTg5MTE0OTBjMzVhYzRlYmYzOWRmZGJhMjc4M2Y0OWU0NWZjYQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@apple.com", "date": "2004-08-31T00:29:04Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-08-31T00:29:04Z"}, "message": "re PR rtl-optimization/13987 (compile time regression while compile fold-const.i)\n\n2004-08-30  Andrew Pinski  <apinski@apple.com>\n\n        PR rtl-opt/13987\n        * config.host (use_long_long_for_widest_fast_int): New, default is\n        off.\n        (ia64-*-hpux*): Enable use_long_long_for_widest_fast_int.\n        * configure.ac: If use_long_long_for_widest_fast_int, then\n        define USE_LONG_LONG_FOR_WIDEST_FAST_INT.\n        * configure: Regenerate.\n        * config.in: Regenerate.\n        * hwint.h (HOST_WIDEST_FAST_INT, HOST_BITS_PER_WIDEST_FAST_INT):\n        New: widest integer type supported efficiently in hardware for the\n        host.\n        * sbitmap.h (SBITMAP_ELT_BITS): Define based on\n        HOST_BITS_PER_WIDEST_FAST_INT.\n        (SBITMAP_ELT_TYPE): Define based on HOST_WIDEST_FAST_INT.\n        * hard-reg-set.h (HARD_REG_ELT_TYPE): Define based on\n        HOST_WIDEST_FAST_INT\n        instead of HOST_WIDE_INT.\n        (HARD_REG_SET_LONGS): Likewise.\n        (UHOST_BITS_PER_WIDE_INT): Likewise.\n        Change the checks for the fast cases to be based on\n        HOST_BITS_PER_WIDES_FAST_INT instead of HOST_BITS_PER_WIDE_INT.\n\nFrom-SVN: r86816", "tree": {"sha": "a163328f7fe038e4d6f4871e51c5cd9cf77f18b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a163328f7fe038e4d6f4871e51c5cd9cf77f18b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99fa8911490c35ac4ebf39dfdba2783f49e45fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fa8911490c35ac4ebf39dfdba2783f49e45fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99fa8911490c35ac4ebf39dfdba2783f49e45fca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fa8911490c35ac4ebf39dfdba2783f49e45fca/comments", "author": null, "committer": null, "parents": [{"sha": "389f67dcb325c96767cbb1b495946999e5379651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/389f67dcb325c96767cbb1b495946999e5379651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/389f67dcb325c96767cbb1b495946999e5379651"}], "stats": {"total": 104, "additions": 89, "deletions": 15}, "files": [{"sha": "e5c7ac0a3bd8e514f2ef1ce5de6db69e6249c962", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -1,3 +1,27 @@\n+2004-08-30  Andrew Pinski  <apinski@apple.com>\n+\n+\tPR rtl-opt/13987\n+\t* config.host (use_long_long_for_widest_fast_int): New, default is \n+\toff.\n+\t(ia64-*-hpux*): Enable use_long_long_for_widest_fast_int.\n+\t* configure.ac: If use_long_long_for_widest_fast_int, then\n+\tdefine USE_LONG_LONG_FOR_WIDEST_FAST_INT.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\t* hwint.h (HOST_WIDEST_FAST_INT, HOST_BITS_PER_WIDEST_FAST_INT):\n+\tNew: widest integer type supported efficiently in hardware for the\n+\thost.\n+\t* sbitmap.h (SBITMAP_ELT_BITS): Define based on\n+\tHOST_BITS_PER_WIDEST_FAST_INT.\n+\t(SBITMAP_ELT_TYPE): Define based on HOST_WIDEST_FAST_INT.\n+\t* hard-reg-set.h (HARD_REG_ELT_TYPE): Define based on \n+\tHOST_WIDEST_FAST_INT\n+\tinstead of HOST_WIDE_INT.\n+\t(HARD_REG_SET_LONGS): Likewise.\n+\t(UHOST_BITS_PER_WIDE_INT): Likewise.\n+\tChange the checks for the fast cases to be based on\n+\tHOST_BITS_PER_WIDES_FAST_INT instead of HOST_BITS_PER_WIDE_INT.\n+\n 2004-08-30  Steven Bosscher  <stevenb@suse.de>\n \n \t* cfgcleanup.c (merge_memattrs): Look at the value of MEM_SIZE,"}, {"sha": "fa7963062bf5fa49a07180e006aa21c80f98de01", "filename": "gcc/config.host", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -52,6 +52,10 @@\n #\n #  host_can_use_collect2 Set to yes normally; to no if the host cannot\n #\t\t\tlink or otherwise use collect2\n+#  use_long_long_for_widest_fast_int Set this to 'yes' if 'long long'\n+#\t\t\t(or '__int64') is wider than 'long' but still\n+#\t\t\tefficeiently supported by the host hardware.\n+#\t\t\tOnly affects compile speed.  Default is 'no'.\n \n # When setting any of these variables, check to see if a corresponding\n # variable is present in config.build; if so, you will likely want to \n@@ -66,6 +70,7 @@ host_extra_objs=\n host_extra_gcc_objs=\n out_host_hook_obj=host-default.o\n host_can_use_collect2=yes\n+use_long_long_for_widest_fast_int=no\n \n # Unsupported hosts list.  Generally, only include hosts known to fail here,\n # since we allow hosts not listed to be supported generically.\n@@ -172,4 +177,7 @@ case ${host} in\n     out_host_hook_obj=host-linux.o\n     host_xmake_file=x-linux\n     ;;\n+  ia64-*-hpux*)\n+    use_long_long_for_widest_fast_int=yes\n+    ;;\n esac"}, {"sha": "f169e6dfdb1ef827cfffe62296ace33fcfd4149f", "filename": "gcc/config.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -576,6 +576,10 @@\n /* Define if gcc should use -lunwind. */\n #undef USE_LIBUNWIND_EXCEPTIONS\n \n+/* Define to 1 if the 'long long' (or '__int64') is wider than 'long' but\n+   still efficiently supported by the host hardware. */\n+#undef USE_LONG_LONG_FOR_WIDEST_FAST_INT\n+\n /* Define if location_t is fileline integer cookie. */\n #undef USE_MAPPED_LOCATION\n "}, {"sha": "db6fc03cb544f4b1cce83ad238d5bd3a1ca7ad36", "filename": "gcc/configure", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -9281,6 +9281,14 @@ _ACEOF\n \n fi\n \n+if test x$use_long_long_for_widest_fast_int = xyes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define USE_LONG_LONG_FOR_WIDEST_FAST_INT 1\n+_ACEOF\n+\n+fi\n+\n count=a\n for f in $host_xm_file; do\n \tcount=${count}x"}, {"sha": "f1295d4f4d633ac959641d0a2c1b2e4052df064e", "filename": "gcc/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -1220,6 +1220,12 @@ if test x$need_64bit_hwint = xyes; then\n [Define to 1 if HOST_WIDE_INT must be 64 bits wide (see hwint.h).])\n fi\n \n+if test x$use_long_long_for_widest_fast_int = xyes; then\n+\tAC_DEFINE(USE_LONG_LONG_FOR_WIDEST_FAST_INT, 1,\n+[Define to 1 if the 'long long' (or '__int64') is wider than 'long' but still\n+efficiently supported by the host hardware.])\n+fi\n+\n count=a\n for f in $host_xm_file; do\n \tcount=${count}x"}, {"sha": "166a839a759ff166065ceddc16f2201077bf398e", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -33,22 +33,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Note that lots of code assumes that the first part of a regset is\n    the same format as a HARD_REG_SET.  To help make sure this is true,\n-   we only try the widest integer mode (HOST_WIDE_INT) instead of all the\n-   smaller types.  This approach loses only if there are a very few\n-   registers and then only in the few cases where we have an array of\n-   HARD_REG_SETs, so it needn't be as complex as it used to be.  */\n+   we only try the widest fast integer mode (HOST_WIDEST_FAST_INT)\n+   instead of all the smaller types.  This approach loses only if\n+   there are avery few registers and then only in the few cases where\n+   we have an array of HARD_REG_SETs, so it needn't be as complex as\n+   it used to be.  */\n \n-typedef unsigned HOST_WIDE_INT HARD_REG_ELT_TYPE;\n+typedef unsigned HOST_WIDEST_FAST_INT HARD_REG_ELT_TYPE;\n \n-#if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDE_INT\n+#if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDEST_FAST_INT\n \n #define HARD_REG_SET HARD_REG_ELT_TYPE\n \n #else\n \n #define HARD_REG_SET_LONGS \\\n- ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDE_INT - 1)\t\\\n-  / HOST_BITS_PER_WIDE_INT)\n+ ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDEST_FAST_INT - 1)\t\\\n+  / HOST_BITS_PER_WIDEST_FAST_INT)\n typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n \n #endif\n@@ -111,7 +112,7 @@ typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n \n #else\n \n-#define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDE_INT)\n+#define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n \n #define SET_HARD_REG_BIT(SET, BIT)\t\t\\\n   ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n@@ -125,7 +126,7 @@ typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n   (!!((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n       & (HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))))\n \n-#if FIRST_PSEUDO_REGISTER <= 2*HOST_BITS_PER_WIDE_INT\n+#if FIRST_PSEUDO_REGISTER <= 2*HOST_BITS_PER_WIDEST_FAST_INT\n #define CLEAR_HARD_REG_SET(TO)  \\\n do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = 0;\t\t\t\t\t\t\\\n@@ -179,7 +180,7 @@ do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n \tgoto TO; } while (0)\n \n #else\n-#if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDE_INT\n+#if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDES_FAST_INT\n #define CLEAR_HARD_REG_SET(TO)  \\\n do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = 0;\t\t\t\t\t\t\\\n@@ -243,7 +244,7 @@ do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n \tgoto TO; } while (0)\n \n #else\n-#if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDE_INT\n+#if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDEST_FAST_INT\n #define CLEAR_HARD_REG_SET(TO)  \\\n do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = 0;\t\t\t\t\t\t\\\n@@ -316,7 +317,7 @@ do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n \t && (scan_xp_[3] == scan_yp_[3]))\t\t\t\\\n \tgoto TO; } while (0)\n \n-#else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDE_INT */\n+#else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDEST_FAST_INT */\n \n #define CLEAR_HARD_REG_SET(TO)  \\\n do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\"}, {"sha": "ccf624f6d054877e24c28e6f057c96467571d2d4", "filename": "gcc/hwint.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -116,4 +116,27 @@ extern char sizeof_long_long_must_be_8[sizeof(long long) == 8 ? 1 : -1];\n # define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     \"0x%llx%016llx\"\n #endif\n \n+/* Define HOST_WIDEST_FAST_INT to the widest integer type supported\n+   efficiently in hardware.  (That is, the widest integer type that fits\n+   in a hardware register.)  Normally this is \"long\" but on some hosts it\n+   should be \"long long\" or \"__int64\".  This is no convenient way to\n+   autodect this, so such systems must set a flag in config.host; see there\n+   for details.  */\n+\n+#ifdef USE_LONG_LONG_FOR_WIDEST_FAST_INT\n+#  ifdef HAVE_LONG_LONG\n+#    define HOST_WIDEST_FAST_INT long long\n+#    define HOST_BITS_PER_WIDEST_FAST_INT HOST_BITS_PER_LONGLONG\n+#  elif defined (HAVE___INT64)\n+#    define HOST_WIDEST_FAST_INT __int64\n+#    define HOST_BITS_PER_WIDEST_FAST_INT HOST_BITS_PER___INT64\n+#  else\n+#    error \"Your host said it wantted to use long long or __int64 but neither\"\n+#    error \"exist\"\n+#  endif\n+#else\n+#  define HOST_WIDEST_FAST_INT long\n+#  define HOST_BITS_PER_WIDEST_FAST_INT HOST_BITS_PER_LONG\n+#endif\n+\n #endif /* ! GCC_HWINT_H */"}, {"sha": "8584811cddb7a1d454b71124f85b323284e13902", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fa8911490c35ac4ebf39dfdba2783f49e45fca/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=99fa8911490c35ac4ebf39dfdba2783f49e45fca", "patch": "@@ -25,8 +25,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    It should be straightforward to convert so for now we keep things simple\n    while more important issues are dealt with.  */\n \n-#define SBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDE_INT)\n-#define SBITMAP_ELT_TYPE unsigned HOST_WIDE_INT\n+#define SBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n+#define SBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n \n typedef struct simple_bitmap_def\n {"}]}