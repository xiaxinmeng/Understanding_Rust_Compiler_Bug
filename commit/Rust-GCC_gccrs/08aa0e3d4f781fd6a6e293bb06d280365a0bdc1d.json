{"sha": "08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhYTBlM2Q0Zjc4MWZkNmE2ZTI5M2JiMDZkMjgwMzY1YTBiZGMxZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-10T08:54:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-10T10:25:19Z"}, "message": "tree-optimization/101809 - support emulated gather for double[int]\n\nThis adds emulated gather support for index vectors with more\nelements than the data vector.  The internal function gather\nvectorization code doesn't currently handle this (but the builtin\ndecl code does).  This allows vectorization of double data gather\nwith int indexes on 32bit platforms where there isn't an implicit\nwidening to 64bit present.\n\n2021-08-10  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101809\n\t* tree-vect-stmts.c (get_load_store_type): Allow emulated\n\tgathers with offset vector nunits being a constant multiple\n\tof the data vector nunits.\n\t(vect_get_gather_scatter_ops): Use the appropriate nunits\n\tfor the offset vector defs.\n\t(vectorizable_store): Adjust call to\n\tvect_get_gather_scatter_ops.\n\t(vectorizable_load): Likewise.  Handle the case of less\n\toffset vectors than data vectors.", "tree": {"sha": "9d0e2d205aa98850d8c33f85b869c212a2ce5d3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d0e2d205aa98850d8c33f85b869c212a2ce5d3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7665af0b1a964b1baae3a59b22fcc420369c63cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7665af0b1a964b1baae3a59b22fcc420369c63cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7665af0b1a964b1baae3a59b22fcc420369c63cf"}], "stats": {"total": 47, "additions": 30, "deletions": 17}, "files": [{"sha": "ab402b57fb4264ebd7dd2feb9f7ac754450e0e58", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=08aa0e3d4f781fd6a6e293bb06d280365a0bdc1d", "patch": "@@ -2377,9 +2377,11 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t      return false;\n \t    }\n \t  else if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant ()\n-\t\t   || !known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t TYPE_VECTOR_SUBPARTS\n-\t\t\t\t   (gs_info->offset_vectype)))\n+\t\t   || !TYPE_VECTOR_SUBPARTS\n+\t\t\t (gs_info->offset_vectype).is_constant ()\n+\t\t   || !constant_multiple_p (TYPE_VECTOR_SUBPARTS\n+\t\t\t\t\t      (gs_info->offset_vectype),\n+\t\t\t\t\t    TYPE_VECTOR_SUBPARTS (vectype)))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2928,11 +2930,10 @@ vect_build_gather_load_calls (vec_info *vinfo, stmt_vec_info stmt_info,\n    containing loop.  */\n \n static void\n-vect_get_gather_scatter_ops (vec_info *vinfo,\n+vect_get_gather_scatter_ops (loop_vec_info loop_vinfo,\n \t\t\t     class loop *loop, stmt_vec_info stmt_info,\n \t\t\t     gather_scatter_info *gs_info,\n-\t\t\t     tree *dataref_ptr, vec<tree> *vec_offset,\n-\t\t\t     unsigned ncopies)\n+\t\t\t     tree *dataref_ptr, vec<tree> *vec_offset)\n {\n   gimple_seq stmts = NULL;\n   *dataref_ptr = force_gimple_operand (gs_info->base, &stmts, true, NULL_TREE);\n@@ -2943,8 +2944,10 @@ vect_get_gather_scatter_ops (vec_info *vinfo,\n       new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n       gcc_assert (!new_bb);\n     }\n-  vect_get_vec_defs_for_operand (vinfo, stmt_info, ncopies, gs_info->offset,\n-\t\t\t\t vec_offset, gs_info->offset_vectype);\n+  unsigned ncopies = vect_get_num_copies (loop_vinfo, gs_info->offset_vectype);\n+  vect_get_vec_defs_for_operand (loop_vinfo, stmt_info, ncopies,\n+\t\t\t\t gs_info->offset, vec_offset,\n+\t\t\t\t gs_info->offset_vectype);\n }\n \n /* Prepare to implement a grouped or strided load or store using\n@@ -8072,8 +8075,9 @@ vectorizable_store (vec_info *vinfo,\n \t    }\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n \t    {\n-\t      vect_get_gather_scatter_ops (vinfo, loop, stmt_info, &gs_info,\n-\t\t\t\t\t   &dataref_ptr, &vec_offsets, ncopies);\n+\t      vect_get_gather_scatter_ops (loop_vinfo, loop, stmt_info,\n+\t\t\t\t\t   &gs_info, &dataref_ptr,\n+\t\t\t\t\t   &vec_offsets);\n \t      vec_offset = vec_offsets[0];\n \t    }\n \t  else\n@@ -9376,9 +9380,9 @@ vectorizable_load (vec_info *vinfo,\n \t    }\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n \t    {\n-\t      vect_get_gather_scatter_ops (vinfo, loop, stmt_info, &gs_info,\n-\t\t\t\t\t   &dataref_ptr, &vec_offsets, ncopies);\n-\t      vec_offset = vec_offsets[0];\n+\t      vect_get_gather_scatter_ops (loop_vinfo, loop, stmt_info,\n+\t\t\t\t\t   &gs_info, &dataref_ptr,\n+\t\t\t\t\t   &vec_offsets);\n \t    }\n \t  else\n \t    dataref_ptr\n@@ -9395,9 +9399,7 @@ vectorizable_load (vec_info *vinfo,\n \t  if (dataref_offset)\n \t    dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset,\n \t\t\t\t\t      bump);\n-\t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-\t    vec_offset = vec_offsets[j];\n-\t  else\n+\t  else if (!STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n \t    dataref_ptr = bump_vector_ptr (vinfo, dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t   stmt_info, bump);\n \t  if (mask)\n@@ -9490,6 +9492,7 @@ vectorizable_load (vec_info *vinfo,\n \t\t    if (memory_access_type == VMAT_GATHER_SCATTER\n \t\t\t&& gs_info.ifn != IFN_LAST)\n \t\t      {\n+\t\t\tvec_offset = vec_offsets[j];\n \t\t\ttree zero = build_zero_cst (vectype);\n \t\t\ttree scale = size_int (gs_info.scale);\n \t\t\tgcall *call;\n@@ -9512,9 +9515,18 @@ vectorizable_load (vec_info *vinfo,\n \t\t\tgcc_assert (!final_mask);\n \t\t\tunsigned HOST_WIDE_INT const_nunits\n \t\t\t  = nunits.to_constant ();\n+\t\t\tunsigned HOST_WIDE_INT const_offset_nunits\n+\t\t\t  = TYPE_VECTOR_SUBPARTS (gs_info.offset_vectype)\n+\t\t\t      .to_constant ();\n \t\t\tvec<constructor_elt, va_gc> *ctor_elts;\n \t\t\tvec_alloc (ctor_elts, const_nunits);\n \t\t\tgimple_seq stmts = NULL;\n+\t\t\t/* We support offset vectors with more elements\n+\t\t\t   than the data vector for now.  */\n+\t\t\tunsigned HOST_WIDE_INT factor\n+\t\t\t  = const_offset_nunits / const_nunits;\n+\t\t\tvec_offset = vec_offsets[j / factor];\n+\t\t\tunsigned elt_offset = (j % factor) * const_nunits;\n \t\t\ttree idx_type = TREE_TYPE (TREE_TYPE (vec_offset));\n \t\t\ttree scale = size_int (gs_info.scale);\n \t\t\talign\n@@ -9525,7 +9537,8 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t  {\n \t\t\t    tree boff = size_binop (MULT_EXPR,\n \t\t\t\t\t\t    TYPE_SIZE (idx_type),\n-\t\t\t\t\t\t    bitsize_int (k));\n+\t\t\t\t\t\t    bitsize_int\n+\t\t\t\t\t\t      (k + elt_offset));\n \t\t\t    tree idx = gimple_build (&stmts, BIT_FIELD_REF,\n \t\t\t\t\t\t     idx_type, vec_offset,\n \t\t\t\t\t\t     TYPE_SIZE (idx_type),"}]}