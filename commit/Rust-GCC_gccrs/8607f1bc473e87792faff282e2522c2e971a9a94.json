{"sha": "8607f1bc473e87792faff282e2522c2e971a9a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwN2YxYmM0NzNlODc3OTJmYWZmMjgyZTI1MjJjMmU5NzFhOWE5NA==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2001-10-03T22:05:57Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-10-03T22:05:57Z"}, "message": "c-parse.in (objc_inherit_code, [...]): Make static.\n\n2001-10-03  Ziemowit Laski  <zlaski@apple.com>\n\n        * c-parse.in (objc_inherit_code, objc_pq_context,\n        objc_public_flag): Make static.\n        (objc_interface_context, objc_implementation_context,\n        objc_method_context, objc_ivar_chain, objc_ivar_context): Move to\n        global tree array in objc/objc-act.[ch].\n        (methoddef): Remove unnecessary code.\n\n        * objc/objc-act.c: (hashed_attribute, hashed_entry, imp_entry):\n        Hoist struct definitions to objc-act.h.\n        (nst_method_hash_list, cls_method_hash_list, imp_list, imp_count,\n        cat_count): Place declaration in objc-act.h.\n        (objc_tree_index): Move enumeration to objc-act.h.\n        (objc_global_trees): Place declaration and macro accessors in\n        objc-act.h.\n        (implementation_context): Remove duplicate; use\n        objc_implementation_context instead:\n        (method_context): Remove duplicate; use objc_method_context\n        instead.\n        (objc_ellipsis_node, objc_method_prototype_template,\n        implemented_classes, function_type): Move global vars to\n        objc_global_trees.\n        (init_objc): Use LAST_BASE_TREE_CODE instead of LAST_CODE.\n        (build_message_expr): Move actual construction of ObjC message\n        send nodes to finish_message_expr.\n        (finish_message_expr): New routine, contains code formerly in\n        build_message_expr.\n        * objc/objc-act.h (finish_message_expr): New prototype.\n        (objc_ivar_chain, objc_method_context, objc_ellipsis_node): Remove\n        declarations; these vars are now part of objc_global_trees.\n        (objc_tree_index, objc_global_trees): Move definitions from\n        objc-act.c.\n        * objc/objc-tree.def: Update copyright info.\n\nFrom-SVN: r46000", "tree": {"sha": "a9086dda614a021f61ce4b8b7024b034cf3e5ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9086dda614a021f61ce4b8b7024b034cf3e5ecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8607f1bc473e87792faff282e2522c2e971a9a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8607f1bc473e87792faff282e2522c2e971a9a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8607f1bc473e87792faff282e2522c2e971a9a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8607f1bc473e87792faff282e2522c2e971a9a94/comments", "author": null, "committer": null, "parents": [{"sha": "8bf4eeece3076a35dbfe8d7385b4fef2488337d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf4eeece3076a35dbfe8d7385b4fef2488337d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf4eeece3076a35dbfe8d7385b4fef2488337d6"}], "stats": {"total": 879, "additions": 457, "deletions": 422}, "files": [{"sha": "3fab70a88d6a6ded5e5f9970389ee16d4ce6907b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8607f1bc473e87792faff282e2522c2e971a9a94", "patch": "@@ -1,3 +1,38 @@\n+2001-10-03  Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* c-parse.in (objc_inherit_code, objc_pq_context,\n+\tobjc_public_flag): Make static.\n+\t(objc_interface_context, objc_implementation_context,\n+\tobjc_method_context, objc_ivar_chain, objc_ivar_context): Move to\n+\tglobal tree array in objc/objc-act.[ch].\n+\t(methoddef): Remove unnecessary code.\n+\n+\t* objc/objc-act.c: (hashed_attribute, hashed_entry, imp_entry):\n+\tHoist struct definitions to objc-act.h.\n+\t(nst_method_hash_list, cls_method_hash_list, imp_list, imp_count,\n+\tcat_count): Place declaration in objc-act.h.\n+\t(objc_tree_index): Move enumeration to objc-act.h.\n+\t(objc_global_trees): Place declaration and macro accessors in\n+\tobjc-act.h.\n+\t(implementation_context): Remove duplicate; use\n+\tobjc_implementation_context instead:\n+\t(method_context): Remove duplicate; use objc_method_context\n+\tinstead.\n+\t(objc_ellipsis_node, objc_method_prototype_template,\n+\timplemented_classes, function_type): Move global vars to\n+\tobjc_global_trees.\n+\t(init_objc): Use LAST_BASE_TREE_CODE instead of LAST_CODE.\n+\t(build_message_expr): Move actual construction of ObjC message\n+\tsend nodes to finish_message_expr.\n+\t(finish_message_expr): New routine, contains code formerly in\n+\tbuild_message_expr.\n+\t* objc/objc-act.h (finish_message_expr): New prototype.\n+\t(objc_ivar_chain, objc_method_context, objc_ellipsis_node): Remove\n+\tdeclarations; these vars are now part of objc_global_trees.\n+\t(objc_tree_index, objc_global_trees): Move definitions from\n+\tobjc-act.c.\n+\t* objc/objc-tree.def: Update copyright info.\n+\n Wed Oct  3 12:22:11 EDT 2001  John Wehle  (john@feith.com)\n \n \t* dwarf2asm.c (unaligned_integer_asm_op): Abort if"}, {"sha": "28ac2b5a550f7bddad146cb3be033c9e5414efcf", "filename": "gcc/c-parse.in", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=8607f1bc473e87792faff282e2522c2e971a9a94", "patch": "@@ -281,23 +281,16 @@ static tree declspec_stack;\n   } while (0)\n \n ifobjc\n-/* Objective-C specific information */\n-\n-tree objc_interface_context;\n-tree objc_implementation_context;\n-tree objc_method_context;\n-tree objc_ivar_chain;\n-tree objc_ivar_context;\n-enum tree_code objc_inherit_code;\n-int objc_receiver_context;\n-int objc_public_flag;\n-int objc_pq_context;\n+/* Objective-C specific parser/lexer information */\n+\n+static enum tree_code objc_inherit_code;\n+static int objc_pq_context = 0, objc_public_flag = 0;\n \n /* The following flag is needed to contextualize ObjC lexical analysis.\n    In some cases (e.g., 'int NSObject;'), it is undesirable to bind \n    an identifier to an ObjC class, even if a class with that name \n    exists.  */\n-int objc_need_raw_identifier;\n+static int objc_need_raw_identifier;\n #define OBJC_NEED_RAW_IDENTIFIER(VAL)\tobjc_need_raw_identifier = VAL\n end ifobjc\n \n@@ -324,13 +317,6 @@ c_parse_init ()\n   ggc_add_tree_root (&current_declspecs, 1);\n   ggc_add_tree_root (&prefix_attributes, 1);\n   ggc_add_tree_root (&all_prefix_attributes, 1);\n-ifobjc\n-  ggc_add_tree_root (&objc_interface_context, 1);\n-  ggc_add_tree_root (&objc_implementation_context, 1);\n-  ggc_add_tree_root (&objc_method_context, 1);\n-  ggc_add_tree_root (&objc_ivar_chain, 1);\n-  ggc_add_tree_root (&objc_ivar_context, 1);\n-end ifobjc\n }\n \n %}\n@@ -2948,7 +2934,6 @@ methoddef:\n \t\t  else\n \t\t    add_instance_method (objc_implementation_context, $3);\n \t\t  start_method_def ($3);\n-\t\t  objc_method_context = $3;\n \t\t}\n \t  optarglist\n \t\t{\n@@ -2957,7 +2942,6 @@ methoddef:\n \t  compstmt_or_error\n \t\t{\n \t\t  finish_method_def ();\n-\t\t  objc_method_context = NULL_TREE;\n \t\t}\n \t;\n "}, {"sha": "c1e99d075ec1394daf2965ea7bc35053d066be4e", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 173, "deletions": 393, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8607f1bc473e87792faff282e2522c2e971a9a94", "patch": "@@ -148,9 +148,6 @@ char *util_firstobj;\n #define OBJC_ENCODE_INLINE_DEFS \t0\n #define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n \n-/* Needed to help fix missing @end situations.  */\n-extern tree objc_implementation_context;\n-\n /*** Private Interface (procedures) ***/\n \n /* Used by compile_file.  */\n@@ -209,22 +206,10 @@ static const char *objc_demangle\t\tPARAMS ((const char *));\n static const char *objc_printable_name\t\tPARAMS ((tree, int));\n static void objc_expand_function_end            PARAMS ((void));\n \n-/* Misc. bookkeeping */\n-\n-typedef struct hashed_entry \t*hash;\n-typedef struct hashed_attribute  *attr;\n+/* Hash tables to manage the global pool of method prototypes.  */\n \n-struct hashed_attribute\n-{\n-  attr next;\n-  tree value;\n-};\n-struct hashed_entry\n-{\n-  attr list;\n-  hash next;\n-  tree key;\n-};\n+hash *nst_method_hash_list = 0;\n+hash *cls_method_hash_list = 0;\n \n static void hash_init\t\t\t\tPARAMS ((void));\n static void hash_enter\t\t\t\tPARAMS ((hash *, tree));\n@@ -398,203 +383,17 @@ static const char *TAG_MSGSEND;\n static const char *TAG_MSGSENDSUPER;\n static const char *TAG_EXECCLASS;\n \n-/* Set by `continue_class' and checked by `is_public'.  */\n-\n-#define TREE_STATIC_TEMPLATE(record_type) (TREE_PUBLIC (record_type))\n-#define TYPED_OBJECT(type) \\\n-       (TREE_CODE (type) == RECORD_TYPE && TREE_STATIC_TEMPLATE (type))\n-\n-tree objc_ellipsis_node;\n-\n-enum objc_tree_index\n-{\n-    OCTI_STATIC_NST,\n-    OCTI_STATIC_NST_DECL,\n-    OCTI_SELF_ID,\n-    OCTI_UCMD_ID,\n-    OCTI_UNUSED_LIST,\n-    OCTI_SELF_DECL,\n-    OCTI_UMSG_DECL,\n-    OCTI_UMSG_SUPER_DECL,\n-    OCTI_GET_CLASS_DECL,\n-    OCTI_GET_MCLASS_DECL,\n-    OCTI_SUPER_TYPE,\n-    OCTI_SEL_TYPE,\n-    OCTI_ID_TYPE,\n-    OCTI_CLS_TYPE,\n-    OCTI_NST_TYPE,\n-    OCTI_PROTO_TYPE,\n-\n-    OCTI_CLS_CHAIN,\n-    OCTI_ALIAS_CHAIN,\n-    OCTI_INTF_CHAIN,\n-    OCTI_PROTO_CHAIN,\n-    OCTI_CLS_REF_CHAIN,\n-    OCTI_SEL_REF_CHAIN,\n-    OCTI_CLS_NAMES_CHAIN,\n-    OCTI_METH_VAR_NAMES_CHAIN,\n-    OCTI_METH_VAR_TYPES_CHAIN,\n-\n-    OCTI_SYMBOLS_DECL,\n-    OCTI_NST_VAR_DECL,\n-    OCTI_CLS_VAR_DECL,\n-    OCTI_NST_METH_DECL,\n-    OCTI_CLS_METH_DECL,\n-    OCTI_CLS_DECL,\n-    OCTI_MCLS_DECL,\n-    OCTI_SEL_TABLE_DECL,\n-    OCTI_MODULES_DECL,\n-    OCTI_STRG_DECL,\n-\n-    OCTI_IMPL_CTX,\n-    OCTI_IMPL_TEMPL,\n-\n-    OCTI_CLS_TEMPL,\n-    OCTI_CAT_TEMPL,\n-    OCTI_UPRIV_REC,\n-    OCTI_PROTO_TEMPL,\n-    OCTI_SEL_TEMPL,\n-    OCTI_UCLS_SUPER_REF,\n-    OCTI_UUCLS_SUPER_REF,\n-    OCTI_METH_TEMPL,\n-    OCTI_IVAR_TEMPL,\n-    OCTI_SYMTAB_TEMPL,\n-    OCTI_MODULE_TEMPL,\n-    OCTI_SUPER_TEMPL,\n-    OCTI_OBJ_REF,\n-    OCTI_OBJ_ID,\n-    OCTI_CLS_ID,\n-    OCTI_ID_ID,\n-    OCTI_CNST_STR_ID,\n-    OCTI_CNST_STR_TYPE,\n-    OCTI_CNST_STR_GLOB_ID,\n-    OCTI_STRING_CLASS_DECL,\n-    OCTI_SUPER_DECL,\n-    OCTI_METH_CTX,\n-\n-    OCTI_MAX\n-};\n-\n-static tree objc_global_trees[OCTI_MAX];\n-\n-/* List of classes with list of their static instances.  */\n-#define objc_static_instances\tobjc_global_trees[OCTI_STATIC_NST]\n-\n-/* The declaration of the array administrating the static instances.  */\n-#define static_instances_decl\tobjc_global_trees[OCTI_STATIC_NST_DECL]\n-\n-/* Some commonly used instances of \"identifier_node\".  */\n+/* The OCTI_... enumeration itself in in objc/objc-act.h.  */\n+tree objc_global_trees[OCTI_MAX];\n \n-#define self_id\t\t\tobjc_global_trees[OCTI_SELF_ID]\n-#define ucmd_id\t\t\tobjc_global_trees[OCTI_UCMD_ID]\n-#define unused_list\t\tobjc_global_trees[OCTI_UNUSED_LIST]\n-\n-#define self_decl\t\tobjc_global_trees[OCTI_SELF_DECL]\n-#define umsg_decl\t\tobjc_global_trees[OCTI_UMSG_DECL]\n-#define umsg_super_decl\t\tobjc_global_trees[OCTI_UMSG_SUPER_DECL]\n-#define objc_get_class_decl\tobjc_global_trees[OCTI_GET_CLASS_DECL]\n-#define objc_get_meta_class_decl\t\t\t\\\n-\t\t\t\tobjc_global_trees[OCTI_GET_MCLASS_DECL]\n-\n-#define super_type\t\tobjc_global_trees[OCTI_SUPER_TYPE]\n-#define selector_type\t\tobjc_global_trees[OCTI_SEL_TYPE]\n-#define id_type\t\t\tobjc_global_trees[OCTI_ID_TYPE]\n-#define objc_class_type\t\tobjc_global_trees[OCTI_CLS_TYPE]\n-#define instance_type\t\tobjc_global_trees[OCTI_NST_TYPE]\n-#define protocol_type\t\tobjc_global_trees[OCTI_PROTO_TYPE]\n-\n-/* Type checking macros.  */\n-\n-#define IS_ID(TYPE) \\\n-  (TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (id_type))\n-#define IS_PROTOCOL_QUALIFIED_ID(TYPE) \\\n-  (IS_ID (TYPE) && TYPE_PROTOCOL_LIST (TYPE))\n-#define IS_SUPER(TYPE) \\\n-  (super_type && TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (super_type))\n-\n-#define class_chain\t\tobjc_global_trees[OCTI_CLS_CHAIN]\n-#define alias_chain\t\tobjc_global_trees[OCTI_ALIAS_CHAIN]\n-#define interface_chain\t\tobjc_global_trees[OCTI_INTF_CHAIN]\n-#define protocol_chain\t\tobjc_global_trees[OCTI_PROTO_CHAIN]\n-\n-/* Chains to manage selectors that are referenced and defined in the\n-   module.  */\n-\n-#define cls_ref_chain\t\tobjc_global_trees[OCTI_CLS_REF_CHAIN]\t/* Classes referenced.  */\n-#define sel_ref_chain\t\tobjc_global_trees[OCTI_SEL_REF_CHAIN]\t/* Selectors referenced.  */\n-\n-/* Chains to manage uniquing of strings.  */\n-\n-#define class_names_chain\tobjc_global_trees[OCTI_CLS_NAMES_CHAIN]\n-#define meth_var_names_chain\tobjc_global_trees[OCTI_METH_VAR_NAMES_CHAIN]\n-#define meth_var_types_chain\tobjc_global_trees[OCTI_METH_VAR_TYPES_CHAIN]\n-\n-/* Hash tables to manage the global pool of method prototypes.  */\n-\n-static hash *nst_method_hash_list = 0;\n-static hash *cls_method_hash_list = 0;\n-\n-/* Backend data declarations.  */\n-\n-#define UOBJC_SYMBOLS_decl\t\tobjc_global_trees[OCTI_SYMBOLS_DECL]\n-#define UOBJC_INSTANCE_VARIABLES_decl\tobjc_global_trees[OCTI_NST_VAR_DECL]\n-#define UOBJC_CLASS_VARIABLES_decl\tobjc_global_trees[OCTI_CLS_VAR_DECL]\n-#define UOBJC_INSTANCE_METHODS_decl\tobjc_global_trees[OCTI_NST_METH_DECL]\n-#define UOBJC_CLASS_METHODS_decl\tobjc_global_trees[OCTI_CLS_METH_DECL]\n-#define UOBJC_CLASS_decl\t\tobjc_global_trees[OCTI_CLS_DECL]\n-#define UOBJC_METACLASS_decl\t\tobjc_global_trees[OCTI_MCLS_DECL]\n-#define UOBJC_SELECTOR_TABLE_decl\tobjc_global_trees[OCTI_SEL_TABLE_DECL]\n-#define UOBJC_MODULES_decl\t\tobjc_global_trees[OCTI_MODULES_DECL]\n-#define UOBJC_STRINGS_decl\t\tobjc_global_trees[OCTI_STRG_DECL]\n-\n-/* The following are used when compiling a class implementation.\n-   implementation_template will normally be an interface, however if\n-   none exists this will be equal to implementation_context...it is\n-   set in start_class.  */\n-\n-#define implementation_context\t\tobjc_global_trees[OCTI_IMPL_CTX]\n-#define implementation_template\t\tobjc_global_trees[OCTI_IMPL_TEMPL]\n-\n-struct imp_entry\n-{\n-  struct imp_entry *next;\n-  tree imp_context;\n-  tree imp_template;\n-  tree class_decl;\t\t/* _OBJC_CLASS_<my_name>; */\n-  tree meta_decl;\t\t/* _OBJC_METACLASS_<my_name>; */\n-};\n+int objc_receiver_context;\n \n static void handle_impent\t\t\tPARAMS ((struct imp_entry *));\n \n-static struct imp_entry *imp_list = 0;\n-static int imp_count = 0;\t/* `@implementation' */\n-static int cat_count = 0;\t/* `@category' */\n-\n-#define objc_class_template\tobjc_global_trees[OCTI_CLS_TEMPL]\n-#define objc_category_template\tobjc_global_trees[OCTI_CAT_TEMPL]\n-#define uprivate_record\t\tobjc_global_trees[OCTI_UPRIV_REC]\n-#define objc_protocol_template\tobjc_global_trees[OCTI_PROTO_TEMPL]\n-#define objc_selector_template\tobjc_global_trees[OCTI_SEL_TEMPL]\n-#define ucls_super_ref\t\tobjc_global_trees[OCTI_UCLS_SUPER_REF]\n-#define uucls_super_ref\t\tobjc_global_trees[OCTI_UUCLS_SUPER_REF]\n-\n-#define objc_method_template\tobjc_global_trees[OCTI_METH_TEMPL]\n-#define objc_ivar_template\tobjc_global_trees[OCTI_IVAR_TEMPL]\n-#define objc_symtab_template\tobjc_global_trees[OCTI_SYMTAB_TEMPL]\n-#define objc_module_template\tobjc_global_trees[OCTI_MODULE_TEMPL]\n-#define objc_super_template\tobjc_global_trees[OCTI_SUPER_TEMPL]\n-#define objc_object_reference\tobjc_global_trees[OCTI_OBJ_REF]\n-\n-#define objc_object_id\t\tobjc_global_trees[OCTI_OBJ_ID]\n-#define objc_class_id\t\tobjc_global_trees[OCTI_CLS_ID]\n-#define objc_id_id\t\tobjc_global_trees[OCTI_ID_ID]\n-#define constant_string_id\tobjc_global_trees[OCTI_CNST_STR_ID]\n-#define constant_string_type\tobjc_global_trees[OCTI_CNST_STR_TYPE]\n-#define constant_string_global_id  objc_global_trees[OCTI_CNST_STR_GLOB_ID]\n-#define string_class_decl\tobjc_global_trees[OCTI_STRING_CLASS_DECL]\n-#define UOBJC_SUPER_decl\tobjc_global_trees[OCTI_SUPER_DECL]\n-\n-#define method_context\t\tobjc_global_trees[OCTI_METH_CTX]\n+struct imp_entry *imp_list = 0;\n+int imp_count = 0;\t/* `@implementation' */\n+int cat_count = 0;\t/* `@category' */\n+\n static int  method_slot = 0;\t/* Used by start_method_def, */\n \n #define BUFSIZE\t\t1024\n@@ -1753,20 +1552,20 @@ static void\n forward_declare_categories ()\n {\n   struct imp_entry *impent;\n-  tree sav = implementation_context;\n+  tree sav = objc_implementation_context;\n \n   for (impent = imp_list; impent; impent = impent->next)\n     {\n       if (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)\n \t{\n \t  /* Set an invisible arg to synth_id_with_class_suffix.  */\n-\t  implementation_context = impent->imp_context;\n+\t  objc_implementation_context = impent->imp_context;\n \t  impent->class_decl\n \t    = create_builtin_decl (VAR_DECL, objc_category_template,\n-\t\t\t\t   IDENTIFIER_POINTER (synth_id_with_class_suffix (\"_OBJC_CATEGORY\", implementation_context)));\n+\t\t\t\t   IDENTIFIER_POINTER (synth_id_with_class_suffix (\"_OBJC_CATEGORY\", objc_implementation_context)));\n \t}\n     }\n-  implementation_context = sav;\n+  objc_implementation_context = sav;\n }\n \n /* Create the declaration of _OBJC_SYMBOLS, with type `strict _objc_symtab'\n@@ -3012,15 +2811,13 @@ static void\n generate_method_descriptors (protocol)\t/* generate_dispatch_tables */\n   tree protocol;\n {\n-  static tree objc_method_prototype_template;\n   tree initlist, chain, method_list_template;\n   tree cast, variable_length_type;\n   int size;\n \n   if (!objc_method_prototype_template)\n     {\n       objc_method_prototype_template = build_method_prototype_template ();\n-      ggc_add_tree_root (&objc_method_prototype_template, 1);\n     }\n \n   cast = build_tree_list (build_tree_list (NULL_TREE, xref_tag (RECORD_TYPE,\n@@ -3617,7 +3414,7 @@ synth_forward_declarations ()\n \n   /* extern struct objc_class _OBJC_CLASS_<my_name>; */\n \n-  an_id = synth_id_with_class_suffix (\"_OBJC_CLASS\", implementation_context);\n+  an_id = synth_id_with_class_suffix (\"_OBJC_CLASS\", objc_implementation_context);\n \n   sc_spec = build_tree_list (NULL_TREE, ridpointers[(int) RID_EXTERN]);\n   decl_specs = tree_cons (NULL_TREE, objc_class_template, sc_spec);\n@@ -3628,7 +3425,7 @@ synth_forward_declarations ()\n   /* extern struct objc_class _OBJC_METACLASS_<my_name>; */\n \n   an_id = synth_id_with_class_suffix (\"_OBJC_METACLASS\",\n-\t\t\t\t      implementation_context);\n+\t\t\t\t      objc_implementation_context);\n \n   UOBJC_METACLASS_decl = define_decl (an_id, decl_specs);\n   TREE_USED (UOBJC_METACLASS_decl) = 1;\n@@ -3957,7 +3754,7 @@ generate_ivars_list (type, name, size, list)\n   sc_spec = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n   decl_specs = tree_cons (NULL_TREE, type, sc_spec);\n \n-  decl = start_decl (synth_id_with_class_suffix (name, implementation_context),\n+  decl = start_decl (synth_id_with_class_suffix (name, objc_implementation_context),\n \t\t     decl_specs, 1, NULL_TREE);\n \n   initlist = build_tree_list (NULL_TREE, build_int_2 (size, 0));\n@@ -4122,7 +3919,7 @@ generate_dispatch_table (type, name, size, list)\n   sc_spec = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n   decl_specs = tree_cons (NULL_TREE, type, sc_spec);\n \n-  decl = start_decl (synth_id_with_class_suffix (name, implementation_context),\n+  decl = start_decl (synth_id_with_class_suffix (name, objc_implementation_context),\n \t\t     decl_specs, 1, NULL_TREE);\n \n   initlist = build_tree_list (NULL_TREE, build_int_2 (0, 0));\n@@ -4155,7 +3952,7 @@ generate_dispatch_tables ()\n \n   variable_length_type = groktypename (cast);\n \n-  chain = CLASS_CLS_METHODS (implementation_context);\n+  chain = CLASS_CLS_METHODS (objc_implementation_context);\n   if (chain)\n     {\n       size = list_length (chain);\n@@ -4167,7 +3964,7 @@ generate_dispatch_tables ()\n \n       UOBJC_CLASS_METHODS_decl\n \t= generate_dispatch_table (method_list_template,\n-\t\t\t\t   ((TREE_CODE (implementation_context)\n+\t\t\t\t   ((TREE_CODE (objc_implementation_context)\n \t\t\t\t     == CLASS_IMPLEMENTATION_TYPE)\n \t\t\t\t    ? \"_OBJC_CLASS_METHODS\"\n \t\t\t\t    : \"_OBJC_CATEGORY_CLASS_METHODS\"),\n@@ -4177,7 +3974,7 @@ generate_dispatch_tables ()\n   else\n     UOBJC_CLASS_METHODS_decl = 0;\n \n-  chain = CLASS_NST_METHODS (implementation_context);\n+  chain = CLASS_NST_METHODS (objc_implementation_context);\n   if (chain)\n     {\n       size = list_length (chain);\n@@ -4187,7 +3984,7 @@ generate_dispatch_tables ()\n       initlist\n \t= build_dispatch_table_initializer (objc_method_template, chain);\n \n-      if (TREE_CODE (implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n+      if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n \tUOBJC_INSTANCE_METHODS_decl\n \t  = generate_dispatch_table (method_list_template,\n \t\t\t\t     \"_OBJC_INSTANCE_METHODS\",\n@@ -4490,7 +4287,7 @@ generate_category (cat)\n   decl_specs = tree_cons (NULL_TREE, objc_category_template, sc_spec);\n \n   decl = start_decl (synth_id_with_class_suffix (\"_OBJC_CATEGORY\",\n-\t\t\t\t\t\t implementation_context),\n+\t\t\t\t\t\t objc_implementation_context),\n \t\t     decl_specs, 1, NULL_TREE);\n \n   initlist = build_category_initializer (TREE_TYPE (decl),\n@@ -4619,7 +4416,7 @@ synth_id_with_class_suffix (preamble, ctxt)\n       || TREE_CODE (ctxt) == CLASS_INTERFACE_TYPE)\n     {\n       const char *const class_name\n-\t= IDENTIFIER_POINTER (CLASS_NAME (implementation_context));\n+\t= IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));\n       string = (char *) alloca (strlen (preamble) + strlen (class_name) + 3);\n       sprintf (string, \"%s_%s\", preamble,\n \t       IDENTIFIER_POINTER (CLASS_NAME (ctxt)));\n@@ -4629,9 +4426,9 @@ synth_id_with_class_suffix (preamble, ctxt)\n     {\n       /* We have a category.  */\n       const char *const class_name\n-\t= IDENTIFIER_POINTER (CLASS_NAME (implementation_context));\n+\t= IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));\n       const char *const class_super_name\n-\t= IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context));\n+\t= IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context));\n       string = (char *) alloca (strlen (preamble)\n \t\t\t\t+ strlen (class_name)\n \t\t\t\t+ strlen (class_super_name)\n@@ -4819,8 +4616,8 @@ build_method_decl (code, ret_type, selector, add_args)\n #define METHOD_DEF 0\n #define METHOD_REF 1\n \n-/* Used by `build_message_expr' and `comp_method_types'.  Return an\n-   argument list for method METH.  CONTEXT is either METHOD_DEF or\n+/* Used by `build_objc_method_call' and `comp_method_types'.  Return\n+   an argument list for method METH.  CONTEXT is either METHOD_DEF or\n    METHOD_REF, saying whether we are trying to define a method or call\n    one.  SUPERFLAG says this is for a send to super; this makes a\n    difference for the NeXT calling sequence in which the lookup and\n@@ -4973,57 +4770,14 @@ build_message_expr (mess)\n      tree mess;\n {\n   tree receiver = TREE_PURPOSE (mess);\n-  tree selector, self_object;\n-  tree rtype, sel_name;\n+  tree sel_name;\n   tree args = TREE_VALUE (mess);\n   tree method_params = NULL_TREE;\n-  tree method_prototype = NULL_TREE;\n-  tree retval;\n-  int statically_typed = 0, statically_allocated = 0;\n-  tree class_ident = 0;\n-\n-  /* 1 if this is sending to the superclass.  */\n-  int super;\n \n   if (TREE_CODE (receiver) == ERROR_MARK)\n     return error_mark_node;\n \n-  /* Determine receiver type.  */\n-  rtype = TREE_TYPE (receiver);\n-  super = IS_SUPER (rtype);\n-\n-  if (! super)\n-    {\n-      if (TREE_STATIC_TEMPLATE (rtype))\n-\tstatically_allocated = 1;\n-      else if (TREE_CODE (rtype) == POINTER_TYPE\n-\t       && TREE_STATIC_TEMPLATE (TREE_TYPE (rtype)))\n-\tstatically_typed = 1;\n-      else if ((flag_next_runtime\n-\t\t|| (TREE_CODE (receiver) == CALL_EXPR && IS_ID (rtype)))\n-\t       && (class_ident = receiver_is_class_object (receiver)))\n-\t;\n-      else if (! IS_ID (rtype)\n-\t       /* Allow any type that matches objc_class_type.  */\n-\t       && ! comptypes (rtype, objc_class_type))\n-\t{\n-\t  warning (\"invalid receiver type `%s'\",\n-\t\t   gen_declaration (rtype, errbuf));\n-\t}\n-\n-      if (statically_allocated)\n-\treceiver = build_unary_op (ADDR_EXPR, receiver, 0);\n-\n-      /* Don't evaluate the receiver twice.  */\n-      receiver = save_expr (receiver);\n-      self_object = receiver;\n-    }\n-  else\n-    /* If sending to `super', use current self as the object.  */\n-    self_object = self_decl;\n-\n   /* Obtain the full selector name.  */\n-\n   if (TREE_CODE (args) == IDENTIFIER_NODE)\n     /* A unary selector.  */\n     sel_name = args;\n@@ -5033,8 +4787,6 @@ build_message_expr (mess)\n     abort ();\n \n   /* Build the parameter list to give to the method.  */\n-\n-  method_params = NULL_TREE;\n   if (TREE_CODE (args) == TREE_LIST)\n     {\n       tree chain = args, prev = NULL_TREE;\n@@ -5058,9 +4810,58 @@ build_message_expr (mess)\n       method_params = args;\n     }\n \n+  return finish_message_expr (receiver, sel_name, method_params);\n+}\n+\n+/* The 'finish_message_expr' routine is called from within\n+   'build_message_expr' for non-template functions.  In the case of\n+   C++ template functions, it is called from 'build_expr_from_tree'\n+   (in decl2.c) after RECEIVER and METHOD_PARAMS have been expanded.  */\n+   \n+tree\n+finish_message_expr (receiver, sel_name, method_params)\n+     tree receiver, sel_name, method_params; \n+{      \n+  tree method_prototype = NULL_TREE, class_ident = NULL_TREE;\n+  tree selector, self_object, retval;\n+  int statically_typed = 0, statically_allocated = 0;\n+  \n+  /* Determine receiver type. */\n+  tree rtype = TREE_TYPE (receiver);\n+  int super = IS_SUPER (rtype);\n+\n+  if (! super)\n+    {\n+      if (TREE_STATIC_TEMPLATE (rtype))\n+\tstatically_allocated = 1;\n+      else if (TREE_CODE (rtype) == POINTER_TYPE\n+\t       && TREE_STATIC_TEMPLATE (TREE_TYPE (rtype)))\n+\tstatically_typed = 1;\n+      else if ((flag_next_runtime\n+\t\t|| (TREE_CODE (receiver) == CALL_EXPR && IS_ID (rtype)))\n+\t       && (class_ident = receiver_is_class_object (receiver)))\n+\t;\n+      else if (! IS_ID (rtype)\n+\t       /* Allow any type that matches objc_class_type.  */\n+\t       && ! comptypes (rtype, objc_class_type))\n+\t{\n+\t  warning (\"invalid receiver type `%s'\",\n+\t\t   gen_declaration (rtype, errbuf));\n+\t}\n+      if (statically_allocated)\n+\treceiver = build_unary_op (ADDR_EXPR, receiver, 0);\n+\n+      /* Don't evaluate the receiver twice. */\n+      receiver = save_expr (receiver);\n+      self_object = receiver;\n+    }\n+  else\n+    /* If sending to `super', use current self as the object.  */\n+    self_object = self_decl;\n+\n   /* Determine operation return type.  */\n \n-  if (IS_SUPER (rtype))\n+  if (super)\n     {\n       tree iface;\n \n@@ -5069,7 +4870,7 @@ build_message_expr (mess)\n \t  iface\n \t    = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n \n-\t  if (TREE_CODE (method_context) == INSTANCE_METHOD_DECL)\n+\t  if (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL)\n \t    method_prototype = lookup_instance_method_static (iface, sel_name);\n \t  else\n \t    method_prototype = lookup_class_method_static (iface, sel_name);\n@@ -5111,8 +4912,8 @@ build_message_expr (mess)\n \n       /* `self' is now statically_typed.  All methods should be visible\n          within the context of the implementation.  */\n-      if (implementation_context\n-\t  && CLASS_NAME (implementation_context) == TYPE_NAME (ctype))\n+      if (objc_implementation_context\n+\t  && CLASS_NAME (objc_implementation_context) == TYPE_NAME (ctype))\n \t{\n \t  method_prototype\n \t    = lookup_instance_method_static (implementation_template,\n@@ -5124,11 +4925,11 @@ build_message_expr (mess)\n \t\t\t\t\t\tsel_name, 0);\n \n \t  if (! method_prototype\n-\t      && implementation_template != implementation_context)\n+\t      && implementation_template != objc_implementation_context)\n \t    /* The method is not published in the interface.  Check\n                locally.  */\n \t    method_prototype\n-\t      = lookup_method (CLASS_NST_METHODS (implementation_context),\n+\t      = lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n \t\t\t       sel_name);\n \t}\n       else\n@@ -5155,18 +4956,18 @@ build_message_expr (mess)\n     }\n   else if (class_ident)\n     {\n-      if (implementation_context\n-\t  && CLASS_NAME (implementation_context) == class_ident)\n+      if (objc_implementation_context\n+\t  && CLASS_NAME (objc_implementation_context) == class_ident)\n \t{\n \t  method_prototype\n \t    = lookup_class_method_static (implementation_template, sel_name);\n \n \t  if (!method_prototype\n-\t      && implementation_template != implementation_context)\n+\t      && implementation_template != objc_implementation_context)\n \t    /* The method is not published in the interface. Check\n                locally.  */\n \t    method_prototype\n-\t      = lookup_method (CLASS_CLS_METHODS (implementation_context),\n+\t      = lookup_method (CLASS_CLS_METHODS (objc_implementation_context),\n \t\t\t       sel_name);\n \t}\n       else\n@@ -5284,21 +5085,20 @@ build_objc_method_call (super_flag, method_prototype, lookup_object, object,\n \t     Clobber the data type of SENDER temporarily to accept\n \t     all the arguments for this operation, and to return\n \t     whatever this operation returns.  */\n-\t  tree arglist = NULL_TREE;\n-\t  tree retval;\n+\t  tree arglist = NULL_TREE, retval, savarg, savret;\n+\t  tree ret_type = groktypename (TREE_TYPE (method_prototype));\n \n \t  /* Save the proper contents of SENDER's data type.  */\n-\t  tree savarg = TYPE_ARG_TYPES (TREE_TYPE (sender));\n-\t  tree savret = TREE_TYPE (TREE_TYPE (sender));\n+\t  savarg = TYPE_ARG_TYPES (TREE_TYPE (sender));\n+\t  savret = TREE_TYPE (TREE_TYPE (sender));\n \n \t  /* Install this method's argument types.  */\n \t  arglist = get_arg_type_list (method_prototype, METHOD_REF,\n \t\t\t\t       super_flag);\n \t  TYPE_ARG_TYPES (TREE_TYPE (sender)) = arglist;\n \n \t  /* Install this method's return type.  */\n-\t  TREE_TYPE (TREE_TYPE (sender))\n-\t    = groktypename (TREE_TYPE (method_prototype));\n+\t  TREE_TYPE (TREE_TYPE (sender)) = ret_type;\n \n \t  /* Call SENDER with all the parameters.  This will do type\n \t     checking using the arg types for this method.  */\n@@ -5456,7 +5256,7 @@ tree\n build_ivar_reference (id)\n      tree id;\n {\n-  if (TREE_CODE (method_context) == CLASS_METHOD_DECL)\n+  if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)\n     {\n       /* Historically, a class method that produced objects (factory\n \t method) would assign `self' to the instance that it\n@@ -5474,12 +5274,7 @@ build_ivar_reference (id)\n \n   return build_component_ref (build_indirect_ref (self_decl, \"->\"), id);\n }\n-\f\n-#define HASH_ALLOC_LIST_SIZE\t170\n-#define ATTR_ALLOC_LIST_SIZE\t170\n-#define SIZEHASHTABLE \t\t257\n-\n-/* make positive */\n+\f/* Make the hash value positive.  */\n #define HASHFUNCTION(key)\t((size_t) key & 0x7fffffff)\n \n static void\n@@ -5921,12 +5716,12 @@ is_public (expr, identifier)\n \t      /* Important difference between the Stepstone translator:\n \t\t all instance variables should be public within the context\n \t\t of the implementation.  */\n-\t      if (implementation_context\n-\t\t  && (((TREE_CODE (implementation_context)\n+\t      if (objc_implementation_context\n+\t\t  && (((TREE_CODE (objc_implementation_context)\n \t\t\t== CLASS_IMPLEMENTATION_TYPE)\n-\t\t       || (TREE_CODE (implementation_context)\n+\t\t       || (TREE_CODE (objc_implementation_context)\n \t\t\t   == CATEGORY_IMPLEMENTATION_TYPE))\n-\t\t      && (CLASS_NAME (implementation_context)\n+\t\t      && (CLASS_NAME (objc_implementation_context)\n \t\t\t  == TYPE_NAME (basetype))))\n \t\treturn ! is_private (decl);\n \n@@ -5937,7 +5732,7 @@ is_public (expr, identifier)\n \t    }\n \t}\n \n-      else if (implementation_context && (basetype == objc_object_reference))\n+      else if (objc_implementation_context && (basetype == objc_object_reference))\n \t{\n \t  TREE_TYPE (expr) = uprivate_record;\n \t  warning (\"static access to object of type `id'\");\n@@ -5975,14 +5770,14 @@ check_methods (chain, list, mtype)\n \t{\n \t  if (first)\n \t    {\n-\t      if (TREE_CODE (implementation_context)\n+\t      if (TREE_CODE (objc_implementation_context)\n \t\t  == CLASS_IMPLEMENTATION_TYPE)\n \t\twarning (\"incomplete implementation of class `%s'\",\n-\t\t\t IDENTIFIER_POINTER (CLASS_NAME (implementation_context)));\n-\t      else if (TREE_CODE (implementation_context)\n+\t\t\t IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context)));\n+\t      else if (TREE_CODE (objc_implementation_context)\n \t\t       == CATEGORY_IMPLEMENTATION_TYPE)\n \t\twarning (\"incomplete implementation of category `%s'\",\n-\t\t\t IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n+\t\t\t IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));\n \t      first = 0;\n \t    }\n \n@@ -6068,16 +5863,16 @@ check_methods_accessible (chain, context, mtype)\n \t{\n \t  if (first)\n \t    {\n-\t      if (TREE_CODE (implementation_context)\n+\t      if (TREE_CODE (objc_implementation_context)\n \t\t  == CLASS_IMPLEMENTATION_TYPE)\n \t\twarning (\"incomplete implementation of class `%s'\",\n \t\t\t IDENTIFIER_POINTER\n-\t\t\t   (CLASS_NAME (implementation_context)));\n-\t      else if (TREE_CODE (implementation_context)\n+\t\t\t   (CLASS_NAME (objc_implementation_context)));\n+\t      else if (TREE_CODE (objc_implementation_context)\n \t\t       == CATEGORY_IMPLEMENTATION_TYPE)\n \t\twarning (\"incomplete implementation of category `%s'\",\n \t\t\t IDENTIFIER_POINTER\n-\t\t\t   (CLASS_SUPER_NAME (implementation_context)));\n+\t\t\t   (CLASS_SUPER_NAME (objc_implementation_context)));\n \t      first = 0;\n \t    }\n \t  warning (\"method definition for `%c%s' not found\",\n@@ -6090,7 +5885,7 @@ check_methods_accessible (chain, context, mtype)\n }\n \n /* Check whether the current interface (accessible via\n-   'implementation_context') actually implements protocol P, along\n+   'objc_implementation_context') actually implements protocol P, along\n    with any protocols that P inherits.  */\n    \n static void\n@@ -6107,19 +5902,19 @@ check_protocol (p, type, name)\n       if (flag_warn_protocol)\n \t{\n \t  f1 = check_methods (PROTOCOL_CLS_METHODS (p),\n-\t\t\t      CLASS_CLS_METHODS (implementation_context),\n+\t\t\t      CLASS_CLS_METHODS (objc_implementation_context),\n \t\t\t      '+');\n \t  f2 = check_methods (PROTOCOL_NST_METHODS (p),\n-\t\t\t      CLASS_NST_METHODS (implementation_context),\n+\t\t\t      CLASS_NST_METHODS (objc_implementation_context),\n \t\t\t      '-');\n \t}\n       else\n \t{\n \t  f1 = check_methods_accessible (PROTOCOL_CLS_METHODS (p),\n-\t\t\t\t\t implementation_context,\n+\t\t\t\t\t objc_implementation_context,\n \t\t\t\t\t '+');\n \t  f2 = check_methods_accessible (PROTOCOL_NST_METHODS (p),\n-\t\t\t\t\t implementation_context,\n+\t\t\t\t\t objc_implementation_context,\n \t\t\t\t\t '-');\n \t}\n \n@@ -6148,7 +5943,7 @@ check_protocol (p, type, name)\n }\n \t\n /* Check whether the current interface (accessible via\n-   'implementation_context') actually implements the protocols listed\n+   'objc_implementation_context') actually implements the protocols listed\n    in PROTO_LIST.  */\n    \n static void\n@@ -6204,11 +5999,8 @@ start_class (code, class_name, super_name, protocol_list)\n   if (code == CLASS_IMPLEMENTATION_TYPE)\n     {\n       {\n-        static tree implemented_classes = 0;\n         tree chain;\n \n-\tif (!implemented_classes)\n-\t  ggc_add_tree_root (&implemented_classes, 1);\n         for (chain = implemented_classes; chain; chain = TREE_CHAIN (chain))\n            if (TREE_VALUE (chain) == class_name)\n \t     {\n@@ -6234,15 +6026,15 @@ start_class (code, class_name, super_name, protocol_list)\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n \n-      implementation_context = class;\n+      objc_implementation_context = class;\n \n       /* Lookup the interface for this implementation.  */\n \n       if (!(implementation_template = lookup_interface (class_name)))\n         {\n \t  warning (\"Cannot find interface declaration for `%s'\",\n \t\t   IDENTIFIER_POINTER (class_name));\n-\t  add_class (implementation_template = implementation_context);\n+\t  add_class (implementation_template = objc_implementation_context);\n         }\n \n       /* If a super class has been specified in the implementation,\n@@ -6261,7 +6053,7 @@ start_class (code, class_name, super_name, protocol_list)\n \n       else if (! super_name)\n \t{\n-\t  CLASS_SUPER_NAME (implementation_context) \n+\t  CLASS_SUPER_NAME (objc_implementation_context) \n \t    = CLASS_SUPER_NAME (implementation_template);\n \t}\n     }\n@@ -6317,7 +6109,7 @@ start_class (code, class_name, super_name, protocol_list)\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n \n-      implementation_context = class;\n+      objc_implementation_context = class;\n \n       /* For a category, class_name is really the name of the class that\n \t the following set of methods will be associated with.  We must\n@@ -6405,18 +6197,18 @@ finish_class (class)\n     {\n       /* All code generation is done in finish_objc.  */\n \n-      if (implementation_template != implementation_context)\n+      if (implementation_template != objc_implementation_context)\n \t{\n \t  /* Ensure that all method listed in the interface contain bodies.  */\n \t  check_methods (CLASS_CLS_METHODS (implementation_template),\n-\t\t\t CLASS_CLS_METHODS (implementation_context), '+');\n+\t\t\t CLASS_CLS_METHODS (objc_implementation_context), '+');\n \t  check_methods (CLASS_NST_METHODS (implementation_template),\n-\t\t\t CLASS_NST_METHODS (implementation_context), '-');\n+\t\t\t CLASS_NST_METHODS (objc_implementation_context), '-');\n \n \t  if (CLASS_PROTOCOL_LIST (implementation_template))\n \t    check_protocols (CLASS_PROTOCOL_LIST (implementation_template),\n \t\t\t     \"class\",\n-\t\t\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)));\n+\t\t\t     IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context)));\n \t}\n     }\n \n@@ -6436,14 +6228,14 @@ finish_class (class)\n \t{\n \t  /* Ensure all method listed in the interface contain bodies.  */\n \t  check_methods (CLASS_CLS_METHODS (category),\n-\t\t\t CLASS_CLS_METHODS (implementation_context), '+');\n+\t\t\t CLASS_CLS_METHODS (objc_implementation_context), '+');\n \t  check_methods (CLASS_NST_METHODS (category),\n-\t\t\t CLASS_NST_METHODS (implementation_context), '-');\n+\t\t\t CLASS_NST_METHODS (objc_implementation_context), '-');\n \n \t  if (CLASS_PROTOCOL_LIST (category))\n \t    check_protocols (CLASS_PROTOCOL_LIST (category),\n \t\t\t     \"category\",\n-\t\t\t     IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n+\t\t\t     IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));\n \t}\n     }\n \n@@ -7042,15 +6834,15 @@ start_method_def (method)\n   tree decl_specs;\n \n   /* Required to implement _msgSuper.  */\n-  method_context = method;\n+  objc_method_context = method;\n   UOBJC_SUPER_decl = NULL_TREE;\n \n   /* Must be called BEFORE start_function.  */\n   pushlevel (0);\n \n   /* Generate prototype declarations for arguments...\"new-style\".  */\n \n-  if (TREE_CODE (method_context) == INSTANCE_METHOD_DECL)\n+  if (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL)\n     decl_specs = build_tree_list (NULL_TREE, uprivate_record);\n   else\n     /* Really a `struct objc_class *'. However, we allow people to\n@@ -7145,22 +6937,17 @@ static int\n comp_method_with_proto (method, proto)\n      tree method, proto;\n {\n-  static tree function_type = 0;\n-\n-  /* Create a function_type node once.  */\n-  if (!function_type)\n-    {\n-      function_type = make_node (FUNCTION_TYPE);\n-      ggc_add_tree_root (&function_type, 1);\n-    }\n+  /* Create a function template node at most once.  */\n+  if (!function1_template)\n+    function1_template = make_node (FUNCTION_TYPE);\n \n   /* Install argument types - normally set by build_function_type.  */\n-  TYPE_ARG_TYPES (function_type) = get_arg_type_list (proto, METHOD_DEF, 0);\n+  TYPE_ARG_TYPES (function1_template) = get_arg_type_list (proto, METHOD_DEF, 0);\n \n   /* install return type */\n-  TREE_TYPE (function_type) = groktypename (TREE_TYPE (proto));\n+  TREE_TYPE (function1_template) = groktypename (TREE_TYPE (proto));\n \n-  return comptypes (TREE_TYPE (METHOD_DEFINITION (method)), function_type);\n+  return comptypes (TREE_TYPE (METHOD_DEFINITION (method)), function1_template);\n }\n \n /* Return 1 if PROTO1 is consistent with PROTO2.  */\n@@ -7169,25 +6956,21 @@ static int\n comp_proto_with_proto (proto0, proto1)\n      tree proto0, proto1;\n {\n-  static tree function_type[2];\n-\n-  /* Create a couple function_type node's once.  */\n-  if (!function_type[0])\n-    {\n-      function_type[0] = make_node (FUNCTION_TYPE);\n-      function_type[1] = make_node (FUNCTION_TYPE);\n-      ggc_add_tree_root (function_type, 2);\n-    }\n+  /* Create a couple of function_template nodes at most once.  */\n+  if (!function1_template)\n+    function1_template = make_node (FUNCTION_TYPE);\n+  if (!function2_template)\n+    function2_template = make_node (FUNCTION_TYPE);\n \n   /* Install argument types; normally set by build_function_type.  */\n-  TYPE_ARG_TYPES (function_type[0]) = get_arg_type_list (proto0, METHOD_REF, 0);\n-  TYPE_ARG_TYPES (function_type[1]) = get_arg_type_list (proto1, METHOD_REF, 0);\n+  TYPE_ARG_TYPES (function1_template) = get_arg_type_list (proto0, METHOD_REF, 0);\n+  TYPE_ARG_TYPES (function2_template) = get_arg_type_list (proto1, METHOD_REF, 0);\n \n   /* Install return type.  */\n-  TREE_TYPE (function_type[0]) = groktypename (TREE_TYPE (proto0));\n-  TREE_TYPE (function_type[1]) = groktypename (TREE_TYPE (proto1));\n+  TREE_TYPE (function1_template) = groktypename (TREE_TYPE (proto0));\n+  TREE_TYPE (function2_template) = groktypename (TREE_TYPE (proto1));\n \n-  return comptypes (function_type[0], function_type[1]);\n+  return comptypes (function1_template, function2_template);\n }\n \n /* - Generate an identifier for the function. the format is \"_n_cls\",\n@@ -7211,11 +6994,11 @@ really_start_method (method, parmlist)\n   decl_specs = chainon (sc_spec, ret_spec);\n \n   sel_name = IDENTIFIER_POINTER (METHOD_SEL_NAME (method));\n-  class_name = IDENTIFIER_POINTER (CLASS_NAME (implementation_context));\n-  cat_name = ((TREE_CODE (implementation_context)\n+  class_name = IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));\n+  cat_name = ((TREE_CODE (objc_implementation_context)\n \t       == CLASS_IMPLEMENTATION_TYPE)\n \t      ? NULL\n-\t      : IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n+\t      : IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));\n   method_slot++;\n \n   /* Make sure this is big enough for any plausible method label.  */\n@@ -7261,7 +7044,7 @@ really_start_method (method, parmlist)\n \n   /* Check consistency...start_function, pushdecl, duplicate_decls.  */\n \n-  if (implementation_template != implementation_context)\n+  if (implementation_template != objc_implementation_context)\n     {\n       tree proto;\n \n@@ -7292,7 +7075,7 @@ continue_method_def ()\n {\n   tree parmlist;\n \n-  if (METHOD_ADD_ARGS (method_context) == objc_ellipsis_node)\n+  if (METHOD_ADD_ARGS (objc_method_context) == objc_ellipsis_node)\n     /* We have a `, ...' immediately following the selector.  */\n     parmlist = get_parm_info (0);\n   else\n@@ -7303,7 +7086,7 @@ continue_method_def ()\n   self_decl = TREE_PURPOSE (parmlist);\n \n   poplevel (0, 0, 0);\n-  really_start_method (method_context, parmlist);\n+  really_start_method (objc_method_context, parmlist);\n   store_parm_decls ();\n }\n \n@@ -7336,7 +7119,7 @@ add_objc_decls ()\n tree\n get_super_receiver ()\n {\n-  if (method_context)\n+  if (objc_method_context)\n     {\n       tree super_expr, super_expr_list;\n \n@@ -7349,13 +7132,13 @@ get_super_receiver ()\n       super_expr = build_component_ref (UOBJC_SUPER_decl,\n \t\t\t\t\tget_identifier (\"class\"));\n \n-      if (TREE_CODE (implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n+      if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n \t{\n \t  /* [_cls, __cls]Super are \"pre-built\" in\n \t     synth_forward_declarations.  */\n \n \t  super_expr = build_modify_expr (super_expr, NOP_EXPR,\n-\t\t\t\t\t  ((TREE_CODE (method_context)\n+\t\t\t\t\t  ((TREE_CODE (objc_method_context)\n \t\t\t\t\t    == INSTANCE_METHOD_DECL)\n \t\t\t\t\t   ? ucls_super_ref\n \t\t\t\t\t   : uucls_super_ref));\n@@ -7378,15 +7161,15 @@ get_super_receiver ()\n \t  if (flag_next_runtime)\n \t    {\n \t      super_class = get_class_reference (super_name);\n-\t      if (TREE_CODE (method_context) == CLASS_METHOD_DECL)\n+\t      if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)\n \t\tsuper_class\n \t\t  = build_component_ref (build_indirect_ref (super_class, \"->\"),\n \t\t\t\t\t get_identifier (\"isa\"));\n \t    }\n \t  else\n \t    {\n \t      add_class_reference (super_name);\n-\t      super_class = (TREE_CODE (method_context) == INSTANCE_METHOD_DECL\n+\t      super_class = (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL\n \t\t\t     ? objc_get_class_decl : objc_get_meta_class_decl);\n \t      assemble_external (super_class);\n \t      super_class\n@@ -7476,7 +7259,7 @@ encode_method_def (func_decl)\n static void\n objc_expand_function_end ()\n {\n-  METHOD_ENCODING (method_context) = encode_method_def (current_function_decl);\n+  METHOD_ENCODING (objc_method_context) = encode_method_def (current_function_decl);\n }\n \n void\n@@ -7488,18 +7271,18 @@ finish_method_def ()\n \n   /* Required to implement _msgSuper. This must be done AFTER finish_function,\n      since the optimizer may find \"may be used before set\" errors.  */\n-  method_context = NULL_TREE;\n+  objc_method_context = NULL_TREE;\n }\n \n #if 0\n int\n lang_report_error_function (decl)\n       tree decl;\n {\n-  if (method_context)\n+  if (objc_method_context)\n     {\n       fprintf (stderr, \"In method `%s'\\n\",\n-\t       IDENTIFIER_POINTER (METHOD_SEL_NAME (method_context)));\n+\t       IDENTIFIER_POINTER (METHOD_SEL_NAME (objc_method_context)));\n       return 1;\n     }\n \n@@ -8256,20 +8039,18 @@ init_objc ()\n {\n   /* Add the special tree codes of Objective C to the tables.  */\n \n-#define LAST_CODE LAST_C_TREE_CODE\n-\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n \n-  memcpy (tree_code_type + (int) LAST_CODE,\n+  memcpy (tree_code_type + (int) LAST_BASE_TREE_CODE,\n \t  objc_tree_code_type,\n-\t  (int) LAST_OBJC_TREE_CODE - (int) LAST_CODE);\n-  memcpy (tree_code_length + (int) LAST_CODE,\n+\t  (int) LAST_OBJC_TREE_CODE - (int) LAST_BASE_TREE_CODE);\n+  memcpy (tree_code_length + (int) LAST_BASE_TREE_CODE,\n \t  objc_tree_code_length,\n-\t  (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE) * sizeof (int)));\n-  memcpy (tree_code_name + (int) LAST_CODE,\n+\t  (((int) LAST_OBJC_TREE_CODE - (int) LAST_BASE_TREE_CODE) * sizeof (int)));\n+  memcpy (tree_code_name + (int) LAST_BASE_TREE_CODE,\n \t  objc_tree_code_name,\n-\t  (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE) * sizeof (char *)));\n+\t  (((int) LAST_OBJC_TREE_CODE - (int) LAST_BASE_TREE_CODE) * sizeof (char *)));\n \n   errbuf = (char *)xmalloc (BUFSIZE);\n   hash_init ();\n@@ -8298,7 +8079,7 @@ finish_objc ()\n   if (objc_implementation_context)\n     {\n       warning (\"`@end' missing in implementation context\");\n-      finish_class (implementation_context);\n+      finish_class (objc_implementation_context);\n       objc_ivar_chain = NULL_TREE;\n       objc_implementation_context = NULL_TREE;\n     }\n@@ -8314,19 +8095,19 @@ finish_objc ()\n   if (objc_static_instances)\n     generate_static_references ();\n \n-  if (implementation_context || class_names_chain\n+  if (objc_implementation_context || class_names_chain\n       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)\n     generate_objc_symtab_decl ();\n \n   for (impent = imp_list; impent; impent = impent->next)\n     {\n-      implementation_context = impent->imp_context;\n+      objc_implementation_context = impent->imp_context;\n       implementation_template = impent->imp_template;\n \n       UOBJC_CLASS_decl = impent->class_decl;\n       UOBJC_METACLASS_decl = impent->meta_decl;\n \n-      if (TREE_CODE (implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n+      if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n \t{\n \t  /* all of the following reference the string pool...  */\n \t  generate_ivar_lists ();\n@@ -8336,7 +8117,7 @@ finish_objc ()\n       else\n \t{\n \t  generate_dispatch_tables ();\n-\t  generate_category (implementation_context);\n+\t  generate_category (objc_implementation_context);\n \t}\n     }\n \n@@ -8348,7 +8129,7 @@ finish_objc ()\n   if (protocol_chain)\n     generate_protocols ();\n \n-  if (implementation_context || class_names_chain || objc_static_instances\n+  if (objc_implementation_context || class_names_chain || objc_static_instances\n       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)\n     {\n       /* Arrange for Objc data structures to be initialized at run time.  */\n@@ -8378,8 +8159,8 @@ finish_objc ()\n \n   if (flag_gen_declaration)\n     {\n-      add_class (implementation_context);\n-      dump_interface (gen_declaration_file, implementation_context);\n+      add_class (objc_implementation_context);\n+      dump_interface (gen_declaration_file, objc_implementation_context);\n     }\n \n   if (warn_selector)\n@@ -8501,7 +8282,7 @@ handle_impent (impent)\n {\n   char *string;\n \n-  implementation_context = impent->imp_context;\n+  objc_implementation_context = impent->imp_context;\n   implementation_template = impent->imp_template;\n \n   if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n@@ -8593,7 +8374,6 @@ ggc_mark_hash_table (arg)\n static void\n objc_act_parse_init ()\n {\n-  ggc_add_tree_root (&objc_ellipsis_node, 1);\n   ggc_add_tree_root (objc_global_trees, OCTI_MAX);\n   ggc_add_root (&imp_list, 1, sizeof imp_list, ggc_mark_imp_list);\n   ggc_add_root (&nst_method_hash_list, 1, sizeof nst_method_hash_list, ggc_mark_hash_table);"}, {"sha": "2825970a3dc0962bf3940d12c4a8452fb901cb98", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 241, "deletions": 6, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=8607f1bc473e87792faff282e2522c2e971a9a94", "patch": "@@ -46,17 +46,14 @@ tree get_class_reference\t\t\tPARAMS ((tree));\n tree get_static_reference\t\t\tPARAMS ((tree, tree));\n tree get_object_reference\t\t\tPARAMS ((tree));\n tree build_message_expr\t\t\t\tPARAMS ((tree));\n+tree finish_message_expr\t\t\tPARAMS ((tree, tree, tree));\n tree build_selector_expr\t\t\tPARAMS ((tree));\n tree build_ivar_reference\t\t\tPARAMS ((tree));\n tree build_keyword_decl\t\t\t\tPARAMS ((tree, tree, tree));\n tree build_method_decl\t\t\t\tPARAMS ((enum tree_code, tree, tree, tree));\n tree build_protocol_expr\t\t\tPARAMS ((tree));\n tree build_objc_string_object\t\t\tPARAMS ((tree));\n \n-extern tree objc_ivar_chain;\n-extern tree objc_method_context;\n-extern tree objc_ellipsis_node;\n-\n void objc_declare_alias\t\t\t\tPARAMS ((tree, tree));\n void objc_declare_class\t\t\t\tPARAMS ((tree));\n void objc_declare_protocols\t\t\tPARAMS ((tree));\n@@ -105,16 +102,254 @@ tree build_encode_expr\t\t\t\tPARAMS ((tree));\n #define PROTOCOL_DEFINED(CLASS) TREE_USED (CLASS)\n #define TYPE_PROTOCOL_LIST(TYPE) ((TYPE)->type.context)\n \n+/* Set by `continue_class' and checked by `is_public'.  */\n+\n+#define TREE_STATIC_TEMPLATE(record_type) (TREE_PUBLIC (record_type))\n+#define TYPED_OBJECT(type) \\\n+       (TREE_CODE (type) == RECORD_TYPE && TREE_STATIC_TEMPLATE (type))\n+\n /* Define the Objective-C or Objective-C++ language-specific tree codes.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n enum objc_tree_code {\n #ifdef OBJCPLUS\n-  dummy_tree_code = LAST_CPLUS_TREE_CODE,\n+  LAST_BASE_TREE_CODE = LAST_CPLUS_TREE_CODE,\n #else\n-  dummy_tree_code = LAST_C_TREE_CODE,\n+  LAST_BASE_TREE_CODE = LAST_C_TREE_CODE,\n #endif\n #include \"objc-tree.def\"\n   LAST_OBJC_TREE_CODE\n };\n #undef DEFTREECODE\n+\n+/* Hash tables to manage the global pool of method prototypes.  */\n+\n+typedef struct hashed_entry\t*hash;\n+typedef struct hashed_attribute\t*attr;\n+\n+struct hashed_attribute\n+{\n+  attr next;\n+  tree value;\n+};\n+struct hashed_entry\n+{\n+  attr list;\n+  hash next;\n+  tree key;\n+};\n+\n+extern hash *nst_method_hash_list;\n+extern hash *cls_method_hash_list;\n+\n+#define HASH_ALLOC_LIST_SIZE\t170\n+#define ATTR_ALLOC_LIST_SIZE\t170\n+#define SIZEHASHTABLE \t\t257\n+\n+/* Objective-C/Objective-C++ @implementation list.  */\n+\n+struct imp_entry\n+{\n+  struct imp_entry *next;\n+  tree imp_context;\n+  tree imp_template;\n+  tree class_decl;\t\t/* _OBJC_CLASS_<my_name>; */\n+  tree meta_decl;\t\t/* _OBJC_METACLASS_<my_name>; */\n+};\n+\n+extern struct imp_entry *imp_list;\n+extern int imp_count;\t/* `@implementation' */\n+extern int cat_count;\t/* `@category' */\n+\n+/* Objective-C/Objective-C++ global tree enumeration.  */\n+\n+enum objc_tree_index\n+{\n+    OCTI_STATIC_NST,\n+    OCTI_STATIC_NST_DECL,\n+    OCTI_SELF_ID,\n+    OCTI_UCMD_ID,\n+    OCTI_UNUSED_LIST,\n+    OCTI_ELLIPSIS_NODE,\n+\n+    OCTI_SELF_DECL,\n+    OCTI_UMSG_DECL,\n+    OCTI_UMSG_SUPER_DECL,\n+    OCTI_GET_CLASS_DECL,\n+    OCTI_GET_MCLASS_DECL,\n+    OCTI_SUPER_TYPE,\n+    OCTI_SEL_TYPE,\n+    OCTI_ID_TYPE,\n+    OCTI_CLS_TYPE,\n+    OCTI_NST_TYPE,\n+    OCTI_PROTO_TYPE,\n+\n+    OCTI_CLS_CHAIN,\n+    OCTI_ALIAS_CHAIN,\n+    OCTI_INTF_CHAIN,\n+    OCTI_PROTO_CHAIN,\n+    OCTI_IMPL_CHAIN,\n+    OCTI_CLS_REF_CHAIN,\n+    OCTI_SEL_REF_CHAIN,\n+    OCTI_IVAR_CHAIN,\n+    OCTI_CLS_NAMES_CHAIN,\n+    OCTI_METH_VAR_NAMES_CHAIN,\n+    OCTI_METH_VAR_TYPES_CHAIN,\n+\n+    OCTI_SYMBOLS_DECL,\n+    OCTI_NST_VAR_DECL,\n+    OCTI_CLS_VAR_DECL,\n+    OCTI_NST_METH_DECL,\n+    OCTI_CLS_METH_DECL,\n+    OCTI_CLS_DECL,\n+    OCTI_MCLS_DECL,\n+    OCTI_SEL_TABLE_DECL,\n+    OCTI_MODULES_DECL,\n+    OCTI_STRG_DECL,\n+\n+    OCTI_INTF_CTX,\n+    OCTI_IMPL_CTX,\n+    OCTI_METH_CTX,\n+    OCTI_IVAR_CTX,\n+\n+    OCTI_IMPL_TEMPL,\n+    OCTI_CLS_TEMPL,\n+    OCTI_CAT_TEMPL,\n+    OCTI_UPRIV_REC,\n+    OCTI_PROTO_TEMPL,\n+    OCTI_SEL_TEMPL,\n+    OCTI_UCLS_SUPER_REF,\n+    OCTI_UUCLS_SUPER_REF,\n+    OCTI_METH_TEMPL,\n+    OCTI_IVAR_TEMPL,\n+    OCTI_SYMTAB_TEMPL,\n+    OCTI_MODULE_TEMPL,\n+    OCTI_SUPER_TEMPL,\n+    OCTI_OBJ_REF,\n+    OCTI_METH_PROTO_TEMPL,\n+    OCTI_FUNCTION1_TEMPL,\n+    OCTI_FUNCTION2_TEMPL,\n+\n+    OCTI_OBJ_ID,\n+    OCTI_CLS_ID,\n+    OCTI_ID_ID,\n+    OCTI_CNST_STR_ID,\n+    OCTI_CNST_STR_TYPE,\n+    OCTI_CNST_STR_GLOB_ID,\n+    OCTI_STRING_CLASS_DECL,\n+    OCTI_SUPER_DECL,\n+    \n+    OCTI_MAX\n+};\n+\n+extern tree objc_global_trees[OCTI_MAX];\n+\n+/* List of classes with list of their static instances.  */\n+#define objc_static_instances\tobjc_global_trees[OCTI_STATIC_NST]\n+\n+/* The declaration of the array administrating the static instances.  */\n+#define static_instances_decl\tobjc_global_trees[OCTI_STATIC_NST_DECL]\n+\n+/* Some commonly used instances of \"identifier_node\".  */\n+\n+#define self_id\t\t\tobjc_global_trees[OCTI_SELF_ID]\n+#define ucmd_id\t\t\tobjc_global_trees[OCTI_UCMD_ID]\n+#define unused_list\t\tobjc_global_trees[OCTI_UNUSED_LIST]\n+#define objc_ellipsis_node\tobjc_global_trees[OCTI_ELLIPSIS_NODE]\n+\n+#define self_decl\t\tobjc_global_trees[OCTI_SELF_DECL]\n+#define umsg_decl\t\tobjc_global_trees[OCTI_UMSG_DECL]\n+#define umsg_super_decl\t\tobjc_global_trees[OCTI_UMSG_SUPER_DECL]\n+#define objc_get_class_decl\tobjc_global_trees[OCTI_GET_CLASS_DECL]\n+#define objc_get_meta_class_decl\t\t\t\\\n+\t\t\t\tobjc_global_trees[OCTI_GET_MCLASS_DECL]\n+\n+#define super_type\t\tobjc_global_trees[OCTI_SUPER_TYPE]\n+#define selector_type\t\tobjc_global_trees[OCTI_SEL_TYPE]\n+#define id_type\t\t\tobjc_global_trees[OCTI_ID_TYPE]\n+#define objc_class_type\t\tobjc_global_trees[OCTI_CLS_TYPE]\n+#define instance_type\t\tobjc_global_trees[OCTI_NST_TYPE]\n+#define protocol_type\t\tobjc_global_trees[OCTI_PROTO_TYPE]\n+\n+/* Type checking macros.  */\n+\n+#define IS_ID(TYPE) \\\n+  (TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (id_type))\n+#define IS_PROTOCOL_QUALIFIED_ID(TYPE) \\\n+  (IS_ID (TYPE) && TYPE_PROTOCOL_LIST (TYPE))\n+#define IS_SUPER(TYPE) \\\n+  (super_type && TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (super_type))\n+\n+#define class_chain\t\tobjc_global_trees[OCTI_CLS_CHAIN]\n+#define alias_chain\t\tobjc_global_trees[OCTI_ALIAS_CHAIN]\n+#define interface_chain\t\tobjc_global_trees[OCTI_INTF_CHAIN]\n+#define protocol_chain\t\tobjc_global_trees[OCTI_PROTO_CHAIN]\n+#define implemented_classes\tobjc_global_trees[OCTI_IMPL_CHAIN]\n+\n+/* Chains to manage selectors that are referenced and defined in the\n+   module.  */\n+\n+#define cls_ref_chain\t\tobjc_global_trees[OCTI_CLS_REF_CHAIN]\t/* Classes referenced.  */\n+#define sel_ref_chain\t\tobjc_global_trees[OCTI_SEL_REF_CHAIN]\t/* Selectors referenced.  */\n+#define objc_ivar_chain\t\tobjc_global_trees[OCTI_IVAR_CHAIN]\n+\n+/* Chains to manage uniquing of strings.  */\n+\n+#define class_names_chain\tobjc_global_trees[OCTI_CLS_NAMES_CHAIN]\n+#define meth_var_names_chain\tobjc_global_trees[OCTI_METH_VAR_NAMES_CHAIN]\n+#define meth_var_types_chain\tobjc_global_trees[OCTI_METH_VAR_TYPES_CHAIN]\n+\n+\n+/* Backend data declarations.  */\n+\n+#define UOBJC_SYMBOLS_decl\t\tobjc_global_trees[OCTI_SYMBOLS_DECL]\n+#define UOBJC_INSTANCE_VARIABLES_decl\tobjc_global_trees[OCTI_NST_VAR_DECL]\n+#define UOBJC_CLASS_VARIABLES_decl\tobjc_global_trees[OCTI_CLS_VAR_DECL]\n+#define UOBJC_INSTANCE_METHODS_decl\tobjc_global_trees[OCTI_NST_METH_DECL]\n+#define UOBJC_CLASS_METHODS_decl\tobjc_global_trees[OCTI_CLS_METH_DECL]\n+#define UOBJC_CLASS_decl\t\tobjc_global_trees[OCTI_CLS_DECL]\n+#define UOBJC_METACLASS_decl\t\tobjc_global_trees[OCTI_MCLS_DECL]\n+#define UOBJC_SELECTOR_TABLE_decl\tobjc_global_trees[OCTI_SEL_TABLE_DECL]\n+#define UOBJC_MODULES_decl\t\tobjc_global_trees[OCTI_MODULES_DECL]\n+#define UOBJC_STRINGS_decl\t\tobjc_global_trees[OCTI_STRG_DECL]\n+\n+/* The following are used when compiling a class implementation.\n+   implementation_template will normally be an interface, however if\n+   none exists this will be equal to objc_implementation_context...it is\n+   set in start_class.  */\n+\n+#define objc_interface_context\t\tobjc_global_trees[OCTI_INTF_CTX]\n+#define objc_implementation_context\tobjc_global_trees[OCTI_IMPL_CTX]\n+#define objc_method_context\t\tobjc_global_trees[OCTI_METH_CTX]\n+#define objc_ivar_context\t\tobjc_global_trees[OCTI_IVAR_CTX]\n+\n+#define implementation_template\tobjc_global_trees[OCTI_IMPL_TEMPL]\n+#define objc_class_template\tobjc_global_trees[OCTI_CLS_TEMPL]\n+#define objc_category_template\tobjc_global_trees[OCTI_CAT_TEMPL]\n+#define uprivate_record\t\tobjc_global_trees[OCTI_UPRIV_REC]\n+#define objc_protocol_template\tobjc_global_trees[OCTI_PROTO_TEMPL]\n+#define objc_selector_template\tobjc_global_trees[OCTI_SEL_TEMPL]\n+#define ucls_super_ref\t\tobjc_global_trees[OCTI_UCLS_SUPER_REF]\n+#define uucls_super_ref\t\tobjc_global_trees[OCTI_UUCLS_SUPER_REF]\n+\n+#define objc_method_template\tobjc_global_trees[OCTI_METH_TEMPL]\n+#define objc_ivar_template\tobjc_global_trees[OCTI_IVAR_TEMPL]\n+#define objc_symtab_template\tobjc_global_trees[OCTI_SYMTAB_TEMPL]\n+#define objc_module_template\tobjc_global_trees[OCTI_MODULE_TEMPL]\n+#define objc_super_template\tobjc_global_trees[OCTI_SUPER_TEMPL]\n+#define objc_object_reference\tobjc_global_trees[OCTI_OBJ_REF]\n+#define objc_method_prototype_template\t\t\\\n+\t\t\t\tobjc_global_trees[OCTI_METH_PROTO_TEMPL]\n+#define function1_template\tobjc_global_trees[OCTI_FUNCTION1_TEMPL]\n+#define function2_template\tobjc_global_trees[OCTI_FUNCTION2_TEMPL]\n+\t\t\t\t\n+#define objc_object_id\t\tobjc_global_trees[OCTI_OBJ_ID]\n+#define objc_class_id\t\tobjc_global_trees[OCTI_CLS_ID]\n+#define objc_id_id\t\tobjc_global_trees[OCTI_ID_ID]\n+#define constant_string_id\tobjc_global_trees[OCTI_CNST_STR_ID]\n+#define constant_string_type\tobjc_global_trees[OCTI_CNST_STR_TYPE]\n+#define constant_string_global_id\t\t\\\n+\t\t\t\tobjc_global_trees[OCTI_CNST_STR_GLOB_ID]\n+#define string_class_decl\tobjc_global_trees[OCTI_STRING_CLASS_DECL]\n+#define UOBJC_SUPER_decl\tobjc_global_trees[OCTI_SUPER_DECL]\n+"}, {"sha": "979556f0fa15a54e4bd6a19773d013e2958f6756", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8607f1bc473e87792faff282e2522c2e971a9a94/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=8607f1bc473e87792faff282e2522c2e971a9a94", "patch": "@@ -1,7 +1,8 @@\n /* This file contains the definitions and documentation for the\n    additional tree codes used in the Objective C front end (see tree.def\n    for the standard codes).\n-   Copyright (C) 1990, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1997, 1998, 1999, 2000, 2001 \n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -25,7 +26,7 @@ Boston, MA 02111-1307, USA.  */\n DEFTREECODE (CLASS_INTERFACE_TYPE, \"class_interface_type\", 't', 0)\n DEFTREECODE (CLASS_IMPLEMENTATION_TYPE, \"class_implementation_type\", 't', 0)\n DEFTREECODE (CATEGORY_INTERFACE_TYPE, \"category_interface_type\", 't', 0)\n-DEFTREECODE (CATEGORY_IMPLEMENTATION_TYPE,\"category_implementation_type\",'t',0)\n+DEFTREECODE (CATEGORY_IMPLEMENTATION_TYPE,\"category_implementation_type\", 't', 0)\n DEFTREECODE (PROTOCOL_INTERFACE_TYPE, \"protocol_interface_type\", 't', 0)\n \n /* Objective-C decls.  */"}]}