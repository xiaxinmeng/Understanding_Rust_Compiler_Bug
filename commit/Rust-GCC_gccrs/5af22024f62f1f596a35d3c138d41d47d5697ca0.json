{"sha": "5af22024f62f1f596a35d3c138d41d47d5697ca0", "node_id": "C_kwDOANBUbNoAKDVhZjIyMDI0ZjYyZjFmNTk2YTM1ZDNjMTM4ZDQxZDQ3ZDU2OTdjYTA", "commit": {"author": {"name": "Eugene Rozenfeld", "email": "erozen@microsoft.com", "date": "2022-04-26T21:28:16Z"}, "committer": {"name": "Eugene Rozenfeld", "email": "erozen@microsoft.com", "date": "2022-05-24T23:49:45Z"}, "message": "Fix profile count maintenance in vectorizer peeling.\n\nThis patch changes the code to save/restore profile counts for\nthe epliog loop (when not using scalar loop in the epilog)\ninstead of scaling them down and then back up, which may lead\nto problems if we scale down to 0.\n\nTested on x86_64-pc-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop-manip.cc (vect_do_peeling): Save/restore profile\n\tcounts for the epilog loop.", "tree": {"sha": "2b4c4c86a218027e940fd14a37318a0b0945c8bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4c4c86a218027e940fd14a37318a0b0945c8bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5af22024f62f1f596a35d3c138d41d47d5697ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af22024f62f1f596a35d3c138d41d47d5697ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af22024f62f1f596a35d3c138d41d47d5697ca0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af22024f62f1f596a35d3c138d41d47d5697ca0/comments", "author": {"login": "erozenfeld", "id": 10624223, "node_id": "MDQ6VXNlcjEwNjI0MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/10624223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erozenfeld", "html_url": "https://github.com/erozenfeld", "followers_url": "https://api.github.com/users/erozenfeld/followers", "following_url": "https://api.github.com/users/erozenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/erozenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/erozenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erozenfeld/subscriptions", "organizations_url": "https://api.github.com/users/erozenfeld/orgs", "repos_url": "https://api.github.com/users/erozenfeld/repos", "events_url": "https://api.github.com/users/erozenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/erozenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erozenfeld", "id": 10624223, "node_id": "MDQ6VXNlcjEwNjI0MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/10624223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erozenfeld", "html_url": "https://github.com/erozenfeld", "followers_url": "https://api.github.com/users/erozenfeld/followers", "following_url": "https://api.github.com/users/erozenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/erozenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/erozenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erozenfeld/subscriptions", "organizations_url": "https://api.github.com/users/erozenfeld/orgs", "repos_url": "https://api.github.com/users/erozenfeld/repos", "events_url": "https://api.github.com/users/erozenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/erozenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d1986aee47c592f903527bb68546efc557735d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1986aee47c592f903527bb68546efc557735d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d1986aee47c592f903527bb68546efc557735d"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "e81de45e07e23b184d9ffb301e6d4ee07a35d92c", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af22024f62f1f596a35d3c138d41d47d5697ca0/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af22024f62f1f596a35d3c138d41d47d5697ca0/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=5af22024f62f1f596a35d3c138d41d47d5697ca0", "patch": "@@ -2810,10 +2810,21 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     skip_epilog = false;\n \n+  class loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n+  auto_vec<profile_count> original_counts;\n+  basic_block *original_bbs = NULL;\n+\n   if (skip_vector)\n     {\n       split_edge (loop_preheader_edge (loop));\n \n+      if (epilog_peeling && (vect_epilogues || scalar_loop == NULL))\n+\t{\n+\t  original_bbs = get_loop_body (loop);\n+\t  for (unsigned int i = 0; i < loop->num_nodes; i++)\n+\t    original_counts.safe_push(original_bbs[i]->count);\n+\t}\n+\n       /* Due to the order in which we peel prolog and epilog, we first\n \t propagate probability to the whole loop.  The purpose is to\n \t avoid adjusting probabilities of both prolog and vector loops\n@@ -2828,7 +2839,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n     }\n \n   dump_user_location_t loop_loc = find_loop_location (loop);\n-  class loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n   if (vect_epilogues)\n     /* Make sure to set the epilogue's epilogue scalar loop, such that we can\n        use the original scalar loop as remaining epilogue if necessary.  */\n@@ -2985,16 +2995,19 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t     a merge point of control flow.  */\n \t  guard_to->count = guard_bb->count;\n \n-\t  /* Scale probability of epilog loop back.\n-\t     FIXME: We should avoid scaling down and back up.  Profile may\n-\t     get lost if we scale down to 0.  */\n-\t  basic_block *bbs = get_loop_body (epilog);\n-\t  for (unsigned int i = 0; i < epilog->num_nodes; i++)\n-\t    bbs[i]->count = bbs[i]->count.apply_scale\n-\t\t\t\t (bbs[i]->count,\n-\t\t\t\t  bbs[i]->count.apply_probability\n-\t\t\t\t    (prob_vector));\n-\t  free (bbs);\n+\t  /* Restore the counts of the epilog loop if we didn't use the scalar loop. */\n+\t  if (vect_epilogues || scalar_loop == NULL)\n+\t    {\n+\t      gcc_assert(epilog->num_nodes == loop->num_nodes);\n+\t      basic_block *bbs = get_loop_body (epilog);\n+\t      for (unsigned int i = 0; i < epilog->num_nodes; i++)\n+\t\t{\n+\t\t  gcc_assert(get_bb_original (bbs[i]) == original_bbs[i]);\n+\t\t  bbs[i]->count = original_counts[i];\n+\t\t}\n+\t      free (bbs);\n+\t      free (original_bbs);\n+\t    }\n \t}\n \n       basic_block bb_before_epilog = loop_preheader_edge (epilog)->src;"}]}