{"sha": "001cbba0efcd44aa1c955c5e6fbbb118aec55440", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAxY2JiYTBlZmNkNDRhYTFjOTU1YzVlNmZiYmIxMThhZWM1NTQ0MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-10-20T18:34:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-10-20T18:34:36Z"}, "message": "debug/dwarf: support 64-bit DWARF in byte order check\n    \n    Also fix 64-bit DWARF to read a 64-bit abbrev offset in the\n    compilation unit.\n    \n    This is a backport of https://golang.org/cl/71171, which will be in\n    the Go 1.10 release, to the gofrontend copy. Doing it now because AIX\n    is pretty much the only system that uses 64-bit DWARF.\n    \n    Reviewed-on: https://go-review.googlesource.com/72250\n\nFrom-SVN: r253955", "tree": {"sha": "bf968276f6a08a26ec3cea8784d0f5ba5c4f8420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf968276f6a08a26ec3cea8784d0f5ba5c4f8420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/001cbba0efcd44aa1c955c5e6fbbb118aec55440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/001cbba0efcd44aa1c955c5e6fbbb118aec55440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/001cbba0efcd44aa1c955c5e6fbbb118aec55440", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/001cbba0efcd44aa1c955c5e6fbbb118aec55440/comments", "author": null, "committer": null, "parents": [{"sha": "9401eb0730362688b0a1c603d1685fd3f783d170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9401eb0730362688b0a1c603d1685fd3f783d170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9401eb0730362688b0a1c603d1685fd3f783d170"}], "stats": {"total": 105, "additions": 88, "deletions": 17}, "files": [{"sha": "8b1846d07c4f3c372aad80cc455875372df8e807", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/001cbba0efcd44aa1c955c5e6fbbb118aec55440/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/001cbba0efcd44aa1c955c5e6fbbb118aec55440/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=001cbba0efcd44aa1c955c5e6fbbb118aec55440", "patch": "@@ -1,4 +1,4 @@\n-44132970e4b6c1186036bf8eda8982fb6e905d6f\n+a409ac2c78899e638a014c97891925bec93cb3ad\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ffa61c28d15b4f55f0cc3bfab9e514a1e54d946d", "filename": "libgo/go/debug/dwarf/entry.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go?ref=001cbba0efcd44aa1c955c5e6fbbb118aec55440", "patch": "@@ -33,13 +33,13 @@ type abbrevTable map[uint32]abbrev\n \n // ParseAbbrev returns the abbreviation table that starts at byte off\n // in the .debug_abbrev section.\n-func (d *Data) parseAbbrev(off uint32, vers int) (abbrevTable, error) {\n+func (d *Data) parseAbbrev(off uint64, vers int) (abbrevTable, error) {\n \tif m, ok := d.abbrevCache[off]; ok {\n \t\treturn m, nil\n \t}\n \n \tdata := d.abbrev\n-\tif off > uint32(len(data)) {\n+\tif off > uint64(len(data)) {\n \t\tdata = nil\n \t} else {\n \t\tdata = data[off:]"}, {"sha": "58f3023d296796860bc72f668a4390785ddaa487", "filename": "libgo/go/debug/dwarf/entry_test.go", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry_test.go?ref=001cbba0efcd44aa1c955c5e6fbbb118aec55440", "patch": "@@ -135,3 +135,63 @@ func TestReaderRanges(t *testing.T) {\n \t\tt.Errorf(\"saw only %d subprograms, expected %d\", i, len(subprograms))\n \t}\n }\n+\n+func Test64Bit(t *testing.T) {\n+\t// I don't know how to generate a 64-bit DWARF debug\n+\t// compilation unit except by using XCOFF, so this is\n+\t// hand-written.\n+\ttests := []struct {\n+\t\tname string\n+\t\tinfo []byte\n+\t}{\n+\t\t{\n+\t\t\t\"32-bit little\",\n+\t\t\t[]byte{0x30, 0, 0, 0, // comp unit length\n+\t\t\t\t4, 0, // DWARF version 4\n+\t\t\t\t0, 0, 0, 0, // abbrev offset\n+\t\t\t\t8, // address size\n+\t\t\t\t0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"64-bit little\",\n+\t\t\t[]byte{0xff, 0xff, 0xff, 0xff, // 64-bit DWARF\n+\t\t\t\t0x30, 0, 0, 0, 0, 0, 0, 0, // comp unit length\n+\t\t\t\t4, 0, // DWARF version 4\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0, // abbrev offset\n+\t\t\t\t8, // address size\n+\t\t\t\t0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"64-bit big\",\n+\t\t\t[]byte{0xff, 0xff, 0xff, 0xff, // 64-bit DWARF\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0x30, // comp unit length\n+\t\t\t\t0, 4, // DWARF version 4\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0, // abbrev offset\n+\t\t\t\t8, // address size\n+\t\t\t\t0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\t_, err := New(nil, nil, nil, test.info, nil, nil, nil, nil)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %v\", test.name, err)\n+\t\t}\n+\t}\n+}"}, {"sha": "938186998ff5c2af2a9e68d342d0314739eb3df1", "filename": "libgo/go/debug/dwarf/open.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go?ref=001cbba0efcd44aa1c955c5e6fbbb118aec55440", "patch": "@@ -23,7 +23,7 @@ type Data struct {\n \tstr      []byte\n \n \t// parsed data\n-\tabbrevCache map[uint32]abbrevTable\n+\tabbrevCache map[uint64]abbrevTable\n \torder       binary.ByteOrder\n \ttypeCache   map[Offset]Type\n \ttypeSigs    map[uint64]*typeUnit\n@@ -48,17 +48,26 @@ func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Dat\n \t\tpubnames:    pubnames,\n \t\tranges:      ranges,\n \t\tstr:         str,\n-\t\tabbrevCache: make(map[uint32]abbrevTable),\n+\t\tabbrevCache: make(map[uint64]abbrevTable),\n \t\ttypeCache:   make(map[Offset]Type),\n \t\ttypeSigs:    make(map[uint64]*typeUnit),\n \t}\n \n \t// Sniff .debug_info to figure out byte order.\n-\t// bytes 4:6 are the version, a tiny 16-bit number (1, 2, 3).\n+\t// 32-bit DWARF: 4 byte length, 2 byte version.\n+\t// 64-bit DWARf: 4 bytes of 0xff, 8 byte length, 2 byte version.\n \tif len(d.info) < 6 {\n \t\treturn nil, DecodeError{\"info\", Offset(len(d.info)), \"too short\"}\n \t}\n-\tx, y := d.info[4], d.info[5]\n+\toffset := 4\n+\tif d.info[0] == 0xff && d.info[1] == 0xff && d.info[2] == 0xff && d.info[3] == 0xff {\n+\t\tif len(d.info) < 14 {\n+\t\t\treturn nil, DecodeError{\"info\", Offset(len(d.info)), \"too short\"}\n+\t\t}\n+\t\toffset = 12\n+\t}\n+\t// Fetch the version, a tiny 16-bit number (1, 2, 3, 4, 5).\n+\tx, y := d.info[offset], d.info[offset+1]\n \tswitch {\n \tcase x == 0 && y == 0:\n \t\treturn nil, DecodeError{\"info\", 4, \"unsupported version 0\"}"}, {"sha": "76b357ce28b3646ebd9bb5b7c7d8e6c70631f058", "filename": "libgo/go/debug/dwarf/typeunit.go", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftypeunit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftypeunit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftypeunit.go?ref=001cbba0efcd44aa1c955c5e6fbbb118aec55440", "patch": "@@ -38,16 +38,11 @@ func (d *Data) parseTypes(name string, types []byte) error {\n \t\t\tb.error(\"unsupported DWARF version \" + strconv.Itoa(vers))\n \t\t\treturn b.err\n \t\t}\n-\t\tvar ao uint32\n+\t\tvar ao uint64\n \t\tif !dwarf64 {\n-\t\t\tao = b.uint32()\n+\t\t\tao = uint64(b.uint32())\n \t\t} else {\n-\t\t\tao64 := b.uint64()\n-\t\t\tif ao64 != uint64(uint32(ao64)) {\n-\t\t\t\tb.error(\"type unit abbrev offset overflow\")\n-\t\t\t\treturn b.err\n-\t\t\t}\n-\t\t\tao = uint32(ao64)\n+\t\t\tao = b.uint64()\n \t\t}\n \t\tatable, err := d.parseAbbrev(ao, vers)\n \t\tif err != nil {"}, {"sha": "98024ca1f8459fb1481a7a001528c3d09b65498a", "filename": "libgo/go/debug/dwarf/unit.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/001cbba0efcd44aa1c955c5e6fbbb118aec55440/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go?ref=001cbba0efcd44aa1c955c5e6fbbb118aec55440", "patch": "@@ -61,13 +61,20 @@ func (d *Data) parseUnits() ([]unit, error) {\n \t\tu.base = b.off\n \t\tvar n Offset\n \t\tn, u.is64 = b.unitLength()\n+\t\tdataOff := b.off\n \t\tvers := b.uint16()\n \t\tif vers != 2 && vers != 3 && vers != 4 {\n \t\t\tb.error(\"unsupported DWARF version \" + strconv.Itoa(int(vers)))\n \t\t\tbreak\n \t\t}\n \t\tu.vers = int(vers)\n-\t\tatable, err := d.parseAbbrev(b.uint32(), u.vers)\n+\t\tvar abbrevOff uint64\n+\t\tif u.is64 {\n+\t\t\tabbrevOff = b.uint64()\n+\t\t} else {\n+\t\t\tabbrevOff = uint64(b.uint32())\n+\t\t}\n+\t\tatable, err := d.parseAbbrev(abbrevOff, u.vers)\n \t\tif err != nil {\n \t\t\tif b.err == nil {\n \t\t\t\tb.err = err\n@@ -77,7 +84,7 @@ func (d *Data) parseUnits() ([]unit, error) {\n \t\tu.atable = atable\n \t\tu.asize = int(b.uint8())\n \t\tu.off = b.off\n-\t\tu.data = b.bytes(int(n - (2 + 4 + 1)))\n+\t\tu.data = b.bytes(int(n - (b.off - dataOff)))\n \t}\n \tif b.err != nil {\n \t\treturn nil, b.err"}]}