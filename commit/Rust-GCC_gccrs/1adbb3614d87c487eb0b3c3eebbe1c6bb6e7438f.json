{"sha": "1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkYmIzNjE0ZDg3YzQ4N2ViMGIzYzNlZWJiZTFjNmJiNmU3NDM4Zg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-04-13T15:56:21Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-04-13T15:56:21Z"}, "message": "re PR debug/48866 (gcc hangs when -g is set)\n\nPR debug/48866\n* df.h (enum debug_temp_where): New.\n(dead_debug_init, dead_debug_finish) Declare.\n(dead_debug_add, dead_debug_insert_temp): Declare.\n(struct dead_debug_use, struct dead_debug): Moved from...\n* df-problems.c: ... here.\n(df_set_unused_notes_for_mw): Bind debug uses of unused regno\nto a debug temp.\n(df_create_unused_note): Likewise.\n(df_set_dead_notes_for_mw): Move comment where it belongs.\n(dead_debug_init): Export.\n(dead_debug_reset_uses): New, factored out of...\n(dead_debug_finish): ...this.  Export.\n(dead_debug_reset): Remove.\n(dead_debug_add): Export.\n(dead_debug_insert_before): Rename to...\n(dead_debug_insert_temp): ... this.  Add where argument.  Export.\nLocate stored value for BEFORE_WITH_VALUE.  Avoid repeat inserts.\nReturn insertion count.\n(df_note_bb_compute): Adjust.\n* dce.c (word_dce_process_block): Adjust dead debug uses.\n(dce_process_block): Likewise.\n\nFrom-SVN: r186422", "tree": {"sha": "283216c0c3a9019c8feb931e55ba7d5c90f81f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/283216c0c3a9019c8feb931e55ba7d5c90f81f3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/comments", "author": null, "committer": null, "parents": [{"sha": "6ae1d471b16228d47bbcfbe3b2b90c323a0af1ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae1d471b16228d47bbcfbe3b2b90c323a0af1ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ae1d471b16228d47bbcfbe3b2b90c323a0af1ba"}], "stats": {"total": 404, "additions": 301, "deletions": 103}, "files": [{"sha": "c0df5218a2b8ecfd06802e98673faf6dbde49213", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "patch": "@@ -1,3 +1,28 @@\n+2012-04-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/48866\n+\t* df.h (enum debug_temp_where): New.\n+\t(dead_debug_init, dead_debug_finish) Declare.\n+\t(dead_debug_add, dead_debug_insert_temp): Declare.\n+\t(struct dead_debug_use, struct dead_debug): Moved from...\n+\t* df-problems.c: ... here.\n+\t(df_set_unused_notes_for_mw): Bind debug uses of unused regno\n+\tto a debug temp.\n+\t(df_create_unused_note): Likewise.\n+\t(df_set_dead_notes_for_mw): Move comment where it belongs.\n+\t(dead_debug_init): Export.\n+\t(dead_debug_reset_uses): New, factored out of...\n+\t(dead_debug_finish): ...this.  Export.\n+\t(dead_debug_reset): Remove.\n+\t(dead_debug_add): Export.\n+\t(dead_debug_insert_before): Rename to...\n+\t(dead_debug_insert_temp): ... this.  Add where argument.  Export.\n+\tLocate stored value for BEFORE_WITH_VALUE.  Avoid repeat inserts.\n+\tReturn insertion count.\n+\t(df_note_bb_compute): Adjust.\n+\t* dce.c (word_dce_process_block): Adjust dead debug uses.\n+\t(dce_process_block): Likewise.\n+\n 2012-04-13  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* df-problems.c (df_note_bb_compute): Do not take note of"}, {"sha": "c706296c663e052ad9aafd21e2ffe52b93fcae47", "filename": "gcc/dce.c", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "patch": "@@ -807,6 +807,7 @@ word_dce_process_block (basic_block bb, bool redo_out)\n   bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n   rtx insn;\n   bool block_changed;\n+  struct dead_debug debug;\n \n   if (redo_out)\n     {\n@@ -828,11 +829,24 @@ word_dce_process_block (basic_block bb, bool redo_out)\n     }\n \n   bitmap_copy (local_live, DF_WORD_LR_OUT (bb));\n+  dead_debug_init (&debug, NULL);\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n-    if (NONDEBUG_INSN_P (insn))\n+    if (DEBUG_INSN_P (insn))\n+      {\n+\tdf_ref *use_rec;\n+\tfor (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t  if (DF_REF_REGNO (*use_rec) >= FIRST_PSEUDO_REGISTER\n+\t      && (GET_MODE_SIZE (GET_MODE (DF_REF_REAL_REG (*use_rec)))\n+\t\t  == 2 * UNITS_PER_WORD)\n+\t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (*use_rec))\n+\t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (*use_rec) + 1))\n+\t    dead_debug_add (&debug, *use_rec, DF_REF_REGNO (*use_rec));\n+      }\n+    else if (INSN_P (insn))\n       {\n \tbool any_changed;\n+\n \t/* No matter if the instruction is needed or not, we remove\n \t   any regno in the defs from the live set.  */\n \tany_changed = df_word_lr_simulate_defs (insn, local_live);\n@@ -844,6 +858,15 @@ word_dce_process_block (basic_block bb, bool redo_out)\n \tif (marked_insn_p (insn))\n \t  df_word_lr_simulate_uses (insn, local_live);\n \n+\tif (debug.used && !bitmap_empty_p (debug.used))\n+\t  {\n+\t    df_ref *def_rec;\n+\n+\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t      dead_debug_insert_temp (&debug, DF_REF_REGNO (*def_rec), insn,\n+\t\t\t\t      DEBUG_TEMP_BEFORE_WITH_VALUE);\n+\t  }\n+\n \tif (dump_file)\n \t  {\n \t    fprintf (dump_file, \"finished processing insn %d live out = \",\n@@ -856,6 +879,7 @@ word_dce_process_block (basic_block bb, bool redo_out)\n   if (block_changed)\n     bitmap_copy (DF_WORD_LR_IN (bb), local_live);\n \n+  dead_debug_finish (&debug, NULL);\n   BITMAP_FREE (local_live);\n   return block_changed;\n }\n@@ -873,6 +897,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n   rtx insn;\n   bool block_changed;\n   df_ref *def_rec;\n+  struct dead_debug debug;\n \n   if (redo_out)\n     {\n@@ -896,22 +921,36 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n   bitmap_copy (local_live, DF_LR_OUT (bb));\n \n   df_simulate_initialize_backwards (bb, local_live);\n+  dead_debug_init (&debug, NULL);\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n-    if (INSN_P (insn))\n+    if (DEBUG_INSN_P (insn))\n+      {\n+\tdf_ref *use_rec;\n+\tfor (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t  if (!bitmap_bit_p (local_live, DF_REF_REGNO (*use_rec))\n+\t      && !bitmap_bit_p (au, DF_REF_REGNO (*use_rec)))\n+\t    dead_debug_add (&debug, *use_rec, DF_REF_REGNO (*use_rec));\n+      }\n+    else if (INSN_P (insn))\n       {\n \tbool needed = marked_insn_p (insn);\n \n \t/* The insn is needed if there is someone who uses the output.  */\n \tif (!needed)\n \t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (bitmap_bit_p (local_live, DF_REF_REGNO (*def_rec))\n-\t\t|| bitmap_bit_p (au, DF_REF_REGNO (*def_rec)))\n-\t      {\n-\t\tneeded = true;\n-\t\tmark_insn (insn, true);\n-\t\tbreak;\n-\t      }\n+\t    {\n+\t      dead_debug_insert_temp (&debug, DF_REF_REGNO (*def_rec), insn,\n+\t\t\t\t      DEBUG_TEMP_BEFORE_WITH_VALUE);\n+\n+\t      if (bitmap_bit_p (local_live, DF_REF_REGNO (*def_rec))\n+\t\t  || bitmap_bit_p (au, DF_REF_REGNO (*def_rec)))\n+\t\t{\n+\t\t  needed = true;\n+\t\t  mark_insn (insn, true);\n+\t\t  break;\n+\t\t}\n+\t    }\n \n \t/* No matter if the instruction is needed or not, we remove\n \t   any regno in the defs from the live set.  */\n@@ -923,6 +962,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t  df_simulate_uses (insn, local_live);\n       }\n \n+  dead_debug_finish (&debug, NULL);\n   df_simulate_finalize_backwards (bb, local_live);\n \n   block_changed = !bitmap_equal_p (local_live, DF_LR_IN (bb));"}, {"sha": "e04daceccabc2f3406a7e64b01b274d938110a79", "filename": "gcc/df-problems.c", "status": "modified", "additions": 185, "deletions": 94, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "patch": "@@ -2886,25 +2886,6 @@ df_whole_mw_reg_unused_p (struct df_mw_hardreg *mws,\n }\n \n \n-/* Node of a linked list of uses of dead REGs in debug insns.  */\n-struct dead_debug_use\n-{\n-  df_ref use;\n-  struct dead_debug_use *next;\n-};\n-\n-/* Linked list of the above, with a bitmap of the REGs in the\n-   list.  */\n-struct dead_debug\n-{\n-  struct dead_debug_use *head;\n-  bitmap used;\n-  bitmap to_rescan;\n-};\n-\n-static void dead_debug_reset (struct dead_debug *, unsigned int);\n-\n-\n /* Set the REG_UNUSED notes for the multiword hardreg defs in INSN\n    based on the bits in LIVE.  Do not generate notes for registers in\n    artificial uses.  DO_NOT_GEN is updated so that REG_DEAD notes are\n@@ -2930,7 +2911,7 @@ df_set_unused_notes_for_mw (rtx insn, struct df_mw_hardreg *mws,\n     {\n       unsigned int regno = mws->start_regno;\n       df_set_note (REG_UNUSED, insn, mws->mw_reg);\n-      dead_debug_reset (debug, regno);\n+      dead_debug_insert_temp (debug, regno, insn, DEBUG_TEMP_AFTER_WITH_REG);\n \n #ifdef REG_DEAD_DEBUGGING\n       df_print_note (\"adding 1: \", insn, REG_NOTES (insn));\n@@ -2945,7 +2926,7 @@ df_set_unused_notes_for_mw (rtx insn, struct df_mw_hardreg *mws,\n \t    && !bitmap_bit_p (artificial_uses, r))\n \t  {\n \t    df_set_note (REG_UNUSED, insn, regno_reg_rtx[r]);\n-\t    dead_debug_reset (debug, r);\n+\t    dead_debug_insert_temp (debug, r, insn, DEBUG_TEMP_AFTER_WITH_REG);\n #ifdef REG_DEAD_DEBUGGING\n \t    df_print_note (\"adding 2: \", insn, REG_NOTES (insn));\n #endif\n@@ -3013,12 +2994,12 @@ df_set_dead_notes_for_mw (rtx insn, struct df_mw_hardreg *mws,\n \n   if (df_whole_mw_reg_dead_p (mws, live, artificial_uses, do_not_gen))\n     {\n-      /* Add a dead note for the entire multi word register.  */\n       if (is_debug)\n \t{\n \t  *added_notes_p = true;\n \t  return;\n \t}\n+      /* Add a dead note for the entire multi word register.  */\n       df_set_note (REG_DEAD, insn, mws->mw_reg);\n #ifdef REG_DEAD_DEBUGGING\n       df_print_note (\"adding 1: \", insn, REG_NOTES (insn));\n@@ -3072,7 +3053,7 @@ df_create_unused_note (rtx insn, df_ref def,\n       rtx reg = (DF_REF_LOC (def))\n                 ? *DF_REF_REAL_LOC (def): DF_REF_REG (def);\n       df_set_note (REG_UNUSED, insn, reg);\n-      dead_debug_reset (debug, dregno);\n+      dead_debug_insert_temp (debug, dregno, insn, DEBUG_TEMP_AFTER_WITH_REG);\n #ifdef REG_DEAD_DEBUGGING\n       df_print_note (\"adding 3: \", insn, REG_NOTES (insn));\n #endif\n@@ -3083,7 +3064,7 @@ df_create_unused_note (rtx insn, df_ref def,\n \n \n /* Initialize DEBUG to an empty list, and clear USED, if given.  */\n-static inline void\n+void\n dead_debug_init (struct dead_debug *debug, bitmap used)\n {\n   debug->head = NULL;\n@@ -3093,32 +3074,83 @@ dead_debug_init (struct dead_debug *debug, bitmap used)\n     bitmap_clear (used);\n }\n \n-/* Reset all debug insns with pending uses.  Release the bitmap in it,\n-   unless it is USED.  USED must be the same bitmap passed to\n-   dead_debug_init.  */\n-static inline void\n-dead_debug_finish (struct dead_debug *debug, bitmap used)\n+/* Reset all debug uses in HEAD, and clear DEBUG->to_rescan bits of\n+   each reset insn.  DEBUG is not otherwise modified.  If HEAD is\n+   DEBUG->head, DEBUG->head will be set to NULL at the end.\n+   Otherwise, entries from DEBUG->head that pertain to reset insns\n+   will be removed, and only then rescanned.  */\n+\n+static void\n+dead_debug_reset_uses (struct dead_debug *debug, struct dead_debug_use *head)\n {\n-  struct dead_debug_use *head;\n-  rtx insn = NULL;\n+  bool got_head = (debug->head == head);\n+  bitmap rescan;\n+  struct dead_debug_use **tailp = &debug->head;\n+  struct dead_debug_use *cur;\n+  bitmap_iterator bi;\n+  unsigned int uid;\n \n-  if (debug->used != used)\n-    BITMAP_FREE (debug->used);\n+  if (got_head)\n+    rescan = NULL;\n+  else\n+    rescan = BITMAP_ALLOC (NULL);\n \n-  while ((head = debug->head))\n+  while (head)\n     {\n+      struct dead_debug_use *next = head->next;\n+      rtx insn;\n+\n       insn = DF_REF_INSN (head->use);\n-      if (!head->next || DF_REF_INSN (head->next->use) != insn)\n+      if (!next || DF_REF_INSN (next->use) != insn)\n \t{\n \t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n-\t  df_insn_rescan_debug_internal (insn);\n+\t  if (got_head)\n+\t    df_insn_rescan_debug_internal (insn);\n+\t  else\n+\t    bitmap_set_bit (rescan, INSN_UID (insn));\n \t  if (debug->to_rescan)\n \t    bitmap_clear_bit (debug->to_rescan, INSN_UID (insn));\n \t}\n-      debug->head = head->next;\n       XDELETE (head);\n+      head = next;\n+    }\n+\n+  if (got_head)\n+    {\n+      debug->head = NULL;\n+      return;\n+    }\n+\n+  while ((cur = *tailp))\n+    if (bitmap_bit_p (rescan, INSN_UID (DF_REF_INSN (cur->use))))\n+      {\n+\t*tailp = cur->next;\n+\tXDELETE (cur);\n+      }\n+    else\n+      tailp = &cur->next;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (rescan, 0, uid, bi)\n+    {\n+      struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n+      if (insn_info)\n+\tdf_insn_rescan_debug_internal (insn_info->insn);\n     }\n \n+  BITMAP_FREE (rescan);\n+}\n+\n+/* Reset all debug insns with pending uses.  Release the bitmap in it,\n+   unless it is USED.  USED must be the same bitmap passed to\n+   dead_debug_init.  */\n+void\n+dead_debug_finish (struct dead_debug *debug, bitmap used)\n+{\n+  if (debug->used != used)\n+    BITMAP_FREE (debug->used);\n+\n+  dead_debug_reset_uses (debug, debug->head);\n+\n   if (debug->to_rescan)\n     {\n       bitmap_iterator bi;\n@@ -3134,54 +3166,9 @@ dead_debug_finish (struct dead_debug *debug, bitmap used)\n     }\n }\n \n-/* Reset DEBUG_INSNs with pending uses of DREGNO.  */\n-static void\n-dead_debug_reset (struct dead_debug *debug, unsigned int dregno)\n-{\n-  struct dead_debug_use **tailp = &debug->head;\n-  struct dead_debug_use **insnp = &debug->head;\n-  struct dead_debug_use *cur;\n-  rtx insn;\n-\n-  if (!debug->used || !bitmap_clear_bit (debug->used, dregno))\n-    return;\n-\n-  while ((cur = *tailp))\n-    {\n-      if (DF_REF_REGNO (cur->use) == dregno)\n-\t{\n-\t  *tailp = cur->next;\n-\t  insn = DF_REF_INSN (cur->use);\n-\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n-\t  if (debug->to_rescan == NULL)\n-\t    debug->to_rescan = BITMAP_ALLOC (NULL);\n-\t  bitmap_set_bit (debug->to_rescan, INSN_UID (insn));\n-\t  XDELETE (cur);\n-\t  /* If the current use isn't the first one attached to INSN, go back\n-\t     to this first use.  We assume that the uses attached to an insn\n-\t     are adjacent.  */                                                                       \n-\t  if (tailp != insnp && DF_REF_INSN ((*insnp)->use) == insn)\n-\t    tailp = insnp;\n-\t  /* Then remove all the other uses attached to INSN.  */\n-\t  while ((cur = *tailp) && DF_REF_INSN (cur->use) == insn)\n-\t    {\n-\t      *tailp = cur->next;\n-\t      XDELETE (cur);\n-\t    }\n-\t  insnp = tailp;\n-\t}\n-      else\n-\t{\n-\t  if (DF_REF_INSN ((*insnp)->use) != DF_REF_INSN (cur->use))\n-\t    insnp = tailp;\n-\t  tailp = &(*tailp)->next;\n-\t}\n-    }\n-}\n-\n /* Add USE to DEBUG.  It must be a dead reference to UREGNO in a debug\n    insn.  Create a bitmap for DEBUG as needed.  */\n-static inline void\n+void\n dead_debug_add (struct dead_debug *debug, df_ref use, unsigned int uregno)\n {\n   struct dead_debug_use *newddu = XNEW (struct dead_debug_use);\n@@ -3197,23 +3184,27 @@ dead_debug_add (struct dead_debug *debug, df_ref use, unsigned int uregno)\n }\n \n /* If UREGNO is referenced by any entry in DEBUG, emit a debug insn\n-   before INSN that binds the REG to a debug temp, and replace all\n-   uses of UREGNO in DEBUG with uses of the debug temp.  INSN must be\n-   the insn where UREGNO dies.  */\n-static inline void\n-dead_debug_insert_before (struct dead_debug *debug, unsigned int uregno,\n-\t\t\t  rtx insn)\n+   before or after INSN (depending on WHERE), that binds a debug temp\n+   to the widest-mode use of UREGNO, if WHERE is *_WITH_REG, or the\n+   value stored in UREGNO by INSN otherwise, and replace all uses of\n+   UREGNO in DEBUG with uses of the debug temp.  INSN must be where\n+   UREGNO dies, if WHERE is *_BEFORE_*, or where it is set otherwise.\n+   Return the number of debug insns emitted.  */\n+int\n+dead_debug_insert_temp (struct dead_debug *debug, unsigned int uregno,\n+\t\t\trtx insn, enum debug_temp_where where)\n {\n   struct dead_debug_use **tailp = &debug->head;\n   struct dead_debug_use *cur;\n   struct dead_debug_use *uses = NULL;\n   struct dead_debug_use **usesp = &uses;\n   rtx reg = NULL;\n+  rtx breg;\n   rtx dval;\n   rtx bind;\n \n   if (!debug->used || !bitmap_clear_bit (debug->used, uregno))\n-    return;\n+    return 0;\n \n   /* Move all uses of uregno from debug->head to uses, setting mode to\n      the widest referenced mode.  */\n@@ -3237,17 +3228,114 @@ dead_debug_insert_before (struct dead_debug *debug, unsigned int uregno,\n   /* We may have dangling bits in debug->used for registers that were part\n      of a multi-register use, one component of which has been reset.  */\n   if (reg == NULL)\n-    return;\n+    {\n+      gcc_checking_assert (!uses);\n+      return 0;\n+    }\n+\n+  gcc_checking_assert (uses);\n+\n+  breg = reg;\n+  /* Recover the expression INSN stores in REG.  */\n+  if (where == DEBUG_TEMP_BEFORE_WITH_VALUE)\n+    {\n+      rtx set = single_set (insn);\n+      rtx dest, src;\n+\n+      if (set)\n+\t{\n+\t  dest = SET_DEST (set);\n+\t  src = SET_SRC (set);\n+\t  /* Lose if the REG-setting insn is a CALL.  */\n+\t  if (GET_CODE (src) == CALL)\n+\t    {\n+\t      while (uses)\n+\t\t{\n+\t\t  cur = uses->next;\n+\t\t  XDELETE (uses);\n+\t\t  uses = cur;\n+\t\t}\n+\t      return 0;\n+\t    }\n+\t}\n+\n+      /* ??? Should we try to extract it from a PARALLEL?  */\n+      if (!set)\n+\tbreg = NULL;\n+      /* Cool, it's the same REG, we can use SRC.  */\n+      else if (dest == reg)\n+\tbreg = copy_rtx (src);\n+      else if (REG_P (dest))\n+\t{\n+\t  /* Hmm...  Something's fishy, we should be setting REG here.  */\n+\t  if (REGNO (dest) != REGNO (reg))\n+\t    breg = NULL;\n+\t  /* Ok, it's the same (hardware) REG, but with a different\n+\t     mode, so SUBREG it.  */\n+\t  else\n+\t    breg = lowpart_subreg (GET_MODE (reg), copy_rtx (src),\n+\t\t\t\t   GET_MODE (dest));\n+\t}\n+      else if (GET_CODE (dest) == SUBREG)\n+\t{\n+\t  /* We should be setting REG here.  Lose.  */\n+\t  if (REGNO (SUBREG_REG (dest)) != REGNO (reg))\n+\t    breg = NULL;\n+\t  /* Lose if we're setting something other than the lowpart of\n+\t     REG.  */\n+\t  else if (!subreg_lowpart_p (dest))\n+\t    breg = NULL;\n+\t  /* If we're not overwriting all the hardware registers that\n+\t     setting REG in its mode would, we won't know what to bind\n+\t     the debug temp to.  */\n+\t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n+\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n+\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n+\t    breg = NULL;\n+\t  /* Yay, we can use SRC, just adjust its mode.  */\n+\t  else\n+\t    breg = lowpart_subreg (GET_MODE (reg), copy_rtx (src),\n+\t\t\t\t   GET_MODE (dest));\n+\t}\n+      /* Oh well, we're out of luck.  */\n+      else\n+\tbreg = NULL;\n+\n+      /* We couldn't figure out the value stored in REG, so reset all\n+\t of its pending debug uses.  */\n+      if (!breg)\n+\t{\n+\t  dead_debug_reset_uses (debug, uses);\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* If there's a single (debug) use of an otherwise unused REG, and\n+     the debug use is not part of a larger expression, then it\n+     probably doesn't make sense to introduce a new debug temp.  */\n+  if (where == DEBUG_TEMP_AFTER_WITH_REG && !uses->next)\n+    {\n+      rtx next = DF_REF_INSN (uses->use);\n+\n+      if (DEBUG_INSN_P (next) && reg == INSN_VAR_LOCATION_LOC (next))\n+\t{\n+\t  XDELETE (uses);\n+\t  return 0;\n+\t}\n+    }\n \n   /* Create DEBUG_EXPR (and DEBUG_EXPR_DECL).  */\n   dval = make_debug_expr_from_rtl (reg);\n \n   /* Emit a debug bind insn before the insn in which reg dies.  */\n   bind = gen_rtx_VAR_LOCATION (GET_MODE (reg),\n-\t\t\t       DEBUG_EXPR_TREE_DECL (dval), reg,\n+\t\t\t       DEBUG_EXPR_TREE_DECL (dval), breg,\n \t\t\t       VAR_INIT_STATUS_INITIALIZED);\n \n-  bind = emit_debug_insn_before (bind, insn);\n+  if (where == DEBUG_TEMP_AFTER_WITH_REG)\n+    bind = emit_debug_insn_after (bind, insn);\n+  else\n+    bind = emit_debug_insn_before (bind, insn);\n   df_insn_rescan (bind);\n \n   /* Adjust all uses.  */\n@@ -3265,6 +3353,8 @@ dead_debug_insert_before (struct dead_debug *debug, unsigned int uregno,\n       uses = cur->next;\n       XDELETE (cur);\n     }\n+\n+  return 1;\n }\n \n /* Recompute the REG_DEAD and REG_UNUSED notes and compute register\n@@ -3464,7 +3554,8 @@ df_note_bb_compute (unsigned int bb_index,\n \t\t  break;\n \t\t}\n \t      else\n-\t\tdead_debug_insert_before (&debug, uregno, insn);\n+\t\tdead_debug_insert_temp (&debug, uregno, insn,\n+\t\t\t\t\tDEBUG_TEMP_BEFORE_WITH_REG);\n \n \t      if ( (!(DF_REF_FLAGS (use)\n \t\t      & (DF_REF_MW_HARDREG | DF_REF_READ_WRITE)))"}, {"sha": "c0fabb9e2b7113bb96db8525a95c717f77b89984", "filename": "gcc/df.h", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=1adbb3614d87c487eb0b3c3eebbe1c6bb6e7438f", "patch": "@@ -1101,4 +1101,46 @@ extern void union_defs (df_ref, struct web_entry *,\n \t\t\tunsigned int *used, struct web_entry *,\n \t\t\tbool (*fun) (struct web_entry *, struct web_entry *));\n \n+/* Debug uses of dead regs.  */\n+\n+/* Node of a linked list of uses of dead REGs in debug insns.  */\n+struct dead_debug_use\n+{\n+  df_ref use;\n+  struct dead_debug_use *next;\n+};\n+\n+/* Linked list of the above, with a bitmap of the REGs in the\n+   list.  */\n+struct dead_debug\n+{\n+  struct dead_debug_use *head;\n+  bitmap used;\n+  bitmap to_rescan;\n+};\n+\n+/* This type controls the behavior of dead_debug_insert_temp WRT\n+   UREGNO and INSN.  */\n+enum debug_temp_where\n+  {\n+    /* Bind a newly-created debug temporary to a REG for UREGNO, and\n+       insert the debug insn before INSN.  REG is expected to die at\n+       INSN.  */\n+    DEBUG_TEMP_BEFORE_WITH_REG = -1,\n+    /* Bind a newly-created debug temporary to the value INSN stores\n+       in REG, and insert the debug insn before INSN.  */\n+    DEBUG_TEMP_BEFORE_WITH_VALUE = 0,\n+    /* Bind a newly-created debug temporary to a REG for UREGNO, and\n+       insert the debug insn after INSN.  REG is expected to be set at\n+       INSN.  */\n+    DEBUG_TEMP_AFTER_WITH_REG = 1\n+  };\n+\n+extern void dead_debug_init (struct dead_debug *, bitmap);\n+extern void dead_debug_finish (struct dead_debug *, bitmap);\n+extern void dead_debug_add (struct dead_debug *, df_ref, unsigned int);\n+extern int dead_debug_insert_temp (struct dead_debug *,\n+\t\t\t\t   unsigned int uregno, rtx insn,\n+\t\t\t\t   enum debug_temp_where);\n+\n #endif /* GCC_DF_H */"}]}