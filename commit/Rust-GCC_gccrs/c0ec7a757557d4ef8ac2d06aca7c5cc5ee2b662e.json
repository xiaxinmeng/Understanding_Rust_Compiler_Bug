{"sha": "c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlYzdhNzU3NTU3ZDRlZjhhYzJkMDZhY2E3YzVjYzVlZTJiNjYyZQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-11-03T23:25:02Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-11-03T23:25:02Z"}, "message": "[multiple changes]\n\nWed Nov  3 15:11:27 1999  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.md: Remove insn type fpsqrt, add fpsqrts\n\tand fpsqrtd.  Use them and create fdiv function unit to more\n\taccurately represent fpu sqrt pipeline semantics on UltraSparc.\n\t* config/sparc/sparc.c: Account for fpsqrt{s,d} changes.\n\nWed Nov  3 15:11:27 1999  Matteo Frigo <athena@fftw.org>\n\n\t* config/sparc/sparc.md: Adjust FADD/FMUL result latencies to\n\t3 on UltraSparc.\n\t* config/sparc/sparc.c (ultra_schedule_insn): Insert launched\n\tinsn into ready list, do not use just a raw swap.\n\nFrom-SVN: r30386", "tree": {"sha": "3e40dd9d781a071cf660051cb643d3df4ddca6d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e40dd9d781a071cf660051cb643d3df4ddca6d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/comments", "author": null, "committer": null, "parents": [{"sha": "aeeeda0391708755e09263bec674298280794f60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeeeda0391708755e09263bec674298280794f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeeeda0391708755e09263bec674298280794f60"}], "stats": {"total": 76, "additions": 52, "deletions": 24}, "files": [{"sha": "573144367aede85eaa5eeb4f83a5f88e894faa64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "patch": "@@ -1,3 +1,17 @@\n+Wed Nov  3 15:11:27 1999  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.md: Remove insn type fpsqrt, add fpsqrts\n+\tand fpsqrtd.  Use them and create fdiv function unit to more\n+\taccurately represent fpu sqrt pipeline semantics on UltraSparc.\n+\t* config/sparc/sparc.c: Account for fpsqrt{s,d} changes.\n+\n+Wed Nov  3 15:11:27 1999  Matteo Frigo <athena@fftw.org>\n+\n+\t* config/sparc/sparc.md: Adjust FADD/FMUL result latencies to\n+\t3 on UltraSparc.\n+\t* config/sparc/sparc.c (ultra_schedule_insn): Insert launched\n+\tinsn into ready list, do not use just a raw swap.\n+\n Wed Nov  3 14:51:59 1999  Mark P. Mitchell  <mark@codesourcery.com>\n \n \t* rtl.h (renumber_insns): New function."}, {"sha": "4592ceceddb181c637176d00c8042f578ef045bc", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "patch": "@@ -6475,7 +6475,8 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n     return 0;\n \n #define SLOW_FP(dep_type) \\\n-(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)\n+(dep_type == TYPE_FPSQRTS || dep_type == TYPE_FPSQRTD || \\\n+ dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)\n \n   switch (REG_NOTE_KIND (link))\n     {\n@@ -6701,7 +6702,8 @@ ultra_code_from_mask (type_mask)\n \t\t\tTMASK (TYPE_FPSTORE)))\n     return LSU;\n   else if (type_mask & (TMASK (TYPE_FPMUL) | TMASK (TYPE_FPDIVS) |\n-\t\t\tTMASK (TYPE_FPDIVD) | TMASK (TYPE_FPSQRT)))\n+\t\t\tTMASK (TYPE_FPDIVD) | TMASK (TYPE_FPSQRTS) |\n+\t\t\tTMASK (TYPE_FPSQRTD)))\n     return FPM;\n   else if (type_mask & (TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPCMOVE) |\n \t\t\tTMASK (TYPE_FP) | TMASK (TYPE_FPCMP)))\n@@ -6780,7 +6782,8 @@ ultra_fpmode_conflict_exists (fpmode)\n \t      && GET_CODE (SET_SRC (pat)) != NEG\n \t      && ((TMASK (get_attr_type (insn)) &\n \t\t   (TMASK (TYPE_FPDIVS) | TMASK (TYPE_FPDIVD) |\n-\t\t    TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPSQRT) |\n+\t\t    TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPSQRTS) |\n+\t\t    TMASK (TYPE_FPSQRTD) |\n                     TMASK (TYPE_LOAD) | TMASK (TYPE_STORE))) == 0))\n \t    return 1;\n \t}\n@@ -6938,6 +6941,7 @@ ultra_schedule_insn (ip, ready, this, type)\n {\n   int pipe_slot;\n   char mask = ultra_pipe.free_slot_mask;\n+  rtx temp;\n \n   /* Obtain free slot.  */\n   for (pipe_slot = 0; pipe_slot < 4; pipe_slot++)\n@@ -6959,13 +6963,13 @@ ultra_schedule_insn (ip, ready, this, type)\n   ultra_pipe.commit[pipe_slot] = 0;\n \n   /* Update ready list.  */\n-  if (ip != &ready[this])\n+  temp = *ip;\n+  while (ip != &ready[this])\n     {\n-      rtx temp = *ip;\n-\n-      *ip = ready[this];\n-      ready[this] = temp;\n+      ip[0] = ip[1];\n+      ++ip;\n     }\n+  *ip = temp;\n }\n \n /* Advance to the next pipeline group.  */\n@@ -7170,7 +7174,8 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n \t  }\n \telse if ((ip = ultra_find_type ((TMASK (TYPE_FPDIVS) |\n \t\t\t\t\t TMASK (TYPE_FPDIVD) |\n-\t\t\t\t\t TMASK (TYPE_FPSQRT)),\n+\t\t\t\t\t TMASK (TYPE_FPSQRTS) |\n+\t\t\t\t\t TMASK (TYPE_FPSQRTD)),\n \t\t\t\t\tready, this_insn)) != 0)\n \t  {\n \t    ultra_schedule_insn (ip, ready, this_insn, FPM);"}, {"sha": "c15dbbe30765ea7a6082b0cf187b6db4689be0c2", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c0ec7a757557d4ef8ac2d06aca7c5cc5ee2b662e", "patch": "@@ -98,7 +98,7 @@\n ;; type \"call_no_delay_slot\" is a call followed by an unimp instruction.\n \n (define_attr \"type\"\n-  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,return,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrt,cmove,multi,misc\"\n+  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,return,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrts,fpsqrtd,cmove,multi,misc\"\n   (const_string \"binary\"))\n \n ;; Set true if insn uses call-clobbered intermediate register.\n@@ -273,7 +273,7 @@\n \n (define_function_unit \"fp_mds\" 1 0\n   (and (eq_attr \"cpu\" \"cypress\")\n-    (eq_attr \"type\" \"fpsqrt\"))\n+    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n   63 63)\n \n ;; ----- The TMS390Z55 scheduling\n@@ -340,7 +340,7 @@\n \n (define_function_unit \"fp_mds\" 1 0\n   (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fpsqrt\"))\n+    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n   12 10)\n \n (define_function_unit \"fp_mds\" 1 0\n@@ -387,7 +387,7 @@\n \n (define_function_unit \"fp_mds\" 1 0\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"fpsqrt\"))\n+    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n   17 15)\n \n (define_function_unit \"fp_mds\" 1 0\n@@ -478,14 +478,18 @@\n ;; Timings; throughput/latency\n ;; FMOV     1/1    fmov, fabs, fneg\n ;; FMOVcc   1/2\n-;; FADD     1/4    add/sub, format conv, compar\n-;; FMUL     1/4\n+;; FADD     1/3    add/sub, format conv, compar\n+;; FMUL     1/3\n ;; FDIVs    12/12\n ;; FDIVd    22/22\n ;; FSQRTs   12/12\n ;; FSQRTd   22/22\n ;; FCMP takes 1 cycle to branch, 2 cycles to conditional move.\n ;;\n+;; FDIV{s,d}/FSQRT{s,d} are given their own unit since they only\n+;; use the FPM multiplier for final rounding 3 cycles before the\n+;; end of their latency and we have no real way to model that.\n+;;\n ;; ??? This is really bogus because the timings really depend upon\n ;; who uses the result.  We should record who the user is with\n ;; more descriptive 'type' attribute names and account for these\n@@ -504,7 +508,7 @@\n (define_function_unit \"fadd\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n     (eq_attr \"type\" \"fp\"))\n-  4 1)\n+  3 1)\n \n (define_function_unit \"fadd\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n@@ -514,27 +518,32 @@\n (define_function_unit \"fmul\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n     (eq_attr \"type\" \"fpmul\"))\n-  4 1)\n+  3 1)\n \n (define_function_unit \"fadd\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n     (eq_attr \"type\" \"fpcmove\"))\n   2 1)\n \n-(define_function_unit \"fmul\" 1 0\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n     (eq_attr \"type\" \"fpdivs\"))\n   12 12)\n \n-(define_function_unit \"fmul\" 1 0\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n     (eq_attr \"type\" \"fpdivd\"))\n   22 22)\n \n-(define_function_unit \"fmul\" 1 0\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"fpsqrt\"))\n+    (eq_attr \"type\" \"fpsqrts\"))\n   12 12)\n+\n+(define_function_unit \"fdiv\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpsqrtd\"))\n+  22 22)\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n@@ -6884,23 +6893,23 @@\n \t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fsqrtq\\\\t%1, %0\"\n-  [(set_attr \"type\" \"fpsqrt\")\n+  [(set_attr \"type\" \"fpsqrtd\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"e\")))]\n   \"TARGET_FPU\"\n   \"fsqrtd\\\\t%1, %0\"\n-  [(set_attr \"type\" \"fpsqrt\")\n+  [(set_attr \"type\" \"fpsqrtd\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_FPU\"\n   \"fsqrts\\\\t%1, %0\"\n-  [(set_attr \"type\" \"fpsqrt\")\n+  [(set_attr \"type\" \"fpsqrts\")\n    (set_attr \"length\" \"1\")])\n \f\n ;;- arithmetic shift instructions"}]}