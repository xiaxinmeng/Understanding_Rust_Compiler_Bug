{"sha": "727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI3ZTdiMWE4NzBiZGMwNTdjNGNiNmQ3ZDA5ZWYxYjU2YTg0ZjIyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:49:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:49:10Z"}, "message": "[multiple changes]\n\n2012-07-12  Robert Dewar  <dewar@adacore.com>\n\n\t* s-atopri.adb, s-atopri.ads: Minor reformatting.\n\n2012-07-12  Robert Dewar  <dewar@adacore.com>\n\n\t* ali.adb: Add circuitry to read new named form of restrictions lines.\n\t* debug.adb: Add doc for new -gnatd.R switch (used positional\n\tnotation for output of restrictions data in ali file).\n\t* lib-writ.adb: Implement new named format for restrictions lines.\n\t* lib-writ.ads: Add documentation for new named format for\n\trestrictions in ali files.\n\t* restrict.adb, restrict.ads, sem_prag.adb: Update comments.\n\t* rident.ads: Go back to withing System.Rident\n\t* s-rident.ads: Add extensive comment on dealing with consistency\n\tchecking.\n\n2012-07-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb, scos.ads: Emit detailed SCOs for SELECT statements.\n\nFrom-SVN: r189438", "tree": {"sha": "9754099aee8625dc123639e1fe1bb60689179ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9754099aee8625dc123639e1fe1bb60689179ee3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/comments", "author": null, "committer": null, "parents": [{"sha": "03459f403ea66cc694767e8ca351cf6550e148a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03459f403ea66cc694767e8ca351cf6550e148a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03459f403ea66cc694767e8ca351cf6550e148a7"}], "stats": {"total": 1982, "additions": 1072, "deletions": 910}, "files": [{"sha": "fa755415f6a4a5549a6f7c497bdd1eead7c0e1e8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -1,3 +1,24 @@\n+2012-07-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-atopri.adb, s-atopri.ads: Minor reformatting.\n+\n+2012-07-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* ali.adb: Add circuitry to read new named form of restrictions lines.\n+\t* debug.adb: Add doc for new -gnatd.R switch (used positional\n+\tnotation for output of restrictions data in ali file).\n+\t* lib-writ.adb: Implement new named format for restrictions lines.\n+\t* lib-writ.ads: Add documentation for new named format for\n+\trestrictions in ali files.\n+\t* restrict.adb, restrict.ads, sem_prag.adb: Update comments.\n+\t* rident.ads: Go back to withing System.Rident\n+\t* s-rident.ads: Add extensive comment on dealing with consistency\n+\tchecking.\n+\n+2012-07-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb, scos.ads: Emit detailed SCOs for SELECT statements.\n+\n 2012-07-12  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_disp.adb: Minor reformatting"}, {"sha": "86ad184de2bbc8598296afa7822725a713f8ed98", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 256, "deletions": 62, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -135,7 +135,7 @@ package body ALI is\n       Ignore_Errors    : Boolean := False;\n       Directly_Scanned : Boolean := False) return ALI_Id\n    is\n-      P         : Text_Ptr := T'First;\n+      P         : Text_Ptr            := T'First;\n       Line      : Logical_Line_Number := 1;\n       Id        : ALI_Id;\n       C         : Character;\n@@ -1154,7 +1154,7 @@ package body ALI is\n       C := Getc;\n       Check_Unknown_Line;\n \n-      --  Acquire first restrictions line\n+      --  Loop to skip to first restrictions line\n \n       while C /= 'R' loop\n          if Ignore_Errors then\n@@ -1169,10 +1169,15 @@ package body ALI is\n          end if;\n       end loop;\n \n+      --  Ignore all 'R' lines if that is required\n+\n       if Ignore ('R') then\n-         Skip_Line;\n+         while C = 'R' loop\n+            Skip_Line;\n+            C := Getc;\n+         end loop;\n \n-      --  Process restrictions line\n+      --  Here we process the restrictions lines (other than unit name cases)\n \n       else\n          Scan_Restrictions : declare\n@@ -1182,16 +1187,191 @@ package body ALI is\n             Bad_R_Line : exception;\n             --  Signal bad restrictions line (raised on unexpected character)\n \n-         begin\n-            Checkc (' ');\n-            Skip_Space;\n+            Typ : Character;\n+            R   : Restriction_Id;\n+            N   : Natural;\n \n-            --  Acquire information for boolean restrictions\n+         begin\n+            --  Named restriction case\n \n-            for R in All_Boolean_Restrictions loop\n+            if Nextc = 'N' then\n+               Skip_Line;\n                C := Getc;\n \n-               case C is\n+               --  Loop through RR and RV lines\n+\n+               while C = 'R' and then Nextc /= ' ' loop\n+                  Typ := Getc;\n+                  Checkc (' ');\n+\n+                  --  Acquire restriction name\n+\n+                  Name_Len := 0;\n+                  while not At_Eol and then Nextc /= '=' loop\n+                     Name_Len := Name_Len + 1;\n+                     Name_Buffer (Name_Len) := Getc;\n+                  end loop;\n+\n+                  --  Now search list of restrictions to find match\n+\n+                  declare\n+                     RN : String renames Name_Buffer (1 .. Name_Len);\n+\n+                  begin\n+                     R := Restriction_Id'First;\n+                     while R < Not_A_Restriction_Id loop\n+                        if Restriction_Id'Image (R) = RN then\n+                           goto R_Found;\n+                        end if;\n+\n+                        R := Restriction_Id'Succ (R);\n+                     end loop;\n+\n+                     --  We don't recognize the restriction. This might be\n+                     --  thought of as an error, and it really is, but we\n+                     --  want to allow building with inconsistent versions\n+                     --  of the binder and ali files (see comments at the\n+                     --  start of package System.Rident), so we just ignore\n+                     --  this situation.\n+\n+                     goto Done_With_Restriction_Line;\n+                  end;\n+\n+                  <<R_Found>>\n+\n+                  case R is\n+\n+                     --  Boolean restriction case\n+\n+                     when All_Boolean_Restrictions =>\n+                        case Typ is\n+                           when 'V' =>\n+                              ALIs.Table (Id).Restrictions.Violated (R) :=\n+                                True;\n+                              Cumulative_Restrictions.Violated (R) := True;\n+\n+                           when 'R' =>\n+                              ALIs.Table (Id).Restrictions.Set (R) := True;\n+                              Cumulative_Restrictions.Set (R) := True;\n+\n+                           when others =>\n+                              raise Bad_R_Line;\n+                        end case;\n+\n+                     --  Parameter restriction case\n+\n+                     when All_Parameter_Restrictions =>\n+                        if At_Eol or else Nextc /= '=' then\n+                           raise Bad_R_Line;\n+                        else\n+                           Skipc;\n+                        end if;\n+\n+                        N := Natural (Get_Nat);\n+\n+                        case Typ is\n+\n+                           --  Restriction set\n+\n+                           when 'R' =>\n+                              ALIs.Table (Id).Restrictions.Set (R) := True;\n+                              ALIs.Table (Id).Restrictions.Value (R) := N;\n+\n+                              if Cumulative_Restrictions.Set (R) then\n+                                 Cumulative_Restrictions.Value (R) :=\n+                                   Integer'Min\n+                                     (Cumulative_Restrictions.Value (R), N);\n+                              else\n+                                 Cumulative_Restrictions.Set (R) := True;\n+                                 Cumulative_Restrictions.Value (R) := N;\n+                              end if;\n+\n+                           --  Restriction violated\n+\n+                           when 'V' =>\n+                              ALIs.Table (Id).Restrictions.Violated (R) :=\n+                                True;\n+                              Cumulative_Restrictions.Violated (R) := True;\n+                              ALIs.Table (Id).Restrictions.Count (R) := N;\n+\n+                              --  Checked Max_Parameter case\n+\n+                              if R in Checked_Max_Parameter_Restrictions then\n+                                 Cumulative_Restrictions.Count (R) :=\n+                                   Integer'Max\n+                                     (Cumulative_Restrictions.Count (R), N);\n+\n+                              --  Other checked parameter cases\n+\n+                              else\n+                                 declare\n+                                    pragma Unsuppress (Overflow_Check);\n+\n+                                 begin\n+                                    Cumulative_Restrictions.Count (R) :=\n+                                      Cumulative_Restrictions.Count (R) + N;\n+\n+                                 exception\n+                                    when Constraint_Error =>\n+\n+                                       --  A constraint error comes from the\n+                                       --  additionh. We reset to the maximum\n+                                       --  and indicate that the real value is\n+                                       --  now unknown.\n+\n+                                       Cumulative_Restrictions.Value (R) :=\n+                                         Integer'Last;\n+                                       Cumulative_Restrictions.Unknown (R) :=\n+                                         True;\n+                                 end;\n+                              end if;\n+\n+                              --  Deal with + case\n+\n+                              if Nextc = '+' then\n+                                 Skipc;\n+                                 ALIs.Table (Id).Restrictions.Unknown (R) :=\n+                                   True;\n+                                 Cumulative_Restrictions.Unknown (R) := True;\n+                              end if;\n+\n+                           --  Other than 'R' or 'V'\n+\n+                           when others =>\n+                              raise Bad_R_Line;\n+                        end case;\n+\n+                        if not At_Eol then\n+                           raise Bad_R_Line;\n+                        end if;\n+\n+                     --  Bizarre error case NOT_A_RESTRICTION\n+\n+                     when Not_A_Restriction_Id =>\n+                        raise Bad_R_Line;\n+                  end case;\n+\n+                  if not At_Eol then\n+                     raise Bad_R_Line;\n+                  end if;\n+\n+               <<Done_With_Restriction_Line>>\n+                  Skip_Line;\n+                  C := Getc;\n+               end loop;\n+\n+            --  Positional restriction case\n+\n+            else\n+               Checkc (' ');\n+               Skip_Space;\n+\n+               --  Acquire information for boolean restrictions\n+\n+               for R in All_Boolean_Restrictions loop\n+                  C := Getc;\n+\n+                  case C is\n                   when 'v' =>\n                      ALIs.Table (Id).Restrictions.Violated (R) := True;\n                      Cumulative_Restrictions.Violated (R) := True;\n@@ -1205,44 +1385,42 @@ package body ALI is\n \n                   when others =>\n                      raise Bad_R_Line;\n-               end case;\n-            end loop;\n-\n-            --  Acquire information for parameter restrictions\n+                  end case;\n+               end loop;\n \n-            for RP in All_Parameter_Restrictions loop\n+               --  Acquire information for parameter restrictions\n \n-               --  Acquire restrictions pragma information\n+               for RP in All_Parameter_Restrictions loop\n+                  case Getc is\n+                     when 'n' =>\n+                        null;\n \n-               case Getc is\n-                  when 'n' =>\n-                     null;\n+                     when 'r' =>\n+                        ALIs.Table (Id).Restrictions.Set (RP) := True;\n \n-                  when 'r' =>\n-                     ALIs.Table (Id).Restrictions.Set (RP) := True;\n+                        declare\n+                           N : constant Integer := Integer (Get_Nat);\n+                        begin\n+                           ALIs.Table (Id).Restrictions.Value (RP) := N;\n \n-                     declare\n-                        N : constant Integer := Integer (Get_Nat);\n-                     begin\n-                        ALIs.Table (Id).Restrictions.Value (RP) := N;\n+                           if Cumulative_Restrictions.Set (RP) then\n+                              Cumulative_Restrictions.Value (RP) :=\n+                                Integer'Min\n+                                  (Cumulative_Restrictions.Value (RP), N);\n+                           else\n+                              Cumulative_Restrictions.Set (RP) := True;\n+                              Cumulative_Restrictions.Value (RP) := N;\n+                           end if;\n+                        end;\n \n-                        if Cumulative_Restrictions.Set (RP) then\n-                           Cumulative_Restrictions.Value (RP) :=\n-                             Integer'Min\n-                               (Cumulative_Restrictions.Value (RP), N);\n-                        else\n-                           Cumulative_Restrictions.Set (RP) := True;\n-                           Cumulative_Restrictions.Value (RP) := N;\n-                        end if;\n-                     end;\n+                     when others =>\n+                        raise Bad_R_Line;\n+                  end case;\n \n-                  when others =>\n-                     raise Bad_R_Line;\n-               end case;\n+                  --  Acquire restrictions violations information\n \n-               --  Acquire restrictions violations information\n+                  case Getc is\n \n-               case Getc is\n                   when 'n' =>\n                      null;\n \n@@ -1252,7 +1430,6 @@ package body ALI is\n \n                      declare\n                         N : constant Integer := Integer (Get_Nat);\n-                        pragma Unsuppress (Overflow_Check);\n \n                      begin\n                         ALIs.Table (Id).Restrictions.Count (RP) := N;\n@@ -1261,60 +1438,77 @@ package body ALI is\n                            Cumulative_Restrictions.Count (RP) :=\n                              Integer'Max\n                                (Cumulative_Restrictions.Count (RP), N);\n+\n                         else\n-                           Cumulative_Restrictions.Count (RP) :=\n-                             Cumulative_Restrictions.Count (RP) + N;\n-                        end if;\n+                           declare\n+                              pragma Unsuppress (Overflow_Check);\n \n-                     exception\n-                        when Constraint_Error =>\n+                           begin\n+                              Cumulative_Restrictions.Count (RP) :=\n+                                Cumulative_Restrictions.Count (RP) + N;\n+\n+                           exception\n+                              when Constraint_Error =>\n \n-                           --  A constraint error comes from the addition in\n-                           --  the else branch. We reset to the maximum and\n-                           --  indicate that the real value is now unknown.\n+                                 --  A constraint error comes from the add. We\n+                                 --  reset to the maximum and indicate that the\n+                                 --  real value is now unknown.\n+\n+                                 Cumulative_Restrictions.Value (RP) :=\n+                                   Integer'Last;\n+                                 Cumulative_Restrictions.Unknown (RP) := True;\n+                           end;\n+                        end if;\n \n-                           Cumulative_Restrictions.Value (RP) := Integer'Last;\n+                        if Nextc = '+' then\n+                           Skipc;\n+                           ALIs.Table (Id).Restrictions.Unknown (RP) := True;\n                            Cumulative_Restrictions.Unknown (RP) := True;\n+                        end if;\n                      end;\n \n-                     if Nextc = '+' then\n-                        Skipc;\n-                        ALIs.Table (Id).Restrictions.Unknown (RP) := True;\n-                        Cumulative_Restrictions.Unknown (RP) := True;\n-                     end if;\n-\n                   when others =>\n                      raise Bad_R_Line;\n-               end case;\n-            end loop;\n+                  end case;\n+               end loop;\n \n-            Skip_Eol;\n+               if not At_Eol then\n+                  raise Bad_R_Line;\n+               else\n+                  Skip_Line;\n+                  C := Getc;\n+               end if;\n+            end if;\n \n          --  Here if error during scanning of restrictions line\n \n          exception\n             when Bad_R_Line =>\n \n                --  In Ignore_Errors mode, undo any changes to restrictions\n-               --  from this unit, and continue on.\n+               --  from this unit, and continue on, skipping remaining R\n+               --  lines for this unit.\n \n                if Ignore_Errors then\n                   Cumulative_Restrictions := Save_R;\n                   ALIs.Table (Id).Restrictions := No_Restrictions;\n-                  Skip_Eol;\n+\n+                  loop\n+                     Skip_Eol;\n+                     C := Getc;\n+                     exit when C /= 'R';\n+                  end loop;\n \n                --  In normal mode, this is a fatal error\n \n                else\n                   Fatal_Error;\n                end if;\n-\n          end Scan_Restrictions;\n       end if;\n \n       --  Acquire additional restrictions (No_Dependence) lines if present\n \n-      C := Getc;\n       while C = 'R' loop\n          if Ignore ('R') then\n             Skip_Line;"}, {"sha": "33f99c68cff37696f1921ad4133454fb84999582", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -135,7 +135,7 @@ package body Debug is\n    --  d.O  Dump internal SCO tables\n    --  d.P  Previous (non-optimized) handling of length comparisons\n    --  d.Q\n-   --  d.R\n+   --  d.R  Restrictions in ali files in positional form\n    --  d.S  Force Optimize_Alignment (Space)\n    --  d.T  Force Optimize_Alignment (Time)\n    --  d.U  Ignore indirect calls for static elaboration\n@@ -642,6 +642,11 @@ package body Debug is\n    --       This is there in case we find a situation where the optimization\n    --       malfunctions, to provide a work around.\n \n+   --  d.R  As documented in lib-writ.ads, restrictions in the ali file can\n+   --       have two forms, positional and named. The named notation is the\n+   --       current preferred form, but the use of this debug switch will force\n+   --       the use of the obsolescent positional form.\n+\n    --  d.S  Force Optimize_Alignment (Space) mode as the default\n \n    --  d.T  Force Optimize_Alignment (Time) mode as the default"}, {"sha": "1c55a06aa3e940a2cafe20b584c0464a580e0cb9", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 114, "deletions": 37, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -26,6 +26,7 @@\n with ALI;      use ALI;\n with Atree;    use Atree;\n with Casing;   use Casing;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Fname;    use Fname;\n@@ -1140,52 +1141,128 @@ package body Lib.Writ is\n          end if;\n       end loop;\n \n-      --  Output first restrictions line\n+      --  Positional case (only if debug flag -gnatd.R is set)\n \n-      Write_Info_Initiate ('R');\n-      Write_Info_Char (' ');\n+      if Debug_Flag_Dot_RR then\n \n-      --  First the information for the boolean restrictions\n+         --  Output first restrictions line\n \n-      for R in All_Boolean_Restrictions loop\n-         if Main_Restrictions.Set (R)\n-           and then not Restriction_Warnings (R)\n-         then\n-            Write_Info_Char ('r');\n-         elsif Main_Restrictions.Violated (R) then\n-            Write_Info_Char ('v');\n-         else\n-            Write_Info_Char ('n');\n-         end if;\n-      end loop;\n+         Write_Info_Initiate ('R');\n+         Write_Info_Char (' ');\n \n-      --  And now the information for the parameter restrictions\n+         --  First the information for the boolean restrictions\n \n-      for RP in All_Parameter_Restrictions loop\n-         if Main_Restrictions.Set (RP)\n-           and then not Restriction_Warnings (RP)\n-         then\n-            Write_Info_Char ('r');\n-            Write_Info_Nat (Nat (Main_Restrictions.Value (RP)));\n-         else\n-            Write_Info_Char ('n');\n-         end if;\n+         for R in All_Boolean_Restrictions loop\n+            if Main_Restrictions.Set (R)\n+              and then not Restriction_Warnings (R)\n+            then\n+               Write_Info_Char ('r');\n+            elsif Main_Restrictions.Violated (R) then\n+               Write_Info_Char ('v');\n+            else\n+               Write_Info_Char ('n');\n+            end if;\n+         end loop;\n \n-         if not Main_Restrictions.Violated (RP)\n-           or else RP not in Checked_Parameter_Restrictions\n-         then\n-            Write_Info_Char ('n');\n-         else\n-            Write_Info_Char ('v');\n-            Write_Info_Nat (Nat (Main_Restrictions.Count (RP)));\n+         --  And now the information for the parameter restrictions\n+\n+         for RP in All_Parameter_Restrictions loop\n+            if Main_Restrictions.Set (RP)\n+              and then not Restriction_Warnings (RP)\n+            then\n+               Write_Info_Char ('r');\n+               Write_Info_Nat (Nat (Main_Restrictions.Value (RP)));\n+            else\n+               Write_Info_Char ('n');\n+            end if;\n+\n+            if not Main_Restrictions.Violated (RP)\n+              or else RP not in Checked_Parameter_Restrictions\n+            then\n+               Write_Info_Char ('n');\n+            else\n+               Write_Info_Char ('v');\n+               Write_Info_Nat (Nat (Main_Restrictions.Count (RP)));\n \n-            if Main_Restrictions.Unknown (RP) then\n-               Write_Info_Char ('+');\n+               if Main_Restrictions.Unknown (RP) then\n+                  Write_Info_Char ('+');\n+               end if;\n             end if;\n-         end if;\n-      end loop;\n+         end loop;\n \n-      Write_Info_EOL;\n+         Write_Info_EOL;\n+\n+      --  Named case (if debug flag -gnatd.R is not set)\n+\n+      else\n+         declare\n+            C : Character;\n+\n+         begin\n+            --  Write RN header line with preceding blank line\n+\n+            Write_Info_EOL;\n+            Write_Info_Initiate ('R');\n+            Write_Info_Char ('N');\n+            Write_Info_EOL;\n+\n+            --  First the lines for the boolean restrictions\n+\n+            for R in All_Boolean_Restrictions loop\n+               if Main_Restrictions.Set (R)\n+                 and then not Restriction_Warnings (R)\n+               then\n+                  C := 'R';\n+               elsif Main_Restrictions.Violated (R) then\n+                  C := 'V';\n+               else\n+                  goto Continue;\n+               end if;\n+\n+               Write_Info_Initiate ('R');\n+               Write_Info_Char (C);\n+               Write_Info_Char (' ');\n+               Write_Info_Str (All_Boolean_Restrictions'Image (R));\n+               Write_Info_EOL;\n+\n+            <<Continue>>\n+               null;\n+            end loop;\n+         end;\n+\n+         --  And now the lines for the parameter restrictions\n+\n+         for RP in All_Parameter_Restrictions loop\n+            if Main_Restrictions.Set (RP)\n+              and then not Restriction_Warnings (RP)\n+            then\n+               Write_Info_Initiate ('R');\n+               Write_Info_Str (\"R \");\n+               Write_Info_Str (All_Parameter_Restrictions'Image (RP));\n+               Write_Info_Char ('=');\n+               Write_Info_Nat (Nat (Main_Restrictions.Value (RP)));\n+               Write_Info_EOL;\n+            end if;\n+\n+            if not Main_Restrictions.Violated (RP)\n+              or else RP not in Checked_Parameter_Restrictions\n+            then\n+               null;\n+            else\n+               Write_Info_Initiate ('R');\n+               Write_Info_Str (\"V \");\n+               Write_Info_Str (All_Parameter_Restrictions'Image (RP));\n+               Write_Info_Char ('=');\n+               Write_Info_Nat (Nat (Main_Restrictions.Count (RP)));\n+\n+               if Main_Restrictions.Unknown (RP) then\n+                  Write_Info_Char ('+');\n+               end if;\n+\n+               Write_Info_EOL;\n+            end if;\n+         end loop;\n+      end if;\n \n       --  Output R lines for No_Dependence entries\n "}, {"sha": "fdc99482afe0406685e3abcf619251f19e0270c3", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -262,6 +262,28 @@ package Lib.Writ is\n    --  -- R  Restrictions --\n    --  ---------------------\n \n+   --  There are two forms for R lines, positional and named. The positional\n+   --  notation is now considered obsolescent, it is not generated by the most\n+   --  recent versions of the compiler except under control of the debug switch\n+   --  -gnatdR, but is still recognized by the binder.\n+\n+   --  The recognition by the binder is to ease the transition, and better deal\n+   --  with some cases of inconsistent builds using incompatible versions of\n+   --  the compiler and binder. The named notation is the current preferred\n+   --  approach.\n+\n+   --  Note that R lines are generated using the information in unit Rident,\n+   --  and intepreted by the binder using the information in System.Rident.\n+   --  Normally these two units should be effectively identical. However in\n+   --  some cases of inconsistent builds, they may be different. This may lead\n+   --  to binder diagnostics, which can be suppressed using the -C switch for\n+   --  the binder, which results in ignoring unrecognized restrictions in the\n+   --  ali files.\n+\n+   --  ---------------------------------------\n+   --  -- R  Restrictions (Positional Form) --\n+   --  ---------------------------------------\n+\n    --  The first R line records the status of restrictions generated by pragma\n    --  Restrictions encountered, as well as information on what the compiler\n    --  has been able to determine with respect to restrictions violations.\n@@ -348,6 +370,74 @@ package Lib.Writ is\n    --      signal a fatal error if it is missing. This means that future\n    --      changes to the ALI file format must retain the R line.\n \n+   --  ----------------------------------\n+   --  -- R  Restrictions (Named Form) --\n+   --  ----------------------------------\n+\n+   --  The first R line for named form announces that named notation will be\n+   --  used, and also assures that there is at least one R line present, which\n+   --  makes parsing of ali files simpler. A blank line preceds the RN line.\n+\n+   --  RN\n+\n+   --  In named notation, the restrictions are given as a series of lines, one\n+   --  per retrictions that is specified or violated (no information is present\n+   --  for restrictions that are not specified or violated). In the following\n+   --  name is the name of the restriction in all upper case.\n+\n+   --  For boolean restrictions, we have only two possibilities. A restrictions\n+   --  pragma is present, or a violation is detected:\n+\n+   --  RR name\n+\n+   --    A restriction pragma is present for the named boolean restriction.\n+   --    No violations were detected by the compiler (or the unit in question\n+   --    would have been found to be illegal).\n+\n+   --  RV name\n+\n+   --    No restriction pragma is present for the named boolean restriction.\n+   --    However, the compiler did detect one or more violations of this\n+   --    restriction, which may require a binder consistency check.\n+\n+   --  For the case of restrictions that take a parameter, we need both the\n+   --  information from pragma if present, and the actual information about\n+   --  what possible violations occur. For example, we can have a unit with\n+   --  a pragma Restrictions (Max_Tasks => 4), where the compiler can detect\n+   --  that there are exactly three tasks declared. Both of these pieces\n+   --  of information must be passed to the binder. The parameter of 4 is\n+   --  important in case the total number of tasks in the partition is greater\n+   --  than 4. The parameter of 3 is important in case some other unit has a\n+   --  restrictions pragma with Max_Tasks=>2.\n+\n+   --  RR name=N\n+\n+   --    A restriction pragma is present for the named restriction which is\n+   --    one of the restrictions taking a parameter. The value N (a decimal\n+   --    integer) is the value given in the restriction pragma.\n+\n+   --  RV name=N\n+\n+   --    A restriction pragma may or may not be present for the restriction\n+   --    given by name (one of the restrictions taking a parameter). But in\n+   --    either case, the compiler detected possible violations. N (a decimal\n+   --    integer) is the maximum or total count of violations (depending\n+   --    on the checking type) in all the units represented by the ali file).\n+   --    The value here is known to be exact by the compiler and is in the\n+   --    range of Natural. Note that if an RR line is present for the same\n+   --    restriction, then the value in the RV line cannot exceed the value\n+   --    in the RR line (since otherwise the compiler would have detected a\n+   --    violation of the restriction).\n+\n+   --  RV name=N+\n+\n+   --    Similar to the above, but the compiler cannot determine the exact\n+   --    count of violations, but it is at least N.\n+\n+   --  -------------------------------------------------\n+   --  -- R  Restrictions (No_Dependence Information) --\n+   --  -------------------------------------------------\n+\n    --  Subsequent R lines are present only if pragma Restriction No_Dependence\n    --  is used. There is one such line for each such pragma appearing in the\n    --  extended main unit. The format is:"}, {"sha": "766621ada526081c13480c4318d3323f2135bf96", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 498, "deletions": 353, "changes": 851, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,9 +69,9 @@ package body Par_SCO is\n \n    --  We need to be able to get to conditions quickly for handling the calls\n    --  to Set_SCO_Condition efficiently, and similarly to get to pragmas to\n-   --  handle calls to Set_SCO_Pragma_Enabled. For this purpose we identify\n-   --  the conditions and pragmas in the table by their starting sloc, and use\n-   --  this hash table to map from these sloc values to SCO_Table indexes.\n+   --  handle calls to Set_SCO_Pragma_Enabled. For this purpose we identify the\n+   --  conditions and pragmas in the table by their starting sloc, and use this\n+   --  hash table to map from these sloc values to SCO_Table indexes.\n \n    type Header_Num is new Integer range 0 .. 996;\n    --  Type for hash table headers\n@@ -133,13 +133,16 @@ package body Par_SCO is\n       --  F/T/S/E for a valid dominance marker, or ' ' for no dominant\n \n       N : Node_Id;\n-      --  Node providing the sloc(s) for the dominance marker\n+      --  Node providing the Sloc(s) for the dominance marker\n    end record;\n    No_Dominant : constant Dominant_Info := (' ', Empty);\n \n    procedure Traverse_Declarations_Or_Statements\n      (L : List_Id;\n-      D : Dominant_Info := No_Dominant);\n+      D : Dominant_Info := No_Dominant;\n+      P : Node_Id       := Empty);\n+   --  Process L, a list of statements or declarations dominated by D.\n+   --  If P is present, it is processed as though it had been prepended to L.\n \n    procedure Traverse_Generic_Instantiation       (N : Node_Id);\n    procedure Traverse_Generic_Package_Declaration (N : Node_Id);\n@@ -328,9 +331,7 @@ package body Par_SCO is\n \n    function Is_Logical_Operator (N : Node_Id) return Boolean is\n    begin\n-      return Nkind_In (N, N_Op_Not,\n-                          N_And_Then,\n-                          N_Or_Else);\n+      return Nkind_In (N, N_Op_Not, N_And_Then, N_Or_Else);\n    end Is_Logical_Operator;\n \n    -----------------------\n@@ -475,7 +476,7 @@ package body Par_SCO is\n \n       procedure Output_Header (T : Character) is\n          Loc : Source_Ptr := No_Location;\n-         --  Node whose sloc is used for the decision\n+         --  Node whose Sloc is used for the decision\n \n       begin\n          case T is\n@@ -488,13 +489,22 @@ package body Par_SCO is\n \n             when 'G' | 'P' =>\n \n-               --  For entry, the token sloc is from the N_Entry_Body. For\n-               --  PRAGMA, we must get the location from the pragma node.\n+               --  For entry guard, the token sloc is from the N_Entry_Body.\n+               --  For PRAGMA, we must get the location from the pragma node.\n                --  Argument N is the pragma argument, and we have to go up two\n                --  levels (through the pragma argument association) to get to\n-               --  the pragma node itself.\n-\n-               Loc := Sloc (Parent (Parent (N)));\n+               --  the pragma node itself. For the guard on a select\n+               --  alternative, we do not have access to the token location\n+               --  for the WHEN, so we use the sloc of the condition itself.\n+\n+               if Nkind_In (Parent (N), N_Accept_Alternative,\n+                                        N_Delay_Alternative,\n+                                        N_Terminate_Alternative)\n+               then\n+                  Loc := Sloc (N);\n+               else\n+                  Loc := Sloc (Parent (Parent (N)));\n+               end if;\n \n             when 'X' =>\n \n@@ -547,10 +557,7 @@ package body Par_SCO is\n             --  Logical operators, output table entries and then process\n             --  operands recursively to deal with nested conditions.\n \n-            when N_And_Then |\n-                 N_Or_Else  |\n-                 N_Op_Not   =>\n-\n+            when N_And_Then | N_Or_Else  | N_Op_Not =>\n                declare\n                   T : Character;\n \n@@ -1036,16 +1043,16 @@ package body Par_SCO is\n \n    procedure Traverse_Declarations_Or_Statements\n      (L : List_Id;\n-      D : Dominant_Info := No_Dominant)\n+      D : Dominant_Info := No_Dominant;\n+      P : Node_Id       := Empty)\n    is\n       Current_Dominant : Dominant_Info := D;\n       --  Dominance information for the current basic block\n \n       Current_Test : Node_Id;\n       --  Conditional node (N_If_Statement or N_Elsiif being processed\n \n-      N     : Node_Id;\n-      Dummy : Source_Ptr;\n+      N : Node_Id;\n \n       SC_First : constant Nat := SC.Last + 1;\n       SD_First : constant Nat := SD.Last + 1;\n@@ -1056,15 +1063,6 @@ package body Par_SCO is\n       --  is the letter that identifies the type of statement/declaration that\n       --  is being added to the sequence.\n \n-      procedure Extend_Statement_Sequence\n-        (From : Node_Id;\n-         To   : Node_Id;\n-         Typ  : Character);\n-      --  This version extends the current statement sequence with an entry\n-      --  that starts with the first token of From, and ends with the last\n-      --  token of To. It is used for example in a CASE statement to cover\n-      --  the range from the CASE token to the last token of the expression.\n-\n       procedure Set_Statement_Entry;\n       --  Output CS entries for all statements saved in table SC, and end the\n       --  current CS sequence.\n@@ -1080,6 +1078,9 @@ package body Par_SCO is\n       pragma Inline (Process_Decisions_Defer);\n       --  Same case for list arguments, deferred call to Process_Decisions\n \n+      procedure Traverse_One (N : Node_Id);\n+      --  Traverse one declaration or statement\n+\n       -------------------------\n       -- Set_Statement_Entry --\n       -------------------------\n@@ -1180,24 +1181,50 @@ package body Par_SCO is\n       -------------------------------\n \n       procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character) is\n-         F : Source_Ptr;\n-         T : Source_Ptr;\n+         F       : Source_Ptr;\n+         T       : Source_Ptr;\n+         Dummy   : Source_Ptr;\n+         To_Node : Node_Id := Empty;\n+\n       begin\n          Sloc_Range (N, F, T);\n-         SC.Append ((N, F, T, Typ));\n-      end Extend_Statement_Sequence;\n \n-      procedure Extend_Statement_Sequence\n-        (From : Node_Id;\n-         To   : Node_Id;\n-         Typ  : Character)\n-      is\n-         F : Source_Ptr;\n-         T : Source_Ptr;\n-      begin\n-         Sloc_Range (From, F, Dummy);\n-         Sloc_Range (To, Dummy, T);\n-         SC.Append ((From, F, T, Typ));\n+         case Nkind (N) is\n+            when N_Accept_Statement =>\n+               if Present (Parameter_Specifications (N)) then\n+                  To_Node := Last (Parameter_Specifications (N));\n+               elsif Present (Entry_Index (N)) then\n+                  To_Node := Entry_Index (N);\n+               end if;\n+\n+            when N_Case_Statement =>\n+               To_Node := Expression (N);\n+\n+            when N_If_Statement | N_Elsif_Part =>\n+               To_Node := Condition (N);\n+\n+            when N_Extended_Return_Statement =>\n+               To_Node := Last (Return_Object_Declarations (N));\n+\n+            when N_Loop_Statement =>\n+               To_Node := Iteration_Scheme (N);\n+\n+            when N_Selective_Accept       |\n+                 N_Timed_Entry_Call       |\n+                 N_Conditional_Entry_Call |\n+                 N_Asynchronous_Select    =>\n+               T := F;\n+\n+            when others =>\n+               null;\n+\n+         end case;\n+\n+         if Present (To_Node) then\n+            Sloc_Range (To_Node, Dummy, T);\n+         end if;\n+\n+         SC.Append ((N, F, T, Typ));\n       end Extend_Statement_Sequence;\n \n       -----------------------------\n@@ -1214,430 +1241,548 @@ package body Par_SCO is\n          SD.Append ((Empty, L, T, Current_Pragma_Sloc));\n       end Process_Decisions_Defer;\n \n-   --  Start of processing for Traverse_Declarations_Or_Statements\n+      ------------------\n+      -- Traverse_One --\n+      ------------------\n \n-   begin\n-      if Is_Non_Empty_List (L) then\n+      procedure Traverse_One (N : Node_Id) is\n+      begin\n+         --  Initialize or extend current statement sequence. Note that for\n+         --  special cases such as IF and Case statements we will modify\n+         --  the range to exclude internal statements that should not be\n+         --  counted as part of the current statement sequence.\n \n-         --  Loop through statements or declarations\n+         case Nkind (N) is\n \n-         N := First (L);\n-         while Present (N) loop\n+            --  Package declaration\n \n-            --  Initialize or extend current statement sequence. Note that for\n-            --  special cases such as IF and Case statements we will modify\n-            --  the range to exclude internal statements that should not be\n-            --  counted as part of the current statement sequence.\n+            when N_Package_Declaration =>\n+               Set_Statement_Entry;\n+               Traverse_Package_Declaration (N);\n \n-            case Nkind (N) is\n+            --  Generic package declaration\n \n-               --  Package declaration\n+            when N_Generic_Package_Declaration =>\n+               Set_Statement_Entry;\n+               Traverse_Generic_Package_Declaration (N);\n \n-               when N_Package_Declaration =>\n-                  Set_Statement_Entry;\n-                  Traverse_Package_Declaration (N);\n+            --  Package body\n \n-               --  Generic package declaration\n+            when N_Package_Body =>\n+               Set_Statement_Entry;\n+               Traverse_Package_Body (N);\n \n-               when N_Generic_Package_Declaration =>\n-                  Set_Statement_Entry;\n-                  Traverse_Generic_Package_Declaration (N);\n+            --  Subprogram declaration\n \n-               --  Package body\n+            when N_Subprogram_Declaration =>\n+               Process_Decisions_Defer\n+                 (Parameter_Specifications (Specification (N)), 'X');\n \n-               when N_Package_Body =>\n-                  Set_Statement_Entry;\n-                  Traverse_Package_Body (N);\n+            --  Generic subprogram declaration\n+\n+            when N_Generic_Subprogram_Declaration =>\n+               Process_Decisions_Defer\n+                 (Generic_Formal_Declarations (N), 'X');\n+               Process_Decisions_Defer\n+                 (Parameter_Specifications (Specification (N)), 'X');\n \n-               --  Subprogram declaration\n+            --  Task or subprogram body\n \n-               when N_Subprogram_Declaration =>\n-                  Process_Decisions_Defer\n-                    (Parameter_Specifications (Specification (N)), 'X');\n+            when N_Task_Body | N_Subprogram_Body =>\n+               Set_Statement_Entry;\n+               Traverse_Subprogram_Or_Task_Body (N);\n \n-               --  Generic subprogram declaration\n+            --  Entry body\n \n-               when N_Generic_Subprogram_Declaration =>\n-                  Process_Decisions_Defer\n-                    (Generic_Formal_Declarations (N), 'X');\n-                  Process_Decisions_Defer\n-                    (Parameter_Specifications (Specification (N)), 'X');\n+            when N_Entry_Body =>\n+               declare\n+                  Cond : constant Node_Id :=\n+                           Condition (Entry_Body_Formal_Part (N));\n \n-               --  Task or subprogram body\n+                  Inner_Dominant : Dominant_Info := No_Dominant;\n \n-               when N_Task_Body | N_Subprogram_Body =>\n+               begin\n                   Set_Statement_Entry;\n-                  Traverse_Subprogram_Or_Task_Body (N);\n \n-               --  Entry body\n+                  if Present (Cond) then\n+                     Process_Decisions_Defer (Cond, 'G');\n+\n+                     --  For an entry body with a barrier, the entry body\n+                     --  is dominanted by a True evaluation of the barrier.\n \n-               when N_Entry_Body =>\n+                     Inner_Dominant := ('T', N);\n+                  end if;\n+\n+                  Traverse_Subprogram_Or_Task_Body (N, Inner_Dominant);\n+               end;\n+\n+            --  Protected body\n+\n+            when N_Protected_Body =>\n+               Set_Statement_Entry;\n+               Traverse_Protected_Body (N);\n+\n+            --  Exit statement, which is an exit statement in the SCO sense,\n+            --  so it is included in the current statement sequence, but\n+            --  then it terminates this sequence. We also have to process\n+            --  any decisions in the exit statement expression.\n+\n+            when N_Exit_Statement =>\n+               Extend_Statement_Sequence (N, ' ');\n+               Process_Decisions_Defer (Condition (N), 'E');\n+               Set_Statement_Entry;\n+\n+               --  If condition is present, then following statement is\n+               --  only executed if the condition evaluates to False.\n+\n+               if Present (Condition (N)) then\n+                  Current_Dominant := ('F', N);\n+               else\n+                  Current_Dominant := No_Dominant;\n+               end if;\n+\n+            --  Label, which breaks the current statement sequence, but the\n+            --  label itself is not included in the next statement sequence,\n+            --  since it generates no code.\n+\n+            when N_Label =>\n+               Set_Statement_Entry;\n+               Current_Dominant := No_Dominant;\n+\n+            --  Block statement, which breaks the current statement sequence\n+\n+            when N_Block_Statement =>\n+               Set_Statement_Entry;\n+               Traverse_Declarations_Or_Statements\n+                 (L => Declarations (N),\n+                  D => Current_Dominant);\n+               Traverse_Handled_Statement_Sequence\n+                 (N => Handled_Statement_Sequence (N),\n+                  D => Current_Dominant);\n+\n+            --  If statement, which breaks the current statement sequence,\n+            --  but we include the condition in the current sequence.\n+\n+            when N_If_Statement =>\n+               Current_Test := N;\n+               Extend_Statement_Sequence (N, 'I');\n+               Process_Decisions_Defer (Condition (N), 'I');\n+               Set_Statement_Entry;\n+\n+               --  Now we traverse the statements in the THEN part\n+\n+               Traverse_Declarations_Or_Statements\n+                 (L => Then_Statements (N),\n+                  D => ('T', N));\n+\n+               --  Loop through ELSIF parts if present\n+\n+               if Present (Elsif_Parts (N)) then\n                   declare\n-                     Cond : constant Node_Id :=\n-                              Condition (Entry_Body_Formal_Part (N));\n-                     Inner_Dominant : Dominant_Info := No_Dominant;\n-                  begin\n-                     Set_Statement_Entry;\n+                     Saved_Dominant : constant Dominant_Info :=\n+                                        Current_Dominant;\n \n-                     if Present (Cond) then\n-                        Process_Decisions_Defer (Cond, 'G');\n+                     Elif : Node_Id := First (Elsif_Parts (N));\n \n-                        --  For an entry body with a barrier, the entry body\n-                        --  is dominanted by a True evaluation of the barrier.\n+                  begin\n+                     while Present (Elif) loop\n \n-                        Inner_Dominant := ('T', N);\n-                     end if;\n+                        --  An Elsif is executed only if the previous test\n+                        --  got a FALSE outcome.\n \n-                     Traverse_Subprogram_Or_Task_Body (N, Inner_Dominant);\n-                  end;\n+                        Current_Dominant := ('F', Current_Test);\n \n-               --  Protected body\n+                        --  Now update current test information\n \n-               when N_Protected_Body =>\n-                  Set_Statement_Entry;\n-                  Traverse_Protected_Body (N);\n+                        Current_Test := Elif;\n \n-               --  Exit statement, which is an exit statement in the SCO sense,\n-               --  so it is included in the current statement sequence, but\n-               --  then it terminates this sequence. We also have to process\n-               --  any decisions in the exit statement expression.\n+                        --  We generate a statement sequence for the\n+                        --  construct \"ELSIF condition\", so that we have\n+                        --  a statement for the resulting decisions.\n \n-               when N_Exit_Statement =>\n-                  Extend_Statement_Sequence (N, ' ');\n-                  Process_Decisions_Defer (Condition (N), 'E');\n-                  Set_Statement_Entry;\n+                        Extend_Statement_Sequence (Elif, 'I');\n+                        Process_Decisions_Defer (Condition (Elif), 'I');\n+                        Set_Statement_Entry;\n \n-                  --  If condition is present, then following statement is\n-                  --  only executed if the condition evaluates to False.\n+                        --  An ELSIF part is never guaranteed to have\n+                        --  been executed, following statements are only\n+                        --  dominated by the initial IF statement.\n \n-                  if Present (Condition (N)) then\n-                     Current_Dominant := ('F', N);\n-                  else\n-                     Current_Dominant := No_Dominant;\n-                  end if;\n+                        Current_Dominant := Saved_Dominant;\n \n-               --  Label, which breaks the current statement sequence, but the\n-               --  label itself is not included in the next statement sequence,\n-               --  since it generates no code.\n+                        --  Traverse the statements in the ELSIF\n \n-               when N_Label =>\n-                  Set_Statement_Entry;\n-                  Current_Dominant := No_Dominant;\n+                        Traverse_Declarations_Or_Statements\n+                          (L => Then_Statements (Elif),\n+                           D => ('T', Elif));\n+                        Next (Elif);\n+                     end loop;\n+                  end;\n+               end if;\n \n-               --  Block statement, which breaks the current statement sequence\n+               --  Finally traverse the ELSE statements if present\n \n-               when N_Block_Statement =>\n-                  Set_Statement_Entry;\n-                  Traverse_Declarations_Or_Statements\n-                    (L => Declarations (N),\n-                     D => Current_Dominant);\n-                  Traverse_Handled_Statement_Sequence\n-                    (N => Handled_Statement_Sequence (N),\n-                     D => Current_Dominant);\n+               Traverse_Declarations_Or_Statements\n+                 (L => Else_Statements (N),\n+                  D => ('F', Current_Test));\n \n-               --  If statement, which breaks the current statement sequence,\n-               --  but we include the condition in the current sequence.\n+            --  CASE statement, which breaks the current statement sequence,\n+            --  but we include the expression in the current sequence.\n \n-               when N_If_Statement =>\n-                  Current_Test := N;\n-                  Extend_Statement_Sequence (N, Condition (N), 'I');\n-                  Process_Decisions_Defer (Condition (N), 'I');\n-                  Set_Statement_Entry;\n+            when N_Case_Statement =>\n+               Extend_Statement_Sequence (N, 'C');\n+               Process_Decisions_Defer (Expression (N), 'X');\n+               Set_Statement_Entry;\n \n-                  --  Now we traverse the statements in the THEN part\n+               --  Process case branches, all of which are dominated by the\n+               --  CASE statement.\n \n-                  Traverse_Declarations_Or_Statements\n-                    (L => Then_Statements (N),\n-                     D => ('T', N));\n+               declare\n+                  Alt : Node_Id;\n+               begin\n+                  Alt := First (Alternatives (N));\n+                  while Present (Alt) loop\n+                     Traverse_Declarations_Or_Statements\n+                       (L => Statements (Alt),\n+                        D => Current_Dominant);\n+                     Next (Alt);\n+                  end loop;\n+               end;\n \n-                  --  Loop through ELSIF parts if present\n+            --  ACCEPT statement\n \n-                  if Present (Elsif_Parts (N)) then\n-                     declare\n-                        Saved_Dominant : constant Dominant_Info :=\n-                                           Current_Dominant;\n-                        Elif : Node_Id := First (Elsif_Parts (N));\n+            when N_Accept_Statement =>\n+               Extend_Statement_Sequence (N, 'A');\n+               Set_Statement_Entry;\n \n-                     begin\n-                        while Present (Elif) loop\n+               --  Process sequence of statements, dominant is the ACCEPT\n+               --  statement.\n \n-                           --  An Elsif is executed only if the previous test\n-                           --  got a FALSE outcome.\n+               Traverse_Handled_Statement_Sequence\n+                 (N => Handled_Statement_Sequence (N),\n+                  D => Current_Dominant);\n \n-                           Current_Dominant := ('F', Current_Test);\n+            --  SELECT\n \n-                           --  Now update current test information\n+            when N_Selective_Accept =>\n+               Extend_Statement_Sequence (N, 'S');\n+               Set_Statement_Entry;\n \n-                           Current_Test := Elif;\n+               --  Process alternatives\n \n-                           --  We generate a statement sequence for the\n-                           --  construct \"ELSIF condition\", so that we have\n-                           --  a statement for the resulting decisions.\n+               declare\n+                  Alt   : Node_Id;\n+                  Guard : Node_Id;\n+                  S_Dom : Dominant_Info;\n+\n+               begin\n+                  Alt := First (Select_Alternatives (N));\n+                  while Present (Alt) loop\n+                     S_Dom := Current_Dominant;\n+                     Guard := Condition (Alt);\n+\n+                     if Present (Guard) then\n+                        Process_Decisions\n+                          (Guard,\n+                           'G',\n+                           Pragma_Sloc => No_Location);\n+                        Current_Dominant := ('T', Guard);\n+                     end if;\n \n-                           Extend_Statement_Sequence\n-                             (Elif, Condition (Elif), 'I');\n-                           Process_Decisions_Defer (Condition (Elif), 'I');\n-                           Set_Statement_Entry;\n+                     Traverse_One (Alt);\n \n-                           --  An ELSIF part is never guaranteed to have\n-                           --  been executed, following statements are only\n-                           --  dominated by the initial IF statement.\n+                     Current_Dominant := S_Dom;\n+                     Next (Alt);\n+                  end loop;\n+               end;\n \n-                           Current_Dominant := Saved_Dominant;\n+               Traverse_Declarations_Or_Statements\n+                 (L => Else_Statements (N),\n+                  D => Current_Dominant);\n \n-                           --  Traverse the statements in the ELSIF\n+            when N_Timed_Entry_Call | N_Conditional_Entry_Call =>\n+               Extend_Statement_Sequence (N, 'S');\n+               Set_Statement_Entry;\n \n-                           Traverse_Declarations_Or_Statements\n-                             (L => Then_Statements (Elif),\n-                              D => ('T', Elif));\n-                           Next (Elif);\n-                        end loop;\n-                     end;\n-                  end if;\n+               --  Process alternatives\n \n-                  --  Finally traverse the ELSE statements if present\n+               Traverse_One (Entry_Call_Alternative (N));\n \n+               if Nkind (N) = N_Timed_Entry_Call then\n+                  Traverse_One (Delay_Alternative (N));\n+               else\n                   Traverse_Declarations_Or_Statements\n                     (L => Else_Statements (N),\n-                     D => ('F', Current_Test));\n+                     D => Current_Dominant);\n+               end if;\n \n-               --  Case statement, which breaks the current statement sequence,\n-               --  but we include the expression in the current sequence.\n+            when N_Asynchronous_Select =>\n+               Extend_Statement_Sequence (N, 'S');\n+               Set_Statement_Entry;\n \n-               when N_Case_Statement =>\n-                  Extend_Statement_Sequence (N, Expression (N), 'C');\n-                  Process_Decisions_Defer (Expression (N), 'X');\n-                  Set_Statement_Entry;\n+               Traverse_One (Triggering_Alternative (N));\n+               Traverse_Declarations_Or_Statements\n+                 (L => Statements (Abortable_Part (N)),\n+                  D => Current_Dominant);\n \n-                  --  Process case branches, all of which are dominated by the\n-                  --  CASE statement.\n+            when N_Accept_Alternative =>\n+               Traverse_Declarations_Or_Statements\n+                 (L => Statements (N),\n+                  D => Current_Dominant,\n+                  P => Accept_Statement (N));\n \n-                  declare\n-                     Alt : Node_Id;\n-                  begin\n-                     Alt := First (Alternatives (N));\n-                     while Present (Alt) loop\n-                        Traverse_Declarations_Or_Statements\n-                          (L => Statements (Alt),\n-                           D => Current_Dominant);\n-                        Next (Alt);\n-                     end loop;\n-                  end;\n+            when N_Entry_Call_Alternative =>\n+               Traverse_Declarations_Or_Statements\n+                 (L => Statements (N),\n+                  D => Current_Dominant,\n+                  P => Entry_Call_Statement (N));\n+\n+            when N_Delay_Alternative =>\n+               Traverse_Declarations_Or_Statements\n+                 (L => Statements (N),\n+                  D => Current_Dominant,\n+                  P => Delay_Statement (N));\n \n-               --  Unconditional exit points, which are included in the current\n-               --  statement sequence, but then terminate it\n+            when N_Triggering_Alternative =>\n+               Traverse_Declarations_Or_Statements\n+                 (L => Statements (N),\n+                  D => Current_Dominant,\n+                  P => Triggering_Statement (N));\n \n-               when N_Requeue_Statement |\n-                    N_Goto_Statement    |\n-                    N_Raise_Statement   =>\n-                  Extend_Statement_Sequence (N, ' ');\n-                  Set_Statement_Entry;\n-                  Current_Dominant := No_Dominant;\n+            when N_Terminate_Alternative =>\n+               Extend_Statement_Sequence (N, ' ');\n+               Set_Statement_Entry;\n \n-               --  Simple return statement. which is an exit point, but we\n-               --  have to process the return expression for decisions.\n+            --  Unconditional exit points, which are included in the current\n+            --  statement sequence, but then terminate it\n \n-               when N_Simple_Return_Statement =>\n-                  Extend_Statement_Sequence (N, ' ');\n-                  Process_Decisions_Defer (Expression (N), 'X');\n-                  Set_Statement_Entry;\n-                  Current_Dominant := No_Dominant;\n+            when N_Requeue_Statement |\n+                 N_Goto_Statement    |\n+                 N_Raise_Statement   =>\n+               Extend_Statement_Sequence (N, ' ');\n+               Set_Statement_Entry;\n+               Current_Dominant := No_Dominant;\n \n-               --  Extended return statement\n+            --  Simple return statement. which is an exit point, but we\n+            --  have to process the return expression for decisions.\n \n-               when N_Extended_Return_Statement =>\n-                  Extend_Statement_Sequence\n-                    (N, Last (Return_Object_Declarations (N)), 'R');\n-                  Process_Decisions_Defer\n-                    (Return_Object_Declarations (N), 'X');\n-                  Set_Statement_Entry;\n+            when N_Simple_Return_Statement =>\n+               Extend_Statement_Sequence (N, ' ');\n+               Process_Decisions_Defer (Expression (N), 'X');\n+               Set_Statement_Entry;\n+               Current_Dominant := No_Dominant;\n \n-                  Traverse_Handled_Statement_Sequence\n-                    (N => Handled_Statement_Sequence (N),\n-                     D => Current_Dominant);\n+            --  Extended return statement\n \n-                  Current_Dominant := No_Dominant;\n+            when N_Extended_Return_Statement =>\n+               Extend_Statement_Sequence (N, 'R');\n+               Process_Decisions_Defer\n+                 (Return_Object_Declarations (N), 'X');\n+               Set_Statement_Entry;\n \n-               --  Loop ends the current statement sequence, but we include\n-               --  the iteration scheme if present in the current sequence.\n-               --  But the body of the loop starts a new sequence, since it\n-               --  may not be executed as part of the current sequence.\n+               Traverse_Handled_Statement_Sequence\n+                 (N => Handled_Statement_Sequence (N),\n+                  D => Current_Dominant);\n \n-               when N_Loop_Statement =>\n-                  declare\n-                     ISC            : constant Node_Id := Iteration_Scheme (N);\n-                     Inner_Dominant : Dominant_Info    := No_Dominant;\n+               Current_Dominant := No_Dominant;\n \n-                  begin\n-                     if Present (ISC) then\n+            --  Loop ends the current statement sequence, but we include\n+            --  the iteration scheme if present in the current sequence.\n+            --  But the body of the loop starts a new sequence, since it\n+            --  may not be executed as part of the current sequence.\n \n-                        --  If iteration scheme present, extend the current\n-                        --  statement sequence to include the iteration scheme\n-                        --  and process any decisions it contains.\n+            when N_Loop_Statement =>\n+               declare\n+                  ISC            : constant Node_Id := Iteration_Scheme (N);\n+                  Inner_Dominant : Dominant_Info    := No_Dominant;\n \n-                        --  While loop\n+               begin\n+                  if Present (ISC) then\n \n-                        if Present (Condition (ISC)) then\n-                           Extend_Statement_Sequence (N, ISC, 'W');\n-                           Process_Decisions_Defer (Condition (ISC), 'W');\n+                     --  If iteration scheme present, extend the current\n+                     --  statement sequence to include the iteration scheme\n+                     --  and process any decisions it contains.\n \n-                           --  Set more specific dominant for inner statements\n-                           --  (the control sloc for the decision is that of\n-                           --  the WHILE token).\n+                     --  While loop\n \n-                           Inner_Dominant := ('T', ISC);\n+                     if Present (Condition (ISC)) then\n+                        Extend_Statement_Sequence (N, 'W');\n+                        Process_Decisions_Defer (Condition (ISC), 'W');\n \n-                        --  For loop\n+                        --  Set more specific dominant for inner statements\n+                        --  (the control sloc for the decision is that of\n+                        --  the WHILE token).\n \n-                        else\n-                           Extend_Statement_Sequence (N, ISC, 'F');\n-                           Process_Decisions_Defer\n-                             (Loop_Parameter_Specification (ISC), 'X');\n-                        end if;\n-                     end if;\n+                        Inner_Dominant := ('T', ISC);\n \n-                     Set_Statement_Entry;\n+                     --  For loop\n \n-                     if Inner_Dominant = No_Dominant then\n-                        Inner_Dominant := Current_Dominant;\n+                     else\n+                        Extend_Statement_Sequence (N, 'F');\n+                        Process_Decisions_Defer\n+                          (Loop_Parameter_Specification (ISC), 'X');\n                      end if;\n+                  end if;\n \n-                     Traverse_Declarations_Or_Statements\n-                       (L => Statements (N),\n-                        D => Inner_Dominant);\n-                  end;\n+                  Set_Statement_Entry;\n \n-               --  Pragma\n+                  if Inner_Dominant = No_Dominant then\n+                     Inner_Dominant := Current_Dominant;\n+                  end if;\n \n-               when N_Pragma =>\n+                  Traverse_Declarations_Or_Statements\n+                    (L => Statements (N),\n+                     D => Inner_Dominant);\n+               end;\n \n-                  --  Record sloc of pragma (pragmas don't nest)\n+            --  Pragma\n \n-                  pragma Assert (Current_Pragma_Sloc = No_Location);\n-                  Current_Pragma_Sloc := Sloc (N);\n+            when N_Pragma =>\n \n-                  --  Processing depends on the kind of pragma\n+               --  Record sloc of pragma (pragmas don't nest)\n \n-                  declare\n-                     Nam : constant Name_Id := Pragma_Name (N);\n-                     Arg : Node_Id := First (Pragma_Argument_Associations (N));\n-                     Typ : Character;\n+               pragma Assert (Current_Pragma_Sloc = No_Location);\n+               Current_Pragma_Sloc := Sloc (N);\n \n-                  begin\n-                     case Nam is\n-                        when Name_Assert        |\n-                             Name_Check         |\n-                             Name_Precondition  |\n-                             Name_Postcondition =>\n-\n-                           --  For Assert/Check/Precondition/Postcondition, we\n-                           --  must generate a P entry for the decision. Note\n-                           --  that this is done unconditionally at this stage.\n-                           --  Output for disabled pragmas is suppressed later\n-                           --  on when we output the decision line in Put_SCOs,\n-                           --  depending on setting by Set_SCO_Pragma_Enabled.\n-\n-                           if Nam = Name_Check then\n-                              Next (Arg);\n-                           end if;\n+               --  Processing depends on the kind of pragma\n \n-                           Process_Decisions_Defer (Expression (Arg), 'P');\n-                           Typ := 'p';\n+               declare\n+                  Nam : constant Name_Id := Pragma_Name (N);\n+                  Arg : Node_Id          :=\n+                          First (Pragma_Argument_Associations (N));\n+                  Typ : Character;\n \n-                        when Name_Debug =>\n-                           if Present (Arg) and then Present (Next (Arg)) then\n+               begin\n+                  case Nam is\n+                     when Name_Assert        |\n+                          Name_Check         |\n+                          Name_Precondition  |\n+                          Name_Postcondition =>\n+\n+                        --  For Assert/Check/Precondition/Postcondition, we\n+                        --  must generate a P entry for the decision. Note\n+                        --  that this is done unconditionally at this stage.\n+                        --  Output for disabled pragmas is suppressed later\n+                        --  on when we output the decision line in Put_SCOs,\n+                        --  depending on setting by Set_SCO_Pragma_Enabled.\n+\n+                        if Nam = Name_Check then\n+                           Next (Arg);\n+                        end if;\n \n-                              --  Case of a dyadic pragma Debug: first argument\n-                              --  is a P decision, any nested decision in the\n-                              --  second argument is an X decision.\n+                        Process_Decisions_Defer (Expression (Arg), 'P');\n+                        Typ := 'p';\n \n-                              Process_Decisions_Defer (Expression (Arg), 'P');\n-                              Next (Arg);\n-                           end if;\n+                     when Name_Debug =>\n+                        if Present (Arg) and then Present (Next (Arg)) then\n \n-                           Process_Decisions_Defer (Expression (Arg), 'X');\n-                           Typ := 'p';\n+                           --  Case of a dyadic pragma Debug: first argument\n+                           --  is a P decision, any nested decision in the\n+                           --  second argument is an X decision.\n \n-                        --  For all other pragmas, we generate decision entries\n-                        --  for any embedded expressions, and the pragma is\n-                        --  never disabled.\n+                           Process_Decisions_Defer (Expression (Arg), 'P');\n+                           Next (Arg);\n+                        end if;\n \n-                        when others =>\n-                           Process_Decisions_Defer (N, 'X');\n-                           Typ := 'P';\n-                     end case;\n+                        Process_Decisions_Defer (Expression (Arg), 'X');\n+                        Typ := 'p';\n \n-                     --  Add statement SCO\n+                     --  For all other pragmas, we generate decision entries\n+                     --  for any embedded expressions, and the pragma is\n+                     --  never disabled.\n \n-                     Extend_Statement_Sequence (N, Typ);\n+                     when others =>\n+                        Process_Decisions_Defer (N, 'X');\n+                        Typ := 'P';\n+                  end case;\n \n-                     Current_Pragma_Sloc := No_Location;\n-                  end;\n+                  --  Add statement SCO\n \n-               --  Object declaration. Ignored if Prev_Ids is set, since the\n-               --  parser generates multiple instances of the whole declaration\n-               --  if there is more than one identifier declared, and we only\n-               --  want one entry in the SCO's, so we take the first, for which\n-               --  Prev_Ids is False.\n+                  Extend_Statement_Sequence (N, Typ);\n \n-               when N_Object_Declaration =>\n-                  if not Prev_Ids (N) then\n-                     Extend_Statement_Sequence (N, 'o');\n+                  Current_Pragma_Sloc := No_Location;\n+               end;\n \n-                     if Has_Decision (N) then\n-                        Process_Decisions_Defer (N, 'X');\n-                     end if;\n-                  end if;\n+            --  Object declaration. Ignored if Prev_Ids is set, since the\n+            --  parser generates multiple instances of the whole declaration\n+            --  if there is more than one identifier declared, and we only\n+            --  want one entry in the SCO's, so we take the first, for which\n+            --  Prev_Ids is False.\n \n-               --  All other cases, which extend the current statement sequence\n-               --  but do not terminate it, even if they have nested decisions.\n+            when N_Object_Declaration =>\n+               if not Prev_Ids (N) then\n+                  Extend_Statement_Sequence (N, 'o');\n \n-               when others =>\n+                  if Has_Decision (N) then\n+                     Process_Decisions_Defer (N, 'X');\n+                  end if;\n+               end if;\n \n-                  --  Determine required type character code, or ASCII.NUL if\n-                  --  no SCO should be generated for this node.\n+            --  All other cases, which extend the current statement sequence\n+            --  but do not terminate it, even if they have nested decisions.\n \n-                  declare\n-                     Typ : Character;\n+            when others =>\n \n-                  begin\n-                     case Nkind (N) is\n-                        when N_Full_Type_Declaration         |\n-                             N_Incomplete_Type_Declaration   |\n-                             N_Private_Type_Declaration      |\n-                             N_Private_Extension_Declaration =>\n-                           Typ := 't';\n+               --  Determine required type character code, or ASCII.NUL if\n+               --  no SCO should be generated for this node.\n \n-                        when N_Subtype_Declaration           =>\n-                           Typ := 's';\n+               declare\n+                  Typ : Character;\n \n-                        when N_Renaming_Declaration          =>\n-                           Typ := 'r';\n+               begin\n+                  case Nkind (N) is\n+                     when N_Full_Type_Declaration         |\n+                          N_Incomplete_Type_Declaration   |\n+                          N_Private_Type_Declaration      |\n+                          N_Private_Extension_Declaration =>\n+                        Typ := 't';\n \n-                        when N_Generic_Instantiation         =>\n-                           Typ := 'i';\n+                     when N_Subtype_Declaration           =>\n+                        Typ := 's';\n \n-                        when N_Representation_Clause         |\n-                             N_Use_Package_Clause            |\n-                             N_Use_Type_Clause               =>\n-                           Typ := ASCII.NUL;\n+                     when N_Renaming_Declaration          =>\n+                        Typ := 'r';\n \n-                        when others                          =>\n-                           Typ := ' ';\n-                     end case;\n+                     when N_Generic_Instantiation         =>\n+                        Typ := 'i';\n \n-                     if Typ /= ASCII.NUL then\n-                        Extend_Statement_Sequence (N, Typ);\n-                     end if;\n-                  end;\n+                     when N_Representation_Clause         |\n+                          N_Use_Package_Clause            |\n+                          N_Use_Type_Clause               =>\n+                        Typ := ASCII.NUL;\n \n-                  --  Process any embedded decisions\n+                     when others                          =>\n+                        Typ := ' ';\n+                  end case;\n \n-                  if Has_Decision (N) then\n-                     Process_Decisions_Defer (N, 'X');\n+                  if Typ /= ASCII.NUL then\n+                     Extend_Statement_Sequence (N, Typ);\n                   end if;\n-            end case;\n+               end;\n+\n+               --  Process any embedded decisions\n+\n+               if Has_Decision (N) then\n+                  Process_Decisions_Defer (N, 'X');\n+               end if;\n+         end case;\n+\n+      end Traverse_One;\n \n+   --  Start of processing for Traverse_Declarations_Or_Statements\n+\n+   begin\n+      if Present (P) then\n+         Traverse_One (P);\n+      end if;\n+\n+      if Is_Non_Empty_List (L) then\n+\n+         --  Loop through statements or declarations\n+\n+         N := First (L);\n+         while Present (N) loop\n+            Traverse_One (N);\n             Next (N);\n          end loop;\n "}, {"sha": "6b3dc2a0c4c4646623f2326b1c8faf2bb56f4244", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -541,10 +541,10 @@ package body Restrict is\n       then\n          null;\n \n-      --  Here if restriction set, check for violation (either this is a\n-      --  Boolean restriction, or a parameter restriction with a value of\n-      --  zero and an unknown count, or a parameter restriction with a\n-      --  known value that exceeds the restriction count).\n+      --  Here if restriction set, check for violation (this is a Boolean\n+      --  restriction, or a parameter restriction with a value of zero and an\n+      --  unknown count, or a parameter restriction with a known value that\n+      --  exceeds the restriction count).\n \n       elsif R in All_Boolean_Restrictions\n         or else (Restrictions.Unknown (R)\n@@ -768,7 +768,7 @@ package body Restrict is\n    ----------------------------------\n \n    --  Note: body of this function must be coordinated with list of\n-   --  renaming declarations in Rident.\n+   --  renaming declarations in System.Rident.\n \n    function Process_Restriction_Synonyms (N : Node_Id) return Name_Id\n    is"}, {"sha": "1d9d67f910e5f1f4d74c924478f1fa5b3d8c7fc0", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -332,10 +332,10 @@ package Restrict is\n    --  exception propagation is activated.\n \n    function Process_Restriction_Synonyms (N : Node_Id) return Name_Id;\n-   --  Id is a node whose Chars field contains the name of a restriction. If it\n-   --  is one of synonyms that we allow for historical purposes (for list see\n-   --  Rident), then the proper official name is returned. Otherwise the Chars\n-   --  field of the argument is returned unchanged.\n+   --  Id is a node whose Chars field contains the name of a restriction.\n+   --  If it is one of synonyms that we allow for historical purposes (for\n+   --  list see System.Rident), then the proper official name is returned.\n+   --  Otherwise the Chars field of the argument is returned unchanged.\n \n    function Restriction_Active (R : All_Restrictions) return Boolean;\n    pragma Inline (Restriction_Active);"}, {"sha": "615e17bfc78ed1bd47ae15994beb0473954450a0", "filename": "gcc/ada/rident.ads", "status": "modified", "additions": 10, "deletions": 410, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Frident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Frident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frident.ads?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -34,416 +34,16 @@\n --  it can be used by the binder without dragging in unneeded compiler\n --  packages.\n \n-package Rident is\n+--  Note: the actual definitions of the types are in package System.Rident,\n+--  and this package is merely an instantiation of that package. The point\n+--  of this level of generic indirection is to allow the compile time use\n+--  to have the image tables available (this package is not compiled with\n+--  Discard_Names), while at run-time we do not want those image tables.\n \n-   --  The following enumeration type defines the set of restriction\n-   --  identifiers that are implemented in GNAT.\n+--  Rather than have clients instantiate System.Rident directly, we have the\n+--  single instantiation here at the library level, which means that we only\n+--  have one copy of the image tables\n \n-   --  To add a new restriction identifier, add an entry with the name to be\n-   --  used in the pragma, and add calls to the Restrict.Check_Restriction\n-   --  routine as appropriate.\n+with System.Rident;\n \n-   type Restriction_Id is\n-\n-      --  The following cases are checked for consistency in the binder. The\n-      --  binder will check that every unit either has the restriction set, or\n-      --  does not violate the restriction.\n-\n-     (Simple_Barriers,                         -- GNAT (Ravenscar)\n-      No_Abort_Statements,                     -- (RM D.7(5), H.4(3))\n-      No_Access_Subprograms,                   -- (RM H.4(17))\n-      No_Allocators,                           -- (RM H.4(7))\n-      No_Allocators_After_Elaboration,         -- Ada 2012 (RM D.7(19.1/2))\n-      No_Anonymous_Allocators,                 -- Ada 2012 (RM H.4(8/1))\n-      No_Asynchronous_Control,                 -- (RM D.7(10))\n-      No_Calendar,                             -- GNAT\n-      No_Default_Stream_Attributes,            -- Ada 2012 (RM 13.12.1(4/2))\n-      No_Delay,                                -- (RM H.4(21))\n-      No_Direct_Boolean_Operators,             -- GNAT\n-      No_Dispatch,                             -- (RM H.4(19))\n-      No_Dispatching_Calls,                    -- GNAT\n-      No_Dynamic_Attachment,                   -- GNAT\n-      No_Dynamic_Priorities,                   -- (RM D.9(9))\n-      No_Enumeration_Maps,                     -- GNAT\n-      No_Entry_Calls_In_Elaboration_Code,      -- GNAT\n-      No_Entry_Queue,                          -- GNAT (Ravenscar)\n-      No_Exception_Handlers,                   -- GNAT\n-      No_Exception_Propagation,                -- GNAT\n-      No_Exception_Registration,               -- GNAT\n-      No_Exceptions,                           -- (RM H.4(12))\n-      No_Finalization,                         -- GNAT\n-      No_Fixed_Point,                          -- (RM H.4(15))\n-      No_Floating_Point,                       -- (RM H.4(14))\n-      No_IO,                                   -- (RM H.4(20))\n-      No_Implicit_Conditionals,                -- GNAT\n-      No_Implicit_Dynamic_Code,                -- GNAT\n-      No_Implicit_Heap_Allocations,            -- (RM D.8(8), H.4(3))\n-      No_Implicit_Loops,                       -- GNAT\n-      No_Initialize_Scalars,                   -- GNAT\n-      No_Local_Allocators,                     -- (RM H.4(8))\n-      No_Local_Timing_Events,                  -- (RM D.7(10.2/2))\n-      No_Local_Protected_Objects,              -- GNAT\n-      No_Nested_Finalization,                  -- (RM D.7(4))\n-      No_Protected_Type_Allocators,            -- GNAT\n-      No_Protected_Types,                      -- (RM H.4(5))\n-      No_Recursion,                            -- (RM H.4(22))\n-      No_Reentrancy,                           -- (RM H.4(23))\n-      No_Relative_Delay,                       -- GNAT (Ravenscar)\n-      No_Requeue_Statements,                   -- GNAT\n-      No_Secondary_Stack,                      -- GNAT\n-      No_Select_Statements,                    -- GNAT (Ravenscar)\n-      No_Specific_Termination_Handlers,        -- (RM D.7(10.7/2))\n-      No_Standard_Storage_Pools,               -- GNAT\n-      No_Stream_Optimizations,                 -- GNAT\n-      No_Streams,                              -- GNAT\n-      No_Task_Allocators,                      -- (RM D.7(7))\n-      No_Task_Attributes_Package,              -- GNAT\n-      No_Task_Hierarchy,                       -- (RM D.7(3), H.4(3))\n-      No_Task_Termination,                     -- GNAT (Ravenscar)\n-      No_Tasking,                              -- GNAT\n-      No_Terminate_Alternatives,               -- (RM D.7(6))\n-      No_Unchecked_Access,                     -- (RM H.4(18))\n-      No_Unchecked_Conversion,                 -- (RM H.4(16))\n-      No_Unchecked_Deallocation,               -- (RM H.4(9))\n-      Static_Priorities,                       -- GNAT\n-      Static_Storage_Size,                     -- GNAT\n-\n-      --  The following require consistency checking with special rules. See\n-      --  individual routines in unit Bcheck for details of what is required.\n-\n-      No_Default_Initialization,               -- GNAT\n-\n-      --  The following cases do not require consistency checking and if used\n-      --  as a configuration pragma within a specific unit, apply only to that\n-      --  unit (e.g. if used in the package spec, do not apply to the body)\n-\n-      --  Note: No_Elaboration_Code is handled specially. Like the other\n-      --  non-partition-wide restrictions, it can only be set in a unit that\n-      --  is part of the extended main source unit (body/spec/subunits). But\n-      --  it is sticky, in that if it is found anywhere within any of these\n-      --  units, it applies to all units in this extended main source.\n-\n-      Immediate_Reclamation,                   -- (RM H.4(10))\n-      No_Implementation_Aspect_Specifications, -- Ada 2012 AI-241\n-      No_Implementation_Attributes,            -- Ada 2005 AI-257\n-      No_Implementation_Identifiers,           -- Ada 2012 AI-246\n-      No_Implementation_Pragmas,               -- Ada 2005 AI-257\n-      No_Implementation_Restrictions,          -- GNAT\n-      No_Implementation_Units,                 -- Ada 2012 AI-242\n-      No_Implicit_Aliasing,                    -- GNAT\n-      No_Elaboration_Code,                     -- GNAT\n-      No_Obsolescent_Features,                 -- Ada 2005 AI-368\n-      No_Wide_Characters,                      -- GNAT\n-      SPARK,                                   -- GNAT\n-\n-      --  The following cases require a parameter value\n-\n-      --  The following entries are fully checked at compile/bind time, which\n-      --  means that the compiler can in general tell the minimum value which\n-      --  could be used with a restrictions pragma. The binder can deduce the\n-      --  appropriate minimum value for the partition by taking the maximum\n-      --  value required by any unit.\n-\n-      Max_Protected_Entries,                   -- (RM D.7(14))\n-      Max_Select_Alternatives,                 -- (RM D.7(12))\n-      Max_Task_Entries,                        -- (RM D.7(13), H.4(3))\n-\n-      --  The following entries are also fully checked at compile/bind time,\n-      --  and the compiler can also at least in some cases tell the minimum\n-      --  value which could be used with a restriction pragma. The difference\n-      --  is that the contributions are additive, so the binder deduces this\n-      --  value by adding the unit contributions.\n-\n-      Max_Tasks,                               -- (RM D.7(19), H.4(3))\n-\n-      --  The following entries are checked at compile time only for zero/\n-      --  nonzero entries. This means that the compiler can tell at compile\n-      --  time if a restriction value of zero is (would be) violated, but that\n-      --  the compiler cannot distinguish between different non-zero values.\n-\n-      Max_Asynchronous_Select_Nesting,         -- (RM D.7(18), H.4(3))\n-      Max_Entry_Queue_Length,                  -- GNAT\n-\n-      --  The remaining entries are not checked at compile/bind time\n-\n-      Max_Storage_At_Blocking,                 -- (RM D.7(17))\n-\n-      Not_A_Restriction_Id);\n-\n-   --  Synonyms permitted for historical purposes of compatibility.\n-   --  Must be coordinated with Restrict.Process_Restriction_Synonym.\n-\n-   Boolean_Entry_Barriers : Restriction_Id renames Simple_Barriers;\n-   Max_Entry_Queue_Depth  : Restriction_Id renames Max_Entry_Queue_Length;\n-   No_Dynamic_Interrupts  : Restriction_Id renames No_Dynamic_Attachment;\n-   No_Requeue             : Restriction_Id renames No_Requeue_Statements;\n-   No_Task_Attributes     : Restriction_Id renames No_Task_Attributes_Package;\n-\n-   subtype All_Restrictions is Restriction_Id range\n-     Simple_Barriers .. Max_Storage_At_Blocking;\n-   --  All restrictions (excluding only Not_A_Restriction_Id)\n-\n-   subtype All_Boolean_Restrictions is Restriction_Id range\n-     Simple_Barriers .. SPARK;\n-   --  All restrictions which do not take a parameter\n-\n-   subtype Partition_Boolean_Restrictions is All_Boolean_Restrictions range\n-     Simple_Barriers .. Static_Storage_Size;\n-   --  Boolean restrictions that are checked for partition consistency.\n-   --  Note that all parameter restrictions are checked for partition\n-   --  consistency by default, so this distinction is only needed in the\n-   --  case of Boolean restrictions.\n-\n-   subtype Cunit_Boolean_Restrictions is All_Boolean_Restrictions range\n-     Immediate_Reclamation .. SPARK;\n-   --  Boolean restrictions that are not checked for partition consistency\n-   --  and that thus apply only to the current unit. Note that for these\n-   --  restrictions, the compiler does not apply restrictions found in\n-   --  with'ed units, parent specs etc. to the main unit, and vice versa.\n-\n-   subtype All_Parameter_Restrictions is\n-     Restriction_Id range\n-       Max_Protected_Entries .. Max_Storage_At_Blocking;\n-   --  All restrictions that take a parameter\n-\n-   subtype Checked_Parameter_Restrictions is\n-     All_Parameter_Restrictions range\n-       Max_Protected_Entries .. Max_Entry_Queue_Length;\n-   --  These are the parameter restrictions that can be at least partially\n-   --  checked at compile/binder time. Minimally, the compiler can detect\n-   --  violations of a restriction pragma with a value of zero reliably.\n-\n-   subtype Checked_Max_Parameter_Restrictions is\n-     Checked_Parameter_Restrictions range\n-       Max_Protected_Entries .. Max_Task_Entries;\n-   --  Restrictions with parameters that can be checked in some cases by\n-   --  maximizing among statically detected instances where the compiler\n-   --  can determine the count.\n-\n-   subtype Checked_Add_Parameter_Restrictions is\n-     Checked_Parameter_Restrictions range\n-       Max_Tasks .. Max_Tasks;\n-   --  Restrictions with parameters that can be checked in some cases by\n-   --  summing the statically detected instances where the compiler can\n-   --  determine the count.\n-\n-   subtype Checked_Val_Parameter_Restrictions is\n-     Checked_Parameter_Restrictions range\n-       Max_Protected_Entries .. Max_Tasks;\n-   --  Restrictions with parameter where the count is known at least in some\n-   --  cases by the compiler/binder.\n-\n-   subtype Checked_Zero_Parameter_Restrictions is\n-     Checked_Parameter_Restrictions range\n-       Max_Asynchronous_Select_Nesting .. Max_Entry_Queue_Length;\n-   --  Restrictions with parameters where the compiler can detect the use of\n-   --  the feature, and hence violations of a restriction specifying a value\n-   --  of zero, but cannot detect specific values other than zero/nonzero.\n-\n-   subtype Unchecked_Parameter_Restrictions is\n-     All_Parameter_Restrictions range\n-       Max_Storage_At_Blocking .. Max_Storage_At_Blocking;\n-   --  Restrictions with parameters where the compiler cannot ever detect\n-   --  corresponding compile time usage, so the binder and compiler never\n-   --  detect violations of any restriction.\n-\n-   -------------------------------------\n-   -- Restriction Status Declarations --\n-   -------------------------------------\n-\n-   --  The following declarations are used to record the current status or\n-   --  restrictions (for the current unit, or related units, at compile time,\n-   --  and for all units in a partition at bind time or run time).\n-\n-   type Restriction_Flags  is array (All_Restrictions)           of Boolean;\n-   type Restriction_Values is array (All_Parameter_Restrictions) of Natural;\n-   type Parameter_Flags    is array (All_Parameter_Restrictions) of Boolean;\n-\n-   type Restrictions_Info is record\n-      Set : Restriction_Flags;\n-      --  An entry is True in the Set array if a restrictions pragma has been\n-      --  encountered for the given restriction. If the value is True for a\n-      --  parameter restriction, then the corresponding entry in the Value\n-      --  array gives the minimum value encountered for any such restriction.\n-\n-      Value : Restriction_Values;\n-      --  If the entry for a parameter restriction in Set is True (i.e. a\n-      --  restrictions pragma for the restriction has been encountered), then\n-      --  the corresponding entry in the Value array is the minimum value\n-      --  specified by any such restrictions pragma. Note that a restrictions\n-      --  pragma specifying a value greater than Int'Last is simply ignored.\n-\n-      Violated : Restriction_Flags;\n-      --  An entry is True in the violations array if the compiler has detected\n-      --  a violation of the restriction. For a parameter restriction, the\n-      --  Count and Unknown arrays have additional information.\n-\n-      Count : Restriction_Values;\n-      --  If an entry for a parameter restriction is True in Violated, the\n-      --  corresponding entry in the Count array may record additional\n-      --  information. If the actual minimum count is known (by taking\n-      --  maximums, or sums, depending on the restriction), it will be\n-      --  recorded in this array. If not, then the value will remain zero.\n-      --  The value is also zero for a non-violated restriction.\n-\n-      Unknown : Parameter_Flags;\n-      --  If an entry for a parameter restriction is True in Violated, the\n-      --  corresponding entry in the Unknown array may record additional\n-      --  information. If the actual count is not known by the compiler (but\n-      --  is known to be non-zero), then the entry in Unknown will be True.\n-      --  This indicates that the value in Count is not known to be exact,\n-      --  and the actual violation count may be higher.\n-\n-      --  Note: If Violated (K) is True, then either Count (K) > 0 or\n-      --  Unknown (K) = True. It is possible for both these to be set.\n-      --  For example, if Count (K) = 3 and Unknown (K) is True, it means\n-      --  that the actual violation count is at least 3 but might be higher.\n-   end record;\n-\n-   No_Restrictions : constant Restrictions_Info :=\n-     (Set      => (others => False),\n-      Value    => (others => 0),\n-      Violated => (others => False),\n-      Count    => (others => 0),\n-      Unknown  => (others => False));\n-   --  Used to initialize Restrictions_Info variables\n-\n-   ----------------------------------\n-   -- Profile Definitions and Data --\n-   ----------------------------------\n-\n-   --  Note: to add a profile, modify the following declarations appropriately,\n-   --  add Name_xxx to Snames, and add a branch to the conditions for pragmas\n-   --  Profile and Profile_Warnings in the body of Sem_Prag.\n-\n-   type Profile_Name is\n-     (No_Profile,\n-      No_Implementation_Extensions,\n-      Ravenscar,\n-      Restricted);\n-   --  Names of recognized profiles. No_Profile is used to indicate that a\n-   --  restriction came from pragma Restrictions[_Warning], as opposed to\n-   --  pragma Profile[_Warning].\n-\n-   subtype Profile_Name_Actual is Profile_Name\n-     range No_Implementation_Extensions .. Restricted;\n-   --  Actual used profile names\n-\n-   type Profile_Data is record\n-      Set : Restriction_Flags;\n-      --  Set to True if given restriction must be set for the profile, and\n-      --  False if it need not be set (False does not mean that it must not be\n-      --  set, just that it need not be set). If the flag is True for a\n-      --  parameter restriction, then the Value array gives the maximum value\n-      --  permitted by the profile.\n-\n-      Value : Restriction_Values;\n-      --  An entry in this array is meaningful only if the corresponding flag\n-      --  in Set is True. In that case, the value in this array is the maximum\n-      --  value of the parameter permitted by the profile.\n-   end record;\n-\n-   Profile_Info : constant array (Profile_Name_Actual) of Profile_Data :=\n-\n-                    (No_Implementation_Extensions =>\n-                        --  Restrictions for Restricted profile\n-\n-                       (Set   =>\n-                          (No_Implementation_Aspect_Specifications => True,\n-                           No_Implementation_Attributes            => True,\n-                           No_Implementation_Identifiers           => True,\n-                           No_Implementation_Pragmas               => True,\n-                           No_Implementation_Units                 => True,\n-                           others                                  => False),\n-\n-                        --  Value settings for Restricted profile (none\n-\n-                        Value =>\n-                          (others                          => 0)),\n-\n-                     --  Restricted Profile\n-\n-                     Restricted =>\n-\n-                        --  Restrictions for Restricted profile\n-\n-                       (Set   =>\n-                          (No_Abort_Statements             => True,\n-                           No_Asynchronous_Control         => True,\n-                           No_Dynamic_Attachment           => True,\n-                           No_Dynamic_Priorities           => True,\n-                           No_Entry_Queue                  => True,\n-                           No_Local_Protected_Objects      => True,\n-                           No_Protected_Type_Allocators    => True,\n-                           No_Requeue_Statements           => True,\n-                           No_Task_Allocators              => True,\n-                           No_Task_Attributes_Package      => True,\n-                           No_Task_Hierarchy               => True,\n-                           No_Terminate_Alternatives       => True,\n-                           Max_Asynchronous_Select_Nesting => True,\n-                           Max_Protected_Entries           => True,\n-                           Max_Select_Alternatives         => True,\n-                           Max_Task_Entries                => True,\n-                           others                          => False),\n-\n-                        --  Value settings for Restricted profile\n-\n-                        Value =>\n-                          (Max_Asynchronous_Select_Nesting => 0,\n-                           Max_Protected_Entries           => 1,\n-                           Max_Select_Alternatives         => 0,\n-                           Max_Task_Entries                => 0,\n-                           others                          => 0)),\n-\n-                     --  Ravenscar Profile\n-\n-                     --  Note: the table entries here only represent the\n-                     --  required restriction profile for Ravenscar. The\n-                     --  full Ravenscar profile also requires:\n-\n-                     --    pragma Dispatching_Policy (FIFO_Within_Priorities);\n-                     --    pragma Locking_Policy (Ceiling_Locking);\n-                     --    pragma Detect_Blocking\n-\n-                     Ravenscar  =>\n-\n-                     --  Restrictions for Ravenscar = Restricted profile ..\n-\n-                       (Set   =>\n-                          (No_Abort_Statements             => True,\n-                           No_Asynchronous_Control         => True,\n-                           No_Dynamic_Attachment           => True,\n-                           No_Dynamic_Priorities           => True,\n-                           No_Entry_Queue                  => True,\n-                           No_Local_Protected_Objects      => True,\n-                           No_Protected_Type_Allocators    => True,\n-                           No_Requeue_Statements           => True,\n-                           No_Task_Allocators              => True,\n-                           No_Task_Attributes_Package      => True,\n-                           No_Task_Hierarchy               => True,\n-                           No_Terminate_Alternatives       => True,\n-                           Max_Asynchronous_Select_Nesting => True,\n-                           Max_Protected_Entries           => True,\n-                           Max_Select_Alternatives         => True,\n-                           Max_Task_Entries                => True,\n-\n-                           --  plus these additional restrictions:\n-\n-                           No_Calendar                     => True,\n-                           No_Implicit_Heap_Allocations    => True,\n-                           No_Relative_Delay               => True,\n-                           No_Select_Statements            => True,\n-                           No_Task_Termination             => True,\n-                           Simple_Barriers                 => True,\n-                           others                          => False),\n-\n-                        --  Value settings for Ravenscar (same as Restricted)\n-\n-                        Value =>\n-                          (Max_Asynchronous_Select_Nesting => 0,\n-                           Max_Protected_Entries           => 1,\n-                           Max_Select_Alternatives         => 0,\n-                           Max_Task_Entries                => 0,\n-                           others                          => 0)));\n-\n-end Rident;\n+package Rident is new System.Rident;"}, {"sha": "ed5ca536e1364f2a840cb019abd5f01400c5c74f", "filename": "gcc/ada/s-atopri.adb", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fs-atopri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fs-atopri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atopri.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -30,14 +30,15 @@\n ------------------------------------------------------------------------------\n \n package body System.Atomic_Primitives is\n+\n    ---------------------------\n    -- Lock_Free_Try_Write_8 --\n    ---------------------------\n \n    function Lock_Free_Try_Write_8\n-      (Ptr       : Address;\n-       Expected  : in out uint8;\n-       Desired   : uint8) return Boolean\n+      (Ptr      : Address;\n+       Expected : in out uint8;\n+       Desired  : uint8) return Boolean\n    is\n       Actual : uint8;\n \n@@ -59,9 +60,9 @@ package body System.Atomic_Primitives is\n    ----------------------------\n \n    function Lock_Free_Try_Write_16\n-      (Ptr       : Address;\n-       Expected  : in out uint16;\n-       Desired   : uint16) return Boolean\n+      (Ptr      : Address;\n+       Expected : in out uint16;\n+       Desired  : uint16) return Boolean\n    is\n       Actual : uint16;\n \n@@ -83,9 +84,9 @@ package body System.Atomic_Primitives is\n    ----------------------------\n \n    function Lock_Free_Try_Write_32\n-      (Ptr       : Address;\n-       Expected  : in out uint32;\n-       Desired   : uint32) return Boolean\n+      (Ptr      : Address;\n+       Expected : in out uint32;\n+       Desired  : uint32) return Boolean\n    is\n       Actual : uint32;\n \n@@ -107,9 +108,9 @@ package body System.Atomic_Primitives is\n    ----------------------------\n \n    function Lock_Free_Try_Write_64\n-      (Ptr       : Address;\n-       Expected  : in out uint64;\n-       Desired   : uint64) return Boolean\n+      (Ptr      : Address;\n+       Expected : in out uint64;\n+       Desired  : uint64) return Boolean\n    is\n       Actual : uint64;\n "}, {"sha": "bc58806970568c78045c956963bbbd8c55809854", "filename": "gcc/ada/s-atopri.ads", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fs-atopri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fs-atopri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atopri.ads?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -152,24 +152,24 @@ package System.Atomic_Primitives is\n       (Atomic_Load_64 (Ptr, Acquire));\n \n    function Lock_Free_Try_Write_8\n-      (Ptr       : Address;\n-       Expected  : in out uint8;\n-       Desired   : uint8) return Boolean;\n+      (Ptr      : Address;\n+       Expected : in out uint8;\n+       Desired  : uint8) return Boolean;\n \n    function Lock_Free_Try_Write_16\n-      (Ptr       : Address;\n-       Expected  : in out uint16;\n-       Desired   : uint16) return Boolean;\n+      (Ptr      : Address;\n+       Expected : in out uint16;\n+       Desired  : uint16) return Boolean;\n \n    function Lock_Free_Try_Write_32\n-      (Ptr       : Address;\n-       Expected  : in out uint32;\n-       Desired   : uint32) return Boolean;\n+      (Ptr      : Address;\n+       Expected : in out uint32;\n+       Desired  : uint32) return Boolean;\n \n    function Lock_Free_Try_Write_64\n-      (Ptr       : Address;\n-       Expected  : in out uint64;\n-       Desired   : uint64) return Boolean;\n+      (Ptr      : Address;\n+       Expected : in out uint64;\n+       Desired  : uint64) return Boolean;\n \n    pragma Inline (Lock_Free_Read_8);\n    pragma Inline (Lock_Free_Read_16);"}, {"sha": "880a72915051788e17856e96c4794c5d9021e8ce", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -30,17 +30,44 @@\n ------------------------------------------------------------------------------\n \n --  This package defines the set of restriction identifiers. It is a generic\n---  package that is instantiated by the binder for output of the restrictions\n---  structure, and is instantiated in package System.Restrictions for use at\n---  run-time.\n+--  package that is instantiated by the compiler/binder in package Rident, and\n+--  is instantiated in package System.Restrictions for use at run-time.\n \n --  The reason that we make this a generic package is so that in the case of\n---  the instantiation in the binder, we can generate normal image tables for\n---  the enumeration types, which are needed for diagnostic and informational\n---  messages as well as for identification of restrictions. At run-time we\n---  really do not want to waste the space for these image tables, and they are\n---  not needed, so we can do the instantiation under control of Discard_Names\n---  to remove the tables.\n+--  the instantiation in Rident for use at compile time and bind time, we can\n+--  generate normal image tables for the enumeration types, which are needed\n+--  for diagnostic and informational messages. At run-time we really do not\n+--  want to waste the space for these image tables, and they are not needed,\n+--  so we can do the instantiation under control of Discard_Names to remove\n+--  the tables.\n+\n+---------------------------------------------------\n+-- Note On Compile/Run-Time Consistency Checking --\n+---------------------------------------------------\n+\n+--  This unit is with'ed by the run-time (to make System.Restrictions which is\n+--  used for run-time access to restriction information), by the compiler (to\n+--  determine what restrictions are implemented and what their category is) and\n+--  by the binder (in processing ali files, and generating the information used\n+--  at run-time to access restriction information).\n+\n+--  Normally the version of System.Rident referenced in all three contexts\n+--  should be the same. However, problems could arise in certain inconsistent\n+--  builds that used inconsistent versions of the compiler and run-time. This\n+--  sort of thing is not strictly correct, but it does arise when short-cuts\n+--  are taken in build procedures.\n+\n+--  Previously, this kind of inconsistency could cause a significant problem.\n+--  If versions of System.Rident accessed by the compiler and binder differed,\n+--  then the binder could fail to recognize the R (restrictions line) in the\n+--  ali file, leading to bind errors when restrictions were added or removed.\n+\n+--  The latest implementation avoids both this problem by using a named\n+--  scheme for recording restrictions, rather than a positional scheme which\n+--  fails completely if restrictions are added or subtracted. Now the worst\n+--  that happens at bind time in incosistent builds is that unrecognized\n+--  restrictions are ignored, and the consistency checking for restrictions\n+--  might be incomplete, which is no big deal.\n \n pragma Compiler_Unit;\n "}, {"sha": "9f478985284634be7ef5fe5ad2ec3ae2c42d9351", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -152,14 +152,16 @@ package SCOs is\n    --      o        object declaration\n    --      r        renaming declaration\n    --      i        generic instantiation\n-   --      C        CASE statement (from CASE through end of expression)\n+   --      A        ACCEPT statement (from ACCEPT to end of parameter profile)\n+   --      C        CASE statement (from CASE to end of expression)\n    --      E        EXIT statement\n-   --      F        FOR loop (from FOR through end of iteration scheme)\n-   --      I        IF statement (from IF through end of condition)\n+   --      F        FOR loop (from FOR to end of iteration scheme)\n+   --      I        IF statement (from IF to end of condition)\n    --      P[name:] PRAGMA with the indicated name\n    --      p[name:] disabled PRAGMA with the indicated name\n    --      R        extended RETURN statement\n-   --      W        WHILE loop statement (from WHILE through end of condition)\n+   --      S        SELECT statement\n+   --      W        WHILE loop statement (from WHILE to end of condition)\n \n    --      Note: for I and W, condition above is in the RM syntax sense (this\n    --      condition is a decision in SCO terminology)."}, {"sha": "ecec30f83782cc79d6cfe51bba52bbaee8b49ccb", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/727e7b1a870bdc057c4cb6d7d09ef1b56a84f222/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=727e7b1a870bdc057c4cb6d7d09ef1b56a84f222", "patch": "@@ -6254,7 +6254,7 @@ package body Sem_Prag is\n \n       --    Set Detect_Blocking mode\n \n-      --    Set required restrictions (see Rident for detailed list)\n+      --    Set required restrictions (see System.Rident for detailed list)\n \n       --    Set the No_Dependence rules\n       --      No_Dependence => Ada.Asynchronous_Task_Control"}]}