{"sha": "b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYxYjFmMTcwOGVkNTExNGJjNzUzZTU0YjRkM2IzYjkyZDk5NjQ5Yw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-01-19T16:05:57Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-01-19T16:05:57Z"}, "message": "re PR tree-optimization/41783 (r151561 (PRE fix) regresses zeusmp)\n\n\tPR tree-optimization/41783\n\t* tree-data-ref.c (toplevel): Include flags.h.\n\t(dump_data_dependence_relation):  Also dump the inputs if the\n\tresult will be unknown.\n\t(split_constant_offset_1): Look through some conversions.\n\t* tree-predcom.c (determine_roots_comp): Restart a new chain if\n\tthe offset from last element is too large.\n\t(ref_at_iteration): Deal also with MISALIGNED_INDIRECT_REF.\n\t(reassociate_to_the_same_stmt): Handle vector registers.\n\t* tree-vect-data-refs.c (vect_equal_offsets): Handle unary operations\n\t(e.g. conversions).\n\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop): Add \n\twide_prolog_niters argument, emit widening instructions.\n\t(vect_do_peeling_for_alignment): Adjust caller, use widened\n\tvariant of the iteration cound.\n\t* Makefile.in (tree-data-ref.o): Add $(FLAGS_H).\n\ntestsuite/\n\t* gfortran.dg/vect/fast-math-mgrid-resid.f: New.\n\nFrom-SVN: r156043", "tree": {"sha": "8b75ec9a7cd6dfed1c0f14f1e6f59e465852c3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b75ec9a7cd6dfed1c0f14f1e6f59e465852c3c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/comments", "author": null, "committer": null, "parents": [{"sha": "b3d7e1910fd9146716cc75a562bd59327c79ee58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d7e1910fd9146716cc75a562bd59327c79ee58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d7e1910fd9146716cc75a562bd59327c79ee58"}], "stats": {"total": 173, "additions": 154, "deletions": 19}, "files": [{"sha": "ca67d10d031c65194d058a4992e51c80cc2a3b2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -1,10 +1,29 @@\n+2010-01-19  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/41783\n+\t* tree-data-ref.c (toplevel): Include flags.h.\n+\t(dump_data_dependence_relation):  Also dump the inputs if the\n+\tresult will be unknown.\n+\t(split_constant_offset_1): Look through some conversions.\n+\t* tree-predcom.c (determine_roots_comp): Restart a new chain if\n+\tthe offset from last element is too large.\n+\t(ref_at_iteration): Deal also with MISALIGNED_INDIRECT_REF.\n+\t(reassociate_to_the_same_stmt): Handle vector registers.\n+\t* tree-vect-data-refs.c (vect_equal_offsets): Handle unary operations\n+\t(e.g. conversions).\n+\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop): Add \n+\twide_prolog_niters argument, emit widening instructions.\n+\t(vect_do_peeling_for_alignment): Adjust caller, use widened\n+\tvariant of the iteration cound.\n+\t* Makefile.in (tree-data-ref.o): Add $(FLAGS_H).\n+\n 2010-01-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n-       PR target/38697\n-       * config/arm/neon-testgen.m (emit_automatics): New parameter\n+\tPR target/38697\n+\t* config/arm/neon-testgen.m (emit_automatics): New parameter\n \tfeatures. Adjust for Fixed_return_reg feature.\n \t(test_intrinsic): Call emit_automatics with new feature.\n-       * config/arm/neon.ml: Update copyright years.\n+\t* config/arm/neon.ml: Update copyright years.\n \t(features): New Fixed_return_reg feature.\n \t(ops): Update feature for Vget_low.\n "}, {"sha": "7c08ea2a4de20801c2affdb7869abe9ccc9adc7c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -2548,7 +2548,7 @@ tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TIMEVAR_H) $(CFGLOOP_H) $(SCEV_H) $(TREE_PASS_H) $(FLAGS_H) \\\n    gt-tree-scalar-evolution.h\n tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n+   $(GGC_H) $(FLAGS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(TREE_PASS_H) langhooks.h\n sese.o: sese.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "58666a60a77230a1b54c0cb2d1f956913b822d4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -1,3 +1,8 @@\n+2010-01-19  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/41783\n+\t* gfortran.dg/vect/fast-math-mgrid-resid.f: New.\n+\n 2010-01-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/38697."}, {"sha": "2d1844b367a2700f345678906905c79fae26f2c4", "filename": "gcc/testsuite/gfortran.dg/vect/fast-math-mgrid-resid.f", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-mgrid-resid.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-mgrid-resid.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Ffast-math-mgrid-resid.f?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_double }\n+! { dg-options \"-O3 -ffast-math -fpredictive-commoning -ftree-vectorize -fdump-tree-optimized\" }\n+\n+******* RESID COMPUTES THE RESIDUAL:  R = V - AU\n+*\n+*      THIS SIMPLE IMPLEMENTATION COSTS  27A + 4M PER RESULT, WHERE\n+*      A AND M DENOTE THE COSTS OF ADDITION (OR SUBTRACTION) AND \n+*      MULTIPLICATION, RESPECTIVELY.  BY USING SEVERAL TWO-DIMENSIONAL \n+*      BUFFERS ONE CAN REDUCE THIS COST TO  13A + 4M IN THE GENERAL \n+*      CASE, OR  10A + 3M WHEN THE COEFFICIENT A(1) IS ZERO.\n+*\n+      SUBROUTINE RESID(U,V,R,N,A)\n+      INTEGER N\n+      REAL*8 U(N,N,N),V(N,N,N),R(N,N,N),A(0:3)\n+      INTEGER I3, I2, I1\n+C\n+      DO 600 I3=2,N-1\n+      DO 600 I2=2,N-1\n+      DO 600 I1=2,N-1\n+ 600  R(I1,I2,I3)=V(I1,I2,I3)\n+     >      -A(0)*( U(I1,  I2,  I3  ) )\n+     >      -A(1)*( U(I1-1,I2,  I3  ) + U(I1+1,I2,  I3  )\n+     >                 +  U(I1,  I2-1,I3  ) + U(I1,  I2+1,I3  )\n+     >                 +  U(I1,  I2,  I3-1) + U(I1,  I2,  I3+1) )\n+     >      -A(2)*( U(I1-1,I2-1,I3  ) + U(I1+1,I2-1,I3  )\n+     >                 +  U(I1-1,I2+1,I3  ) + U(I1+1,I2+1,I3  )\n+     >                 +  U(I1,  I2-1,I3-1) + U(I1,  I2+1,I3-1)\n+     >                 +  U(I1,  I2-1,I3+1) + U(I1,  I2+1,I3+1)\n+     >                 +  U(I1-1,I2,  I3-1) + U(I1-1,I2,  I3+1)\n+     >                 +  U(I1+1,I2,  I3-1) + U(I1+1,I2,  I3+1) )\n+     >      -A(3)*( U(I1-1,I2-1,I3-1) + U(I1+1,I2-1,I3-1)\n+     >                 +  U(I1-1,I2+1,I3-1) + U(I1+1,I2+1,I3-1)\n+     >                 +  U(I1-1,I2-1,I3+1) + U(I1+1,I2-1,I3+1)\n+     >                 +  U(I1-1,I2+1,I3+1) + U(I1+1,I2+1,I3+1) )\n+C\n+      RETURN\n+      END\n+! we want to check that predictive commoning did something on the\n+! vectorized loop, which means we have to have exactly 13 vector\n+! additions.\n+! { dg-final { scan-tree-dump-times \"vect_var\\[^\\\\n\\]*\\\\+ \" 13 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"vect\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "9f5a623b2fa9e161b85f7c0c6acfe9a0abe014d4", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n+#include \"flags.h\"\n #include \"tree.h\"\n \n /* These RTL headers are needed for basic-block.h.  */\n@@ -380,6 +381,19 @@ dump_data_dependence_relation (FILE *outf,\n \n   if (!ddr || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n+      if (ddr)\n+\t{\n+\t  dra = DDR_A (ddr);\n+\t  drb = DDR_B (ddr);\n+\t  if (dra)\n+\t    dump_data_reference (outf, dra);\n+\t  else\n+\t    fprintf (outf, \"    (nil)\\n\");\n+\t  if (drb)\n+\t    dump_data_reference (outf, drb);\n+\t  else\n+\t    fprintf (outf, \"    (nil)\\n\");\n+\t}\n       fprintf (outf, \"    (don't know)\\n)\\n\");\n       return;\n     }\n@@ -631,6 +645,24 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \n \treturn split_constant_offset_1 (type, var0, subcode, var1, var, off);\n       }\n+    CASE_CONVERT:\n+      {\n+\t/* We must not introduce undefined overflow, and we must not change the value.\n+\t   Hence we're okay if the inner type doesn't overflow to start with\n+\t   (pointer or signed), the outer type also is an integer or pointer\n+\t   and the outer precision is at least as large as the inner.  */\n+\ttree itype = TREE_TYPE (op0);\n+\tif ((POINTER_TYPE_P (itype)\n+\t     || (INTEGRAL_TYPE_P (itype) && TYPE_OVERFLOW_UNDEFINED (itype)))\n+\t    && TYPE_PRECISION (type) >= TYPE_PRECISION (itype)\n+\t    && (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type)))\n+\t  {\n+\t    split_constant_offset (op0, &var0, off);\n+\t    *var = fold_convert (type, var0);\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n \n     default:\n       return false;"}, {"sha": "f31c39203667dce87fcf9c05283144dd3ccdc548", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -1180,6 +1180,7 @@ determine_roots_comp (struct loop *loop,\n   unsigned i;\n   dref a;\n   chain_p chain = NULL;\n+  double_int last_ofs = double_int_zero;\n \n   /* Invariants are handled specially.  */\n   if (comp->comp_step == RS_INVARIANT)\n@@ -1194,13 +1195,20 @@ determine_roots_comp (struct loop *loop,\n \n   for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n     {\n-      if (!chain || !DR_IS_READ (a->ref))\n+      if (!chain || !DR_IS_READ (a->ref)\n+\t  || double_int_ucmp (uhwi_to_double_int (MAX_DISTANCE),\n+\t\t\t      double_int_add (a->offset,\n+\t\t\t\t\t      double_int_neg (last_ofs))) <= 0)\n \t{\n \t  if (nontrivial_chain_p (chain))\n-\t    VEC_safe_push (chain_p, heap, *chains, chain);\n+\t    {\n+\t      add_looparound_copies (loop, chain);\n+\t      VEC_safe_push (chain_p, heap, *chains, chain);\n+\t    }\n \t  else\n \t    release_chain (chain);\n \t  chain = make_rooted_chain (a);\n+\t  last_ofs = a->offset;\n \t  continue;\n \t}\n \n@@ -1338,9 +1346,11 @@ ref_at_iteration (struct loop *loop, tree ref, int iter)\n   else if (!INDIRECT_REF_P (ref))\n     return unshare_expr (ref);\n \n-  if (TREE_CODE (ref) == INDIRECT_REF)\n+  if (INDIRECT_REF_P (ref))\n     {\n-      ret = build1 (INDIRECT_REF, TREE_TYPE (ref), NULL_TREE);\n+      /* Take care for INDIRECT_REF and MISALIGNED_INDIRECT_REF at\n+         the same time.  */\n+      ret = copy_node (ref);\n       idx = TREE_OPERAND (ref, 0);\n       idx_p = &TREE_OPERAND (ret, 0);\n     }\n@@ -2205,11 +2215,17 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n   /* Insert the new statement combining NAME1 and NAME2 before S1, and\n      combine it with the rhs of S1.  */\n   var = create_tmp_var (type, \"predreastmp\");\n+  if (TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (var) = 1;\n   add_referenced_var (var);\n   new_name = make_ssa_name (var, NULL);\n   new_stmt = gimple_build_assign_with_ops (code, new_name, name1, name2);\n \n   var = create_tmp_var (type, \"predreastmp\");\n+  if (TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (var) = 1;\n   add_referenced_var (var);\n   tmp_name = make_ssa_name (var, NULL);\n "}, {"sha": "37ae9b5e3bf94153b4217c81196be4e968fe05e3", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -294,7 +294,7 @@ vect_update_interleaving_chain (struct data_reference *drb,\n static bool\n vect_equal_offsets (tree offset1, tree offset2)\n {\n-  bool res0, res1;\n+  bool res;\n \n   STRIP_NOPS (offset1);\n   STRIP_NOPS (offset2);\n@@ -303,16 +303,19 @@ vect_equal_offsets (tree offset1, tree offset2)\n     return true;\n \n   if (TREE_CODE (offset1) != TREE_CODE (offset2)\n-      || !BINARY_CLASS_P (offset1)\n-      || !BINARY_CLASS_P (offset2))\n+      || (!BINARY_CLASS_P (offset1) && !UNARY_CLASS_P (offset1)))\n     return false;\n \n-  res0 = vect_equal_offsets (TREE_OPERAND (offset1, 0),\n-\t\t\t     TREE_OPERAND (offset2, 0));\n-  res1 = vect_equal_offsets (TREE_OPERAND (offset1, 1),\n-\t\t\t     TREE_OPERAND (offset2, 1));\n+  res = vect_equal_offsets (TREE_OPERAND (offset1, 0),\n+\t\t\t    TREE_OPERAND (offset2, 0));\n \n-  return (res0 && res1);\n+  if (!res || !BINARY_CLASS_P (offset1))\n+    return res;\n+\n+  res = vect_equal_offsets (TREE_OPERAND (offset1, 1),\n+\t\t\t    TREE_OPERAND (offset2, 1));\n+\n+  return res;\n }\n \n "}, {"sha": "f4056b058912091abc85adf92a79d76b1db91e5b", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61b1f1708ed5114bc753e54b4d3b3b92d99649c/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b61b1f1708ed5114bc753e54b4d3b3b92d99649c", "patch": "@@ -1961,7 +1961,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n    use TYPE_VECTOR_SUBPARTS.  */\n \n static tree\n-vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n+vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n+\t\t\t\t tree *wide_prolog_niters)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -2045,6 +2046,19 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   add_referenced_var (var);\n   stmts = NULL;\n   iters_name = force_gimple_operand (iters, &stmts, false, var);\n+  if (types_compatible_p (sizetype, niters_type))\n+    *wide_prolog_niters = iters_name;\n+  else\n+    {\n+      gimple_seq seq = NULL;\n+      tree wide_iters = fold_convert (sizetype, iters);\n+      var = create_tmp_var (sizetype, \"prolog_loop_niters\");\n+      add_referenced_var (var);\n+      *wide_prolog_niters = force_gimple_operand (wide_iters, &seq, false,\n+\t\t\t\t\t\t  var);\n+      if (seq)\n+\tgimple_seq_add_seq (&stmts, seq);\n+    }\n \n   /* Insert stmt on loop preheader edge.  */\n   if (stmts)\n@@ -2115,6 +2129,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop, ni_name;\n   tree n_iters;\n+  tree wide_prolog_niters;\n   struct loop *new_loop;\n   unsigned int th = 0;\n   int min_profitable_iters;\n@@ -2125,7 +2140,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   initialize_original_copy_tables ();\n \n   ni_name = vect_build_loop_niters (loop_vinfo, NULL);\n-  niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name);\n+  niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name,\n+\t\t\t\t\t\t\t   &wide_prolog_niters);\n \n \n   /* Get profitability threshold for vectorized loop.  */\n@@ -2150,7 +2166,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n \t\tTREE_TYPE (n_iters), n_iters, niters_of_prolog_loop);\n \n   /* Update the init conditions of the access functions of all data refs.  */\n-  vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);\n+  vect_update_inits_of_drs (loop_vinfo, wide_prolog_niters);\n \n   /* After peeling we have to reset scalar evolution analyzer.  */\n   scev_reset ();"}]}