{"sha": "c34db4b6f8a5d80367c709309f9b00cb32630054", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0ZGI0YjZmOGE1ZDgwMzY3YzcwOTMwOWY5YjAwY2IzMjYzMDA1NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-03T15:20:16Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-03T15:20:16Z"}, "message": "Track access ranges in ipa-modref\n\nthis patch implements tracking of access ranges.  This is only applied when\nbase pointer is an arugment. Incrementally i will extend it to also track\nTBAA basetype so we can disambiguate ranges for accesses to same basetype\n(which makes is quite bit more effective). For this reason i track the access\noffset separately from parameter offset (the second track combined adjustments\nto the parameter). This is I think last feature I would like to add to the\nmemory access summary this stage1.\n\nFurther work will be needed to opitmize the summary and merge adjacent\nrange/make collapsing more intelingent (so we do not lose track that often),\nbut I wanted to keep basic patch simple.\n\nAccording to the cc1plus stats:\n\nAlias oracle query stats:\n  refs_may_alias_p: 64108082 disambiguations, 74386675 queries\n  ref_maybe_used_by_call_p: 142319 disambiguations, 65004781 queries\n  call_may_clobber_ref_p: 23587 disambiguations, 29420 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 38117 queries\n  nonoverlapping_refs_since_match_p: 19489 disambiguations, 55748 must overlaps, 76044 queries\n  aliasing_component_refs_p: 54763 disambiguations, 755876 queries\n  TBAA oracle: 24184658 disambiguations 56823187 queries\n               16260329 are in alias set 0\n               10617146 queries asked about the same object\n               125 queries asked about the same alias set\n               0 access volatile\n               3960555 are dependent in the DAG\n               1800374 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 10656 disambiguations, 47037 queries\n  modref clobber: 1473322 disambiguations, 1961464 queries\n  5027242 tbaa queries (2.563005 per modref query)\n  649087 base compares (0.330920 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 977385 disambiguations, 13609749 queries\n  pt_solutions_intersect: 1032703 disambiguations, 13187507 queries\n\nWhich should still compare with\nhttps://gcc.gnu.org/pipermail/gcc-patches/2020-September/554930.html\nthere is about 2% more load disambiguations and 3.6% more store that is not\ngreat, but the TBAA part helps noticeably more and also this should help\nwith -fno-strict-aliasing.\n\nI plan to work on improving param tracking too.\n\nBootstrapped/regtested x86_64-linux with the other changes, OK?\n\n2020-10-02  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.c (test_insert_search_collapse): Update andling\n\tof accesses.\n\t(test_merge): Likewise.\n\t* ipa-modref-tree.h (struct modref_access_node): Add offset, size,\n\tmax_size, parm_offset and parm_offset_known.\n\t(modref_access_node::useful_p): Constify.\n\t(modref_access_node::range_info_useful_p): New predicate.\n\t(modref_access_node::operator==): New.\n\t(struct modref_parm_map): New structure.\n\t(modref_tree::merge): Update for racking parameters)\n\t* ipa-modref.c (dump_access): Dump new fields.\n\t(get_access): Fill in new fields.\n\t(merge_call_side_effects): Update handling of parm map.\n\t(write_modref_records): Stream new fields.\n\t(read_modref_records): Stream new fields.\n\t(compute_parm_map): Update for new parm map.\n\t(ipa_merge_modref_summary_after_inlining): Update.\n\t(modref_propagate_in_scc): Update.\n\t* tree-ssa-alias.c (modref_may_conflict): Handle known ranges.", "tree": {"sha": "3979a06e5a7afbd74ad4c70342296efcd71c2029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3979a06e5a7afbd74ad4c70342296efcd71c2029"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34db4b6f8a5d80367c709309f9b00cb32630054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34db4b6f8a5d80367c709309f9b00cb32630054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34db4b6f8a5d80367c709309f9b00cb32630054", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34db4b6f8a5d80367c709309f9b00cb32630054/comments", "author": null, "committer": null, "parents": [{"sha": "8510e3301bd519352fc20876da8994f68a0c7e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8510e3301bd519352fc20876da8994f68a0c7e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8510e3301bd519352fc20876da8994f68a0c7e93"}], "stats": {"total": 220, "additions": 186, "deletions": 34}, "files": [{"sha": "1a595090b6c70fbc0d28aa5874e13276abdb1089", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=c34db4b6f8a5d80367c709309f9b00cb32630054", "patch": "@@ -35,7 +35,7 @@ test_insert_search_collapse ()\n {\n   modref_base_node<alias_set_type> *base_node;\n   modref_ref_node<alias_set_type> *ref_node;\n-  modref_access_node a = { -1 };\n+  modref_access_node a = unspecified_modref_access_node;\n \n   modref_tree<alias_set_type> *t = new modref_tree<alias_set_type>(1, 2, 2);\n   ASSERT_FALSE (t->every_base);\n@@ -118,7 +118,7 @@ test_merge ()\n {\n   modref_tree<alias_set_type> *t1, *t2;\n   modref_base_node<alias_set_type> *base_node;\n-  modref_access_node a = { -1 };\n+  modref_access_node a = unspecified_modref_access_node;\n \n   t1 = new modref_tree<alias_set_type>(3, 4, 1);\n   t1->insert (1, 1, a);"}, {"sha": "b37280d18c7caac8d7496b7ca6cd93ee9b0e8fb0", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=c34db4b6f8a5d80367c709309f9b00cb32630054", "patch": "@@ -44,17 +44,56 @@ struct ipa_modref_summary;\n /* Memory access.  */\n struct GTY(()) modref_access_node\n {\n+\n+  /* Access range information (in bits).  */\n+  poly_int64 offset;\n+  poly_int64 size;\n+  poly_int64 max_size;\n+\n+  /* Offset from parmeter pointer to the base of the access (in bytes).  */\n+  poly_int64 parm_offset;\n+\n   /* Index of parameter which specifies the base of access. -1 if base is not\n      a function parameter.  */\n   int parm_index;\n+  bool parm_offset_known;\n \n   /* Return true if access node holds no useful info.  */\n-  bool useful_p ()\n+  bool useful_p () const\n     {\n       return parm_index != -1;\n     }\n+  /* Return true if range info is useful.  */\n+  bool range_info_useful_p () const\n+    {\n+      return parm_index != -1 && parm_offset_known;\n+    }\n+  /* Return true if both accesses are the same.  */\n+  bool operator == (modref_access_node &a) const\n+    {\n+      if (parm_index != a.parm_index)\n+\treturn false;\n+      if (parm_index >= 0)\n+\t{\n+\t  if (parm_offset_known != a.parm_offset_known)\n+\t    return false;\n+\t  if (parm_offset_known\n+\t      && !known_eq (parm_offset, a.parm_offset))\n+\t    return false;\n+\t}\n+      if (range_info_useful_p ()\n+\t  && (!known_eq (a.offset, offset)\n+\t      || !known_eq (a.size, size)\n+\t      || !known_eq (a.max_size, max_size)))\n+\treturn false;\n+      return true;\n+    }\n };\n \n+/* Access node specifying no useful info.  */\n+const modref_access_node unspecified_modref_access_node\n+\t\t = {0, -1, -1, 0, -1, false};\n+\n template <typename T>\n struct GTY((user)) modref_ref_node\n {\n@@ -74,7 +113,7 @@ struct GTY((user)) modref_ref_node\n     size_t i;\n     modref_access_node *a;\n     FOR_EACH_VEC_SAFE_ELT (accesses, i, a)\n-      if (a->parm_index == access.parm_index)\n+      if (*a == access)\n \treturn a;\n     return NULL;\n   }\n@@ -195,6 +234,19 @@ struct GTY((user)) modref_base_node\n   }\n };\n \n+/* Map translating parameters across function call.  */\n+\n+struct modref_parm_map\n+{\n+  /* Index of parameter we translate to.\n+     -1 indicates that parameter is unknown\n+     -2 indicates that parmaeter points to local memory and access can be\n+\tdiscarded.  */\n+  int parm_index;\n+  bool parm_offset_known;\n+  poly_int64 parm_offset;\n+};\n+\n /* Access tree for a single function.  */\n template <typename T>\n struct GTY((user)) modref_tree\n@@ -363,7 +415,7 @@ struct GTY((user)) modref_tree\n      PARM_MAP, if non-NULL, maps parm indexes of callee to caller.  -2 is used\n      to signalize that parameter is local and does not need to be tracked.\n      Return true if something has changed.  */\n-  bool merge (modref_tree <T> *other, vec <int> *parm_map)\n+  bool merge (modref_tree <T> *other, vec <modref_parm_map> *parm_map)\n   {\n     if (!other || every_base)\n       return false;\n@@ -406,21 +458,31 @@ struct GTY((user)) modref_tree\n \t    {\n \t      if (ref_node->every_access)\n \t\t{\n-\t\t  modref_access_node a = {-1};\n-\t\t  changed |= insert (base_node->base, ref_node->ref, a);\n+\t\t  changed |= insert (base_node->base,\n+\t\t\t\t     ref_node->ref,\n+\t\t\t\t     unspecified_modref_access_node);\n \t\t}\n \t      else\n \t\tFOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n \t\t  {\n \t\t    modref_access_node a = *access_node;\n+\n \t\t    if (a.parm_index != -1 && parm_map)\n \t\t      {\n \t\t\tif (a.parm_index >= (int)parm_map->length ())\n \t\t\t  a.parm_index = -1;\n-\t\t\telse if ((*parm_map) [a.parm_index] == -2)\n+\t\t\telse if ((*parm_map) [a.parm_index].parm_index == -2)\n \t\t\t  continue;\n \t\t\telse\n-\t\t\t  a.parm_index = (*parm_map) [a.parm_index];\n+\t\t\t  {\n+\t\t\t    a.parm_offset\n+\t\t\t\t += (*parm_map) [a.parm_index].parm_offset;\n+\t\t\t    a.parm_offset_known\n+\t\t\t\t &= (*parm_map)\n+\t\t\t\t\t [a.parm_index].parm_offset_known;\n+\t\t\t    a.parm_index\n+\t\t\t\t = (*parm_map) [a.parm_index].parm_index;\n+\t\t\t  }\n \t\t      }\n \t\t    changed |= insert (base_node->base, ref_node->ref, a);\n \t\t  }"}, {"sha": "a5fa33a35de04152474ab9317eed42184ea25ad7", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 82, "deletions": 20, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=c34db4b6f8a5d80367c709309f9b00cb32630054", "patch": "@@ -143,7 +143,26 @@ modref_summary::useful_p (int ecf_flags)\n static void\n dump_access (modref_access_node *a, FILE *out)\n {\n-   fprintf (out, \"          Parm %i\\n\", a->parm_index);\n+  fprintf (out, \"          access:\");\n+  if (a->parm_index != -1)\n+    {\n+      fprintf (out, \" Parm %i\", a->parm_index);\n+      if (a->parm_offset_known)\n+\t{\n+\t  fprintf (out, \" param offset:\");\n+\t  print_dec ((poly_int64_pod)a->parm_offset, out, SIGNED);\n+\t}\n+    }\n+  if (a->range_info_useful_p ())\n+    {\n+      fprintf (out, \" offset:\");\n+      print_dec ((poly_int64_pod)a->offset, out, SIGNED);\n+      fprintf (out, \" size:\");\n+      print_dec ((poly_int64_pod)a->size, out, SIGNED);\n+      fprintf (out, \" max_size:\");\n+      print_dec ((poly_int64_pod)a->max_size, out, SIGNED);\n+    }\n+  fprintf (out, \"\\n\");\n }\n \n /* Dump records TT to OUT.  */\n@@ -292,14 +311,15 @@ get_modref_function_summary (cgraph_node *func)\n static modref_access_node\n get_access (ao_ref *ref)\n {\n-  modref_access_node a;\n   tree base;\n \n-  base = ref->ref;\n-  while (handled_component_p (base))\n-    base = TREE_OPERAND (base, 0);\n+  base = ao_ref_base (ref);\n+  modref_access_node a = {ref->offset, ref->size, ref->max_size,\n+\t\t\t  0, -1, false};\n   if (TREE_CODE (base) == MEM_REF || TREE_CODE (base) == TARGET_MEM_REF)\n     {\n+      tree offset = TREE_CODE (base) == MEM_REF\n+\t\t    ? TREE_OPERAND (base, 1) : NULL_TREE;\n       base = TREE_OPERAND (base, 0);\n       if (TREE_CODE (base) == SSA_NAME\n \t  && SSA_NAME_IS_DEFAULT_DEF (base)\n@@ -316,6 +336,8 @@ get_access (ao_ref *ref)\n \t\t}\n \t      a.parm_index++;\n \t    }\n+\t  a.parm_offset_known\n+\t    = offset && wi::to_poly_offset (offset).to_shwi (&a.parm_offset);\n \t}\n       else\n \ta.parm_index = -1;\n@@ -446,7 +468,7 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t\t\t gimple *stmt, modref_summary *callee_summary,\n \t\t\t bool ignore_stores)\n {\n-  auto_vec <int, 32> parm_map;\n+  auto_vec <modref_parm_map, 32> parm_map;\n   bool changed = false;\n \n   parm_map.safe_grow (gimple_call_num_args (stmt));\n@@ -469,12 +491,14 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t\t}\n \t      index++;\n \t    }\n-\t  parm_map[i] = index;\n+\t  parm_map[i].parm_index = index;\n+\t  parm_map[i].parm_offset_known = true;\n+\t  parm_map[i].parm_offset = 0;\n \t}\n       else if (points_to_local_or_readonly_memory_p (op))\n-\tparm_map[i] = -2;\n+\tparm_map[i].parm_index = -2;\n       else\n-\tparm_map[i] = -1;\n+\tparm_map[i].parm_index = -1;\n     }\n \n   /* Merge with callee's summary.  */\n@@ -970,7 +994,20 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n \t  size_t k;\n \t  modref_access_node *access_node;\n \t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n-\t    streamer_write_uhwi (ob, access_node->parm_index);\n+\t    {\n+\t      streamer_write_uhwi (ob, access_node->parm_index);\n+\t      if (access_node->parm_index != -1)\n+\t\t{\n+\t\t  streamer_write_uhwi (ob, access_node->parm_offset_known);\n+\t\t  if (access_node->parm_offset_known)\n+\t\t    {\n+\t\t      streamer_write_poly_int64 (ob, access_node->parm_offset);\n+\t\t      streamer_write_poly_int64 (ob, access_node->offset);\n+\t\t      streamer_write_poly_int64 (ob, access_node->size);\n+\t\t      streamer_write_poly_int64 (ob, access_node->max_size);\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n }\n@@ -1084,7 +1121,25 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \t  for (size_t k = 0; k < naccesses; k++)\n \t    {\n \t      int parm_index = streamer_read_uhwi (ib);\n-\t      modref_access_node a = {parm_index};\n+\t      bool parm_offset_known = false;\n+\t      poly_int64 parm_offset = 0;\n+\t      poly_int64 offset = 0;\n+\t      poly_int64 size = -1;\n+\t      poly_int64 max_size = -1;\n+\n+\t      if (parm_index != -1)\n+\t\t{\n+\t\t  parm_offset_known = streamer_read_uhwi (ib);\n+\t\t  if (parm_offset_known)\n+\t\t    {\n+\t\t      parm_offset = streamer_read_poly_int64 (ib);\n+\t\t      offset = streamer_read_poly_int64 (ib);\n+\t\t      size = streamer_read_poly_int64 (ib);\n+\t\t      max_size = streamer_read_poly_int64 (ib);\n+\t\t    }\n+\t\t}\n+\t      modref_access_node a = {offset, size, max_size, parm_offset,\n+\t\t\t\t      parm_index, parm_offset_known};\n \t      if (nolto_ref_node)\n \t\tnolto_ref_node->insert_access (a, max_accesses);\n \t      if (lto_ref_node)\n@@ -1331,7 +1386,7 @@ ignore_edge (struct cgraph_edge *e)\n /* Compute parm_map for CALLE_EDGE.  */\n \n static void\n-compute_parm_map (cgraph_edge *callee_edge, vec<int> *parm_map)\n+compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n {\n   class ipa_edge_args *args;\n   if (ipa_node_params_sum\n@@ -1357,7 +1412,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<int> *parm_map)\n \t{\n \t  if (es && es->param[i].points_to_local_or_readonly_memory)\n \t    {\n-\t      (*parm_map)[i] = -2;\n+\t      (*parm_map)[i].parm_index = -2;\n \t      continue;\n \t    }\n \n@@ -1371,26 +1426,33 @@ compute_parm_map (cgraph_edge *callee_edge, vec<int> *parm_map)\n \t\t\t\t\t\t (callee_pi, i));\n \t      if (cst && points_to_local_or_readonly_memory_p (cst))\n \t\t{\n-\t\t  (*parm_map)[i] = -2;\n+\t\t  (*parm_map)[i].parm_index = -2;\n \t\t  continue;\n \t\t}\n \t    }\n \t  if (jf && jf->type == IPA_JF_PASS_THROUGH)\n \t    {\n-\t      (*parm_map)[i]\n+\t      (*parm_map)[i].parm_index\n \t\t = ipa_get_jf_pass_through_formal_id (jf);\n+\t      (*parm_map)[i].parm_offset_known\n+\t\t= ipa_get_jf_pass_through_operation (jf) == NOP_EXPR;\n+\t      (*parm_map)[i].parm_offset = 0;\n \t      continue;\n \t    }\n \t  if (jf && jf->type == IPA_JF_ANCESTOR)\n-\t    (*parm_map)[i] = ipa_get_jf_ancestor_formal_id (jf);\n+\t    {\n+\t      (*parm_map)[i].parm_index = ipa_get_jf_ancestor_formal_id (jf);\n+\t      (*parm_map)[i].parm_offset_known = true;\n+\t      (*parm_map)[i].parm_offset = ipa_get_jf_ancestor_offset (jf);\n+ \t    }\n \t  else\n-\t    (*parm_map)[i] = -1;\n+\t    (*parm_map)[i].parm_index = -1;\n \t}\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"  Parm map: \");\n \t  for (i = 0; i < count; i++)\n-\t    fprintf (dump_file, \" %i\", (*parm_map)[i]);\n+\t    fprintf (dump_file, \" %i\", (*parm_map)[i].parm_index);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n@@ -1432,7 +1494,7 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n     }\n   else\n     {\n-      auto_vec <int, 32> parm_map;\n+      auto_vec <modref_parm_map, 32> parm_map;\n \n       compute_parm_map (edge, &parm_map);\n \n@@ -1598,7 +1660,7 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t}\n \n \n-\t      auto_vec <int, 32> parm_map;\n+\t      auto_vec <modref_parm_map, 32> parm_map;\n \n \t      compute_parm_map (callee_edge, &parm_map);\n "}, {"sha": "97dc4ac88147461bbe8464bb67adfbfd27b9d034", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34db4b6f8a5d80367c709309f9b00cb32630054/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c34db4b6f8a5d80367c709309f9b00cb32630054", "patch": "@@ -2505,8 +2505,8 @@ modref_may_conflict (const gimple *stmt,\n \t    }\n \n \t  /* TBAA checks did not disambiguate,  try to use base pointer, for\n-\t     that we however need to have ref->ref.  */\n-\t  if (ref_node->every_access || !ref->ref)\n+\t     that we however need to have ref->ref or ref->base.  */\n+\t  if (ref_node->every_access || (!ref->ref && !ref->base))\n \t    return true;\n \n \t  modref_access_node *access_node;\n@@ -2520,12 +2520,40 @@ modref_may_conflict (const gimple *stmt,\n \t\t     >= gimple_call_num_args (stmt))\n \t\treturn true;\n \n-\n \t      alias_stats.modref_baseptr_tests++;\n \n-\t      if (ptr_deref_may_alias_ref_p_1\n-\t\t   (gimple_call_arg (stmt, access_node->parm_index), ref))\n+\t      tree arg = gimple_call_arg (stmt, access_node->parm_index);\n+\n+\t      if (integer_zerop (arg) && flag_delete_null_pointer_checks)\n+\t\tcontinue;\n+\n+\t      if (!POINTER_TYPE_P (TREE_TYPE (arg)))\n \t\treturn true;\n+\n+\t      /* ao_ref_init_from_ptr_and_range assumes that memory access\n+\t\t starts by the pointed to location.  If we did not track the\n+\t\t offset it is possible that it starts before the actual\n+\t\t pointer.  */\n+\t      if (!access_node->parm_offset_known)\n+\t\t{\n+\t\t  if (ptr_deref_may_alias_ref_p_1 (arg, ref))\n+\t\t    return true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  ao_ref ref2;\n+\n+\t\t  ao_ref_init_from_ptr_and_range\n+\t\t\t (&ref2, arg, true,\n+\t\t\t  access_node->offset\n+\t\t\t  + (access_node->parm_offset\n+\t\t\t     << LOG2_BITS_PER_UNIT), access_node->size,\n+\t\t\t  access_node->max_size);\n+\t\t  ref2.ref_alias_set = ref_set;\n+\t\t  ref2.base_alias_set = base_set;\n+\t\t  if (refs_may_alias_p_1 (&ref2, ref, tbaa_p))\n+\t\t    return true;\n+\t\t}\n \t      num_tests++;\n \t    }\n \t}"}]}