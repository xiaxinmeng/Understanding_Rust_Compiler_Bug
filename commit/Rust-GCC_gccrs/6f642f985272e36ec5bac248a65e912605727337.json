{"sha": "6f642f985272e36ec5bac248a65e912605727337", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY2NDJmOTg1MjcyZTM2ZWM1YmFjMjQ4YTY1ZTkxMjYwNTcyNzMzNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-26T15:20:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-26T15:20:53Z"}, "message": "re PR middle-end/19515 (Violation of C99 6.7.8 \u00a721 for unions)\n\n        PR middle-end/19515\n        * expr.c (categorize_ctor_elements): New argument p_must_clear.\n        (categorize_ctor_elements_1): Likewise.  Detect a union that isn't\n        fully initialized.\n        (mostly_zeros_p): Update for new categorize_ctor_elements argument.\n        * gimplify.c (gimplify_init_constructor): Likewise.  Only shove\n        objects into static storage if they have more than one non-zero value.\n        * tree.h (categorize_ctor_elements): Update decl.\n\nFrom-SVN: r94266", "tree": {"sha": "2bf5d70375fa0bc54fd1069c76adcd376923ad97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bf5d70375fa0bc54fd1069c76adcd376923ad97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f642f985272e36ec5bac248a65e912605727337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f642f985272e36ec5bac248a65e912605727337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f642f985272e36ec5bac248a65e912605727337", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f642f985272e36ec5bac248a65e912605727337/comments", "author": null, "committer": null, "parents": [{"sha": "ead553a1d9f9206c1f5a3b1a6799ea877fc9a845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead553a1d9f9206c1f5a3b1a6799ea877fc9a845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead553a1d9f9206c1f5a3b1a6799ea877fc9a845"}], "stats": {"total": 92, "additions": 80, "deletions": 12}, "files": [{"sha": "a7b83b8d4fe85b447080a8e1a8d545b40bfd5e83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f642f985272e36ec5bac248a65e912605727337/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f642f985272e36ec5bac248a65e912605727337/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f642f985272e36ec5bac248a65e912605727337", "patch": "@@ -1,3 +1,14 @@\n+2005-01-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/19515\n+\t* expr.c (categorize_ctor_elements): New argument p_must_clear.\n+\t(categorize_ctor_elements_1): Likewise.  Detect a union that isn't\n+\tfully initialized.\n+\t(mostly_zeros_p): Update for new categorize_ctor_elements argument.\n+\t* gimplify.c (gimplify_init_constructor): Likewise.  Only shove\n+\tobjects into static storage if they have more than one non-zero value.\n+\t* tree.h (categorize_ctor_elements): Update decl.\n+\n 2005-01-26  Steven Bosscher  <stevenb@suse.de>\n \n \tPR middle-end/19616\t"}, {"sha": "ed693a3166f6163371194766c2eee9af5627f7b8", "filename": "gcc/expr.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f642f985272e36ec5bac248a65e912605727337/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f642f985272e36ec5bac248a65e912605727337/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6f642f985272e36ec5bac248a65e912605727337", "patch": "@@ -4272,12 +4272,15 @@ store_expr (tree exp, rtx target, int call_param_p)\n    * how many scalar fields are set to non-constant values,\n      and place it in  *P_NC_ELTS; and\n    * how many scalar fields in total are in CTOR,\n-     and place it in *P_ELT_COUNT.  */\n+     and place it in *P_ELT_COUNT.\n+   * if a type is a union, and the initializer from the constructor\n+     is not the largest element in the union, then set *p_must_clear.  */\n \n static void\n categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t\t\t    HOST_WIDE_INT *p_nc_elts,\n-\t\t\t    HOST_WIDE_INT *p_elt_count)\n+\t\t\t    HOST_WIDE_INT *p_elt_count,\n+\t\t\t    bool *p_must_clear)\n {\n   HOST_WIDE_INT nz_elts, nc_elts, elt_count;\n   tree list;\n@@ -4307,11 +4310,11 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t{\n \tcase CONSTRUCTOR:\n \t  {\n-\t    HOST_WIDE_INT nz = 0, nc = 0, count = 0;\n-\t    categorize_ctor_elements_1 (value, &nz, &nc, &count);\n+\t    HOST_WIDE_INT nz = 0, nc = 0, ic = 0;\n+\t    categorize_ctor_elements_1 (value, &nz, &nc, &ic, p_must_clear);\n \t    nz_elts += mult * nz;\n \t    nc_elts += mult * nc;\n-\t    elt_count += mult * count;\n+\t    elt_count += mult * ic;\n \t  }\n \t  break;\n \n@@ -4356,6 +4359,36 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t}\n     }\n \n+  if (!*p_must_clear\n+      && (TREE_CODE (TREE_TYPE (ctor)) == UNION_TYPE\n+\t  || TREE_CODE (TREE_TYPE (ctor)) == QUAL_UNION_TYPE))\n+    {\n+      tree init_sub_type;\n+\n+      /* We don't expect more than one element of the union to be\n+\t initialized.  Not sure what we should do otherwise... */\n+      list = CONSTRUCTOR_ELTS (ctor);\n+      gcc_assert (TREE_CHAIN (list) == NULL);\n+\n+      init_sub_type = TREE_TYPE (TREE_VALUE (list));\n+\n+      /* ??? We could look at each element of the union, and find the\n+\t largest element.  Which would avoid comparing the size of the\n+\t initialized element against any tail padding in the union.\n+\t Doesn't seem worth the effort...  */\n+      if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (ctor)), \n+\t\t\t    TYPE_SIZE (init_sub_type)) == 1)\n+\t{\n+\t  /* And now we have to find out if the element itself is fully\n+\t     constructed.  E.g. for union { struct { int a, b; } s; } u\n+\t     = { .s = { .a = 1 } }.  */\n+\t  if (elt_count != count_type_elements (init_sub_type))\n+\t    *p_must_clear = true;\n+\t}\n+      else\n+\t*p_must_clear = true;\n+    }\n+\n   *p_nz_elts += nz_elts;\n   *p_nc_elts += nc_elts;\n   *p_elt_count += elt_count;\n@@ -4364,12 +4397,15 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n void\n categorize_ctor_elements (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t\t\t  HOST_WIDE_INT *p_nc_elts,\n-\t\t\t  HOST_WIDE_INT *p_elt_count)\n+\t\t\t  HOST_WIDE_INT *p_elt_count,\n+\t\t\t  bool *p_must_clear)\n {\n   *p_nz_elts = 0;\n   *p_nc_elts = 0;\n   *p_elt_count = 0;\n-  categorize_ctor_elements_1 (ctor, p_nz_elts, p_nc_elts, p_elt_count);\n+  *p_must_clear = false;\n+  categorize_ctor_elements_1 (ctor, p_nz_elts, p_nc_elts, p_elt_count,\n+\t\t\t      p_must_clear);\n }\n \n /* Count the number of scalars in TYPE.  Return -1 on overflow or\n@@ -4459,8 +4495,12 @@ mostly_zeros_p (tree exp)\n \n     {\n       HOST_WIDE_INT nz_elts, nc_elts, count, elts;\n+      bool must_clear;\n+\n+      categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count, &must_clear);\n+      if (must_clear)\n+\treturn 1;\n \n-      categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count);\n       elts = count_type_elements (TREE_TYPE (exp));\n \n       return nz_elts < elts / 4;"}, {"sha": "ac9ae14a74a7d4b1f21064a9738aedfd9b387beb", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f642f985272e36ec5bac248a65e912605727337/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f642f985272e36ec5bac248a65e912605727337/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6f642f985272e36ec5bac248a65e912605727337", "patch": "@@ -2599,11 +2599,12 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \n \tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n \t\t\t\t  &num_nonconstant_elements,\n-\t\t\t\t  &num_ctor_elements);\n+\t\t\t\t  &num_ctor_elements, &cleared);\n \n \t/* If a const aggregate variable is being initialized, then it\n \t   should never be a lose to promote the variable to be static.  */\n \tif (num_nonconstant_elements == 0\n+\t    && num_nonzero_elements > 1\n \t    && TREE_READONLY (object)\n \t    && TREE_CODE (object) == VAR_DECL)\n \t  {\n@@ -2685,7 +2686,6 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \tnum_type_elements = count_type_elements (TREE_TYPE (ctor));\n \n \t/* If there are \"lots\" of zeros, then block clear the object first.  */\n-\tcleared = false;\n \tif (num_type_elements - num_nonzero_elements > CLEAR_RATIO\n \t    && num_nonzero_elements < num_type_elements/4)\n \t  cleared = true;"}, {"sha": "df0e10721882bf3f223410516f69eccfc4b482eb", "filename": "gcc/testsuite/gcc.c-torture/execute/pr19515.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f642f985272e36ec5bac248a65e912605727337/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19515.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f642f985272e36ec5bac248a65e912605727337/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19515.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19515.c?ref=6f642f985272e36ec5bac248a65e912605727337", "patch": "@@ -0,0 +1,17 @@\n+/* PR 19515 */\n+\n+typedef union {\n+      char a2[8];\n+}aun;\n+\n+void abort (void);\n+\n+int main(void)\n+{\n+  aun a = {{0}};\n+\n+  if (a.a2[2] != 0)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "65e660fecc4faa8a09d0c728e619f1c233b216af", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f642f985272e36ec5bac248a65e912605727337/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f642f985272e36ec5bac248a65e912605727337/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6f642f985272e36ec5bac248a65e912605727337", "patch": "@@ -3235,8 +3235,8 @@ extern int fields_length (tree);\n \n extern bool initializer_zerop (tree);\n \n-extern void categorize_ctor_elements (tree, HOST_WIDE_INT *,\n-\t\t\t\t      HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern void categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      HOST_WIDE_INT *, bool *);\n extern HOST_WIDE_INT count_type_elements (tree);\n \n /* add_var_to_bind_expr (bind_expr, var) binds var to bind_expr.  */"}]}