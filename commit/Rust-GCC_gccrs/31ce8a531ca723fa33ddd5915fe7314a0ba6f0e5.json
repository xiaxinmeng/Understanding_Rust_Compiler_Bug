{"sha": "31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjZThhNTMxY2E3MjNmYTMzZGRkNTkxNWZlNzMxNGEwYmE2ZjBlNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@codesourcery.com", "date": "2010-04-14T20:42:02Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-04-14T20:42:02Z"}, "message": "re PR rtl-optimization/21803 ([ia64] gcc produces really odd predicated code)\n\ngcc/\n\tPR target/21803\n\t* ifcvt.c (cond_exec_process_if_block): Look for identical sequences\n\tat the start and end of the then/else blocks, and omit them from the\n\tconversion.\n\t* cfgcleanup.c (flow_find_cross_jump): No longer static.  Remove MODE\n\targument; all callers changed.  Pass zero to old_insns_match_p instead.\n\t(flow_find_head_matching_sequence): New function.\n\t(old_insns_match_p): Check REG_EH_REGION notes for calls.\n\t* basic-block.h (flow_find_cross_jump,\n\tflow_find_head_matching_sequence): Declare functions.\n\ngcc/testsuite/\n\tPR target/21803\n\t* gcc.target/arm/pr42496.c: New test.\n\nFrom-SVN: r158357", "tree": {"sha": "1884df733d474367203b5216eb04d450bcd6d268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1884df733d474367203b5216eb04d450bcd6d268"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/comments", "author": null, "committer": null, "parents": [{"sha": "943f82e7681224a36aadf743b6572ef55ec9e7ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/943f82e7681224a36aadf743b6572ef55ec9e7ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/943f82e7681224a36aadf743b6572ef55ec9e7ec"}], "stats": {"total": 291, "additions": 261, "deletions": 30}, "files": [{"sha": "b09f10f51b0ff00113b5cc9fc5470bbac4aa001d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "patch": "@@ -1,3 +1,16 @@\n+2010-04-14  Bernd Schmidt  <bernd.schmidt@codesourcery.com>\n+\t\n+\tPR target/21803\n+\t* ifcvt.c (cond_exec_process_if_block): Look for identical sequences\n+\tat the start and end of the then/else blocks, and omit them from the\n+\tconversion.\n+\t* cfgcleanup.c (flow_find_cross_jump): No longer static.  Remove MODE\n+\targument; all callers changed.  Pass zero to old_insns_match_p instead.\n+\t(flow_find_head_matching_sequence): New function.\n+\t(old_insns_match_p): Check REG_EH_REGION notes for calls.\n+\t* basic-block.h (flow_find_cross_jump,\n+\tflow_find_head_matching_sequence): Declare functions.\n+\n 2010-04-14  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/36625"}, {"sha": "34b18bd51e8635348d0207b6d307f994150c849f", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "patch": "@@ -894,6 +894,10 @@ extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n \n /* In cfgcleanup.c.  */\n extern bool cleanup_cfg (int);\n+extern int flow_find_cross_jump (basic_block, basic_block, rtx *, rtx *);\n+extern int flow_find_head_matching_sequence (basic_block, basic_block,\n+\t\t\t\t\t     rtx *, rtx *, int);\n+\n extern bool delete_unreachable_blocks (void);\n \n extern bool mark_dfs_back_edges (void);"}, {"sha": "dc6c245b9506baf620e0bf4d7fe1a159db26dc1f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 138, "deletions": 26, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "patch": "@@ -68,7 +68,6 @@ static bool crossjumps_occured;\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n-static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n static bool old_insns_match_p (int, rtx, rtx);\n \n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n@@ -972,13 +971,27 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n      be filled that clobbers a parameter expected by the subroutine.\n \n      ??? We take the simple route for now and assume that if they're\n-     equal, they were constructed identically.  */\n+     equal, they were constructed identically.\n \n-  if (CALL_P (i1)\n-      && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n+     Also check for identical exception regions.  */\n+\n+  if (CALL_P (i1))\n+    {\n+      /* Ensure the same EH region.  */\n+      rtx n1 = find_reg_note (i1, REG_EH_REGION, 0);\n+      rtx n2 = find_reg_note (i2, REG_EH_REGION, 0);\n+\n+      if (!n1 && n2)\n+\treturn false;\n+\n+      if (n1 && (!n2 || XEXP (n1, 0) != XEXP (n2, 0)))\n+\treturn false;\n+\n+      if (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n \t\t\tCALL_INSN_FUNCTION_USAGE (i2))\n-\t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n-    return false;\n+\t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2))\n+\treturn false;\n+    }\n \n #ifdef STACK_REGS\n   /* If cross_jump_death_matters is not 0, the insn's mode\n@@ -1017,16 +1030,38 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n   return false;\n }\n \f\n+/* When comparing insns I1 and I2 in flow_find_cross_jump or\n+   flow_find_head_matching_sequence, ensure the notes match.  */\n+\n+static void\n+merge_notes (rtx i1, rtx i2)\n+{\n+  /* If the merged insns have different REG_EQUAL notes, then\n+     remove them.  */\n+  rtx equiv1 = find_reg_equal_equiv_note (i1);\n+  rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+  if (equiv1 && !equiv2)\n+    remove_note (i1, equiv1);\n+  else if (!equiv1 && equiv2)\n+    remove_note (i2, equiv2);\n+  else if (equiv1 && equiv2\n+\t   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n+    {\n+      remove_note (i1, equiv1);\n+      remove_note (i2, equiv2);\n+    }\n+}\n+\n /* Look through the insns at the end of BB1 and BB2 and find the longest\n    sequence that are equivalent.  Store the first insns for that sequence\n    in *F1 and *F2 and return the sequence length.\n \n    To simplify callers of this function, if the blocks match exactly,\n    store the head of the blocks in *F1 and *F2.  */\n \n-static int\n-flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n-\t\t      basic_block bb2, rtx *f1, rtx *f2)\n+int\n+flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2)\n {\n   rtx i1, i2, last1, last2, afterlast1, afterlast2;\n   int ninsns = 0;\n@@ -1066,29 +1101,15 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n       if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n \tbreak;\n \n-      if (!old_insns_match_p (mode, i1, i2))\n+      if (!old_insns_match_p (0, i1, i2))\n \tbreak;\n \n       merge_memattrs (i1, i2);\n \n       /* Don't begin a cross-jump with a NOTE insn.  */\n       if (INSN_P (i1))\n \t{\n-\t  /* If the merged insns have different REG_EQUAL notes, then\n-\t     remove them.  */\n-\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n-\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n-\n-\t  if (equiv1 && !equiv2)\n-\t    remove_note (i1, equiv1);\n-\t  else if (!equiv1 && equiv2)\n-\t    remove_note (i2, equiv2);\n-\t  else if (equiv1 && equiv2\n-\t\t   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n-\t    {\n-\t      remove_note (i1, equiv1);\n-\t      remove_note (i2, equiv2);\n-\t    }\n+\t  merge_notes (i1, i2);\n \n \t  afterlast1 = last1, afterlast2 = last2;\n \t  last1 = i1, last2 = i2;\n@@ -1130,6 +1151,97 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n   return ninsns;\n }\n \n+/* Like flow_find_cross_jump, except start looking for a matching sequence from\n+   the head of the two blocks.  Do not include jumps at the end.\n+   If STOP_AFTER is nonzero, stop after finding that many matching\n+   instructions.  */\n+\n+int\n+flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx *f1,\n+\t\t\t\t  rtx *f2, int stop_after)\n+{\n+  rtx i1, i2, last1, last2, beforelast1, beforelast2;\n+  int ninsns = 0;\n+  edge e;\n+  edge_iterator ei;\n+  int nehedges1 = 0, nehedges2 = 0;\n+\n+  FOR_EACH_EDGE (e, ei, bb1->succs)\n+    if (e->flags & EDGE_EH)\n+      nehedges1++;\n+  FOR_EACH_EDGE (e, ei, bb2->succs)\n+    if (e->flags & EDGE_EH)\n+      nehedges2++;\n+\n+  i1 = BB_HEAD (bb1);\n+  i2 = BB_HEAD (bb2);\n+  last1 = beforelast1 = last2 = beforelast2 = NULL_RTX;\n+\n+  while (true)\n+    {\n+\n+      /* Ignore notes.  */\n+      while (!NONDEBUG_INSN_P (i1) && i1 != BB_END (bb1))\n+\ti1 = NEXT_INSN (i1);\n+\n+      while (!NONDEBUG_INSN_P (i2) && i2 != BB_END (bb2))\n+\ti2 = NEXT_INSN (i2);\n+\n+      if (NOTE_P (i1) || NOTE_P (i2)\n+\t  || JUMP_P (i1) || JUMP_P (i2))\n+\tbreak;\n+\n+      /* A sanity check to make sure we're not merging insns with different\n+\t effects on EH.  If only one of them ends a basic block, it shouldn't\n+\t have an EH edge; if both end a basic block, there should be the same\n+\t number of EH edges.  */\n+      if ((i1 == BB_END (bb1) && i2 != BB_END (bb2)\n+\t   && nehedges1 > 0)\n+\t  || (i2 == BB_END (bb2) && i1 != BB_END (bb1)\n+\t      && nehedges2 > 0)\n+\t  || (i1 == BB_END (bb1) && i2 == BB_END (bb2)\n+\t      && nehedges1 != nehedges2))\n+\tbreak;\n+\n+      if (!old_insns_match_p (0, i1, i2))\n+\tbreak;\n+\n+      merge_memattrs (i1, i2);\n+\n+      /* Don't begin a cross-jump with a NOTE insn.  */\n+      if (INSN_P (i1))\n+\t{\n+\t  merge_notes (i1, i2);\n+\n+\t  beforelast1 = last1, beforelast2 = last2;\n+\t  last1 = i1, last2 = i2;\n+\t  ninsns++;\n+\t}\n+\n+      if (i1 == BB_END (bb1) || i2 == BB_END (bb2)\n+\t  || (stop_after > 0 && ninsns == stop_after))\n+\tbreak;\n+\n+      i1 = NEXT_INSN (i1);\n+      i2 = NEXT_INSN (i2);\n+    }\n+\n+#ifdef HAVE_cc0\n+  /* Don't allow a compare to be shared by cross-jumping unless the insn\n+     after the compare is also shared.  */\n+  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && sets_cc0_p (last1))\n+    last1 = beforelast1, last2 = beforelast2, ninsns--;\n+#endif\n+\n+  if (ninsns)\n+    {\n+      *f1 = last1;\n+      *f2 = last2;\n+    }\n+\n+  return ninsns;\n+}\n+\n /* Return true iff outgoing edges of BB1 and BB2 match, together with\n    the branch instruction.  This means that if we commonize the control\n    flow before end of the basic block, the semantic remains unchanged.\n@@ -1498,7 +1610,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     return false;\n \n   /* ... and part the second.  */\n-  nmatch = flow_find_cross_jump (mode, src1, src2, &newpos1, &newpos2);\n+  nmatch = flow_find_cross_jump (src1, src2, &newpos1, &newpos2);\n \n   /* Don't proceed with the crossjump unless we found a sufficient number\n      of matching instructions or the 'from' block was totally matched"}, {"sha": "1f4773a6d459bfd5f427559bce7fc65e3c9098bb", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "patch": "@@ -385,7 +385,11 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n   rtx false_expr;\t\t/* test for then block insns */\n   rtx true_prob_val;\t\t/* probability of else block */\n   rtx false_prob_val;\t\t/* probability of then block */\n-  int n_insns;\n+  rtx then_last_head = NULL_RTX;\t/* Last match at the head of THEN */\n+  rtx else_last_head = NULL_RTX;\t/* Last match at the head of ELSE */\n+  rtx then_first_tail = NULL_RTX;\t/* First match at the tail of THEN */\n+  rtx else_first_tail = NULL_RTX;\t/* First match at the tail of ELSE */\n+  int then_n_insns, else_n_insns, n_insns;\n   enum rtx_code false_code;\n \n   /* If test is comprised of && or || elements, and we've failed at handling\n@@ -418,15 +422,78 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n      number of insns and see if it is small enough to convert.  */\n   then_start = first_active_insn (then_bb);\n   then_end = last_active_insn (then_bb, TRUE);\n-  n_insns = ce_info->num_then_insns = count_bb_insns (then_bb);\n+  then_n_insns = ce_info->num_then_insns = count_bb_insns (then_bb);\n+  n_insns = then_n_insns;\n   max = MAX_CONDITIONAL_EXECUTE;\n \n   if (else_bb)\n     {\n+      int n_matching;\n+\n       max *= 2;\n       else_start = first_active_insn (else_bb);\n       else_end = last_active_insn (else_bb, TRUE);\n-      n_insns += ce_info->num_else_insns = count_bb_insns (else_bb);\n+      else_n_insns = ce_info->num_else_insns = count_bb_insns (else_bb);\n+      n_insns += else_n_insns;\n+\n+      /* Look for matching sequences at the head and tail of the two blocks,\n+\t and limit the range of insns to be converted if possible.  */\n+      n_matching = flow_find_cross_jump (then_bb, else_bb,\n+\t\t\t\t\t &then_first_tail, &else_first_tail);\n+      if (then_first_tail == BB_HEAD (then_bb))\n+\tthen_start = then_end = NULL_RTX;\n+      if (else_first_tail == BB_HEAD (else_bb))\n+\telse_start = else_end = NULL_RTX;\n+\n+      if (n_matching > 0)\n+\t{\n+\t  if (then_end)\n+\t    then_end = prev_active_insn (then_first_tail);\n+\t  if (else_end)\n+\t    else_end = prev_active_insn (else_first_tail);\n+\t  n_insns -= 2 * n_matching;\n+\t}\n+\n+      if (then_start && else_start)\n+\t{\n+\t  int longest_match = MIN (then_n_insns - n_matching,\n+\t\t\t\t   else_n_insns - n_matching);\n+\t  n_matching\n+\t    = flow_find_head_matching_sequence (then_bb, else_bb,\n+\t\t\t\t\t\t&then_last_head,\n+\t\t\t\t\t\t&else_last_head,\n+\t\t\t\t\t\tlongest_match);\n+\n+\t  if (n_matching > 0)\n+\t    {\n+\t      rtx insn;\n+\n+\t      /* We won't pass the insns in the head sequence to\n+\t\t cond_exec_process_insns, so we need to test them here\n+\t\t to make sure that they don't clobber the condition.  */\n+\t      for (insn = BB_HEAD (then_bb);\n+\t\t   insn != NEXT_INSN (then_last_head);\n+\t\t   insn = NEXT_INSN (insn))\n+\t\tif (!LABEL_P (insn) && !NOTE_P (insn)\n+\t\t    && !DEBUG_INSN_P (insn)\n+\t\t    && modified_in_p (test_expr, insn))\n+\t\t  return FALSE;\n+\t    }\n+\n+\t  if (then_last_head == then_end)\n+\t    then_start = then_end = NULL_RTX;\n+\t  if (else_last_head == else_end)\n+\t    else_start = else_end = NULL_RTX;\n+\n+\t  if (n_matching > 0)\n+\t    {\n+\t      if (then_start)\n+\t\tthen_start = next_active_insn (then_last_head);\n+\t      if (else_start)\n+\t\telse_start = next_active_insn (else_last_head);\n+\t      n_insns -= 2 * n_matching;\n+\t    }\n+\t}\n     }\n \n   if (n_insns > max)\n@@ -570,7 +637,21 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n     fprintf (dump_file, \"%d insn%s converted to conditional execution.\\n\",\n \t     n_insns, (n_insns == 1) ? \" was\" : \"s were\");\n \n-  /* Merge the blocks!  */\n+  /* Merge the blocks!  If we had matching sequences, make sure to delete one\n+     copy at the appropriate location first: delete the copy in the THEN branch\n+     for a tail sequence so that the remaining one is executed last for both\n+     branches, and delete the copy in the ELSE branch for a head sequence so\n+     that the remaining one is executed first for both branches.  */\n+  if (then_first_tail)\n+    {\n+      rtx from = then_first_tail;\n+      if (!INSN_P (from))\n+\tfrom = next_active_insn (from);\n+      delete_insn_chain (from, BB_END (then_bb), false);\n+    }\n+  if (else_last_head)\n+    delete_insn_chain (first_active_insn (else_bb), else_last_head, false);\n+\n   merge_if_block (ce_info);\n   cond_exec_changed_p = TRUE;\n   return TRUE;"}, {"sha": "25024a3ee419ca6527ba51e29cc0cdbee514217b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "patch": "@@ -1,3 +1,8 @@\n+2010-04-14  Bernd Schmidt  <bernd.schmidt@codesourcery.com>\n+\n+\tPR target/21803\n+\t* gcc.target/arm/pr42496.c: New test.\n+\n 2010-04-14  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/36625"}, {"sha": "c6d8a1f398085d6af4f07228694929e49fff07ea", "filename": "gcc/testsuite/gcc.target/arm/pr42496.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42496.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42496.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42496.c?ref=31ce8a531ca723fa33ddd5915fe7314a0ba6f0e5", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O2\" }  */\n+\n+void foo(int i)\n+{\n+    extern int j;\n+\n+    if (i) {\n+         j = 10;\n+    }\n+    else {\n+          j = 20;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"strne\" } } */\n+/* { dg-final { scan-assembler-not \"streq\" } } */"}]}