{"sha": "b1caaefc1cde4049a13aa413cdae0be107551c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjYWFlZmMxY2RlNDA0OWExM2FhNDEzY2RhZTBiZTEwNzU1MWMzMQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-07-10T07:05:40Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-07-10T07:05:40Z"}, "message": "gfc-internals.texi (section gfc_expr): Created documentation about the gfc_expr internal data structure.\n\n2008-07-10  Daniel Kraft  <d@domob.eu>\n\n\t* gfc-internals.texi (section gfc_expr):  Created documentation about\n\tthe gfc_expr internal data structure.\n\nFrom-SVN: r137688", "tree": {"sha": "9e21861b9addb555841cbfb6bf5831aa242dcc43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e21861b9addb555841cbfb6bf5831aa242dcc43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1caaefc1cde4049a13aa413cdae0be107551c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1caaefc1cde4049a13aa413cdae0be107551c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1caaefc1cde4049a13aa413cdae0be107551c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1caaefc1cde4049a13aa413cdae0be107551c31/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15e1dac036941cf6f094ef8b4f11353d05968ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e1dac036941cf6f094ef8b4f11353d05968ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e1dac036941cf6f094ef8b4f11353d05968ac8"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "d8c31145d98b8245a7dc23e1df15c6a6ee161ba0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1caaefc1cde4049a13aa413cdae0be107551c31/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1caaefc1cde4049a13aa413cdae0be107551c31/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b1caaefc1cde4049a13aa413cdae0be107551c31", "patch": "@@ -1,3 +1,8 @@\n+2008-07-10  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfc-internals.texi (section gfc_expr):  Created documentation about\n+\tthe gfc_expr internal data structure.\n+\n 2008-07-07  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/36670"}, {"sha": "330db81c59c3b96b2f6ff1d0abff2f9ef3a1906d", "filename": "gcc/fortran/gfc-internals.texi", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1caaefc1cde4049a13aa413cdae0be107551c31/gcc%2Ffortran%2Fgfc-internals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1caaefc1cde4049a13aa413cdae0be107551c31/gcc%2Ffortran%2Fgfc-internals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfc-internals.texi?ref=b1caaefc1cde4049a13aa413cdae0be107551c31", "patch": "@@ -285,8 +285,10 @@ structures.\n \n @menu\n * gfc_code:: Representation of Executable Statements.\n+* gfc_expr:: Representation of Values and Expressions.\n @end menu\n \n+\n @c gfc_code\n @c --------\n \n@@ -403,6 +405,153 @@ case-block, and @code{extx.case_list} contains the case-values this block\n corresponds to.  The @code{block} member links to the next case in the list.\n \n \n+@c gfc_expr\n+@c --------\n+\n+@node gfc_expr\n+@section @code{gfc_expr}\n+@tindex @code{gfc_expr}\n+@tindex @code{struct gfc_expr}\n+\n+Expressions and ``values'', including constants, variable-, array- and\n+component-references as well as complex expressions consisting of operators and\n+function calls are internally represented as one or a whole tree of\n+@code{gfc_expr} objects.  The member @code{expr_type} specifies the overall\n+type of an expression (for instance, @code{EXPR_CONSTANT} for constants or\n+@code{EXPR_VARIABLE} for variable references).  The members @code{ts} and\n+@code{rank} as well as @code{shape}, which can be @code{NULL}, specify\n+the type, rank and, if applicable, shape of the whole expression or expression\n+tree of which the current structure is the root.  @code{where} is the locus of\n+this expression in the source code.\n+\n+Depending on the flavour of the expression being described by the object\n+(that is, the value of its @code{expr_type} member), the corresponding structure\n+in the @code{value} union will usually contain additional data describing the\n+expression's value in a type-specific manner.  The @code{ref} member is used to\n+build chains of (array-, component- and substring-) references if the expression\n+in question contains such references, see below for details.\n+\n+\n+@subsection Constants\n+\n+Scalar constants are represented by @code{gfc_expr} nodes with their\n+@code{expr_type} set to @code{EXPR_CONSTANT}.  The constant's value shall\n+already be known at compile-time and is stored in the @code{logical},\n+@code{integer}, @code{real}, @code{complex} or @code{character} struct inside\n+@code{value}, depending on the constant's type specification.\n+\n+\n+@subsection Operators\n+\n+Operator-expressions are expressions that are the result of the execution of\n+some operator on one or two operands.  The expressions have an @code{expr_type}\n+of @code{EXPR_OP}.  Their @code{value.op} structure contains additional data.\n+\n+@code{op1} and optionally @code{op2} if the operator is binary point to the\n+two operands, and @code{operator} or @code{uop} describe the operator that\n+should be evaluated on these operands, where @code{uop} describes a user-defined\n+operator.\n+\n+\n+@subsection Function Calls\n+\n+If the expression is the return value of a function-call, its @code{expr_type}\n+is set to @code{EXPR_FUNCTION}, and @code{symtree} must point to the symtree\n+identifying the function to be called.  @code{value.function.actual} holds the\n+actual arguments given to the function as a linked list of\n+@code{gfc_actual_arglist} nodes.\n+\n+The other members of @code{value.function} describe the function being called\n+in more detail, containing a link to the intrinsic symbol or user-defined\n+function symbol if the call is to an intrinsic or external function,\n+respectively.  These values are determined during resolution-phase from the\n+structure's @code{symtree} member.\n+\n+\n+@subsection Array- and Structure-Constructors\n+\n+Array- and structure-constructors (one could probably call them ``array-'' and\n+``derived-type constants'') are @code{gfc_expr} structures with their\n+@code{expr_type} member set to @code{EXPR_ARRAY} or @code{EXPR_STRUCTURE},\n+respectively.  For structure constructors, @code{symtree} points to the\n+derived-type symbol for the type being constructed.\n+\n+The values for initializing each array element or structure component are\n+stored as linked-list of @code{gfc_constructor} nodes in the\n+@code{value.constructor} member.\n+\n+\n+@subsection Null\n+\n+@code{NULL} is a special value for pointers; it can be of different base types.\n+Such a @code{NULL} value is represented in the internal tree by a\n+@code{gfc_expr} node with @code{expr_type} @code{EXPR_NULL}.  If the base type\n+of the @code{NULL} expression is known, it is stored in @code{ts} (that's for\n+instance the case for default-initializers of @code{ALLOCATABLE} components),\n+but this member can also be set to @code{BT_UNKNOWN} if the information is not\n+available (for instance, when the expression is a pointer-initializer\n+@code{NULL()}).\n+\n+\n+@subsection Variables and Reference Expressions\n+\n+Variable references are @code{gfc_expr} structures with their @code{expr_type}\n+set to @code{EXPR_VARIABLE}; their @code{symtree} should point to the variable\n+that is referenced.\n+\n+For this type of expression, it's also possible to chain array-, component-\n+or substring-references to the original expression to get something like\n+@samp{struct%component(2:5)}, where @code{component} is either an array or\n+a @code{CHARACTER} member of @code{struct} that is of some derived-type.  Such a\n+chain of references is achieved by a linked list headed by @code{ref} of the\n+@code{gfc_expr} node.  For the example above it would be (@samp{==|} is the\n+last @code{NULL} pointer):\n+\n+@smallexample\n+EXPR_VARIABLE(struct) ==> REF_COMPONENT(component) ==> REF_ARRAY(2:5) ==|\n+@end smallexample\n+\n+If @code{component} is a string rather than an array, the last element would be\n+a @code{REF_SUBSTRING} reference, of course.  If the variable itself or some\n+component referenced is an array and the expression should reference the whole\n+array rather than being followed by an array-element or -section reference, a\n+@code{REF_ARRAY} reference must be built as the last element in the chain with\n+an array-reference type of @code{AR_FULL}. Consider this example code:\n+\n+@smallexample\n+TYPE :: mytype\n+  INTEGER :: array(42)\n+END TYPE mytype\n+\n+TYPE(mytype) :: variable\n+INTEGER :: local_array(5)\n+\n+CALL do_something (variable%array, local_array)\n+@end smallexample\n+\n+The @code{gfc_expr} nodes representing the arguments to the @samp{do_something}\n+call will have a reference-chain like this:\n+\n+@smallexample\n+EXPR_VARIABLE(variable) ==> REF_COMPONENT(array) ==> REF_ARRAY(FULL) ==|\n+EXPR_VARIABLE(local_array) ==> REF_ARRAY(FULL) ==|\n+@end smallexample\n+\n+\n+@subsection Constant Substring References\n+\n+@code{EXPR_SUBSTRING} is a special type of expression that encodes a substring\n+reference of a constant string, as in the following code snippet:\n+\n+@smallexample\n+x = \"abcde\"(1:2)\n+@end smallexample\n+\n+In this case, @code{value.character} contains the full string's data as if it\n+was a string constant, but the @code{ref} member is also set and points to a\n+substring reference as described in the subsection above.\n+\n+\n @c ---------------------------------------------------------------------\n @c LibGFortran\n @c ---------------------------------------------------------------------"}]}