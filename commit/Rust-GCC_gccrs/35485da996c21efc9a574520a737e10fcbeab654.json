{"sha": "35485da996c21efc9a574520a737e10fcbeab654", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU0ODVkYTk5NmMyMWVmYzlhNTc0NTIwYTczN2UxMGZjYmVhYjY1NA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-11-11T21:55:52Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-11-11T21:55:52Z"}, "message": "Merger of dmalcolm/jit branch from git\n\nChangeLog:\n\t* ChangeLog.jit: New.\n\t* MAINTAINERS (Various Maintainers): Add myself as jit maintainer.\n\ncontrib/ChangeLog:\n\t* ChangeLog.jit: New.\n\t* jit-coverage-report.py: New file: a script to print crude\n\tcode-coverage information for the libgccjit API.\n\ngcc/ChangeLog:\n\t* ChangeLog.jit: New.\n\t* Makefile.in (doc_build_sys): New variable, set to \"sphinx\" if\n\tsphinx is installed, falling back to \"texinfo\" otherwise.\n\t(FULL_DRIVER_NAME): New variable, adapted from the\n\tinstall-driver target.  New target, a symlink within the builddir,\n\tlinked to \"xgcc\", for use when running the JIT library from the\n\tbuilddir.\n\t(MOSTLYCLEANFILES): Add FULL_DRIVER_NAME.\n\t(install-driver): Use $(FULL_DRIVER_NAME) rather than spelling it\n\tout.\n\t* configure.ac (doc_build_sys): New variable, set to \"sphinx\" if\n\tsphinx is installed, falling back to \"texinfo\" otherwise.\n\t(GCC_DRIVER_NAME): Generate a gcc-driver-name.h file containing\n\tGCC_DRIVER_NAME for the benefit of jit/internal-api.c.\n\t* configure: Regenerate.\n\t* doc/install.texi (--enable-host-shared): Specify that this is\n\trequired when building libgccjit.\n\t(Tools/packages necessary for modifying GCC): Add Sphinx.\n\t* timevar.def (TV_JIT_REPLAY): New.\n\t(TV_ASSEMBLE): New.\n\t(TV_LINK): New.\n\t(TV_LOAD): New.\n\ngcc/java/ChangeLog:\n\t* gcc/ChangeLog.jit: New.\n\ngcc/jit/ChangeLog:\n\t* ChangeLog.jit: New.\n\t* ChangeLog: New.\n\t* Make-lang.in: New.\n\t* TODO.rst: New.\n\t* config-lang.in: New.\n\t* docs/Makefile: New.\n\t* docs/_build/texinfo/Makefile: New.\n\t* docs/_build/texinfo/factorial.png: New.\n\t* docs/_build/texinfo/libgccjit.texi: New.\n\t* docs/_build/texinfo/sum-of-squares.png: New.\n\t* docs/conf.py: New.\n\t* docs/examples/tut01-hello-world.c: New.\n\t* docs/examples/tut02-square.c: New.\n\t* docs/examples/tut03-sum-of-squares.c: New.\n\t* docs/examples/tut04-toyvm/Makefile: New.\n\t* docs/examples/tut04-toyvm/factorial.toy: New.\n\t* docs/examples/tut04-toyvm/fibonacci.toy: New.\n\t* docs/examples/tut04-toyvm/toyvm.c: New.\n\t* docs/index.rst: New.\n\t* docs/internals/index.rst: New.\n\t* docs/intro/factorial.png: New.\n\t* docs/intro/index.rst: New.\n\t* docs/intro/sum-of-squares.png: New.\n\t* docs/intro/tutorial01.rst: New.\n\t* docs/intro/tutorial02.rst: New.\n\t* docs/intro/tutorial03.rst: New.\n\t* docs/intro/tutorial04.rst: New.\n\t* docs/topics/contexts.rst: New.\n\t* docs/topics/expressions.rst: New.\n\t* docs/topics/functions.rst: New.\n\t* docs/topics/index.rst: New.\n\t* docs/topics/locations.rst: New.\n\t* docs/topics/objects.rst: New.\n\t* docs/topics/results.rst: New.\n\t* docs/topics/types.rst: New.\n\t* dummy-frontend.c: New.\n\t* jit-builtins.c: New.\n\t* jit-builtins.h: New.\n\t* jit-common.h: New.\n\t* jit-playback.c: New.\n\t* jit-playback.h: New.\n\t* jit-recording.c: New.\n\t* jit-recording.h: New.\n\t* libgccjit++.h: New.\n\t* libgccjit.c: New.\n\t* libgccjit.h: New.\n\t* libgccjit.map: New.\n\t* notes.txt: New.\n\ngcc/testsuite/ChangeLog:\n\t* ChangeLog.jit: New.\n\t* jit.dg/all-non-failing-tests.h: New.\n\t* jit.dg/harness.h: New.\n\t* jit.dg/jit.exp: New.\n\t* jit.dg/test-accessing-struct.c: New.\n\t* jit.dg/test-accessing-union.c: New.\n\t* jit.dg/test-array-as-pointer.c: New.\n\t* jit.dg/test-arrays.c: New.\n\t* jit.dg/test-calling-external-function.c: New.\n\t* jit.dg/test-calling-function-ptr.c: New.\n\t* jit.dg/test-combination.c: New.\n\t* jit.dg/test-dot-product.c: New.\n\t* jit.dg/test-empty.c: New.\n\t* jit.dg/test-error-accessing-field-in-other-struct.c: New.\n\t* jit.dg/test-error-adding-to-terminated-block.c: New.\n\t* jit.dg/test-error-array-as-pointer.c: New.\n\t* jit.dg/test-error-bad-cast.c: New.\n\t* jit.dg/test-error-block-in-wrong-function.c: New.\n\t* jit.dg/test-error-call-through-ptr-with-mismatching-args.c: New.\n\t* jit.dg/test-error-call-through-ptr-with-non-function.c: New.\n\t* jit.dg/test-error-call-through-ptr-with-non-pointer.c: New.\n\t* jit.dg/test-error-call-through-ptr-with-not-enough-args.c: New.\n\t* jit.dg/test-error-call-through-ptr-with-too-many-args.c: New.\n\t* jit.dg/test-error-call-with-mismatching-args.c: New.\n\t* jit.dg/test-error-call-with-not-enough-args.c: New.\n\t* jit.dg/test-error-call-with-too-many-args.c: New.\n\t* jit.dg/test-error-dereference-field-of-non-pointer.c: New.\n\t* jit.dg/test-error-dereference-read-of-non-pointer.c: New.\n\t* jit.dg/test-error-get-type-bad-enum.c: New.\n\t* jit.dg/test-error-index-not-a-numeric-type.c: New.\n\t* jit.dg/test-error-mismatching-types-in-assignment.c: New.\n\t* jit.dg/test-error-mismatching-types-in-call.c: New.\n\t* jit.dg/test-error-missing-return.c: New.\n\t* jit.dg/test-error-new-binary-op-bad-op.c: New.\n\t* jit.dg/test-error-new-function-bad-kind.c: New.\n\t* jit.dg/test-error-new-unary-op-bad-op.c: New.\n\t* jit.dg/test-error-null-passed-to-api.c: New.\n\t* jit.dg/test-error-return-within-void-function.c: New.\n\t* jit.dg/test-error-unreachable-block.c: New.\n\t* jit.dg/test-error-unterminated-block.c: New.\n\t* jit.dg/test-error-value-not-a-numeric-type.c: New.\n\t* jit.dg/test-expressions.c: New.\n\t* jit.dg/test-factorial.c: New.\n\t* jit.dg/test-fibonacci.c: New.\n\t* jit.dg/test-functions.c: New.\n\t* jit.dg/test-fuzzer.c: New.\n\t* jit.dg/test-hello-world.c: New.\n\t* jit.dg/test-linked-list.c: New.\n\t* jit.dg/test-long-names.c: New.\n\t* jit.dg/test-nested-contexts.c: New.\n\t* jit.dg/test-nested-loops.c: New.\n\t* jit.dg/test-operator-overloading.cc: New.\n\t* jit.dg/test-quadratic.c: New.\n\t* jit.dg/test-quadratic.cc: New.\n\t* jit.dg/test-reading-struct.c: New.\n\t* jit.dg/test-string-literal.c: New.\n\t* jit.dg/test-sum-of-squares.c: New.\n\t* jit.dg/test-threads.c: New.\n\t* jit.dg/test-types.c: New.\n\t* jit.dg/test-using-global.c: New.\n\t* jit.dg/test-volatile.c: New.\n\ninclude/ChangeLog:\n\t* ChangeLog.jit: New.\n\nlibbacktrace/ChangeLog:\n\t* ChangeLog.jit: New.\n\nlibcpp/ChangeLog:\n\t* ChangeLog.jit: New.\n\nlibdecnumber/ChangeLog:\n\t* ChangeLog.jit: New.\n\nlibiberty/ChangeLog:\n\t* ChangeLog.jit: New.\n\nzlib/ChangeLog:\n\t* ChangeLog.jit: New.\n\nFrom-SVN: r217374", "tree": {"sha": "50dc30071e711da437584255821706cc0e1ef426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50dc30071e711da437584255821706cc0e1ef426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35485da996c21efc9a574520a737e10fcbeab654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35485da996c21efc9a574520a737e10fcbeab654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35485da996c21efc9a574520a737e10fcbeab654", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35485da996c21efc9a574520a737e10fcbeab654/comments", "author": null, "committer": null, "parents": [{"sha": "970a9caa49aff82c46a9d9f96410653ac9a588f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970a9caa49aff82c46a9d9f96410653ac9a588f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/970a9caa49aff82c46a9d9f96410653ac9a588f7"}], "stats": {"total": 39778, "additions": 39772, "deletions": 6}, "files": [{"sha": "4d45d9d8ed1f268f76633e9cd088a64f726a4a96", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -1,3 +1,8 @@\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: New.\n+\t* MAINTAINERS (Various Maintainers): Add myself as jit maintainer.\n+\n 2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR target/63610"}, {"sha": "d4ba859a32ca185c68b422e88eb96cc312223b1b", "filename": "ChangeLog.jit", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/ChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/ChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,23 @@\n+2014-10-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* MAINTAINERS: Update jit entry to match formatting change on\n+\ttrunk: \"Put all email addresses between '<' and '>'.\"\n+\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: Add copyright footer.\n+\n+2014-09-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* MAINTAINERS (Various Maintainers): Add myself as jit maintainer.\n+\n+2013-10-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure.ac: Add --enable-host-shared\n+\t* configure: Regenerate.\n+\f\n+Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "c7d45dfea24d9a5e55526bc3266d27a275eaf019", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -260,6 +260,7 @@ testsuite\t\tJanis Johnson\t\t<janisjo@codesourcery.com>\n register allocation\tVladimir Makarov\t<vmakarov@redhat.com>\n gdbhooks.py\t\tDavid Malcolm\t\t<dmalcolm@redhat.com>\n SLSR\t\t\tBill Schmidt\t\t<wschmidt@linux.vnet.ibm.com>\n+jit\t\t\tDavid Malcolm\t\t<dmalcolm@redhat.com>\n \n Note that individuals who maintain parts of the compiler need approval to\n check in changes outside of the parts of the compiler they maintain."}, {"sha": "2484d86e20d8a2d39f3c25795d3ac27494b4d9a7", "filename": "contrib/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -1,3 +1,9 @@\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: New.\n+\t* jit-coverage-report.py: New file: a script to print crude\n+\tcode-coverage information for the libgccjit API.\n+\n 2014-11-11  Marat Zakirov  <m.zakirov@samsung.com>\n \n \t* mklog: Symbol '}' stops search for changes.  "}, {"sha": "38a315ae039e299cb74fe266b4e04ff6ddcf5891", "filename": "contrib/ChangeLog.jit", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/contrib%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/contrib%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,14 @@\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: Add copyright footer.\n+\n+2014-01-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit-coverage-report.py: New file: a script to print crude\n+\tcode-coverage information for the libgccjit API.\n+\f\n+Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "529336f59fbfe729da8c3a16ea1508863ac8bd37", "filename": "contrib/jit-coverage-report.py", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/contrib%2Fjit-coverage-report.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/contrib%2Fjit-coverage-report.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fjit-coverage-report.py?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,67 @@\n+#! /usr/bin/python\n+#\n+# Print a report on which libgccjit.so symbols are used in which test\n+# cases, and which lack test coverage.  Tested with Python 2.7 and 3.2\n+# To be run from the root directory of the source tree.\n+#\n+# Copyright (C) 2014 Free Software Foundation, Inc.\n+# Written by David Malcolm <dmalcolm@redhat.com>.\n+#\n+# This script is Free Software, and it can be copied, distributed and\n+# modified as defined in the GNU General Public License.  A copy of\n+# its license can be downloaded from http://www.gnu.org/copyleft/gpl.html\n+\n+from collections import Counter\n+import glob\n+import re\n+import sys\n+\n+def parse_map_file(path):\n+    \"\"\"\n+    Parse libgccjit.map, returning the symbols in the API as a list of str.\n+    \"\"\"\n+    syms = []\n+    with open(path) as f:\n+        for line in f:\n+            m = re.match('^\\s+([a-z_]+);$', line)\n+            if m:\n+                syms.append(m.group(1))\n+    return syms\n+\n+def parse_test_case(path):\n+    \"\"\"\n+    Locate all symbol-like things in a C test case, yielding\n+    them as a sequence of str.\n+    \"\"\"\n+    with open(path) as f:\n+        for line in f:\n+            for m in re.finditer('([_A-Za-z][_A-Za-z0-9]*)', line):\n+                yield m.group(1)\n+\n+def find_test_cases():\n+    for path in glob.glob('gcc/testsuite/jit.dg/*.[ch]'):\n+        yield path\n+\n+api_syms = parse_map_file('gcc/jit/libgccjit.map')\n+\n+syms_in_test_cases = {}\n+for path in find_test_cases():\n+    syms_in_test_cases[path] = list(parse_test_case(path))\n+\n+uses = Counter()\n+for sym in sorted(api_syms):\n+    print('symbol: %s' % sym)\n+    uses[sym] = 0\n+    for path in syms_in_test_cases:\n+        count = syms_in_test_cases[path].count(sym)\n+        uses[sym] += count\n+        if count:\n+            print('  uses in %s: %i' % (path, count))\n+    if uses[sym] == 0:\n+        print('  NEVER USED')\n+    sys.stdout.write('\\n')\n+\n+layout = '%40s  %5s  %s'\n+print(layout % ('SYMBOL', 'USES', 'HISTOGRAM'))\n+for sym, count in uses.most_common():\n+    print(layout % (sym, count, '*' * count if count else 'UNUSED'))"}, {"sha": "951aa02b62d8273ddd36a519e9dc44b0fb6f7037", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -1,3 +1,28 @@\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: New.\n+\t* Makefile.in (doc_build_sys): New variable, set to \"sphinx\" if\n+\tsphinx is installed, falling back to \"texinfo\" otherwise.\n+\t(FULL_DRIVER_NAME): New variable, adapted from the\n+\tinstall-driver target.  New target, a symlink within the builddir,\n+\tlinked to \"xgcc\", for use when running the JIT library from the\n+\tbuilddir.\n+\t(MOSTLYCLEANFILES): Add FULL_DRIVER_NAME.\n+\t(install-driver): Use $(FULL_DRIVER_NAME) rather than spelling it\n+\tout.\n+\t* configure.ac (doc_build_sys): New variable, set to \"sphinx\" if\n+\tsphinx is installed, falling back to \"texinfo\" otherwise.\n+\t(GCC_DRIVER_NAME): Generate a gcc-driver-name.h file containing\n+\tGCC_DRIVER_NAME for the benefit of jit/internal-api.c.\n+\t* configure: Regenerate.\n+\t* doc/install.texi (--enable-host-shared): Specify that this is\n+\trequired when building libgccjit.\n+\t(Tools/packages necessary for modifying GCC): Add Sphinx.\n+\t* timevar.def (TV_JIT_REPLAY): New.\n+\t(TV_ASSEMBLE): New.\n+\t(TV_LINK): New.\n+\t(TV_LOAD): New.\n+\n 2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR target/63610"}, {"sha": "613084e5f0e8b174b041500b1b17f645f211d936", "filename": "gcc/ChangeLog.jit", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,360 @@\n+2014-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/install.texi (Tools/packages necessary for modifying GCC):\n+\tSpecify that Sphinx version 1.0 or later is required.  Wrap .rst\n+\tinside an @file command.\n+\n+2014-10-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cgraph.h: Drop now-redundant prototype of ipa_cp_c_finalize,\n+\tsince trunk added this in ipa-prop.h.\n+\t* ipa-icf.c (ipa_icf_driver): Set optimizer to NULL when\n+\tdone.\n+\n+2014-10-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/install.texi (Tools/packages necessary for modifying GCC):\n+\tAdd Sphinx.\n+\n+2014-10-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (pkgconfigdir): Drop this.\n+\t(installdirs): Likewise.\n+\t* configure.ac (gcc_version): Don't AC_SUBST this.\n+\t* configure: Regenerate.\n+\n+2014-10-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (FULL_DRIVER_NAME): New variable, adapted from the\n+\tinstall-driver target.  New target, a symlink within the builddir,\n+\tlinked to \"xgcc\", for use when running the JIT library from the\n+\tbuilddir.\n+\t(MOSTLYCLEANFILES): Add FULL_DRIVER_NAME.\n+\t(install-driver): Use $(FULL_DRIVER_NAME) rather than spelling it\n+\tout.\n+\t(site.exp): Don't set \"bindir\", as this is no longer needed when\n+\trunning the jit testsuite.\n+\n+2014-10-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure.ac: Update a reference to jit/internal-api.c to\n+\tjit/jit-playback.c.\n+\t* configure: Regenerate.\n+\n+2014-10-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (site.exp): When constructing site.exp, add a line\n+\tto set \"bindir\".\n+\t* configure.ac: Generate a gcc-driver-name.h file containing\n+\tGCC_DRIVER_NAME for the benefit of jit/internal-api.c.\n+\t* configure: Regenerate.\n+\n+2014-10-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic.c (diagnostic_finish): Free the memory for\n+\tcontext->classify_diagnostic and context->printer, running the\n+\tdestructor for the latter.\n+\n+2014-10-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure: Regenerate, after merger from trunk.\n+\n+2014-10-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure.ac (doc_build_sys): New variable, set to \"sphinx\" if\n+\tsphinx is installed, falling back to \"texinfo\" otherwise.\n+\t* configure: Regenerate.\n+\t* Makefile.in (doc_build_sys): New.\n+\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: Add copyright footer.\n+\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cgraph.h (cgraphbuild_c_finalize): Delete prototype of empty\n+\tfunction.\n+\t(ipa_c_finalize): Likewise.\n+\t(predict_c_finalize): Likewise.\n+\t(symtab_c_finalize): Likewise.\n+\t(varpool_c_finalize): Likewise.\n+\n+\t* cgraph.c (cgraph_c_finalize): Add leading comment.  Put return\n+\ttype on line before function name.\n+\t* cgraphunit.c (cgraphunit_c_finalize): Likewise.\n+\t* dwarf2out.c (dwarf2out_c_finalize): Likewise.\n+\t* gcse.c (gcse_c_finalize): Likewise.\n+\t* ipa-cp.c (ipa_cp_c_finalize): Likewise.\n+\t* ipa-reference.c (ipa_reference_c_finalize): Likewise.\n+\n+\t* params.c (params_c_finalize): Update leading comment to match\n+\tformat of the others mentioned above.\n+\n+\t* cgraphbuild.c (cgraphbuild_c_finalize): Delete empty function.\n+\t* ipa.c (ipa_c_finalize): Likewise.\n+\t* predict.c (predict_c_finalize): Likewise.\n+\t* symtab.c (symtab_c_finalize): Likewise.\n+\t* varpool.c (varpool_c_finalize): Likewise.\n+\n+\t* toplev.c (toplev::finalize): Remove calls to empty functions\n+\tcgraphbuild_c_finalize, ipa_c_finalize, predict_c_finalize,\n+\tsymtab_c_finalize, varpool_c_finalize.\n+\n+2014-09-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* passes.c (execute_ipa_summary_passes): Fix whitespace when\n+\tassigning to current_pass.\n+\t(ipa_write_summaries_2): Assign \"pass\" to \"current_pass\" global\n+\tbefore calling write_summary hook.\n+\t(ipa_write_optimization_summaries_1): Likewise when calling\n+\twrite_optimization_summary hook.\n+\t(ipa_read_summaries_1): Likewise for read_summary hook.\n+\t(ipa_read_optimization_summaries_1): Likewise for\n+\tread_optimization_summary hook.\n+\t(execute_ipa_stmt_fixups): Likewise for stmt_fixup hook.\n+\n+2014-09-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cgraph.c (cgraph_c_finalize): Remove FIXME.\n+\t* timevar.c (timevar_init): Likewise.\n+\n+2014-09-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (pkgconfigdir): New.\n+\t(installdirs): Add creation of $(DESTDIR)$(pkgconfigdir).\n+\t* configure.ac (gcc_version): Expose this value for use via\n+\tAC_SUBST, since we need it within the new file libgccjit.pc.in.\n+\t* configure: Regenerate.\n+\n+2014-09-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cgraph.c (cgraph_c_finalize): Update to reflect the movement of\n+\tmany globals into fields of the \"symtab\" object.\n+\t* cgraphunit.c (graphunit_c_finalize): Likewise.\n+\t* symtab.c (symtab_c_finalize): Likewise.\n+\n+\t* toplev.c (initialize_rtl): Move static local \"initialized_once\"\n+\tinto file scope, and rename to...\n+\t(rtl_initialized): New variable.\n+\t(toplev::finalize): Clear rtl_initialized and\n+\tthis_target_rtl->target_specific_initialized so that RTL will be\n+\treinitialized when the compiler is run more than once in-process.\n+\n+2014-07-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cgraph.h (ipa_cp_c_finalize): Add prototype.\n+\t* ipa-cp.c (ipa_cp_c_finalize): New.\n+\t* toplev.c (toplev::finalize): Add call to ipa_cp_c_finalize.\n+\n+2014-05-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* params.c (global_init_params): Require that params_finished be\n+\tfalse, rather than being idempotent, in favor of purging all state\n+\tbetween toplev invocations, since in a release build\n+\tinit_ggc_heuristics calls set_param_value_internal, and the\n+\tlatter assumes that params_finished is true.\n+\t(params_c_finalize): New.\n+\t* params.h (params_c_finalize): New.\n+\t* toplev.c (toplev::finalize): Call params_c_finalize.\n+\n+2014-03-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* toplev.c (general_init): Initialize input_location.\n+\t* input.c (input_location): Initialize to UNKNOWN_LOCATION.\n+\n+2014-03-19  Tom Tromey  <tromey@redhat.com>\n+\n+\t* timevar.h (auto_timevar): New class.\n+\n+2014-03-19  Tom Tromey  <tromey@redhat.com>\n+\n+\t* diagnostic.c (bt_stop): Use toplev::main.\n+\t* main.c (main): Update.\n+\t* toplev.c (do_compile): Remove argument.  Don't check\n+\tuse_TV_TOTAL.\n+\t(toplev::toplev, toplev::~toplev, toplev::start_timevars): New\n+\tfunctions.\n+\t(toplev::main): Rename from toplev_main.  Update.\n+\t(toplev::finalize): Rename from toplev_finalize.  Update.\n+\t* toplev.h (class toplev): New.\n+\t(struct toplev_options): Remove.\n+\t(toplev_main, toplev_finalize): Don't declare.\n+\n+2014-03-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcse.c (gcse_c_finalize): New, to clear test_insn between\n+\tin-process compiles.\n+\t* gcse.h (gcse_c_finalize): New.\n+\t* toplev.c: Include \"gcse.h\" so that we can...\n+\t(toplev_finalize): Call gcse_c_finalize.\n+\n+2014-03-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dwarf2out.c (dwarf2out_c_finalize): Release base_types.\n+\n+2014-03-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ipa-reference.c (ipa_init): Move static bool init_p from here\n+\tto...\n+\t(ipa_init_p): New file-scope variable, so that it can be reset\n+\twhen repeatedly invoking the compiler within one process by...\n+\t(ipa_reference_c_finalize): New function.\n+\t* ipa-reference.h (ipa_reference_c_finalize): New.\n+\t* toplev.c (toplev_finalize): Invoke new function\n+\tipa_reference_c_finalize.\n+\n+2014-01-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* timevar.def: Replace TV_CLIENT_CALLBACK with TV_JIT_REPLAY.\n+\n+2013-10-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/install.texi (--enable-shared): Add note contrasting it\n+\twith...\n+\t(--enable-host-shared): New option.\n+\n+2013-10-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dumpfile.h (gcc::dump_manager): New class, to hold state\n+\trelating to dumpfile management.\n+\t(get_dump_file_name): Remove in favor of method of dump_manager.\n+\t(dump_initialized_p): Likewise.\n+\t(dump_start): Likewise.\n+\t(dump_finish): Likewise.\n+\t(dump_switch_p): Likewise.\n+\t(dump_register): Likewise.\n+\t(get_dump_file_info): Likewise.\n+\t* context.c (gcc::context::context): Construct the dump_manager\n+\tinstance.\n+\t* context.h (gcc::context::get_dumps): New.\n+\t(gcc::context::m_dumps): New.\n+\t* coverage.c (coverage_init): Port to dump_manager API.\n+\t* dumpfile.c (extra_dump_files): Convert to field of\n+\tgcc::dump_manager.\n+\t(extra_dump_files_in_use): Likewise.\n+\t(extra_dump_files_alloced): Likewise.\n+\t(gcc::dump_manager::dump_manager): New.\n+\t(dump_register): Convert to...\n+\t(gcc::dump_manager::dump_register): ...method, replacing\n+\tfunction-static next_dump with m_next_dump field.\n+\t(get_dump_file_info): Convert to...\n+\t(gcc::dump_manager::get_dump_file_info): ...method.\n+\t(get_dump_file_name): Convert to...\n+\t(gcc::dump_manager::get_dump_file_name): ...method.\n+\t(dump_start): Convert to...\n+\t(gcc::dump_manager::dump_start): ...method.\n+\t(dump_finish): Convert to...\n+\t(gcc::dump_manager::dump_finish): ...method.\n+\t(dump_begin): Replace body with...\n+\t(gcc::dump_manager::dump_begin): ...new method.\n+\t(dump_phase_enabled_p): Convert to...\n+\t(gcc::dump_manager::dump_phase_enabled_p): ...method.\n+\t(dump_phase_enabled_p): Convert to...\n+\t(gcc::dump_manager::dump_phase_enabled_p): ...method.\n+\t(dump_initialized_p):  Convert to...\n+\t(gcc::dump_manager::dump_initialized_p): ...method.\n+\t(dump_flag_name): Replace body with...\n+\t(gcc::dump_manager::dump_flag_name): ...new method.\n+\t(dump_enable_all): Convert to...\n+\t(gcc::dump_manager::dump_enable_all): ...new method.\n+\t(opt_info_enable_passes): Convert to...\n+\t(gcc::dump_manager::opt_info_enable_passes): ...new method.\n+\t(dump_switch_p_1): Convert to...\n+\t(gcc::dump_manager::dump_switch_p_1): ...new method.\n+\t(dump_switch_p):  Convert to...\n+\t(gcc::dump_manager::dump_switch_p): ...new method.\n+\t(opt_info_switch_p): Port to dump_manager API.\n+\t(enable_rtl_dump_file): Likewise.\n+\t* opts-global.c (handle_common_deferred_options): Port to new\n+\tdump_manager API.\n+\t* passes.c (pass_manager::finish_optimization_passes): Likewise.\n+\t(pass_manager::register_one_dump_file): Likewise.\n+\t(pass_manager::register_pass): Likewise.\n+\t(pass_init_dump_file): Likewise.\n+\t(pass_fini_dump_file): Likewise.\n+\t* statistics.c (statistics_early_init): Likewise.\n+\n+2013-10-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ipa-inline.c (ipa_inline): Fix leak of \"order\" when\n+\toptimizations are disabled.\n+\n+2013-10-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* coverage.c (coverage_finish): Fix leak of da_file_name.\n+\n+2013-10-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in: Set PICFLAG from configure script; add it to\n+\tINTERNAL_CFLAGS.\n+\t* configure.ac (--enable-host-shared): Set up PICFLAG rather\n+\tthan attempting to append -fPIC to CFLAGS, CXXFLAGS, LDFLAGS.\n+\t* configure: Regenerate.\n+\n+2013-10-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (LIBIBERTY): Use pic build of libiberty.a if\n+\tconfigured with --enable-host-shared.\n+\t(BUILD_LIBIBERTY): Likewise.\n+\t* cgraph.c (cgraph_c_finalize): New.\n+\t* cgraph.h (symtab_c_finalize): New declaration.\n+\t(cgraph_c_finalize): Likewise.\n+\t(cgraphunit_c_finalize): Likewise.\n+\t(cgraphbuild_c_finalize): Likewise.\n+\t(ipa_c_finalize): Likewise.\n+\t(predict_c_finalize): Likewise.\n+\t(varpool_c_finalize): Likewise.\n+\t* cgraphbuild.c (cgraphbuild_c_finalize): New.\n+\t* cgraphunit.c (first_analyzed): Move from analyze_functions\n+\tto file-scope.\n+\t(first_analyzed_var): Likewise.\n+\t(analyze_functions): Move static variables into file-scope.\n+\t(cgraphunit_c_finalize): New.\n+\t* configure.ac: Add --enable-host-shared, adding -fPIC.\n+\t* configure: Regenerate.\n+\t* dwarf2out.c (dwarf2out_c_finalize): New.\n+\t* dwarf2out.h (dwarf2out_c_finalize): Declare.\n+\t* ggc-page.c (init_ggc): Make idempotent.\n+\t* ipa-pure-const.c (function_insertion_hook_holder): Move to be\n+\ta field of class pass_ipa_pure_const.\n+\t(node_duplication_hook_holder): Likewise.\n+\t(node_removal_hook_holder): Likewise.\n+\t(register_hooks): Convert to method...\n+\t(pass_ipa_pure_const::register_hooks): ...here, converting\n+\tstatic variable init_p into...\n+\t(pass_ipa_pure_const::init_p): ...new field.\n+\t(pure_const_generate_summary): Update invocation of\n+\tregister_hooks to invoke as a method of current_pass.\n+\t(pure_const_read_summary): Likewise.\n+\t(propagate): Convert to...\n+\t(pass_ipa_pure_const::execute): ...method.\n+\t* ipa.c (ipa_c_finalize): New.\n+\t* main.c (main): Update usage of toplev_main.\n+\t* params.c (global_init_params): Make idempotent.\n+\t* passes.c (execute_ipa_summary_passes): Set current_pass.\n+\t* predict.c (predict_c_finalize): New.\n+\t* stringpool.c (init_stringpool): Clean up if we're called more\n+\tthan once.\n+\t* symtab.c (symtab_c_finalize): New.\n+\t* timevar.c (timevar_init): Ignore repeated calls.\n+\t* timevar.def (TV_CLIENT_CALLBACK): Add.\n+\t(TV_ASSEMBLE): Add.\n+\t(TV_LINK): Add.\n+\t(TV_LOAD): Add.\n+\t* toplev.c (do_compile) Add parameter (const toplev_options *);\n+\tuse it to avoid starting/stopping/reporting timevar TV_TOTAL\n+\tfor the case where toplev_main does not emcompass all timevars.\n+\t(toplev_main): Add parameter (const toplev_options *); pass it\n+\tto do_compile.\n+\t(toplev_finalize): New.\n+\t* toplev.h (struct toplev_options): New.\n+\t(toplev_main): Add parameter (const toplev_options *).\n+\t(toplev_finalize): New.\n+\t* varpool.c (varpool_c_finalize): New.\n+\n+\f\n+Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "0ab3476d517b916ef1eef6178f26e4629a789cdc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -316,6 +316,11 @@ write_entries_to_file = $(shell rm -f $(2) || :) $(shell touch $(2)) \\\n \t\t\t  $(shell expr $(range) + $(write_entries_to_file_split) - 1), $(1))\" \\\n \t     | tr ' ' '\\012' >> $(2)))\n \n+# The jit documentation looks better if built with sphinx, but can be\n+# built with texinfo if sphinx is not available.\n+# configure sets \"doc_build_sys\" to \"sphinx\" or \"texinfo\" accordingly\n+doc_build_sys=@doc_build_sys@\n+\n # --------\n # UNSORTED\n # --------\n@@ -1508,14 +1513,17 @@ BACKEND = libbackend.a main.o @TREEBROWSER@ libcommon-target.a libcommon.a \\\n # front-end checking.\n TREECHECKING = @TREECHECKING@\n \n+# The full name of the driver on installation\n+FULL_DRIVER_NAME=$(target_noncanonical)-gcc-$(version)$(exeext)\n+\n MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n  insn-latencytab.c insn-opinit.c insn-opinit.h insn-preds.c insn-constants.h \\\n  tm-preds.h tm-constrs.h checksum-options gimple-match.c generic-match.c \\\n  tree-check.h min-insn-modes.c insn-modes.c insn-modes.h \\\n  genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-input.list \\\n- xgcc$(exeext) cpp$(exeext) \\\n+ xgcc$(exeext) cpp$(exeext) $(FULL_DRIVER_NAME) \\\n  $(EXTRA_PROGRAMS) gcc-cross$(exeext) \\\n  $(SPECS) collect2$(exeext) gcc-ar$(exeext) gcc-nm$(exeext) \\\n  gcc-ranlib$(exeext) \\\n@@ -1524,6 +1532,12 @@ MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  gengtype$(exeext) *.[0-9][0-9].* *.[si] *-checksum.c libbackend.a \\\n  libcommon-target.a libcommon.a libgcc.mk\n \n+# This symlink makes the full installation name of the driver be available\n+# from within the *build* directory, for use when running the JIT library\n+# from there (e.g. when running its testsuite).\n+$(FULL_DRIVER_NAME): ./xgcc\n+\t$(LN) -s $< $@\n+\n #\f\n # Language makefile fragments.\n \n@@ -3287,9 +3301,9 @@ install-driver: installdirs xgcc$(exeext)\n \t-rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)\n \t-$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)\n \t-if [ \"$(GCC_INSTALL_NAME)\" != \"$(target_noncanonical)-gcc-$(version)\" ]; then \\\n-\t  rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)$(exeext); \\\n+\t  rm -f $(DESTDIR)$(bindir)/$(FULL_DRIVER_NAME); \\\n \t  ( cd $(DESTDIR)$(bindir) && \\\n-\t    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) ); \\\n+\t    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(FULL_DRIVER_NAME) ); \\\n \tfi\n \t-if [ ! -f gcc-cross$(exeext) ] \\\n \t    && [ \"$(GCC_INSTALL_NAME)\" != \"$(GCC_TARGET_INSTALL_NAME)\" ]; then \\"}, {"sha": "7f1f47d226a38cf3a88b4c099d0eac1542d6a73d", "filename": "gcc/configure", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -743,6 +743,7 @@ CXXDEPMODE\n DEPDIR\n am__leading_dot\n CXXCPP\n+doc_build_sys\n AR\n NM\n BISON\n@@ -8069,6 +8070,47 @@ fi\n \n fi\n \n+# The jit documentation looks better if built with sphinx, but can be\n+# built with texinfo if sphinx is not available.\n+# Set \"doc_build_sys\" to \"sphinx\" or \"texinfo\" accordingly.\n+# Extract the first word of \"sphinx-build\", so it can be a program name with args.\n+set dummy sphinx-build; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if test \"${ac_cv_prog_doc_build_sys+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$doc_build_sys\"; then\n+  ac_cv_prog_doc_build_sys=\"$doc_build_sys\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if { test -f \"$as_dir/$ac_word$ac_exec_ext\" && $as_test_x \"$as_dir/$ac_word$ac_exec_ext\"; }; then\n+    ac_cv_prog_doc_build_sys=\"sphinx\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+  test -z \"$ac_cv_prog_doc_build_sys\" && ac_cv_prog_doc_build_sys=\"texinfo\"\n+fi\n+fi\n+doc_build_sys=$ac_cv_prog_doc_build_sys\n+if test -n \"$doc_build_sys\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $doc_build_sys\" >&5\n+$as_echo \"$doc_build_sys\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n \n # --------------------\n # Checks for C headers\n@@ -18058,7 +18100,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18061 \"configure\"\n+#line 18103 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -18164,7 +18206,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18167 \"configure\"\n+#line 18209 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -28185,6 +28227,12 @@ _ACEOF\n \n fi\n \n+# Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit\n+# of jit/jit-playback.c.\n+cat > gcc-driver-name.h <<EOF\n+#define GCC_DRIVER_NAME \"${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}\"\n+EOF\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "ecb75be101bef3aa8aaeea81acd74e3a0550565f", "filename": "gcc/configure.ac", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -971,6 +971,10 @@ else\n   AC_CHECK_PROG(AR, ar, ar, ${CONFIG_SHELL-/bin/sh} ${srcdir}/../missing ar)\n fi\n \n+# The jit documentation looks better if built with sphinx, but can be\n+# built with texinfo if sphinx is not available.\n+# Set \"doc_build_sys\" to \"sphinx\" or \"texinfo\" accordingly.\n+AC_CHECK_PROG(doc_build_sys, sphinx-build, sphinx, texinfo)\n \n # --------------------\n # Checks for C headers\n@@ -5604,6 +5608,12 @@ if test x\"${LINKER_HASH_STYLE}\" != x; then\n                                          [The linker hash style])\n fi\n \n+# Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit\n+# of jit/jit-playback.c.\n+cat > gcc-driver-name.h <<EOF\n+#define GCC_DRIVER_NAME \"${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}\"\n+EOF\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "9fbf853d3a38cb27aa4be0c4a95771cd19dff509", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -476,6 +476,11 @@ Necessary for running @command{texi2dvi} and @command{texi2pdf}, which\n are used when running @command{make dvi} or @command{make pdf} to create\n DVI or PDF files, respectively.\n \n+@item Sphinx version 1.0 (or later)\n+\n+Necessary to regenerate @file{jit/docs/_build/texinfo} from the @file{.rst}\n+files in the directories below @file{jit/docs}.\n+\n @item SVN (any version)\n @itemx SSH (any version)\n \n@@ -939,7 +944,7 @@ Specify that the @emph{host} code should be built into position-independent\n machine code (with -fPIC), allowing it to be used within shared libraries,\n but yielding a slightly slower compiler.\n \n-Currently this option is only of use to people developing GCC itself.\n+This option is required when building the libgccjit.so library.\n \n Contrast with @option{--enable-shared}, which affects @emph{target}\n libraries."}, {"sha": "267c3e1e0773a4f7ca2df7ab01baafb6eab84c53", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -1,3 +1,7 @@\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc/ChangeLog.jit: New.\n+\n 2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* builtins.c, java-tree.h, typeck.c: Remove redundant enum from"}, {"sha": "e5e7e273e9f9e5bbd9df5cdfa01ffdc62869b80e", "filename": "gcc/java/ChangeLog.jit", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjava%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjava%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,14 @@\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: Add copyright footer.\n+\n+2013-10-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* lang.c (java_handle_option): Update for introduction of\n+\tgcc::dump_manager.\n+\f\n+Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "23a7b1358f06ff081f5afd8f68de90965f0e27b1", "filename": "gcc/jit/ChangeLog", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,60 @@\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: New.\n+\t* ChangeLog: New.\n+\t* Make-lang.in: New.\n+\t* TODO.rst: New.\n+\t* config-lang.in: New.\n+\t* docs/Makefile: New.\n+\t* docs/_build/texinfo/Makefile: New.\n+\t* docs/_build/texinfo/factorial.png: New.\n+\t* docs/_build/texinfo/libgccjit.texi: New.\n+\t* docs/_build/texinfo/sum-of-squares.png: New.\n+\t* docs/conf.py: New.\n+\t* docs/examples/tut01-hello-world.c: New.\n+\t* docs/examples/tut02-square.c: New.\n+\t* docs/examples/tut03-sum-of-squares.c: New.\n+\t* docs/examples/tut04-toyvm/Makefile: New.\n+\t* docs/examples/tut04-toyvm/factorial.toy: New.\n+\t* docs/examples/tut04-toyvm/fibonacci.toy: New.\n+\t* docs/examples/tut04-toyvm/toyvm.c: New.\n+\t* docs/index.rst: New.\n+\t* docs/internals/index.rst: New.\n+\t* docs/intro/factorial.png: New.\n+\t* docs/intro/index.rst: New.\n+\t* docs/intro/sum-of-squares.png: New.\n+\t* docs/intro/tutorial01.rst: New.\n+\t* docs/intro/tutorial02.rst: New.\n+\t* docs/intro/tutorial03.rst: New.\n+\t* docs/intro/tutorial04.rst: New.\n+\t* docs/topics/contexts.rst: New.\n+\t* docs/topics/expressions.rst: New.\n+\t* docs/topics/functions.rst: New.\n+\t* docs/topics/index.rst: New.\n+\t* docs/topics/locations.rst: New.\n+\t* docs/topics/objects.rst: New.\n+\t* docs/topics/results.rst: New.\n+\t* docs/topics/types.rst: New.\n+\t* dummy-frontend.c: New.\n+\t* jit-builtins.c: New.\n+\t* jit-builtins.h: New.\n+\t* jit-common.h: New.\n+\t* jit-playback.c: New.\n+\t* jit-playback.h: New.\n+\t* jit-recording.c: New.\n+\t* jit-recording.h: New.\n+\t* libgccjit++.h: New.\n+\t* libgccjit.c: New.\n+\t* libgccjit.h: New.\n+\t* libgccjit.map: New.\n+\t* notes.txt: New.\n+\n+2013-07-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Initial creation\n+\n+Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "f887e0fc35ce5d288e73fe7e071257658bd4941e", "filename": "gcc/jit/ChangeLog.jit", "status": "added", "additions": 3498, "deletions": 0, "changes": 3498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "167fcadfc211ed061e8d4d70105b5d38e761023e", "filename": "gcc/jit/Make-lang.in", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FMake-lang.in?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,298 @@\n+# Top level -*- makefile -*- fragment for libgccjit.so.\n+#   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+#This file is part of GCC.\n+\n+#GCC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 3, or (at your option)\n+#any later version.\n+\n+#GCC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file provides the language dependent support in the main Makefile.\n+# Each language makefile fragment must provide the following targets:\n+#\n+# foo.all.cross, foo.start.encap, foo.rest.encap,\n+# foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,\n+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,\n+# foo.mostlyclean, foo.clean, foo.distclean,\n+# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n+#\n+# where `foo' is the name of the language.\n+#\n+# It should also provide rules for:\n+#\n+# - making any compiler driver (eg: g++)\n+# - the compiler proper (eg: cc1plus)\n+# - define the names for selecting the language in LANGUAGES.\n+\n+#\f\n+# Define the names for selecting jit in LANGUAGES.\n+# Note that it would be nice to move the dependency on g++\n+# into the jit rule, but that needs a little bit of work\n+# to do the right thing within all.cross.\n+\n+LIBGCCJIT_LINKER_NAME = libgccjit.so\n+LIBGCCJIT_VERSION_NUM = 0\n+LIBGCCJIT_MINOR_NUM = 0\n+LIBGCCJIT_RELEASE_NUM = 1\n+LIBGCCJIT_SONAME = $(LIBGCCJIT_LINKER_NAME).$(LIBGCCJIT_VERSION_NUM)\n+LIBGCCJIT_FILENAME = \\\n+  $(LIBGCCJIT_SONAME).$(LIBGCCJIT_MINOR_NUM).$(LIBGCCJIT_RELEASE_NUM)\n+\n+LIBGCCJIT_LINKER_NAME_SYMLINK = $(LIBGCCJIT_LINKER_NAME)\n+LIBGCCJIT_SONAME_SYMLINK = $(LIBGCCJIT_SONAME)\n+\n+jit: $(LIBGCCJIT_FILENAME) \\\n+\t$(LIBGCCJIT_SYMLINK) \\\n+\t$(LIBGCCJIT_LINKER_NAME_SYMLINK) \\\n+\t$(FULL_DRIVER_NAME)\n+\n+# Tell GNU make to ignore these if they exist.\n+.PHONY: jit\n+\n+jit_OBJS = attribs.o \\\n+\tjit/dummy-frontend.o \\\n+\tjit/libgccjit.o \\\n+\tjit/jit-recording.o \\\n+\tjit/jit-playback.o \\\n+\tjit/jit-builtins.o\n+\n+# Use strict warnings for this front end.\n+jit-warn = $(STRICT_WARN)\n+\n+# We avoid using $(BACKEND) from Makefile.in in order to avoid pulling\n+# in main.o\n+$(LIBGCCJIT_FILENAME): $(jit_OBJS) \\\n+\tlibbackend.a libcommon-target.a libcommon.a \\\n+\t$(CPPLIB) $(LIBDECNUMBER) \\\n+\t$(LIBDEPS) $(srcdir)/jit/libgccjit.map\n+\t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ -shared \\\n+\t     $(jit_OBJS) libbackend.a libcommon-target.a libcommon.a \\\n+\t     $(CPPLIB) $(LIBDECNUMBER) $(LIBS) $(BACKENDLIBS) \\\n+\t     -Wl,--version-script=$(srcdir)/jit/libgccjit.map \\\n+\t     -Wl,-soname,$(LIBGCCJIT_SONAME)\n+\n+$(LIBGCCJIT_SONAME_SYMLINK): $(LIBGCCJIT_FILENAME)\n+\tln -sf $(LIBGCCJIT_FILENAME) $(LIBGCCJIT_SONAME_SYMLINK)\n+\n+$(LIBGCCJIT_LINKER_NAME_SYMLINK): $(LIBGCCJIT_SONAME_SYMLINK)\n+\tln -sf $(LIBGCCJIT_SONAME_SYMLINK) $(LIBGCCJIT_LINKER_NAME_SYMLINK)\n+\n+#\f\n+# Build hooks:\n+\n+jit.all.cross:\n+jit.start.encap:\n+jit.rest.encap:\n+\n+# Documentation build hooks.\n+#\n+# The documentation can be built using the texinfo toolchain, or\n+# the sphinx toolchain\n+#\n+# The jit documentation is authored using Sphinx, which has numerous\n+# advantages over Texinfo, including:\n+#\n+#   * much faster\n+#\n+#   * use of CSS and JS to provide less of a 1990s feel in the generated\n+#     HTML.\n+#\n+#   * sane, stable HTML page and anchor names\n+#\n+#   * sane HTML navigation: ability to move forward and back in the HTML\n+#     at every node to read the HTML like a book\n+#\n+#   * syntax-coloring of examples\n+#\n+#   * the ability to \"include\" fragments of code inline.  This is used\n+#     heavily by the jit docs, so that the example code is shared by both\n+#     the test suite and the documentation to ensure that the examples\n+#     appearing in the docs actually compile and work\n+#\n+# Sphinx is not a \"blessed\" dependency, and so a prebuilt libgccjit.texinfo\n+# file built by Sphinx is checked into the source tree to avoid requiring\n+# everyone to have Sphinx installed.\n+#\n+# This prebuilt libgccjit.texinfo has the \"include\" fragments \"baked in\",\n+# and so contains the content from the sphinx toolchain, but lacks the\n+# syntax-coloring, and the generated HTML is (IMHO) greatly inferior to\n+# that generated by Sphinx.\n+\n+# These targets redirect HTML creation and installation to either\n+# jit.sphinx.(install-)html or jit.texinfo.(install-)html.\n+jit.html: jit.$(doc_build_sys).html\n+jit.install-html: jit.$(doc_build_sys).install-html\n+\n+# For now, use texinfo for pdf, since the sphinx latex toolchain currently\n+# fails for me deep inside pdflatex (see notes below)\n+jit.pdf: jit.texinfo.pdf\n+jit.install-pdf: jit.texinfo.install-pdf\n+\n+# Hooks for building docs using texinfo\n+JIT_TEXI_FILES = $(srcdir)/jit/docs/_build/texinfo/libgccjit.texi\n+\n+jit.info: doc/libgccjit.info\n+doc/libgccjit.info: $(JIT_TEXI_FILES)\n+\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n+\t  rm -f doc/libgccjit.info*; \\\n+\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n+\t\t-I $(gcc_docdir)/include -o $@ $<; \\\n+\telse true; fi\n+\n+jit.install-info: $(DESTDIR)$(infodir)/libgccjit.info\n+\n+jit.dvi: doc/libgccjit.dvi\n+doc/libgccjit.dvi: $(JIT_TEXI_FILES)\n+\t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+jit.texinfo.html: $(build_htmldir)/jit/index.html\n+\n+$(build_htmldir)/jit/index.html: $(srcdir)/jit/docs/_build/texinfo/libgccjit.texi\n+\t$(mkinstalldirs) $(@D)\n+\trm -f $(@D)/*\n+\t$(TEXI2HTML) -I $(gcc_docdir)/include -I $(srcdir)/jit -o $(@D) $<\n+\n+jit.texinfo.install-html: jit.texinfo.html\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n+\t@for p in $(build_htmldir)/jit; do \\\n+\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(html__strip_dir) \\\n+\t  if test -d \"$$d$$p\"; then \\\n+\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  else \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  fi; \\\n+\tdone\n+\n+jit.texinfo.pdf: doc/libgccjit.pdf\n+\n+doc/libgccjit.pdf: $(JIT_TEXI_FILES)\n+\t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+jit.texinfo.install-pdf: doc/libgccjit.pdf\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+\t@for p in doc/libgccjit.pdf; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(pdf__strip_dir) \\\n+\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+\tdone\n+\n+# Hooks for building docs using the Sphinx toolchain:\n+\n+SPHINX_BUILD_DIR=jit/sphinx-build\n+\n+jit.sphinx.html:\n+\tmkdir -p $(SPHINX_BUILD_DIR)\n+\t(cd $(srcdir)/jit/docs && \\\n+\t  make html BUILDDIR=$(PWD)/$(SPHINX_BUILD_DIR) )\n+\n+jit_htmldir=$(htmldir)/jit\n+\n+jit.sphinx.install-html: jit.sphinx.html\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(jit_htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(jit_htmldir)\"\n+\t@for f in $(shell cd $(SPHINX_BUILD_DIR)/html && find) ; do \\\n+\t  if test -f $(SPHINX_BUILD_DIR)/html/\"$$f\"; then \\\n+\t     $(INSTALL_DATA) $(SPHINX_BUILD_DIR)/html/\"$$f\" $(DESTDIR)$(jit_htmldir)/\"$$f\"; \\\n+\t  else \\\n+\t     mkdir $(DESTDIR)$(jit_htmldir)/\"$$f\"; \\\n+\t  fi; \\\n+\tdone\n+\n+# (This one is currently failing deep inside pdflatex for me;\n+# see https://bugzilla.redhat.com/show_bug.cgi?id=1148845 )\n+jit.sphinx.pdf: $(SPHINX_BUILD_DIR)/latex/libgccjit.pdf\n+$(SPHINX_BUILD_DIR)/latex/libgccjit.pdf:\n+\tmkdir -p $(SPHINX_BUILD_DIR)\n+\t(cd $(srcdir)/jit/docs && \\\n+\t  make latexpdf BUILDDIR=$(PWD)/$(SPHINX_BUILD_DIR) )\n+\n+jit.sphinx.install-pdf: $(SPHINX_BUILD_DIR)/latex/libgccjit.pdf\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+\t@for p in $(SPHINX_BUILD_DIR)/latex/libgccjit.pdf; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(pdf__strip_dir) \\\n+\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+\tdone\n+\n+jit.srcinfo:\n+jit.srcextra:\n+\n+jit.tags:\n+\n+jit.man:\n+\n+jit.srcman:\n+\n+lang_checks += check-jit\n+\n+#\f\n+# Install hooks:\n+jit.install-common: installdirs\n+\t$(INSTALL_PROGRAM) $(LIBGCCJIT_FILENAME) \\\n+\t  $(DESTDIR)/$(libdir)/$(LIBGCCJIT_FILENAME)\n+\tln -sf \\\n+\t  $(LIBGCCJIT_FILENAME) \\\n+\t  $(DESTDIR)/$(libdir)/$(LIBGCCJIT_SONAME_SYMLINK)\n+\tln -sf \\\n+\t  $(LIBGCCJIT_SONAME_SYMLINK)\\\n+\t  $(DESTDIR)/$(libdir)/$(LIBGCCJIT_LINKER_NAME_SYMLINK)\n+\t$(INSTALL_PROGRAM) $(srcdir)/jit/libgccjit.h \\\n+\t  $(DESTDIR)/$(includedir)/libgccjit.h\n+\t$(INSTALL_PROGRAM) $(srcdir)/jit/libgccjit++.h \\\n+\t  $(DESTDIR)/$(includedir)/libgccjit++.h\n+\n+jit.install-man:\n+\n+jit.install-plugin:\n+\n+jit.uninstall:\n+\n+#\f\n+# Clean hooks:\n+# A lot of the ancillary files are deleted by the main makefile.\n+# We just have to delete files specific to us.\n+\n+jit.mostlyclean:\n+\n+jit.clean:\n+\n+jit.distclean:\n+\n+jit.maintainer-clean:\n+\n+#\f\n+# Stage hooks:\n+# The main makefile has already created stage?/jit.\n+\n+jit.stage1: stage1-start\n+\t-mv jit/*$(objext) stage1/jit\n+jit.stage2: stage2-start\n+\t-mv jit/*$(objext) stage2/jit\n+jit.stage3: stage3-start\n+\t-mv jit/*$(objext) stage3/jit\n+jit.stage4: stage4-start\n+\t-mv jit/*$(objext) stage4/jit\n+jit.stageprofile: stageprofile-start\n+\t-mv jit/*$(objext) stageprofile/jit\n+jit.stagefeedback: stagefeedback-start\n+\t-mv jit/*$(objext) stagefeedback/jit"}, {"sha": "09c4d9da611140206e9233fbbe6717233d7b0ccf", "filename": "gcc/jit/TODO.rst", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FTODO.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2FTODO.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FTODO.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,119 @@\n+TODOs\n+-----\n+\n+API\n+===\n+* error-handling:\n+    * have a client-provided error-handling callback for the context, and\n+      call it, rather than asserting/crashing etc, to make the API resilient and helpful\n+\n+* probably should turn off signal handlers and backtracing, leaving that to\n+  the client code\n+\n+* enums and ABI: give enums specific numbers, in ranges, to make it\n+  possible to maintain a logical ordering whilst preserving ABI.\n+\n+* expose the statements in the API? (mostly so they can be stringified?)\n+\n+* support more arithmetic ops and comparison modes\n+\n+* access to a function by address::\n+\n+    extern gcc_jit_function *\n+    gcc_jit_context_get_function (ctxt,\n+                                  void *); /* need type information */\n+\n+  so you can access \"static\" fns in your code.\n+\n+* ability to turn a function into a function pointer::\n+\n+    gcc_jit_function_as_rvalue ()\n+\n+* expressing branch probabilies (like __builtin_expect)::\n+\n+    extern gcc_jit_rvalue *\n+    gcc_jit_rvalue_likely (gcc_jit_rvalue *rvalue,\n+                           int is_likely);\n+\n+  though would:\n+\n+    extern void\n+    gcc_jit_block_set_likelihood (gcc_jit_block *block,\n+                                  int hotness);\n+\n+  be better?  (for expressing how hot the current location is)\n+\n+* add a SONAME to the library (and potentially version the symbols?)\n+\n+* do we need alternative forms of division (floor vs rounding)?\n+\n+* are we missing any ops?\n+\n+* error-checking:\n+\n+    * gcc_jit_context_new_unary_op: various checks needed\n+\n+    * gcc_jit_context_new_binary_op: various checks needed\n+\n+    * gcc_jit_context_new_comparison: must be numeric or pointer types\n+\n+    * gcc_jit_context_new_array_access: \"index\" must be of numeric type.\n+\n+    * gcc_jit_lvalue_access_field: must be field of correct struct\n+\n+    * gcc_jit_rvalue_access_field: must be field of correct struct\n+\n+    * gcc_jit_block_add_assignment_op: check the types\n+\n+* Implement more kinds of casts e.g. pointers\n+\n+Bugs\n+====\n+* fixing all the state issues: make it work repeatedly with optimization\n+  turned up to full.\n+\n+* make the dirty dirty hacks less egregious...\n+\n+* test under valgrind; fix memory leaks\n+\n+* re-architect gcc so we don't have to reinitialize everything every time\n+  a context is compiled\n+\n+Test suite\n+==========\n+* get DejaGnu to build and run C++ testcases\n+\n+* measure code coverage in testing of libgccjit.so\n+\n+Future milestones\n+=================\n+* try porting llvmpipe to gcc\n+\n+* inline assembler?\n+\n+* Detect and issue warnings/errors about uses of uninitialized variables\n+\n+* Warn about unused objects in a context (e.g. rvalues/lvalues)?  (e.g.\n+  for gcc_jit_context_new_call vs gcc_jit_block_add_eval)\n+\n+Nice to have\n+============\n+* Currently each function has a single stmt_list, which is built in\n+  postprocessing by walking the list of blocks.  Presumably we could\n+  have each block have its own stmt_list, avoiding the need for this\n+  traversal, and having the block structure show up within tree dumps.\n+  Alternatively, could we skip tree and go straight to gimple?\n+\n+* ability to give contexts names, for ease of debugging?\n+\n+\n+Probably not needed\n+===================\n+* \"switch\" and \"case\" ?\n+\n+* sizeof (should this be an API hook?)  do we even need it? presumably\n+  client code can just do the sizeof() in its own code.\n+\n+* do we need unary plus?\n+\n+etc etc"}, {"sha": "7a32afe7b7b0c6f9e5356244c56f58e1c0858500", "filename": "gcc/jit/config-lang.in", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fconfig-lang.in?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,38 @@\n+# Top level configure fragment for libgccjit.so.\n+#   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+#This file is part of GCC.\n+\n+#GCC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 3, or (at your option)\n+#any later version.\n+\n+#GCC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+\n+language=\"jit\"\n+\n+compilers=\"libgccjit.so\"\n+\n+target_libs=\"\"\n+\n+gtfiles=\"\\$(srcdir)/jit/dummy-frontend.c\"\n+\n+# The configuration requires --enable-host-shared\n+# for jit to be supported.\n+# Hence to get the jit, one must configure with:\n+#   --enable-host-shared --enable-languages=jit\n+build_by_default=\"no\""}, {"sha": "7d20702455a2714b6502da0779bcfea83456b43a", "filename": "gcc/jit/docs/Makefile", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2FMakefile?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,153 @@\n+# Makefile for Sphinx documentation\n+#\n+\n+# You can set these variables from the command line.\n+SPHINXOPTS    =\n+SPHINXBUILD   = sphinx-build\n+PAPER         =\n+BUILDDIR      = _build\n+\n+# Internal variables.\n+PAPEROPT_a4     = -D latex_paper_size=a4\n+PAPEROPT_letter = -D latex_paper_size=letter\n+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .\n+# the i18n builder cannot share the environment and doctrees with the others\n+I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .\n+\n+.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext\n+\n+help:\n+\t@echo \"Please use \\`make <target>' where <target> is one of\"\n+\t@echo \"  html       to make standalone HTML files\"\n+\t@echo \"  dirhtml    to make HTML files named index.html in directories\"\n+\t@echo \"  singlehtml to make a single large HTML file\"\n+\t@echo \"  pickle     to make pickle files\"\n+\t@echo \"  json       to make JSON files\"\n+\t@echo \"  htmlhelp   to make HTML files and a HTML help project\"\n+\t@echo \"  qthelp     to make HTML files and a qthelp project\"\n+\t@echo \"  devhelp    to make HTML files and a Devhelp project\"\n+\t@echo \"  epub       to make an epub\"\n+\t@echo \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n+\t@echo \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n+\t@echo \"  text       to make text files\"\n+\t@echo \"  man        to make manual pages\"\n+\t@echo \"  texinfo    to make Texinfo files\"\n+\t@echo \"  info       to make Texinfo files and run them through makeinfo\"\n+\t@echo \"  gettext    to make PO message catalogs\"\n+\t@echo \"  changes    to make an overview of all changed/added/deprecated items\"\n+\t@echo \"  linkcheck  to check all external links for integrity\"\n+\t@echo \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n+\n+clean:\n+\t-rm -rf $(BUILDDIR)/*\n+\n+html:\n+\t$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html\n+\t@echo\n+\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/html.\"\n+\n+dirhtml:\n+\t$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml\n+\t@echo\n+\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/dirhtml.\"\n+\n+singlehtml:\n+\t$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml\n+\t@echo\n+\t@echo \"Build finished. The HTML page is in $(BUILDDIR)/singlehtml.\"\n+\n+pickle:\n+\t$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle\n+\t@echo\n+\t@echo \"Build finished; now you can process the pickle files.\"\n+\n+json:\n+\t$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json\n+\t@echo\n+\t@echo \"Build finished; now you can process the JSON files.\"\n+\n+htmlhelp:\n+\t$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp\n+\t@echo\n+\t@echo \"Build finished; now you can run HTML Help Workshop with the\" \\\n+\t      \".hhp project file in $(BUILDDIR)/htmlhelp.\"\n+\n+qthelp:\n+\t$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp\n+\t@echo\n+\t@echo \"Build finished; now you can run \"qcollectiongenerator\" with the\" \\\n+\t      \".qhcp project file in $(BUILDDIR)/qthelp, like this:\"\n+\t@echo \"# qcollectiongenerator $(BUILDDIR)/qthelp/libgccjit.qhcp\"\n+\t@echo \"To view the help file:\"\n+\t@echo \"# assistant -collectionFile $(BUILDDIR)/qthelp/libgccjit.qhc\"\n+\n+devhelp:\n+\t$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp\n+\t@echo\n+\t@echo \"Build finished.\"\n+\t@echo \"To view the help file:\"\n+\t@echo \"# mkdir -p $$HOME/.local/share/devhelp/libgccjit\"\n+\t@echo \"# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/libgccjit\"\n+\t@echo \"# devhelp\"\n+\n+epub:\n+\t$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub\n+\t@echo\n+\t@echo \"Build finished. The epub file is in $(BUILDDIR)/epub.\"\n+\n+latex:\n+\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n+\t@echo\n+\t@echo \"Build finished; the LaTeX files are in $(BUILDDIR)/latex.\"\n+\t@echo \"Run \\`make' in that directory to run these through (pdf)latex\" \\\n+\t      \"(use \\`make latexpdf' here to do that automatically).\"\n+\n+latexpdf:\n+\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n+\t@echo \"Running LaTeX files through pdflatex...\"\n+\t$(MAKE) -C $(BUILDDIR)/latex all-pdf\n+\t@echo \"pdflatex finished; the PDF files are in $(BUILDDIR)/latex.\"\n+\n+text:\n+\t$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text\n+\t@echo\n+\t@echo \"Build finished. The text files are in $(BUILDDIR)/text.\"\n+\n+man:\n+\t$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man\n+\t@echo\n+\t@echo \"Build finished. The manual pages are in $(BUILDDIR)/man.\"\n+\n+texinfo:\n+\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo\n+\t@echo\n+\t@echo \"Build finished. The Texinfo files are in $(BUILDDIR)/texinfo.\"\n+\t@echo \"Run \\`make' in that directory to run these through makeinfo\" \\\n+\t      \"(use \\`make info' here to do that automatically).\"\n+\n+info:\n+\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo\n+\t@echo \"Running Texinfo files through makeinfo...\"\n+\tmake -C $(BUILDDIR)/texinfo info\n+\t@echo \"makeinfo finished; the Info files are in $(BUILDDIR)/texinfo.\"\n+\n+gettext:\n+\t$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale\n+\t@echo\n+\t@echo \"Build finished. The message catalogs are in $(BUILDDIR)/locale.\"\n+\n+changes:\n+\t$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes\n+\t@echo\n+\t@echo \"The overview file is in $(BUILDDIR)/changes.\"\n+\n+linkcheck:\n+\t$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck\n+\t@echo\n+\t@echo \"Link check complete; look for any errors in the above output \" \\\n+\t      \"or in $(BUILDDIR)/linkcheck/output.txt.\"\n+\n+doctest:\n+\t$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest\n+\t@echo \"Testing of doctests in the sources finished, look at the \" \\\n+\t      \"results in $(BUILDDIR)/doctest/output.txt.\""}, {"sha": "87e3048f44fd81b5722b0dea11c180d57e5d4211", "filename": "gcc/jit/docs/_build/texinfo/Makefile", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2FMakefile?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,50 @@\n+# Makefile for Sphinx Texinfo output\n+\n+infodir ?= /usr/share/info\n+\n+MAKEINFO = makeinfo --no-split\n+MAKEINFO_html = makeinfo --no-split --html\n+MAKEINFO_plaintext = makeinfo --no-split --plaintext\n+TEXI2PDF = texi2pdf --batch --expand\n+INSTALL_INFO = install-info\n+\n+ALLDOCS = $(basename $(wildcard *.texi))\n+\n+all: info\n+info: $(addsuffix .info,$(ALLDOCS))\n+plaintext: $(addsuffix .txt,$(ALLDOCS))\n+html: $(addsuffix .html,$(ALLDOCS))\n+pdf: $(addsuffix .pdf,$(ALLDOCS))\n+\n+install-info: info\n+\tfor f in *.info; do \\\n+\t  cp -t $(infodir) \"$$f\" && \\\n+\t  $(INSTALL_INFO) --info-dir=$(infodir) \"$$f\" ; \\\n+\tdone\n+\n+uninstall-info: info\n+\tfor f in *.info; do \\\n+\t  rm -f \"$(infodir)/$$f\"  ; \\\n+\t  $(INSTALL_INFO) --delete --info-dir=$(infodir) \"$$f\" ; \\\n+\tdone\n+\n+%.info: %.texi\n+\t$(MAKEINFO) -o '$@' '$<'\n+\n+%.txt: %.texi\n+\t$(MAKEINFO_plaintext) -o '$@' '$<'\n+\n+%.html: %.texi\n+\t$(MAKEINFO_html) -o '$@' '$<'\n+\n+%.pdf: %.texi\n+\t-$(TEXI2PDF) '$<'\n+\t-$(TEXI2PDF) '$<'\n+\t-$(TEXI2PDF) '$<'\n+\n+clean:\n+\t-rm -f *.info *.pdf *.txt *.html\n+\t-rm -f *.log *.ind *.aux *.toc *.syn *.idx *.out *.ilg *.pla *.ky *.pg\n+\t-rm -f *.vr *.tp *.fn *.fns *.def *.defs *.cp *.cps *.ge *.ges *.mo\n+\n+.PHONY: all info plaintext html pdf install-info uninstall-info clean"}, {"sha": "dff47ce276721746c2b1f1ae4059ea77c7bf5b75", "filename": "gcc/jit/docs/_build/texinfo/factorial.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Ffactorial.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Ffactorial.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Ffactorial.png?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "58ba150c0560fef38adb75fd9ebc72f4b88f5d3e", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "added", "additions": 6537, "deletions": 0, "changes": 6537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "7a3b4afff38e2f365ef2a09df997cb98d032fbcb", "filename": "gcc/jit/docs/_build/texinfo/sum-of-squares.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Fsum-of-squares.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Fsum-of-squares.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Fsum-of-squares.png?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "c300339322f574a86053f28fbb2e7bd8ddbde401", "filename": "gcc/jit/docs/conf.py", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fconf.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fconf.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fconf.py?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,258 @@\n+# -*- coding: utf-8 -*-\n+#\n+# libgccjit documentation build configuration file, created by\n+# sphinx-quickstart on Wed Jul 30 13:39:01 2014.\n+#\n+# This file is execfile()d with the current directory set to its containing dir.\n+#\n+# Note that not all possible configuration values are present in this\n+# autogenerated file.\n+#\n+# All configuration values have a default; values that are commented out\n+# serve to show the default.\n+\n+import sys, os\n+\n+# If extensions (or modules to document with autodoc) are in another directory,\n+# add these directories to sys.path here. If the directory is relative to the\n+# documentation root, use os.path.abspath to make it absolute, like shown here.\n+#sys.path.insert(0, os.path.abspath('.'))\n+\n+# -- General configuration -----------------------------------------------------\n+\n+# If your documentation needs a minimal Sphinx version, state it here.\n+#needs_sphinx = '1.0'\n+\n+# Add any Sphinx extension module names here, as strings. They can be extensions\n+# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n+extensions = []\n+\n+# Add any paths that contain templates here, relative to this directory.\n+templates_path = ['_templates']\n+\n+# The suffix of source filenames.\n+source_suffix = '.rst'\n+\n+# The encoding of source files.\n+#source_encoding = 'utf-8-sig'\n+\n+# The master toctree document.\n+master_doc = 'index'\n+\n+# General information about the project.\n+project = u'libgccjit'\n+copyright = u'2014, Free Software Foundation'\n+\n+# GCC-specific: extract version information from \"gcc\" src subdir for\n+# use in \"version\" and \"release\" below.\n+def __read_file(name):\n+    gcc_srcdir = '../..'\n+    path = os.path.join(gcc_srcdir, name)\n+    if os.path.exists(path):\n+        return open(path).read().strip()\n+    else:\n+        return ''\n+gcc_BASEVER = __read_file('BASE-VER')\n+gcc_DEVPHASE = __read_file('DEV-PHASE')\n+gcc_DATESTAMP = __read_file('DATESTAMP')\n+gcc_REVISION = __read_file('REVISION')\n+\n+# The version info for the project you're documenting, acts as replacement for\n+# |version| and |release|, also used in various other places throughout the\n+# built documents.\n+#\n+# The short X.Y version.\n+version = gcc_BASEVER\n+# The full version, including alpha/beta/rc tags.\n+release = ('%s (%s %s%s)'\n+           % (gcc_BASEVER, gcc_DEVPHASE, gcc_DATESTAMP,\n+              (' %s' % gcc_REVISION) if gcc_REVISION else ''))\n+\n+# The language for content autogenerated by Sphinx. Refer to documentation\n+# for a list of supported languages.\n+#language = None\n+\n+# There are two options for replacing |today|: either, you set today to some\n+# non-false value, then it is used:\n+#today = ''\n+# Else, today_fmt is used as the format for a strftime call.\n+#today_fmt = '%B %d, %Y'\n+\n+# List of patterns, relative to source directory, that match files and\n+# directories to ignore when looking for source files.\n+exclude_patterns = ['_build']\n+\n+# The reST default role (used for this markup: `text`) to use for all documents.\n+#default_role = None\n+\n+# If true, '()' will be appended to :func: etc. cross-reference text.\n+#add_function_parentheses = True\n+\n+# If true, the current module name will be prepended to all description\n+# unit titles (such as .. function::).\n+#add_module_names = True\n+\n+# If true, sectionauthor and moduleauthor directives will be shown in the\n+# output. They are ignored by default.\n+#show_authors = False\n+\n+# The name of the Pygments (syntax highlighting) style to use.\n+pygments_style = 'sphinx'\n+\n+# A list of ignored prefixes for module index sorting.\n+#modindex_common_prefix = []\n+\n+\n+# -- Options for HTML output ---------------------------------------------------\n+\n+# The theme to use for HTML and HTML Help pages.  See the documentation for\n+# a list of builtin themes.\n+html_theme = 'pyramid'\n+\n+# Theme options are theme-specific and customize the look and feel of a theme\n+# further.  For a list of options available for each theme, see the\n+# documentation.\n+#html_theme_options = {}\n+\n+# Add any paths that contain custom themes here, relative to this directory.\n+#html_theme_path = []\n+\n+# The name for this set of Sphinx documents.  If None, it defaults to\n+# \"<project> v<release> documentation\".\n+#html_title = None\n+\n+# A shorter title for the navigation bar.  Default is the same as html_title.\n+#html_short_title = None\n+\n+# The name of an image file (relative to this directory) to place at the top\n+# of the sidebar.\n+#html_logo = None\n+\n+# The name of an image file (within the static path) to use as favicon of the\n+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n+# pixels large.\n+#html_favicon = None\n+\n+# Add any paths that contain custom static files (such as style sheets) here,\n+# relative to this directory. They are copied after the builtin static files,\n+# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n+html_static_path = ['_static']\n+\n+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n+# using the given strftime format.\n+#html_last_updated_fmt = '%b %d, %Y'\n+\n+# If true, SmartyPants will be used to convert quotes and dashes to\n+# typographically correct entities.\n+#html_use_smartypants = True\n+\n+# Custom sidebar templates, maps document names to template names.\n+#html_sidebars = {}\n+\n+# Additional templates that should be rendered to pages, maps page names to\n+# template names.\n+#html_additional_pages = {}\n+\n+# If false, no module index is generated.\n+#html_domain_indices = True\n+\n+# If false, no index is generated.\n+#html_use_index = True\n+\n+# If true, the index is split into individual pages for each letter.\n+#html_split_index = False\n+\n+# If true, links to the reST sources are added to the pages.\n+#html_show_sourcelink = True\n+\n+# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n+#html_show_sphinx = True\n+\n+# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n+#html_show_copyright = True\n+\n+# If true, an OpenSearch description file will be output, and all pages will\n+# contain a <link> tag referring to it.  The value of this option must be the\n+# base URL from which the finished HTML is served.\n+#html_use_opensearch = ''\n+\n+# This is the file name suffix for HTML files (e.g. \".xhtml\").\n+#html_file_suffix = None\n+\n+# Output file base name for HTML help builder.\n+htmlhelp_basename = 'libgccjitdoc'\n+\n+\n+# -- Options for LaTeX output --------------------------------------------------\n+\n+latex_elements = {\n+# The paper size ('letterpaper' or 'a4paper').\n+#'papersize': 'letterpaper',\n+\n+# The font size ('10pt', '11pt' or '12pt').\n+#'pointsize': '10pt',\n+\n+# Additional stuff for the LaTeX preamble.\n+#'preamble': '',\n+}\n+\n+# Grouping the document tree into LaTeX files. List of tuples\n+# (source start file, target name, title, author, documentclass [howto/manual]).\n+latex_documents = [\n+  ('index', 'libgccjit.tex', u'libgccjit Documentation',\n+   u'David Malcolm', 'manual'),\n+]\n+\n+# The name of an image file (relative to this directory) to place at the top of\n+# the title page.\n+#latex_logo = None\n+\n+# For \"manual\" documents, if this is true, then toplevel headings are parts,\n+# not chapters.\n+#latex_use_parts = False\n+\n+# If true, show page references after internal links.\n+#latex_show_pagerefs = False\n+\n+# If true, show URL addresses after external links.\n+#latex_show_urls = False\n+\n+# Documents to append as an appendix to all manuals.\n+#latex_appendices = []\n+\n+# If false, no module index is generated.\n+#latex_domain_indices = True\n+\n+\n+# -- Options for manual page output --------------------------------------------\n+\n+# One entry per manual page. List of tuples\n+# (source start file, name, description, authors, manual section).\n+man_pages = [\n+    ('index', 'libgccjit', u'libgccjit Documentation',\n+     [u'David Malcolm'], 1)\n+]\n+\n+# If true, show URL addresses after external links.\n+#man_show_urls = False\n+\n+\n+# -- Options for Texinfo output ------------------------------------------------\n+\n+# Grouping the document tree into Texinfo files. List of tuples\n+# (source start file, target name, title, author,\n+#  dir menu entry, description, category)\n+texinfo_documents = [\n+  ('index', 'libgccjit', u'libgccjit Documentation',\n+   u'David Malcolm', 'libgccjit', 'One line description of project.',\n+   'Miscellaneous'),\n+]\n+\n+# Documents to append as an appendix to all manuals.\n+#texinfo_appendices = []\n+\n+# If false, no module index is generated.\n+#texinfo_domain_indices = True\n+\n+# How to display URL addresses: 'footnote', 'no', or 'inline'.\n+#texinfo_show_urls = 'footnote'"}, {"sha": "49c9651db2b537a51a845845816e8875e1b77ff5", "filename": "gcc/jit/docs/examples/tut01-hello-world.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut01-hello-world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut01-hello-world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut01-hello-world.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,123 @@\n+/* Smoketest example for libgccjit.so\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <libgccjit.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+static void\n+create_code (gcc_jit_context *ctxt)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     greet (const char *name)\n+     {\n+        printf (\"hello %s\\n\", name);\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"greet\",\n+                                  1, &param_name,\n+                                  0);\n+\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_function *printf_func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  gcc_jit_context_get_type (\n+\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n+\t\t\t\t  \"printf\",\n+\t\t\t\t  1, &param_format,\n+\t\t\t\t  1);\n+  gcc_jit_rvalue *args[2];\n+  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n+  args[1] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+                              NULL,\n+                              printf_func,\n+                              2, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  gcc_jit_context *ctxt;\n+  gcc_jit_result *result;\n+\n+  /* Get a \"context\" object for working with the library.  */\n+  ctxt = gcc_jit_context_acquire ();\n+  if (!ctxt)\n+    {\n+      fprintf (stderr, \"NULL ctxt\");\n+      exit (1);\n+    }\n+\n+  /* Set some options on the context.\n+     Let's see the code being generated, in assembler form.  */\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+    0);\n+\n+  /* Populate the context.  */\n+  create_code (ctxt);\n+\n+  /* Compile the code.  */\n+  result = gcc_jit_context_compile (ctxt);\n+  if (!result)\n+    {\n+      fprintf (stderr, \"NULL result\");\n+      exit (1);\n+    }\n+\n+  /* Extract the generated code from \"result\".  */\n+  typedef void (*fn_type) (const char *);\n+  fn_type greet =\n+    (fn_type)gcc_jit_result_get_code (result, \"greet\");\n+  if (!greet)\n+    {\n+      fprintf (stderr, \"NULL greet\");\n+      exit (1);\n+    }\n+\n+  /* Now call the generated function: */\n+  greet (\"world\");\n+  fflush (stdout);\n+\n+  gcc_jit_context_release (ctxt);\n+  gcc_jit_result_release (result);\n+  return 0;\n+}"}, {"sha": "5eae179994959911ec101db4654fb7c5b855f83f", "filename": "gcc/jit/docs/examples/tut02-square.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,107 @@\n+/* Usage example for libgccjit.so\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <libgccjit.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+void\n+create_code (gcc_jit_context *ctxt)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+      int square (int i)\n+      {\n+        return i * i;\n+      }\n+  */\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_param *param_i =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  int_type,\n+                                  \"square\",\n+                                  1, &param_i,\n+                                  0);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_rvalue *expr =\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT, int_type,\n+      gcc_jit_param_as_rvalue (param_i),\n+      gcc_jit_param_as_rvalue (param_i));\n+\n+   gcc_jit_block_end_with_return (block, NULL, expr);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  gcc_jit_context *ctxt = NULL;\n+  gcc_jit_result *result = NULL;\n+\n+  /* Get a \"context\" object for working with the library.  */\n+  ctxt = gcc_jit_context_acquire ();\n+  if (!ctxt)\n+    {\n+      fprintf (stderr, \"NULL ctxt\");\n+      goto error;\n+    }\n+\n+  /* Set some options on the context.\n+     Let's see the code being generated, in assembler form.  */\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+    0);\n+\n+  /* Populate the context.  */\n+  create_code (ctxt);\n+\n+  /* Compile the code.  */\n+  result = gcc_jit_context_compile (ctxt);\n+  if (!result)\n+    {\n+      fprintf (stderr, \"NULL result\");\n+      goto error;\n+    }\n+\n+  /* Extract the generated code from \"result\".  */\n+  void *fn_ptr = gcc_jit_result_get_code (result, \"square\");\n+  if (!fn_ptr)\n+     {\n+       fprintf (stderr, \"NULL fn_ptr\");\n+       goto error;\n+     }\n+\n+  typedef int (*fn_type) (int);\n+  fn_type square = (fn_type)fn_ptr;\n+  printf (\"result: %d\", square (5));\n+\n+ error:\n+  gcc_jit_context_release (ctxt);\n+  gcc_jit_result_release (result);\n+  return 0;\n+}"}, {"sha": "594230b5563abd30c34844d1c054598845c4b504", "filename": "gcc/jit/docs/examples/tut03-sum-of-squares.c", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut03-sum-of-squares.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut03-sum-of-squares.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut03-sum-of-squares.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,172 @@\n+/* Usage example for libgccjit.so\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <libgccjit.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+void\n+create_code (gcc_jit_context *ctxt)\n+{\n+  /*\n+    Simple sum-of-squares, to test conditionals and looping\n+\n+    int loop_test (int n)\n+    {\n+      int i;\n+      int sum = 0;\n+      for (i = 0; i < n ; i ++)\n+      {\n+\tsum += i * i;\n+      }\n+      return sum;\n+   */\n+  gcc_jit_type *the_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = the_type;\n+\n+  gcc_jit_param *n =\n+    gcc_jit_context_new_param (ctxt, NULL, the_type, \"n\");\n+  gcc_jit_param *params[1] = {n};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"loop_test\",\n+\t\t\t\t  1, params, 0);\n+\n+  /* Build locals:  */\n+  gcc_jit_lvalue *i =\n+    gcc_jit_function_new_local (func, NULL, the_type, \"i\");\n+  gcc_jit_lvalue *sum =\n+    gcc_jit_function_new_local (func, NULL, the_type, \"sum\");\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+  gcc_jit_block *b_loop_cond =\n+    gcc_jit_function_new_block (func, \"loop_cond\");\n+  gcc_jit_block *b_loop_body =\n+    gcc_jit_function_new_block (func, \"loop_body\");\n+  gcc_jit_block *b_after_loop =\n+    gcc_jit_function_new_block (func, \"after_loop\");\n+\n+  /* sum = 0; */\n+  gcc_jit_block_add_assignment (\n+    b_initial, NULL,\n+    sum,\n+    gcc_jit_context_zero (ctxt, the_type));\n+\n+  /* i = 0; */\n+  gcc_jit_block_add_assignment (\n+    b_initial, NULL,\n+    i,\n+    gcc_jit_context_zero (ctxt, the_type));\n+\n+  gcc_jit_block_end_with_jump (b_initial, NULL, b_loop_cond);\n+\n+  /* if (i >= n) */\n+  gcc_jit_block_end_with_conditional (\n+    b_loop_cond, NULL,\n+    gcc_jit_context_new_comparison (\n+       ctxt, NULL,\n+       GCC_JIT_COMPARISON_GE,\n+       gcc_jit_lvalue_as_rvalue (i),\n+       gcc_jit_param_as_rvalue (n)),\n+    b_after_loop,\n+    b_loop_body);\n+\n+  /* sum += i * i */\n+  gcc_jit_block_add_assignment_op (\n+    b_loop_body, NULL,\n+    sum,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT, the_type,\n+      gcc_jit_lvalue_as_rvalue (i),\n+      gcc_jit_lvalue_as_rvalue (i)));\n+\n+  /* i++ */\n+  gcc_jit_block_add_assignment_op (\n+    b_loop_body, NULL,\n+    i,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_one (ctxt, the_type));\n+\n+  gcc_jit_block_end_with_jump (b_loop_body, NULL, b_loop_cond);\n+\n+  /* return sum */\n+  gcc_jit_block_end_with_return (\n+    b_after_loop,\n+    NULL,\n+    gcc_jit_lvalue_as_rvalue (sum));\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  gcc_jit_context *ctxt = NULL;\n+  gcc_jit_result *result = NULL;\n+\n+  /* Get a \"context\" object for working with the library.  */\n+  ctxt = gcc_jit_context_acquire ();\n+  if (!ctxt)\n+    {\n+      fprintf (stderr, \"NULL ctxt\");\n+      goto error;\n+    }\n+\n+  /* Set some options on the context.\n+     Let's see the code being generated, in assembler form.  */\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+    0);\n+\n+  /* Populate the context.  */\n+  create_code (ctxt);\n+\n+  /* Compile the code.  */\n+  result = gcc_jit_context_compile (ctxt);\n+  if (!result)\n+    {\n+      fprintf (stderr, \"NULL result\");\n+      goto error;\n+    }\n+\n+  /* Extract the generated code from \"result\".  */\n+  typedef int (*loop_test_fn_type) (int);\n+  loop_test_fn_type loop_test =\n+    (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\n+  if (!loop_test)\n+    {\n+      fprintf (stderr, \"NULL loop_test\");\n+      goto error;\n+    }\n+\n+  /* Run the generated code.  */\n+  int val = loop_test (10);\n+  printf(\"loop_test returned: %d\\n\", val);\n+\n+ error:\n+  gcc_jit_context_release (ctxt);\n+  gcc_jit_result_release (result);\n+  return 0;\n+}"}, {"sha": "1b45c8de186dfbcf8b319b389bb883b2361326f1", "filename": "gcc/jit/docs/examples/tut04-toyvm/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2FMakefile?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,11 @@\n+factorial: toyvm\n+\t./toyvm factorial.toy 10\n+\n+fibonacci: toyvm\n+\t./toyvm fibonacci.toy 8\n+\n+toyvm: toyvm.c Makefile\n+\tg++ -Wall -g -o $@ $< $(shell pkg-config --cflags --libs libgccjit)\n+\n+clean:\n+\trm -f *.o toyvm"}, {"sha": "48e4034e8ac3c089a0db419ede18da40a44481cd", "filename": "gcc/jit/docs/examples/tut04-toyvm/factorial.toy", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ffactorial.toy", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ffactorial.toy", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ffactorial.toy?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,50 @@\n+# Simple recursive factorial implementation, roughly equivalent to:\n+#\n+#  int factorial (int arg)\n+#  {\n+#     if (arg < 2)\n+#       return arg\n+#     return arg * factorial (arg - 1)\n+#  }\n+\n+# Initial state:\n+# stack: [arg]\n+\n+# 0:\n+DUP\n+# stack: [arg, arg]\n+\n+# 1:\n+PUSH_CONST 2\n+# stack: [arg, arg, 2]\n+\n+# 2:\n+BINARY_COMPARE_LT\n+# stack: [arg, (arg < 2)]\n+\n+# 3:\n+JUMP_ABS_IF_TRUE 9\n+# stack: [arg]\n+\n+# 4:\n+DUP\n+# stack: [arg, arg]\n+\n+# 5:\n+PUSH_CONST 1\n+# stack: [arg, arg, 1]\n+\n+# 6:\n+BINARY_SUBTRACT\n+# stack: [arg,  (arg - 1)\n+\n+# 7:\n+RECURSE\n+# stack: [arg, factorial(arg - 1)]\n+\n+# 8:\n+BINARY_MULT\n+# stack: [arg * factorial(arg - 1)]\n+\n+# 9:\n+RETURN"}, {"sha": "5ae0a4062523f65ac76178660a6c1bc125da1eac", "filename": "gcc/jit/docs/examples/tut04-toyvm/fibonacci.toy", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ffibonacci.toy", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ffibonacci.toy", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ffibonacci.toy?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,66 @@\n+# Simple recursive fibonacci implementation, roughly equivalent to:\n+#\n+#  int fibonacci (int arg)\n+#  {\n+#     if (arg < 2)\n+#       return arg\n+#     return fibonacci (arg-1) + fibonacci (arg-2)\n+#  }\n+\n+# Initial state:\n+# stack: [arg]\n+\n+# 0:\n+DUP\n+# stack: [arg, arg]\n+\n+# 1:\n+PUSH_CONST 2\n+# stack: [arg, arg, 2]\n+\n+# 2:\n+BINARY_COMPARE_LT\n+# stack: [arg, (arg < 2)]\n+\n+# 3:\n+JUMP_ABS_IF_TRUE 13\n+# stack: [arg]\n+\n+# 4:\n+DUP\n+# stack: [arg, arg]\n+\n+# 5:\n+PUSH_CONST  1\n+# stack: [arg, arg, 1]\n+\n+# 6:\n+BINARY_SUBTRACT\n+# stack: [arg,  (arg - 1)\n+\n+# 7:\n+RECURSE\n+# stack: [arg, fib(arg - 1)]\n+\n+# 8:\n+ROT\n+# stack: [fib(arg - 1), arg]\n+\n+# 9:\n+PUSH_CONST  2\n+# stack: [fib(arg - 1), arg, 2]\n+\n+# 10:\n+BINARY_SUBTRACT\n+# stack: [fib(arg - 1), arg,  (arg - 2)\n+\n+# 11:\n+RECURSE\n+# stack: [fib(arg - 1), fib(arg - 1)]\n+\n+# 12:\n+BINARY_ADD\n+# stack: [fib(arg - 1) + fib(arg - 1)]\n+\n+# 13:\n+RETURN"}, {"sha": "666bf2ed2d3e0913d5e77f985a793c8b7ce1797c", "filename": "gcc/jit/docs/examples/tut04-toyvm/toyvm.c", "status": "added", "additions": 861, "deletions": 0, "changes": 861, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ftoyvm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ftoyvm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ftoyvm.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,861 @@\n+/* A simple stack-based virtual machine to demonstrate\n+   JIT-compilation.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <dejagnu.h>\n+\n+#include <libgccjit.h>\n+\n+/* Typedefs.  */\n+typedef struct toyvm_op toyvm_op;\n+typedef struct toyvm_function toyvm_function;\n+typedef struct toyvm_frame toyvm_frame;\n+typedef struct compilation_state compilation_state;\n+\n+/* Functions are compiled to this function ptr type.  */\n+typedef int (*toyvm_compiled_func) (int);\n+\n+enum opcode {\n+  /* Ops taking no operand.  */\n+  DUP,\n+  ROT,\n+  BINARY_ADD,\n+  BINARY_SUBTRACT,\n+  BINARY_MULT,\n+  BINARY_COMPARE_LT,\n+  RECURSE,\n+  RETURN,\n+\n+  /* Ops taking an operand.  */\n+  PUSH_CONST,\n+  JUMP_ABS_IF_TRUE\n+};\n+\n+#define FIRST_UNARY_OPCODE (PUSH_CONST)\n+\n+const char * const opcode_names[] = {\n+  \"DUP\",\n+  \"ROT\",\n+  \"BINARY_ADD\",\n+  \"BINARY_SUBTRACT\",\n+  \"BINARY_MULT\",\n+  \"BINARY_COMPARE_LT\",\n+  \"RECURSE\",\n+  \"RETURN\",\n+\n+  \"PUSH_CONST\",\n+  \"JUMP_ABS_IF_TRUE\",\n+};\n+\n+struct toyvm_op\n+{\n+  /* Which operation.  */\n+  enum opcode op_opcode;\n+\n+  /* Some opcodes take an argument.  */\n+  int op_operand;\n+\n+  /* The line number of the operation within the source file.  */\n+  int op_linenum;\n+};\n+\n+#define MAX_OPS  (64)\n+\n+struct toyvm_function\n+{\n+  const char *fn_filename;\n+  int         fn_num_ops;\n+  toyvm_op    fn_ops[MAX_OPS];\n+};\n+\n+#define MAX_STACK_DEPTH (8)\n+\n+struct toyvm_frame\n+{\n+  toyvm_function *frm_function;\n+  int             frm_pc;\n+  int             frm_stack[MAX_STACK_DEPTH];\n+  int             frm_cur_depth;\n+};\n+\n+static void\n+add_op (toyvm_function *fn, enum opcode opcode,\n+\tint operand, int linenum)\n+{\n+  toyvm_op *op;\n+  assert (fn->fn_num_ops < MAX_OPS);\n+  op = &fn->fn_ops[fn->fn_num_ops++];\n+  op->op_opcode = opcode;\n+  op->op_operand = operand;\n+  op->op_linenum = linenum;\n+}\n+\n+static void\n+add_unary_op (toyvm_function *fn, enum opcode opcode,\n+\t      const char *rest_of_line, int linenum)\n+{\n+  int operand = atoi (rest_of_line);\n+  add_op (fn, opcode, operand, linenum);\n+}\n+\n+static toyvm_function *\n+toyvm_function_parse (const char *filename, const char *name)\n+{\n+  FILE *f = NULL;\n+  toyvm_function *fn = NULL;\n+  char *line = NULL;\n+  ssize_t linelen;\n+  size_t bufsize;\n+  int linenum = 0;\n+\n+  assert (filename);\n+  assert (name);\n+\n+  f = fopen (filename, \"r\");\n+  if (!f)\n+    {\n+      fprintf (stderr,\n+\t       \"cannot open file %s: %s\\n\",\n+\t       filename, strerror (errno));\n+      goto error;\n+    }\n+\n+  fn = (toyvm_function *)calloc (1, sizeof (toyvm_function));\n+  if (!fn)\n+    {\n+      fprintf (stderr, \"out of memory allocating toyvm_function\\n\");\n+      goto error;\n+    }\n+  fn->fn_filename = name;\n+\n+  /* Read the lines of the file.  */\n+  while ((linelen = getline (&line, &bufsize, f)) != -1)\n+    {\n+      /* Note that this is a terrible parser, but it avoids the need to\n+\t bring in lex/yacc as a dependency.  */\n+      linenum++;\n+\n+      if (0)\n+\tfprintf (stdout, \"%3d: %s\", linenum, line);\n+\n+      /* Lines beginning with # are comments.  */\n+      if (line[0] == '#')\n+\tcontinue;\n+\n+      /* Skip blank lines.  */\n+      if (line[0] == '\\n')\n+\tcontinue;\n+\n+#define LINE_MATCHES(OPCODE) (0 == strncmp ((OPCODE), line, strlen (OPCODE)))\n+      if (LINE_MATCHES (\"DUP\\n\"))\n+\tadd_op (fn, DUP, 0, linenum);\n+      else if (LINE_MATCHES (\"ROT\\n\"))\n+\tadd_op (fn, ROT, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_ADD\\n\"))\n+\tadd_op (fn, BINARY_ADD, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_SUBTRACT\\n\"))\n+\tadd_op (fn, BINARY_SUBTRACT, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_MULT\\n\"))\n+\tadd_op (fn, BINARY_MULT, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_COMPARE_LT\\n\"))\n+\tadd_op (fn, BINARY_COMPARE_LT, 0, linenum);\n+      else if (LINE_MATCHES (\"RECURSE\\n\"))\n+\tadd_op (fn, RECURSE, 0, linenum);\n+      else if (LINE_MATCHES (\"RETURN\\n\"))\n+\tadd_op (fn, RETURN, 0, linenum);\n+      else if (LINE_MATCHES (\"PUSH_CONST \"))\n+\tadd_unary_op (fn, PUSH_CONST,\n+\t\t      line + strlen (\"PUSH_CONST \"), linenum);\n+      else if (LINE_MATCHES (\"JUMP_ABS_IF_TRUE \"))\n+\tadd_unary_op (fn, JUMP_ABS_IF_TRUE,\n+\t\t      line + strlen(\"JUMP_ABS_IF_TRUE \"), linenum);\n+      else\n+\t{\n+\t  fprintf (stderr, \"%s:%d: parse error\\n\", filename, linenum);\n+\t  free (fn);\n+\t  fn = NULL;\n+\t  goto error;\n+\t}\n+#undef LINE_MATCHES\n+    }\n+  free (line);\n+  fclose (f);\n+\n+  return fn;\n+\n+ error:\n+  free (line);\n+  fclose (f);\n+  free (fn);\n+  return NULL;\n+}\n+\n+static void\n+toyvm_function_disassemble_op (toyvm_function *fn, toyvm_op *op, int index, FILE *out)\n+{\n+  fprintf (out, \"%s:%d: index %d: %s\",\n+\t   fn->fn_filename, op->op_linenum, index,\n+\t   opcode_names[op->op_opcode]);\n+  if (op->op_opcode >= FIRST_UNARY_OPCODE)\n+    fprintf (out, \" %d\", op->op_operand);\n+  fprintf (out, \"\\n\");\n+}\n+\n+static void\n+toyvm_function_disassemble (toyvm_function *fn, FILE *out)\n+{\n+  int i;\n+  for (i = 0; i < fn->fn_num_ops; i++)\n+    {\n+      toyvm_op *op = &fn->fn_ops[i];\n+      toyvm_function_disassemble_op (fn, op, i, out);\n+    }\n+}\n+\n+static void\n+toyvm_frame_push (toyvm_frame *frame, int arg)\n+{\n+  assert (frame->frm_cur_depth < MAX_STACK_DEPTH);\n+  frame->frm_stack[frame->frm_cur_depth++] = arg;\n+}\n+\n+static int\n+toyvm_frame_pop (toyvm_frame *frame)\n+{\n+  assert (frame->frm_cur_depth > 0);\n+  return frame->frm_stack[--frame->frm_cur_depth];\n+}\n+\n+static void\n+toyvm_frame_dump_stack (toyvm_frame *frame, FILE *out)\n+{\n+  int i;\n+  fprintf (out, \"stack:\");\n+  for (i = 0; i < frame->frm_cur_depth; i++)\n+    {\n+      fprintf (out, \" %d\", frame->frm_stack[i]);\n+    }\n+  fprintf (out, \"\\n\");\n+}\n+\n+/* Execute the given function.  */\n+\n+static int\n+toyvm_function_interpret (toyvm_function *fn, int arg, FILE *trace)\n+{\n+  toyvm_frame frame;\n+#define PUSH(ARG) (toyvm_frame_push (&frame, (ARG)))\n+#define POP(ARG) (toyvm_frame_pop (&frame))\n+\n+  frame.frm_function = fn;\n+  frame.frm_pc = 0;\n+  frame.frm_cur_depth = 0;\n+\n+  PUSH (arg);\n+\n+  while (1)\n+    {\n+      toyvm_op *op;\n+      int x, y;\n+      assert (frame.frm_pc < fn->fn_num_ops);\n+      op = &fn->fn_ops[frame.frm_pc++];\n+\n+      if (trace)\n+\t{\n+\t  toyvm_frame_dump_stack (&frame, trace);\n+\t  toyvm_function_disassemble_op (fn, op, frame.frm_pc, trace);\n+\t}\n+\n+      switch (op->op_opcode)\n+\t{\n+\t  /* Ops taking no operand.  */\n+\tcase DUP:\n+\t  x = POP ();\n+\t  PUSH (x);\n+\t  PUSH (x);\n+\t  break;\n+\n+\tcase ROT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (y);\n+\t  PUSH (x);\n+\t  break;\n+\n+\tcase BINARY_ADD:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x + y);\n+\t  break;\n+\n+\tcase BINARY_SUBTRACT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x - y);\n+\t  break;\n+\n+\tcase BINARY_MULT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x * y);\n+\t  break;\n+\n+\tcase BINARY_COMPARE_LT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x < y);\n+\t  break;\n+\n+\tcase RECURSE:\n+\t  x = POP ();\n+\t  x = toyvm_function_interpret (fn, x, trace);\n+\t  PUSH (x);\n+\t  break;\n+\n+\tcase RETURN:\n+\t  return POP ();\n+\n+\t  /* Ops taking an operand.  */\n+\tcase PUSH_CONST:\n+\t  PUSH (op->op_operand);\n+\t  break;\n+\n+\tcase JUMP_ABS_IF_TRUE:\n+\t  x = POP ();\n+\t  if (x)\n+\t    frame.frm_pc = op->op_operand;\n+\t  break;\n+\n+\tdefault:\n+\t  assert (0); /* unknown opcode */\n+\n+\t} /* end of switch on opcode */\n+    } /* end of while loop */\n+\n+#undef PUSH\n+#undef POP\n+}\n+\n+/* JIT compilation.  */\n+\n+struct compilation_state\n+{\n+  gcc_jit_context *ctxt;\n+\n+  gcc_jit_type *int_type;\n+  gcc_jit_type *bool_type;\n+  gcc_jit_type *stack_type; /* int[MAX_STACK_DEPTH] */\n+\n+  gcc_jit_rvalue *const_one;\n+\n+  gcc_jit_function *fn;\n+  gcc_jit_param *param_arg;\n+  gcc_jit_lvalue *stack;\n+  gcc_jit_lvalue *stack_depth;\n+  gcc_jit_lvalue *x;\n+  gcc_jit_lvalue *y;\n+\n+  gcc_jit_location *op_locs[MAX_OPS];\n+  gcc_jit_block *initial_block;\n+  gcc_jit_block *op_blocks[MAX_OPS];\n+\n+};\n+\n+/* Stack manipulation.  */\n+\n+static void\n+add_push (compilation_state *state,\n+\t  gcc_jit_block *block,\n+\t  gcc_jit_rvalue *rvalue,\n+\t  gcc_jit_location *loc)\n+{\n+  /* stack[stack_depth] = RVALUE */\n+  gcc_jit_block_add_assignment (\n+    block,\n+    loc,\n+    /* stack[stack_depth] */\n+    gcc_jit_context_new_array_access (\n+      state->ctxt,\n+      loc,\n+      gcc_jit_lvalue_as_rvalue (state->stack),\n+      gcc_jit_lvalue_as_rvalue (state->stack_depth)),\n+    rvalue);\n+\n+  /* \"stack_depth++;\".  */\n+  gcc_jit_block_add_assignment_op (\n+    block,\n+    loc,\n+    state->stack_depth,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    state->const_one);\n+}\n+\n+static void\n+add_pop (compilation_state *state,\n+\t gcc_jit_block *block,\n+\t gcc_jit_lvalue *lvalue,\n+\t gcc_jit_location *loc)\n+{\n+  /* \"--stack_depth;\".  */\n+  gcc_jit_block_add_assignment_op (\n+    block,\n+    loc,\n+    state->stack_depth,\n+    GCC_JIT_BINARY_OP_MINUS,\n+    state->const_one);\n+\n+  /* \"LVALUE = stack[stack_depth];\".  */\n+  gcc_jit_block_add_assignment (\n+    block,\n+    loc,\n+    lvalue,\n+    /* stack[stack_depth] */\n+    gcc_jit_lvalue_as_rvalue (\n+      gcc_jit_context_new_array_access (\n+\tstate->ctxt,\n+\tloc,\n+\tgcc_jit_lvalue_as_rvalue (state->stack),\n+\tgcc_jit_lvalue_as_rvalue (state->stack_depth))));\n+}\n+\n+/* The main compilation hook.  */\n+\n+static toyvm_compiled_func\n+toyvm_function_compile (toyvm_function *fn)\n+{\n+  compilation_state state;\n+  int pc;\n+  char *funcname;\n+\n+  memset (&state, 0, sizeof (state));\n+\n+  /* Copy filename to funcname.  */\n+  funcname = (char *)malloc (strlen (fn->fn_filename) + 1);\n+  strcpy (funcname, fn->fn_filename);\n+\n+  /* Convert \".\" to NIL terminator.  */\n+  *(strchr (funcname, '.')) = '\\0';\n+\n+  state.ctxt = gcc_jit_context_acquire ();\n+\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+\t\t\t\t   GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+\t\t\t\t   0);\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+\t\t\t\t   GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+\t\t\t\t   0);\n+  gcc_jit_context_set_int_option (state.ctxt,\n+\t\t\t\t  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+\t\t\t\t  3);\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+\t\t\t\t   GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n+\t\t\t\t   0);\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+\t\t\t\t   GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n+\t\t\t\t   0);\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+\t\t\t\t   GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+\t\t\t\t   1);\n+\n+  /* Create types.  */\n+  state.int_type =\n+    gcc_jit_context_get_type (state.ctxt, GCC_JIT_TYPE_INT);\n+  state.bool_type =\n+    gcc_jit_context_get_type (state.ctxt, GCC_JIT_TYPE_BOOL);\n+  state.stack_type =\n+    gcc_jit_context_new_array_type (state.ctxt, NULL,\n+\t\t\t\t    state.int_type, MAX_STACK_DEPTH);\n+\n+  /* The constant value 1.  */\n+  state.const_one = gcc_jit_context_one (state.ctxt, state.int_type);\n+\n+  /* Create locations.  */\n+  for (pc = 0; pc < fn->fn_num_ops; pc++)\n+    {\n+      toyvm_op *op = &fn->fn_ops[pc];\n+\n+      state.op_locs[pc] = gcc_jit_context_new_location (state.ctxt,\n+\t\t\t\t\t\t\tfn->fn_filename,\n+\t\t\t\t\t\t\top->op_linenum,\n+\t\t\t\t\t\t\t0); /* column */\n+    }\n+\n+  /* Creating the function.  */\n+  state.param_arg =\n+    gcc_jit_context_new_param (state.ctxt, state.op_locs[0],\n+\t\t\t       state.int_type, \"arg\");\n+  state.fn =\n+    gcc_jit_context_new_function (state.ctxt,\n+\t\t\t\t  state.op_locs[0],\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  state.int_type,\n+\t\t\t\t  funcname,\n+\t\t\t\t  1, &state.param_arg, 0);\n+\n+  /* Create stack lvalues.  */\n+  state.stack =\n+    gcc_jit_function_new_local (state.fn, NULL,\n+\t\t\t\tstate.stack_type, \"stack\");\n+  state.stack_depth =\n+    gcc_jit_function_new_local (state.fn, NULL,\n+\t\t\t\tstate.int_type, \"stack_depth\");\n+  state.x =\n+    gcc_jit_function_new_local (state.fn, NULL,\n+\t\t\t\tstate.int_type, \"x\");\n+  state.y =\n+    gcc_jit_function_new_local (state.fn, NULL,\n+\t\t\t\tstate.int_type, \"y\");\n+\n+  /* 1st pass: create blocks, one per opcode. */\n+\n+  /* We need an entry block to do one-time initialization, so create that\n+     first.  */\n+  state.initial_block = gcc_jit_function_new_block (state.fn, \"initial\");\n+\n+  /* Create a block per operation.  */\n+  for (pc = 0; pc < fn->fn_num_ops; pc++)\n+    {\n+      char buf[16];\n+      sprintf (buf, \"instr%i\", pc);\n+      state.op_blocks[pc] = gcc_jit_function_new_block (state.fn, buf);\n+    }\n+\n+  /* Populate the initial block.  */\n+\n+  /* \"stack_depth = 0;\".  */\n+  gcc_jit_block_add_assignment (\n+    state.initial_block,\n+    state.op_locs[0],\n+    state.stack_depth,\n+    gcc_jit_context_zero (state.ctxt, state.int_type));\n+\n+  /* \"PUSH (arg);\".  */\n+  add_push (&state,\n+\t    state.initial_block,\n+\t    gcc_jit_param_as_rvalue (state.param_arg),\n+\t    state.op_locs[0]);\n+\n+  /* ...and jump to insn 0.  */\n+  gcc_jit_block_end_with_jump (state.initial_block,\n+\t\t\t       state.op_locs[0],\n+\t\t\t       state.op_blocks[0]);\n+\n+  /* 2nd pass: fill in instructions.  */\n+  for (pc = 0; pc < fn->fn_num_ops; pc++)\n+    {\n+      gcc_jit_location *loc = state.op_locs[pc];\n+\n+      gcc_jit_block *block = state.op_blocks[pc];\n+      gcc_jit_block *next_block = (pc < fn->fn_num_ops\n+\t\t\t\t   ? state.op_blocks[pc + 1]\n+\t\t\t\t   : NULL);\n+\n+      toyvm_op *op;\n+      op = &fn->fn_ops[pc];\n+\n+      /* Helper macros.  */\n+\n+#define X_EQUALS_POP()\\\n+      add_pop (&state, block, state.x, loc)\n+#define Y_EQUALS_POP()\\\n+      add_pop (&state, block, state.y, loc)\n+#define PUSH_RVALUE(RVALUE)\\\n+      add_push (&state, block, (RVALUE), loc)\n+#define PUSH_X()\\\n+      PUSH_RVALUE (gcc_jit_lvalue_as_rvalue (state.x))\n+#define PUSH_Y() \\\n+      PUSH_RVALUE (gcc_jit_lvalue_as_rvalue (state.y))\n+\n+      gcc_jit_block_add_comment (block, loc, opcode_names[op->op_opcode]);\n+\n+      /* Handle the individual opcodes.  */\n+\n+      switch (op->op_opcode)\n+\t{\n+\tcase DUP:\n+\t  X_EQUALS_POP ();\n+\t  PUSH_X ();\n+\t  PUSH_X ();\n+\t  break;\n+\n+\tcase ROT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_Y ();\n+\t  PUSH_X ();\n+\t  break;\n+\n+\tcase BINARY_ADD:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+\t   gcc_jit_context_new_binary_op (\n+\t     state.ctxt,\n+\t     loc,\n+\t     GCC_JIT_BINARY_OP_PLUS,\n+\t     state.int_type,\n+\t     gcc_jit_lvalue_as_rvalue (state.x),\n+\t     gcc_jit_lvalue_as_rvalue (state.y)));\n+\t  break;\n+\n+\tcase BINARY_SUBTRACT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+\t   gcc_jit_context_new_binary_op (\n+\t     state.ctxt,\n+\t     loc,\n+\t     GCC_JIT_BINARY_OP_MINUS,\n+\t     state.int_type,\n+\t     gcc_jit_lvalue_as_rvalue (state.x),\n+\t     gcc_jit_lvalue_as_rvalue (state.y)));\n+\t  break;\n+\n+\tcase BINARY_MULT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+\t   gcc_jit_context_new_binary_op (\n+\t     state.ctxt,\n+\t     loc,\n+\t     GCC_JIT_BINARY_OP_MULT,\n+\t     state.int_type,\n+\t     gcc_jit_lvalue_as_rvalue (state.x),\n+\t     gcc_jit_lvalue_as_rvalue (state.y)));\n+\t  break;\n+\n+\tcase BINARY_COMPARE_LT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+\t     /* cast of bool to int */\n+\t     gcc_jit_context_new_cast (\n+\t       state.ctxt,\n+\t       loc,\n+\t       /* (x < y) as a bool */\n+\t       gcc_jit_context_new_comparison (\n+\t\t state.ctxt,\n+\t\t loc,\n+\t\t GCC_JIT_COMPARISON_LT,\n+\t\t gcc_jit_lvalue_as_rvalue (state.x),\n+\t\t gcc_jit_lvalue_as_rvalue (state.y)),\n+\t       state.int_type));\n+\t  break;\n+\n+\tcase RECURSE:\n+\t  {\n+\t    X_EQUALS_POP ();\n+\t    gcc_jit_rvalue *arg = gcc_jit_lvalue_as_rvalue (state.x);\n+\t    PUSH_RVALUE (\n+\t      gcc_jit_context_new_call (\n+\t\tstate.ctxt,\n+\t\tloc,\n+\t\tstate.fn,\n+\t\t1, &arg));\n+\t    break;\n+\t  }\n+\n+\tcase RETURN:\n+\t  X_EQUALS_POP ();\n+\t  gcc_jit_block_end_with_return (\n+\t    block,\n+\t    loc,\n+\t    gcc_jit_lvalue_as_rvalue (state.x));\n+\t  break;\n+\n+\t  /* Ops taking an operand.  */\n+\tcase PUSH_CONST:\n+\t  PUSH_RVALUE (\n+\t    gcc_jit_context_new_rvalue_from_int (\n+\t      state.ctxt,\n+\t      state.int_type,\n+\t      op->op_operand));\n+\t  break;\n+\n+\tcase JUMP_ABS_IF_TRUE:\n+\t  X_EQUALS_POP ();\n+\t  gcc_jit_block_end_with_conditional (\n+\t    block,\n+\t    loc,\n+\t    /* \"(bool)x\".  */\n+\t    gcc_jit_context_new_cast (\n+\t      state.ctxt,\n+\t      loc,\n+\t      gcc_jit_lvalue_as_rvalue (state.x),\n+\t      state.bool_type),\n+\t    state.op_blocks[op->op_operand], /* on_true */\n+\t    next_block); /* on_false */\n+\t  break;\n+\n+\tdefault:\n+\t  assert(0);\n+\t} /* end of switch on opcode */\n+\n+      /* Go to the next block.  */\n+      if (op->op_opcode != JUMP_ABS_IF_TRUE\n+\t  && op->op_opcode != RETURN)\n+\tgcc_jit_block_end_with_jump (\n+\t  block,\n+\t  loc,\n+\t  next_block);\n+\n+    } /* end of loop on PC locations.  */\n+\n+  /* We've now finished populating the context.  Compile it.  */\n+  gcc_jit_result *result = gcc_jit_context_compile (state.ctxt);\n+  gcc_jit_context_release (state.ctxt);\n+\n+  return (toyvm_compiled_func)gcc_jit_result_get_code (result,\n+\t\t\t\t\t\t       funcname);\n+  /* (this leaks \"result\" and \"funcname\") */\n+}\n+\n+char test[1024];\n+\n+#define CHECK_NON_NULL(PTR) \\\n+  do {                                       \\\n+    if ((PTR) != NULL)                       \\\n+      {                                      \\\n+\tpass (\"%s: %s is non-null\", test, #PTR); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                      \\\n+\tfail (\"%s: %s is NULL\", test, #PTR); \\\n+\tabort ();                            \\\n+    }                                        \\\n+  } while (0)\n+\n+#define CHECK_VALUE(ACTUAL, EXPECTED) \\\n+  do {                                       \\\n+    if ((ACTUAL) == (EXPECTED))              \\\n+      {                                      \\\n+\tpass (\"%s: actual: %s == expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                        \\\n+\tfail (\"%s: actual: %s != expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+\tfprintf (stderr, \"incorrect value\\n\"); \\\n+\tabort ();                              \\\n+    }                                        \\\n+  } while (0)\n+\n+static void\n+test_script (const char *scripts_dir, const char *script_name, int input,\n+\t     int expected_result)\n+{\n+  char *script_path;\n+  toyvm_function *fn;\n+  int interpreted_result;\n+  toyvm_compiled_func code;\n+  int compiled_result;\n+\n+  snprintf (test, sizeof (test), \"toyvm.c: %s\", script_name);\n+\n+  script_path = (char *)malloc (strlen (scripts_dir)\n+\t\t\t\t+ strlen (script_name) + 1);\n+  CHECK_NON_NULL (script_path);\n+  sprintf (script_path, \"%s%s\", scripts_dir, script_name);\n+\n+  fn = toyvm_function_parse (script_path, script_name);\n+  CHECK_NON_NULL (fn);\n+\n+  interpreted_result = toyvm_function_interpret (fn, input, NULL);\n+  CHECK_VALUE (interpreted_result, expected_result);\n+\n+  code = toyvm_function_compile (fn);\n+  CHECK_NON_NULL (code);\n+\n+  compiled_result = code (input);\n+  CHECK_VALUE (compiled_result, expected_result);\n+\n+  free (script_path);\n+}\n+\n+#define PATH_TO_SCRIPTS  (\"/jit/docs/examples/tut04-toyvm/\")\n+\n+static void\n+test_suite (void)\n+{\n+  const char *srcdir;\n+  char *scripts_dir;\n+\n+  snprintf (test, sizeof (test), \"toyvm.c\");\n+\n+  /* We need to locate the test scripts.\n+     Rely on \"srcdir\" being set in the environment.  */\n+\n+  srcdir = getenv (\"srcdir\");\n+  CHECK_NON_NULL (srcdir);\n+\n+  scripts_dir = (char *)malloc (strlen (srcdir) + strlen(PATH_TO_SCRIPTS)\n+\t\t\t\t+ 1);\n+  CHECK_NON_NULL (scripts_dir);\n+  sprintf (scripts_dir, \"%s%s\", srcdir, PATH_TO_SCRIPTS);\n+\n+  test_script (scripts_dir, \"factorial.toy\", 10, 3628800);\n+  test_script (scripts_dir, \"fibonacci.toy\", 10, 55);\n+\n+  free (scripts_dir);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const char *filename = NULL;\n+  toyvm_function *fn = NULL;\n+\n+  /* If called with no args, assume we're being run by the test suite.  */\n+  if (argc < 3)\n+    {\n+      test_suite ();\n+      return 0;\n+    }\n+\n+  if (argc != 3)\n+    {\n+      fprintf (stdout,\n+\t\"%s FILENAME INPUT: Parse and run a .toy file\\n\",\n+\targv[0]);\n+      exit (1);\n+    }\n+\n+  filename = argv[1];\n+  fn = toyvm_function_parse (filename, filename);\n+  if (!fn)\n+    exit (1);\n+\n+  if (0)\n+    toyvm_function_disassemble (fn, stdout);\n+\n+  printf (\"interpreter result: %d\\n\",\n+\t  toyvm_function_interpret (fn, atoi (argv[2]), NULL));\n+\n+  /* JIT-compilation.  */\n+  toyvm_compiled_func code = toyvm_function_compile (fn);\n+  printf (\"compiler result: %d\\n\",\n+\t  code (atoi (argv[2])));\n+\n+ return 0;\n+}"}, {"sha": "ed75e36c201ba8f34eba947aa4072abe83f9ec46", "filename": "gcc/jit/docs/index.rst", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Findex.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,50 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+libgccjit\n+=========\n+\n+Contents:\n+\n+.. toctree::\n+   :maxdepth: 2\n+\n+   intro/index.rst\n+   topics/index.rst\n+   internals/index.rst\n+\n+This document describes `libgccjit <http://gcc.gnu.org/wiki/JIT>`_, an API\n+for embedding GCC inside programs and libraries.\n+\n+Note that libgccjit is currently of \"Alpha\" quality;\n+the APIs are not yet set in stone, and they shouldn't be used in\n+production yet.\n+\n+\n+Indices and tables\n+==================\n+\n+* :ref:`genindex`\n+* :ref:`modindex`\n+* :ref:`search`\n+\n+.. Some notes:\n+\n+   The Sphinx C domain appears to lack explicit support for enum values,\n+   so I've been using :c:macro: for them.\n+\n+   See http://sphinx-doc.org/domains.html#the-c-domain"}, {"sha": "80626e4a10bc5b57d6429f964d14daf5faafdf3d", "filename": "gcc/jit/docs/internals/index.rst", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,216 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Internals\n+=========\n+\n+Working on the JIT library\n+--------------------------\n+Having checked out the source code (to \"src\"), you can configure and build\n+the JIT library like this:\n+\n+.. code-block:: bash\n+\n+  mkdir build\n+  mkdir install\n+  PREFIX=$(pwd)/install\n+  cd build\n+  ../src/configure \\\n+     --enable-host-shared \\\n+     --enable-languages=jit \\\n+     --disable-bootstrap \\\n+     --enable-checking=release \\\n+     --prefix=$PREFIX\n+  nice make -j4 # altering the \"4\" to however many cores you have\n+\n+This should build a libgccjit.so within jit/build/gcc:\n+\n+.. code-block:: console\n+\n+ [build] $ file gcc/libgccjit.so*\n+ gcc/libgccjit.so:       symbolic link to `libgccjit.so.0'\n+ gcc/libgccjit.so.0:     symbolic link to `libgccjit.so.0.0.1'\n+ gcc/libgccjit.so.0.0.1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped\n+\n+Here's what those configuration options mean:\n+\n+.. option:: --enable-host-shared\n+\n+  Configuring with this option means that the compiler is built as\n+  position-independent code, which incurs a slight performance hit,\n+  but it necessary for a shared library.\n+\n+.. option:: --enable-languages=jit\n+\n+  This specifies which frontends to build.  The JIT library looks like\n+  a frontend to the rest of the code.\n+\n+.. option:: --disable-bootstrap\n+\n+  For hacking on the \"jit\" subdirectory, performing a full\n+  bootstrap can be overkill, since it's unused by a bootstrap.  However,\n+  when submitting patches, you should remove this option, to ensure that\n+  the compiler can still bootstrap itself.\n+\n+.. option:: --enable-checking=release\n+\n+  The compile can perform extensive self-checking as it runs, useful when\n+  debugging, but slowing things down.\n+\n+  For maximum speed, configure with ``--enable-checking=release`` to\n+  disable this self-checking.\n+\n+Running the test suite\n+----------------------\n+\n+.. code-block:: console\n+\n+  [build] $ cd gcc\n+  [gcc] $ make check-jit RUNTESTFLAGS=\"-v -v -v\"\n+\n+A summary of the tests can then be seen in:\n+\n+.. code-block:: console\n+\n+  jit/build/gcc/testsuite/jit/jit.sum\n+\n+and detailed logs in:\n+\n+.. code-block:: console\n+\n+  jit/build/gcc/testsuite/jit/jit.log\n+\n+The test executables can be seen as:\n+\n+.. code-block:: console\n+\n+  jit/build/gcc/testsuite/jit/*.exe\n+\n+which can be run independently.\n+\n+You can compile and run individual tests by passing \"jit.exp=TESTNAME\" to RUNTESTFLAGS e.g.:\n+\n+.. code-block:: console\n+\n+   [gcc] $ make check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=test-factorial.c\"\n+\n+and once a test has been compiled, you can debug it directly:\n+\n+.. code-block:: console\n+\n+   [gcc] $ PATH=.:$PATH \\\n+           LD_LIBRARY_PATH=. \\\n+           LIBRARY_PATH=. \\\n+             gdb --args \\\n+               testsuite/jit/test-factorial.exe\n+\n+Environment variables\n+---------------------\n+When running client code against a locally-built libgccjit, three\n+environment variables need to be set up:\n+\n+.. envvar:: LD_LIBRARY_PATH\n+\n+   `libgccjit.so` is dynamically linked into client code, so if running\n+   against a locally-built library, ``LD_LIBRARY_PATH`` needs to be set\n+   up appropriately.  The library can be found within the \"gcc\"\n+   subdirectory of the build tree:\n+\n+  .. code-block:: console\n+\n+    $ file libgccjit.so*\n+    libgccjit.so:       symbolic link to `libgccjit.so.0'\n+    libgccjit.so.0:     symbolic link to `libgccjit.so.0.0.1'\n+    libgccjit.so.0.0.1: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, not stripped\n+\n+.. envvar:: PATH\n+\n+  The library uses a driver executable for converting from .s assembler\n+  files to .so shared libraries.  Specifically, it looks for a name\n+  expanded from\n+  ``${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}``\n+  such as ``x86_64-unknown-linux-gnu-gcc-5.0.0``.\n+\n+  Hence ``PATH`` needs to include a directory where the library can\n+  locate this executable.\n+\n+  The executable is normally installed to the installation bindir\n+  (e.g. /usr/bin), but a copy is also created within the \"gcc\"\n+  subdirectory of the build tree for running the testsuite, and for ease\n+  of development.\n+\n+.. envvar:: LIBRARY_PATH\n+\n+  The driver executable invokes the linker, and the latter needs to locate\n+  support libraries needed by the generated code, or you will see errors\n+  like:\n+\n+  .. code-block:: console\n+\n+    ld: cannot find crtbeginS.o: No such file or directory\n+    ld: cannot find -lgcc\n+    ld: cannot find -lgcc_s\n+\n+  Hence if running directly from a locally-built copy (without installing),\n+  ``LIBRARY_PATH`` needs to contain the \"gcc\" subdirectory of the build\n+  tree.\n+\n+For example, to run a binary that uses the library against a non-installed\n+build of the library in LIBGCCJIT_BUILD_DIR you need an invocation of the\n+client code like this, to preprend the dir to each of the environment\n+variables:\n+\n+.. code-block:: console\n+\n+  $ LD_LIBRARY_PATH=$(LIBGCCJIT_BUILD_DIR):$(LD_LIBRARY_PATH) \\\n+    PATH=$(LIBGCCJIT_BUILD_DIR):$(PATH) \\\n+    LIBRARY_PATH=$(LIBGCCJIT_BUILD_DIR):$(LIBRARY_PATH) \\\n+      ./jit-hello-world\n+  hello world\n+\n+Overview of code structure\n+--------------------------\n+\n+* ``libgccjit.c`` implements the API entrypoints.  It performs error\n+  checking, then calls into classes of the gcc::jit::recording namespace\n+  within ``jit-recording.c`` and ``jit-recording.h``.\n+\n+* The gcc::jit::recording classes (within ``jit-recording.c`` and\n+  ``jit-recording.h``) record the API calls that are made:\n+\n+   .. literalinclude:: ../../jit-common.h\n+    :start-after: /* Recording types.  */\n+    :end-before: /* End of recording types. */\n+    :language: c++\n+\n+* When the context is compiled, the gcc::jit::playback classes (within\n+  ``jit-playback.c`` and ``jit-playback.h``) replay the API calls\n+  within langhook:parse_file:\n+\n+   .. literalinclude:: ../../jit-common.h\n+    :start-after: /* Playback types.  */\n+    :end-before: /* End of playback types. */\n+    :language: c++\n+\n+   .. literalinclude:: ../../notes.txt\n+    :lines: 1-\n+\n+Here is a high-level summary from ``jit-common.h``:\n+\n+.. include:: ../../jit-common.h\n+  :start-after: This comment is included by the docs.\n+  :end-before: End of comment for inclusion in the docs.  */"}, {"sha": "dff47ce276721746c2b1f1ae4059ea77c7bf5b75", "filename": "gcc/jit/docs/intro/factorial.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ffactorial.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ffactorial.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ffactorial.png?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "d3bcec93c75dbf21ecdc5276f54368a06b8e84bc", "filename": "gcc/jit/docs/intro/index.rst", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Findex.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,27 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Tutorial\n+========\n+\n+.. toctree::\n+   :maxdepth: 2\n+\n+   tutorial01.rst\n+   tutorial02.rst\n+   tutorial03.rst\n+   tutorial04.rst"}, {"sha": "7a3b4afff38e2f365ef2a09df997cb98d032fbcb", "filename": "gcc/jit/docs/intro/sum-of-squares.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Fsum-of-squares.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Fsum-of-squares.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Fsum-of-squares.png?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "b1a51288d7b08409cbf589bfca9723f49c9b37db", "filename": "gcc/jit/docs/intro/tutorial01.rst", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial01.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial01.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial01.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,52 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Tutorial part 1: \"Hello world\"\n+==============================\n+\n+Before we look at the details of the API, let's look at building and\n+running programs that use the library.\n+\n+Here's a toy \"hello world\" program that uses the library to synthesize\n+a call to `printf` and uses it to write a message to stdout.\n+\n+Don't worry about the content of the program for now; we'll cover\n+the details in later parts of this tutorial.\n+\n+   .. literalinclude:: ../examples/tut01-hello-world.c\n+    :language: c\n+\n+Copy the above to `tut01-hello-world.c`.\n+\n+Assuming you have the jit library installed, build the test program\n+using:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut01-hello-world.c \\\n+      -o tut01-hello-world \\\n+      -lgccjit\n+\n+You should then be able to run the built program:\n+\n+.. code-block:: console\n+\n+  $ ./tut01-hello-world\n+  hello world"}, {"sha": "f52499ea0aa519f0df9661eae4795e2e36f2f7a9", "filename": "gcc/jit/docs/intro/tutorial02.rst", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial02.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial02.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial02.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,349 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Tutorial part 2: Creating a trivial machine code function\n+---------------------------------------------------------\n+\n+Consider this C function:\n+\n+.. code-block:: c\n+\n+   int square (int i)\n+   {\n+     return i * i;\n+   }\n+\n+How can we construct this at run-time using libgccjit?\n+\n+First we need to include the relevant header:\n+\n+.. code-block:: c\n+\n+  #include <libgccjit.h>\n+\n+All state associated with compilation is associated with a\n+:c:type:`gcc_jit_context *`.\n+\n+Create one using :c:func:`gcc_jit_context_acquire`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context *ctxt;\n+  ctxt = gcc_jit_context_acquire ();\n+\n+The JIT library has a system of types.  It is statically-typed: every\n+expression is of a specific type, fixed at compile-time.  In our example,\n+all of the expressions are of the C `int` type, so let's obtain this from\n+the context, as a :c:type:`gcc_jit_type *`, using\n+:c:func:`gcc_jit_context_get_type`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+:c:type:`gcc_jit_type *` is an example of a \"contextual\" object: every\n+entity in the API is associated with a :c:type:`gcc_jit_context *`.\n+\n+Memory management is easy: all such \"contextual\" objects are automatically\n+cleaned up for you when the context is released, using\n+:c:func:`gcc_jit_context_release`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_release (ctxt);\n+\n+so you don't need to manually track and cleanup all objects, just the\n+contexts.\n+\n+Although the API is C-based, there is a form of class hierarchy, which\n+looks like this::\n+\n+  +- gcc_jit_object\n+      +- gcc_jit_location\n+      +- gcc_jit_type\n+         +- gcc_jit_struct\n+      +- gcc_jit_field\n+      +- gcc_jit_function\n+      +- gcc_jit_block\n+      +- gcc_jit_rvalue\n+          +- gcc_jit_lvalue\n+             +- gcc_jit_param\n+\n+There are casting methods for upcasting from subclasses to parent classes.\n+For example, :c:func:`gcc_jit_type_as_object`:\n+\n+.. code-block:: c\n+\n+   gcc_jit_object *obj = gcc_jit_type_as_object (int_type);\n+\n+One thing you can do with a :c:type:`gcc_jit_object *` is\n+to ask it for a human-readable description, using\n+:c:func:`gcc_jit_object_get_debug_string`:\n+\n+.. code-block:: c\n+\n+   printf (\"obj: %s\\n\", gcc_jit_object_get_debug_string (obj));\n+\n+giving this text on stdout:\n+\n+.. code-block:: bash\n+\n+   obj: int\n+\n+This is invaluable when debugging.\n+\n+Let's create the function.  To do so, we first need to construct\n+its single parameter, specifying its type and giving it a name,\n+using :c:func:`gcc_jit_context_new_param`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_param *param_i =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+\n+Now we can create the function, using\n+:c:func:`gcc_jit_context_new_function`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  int_type,\n+                                  \"square\",\n+                                  1, &param_i,\n+                                  0);\n+\n+To define the code within the function, we must create basic blocks\n+containing statements.\n+\n+Every basic block contains a list of statements, eventually terminated\n+by a statement that either returns, or jumps to another basic block.\n+\n+Our function has no control-flow, so we just need one basic block:\n+\n+.. code-block:: c\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+Our basic block is relatively simple: it immediately terminates by\n+returning the value of an expression.\n+\n+We can build the expression using :c:func:`gcc_jit_context_new_binary_op`:\n+\n+.. code-block:: c\n+\n+   gcc_jit_rvalue *expr =\n+     gcc_jit_context_new_binary_op (\n+       ctxt, NULL,\n+       GCC_JIT_BINARY_OP_MULT, int_type,\n+       gcc_jit_param_as_rvalue (param_i),\n+       gcc_jit_param_as_rvalue (param_i));\n+\n+A :c:type:`gcc_jit_rvalue *` is another example of a\n+:c:type:`gcc_jit_object *` subclass.  We can upcast it using\n+:c:func:`gcc_jit_rvalue_as_object` and as before print it with\n+:c:func:`gcc_jit_object_get_debug_string`.\n+\n+.. code-block:: c\n+\n+   printf (\"expr: %s\\n\",\n+           gcc_jit_object_get_debug_string (\n+             gcc_jit_rvalue_as_object (expr)));\n+\n+giving this output:\n+\n+.. code-block:: bash\n+\n+   expr: i * i\n+\n+Creating the expression in itself doesn't do anything; we have to add\n+this expression to a statement within the block.  In this case, we use it\n+to build a return statement, which terminates the basic block:\n+\n+.. code-block:: c\n+\n+  gcc_jit_block_end_with_return (block, NULL, expr);\n+\n+OK, we've populated the context.  We can now compile it using\n+:c:func:`gcc_jit_context_compile`:\n+\n+.. code-block:: c\n+\n+   gcc_jit_result *result;\n+   result = gcc_jit_context_compile (ctxt);\n+\n+and get a :c:type:`gcc_jit_result *`.\n+\n+We can now use :c:func:`gcc_jit_result_get_code` to look up a specific\n+machine code routine within the result, in this case, the function we\n+created above.\n+\n+.. code-block:: c\n+\n+   void *fn_ptr = gcc_jit_result_get_code (result, \"square\");\n+   if (!fn_ptr)\n+     {\n+       fprintf (stderr, \"NULL fn_ptr\");\n+       goto error;\n+     }\n+\n+We can now cast the pointer to an appropriate function pointer type, and\n+then call it:\n+\n+.. code-block:: c\n+\n+  typedef int (*fn_type) (int);\n+  fn_type square = (fn_type)fn_ptr;\n+  printf (\"result: %d\", square (5));\n+\n+.. code-block:: bash\n+\n+  result: 25\n+\n+\n+Options\n+*******\n+\n+To get more information on what's going on, you can set debugging flags\n+on the context using :c:func:`gcc_jit_context_set_bool_option`.\n+\n+.. (I'm deliberately not mentioning\n+    :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE` here since I think\n+    it's probably more of use to implementors than to users)\n+\n+Setting :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE` will dump a\n+C-like representation to stderr when you compile (GCC's \"GIMPLE\"\n+representation):\n+\n+.. code-block:: c\n+\n+   gcc_jit_context_set_bool_option (\n+     ctxt,\n+     GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+     1);\n+   result = gcc_jit_context_compile (ctxt);\n+\n+.. code-block:: c\n+\n+  square (signed int i)\n+  {\n+    signed int D.260;\n+\n+    entry:\n+    D.260 = i * i;\n+    return D.260;\n+  }\n+\n+We can see the generated machine code in assembler form (on stderr) by\n+setting :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE` on the context\n+before compiling:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+    1);\n+  result = gcc_jit_context_compile (ctxt);\n+\n+.. code-block:: gas\n+\n+        .file   \"fake.c\"\n+        .text\n+        .globl  square\n+        .type   square, @function\n+  square:\n+  .LFB6:\n+        .cfi_startproc\n+        pushq   %rbp\n+        .cfi_def_cfa_offset 16\n+        .cfi_offset 6, -16\n+        movq    %rsp, %rbp\n+        .cfi_def_cfa_register 6\n+        movl    %edi, -4(%rbp)\n+  .L14:\n+        movl    -4(%rbp), %eax\n+        imull   -4(%rbp), %eax\n+        popq    %rbp\n+        .cfi_def_cfa 7, 8\n+        ret\n+        .cfi_endproc\n+  .LFE6:\n+        .size   square, .-square\n+        .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n+        .section       .note.GNU-stack,\"\",@progbits\n+\n+By default, no optimizations are performed, the equivalent of GCC's\n+`-O0` option.  We can turn things up to e.g. `-O3` by calling\n+:c:func:`gcc_jit_context_set_int_option` with\n+:c:macro:`GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_int_option (\n+    ctxt,\n+    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+    3);\n+\n+.. code-block:: gas\n+\n+        .file   \"fake.c\"\n+        .text\n+        .p2align 4,,15\n+        .globl  square\n+        .type   square, @function\n+  square:\n+  .LFB7:\n+        .cfi_startproc\n+  .L16:\n+        movl    %edi, %eax\n+        imull   %edi, %eax\n+        ret\n+        .cfi_endproc\n+  .LFE7:\n+        .size   square, .-square\n+        .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n+        .section        .note.GNU-stack,\"\",@progbits\n+\n+Naturally this has only a small effect on such a trivial function.\n+\n+\n+Full example\n+************\n+\n+Here's what the above looks like as a complete program:\n+\n+   .. literalinclude:: ../examples/tut02-square.c\n+    :lines: 1-\n+    :language: c\n+\n+Building and running it:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut02-square.c \\\n+      -o tut02-square \\\n+      -lgccjit\n+\n+  # Run the built program:\n+  $ ./tut02-square\n+  result: 25"}, {"sha": "08451509d162e458f2f3b3a421c029467d236839", "filename": "gcc/jit/docs/intro/tutorial03.rst", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial03.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial03.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial03.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,378 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Tutorial part 3: Loops and variables\n+------------------------------------\n+Consider this C function:\n+\n+ .. code-block:: c\n+\n+  int loop_test (int n)\n+  {\n+    int sum = 0;\n+    for (int i = 0; i < n; i++)\n+      sum += i * i;\n+    return sum;\n+  }\n+\n+This example demonstrates some more features of libgccjit, with local\n+variables and a loop.\n+\n+To break this down into libgccjit terms, it's usually easier to reword\n+the `for` loop as a `while` loop, giving:\n+\n+ .. code-block:: c\n+\n+  int loop_test (int n)\n+  {\n+    int sum = 0;\n+    int i = 0;\n+    while (i < n)\n+    {\n+      sum += i * i;\n+      i++;\n+    }\n+    return sum;\n+  }\n+\n+Here's what the final control flow graph will look like:\n+\n+    .. figure:: sum-of-squares.png\n+      :alt: image of a control flow graph\n+\n+As before, we include the libgccjit header and make a\n+:c:type:`gcc_jit_context *`.\n+\n+.. code-block:: c\n+\n+  #include <libgccjit.h>\n+\n+  void test (void)\n+  {\n+    gcc_jit_context *ctxt;\n+    ctxt = gcc_jit_context_acquire ();\n+\n+The function works with the C `int` type:\n+\n+.. code-block:: c\n+\n+  gcc_jit_type *the_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = the_type;\n+\n+though we could equally well make it work on, say, `double`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_type *the_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_DOUBLE);\n+\n+Let's build the function:\n+\n+.. code-block:: c\n+\n+  gcc_jit_param *n =\n+    gcc_jit_context_new_param (ctxt, NULL, the_type, \"n\");\n+  gcc_jit_param *params[1] = {n};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"loop_test\",\n+\t\t\t\t  1, params, 0);\n+\n+Expressions: lvalues and rvalues\n+********************************\n+\n+The base class of expression is the :c:type:`gcc_jit_rvalue *`,\n+representing an expression that can be on the *right*-hand side of\n+an assignment: a value that can be computed somehow, and assigned\n+*to* a storage area (such as a variable).  It has a specific\n+:c:type:`gcc_jit_type *`.\n+\n+Anothe important class is :c:type:`gcc_jit_lvalue *`.\n+A :c:type:`gcc_jit_lvalue *`. is something that can of the *left*-hand\n+side of an assignment: a storage area (such as a variable).\n+\n+In other words, every assignment can be thought of as:\n+\n+.. code-block:: c\n+\n+   LVALUE = RVALUE;\n+\n+Note that :c:type:`gcc_jit_lvalue *` is a subclass of\n+:c:type:`gcc_jit_rvalue *`, where in an assignment of the form:\n+\n+.. code-block:: c\n+\n+   LVALUE_A = LVALUE_B;\n+\n+the `LVALUE_B` implies reading the current value of that storage\n+area, assigning it into the `LVALUE_A`.\n+\n+So far the only expressions we've seen are `i * i`:\n+\n+.. code-block:: c\n+\n+   gcc_jit_rvalue *expr =\n+     gcc_jit_context_new_binary_op (\n+       ctxt, NULL,\n+       GCC_JIT_BINARY_OP_MULT, int_type,\n+       gcc_jit_param_as_rvalue (param_i),\n+       gcc_jit_param_as_rvalue (param_i));\n+\n+which is a :c:type:`gcc_jit_rvalue *`, and the various function\n+parameters: `param_i` and `param_n`, instances of\n+:c:type:`gcc_jit_param *`, which is a subclass of\n+:c:type:`gcc_jit_lvalue *` (and, in turn, of :c:type:`gcc_jit_rvalue *`):\n+we can both read from and write to function parameters within the\n+body of a function.\n+\n+Our new example has a couple of local variables.  We create them by\n+calling :c:func:`gcc_jit_function_new_local`, supplying a type and a\n+name:\n+\n+.. code-block:: c\n+\n+  /* Build locals:  */\n+  gcc_jit_lvalue *i =\n+    gcc_jit_function_new_local (func, NULL, the_type, \"i\");\n+  gcc_jit_lvalue *sum =\n+    gcc_jit_function_new_local (func, NULL, the_type, \"sum\");\n+\n+These are instances of :c:type:`gcc_jit_lvalue *` - they can be read from\n+and written to.\n+\n+Note that there is no precanned way to create *and* initialize a variable\n+like in C:\n+\n+.. code-block:: c\n+\n+   int i = 0;\n+\n+Instead, having added the local to the function, we have to separately add\n+an assignment of `0` to `local_i` at the beginning of the function.\n+\n+Control flow\n+************\n+\n+This function has a loop, so we need to build some basic blocks to\n+handle the control flow.  In this case, we need 4 blocks:\n+\n+1. before the loop (initializing the locals)\n+2. the conditional at the top of the loop (comparing `i < n`)\n+3. the body of the loop\n+4. after the loop terminates (`return sum`)\n+\n+so we create these as :c:type:`gcc_jit_block *` instances within the\n+:c:type:`gcc_jit_function *`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+  gcc_jit_block *b_loop_cond =\n+    gcc_jit_function_new_block (func, \"loop_cond\");\n+  gcc_jit_block *b_loop_body =\n+    gcc_jit_function_new_block (func, \"loop_body\");\n+  gcc_jit_block *b_after_loop =\n+    gcc_jit_function_new_block (func, \"after_loop\");\n+\n+We now populate each block with statements.\n+\n+The entry block `b_initial` consists of initializations followed by a jump\n+to the conditional.  We assign `0` to `i` and to `sum`, using\n+:c:func:`gcc_jit_block_add_assignment` to add\n+an assignment statement, and using :c:func:`gcc_jit_context_zero` to get\n+the constant value `0` for the relevant type for the right-hand side of\n+the assignment:\n+\n+.. code-block:: c\n+\n+  /* sum = 0; */\n+  gcc_jit_block_add_assignment (\n+    b_initial, NULL,\n+    sum,\n+    gcc_jit_context_zero (ctxt, the_type));\n+\n+  /* i = 0; */\n+  gcc_jit_block_add_assignment (\n+    b_initial, NULL,\n+    i,\n+    gcc_jit_context_zero (ctxt, the_type));\n+\n+We can then terminate the entry block by jumping to the conditional:\n+\n+.. code-block:: c\n+\n+  gcc_jit_block_end_with_jump (b_initial, NULL, b_loop_cond);\n+\n+The conditional block is equivalent to the line `while (i < n)` from our\n+C example. It contains a single statement: a conditional, which jumps to\n+one of two destination blocks depending on a boolean\n+:c:type:`gcc_jit_rvalue *`, in this case the comparison of `i` and `n`.\n+We build the comparison using :c:func:`gcc_jit_context_new_comparison`:\n+\n+.. code-block:: c\n+\n+   gcc_jit_rvalue *guard =\n+     gcc_jit_context_new_comparison (\n+       ctxt, NULL,\n+       GCC_JIT_COMPARISON_GE,\n+       gcc_jit_lvalue_as_rvalue (i),\n+       gcc_jit_param_as_rvalue (n));\n+\n+and can then use this to add `b_loop_cond`'s sole statement, via\n+:c:func:`gcc_jit_block_end_with_conditional`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_block_end_with_conditional (b_loop_cond, NULL, guard);\n+\n+Next, we populate the body of the loop.\n+\n+The C statement `sum += i * i;` is an assignment operation, where an\n+lvalue is modified \"in-place\".  We use\n+:c:func:`gcc_jit_block_add_assignment_op` to handle these operations:\n+\n+.. code-block:: c\n+\n+  /* sum += i * i */\n+  gcc_jit_block_add_assignment_op (\n+    b_loop_body, NULL,\n+    sum,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT, the_type,\n+      gcc_jit_lvalue_as_rvalue (i),\n+      gcc_jit_lvalue_as_rvalue (i)));\n+\n+The `i++` can be thought of as `i += 1`, and can thus be handled in\n+a similar way.  We use :c:func:`gcc_jit_context_one` to get the constant\n+value `1` (for the relevant type) for the right-hand side\n+of the assignment.\n+\n+.. code-block:: c\n+\n+  /* i++ */\n+  gcc_jit_block_add_assignment_op (\n+    b_loop_body, NULL,\n+    i,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_one (ctxt, the_type));\n+\n+.. note::\n+\n+  For numeric constants other than 0 or 1, we could use\n+  :c:func:`gcc_jit_context_new_rvalue_from_int` and\n+  :c:func:`gcc_jit_context_new_rvalue_from_double`.\n+\n+The loop body completes by jumping back to the conditional:\n+\n+.. code-block:: c\n+\n+  gcc_jit_block_end_with_jump (b_loop_body, NULL, b_loop_cond);\n+\n+Finally, we populate the `b_after_loop` block, reached when the loop\n+conditional is false.  We want to generate the equivalent of:\n+\n+.. code-block:: c\n+\n+   return sum;\n+\n+so the block is just one statement:\n+\n+.. code-block:: c\n+\n+  /* return sum */\n+  gcc_jit_block_end_with_return (\n+    b_after_loop,\n+    NULL,\n+    gcc_jit_lvalue_as_rvalue (sum));\n+\n+.. note::\n+\n+   You can intermingle block creation with statement creation,\n+   but given that the terminator statements generally include references\n+   to other blocks, I find it's clearer to create all the blocks,\n+   *then* all the statements.\n+\n+We've finished populating the function.  As before, we can now compile it\n+to machine code:\n+\n+.. code-block:: c\n+\n+   gcc_jit_result *result;\n+   result = gcc_jit_context_compile (ctxt);\n+\n+   typedef int (*loop_test_fn_type) (int);\n+   loop_test_fn_type loop_test =\n+    (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\n+   if (!loop_test)\n+     goto error;\n+   printf (\"result: %d\", loop_test (10));\n+\n+.. code-block:: bash\n+\n+   result: 285\n+\n+\n+Visualizing the control flow graph\n+**********************************\n+\n+You can see the control flow graph of a function using\n+:c:func:`gcc_jit_function_dump_to_dot`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_function_dump_to_dot (func, \"/tmp/sum-of-squares.dot\");\n+\n+giving a .dot file in GraphViz format.\n+\n+You can convert this to an image using `dot`:\n+\n+.. code-block:: bash\n+\n+   $ dot -Tpng /tmp/sum-of-squares.dot -o /tmp/sum-of-squares.png\n+\n+or use a viewer (my preferred one is xdot.py; see\n+https://github.com/jrfonseca/xdot.py; on Fedora you can\n+install it with `yum install python-xdot`):\n+\n+    .. figure:: sum-of-squares.png\n+      :alt: image of a control flow graph\n+\n+Full example\n+************\n+\n+   .. literalinclude:: ../examples/tut03-sum-of-squares.c\n+    :lines: 1-\n+    :language: c\n+\n+Building and running it:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut03-sum-of-squares.c \\\n+      -o tut03-sum-of-squares \\\n+      -lgccjit\n+\n+  # Run the built program:\n+  $ ./tut03-sum-of-squares\n+  loop_test returned: 285"}, {"sha": "cafdddb2aefc21f1a2176f2aec9eaf12aa8bd31a", "filename": "gcc/jit/docs/intro/tutorial04.rst", "status": "added", "additions": 1108, "deletions": 0, "changes": 1108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial04.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial04.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial04.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,1108 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Tutorial part 4: Adding JIT-compilation to a toy interpreter\n+------------------------------------------------------------\n+In this example we construct a \"toy\" interpreter, and add JIT-compilation\n+to it.\n+\n+Our toy interpreter\n+*******************\n+\n+It's a stack-based interpreter, and is intended as a (very simple) example\n+of the kind of bytecode interpreter seen in dynamic languages such as\n+Python, Ruby etc.\n+\n+For the sake of simplicity, our toy virtual machine is very limited:\n+\n+  * The only data type is `int`\n+\n+  * It can only work on one function at a time (so that the only\n+    function call that can be made is to recurse).\n+\n+  * Functions can only take one parameter.\n+\n+  * Functions have a stack of `int` values.\n+\n+  * We'll implement function call within the interpreter by calling a\n+    function in our implementation, rather than implementing our own\n+    frame stack.\n+\n+  * The parser is only good enough to get the examples to work.\n+\n+Naturally, a real interpreter would be much more complicated that this.\n+\n+The following operations are supported:\n+\n+====================== ======================== =============== ==============\n+Operation              Meaning                  Old Stack       New Stack\n+====================== ======================== =============== ==============\n+DUP                    Duplicate top of stack.  ``[..., x]``    ``[..., x, x]``\n+ROT                    Swap top two elements    ``[..., x, y]`` ``[..., y, x]``\n+                       of stack.\n+BINARY_ADD             Add the top two elements ``[..., x, y]`` ``[..., (x+y)]``\n+                       on the stack.\n+BINARY_SUBTRACT        Likewise, but subtract.  ``[..., x, y]`` ``[..., (x-y)]``\n+BINARY_MULT            Likewise, but multiply.  ``[..., x, y]`` ``[..., (x*y)]``\n+BINARY_COMPARE_LT      Compare the top two      ``[..., x, y]`` ``[..., (x<y)]``\n+                       elements on the stack\n+                       and push a nonzero/zero\n+                       if (x<y).\n+RECURSE                Recurse, passing the top ``[..., x]``    ``[..., fn(x)]``\n+                       of the stack, and\n+                       popping the result.\n+RETURN                 Return the top of the    ``[x]``         ``[]``\n+                       stack.\n+PUSH_CONST `arg`       Push an int const.       ``[...]``       ``[..., arg]``\n+JUMP_ABS_IF_TRUE `arg` Pop; if top of stack was ``[..., x]``    ``[...]``\n+                       nonzero, jump to\n+                       ``arg``.\n+====================== ======================== =============== ==============\n+\n+Programs can be interpreted, disassembled, and compiled to machine code.\n+\n+The interpreter reads ``.toy`` scripts.  Here's what a simple recursive\n+factorial program looks like, the script ``factorial.toy``.\n+The parser ignores lines beginning with a `#`.\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/factorial.toy\n+    :lines: 1-\n+    :language: c\n+\n+The interpreter is a simple infinite loop with a big ``switch`` statement\n+based on what the next opcode is:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Execute the given function.  */\n+    :end-before: /* JIT compilation.  */\n+    :language: c\n+\n+Compiling to machine code\n+*************************\n+We want to generate machine code that can be cast to this type and\n+then directly executed in-process:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Functions are compiled to this function ptr type.  */\n+    :end-before: enum opcode\n+    :language: c\n+\n+Our compiler isn't very sophisticated; it takes the implementation of\n+each opcode above, and maps it directly to the operations supported by\n+the libgccjit API.\n+\n+How should we handle the stack?  In theory we could calculate what the\n+stack depth will be at each opcode, and optimize away the stack\n+manipulation \"by hand\".  We'll see below that libgccjit is able to do\n+this for us, so we'll implement stack manipulation\n+in a direct way, by creating a ``stack`` array and ``stack_depth``\n+variables, local within the generated function, equivalent to this C code:\n+\n+.. code-block:: c\n+\n+  int stack_depth;\n+  int stack[MAX_STACK_DEPTH];\n+\n+We'll also have local variables ``x`` and ``y`` for use when implementing\n+the opcodes, equivalent to this:\n+\n+.. code-block:: c\n+\n+  int x;\n+  int y;\n+\n+This means our compiler has the following state:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* JIT compilation.  */\n+    :end-before: /* Stack manipulation.  */\n+    :language: c\n+\n+Setting things up\n+*****************\n+\n+First we create our types:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Create types.  */\n+    :end-before: /* The constant value 1.  */\n+    :language: c\n+\n+along with extracting a useful `int` constant:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* The constant value 1.  */\n+    :end-before: /* Create locations.  */\n+    :language: c\n+\n+We'll implement push and pop in terms of the ``stack`` array and\n+``stack_depth``.  Here are helper functions for adding statements to\n+a block, implementing pushing and popping values:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Stack manipulation.  */\n+    :end-before: /* The main compilation hook.  */\n+    :language: c\n+\n+We will support single-stepping through the generated code in the\n+debugger, so we need to create :c:type:`gcc_jit_location` instances, one\n+per operation in the source code.  These will reference the lines of\n+e.g. ``factorial.toy``.\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Create locations.  */\n+    :end-before: /* Creating the function.  */\n+    :language: c\n+\n+Let's create the function itself.  As usual, we create its parameter\n+first, then use the parameter to create the function:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Creating the function.  */\n+    :end-before: /* Create stack lvalues.  */\n+    :language: c\n+\n+We create the locals within the function.\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Create stack lvalues.  */\n+    :end-before: /* 1st pass: create blocks, one per opcode.\n+    :language: c\n+\n+Populating the function\n+***********************\n+\n+There's some one-time initialization, and the API treats the first block\n+you create as the entrypoint of the function, so we need to create that\n+block first:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: first.  */\n+    :end-before: /* Create a block per operation.  */\n+    :language: c\n+\n+We can now create blocks for each of the operations.  Most of these will\n+be consolidated into larger blocks when the optimizer runs.\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Create a block per operation.  */\n+    :end-before: /* Populate the initial block.  */\n+    :language: c\n+\n+Now that we have a block it can jump to when it's done, we can populate\n+the initial block:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Populate the initial block.  */\n+    :end-before: /* 2nd pass: fill in instructions.  */\n+    :language: c\n+\n+We can now populate the blocks for the individual operations.  We loop\n+through them, adding instructions to their blocks:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* 2nd pass: fill in instructions.  */\n+    :end-before: /* Helper macros.  */\n+    :language: c\n+\n+We're going to have another big ``switch`` statement for implementing\n+the opcodes, this time for compiling them, rather than interpreting\n+them.  It's helpful to have macros for implementing push and pop, so that\n+we can make the ``switch`` statement that's coming up look as much as\n+possible like the one above within the interpreter:\n+\n+.. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Helper macros.  */\n+    :end-before: gcc_jit_block_add_comment\n+    :language: c\n+\n+.. note::\n+\n+   A particularly clever implementation would have an *identical*\n+   ``switch`` statement shared by the interpreter and the compiler, with\n+   some preprocessor \"magic\".  We're not doing that here, for the sake\n+   of simplicity.\n+\n+When I first implemented this compiler, I accidentally missed an edit\n+when copying and pasting the ``Y_EQUALS_POP`` macro, so that popping the\n+stack into ``y`` instead erroneously assigned it to ``x``, leaving ``y``\n+uninitialized.\n+\n+To track this kind of thing down, we can use\n+:c:func:`gcc_jit_block_add_comment` to add descriptive comments\n+to the internal representation.  This is invaluable when looking through\n+the generated IR for, say ``factorial``:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: PUSH_RVALUE (gcc_jit_lvalue_as_rvalue (state.y))\n+    :end-before: /* Handle the individual opcodes.  */\n+    :language: c\n+\n+We can now write the big ``switch`` statement that implements the\n+individual opcodes, populating the relevant block with statements:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Handle the individual opcodes.  */\n+    :end-before: /* Go to the next block.  */\n+    :language: c\n+\n+Every block must be terminated, via a call to one of the\n+``gcc_jit_block_end_with_`` entrypoints.  This has been done for two\n+of the opcodes, but we need to do it for the other ones, by jumping\n+to the next block.\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* Go to the next block.  */\n+    :end-before: /* end of loop on PC locations.  */\n+    :language: c\n+\n+This is analogous to simply incrementing the program counter.\n+\n+Verifying the control flow graph\n+********************************\n+Having finished looping over the blocks, the context is complete.\n+\n+As before, we can verify that the control flow and statements are sane by\n+using :c:func:`gcc_jit_function_dump_to_dot`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_function_dump_to_dot (state.fn, \"/tmp/factorial.dot\");\n+\n+and viewing the result.  Note how the label names, comments, and\n+variable names show up in the dump, to make it easier to spot\n+errors in our compiler.\n+\n+  .. figure:: factorial.png\n+    :alt: image of a control flow graph\n+\n+Compiling the context\n+*********************\n+Having finished looping over the blocks and populating them with\n+statements, the context is complete.\n+\n+We can now compile it, and extract machine code from the result:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* We've now finished populating the context.  Compile it.  */\n+    :end-before: /* (this leaks \"result\" and \"funcname\") */\n+    :language: c\n+\n+We can now run the result:\n+\n+   .. literalinclude:: ../examples/tut04-toyvm/toyvm.c\n+    :start-after: /* JIT-compilation.  */\n+    :end-before: return 0;\n+    :language: c\n+\n+Single-stepping through the generated code\n+******************************************\n+\n+It's possible to debug the generated code.  To do this we need to both:\n+\n+  * Set up source code locations for our statements, so that we can\n+    meaningfully step through the code.  We did this above by\n+    calling :c:func:`gcc_jit_context_new_location` and using the\n+    results.\n+\n+  * Enable the generation of debugging information, by setting\n+    :c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` on the\n+    :c:type:`gcc_jit_context` via\n+    :c:func:`gcc_jit_context_set_bool_option`:\n+\n+    .. code-block:: c\n+\n+     gcc_jit_context_set_bool_option (\n+       ctxt,\n+       GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+       1);\n+\n+Having done this, we can put a breakpoint on the generated function:\n+\n+.. code-block:: console\n+\n+  $ gdb --args ./toyvm factorial.toy 10\n+  (gdb) break factorial\n+  Function \"factorial\" not defined.\n+  Make breakpoint pending on future shared library load? (y or [n]) y\n+  Breakpoint 1 (factorial) pending.\n+  (gdb) run\n+  Breakpoint 1, factorial (arg=10) at factorial.toy:14\n+  14\tDUP\n+\n+We've set up location information, which references ``factorial.toy``.\n+This allows us to use e.g. ``list`` to see where we are in the script:\n+\n+.. code-block:: console\n+\n+  (gdb) list\n+  9\n+  10    # Initial state:\n+  11    # stack: [arg]\n+  12\n+  13    # 0:\n+  14    DUP\n+  15    # stack: [arg, arg]\n+  16\n+  17    # 1:\n+  18    PUSH_CONST 2\n+\n+and to step through the function, examining the data:\n+\n+.. code-block:: console\n+\n+  (gdb) n\n+  18    PUSH_CONST 2\n+  (gdb) n\n+  22    BINARY_COMPARE_LT\n+  (gdb) print stack\n+  $5 = {10, 10, 2, 0, -7152, 32767, 0, 0}\n+  (gdb) print stack_depth\n+  $6 = 3\n+\n+You'll see that the parts of the ``stack`` array that haven't been\n+touched yet are uninitialized.\n+\n+.. note::\n+\n+   Turning on optimizations may lead to unpredictable results when\n+   stepping through the generated code: the execution may appear to\n+   \"jump around\" the source code.  This is analogous to turning up the\n+   optimization level in a regular compiler.\n+\n+Examining the generated code\n+****************************\n+\n+How good is the optimized code?\n+\n+We can turn up optimizations, by calling\n+:c:func:`gcc_jit_context_set_int_option` with\n+:c:macro:`GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_int_option (\n+    ctxt,\n+    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+    3);\n+\n+One of GCC's internal representations is called \"gimple\".  A dump of the\n+initial gimple representation of the code can be seen by setting:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_bool_option (ctxt,\n+                                   GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+                                   1);\n+\n+With optimization on and source locations displayed, this gives:\n+\n+.. We'll use \"c\" for gimple dumps\n+\n+.. code-block:: c\n+\n+  factorial (signed int arg)\n+  {\n+    <unnamed type> D.80;\n+    signed int D.81;\n+    signed int D.82;\n+    signed int D.83;\n+    signed int D.84;\n+    signed int D.85;\n+    signed int y;\n+    signed int x;\n+    signed int stack_depth;\n+    signed int stack[8];\n+\n+    try\n+      {\n+        initial:\n+        stack_depth = 0;\n+        stack[stack_depth] = arg;\n+        stack_depth = stack_depth + 1;\n+        goto instr0;\n+        instr0:\n+        /* DUP */:\n+        stack_depth = stack_depth + -1;\n+        x = stack[stack_depth];\n+        stack[stack_depth] = x;\n+        stack_depth = stack_depth + 1;\n+        stack[stack_depth] = x;\n+        stack_depth = stack_depth + 1;\n+        goto instr1;\n+        instr1:\n+        /* PUSH_CONST */:\n+        stack[stack_depth] = 2;\n+        stack_depth = stack_depth + 1;\n+        goto instr2;\n+\n+        /* etc */\n+\n+You can see the generated machine code in assembly form via:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+    1);\n+  result = gcc_jit_context_compile (ctxt);\n+\n+which shows that (on this x86_64 box) the compiler has unrolled the loop\n+and is using MMX instructions to perform several multiplications\n+simultaneously:\n+\n+.. code-block:: gas\n+\n+          .file   \"fake.c\"\n+          .text\n+  .Ltext0:\n+          .p2align 4,,15\n+          .globl  factorial\n+          .type   factorial, @function\n+  factorial:\n+  .LFB0:\n+          .file 1 \"factorial.toy\"\n+          .loc 1 14 0\n+          .cfi_startproc\n+  .LVL0:\n+  .L2:\n+          .loc 1 26 0\n+          cmpl    $1, %edi\n+          jle     .L13\n+          leal    -1(%rdi), %edx\n+          movl    %edx, %ecx\n+          shrl    $2, %ecx\n+          leal    0(,%rcx,4), %esi\n+          testl   %esi, %esi\n+          je      .L14\n+          cmpl    $9, %edx\n+          jbe     .L14\n+          leal    -2(%rdi), %eax\n+          movl    %eax, -16(%rsp)\n+          leal    -3(%rdi), %eax\n+          movd    -16(%rsp), %xmm0\n+          movl    %edi, -16(%rsp)\n+          movl    %eax, -12(%rsp)\n+          movd    -16(%rsp), %xmm1\n+          xorl    %eax, %eax\n+          movl    %edx, -16(%rsp)\n+          movd    -12(%rsp), %xmm4\n+          movd    -16(%rsp), %xmm6\n+          punpckldq       %xmm4, %xmm0\n+          movdqa  .LC1(%rip), %xmm4\n+          punpckldq       %xmm6, %xmm1\n+          punpcklqdq      %xmm0, %xmm1\n+          movdqa  .LC0(%rip), %xmm0\n+          jmp     .L5\n+          # etc - edited for brevity\n+\n+This is clearly overkill for a function that will likely overflow the\n+``int`` type before the vectorization is worthwhile - but then again, this\n+is a toy example.\n+\n+Turning down the optimization level to 2:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_int_option (\n+    ctxt,\n+    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+    3);\n+\n+yields this code, which is simple enough to quote in its entirety:\n+\n+.. code-block:: gas\n+\n+          .file   \"fake.c\"\n+          .text\n+          .p2align 4,,15\n+          .globl  factorial\n+          .type   factorial, @function\n+  factorial:\n+  .LFB0:\n+          .cfi_startproc\n+  .L2:\n+          cmpl    $1, %edi\n+          jle     .L8\n+          movl    $1, %edx\n+          jmp     .L4\n+          .p2align 4,,10\n+          .p2align 3\n+  .L6:\n+          movl    %eax, %edi\n+  .L4:\n+  .L5:\n+          leal    -1(%rdi), %eax\n+          imull   %edi, %edx\n+          cmpl    $1, %eax\n+          jne     .L6\n+  .L3:\n+  .L7:\n+          imull   %edx, %eax\n+          ret\n+  .L8:\n+          movl    %edi, %eax\n+          movl    $1, %edx\n+          jmp     .L7\n+          .cfi_endproc\n+  .LFE0:\n+          .size   factorial, .-factorial\n+          .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-%{gcc_release})\"\n+          .section        .note.GNU-stack,\"\",@progbits\n+\n+Note that the stack pushing and popping have been eliminated, as has the\n+recursive call (in favor of an iteration).\n+\n+Putting it all together\n+***********************\n+\n+The complete example can be seen in the source tree at\n+``gcc/jit/docs/examples/tut04-toyvm/toyvm.c``\n+\n+along with a Makefile and a couple of sample .toy scripts:\n+\n+.. code-block:: console\n+\n+  $ ls -al\n+  drwxrwxr-x. 2 david david   4096 Sep 19 17:46 .\n+  drwxrwxr-x. 3 david david   4096 Sep 19 15:26 ..\n+  -rw-rw-r--. 1 david david    615 Sep 19 12:43 factorial.toy\n+  -rw-rw-r--. 1 david david    834 Sep 19 13:08 fibonacci.toy\n+  -rw-rw-r--. 1 david david    238 Sep 19 14:22 Makefile\n+  -rw-rw-r--. 1 david david  16457 Sep 19 17:07 toyvm.c\n+\n+  $ make toyvm\n+  g++ -Wall -g -o toyvm toyvm.c -lgccjit\n+\n+  $ ./toyvm factorial.toy 10\n+  interpreter result: 3628800\n+  compiler result: 3628800\n+\n+  $ ./toyvm fibonacci.toy 10\n+  interpreter result: 55\n+  compiler result: 55\n+\n+Behind the curtain: How does our code get optimized?\n+****************************************************\n+\n+Our example is done, but you may be wondering about exactly how the\n+compiler turned what we gave it into the machine code seen above.\n+\n+We can examine what the compiler is doing in detail by setting:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+                                   GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n+                                   1);\n+  gcc_jit_context_set_bool_option (state.ctxt,\n+                                   GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n+                                   1);\n+\n+This will dump detailed information about the compiler's state to a\n+directory under ``/tmp``, and keep it from being cleaned up.\n+\n+The precise names and their formats of these files is subject to change.\n+Higher optimization levels lead to more files.\n+Here's what I saw (edited for brevity; there were almost 200 files):\n+\n+.. code-block:: console\n+\n+  intermediate files written to /tmp/libgccjit-KPQbGw\n+  $ ls /tmp/libgccjit-KPQbGw/\n+  fake.c.000i.cgraph\n+  fake.c.000i.type-inheritance\n+  fake.c.004t.gimple\n+  fake.c.007t.omplower\n+  fake.c.008t.lower\n+  fake.c.011t.eh\n+  fake.c.012t.cfg\n+  fake.c.014i.visibility\n+  fake.c.015i.early_local_cleanups\n+  fake.c.016t.ssa\n+  # etc\n+\n+The gimple code is converted into Static Single Assignment form,\n+with annotations for use when generating the debuginfo:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-KPQbGw/fake.c.016t.ssa\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+    signed int _56;\n+\n+  initial:\n+    stack_depth_3 = 0;\n+    # DEBUG stack_depth => stack_depth_3\n+    stack[stack_depth_3] = arg_5(D);\n+    stack_depth_7 = stack_depth_3 + 1;\n+    # DEBUG stack_depth => stack_depth_7\n+    # DEBUG instr0 => NULL\n+    # DEBUG /* DUP */ => NULL\n+    stack_depth_8 = stack_depth_7 + -1;\n+    # DEBUG stack_depth => stack_depth_8\n+    x_9 = stack[stack_depth_8];\n+    # DEBUG x => x_9\n+    stack[stack_depth_8] = x_9;\n+    stack_depth_11 = stack_depth_8 + 1;\n+    # DEBUG stack_depth => stack_depth_11\n+    stack[stack_depth_11] = x_9;\n+    stack_depth_13 = stack_depth_11 + 1;\n+    # DEBUG stack_depth => stack_depth_13\n+    # DEBUG instr1 => NULL\n+    # DEBUG /* PUSH_CONST */ => NULL\n+    stack[stack_depth_13] = 2;\n+\n+    /* etc; edited for brevity */\n+\n+We can perhaps better see the code by turning off\n+:c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` to suppress all those ``DEBUG``\n+statements, giving:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.016t.ssa\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+    signed int _56;\n+\n+  initial:\n+    stack_depth_3 = 0;\n+    stack[stack_depth_3] = arg_5(D);\n+    stack_depth_7 = stack_depth_3 + 1;\n+    stack_depth_8 = stack_depth_7 + -1;\n+    x_9 = stack[stack_depth_8];\n+    stack[stack_depth_8] = x_9;\n+    stack_depth_11 = stack_depth_8 + 1;\n+    stack[stack_depth_11] = x_9;\n+    stack_depth_13 = stack_depth_11 + 1;\n+    stack[stack_depth_13] = 2;\n+    stack_depth_15 = stack_depth_13 + 1;\n+    stack_depth_16 = stack_depth_15 + -1;\n+    y_17 = stack[stack_depth_16];\n+    stack_depth_18 = stack_depth_16 + -1;\n+    x_19 = stack[stack_depth_18];\n+    _20 = x_19 < y_17;\n+    _21 = (signed int) _20;\n+    stack[stack_depth_18] = _21;\n+    stack_depth_23 = stack_depth_18 + 1;\n+    stack_depth_24 = stack_depth_23 + -1;\n+    x_25 = stack[stack_depth_24];\n+    if (x_25 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    stack_depth_26 = stack_depth_24 + -1;\n+    x_27 = stack[stack_depth_26];\n+    stack[stack_depth_26] = x_27;\n+    stack_depth_29 = stack_depth_26 + 1;\n+    stack[stack_depth_29] = x_27;\n+    stack_depth_31 = stack_depth_29 + 1;\n+    stack[stack_depth_31] = 1;\n+    stack_depth_33 = stack_depth_31 + 1;\n+    stack_depth_34 = stack_depth_33 + -1;\n+    y_35 = stack[stack_depth_34];\n+    stack_depth_36 = stack_depth_34 + -1;\n+    x_37 = stack[stack_depth_36];\n+    _38 = x_37 - y_35;\n+    stack[stack_depth_36] = _38;\n+    stack_depth_40 = stack_depth_36 + 1;\n+    stack_depth_41 = stack_depth_40 + -1;\n+    x_42 = stack[stack_depth_41];\n+    _44 = factorial (x_42);\n+    stack[stack_depth_41] = _44;\n+    stack_depth_46 = stack_depth_41 + 1;\n+    stack_depth_47 = stack_depth_46 + -1;\n+    y_48 = stack[stack_depth_47];\n+    stack_depth_49 = stack_depth_47 + -1;\n+    x_50 = stack[stack_depth_49];\n+    _51 = x_50 * y_48;\n+    stack[stack_depth_49] = _51;\n+    stack_depth_53 = stack_depth_49 + 1;\n+\n+    # stack_depth_1 = PHI <stack_depth_24(2), stack_depth_53(3)>\n+  instr9:\n+  /* RETURN */:\n+    stack_depth_54 = stack_depth_1 + -1;\n+    x_55 = stack[stack_depth_54];\n+    _56 = x_55;\n+    stack ={v} {CLOBBER};\n+    return _56;\n+\n+  }\n+\n+Note in the above how all the :c:type:`gcc_jit_block` instances we\n+created have been consolidated into just 3 blocks in GCC's internal\n+representation: ``initial``, ``instr4`` and ``instr9``.\n+\n+Optimizing away stack manipulation\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+Recall our simple implementation of stack operations.  Let's examine\n+how the stack operations are optimized away.\n+\n+After a pass of constant-propagation, the depth of the stack at each\n+opcode can be determined at compile-time:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.021t.ccp1\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+\n+  initial:\n+    stack[0] = arg_5(D);\n+    x_9 = stack[0];\n+    stack[0] = x_9;\n+    stack[1] = x_9;\n+    stack[2] = 2;\n+    y_17 = stack[2];\n+    x_19 = stack[1];\n+    _20 = x_19 < y_17;\n+    _21 = (signed int) _20;\n+    stack[1] = _21;\n+    x_25 = stack[1];\n+    if (x_25 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    x_27 = stack[0];\n+    stack[0] = x_27;\n+    stack[1] = x_27;\n+    stack[2] = 1;\n+    y_35 = stack[2];\n+    x_37 = stack[1];\n+    _38 = x_37 - y_35;\n+    stack[1] = _38;\n+    x_42 = stack[1];\n+    _44 = factorial (x_42);\n+    stack[1] = _44;\n+    y_48 = stack[1];\n+    x_50 = stack[0];\n+    _51 = x_50 * y_48;\n+    stack[0] = _51;\n+\n+  instr9:\n+  /* RETURN */:\n+    x_55 = stack[0];\n+    x_56 = x_55;\n+    stack ={v} {CLOBBER};\n+    return x_56;\n+\n+  }\n+\n+Note how, in the above, all those ``stack_depth`` values are now just\n+constants: we're accessing specific stack locations at each opcode.\n+\n+The \"esra\" pass (\"Early Scalar Replacement of Aggregates\") breaks\n+out our \"stack\" array into individual elements:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.024t.esra\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  Created a replacement for stack offset: 0, size: 32: stack$0\n+  Created a replacement for stack offset: 32, size: 32: stack$1\n+  Created a replacement for stack offset: 64, size: 32: stack$2\n+\n+  Symbols to be put in SSA form\n+  { D.89 D.90 D.91 }\n+  Incremental SSA update started at block: 0\n+  Number of blocks in CFG: 5\n+  Number of blocks to update: 4 ( 80%)\n+\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack$2;\n+    signed int stack$1;\n+    signed int stack$0;\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+\n+  initial:\n+    stack$0_45 = arg_5(D);\n+    x_9 = stack$0_45;\n+    stack$0_39 = x_9;\n+    stack$1_32 = x_9;\n+    stack$2_30 = 2;\n+    y_17 = stack$2_30;\n+    x_19 = stack$1_32;\n+    _20 = x_19 < y_17;\n+    _21 = (signed int) _20;\n+    stack$1_28 = _21;\n+    x_25 = stack$1_28;\n+    if (x_25 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    x_27 = stack$0_39;\n+    stack$0_22 = x_27;\n+    stack$1_14 = x_27;\n+    stack$2_12 = 1;\n+    y_35 = stack$2_12;\n+    x_37 = stack$1_14;\n+    _38 = x_37 - y_35;\n+    stack$1_10 = _38;\n+    x_42 = stack$1_10;\n+    _44 = factorial (x_42);\n+    stack$1_6 = _44;\n+    y_48 = stack$1_6;\n+    x_50 = stack$0_22;\n+    _51 = x_50 * y_48;\n+    stack$0_1 = _51;\n+\n+    # stack$0_52 = PHI <stack$0_39(2), stack$0_1(3)>\n+  instr9:\n+  /* RETURN */:\n+    x_55 = stack$0_52;\n+    x_56 = x_55;\n+    stack ={v} {CLOBBER};\n+    return x_56;\n+\n+  }\n+\n+Hence at this point, all those pushes and pops of the stack are now\n+simply assignments to specific temporary variables.\n+\n+After some copy propagation, the stack manipulation has been completely\n+optimized away:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.026t.copyprop1\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack$2;\n+    signed int stack$1;\n+    signed int stack$0;\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+\n+  initial:\n+    stack$0_39 = arg_5(D);\n+    _20 = arg_5(D) <= 1;\n+    _21 = (signed int) _20;\n+    if (_21 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    _38 = arg_5(D) + -1;\n+    _44 = factorial (_38);\n+    _51 = arg_5(D) * _44;\n+    stack$0_1 = _51;\n+\n+    # stack$0_52 = PHI <arg_5(D)(2), _51(3)>\n+  instr9:\n+  /* RETURN */:\n+    stack ={v} {CLOBBER};\n+    return stack$0_52;\n+\n+  }\n+\n+Later on, another pass finally eliminated ``stack_depth`` local and the\n+unused parts of the `stack`` array altogether:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.036t.release_ssa\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  Released 44 names, 314.29%, removed 44 holes\n+  factorial (signed int arg)\n+  {\n+    signed int stack$0;\n+    signed int mult_acc_1;\n+    <unnamed type> _5;\n+    signed int _6;\n+    signed int _7;\n+    signed int mul_tmp_10;\n+    signed int mult_acc_11;\n+    signed int mult_acc_13;\n+\n+    # arg_9 = PHI <arg_8(D)(0)>\n+    # mult_acc_13 = PHI <1(0)>\n+  initial:\n+\n+    <bb 5>:\n+    # arg_4 = PHI <arg_9(2), _7(3)>\n+    # mult_acc_1 = PHI <mult_acc_13(2), mult_acc_11(3)>\n+    _5 = arg_4 <= 1;\n+    _6 = (signed int) _5;\n+    if (_6 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    _7 = arg_4 + -1;\n+    mult_acc_11 = mult_acc_1 * arg_4;\n+    goto <bb 5>;\n+\n+    # stack$0_12 = PHI <arg_4(5)>\n+  instr9:\n+  /* RETURN */:\n+    mul_tmp_10 = mult_acc_1 * stack$0_12;\n+    return mul_tmp_10;\n+\n+  }\n+\n+\n+Elimination of tail recursion\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+Another significant optimization is the detection that the call to\n+``factorial`` is tail recursion, which can be eliminated in favor of\n+an iteration:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.030t.tailr1\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+\n+  Symbols to be put in SSA form\n+  { D.88 }\n+  Incremental SSA update started at block: 0\n+  Number of blocks in CFG: 5\n+  Number of blocks to update: 4 ( 80%)\n+\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack$2;\n+    signed int stack$1;\n+    signed int stack$0;\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    signed int mult_acc_1;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int mul_tmp_44;\n+    signed int mult_acc_51;\n+\n+    # arg_5 = PHI <arg_39(D)(0), _38(3)>\n+    # mult_acc_1 = PHI <1(0), mult_acc_51(3)>\n+  initial:\n+    _20 = arg_5 <= 1;\n+    _21 = (signed int) _20;\n+    if (_21 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    _38 = arg_5 + -1;\n+    mult_acc_51 = mult_acc_1 * arg_5;\n+    goto <bb 2> (initial);\n+\n+    # stack$0_52 = PHI <arg_5(2)>\n+  instr9:\n+  /* RETURN */:\n+    stack ={v} {CLOBBER};\n+    mul_tmp_44 = mult_acc_1 * stack$0_52;\n+    return mul_tmp_44;\n+\n+  }"}, {"sha": "d8dd4f8df718d6d22e8f402f9b1fb681c6cfc0f0", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,315 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Compilation contexts\n+====================\n+\n+.. type:: gcc_jit_context\n+\n+The top-level of the API is the :c:type:`gcc_jit_context` type.\n+\n+A :c:type:`gcc_jit_context` instance encapsulates the state of a\n+compilation.\n+\n+You can set up options on it, and add types, functions and code.\n+Invoking :c:func:`gcc_jit_context_compile` on it gives you a\n+:c:type:`gcc_jit_result`.\n+\n+Lifetime-management\n+-------------------\n+Contexts are the unit of lifetime-management within the API: objects\n+have their lifetime bounded by the context they are created within, and\n+cleanup of such objects is done for you when the context is released.\n+\n+.. function:: gcc_jit_context *gcc_jit_context_acquire (void)\n+\n+  This function acquires a new :c:type:`gcc_jit_object *` instance,\n+  which is independent of any others that may be present within this\n+  process.\n+\n+.. function:: void gcc_jit_context_release (gcc_jit_context *ctxt)\n+\n+  This function releases all resources associated with the given context.\n+  Both the context itself and all of its :c:type:`gcc_jit_object *`\n+  instances are cleaned up.  It should be called exactly once on a given\n+  context.\n+\n+  It is invalid to use the context or any of its \"contextual\" objects\n+  after calling this.\n+\n+  .. code-block:: c\n+\n+    gcc_jit_context_release (ctxt);\n+\n+.. function:: gcc_jit_context * gcc_jit_context_new_child_context (gcc_jit_context *parent_ctxt)\n+\n+   Given an existing JIT context, create a child context.\n+\n+   The child inherits a copy of all option-settings from the parent.\n+\n+   The child can reference objects created within the parent, but not\n+   vice-versa.\n+\n+   The lifetime of the child context must be bounded by that of the\n+   parent: you should release a child context before releasing the parent\n+   context.\n+\n+   If you use a function from a parent context within a child context,\n+   you have to compile the parent context before you can compile the\n+   child context, and the gcc_jit_result of the parent context must\n+   outlive the gcc_jit_result of the child context.\n+\n+   This allows caching of shared initializations.  For example, you could\n+   create types and declarations of global functions in a parent context\n+   once within a process, and then create child contexts whenever a\n+   function or loop becomes hot. Each such child context can be used for\n+   JIT-compiling just one function or loop, but can reference types\n+   and helper functions created within the parent context.\n+\n+   Contexts can be arbitrarily nested, provided the above rules are\n+   followed, but it's probably not worth going above 2 or 3 levels, and\n+   there will likely be a performance hit for such nesting.\n+\n+\n+Thread-safety\n+-------------\n+Instances of :c:type:`gcc_jit_object *` created via\n+:c:func:`gcc_jit_context_acquire` are independent from each other:\n+only one thread may use a given context at once, but multiple threads\n+could each have their own contexts without needing locks.\n+\n+Contexts created via :c:func:`gcc_jit_context_new_child_context` are\n+related to their parent context.  They can be partitioned by their\n+ultimate ancestor into independent \"family trees\".   Only one thread\n+within a process may use a given \"family tree\" of such contexts at once,\n+and if you're using multiple threads you should provide your own locking\n+around entire such context partitions.\n+\n+\n+Error-handling\n+--------------\n+You can only compile and get code from a context if no errors occur.\n+\n+In general, if an error occurs when using an API entrypoint, it returns\n+NULL.  You don't have to check everywhere for NULL results, since the\n+API gracefully handles a NULL being passed in for any argument.\n+\n+Errors are printed on stderr and can be queried using\n+:c:func:`gcc_jit_context_get_first_error`.\n+\n+.. function:: const char *\\\n+              gcc_jit_context_get_first_error (gcc_jit_context *ctxt)\n+\n+   Returns the first error message that occurred on the context.\n+\n+   The returned string is valid for the rest of the lifetime of the\n+   context.\n+\n+   If no errors occurred, this will be NULL.\n+\n+Debugging\n+---------\n+\n+.. function:: void\\\n+              gcc_jit_context_dump_to_file (gcc_jit_context *ctxt,\\\n+                                            const char *path,\\\n+                                            int update_locations)\n+\n+   To help with debugging: dump a C-like representation to the given path,\n+   describing what's been set up on the context.\n+\n+   If \"update_locations\" is true, then also set up :type:`gcc_jit_location`\n+   information throughout the context, pointing at the dump file as if it\n+   were a source file.  This may be of use in conjunction with\n+   :macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` to allow stepping through the\n+   code in a debugger.\n+\n+\n+Options\n+-------\n+\n+String Options\n+**************\n+\n+.. function:: void gcc_jit_context_set_str_option(gcc_jit_context *ctxt, \\\n+                                                  enum gcc_jit_str_option opt, \\\n+                                                  const char *value)\n+\n+   Set a string option of the context.\n+\n+   .. type:: enum gcc_jit_str_option\n+\n+   There is currently just one string option:\n+\n+   .. macro:: GCC_JIT_STR_OPTION_PROGNAME\n+\n+      The name of the program, for use as a prefix when printing error\n+      messages to stderr.  If `NULL`, or default, \"libgccjit.so\" is used.\n+\n+Boolean options\n+***************\n+\n+.. function:: void gcc_jit_context_set_bool_option(gcc_jit_context *ctxt, \\\n+\t\t\t\t                   enum gcc_jit_bool_option opt, \\\n+\t\t\t\t                   int value)\n+\n+  Set a boolean option of the context.\n+  Zero is \"false\" (the default), non-zero is \"true\".\n+\n+  .. type:: enum gcc_jit_bool_option\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_DEBUGINFO\n+\n+     If true, :func:`gcc_jit_context_compile` will attempt to do the right\n+     thing so that if you attach a debugger to the process, it will\n+     be able to inspect variables and step through your code.\n+\n+     Note that you can't step through code unless you set up source\n+     location information for the code (by creating and passing in\n+     :type:`gcc_jit_location` instances).\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE\n+\n+     If true, :func:`gcc_jit_context_compile` will dump its initial\n+     \"tree\" representation of your code to stderr (before any\n+     optimizations).\n+\n+     Here's some sample output (from the `square` example)::\n+\n+        <statement_list 0x7f4875a62cc0\n+           type <void_type 0x7f4875a64bd0 VOID\n+               align 8 symtab 0 alias set -1 canonical type 0x7f4875a64bd0\n+               pointer_to_this <pointer_type 0x7f4875a64c78>>\n+           side-effects head 0x7f4875a761e0 tail 0x7f4875a761f8 stmts 0x7f4875a62d20 0x7f4875a62d00\n+\n+           stmt <label_expr 0x7f4875a62d20 type <void_type 0x7f4875a64bd0>\n+               side-effects\n+               arg 0 <label_decl 0x7f4875a79080 entry type <void_type 0x7f4875a64bd0>\n+                   VOID file (null) line 0 col 0\n+                   align 1 context <function_decl 0x7f4875a77500 square>>>\n+           stmt <return_expr 0x7f4875a62d00\n+               type <integer_type 0x7f4875a645e8 public SI\n+                   size <integer_cst 0x7f4875a623a0 constant 32>\n+                   unit size <integer_cst 0x7f4875a623c0 constant 4>\n+                   align 32 symtab 0 alias set -1 canonical type 0x7f4875a645e8 precision 32 min <integer_cst 0x7f4875a62340 -2147483648> max <integer_cst 0x7f4875a62360 2147483647>\n+                   pointer_to_this <pointer_type 0x7f4875a6b348>>\n+               side-effects\n+               arg 0 <modify_expr 0x7f4875a72a78 type <integer_type 0x7f4875a645e8>\n+                   side-effects arg 0 <result_decl 0x7f4875a7a000 D.54>\n+                   arg 1 <mult_expr 0x7f4875a72a50 type <integer_type 0x7f4875a645e8>\n+                       arg 0 <parm_decl 0x7f4875a79000 i> arg 1 <parm_decl 0x7f4875a79000 i>>>>>\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE\n+\n+     If true, :func:`gcc_jit_context_compile` will dump the \"gimple\"\n+     representation of your code to stderr, before any optimizations\n+     are performed.  The dump resembles C code:\n+\n+     .. code-block:: c\n+\n+       square (signed int i)\n+       {\n+         signed int D.56;\n+\n+         entry:\n+         D.56 = i * i;\n+         return D.56;\n+       }\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE\n+\n+     If true, :func:`gcc_jit_context_compile` will dump the final\n+     generated code to stderr, in the form of assembly language:\n+\n+     .. code-block:: gas\n+\n+           .file    \"fake.c\"\n+           .text\n+           .globl    square\n+           .type    square, @function\n+       square:\n+       .LFB0:\n+           .cfi_startproc\n+           pushq    %rbp\n+           .cfi_def_cfa_offset 16\n+           .cfi_offset 6, -16\n+           movq    %rsp, %rbp\n+           .cfi_def_cfa_register 6\n+           movl    %edi, -4(%rbp)\n+       .L2:\n+           movl    -4(%rbp), %eax\n+           imull    -4(%rbp), %eax\n+           popq    %rbp\n+           .cfi_def_cfa 7, 8\n+           ret\n+           .cfi_endproc\n+       .LFE0:\n+           .size    square, .-square\n+           .ident    \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.1-%{gcc_release})\"\n+           .section    .note.GNU-stack,\"\",@progbits\n+\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_DUMP_SUMMARY\n+\n+     If true, :func:`gcc_jit_context_compile` will print information to stderr\n+     on the actions it is performing, followed by a profile showing\n+     the time taken and memory usage of each phase.\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING\n+\n+     If true, :func:`gcc_jit_context_compile` will dump copious\n+     amount of information on what it's doing to various\n+     files within a temporary directory.  Use\n+     :macro:`GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES` (see below) to\n+     see the results.  The files are intended to be human-readable,\n+     but the exact files and their formats are subject to change.\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_SELFCHECK_GC\n+\n+     If true, libgccjit will aggressively run its garbage collector, to\n+     shake out bugs (greatly slowing down the compile).  This is likely\n+     to only be of interest to developers *of* the library.  It is\n+     used when running the selftest suite.\n+\n+  .. macro:: GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES\n+\n+     If true, the :type:`gcc_jit_context` will not clean up intermediate files\n+     written to the filesystem, and will display their location on stderr.\n+\n+Integer options\n+***************\n+\n+.. function:: void gcc_jit_context_set_int_option (gcc_jit_context *ctxt, \\\n+\t\t\t\t                   enum gcc_jit_int_option opt, \\\n+\t\t\t\t                   int value)\n+\n+  Set an integer option of the context.\n+\n+  .. type:: enum gcc_jit_int_option\n+\n+  There is currently just one integer option:\n+\n+  .. macro:: GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL\n+\n+     How much to optimize the code.\n+\n+     Valid values are 0-3, corresponding to GCC's command-line options\n+     -O0 through -O3.\n+\n+     The default value is 0 (unoptimized)."}, {"sha": "1cf9641aaf154f4eab05ef5791111509fbf5980e", "filename": "gcc/jit/docs/topics/expressions.rst", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,525 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Expressions\n+===========\n+\n+Rvalues\n+-------\n+.. type:: gcc_jit_rvalue\n+\n+A :c:type:`gcc_jit_rvalue *` is an expression that can be computed.\n+\n+It can be simple, e.g.:\n+\n+  * an integer value e.g. `0` or `42`\n+  * a string literal e.g. `\"Hello world\"`\n+  * a variable e.g. `i`.  These are also lvalues (see below).\n+\n+or compound e.g.:\n+\n+  * a unary expression e.g. `!cond`\n+  * a binary expression e.g. `(a + b)`\n+  * a function call e.g. `get_distance (&player_ship, &target)`\n+  * etc.\n+\n+Every rvalue has an associated type, and the API will check to ensure\n+that types match up correctly (otherwise the context will emit an error).\n+\n+.. function:: gcc_jit_type *gcc_jit_rvalue_get_type (gcc_jit_rvalue *rvalue)\n+\n+  Get the type of this rvalue.\n+\n+.. function:: gcc_jit_object *gcc_jit_rvalue_as_object (gcc_jit_rvalue *rvalue)\n+\n+  Upcast the given rvalue to be an object.\n+\n+\n+Simple expressions\n+******************\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_rvalue_from_int (gcc_jit_context *ctxt, \\\n+                                                   gcc_jit_type *numeric_type, \\\n+                                                   int value)\n+\n+   Given a numeric type (integer or floating point), build an rvalue for\n+   the given constant value.\n+\n+.. function::  gcc_jit_rvalue *gcc_jit_context_zero (gcc_jit_context *ctxt, \\\n+                                                     gcc_jit_type *numeric_type)\n+\n+   Given a numeric type (integer or floating point), get the rvalue for\n+   zero.  Essentially this is just a shortcut for:\n+\n+   .. code-block:: c\n+\n+      gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 0)\n+\n+.. function::  gcc_jit_rvalue *gcc_jit_context_one (gcc_jit_context *ctxt, \\\n+                                                    gcc_jit_type *numeric_type)\n+\n+   Given a numeric type (integer or floating point), get the rvalue for\n+   zero.  Essentially this is just a shortcut for:\n+\n+   .. code-block:: c\n+\n+      gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 1)\n+\n+.. function::  gcc_jit_rvalue *\\\n+               gcc_jit_context_new_rvalue_from_double (gcc_jit_context *ctxt, \\\n+                                                       gcc_jit_type *numeric_type, \\\n+                                                       double value)\n+\n+   Given a numeric type (integer or floating point), build an rvalue for\n+   the given constant value.\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_rvalue_from_ptr (gcc_jit_context *ctxt, \\\n+                                                   gcc_jit_type *pointer_type, \\\n+                                                   void *value)\n+\n+   Given a pointer type, build an rvalue for the given address.\n+\n+.. function:: gcc_jit_rvalue *gcc_jit_context_null (gcc_jit_context *ctxt, \\\n+                                                    gcc_jit_type *pointer_type)\n+\n+   Given a pointer type, build an rvalue for ``NULL``.  Essentially this\n+   is just a shortcut for:\n+\n+   .. code-block:: c\n+\n+      gcc_jit_context_new_rvalue_from_ptr (ctxt, pointer_type, NULL)\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_string_literal (gcc_jit_context *ctxt, \\\n+                                                  const char *value)\n+\n+   Generate an rvalue for the given NIL-terminated string, of type\n+   :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR`.\n+\n+\n+Unary Operations\n+****************\n+\n+.. function:: gcc_jit_rvalue * \\\n+              gcc_jit_context_new_unary_op (gcc_jit_context *ctxt, \\\n+                                            gcc_jit_location *loc, \\\n+                                            enum gcc_jit_unary_op op, \\\n+                                            gcc_jit_type *result_type, \\\n+                                            gcc_jit_rvalue *rvalue)\n+\n+   Build a unary operation out of an input rvalue.\n+\n+.. type:: enum gcc_jit_unary_op\n+\n+The available unary operations are:\n+\n+==========================================  ============\n+Unary Operation                             C equivalent\n+==========================================  ============\n+:c:macro:`GCC_JIT_UNARY_OP_MINUS`           `-(EXPR)`\n+:c:macro:`GCC_JIT_UNARY_OP_BITWISE_NEGATE`  `~(EXPR)`\n+:c:macro:`GCC_JIT_UNARY_OP_LOGICAL_NEGATE`  `!(EXPR)`\n+==========================================  ============\n+\n+.. c:macro:: GCC_JIT_UNARY_OP_MINUS\n+\n+    Negate an arithmetic value; analogous to:\n+\n+    .. code-block:: c\n+\n+       -(EXPR)\n+\n+    in C.\n+\n+.. c:macro:: GCC_JIT_UNARY_OP_BITWISE_NEGATE\n+\n+    Bitwise negation of an integer value (one's complement); analogous\n+    to:\n+\n+    .. code-block:: c\n+\n+       ~(EXPR)\n+\n+    in C.\n+\n+.. c:macro:: GCC_JIT_UNARY_OP_LOGICAL_NEGATE\n+\n+    Logical negation of an arithmetic or pointer value; analogous to:\n+\n+    .. code-block:: c\n+\n+       !(EXPR)\n+\n+    in C.\n+\n+Binary Operations\n+*****************\n+\n+.. function:: gcc_jit_rvalue *gcc_jit_context_new_binary_op (gcc_jit_context *ctxt, \\\n+                                                             gcc_jit_location *loc, \\\n+                                                             enum gcc_jit_binary_op op, \\\n+                                                             gcc_jit_type *result_type, \\\n+                                                             gcc_jit_rvalue *a, gcc_jit_rvalue *b)\n+\n+   Build a binary operation out of two constituent rvalues.\n+\n+.. type:: enum gcc_jit_binary_op\n+\n+The available binary operations are:\n+\n+========================================  ============\n+Binary Operation                          C equivalent\n+========================================  ============\n+:c:macro:`GCC_JIT_BINARY_OP_PLUS`         `x + y`\n+:c:macro:`GCC_JIT_BINARY_OP_MINUS`        `x - y`\n+:c:macro:`GCC_JIT_BINARY_OP_MULT`         `x * y`\n+:c:macro:`GCC_JIT_BINARY_OP_DIVIDE`       `x / y`\n+:c:macro:`GCC_JIT_BINARY_OP_MODULO`       `x % y`\n+:c:macro:`GCC_JIT_BINARY_OP_BITWISE_AND`  `x & y`\n+:c:macro:`GCC_JIT_BINARY_OP_BITWISE_XOR`  `x ^ y`\n+:c:macro:`GCC_JIT_BINARY_OP_BITWISE_OR`   `x | y`\n+:c:macro:`GCC_JIT_BINARY_OP_LOGICAL_AND`  `x && y`\n+:c:macro:`GCC_JIT_BINARY_OP_LOGICAL_OR`   `x || y`\n+:c:macro:`GCC_JIT_BINARY_OP_LSHIFT`       `x << y`\n+:c:macro:`GCC_JIT_BINARY_OP_RSHIFT`       `x >> y`\n+========================================  ============\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_PLUS\n+\n+   Addition of arithmetic values; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) + (EXPR_B)\n+\n+   in C.\n+\n+   For pointer addition, use :c:func:`gcc_jit_context_new_array_access`.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_MINUS`\n+\n+   Subtraction of arithmetic values; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) - (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_MULT\n+\n+   Multiplication of a pair of arithmetic values; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) * (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_DIVIDE\n+\n+   Quotient of division of arithmetic values; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) / (EXPR_B)\n+\n+   in C.\n+\n+   The result type affects the kind of division: if the result type is\n+   integer-based, then the result is truncated towards zero, whereas\n+   a floating-point result type indicates floating-point division.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_MODULO\n+\n+   Remainder of division of arithmetic values; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) % (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_BITWISE_AND\n+\n+   Bitwise AND; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) & (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_BITWISE_XOR\n+\n+   Bitwise exclusive OR; analogous to:\n+\n+   .. code-block:: c\n+\n+      (EXPR_A) ^ (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_BITWISE_OR\n+\n+   Bitwise inclusive OR; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) | (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_LOGICAL_AND\n+\n+   Logical AND; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) && (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_LOGICAL_OR\n+\n+   Logical OR; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) || (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_LSHIFT\n+\n+   Left shift; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) << (EXPR_B)\n+\n+   in C.\n+\n+.. c:macro:: GCC_JIT_BINARY_OP_RSHIFT\n+\n+   Right shift; analogous to:\n+\n+   .. code-block:: c\n+\n+     (EXPR_A) >> (EXPR_B)\n+\n+   in C.\n+\n+Comparisons\n+***********\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_comparison (gcc_jit_context *ctxt,\\\n+                                              gcc_jit_location *loc,\\\n+                                              enum gcc_jit_comparison op,\\\n+                                              gcc_jit_rvalue *a, gcc_jit_rvalue *b)\n+\n+   Build a boolean rvalue out of the comparison of two other rvalues.\n+\n+.. type:: enum gcc_jit_comparison\n+\n+=======================================  ============\n+Comparison                               C equivalent\n+=======================================  ============\n+:c:macro:`GCC_JIT_COMPARISON_EQ`         `x == y`\n+:c:macro:`GCC_JIT_COMPARISON_NE`         `x != y`\n+:c:macro:`GCC_JIT_COMPARISON_LT`         `x < y`\n+:c:macro:`GCC_JIT_COMPARISON_LE`         `x <= y`\n+:c:macro:`GCC_JIT_COMPARISON_GT`         `x > y`\n+:c:macro:`GCC_JIT_COMPARISON_GE`         `x >= y`\n+=======================================  ============\n+\n+\n+Function calls\n+**************\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_call (gcc_jit_context *ctxt,\\\n+                                        gcc_jit_location *loc,\\\n+                                        gcc_jit_function *func,\\\n+                                        int numargs , gcc_jit_rvalue **args)\n+\n+   Given a function and the given table of argument rvalues, construct a\n+   call to the function, with the result as an rvalue.\n+\n+   .. note::\n+\n+      :c:func:`gcc_jit_context_new_call` merely builds a\n+      :c:type:`gcc_jit_rvalue` i.e. an expression that can be evaluated,\n+      perhaps as part of a more complicated expression.\n+      The call *won't* happen unless you add a statement to a function\n+      that evaluates the expression.\n+\n+      For example, if you want to call a function and discard the result\n+      (or to call a function with ``void`` return type), use\n+      :c:func:`gcc_jit_block_add_eval`:\n+\n+      .. code-block:: c\n+\n+         /* Add \"(void)printf (arg0, arg1);\".  */\n+         gcc_jit_block_add_eval (\n+           block, NULL,\n+           gcc_jit_context_new_call (\n+             ctxt,\n+             NULL,\n+             printf_func,\n+             2, args));\n+\n+Type-coercion\n+*************\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_cast (gcc_jit_context *ctxt,\\\n+                                        gcc_jit_location *loc,\\\n+                                        gcc_jit_rvalue *rvalue,\\\n+                                        gcc_jit_type *type)\n+\n+   Given an rvalue of T, construct another rvalue of another type.\n+\n+   Currently only a limited set of conversions are possible:\n+\n+     * int <-> float\n+     * int <-> bool\n+     * P*  <-> Q*, for pointer types P and Q\n+\n+Lvalues\n+-------\n+\n+.. type:: gcc_jit_lvalue\n+\n+An lvalue is something that can of the *left*-hand side of an assignment:\n+a storage area (such as a variable).  It is also usable as an rvalue,\n+where the rvalue is computed by reading from the storage area.\n+\n+.. function:: gcc_jit_object *\\\n+              gcc_jit_lvalue_as_object (gcc_jit_lvalue *lvalue)\n+\n+   Upcast an lvalue to be an object.\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_lvalue_as_rvalue (gcc_jit_lvalue *lvalue)\n+\n+   Upcast an lvalue to be an rvalue.\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_lvalue_get_address (gcc_jit_lvalue *lvalue,\\\n+                                          gcc_jit_location *loc)\n+\n+   Take the address of an lvalue; analogous to:\n+\n+   .. code-block:: c\n+\n+     &(EXPR)\n+\n+   in C.\n+\n+Global variables\n+****************\n+\n+.. function:: gcc_jit_lvalue *\\\n+              gcc_jit_context_new_global (gcc_jit_context *ctxt,\\\n+                                          gcc_jit_location *loc,\\\n+                                          gcc_jit_type *type,\\\n+                                          const char *name)\n+\n+   Add a new global variable of the given type and name to the context.\n+\n+\n+Working with pointers, structs and unions\n+-----------------------------------------\n+\n+.. function:: gcc_jit_lvalue *\\\n+              gcc_jit_rvalue_dereference (gcc_jit_rvalue *rvalue,\\\n+                                          gcc_jit_location *loc)\n+\n+   Given an rvalue of pointer type ``T *``, dereferencing the pointer,\n+   getting an lvalue of type ``T``.  Analogous to:\n+\n+   .. code-block:: c\n+\n+     *(EXPR)\n+\n+   in C.\n+\n+Field access is provided separately for both lvalues and rvalues.\n+\n+.. function:: gcc_jit_lvalue *\\\n+              gcc_jit_lvalue_access_field (gcc_jit_lvalue *struct_,\\\n+                                           gcc_jit_location *loc,\\\n+                                           gcc_jit_field *field)\n+\n+   Given an lvalue of struct or union type, access the given field,\n+   getting an lvalue of the field's type.  Analogous to:\n+\n+   .. code-block:: c\n+\n+      (EXPR).field = ...;\n+\n+   in C.\n+\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_rvalue_access_field (gcc_jit_rvalue *struct_,\\\n+                                           gcc_jit_location *loc,\\\n+                                           gcc_jit_field *field)\n+\n+   Given an rvalue of struct or union type, access the given field\n+   as an rvalue.  Analogous to:\n+\n+   .. code-block:: c\n+\n+      (EXPR).field\n+\n+   in C.\n+\n+.. function:: gcc_jit_lvalue *\\\n+              gcc_jit_rvalue_dereference_field (gcc_jit_rvalue *ptr,\\\n+                                                gcc_jit_location *loc,\\\n+                                                gcc_jit_field *field)\n+\n+   Given an rvalue of pointer type ``T *`` where T is of struct or union\n+   type, access the given field as an lvalue.  Analogous to:\n+\n+   .. code-block:: c\n+\n+      (EXPR)->field\n+\n+   in C, itself equivalent to ``(*EXPR).FIELD``.\n+\n+.. function:: gcc_jit_lvalue *\\\n+              gcc_jit_context_new_array_access (gcc_jit_context *ctxt,\\\n+                                                gcc_jit_location *loc,\\\n+                                                gcc_jit_rvalue *ptr,\\\n+                                                gcc_jit_rvalue *index)\n+\n+   Given an rvalue of pointer type ``T *``, get at the element `T` at\n+   the given index, using standard C array indexing rules i.e. each\n+   increment of ``index`` corresponds to ``sizeof(T)`` bytes.\n+   Analogous to:\n+\n+   .. code-block:: c\n+\n+      PTR[INDEX]\n+\n+   in C (or, indeed, to ``PTR + INDEX``)."}, {"sha": "aa0c06941822a8d36b9d1a5b49f1074346470c8f", "filename": "gcc/jit/docs/topics/functions.rst", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,311 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Creating and using functions\n+============================\n+\n+Params\n+------\n+.. type:: gcc_jit_param\n+\n+   A `gcc_jit_param` represents a parameter to a function.\n+\n+.. function:: gcc_jit_param *\\\n+              gcc_jit_context_new_param (gcc_jit_context *ctxt,\\\n+                                         gcc_jit_location *loc,\\\n+                                         gcc_jit_type *type,\\\n+                                         const char *name)\n+\n+   In preparation for creating a function, create a new parameter of the\n+   given type and name.\n+\n+Parameters are lvalues, and thus are also rvalues (and objects), so the\n+following upcasts are available:\n+\n+.. function::  gcc_jit_lvalue *\\\n+               gcc_jit_param_as_lvalue (gcc_jit_param *param)\n+\n+   Upcasting from param to lvalue.\n+\n+.. function::  gcc_jit_rvalue *\\\n+               gcc_jit_param_as_rvalue (gcc_jit_param *param)\n+\n+   Upcasting from param to rvalue.\n+\n+.. function::  gcc_jit_object *\\\n+               gcc_jit_param_as_object (gcc_jit_param *param)\n+\n+   Upcasting from param to object.\n+\n+\n+Functions\n+---------\n+\n+.. type:: gcc_jit_function\n+\n+   A `gcc_jit_function` represents a function - either one that we're\n+   creating ourselves, or one that we're referencing.\n+\n+.. function::  gcc_jit_function *\\\n+               gcc_jit_context_new_function (gcc_jit_context *ctxt,\\\n+                                             gcc_jit_location *loc,\\\n+                                             enum gcc_jit_function_kind kind,\\\n+                                             gcc_jit_type *return_type,\\\n+                                             const char *name,\\\n+                                             int num_params,\\\n+                                             gcc_jit_param **params,\\\n+                                             int is_variadic)\n+\n+   Create a gcc_jit_function with the given name and parameters.\n+\n+   .. type:: enum gcc_jit_function_kind\n+\n+   This enum controls the kind of function created, and has the following\n+   values:\n+\n+      .. macro:: GCC_JIT_FUNCTION_EXPORTED\n+\n+         Function is defined by the client code and visible\n+         by name outside of the JIT.\n+\n+      .. macro::   GCC_JIT_FUNCTION_INTERNAL\n+\n+         Function is defined by the client code, but is invisible\n+         outside of the JIT.  Analogous to a \"static\" function.\n+\n+      .. macro::   GCC_JIT_FUNCTION_IMPORTED\n+\n+         Function is not defined by the client code; we're merely\n+         referring to it.  Analogous to using an \"extern\" function from a\n+         header file.\n+\n+      .. macro::   GCC_JIT_FUNCTION_ALWAYS_INLINE\n+\n+         Function is only ever inlined into other functions, and is\n+         invisible outside of the JIT.\n+\n+         Analogous to prefixing with ``inline`` and adding\n+         ``__attribute__((always_inline))``\n+\n+         Inlining will only occur when the optimization level is\n+         above 0; when optimization is off, this is essentially the\n+         same as GCC_JIT_FUNCTION_INTERNAL.\n+\n+.. function::  gcc_jit_function *\\\n+               gcc_jit_context_get_builtin_function (gcc_jit_context *ctxt,\\\n+                                                     const char *name)\n+\n+.. function::  gcc_jit_object *\\\n+               gcc_jit_function_as_object (gcc_jit_function *func)\n+\n+    Upcasting from function to object.\n+\n+.. function::  gcc_jit_param *\\\n+               gcc_jit_function_get_param (gcc_jit_function *func, int index)\n+\n+   Get the param of the given index (0-based).\n+\n+.. function::  void \\\n+               gcc_jit_function_dump_to_dot (gcc_jit_function *func,\\\n+                                             const char *path)\n+\n+   Emit the function in graphviz format to the given path.\n+\n+.. function:: gcc_jit_lvalue *\\\n+              gcc_jit_function_new_local (gcc_jit_function *func,\\\n+                                          gcc_jit_location *loc,\\\n+                                          gcc_jit_type *type,\\\n+                                          const char *name)\n+\n+   Create a new local variable within the function, of the given type and\n+   name.\n+\n+\n+Blocks\n+------\n+.. type:: gcc_jit_block\n+\n+   A `gcc_jit_block` represents a basic block within a function  i.e. a\n+   sequence of statements with a single entry point and a single exit\n+   point.\n+\n+   The first basic block that you create within a function will\n+   be the entrypoint.\n+\n+   Each basic block that you create within a function must be\n+   terminated, either with a conditional, a jump, or a return.\n+\n+   It's legal to have multiple basic blocks that return within\n+   one function.\n+\n+.. function::  gcc_jit_block *\\\n+               gcc_jit_function_new_block (gcc_jit_function *func,\\\n+                                           const char *name)\n+\n+   Create a basic block of the given name.  The name may be NULL, but\n+   providing meaningful names is often helpful when debugging: it may\n+   show up in dumps of the internal representation, and in error\n+   messages.\n+\n+.. function::  gcc_jit_object *\\\n+               gcc_jit_block_as_object (gcc_jit_block *block)\n+\n+   Upcast from block to object.\n+\n+.. function::  gcc_jit_function *\\\n+               gcc_jit_block_get_function (gcc_jit_block *block)\n+\n+   Which function is this block within?\n+\n+\n+Statements\n+----------\n+\n+.. function:: void\\\n+              gcc_jit_block_add_eval (gcc_jit_block *block,\\\n+                                      gcc_jit_location *loc,\\\n+                                      gcc_jit_rvalue *rvalue)\n+\n+   Add evaluation of an rvalue, discarding the result\n+   (e.g. a function call that \"returns\" void).\n+\n+   This is equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     (void)expression;\n+\n+.. function:: void\\\n+              gcc_jit_block_add_assignment (gcc_jit_block *block,\\\n+                                            gcc_jit_location *loc,\\\n+                                            gcc_jit_lvalue *lvalue,\\\n+                                            gcc_jit_rvalue *rvalue)\n+\n+   Add evaluation of an rvalue, assigning the result to the given\n+   lvalue.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     lvalue = rvalue;\n+\n+.. function:: void\\\n+              gcc_jit_block_add_assignment_op (gcc_jit_block *block,\\\n+                                 gcc_jit_location *loc,\\\n+                                 gcc_jit_lvalue *lvalue,\\\n+                                 enum gcc_jit_binary_op op,\\\n+                                 gcc_jit_rvalue *rvalue)\n+\n+   Add evaluation of an rvalue, using the result to modify an\n+   lvalue.\n+\n+   This is analogous to \"+=\" and friends:\n+\n+   .. code-block:: c\n+\n+     lvalue += rvalue;\n+     lvalue *= rvalue;\n+     lvalue /= rvalue;\n+\n+   etc.  For example:\n+\n+   .. code-block:: c\n+\n+     /* \"i++\" */\n+     gcc_jit_block_add_assignment_op (\n+       loop_body, NULL,\n+       i,\n+       GCC_JIT_BINARY_OP_PLUS,\n+       gcc_jit_context_one (ctxt, int_type));\n+\n+.. function:: void\\\n+              gcc_jit_block_add_comment (gcc_jit_block *block,\\\n+                                         gcc_jit_location *loc,\\\n+                                         const char *text)\n+\n+   Add a no-op textual comment to the internal representation of the\n+   code.  It will be optimized away, but will be visible in the dumps\n+   seen via :macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE`\n+   and :macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE`,\n+   and thus may be of use when debugging how your project's internal\n+   representation gets converted to the libgccjit IR.\n+\n+.. function:: void\\\n+              gcc_jit_block_end_with_conditional (gcc_jit_block *block,\\\n+                                                  gcc_jit_location *loc,\\\n+                                                  gcc_jit_rvalue *boolval,\\\n+                                                  gcc_jit_block *on_true,\\\n+                                                  gcc_jit_block *on_false)\n+\n+   Terminate a block by adding evaluation of an rvalue, branching on the\n+   result to the appropriate successor block.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     if (boolval)\n+       goto on_true;\n+     else\n+       goto on_false;\n+\n+   block, boolval, on_true, and on_false must be non-NULL.\n+\n+.. function:: void\\\n+              gcc_jit_block_end_with_jump (gcc_jit_block *block,\\\n+                                           gcc_jit_location *loc,\\\n+                                           gcc_jit_block *target)\n+\n+\n+   Terminate a block by adding a jump to the given target block.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+      goto target;\n+\n+.. function:: void\\\n+              gcc_jit_block_end_with_return (gcc_jit_block *block,\\\n+                                             gcc_jit_location *loc,\\\n+                                             gcc_jit_rvalue *rvalue)\n+\n+\n+   Terminate a block by adding evaluation of an rvalue, returning the value.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+      return expression;\n+\n+.. function:: void\\\n+              gcc_jit_block_end_with_void_return (gcc_jit_block *block,\\\n+                                                  gcc_jit_location *loc)\n+\n+\n+   Terminate a block by adding a valueless return, for use within a function\n+   with \"void\" return type.\n+\n+   This is equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+      return;"}, {"sha": "a12913751539048abd716ffc480181a82c60000f", "filename": "gcc/jit/docs/topics/index.rst", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,30 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Topic Reference\n+===============\n+\n+.. toctree::\n+   :maxdepth: 2\n+\n+   contexts.rst\n+   objects.rst\n+   types.rst\n+   expressions.rst\n+   functions.rst\n+   locations.rst\n+   results.rst"}, {"sha": "d1db97436229a556f697640d6855254042b782e8", "filename": "gcc/jit/docs/topics/locations.rst", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Flocations.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Flocations.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Flocations.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,69 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Source Locations\n+================\n+\n+.. type:: gcc_jit_location\n+\n+   A `gcc_jit_location` encapsulates a source code location, so that\n+   you can (optionally) associate locations in your language with\n+   statements in the JIT-compiled code, allowing the debugger to\n+   single-step through your language.\n+\n+   `gcc_jit_location` instances are optional: you can always pass NULL to\n+   any API entrypoint accepting one.\n+\n+   You can construct them using :c:func:`gcc_jit_context_new_location`.\n+\n+   You need to enable :c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` on the\n+   :c:type:`gcc_jit_context` for these locations to actually be usable by\n+   the debugger:\n+\n+   .. code-block:: c\n+\n+     gcc_jit_context_set_bool_option (\n+       ctxt,\n+       GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+       1);\n+\n+.. function:: gcc_jit_location *\\\n+              gcc_jit_context_new_location (gcc_jit_context *ctxt,\\\n+                                            const char *filename,\\\n+                                            int line,\\\n+                                            int column)\n+\n+   Create a `gcc_jit_location` instance representing the given source\n+   location.\n+\n+Faking it\n+---------\n+If you don't have source code for your internal representation, but need\n+to debug, you can generate a C-like representation of the functions in\n+your context using :c:func:`gcc_jit_context_dump_to_file()`:\n+\n+.. code-block:: c\n+\n+  gcc_jit_context_dump_to_file (ctxt, \"/tmp/something.c\",\n+                                1 /* update_locations */);\n+\n+This will dump C-like code to the given path.  If the `update_locations`\n+argument is true, this will also set up `gcc_jit_location` information\n+throughout the context, pointing at the dump file as if it were a source\n+file, giving you *something* you can step through in the debugger."}, {"sha": "b05888d4ff39a78b3d7227f721a455b041ffef7f", "filename": "gcc/jit/docs/topics/objects.rst", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,86 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Objects\n+=======\n+\n+.. type:: gcc_jit_object\n+\n+Almost every entity in the API (with the exception of\n+:c:type:`gcc_jit_context *` and :c:type:`gcc_jit_result *`) is a\n+\"contextual\" object, a :c:type:`gcc_jit_object *`\n+\n+A JIT object:\n+\n+  * is associated with a :c:type:`gcc_jit_context *`.\n+\n+  * is automatically cleaned up for you when its context is released so\n+    you don't need to manually track and cleanup all objects, just the\n+    contexts.\n+\n+Although the API is C-based, there is a form of class hierarchy, which\n+looks like this::\n+\n+  +- gcc_jit_object\n+      +- gcc_jit_location\n+      +- gcc_jit_type\n+         +- gcc_jit_struct\n+      +- gcc_jit_field\n+      +- gcc_jit_function\n+      +- gcc_jit_block\n+      +- gcc_jit_rvalue\n+          +- gcc_jit_lvalue\n+             +- gcc_jit_param\n+\n+There are casting methods for upcasting from subclasses to parent classes.\n+For example, :c:func:`gcc_jit_type_as_object`:\n+\n+.. code-block:: c\n+\n+   gcc_jit_object *obj = gcc_jit_type_as_object (int_type);\n+\n+The object \"base class\" has the following operations:\n+\n+.. function:: gcc_jit_context *gcc_jit_object_get_context (gcc_jit_object *obj)\n+\n+  Which context is \"obj\" within?\n+\n+\n+.. function:: const char *gcc_jit_object_get_debug_string (gcc_jit_object *obj)\n+\n+  Generate a human-readable description for the given object.\n+\n+  For example,\n+\n+  .. code-block:: c\n+\n+     printf (\"obj: %s\\n\", gcc_jit_object_get_debug_string (obj));\n+\n+  might give this text on stdout:\n+\n+  .. code-block:: bash\n+\n+     obj: 4.0 * (float)i\n+\n+  .. note::\n+\n+     If you call this on an object, the `const char *` buffer is allocated\n+     and generated on the first call for that object, and the buffer will\n+     have the same lifetime as the object  i.e. it will exist until the\n+     object's context is released."}, {"sha": "10dc94f2cecb96afae9c5448f82ce0bb683fff8e", "filename": "gcc/jit/docs/topics/results.rst", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fresults.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Fresults.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fresults.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,48 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Compilation results\n+===================\n+\n+.. type:: gcc_jit_result\n+\n+  A `gcc_jit_result` encapsulates the result of compiling a context.\n+\n+.. function:: gcc_jit_result *\\\n+              gcc_jit_context_compile (gcc_jit_context *ctxt)\n+\n+   This calls into GCC and builds the code, returning a\n+   `gcc_jit_result *`.\n+\n+\n+.. function:: void *\\\n+              gcc_jit_result_get_code (gcc_jit_result *result,\\\n+                                       const char *funcname)\n+\n+   Locate a given function within the built machine code.\n+   This will need to be cast to a function pointer of the\n+   correct type before it can be called.\n+\n+\n+.. function:: void\\\n+              gcc_jit_result_release (gcc_jit_result *result)\n+\n+   Once we're done with the code, this unloads the built .so file.\n+   This cleans up the result; after calling this, it's no longer\n+   valid to use the result."}, {"sha": "6770eca6099b0b5535397429231fb81ef5ef5488", "filename": "gcc/jit/docs/topics/types.rst", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,217 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Types\n+=====\n+\n+.. c:type:: gcc_jit_type\n+\n+   gcc_jit_type represents a type within the library.\n+\n+.. function:: gcc_jit_object *gcc_jit_type_as_object (gcc_jit_type *type)\n+\n+   Upcast a type to an object.\n+\n+Types can be created in several ways:\n+\n+* fundamental types can be accessed using\n+  :func:`gcc_jit_context_get_type`:\n+\n+  .. code-block:: c\n+\n+      gcc_jit_type *int_type = gcc_jit_context_get_type (GCC_JIT_TYPE_INT);\n+\n+  See :func:`gcc_jit_context_get_type` for the available types.\n+\n+* derived types can be accessed by using functions such as\n+  :func:`gcc_jit_type_get_pointer` and :func:`gcc_jit_type_get_const`:\n+\n+  .. code-block:: c\n+\n+    gcc_jit_type *const_int_star = gcc_jit_type_get_pointer (gcc_jit_type_get_const (int_type));\n+    gcc_jit_type *int_const_star = gcc_jit_type_get_const (gcc_jit_type_get_pointer (int_type));\n+\n+* by creating structures (see below).\n+\n+Standard types\n+--------------\n+\n+.. function:: gcc_jit_type *gcc_jit_context_get_type (gcc_jit_context *ctxt, \\\n+                                                      enum gcc_jit_types type_)\n+\n+   Access a specific type.  The available types are:\n+\n+   =========================================  ================================\n+   `enum gcc_jit_types` value                 Meaning\n+   =========================================  ================================\n+   :c:data:`GCC_JIT_TYPE_VOID`                C's ``void`` type.\n+   :c:data:`GCC_JIT_TYPE_VOID_PTR`            C's ``void *``.\n+   :c:data:`GCC_JIT_TYPE_BOOL`                C++'s ``bool`` type; also C99's\n+                                              ``_Bool`` type, aka ``bool`` if\n+                                              using stdbool.h.\n+   :c:data:`GCC_JIT_TYPE_CHAR`                C's ``char`` (of some signedness)\n+   :c:data:`GCC_JIT_TYPE_SIGNED_CHAR`         C's ``signed char``\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_CHAR`       C's ``unsigned char``\n+   :c:data:`GCC_JIT_TYPE_SHORT`               C's ``short`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_SHORT`      C's ``unsigned short``\n+   :c:data:`GCC_JIT_TYPE_INT`                 C's ``int`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_INT`        C's ``unsigned int``\n+   :c:data:`GCC_JIT_TYPE_LONG`                C's ``long`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_LONG`       C's ``unsigned long``\n+   :c:data:`GCC_JIT_TYPE_LONG_LONG`           C99's ``long long`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_LONG_LONG`  C99's ``unsigned long long``\n+   :c:data:`GCC_JIT_TYPE_FLOAT`\n+   :c:data:`GCC_JIT_TYPE_DOUBLE`\n+   :c:data:`GCC_JIT_TYPE_LONG_DOUBLE`\n+   :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR`      C type: ``(const char *)``\n+   :c:data:`GCC_JIT_TYPE_SIZE_T`              C's ``size_t`` type\n+   :c:data:`GCC_JIT_TYPE_FILE_PTR`            C type: ``(FILE *)``\n+   =========================================  ================================\n+\n+.. function:: gcc_jit_type *\\\n+              gcc_jit_context_get_int_type (gcc_jit_context *ctxt, \\\n+                                            int num_bytes, int is_signed)\n+\n+   Access the integer type of the given size.\n+\n+\n+Pointers, `const`, and `volatile`\n+---------------------------------\n+\n+.. function::  gcc_jit_type *gcc_jit_type_get_pointer (gcc_jit_type *type)\n+\n+   Given type \"T\", get type \"T*\".\n+\n+.. function::  gcc_jit_type *gcc_jit_type_get_const (gcc_jit_type *type)\n+\n+   Given type \"T\", get type \"const T\".\n+\n+.. function::  gcc_jit_type *gcc_jit_type_get_volatile (gcc_jit_type *type)\n+\n+   Given type \"T\", get type \"volatile T\".\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_context_new_array_type (gcc_jit_context *ctxt, \\\n+                                               gcc_jit_location *loc, \\\n+                                               gcc_jit_type *element_type, \\\n+                                               int num_elements)\n+\n+   Given type \"T\", get type \"T[N]\" (for a constant N).\n+\n+\n+Structures and unions\n+---------------------\n+\n+.. c:type:: gcc_jit_struct\n+\n+A compound type analagous to a C `struct`.\n+\n+.. c:type:: gcc_jit_field\n+\n+A field within a :c:type:`gcc_jit_struct`.\n+\n+You can model C `struct` types by creating :c:type:`gcc_jit_struct *` and\n+:c:type:`gcc_jit_field` instances, in either order:\n+\n+* by creating the fields, then the structure.  For example, to model:\n+\n+  .. code-block:: c\n+\n+    struct coord {double x; double y; };\n+\n+  you could call:\n+\n+  .. code-block:: c\n+\n+    gcc_jit_field *field_x =\n+      gcc_jit_context_new_field (ctxt, NULL, double_type, \"x\");\n+    gcc_jit_field *field_y =\n+      gcc_jit_context_new_field (ctxt, NULL, double_type, \"y\");\n+    gcc_jit_field *fields[2] = {field_x, field_y};\n+    gcc_jit_struct *coord =\n+      gcc_jit_context_new_struct_type (ctxt, NULL, \"coord\", 2, fields);\n+\n+* by creating the structure, then populating it with fields, typically\n+  to allow modelling self-referential structs such as:\n+\n+  .. code-block:: c\n+\n+    struct node { int m_hash; struct node *m_next; };\n+\n+  like this:\n+\n+  .. code-block:: c\n+\n+    gcc_jit_type *node =\n+      gcc_jit_context_new_opaque_struct (ctxt, NULL, \"node\");\n+    gcc_jit_type *node_ptr =\n+      gcc_jit_type_get_pointer (node);\n+    gcc_jit_field *field_hash =\n+      gcc_jit_context_new_field (ctxt, NULL, int_type, \"m_hash\");\n+    gcc_jit_field *field_next =\n+      gcc_jit_context_new_field (ctxt, NULL, node_ptr, \"m_next\");\n+    gcc_jit_field *fields[2] = {field_hash, field_next};\n+    gcc_jit_struct_set_fields (node, NULL, 2, fields);\n+\n+.. function:: gcc_jit_field *\\\n+              gcc_jit_context_new_field (gcc_jit_context *ctxt,\\\n+                                         gcc_jit_location *loc,\\\n+                                         gcc_jit_type *type,\\\n+                                         const char *name)\n+\n+   Construct a new field, with the given type and name.\n+\n+.. function:: gcc_jit_object *\\\n+              gcc_jit_field_as_object (gcc_jit_field *field)\n+\n+   Upcast from field to object.\n+\n+.. function:: gcc_jit_struct *\\\n+   gcc_jit_context_new_struct_type (gcc_jit_context *ctxt,\\\n+                                    gcc_jit_location *loc,\\\n+                                    const char *name,\\\n+                                    int num_fields,\\\n+                                    gcc_jit_field **fields)\n+\n+     Construct a new struct type, with the given name and fields.\n+\n+.. function:: gcc_jit_struct *\\\n+              gcc_jit_context_new_opaque_struct (gcc_jit_context *ctxt,\\\n+                                                 gcc_jit_location *loc,\\\n+                                                 const char *name)\n+\n+     Construct a new struct type, with the given name, but without\n+     specifying the fields.   The fields can be omitted (in which case the\n+     size of the struct is not known), or later specified using\n+     :c:func:`gcc_jit_struct_set_fields`.\n+\n+.. function:: gcc_jit_type *\\\n+              gcc_jit_struct_as_type (gcc_jit_struct *struct_type)\n+\n+   Upcast from struct to type.\n+\n+.. function:: void\\\n+              gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\\\n+                                         gcc_jit_location *loc,\\\n+                                         int num_fields,\\\n+                                         gcc_jit_field **fields)\n+\n+   Populate the fields of a formerly-opaque struct type.\n+\n+   This can only be called once on a given struct type."}, {"sha": "7e3abda1f6fb458bbaaf3eee8fe93ae23f3eb9d6", "filename": "gcc/jit/dummy-frontend.c", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdummy-frontend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fdummy-frontend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdummy-frontend.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,252 @@\n+/* jit.c -- Dummy \"frontend\" for use during JIT-compilation.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"signop.h\"\n+#include \"tree-core.h\"\n+#include \"stor-layout.h\"\n+#include \"tree.h\"\n+#include \"debug.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"hash-map.h\"\n+#include \"is-a.h\"\n+#include \"plugin-api.h\"\n+#include \"vec.h\"\n+#include \"hashtab.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"function.h\"\n+#include \"ipa-ref.h\"\n+#include \"dumpfile.h\"\n+#include \"cgraph.h\"\n+\n+#include \"jit-common.h\"\n+#include \"jit-playback.h\"\n+\n+#include <mpfr.h>\n+\n+/* Language-dependent contents of a type.  */\n+\n+struct GTY(()) lang_type\n+{\n+  char dummy;\n+};\n+\n+/* Language-dependent contents of a decl.  */\n+\n+struct GTY((variable_size)) lang_decl\n+{\n+  char dummy;\n+};\n+\n+/* Language-dependent contents of an identifier.  This must include a\n+   tree_identifier.  */\n+\n+struct GTY(()) lang_identifier\n+{\n+  struct tree_identifier common;\n+};\n+\n+/* The resulting tree type.  */\n+\n+union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+\t   chain_next (\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n+lang_tree_node\n+{\n+  union tree_node GTY((tag (\"0\"),\n+\t\t       desc (\"tree_node_structure (&%h)\"))) generic;\n+  struct lang_identifier GTY((tag (\"1\"))) identifier;\n+};\n+\n+/* We don't use language_function.  */\n+\n+struct GTY(()) language_function\n+{\n+  int dummy;\n+};\n+\n+/* GC-marking callback for use from jit_root_tab.\n+\n+   If there's an active playback context, call its marking method\n+   so that it can mark any pointers it references.  */\n+\n+static void my_ggc_walker (void *)\n+{\n+  if (gcc::jit::active_playback_ctxt)\n+    gcc::jit::active_playback_ctxt->gt_ggc_mx ();\n+}\n+\n+const char *dummy;\n+\n+struct ggc_root_tab jit_root_tab[] =\n+  {\n+    {\n+      &dummy, 1, 0, my_ggc_walker, NULL\n+    },\n+    LAST_GGC_ROOT_TAB\n+  };\n+\n+/* Language hooks.  */\n+\n+static bool\n+jit_langhook_init (void)\n+{\n+  static bool registered_root_tab = false;\n+  if (!registered_root_tab)\n+    {\n+      ggc_register_root_tab (jit_root_tab);\n+      registered_root_tab = true;\n+    }\n+\n+  build_common_tree_nodes (false, false);\n+\n+  /* I don't know why this has to be done explicitly.  */\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n+\n+  build_common_builtin_nodes ();\n+\n+  /* The default precision for floating point numbers.  This is used\n+     for floating point constants with abstract type.  This may\n+     eventually be controllable by a command line option.  */\n+  mpfr_set_default_prec (256);\n+\n+  return true;\n+}\n+\n+static void\n+jit_langhook_parse_file (void)\n+{\n+  /* Replay the activity by the client, recorded on the context.  */\n+  gcc_assert (gcc::jit::active_playback_ctxt);\n+  gcc::jit::active_playback_ctxt->replay ();\n+}\n+\n+static tree\n+jit_langhook_type_for_mode (enum machine_mode mode, int unsignedp)\n+{\n+  if (mode == TYPE_MODE (float_type_node))\n+    return float_type_node;\n+\n+  if (mode == TYPE_MODE (double_type_node))\n+    return double_type_node;\n+\n+  if (mode == TYPE_MODE (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      if (mode == TYPE_MODE (complex_float_type_node))\n+\treturn complex_float_type_node;\n+      if (mode == TYPE_MODE (complex_double_type_node))\n+\treturn complex_double_type_node;\n+      if (mode == TYPE_MODE (complex_long_double_type_node))\n+\treturn complex_long_double_type_node;\n+      if (mode == TYPE_MODE (complex_integer_type_node) && !unsignedp)\n+\treturn complex_integer_type_node;\n+    }\n+\n+  /* gcc_unreachable */\n+  return NULL;\n+}\n+\n+static tree\n+jit_langhook_type_for_size (unsigned int bits ATTRIBUTE_UNUSED,\n+\t\t\t    int unsignedp ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Record a builtin function.  We just ignore builtin functions.  */\n+\n+static tree\n+jit_langhook_builtin_function (tree decl)\n+{\n+  return decl;\n+}\n+\n+static bool\n+jit_langhook_global_bindings_p (void)\n+{\n+  gcc_unreachable ();\n+  return true;\n+}\n+\n+static tree\n+jit_langhook_pushdecl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+static tree\n+jit_langhook_getdecls (void)\n+{\n+  return NULL;\n+}\n+\n+static void\n+jit_langhook_write_globals (void)\n+{\n+  /* This is the hook that runs the middle and backends: */\n+  symtab->finalize_compilation_unit ();\n+}\n+\n+#undef LANG_HOOKS_NAME\n+#define LANG_HOOKS_NAME\t\t\"libgccjit\"\n+\n+#undef LANG_HOOKS_INIT\n+#define LANG_HOOKS_INIT\t\tjit_langhook_init\n+\n+#undef LANG_HOOKS_PARSE_FILE\n+#define LANG_HOOKS_PARSE_FILE\t\tjit_langhook_parse_file\n+\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#define LANG_HOOKS_TYPE_FOR_MODE\tjit_langhook_type_for_mode\n+\n+#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#define LANG_HOOKS_TYPE_FOR_SIZE\tjit_langhook_type_for_size\n+\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n+#define LANG_HOOKS_BUILTIN_FUNCTION\tjit_langhook_builtin_function\n+\n+#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n+#define LANG_HOOKS_GLOBAL_BINDINGS_P\tjit_langhook_global_bindings_p\n+\n+#undef LANG_HOOKS_PUSHDECL\n+#define LANG_HOOKS_PUSHDECL\t\tjit_langhook_pushdecl\n+\n+#undef LANG_HOOKS_GETDECLS\n+#define LANG_HOOKS_GETDECLS\t\tjit_langhook_getdecls\n+\n+#undef LANG_HOOKS_WRITE_GLOBALS\n+#define LANG_HOOKS_WRITE_GLOBALS\tjit_langhook_write_globals\n+\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+#include \"gt-jit-dummy-frontend.h\"\n+#include \"gtype-jit.h\""}, {"sha": "07902e86e76f9a145d4fefcecfb69e970dd118ec", "filename": "gcc/jit/jit-builtins.c", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,424 @@\n+/* jit-builtins.c -- Handling of builtin functions during JIT-compilation.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+\n+#include \"jit-common.h\"\n+#include \"jit-builtins.h\"\n+#include \"jit-recording.h\"\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+namespace recording {\n+\n+const char *const prefix = \"__builtin_\";\n+const size_t prefix_len = strlen (prefix);\n+\n+/* Create \"builtin_data\", a const table of the data within builtins.def.  */\n+struct builtin_data\n+{\n+  const char *name;\n+  enum jit_builtin_type type;\n+  bool both_p;\n+  bool fallback_p;\n+\n+  const char *get_asm_name () const\n+  {\n+    if (both_p && fallback_p)\n+      return name + prefix_len;\n+    else\n+      return name;\n+  }\n+};\n+\n+#define DEF_BUILTIN(X, NAME, C, TYPE, LT, BOTH_P, FALLBACK_P, NA, AT, IM, COND)\\\n+  {NAME, TYPE, BOTH_P, FALLBACK_P},\n+static const struct builtin_data builtin_data[] =\n+{\n+#include \"builtins.def\"\n+};\n+#undef DEF_BUILTIN\n+\n+/* Helper function for find_builtin_by_name.  */\n+\n+static bool\n+matches_builtin (const char *in_name,\n+\t\t const struct builtin_data& bd)\n+{\n+  const bool debug = 0;\n+  gcc_assert (bd.name);\n+\n+  if (debug)\n+    fprintf (stderr, \"seen builtin: %s\\n\", bd.name);\n+\n+  if (0 == strcmp (bd.name, in_name))\n+    {\n+      return true;\n+    }\n+\n+  if (bd.both_p)\n+    {\n+      /* Then the macros in builtins.def gave a \"__builtin_\"\n+\t prefix to bd.name, but we should also recognize the form\n+\t without the prefix.  */\n+      gcc_assert (0 == strncmp (bd.name, prefix, prefix_len));\n+      if (debug)\n+\tfprintf (stderr, \"testing without prefix as: %s\\n\",\n+\t\t bd.name + prefix_len);\n+      if (0 == strcmp (bd.name + prefix_len, in_name))\n+\t{\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Locate the built-in function that matches name IN_NAME,\n+   writing the result to OUT_ID and returning true if found,\n+   or returning false if not found.  */\n+\n+static bool\n+find_builtin_by_name (const char *in_name,\n+\t\t      enum built_in_function *out_id)\n+{\n+  /* Locate builtin.  This currently works by performing repeated\n+     strcmp against every possible candidate, which is likely to\n+     inefficient.\n+\n+     We start at index 1 to skip the initial entry (BUILT_IN_NONE), which\n+     has a NULL name.  */\n+  for (unsigned int i = 1;\n+       i < sizeof (builtin_data) / sizeof (builtin_data[0]);\n+       i++)\n+    {\n+      const struct builtin_data& bd = builtin_data[i];\n+      if (matches_builtin (in_name, bd))\n+\t{\n+\t  /* Found a match.  */\n+\t  *out_id = static_cast<enum built_in_function> (i);\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Not found.  */\n+  return false;\n+}\n+\n+// class builtins_manager\n+\n+/* Constructor for gcc::jit::recording::builtins_manager.  */\n+\n+builtins_manager::builtins_manager (context *ctxt)\n+  : m_ctxt (ctxt)\n+{\n+  memset (m_types, 0, sizeof (m_types));\n+  memset (m_builtin_functions, 0, sizeof (m_builtin_functions));\n+}\n+\n+/* Locate a builtin function by name.\n+   Create a recording::function of the appropriate type, reusing them\n+   if they've already been seen.  */\n+\n+function *\n+builtins_manager::get_builtin_function (const char *name)\n+{\n+  enum built_in_function builtin_id;\n+  if (!find_builtin_by_name (name, &builtin_id))\n+    {\n+      m_ctxt->add_error (NULL, \"builtin \\\"%s\\\" not found\", name);\n+      return NULL;\n+    }\n+\n+  gcc_assert (builtin_id >= 0);\n+  gcc_assert (builtin_id < END_BUILTINS);\n+\n+  /* Lazily build the functions, caching them so that repeated calls for\n+     the same id on a context give back the same object.  */\n+  if (!m_builtin_functions[builtin_id])\n+    {\n+      m_builtin_functions[builtin_id] = make_builtin_function (builtin_id);\n+      m_ctxt->record (m_builtin_functions[builtin_id]);\n+    }\n+\n+  return m_builtin_functions[builtin_id];\n+}\n+\n+/* Create the recording::function for a given builtin function, by ID.  */\n+\n+function *\n+builtins_manager::make_builtin_function (enum built_in_function builtin_id)\n+{\n+  const struct builtin_data& bd = builtin_data[builtin_id];\n+  enum jit_builtin_type type_id = bd.type;\n+  function_type *func_type = get_type (type_id)->as_a_function_type ();\n+  if (!func_type)\n+    return NULL;\n+\n+  vec<type *> param_types = func_type->get_param_types ();\n+  recording::param **params = new recording::param *[param_types.length ()];\n+\n+  int i;\n+  type *param_type;\n+  FOR_EACH_VEC_ELT (param_types, i, param_type)\n+    {\n+      char buf[16];\n+      snprintf (buf, 16, \"arg%d\", i);\n+      params[i] = m_ctxt->new_param (NULL,\n+\t\t\t\t     param_type,\n+\t\t\t\t     buf);\n+    }\n+  const char *asm_name = bd.get_asm_name ();\n+  function *result =\n+    new function (m_ctxt,\n+\t\t  NULL,\n+\t\t  GCC_JIT_FUNCTION_IMPORTED, // FIXME\n+\t\t  func_type->get_return_type (),\n+\t\t  m_ctxt->new_string (asm_name),\n+\t\t  param_types.length (),\n+\t\t  params,\n+\t\t  func_type->is_variadic (),\n+\t\t  builtin_id);\n+  delete[] params;\n+  return result;\n+}\n+\n+/* Get the recording::type for a given type of builtin function,\n+   by ID, creating it if it doesn't already exist.  */\n+\n+type *\n+builtins_manager::get_type (enum jit_builtin_type type_id)\n+{\n+  if (!m_types[type_id])\n+    m_types[type_id] = make_type (type_id);\n+  return m_types[type_id];\n+}\n+\n+/* Create the recording::type for a given type of builtin function.  */\n+\n+type *\n+builtins_manager::make_type (enum jit_builtin_type type_id)\n+{\n+  /* Use builtin-types.def to construct a switch statement, with each\n+     case deferring to one of the methods below:\n+       - DEF_PRIMITIVE_TYPE is handled as a call to make_primitive_type.\n+       - the various DEF_FUNCTION_TYPE_n are handled by variadic calls\n+\t to make_fn_type.\n+       - similarly for DEF_FUNCTION_TYPE_VAR_n, but setting the\n+\t\"is_variadic\" argument.\n+       - DEF_POINTER_TYPE is handled by make_ptr_type.\n+     That should handle everything, but just in case we also suppy a\n+     gcc_unreachable default clause.  */\n+  switch (type_id)\n+    {\n+#define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n+      case ENUM: return make_primitive_type (ENUM);\n+#define DEF_FUNCTION_TYPE_0(ENUM, RETURN) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 0);\n+#define DEF_FUNCTION_TYPE_1(ENUM, RETURN, ARG1) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 1, ARG1);\n+#define DEF_FUNCTION_TYPE_2(ENUM, RETURN, ARG1, ARG2) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 2, ARG1, ARG2);\n+#define DEF_FUNCTION_TYPE_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 3, ARG1, ARG2, ARG3);\n+#define DEF_FUNCTION_TYPE_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 4, ARG1, ARG2, ARG3, ARG4);\n+#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\t\\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6)\t\t\t\t\t\\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);\n+#define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, \\\n+\t\t\t\t      ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 1, 0);\n+#define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 1, 1, ARG1);\n+#define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 1, 2, ARG1, ARG2);\n+#define DEF_FUNCTION_TYPE_VAR_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 1, 3, ARG1, ARG2, ARG3);\n+#define DEF_FUNCTION_TYPE_VAR_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n+#define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n+      case ENUM: return make_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_POINTER_TYPE(ENUM, TYPE) \\\n+      case ENUM: return make_ptr_type (ENUM, TYPE);\n+\n+#include \"builtin-types.def\"\n+\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_POINTER_TYPE\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Create the recording::type for a given primitive type within the\n+   builtin system.\n+\n+   Only some types are currently supported.  */\n+\n+type*\n+builtins_manager::make_primitive_type (enum jit_builtin_type type_id)\n+{\n+  switch (type_id)\n+    {\n+    default:\n+      // only some of these types are implemented so far:\n+      m_ctxt->add_error (NULL,\n+\t\t\t \"unimplemented primitive type for builtin: %d\", type_id);\n+      return NULL;\n+\n+    case BT_VOID: return m_ctxt->get_type (GCC_JIT_TYPE_VOID);\n+    case BT_BOOL: return m_ctxt->get_type (GCC_JIT_TYPE_BOOL);\n+    case BT_INT: return m_ctxt->get_type (GCC_JIT_TYPE_INT);\n+    case BT_UINT: return m_ctxt->get_type (GCC_JIT_TYPE_UNSIGNED_INT);\n+    case BT_LONG: return m_ctxt->get_type (GCC_JIT_TYPE_LONG);\n+    case BT_ULONG: return m_ctxt->get_type (GCC_JIT_TYPE_UNSIGNED_LONG);\n+    case BT_LONGLONG: return m_ctxt->get_type (GCC_JIT_TYPE_LONG_LONG);\n+    case BT_ULONGLONG:\n+      return m_ctxt->get_type (GCC_JIT_TYPE_UNSIGNED_LONG_LONG);\n+    // case BT_INT128:\n+    // case BT_UINT128:\n+    // case BT_INTMAX:\n+    // case BT_UINTMAX:\n+    case BT_UINT16: return m_ctxt->get_int_type (2, false);\n+    case BT_UINT32: return m_ctxt->get_int_type (4, false);\n+    case BT_UINT64: return m_ctxt->get_int_type (8, false);\n+    // case BT_WORD:\n+    // case BT_UNWINDWORD:\n+    case BT_FLOAT: return m_ctxt->get_type (GCC_JIT_TYPE_FLOAT);\n+    case BT_DOUBLE: return m_ctxt->get_type (GCC_JIT_TYPE_DOUBLE);\n+    case BT_LONGDOUBLE: return m_ctxt->get_type (GCC_JIT_TYPE_LONG_DOUBLE);\n+    // case BT_COMPLEX_FLOAT:\n+    // case BT_COMPLEX_DOUBLE:\n+    // case BT_COMPLEX_LONGDOUBLE:\n+    case BT_PTR: return m_ctxt->get_type (GCC_JIT_TYPE_VOID_PTR);\n+    case BT_FILEPTR: return m_ctxt->get_type (GCC_JIT_TYPE_FILE_PTR);\n+    // case BT_CONST:\n+    // case BT_VOLATILE_PTR:\n+    // case BT_CONST_VOLATILE_PTR:\n+    // case BT_PTRMODE:\n+    // case BT_INT_PTR:\n+    // case BT_FLOAT_PTR:\n+    // case BT_DOUBLE_PTR:\n+    // case BT_CONST_DOUBLE_PTR:\n+    // case BT_LONGDOUBLE_PTR:\n+    // case BT_PID:\n+    // case BT_SIZE:\n+    // case BT_SSIZE:\n+    // case BT_WINT:\n+    // case BT_STRING:\n+    case BT_CONST_STRING: return m_ctxt->get_type (GCC_JIT_TYPE_CONST_CHAR_PTR);\n+    // case BT_DFLOAT32:\n+    // case BT_DFLOAT64:\n+    // case BT_DFLOAT128:\n+    // case BT_DFLOAT32_PTR:\n+    // case BT_DFLOAT64_PTR:\n+    // case BT_DFLOAT128_PTR:\n+    // case BT_VALIST_REF:\n+    // case BT_VALIST_ARG:\n+    // case BT_I1:\n+    // case BT_I2:\n+    // case BT_I4:\n+    // case BT_I8:\n+    // case BT_I16:\n+    }\n+}\n+\n+/* Create the recording::function_type for a given function type\n+   signature.  */\n+\n+function_type *\n+builtins_manager::make_fn_type (enum jit_builtin_type,\n+\t\t\t\tenum jit_builtin_type return_type_id,\n+\t\t\t\tbool is_variadic,\n+\t\t\t\tint num_args, ...)\n+{\n+  va_list list;\n+  int i;\n+  type **param_types = new type *[num_args];\n+  type *return_type = NULL;\n+  function_type *result = NULL;\n+\n+  va_start (list, num_args);\n+  for (i = 0; i < num_args; ++i)\n+    {\n+      enum jit_builtin_type arg_type_id =\n+\t(enum jit_builtin_type) va_arg (list, int);\n+      param_types[i] = get_type (arg_type_id);\n+      if (!param_types[i])\n+\tgoto error;\n+    }\n+  va_end (list);\n+\n+  return_type = get_type (return_type_id);\n+  if (!return_type)\n+    goto error;\n+\n+  result = new function_type (m_ctxt,\n+\t\t\t      return_type,\n+\t\t\t      num_args,\n+\t\t\t      param_types,\n+\t\t\t      is_variadic);\n+\n+ error:\n+  delete[] param_types;\n+  return result;\n+}\n+\n+/* Handler for DEF_POINTER_TYPE within builtins_manager::make_type.  */\n+\n+type *\n+builtins_manager::make_ptr_type (enum jit_builtin_type,\n+\t\t\t\t enum jit_builtin_type other_type_id)\n+{\n+  type *base_type = get_type (other_type_id);\n+  return base_type->get_pointer ();\n+}\n+\n+} // namespace recording\n+} // namespace jit\n+} // namespace gcc"}, {"sha": "7c46bfdbe468c68b7178fa435b4c9d60beb56268", "filename": "gcc/jit/jit-builtins.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,114 @@\n+/* jit-builtins.h -- Handling of builtin functions during JIT-compilation.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef JIT_BUILTINS_H\n+#define JIT_BUILTINS_H\n+\n+#include \"jit-common.h\"\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+namespace recording {\n+\n+/* Create an enum of the builtin types.  */\n+\n+enum jit_builtin_type\n+{\n+#define DEF_PRIMITIVE_TYPE(NAME, VALUE) NAME,\n+#define DEF_FUNCTION_TYPE_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n+#define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n+#define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG6) \\\n+  NAME,\n+#define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n+#include \"builtin-types.def\"\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_POINTER_TYPE\n+  BT_LAST\n+}; /* enum jit_builtin_type */\n+\n+/***********************************************************************/\n+\n+class builtins_manager\n+{\n+public:\n+  builtins_manager (context *ctxt);\n+\n+  function *\n+  get_builtin_function (const char *name);\n+\n+private:\n+  function *make_builtin_function (enum built_in_function builtin_id);\n+\n+  type *get_type (enum jit_builtin_type type_id);\n+\n+  type *make_type (enum jit_builtin_type type_id);\n+\n+  type*\n+  make_primitive_type (enum jit_builtin_type type_id);\n+\n+  function_type*\n+  make_fn_type (enum jit_builtin_type type_id,\n+\t\tenum jit_builtin_type return_type_id,\n+\t\tbool is_variadic,\n+\t\tint num_args, ...);\n+\n+  type*\n+  make_ptr_type (enum jit_builtin_type type_id,\n+\t\t enum jit_builtin_type other_type_id);\n+\n+private:\n+  context *m_ctxt;\n+  type *m_types[BT_LAST];\n+  function *m_builtin_functions[END_BUILTINS];\n+};\n+\n+} // namespace recording\n+} // namespace jit\n+} // namespace gcc\n+\n+#endif /* JIT_BUILTINS_H */"}, {"sha": "58e4a8cf4e00552066b1d1ac71856c3aaf19ec90", "filename": "gcc/jit/jit-common.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,182 @@\n+/* Core of implementation of libgccjit.so\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef JIT_COMMON_H\n+#define JIT_COMMON_H\n+\n+#include \"libgccjit.h\"\n+\n+#include \"tree.h\"\n+#include \"tree-iterator.h\"\n+\n+#ifdef GCC_VERSION\n+#if GCC_VERSION >= 4001\n+#define GNU_PRINTF(M, N) __attribute__ ((format (gnu_printf, (M), (N))))\n+#else\n+#define GNU_PRINTF(M, N)\n+#endif\n+#endif\n+\n+const int NUM_GCC_JIT_TYPES = GCC_JIT_TYPE_FILE_PTR + 1;\n+\n+/* This comment is included by the docs.\n+\n+   In order to allow jit objects to be usable outside of a compile\n+   whilst working with the existing structure of GCC's code the\n+   C API is implemented in terms of a gcc::jit::recording::context,\n+   which records the calls made to it.\n+\n+   When a gcc_jit_context is compiled, the recording context creates a\n+   playback context.  The playback context invokes the bulk of the GCC\n+   code, and within the \"frontend\" parsing hook, plays back the recorded\n+   API calls, creating GCC tree objects.\n+\n+   So there are two parallel families of classes: those relating to\n+   recording, and those relating to playback:\n+\n+   * Visibility: recording objects are exposed back to client code,\n+     whereas playback objects are internal to the library.\n+\n+   * Lifetime: recording objects have a lifetime equal to that of the\n+     recording context that created them, whereas playback objects only\n+     exist within the frontend hook.\n+\n+   * Memory allocation: recording objects are allocated by the recording\n+     context, and automatically freed by it when the context is released,\n+     whereas playback objects are allocated within the GC heap, and\n+     garbage-collected; they can own GC-references.\n+\n+   * Integration with rest of GCC: recording objects are unrelated to the\n+     rest of GCC, whereas playback objects are wrappers around \"tree\"\n+     instances.  Hence you can't ask a recording rvalue or lvalue what its\n+     type is, whereas you can for a playback rvalue of lvalue (since it\n+     can work with the underlying GCC tree nodes).\n+\n+   * Instancing: There can be multiple recording contexts \"alive\" at once\n+     (albeit it only one compiling at once), whereas there can only be one\n+     playback context alive at one time (since it interacts with the GC).\n+\n+   Ultimately if GCC could support multiple GC heaps and contexts, and\n+   finer-grained initialization, then this recording vs playback\n+   distinction could be eliminated.\n+\n+   During a playback, we associate objects from the recording with\n+   their counterparts during this playback.  For simplicity, we store this\n+   within the recording objects, as ``void *m_playback_obj``, casting it to\n+   the appropriate playback object subclass.  For these casts to make\n+   sense, the two class hierarchies need to have the same structure.\n+\n+   Note that the playback objects that ``m_playback_obj`` points to are\n+   GC-allocated, but the recording objects don't own references:\n+   these associations only exist within a part of the code where\n+   the GC doesn't collect, and are set back to NULL before the GC can\n+   run.\n+\n+   End of comment for inclusion in the docs.  */\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+class result;\n+class dump;\n+\n+namespace recording {\n+\n+  /* Recording types.  */\n+\n+  /* Indentation indicates inheritance: */\n+  class context;\n+  class builtins_manager; // declared within jit-builtins.h\n+  class memento;\n+    class string;\n+    class location;\n+    class type;\n+      class function_type;\n+      class compound_type;\n+        class struct_;\n+\tclass union_;\n+    class field;\n+    class fields;\n+    class function;\n+    class block;\n+    class rvalue;\n+      class lvalue;\n+        class local;\n+\tclass global;\n+        class param;\n+    class statement;\n+\n+  /* End of recording types. */\n+}\n+\n+namespace playback {\n+  /* Playback types.  */\n+\n+  /* Indentation indicates inheritance: */\n+  class context;\n+  class wrapper;\n+    class type;\n+      class compound_type;\n+    class field;\n+    class function;\n+    class block;\n+    class rvalue;\n+      class lvalue;\n+        class param;\n+    class source_file;\n+    class source_line;\n+    class location;\n+\n+  /* End of playback types. */\n+}\n+\n+typedef playback::context replayer;\n+\n+class dump\n+{\n+public:\n+  dump (recording::context &ctxt,\n+\tconst char *filename,\n+\tbool update_locations);\n+  ~dump ();\n+\n+  void write (const char *fmt, ...)\n+    GNU_PRINTF(2, 3);\n+\n+  bool update_locations () const { return m_update_locations; }\n+\n+  recording::location *\n+  make_location () const;\n+\n+private:\n+  recording::context &m_ctxt;\n+  const char *m_filename;\n+  bool m_update_locations;\n+  int m_line;\n+  int m_column;\n+  FILE *m_file;\n+};\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc\n+\n+#endif /* JIT_COMMON_H */"}, {"sha": "285a3ef9d60006d287f136b21ecea353ddb77e07", "filename": "gcc/jit/jit-playback.c", "status": "added", "additions": 2100, "deletions": 0, "changes": 2100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,2100 @@\n+/* Internals of libgccjit: classes for playing back recorded API calls.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"hash-map.h\"\n+#include \"is-a.h\"\n+#include \"plugin-api.h\"\n+#include \"vec.h\"\n+#include \"hashtab.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"function.h\"\n+#include \"ipa-ref.h\"\n+#include \"dumpfile.h\"\n+#include \"cgraph.h\"\n+#include \"toplev.h\"\n+#include \"timevar.h\"\n+#include \"tree-cfg.h\"\n+#include \"target.h\"\n+#include \"convert.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"print-tree.h\"\n+#include \"gimplify.h\"\n+#include \"gcc-driver-name.h\"\n+\n+#include \"jit-common.h\"\n+#include \"jit-playback.h\"\n+\n+\n+/* gcc::jit::playback::context::build_cast uses the convert.h API,\n+   which in turn requires the frontend to provide a \"convert\"\n+   function, apparently as a fallback.\n+\n+   Hence we provide this dummy one, with the requirement that any casts\n+   are handled before reaching this.  */\n+extern tree convert (tree type, tree expr);\n+\n+tree\n+convert (tree dst_type, tree expr)\n+{\n+  gcc_assert (gcc::jit::active_playback_ctxt);\n+  gcc::jit::active_playback_ctxt->add_error (NULL, \"unhandled conversion\");\n+  fprintf (stderr, \"input expression:\\n\");\n+  debug_tree (expr);\n+  fprintf (stderr, \"requested type:\\n\");\n+  debug_tree (dst_type);\n+  return error_mark_node;\n+}\n+\n+namespace gcc {\n+namespace jit {\n+\n+/**********************************************************************\n+ Playback.\n+ **********************************************************************/\n+\n+/* The constructor for gcc::jit::playback::context.  */\n+\n+playback::context::context (recording::context *ctxt)\n+  : m_recording_ctxt (ctxt),\n+    m_char_array_type_node (NULL),\n+    m_const_char_ptr (NULL)\n+{\n+  m_functions.create (0);\n+  m_source_files.create (0);\n+  m_cached_locations.create (0);\n+}\n+\n+/* The destructor for gcc::jit::playback::context.  */\n+\n+playback::context::~context ()\n+{\n+  if (get_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES))\n+    fprintf (stderr, \"intermediate files written to %s\\n\", m_path_tempdir);\n+  else\n+    {\n+      /* Clean up .s/.so and tempdir. */\n+      if (m_path_s_file)\n+        unlink (m_path_s_file);\n+      if (m_path_so_file)\n+        unlink (m_path_so_file);\n+      if (m_path_tempdir)\n+        rmdir (m_path_tempdir);\n+    }\n+\n+  free (m_path_template);\n+  /* m_path_tempdir aliases m_path_template, or is NULL, so don't\n+     attempt to free it .  */\n+  free (m_path_c_file);\n+  free (m_path_s_file);\n+  free (m_path_so_file);\n+  m_functions.release ();\n+}\n+\n+/* A playback::context can reference GC-managed pointers.  Mark them\n+   (\"by hand\", rather than by gengtype).\n+\n+   This is called on the active playback context (if any) by the\n+   my_ggc_walker hook in the jit_root_table in dummy-frontend.c.  */\n+\n+void\n+playback::context::\n+gt_ggc_mx ()\n+{\n+  int i;\n+  function *func;\n+  FOR_EACH_VEC_ELT (m_functions, i, func)\n+    {\n+      if (ggc_test_and_set_mark (func))\n+\tfunc->gt_ggc_mx ();\n+    }\n+}\n+\n+/* Given an enum gcc_jit_types value, get a \"tree\" type.  */\n+\n+static tree\n+get_tree_node_for_type (enum gcc_jit_types type_)\n+{\n+  switch (type_)\n+    {\n+    case GCC_JIT_TYPE_VOID:\n+      return void_type_node;\n+\n+    case GCC_JIT_TYPE_VOID_PTR:\n+      return ptr_type_node;\n+\n+    case GCC_JIT_TYPE_BOOL:\n+      return boolean_type_node;\n+\n+    case GCC_JIT_TYPE_CHAR:\n+      return char_type_node;\n+    case GCC_JIT_TYPE_SIGNED_CHAR:\n+      return signed_char_type_node;\n+    case GCC_JIT_TYPE_UNSIGNED_CHAR:\n+      return unsigned_char_type_node;\n+\n+    case GCC_JIT_TYPE_SHORT:\n+      return short_integer_type_node;\n+    case GCC_JIT_TYPE_UNSIGNED_SHORT:\n+      return short_unsigned_type_node;\n+\n+    case GCC_JIT_TYPE_CONST_CHAR_PTR:\n+      {\n+\ttree const_char = build_qualified_type (char_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+\treturn build_pointer_type (const_char);\n+      }\n+\n+    case GCC_JIT_TYPE_INT:\n+      return integer_type_node;\n+    case GCC_JIT_TYPE_UNSIGNED_INT:\n+      return unsigned_type_node;\n+\n+    case GCC_JIT_TYPE_LONG:\n+      return long_integer_type_node;\n+    case GCC_JIT_TYPE_UNSIGNED_LONG:\n+      return long_unsigned_type_node;\n+\n+    case GCC_JIT_TYPE_LONG_LONG:\n+      return long_long_integer_type_node;\n+    case GCC_JIT_TYPE_UNSIGNED_LONG_LONG:\n+      return long_long_unsigned_type_node;\n+\n+    case GCC_JIT_TYPE_FLOAT:\n+      return float_type_node;\n+    case GCC_JIT_TYPE_DOUBLE:\n+      return double_type_node;\n+    case GCC_JIT_TYPE_LONG_DOUBLE:\n+      return long_double_type_node;\n+\n+    case GCC_JIT_TYPE_SIZE_T:\n+      return size_type_node;\n+\n+    case GCC_JIT_TYPE_FILE_PTR:\n+      return fileptr_type_node;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Construct a playback::type instance (wrapping a tree) for the given\n+   enum value.  */\n+\n+playback::type *\n+playback::context::\n+get_type (enum gcc_jit_types type_)\n+{\n+  tree type_node = get_tree_node_for_type (type_);\n+  if (NULL == type_node)\n+    {\n+      add_error (NULL,\n+\t\t \"unrecognized (enum gcc_jit_types) value: %i\", type_);\n+      return NULL;\n+    }\n+\n+  return new type (type_node);\n+}\n+\n+/* Construct a playback::type instance (wrapping a tree) for the given\n+   array type.  */\n+\n+playback::type *\n+playback::context::\n+new_array_type (playback::location *loc,\n+\t\tplayback::type *element_type,\n+\t\tint num_elements)\n+{\n+  gcc_assert (element_type);\n+\n+  tree t = build_array_type_nelts (element_type->as_tree (),\n+\t\t\t\t   num_elements);\n+  layout_type (t);\n+\n+  if (loc)\n+    set_tree_location (t, loc);\n+\n+  return new type (t);\n+}\n+\n+/* Construct a playback::field instance (wrapping a tree).  */\n+\n+playback::field *\n+playback::context::\n+new_field (location *loc,\n+\t   type *type,\n+\t   const char *name)\n+{\n+  gcc_assert (type);\n+  gcc_assert (name);\n+\n+  /* compare with c/c-decl.c:grokfield and grokdeclarator.  */\n+  tree decl = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t  get_identifier (name), type->as_tree ());\n+\n+  if (loc)\n+    set_tree_location (decl, loc);\n+\n+  return new field (decl);\n+}\n+\n+/* Construct a playback::compound_type instance (wrapping a tree).  */\n+\n+playback::compound_type *\n+playback::context::\n+new_compound_type (location *loc,\n+\t\t   const char *name,\n+\t\t   bool is_struct) /* else is union */\n+{\n+  gcc_assert (name);\n+\n+  /* Compare with c/c-decl.c: start_struct. */\n+\n+  tree t = make_node (is_struct ? RECORD_TYPE : UNION_TYPE);\n+  TYPE_NAME (t) = get_identifier (name);\n+  TYPE_SIZE (t) = 0;\n+\n+  if (loc)\n+    set_tree_location (t, loc);\n+\n+  return new compound_type (t);\n+}\n+\n+void\n+playback::compound_type::set_fields (const vec<playback::field *> &fields)\n+{\n+  /* Compare with c/c-decl.c: finish_struct. */\n+  tree t = as_tree ();\n+\n+  tree fieldlist = NULL;\n+  for (unsigned i = 0; i < fields.length (); i++)\n+    {\n+      field *f = fields[i];\n+      DECL_CONTEXT (f->as_tree ()) = t;\n+      fieldlist = chainon (f->as_tree (), fieldlist);\n+    }\n+  fieldlist = nreverse (fieldlist);\n+  TYPE_FIELDS (t) = fieldlist;\n+\n+  layout_type (t);\n+}\n+\n+/* Construct a playback::type instance (wrapping a tree) for a function\n+   type.  */\n+\n+playback::type *\n+playback::context::\n+new_function_type (type *return_type,\n+\t\t   vec<type *> *param_types,\n+\t\t   int is_variadic)\n+{\n+  int i;\n+  type *param_type;\n+\n+  tree *arg_types = (tree *)xcalloc(param_types->length (), sizeof(tree*));\n+\n+  FOR_EACH_VEC_ELT (*param_types, i, param_type)\n+    arg_types[i] = param_type->as_tree ();\n+\n+  tree fn_type;\n+  if (is_variadic)\n+    fn_type =\n+      build_varargs_function_type_array (return_type->as_tree (),\n+\t\t\t\t\t param_types->length (),\n+\t\t\t\t\t arg_types);\n+  else\n+    fn_type = build_function_type_array (return_type->as_tree (),\n+\t\t\t\t\t param_types->length (),\n+\t\t\t\t\t arg_types);\n+  free (arg_types);\n+\n+  return new type (fn_type);\n+}\n+\n+/* Construct a playback::param instance (wrapping a tree).  */\n+\n+playback::param *\n+playback::context::\n+new_param (location *loc,\n+\t   type *type,\n+\t   const char *name)\n+{\n+  gcc_assert (type);\n+  gcc_assert (name);\n+  tree inner = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t\t   get_identifier (name), type->as_tree ());\n+  if (loc)\n+    set_tree_location (inner, loc);\n+\n+  return new param (this, inner);\n+}\n+\n+/* Construct a playback::function instance.  */\n+\n+playback::function *\n+playback::context::\n+new_function (location *loc,\n+\t      enum gcc_jit_function_kind kind,\n+\t      type *return_type,\n+\t      const char *name,\n+\t      vec<param *> *params,\n+\t      int is_variadic,\n+\t      enum built_in_function builtin_id)\n+{\n+  int i;\n+  param *param;\n+\n+  //can return_type be NULL?\n+  gcc_assert (name);\n+\n+  tree *arg_types = (tree *)xcalloc(params->length (), sizeof(tree*));\n+  FOR_EACH_VEC_ELT (*params, i, param)\n+    arg_types[i] = TREE_TYPE (param->as_tree ());\n+\n+  tree fn_type;\n+  if (is_variadic)\n+    fn_type = build_varargs_function_type_array (return_type->as_tree (),\n+\t\t\t\t\t\t params->length (), arg_types);\n+  else\n+    fn_type = build_function_type_array (return_type->as_tree (),\n+\t\t\t\t\t params->length (), arg_types);\n+  free (arg_types);\n+\n+  /* FIXME: this uses input_location: */\n+  tree fndecl = build_fn_decl (name, fn_type);\n+\n+  if (loc)\n+    set_tree_location (fndecl, loc);\n+\n+  tree resdecl = build_decl (UNKNOWN_LOCATION, RESULT_DECL,\n+\t\t\t     NULL_TREE, return_type->as_tree ());\n+  DECL_ARTIFICIAL (resdecl) = 1;\n+  DECL_IGNORED_P (resdecl) = 1;\n+  DECL_RESULT (fndecl) = resdecl;\n+\n+  if (builtin_id)\n+    {\n+      DECL_BUILT_IN_CLASS (fndecl) = BUILT_IN_NORMAL;\n+      DECL_FUNCTION_CODE (fndecl) = builtin_id;\n+      gcc_assert (loc == NULL);\n+      DECL_SOURCE_LOCATION (fndecl) = BUILTINS_LOCATION;\n+    }\n+\n+  if (kind != GCC_JIT_FUNCTION_IMPORTED)\n+    {\n+      tree param_decl_list = NULL;\n+      FOR_EACH_VEC_ELT (*params, i, param)\n+\t{\n+\t  param_decl_list = chainon (param->as_tree (), param_decl_list);\n+\t}\n+\n+      /* The param list was created in reverse order; fix it: */\n+      param_decl_list = nreverse (param_decl_list);\n+\n+      tree t;\n+      for (t = param_decl_list; t; t = DECL_CHAIN (t))\n+\t{\n+\t  DECL_CONTEXT (t) = fndecl;\n+\t  DECL_ARG_TYPE (t) = TREE_TYPE (t);\n+\t}\n+\n+      /* Set it up on DECL_ARGUMENTS */\n+      DECL_ARGUMENTS(fndecl) = param_decl_list;\n+    }\n+\n+  if (kind == GCC_JIT_FUNCTION_ALWAYS_INLINE)\n+    {\n+      DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+      /* Add attribute \"always_inline\": */\n+      DECL_ATTRIBUTES (fndecl) =\n+\ttree_cons (get_identifier (\"always_inline\"),\n+\t\t   NULL,\n+\t\t   DECL_ATTRIBUTES (fndecl));\n+    }\n+\n+  function *func = new function (this, fndecl, kind);\n+  m_functions.safe_push (func);\n+  return func;\n+}\n+\n+/* Construct a playback::lvalue instance (wrapping a tree).  */\n+\n+playback::lvalue *\n+playback::context::\n+new_global (location *loc,\n+            type *type,\n+            const char *name)\n+{\n+  gcc_assert (type);\n+  gcc_assert (name);\n+  tree inner = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t   get_identifier (name),\n+\t\t\t   type->as_tree ());\n+  TREE_PUBLIC (inner) = 1;\n+  DECL_COMMON (inner) = 1;\n+  DECL_EXTERNAL (inner) = 1;\n+\n+  if (loc)\n+    set_tree_location (inner, loc);\n+\n+  return new lvalue (this, inner);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree).  */\n+\n+playback::rvalue *\n+playback::context::\n+new_rvalue_from_int (type *type,\n+\t\t     int value)\n+{\n+  // FIXME: type-checking, or coercion?\n+  tree inner_type = type->as_tree ();\n+  if (INTEGRAL_TYPE_P (inner_type))\n+    {\n+      tree inner = build_int_cst (inner_type, value);\n+      return new rvalue (this, inner);\n+    }\n+  else\n+    {\n+      REAL_VALUE_TYPE real_value;\n+      real_from_integer (&real_value, VOIDmode, value, SIGNED);\n+      tree inner = build_real (inner_type, real_value);\n+      return new rvalue (this, inner);\n+    }\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree).  */\n+\n+playback::rvalue *\n+playback::context::\n+new_rvalue_from_double (type *type,\n+\t\t\tdouble value)\n+{\n+  // FIXME: type-checking, or coercion?\n+  tree inner_type = type->as_tree ();\n+\n+  /* We have a \"double\", we want a REAL_VALUE_TYPE.\n+\n+     real.c:real_from_target appears to require the representation to be\n+     split into 32-bit values, and then sent as an pair of host long\n+     ints.  */\n+  REAL_VALUE_TYPE real_value;\n+  union\n+  {\n+    double as_double;\n+    uint32_t as_uint32s[2];\n+  } u;\n+  u.as_double = value;\n+  long int as_long_ints[2];\n+  as_long_ints[0] = u.as_uint32s[0];\n+  as_long_ints[1] = u.as_uint32s[1];\n+  real_from_target (&real_value, as_long_ints, DFmode);\n+  tree inner = build_real (inner_type, real_value);\n+  return new rvalue (this, inner);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree).  */\n+\n+playback::rvalue *\n+playback::context::\n+new_rvalue_from_ptr (type *type,\n+\t\t     void *value)\n+{\n+  tree inner_type = type->as_tree ();\n+  /* FIXME: how to ensure we have a wide enough type?  */\n+  tree inner = build_int_cstu (inner_type, (unsigned HOST_WIDE_INT)value);\n+  return new rvalue (this, inner);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree).  */\n+\n+playback::rvalue *\n+playback::context::\n+new_string_literal (const char *value)\n+{\n+  tree t_str = build_string (strlen (value), value);\n+  gcc_assert (m_char_array_type_node);\n+  TREE_TYPE (t_str) = m_char_array_type_node;\n+\n+  /* Convert to (const char*), loosely based on\n+     c/c-typeck.c: array_to_pointer_conversion,\n+     by taking address of start of string.  */\n+  tree t_addr = build1 (ADDR_EXPR, m_const_char_ptr, t_str);\n+\n+  return new rvalue (this, t_addr);\n+}\n+\n+/* Coerce a tree expression into a boolean tree expression.  */\n+\n+tree\n+playback::context::\n+as_truth_value (tree expr, location *loc)\n+{\n+  /* Compare to c-typeck.c:c_objc_common_truthvalue_conversion */\n+  tree typed_zero = fold_build1 (CONVERT_EXPR,\n+\t\t\t\t TREE_TYPE (expr),\n+\t\t\t\t integer_zero_node);\n+  if (loc)\n+    set_tree_location (typed_zero, loc);\n+\n+  expr = build2 (NE_EXPR, integer_type_node, expr, typed_zero);\n+  if (loc)\n+    set_tree_location (expr, loc);\n+\n+  return expr;\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   unary op.  */\n+\n+playback::rvalue *\n+playback::context::\n+new_unary_op (location *loc,\n+\t      enum gcc_jit_unary_op op,\n+\t      type *result_type,\n+\t      rvalue *a)\n+{\n+  // FIXME: type-checking, or coercion?\n+  enum tree_code inner_op;\n+\n+  gcc_assert (result_type);\n+  gcc_assert (a);\n+\n+  tree node = a->as_tree ();\n+  tree inner_result = NULL;\n+\n+  switch (op)\n+    {\n+    default:\n+      add_error (loc, \"unrecognized (enum gcc_jit_unary_op) value: %i\", op);\n+      return NULL;\n+\n+    case GCC_JIT_UNARY_OP_MINUS:\n+      inner_op = NEGATE_EXPR;\n+      break;\n+\n+    case GCC_JIT_UNARY_OP_BITWISE_NEGATE:\n+      inner_op = BIT_NOT_EXPR;\n+      break;\n+\n+    case GCC_JIT_UNARY_OP_LOGICAL_NEGATE:\n+      node = as_truth_value (node, loc);\n+      inner_result = invert_truthvalue (node);\n+      if (loc)\n+\tset_tree_location (inner_result, loc);\n+      return new rvalue (this, inner_result);\n+    }\n+\n+  inner_result = build1 (inner_op,\n+\t\t\t result_type->as_tree (),\n+\t\t\t node);\n+  if (loc)\n+    set_tree_location (inner_result, loc);\n+\n+  return new rvalue (this, inner_result);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   binary op.  */\n+\n+playback::rvalue *\n+playback::context::\n+new_binary_op (location *loc,\n+\t       enum gcc_jit_binary_op op,\n+\t       type *result_type,\n+\t       rvalue *a, rvalue *b)\n+{\n+  // FIXME: type-checking, or coercion?\n+  enum tree_code inner_op;\n+\n+  gcc_assert (result_type);\n+  gcc_assert (a);\n+  gcc_assert (b);\n+\n+  tree node_a = a->as_tree ();\n+  tree node_b = b->as_tree ();\n+\n+  switch (op)\n+    {\n+    default:\n+      add_error (loc, \"unrecognized (enum gcc_jit_binary_op) value: %i\", op);\n+      return NULL;\n+\n+    case GCC_JIT_BINARY_OP_PLUS:\n+      inner_op = PLUS_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_MINUS:\n+      inner_op = MINUS_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_MULT:\n+      inner_op = MULT_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_DIVIDE:\n+      if (FLOAT_TYPE_P (result_type->as_tree ()))\n+\t/* Floating-point division: */\n+\tinner_op = RDIV_EXPR;\n+      else\n+\t/* Truncating to zero: */\n+\tinner_op = TRUNC_DIV_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_MODULO:\n+      inner_op = TRUNC_MOD_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_BITWISE_AND:\n+      inner_op = BIT_AND_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_BITWISE_XOR:\n+      inner_op = BIT_XOR_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_BITWISE_OR:\n+      inner_op = BIT_IOR_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_LOGICAL_AND:\n+      node_a = as_truth_value (node_a, loc);\n+      node_b = as_truth_value (node_b, loc);\n+      inner_op = TRUTH_ANDIF_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_LOGICAL_OR:\n+      node_a = as_truth_value (node_a, loc);\n+      node_b = as_truth_value (node_b, loc);\n+      inner_op = TRUTH_ORIF_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_LSHIFT:\n+      inner_op = LSHIFT_EXPR;\n+      break;\n+\n+    case GCC_JIT_BINARY_OP_RSHIFT:\n+      inner_op = RSHIFT_EXPR;\n+      break;\n+    }\n+\n+  tree inner_expr = build2 (inner_op,\n+\t\t\t    result_type->as_tree (),\n+\t\t\t    node_a,\n+\t\t\t    node_b);\n+  if (loc)\n+    set_tree_location (inner_expr, loc);\n+\n+  return new rvalue (this, inner_expr);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   comparison.  */\n+\n+playback::rvalue *\n+playback::context::\n+new_comparison (location *loc,\n+\t\tenum gcc_jit_comparison op,\n+\t\trvalue *a, rvalue *b)\n+{\n+  // FIXME: type-checking, or coercion?\n+  enum tree_code inner_op;\n+\n+  gcc_assert (a);\n+  gcc_assert (b);\n+\n+  switch (op)\n+    {\n+    default:\n+      add_error (loc, \"unrecognized (enum gcc_jit_comparison) value: %i\", op);\n+      return NULL;\n+\n+    case GCC_JIT_COMPARISON_EQ:\n+      inner_op = EQ_EXPR;\n+      break;\n+    case GCC_JIT_COMPARISON_NE:\n+      inner_op = NE_EXPR;\n+      break;\n+    case GCC_JIT_COMPARISON_LT:\n+      inner_op = LT_EXPR;\n+      break;\n+    case GCC_JIT_COMPARISON_LE:\n+      inner_op = LE_EXPR;\n+      break;\n+    case GCC_JIT_COMPARISON_GT:\n+      inner_op = GT_EXPR;\n+      break;\n+    case GCC_JIT_COMPARISON_GE:\n+      inner_op = GE_EXPR;\n+      break;\n+    }\n+\n+  tree inner_expr = build2 (inner_op,\n+\t\t\t    boolean_type_node,\n+\t\t\t    a->as_tree (),\n+\t\t\t    b->as_tree ());\n+  if (loc)\n+    set_tree_location (inner_expr, loc);\n+  return new rvalue (this, inner_expr);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   function call.  */\n+\n+playback::rvalue *\n+playback::context::\n+build_call (location *loc,\n+\t    tree fn_ptr,\n+\t    vec<rvalue *> args)\n+{\n+  vec<tree, va_gc> *tree_args;\n+  vec_alloc (tree_args, args.length ());\n+  for (unsigned i = 0; i < args.length (); i++)\n+    tree_args->quick_push (args[i]->as_tree ());\n+\n+  if (loc)\n+    set_tree_location (fn_ptr, loc);\n+\n+  tree fn = TREE_TYPE (fn_ptr);\n+  tree fn_type = TREE_TYPE (fn);\n+  tree return_type = TREE_TYPE (fn_type);\n+\n+  return new rvalue (this,\n+\t\t     build_call_vec (return_type,\n+\t\t\t\t     fn_ptr, tree_args));\n+\n+  /* see c-typeck.c: build_function_call\n+     which calls build_function_call_vec\n+\n+     which does lots of checking, then:\n+    result = build_call_array_loc (loc, TREE_TYPE (fntype),\n+\t\t\t\t   function, nargs, argarray);\n+    which is in tree.c\n+    (see also build_call_vec)\n+   */\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   call to a specific function.  */\n+\n+playback::rvalue *\n+playback::context::\n+new_call (location *loc,\n+\t  function *func,\n+\t  vec<rvalue *> args)\n+{\n+  tree fndecl;\n+\n+  gcc_assert (func);\n+\n+  fndecl = func->as_fndecl ();\n+\n+  tree fntype = TREE_TYPE (fndecl);\n+\n+  tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n+\n+  return build_call (loc, fn, args);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   call through a function pointer.  */\n+\n+playback::rvalue *\n+playback::context::\n+new_call_through_ptr (location *loc,\n+\t\t      rvalue *fn_ptr,\n+\t\t      vec<rvalue *> args)\n+{\n+  gcc_assert (fn_ptr);\n+  tree t_fn_ptr = fn_ptr->as_tree ();\n+\n+  return build_call (loc, t_fn_ptr, args);\n+}\n+\n+/* Construct a tree for a cast.  */\n+\n+tree\n+playback::context::build_cast (playback::location *loc,\n+\t\t\t       playback::rvalue *expr,\n+\t\t\t       playback::type *type_)\n+{\n+  /* For comparison, see:\n+     - c/c-typeck.c:build_c_cast\n+     - c/c-convert.c: convert\n+     - convert.h\n+\n+     Only some kinds of cast are currently supported here.  */\n+  tree t_expr = expr->as_tree ();\n+  tree t_dst_type = type_->as_tree ();\n+  tree t_ret = NULL;\n+  t_ret = targetm.convert_to_type (t_dst_type, t_expr);\n+  if (t_ret)\n+      return t_ret;\n+  enum tree_code dst_code = TREE_CODE (t_dst_type);\n+  switch (dst_code)\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      t_ret = convert_to_integer (t_dst_type, t_expr);\n+      goto maybe_fold;\n+\n+    case BOOLEAN_TYPE:\n+      /* Compare with c_objc_common_truthvalue_conversion and\n+\t c_common_truthvalue_conversion. */\n+      /* For now, convert to: (t_expr != 0)  */\n+      t_ret = build2 (NE_EXPR, t_dst_type,\n+\t\t      t_expr, integer_zero_node);\n+      goto maybe_fold;\n+\n+    case REAL_TYPE:\n+      t_ret = convert_to_real (t_dst_type, t_expr);\n+      goto maybe_fold;\n+\n+    case POINTER_TYPE:\n+      t_ret = build1 (NOP_EXPR, t_dst_type, t_expr);\n+      goto maybe_fold;\n+\n+    default:\n+      add_error (loc, \"couldn't handle cast during playback\");\n+      fprintf (stderr, \"input expression:\\n\");\n+      debug_tree (t_expr);\n+      fprintf (stderr, \"requested type:\\n\");\n+      debug_tree (t_dst_type);\n+      return error_mark_node;\n+\n+    maybe_fold:\n+      if (TREE_CODE (t_ret) != C_MAYBE_CONST_EXPR)\n+\tt_ret = fold (t_ret);\n+      return t_ret;\n+    }\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   cast.  */\n+\n+playback::rvalue *\n+playback::context::\n+new_cast (playback::location *loc,\n+\t  playback::rvalue *expr,\n+\t  playback::type *type_)\n+{\n+\n+  tree t_cast = build_cast (loc, expr, type_);\n+  if (loc)\n+    set_tree_location (t_cast, loc);\n+  return new rvalue (this, t_cast);\n+}\n+\n+/* Construct a playback::lvalue instance (wrapping a tree) for an\n+   array access.  */\n+\n+playback::lvalue *\n+playback::context::\n+new_array_access (location *loc,\n+\t\t  rvalue *ptr,\n+\t\t  rvalue *index)\n+{\n+  gcc_assert (ptr);\n+  gcc_assert (index);\n+\n+  /* For comparison, see:\n+       c/c-typeck.c: build_array_ref\n+       c-family/c-common.c: pointer_int_sum\n+  */\n+  tree t_ptr = ptr->as_tree ();\n+  tree t_index = index->as_tree ();\n+  tree t_type_ptr = TREE_TYPE (t_ptr);\n+  tree t_type_star_ptr = TREE_TYPE (t_type_ptr);\n+\n+  if (TREE_CODE (t_type_ptr) == ARRAY_TYPE)\n+    {\n+      tree t_result = build4 (ARRAY_REF, t_type_star_ptr, t_ptr, t_index,\n+\t\t\t      NULL_TREE, NULL_TREE);\n+      if (loc)\n+        set_tree_location (t_result, loc);\n+      return new lvalue (this, t_result);\n+    }\n+  else\n+    {\n+      /* Convert index to an offset in bytes.  */\n+      tree t_sizeof = size_in_bytes (t_type_star_ptr);\n+      t_index = fold_build1 (CONVERT_EXPR, sizetype, t_index);\n+      tree t_offset = build2 (MULT_EXPR, sizetype, t_index, t_sizeof);\n+\n+      /* Locate (ptr + offset).  */\n+      tree t_address = build2 (POINTER_PLUS_EXPR, t_type_ptr, t_ptr, t_offset);\n+\n+      tree t_indirection = build1 (INDIRECT_REF, t_type_star_ptr, t_address);\n+      if (loc)\n+        {\n+          set_tree_location (t_sizeof, loc);\n+          set_tree_location (t_offset, loc);\n+          set_tree_location (t_address, loc);\n+          set_tree_location (t_indirection, loc);\n+        }\n+\n+      return new lvalue (this, t_indirection);\n+    }\n+}\n+\n+/* Construct a tree for a field access.  */\n+\n+tree\n+playback::context::\n+new_field_access (location *loc,\n+\t\t  tree datum,\n+\t\t  field *field)\n+{\n+  gcc_assert (datum);\n+  gcc_assert (field);\n+\n+  /* Compare with c/c-typeck.c:lookup_field, build_indirect_ref, and\n+     build_component_ref. */\n+  tree type = TREE_TYPE (datum);\n+  gcc_assert (type);\n+  gcc_assert (TREE_CODE (type) != POINTER_TYPE);\n+\n+ tree t_field = field->as_tree ();\n+ tree ref = build3 (COMPONENT_REF, TREE_TYPE (t_field), datum,\n+\t\t     t_field, NULL_TREE);\n+  if (loc)\n+    set_tree_location (ref, loc);\n+  return ref;\n+}\n+\n+/* Construct a tree for a dereference.  */\n+\n+tree\n+playback::context::\n+new_dereference (tree ptr,\n+\t\t location *loc)\n+{\n+  gcc_assert (ptr);\n+\n+  tree type = TREE_TYPE (TREE_TYPE(ptr));\n+  tree datum = build1 (INDIRECT_REF, type, ptr);\n+  if (loc)\n+    set_tree_location (datum, loc);\n+  return datum;\n+}\n+\n+/* Construct a playback::lvalue instance (wrapping a tree) for a\n+   field access.  */\n+\n+playback::lvalue *\n+playback::lvalue::\n+access_field (location *loc,\n+\t      field *field)\n+{\n+  tree datum = as_tree ();\n+  tree ref = get_context ()->new_field_access (loc, datum, field);\n+  if (!ref)\n+    return NULL;\n+  return new lvalue (get_context (), ref);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for a\n+   field access.  */\n+\n+playback::rvalue *\n+playback::rvalue::\n+access_field (location *loc,\n+\t      field *field)\n+{\n+  tree datum = as_tree ();\n+  tree ref = get_context ()->new_field_access (loc, datum, field);\n+  if (!ref)\n+    return NULL;\n+  return new rvalue (get_context (), ref);\n+}\n+\n+/* Construct a playback::lvalue instance (wrapping a tree) for a\n+   dereferenced field access.  */\n+\n+playback::lvalue *\n+playback::rvalue::\n+dereference_field (location *loc,\n+\t\t   field *field)\n+{\n+  tree ptr = as_tree ();\n+  tree datum = get_context ()->new_dereference (ptr, loc);\n+  if (!datum)\n+    return NULL;\n+  tree ref = get_context ()->new_field_access (loc, datum, field);\n+  if (!ref)\n+    return NULL;\n+  return new lvalue (get_context (), ref);\n+}\n+\n+/* Construct a playback::lvalue instance (wrapping a tree) for a\n+   dereference.  */\n+\n+playback::lvalue *\n+playback::rvalue::\n+dereference (location *loc)\n+{\n+  tree ptr = as_tree ();\n+  tree datum = get_context ()->new_dereference (ptr, loc);\n+  return new lvalue (get_context (), datum);\n+}\n+\n+/* Construct a playback::rvalue instance (wrapping a tree) for an\n+   address-lookup.  */\n+\n+playback::rvalue *\n+playback::lvalue::\n+get_address (location *loc)\n+{\n+  tree t_lvalue = as_tree ();\n+  tree t_thistype = TREE_TYPE (t_lvalue);\n+  tree t_ptrtype = build_pointer_type (t_thistype);\n+  tree ptr = build1 (ADDR_EXPR, t_ptrtype, t_lvalue);\n+  if (loc)\n+    get_context ()->set_tree_location (ptr, loc);\n+  return new rvalue (get_context (), ptr);\n+}\n+\n+/* gcc::jit::playback::wrapper subclasses are GC-managed:\n+   allocate them using ggc_internal_cleared_alloc.  */\n+\n+void *\n+playback::wrapper::\n+operator new (size_t sz)\n+{\n+  return ggc_internal_cleared_alloc (sz MEM_STAT_INFO);\n+}\n+\n+/* Constructor for gcc:jit::playback::function.  */\n+\n+playback::function::\n+function (context *ctxt,\n+\t  tree fndecl,\n+\t  enum gcc_jit_function_kind kind)\n+: m_ctxt(ctxt),\n+  m_inner_fndecl (fndecl),\n+  m_inner_bind_expr (NULL),\n+  m_kind (kind)\n+{\n+  if (m_kind != GCC_JIT_FUNCTION_IMPORTED)\n+    {\n+      /* Create a BIND_EXPR, and within it, a statement list.  */\n+      m_stmt_list = alloc_stmt_list ();\n+      m_stmt_iter = tsi_start (m_stmt_list);\n+      m_inner_block = make_node (BLOCK);\n+      m_inner_bind_expr =\n+\tbuild3 (BIND_EXPR, void_type_node, NULL, m_stmt_list, m_inner_block);\n+    }\n+  else\n+    {\n+      m_inner_block = NULL;\n+      m_stmt_list = NULL;\n+    }\n+}\n+\n+/* Hand-written GC-marking hook for playback functions.  */\n+\n+void\n+playback::function::\n+gt_ggc_mx ()\n+{\n+  gt_ggc_m_9tree_node (m_inner_fndecl);\n+  gt_ggc_m_9tree_node (m_inner_bind_expr);\n+  gt_ggc_m_9tree_node (m_stmt_list);\n+  gt_ggc_m_9tree_node (m_inner_block);\n+}\n+\n+/* Get the return type of a playback function, in tree form.  */\n+\n+tree\n+playback::function::\n+get_return_type_as_tree () const\n+{\n+  return TREE_TYPE (TREE_TYPE(m_inner_fndecl));\n+}\n+\n+/* Construct a new local within this playback::function.  */\n+\n+playback::lvalue *\n+playback::function::\n+new_local (location *loc,\n+\t   type *type,\n+\t   const char *name)\n+{\n+  gcc_assert (type);\n+  gcc_assert (name);\n+  tree inner = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t   get_identifier (name),\n+\t\t\t   type->as_tree ());\n+  DECL_CONTEXT (inner) = this->m_inner_fndecl;\n+\n+  /* Prepend to BIND_EXPR_VARS: */\n+  DECL_CHAIN (inner) = BIND_EXPR_VARS (m_inner_bind_expr);\n+  BIND_EXPR_VARS (m_inner_bind_expr) = inner;\n+\n+  if (loc)\n+    set_tree_location (inner, loc);\n+  return new lvalue (m_ctxt, inner);\n+}\n+\n+/* Construct a new block within this playback::function.  */\n+\n+playback::block *\n+playback::function::\n+new_block (const char *name)\n+{\n+  gcc_assert (m_kind != GCC_JIT_FUNCTION_IMPORTED);\n+\n+  block *result = new playback::block (this, name);\n+  m_blocks.safe_push (result);\n+  return result;\n+}\n+\n+/* Build a statement list for the function as a whole out of the\n+   lists of statements for the individual blocks, building labels\n+   for each block.  */\n+\n+void\n+playback::function::\n+build_stmt_list ()\n+{\n+  int i;\n+  block *b;\n+\n+  FOR_EACH_VEC_ELT (m_blocks, i, b)\n+    {\n+      int j;\n+      tree stmt;\n+\n+      b->m_label_expr = build1 (LABEL_EXPR,\n+\t\t\t\tvoid_type_node,\n+\t\t\t\tb->as_label_decl ());\n+      tsi_link_after (&m_stmt_iter, b->m_label_expr, TSI_CONTINUE_LINKING);\n+\n+      FOR_EACH_VEC_ELT (b->m_stmts, j, stmt)\n+\ttsi_link_after (&m_stmt_iter, stmt, TSI_CONTINUE_LINKING);\n+    }\n+}\n+\n+/* Finish compiling the given function, potentially running the\n+   garbage-collector.\n+   The function will have a statement list by now.\n+   Amongst other things, this gimplifies the statement list,\n+   and calls cgraph_node::finalize_function on the function.  */\n+\n+void\n+playback::function::\n+postprocess ()\n+{\n+  if (m_ctxt->get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE))\n+    debug_tree (m_stmt_list);\n+\n+  /* Do we need this to force cgraphunit.c to output the function? */\n+  if (m_kind == GCC_JIT_FUNCTION_EXPORTED)\n+    {\n+      DECL_EXTERNAL (m_inner_fndecl) = 0;\n+      DECL_PRESERVE_P (m_inner_fndecl) = 1;\n+    }\n+\n+  if (m_kind == GCC_JIT_FUNCTION_INTERNAL\n+      ||m_kind == GCC_JIT_FUNCTION_ALWAYS_INLINE)\n+    {\n+      DECL_EXTERNAL (m_inner_fndecl) = 0;\n+      TREE_PUBLIC (m_inner_fndecl) = 0;\n+    }\n+\n+  if (m_kind != GCC_JIT_FUNCTION_IMPORTED)\n+    {\n+      /* Seem to need this in gimple-low.c: */\n+      gcc_assert (m_inner_block);\n+      DECL_INITIAL (m_inner_fndecl) = m_inner_block;\n+\n+      /* how to add to function? the following appears to be how to\n+\t set the body of a m_inner_fndecl: */\n+      DECL_SAVED_TREE(m_inner_fndecl) = m_inner_bind_expr;\n+\n+      /* Ensure that locals appear in the debuginfo.  */\n+      BLOCK_VARS (m_inner_block) = BIND_EXPR_VARS (m_inner_bind_expr);\n+\n+      //debug_tree (m_inner_fndecl);\n+\n+      /* Convert to gimple: */\n+      //printf(\"about to gimplify_function_tree\\n\");\n+      gimplify_function_tree (m_inner_fndecl);\n+      //printf(\"finished gimplify_function_tree\\n\");\n+\n+      current_function_decl = m_inner_fndecl;\n+      if (m_ctxt->get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE))\n+\tdump_function_to_file (m_inner_fndecl, stderr, TDF_VOPS|TDF_MEMSYMS|TDF_LINENO);\n+      //debug_tree (m_inner_fndecl);\n+\n+      //printf(\"about to add to cgraph\\n\");\n+      /* Add to cgraph: */\n+      cgraph_node::finalize_function (m_inner_fndecl, false);\n+      /* This can trigger a collection, so we need to have all of\n+\t the funcs as roots.  */\n+\n+      current_function_decl = NULL;\n+    }\n+}\n+\n+/* Add an eval of the rvalue to the function's statement list.  */\n+\n+void\n+playback::block::\n+add_eval (location *loc,\n+\t  rvalue *rvalue)\n+{\n+  gcc_assert (rvalue);\n+\n+  if (loc)\n+    set_tree_location (rvalue->as_tree (), loc);\n+\n+  add_stmt (rvalue->as_tree ());\n+}\n+\n+/* Add an assignment to the function's statement list.  */\n+\n+void\n+playback::block::\n+add_assignment (location *loc,\n+\t\tlvalue *lvalue,\n+\t\trvalue *rvalue)\n+{\n+  gcc_assert (lvalue);\n+  gcc_assert (rvalue);\n+\n+  tree t_lvalue = lvalue->as_tree ();\n+  tree t_rvalue = rvalue->as_tree ();\n+  if (TREE_TYPE (t_rvalue) != TREE_TYPE (t_lvalue))\n+    {\n+      t_rvalue = build1 (CONVERT_EXPR,\n+\t\t         TREE_TYPE (t_lvalue),\n+\t\t         t_rvalue);\n+      if (loc)\n+\tset_tree_location (t_rvalue, loc);\n+    }\n+\n+  tree stmt =\n+    build2 (MODIFY_EXPR, TREE_TYPE (t_lvalue),\n+\t    t_lvalue, t_rvalue);\n+  if (loc)\n+    set_tree_location (stmt, loc);\n+  add_stmt (stmt);\n+}\n+\n+/* Add a comment to the function's statement list.\n+   For now this is done by adding a dummy label.  */\n+\n+void\n+playback::block::\n+add_comment (location *loc,\n+\t     const char *text)\n+{\n+  /* Wrap the text in C-style comment delimiters.  */\n+  size_t sz =\n+    (3 /* opening delim */\n+     + strlen (text)\n+     + 3 /* closing delim */\n+     + 1 /* terminator */);\n+  char *wrapped = (char *)ggc_internal_alloc (sz);\n+  snprintf (wrapped, sz, \"/* %s */\", text);\n+\n+  /* For now we simply implement this by adding a dummy label with a name\n+     containing the given text.  */\n+  tree identifier = get_identifier (wrapped);\n+  tree label_decl = build_decl (UNKNOWN_LOCATION, LABEL_DECL,\n+\t\t\t\tidentifier, void_type_node);\n+  DECL_CONTEXT (label_decl) = m_func->as_fndecl ();\n+\n+  tree label_expr = build1 (LABEL_EXPR, void_type_node, label_decl);\n+  if (loc)\n+    set_tree_location (label_expr, loc);\n+  add_stmt (label_expr);\n+}\n+\n+/* Add a conditional jump statement to the function's statement list.  */\n+\n+void\n+playback::block::\n+add_conditional (location *loc,\n+\t\t rvalue *boolval,\n+\t\t block *on_true,\n+\t\t block *on_false)\n+{\n+  gcc_assert (boolval);\n+  gcc_assert (on_true);\n+  gcc_assert (on_false);\n+\n+  /* COND_EXPR wants statement lists for the true/false operands, but we\n+     want labels.\n+     Shim it by creating jumps to the labels */\n+  tree true_jump = build1 (GOTO_EXPR, void_type_node,\n+\t\t\t   on_true->as_label_decl ());\n+  if (loc)\n+    set_tree_location (true_jump, loc);\n+\n+  tree false_jump = build1 (GOTO_EXPR, void_type_node,\n+\t\t\t    on_false->as_label_decl ());\n+  if (loc)\n+    set_tree_location (false_jump, loc);\n+\n+  tree stmt =\n+    build3 (COND_EXPR, void_type_node, boolval->as_tree (),\n+\t    true_jump, false_jump);\n+  if (loc)\n+    set_tree_location (stmt, loc);\n+  add_stmt (stmt);\n+}\n+\n+/* Add an unconditional jump statement to the function's statement list.  */\n+\n+void\n+playback::block::\n+add_jump (location *loc,\n+\t  block *target)\n+{\n+  gcc_assert (target);\n+\n+  // see c_finish_loop\n+  //tree top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+  //add_stmt (top);\n+\n+  //tree stmt = build_and_jump (&LABEL_EXPR_LABEL (target->label_));\n+  TREE_USED (target->as_label_decl ()) = 1;\n+  tree stmt = build1 (GOTO_EXPR, void_type_node, target->as_label_decl ());\n+  if (loc)\n+    set_tree_location (stmt, loc);\n+  add_stmt (stmt);\n+\n+  /*\n+  from c-typeck.c:\n+tree\n+c_finish_goto_label (location_t loc, tree label)\n+{\n+  tree decl = lookup_label_for_goto (loc, label);\n+  if (!decl)\n+    return NULL_TREE;\n+  TREE_USED (decl) = 1;\n+  {\n+    tree t = build1 (GOTO_EXPR, void_type_node, decl);\n+    SET_EXPR_LOCATION (t, loc);\n+    return add_stmt (t);\n+  }\n+}\n+  */\n+\n+}\n+\n+/* Add a return statement to the function's statement list.  */\n+\n+void\n+playback::block::\n+add_return (location *loc,\n+\t    rvalue *rvalue)\n+{\n+  tree modify_retval = NULL;\n+  tree return_type = m_func->get_return_type_as_tree ();\n+  if (rvalue)\n+    {\n+      tree t_lvalue = DECL_RESULT (m_func->as_fndecl ());\n+      tree t_rvalue = rvalue->as_tree ();\n+      if (TREE_TYPE (t_rvalue) != TREE_TYPE (t_lvalue))\n+\tt_rvalue = build1 (CONVERT_EXPR,\n+\t\t\t   TREE_TYPE (t_lvalue),\n+\t\t\t   t_rvalue);\n+      modify_retval = build2 (MODIFY_EXPR, return_type,\n+\t\t\t      t_lvalue, t_rvalue);\n+      if (loc)\n+\tset_tree_location (modify_retval, loc);\n+    }\n+  tree return_stmt = build1 (RETURN_EXPR, return_type,\n+\t\t\t     modify_retval);\n+  if (loc)\n+    set_tree_location (return_stmt, loc);\n+\n+  add_stmt (return_stmt);\n+}\n+\n+/* Constructor for gcc::jit::playback::block.  */\n+\n+playback::block::\n+block (function *func,\n+       const char *name)\n+: m_func (func),\n+  m_stmts ()\n+{\n+  tree identifier;\n+\n+  gcc_assert (func);\n+  // name can be NULL\n+  if (name)\n+    identifier = get_identifier (name);\n+  else\n+    identifier = NULL;\n+  m_label_decl = build_decl (UNKNOWN_LOCATION, LABEL_DECL,\n+\t\t\t    identifier, void_type_node);\n+  DECL_CONTEXT (m_label_decl) = func->as_fndecl ();\n+  m_label_expr = NULL;\n+}\n+\n+/* Construct a tempdir path template suitable for use by mkdtemp\n+   e.g. \"/tmp/libgccjit-XXXXXX\", but respecting the rules in\n+   libiberty's choose_tempdir rather than hardcoding \"/tmp/\".\n+\n+   The memory is allocated using malloc and must be freed.\n+   Aborts the process if allocation fails. */\n+\n+static char *\n+make_tempdir_path_template ()\n+{\n+  const char *tmpdir_buf;\n+  size_t tmpdir_len;\n+  const char *file_template_buf;\n+  size_t file_template_len;\n+  char *result;\n+\n+  /* The result of choose_tmpdir is a cached buffer within libiberty, so\n+     we must *not* free it.  */\n+  tmpdir_buf = choose_tmpdir ();\n+\n+  /* choose_tmpdir aborts on malloc failure.  */\n+  gcc_assert (tmpdir_buf);\n+\n+  tmpdir_len = strlen (tmpdir_buf);\n+  /* tmpdir_buf should now have a dir separator as the final byte.  */\n+  gcc_assert (tmpdir_len > 0);\n+  gcc_assert (tmpdir_buf[tmpdir_len - 1] == DIR_SEPARATOR);\n+\n+  file_template_buf = \"libgccjit-XXXXXX\";\n+  file_template_len = strlen (file_template_buf);\n+\n+  result = XNEWVEC (char, tmpdir_len + file_template_len + 1);\n+  strcpy (result, tmpdir_buf);\n+  strcpy (result + tmpdir_len, file_template_buf);\n+\n+  return result;\n+}\n+\n+/* Compile a playback::context:\n+\n+   - Use the context's options to cconstruct command-line options, and\n+     call into the rest of GCC (toplev::main).\n+   - Assuming it succeeds, we have a .s file; we want a .so file.\n+     Invoke another gcc to convert the .s file to a .so file.\n+   - dlopen the .so file\n+   - Wrap the result up as a playback::result and return it.  */\n+\n+result *\n+playback::context::\n+compile ()\n+{\n+  void *handle = NULL;\n+  const char *ctxt_progname;\n+  result *result_obj = NULL;\n+  const char *fake_args[20];\n+  unsigned int num_args;\n+\n+  m_path_template = make_tempdir_path_template ();\n+  if (!m_path_template)\n+    return NULL;\n+\n+  /* Create tempdir using mkdtemp.  This is created with 0700 perms and\n+     is unique.  Hence no other (non-root) users should have access to\n+     the paths within it.  */\n+  m_path_tempdir = mkdtemp (m_path_template);\n+  if (!m_path_tempdir)\n+    return NULL;\n+  m_path_c_file = concat (m_path_tempdir, \"/fake.c\", NULL);\n+  m_path_s_file = concat (m_path_tempdir, \"/fake.s\", NULL);\n+  m_path_so_file = concat (m_path_tempdir, \"/fake.so\", NULL);\n+\n+  /* Call into the rest of gcc.\n+     For now, we have to assemble command-line options to pass into\n+     toplev::main, so that they can be parsed. */\n+\n+  /* Pass in user-provided program name as argv0, if any, so that it\n+     makes it into GCC's \"progname\" global, used in various diagnostics. */\n+  ctxt_progname = get_str_option (GCC_JIT_STR_OPTION_PROGNAME);\n+  fake_args[0] =\n+    (ctxt_progname ? ctxt_progname : \"libgccjit.so\");\n+\n+  fake_args[1] = m_path_c_file;\n+  num_args = 2;\n+\n+#define ADD_ARG(arg) \\\n+  do \\\n+    { \\\n+      gcc_assert(num_args < sizeof(fake_args)/sizeof(char*)); \\\n+      fake_args[num_args++] = arg; \\\n+    } \\\n+  while (0)\n+\n+  ADD_ARG (\"-fPIC\");\n+\n+  /* Handle int options: */\n+  switch (get_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL))\n+    {\n+    default:\n+      add_error (NULL,\n+\t\t \"unrecognized optimization level: %i\",\n+\t\t get_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL));\n+      return NULL;\n+\n+    case 0:\n+      ADD_ARG (\"-O0\");\n+      break;\n+\n+    case 1:\n+      ADD_ARG (\"-O1\");\n+      break;\n+\n+    case 2:\n+      ADD_ARG (\"-O2\");\n+      break;\n+\n+    case 3:\n+      ADD_ARG (\"-O3\");\n+      break;\n+    }\n+  /* What about -Os? */\n+\n+  /* Handle bool options: */\n+  if (get_bool_option (GCC_JIT_BOOL_OPTION_DEBUGINFO))\n+    ADD_ARG (\"-g\");\n+\n+  /* Suppress timing (and other) info.  */\n+  if (!get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_SUMMARY))\n+    {\n+      ADD_ARG (\"-quiet\");\n+      quiet_flag = 1;\n+    }\n+\n+  /* Aggressively garbage-collect, to shake out bugs: */\n+  if (get_bool_option (GCC_JIT_BOOL_OPTION_SELFCHECK_GC))\n+    {\n+      ADD_ARG (\"--param\");\n+      ADD_ARG (\"ggc-min-expand=0\");\n+      ADD_ARG (\"--param\");\n+      ADD_ARG (\"ggc-min-heapsize=0\");\n+    }\n+\n+  if (get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING))\n+    {\n+      ADD_ARG (\"-fdump-tree-all\");\n+      ADD_ARG (\"-fdump-rtl-all\");\n+      ADD_ARG (\"-fdump-ipa-all\");\n+    }\n+\n+  toplev toplev (false);\n+\n+  toplev.main (num_args, const_cast <char **> (fake_args));\n+  toplev.finalize ();\n+\n+  active_playback_ctxt = NULL;\n+\n+  if (errors_occurred ())\n+    return NULL;\n+\n+  if (get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE))\n+   dump_generated_code ();\n+\n+  /* Gross hacks follow:\n+     We have a .s file; we want a .so file.\n+     We could reuse parts of gcc/gcc.c to do this.\n+     For now, just use the driver binary from the install, as\n+     named in gcc-driver-name.h\n+     e.g. \"x86_64-unknown-linux-gnu-gcc-5.0.0\".\n+   */\n+  {\n+    auto_timevar assemble_timevar (TV_ASSEMBLE);\n+    const char *errmsg;\n+    const char *argv[7];\n+    int exit_status = 0;\n+    int err = 0;\n+    const char *gcc_driver_name = GCC_DRIVER_NAME;\n+\n+    argv[0] = gcc_driver_name;\n+    argv[1] = \"-shared\";\n+    /* The input: assembler.  */\n+    argv[2] = m_path_s_file;\n+    /* The output: shared library.  */\n+    argv[3] = \"-o\";\n+    argv[4] = m_path_so_file;\n+\n+    /* Don't use the linker plugin.\n+       If running with just a \"make\" and not a \"make install\", then we'd\n+       run into\n+          \"fatal error: -fuse-linker-plugin, but liblto_plugin.so not found\"\n+       libto_plugin is a .la at build time, with it becoming installed with\n+       \".so\" suffix: i.e. it doesn't exist with a .so suffix until install\n+       time.  */\n+    argv[5] = \"-fno-use-linker-plugin\";\n+\n+    /* pex argv arrays are NULL-terminated.  */\n+    argv[6] = NULL;\n+\n+    errmsg = pex_one (PEX_SEARCH, /* int flags, */\n+\t\t      gcc_driver_name,\n+\t\t      const_cast<char * const *> (argv),\n+\t\t      ctxt_progname, /* const char *pname */\n+\t\t      NULL, /* const char *outname */\n+\t\t      NULL, /* const char *errname */\n+\t\t      &exit_status, /* int *status */\n+\t\t      &err); /* int *err*/\n+    if (errmsg)\n+      {\n+\tadd_error (NULL, \"error invoking gcc driver: %s\", errmsg);\n+\treturn NULL;\n+      }\n+\n+    /* pex_one can return a NULL errmsg when the executable wasn't\n+       found (or doesn't exist), so trap these cases also.  */\n+    if (exit_status || err)\n+      {\n+\tadd_error (NULL,\n+\t\t   \"error invoking gcc driver: exit_status: %i err: %i\",\n+\t\t   exit_status, err);\n+\tadd_error (NULL,\n+\t\t   \"whilst attempting to run a driver named: %s\",\n+\t\t   gcc_driver_name);\n+\tadd_error (NULL,\n+\t\t   \"PATH was: %s\",\n+\t\t   getenv (\"PATH\"));\n+\treturn NULL;\n+      }\n+  }\n+\n+  // TODO: split out assembles vs linker\n+\n+  /* dlopen the .so file. */\n+  {\n+    auto_timevar load_timevar (TV_LOAD);\n+\n+    const char *error;\n+\n+    /* Clear any existing error.  */\n+    dlerror ();\n+\n+    handle = dlopen (m_path_so_file, RTLD_NOW | RTLD_LOCAL);\n+    if ((error = dlerror()) != NULL)  {\n+      add_error (NULL, \"%s\", error);\n+    }\n+    if (handle)\n+      result_obj = new result (handle);\n+    else\n+      result_obj = NULL;\n+  }\n+\n+  return result_obj;\n+}\n+\n+/* Top-level hook for playing back a recording context.\n+\n+   This plays back m_recording_ctxt, and, if no errors\n+   occurred builds statement lists for and then postprocesses\n+   every function in the result.  */\n+\n+void\n+playback::context::\n+replay ()\n+{\n+  /* Adapted from c-common.c:c_common_nodes_and_builtins.  */\n+  tree array_domain_type = build_index_type (size_int (200));\n+  m_char_array_type_node\n+    = build_array_type (char_type_node, array_domain_type);\n+\n+  m_const_char_ptr\n+    = build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST));\n+\n+  /* Replay the recorded events:  */\n+  timevar_push (TV_JIT_REPLAY);\n+\n+  m_recording_ctxt->replay_into (this);\n+\n+  /* Clean away the temporary references from recording objects\n+     to playback objects.  We have to do this now since the\n+     latter are GC-allocated, but the former don't mark these\n+     refs.  Hence we must stop using them before the GC can run.  */\n+  m_recording_ctxt->disassociate_from_playback ();\n+\n+  timevar_pop (TV_JIT_REPLAY);\n+\n+  if (!errors_occurred ())\n+    {\n+      int i;\n+      function *func;\n+\n+      /* No GC can happen yet; process the cached source locations.  */\n+      handle_locations ();\n+\n+      /* We've now created tree nodes for the stmts in the various blocks\n+\t in each function, but we haven't built each function's single stmt\n+\t list yet.  Do so now.  */\n+      FOR_EACH_VEC_ELT (m_functions, i, func)\n+\tfunc->build_stmt_list ();\n+\n+      /* No GC can have happened yet.  */\n+\n+      /* Postprocess the functions.  This could trigger GC.  */\n+      FOR_EACH_VEC_ELT (m_functions, i, func)\n+\t{\n+\t  gcc_assert (func);\n+\t  func->postprocess ();\n+\t}\n+    }\n+}\n+\n+/* Dump the generated .s file to stderr.  */\n+\n+void\n+playback::context::\n+dump_generated_code ()\n+{\n+  char buf[4096];\n+  size_t sz;\n+  FILE *f_in = fopen (m_path_s_file, \"r\");\n+  if (!f_in)\n+    return;\n+\n+  while ( (sz = fread (buf, 1, sizeof (buf), f_in)) )\n+    fwrite (buf, 1, sz, stderr);\n+\n+  fclose (f_in);\n+}\n+\n+/* qsort comparator for comparing pairs of playback::source_line *,\n+   ordering them by line number.  */\n+\n+static int\n+line_comparator (const void *lhs, const void *rhs)\n+{\n+  const playback::source_line *line_lhs = \\\n+    *static_cast<const playback::source_line * const*> (lhs);\n+  const playback::source_line *line_rhs = \\\n+    *static_cast<const playback::source_line * const*> (rhs);\n+  return line_lhs->get_line_num () - line_rhs->get_line_num ();\n+}\n+\n+/* qsort comparator for comparing pairs of playback::location *,\n+   ordering them by column number.  */\n+\n+static int\n+location_comparator (const void *lhs, const void *rhs)\n+{\n+  const playback::location *loc_lhs = \\\n+    *static_cast<const playback::location * const *> (lhs);\n+  const playback::location *loc_rhs = \\\n+    *static_cast<const playback::location * const *> (rhs);\n+  return loc_lhs->get_column_num () - loc_rhs->get_column_num ();\n+}\n+\n+/* Our API allows locations to be created in arbitrary orders, but the\n+   linemap API requires locations to be created in ascending order\n+   as if we were tokenizing files.\n+\n+   This hook sorts all of the the locations that have been created, and\n+   calls into the linemap API, creating linemap entries in sorted order\n+   for our locations.  */\n+\n+void\n+playback::context::\n+handle_locations ()\n+{\n+  /* Create the source code locations, following the ordering rules\n+     imposed by the linemap API.\n+\n+     line_table is a global.  */\n+  int i;\n+  source_file *file;\n+\n+  FOR_EACH_VEC_ELT (m_source_files, i, file)\n+    {\n+      linemap_add (line_table, LC_ENTER, false, file->get_filename (), 0);\n+\n+      /* Sort lines by ascending line numbers.  */\n+      file->m_source_lines.qsort (&line_comparator);\n+\n+      int j;\n+      source_line *line;\n+      FOR_EACH_VEC_ELT (file->m_source_lines, j, line)\n+\t{\n+\t  int k;\n+\t  location *loc;\n+\n+\t  /* Sort locations in line by ascending column numbers.  */\n+\t  line->m_locations.qsort (&location_comparator);\n+\n+\t  /* Determine maximum column within this line.  */\n+\t  gcc_assert (line->m_locations.length () > 0);\n+\t  location *final_column =\n+\t    line->m_locations[line->m_locations.length () - 1];\n+\t  int max_col = final_column->get_column_num ();\n+\n+\t  linemap_line_start (line_table, line->get_line_num (), max_col);\n+\t  FOR_EACH_VEC_ELT (line->m_locations, k, loc)\n+\t    {\n+\t      loc->m_srcloc =\t\t\t\t\t   \\\n+\t\tlinemap_position_for_column (line_table, loc->get_column_num ());\n+\t    }\n+\t}\n+\n+      linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+    }\n+\n+  /* line_table should now be populated; every playback::location should\n+     now have an m_srcloc.  */\n+\n+  /* Now assign them to tree nodes as appropriate.  */\n+  std::pair<tree, location *> *cached_location;\n+\n+  FOR_EACH_VEC_ELT (m_cached_locations, i, cached_location)\n+    {\n+      tree t = cached_location->first;\n+      source_location srcloc = cached_location->second->m_srcloc;\n+\n+      /* This covers expressions: */\n+      if (CAN_HAVE_LOCATION_P (t))\n+\tSET_EXPR_LOCATION (t, srcloc);\n+      else if (CODE_CONTAINS_STRUCT(TREE_CODE(t), TS_DECL_MINIMAL))\n+\tDECL_SOURCE_LOCATION (t) = srcloc;\n+      else\n+\t{\n+\t  /* Don't know how to set location on this node.  */\n+\t}\n+    }\n+}\n+\n+/* We handle errors on a playback::context by adding them to the\n+   corresponding recording::context.  */\n+\n+void\n+playback::context::\n+add_error (location *loc, const char *fmt, ...)\n+{\n+  va_list ap;\n+  va_start (ap, fmt);\n+  m_recording_ctxt->add_error_va (loc ? loc->get_recording_loc () : NULL,\n+\t\t\t\t  fmt, ap);\n+  va_end (ap);\n+}\n+\n+/* We handle errors on a playback::context by adding them to the\n+   corresponding recording::context.  */\n+\n+void\n+playback::context::\n+add_error_va (location *loc, const char *fmt, va_list ap)\n+{\n+  m_recording_ctxt->add_error_va (loc ? loc->get_recording_loc () : NULL,\n+\t\t\t\t  fmt, ap);\n+}\n+\n+/* Constructor for gcc::jit::playback::result.  */\n+\n+result::\n+result(void *dso_handle)\n+  : m_dso_handle(dso_handle)\n+{\n+}\n+\n+/* gcc::jit::playback::result's destructor.\n+\n+   Called implicitly by gcc_jit_result_release.  */\n+\n+result::~result()\n+{\n+  dlclose (m_dso_handle);\n+}\n+\n+/* Attempt to locate the given function by name within the\n+   playback::result, using dlsym.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_result_get_code.  */\n+\n+void *\n+result::\n+get_code (const char *funcname)\n+{\n+  void *code;\n+  const char *error;\n+\n+  /* Clear any existing error.  */\n+  dlerror ();\n+\n+  code = dlsym (m_dso_handle, funcname);\n+\n+  if ((error = dlerror()) != NULL)  {\n+    fprintf(stderr, \"%s\\n\", error);\n+  }\n+\n+  return code;\n+}\n+\n+/* Dealing with the linemap API.  */\n+\n+/* Construct a playback::location for a recording::location, if it\n+   doesn't exist already.  */\n+\n+playback::location *\n+playback::context::\n+new_location (recording::location *rloc,\n+\t      const char *filename,\n+\t      int line,\n+\t      int column)\n+{\n+  /* Get the source_file for filename, creating if necessary.  */\n+  source_file *src_file = get_source_file (filename);\n+  /* Likewise for the line within the file.  */\n+  source_line *src_line = src_file->get_source_line (line);\n+  /* Likewise for the column within the line.  */\n+  location *loc = src_line->get_location (rloc, column);\n+  return loc;\n+}\n+\n+/* Deferred setting of the location for a given tree, by adding the\n+   (tree, playback::location) pair to a list of deferred associations.\n+   We will actually set the location on the tree later on once\n+   the source_location for the playback::location exists.  */\n+\n+void\n+playback::context::\n+set_tree_location (tree t, location *loc)\n+{\n+  gcc_assert (loc);\n+  m_cached_locations.safe_push (std::make_pair (t, loc));\n+}\n+\n+\n+/* Construct a playback::source_file for the given source\n+   filename, if it doesn't exist already.  */\n+\n+playback::source_file *\n+playback::context::\n+get_source_file (const char *filename)\n+{\n+  /* Locate the file.\n+     For simplicitly, this is currently a linear search.\n+     Replace with a hash if this shows up in the profile.  */\n+  int i;\n+  source_file *file;\n+  tree ident_filename = get_identifier (filename);\n+\n+  FOR_EACH_VEC_ELT (m_source_files, i, file)\n+    if (file->filename_as_tree () == ident_filename)\n+      return file;\n+\n+  /* Not found.  */\n+  file = new source_file (ident_filename);\n+  m_source_files.safe_push (file);\n+  return file;\n+}\n+\n+/* Constructor for gcc::jit::playback::source_file.  */\n+\n+playback::source_file::source_file (tree filename) :\n+  m_source_lines (),\n+  m_filename (filename)\n+{\n+}\n+\n+/* Construct a playback::source_line for the given line\n+   within this source file, if one doesn't exist already.  */\n+\n+playback::source_line *\n+playback::source_file::\n+get_source_line (int line_num)\n+{\n+  /* Locate the line.\n+     For simplicitly, this is currently a linear search.\n+     Replace with a hash if this shows up in the profile.  */\n+  int i;\n+  source_line *line;\n+\n+  FOR_EACH_VEC_ELT (m_source_lines, i, line)\n+    if (line->get_line_num () == line_num)\n+      return line;\n+\n+  /* Not found.  */\n+  line = new source_line (this, line_num);\n+  m_source_lines.safe_push (line);\n+  return line;\n+}\n+\n+/* Constructor for gcc::jit::playback::source_line.  */\n+\n+playback::source_line::source_line (source_file *file, int line_num) :\n+  m_locations (),\n+  m_source_file (file),\n+  m_line_num (line_num)\n+{\n+}\n+\n+/* Construct a playback::location for the given column\n+   within this line of a specific source file, if one doesn't exist\n+   already.  */\n+\n+playback::location *\n+playback::source_line::\n+get_location (recording::location *rloc, int column_num)\n+{\n+  int i;\n+  location *loc;\n+\n+  /* Another linear search that probably should be a hash table.  */\n+  FOR_EACH_VEC_ELT (m_locations, i, loc)\n+    if (loc->get_column_num () == column_num)\n+      return loc;\n+\n+  /* Not found.  */\n+  loc = new location (rloc, this, column_num);\n+  m_locations.safe_push (loc);\n+  return loc;\n+}\n+\n+/* Constructor for gcc::jit::playback::location.  */\n+\n+playback::location::location (recording::location *loc,\n+\t\t\t      source_line *line,\n+\t\t\t      int column_num) :\n+  m_srcloc (UNKNOWN_LOCATION),\n+  m_recording_loc (loc),\n+  m_line (line),\n+  m_column_num(column_num)\n+{\n+}\n+\n+/* The active gcc::jit::playback::context instance.  This is a singleton,\n+   guarded by jit_mutex.  */\n+\n+playback::context *active_playback_ctxt;\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc"}, {"sha": "dcb19bf6d4b1c48d86d835dbc35b189b8c3739a2", "filename": "gcc/jit/jit-playback.h", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,564 @@\n+/* Internals of libgccjit: classes for playing back recorded API calls.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef JIT_PLAYBACK_H\n+#define JIT_PLAYBACK_H\n+\n+#include <utility> // for std::pair\n+\n+#include \"jit-recording.h\"\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+/**********************************************************************\n+ Playback.\n+ **********************************************************************/\n+\n+namespace playback {\n+\n+class context\n+{\n+public:\n+  context (::gcc::jit::recording::context *ctxt);\n+  ~context ();\n+\n+  void gt_ggc_mx ();\n+\n+  void replay ();\n+\n+  location *\n+  new_location (recording::location *rloc,\n+\t\tconst char *filename,\n+\t\tint line,\n+\t\tint column);\n+\n+  type *\n+  get_type (enum gcc_jit_types type);\n+\n+  type *\n+  new_array_type (location *loc,\n+\t\t  type *element_type,\n+\t\t  int num_elements);\n+\n+  field *\n+  new_field (location *loc,\n+\t     type *type,\n+\t     const char *name);\n+\n+  compound_type *\n+  new_compound_type (location *loc,\n+\t\t     const char *name,\n+\t\t     bool is_struct); /* else is union */\n+\n+  type *\n+  new_function_type (type *return_type,\n+\t\t     vec<type *> *param_types,\n+\t\t     int is_variadic);\n+\n+  param *\n+  new_param (location *loc,\n+\t     type *type,\n+\t     const char *name);\n+\n+  function *\n+  new_function (location *loc,\n+\t\tenum gcc_jit_function_kind kind,\n+\t\ttype *return_type,\n+\t\tconst char *name,\n+\t\tvec<param *> *params,\n+\t\tint is_variadic,\n+\t\tenum built_in_function builtin_id);\n+\n+  lvalue *\n+  new_global (location *loc,\n+\t      type *type,\n+\t      const char *name);\n+\n+  rvalue *\n+  new_rvalue_from_int (type *type,\n+\t\t       int value);\n+\n+  rvalue *\n+  new_rvalue_from_double (type *type,\n+\t\t\t  double value);\n+\n+  rvalue *\n+  new_rvalue_from_ptr (type *type,\n+\t\t       void *value);\n+\n+  rvalue *\n+  new_string_literal (const char *value);\n+\n+  rvalue *\n+  new_unary_op (location *loc,\n+\t\tenum gcc_jit_unary_op op,\n+\t\ttype *result_type,\n+\t\trvalue *a);\n+\n+  rvalue *\n+  new_binary_op (location *loc,\n+\t\t enum gcc_jit_binary_op op,\n+\t\t type *result_type,\n+\t\t rvalue *a, rvalue *b);\n+\n+  rvalue *\n+  new_comparison (location *loc,\n+\t\t  enum gcc_jit_comparison op,\n+\t\t  rvalue *a, rvalue *b);\n+\n+  rvalue *\n+  new_call (location *loc,\n+\t    function *func,\n+\t    vec<rvalue *> args);\n+\n+  rvalue *\n+  new_call_through_ptr (location *loc,\n+\t\t\trvalue *fn_ptr,\n+\t\t\tvec<rvalue *> args);\n+\n+  rvalue *\n+  new_cast (location *loc,\n+\t    rvalue *expr,\n+\t    type *type_);\n+\n+  lvalue *\n+  new_array_access (location *loc,\n+\t\t    rvalue *ptr,\n+\t\t    rvalue *index);\n+\n+  void\n+  set_str_option (enum gcc_jit_str_option opt,\n+\t\t  const char *value);\n+\n+  void\n+  set_int_option (enum gcc_jit_int_option opt,\n+\t\t  int value);\n+\n+  void\n+  set_bool_option (enum gcc_jit_bool_option opt,\n+\t\t   int value);\n+\n+  const char *\n+  get_str_option (enum gcc_jit_str_option opt) const\n+  {\n+    return m_recording_ctxt->get_str_option (opt);\n+  }\n+\n+  int\n+  get_int_option (enum gcc_jit_int_option opt) const\n+  {\n+    return m_recording_ctxt->get_int_option (opt);\n+  }\n+\n+  int\n+  get_bool_option (enum gcc_jit_bool_option opt) const\n+  {\n+    return m_recording_ctxt->get_bool_option (opt);\n+  }\n+\n+  result *\n+  compile ();\n+\n+  void\n+  add_error (location *loc, const char *fmt, ...)\n+      GNU_PRINTF(3, 4);\n+\n+  void\n+  add_error_va (location *loc, const char *fmt, va_list ap)\n+      GNU_PRINTF(3, 0);\n+\n+  const char *\n+  get_first_error () const;\n+\n+  void\n+  set_tree_location (tree t, location *loc);\n+\n+  tree\n+  new_field_access (location *loc,\n+\t\t    tree datum,\n+\t\t    field *field);\n+\n+  tree\n+  new_dereference (tree ptr, location *loc);\n+\n+  tree\n+  as_truth_value (tree expr, location *loc);\n+\n+  bool errors_occurred () const\n+  {\n+    return m_recording_ctxt->errors_occurred ();\n+  }\n+\n+private:\n+  void dump_generated_code ();\n+\n+  rvalue *\n+  build_call (location *loc,\n+\t      tree fn_ptr,\n+\t      vec<rvalue *> args);\n+\n+  tree\n+  build_cast (location *loc,\n+\t      rvalue *expr,\n+\t      type *type_);\n+\n+  source_file *\n+  get_source_file (const char *filename);\n+\n+  void handle_locations ();\n+\n+private:\n+  ::gcc::jit::recording::context *m_recording_ctxt;\n+\n+  /* Allocated using xmalloc (by xstrdup).  */\n+  char *m_path_template;\n+\n+  /* This either aliases m_path_template, or is NULL.  */\n+  char *m_path_tempdir;\n+\n+  /* The following are allocated using xmalloc.  */\n+  char *m_path_c_file;\n+  char *m_path_s_file;\n+  char *m_path_so_file;\n+\n+  vec<function *> m_functions;\n+  tree m_char_array_type_node;\n+  tree m_const_char_ptr;\n+\n+  /* Source location handling.  */\n+  vec<source_file *> m_source_files;\n+\n+  vec<std::pair<tree, location *> > m_cached_locations;\n+};\n+\n+/* A temporary wrapper object.\n+   These objects are (mostly) only valid during replay.\n+   We allocate them on the GC heap, so that they will be cleaned\n+   the next time the GC collects.\n+   The exception is the \"function\" class, which is tracked and marked by\n+   the jit::context, since it needs to stay alive during post-processing\n+   (when the GC could run). */\n+class wrapper\n+{\n+public:\n+  /* Allocate in the GC heap.  */\n+  void *operator new (size_t sz);\n+\n+};\n+\n+class type : public wrapper\n+{\n+public:\n+  type (tree inner)\n+    : m_inner(inner)\n+  {}\n+\n+  tree as_tree () const { return m_inner; }\n+\n+  type *get_pointer () const { return new type (build_pointer_type (m_inner)); }\n+\n+  type *get_const () const\n+  {\n+    return new type (build_qualified_type (m_inner, TYPE_QUAL_CONST));\n+  }\n+\n+  type *get_volatile () const\n+  {\n+    return new type (build_qualified_type (m_inner, TYPE_QUAL_VOLATILE));\n+  }\n+\n+private:\n+  tree m_inner;\n+};\n+\n+class compound_type : public type\n+{\n+public:\n+  compound_type (tree inner)\n+    : type (inner)\n+  {}\n+\n+  void set_fields (const vec<field *> &fields);\n+};\n+\n+class field : public wrapper\n+{\n+public:\n+  field (tree inner)\n+    : m_inner(inner)\n+  {}\n+\n+  tree as_tree () const { return m_inner; }\n+\n+private:\n+  tree m_inner;\n+};\n+\n+class function : public wrapper\n+{\n+public:\n+  function(context *ctxt, tree fndecl, enum gcc_jit_function_kind kind);\n+\n+  void gt_ggc_mx ();\n+\n+  tree get_return_type_as_tree () const;\n+\n+  tree as_fndecl () const { return m_inner_fndecl; }\n+\n+  enum gcc_jit_function_kind get_kind () const { return m_kind; }\n+\n+  lvalue *\n+  new_local (location *loc,\n+\t     type *type,\n+\t     const char *name);\n+\n+  block*\n+  new_block (const char *name);\n+\n+  void\n+  build_stmt_list ();\n+\n+  void\n+  postprocess ();\n+\n+public:\n+  context *m_ctxt;\n+\n+public:\n+  void\n+  set_tree_location (tree t, location *loc)\n+  {\n+    m_ctxt->set_tree_location (t, loc);\n+  }\n+\n+private:\n+  tree m_inner_fndecl;\n+  tree m_inner_block;\n+  tree m_inner_bind_expr;\n+  enum gcc_jit_function_kind m_kind;\n+  tree m_stmt_list;\n+  tree_stmt_iterator m_stmt_iter;\n+  vec<block *> m_blocks;\n+};\n+\n+class block : public wrapper\n+{\n+public:\n+  block (function *func,\n+\t const char *name);\n+\n+  tree as_label_decl () const { return m_label_decl; }\n+\n+  void\n+  add_eval (location *loc,\n+\t    rvalue *rvalue);\n+\n+  void\n+  add_assignment (location *loc,\n+\t\t  lvalue *lvalue,\n+\t\t  rvalue *rvalue);\n+\n+  void\n+  add_comment (location *loc,\n+\t       const char *text);\n+\n+  void\n+  add_conditional (location *loc,\n+\t\t   rvalue *boolval,\n+\t\t   block *on_true,\n+\t\t   block *on_false);\n+\n+  block *\n+  add_block (location *loc,\n+\t     const char *name);\n+\n+  void\n+  add_jump (location *loc,\n+\t    block *target);\n+\n+  void\n+  add_return (location *loc,\n+\t      rvalue *rvalue);\n+\n+private:\n+  void\n+  set_tree_location (tree t, location *loc)\n+  {\n+    m_func->set_tree_location (t, loc);\n+  }\n+\n+  void add_stmt (tree stmt)\n+  {\n+    /* TODO: use one stmt_list per block.  */\n+    m_stmts.safe_push (stmt);\n+  }\n+\n+private:\n+  function *m_func;\n+  tree m_label_decl;\n+  vec<tree> m_stmts;\n+\n+public: // for now\n+  tree m_label_expr;\n+\n+  friend class function;\n+};\n+\n+class rvalue : public wrapper\n+{\n+public:\n+  rvalue (context *ctxt, tree inner)\n+    : m_ctxt (ctxt),\n+      m_inner (inner)\n+  {}\n+\n+  rvalue *\n+  as_rvalue () { return this; }\n+\n+  tree as_tree () const { return m_inner; }\n+\n+  context *get_context () const { return m_ctxt; }\n+\n+  type *\n+  get_type () { return new type (TREE_TYPE (m_inner)); }\n+\n+  rvalue *\n+  access_field (location *loc,\n+\t\tfield *field);\n+\n+  lvalue *\n+  dereference_field (location *loc,\n+\t\t     field *field);\n+\n+  lvalue *\n+  dereference (location *loc);\n+\n+private:\n+  context *m_ctxt;\n+  tree m_inner;\n+};\n+\n+class lvalue : public rvalue\n+{\n+public:\n+  lvalue (context *ctxt, tree inner)\n+    : rvalue(ctxt, inner)\n+  {}\n+\n+  lvalue *\n+  as_lvalue () { return this; }\n+\n+  lvalue *\n+  access_field (location *loc,\n+\t\tfield *field);\n+\n+  rvalue *\n+  get_address (location *loc);\n+\n+};\n+\n+class param : public lvalue\n+{\n+public:\n+  param (context *ctxt, tree inner)\n+    : lvalue(ctxt, inner)\n+  {}\n+};\n+\n+/* Dealing with the linemap API.\n+\n+   It appears that libcpp requires locations to be created as if by\n+   a tokenizer, creating them by filename, in ascending order of\n+   line/column, whereas our API doesn't impose any such constraints:\n+   we allow client code to create locations in arbitrary orders.\n+\n+   To square this circle, we need to cache all location creation,\n+   grouping things up by filename/line, and then creating the linemap\n+   entries in a post-processing phase.  */\n+\n+/* A set of locations, all sharing a filename */\n+class source_file : public wrapper\n+{\n+public:\n+  source_file (tree filename);\n+\n+  source_line *\n+  get_source_line (int line_num);\n+\n+  tree filename_as_tree () const { return m_filename; }\n+\n+  const char*\n+  get_filename () const { return IDENTIFIER_POINTER (m_filename); }\n+\n+  vec<source_line *> m_source_lines;\n+\n+private:\n+  tree m_filename;\n+};\n+\n+/* A source line, with one or more locations of interest.  */\n+class source_line : public wrapper\n+{\n+public:\n+  source_line (source_file *file, int line_num);\n+\n+  location *\n+  get_location (recording::location *rloc, int column_num);\n+\n+  int get_line_num () const { return m_line_num; }\n+\n+  vec<location *> m_locations;\n+\n+private:\n+  source_file *m_source_file;\n+  int m_line_num;\n+};\n+\n+/* A specific location on a source line.  This is what we expose\n+   to the client API.  */\n+class location : public wrapper\n+{\n+public:\n+  location (recording::location *loc, source_line *line, int column_num);\n+\n+  int get_column_num () const { return m_column_num; }\n+\n+  recording::location *get_recording_loc () const { return m_recording_loc; }\n+\n+  source_location m_srcloc;\n+\n+private:\n+  recording::location *m_recording_loc;\n+  source_line *m_line;\n+  int m_column_num;\n+};\n+\n+} // namespace gcc::jit::playback\n+\n+extern playback::context *active_playback_ctxt;\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc\n+\n+#endif /* JIT_PLAYBACK_H */\n+"}, {"sha": "8daa8f2e49c9f13529cfe9cdd9e3540f9246c31d", "filename": "gcc/jit/jit-recording.c", "status": "added", "additions": 3434, "deletions": 0, "changes": 3434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "bb1a2eedf900ba99ab7028ac280154dbbc64d985", "filename": "gcc/jit/jit-recording.h", "status": "added", "additions": 1593, "deletions": 0, "changes": 1593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,1593 @@\n+/* Internals of libgccjit: classes for recording calls made to the JIT API.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef JIT_RECORDING_H\n+#define JIT_RECORDING_H\n+\n+#include \"jit-common.h\"\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+class result;\n+class dump;\n+\n+/**********************************************************************\n+ Recording.\n+ **********************************************************************/\n+\n+namespace recording {\n+\n+playback::location *\n+playback_location (replayer *r, location *loc);\n+\n+const char *\n+playback_string (string *str);\n+\n+playback::block *\n+playback_block (block *b);\n+\n+/* A JIT-compilation context.  */\n+class context\n+{\n+public:\n+  context (context *parent_ctxt);\n+  ~context ();\n+\n+  void record (memento *m);\n+  void replay_into (replayer *r);\n+  void disassociate_from_playback ();\n+\n+  string *\n+  new_string (const char *text);\n+\n+  location *\n+  new_location (const char *filename,\n+\t\tint line,\n+\t\tint column);\n+\n+  type *\n+  get_type (enum gcc_jit_types type);\n+\n+  type *\n+  get_int_type (int num_bytes, int is_signed);\n+\n+  type *\n+  new_array_type (location *loc,\n+\t\t  type *element_type,\n+\t\t  int num_elements);\n+\n+  field *\n+  new_field (location *loc,\n+\t     type *type,\n+\t     const char *name);\n+\n+  struct_ *\n+  new_struct_type (location *loc,\n+\t\t   const char *name);\n+\n+  union_ *\n+  new_union_type (location *loc,\n+\t\t  const char *name);\n+\n+  type *\n+  new_function_ptr_type (location *loc,\n+\t\t\t type *return_type,\n+\t\t\t int num_params,\n+\t\t\t type **param_types,\n+\t\t\t int is_variadic);\n+\n+  param *\n+  new_param (location *loc,\n+\t     type *type,\n+\t     const char *name);\n+\n+  function *\n+  new_function (location *loc,\n+\t\tenum gcc_jit_function_kind kind,\n+\t\ttype *return_type,\n+\t\tconst char *name,\n+\t\tint num_params,\n+\t\tparam **params,\n+\t\tint is_variadic,\n+\t\tenum built_in_function builtin_id);\n+\n+  function *\n+  get_builtin_function (const char *name);\n+\n+  lvalue *\n+  new_global (location *loc,\n+\t      type *type,\n+\t      const char *name);\n+\n+  rvalue *\n+  new_rvalue_from_int (type *numeric_type,\n+\t\t       int value);\n+\n+  rvalue *\n+  new_rvalue_from_double (type *numeric_type,\n+\t\t\t  double value);\n+\n+  rvalue *\n+  new_rvalue_from_ptr (type *pointer_type,\n+\t\t       void *value);\n+\n+  rvalue *\n+  new_string_literal (const char *value);\n+\n+  rvalue *\n+  new_unary_op (location *loc,\n+\t\tenum gcc_jit_unary_op op,\n+\t\ttype *result_type,\n+\t\trvalue *a);\n+\n+  rvalue *\n+  new_binary_op (location *loc,\n+\t\t enum gcc_jit_binary_op op,\n+\t\t type *result_type,\n+\t\t rvalue *a, rvalue *b);\n+\n+  rvalue *\n+  new_comparison (location *loc,\n+\t\t  enum gcc_jit_comparison op,\n+\t\t  rvalue *a, rvalue *b);\n+\n+  rvalue *\n+  new_call (location *loc,\n+\t    function *func,\n+\t    int numargs, rvalue **args);\n+\n+  rvalue *\n+  new_call_through_ptr (location *loc,\n+\t\t\trvalue *fn_ptr,\n+\t\t\tint numargs, rvalue **args);\n+\n+  rvalue *\n+  new_cast (location *loc,\n+\t    rvalue *expr,\n+\t    type *type_);\n+\n+  lvalue *\n+  new_array_access (location *loc,\n+\t\t    rvalue *ptr,\n+\t\t    rvalue *index);\n+\n+  void\n+  set_str_option (enum gcc_jit_str_option opt,\n+\t\t  const char *value);\n+\n+  void\n+  set_int_option (enum gcc_jit_int_option opt,\n+\t\t  int value);\n+\n+  void\n+  set_bool_option (enum gcc_jit_bool_option opt,\n+\t\t   int value);\n+\n+  const char *\n+  get_str_option (enum gcc_jit_str_option opt) const\n+  {\n+    return m_str_options[opt];\n+  }\n+\n+  int\n+  get_int_option (enum gcc_jit_int_option opt) const\n+  {\n+    return m_int_options[opt];\n+  }\n+\n+  int\n+  get_bool_option (enum gcc_jit_bool_option opt) const\n+  {\n+    return m_bool_options[opt];\n+  }\n+\n+  result *\n+  compile ();\n+\n+  void\n+  add_error (location *loc, const char *fmt, ...)\n+      GNU_PRINTF(3, 4);\n+\n+  void\n+  add_error_va (location *loc, const char *fmt, va_list ap)\n+      GNU_PRINTF(3, 0);\n+\n+  const char *\n+  get_first_error () const;\n+\n+  bool errors_occurred () const\n+  {\n+    if (m_parent_ctxt)\n+      if (m_parent_ctxt->errors_occurred ())\n+\treturn true;\n+    return m_error_count;\n+  }\n+\n+  type *get_opaque_FILE_type ();\n+\n+  void dump_to_file (const char *path, bool update_locations);\n+\n+private:\n+  void validate ();\n+\n+private:\n+  context *m_parent_ctxt;\n+\n+  int m_error_count;\n+\n+  char *m_first_error_str;\n+  bool m_owns_first_error_str;\n+\n+  const char *m_str_options[GCC_JIT_NUM_STR_OPTIONS];\n+  int m_int_options[GCC_JIT_NUM_INT_OPTIONS];\n+  bool m_bool_options[GCC_JIT_NUM_BOOL_OPTIONS];\n+\n+  /* Recorded API usage.  */\n+  vec<memento *> m_mementos;\n+\n+  /* Specific recordings, for use by dump_to_file.  */\n+  vec<compound_type *> m_compound_types;\n+  vec<function *> m_functions;\n+\n+  type *m_basic_types[NUM_GCC_JIT_TYPES];\n+  type *m_FILE_type;\n+\n+  builtins_manager *m_builtins_manager; // lazily created\n+};\n+\n+\n+/* An object with lifetime managed by the context i.e.\n+   it lives until the context is released, at which\n+   point it itself is cleaned up.  */\n+\n+class memento\n+{\n+public:\n+  virtual ~memento () {}\n+\n+  /* Hook for replaying this.  */\n+  virtual void replay_into (replayer *r) = 0;\n+\n+  void set_playback_obj (void *obj) { m_playback_obj = obj; }\n+\n+\n+  /* Get the context that owns this object.\n+\n+     Implements the post-error-checking part of\n+     gcc_jit_object_get_context.  */\n+  context *get_context () { return m_ctxt; }\n+\n+  memento *\n+  as_object () { return this; }\n+\n+  /* Debugging hook, for use in generating error messages etc.\n+     Implements the post-error-checking part of\n+     gcc_jit_object_get_debug_string.  */\n+  const char *\n+  get_debug_string ();\n+\n+  virtual void write_to_dump (dump &d);\n+\n+protected:\n+  memento (context *ctxt)\n+  : m_ctxt (ctxt),\n+    m_playback_obj (NULL),\n+    m_debug_string (NULL)\n+  {\n+    gcc_assert (ctxt);\n+  }\n+\n+  string *new_string (const char *text) { return m_ctxt->new_string (text); }\n+\n+private:\n+  virtual string * make_debug_string () = 0;\n+\n+public:\n+  context *m_ctxt;\n+\n+protected:\n+  void *m_playback_obj;\n+\n+private:\n+  string *m_debug_string;\n+};\n+\n+/* or just use std::string? */\n+class string : public memento\n+{\n+public:\n+  string (context *ctxt, const char *text);\n+  ~string ();\n+\n+  const char *c_str () { return m_buffer; }\n+\n+  static string * from_printf (context *ctxt, const char *fmt, ...)\n+    GNU_PRINTF(2, 3);\n+\n+  void replay_into (replayer *) {}\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  size_t m_len;\n+  char *m_buffer;\n+};\n+\n+class location : public memento\n+{\n+public:\n+  location (context *ctxt, string *filename, int line, int column)\n+  : memento (ctxt),\n+    m_filename (filename),\n+    m_line (line),\n+    m_column (column)\n+ {}\n+\n+  void replay_into (replayer *r);\n+\n+  playback::location *\n+  playback_location (replayer *r)\n+  {\n+    /* Normally during playback, we can walk forwards through the list of\n+       recording objects, playing them back.  The ordering of recording\n+       ensures that everything that a recording object refers to has\n+       already been played back, so we can simply look up the relevant\n+       m_playback_obj.\n+\n+       Locations are an exception, due to the \"write_to_dump\" method of\n+       recording::statement.  This method can set a new location on a\n+       statement after the statement is created, and thus the location\n+       appears in the context's memento list *after* the statement that\n+       refers to it.\n+\n+       In such circumstances, the statement is replayed *before* the location,\n+       when the latter doesn't yet have a playback object.\n+\n+       Hence we need to ensure that locations have playback objects.  */\n+    if (!m_playback_obj)\n+      {\n+\treplay_into (r);\n+      }\n+    gcc_assert (m_playback_obj);\n+    return static_cast <playback::location *> (m_playback_obj);\n+  }\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  string *m_filename;\n+  int m_line;\n+  int m_column;\n+};\n+\n+class type : public memento\n+{\n+public:\n+  type *get_pointer ();\n+  type *get_const ();\n+  type *get_volatile ();\n+\n+  /* Get the type obtained when dereferencing this type.\n+\n+     This will return NULL if it's not valid to dereference this type.\n+     The caller is responsible for setting an error.  */\n+  virtual type *dereference () = 0;\n+\n+  /* Dynamic casts.  */\n+  virtual function_type *dyn_cast_function_type () { return NULL; }\n+  virtual function_type *as_a_function_type() { gcc_unreachable (); return NULL; }\n+  virtual struct_ *dyn_cast_struct () { return NULL; }\n+\n+  /* Is it typesafe to copy to this type from rtype?  */\n+  virtual bool accepts_writes_from (type *rtype)\n+  {\n+    gcc_assert (rtype);\n+    return this == rtype->unqualified ();\n+  }\n+\n+  /* Strip off \"const\" etc */\n+  virtual type *unqualified ()\n+  {\n+    return this;\n+  }\n+\n+  virtual bool is_int () const = 0;\n+  virtual bool is_float () const = 0;\n+  virtual bool is_bool () const = 0;\n+  virtual type *is_pointer () = 0;\n+  virtual type *is_array () = 0;\n+\n+  bool is_numeric () const\n+  {\n+    return is_int () || is_float () || is_bool ();\n+  }\n+\n+  playback::type *\n+  playback_type ()\n+  {\n+    return static_cast <playback::type *> (m_playback_obj);\n+  }\n+\n+protected:\n+  type (context *ctxt)\n+    : memento (ctxt),\n+    m_pointer_to_this_type (NULL)\n+  {}\n+\n+private:\n+  type *m_pointer_to_this_type;\n+};\n+\n+/* Result of \"gcc_jit_type_get_type\".  */\n+class memento_of_get_type : public type\n+{\n+public:\n+  memento_of_get_type (context *ctxt,\n+\t\t       enum gcc_jit_types kind)\n+  : type (ctxt),\n+    m_kind (kind) {}\n+\n+  type *dereference ();\n+\n+  bool accepts_writes_from (type *rtype)\n+  {\n+    if (m_kind == GCC_JIT_TYPE_VOID_PTR)\n+      if (rtype->is_pointer ())\n+\t{\n+\t  /* LHS (this) is type (void *), and the RHS is a pointer:\n+\t     accept it:  */\n+\t  return true;\n+\t}\n+\n+    return type::accepts_writes_from (rtype);\n+  }\n+\n+  bool is_int () const;\n+  bool is_float () const;\n+  bool is_bool () const;\n+  type *is_pointer () { return dereference (); }\n+  type *is_array () { return NULL; }\n+\n+public:\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  enum gcc_jit_types m_kind;\n+};\n+\n+/* Result of \"gcc_jit_type_get_pointer\".  */\n+class memento_of_get_pointer : public type\n+{\n+public:\n+  memento_of_get_pointer (type *other_type)\n+  : type (other_type->m_ctxt),\n+    m_other_type (other_type) {}\n+\n+  type *dereference () { return m_other_type; }\n+\n+  bool accepts_writes_from (type *rtype);\n+\n+  void replay_into (replayer *r);\n+\n+  bool is_int () const { return false; }\n+  bool is_float () const { return false; }\n+  bool is_bool () const { return false; }\n+  type *is_pointer () { return m_other_type; }\n+  type *is_array () { return NULL; }\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  type *m_other_type;\n+};\n+\n+/* Result of \"gcc_jit_type_get_const\".  */\n+class memento_of_get_const : public type\n+{\n+public:\n+  memento_of_get_const (type *other_type)\n+  : type (other_type->m_ctxt),\n+    m_other_type (other_type) {}\n+\n+  type *dereference () { return m_other_type->dereference (); }\n+\n+  bool accepts_writes_from (type */*rtype*/)\n+  {\n+    /* Can't write to a \"const\".  */\n+    return false;\n+  }\n+\n+  /* Strip off the \"const\", giving the underlying type.  */\n+  type *unqualified () { return m_other_type; }\n+\n+  bool is_int () const { return m_other_type->is_int (); }\n+  bool is_float () const { return m_other_type->is_float (); }\n+  bool is_bool () const { return m_other_type->is_bool (); }\n+  type *is_pointer () { return m_other_type->is_pointer (); }\n+  type *is_array () { return m_other_type->is_array (); }\n+\n+  void replay_into (replayer *);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  type *m_other_type;\n+};\n+\n+/* Result of \"gcc_jit_type_get_volatile\".  */\n+class memento_of_get_volatile : public type\n+{\n+public:\n+  memento_of_get_volatile (type *other_type)\n+  : type (other_type->m_ctxt),\n+    m_other_type (other_type) {}\n+\n+  type *dereference () { return m_other_type->dereference (); }\n+\n+  /* Strip off the \"volatile\", giving the underlying type.  */\n+  type *unqualified () { return m_other_type; }\n+\n+  bool is_int () const { return m_other_type->is_int (); }\n+  bool is_float () const { return m_other_type->is_float (); }\n+  bool is_bool () const { return m_other_type->is_bool (); }\n+  type *is_pointer () { return m_other_type->is_pointer (); }\n+  type *is_array () { return m_other_type->is_array (); }\n+\n+  void replay_into (replayer *);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  type *m_other_type;\n+};\n+\n+class array_type : public type\n+{\n+ public:\n+  array_type (context *ctxt,\n+\t      location *loc,\n+\t      type *element_type,\n+\t      int num_elements)\n+  : type (ctxt),\n+    m_loc (loc),\n+    m_element_type (element_type),\n+    m_num_elements (num_elements)\n+  {}\n+\n+  type *dereference ();\n+\n+  bool is_int () const { return false; }\n+  bool is_float () const { return false; }\n+  bool is_bool () const { return false; }\n+  type *is_pointer () { return NULL; }\n+  type *is_array () { return m_element_type; }\n+\n+  void replay_into (replayer *);\n+\n+ private:\n+  string * make_debug_string ();\n+\n+ private:\n+  location *m_loc;\n+  type *m_element_type;\n+  int m_num_elements;\n+};\n+\n+class function_type : public type\n+{\n+public:\n+  function_type (context *ctxt,\n+\t\t type *return_type,\n+\t\t int num_params,\n+\t\t type **param_types,\n+\t\t int is_variadic);\n+\n+  type *dereference ();\n+  function_type *dyn_cast_function_type () { return this; }\n+  function_type *as_a_function_type () { return this; }\n+\n+  bool is_int () const { return false; }\n+  bool is_float () const { return false; }\n+  bool is_bool () const { return false; }\n+  type *is_pointer () { return NULL; }\n+  type *is_array () { return NULL; }\n+\n+  void replay_into (replayer *);\n+\n+  type * get_return_type () const { return m_return_type; }\n+  vec<type *> get_param_types () const { return m_param_types; }\n+  int is_variadic () const { return m_is_variadic; }\n+\n+  string * make_debug_string_with_ptr ();\n+\n+ private:\n+  string * make_debug_string ();\n+  string * make_debug_string_with (const char *);\n+\n+private:\n+  type *m_return_type;\n+  vec<type *> m_param_types;\n+  int m_is_variadic;\n+};\n+\n+class field : public memento\n+{\n+public:\n+  field (context *ctxt,\n+\t location *loc,\n+\t type *type,\n+\t string *name)\n+  : memento (ctxt),\n+    m_loc (loc),\n+    m_type (type),\n+    m_name (name),\n+    m_container (NULL)\n+  {}\n+\n+  type * get_type () const { return m_type; }\n+\n+  compound_type * get_container () const { return m_container; }\n+  void set_container (compound_type *c) { m_container = c; }\n+\n+  void replay_into (replayer *);\n+\n+  void write_to_dump (dump &d);\n+\n+  playback::field *\n+  playback_field () const\n+  {\n+    return static_cast <playback::field *> (m_playback_obj);\n+  }\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  location *m_loc;\n+  type *m_type;\n+  string *m_name;\n+  compound_type *m_container;\n+};\n+\n+/* Base class for struct_ and union_ */\n+class compound_type : public type\n+{\n+public:\n+  compound_type (context *ctxt,\n+\t\t location *loc,\n+\t\t string *name);\n+\n+  string *get_name () const { return m_name; }\n+  location *get_loc () const { return m_loc; }\n+  fields * get_fields () { return m_fields; }\n+\n+  void\n+  set_fields (location *loc,\n+\t      int num_fields,\n+\t      field **fields);\n+\n+  type *dereference ();\n+\n+  bool is_int () const { return false; }\n+  bool is_float () const { return false; }\n+  bool is_bool () const { return false; }\n+  type *is_pointer () { return NULL; }\n+  type *is_array () { return NULL; }\n+\n+  playback::compound_type *\n+  playback_compound_type ()\n+  {\n+    return static_cast <playback::compound_type *> (m_playback_obj);\n+  }\n+\n+private:\n+  location *m_loc;\n+  string *m_name;\n+  fields *m_fields;\n+};\n+\n+class struct_ : public compound_type\n+{\n+public:\n+  struct_ (context *ctxt,\n+\t   location *loc,\n+\t   string *name);\n+\n+  struct_ *dyn_cast_struct () { return this; }\n+\n+  type *\n+  as_type () { return this; }\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+};\n+\n+// memento of struct_::set_fields\n+class fields : public memento\n+{\n+public:\n+  fields (compound_type *struct_or_union,\n+\t  int num_fields,\n+\t  field **fields);\n+\n+  void replay_into (replayer *r);\n+\n+  void write_to_dump (dump &d);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  compound_type *m_struct_or_union;\n+  vec<field *> m_fields;\n+};\n+\n+class union_ : public compound_type\n+{\n+public:\n+  union_ (context *ctxt,\n+\t  location *loc,\n+\t  string *name);\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  location *m_loc;\n+  string *m_name;\n+  fields *m_fields;\n+};\n+\n+class rvalue : public memento\n+{\n+public:\n+  rvalue (context *ctxt,\n+\t  location *loc,\n+\t  type *type_)\n+  : memento (ctxt),\n+    m_loc (loc),\n+    m_type (type_)\n+  {\n+    gcc_assert (type_);\n+  }\n+\n+  /* Get the recording::type of this rvalue.\n+\n+     Implements the post-error-checking part of\n+     gcc_jit_rvalue_get_type.  */\n+  type * get_type () const { return m_type; }\n+\n+  playback::rvalue *\n+  playback_rvalue () const\n+  {\n+    return static_cast <playback::rvalue *> (m_playback_obj);\n+  }\n+  rvalue *\n+  access_field (location *loc,\n+\t\tfield *field);\n+\n+  lvalue *\n+  dereference_field (location *loc,\n+\t\t     field *field);\n+\n+  lvalue *\n+  dereference (location *loc);\n+\n+protected:\n+  location *m_loc;\n+  type *m_type;\n+};\n+\n+class lvalue : public rvalue\n+{\n+public:\n+  lvalue (context *ctxt,\n+\t  location *loc,\n+\t  type *type_)\n+    : rvalue (ctxt, loc, type_)\n+    {}\n+\n+  playback::lvalue *\n+  playback_lvalue () const\n+  {\n+    return static_cast <playback::lvalue *> (m_playback_obj);\n+  }\n+\n+  lvalue *\n+  access_field (location *loc,\n+\t\tfield *field);\n+\n+  rvalue *\n+  get_address (location *loc);\n+\n+  rvalue *\n+  as_rvalue () { return this; }\n+};\n+\n+class param : public lvalue\n+{\n+public:\n+  param (context *ctxt,\n+\t location *loc,\n+\t type *type,\n+\t string *name)\n+    : lvalue (ctxt, loc, type),\n+    m_name (name) {}\n+\n+  lvalue *\n+  as_lvalue () { return this; }\n+\n+  void replay_into (replayer *r);\n+\n+  playback::param *\n+  playback_param () const\n+  {\n+    return static_cast <playback::param *> (m_playback_obj);\n+  }\n+\n+private:\n+  string * make_debug_string () { return m_name; }\n+\n+private:\n+  string *m_name;\n+};\n+\n+class function : public memento\n+{\n+public:\n+  function (context *ctxt,\n+\t    location *loc,\n+\t    enum gcc_jit_function_kind kind,\n+\t    type *return_type,\n+\t    string *name,\n+\t    int num_params,\n+\t    param **params,\n+\t    int is_variadic,\n+\t    enum built_in_function builtin_id);\n+\n+  void replay_into (replayer *r);\n+\n+  playback::function *\n+  playback_function () const\n+  {\n+    return static_cast <playback::function *> (m_playback_obj);\n+  }\n+\n+  enum gcc_jit_function_kind get_kind () const { return m_kind; }\n+\n+  lvalue *\n+  new_local (location *loc,\n+\t     type *type,\n+\t     const char *name);\n+\n+  block*\n+  new_block (const char *name);\n+\n+  type *get_return_type () const { return m_return_type; }\n+  string * get_name () const { return m_name; }\n+  vec<param *> get_params () const { return m_params; }\n+\n+  /* Get the given param by index.\n+     Implements the post-error-checking part of\n+     gcc_jit_function_get_param.  */\n+  param *get_param (int i) const { return m_params[i]; }\n+\n+  bool is_variadic () const { return m_is_variadic; }\n+\n+  void write_to_dump (dump &d);\n+\n+  void validate ();\n+\n+  void dump_to_dot (const char *path);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  location *m_loc;\n+  enum gcc_jit_function_kind m_kind;\n+  type *m_return_type;\n+  string *m_name;\n+  vec<param *> m_params;\n+  int m_is_variadic;\n+  enum built_in_function m_builtin_id;\n+  vec<local *> m_locals;\n+  vec<block *> m_blocks;\n+};\n+\n+class block : public memento\n+{\n+public:\n+  block (function *func, int index, string *name)\n+  : memento (func->m_ctxt),\n+    m_func (func),\n+    m_index (index),\n+    m_name (name),\n+    m_statements (),\n+    m_has_been_terminated (false),\n+    m_is_reachable (false)\n+  {\n+  }\n+\n+  /* Get the recording::function containing this block.\n+     Implements the post-error-checking part of\n+     gcc_jit_block_get_function.  */\n+  function *get_function () { return m_func; }\n+\n+  bool has_been_terminated () { return m_has_been_terminated; }\n+  bool is_reachable () { return m_is_reachable; }\n+\n+  void\n+  add_eval (location *loc,\n+\t    rvalue *rvalue);\n+\n+  void\n+  add_assignment (location *loc,\n+\t\t  lvalue *lvalue,\n+\t\t  rvalue *rvalue);\n+\n+  void\n+  add_assignment_op (location *loc,\n+\t\t     lvalue *lvalue,\n+\t\t     enum gcc_jit_binary_op op,\n+\t\t     rvalue *rvalue);\n+\n+  void\n+  add_comment (location *loc,\n+\t       const char *text);\n+\n+  void\n+  end_with_conditional (location *loc,\n+\t\t\trvalue *boolval,\n+\t\t\tblock *on_true,\n+\t\t\tblock *on_false);\n+\n+  void\n+  end_with_jump (location *loc,\n+\t\t block *target);\n+\n+  void\n+  end_with_return (location *loc,\n+\t\t   rvalue *rvalue);\n+\n+  playback::block *\n+  playback_block () const\n+  {\n+    return static_cast <playback::block *> (m_playback_obj);\n+  }\n+\n+  void write_to_dump (dump &d);\n+\n+  bool validate ();\n+\n+  location *get_loc () const;\n+\n+  statement *get_first_statement () const;\n+  statement *get_last_statement () const;\n+\n+  int get_successor_blocks (block **next1, block **next2) const;\n+\n+private:\n+  string * make_debug_string ();\n+\n+  void replay_into (replayer *r);\n+\n+  void dump_to_dot (pretty_printer *pp);\n+  void dump_edges_to_dot (pretty_printer *pp);\n+\n+private:\n+  function *m_func;\n+  int m_index;\n+  string *m_name;\n+  vec<statement *> m_statements;\n+  bool m_has_been_terminated;\n+  bool m_is_reachable;\n+\n+  friend class function;\n+};\n+\n+class global : public lvalue\n+{\n+public:\n+  global (context *ctxt,\n+\t  location *loc,\n+\t  type *type,\n+\t  string *name)\n+  : lvalue (ctxt, loc, type),\n+    m_name (name)\n+  {}\n+\n+  void replay_into (replayer *);\n+\n+private:\n+  string * make_debug_string () { return m_name; }\n+\n+private:\n+  string *m_name;\n+};\n+\n+class memento_of_new_rvalue_from_int : public rvalue\n+{\n+public:\n+  memento_of_new_rvalue_from_int (context *ctxt,\n+\t\t\t\t  location *loc,\n+\t\t\t\t  type *numeric_type,\n+\t\t\t\t  int value)\n+  : rvalue (ctxt, loc, numeric_type),\n+    m_value (value) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  int m_value;\n+};\n+\n+class memento_of_new_rvalue_from_double : public rvalue\n+{\n+public:\n+  memento_of_new_rvalue_from_double (context *ctxt,\n+\t\t\t\t     location *loc,\n+\t\t\t\t     type *numeric_type,\n+\t\t\t\t     double value)\n+  : rvalue (ctxt, loc, numeric_type),\n+    m_value (value)\n+  {}\n+\n+  void replay_into (replayer *);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  double m_value;\n+};\n+\n+class memento_of_new_rvalue_from_ptr : public rvalue\n+{\n+public:\n+  memento_of_new_rvalue_from_ptr (context *ctxt,\n+\t\t\t\t  location *loc,\n+\t\t\t\t  type *pointer_type,\n+\t\t\t\t  void *value)\n+  : rvalue (ctxt, loc, pointer_type),\n+    m_value (value)\n+  {}\n+\n+  void replay_into (replayer *);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  void *m_value;\n+};\n+\n+class memento_of_new_string_literal : public rvalue\n+{\n+public:\n+  memento_of_new_string_literal (context *ctxt,\n+\t\t\t\t location *loc,\n+\t\t\t\t string *value)\n+  : rvalue (ctxt, loc, ctxt->get_type (GCC_JIT_TYPE_CONST_CHAR_PTR)),\n+    m_value (value) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  string *m_value;\n+};\n+\n+class unary_op : public rvalue\n+{\n+public:\n+  unary_op (context *ctxt,\n+\t    location *loc,\n+\t    enum gcc_jit_unary_op op,\n+\t    type *result_type,\n+\t    rvalue *a)\n+  : rvalue (ctxt, loc, result_type),\n+    m_op (op),\n+    m_a (a)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  enum gcc_jit_unary_op m_op;\n+  rvalue *m_a;\n+};\n+\n+class binary_op : public rvalue\n+{\n+public:\n+  binary_op (context *ctxt,\n+\t     location *loc,\n+\t     enum gcc_jit_binary_op op,\n+\t     type *result_type,\n+\t     rvalue *a, rvalue *b)\n+  : rvalue (ctxt, loc, result_type),\n+    m_op (op),\n+    m_a (a),\n+    m_b (b) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  enum gcc_jit_binary_op m_op;\n+  rvalue *m_a;\n+  rvalue *m_b;\n+};\n+\n+class comparison : public rvalue\n+{\n+public:\n+  comparison (context *ctxt,\n+\t      location *loc,\n+\t      enum gcc_jit_comparison op,\n+\t      rvalue *a, rvalue *b)\n+  : rvalue (ctxt, loc, ctxt->get_type (GCC_JIT_TYPE_BOOL)),\n+    m_op (op),\n+    m_a (a),\n+    m_b (b)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  enum gcc_jit_comparison m_op;\n+  rvalue *m_a;\n+  rvalue *m_b;\n+};\n+\n+class cast : public rvalue\n+{\n+public:\n+  cast (context *ctxt,\n+\tlocation *loc,\n+\trvalue *a,\n+\ttype *type_)\n+  : rvalue (ctxt, loc, type_),\n+    m_rvalue (a)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_rvalue;\n+};\n+\n+class call : public rvalue\n+{\n+public:\n+  call (context *ctxt,\n+\tlocation *loc,\n+\tfunction *func,\n+\tint numargs,\n+\trvalue **args);\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  function *m_func;\n+  vec<rvalue *> m_args;\n+};\n+\n+class call_through_ptr : public rvalue\n+{\n+public:\n+  call_through_ptr (context *ctxt,\n+\t\t    location *loc,\n+\t\t    rvalue *fn_ptr,\n+\t\t    int numargs,\n+\t\t    rvalue **args);\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_fn_ptr;\n+  vec<rvalue *> m_args;\n+};\n+\n+class array_access : public lvalue\n+{\n+public:\n+  array_access (context *ctxt,\n+\t\tlocation *loc,\n+\t\trvalue *ptr,\n+\t\trvalue *index)\n+  : lvalue (ctxt, loc, ptr->get_type ()->dereference ()),\n+    m_ptr (ptr),\n+    m_index (index)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_ptr;\n+  rvalue *m_index;\n+};\n+\n+class access_field_of_lvalue : public lvalue\n+{\n+public:\n+  access_field_of_lvalue (context *ctxt,\n+\t\t\t  location *loc,\n+\t\t\t  lvalue *val,\n+\t\t\t  field *field)\n+  : lvalue (ctxt, loc, field->get_type ()),\n+    m_lvalue (val),\n+    m_field (field)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  lvalue *m_lvalue;\n+  field *m_field;\n+};\n+\n+class access_field_rvalue : public rvalue\n+{\n+public:\n+  access_field_rvalue (context *ctxt,\n+\t\t       location *loc,\n+\t\t       rvalue *val,\n+\t\t       field *field)\n+  : rvalue (ctxt, loc, field->get_type ()),\n+    m_rvalue (val),\n+    m_field (field)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_rvalue;\n+  field *m_field;\n+};\n+\n+class dereference_field_rvalue : public lvalue\n+{\n+public:\n+  dereference_field_rvalue (context *ctxt,\n+\t\t\t    location *loc,\n+\t\t\t    rvalue *val,\n+\t\t\t    field *field)\n+  : lvalue (ctxt, loc, field->get_type ()),\n+    m_rvalue (val),\n+    m_field (field)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_rvalue;\n+  field *m_field;\n+};\n+\n+class dereference_rvalue : public lvalue\n+{\n+public:\n+  dereference_rvalue (context *ctxt,\n+\t\t      location *loc,\n+\t\t      rvalue *val)\n+  : lvalue (ctxt, loc, val->get_type ()->dereference ()),\n+    m_rvalue (val) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_rvalue;\n+};\n+\n+class get_address_of_lvalue : public rvalue\n+{\n+public:\n+  get_address_of_lvalue (context *ctxt,\n+\t\t\t location *loc,\n+\t\t\t lvalue *val)\n+  : rvalue (ctxt, loc, val->get_type ()->get_pointer ()),\n+    m_lvalue (val)\n+  {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  lvalue *m_lvalue;\n+};\n+\n+class local : public lvalue\n+{\n+public:\n+  local (function *func, location *loc, type *type_, string *name)\n+    : lvalue (func->m_ctxt, loc, type_),\n+    m_func (func),\n+    m_name (name) {}\n+\n+  void replay_into (replayer *r);\n+\n+  void write_to_dump (dump &d);\n+\n+private:\n+  string * make_debug_string () { return m_name; }\n+\n+private:\n+  function *m_func;\n+  string *m_name;\n+};\n+\n+class statement : public memento\n+{\n+public:\n+  virtual int get_successor_blocks (block **out_next1,\n+\t\t\t\t    block **out_next2) const;\n+\n+  void write_to_dump (dump &d);\n+\n+  location *get_loc () const { return m_loc; }\n+\n+protected:\n+  statement (block *b, location *loc)\n+  : memento (b->m_ctxt),\n+    m_block (b),\n+    m_loc (loc) {}\n+\n+  block *get_block () const { return m_block; }\n+\n+  playback::location *\n+  playback_location (replayer *r) const\n+  {\n+    return ::gcc::jit::recording::playback_location (r, m_loc);\n+  }\n+\n+private:\n+  block *m_block;\n+  location *m_loc;\n+};\n+\n+class eval : public statement\n+{\n+public:\n+  eval (block *b,\n+\tlocation *loc,\n+\trvalue *rvalue)\n+  : statement (b, loc),\n+    m_rvalue (rvalue) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_rvalue;\n+};\n+\n+class assignment : public statement\n+{\n+public:\n+  assignment (block *b,\n+\t      location *loc,\n+\t      lvalue *lvalue,\n+\t      rvalue *rvalue)\n+  : statement (b, loc),\n+    m_lvalue (lvalue),\n+    m_rvalue (rvalue) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  lvalue *m_lvalue;\n+  rvalue *m_rvalue;\n+};\n+\n+class assignment_op : public statement\n+{\n+public:\n+  assignment_op (block *b,\n+\t\t location *loc,\n+\t\t lvalue *lvalue,\n+\t\t enum gcc_jit_binary_op op,\n+\t\t rvalue *rvalue)\n+  : statement (b, loc),\n+    m_lvalue (lvalue),\n+    m_op (op),\n+    m_rvalue (rvalue) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  lvalue *m_lvalue;\n+  enum gcc_jit_binary_op m_op;\n+  rvalue *m_rvalue;\n+};\n+\n+class comment : public statement\n+{\n+public:\n+  comment (block *b,\n+\t   location *loc,\n+\t   string *text)\n+  : statement (b, loc),\n+    m_text (text) {}\n+\n+  void replay_into (replayer *r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  string *m_text;\n+};\n+\n+class conditional : public statement\n+{\n+public:\n+  conditional (block *b,\n+\t       location *loc,\n+\t       rvalue *boolval,\n+\t       block *on_true,\n+\t       block *on_false)\n+  : statement (b, loc),\n+    m_boolval (boolval),\n+    m_on_true (on_true),\n+    m_on_false (on_false) {}\n+\n+  void replay_into (replayer *r);\n+\n+  int get_successor_blocks (block **out_next1,\n+\t\t\t    block **out_next2) const;\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_boolval;\n+  block *m_on_true;\n+  block *m_on_false;\n+};\n+\n+class jump : public statement\n+{\n+public:\n+  jump (block *b,\n+\tlocation *loc,\n+\tblock *target)\n+  : statement (b, loc),\n+    m_target (target) {}\n+\n+  void replay_into (replayer *r);\n+\n+  int get_successor_blocks (block **out_next1,\n+\t\t\t    block **out_next2) const;\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  block *m_target;\n+};\n+\n+class return_ : public statement\n+{\n+public:\n+  return_ (block *b,\n+\t   location *loc,\n+\t   rvalue *rvalue)\n+  : statement (b, loc),\n+    m_rvalue (rvalue) {}\n+\n+  void replay_into (replayer *r);\n+\n+  int get_successor_blocks (block **out_next1,\n+\t\t\t    block **out_next2) const;\n+\n+private:\n+  string * make_debug_string ();\n+\n+private:\n+  rvalue *m_rvalue;\n+};\n+\n+} // namespace gcc::jit::recording\n+\n+/* The result of JIT-compilation.  */\n+class result\n+{\n+public:\n+  result(void *dso_handle);\n+\n+  virtual ~result();\n+\n+  void *\n+  get_code (const char *funcname);\n+\n+private:\n+  void *m_dso_handle;\n+};\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc\n+\n+#endif /* JIT_RECORDING_H */\n+"}, {"sha": "67ed5d5ee1ee721929c49728b5e985241cade032", "filename": "gcc/jit/libgccjit++.h", "status": "added", "additions": 1574, "deletions": 0, "changes": 1574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,1574 @@\n+/* A C++ API for libgccjit, purely as inline wrapper functions.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBGCCJIT_PLUS_PLUS_H\n+#define LIBGCCJIT_PLUS_PLUS_H\n+\n+#include \"libgccjit.h\"\n+\n+#include <limits>\n+#include <ostream>\n+#include <vector>\n+\n+/****************************************************************************\n+ C++ API\n+ ****************************************************************************/\n+\n+namespace gccjit\n+{\n+  class context;\n+  class location;\n+  class field;\n+  class type;\n+  class struct_;\n+  class param;\n+  class function;\n+  class block;\n+  class rvalue;\n+  class lvalue;\n+\n+  /* Errors within the API become C++ exceptions of this class.  */\n+  class error\n+  {\n+  };\n+\n+  class object\n+  {\n+  public:\n+    context get_context () const;\n+\n+    std::string get_debug_string () const;\n+\n+  protected:\n+    object ();\n+    object (gcc_jit_object *obj);\n+\n+    gcc_jit_object *get_inner_object () const;\n+\n+  private:\n+    gcc_jit_object *m_inner_obj;\n+  };\n+\n+  inline std::ostream& operator << (std::ostream& stream, const object &obj);\n+\n+  /* Some client code will want to supply source code locations, others\n+     won't.  To avoid doubling the number of entrypoints, everything\n+     accepting a location also has a default argument.  To do this, the\n+     other classes need to see that \"location\" has a default constructor,\n+     hence we need to declare it first.  */\n+  class location : public object\n+  {\n+  public:\n+    location ();\n+    location (gcc_jit_location *loc);\n+\n+    gcc_jit_location *get_inner_location () const;\n+  };\n+\n+  class context\n+  {\n+  public:\n+    static context acquire ();\n+    context ();\n+    context (gcc_jit_context *ctxt);\n+\n+    gccjit::context new_child_context ();\n+\n+    gcc_jit_context *get_inner_context () { return m_inner_ctxt; }\n+\n+    void release ();\n+\n+    gcc_jit_result *compile ();\n+\n+    void dump_to_file (const std::string &path,\n+\t\t       bool update_locations);\n+\n+    void set_int_option (enum gcc_jit_int_option opt,\n+\t\t\t int value);\n+\n+    void set_bool_option (enum gcc_jit_bool_option opt,\n+\t\t\t  int value);\n+\n+    location\n+    new_location (const std::string &filename,\n+\t\t  int line,\n+\t\t  int column);\n+\n+    type get_type (enum gcc_jit_types kind);\n+    type get_int_type (size_t num_bytes, int is_signed);\n+\n+    /* A way to map a specific int type, using the compiler to\n+       get the details automatically e.g.:\n+\t  gccjit::type type = get_int_type <my_int_type_t> ();  */\n+    template <typename T>\n+    type get_int_type ();\n+\n+    type new_array_type (type element_type, int num_elements,\n+\t\t\t location loc = location ());\n+\n+    field new_field (type type_, const std::string &name,\n+\t\t     location loc = location ());\n+\n+    struct_ new_struct_type (const std::string &name,\n+\t\t\t     std::vector<field> &fields,\n+\t\t\t     location loc = location ());\n+\n+    struct_ new_opaque_struct_type (const std::string &name,\n+\t\t\t\t    location loc = location ());\n+\n+    param new_param (type type_,\n+\t\t     const std::string &name,\n+\t\t     location loc = location ());\n+\n+    function new_function (enum gcc_jit_function_kind kind,\n+\t\t\t   type return_type,\n+\t\t\t   const std::string &name,\n+\t\t\t   std::vector<param> &params,\n+\t\t\t   int is_variadic,\n+\t\t\t   location loc = location ());\n+\n+    function get_builtin_function (const std::string &name);\n+\n+    lvalue new_global (type type_,\n+\t\t       const std::string &name,\n+\t\t       location loc = location ());\n+\n+    rvalue new_rvalue (type numeric_type,\n+\t\t       int value) const;\n+    rvalue zero (type numeric_type) const;\n+    rvalue one (type numeric_type) const;\n+    rvalue new_rvalue (type numeric_type,\n+\t\t       double value) const;\n+    rvalue new_rvalue (type pointer_type,\n+\t\t       void *value) const;\n+    rvalue new_rvalue (const std::string &value) const;\n+\n+    /* Generic unary operations...  */\n+    rvalue new_unary_op (enum gcc_jit_unary_op op,\n+\t\t\t type result_type,\n+\t\t\t rvalue a,\n+\t\t\t location loc = location ());\n+\n+    /* ...and shorter ways to spell the various specific kinds of\n+       unary op.  */\n+    rvalue new_minus (type result_type,\n+\t\t      rvalue a,\n+\t\t      location loc = location ());\n+    rvalue new_bitwise_negate (type result_type,\n+\t\t\t       rvalue a,\n+\t\t\t       location loc = location ());\n+    rvalue new_logical_negate (type result_type,\n+\t\t\t       rvalue a,\n+\t\t\t       location loc = location ());\n+\n+    /* Generic binary operations...  */\n+    rvalue new_binary_op (enum gcc_jit_binary_op op,\n+\t\t\t  type result_type,\n+\t\t\t  rvalue a, rvalue b,\n+\t\t\t  location loc = location ());\n+\n+    /* ...and shorter ways to spell the various specific kinds of\n+       binary op.  */\n+    rvalue new_plus (type result_type,\n+\t\t     rvalue a, rvalue b,\n+\t\t     location loc = location ());\n+    rvalue new_minus (type result_type,\n+\t\t      rvalue a, rvalue b,\n+\t\t      location loc = location ());\n+    rvalue new_mult (type result_type,\n+\t\t     rvalue a, rvalue b,\n+\t\t     location loc = location ());\n+    rvalue new_divide (type result_type,\n+\t\t       rvalue a, rvalue b,\n+\t\t       location loc = location ());\n+    rvalue new_modulo (type result_type,\n+\t\t       rvalue a, rvalue b,\n+\t\t       location loc = location ());\n+    rvalue new_bitwise_and (type result_type,\n+\t\t\t    rvalue a, rvalue b,\n+\t\t\t    location loc = location ());\n+    rvalue new_bitwise_xor (type result_type,\n+\t\t\t    rvalue a, rvalue b,\n+\t\t\t    location loc = location ());\n+    rvalue new_bitwise_or (type result_type,\n+\t\t\t   rvalue a, rvalue b,\n+\t\t\t   location loc = location ());\n+    rvalue new_logical_and (type result_type,\n+\t\t\t    rvalue a, rvalue b,\n+\t\t\t    location loc = location ());\n+    rvalue new_logical_or (type result_type,\n+\t\t\t   rvalue a, rvalue b,\n+\t\t\t   location loc = location ());\n+\n+    /* Generic comparisons...  */\n+    rvalue new_comparison (enum gcc_jit_comparison op,\n+\t\t\t   rvalue a, rvalue b,\n+\t\t\t   location loc = location ());\n+    /* ...and shorter ways to spell the various specific kinds of\n+       comparison.  */\n+    rvalue new_eq (rvalue a, rvalue b,\n+\t\t   location loc = location ());\n+    rvalue new_ne (rvalue a, rvalue b,\n+\t\t   location loc = location ());\n+    rvalue new_lt (rvalue a, rvalue b,\n+\t\t   location loc = location ());\n+    rvalue new_le (rvalue a, rvalue b,\n+\t\t   location loc = location ());\n+    rvalue new_gt (rvalue a, rvalue b,\n+\t\t   location loc = location ());\n+    rvalue new_ge (rvalue a, rvalue b,\n+\t\t   location loc = location ());\n+\n+    /* The most general way of creating a function call.  */\n+    rvalue new_call (function func,\n+\t\t     std::vector<rvalue> &args,\n+\t\t     location loc = location ());\n+\n+    /* In addition, we provide a series of overloaded \"new_call\" methods\n+       for specific numbers of args (from 0 - 6), to avoid the need for\n+       client code to manually build a vector.  */\n+    rvalue new_call (function func,\n+\t\t     location loc = location ());\n+    rvalue new_call (function func,\n+\t\t     rvalue arg0,\n+\t\t     location loc = location ());\n+    rvalue new_call (function func,\n+\t\t     rvalue arg0, rvalue arg1,\n+\t\t     location loc = location ());\n+    rvalue new_call (function func,\n+\t\t     rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t     location loc = location ());\n+    rvalue new_call (function func,\n+\t\t     rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t     rvalue arg3,\n+\t\t     location loc = location ());\n+    rvalue new_call (function func,\n+\t\t     rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t     rvalue arg3, rvalue arg4,\n+\t\t     location loc = location ());\n+    rvalue new_call (function func,\n+\t\t     rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t     rvalue arg3, rvalue arg4, rvalue arg5,\n+\t\t     location loc = location ());\n+\n+    rvalue new_cast (rvalue expr,\n+\t\t     type type_,\n+\t\t     location loc = location ());\n+\n+    lvalue new_array_access (rvalue ptr,\n+\t\t\t     rvalue index,\n+\t\t\t     location loc = location ());\n+\n+  private:\n+    gcc_jit_context *m_inner_ctxt;\n+  };\n+\n+  class field : public object\n+  {\n+  public:\n+    field ();\n+    field (gcc_jit_field *inner);\n+\n+    gcc_jit_field *get_inner_field () const;\n+  };\n+\n+  class type : public object\n+  {\n+  public:\n+    type ();\n+    type (gcc_jit_type *inner);\n+\n+    gcc_jit_type *get_inner_type () const;\n+\n+    type get_pointer ();\n+    type get_volatile ();\n+\n+    // Shortcuts for getting values of numeric types:\n+    rvalue zero ();\n+    rvalue one ();\n+ };\n+\n+  class struct_ : public type\n+  {\n+  public:\n+    struct_ ();\n+    struct_ (gcc_jit_struct *inner);\n+\n+    gcc_jit_struct *get_inner_struct () const;\n+  };\n+\n+  class function : public object\n+  {\n+  public:\n+    function ();\n+    function (gcc_jit_function *func);\n+\n+    gcc_jit_function *get_inner_function () const;\n+\n+    void dump_to_dot (const std::string &path);\n+\n+    param get_param (int index) const;\n+\n+    block new_block ();\n+    block new_block (const std::string &name);\n+\n+    lvalue new_local (type type_,\n+\t\t      const std::string &name,\n+\t\t      location loc = location ());\n+\n+    /* A series of overloaded operator () with various numbers of arguments\n+       for a very terse way of creating a call to this function.  The call\n+       is created within the same context as the function itself, which may\n+       not be what you want.  */\n+    rvalue operator() (location loc = location ());\n+    rvalue operator() (rvalue arg0,\n+\t\t       location loc = location ());\n+    rvalue operator() (rvalue arg0, rvalue arg1,\n+\t\t       location loc = location ());\n+    rvalue operator() (rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t       location loc = location ());\n+  };\n+\n+  class block : public object\n+  {\n+  public:\n+    block ();\n+    block (gcc_jit_block *inner);\n+\n+    gcc_jit_block *get_inner_block () const;\n+\n+    function get_function () const;\n+\n+    void add_eval (rvalue rvalue,\n+\t\t   location loc = location ());\n+\n+    void add_assignment (lvalue lvalue,\n+\t\t\t rvalue rvalue,\n+\t\t\t location loc = location ());\n+\n+    void add_assignment_op (lvalue lvalue,\n+\t\t\t    enum gcc_jit_binary_op op,\n+\t\t\t    rvalue rvalue,\n+\t\t\t    location loc = location ());\n+\n+    /* A way to add a function call to the body of a function being\n+       defined, with various numbers of args.  */\n+    rvalue add_call (function other,\n+\t\t     location loc = location ());\n+    rvalue add_call (function other,\n+\t\t     rvalue arg0,\n+\t\t     location loc = location ());\n+    rvalue add_call (function other,\n+\t\t     rvalue arg0, rvalue arg1,\n+\t\t     location loc = location ());\n+    rvalue add_call (function other,\n+\t\t     rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t     location loc = location ());\n+    rvalue add_call (function other,\n+\t\t     rvalue arg0, rvalue arg1, rvalue arg2, rvalue arg3,\n+\t\t     location loc = location ());\n+\n+    void add_comment (const std::string &text,\n+\t\t      location loc = location ());\n+\n+    void end_with_conditional (rvalue boolval,\n+\t\t\t       block on_true,\n+\t\t\t       block on_false,\n+\t\t\t       location loc = location ());\n+\n+    void end_with_jump (block target,\n+\t\t\tlocation loc = location ());\n+\n+    void end_with_return (rvalue rvalue,\n+\t\t\t  location loc = location ());\n+    void end_with_return (location loc = location ());\n+\n+  };\n+\n+  class rvalue : public object\n+  {\n+  public:\n+    rvalue ();\n+    rvalue (gcc_jit_rvalue *inner);\n+    gcc_jit_rvalue *get_inner_rvalue () const;\n+\n+    type get_type ();\n+\n+    rvalue access_field (field field,\n+\t\t\t location loc = location ());\n+\n+    lvalue dereference_field (field field,\n+\t\t\t      location loc = location ());\n+\n+    lvalue dereference (location loc = location ());\n+\n+    rvalue cast_to (type type_,\n+\t\t    location loc = location ());\n+\n+    /* Array access.  */\n+    lvalue operator[] (rvalue index);\n+    lvalue operator[] (int index);\n+  };\n+\n+  class lvalue : public rvalue\n+  {\n+  public:\n+    lvalue ();\n+    lvalue (gcc_jit_lvalue *inner);\n+\n+    gcc_jit_lvalue *get_inner_lvalue () const;\n+\n+    lvalue access_field (field field,\n+\t\t\t location loc = location ());\n+\n+    rvalue get_address (location loc = location ());\n+  };\n+\n+  class param : public lvalue\n+  {\n+  public:\n+    param ();\n+    param (gcc_jit_param *inner);\n+\n+    gcc_jit_param *get_inner_param () const;\n+  };\n+\n+\n+  /* Overloaded operators, for those who want the most terse API\n+     (at the possible risk of being a little too magical).\n+\n+     In each case, the first parameter is used to determine which context\n+     owns the resulting expression, and, where appropriate,  what the\n+     latter's type is. */\n+\n+  /* Unary operators.  */\n+  rvalue operator- (rvalue a); // unary minus\n+  rvalue operator~ (rvalue a); // unary bitwise negate\n+  rvalue operator! (rvalue a); // unary logical negate\n+\n+  /* Binary operators.  */\n+  rvalue operator+ (rvalue a, rvalue b);\n+  rvalue operator- (rvalue a, rvalue b);\n+  rvalue operator* (rvalue a, rvalue b);\n+  rvalue operator/ (rvalue a, rvalue b);\n+  rvalue operator% (rvalue a, rvalue b);\n+  rvalue operator& (rvalue a, rvalue b); //  bitwise and\n+  rvalue operator^ (rvalue a, rvalue b); // bitwise_xor\n+  rvalue operator| (rvalue a, rvalue b); // bitwise_or\n+  rvalue operator&& (rvalue a, rvalue b); // logical_and\n+  rvalue operator|| (rvalue a, rvalue b); // logical_or\n+\n+  /* Comparisons.  */\n+  rvalue operator== (rvalue a, rvalue b);\n+  rvalue operator!= (rvalue a, rvalue b);\n+  rvalue operator< (rvalue a, rvalue b);\n+  rvalue operator<= (rvalue a, rvalue b);\n+  rvalue operator> (rvalue a, rvalue b);\n+  rvalue operator>= (rvalue a, rvalue b);\n+\n+  /* Dereferencing. */\n+  lvalue operator* (rvalue ptr);\n+}\n+\n+/****************************************************************************\n+ Implementation of the API\n+ ****************************************************************************/\n+namespace gccjit {\n+\n+// class context\n+inline context context::acquire ()\n+{\n+  return context (gcc_jit_context_acquire ());\n+}\n+inline context::context () : m_inner_ctxt (NULL) {}\n+inline context::context (gcc_jit_context *inner) : m_inner_ctxt (inner)\n+{\n+  if (!inner)\n+    throw error ();\n+}\n+\n+inline gccjit::context\n+context::new_child_context ()\n+{\n+  return context (gcc_jit_context_new_child_context (m_inner_ctxt));\n+}\n+\n+inline void\n+context::release ()\n+{\n+  gcc_jit_context_release (m_inner_ctxt);\n+  m_inner_ctxt = NULL;\n+}\n+\n+inline gcc_jit_result *\n+context::compile ()\n+{\n+  gcc_jit_result *result = gcc_jit_context_compile (m_inner_ctxt);\n+  if (!result)\n+    throw error ();\n+  return result;\n+}\n+\n+inline void\n+context::dump_to_file (const std::string &path,\n+\t\t       bool update_locations)\n+{\n+  gcc_jit_context_dump_to_file (m_inner_ctxt,\n+\t\t\t\tpath.c_str (),\n+\t\t\t\tupdate_locations);\n+}\n+\n+inline void\n+context::set_int_option (enum gcc_jit_int_option opt,\n+\t\t\t int value)\n+{\n+  gcc_jit_context_set_int_option (m_inner_ctxt, opt, value);\n+\n+}\n+\n+inline void\n+context::set_bool_option (enum gcc_jit_bool_option opt,\n+\t\t\t  int value)\n+{\n+  gcc_jit_context_set_bool_option (m_inner_ctxt, opt, value);\n+\n+}\n+\n+inline location\n+context::new_location (const std::string &filename,\n+\t\t       int line,\n+\t\t       int column)\n+{\n+  return location (gcc_jit_context_new_location (m_inner_ctxt,\n+\t\t\t\t\t\t filename.c_str (),\n+\t\t\t\t\t\t line,\n+\t\t\t\t\t\t column));\n+}\n+\n+inline type\n+context::get_type (enum gcc_jit_types kind)\n+{\n+  return type (gcc_jit_context_get_type (m_inner_ctxt, kind));\n+}\n+\n+inline type\n+context::get_int_type (size_t num_bytes, int is_signed)\n+{\n+  return type (gcc_jit_context_get_int_type (m_inner_ctxt,\n+\t\t\t\t\t     num_bytes,\n+\t\t\t\t\t     is_signed));\n+}\n+\n+template <typename T>\n+inline type\n+context::get_int_type ()\n+{\n+  return get_int_type (sizeof (T), std::numeric_limits<T>::is_signed);\n+}\n+\n+inline type\n+context::new_array_type (type element_type, int num_elements, location loc)\n+{\n+  return type (gcc_jit_context_new_array_type (\n+\t\t m_inner_ctxt,\n+\t\t loc.get_inner_location (),\n+\t\t element_type.get_inner_type (),\n+\t\t num_elements));\n+}\n+\n+inline field\n+context::new_field (type type_, const std::string &name, location loc)\n+{\n+  return field (gcc_jit_context_new_field (m_inner_ctxt,\n+\t\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t\t   type_.get_inner_type (),\n+\t\t\t\t\t   name.c_str ()));\n+}\n+\n+inline struct_\n+context::new_struct_type (const std::string &name,\n+\t\t\t  std::vector<field> &fields,\n+\t\t\t  location loc)\n+{\n+  /* Treat std::vector as an array, relying on it not being resized: */\n+  field *as_array_of_wrappers = &fields[0];\n+\n+  /* Treat the array as being of the underlying pointers, relying on\n+     the wrapper type being such a pointer internally.\t*/\n+  gcc_jit_field **as_array_of_ptrs =\n+    reinterpret_cast<gcc_jit_field **> (as_array_of_wrappers);\n+\n+  return struct_ (gcc_jit_context_new_struct_type (m_inner_ctxt,\n+\t\t\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t\t\t   name.c_str (),\n+\t\t\t\t\t\t   fields.size (),\n+\t\t\t\t\t\t   as_array_of_ptrs));\n+}\n+\n+inline struct_\n+context::new_opaque_struct_type (const std::string &name,\n+\t\t\t\t location loc)\n+{\n+  return struct_ (gcc_jit_context_new_opaque_struct (\n+\t\t    m_inner_ctxt,\n+\t\t    loc.get_inner_location (),\n+\t\t    name.c_str ()));\n+}\n+\n+inline param\n+context::new_param (type type_,\n+\t\t    const std::string &name,\n+\t\t    location loc)\n+{\n+  return param (gcc_jit_context_new_param (m_inner_ctxt,\n+\t\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t\t   type_.get_inner_type (),\n+\t\t\t\t\t   name.c_str ()));\n+}\n+\n+inline function\n+context::new_function (enum gcc_jit_function_kind kind,\n+\t\t       type return_type,\n+\t\t       const std::string &name,\n+\t\t       std::vector<param> &params,\n+\t\t       int is_variadic,\n+\t\t       location loc)\n+{\n+  /* Treat std::vector as an array, relying on it not being resized: */\n+  param *as_array_of_wrappers = &params[0];\n+\n+  /* Treat the array as being of the underlying pointers, relying on\n+     the wrapper type being such a pointer internally.\t*/\n+  gcc_jit_param **as_array_of_ptrs =\n+    reinterpret_cast<gcc_jit_param **> (as_array_of_wrappers);\n+\n+  return function (gcc_jit_context_new_function (m_inner_ctxt,\n+\t\t\t\t\t\t loc.get_inner_location (),\n+\t\t\t\t\t\t kind,\n+\t\t\t\t\t\t return_type.get_inner_type (),\n+\t\t\t\t\t\t name.c_str (),\n+\t\t\t\t\t\t params.size (),\n+\t\t\t\t\t\t as_array_of_ptrs,\n+\t\t\t\t\t\t is_variadic));\n+}\n+\n+inline function\n+context::get_builtin_function (const std::string &name)\n+{\n+  return function (gcc_jit_context_get_builtin_function (m_inner_ctxt,\n+\t\t\t\t\t\t\t name.c_str ()));\n+}\n+\n+inline lvalue\n+context::new_global (type type_,\n+\t\t     const std::string &name,\n+\t\t     location loc)\n+{\n+  return lvalue (gcc_jit_context_new_global (m_inner_ctxt,\n+\t\t\t\t\t     loc.get_inner_location (),\n+\t\t\t\t\t     type_.get_inner_type (),\n+\t\t\t\t\t     name.c_str ()));\n+}\n+\n+inline rvalue\n+context::new_rvalue (type numeric_type,\n+\t\t     int value) const\n+{\n+  return rvalue (\n+    gcc_jit_context_new_rvalue_from_int (m_inner_ctxt,\n+\t\t\t\t\t numeric_type.get_inner_type (),\n+\t\t\t\t\t value));\n+}\n+\n+inline rvalue\n+context::zero (type numeric_type) const\n+{\n+  return rvalue (gcc_jit_context_zero (m_inner_ctxt,\n+\t\t\t\t       numeric_type.get_inner_type ()));\n+}\n+\n+inline rvalue\n+context::one (type numeric_type) const\n+{\n+  return rvalue (gcc_jit_context_one (m_inner_ctxt,\n+\t\t\t\t       numeric_type.get_inner_type ()));\n+}\n+\n+inline rvalue\n+context::new_rvalue (type numeric_type,\n+\t\t     double value) const\n+{\n+  return rvalue (\n+    gcc_jit_context_new_rvalue_from_double (m_inner_ctxt,\n+\t\t\t\t\t    numeric_type.get_inner_type (),\n+\t\t\t\t\t    value));\n+}\n+\n+inline rvalue\n+context::new_rvalue (type pointer_type,\n+\t\t     void *value) const\n+{\n+  return rvalue (\n+    gcc_jit_context_new_rvalue_from_ptr (m_inner_ctxt,\n+\t\t\t\t\t pointer_type.get_inner_type (),\n+\t\t\t\t\t value));\n+}\n+\n+inline rvalue\n+context::new_rvalue (const std::string &value) const\n+{\n+  return rvalue (\n+    gcc_jit_context_new_string_literal (m_inner_ctxt, value.c_str ()));\n+}\n+\n+inline rvalue\n+context::new_unary_op (enum gcc_jit_unary_op op,\n+\t\t       type result_type,\n+\t\t       rvalue a,\n+\t\t       location loc)\n+{\n+  return rvalue (gcc_jit_context_new_unary_op (m_inner_ctxt,\n+\t\t\t\t\t       loc.get_inner_location (),\n+\t\t\t\t\t       op,\n+\t\t\t\t\t       result_type.get_inner_type (),\n+\t\t\t\t\t       a.get_inner_rvalue ()));\n+}\n+inline rvalue\n+context::new_minus (type result_type,\n+\t\t    rvalue a,\n+\t\t    location loc)\n+{\n+  return rvalue (new_unary_op (GCC_JIT_UNARY_OP_MINUS,\n+\t\t\t       result_type, a, loc));\n+}\n+inline rvalue\n+context::new_bitwise_negate (type result_type,\n+\t\t\t     rvalue a,\n+\t\t\t     location loc)\n+{\n+  return rvalue (new_unary_op (GCC_JIT_UNARY_OP_BITWISE_NEGATE,\n+\t\t\t       result_type, a, loc));\n+}\n+inline rvalue\n+context::new_logical_negate (type result_type,\n+\t\t\t     rvalue a,\n+\t\t\t     location loc)\n+{\n+  return rvalue (new_unary_op (GCC_JIT_UNARY_OP_LOGICAL_NEGATE,\n+\t\t\t       result_type, a, loc));\n+}\n+\n+inline rvalue\n+context::new_binary_op (enum gcc_jit_binary_op op,\n+\t\t\ttype result_type,\n+\t\t\trvalue a, rvalue b,\n+\t\t\tlocation loc)\n+{\n+  return rvalue (gcc_jit_context_new_binary_op (m_inner_ctxt,\n+\t\t\t\t\t\tloc.get_inner_location (),\n+\t\t\t\t\t\top,\n+\t\t\t\t\t\tresult_type.get_inner_type (),\n+\t\t\t\t\t\ta.get_inner_rvalue (),\n+\t\t\t\t\t\tb.get_inner_rvalue ()));\n+}\n+inline rvalue\n+context::new_plus (type result_type,\n+\t\t   rvalue a, rvalue b,\n+\t\t   location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_PLUS,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_minus (type result_type,\n+\t\t    rvalue a, rvalue b,\n+\t\t    location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_MINUS,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_mult (type result_type,\n+\t\t   rvalue a, rvalue b,\n+\t\t   location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_MULT,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_divide (type result_type,\n+\t\t     rvalue a, rvalue b,\n+\t\t     location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_DIVIDE,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_modulo (type result_type,\n+\t\t     rvalue a, rvalue b,\n+\t\t     location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_MODULO,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_bitwise_and (type result_type,\n+\t\t\t  rvalue a, rvalue b,\n+\t\t\t  location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_BITWISE_AND,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_bitwise_xor (type result_type,\n+\t\t\t  rvalue a, rvalue b,\n+\t\t\t  location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_BITWISE_XOR,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_bitwise_or (type result_type,\n+\t\t\t rvalue a, rvalue b,\n+\t\t\t location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_BITWISE_OR,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_logical_and (type result_type,\n+\t\t\t  rvalue a, rvalue b,\n+\t\t\t  location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_LOGICAL_AND,\n+\t\t\tresult_type, a, b, loc);\n+}\n+inline rvalue\n+context::new_logical_or (type result_type,\n+\t\t\t rvalue a, rvalue b,\n+\t\t\t location loc)\n+{\n+  return new_binary_op (GCC_JIT_BINARY_OP_LOGICAL_OR,\n+\t\t\tresult_type, a, b, loc);\n+}\n+\n+inline rvalue\n+context::new_comparison (enum gcc_jit_comparison op,\n+\t\t\t rvalue a, rvalue b,\n+\t\t\t location loc)\n+{\n+  return rvalue (gcc_jit_context_new_comparison (m_inner_ctxt,\n+\t\t\t\t\t\t loc.get_inner_location (),\n+\t\t\t\t\t\t op,\n+\t\t\t\t\t\t a.get_inner_rvalue (),\n+\t\t\t\t\t\t b.get_inner_rvalue ()));\n+}\n+inline rvalue\n+context::new_eq (rvalue a, rvalue b,\n+\t\t location loc)\n+{\n+  return new_comparison (GCC_JIT_COMPARISON_EQ,\n+\t\t\t a, b, loc);\n+}\n+inline rvalue\n+context::new_ne (rvalue a, rvalue b,\n+\t\t location loc)\n+{\n+  return new_comparison (GCC_JIT_COMPARISON_NE,\n+\t\t\t a, b, loc);\n+}\n+inline rvalue\n+context::new_lt (rvalue a, rvalue b,\n+\t\t location loc)\n+{\n+  return new_comparison (GCC_JIT_COMPARISON_LT,\n+\t\t\t a, b, loc);\n+}\n+inline rvalue\n+context::new_le (rvalue a, rvalue b,\n+\t\t location loc)\n+{\n+  return new_comparison (GCC_JIT_COMPARISON_LE,\n+\t\t\t a, b, loc);\n+}\n+inline rvalue\n+context::new_gt (rvalue a, rvalue b,\n+\t\t location loc)\n+{\n+  return new_comparison (GCC_JIT_COMPARISON_GT,\n+\t\t\t a, b, loc);\n+}\n+inline rvalue\n+context::new_ge (rvalue a, rvalue b,\n+\t\t location loc)\n+{\n+  return new_comparison (GCC_JIT_COMPARISON_GE,\n+\t\t\t a, b, loc);\n+}\n+\n+inline rvalue\n+context::new_call (function func,\n+\t\t   std::vector<rvalue> &args,\n+\t\t   location loc)\n+{\n+  /* Treat std::vector as an array, relying on it not being resized: */\n+  rvalue *as_array_of_wrappers = &args[0];\n+\n+  /* Treat the array as being of the underlying pointers, relying on\n+     the wrapper type being such a pointer internally.\t*/\n+  gcc_jit_rvalue **as_array_of_ptrs =\n+    reinterpret_cast<gcc_jit_rvalue **> (as_array_of_wrappers);\n+  return gcc_jit_context_new_call (m_inner_ctxt,\n+\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t   func.get_inner_function (),\n+\t\t\t\t   args.size (),\n+\t\t\t\t   as_array_of_ptrs);\n+}\n+inline rvalue\n+context::new_call (function func,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args;\n+  return new_call (func, args, loc);\n+}\n+\n+inline rvalue\n+context::new_call (function func,\n+\t\t   rvalue arg0,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args(1);\n+  args[0] = arg0;\n+  return new_call (func, args, loc);\n+}\n+inline rvalue\n+context::new_call (function func,\n+\t\t   rvalue arg0, rvalue arg1,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args(2);\n+  args[0] = arg0;\n+  args[1] = arg1;\n+  return new_call (func, args, loc);\n+}\n+inline rvalue\n+context::new_call (function func,\n+\t\t   rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args(3);\n+  args[0] = arg0;\n+  args[1] = arg1;\n+  args[2] = arg2;\n+  return new_call (func, args, loc);\n+}\n+inline rvalue\n+context::new_call (function func,\n+\t\t   rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t   rvalue arg3,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args(4);\n+  args[0] = arg0;\n+  args[1] = arg1;\n+  args[2] = arg2;\n+  args[3] = arg3;\n+  return new_call (func, args, loc);\n+}\n+inline rvalue\n+context::new_call (function func,\n+\t\t   rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t   rvalue arg3, rvalue arg4,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args(5);\n+  args[0] = arg0;\n+  args[1] = arg1;\n+  args[2] = arg2;\n+  args[3] = arg3;\n+  args[4] = arg4;\n+  return new_call (func, args, loc);\n+}\n+inline rvalue\n+context::new_call (function func,\n+\t\t   rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t   rvalue arg3, rvalue arg4, rvalue arg5,\n+\t\t   location loc)\n+{\n+  std::vector<rvalue> args(6);\n+  args[0] = arg0;\n+  args[1] = arg1;\n+  args[2] = arg2;\n+  args[3] = arg3;\n+  args[4] = arg4;\n+  args[5] = arg5;\n+  return new_call (func, args, loc);\n+}\n+\n+inline rvalue\n+context::new_cast (rvalue expr,\n+\t\t   type type_,\n+\t\t   location loc)\n+{\n+  return rvalue (gcc_jit_context_new_cast (m_inner_ctxt,\n+\t\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t\t   expr.get_inner_rvalue (),\n+\t\t\t\t\t   type_.get_inner_type ()));\n+}\n+\n+inline lvalue\n+context::new_array_access (rvalue ptr,\n+\t\t\t   rvalue index,\n+\t\t\t   location loc)\n+{\n+  return lvalue (gcc_jit_context_new_array_access (m_inner_ctxt,\n+\t\t\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t\t\t   ptr.get_inner_rvalue (),\n+\t\t\t\t\t\t   index.get_inner_rvalue ()));\n+}\n+\n+// class object\n+inline context\n+object::get_context () const\n+{\n+  return context (gcc_jit_object_get_context (m_inner_obj));\n+}\n+\n+inline std::string\n+object::get_debug_string () const\n+{\n+  return gcc_jit_object_get_debug_string (m_inner_obj);\n+}\n+\n+inline object::object () : m_inner_obj (NULL) {}\n+inline object::object (gcc_jit_object *obj) : m_inner_obj (obj)\n+{\n+  if (!obj)\n+    throw error ();\n+}\n+\n+inline gcc_jit_object *\n+object::get_inner_object () const\n+{\n+  return m_inner_obj;\n+}\n+\n+inline std::ostream&\n+operator << (std::ostream& stream, const object &obj)\n+{\n+  return stream << obj.get_debug_string ();\n+}\n+\n+// class location\n+inline location::location () : object () {}\n+inline location::location (gcc_jit_location *loc)\n+  : object (gcc_jit_location_as_object (loc))\n+{}\n+\n+inline gcc_jit_location *\n+location::get_inner_location () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_location *> (get_inner_object ());\n+}\n+\n+// class field\n+inline field::field () : object () {}\n+inline field::field (gcc_jit_field *inner)\n+  : object (gcc_jit_field_as_object (inner))\n+{}\n+\n+inline gcc_jit_field *\n+field::get_inner_field () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_field *> (get_inner_object ());\n+}\n+\n+// class type\n+inline type::type () : object () {}\n+inline type::type (gcc_jit_type *inner)\n+  : object (gcc_jit_type_as_object (inner))\n+{}\n+\n+inline gcc_jit_type *\n+type::get_inner_type () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_type *> (get_inner_object ());\n+}\n+\n+inline type\n+type::get_pointer ()\n+{\n+  return type (gcc_jit_type_get_pointer (get_inner_type ()));\n+}\n+\n+inline type\n+type::get_volatile ()\n+{\n+  return type (gcc_jit_type_get_volatile (get_inner_type ()));\n+}\n+\n+inline rvalue\n+type::zero ()\n+{\n+  return get_context ().new_rvalue (*this, 0);\n+}\n+\n+inline rvalue\n+type::one ()\n+{\n+  return get_context ().new_rvalue (*this, 1);\n+}\n+\n+// class struct_\n+inline struct_::struct_ () : type (NULL) {}\n+inline struct_::struct_ (gcc_jit_struct *inner) :\n+  type (gcc_jit_struct_as_type (inner))\n+{\n+}\n+\n+inline gcc_jit_struct *\n+struct_::get_inner_struct () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_struct *> (get_inner_object ());\n+}\n+\n+// class function\n+inline function::function () : object () {}\n+inline function::function (gcc_jit_function *inner)\n+  : object (gcc_jit_function_as_object (inner))\n+{}\n+\n+inline gcc_jit_function *\n+function::get_inner_function () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_function *> (get_inner_object ());\n+}\n+\n+inline void\n+function::dump_to_dot (const std::string &path)\n+{\n+  gcc_jit_function_dump_to_dot (get_inner_function (),\n+\t\t\t\tpath.c_str ());\n+}\n+\n+inline param\n+function::get_param (int index) const\n+{\n+  return param (gcc_jit_function_get_param (get_inner_function (),\n+\t\t\t\t\t    index));\n+}\n+\n+inline block\n+function::new_block ()\n+{\n+  return block (gcc_jit_function_new_block (get_inner_function (),\n+\t\t\t\t\t    NULL));\n+}\n+\n+inline block\n+function::new_block (const std::string &name)\n+{\n+  return block (gcc_jit_function_new_block (get_inner_function (),\n+\t\t\t\t\t    name.c_str ()));\n+}\n+\n+inline lvalue\n+function::new_local (type type_,\n+\t\t     const std::string &name,\n+\t\t     location loc)\n+{\n+  return lvalue (gcc_jit_function_new_local (get_inner_function (),\n+\t\t\t\t\t     loc.get_inner_location (),\n+\t\t\t\t\t     type_.get_inner_type (),\n+\t\t\t\t\t     name.c_str ()));\n+}\n+\n+inline function\n+block::get_function () const\n+{\n+  return function (gcc_jit_block_get_function ( get_inner_block ()));\n+}\n+\n+inline void\n+block::add_eval (rvalue rvalue,\n+\t\t location loc)\n+{\n+  gcc_jit_block_add_eval (get_inner_block (),\n+\t\t\t  loc.get_inner_location (),\n+\t\t\t  rvalue.get_inner_rvalue ());\n+}\n+\n+inline void\n+block::add_assignment (lvalue lvalue,\n+\t\t       rvalue rvalue,\n+\t\t       location loc)\n+{\n+  gcc_jit_block_add_assignment (get_inner_block (),\n+\t\t\t\tloc.get_inner_location (),\n+\t\t\t\tlvalue.get_inner_lvalue (),\n+\t\t\t\trvalue.get_inner_rvalue ());\n+}\n+\n+inline void\n+block::add_assignment_op (lvalue lvalue,\n+\t\t\t  enum gcc_jit_binary_op op,\n+\t\t\t  rvalue rvalue,\n+\t\t\t  location loc)\n+{\n+  gcc_jit_block_add_assignment_op (get_inner_block (),\n+\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t   lvalue.get_inner_lvalue (),\n+\t\t\t\t   op,\n+\t\t\t\t   rvalue.get_inner_rvalue ());\n+}\n+\n+inline void\n+block::add_comment (const std::string &text,\n+\t\t    location loc)\n+{\n+  gcc_jit_block_add_comment (get_inner_block (),\n+\t\t\t     loc.get_inner_location (),\n+\t\t\t     text.c_str ());\n+}\n+\n+inline void\n+block::end_with_conditional (rvalue boolval,\n+\t\t\t     block on_true,\n+\t\t\t     block on_false,\n+\t\t\t     location loc)\n+{\n+  gcc_jit_block_end_with_conditional (get_inner_block (),\n+\t\t\t\t      loc.get_inner_location (),\n+\t\t\t\t      boolval.get_inner_rvalue (),\n+\t\t\t\t      on_true.get_inner_block (),\n+\t\t\t\t      on_false.get_inner_block ());\n+}\n+\n+inline void\n+block::end_with_jump (block target,\n+\t\t      location loc)\n+{\n+  gcc_jit_block_end_with_jump (get_inner_block (),\n+\t\t\t       loc.get_inner_location (),\n+\t\t\t       target.get_inner_block ());\n+}\n+\n+inline void\n+block::end_with_return (rvalue rvalue,\n+\t\t\tlocation loc)\n+{\n+  gcc_jit_block_end_with_return (get_inner_block (),\n+\t\t\t\t loc.get_inner_location (),\n+\t\t\t\t rvalue.get_inner_rvalue ());\n+}\n+\n+inline void\n+block::end_with_return (location loc)\n+{\n+  gcc_jit_block_end_with_void_return (get_inner_block (),\n+\t\t\t\t      loc.get_inner_location ());\n+}\n+\n+inline rvalue\n+block::add_call (function other,\n+\t\t location loc)\n+{\n+  rvalue c = get_context ().new_call (other, loc);\n+  add_eval (c);\n+  return c;\n+}\n+inline rvalue\n+block::add_call (function other,\n+\t\t rvalue arg0,\n+\t\t location loc)\n+{\n+  rvalue c = get_context ().new_call (other, arg0, loc);\n+  add_eval (c);\n+  return c;\n+}\n+inline rvalue\n+block::add_call (function other,\n+\t\t rvalue arg0, rvalue arg1,\n+\t\t location loc)\n+{\n+  rvalue c = get_context ().new_call (other, arg0, arg1, loc);\n+  add_eval (c);\n+  return c;\n+}\n+inline rvalue\n+block::add_call (function other,\n+\t\t rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t location loc)\n+{\n+  rvalue c = get_context ().new_call (other, arg0, arg1, arg2, loc);\n+  add_eval (c);\n+  return c;\n+}\n+\n+inline rvalue\n+block::add_call (function other,\n+\t\t rvalue arg0, rvalue arg1, rvalue arg2, rvalue arg3,\n+\t\t location loc)\n+{\n+  rvalue c = get_context ().new_call (other, arg0, arg1, arg2, arg3, loc);\n+  add_eval (c);\n+  return c;\n+}\n+\n+inline rvalue\n+function::operator() (location loc)\n+{\n+  return get_context ().new_call (*this, loc);\n+}\n+inline rvalue\n+function::operator() (rvalue arg0,\n+\t\t      location loc)\n+{\n+  return get_context ().new_call (*this,\n+\t\t\t\t  arg0,\n+\t\t\t\t  loc);\n+}\n+inline rvalue\n+function::operator() (rvalue arg0, rvalue arg1,\n+\t\t      location loc)\n+{\n+  return get_context ().new_call (*this,\n+\t\t\t\t  arg0, arg1,\n+\t\t\t\t  loc);\n+}\n+inline rvalue\n+function::operator() (rvalue arg0, rvalue arg1, rvalue arg2,\n+\t\t      location loc)\n+{\n+  return get_context ().new_call (*this,\n+\t\t\t\t  arg0, arg1, arg2,\n+\t\t\t\t  loc);\n+}\n+\n+// class block\n+inline block::block () : object () {}\n+inline block::block (gcc_jit_block *inner)\n+  : object (gcc_jit_block_as_object (inner))\n+{}\n+\n+inline gcc_jit_block *\n+block::get_inner_block () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_block *> (get_inner_object ());\n+}\n+\n+//  class rvalue\n+inline rvalue::rvalue () : object () {}\n+inline rvalue::rvalue (gcc_jit_rvalue *inner)\n+  : object (gcc_jit_rvalue_as_object (inner))\n+{}\n+\n+inline gcc_jit_rvalue *\n+rvalue::get_inner_rvalue () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_rvalue *> (get_inner_object ());\n+}\n+\n+inline type\n+rvalue::get_type ()\n+{\n+  return type (gcc_jit_rvalue_get_type (get_inner_rvalue ()));\n+}\n+\n+inline rvalue\n+rvalue::access_field (field field,\n+\t\t      location loc)\n+{\n+  return rvalue (gcc_jit_rvalue_access_field (get_inner_rvalue (),\n+\t\t\t\t\t      loc.get_inner_location (),\n+\t\t\t\t\t      field.get_inner_field ()));\n+}\n+\n+inline lvalue\n+rvalue::dereference_field (field field,\n+\t\t\t   location loc)\n+{\n+  return lvalue (gcc_jit_rvalue_dereference_field (get_inner_rvalue (),\n+\t\t\t\t\t\t   loc.get_inner_location (),\n+\t\t\t\t\t\t   field.get_inner_field ()));\n+}\n+\n+inline lvalue\n+rvalue::dereference (location loc)\n+{\n+  return lvalue (gcc_jit_rvalue_dereference (get_inner_rvalue (),\n+\t\t\t\t\t     loc.get_inner_location ()));\n+}\n+\n+inline rvalue\n+rvalue::cast_to (type type_,\n+\t\t location loc)\n+{\n+  return get_context ().new_cast (*this, type_, loc);\n+}\n+\n+inline lvalue\n+rvalue::operator[] (rvalue index)\n+{\n+  return get_context ().new_array_access (*this, index);\n+}\n+\n+inline lvalue\n+rvalue::operator[] (int index)\n+{\n+  context ctxt = get_context ();\n+  type int_t = ctxt.get_int_type <int> ();\n+  return ctxt.new_array_access (*this,\n+\t\t\t\tctxt.new_rvalue (int_t,\n+\t\t\t\t\t\t index));\n+}\n+\n+// class lvalue : public rvalue\n+inline lvalue::lvalue () : rvalue () {}\n+inline lvalue::lvalue (gcc_jit_lvalue *inner)\n+  : rvalue (gcc_jit_lvalue_as_rvalue (inner))\n+{}\n+\n+inline gcc_jit_lvalue *\n+lvalue::get_inner_lvalue () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_lvalue *> (get_inner_object ());\n+}\n+\n+inline lvalue\n+lvalue::access_field (field field, location loc)\n+{\n+  return lvalue (gcc_jit_lvalue_access_field (get_inner_lvalue (),\n+\t\t\t\t\t      loc.get_inner_location (),\n+\t\t\t\t\t      field.get_inner_field ()));\n+}\n+\n+inline rvalue\n+lvalue::get_address (location loc)\n+{\n+  return rvalue (gcc_jit_lvalue_get_address (get_inner_lvalue (),\n+\t\t\t\t\t     loc.get_inner_location ()));\n+}\n+\n+// class param : public lvalue\n+inline param::param () : lvalue () {}\n+inline param::param (gcc_jit_param *inner)\n+  : lvalue (gcc_jit_param_as_lvalue (inner))\n+{}\n+\n+/* Overloaded operators.  */\n+// Unary operators\n+inline rvalue operator- (rvalue a)\n+{\n+  return a.get_context ().new_minus (a.get_type (), a);\n+}\n+inline rvalue operator~ (rvalue a)\n+{\n+  return a.get_context ().new_bitwise_negate (a.get_type (), a);\n+}\n+inline rvalue operator! (rvalue a)\n+{\n+  return a.get_context ().new_logical_negate (a.get_type (), a);\n+}\n+\n+// Binary operators\n+inline rvalue operator+ (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_plus (a.get_type (), a, b);\n+}\n+inline rvalue operator- (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_minus (a.get_type (), a, b);\n+}\n+inline rvalue operator* (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_mult (a.get_type (), a, b);\n+}\n+inline rvalue operator/ (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_divide (a.get_type (), a, b);\n+}\n+inline rvalue operator% (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_modulo (a.get_type (), a, b);\n+}\n+inline rvalue operator& (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_bitwise_and (a.get_type (), a, b);\n+}\n+inline rvalue operator^ (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_bitwise_xor (a.get_type (), a, b);\n+}\n+inline rvalue operator| (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_bitwise_or (a.get_type (), a, b);\n+}\n+inline rvalue operator&& (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_logical_and (a.get_type (), a, b);\n+}\n+inline rvalue operator|| (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_logical_or (a.get_type (), a, b);\n+}\n+\n+/* Comparisons.  */\n+inline rvalue operator== (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_eq (a, b);\n+}\n+inline rvalue operator!= (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_ne (a, b);\n+}\n+inline rvalue operator< (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_lt (a, b);\n+}\n+inline rvalue operator<= (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_le (a, b);\n+}\n+inline rvalue operator> (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_gt (a, b);\n+}\n+inline rvalue operator>= (rvalue a, rvalue b)\n+{\n+  return a.get_context ().new_ge (a, b);\n+}\n+\n+/* Dereferencing. */\n+inline lvalue operator* (rvalue ptr)\n+{\n+  return ptr.dereference ();\n+}\n+\n+} // namespace gccjit\n+\n+#endif /* #ifndef LIBGCCJIT_PLUS_PLUS_H */"}, {"sha": "7bc9209139b000a96e2b0f334ec1ac11560e3889", "filename": "gcc/jit/libgccjit.c", "status": "added", "additions": 2074, "deletions": 0, "changes": 2074, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,2074 @@\n+/* Implementation of the C API; all wrappers into the internal C++ API\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"safe-ctype.h\"\n+\n+#include \"libgccjit.h\"\n+#include \"jit-common.h\"\n+#include \"jit-recording.h\"\n+\n+/* The opaque types used by the public API are actually subclasses\n+   of the gcc::jit::recording classes.  */\n+\n+struct gcc_jit_context : public gcc::jit::recording::context\n+{\n+  gcc_jit_context (gcc_jit_context *parent_ctxt) :\n+    context (parent_ctxt)\n+  {}\n+};\n+\n+struct gcc_jit_result : public gcc::jit::result\n+{\n+};\n+\n+struct gcc_jit_object : public gcc::jit::recording::memento\n+{\n+};\n+\n+struct gcc_jit_location : public gcc::jit::recording::location\n+{\n+};\n+\n+struct gcc_jit_type : public gcc::jit::recording::type\n+{\n+};\n+\n+struct gcc_jit_struct : public gcc::jit::recording::struct_\n+{\n+};\n+\n+struct gcc_jit_field : public gcc::jit::recording::field\n+{\n+};\n+\n+struct gcc_jit_function : public gcc::jit::recording::function\n+{\n+};\n+\n+struct gcc_jit_block : public gcc::jit::recording::block\n+{\n+};\n+\n+struct gcc_jit_rvalue : public gcc::jit::recording::rvalue\n+{\n+};\n+\n+struct gcc_jit_lvalue : public gcc::jit::recording::lvalue\n+{\n+};\n+\n+struct gcc_jit_param : public gcc::jit::recording::param\n+{\n+};\n+\n+/**********************************************************************\n+ Error-handling.\n+\n+ We try to gracefully handle API usage errors by being defensive\n+ at the API boundary.\n+ **********************************************************************/\n+\n+#define JIT_BEGIN_STMT do {\n+#define JIT_END_STMT   } while(0)\n+\n+/* Each of these error-handling macros determines if TEST_EXPR holds.\n+\n+   If TEXT_EXPR fails to hold we return from the enclosing function and\n+   print an error, either via adding an error on the given context CTXT\n+   if CTXT is non-NULL, falling back to simply printing to stderr if CTXT\n+   is NULL.\n+\n+   They have to be macros since they inject their \"return\" into the\n+   function they are placed in.\n+\n+   The variant macros express:\n+\n+     (A) whether or not we need to return a value:\n+\t    RETURN_VAL_IF_FAIL* vs\n+\t    RETURN_IF_FAIL*,\n+\t with the former returning RETURN_EXPR, and\n+\t    RETURN_NULL_IF_FAIL*\n+\t for the common case where a NULL value is to be returned on\n+\t error, and\n+\n+     (B) whether the error message is to be directly printed:\n+\t   RETURN_*IF_FAIL\n+\t or is a format string with some number of arguments:\n+\t   RETURN_*IF_FAIL_PRINTF*\n+\n+   They all use JIT_BEGIN_STMT/JIT_END_STMT so they can be written with\n+   trailing semicolons.\n+*/\n+\n+#define RETURN_VAL_IF_FAIL(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_MSG)\t\\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: %s\", __func__, (ERR_MSG));\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_VAL_IF_FAIL_PRINTF1(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\\\n+\t\t   __func__, (A0));\t\t\t\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_VAL_IF_FAIL_PRINTF2(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0, A1) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1));\t\t\t\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_VAL_IF_FAIL_PRINTF3(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1), (A2));\t\t\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_VAL_IF_FAIL_PRINTF4(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1), (A2), (A3));\t\t\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_VAL_IF_FAIL_PRINTF6(TEST_EXPR, RETURN_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4, A5) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1), (A2), (A3), (A4), (A5));\t\\\n+\treturn (RETURN_EXPR);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_NULL_IF_FAIL(TEST_EXPR, CTXT, LOC, ERR_MSG) \\\n+  RETURN_VAL_IF_FAIL ((TEST_EXPR), NULL, (CTXT), (LOC), (ERR_MSG))\n+\n+#define RETURN_NULL_IF_FAIL_PRINTF1(TEST_EXPR, CTXT, LOC, ERR_FMT, A0) \\\n+  RETURN_VAL_IF_FAIL_PRINTF1 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0)\n+\n+#define RETURN_NULL_IF_FAIL_PRINTF2(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1) \\\n+  RETURN_VAL_IF_FAIL_PRINTF2 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1)\n+\n+#define RETURN_NULL_IF_FAIL_PRINTF3(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2) \\\n+  RETURN_VAL_IF_FAIL_PRINTF3 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1, A2)\n+\n+#define RETURN_NULL_IF_FAIL_PRINTF4(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3) \\\n+  RETURN_VAL_IF_FAIL_PRINTF4 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1, A2, A3)\n+\n+#define RETURN_NULL_IF_FAIL_PRINTF6(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4, A5) \\\n+  RETURN_VAL_IF_FAIL_PRINTF6 (TEST_EXPR, NULL, CTXT, LOC, ERR_FMT, A0, A1, A2, A3, A4, A5)\n+\n+#define RETURN_IF_FAIL(TEST_EXPR, CTXT, LOC, ERR_MSG)\t\t\t\\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: %s\", __func__, (ERR_MSG));\t\t\\\n+\treturn;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_IF_FAIL_PRINTF1(TEST_EXPR, CTXT, LOC, ERR_FMT, A0) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0));\t\t\t\t\t\\\n+\treturn;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_IF_FAIL_PRINTF2(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1));\t\t\t\t\\\n+\treturn;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+#define RETURN_IF_FAIL_PRINTF4(TEST_EXPR, CTXT, LOC, ERR_FMT, A0, A1, A2, A3) \\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    if (!(TEST_EXPR))\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tjit_error ((CTXT), (LOC), \"%s: \" ERR_FMT,\t\t\t\t\\\n+\t\t   __func__, (A0), (A1), (A2), (A3));\t\t\t\\\n+\treturn;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  JIT_END_STMT\n+\n+/* Check that BLOCK is non-NULL, and that it's OK to add statements to\n+   it.  This will fail if BLOCK has already been terminated by some\n+   kind of jump or a return.  */\n+#define RETURN_IF_NOT_VALID_BLOCK(BLOCK, LOC)\t\t\t\t\\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    RETURN_IF_FAIL ((BLOCK), NULL, (LOC), \"NULL block\");\t\t\\\n+    RETURN_IF_FAIL_PRINTF2 (\t\t\t\t\t\t\\\n+      !(BLOCK)->has_been_terminated (),\t\t\t\t\\\n+      (BLOCK)->get_context (),\t\t\t\t\t\t\\\n+      (LOC),\t\t\t\t\t\t\t\t\\\n+      \"adding to terminated block: %s (already terminated by: %s)\",\t\\\n+      (BLOCK)->get_debug_string (),\t\t\t\t\t\\\n+      (BLOCK)->get_last_statement ()->get_debug_string ());\t\t\\\n+  JIT_END_STMT\n+\n+/* As RETURN_IF_NOT_VALID_BLOCK, but injecting a \"return NULL;\" if it\n+   fails.  */\n+#define RETURN_NULL_IF_NOT_VALID_BLOCK(BLOCK, LOC)\t\t\t\\\n+  JIT_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    RETURN_NULL_IF_FAIL ((BLOCK), NULL, (LOC), \"NULL block\");\t\t\\\n+    RETURN_NULL_IF_FAIL_PRINTF2 (\t\t\t\t\t\\\n+      !(BLOCK)->has_been_terminated (),\t\t\t\t\\\n+      (BLOCK)->get_context (),\t\t\t\t\t\t\\\n+      (LOC),\t\t\t\t\t\t\t\t\\\n+      \"adding to terminated block: %s (already terminated by: %s)\",\t\\\n+      (BLOCK)->get_debug_string (),\t\t\t\t\t\\\n+      (BLOCK)->get_last_statement ()->get_debug_string ());\t\t\\\n+  JIT_END_STMT\n+\n+/* Format the given string, and report it as an error, either on CTXT\n+   if non-NULL, or by printing to stderr if we have a NULL context.\n+   LOC gives the source location where the error occcurred, and can be\n+   NULL.  */\n+\n+static void\n+jit_error (gcc::jit::recording::context *ctxt,\n+\t   gcc_jit_location *loc,\n+\t   const char *fmt, ...)\n+  GNU_PRINTF(3, 4);\n+\n+static void\n+jit_error (gcc::jit::recording::context *ctxt,\n+\t   gcc_jit_location *loc,\n+\t   const char *fmt, ...)\n+{\n+  va_list ap;\n+  va_start (ap, fmt);\n+\n+  if (ctxt)\n+    ctxt->add_error_va (loc, fmt, ap);\n+  else\n+    {\n+      /* No context?  Send to stderr.  */\n+      vfprintf (stderr, fmt, ap);\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  va_end (ap);\n+}\n+\n+/* Determine whether or not we can write to lvalues of type LTYPE from\n+   rvalues of type RTYPE, detecting type errors such as attempting to\n+   write to an int with a string literal (without an explicit cast).\n+\n+   This is implemented by calling the\n+   gcc::jit::recording::type::accepts_writes_from virtual function on\n+   LTYPE.  */\n+\n+static bool\n+compatible_types (gcc::jit::recording::type *ltype,\n+\t\t  gcc::jit::recording::type *rtype)\n+{\n+  return ltype->accepts_writes_from (rtype);\n+}\n+\n+/* Public entrypoint for acquiring a gcc_jit_context.\n+   Note that this creates a new top-level context; contrast with\n+   gcc_jit_context_new_child_context below.\n+\n+   The real work is done in the constructor for\n+   gcc::jit::recording::context in jit-recording.c. */\n+\n+gcc_jit_context *\n+gcc_jit_context_acquire (void)\n+{\n+  return new gcc_jit_context (NULL);\n+}\n+\n+/* Public entrypoint for releasing a gcc_jit_context.\n+   The real work is done in the destructor for\n+   gcc::jit::recording::context in jit-recording.c.  */\n+\n+void\n+gcc_jit_context_release (gcc_jit_context *ctxt)\n+{\n+  delete ctxt;\n+}\n+\n+/* Public entrypoint for creating a child context within\n+   PARENT_CTXT.  See description in libgccjit.h.\n+\n+   The real work is done in the constructor for\n+   gcc::jit::recording::context in jit-recording.c. */\n+\n+gcc_jit_context *\n+gcc_jit_context_new_child_context (gcc_jit_context *parent_ctxt)\n+{\n+  return new gcc_jit_context (parent_ctxt);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+     gcc::jit::recording::context::new_location\n+   method in jit-recording.c.  */\n+\n+gcc_jit_location *\n+gcc_jit_context_new_location (gcc_jit_context *ctxt,\n+\t\t\t      const char *filename,\n+\t\t\t      int line,\n+\t\t\t      int column)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+\n+  return (gcc_jit_location *)ctxt->new_location (filename, line, column);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a location is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_location_as_object (gcc_jit_location *loc)\n+{\n+  RETURN_NULL_IF_FAIL (loc, NULL, NULL, \"NULL location\");\n+\n+  return static_cast <gcc_jit_object *> (loc->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a type is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_type_as_object (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return static_cast <gcc_jit_object *> (type->as_object ());\n+}\n+\n+/* Public entrypoint for getting a specific type from a context.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::get_type method, in\n+   jit-recording.c  */\n+\n+gcc_jit_type *\n+gcc_jit_context_get_type (gcc_jit_context *ctxt,\n+\t\t\t  enum gcc_jit_types type)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    (type >= GCC_JIT_TYPE_VOID\n+     && type <= GCC_JIT_TYPE_FILE_PTR),\n+    ctxt, NULL,\n+    \"unrecognized value for enum gcc_jit_types: %i\", type);\n+\n+  return (gcc_jit_type *)ctxt->get_type (type);\n+}\n+\n+/* Public entrypoint for getting the integer type of the given size and\n+   signedness.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::get_int_type method,\n+   in jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_context_get_int_type (gcc_jit_context *ctxt,\n+\t\t\t      int num_bytes, int is_signed)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL (num_bytes >= 0, ctxt, NULL, \"negative size\");\n+\n+  return (gcc_jit_type *)ctxt->get_int_type (num_bytes, is_signed);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::get_pointer method, in\n+   jit-recording.c  */\n+\n+gcc_jit_type *\n+gcc_jit_type_get_pointer (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return (gcc_jit_type *)type->get_pointer ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::get_const method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_type_get_const (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return (gcc_jit_type *)type->get_const ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::get_volatile method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_type_get_volatile (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return (gcc_jit_type *)type->get_volatile ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_array_type method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_context_new_array_type (gcc_jit_context *ctxt,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tgcc_jit_type *element_type,\n+\t\t\t\tint num_elements)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (element_type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL (num_elements >= 0, ctxt, NULL, \"negative size\");\n+\n+  return (gcc_jit_type *)ctxt->new_array_type (loc,\n+\t\t\t\t\t       element_type,\n+\t\t\t\t\t       num_elements);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_field method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_field *\n+gcc_jit_context_new_field (gcc_jit_context *ctxt,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   gcc_jit_type *type,\n+\t\t\t   const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+\n+  return (gcc_jit_field *)ctxt->new_field (loc, type, name);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a field is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_field_as_object (gcc_jit_field *field)\n+{\n+  RETURN_NULL_IF_FAIL (field, NULL, NULL, \"NULL field\");\n+\n+  return static_cast <gcc_jit_object *> (field->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_struct_type method,\n+   immediately followed by a \"set_fields\" call on the resulting\n+   gcc::jit::recording::compound_type *, both in jit-recording.c  */\n+\n+gcc_jit_struct *\n+gcc_jit_context_new_struct_type (gcc_jit_context *ctxt,\n+\t\t\t\t gcc_jit_location *loc,\n+\t\t\t\t const char *name,\n+\t\t\t\t int num_fields,\n+\t\t\t\t gcc_jit_field **fields)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+  if (num_fields)\n+    RETURN_NULL_IF_FAIL (fields, ctxt, loc, \"NULL fields ptr\");\n+  for (int i = 0; i < num_fields; i++)\n+    {\n+      RETURN_NULL_IF_FAIL (fields[i], ctxt, loc, \"NULL field ptr\");\n+      RETURN_NULL_IF_FAIL_PRINTF2 (\n+\tNULL == fields[i]->get_container (),\n+\tctxt, loc,\n+\t\"%s is already a field of %s\",\n+\tfields[i]->get_debug_string (),\n+\tfields[i]->get_container ()->get_debug_string ());\n+    }\n+\n+  gcc::jit::recording::struct_ *result =\n+    ctxt->new_struct_type (loc, name);\n+  result->set_fields (loc,\n+\t\t      num_fields,\n+\t\t      (gcc::jit::recording::field **)fields);\n+  return static_cast<gcc_jit_struct *> (result);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_struct_type method in\n+   jit-recording.c.  */\n+\n+gcc_jit_struct *\n+gcc_jit_context_new_opaque_struct (gcc_jit_context *ctxt,\n+\t\t\t\t   gcc_jit_location *loc,\n+\t\t\t\t   const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+\n+  return (gcc_jit_struct *)ctxt->new_struct_type (loc, name);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::struct_::as_object method in\n+   jit-recording.h.  */\n+\n+gcc_jit_type *\n+gcc_jit_struct_as_type (gcc_jit_struct *struct_type)\n+{\n+  RETURN_NULL_IF_FAIL (struct_type, NULL, NULL, \"NULL struct_type\");\n+\n+  return static_cast <gcc_jit_type *> (struct_type->as_type ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::compound_type::set_fields method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   int num_fields,\n+\t\t\t   gcc_jit_field **fields)\n+{\n+  RETURN_IF_FAIL (struct_type, NULL, loc, \"NULL struct_type\");\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = struct_type->m_ctxt;\n+  RETURN_IF_FAIL_PRINTF1 (\n+    NULL == struct_type->get_fields (), ctxt, loc,\n+    \"%s already has had fields set\",\n+    struct_type->get_debug_string ());\n+  if (num_fields)\n+    RETURN_IF_FAIL (fields, ctxt, loc, \"NULL fields ptr\");\n+  for (int i = 0; i < num_fields; i++)\n+    {\n+      RETURN_IF_FAIL (fields[i], ctxt, loc, \"NULL field ptr\");\n+      RETURN_IF_FAIL_PRINTF2 (\n+\tNULL == fields[i]->get_container (),\n+\tctxt, loc,\n+\t\"%s is already a field of %s\",\n+\tfields[i]->get_debug_string (),\n+\tfields[i]->get_container ()->get_debug_string ());\n+    }\n+\n+  struct_type->set_fields (loc, num_fields,\n+\t\t\t   (gcc::jit::recording::field **)fields);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_union_type method,\n+   immediately followed by a \"set_fields\" call on the resulting\n+   gcc::jit::recording::compound_type *, both in jit-recording.c  */\n+\n+gcc_jit_type *\n+gcc_jit_context_new_union_type (gcc_jit_context *ctxt,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tconst char *name,\n+\t\t\t\tint num_fields,\n+\t\t\t\tgcc_jit_field **fields)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+  if (num_fields)\n+    RETURN_NULL_IF_FAIL (fields, ctxt, loc, \"NULL fields ptr\");\n+  for (int i = 0; i < num_fields; i++)\n+    {\n+      RETURN_NULL_IF_FAIL (fields[i], ctxt, loc, \"NULL field ptr\");\n+      RETURN_NULL_IF_FAIL_PRINTF2 (\n+\tNULL == fields[i]->get_container (),\n+\tctxt, loc,\n+\t\"%s is already a field of %s\",\n+\tfields[i]->get_debug_string (),\n+\tfields[i]->get_container ()->get_debug_string ());\n+    }\n+\n+  gcc::jit::recording::union_ *result =\n+    ctxt->new_union_type (loc, name);\n+  result->set_fields (loc,\n+\t\t      num_fields,\n+\t\t      (gcc::jit::recording::field **)fields);\n+  return (gcc_jit_type *) (result);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_function_ptr_type method,\n+   in jit-recording.c  */\n+\n+gcc_jit_type *\n+gcc_jit_context_new_function_ptr_type (gcc_jit_context *ctxt,\n+\t\t\t\t       gcc_jit_location *loc,\n+\t\t\t\t       gcc_jit_type *return_type,\n+\t\t\t\t       int num_params,\n+\t\t\t\t       gcc_jit_type **param_types,\n+\t\t\t\t       int is_variadic)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (return_type, ctxt, loc, \"NULL return_type\");\n+  RETURN_NULL_IF_FAIL (\n+    (num_params == 0) || param_types,\n+    ctxt, loc,\n+    \"NULL param_types creating function pointer type\");\n+  for (int i = 0; i < num_params; i++)\n+    RETURN_NULL_IF_FAIL_PRINTF1 (\n+      param_types[i],\n+      ctxt, loc,\n+      \"NULL parameter type %i creating function pointer type\", i);\n+\n+  return (gcc_jit_type*)\n+    ctxt->new_function_ptr_type (loc, return_type,\n+\t\t\t\t num_params,\n+\t\t\t\t (gcc::jit::recording::type **)param_types,\n+\t\t\t\t is_variadic);\n+}\n+\n+/* Constructing functions.  */\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_param method, in jit-recording.c  */\n+\n+gcc_jit_param *\n+gcc_jit_context_new_param (gcc_jit_context *ctxt,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   gcc_jit_type *type,\n+\t\t\t   const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+\n+  return (gcc_jit_param *)ctxt->new_param (loc, type, name);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a param is a memento),\n+   in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_param_as_object (gcc_jit_param *param)\n+{\n+  RETURN_NULL_IF_FAIL (param, NULL, NULL, \"NULL param\");\n+\n+  return static_cast <gcc_jit_object *> (param->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::param::as_lvalue method in jit-recording.h.  */\n+\n+gcc_jit_lvalue *\n+gcc_jit_param_as_lvalue (gcc_jit_param *param)\n+{\n+  RETURN_NULL_IF_FAIL (param, NULL, NULL, \"NULL param\");\n+\n+  return (gcc_jit_lvalue *)param->as_lvalue ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::lvalue::as_rvalue method (a param is an rvalue),\n+   in jit-recording.h.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_param_as_rvalue (gcc_jit_param *param)\n+{\n+  RETURN_NULL_IF_FAIL (param, NULL, NULL, \"NULL param\");\n+\n+  return (gcc_jit_rvalue *)param->as_rvalue ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_function method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_function *\n+gcc_jit_context_new_function (gcc_jit_context *ctxt,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      enum gcc_jit_function_kind kind,\n+\t\t\t      gcc_jit_type *return_type,\n+\t\t\t      const char *name,\n+\t\t\t      int num_params,\n+\t\t\t      gcc_jit_param **params,\n+\t\t\t      int is_variadic)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    ((kind >= GCC_JIT_FUNCTION_EXPORTED)\n+     && (kind <= GCC_JIT_FUNCTION_ALWAYS_INLINE)),\n+    ctxt, loc,\n+    \"unrecognized value for enum gcc_jit_function_kind: %i\",\n+    kind);\n+  RETURN_NULL_IF_FAIL (return_type, ctxt, loc, \"NULL return_type\");\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+  /* The assembler can only handle certain names, so for now, enforce\n+     C's rules for identiers upon the name, using ISALPHA and ISALNUM\n+     from safe-ctype.h to ignore the current locale.\n+     Eventually we'll need some way to interact with e.g. C++ name\n+     mangling.  */\n+  {\n+    /* Leading char: */\n+    char ch = *name;\n+    RETURN_NULL_IF_FAIL_PRINTF2 (\n+\tISALPHA (ch) || ch == '_',\n+\tctxt, loc,\n+\t\"name \\\"%s\\\" contains invalid character: '%c'\",\n+\tname, ch);\n+    /* Subsequent chars: */\n+    for (const char *ptr = name + 1; (ch = *ptr); ptr++)\n+      {\n+\tRETURN_NULL_IF_FAIL_PRINTF2 (\n+\t  ISALNUM (ch) || ch == '_',\n+\t  ctxt, loc,\n+\t  \"name \\\"%s\\\" contains invalid character: '%c'\",\n+\t  name, ch);\n+      }\n+  }\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    (num_params == 0) || params,\n+    ctxt, loc,\n+    \"NULL params creating function %s\", name);\n+  for (int i = 0; i < num_params; i++)\n+    RETURN_NULL_IF_FAIL_PRINTF2 (\n+      params[i],\n+      ctxt, loc,\n+      \"NULL parameter %i creating function %s\", i, name);\n+\n+  return (gcc_jit_function*)\n+    ctxt->new_function (loc, kind, return_type, name,\n+\t\t\tnum_params,\n+\t\t\t(gcc::jit::recording::param **)params,\n+\t\t\tis_variadic,\n+\t\t\tBUILT_IN_NONE);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::get_builtin_function method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_function *\n+gcc_jit_context_get_builtin_function (gcc_jit_context *ctxt,\n+\t\t\t\t      const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL (name, ctxt, NULL, \"NULL name\");\n+\n+  return static_cast <gcc_jit_function *> (ctxt->get_builtin_function (name));\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a function is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_function_as_object (gcc_jit_function *func)\n+{\n+  RETURN_NULL_IF_FAIL (func, NULL, NULL, \"NULL function\");\n+\n+  return static_cast <gcc_jit_object *> (func->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function::get_param method, in\n+   jit-recording.h.  */\n+\n+gcc_jit_param *\n+gcc_jit_function_get_param (gcc_jit_function *func, int index)\n+{\n+  RETURN_NULL_IF_FAIL (func, NULL, NULL, \"NULL function\");\n+  gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  RETURN_NULL_IF_FAIL (index >= 0, ctxt, NULL, \"negative index\");\n+  int num_params = func->get_params ().length ();\n+  RETURN_NULL_IF_FAIL_PRINTF3 (index < num_params,\n+\t\t\t       ctxt, NULL,\n+\t\t\t       \"index of %d is too large (%s has %d params)\",\n+\t\t\t       index,\n+\t\t\t       func->get_debug_string (),\n+\t\t\t       num_params);\n+\n+  return static_cast <gcc_jit_param *> (func->get_param (index));\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function::dump_to_dot method, in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_function_dump_to_dot (gcc_jit_function *func,\n+\t\t\t      const char *path)\n+{\n+  RETURN_IF_FAIL (func, NULL, NULL, \"NULL function\");\n+  gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  RETURN_IF_FAIL (path, ctxt, NULL, \"NULL path\");\n+\n+  func->dump_to_dot (path);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function::new_block method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_block*\n+gcc_jit_function_new_block (gcc_jit_function *func,\n+\t\t\t    const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (func, NULL, NULL, \"NULL function\");\n+  RETURN_NULL_IF_FAIL (func->get_kind () != GCC_JIT_FUNCTION_IMPORTED,\n+\t\t       func->get_context (), NULL,\n+\t\t       \"cannot add block to an imported function\");\n+  /* name can be NULL.  */\n+\n+  return (gcc_jit_block *)func->new_block (name);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a block is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_block_as_object (gcc_jit_block *block)\n+{\n+  RETURN_NULL_IF_FAIL (block, NULL, NULL, \"NULL block\");\n+\n+  return static_cast <gcc_jit_object *> (block->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::get_function method, in\n+   jit-recording.h.  */\n+\n+gcc_jit_function *\n+gcc_jit_block_get_function (gcc_jit_block *block)\n+{\n+  RETURN_NULL_IF_FAIL (block, NULL, NULL, \"NULL block\");\n+\n+  return static_cast <gcc_jit_function *> (block->get_function ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_global method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_lvalue *\n+gcc_jit_context_new_global (gcc_jit_context *ctxt,\n+\t\t\t    gcc_jit_location *loc,\n+\t\t\t    gcc_jit_type *type,\n+\t\t\t    const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+\n+  return (gcc_jit_lvalue *)ctxt->new_global (loc, type, name);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (an lvalue is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_lvalue_as_object (gcc_jit_lvalue *lvalue)\n+{\n+  RETURN_NULL_IF_FAIL (lvalue, NULL, NULL, \"NULL lvalue\");\n+\n+  return static_cast <gcc_jit_object *> (lvalue->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::lvalue::as_rvalue method in jit-recording.h.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_lvalue_as_rvalue (gcc_jit_lvalue *lvalue)\n+{\n+  RETURN_NULL_IF_FAIL (lvalue, NULL, NULL, \"NULL lvalue\");\n+\n+  return (gcc_jit_rvalue *)lvalue->as_rvalue ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (an rvalue is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_rvalue_as_object (gcc_jit_rvalue *rvalue)\n+{\n+  RETURN_NULL_IF_FAIL (rvalue, NULL, NULL, \"NULL rvalue\");\n+\n+  return static_cast <gcc_jit_object *> (rvalue->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::rvalue::get_type method, in\n+   jit-recording.h.  */\n+\n+gcc_jit_type *\n+gcc_jit_rvalue_get_type (gcc_jit_rvalue *rvalue)\n+{\n+  RETURN_NULL_IF_FAIL (rvalue, NULL, NULL, \"NULL rvalue\");\n+\n+  return static_cast <gcc_jit_type *> (rvalue->get_type ());\n+}\n+\n+/* Verify that NUMERIC_TYPE is non-NULL, and that it is a \"numeric\"\n+   type i.e. it satisfies gcc::jit::type::is_numeric (), such as the\n+   result of gcc_jit_context_get_type (GCC_JIT_TYPE_INT).  */\n+\n+#define RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE(CTXT, NUMERIC_TYPE) \\\n+  RETURN_NULL_IF_FAIL (NUMERIC_TYPE, CTXT, NULL, \"NULL type\"); \\\n+  RETURN_NULL_IF_FAIL_PRINTF1 (                                \\\n+    NUMERIC_TYPE->is_numeric (), ctxt, NULL,                   \\\n+    \"not a numeric type: %s\",                                  \\\n+    NUMERIC_TYPE->get_debug_string ());\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_rvalue_from_int method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_int (gcc_jit_context *ctxt,\n+\t\t\t\t     gcc_jit_type *numeric_type,\n+\t\t\t\t     int value)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n+\n+  return (gcc_jit_rvalue *)ctxt->new_rvalue_from_int (numeric_type, value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   This is essentially equivalent to:\n+      gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 0);\n+   albeit with slightly different error messages if an error occurs.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_zero (gcc_jit_context *ctxt,\n+\t\t      gcc_jit_type *numeric_type)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n+\n+  return gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 0);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   This is essentially equivalent to:\n+      gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 1);\n+   albeit with slightly different error messages if an error occurs.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_one (gcc_jit_context *ctxt,\n+\t\t     gcc_jit_type *numeric_type)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n+\n+  return gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 1);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_rvalue_from_double method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_double (gcc_jit_context *ctxt,\n+\t\t\t\t\tgcc_jit_type *numeric_type,\n+\t\t\t\t\tdouble value)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n+\n+  return (gcc_jit_rvalue *)ctxt->new_rvalue_from_double (numeric_type, value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_rvalue_from_ptr method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_ptr (gcc_jit_context *ctxt,\n+\t\t\t\t     gcc_jit_type *pointer_type,\n+\t\t\t\t     void *value)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL (pointer_type, ctxt, NULL, \"NULL type\");\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    pointer_type->is_pointer (),\n+    ctxt, NULL,\n+    \"not a pointer type (type: %s)\",\n+    pointer_type->get_debug_string ());\n+\n+  return (gcc_jit_rvalue *)ctxt->new_rvalue_from_ptr (pointer_type, value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   This is essentially equivalent to:\n+      gcc_jit_context_new_rvalue_from_ptr (ctxt, pointer_type, NULL);\n+   albeit with slightly different error messages if an error occurs.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_null (gcc_jit_context *ctxt,\n+\t\t      gcc_jit_type *pointer_type)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL (pointer_type, ctxt, NULL, \"NULL type\");\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    pointer_type->is_pointer (),\n+    ctxt, NULL,\n+    \"not a pointer type (type: %s)\",\n+    pointer_type->get_debug_string ());\n+\n+  return gcc_jit_context_new_rvalue_from_ptr (ctxt, pointer_type, NULL);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_string_literal method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_string_literal (gcc_jit_context *ctxt,\n+\t\t\t\t    const char *value)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_NULL_IF_FAIL (value, ctxt, NULL, \"NULL value\");\n+\n+  return (gcc_jit_rvalue *)ctxt->new_string_literal (value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_unary_op method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_unary_op (gcc_jit_context *ctxt,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      enum gcc_jit_unary_op op,\n+\t\t\t      gcc_jit_type *result_type,\n+\t\t\t      gcc_jit_rvalue *rvalue)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    (op >= GCC_JIT_UNARY_OP_MINUS\n+     && op <= GCC_JIT_UNARY_OP_LOGICAL_NEGATE),\n+    ctxt, loc,\n+    \"unrecognized value for enum gcc_jit_unary_op: %i\",\n+    op);\n+  RETURN_NULL_IF_FAIL (result_type, ctxt, loc, \"NULL result_type\");\n+  RETURN_NULL_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n+\n+  return (gcc_jit_rvalue *)ctxt->new_unary_op (loc, op, result_type, rvalue);\n+}\n+\n+/* Determine if OP is a valid value for enum gcc_jit_binary_op.\n+   For use by both gcc_jit_context_new_binary_op and\n+   gcc_jit_block_add_assignment_op.  */\n+\n+static bool\n+valid_binary_op_p (enum gcc_jit_binary_op op)\n+{\n+  return (op >= GCC_JIT_BINARY_OP_PLUS\n+\t  && op <= GCC_JIT_BINARY_OP_RSHIFT);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_binary_op method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_binary_op (gcc_jit_context *ctxt,\n+\t\t\t       gcc_jit_location *loc,\n+\t\t\t       enum gcc_jit_binary_op op,\n+\t\t\t       gcc_jit_type *result_type,\n+\t\t\t       gcc_jit_rvalue *a, gcc_jit_rvalue *b)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    valid_binary_op_p (op),\n+    ctxt, loc,\n+    \"unrecognized value for enum gcc_jit_binary_op: %i\",\n+    op);\n+  RETURN_NULL_IF_FAIL (result_type, ctxt, loc, \"NULL result_type\");\n+  RETURN_NULL_IF_FAIL (a, ctxt, loc, \"NULL a\");\n+  RETURN_NULL_IF_FAIL (b, ctxt, loc, \"NULL b\");\n+  RETURN_NULL_IF_FAIL_PRINTF4 (\n+    a->get_type () == b->get_type (),\n+    ctxt, loc,\n+    \"mismatching types for binary op:\"\n+    \" a: %s (type: %s) b: %s (type: %s)\",\n+    a->get_debug_string (),\n+    a->get_type ()->get_debug_string (),\n+    b->get_debug_string (),\n+    b->get_type ()->get_debug_string ());\n+\n+  return (gcc_jit_rvalue *)ctxt->new_binary_op (loc, op, result_type, a, b);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_comparison method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_comparison (gcc_jit_context *ctxt,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tenum gcc_jit_comparison op,\n+\t\t\t\tgcc_jit_rvalue *a, gcc_jit_rvalue *b)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL_PRINTF1 (\n+    (op >= GCC_JIT_COMPARISON_EQ\n+     && op <= GCC_JIT_COMPARISON_GE),\n+    ctxt, loc,\n+    \"unrecognized value for enum gcc_jit_comparison: %i\",\n+    op);\n+  RETURN_NULL_IF_FAIL (a, ctxt, loc, \"NULL a\");\n+  RETURN_NULL_IF_FAIL (b, ctxt, loc, \"NULL b\");\n+  RETURN_NULL_IF_FAIL_PRINTF4 (\n+    a->get_type ()->unqualified () == b->get_type ()->unqualified (),\n+    ctxt, loc,\n+    \"mismatching types for comparison:\"\n+    \" a: %s (type: %s) b: %s (type: %s)\",\n+    a->get_debug_string (),\n+    a->get_type ()->get_debug_string (),\n+    b->get_debug_string (),\n+    b->get_type ()->get_debug_string ());\n+\n+  return (gcc_jit_rvalue *)ctxt->new_comparison (loc, op, a, b);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_call method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_call (gcc_jit_context *ctxt,\n+\t\t\t  gcc_jit_location *loc,\n+\t\t\t  gcc_jit_function *func,\n+\t\t\t  int numargs , gcc_jit_rvalue **args)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (func, ctxt, loc, \"NULL function\");\n+  if (numargs)\n+    RETURN_NULL_IF_FAIL (args, ctxt, loc, \"NULL args\");\n+\n+  int min_num_params = func->get_params ().length ();\n+  bool is_variadic = func->is_variadic ();\n+\n+  RETURN_NULL_IF_FAIL_PRINTF3 (\n+    numargs >= min_num_params,\n+    ctxt, loc,\n+    \"not enough arguments to function \\\"%s\\\"\"\n+    \" (got %i args, expected %i)\",\n+    func->get_name ()->c_str (),\n+    numargs, min_num_params);\n+\n+  RETURN_NULL_IF_FAIL_PRINTF3 (\n+    (numargs == min_num_params || is_variadic),\n+    ctxt, loc,\n+    \"too many arguments to function \\\"%s\\\"\"\n+    \" (got %i args, expected %i)\",\n+    func->get_name ()->c_str (),\n+    numargs, min_num_params);\n+\n+  for (int i = 0; i < min_num_params; i++)\n+    {\n+      gcc::jit::recording::param *param = func->get_param (i);\n+      gcc_jit_rvalue *arg = args[i];\n+\n+      RETURN_NULL_IF_FAIL_PRINTF4 (\n+\targ,\n+\tctxt, loc,\n+\t\"NULL argument %i to function \\\"%s\\\":\"\n+\t\" param %s (type: %s)\",\n+\ti + 1,\n+\tfunc->get_name ()->c_str (),\n+\tparam->get_debug_string (),\n+\tparam->get_type ()->get_debug_string ());\n+\n+      RETURN_NULL_IF_FAIL_PRINTF6 (\n+\tcompatible_types (param->get_type (),\n+\t\t\t  arg->get_type ()),\n+\tctxt, loc,\n+\t\"mismatching types for argument %d of function \\\"%s\\\":\"\n+\t\" assignment to param %s (type: %s) from %s (type: %s)\",\n+\ti + 1,\n+\tfunc->get_name ()->c_str (),\n+\tparam->get_debug_string (),\n+\tparam->get_type ()->get_debug_string (),\n+\targ->get_debug_string (),\n+\targ->get_type ()->get_debug_string ());\n+    }\n+\n+  return (gcc_jit_rvalue *)ctxt->new_call (loc,\n+\t\t\t\t\t   func,\n+\t\t\t\t\t   numargs,\n+\t\t\t\t\t   (gcc::jit::recording::rvalue **)args);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_call_through_ptr method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_call_through_ptr (gcc_jit_context *ctxt,\n+\t\t\t\t      gcc_jit_location *loc,\n+\t\t\t\t      gcc_jit_rvalue *fn_ptr,\n+\t\t\t\t      int numargs, gcc_jit_rvalue **args)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (fn_ptr, ctxt, loc, \"NULL fn_ptr\");\n+  if (numargs)\n+    RETURN_NULL_IF_FAIL (args, ctxt, loc, \"NULL args\");\n+\n+  gcc::jit::recording::type *ptr_type = fn_ptr->get_type ()->dereference ();\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    ptr_type, ctxt, loc,\n+    \"fn_ptr is not a ptr: %s\"\n+    \" type: %s\",\n+    fn_ptr->get_debug_string (),\n+    fn_ptr->get_type ()->get_debug_string ());\n+\n+  gcc::jit::recording::function_type *fn_type =\n+    ptr_type->dyn_cast_function_type();\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    fn_type, ctxt, loc,\n+    \"fn_ptr is not a function ptr: %s\"\n+    \" type: %s\",\n+    fn_ptr->get_debug_string (),\n+    fn_ptr->get_type ()->get_debug_string ());\n+\n+  int min_num_params = fn_type->get_param_types ().length ();\n+  bool is_variadic = fn_type->is_variadic ();\n+\n+  RETURN_NULL_IF_FAIL_PRINTF3 (\n+    numargs >= min_num_params,\n+    ctxt, loc,\n+    \"not enough arguments to fn_ptr: %s\"\n+    \" (got %i args, expected %i)\",\n+    fn_ptr->get_debug_string (),\n+    numargs, min_num_params);\n+\n+  RETURN_NULL_IF_FAIL_PRINTF3 (\n+    (numargs == min_num_params || is_variadic),\n+    ctxt, loc,\n+    \"too many arguments to fn_ptr: %s\"\n+    \" (got %i args, expected %i)\",\n+    fn_ptr->get_debug_string (),\n+    numargs, min_num_params);\n+\n+  for (int i = 0; i < min_num_params; i++)\n+    {\n+      gcc::jit::recording::type *param_type = fn_type->get_param_types ()[i];\n+      gcc_jit_rvalue *arg = args[i];\n+\n+      RETURN_NULL_IF_FAIL_PRINTF3 (\n+\targ,\n+\tctxt, loc,\n+\t\"NULL argument %i to fn_ptr: %s\"\n+\t\" (type: %s)\",\n+\ti + 1,\n+\tfn_ptr->get_debug_string (),\n+\tparam_type->get_debug_string ());\n+\n+      RETURN_NULL_IF_FAIL_PRINTF6 (\n+\tcompatible_types (param_type,\n+\t\t\t  arg->get_type ()),\n+\tctxt, loc,\n+\t\"mismatching types for argument %d of fn_ptr: %s:\"\n+\t\" assignment to param %d (type: %s) from %s (type: %s)\",\n+\ti + 1,\n+\tfn_ptr->get_debug_string (),\n+\ti + 1,\n+\tparam_type->get_debug_string (),\n+\targ->get_debug_string (),\n+\targ->get_type ()->get_debug_string ());\n+    }\n+\n+  return (gcc_jit_rvalue *)(\n+\t    ctxt->new_call_through_ptr (loc,\n+\t\t\t\t\tfn_ptr,\n+\t\t\t\t\tnumargs,\n+\t\t\t\t\t(gcc::jit::recording::rvalue **)args));\n+}\n+\n+/* Helper function for determining if we can cast an rvalue from SRC_TYPE\n+   to DST_TYPE, for use by gcc_jit_context_new_cast.\n+\n+   We only permit these kinds of cast:\n+\n+     int <-> float\n+     int <-> bool\n+     P*  <-> Q*   for pointer types P and Q.  */\n+\n+static bool\n+is_valid_cast (gcc::jit::recording::type *src_type,\n+\t       gcc_jit_type *dst_type)\n+{\n+  bool src_is_int = src_type->is_int ();\n+  bool dst_is_int = dst_type->is_int ();\n+  bool src_is_float = src_type->is_float ();\n+  bool dst_is_float = dst_type->is_float ();\n+  bool src_is_bool = src_type->is_bool ();\n+  bool dst_is_bool = dst_type->is_bool ();\n+\n+  if (src_is_int)\n+    if (dst_is_int || dst_is_float || dst_is_bool)\n+      return true;\n+\n+  if (src_is_float)\n+    if (dst_is_int || dst_is_float)\n+      return true;\n+\n+  if (src_is_bool)\n+    if (dst_is_int || dst_is_bool)\n+      return true;\n+\n+  /* Permit casts between pointer types.  */\n+  gcc::jit::recording::type *deref_src_type = src_type->is_pointer ();\n+  gcc::jit::recording::type *deref_dst_type = dst_type->is_pointer ();\n+  if (deref_src_type && deref_dst_type)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_cast method in jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_context_new_cast (gcc_jit_context *ctxt,\n+\t\t\t  gcc_jit_location *loc,\n+\t\t\t  gcc_jit_rvalue *rvalue,\n+\t\t\t  gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL_PRINTF3 (\n+    is_valid_cast (rvalue->get_type (), type),\n+    ctxt, loc,\n+    \"cannot cast %s from type: %s to type: %s\",\n+    rvalue->get_debug_string (),\n+    rvalue->get_type ()->get_debug_string (),\n+    type->get_debug_string ());\n+\n+  return static_cast <gcc_jit_rvalue *> (ctxt->new_cast (loc, rvalue, type));\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_array_access method in\n+   jit-recording.c.  */\n+\n+extern gcc_jit_lvalue *\n+gcc_jit_context_new_array_access (gcc_jit_context *ctxt,\n+\t\t\t\t  gcc_jit_location *loc,\n+\t\t\t\t  gcc_jit_rvalue *ptr,\n+\t\t\t\t  gcc_jit_rvalue *index)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (ptr, ctxt, loc, \"NULL ptr\");\n+  RETURN_NULL_IF_FAIL (index, ctxt, loc, \"NULL index\");\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    ptr->get_type ()->dereference (),\n+    ctxt, loc,\n+    \"ptr: %s (type: %s) is not a pointer or array\",\n+    ptr->get_debug_string (),\n+    ptr->get_type ()->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    index->get_type ()->is_numeric (),\n+    ctxt, loc,\n+    \"index: %s (type: %s) is not of numeric type\",\n+    index->get_debug_string (),\n+    index->get_type ()->get_debug_string ());\n+\n+  return (gcc_jit_lvalue *)ctxt->new_array_access (loc, ptr, index);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::memento::get_context method in\n+   jit-recording.h.  */\n+\n+gcc_jit_context *\n+gcc_jit_object_get_context (gcc_jit_object *obj)\n+{\n+  RETURN_NULL_IF_FAIL (obj, NULL, NULL, \"NULL object\");\n+\n+  return static_cast <gcc_jit_context *> (obj->get_context ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::memento::get_debug_string method in\n+   jit-recording.c.  */\n+\n+const char *\n+gcc_jit_object_get_debug_string (gcc_jit_object *obj)\n+{\n+  RETURN_NULL_IF_FAIL (obj, NULL, NULL, \"NULL object\");\n+\n+  return obj->get_debug_string ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::lvalue::access_field method in\n+   jit-recording.c.  */\n+\n+gcc_jit_lvalue *\n+gcc_jit_lvalue_access_field (gcc_jit_lvalue *struct_,\n+\t\t\t     gcc_jit_location *loc,\n+\t\t\t     gcc_jit_field *field)\n+{\n+  RETURN_NULL_IF_FAIL (struct_, NULL, loc, \"NULL struct\");\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = struct_->m_ctxt;\n+  RETURN_NULL_IF_FAIL (field, ctxt, loc, \"NULL field\");\n+  RETURN_NULL_IF_FAIL_PRINTF1 (field->get_container (), field->m_ctxt, loc,\n+\t\t\t       \"field %s has not been placed in a struct\",\n+\t\t\t       field->get_debug_string ());\n+\n+  return (gcc_jit_lvalue *)struct_->access_field (loc, field);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::rvalue::access_field method in\n+   jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_rvalue_access_field (gcc_jit_rvalue *struct_,\n+\t\t\t     gcc_jit_location *loc,\n+\t\t\t     gcc_jit_field *field)\n+{\n+  RETURN_NULL_IF_FAIL (struct_, NULL, loc, \"NULL struct\");\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = struct_->m_ctxt;\n+  RETURN_NULL_IF_FAIL (field, ctxt, loc, \"NULL field\");\n+  RETURN_NULL_IF_FAIL_PRINTF1 (field->get_container (), field->m_ctxt, loc,\n+\t\t\t       \"field %s has not been placed in a struct\",\n+\t\t\t       field->get_debug_string ());\n+\n+  return (gcc_jit_rvalue *)struct_->access_field (loc, field);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::rvalue::deference_field method in\n+   jit-recording.c.  */\n+\n+gcc_jit_lvalue *\n+gcc_jit_rvalue_dereference_field (gcc_jit_rvalue *ptr,\n+\t\t\t\t  gcc_jit_location *loc,\n+\t\t\t\t  gcc_jit_field *field)\n+{\n+  RETURN_NULL_IF_FAIL (ptr, NULL, loc, \"NULL ptr\");\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (field, NULL, loc, \"NULL field\");\n+  gcc::jit::recording::type *underlying_type =\n+    ptr->get_type ()->is_pointer ();\n+  RETURN_NULL_IF_FAIL_PRINTF1 (field->get_container (), field->m_ctxt, loc,\n+\t\t\t       \"field %s has not been placed in a struct\",\n+\t\t\t       field->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF3 (\n+    underlying_type,\n+    ptr->m_ctxt, loc,\n+    \"dereference of non-pointer %s (type: %s) when accessing ->%s\",\n+    ptr->get_debug_string (),\n+    ptr->get_type ()->get_debug_string (),\n+    field->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    (field->get_container ()->unqualified ()\n+     == underlying_type->unqualified ()),\n+    ptr->m_ctxt, loc,\n+    \"%s is not a field of %s\",\n+    field->get_debug_string (),\n+    underlying_type->get_debug_string ());\n+\n+  return (gcc_jit_lvalue *)ptr->dereference_field (loc, field);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::rvalue::deference method in\n+   jit-recording.c.  */\n+\n+gcc_jit_lvalue *\n+gcc_jit_rvalue_dereference (gcc_jit_rvalue *rvalue,\n+\t\t\t    gcc_jit_location *loc)\n+{\n+  RETURN_NULL_IF_FAIL (rvalue, NULL, loc, \"NULL rvalue\");\n+  /* LOC can be NULL.  */\n+\n+  gcc::jit::recording::type *underlying_type =\n+    rvalue->get_type ()->is_pointer ();\n+\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    underlying_type,\n+    rvalue->m_ctxt, loc,\n+    \"dereference of non-pointer %s (type: %s)\",\n+    rvalue->get_debug_string (),\n+    rvalue->get_type ()->get_debug_string ());\n+\n+  return (gcc_jit_lvalue *)rvalue->dereference (loc);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::lvalue::get_address method in jit-recording.c.  */\n+\n+gcc_jit_rvalue *\n+gcc_jit_lvalue_get_address (gcc_jit_lvalue *lvalue,\n+\t\t\t    gcc_jit_location *loc)\n+{\n+  RETURN_NULL_IF_FAIL (lvalue, NULL, loc, \"NULL lvalue\");\n+  /* LOC can be NULL.  */\n+\n+  return (gcc_jit_rvalue *)lvalue->get_address (loc);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function::new_local method in jit-recording.c.  */\n+\n+gcc_jit_lvalue *\n+gcc_jit_function_new_local (gcc_jit_function *func,\n+\t\t\t    gcc_jit_location *loc,\n+\t\t\t    gcc_jit_type *type,\n+\t\t\t    const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (func, NULL, loc, \"NULL function\");\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  RETURN_NULL_IF_FAIL (func->get_kind () != GCC_JIT_FUNCTION_IMPORTED,\n+\t\t       ctxt, loc,\n+\t\t       \"Cannot add locals to an imported function\");\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+\n+  return (gcc_jit_lvalue *)func->new_local (loc, type, name);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::add_eval method in jit-recording.c.  */\n+\n+void\n+gcc_jit_block_add_eval (gcc_jit_block *block,\n+\t\t\tgcc_jit_location *loc,\n+\t\t\tgcc_jit_rvalue *rvalue)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n+\n+  return block->add_eval (loc, rvalue);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::add_assignment method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_add_assignment (gcc_jit_block *block,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      gcc_jit_lvalue *lvalue,\n+\t\t\t      gcc_jit_rvalue *rvalue)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  RETURN_IF_FAIL (lvalue, ctxt, loc, \"NULL lvalue\");\n+  RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n+  RETURN_IF_FAIL_PRINTF4 (\n+    compatible_types (lvalue->get_type (),\n+\t\t      rvalue->get_type ()),\n+    ctxt, loc,\n+    \"mismatching types:\"\n+    \" assignment to %s (type: %s) from %s (type: %s)\",\n+    lvalue->get_debug_string (),\n+    lvalue->get_type ()->get_debug_string (),\n+    rvalue->get_debug_string (),\n+    rvalue->get_type ()->get_debug_string ());\n+\n+  return block->add_assignment (loc, lvalue, rvalue);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::add_assignment_op method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_add_assignment_op (gcc_jit_block *block,\n+\t\t\t\t gcc_jit_location *loc,\n+\t\t\t\t gcc_jit_lvalue *lvalue,\n+\t\t\t\t enum gcc_jit_binary_op op,\n+\t\t\t\t gcc_jit_rvalue *rvalue)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  RETURN_IF_FAIL (lvalue, ctxt, loc, \"NULL lvalue\");\n+  RETURN_IF_FAIL_PRINTF1 (\n+    valid_binary_op_p (op),\n+    ctxt, loc,\n+    \"unrecognized value for enum gcc_jit_binary_op: %i\",\n+    op);\n+  RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n+\n+  return block->add_assignment_op (loc, lvalue, op, rvalue);\n+}\n+\n+/* Internal helper function for determining if rvalue BOOLVAL is of\n+   boolean type.  For use by gcc_jit_block_end_with_conditional.  */\n+\n+static bool\n+is_bool (gcc_jit_rvalue *boolval)\n+{\n+  gcc::jit::recording::type *actual_type = boolval->get_type ();\n+  gcc::jit::recording::type *bool_type =\n+    boolval->m_ctxt->get_type (GCC_JIT_TYPE_BOOL);\n+  return actual_type == bool_type;\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::end_with_conditional method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_end_with_conditional (gcc_jit_block *block,\n+\t\t\t\t    gcc_jit_location *loc,\n+\t\t\t\t    gcc_jit_rvalue *boolval,\n+\t\t\t\t    gcc_jit_block *on_true,\n+\t\t\t\t    gcc_jit_block *on_false)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  RETURN_IF_FAIL (boolval, ctxt, loc, \"NULL boolval\");\n+  RETURN_IF_FAIL_PRINTF2 (\n+   is_bool (boolval), ctxt, loc,\n+   \"%s (type: %s) is not of boolean type \",\n+   boolval->get_debug_string (),\n+   boolval->get_type ()->get_debug_string ());\n+  RETURN_IF_FAIL (on_true, ctxt, loc, \"NULL on_true\");\n+  RETURN_IF_FAIL (on_true, ctxt, loc, \"NULL on_false\");\n+  RETURN_IF_FAIL_PRINTF4 (\n+    block->get_function () == on_true->get_function (),\n+    ctxt, loc,\n+    \"\\\"on_true\\\" block is not in same function:\"\n+    \" source block %s is in function %s\"\n+    \" whereas target block %s is in function %s\",\n+    block->get_debug_string (),\n+    block->get_function ()->get_debug_string (),\n+    on_true->get_debug_string (),\n+    on_true->get_function ()->get_debug_string ());\n+  RETURN_IF_FAIL_PRINTF4 (\n+    block->get_function () == on_false->get_function (),\n+    ctxt, loc,\n+    \"\\\"on_false\\\" block is not in same function:\"\n+    \" source block %s is in function %s\"\n+    \" whereas target block %s is in function %s\",\n+    block->get_debug_string (),\n+    block->get_function ()->get_debug_string (),\n+    on_false->get_debug_string (),\n+    on_false->get_function ()->get_debug_string ());\n+\n+  return block->end_with_conditional (loc, boolval, on_true, on_false);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::add_comment method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_add_comment (gcc_jit_block *block,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   const char *text)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  RETURN_IF_FAIL (text, ctxt, loc, \"NULL text\");\n+\n+  block->add_comment (loc, text);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::end_with_jump method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_end_with_jump (gcc_jit_block *block,\n+\t\t\t     gcc_jit_location *loc,\n+\t\t\t     gcc_jit_block *target)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  RETURN_IF_FAIL (target, ctxt, loc, \"NULL target\");\n+  RETURN_IF_FAIL_PRINTF4 (\n+    block->get_function () == target->get_function (),\n+    ctxt, loc,\n+    \"target block is not in same function:\"\n+    \" source block %s is in function %s\"\n+    \" whereas target block %s is in function %s\",\n+    block->get_debug_string (),\n+    block->get_function ()->get_debug_string (),\n+    target->get_debug_string (),\n+    target->get_function ()->get_debug_string ());\n+\n+  block->end_with_jump (loc, target);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::end_with_return method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_end_with_return (gcc_jit_block *block,\n+\t\t\t       gcc_jit_location *loc,\n+\t\t\t       gcc_jit_rvalue *rvalue)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  gcc::jit::recording::function *func = block->get_function ();\n+  RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n+  RETURN_IF_FAIL_PRINTF4 (\n+    compatible_types (\n+      func->get_return_type (),\n+      rvalue->get_type ()),\n+    ctxt, loc,\n+    \"mismatching types:\"\n+    \" return of %s (type: %s) in function %s (return type: %s)\",\n+    rvalue->get_debug_string (),\n+    rvalue->get_type ()->get_debug_string (),\n+    func->get_debug_string (),\n+    func->get_return_type ()->get_debug_string ());\n+\n+  return block->end_with_return (loc, rvalue);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::end_with_return method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_end_with_void_return (gcc_jit_block *block,\n+\t\t\t\t    gcc_jit_location *loc)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  /* LOC can be NULL.  */\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  gcc::jit::recording::function *func = block->get_function ();\n+  RETURN_IF_FAIL_PRINTF2 (\n+    func->get_return_type () == ctxt->get_type (GCC_JIT_TYPE_VOID),\n+    ctxt, loc,\n+    \"mismatching types:\"\n+    \" void return in function %s (return type: %s)\",\n+    func->get_debug_string (),\n+    func->get_return_type ()->get_debug_string ());\n+\n+  return block->end_with_return (loc, NULL);\n+}\n+\n+/**********************************************************************\n+ Option-management\n+ **********************************************************************/\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::set_str_option method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_set_str_option (gcc_jit_context *ctxt,\n+\t\t\t\tenum gcc_jit_str_option opt,\n+\t\t\t\tconst char *value)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  /* opt is checked by the inner function.\n+     value can be NULL.  */\n+\n+  ctxt->set_str_option (opt, value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::set_int_option method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_set_int_option (gcc_jit_context *ctxt,\n+\t\t\t\tenum gcc_jit_int_option opt,\n+\t\t\t\tint value)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  /* opt is checked by the inner function.  */\n+\n+  ctxt->set_int_option (opt, value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::set_bool_option method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_set_bool_option (gcc_jit_context *ctxt,\n+\t\t\t\t enum gcc_jit_bool_option opt,\n+\t\t\t\t int value)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  /* opt is checked by the inner function.  */\n+\n+  ctxt->set_bool_option (opt, value);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::compile method in\n+   jit-recording.c.  */\n+\n+gcc_jit_result *\n+gcc_jit_context_compile (gcc_jit_context *ctxt)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+\n+  return (gcc_jit_result *)ctxt->compile ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::dump_to_file method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_dump_to_file (gcc_jit_context *ctxt,\n+\t\t\t      const char *path,\n+\t\t\t      int update_locations)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  RETURN_IF_FAIL (path, ctxt, NULL, \"NULL path\");\n+  ctxt->dump_to_file (path, update_locations);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::get_first_error method in\n+   jit-recording.c.  */\n+\n+const char *\n+gcc_jit_context_get_first_error (gcc_jit_context *ctxt)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+\n+  return ctxt->get_first_error ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::playback::result::get_code method in\n+   jit-playback.c.  */\n+\n+void *\n+gcc_jit_result_get_code (gcc_jit_result *result,\n+\t\t\t const char *fnname)\n+{\n+  RETURN_NULL_IF_FAIL (result, NULL, NULL, \"NULL result\");\n+  RETURN_NULL_IF_FAIL (fnname, NULL, NULL, \"NULL fnname\");\n+\n+  return result->get_code (fnname);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this is essentially a wrapper around the\n+   destructor for gcc::jit::playback::result in jit-playback.c.  */\n+\n+void\n+gcc_jit_result_release (gcc_jit_result *result)\n+{\n+  RETURN_IF_FAIL (result, NULL, NULL, \"NULL result\");\n+\n+  delete result;\n+}"}, {"sha": "e07002dc42d2a023e3fc2602674dfa384e40d8e0", "filename": "gcc/jit/libgccjit.h", "status": "added", "additions": 986, "deletions": 0, "changes": 986, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,986 @@\n+/* A pure C API to enable client code to embed GCC as a JIT-compiler.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBGCCJIT_H\n+#define LIBGCCJIT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+/**********************************************************************\n+ Data structures.\n+ **********************************************************************/\n+/* All structs within the API are opaque. */\n+\n+/* A gcc_jit_context encapsulates the state of a compilation.  It goes\n+   through two states:\n+\n+   (1) \"initial\", during which you can set up options on it, and add\n+       types, functions and code, using the API below.\n+       Invoking gcc_jit_context_compile on it transitions it to the\n+       \"after compilation\" state.\n+\n+   (2) \"after compilation\", when you can call gcc_jit_context_release to\n+       clean up.  */\n+typedef struct gcc_jit_context gcc_jit_context;\n+\n+/* A gcc_jit_result encapsulates the result of a compilation.  */\n+typedef struct gcc_jit_result gcc_jit_result;\n+\n+/* An object created within a context.  Such objects are automatically\n+   cleaned up when the context is released.\n+\n+   The class hierarchy looks like this:\n+\n+     +- gcc_jit_object\n+         +- gcc_jit_location\n+         +- gcc_jit_type\n+\t    +- gcc_jit_struct\n+         +- gcc_jit_field\n+         +- gcc_jit_function\n+         +- gcc_jit_block\n+         +- gcc_jit_rvalue\n+             +- gcc_jit_lvalue\n+                 +- gcc_jit_param\n+*/\n+typedef struct gcc_jit_object gcc_jit_object;\n+\n+/* A gcc_jit_location encapsulates a source code location, so that\n+   you can (optionally) associate locations in your language with\n+   statements in the JIT-compiled code, allowing the debugger to\n+   single-step through your language.\n+\n+   Note that to do so, you also need to enable\n+     GCC_JIT_BOOL_OPTION_DEBUGINFO\n+   on the gcc_jit_context.\n+\n+   gcc_jit_location instances are optional; you can always pass\n+   NULL.  */\n+typedef struct gcc_jit_location gcc_jit_location;\n+\n+/* A gcc_jit_type encapsulates a type e.g. \"int\" or a \"struct foo*\".  */\n+typedef struct gcc_jit_type gcc_jit_type;\n+\n+/* A gcc_jit_field encapsulates a field within a struct; it is used\n+   when creating a struct type (using gcc_jit_context_new_struct_type).\n+   Fields cannot be shared between structs.  */\n+typedef struct gcc_jit_field gcc_jit_field;\n+\n+/* A gcc_jit_struct encapsulates a struct type, either one that we have\n+   the layout for, or an opaque type.  */\n+typedef struct gcc_jit_struct gcc_jit_struct;\n+\n+/* A gcc_jit_function encapsulates a function: either one that you're\n+   creating yourself, or a reference to one that you're dynamically\n+   linking to within the rest of the process.  */\n+typedef struct gcc_jit_function gcc_jit_function;\n+\n+/* A gcc_jit_block encapsulates a \"basic block\" of statements within a\n+   function (i.e. with one entry point and one exit point).\n+\n+   Every block within a function must be terminated with a conditional,\n+   a branch, or a return.\n+\n+   The blocks within a function form a directed graph.\n+\n+   The entrypoint to the function is the first block created within\n+   it.\n+\n+   All of the blocks in a function must be reachable via some path from\n+   the first block.\n+\n+   It's OK to have more than one \"return\" from a function (i.e. multiple\n+   blocks that terminate by returning).  */\n+typedef struct gcc_jit_block gcc_jit_block;\n+\n+/* A gcc_jit_rvalue is an expression within your code, with some type.  */\n+typedef struct gcc_jit_rvalue gcc_jit_rvalue;\n+\n+/* A gcc_jit_lvalue is a storage location within your code (e.g. a\n+   variable, a parameter, etc).  It is also a gcc_jit_rvalue; use\n+   gcc_jit_lvalue_as_rvalue to cast.  */\n+typedef struct gcc_jit_lvalue gcc_jit_lvalue;\n+\n+/* A gcc_jit_param is a function parameter, used when creating a\n+   gcc_jit_function.  It is also a gcc_jit_lvalue (and thus also an\n+   rvalue); use gcc_jit_param_as_lvalue to convert.  */\n+typedef struct gcc_jit_param gcc_jit_param;\n+\n+/* Acquire a JIT-compilation context.  */\n+extern gcc_jit_context *\n+gcc_jit_context_acquire (void);\n+\n+/* Release the context.  After this call, it's no longer valid to use\n+   the ctxt.  */\n+extern void\n+gcc_jit_context_release (gcc_jit_context *ctxt);\n+\n+/* Options taking string values. */\n+enum gcc_jit_str_option\n+{\n+  /* The name of the program, for use as a prefix when printing error\n+     messages to stderr.  If NULL, or default, \"libgccjit.so\" is used.  */\n+  GCC_JIT_STR_OPTION_PROGNAME,\n+\n+  GCC_JIT_NUM_STR_OPTIONS\n+};\n+\n+/* Options taking int values. */\n+enum gcc_jit_int_option\n+{\n+  /* How much to optimize the code.\n+     Valid values are 0-3, corresponding to GCC's command-line options\n+     -O0 through -O3.\n+\n+     The default value is 0 (unoptimized).  */\n+  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+\n+  GCC_JIT_NUM_INT_OPTIONS\n+};\n+\n+/* Options taking boolean values.\n+   These all default to \"false\".  */\n+enum gcc_jit_bool_option\n+{\n+  /* If true, gcc_jit_context_compile will attempt to do the right\n+     thing so that if you attach a debugger to the process, it will\n+     be able to inspect variables and step through your code.\n+\n+     Note that you can't step through code unless you set up source\n+     location information for the code (by creating and passing in\n+     gcc_jit_location instances).  */\n+  GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+\n+  /* If true, gcc_jit_context_compile will dump its initial \"tree\"\n+     representation of your code to stderr (before any\n+     optimizations).  */\n+  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE,\n+\n+  /* If true, gcc_jit_context_compile will dump the \"gimple\"\n+     representation of your code to stderr, before any optimizations\n+     are performed.  The dump resembles C code.  */\n+  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+\n+  /* If true, gcc_jit_context_compile will dump the final\n+     generated code to stderr, in the form of assembly language.  */\n+  GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+\n+  /* If true, gcc_jit_context_compile will print information to stderr\n+     on the actions it is performing, followed by a profile showing\n+     the time taken and memory usage of each phase.\n+   */\n+  GCC_JIT_BOOL_OPTION_DUMP_SUMMARY,\n+\n+  /* If true, gcc_jit_context_compile will dump copious\n+     amount of information on what it's doing to various\n+     files within a temporary directory.  Use\n+     GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES (see below) to\n+     see the results.  The files are intended to be human-readable,\n+     but the exact files and their formats are subject to change.\n+  */\n+  GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n+\n+  /* If true, libgccjit will aggressively run its garbage collector, to\n+     shake out bugs (greatly slowing down the compile).  This is likely\n+     to only be of interest to developers *of* the library.  It is\n+     used when running the selftest suite.  */\n+  GCC_JIT_BOOL_OPTION_SELFCHECK_GC,\n+\n+  /* If true, gcc_jit_context_release will not clean up\n+     intermediate files written to the filesystem, and will display\n+     their location on stderr.  */\n+  GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n+\n+  GCC_JIT_NUM_BOOL_OPTIONS\n+};\n+\n+/* Set a string option on the given context.\n+\n+   The context directly stores the (const char *), so the passed string\n+   must outlive the context.  */\n+extern void\n+gcc_jit_context_set_str_option (gcc_jit_context *ctxt,\n+\t\t\t\tenum gcc_jit_str_option opt,\n+\t\t\t\tconst char *value);\n+\n+/* Set an int option on the given context.  */\n+extern void\n+gcc_jit_context_set_int_option (gcc_jit_context *ctxt,\n+\t\t\t\tenum gcc_jit_int_option opt,\n+\t\t\t\tint value);\n+\n+/* Set a boolean option on the given context.\n+\n+   Zero is \"false\" (the default), non-zero is \"true\".  */\n+extern void\n+gcc_jit_context_set_bool_option (gcc_jit_context *ctxt,\n+\t\t\t\t enum gcc_jit_bool_option opt,\n+\t\t\t\t int value);\n+\n+/* This actually calls into GCC and runs the build, all\n+   in a mutex for now.  The result is a wrapper around a .so file.\n+   It can only be called once on a given context.  */\n+extern gcc_jit_result *\n+gcc_jit_context_compile (gcc_jit_context *ctxt);\n+\n+/* To help with debugging: dump a C-like representation to the given path,\n+   describing what's been set up on the context.\n+\n+   If \"update_locations\" is true, then also set up gcc_jit_location\n+   information throughout the context, pointing at the dump file as if it\n+   were a source file.  This may be of use in conjunction with\n+   GCC_JIT_BOOL_OPTION_DEBUGINFO to allow stepping through the code in a\n+   debugger.  */\n+extern void\n+gcc_jit_context_dump_to_file (gcc_jit_context *ctxt,\n+\t\t\t      const char *path,\n+\t\t\t      int update_locations);\n+\n+/* To be called after a compile, this gives the first error message\n+   that occurred on the context.\n+\n+   The returned string is valid for the rest of the lifetime of the\n+   context.\n+\n+   If no errors occurred, this will be NULL.  */\n+extern const char *\n+gcc_jit_context_get_first_error (gcc_jit_context *ctxt);\n+\n+/* Locate a given function within the built machine code.\n+   This will need to be cast to a function pointer of the\n+   correct type before it can be called. */\n+extern void *\n+gcc_jit_result_get_code (gcc_jit_result *result,\n+\t\t\t const char *funcname);\n+\n+/* Once we're done with the code, this unloads the built .so file.\n+   This cleans up the result; after calling this, it's no longer\n+   valid to use the result.  */\n+extern void\n+gcc_jit_result_release (gcc_jit_result *result);\n+\n+\n+/**********************************************************************\n+ Functions for creating \"contextual\" objects.\n+\n+ All objects created by these functions share the lifetime of the context\n+ they are created within, and are automatically cleaned up for you when\n+ you call gcc_jit_context_release on the context.\n+\n+ Note that this means you can't use references to them after you've\n+ released their context.\n+\n+ All (const char *) string arguments passed to these functions are\n+ copied, so you don't need to keep them around.  Note that this *isn't*\n+ the case for other parts of the API.\n+\n+ You create code by adding a sequence of statements to blocks.\n+**********************************************************************/\n+\n+/**********************************************************************\n+ The base class of \"contextual\" object.\n+ **********************************************************************/\n+/* Which context is \"obj\" within?  */\n+extern gcc_jit_context *\n+gcc_jit_object_get_context (gcc_jit_object *obj);\n+\n+/* Get a human-readable description of this object.\n+   The string buffer is created the first time this is called on a given\n+   object, and persists until the object's context is released.  */\n+extern const char *\n+gcc_jit_object_get_debug_string (gcc_jit_object *obj);\n+\n+/**********************************************************************\n+ Debugging information.\n+ **********************************************************************/\n+\n+/* Creating source code locations for use by the debugger.\n+   Line and column numbers are 1-based.  */\n+extern gcc_jit_location *\n+gcc_jit_context_new_location (gcc_jit_context *ctxt,\n+\t\t\t      const char *filename,\n+\t\t\t      int line,\n+\t\t\t      int column);\n+\n+/* Upcasting from location to object.  */\n+extern gcc_jit_object *\n+gcc_jit_location_as_object (gcc_jit_location *loc);\n+\n+\n+/**********************************************************************\n+ Types.\n+ **********************************************************************/\n+\n+/* Upcasting from type to object.  */\n+extern gcc_jit_object *\n+gcc_jit_type_as_object (gcc_jit_type *type);\n+\n+/* Access to specific types.  */\n+enum gcc_jit_types\n+{\n+  /* C's \"void\" type.  */\n+  GCC_JIT_TYPE_VOID,\n+\n+  /* \"void *\".  */\n+  GCC_JIT_TYPE_VOID_PTR,\n+\n+  /* C++'s bool type; also C99's \"_Bool\" type, aka \"bool\" if using\n+     stdbool.h.  */\n+  GCC_JIT_TYPE_BOOL,\n+\n+  /* Various integer types.  */\n+\n+  /* C's \"char\" (of some signedness) and the variants where the\n+     signedness is specified.  */\n+  GCC_JIT_TYPE_CHAR,\n+  GCC_JIT_TYPE_SIGNED_CHAR,\n+  GCC_JIT_TYPE_UNSIGNED_CHAR,\n+\n+  /* C's \"short\" and \"unsigned short\".  */\n+  GCC_JIT_TYPE_SHORT, /* signed */\n+  GCC_JIT_TYPE_UNSIGNED_SHORT,\n+\n+  /* C's \"int\" and \"unsigned int\".  */\n+  GCC_JIT_TYPE_INT, /* signed */\n+  GCC_JIT_TYPE_UNSIGNED_INT,\n+\n+  /* C's \"long\" and \"unsigned long\".  */\n+  GCC_JIT_TYPE_LONG, /* signed */\n+  GCC_JIT_TYPE_UNSIGNED_LONG,\n+\n+  /* C99's \"long long\" and \"unsigned long long\".  */\n+  GCC_JIT_TYPE_LONG_LONG, /* signed */\n+  GCC_JIT_TYPE_UNSIGNED_LONG_LONG,\n+\n+  /* Floating-point types  */\n+\n+  GCC_JIT_TYPE_FLOAT,\n+  GCC_JIT_TYPE_DOUBLE,\n+  GCC_JIT_TYPE_LONG_DOUBLE,\n+\n+  /* C type: (const char *).  */\n+  GCC_JIT_TYPE_CONST_CHAR_PTR,\n+\n+ /* The C \"size_t\" type.  */\n+  GCC_JIT_TYPE_SIZE_T,\n+\n+ /* C type: (FILE *)  */\n+  GCC_JIT_TYPE_FILE_PTR\n+};\n+\n+extern gcc_jit_type *\n+gcc_jit_context_get_type (gcc_jit_context *ctxt,\n+\t\t\t  enum gcc_jit_types type_);\n+\n+/* Get the integer type of the given size and signedness.  */\n+extern gcc_jit_type *\n+gcc_jit_context_get_int_type (gcc_jit_context *ctxt,\n+\t\t\t      int num_bytes, int is_signed);\n+\n+/* Constructing new types. */\n+\n+/* Given type \"T\", get type \"T*\".  */\n+extern gcc_jit_type *\n+gcc_jit_type_get_pointer (gcc_jit_type *type);\n+\n+/* Given type \"T\", get type \"const T\".  */\n+extern gcc_jit_type *\n+gcc_jit_type_get_const (gcc_jit_type *type);\n+\n+/* Given type \"T\", get type \"volatile T\".  */\n+extern gcc_jit_type *\n+gcc_jit_type_get_volatile (gcc_jit_type *type);\n+\n+/* Given type \"T\", get type \"T[N]\" (for a constant N).  */\n+extern gcc_jit_type *\n+gcc_jit_context_new_array_type (gcc_jit_context *ctxt,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tgcc_jit_type *element_type,\n+\t\t\t\tint num_elements);\n+\n+/* Struct-handling.  */\n+\n+/* Create a field, for use within a struct or union.  */\n+extern gcc_jit_field *\n+gcc_jit_context_new_field (gcc_jit_context *ctxt,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   gcc_jit_type *type,\n+\t\t\t   const char *name);\n+\n+/* Upcasting from field to object.  */\n+extern gcc_jit_object *\n+gcc_jit_field_as_object (gcc_jit_field *field);\n+\n+/* Create a struct type from an array of fields.  */\n+extern gcc_jit_struct *\n+gcc_jit_context_new_struct_type (gcc_jit_context *ctxt,\n+\t\t\t\t gcc_jit_location *loc,\n+\t\t\t\t const char *name,\n+\t\t\t\t int num_fields,\n+\t\t\t\t gcc_jit_field **fields);\n+\n+/* Create an opaque struct type.  */\n+extern gcc_jit_struct *\n+gcc_jit_context_new_opaque_struct (gcc_jit_context *ctxt,\n+\t\t\t\t   gcc_jit_location *loc,\n+\t\t\t\t   const char *name);\n+\n+/* Upcast a struct to a type.  */\n+extern gcc_jit_type *\n+gcc_jit_struct_as_type (gcc_jit_struct *struct_type);\n+\n+/* Populating the fields of a formerly-opaque struct type.\n+   This can only be called once on a given struct type.  */\n+extern void\n+gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   int num_fields,\n+\t\t\t   gcc_jit_field **fields);\n+\n+/* Unions work similarly to structs.  */\n+extern gcc_jit_type *\n+gcc_jit_context_new_union_type (gcc_jit_context *ctxt,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tconst char *name,\n+\t\t\t\tint num_fields,\n+\t\t\t\tgcc_jit_field **fields);\n+\n+/* Function pointers. */\n+\n+extern gcc_jit_type *\n+gcc_jit_context_new_function_ptr_type (gcc_jit_context *ctxt,\n+\t\t\t\t       gcc_jit_location *loc,\n+\t\t\t\t       gcc_jit_type *return_type,\n+\t\t\t\t       int num_params,\n+\t\t\t\t       gcc_jit_type **param_types,\n+\t\t\t\t       int is_variadic);\n+\n+/**********************************************************************\n+ Constructing functions.\n+ **********************************************************************/\n+/* Create a function param.  */\n+extern gcc_jit_param *\n+gcc_jit_context_new_param (gcc_jit_context *ctxt,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   gcc_jit_type *type,\n+\t\t\t   const char *name);\n+\n+/* Upcasting from param to object.  */\n+extern gcc_jit_object *\n+gcc_jit_param_as_object (gcc_jit_param *param);\n+\n+/* Upcasting from param to lvalue.  */\n+extern gcc_jit_lvalue *\n+gcc_jit_param_as_lvalue (gcc_jit_param *param);\n+\n+/* Upcasting from param to rvalue.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_param_as_rvalue (gcc_jit_param *param);\n+\n+/* Kinds of function.  */\n+enum gcc_jit_function_kind\n+{\n+  /* Function is defined by the client code and visible\n+     by name outside of the JIT.  */\n+  GCC_JIT_FUNCTION_EXPORTED,\n+\n+  /* Function is defined by the client code, but is invisible\n+     outside of the JIT.  Analogous to a \"static\" function.  */\n+  GCC_JIT_FUNCTION_INTERNAL,\n+\n+  /* Function is not defined by the client code; we're merely\n+     referring to it.  Analogous to using an \"extern\" function from a\n+     header file.  */\n+  GCC_JIT_FUNCTION_IMPORTED,\n+\n+  /* Function is only ever inlined into other functions, and is\n+     invisible outside of the JIT.\n+\n+     Analogous to prefixing with \"inline\" and adding\n+     __attribute__((always_inline)).\n+\n+     Inlining will only occur when the optimization level is\n+     above 0; when optimization is off, this is essentially the\n+     same as GCC_JIT_FUNCTION_INTERNAL.  */\n+  GCC_JIT_FUNCTION_ALWAYS_INLINE\n+};\n+\n+/* Create a function.  */\n+extern gcc_jit_function *\n+gcc_jit_context_new_function (gcc_jit_context *ctxt,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      enum gcc_jit_function_kind kind,\n+\t\t\t      gcc_jit_type *return_type,\n+\t\t\t      const char *name,\n+\t\t\t      int num_params,\n+\t\t\t      gcc_jit_param **params,\n+\t\t\t      int is_variadic);\n+\n+/* Create a reference to a builtin function (sometimes called\n+   intrinsic functions).  */\n+extern gcc_jit_function *\n+gcc_jit_context_get_builtin_function (gcc_jit_context *ctxt,\n+\t\t\t\t      const char *name);\n+\n+/* Upcasting from function to object.  */\n+extern gcc_jit_object *\n+gcc_jit_function_as_object (gcc_jit_function *func);\n+\n+/* Get a specific param of a function by index.  */\n+extern gcc_jit_param *\n+gcc_jit_function_get_param (gcc_jit_function *func, int index);\n+\n+/* Emit the function in graphviz format.  */\n+extern void\n+gcc_jit_function_dump_to_dot (gcc_jit_function *func,\n+\t\t\t      const char *path);\n+\n+/* Create a block.\n+\n+   The name can be NULL, or you can give it a meaningful name, which\n+   may show up in dumps of the internal representation, and in error\n+   messages.  */\n+extern gcc_jit_block *\n+gcc_jit_function_new_block (gcc_jit_function *func,\n+\t\t\t    const char *name);\n+\n+/* Upcasting from block to object.  */\n+extern gcc_jit_object *\n+gcc_jit_block_as_object (gcc_jit_block *block);\n+\n+/* Which function is this block within?  */\n+extern gcc_jit_function *\n+gcc_jit_block_get_function (gcc_jit_block *block);\n+\n+/**********************************************************************\n+ lvalues, rvalues and expressions.\n+ **********************************************************************/\n+\n+extern gcc_jit_lvalue *\n+gcc_jit_context_new_global (gcc_jit_context *ctxt,\n+\t\t\t    gcc_jit_location *loc,\n+\t\t\t    gcc_jit_type *type,\n+\t\t\t    const char *name);\n+\n+/* Upcasting.  */\n+extern gcc_jit_object *\n+gcc_jit_lvalue_as_object (gcc_jit_lvalue *lvalue);\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_lvalue_as_rvalue (gcc_jit_lvalue *lvalue);\n+\n+extern gcc_jit_object *\n+gcc_jit_rvalue_as_object (gcc_jit_rvalue *rvalue);\n+\n+extern gcc_jit_type *\n+gcc_jit_rvalue_get_type (gcc_jit_rvalue *rvalue);\n+\n+/* Integer constants. */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_int (gcc_jit_context *ctxt,\n+\t\t\t\t     gcc_jit_type *numeric_type,\n+\t\t\t\t     int value);\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_zero (gcc_jit_context *ctxt,\n+\t\t      gcc_jit_type *numeric_type);\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_one (gcc_jit_context *ctxt,\n+\t\t     gcc_jit_type *numeric_type);\n+\n+/* Floating-point constants.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_double (gcc_jit_context *ctxt,\n+\t\t\t\t\tgcc_jit_type *numeric_type,\n+\t\t\t\t\tdouble value);\n+\n+/* Pointers.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_rvalue_from_ptr (gcc_jit_context *ctxt,\n+\t\t\t\t     gcc_jit_type *pointer_type,\n+\t\t\t\t     void *value);\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_null (gcc_jit_context *ctxt,\n+\t\t      gcc_jit_type *pointer_type);\n+\n+/* String literals. */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_string_literal (gcc_jit_context *ctxt,\n+\t\t\t\t    const char *value);\n+\n+enum gcc_jit_unary_op\n+{\n+  /* Negate an arithmetic value; analogous to:\n+       -(EXPR)\n+     in C.  */\n+  GCC_JIT_UNARY_OP_MINUS,\n+\n+  /* Bitwise negation of an integer value (one's complement); analogous\n+     to:\n+       ~(EXPR)\n+     in C.  */\n+  GCC_JIT_UNARY_OP_BITWISE_NEGATE,\n+\n+  /* Logical negation of an arithmetic or pointer value; analogous to:\n+       !(EXPR)\n+     in C.  */\n+  GCC_JIT_UNARY_OP_LOGICAL_NEGATE\n+};\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_unary_op (gcc_jit_context *ctxt,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      enum gcc_jit_unary_op op,\n+\t\t\t      gcc_jit_type *result_type,\n+\t\t\t      gcc_jit_rvalue *rvalue);\n+\n+enum gcc_jit_binary_op\n+{\n+  /* Addition of arithmetic values; analogous to:\n+       (EXPR_A) + (EXPR_B)\n+     in C.\n+     For pointer addition, use gcc_jit_context_new_array_access.  */\n+  GCC_JIT_BINARY_OP_PLUS,\n+\n+  /* Subtraction of arithmetic values; analogous to:\n+       (EXPR_A) - (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_MINUS,\n+\n+  /* Multiplication of a pair of arithmetic values; analogous to:\n+       (EXPR_A) * (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_MULT,\n+\n+  /* Quotient of division of arithmetic values; analogous to:\n+       (EXPR_A) / (EXPR_B)\n+     in C.\n+     The result type affects the kind of division: if the result type is\n+     integer-based, then the result is truncated towards zero, whereas\n+     a floating-point result type indicates floating-point division.  */\n+  GCC_JIT_BINARY_OP_DIVIDE,\n+\n+  /* Remainder of division of arithmetic values; analogous to:\n+       (EXPR_A) % (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_MODULO,\n+\n+  /* Bitwise AND; analogous to:\n+       (EXPR_A) & (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_BITWISE_AND,\n+\n+  /* Bitwise exclusive OR; analogous to:\n+       (EXPR_A) ^ (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_BITWISE_XOR,\n+\n+  /* Bitwise inclusive OR; analogous to:\n+       (EXPR_A) | (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_BITWISE_OR,\n+\n+  /* Logical AND; analogous to:\n+       (EXPR_A) && (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_LOGICAL_AND,\n+\n+  /* Logical OR; analogous to:\n+       (EXPR_A) || (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_LOGICAL_OR,\n+\n+  /* Left shift; analogous to:\n+       (EXPR_A) << (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_LSHIFT,\n+\n+  /* Right shift; analogous to:\n+       (EXPR_A) >> (EXPR_B)\n+     in C.  */\n+  GCC_JIT_BINARY_OP_RSHIFT\n+};\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_binary_op (gcc_jit_context *ctxt,\n+\t\t\t       gcc_jit_location *loc,\n+\t\t\t       enum gcc_jit_binary_op op,\n+\t\t\t       gcc_jit_type *result_type,\n+\t\t\t       gcc_jit_rvalue *a, gcc_jit_rvalue *b);\n+\n+/* (Comparisons are treated as separate from \"binary_op\" to save\n+   you having to specify the result_type).  */\n+\n+enum gcc_jit_comparison\n+{\n+  /* (EXPR_A) == (EXPR_B).  */\n+  GCC_JIT_COMPARISON_EQ,\n+\n+  /* (EXPR_A) != (EXPR_B).  */\n+  GCC_JIT_COMPARISON_NE,\n+\n+  /* (EXPR_A) < (EXPR_B).  */\n+  GCC_JIT_COMPARISON_LT,\n+\n+  /* (EXPR_A) <=(EXPR_B).  */\n+  GCC_JIT_COMPARISON_LE,\n+\n+  /* (EXPR_A) > (EXPR_B).  */\n+  GCC_JIT_COMPARISON_GT,\n+\n+  /* (EXPR_A) >= (EXPR_B).  */\n+  GCC_JIT_COMPARISON_GE\n+};\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_comparison (gcc_jit_context *ctxt,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tenum gcc_jit_comparison op,\n+\t\t\t\tgcc_jit_rvalue *a, gcc_jit_rvalue *b);\n+\n+/* Function calls.  */\n+\n+/* Call of a specific function.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_call (gcc_jit_context *ctxt,\n+\t\t\t  gcc_jit_location *loc,\n+\t\t\t  gcc_jit_function *func,\n+\t\t\t  int numargs , gcc_jit_rvalue **args);\n+\n+/* Call through a function pointer.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_call_through_ptr (gcc_jit_context *ctxt,\n+\t\t\t\t      gcc_jit_location *loc,\n+\t\t\t\t      gcc_jit_rvalue *fn_ptr,\n+\t\t\t\t      int numargs, gcc_jit_rvalue **args);\n+\n+/* Type-coercion.\n+\n+   Currently only a limited set of conversions are possible:\n+     int <-> float\n+     int <-> bool  */\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_cast (gcc_jit_context *ctxt,\n+\t\t\t  gcc_jit_location *loc,\n+\t\t\t  gcc_jit_rvalue *rvalue,\n+\t\t\t  gcc_jit_type *type);\n+\n+extern gcc_jit_lvalue *\n+gcc_jit_context_new_array_access (gcc_jit_context *ctxt,\n+\t\t\t\t  gcc_jit_location *loc,\n+\t\t\t\t  gcc_jit_rvalue *ptr,\n+\t\t\t\t  gcc_jit_rvalue *index);\n+\n+/* Field access is provided separately for both lvalues and rvalues.  */\n+\n+/* Accessing a field of an lvalue of struct type, analogous to:\n+      (EXPR).field = ...;\n+   in C.  */\n+extern gcc_jit_lvalue *\n+gcc_jit_lvalue_access_field (gcc_jit_lvalue *struct_or_union,\n+\t\t\t     gcc_jit_location *loc,\n+\t\t\t     gcc_jit_field *field);\n+\n+/* Accessing a field of an rvalue of struct type, analogous to:\n+      (EXPR).field\n+   in C.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_rvalue_access_field (gcc_jit_rvalue *struct_or_union,\n+\t\t\t     gcc_jit_location *loc,\n+\t\t\t     gcc_jit_field *field);\n+\n+/* Accessing a field of an rvalue of pointer type, analogous to:\n+      (EXPR)->field\n+   in C, itself equivalent to (*EXPR).FIELD  */\n+extern gcc_jit_lvalue *\n+gcc_jit_rvalue_dereference_field (gcc_jit_rvalue *ptr,\n+\t\t\t\t  gcc_jit_location *loc,\n+\t\t\t\t  gcc_jit_field *field);\n+\n+/* Dereferencing a pointer; analogous to:\n+     *(EXPR)\n+*/\n+extern gcc_jit_lvalue *\n+gcc_jit_rvalue_dereference (gcc_jit_rvalue *rvalue,\n+\t\t\t    gcc_jit_location *loc);\n+\n+/* Taking the address of an lvalue; analogous to:\n+     &(EXPR)\n+   in C.  */\n+extern gcc_jit_rvalue *\n+gcc_jit_lvalue_get_address (gcc_jit_lvalue *lvalue,\n+\t\t\t    gcc_jit_location *loc);\n+\n+extern gcc_jit_lvalue *\n+gcc_jit_function_new_local (gcc_jit_function *func,\n+\t\t\t    gcc_jit_location *loc,\n+\t\t\t    gcc_jit_type *type,\n+\t\t\t    const char *name);\n+\n+/**********************************************************************\n+ Statement-creation.\n+ **********************************************************************/\n+\n+/* Add evaluation of an rvalue, discarding the result\n+   (e.g. a function call that \"returns\" void).\n+\n+   This is equivalent to this C code:\n+\n+     (void)expression;\n+*/\n+extern void\n+gcc_jit_block_add_eval (gcc_jit_block *block,\n+\t\t\tgcc_jit_location *loc,\n+\t\t\tgcc_jit_rvalue *rvalue);\n+\n+/* Add evaluation of an rvalue, assigning the result to the given\n+   lvalue.\n+\n+   This is roughly equivalent to this C code:\n+\n+     lvalue = rvalue;\n+*/\n+extern void\n+gcc_jit_block_add_assignment (gcc_jit_block *block,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      gcc_jit_lvalue *lvalue,\n+\t\t\t      gcc_jit_rvalue *rvalue);\n+\n+/* Add evaluation of an rvalue, using the result to modify an\n+   lvalue.\n+\n+   This is analogous to \"+=\" and friends:\n+\n+     lvalue += rvalue;\n+     lvalue *= rvalue;\n+     lvalue /= rvalue;\n+   etc  */\n+extern void\n+gcc_jit_block_add_assignment_op (gcc_jit_block *block,\n+\t\t\t\t gcc_jit_location *loc,\n+\t\t\t\t gcc_jit_lvalue *lvalue,\n+\t\t\t\t enum gcc_jit_binary_op op,\n+\t\t\t\t gcc_jit_rvalue *rvalue);\n+\n+/* Add a no-op textual comment to the internal representation of the\n+   code.  It will be optimized away, but will be visible in the dumps\n+   seen via\n+     GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE\n+   and\n+     GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+   and thus may be of use when debugging how your project's internal\n+   representation gets converted to the libgccjit IR.  */\n+extern void\n+gcc_jit_block_add_comment (gcc_jit_block *block,\n+\t\t\t   gcc_jit_location *loc,\n+\t\t\t   const char *text);\n+\n+/* Terminate a block by adding evaluation of an rvalue, branching on the\n+   result to the appropriate successor block.\n+\n+   This is roughly equivalent to this C code:\n+\n+     if (boolval)\n+       goto on_true;\n+     else\n+       goto on_false;\n+\n+   block, boolval, on_true, and on_false must be non-NULL.  */\n+extern void\n+gcc_jit_block_end_with_conditional (gcc_jit_block *block,\n+\t\t\t\t    gcc_jit_location *loc,\n+\t\t\t\t    gcc_jit_rvalue *boolval,\n+\t\t\t\t    gcc_jit_block *on_true,\n+\t\t\t\t    gcc_jit_block *on_false);\n+\n+/* Terminate a block by adding a jump to the given target block.\n+\n+   This is roughly equivalent to this C code:\n+\n+      goto target;\n+*/\n+extern void\n+gcc_jit_block_end_with_jump (gcc_jit_block *block,\n+\t\t\t     gcc_jit_location *loc,\n+\t\t\t     gcc_jit_block *target);\n+\n+/* Terminate a block by adding evaluation of an rvalue, returning the value.\n+\n+   This is roughly equivalent to this C code:\n+\n+      return expression;\n+*/\n+extern void\n+gcc_jit_block_end_with_return (gcc_jit_block *block,\n+\t\t\t       gcc_jit_location *loc,\n+\t\t\t       gcc_jit_rvalue *rvalue);\n+\n+/* Terminate a block by adding a valueless return, for use within a function\n+   with \"void\" return type.\n+\n+   This is equivalent to this C code:\n+\n+      return;\n+*/\n+extern void\n+gcc_jit_block_end_with_void_return (gcc_jit_block *block,\n+\t\t\t\t    gcc_jit_location *loc);\n+\n+/**********************************************************************\n+ Nested contexts.\n+ **********************************************************************/\n+\n+/* Given an existing JIT context, create a child context.\n+\n+   The child inherits a copy of all option-settings from the parent.\n+\n+   The child can reference objects created within the parent, but not\n+   vice-versa.\n+\n+   The lifetime of the child context must be bounded by that of the\n+   parent: you should release a child context before releasing the parent\n+   context.\n+\n+   If you use a function from a parent context within a child context,\n+   you have to compile the parent context before you can compile the\n+   child context, and the gcc_jit_result of the parent context must\n+   outlive the gcc_jit_result of the child context.\n+\n+   This allows caching of shared initializations.  For example, you could\n+   create types and declarations of global functions in a parent context\n+   once within a process, and then create child contexts whenever a\n+   function or loop becomes hot. Each such child context can be used for\n+   JIT-compiling just one function or loop, but can reference types\n+   and helper functions created within the parent context.\n+\n+   Contexts can be arbitrarily nested, provided the above rules are\n+   followed, but it's probably not worth going above 2 or 3 levels, and\n+   there will likely be a performance hit for such nesting.  */\n+\n+extern gcc_jit_context *\n+gcc_jit_context_new_child_context (gcc_jit_context *parent_ctxt);\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif  /* LIBGCCJIT_H  */"}, {"sha": "d4ba7b6a11d0a9f65c5ed3cd2b20054bceefa8ed", "filename": "gcc/jit/libgccjit.map", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,100 @@\n+# Linker script for libgccjit.so\n+#   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+#   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+{\n+  global:\n+    # Keep this list sorted alphabetically:\n+    gcc_jit_block_add_assignment;\n+    gcc_jit_block_add_assignment_op;\n+    gcc_jit_block_add_comment;\n+    gcc_jit_block_add_eval;\n+    gcc_jit_block_as_object;\n+    gcc_jit_block_end_with_conditional;\n+    gcc_jit_block_end_with_jump;\n+    gcc_jit_block_end_with_return;\n+    gcc_jit_block_end_with_void_return;\n+    gcc_jit_block_get_function;\n+    gcc_jit_context_acquire;\n+    gcc_jit_context_compile;\n+    gcc_jit_context_dump_to_file;\n+    gcc_jit_context_get_builtin_function;\n+    gcc_jit_context_get_first_error;\n+    gcc_jit_context_get_type;\n+    gcc_jit_context_get_int_type;\n+    gcc_jit_context_new_array_access;\n+    gcc_jit_context_new_array_type;\n+    gcc_jit_context_new_binary_op;\n+    gcc_jit_context_new_call;\n+    gcc_jit_context_new_call_through_ptr;\n+    gcc_jit_context_new_cast;\n+    gcc_jit_context_new_child_context;\n+    gcc_jit_context_new_comparison;\n+    gcc_jit_context_new_field;\n+    gcc_jit_context_new_function;\n+    gcc_jit_context_new_function_ptr_type;\n+    gcc_jit_context_new_global;\n+    gcc_jit_context_new_location;\n+    gcc_jit_context_new_opaque_struct;\n+    gcc_jit_context_new_param;\n+    gcc_jit_context_new_rvalue_from_double;\n+    gcc_jit_context_new_rvalue_from_int;\n+    gcc_jit_context_new_rvalue_from_ptr;\n+    gcc_jit_context_new_string_literal;\n+    gcc_jit_context_new_struct_type;\n+    gcc_jit_context_new_unary_op;\n+    gcc_jit_context_new_union_type;\n+    gcc_jit_context_null;\n+    gcc_jit_context_one;\n+    gcc_jit_context_release;\n+    gcc_jit_context_set_bool_option;\n+    gcc_jit_context_set_int_option;\n+    gcc_jit_context_set_str_option;\n+    gcc_jit_context_zero;\n+    gcc_jit_field_as_object;\n+    gcc_jit_function_as_object;\n+    gcc_jit_function_dump_to_dot;\n+    gcc_jit_function_get_param;\n+    gcc_jit_function_new_block;\n+    gcc_jit_function_new_local;\n+    gcc_jit_location_as_object;\n+    gcc_jit_lvalue_as_object;\n+    gcc_jit_lvalue_as_rvalue;\n+    gcc_jit_lvalue_access_field;\n+    gcc_jit_lvalue_get_address;\n+    gcc_jit_object_get_context;\n+    gcc_jit_object_get_debug_string;\n+    gcc_jit_param_as_lvalue;\n+    gcc_jit_param_as_object;\n+    gcc_jit_param_as_rvalue;\n+    gcc_jit_result_get_code;\n+    gcc_jit_result_release;\n+    gcc_jit_rvalue_access_field;\n+    gcc_jit_rvalue_as_object;\n+    gcc_jit_rvalue_dereference;\n+    gcc_jit_rvalue_dereference_field;\n+    gcc_jit_rvalue_get_type;\n+    gcc_jit_struct_as_type;\n+    gcc_jit_struct_set_fields;\n+    gcc_jit_type_as_object;\n+    gcc_jit_type_get_const;\n+    gcc_jit_type_get_pointer;\n+    gcc_jit_type_get_volatile;\n+\n+  local: *;\n+};\n\\ No newline at end of file"}, {"sha": "d337cb46c43a4d970e4628f638400c592de58ce5", "filename": "gcc/jit/notes.txt", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fnotes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Fjit%2Fnotes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fnotes.txt?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,84 @@\n+Client Code   . Generated .            libgccjit.so\n+              . code      .\n+              .           . JIT API  . JIT \"Frontend\". (libbackend.a)\n+....................................................................................\n+   \u2502          .           .          .               .\n+    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n+              .           .    \u2502     .               .\n+              .           .    V     .               .\n+              .           .    \u2500\u2500> libgccjit.c       .\n+              .           .        \u2502 (error-checking).\n+              .           .        \u2502                 .\n+              .           .        \u2500\u2500> jit-recording.c\n+              .           .              (record API calls)\n+              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500              .\n+              .           .    \u2502     .               .\n+   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n+   \u2502          .           .          .               .\n+   \u2502          .           .          .               .\n+   V          .           .  gcc_jit_context_compile .\n+    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n+              .           .    \u2502     .               .\n+              .           .    \u2502 ACQUIRE MUTEX       .\n+              .           .    \u2502     .               .\n+              .           .    V\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> toplev::main (for now)\n+              .           .          .               .       \u2502\n+              .           .          .               .   (various code)\n+              .           .          .               .       \u2502\n+              .           .          .               .       V\n+              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 langhook:parse_file\n+              .           .          .    \u2502          .\n+              .           .          .    \u2502 (jit_langhook_parse_file)\n+              .           .          .    \u2502          .\n+..........................................\u2502..................VVVVVVVVVVVVV...\n+              .           .          .    \u2502          .       No GC in here\n+              .           .          .    \u2502 jit-playback.c\n+              .           .          .    \u2502   (playback of API calls)\n+              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> creation of functions,\n+              .           .          .               .     types, expression trees\n+              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 etc\n+              .           .          .    \u2502(handle_locations: add locations to\n+              .           .          .    \u2502 linemap and associate them with trees)\n+              .           .          .    \u2502          .\n+              .           .          .    \u2502          .       No GC in here\n+..........................................\u2502..................AAAAAAAAAAAAA...\n+              .           .          .    \u2502 for each function\n+              .           .          .    \u2500\u2500> postprocess\n+              .           .          .        \u2502      .\n+              .           .          .        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> cgraph_finalize_function\n+              .           .          .        <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+              .           .          .     <\u2500\u2500       .\n+              .           .          .    \u2502          .\n+              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> (end of\n+              .           .          .               .       \u2502 langhook_parse_file)\n+              .           .          .               .       \u2502\n+              .           .          .               .   (various code)\n+              .           .          .               .       \u2502\n+              .           .          .               .       \u2193\n+              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 langhook:write_globals\n+              .           .          .    \u2502          .\n+              .           .          .    \u2502 (jit_langhook_write_globals)\n+              .           .          .    \u2502          .\n+              .           .          .    \u2502          .\n+              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> finalize_compilation_unit\n+              .           .          .               .       \u2502\n+              .           .          .               .   (the middle\u2500end and backend)\n+              .           .          .               .       \u2193\n+              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 end of toplev::main\n+              .           .    \u2502 RELEASE MUTEX       .\n+              .           .    \u2502     .               .\n+              .           .    \u2502 Convert assembler to DSO\n+              .           .    \u2502     .               .\n+              .           .    \u2502 Load DSO            .\n+   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n+   \u2502          .           .          .               .\n+   Get (void*).           .          .               .\n+   \u2502          .           .          .               .\n+   \u2502 Call it  .           .          .               .\n+   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>       .          .               .\n+              .    \u2502      .          .               .\n+              .    \u2502      .          .               .\n+   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       .          .               .\n+   \u2502          .           .          .               .\n+   \u2502          .           .          .               .\n+etc"}, {"sha": "905a51ade3619b69bf2a58eaae275db46ae0c1bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -1,3 +1,67 @@\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: New.\n+\t* jit.dg/all-non-failing-tests.h: New.\n+\t* jit.dg/harness.h: New.\n+\t* jit.dg/jit.exp: New.\n+\t* jit.dg/test-accessing-struct.c: New.\n+\t* jit.dg/test-accessing-union.c: New.\n+\t* jit.dg/test-array-as-pointer.c: New.\n+\t* jit.dg/test-arrays.c: New.\n+\t* jit.dg/test-calling-external-function.c: New.\n+\t* jit.dg/test-calling-function-ptr.c: New.\n+\t* jit.dg/test-combination.c: New.\n+\t* jit.dg/test-dot-product.c: New.\n+\t* jit.dg/test-empty.c: New.\n+\t* jit.dg/test-error-accessing-field-in-other-struct.c: New.\n+\t* jit.dg/test-error-adding-to-terminated-block.c: New.\n+\t* jit.dg/test-error-array-as-pointer.c: New.\n+\t* jit.dg/test-error-bad-cast.c: New.\n+\t* jit.dg/test-error-block-in-wrong-function.c: New.\n+\t* jit.dg/test-error-call-through-ptr-with-mismatching-args.c: New.\n+\t* jit.dg/test-error-call-through-ptr-with-non-function.c: New.\n+\t* jit.dg/test-error-call-through-ptr-with-non-pointer.c: New.\n+\t* jit.dg/test-error-call-through-ptr-with-not-enough-args.c: New.\n+\t* jit.dg/test-error-call-through-ptr-with-too-many-args.c: New.\n+\t* jit.dg/test-error-call-with-mismatching-args.c: New.\n+\t* jit.dg/test-error-call-with-not-enough-args.c: New.\n+\t* jit.dg/test-error-call-with-too-many-args.c: New.\n+\t* jit.dg/test-error-dereference-field-of-non-pointer.c: New.\n+\t* jit.dg/test-error-dereference-read-of-non-pointer.c: New.\n+\t* jit.dg/test-error-get-type-bad-enum.c: New.\n+\t* jit.dg/test-error-index-not-a-numeric-type.c: New.\n+\t* jit.dg/test-error-mismatching-types-in-assignment.c: New.\n+\t* jit.dg/test-error-mismatching-types-in-call.c: New.\n+\t* jit.dg/test-error-missing-return.c: New.\n+\t* jit.dg/test-error-new-binary-op-bad-op.c: New.\n+\t* jit.dg/test-error-new-function-bad-kind.c: New.\n+\t* jit.dg/test-error-new-unary-op-bad-op.c: New.\n+\t* jit.dg/test-error-null-passed-to-api.c: New.\n+\t* jit.dg/test-error-return-within-void-function.c: New.\n+\t* jit.dg/test-error-unreachable-block.c: New.\n+\t* jit.dg/test-error-unterminated-block.c: New.\n+\t* jit.dg/test-error-value-not-a-numeric-type.c: New.\n+\t* jit.dg/test-expressions.c: New.\n+\t* jit.dg/test-factorial.c: New.\n+\t* jit.dg/test-fibonacci.c: New.\n+\t* jit.dg/test-functions.c: New.\n+\t* jit.dg/test-fuzzer.c: New.\n+\t* jit.dg/test-hello-world.c: New.\n+\t* jit.dg/test-linked-list.c: New.\n+\t* jit.dg/test-long-names.c: New.\n+\t* jit.dg/test-nested-contexts.c: New.\n+\t* jit.dg/test-nested-loops.c: New.\n+\t* jit.dg/test-operator-overloading.cc: New.\n+\t* jit.dg/test-quadratic.c: New.\n+\t* jit.dg/test-quadratic.cc: New.\n+\t* jit.dg/test-reading-struct.c: New.\n+\t* jit.dg/test-string-literal.c: New.\n+\t* jit.dg/test-sum-of-squares.c: New.\n+\t* jit.dg/test-threads.c: New.\n+\t* jit.dg/test-types.c: New.\n+\t* jit.dg/test-using-global.c: New.\n+\t* jit.dg/test-volatile.c: New.\n+\n 2014-11-11  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc.target/aarch64/vbslq_f64_1.c: New."}, {"sha": "a850c6fa72e54fd11ef1102603568cb44aedd422", "filename": "gcc/testsuite/ChangeLog.jit", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,626 @@\n+2014-11-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-get-type-bad-enum.c: New test case.\n+\t* jit.dg/test-error-new-binary-op-bad-op.c: Likewise.\n+\t* jit.dg/test-error-new-function-bad-kind.c: Likewise.\n+\t* jit.dg/test-error-new-unary-op-bad-op.c: Likewise.\n+\n+2014-10-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp (DEFAULT_CFLAGS): Add -fgnu89-inline since\n+\tdejagnu.h assumes this.\n+\n+2014-10-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp (get_path_of_driver): New procedure.\n+\t(jit-dg-test): Don't unsetenv GCC_EXEC_PREFIX, since jit-playback.c\n+\tnow adds -fno-use-linker-plugin to the driver cmdline sidestepping\n+\tthe builddir/installdir libtto_plugin naming issue.\n+\tWhen setting up PATH so that the JIT library can invoke the driver\n+\tby installation name, don't use the installation \"bindir\".\n+\tInstead, simply use the location of xgcc as detected\n+\tget_path_of_driver.  In addition, set up LIBRARY_PATH so that the\n+\tlinker run from inside the JIT library can locate libgcc etc when\n+\tbuilding the .so, pointing it at the same directory.\n+\n+2014-10-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp (fixed_host_execute): New function, taken from\n+\t\"host_execute\" in DejaGnu's dejagnu.exp, with one line removed.\n+\t(jit-dg-test): Use fixed_host_execute, rathern than host_execute.\n+\n+2014-10-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h [MAKE_DEJAGNU_H_THREADSAFE] (note): Redefine\n+\t\"note\" from dejagnu.h to new function dejagnu_note so that we can\n+\tmake \"note\" be threadsafe.\n+\t(set_options): Don't enable GCC_JIT_BOOL_OPTION_DUMP_SUMMARY,\n+\tsince it can generate large amounts of output that could overwhelm\n+\texpect's buffer.\n+\t* jit.dg/test-dot-product.c (verify_code): Use \"note\" rather than\n+\t\"printf\", to give DejaGnu more chances to parse this log data,\n+\trather than overflowing its buffer.\n+\t* jit.dg/test-factorial.c (verify_code): Likewise.\n+\t* jit.dg/test-fibonacci.c (verify_code): Likewise.\n+\t* jit.dg/test-fuzzer.c (main): Likewise.\n+\t* jit.dg/test-nested-loops.c (verify_code): Likewise.\n+\t* jit.dg/test-sum-of-squares.c (verify_code): Likewise.\n+\t* jit.dg/test-threads.c (note): New function, adding thread-safety\n+\ton top of \"dejagnu_note\", the latter being the implementation\n+\tfound in dejagnu.h.\n+\t(run_threaded_test): Use \"note\" rather than \"printf\".\n+\n+2014-10-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp (jit-dg-test): Prepend the installed bindir to\n+\tthe PATH before invoking built binaries using the library, so that\n+\tthe library can find the driver.  Restore the PATH immediately\n+\tafterwards.\n+\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: Add copyright footer.\n+\n+2014-09-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-expressions.c (make_tests_of_binary_ops): Add\n+\tshift operators.\n+\t(verify_binary_ops): Likewise.\n+\n+2014-09-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp: When constructing \"tests\", add the example files\n+\tfrom the documentation, to ensure that they compile.\n+\n+2014-09-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp: Load target-supports.exp.\n+\n+2014-09-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-nested-loops.c: New test case.\n+\t* jit.dg/all-non-failing-tests.h: Add test-nested-loops.c.\n+\t* jit.dg/test-combination.c (create_code): Likewise.\n+\t(verify_code): Likewise.\n+\t* jit.dg/test-threads.c (const): Add test-nested-loops.c.\n+\n+2014-08-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-threads.c: New test case, running all of the\n+\tindividual test cases in separate threads.\n+\t* jit.dg/test-combination.c: Move inclusion of the various\n+\tindividual testcases into...\n+\t* jit.dg/all-non-failing-tests.h: ...this new file, and rename\n+\tTEST_COMBINATION to COMBINED_TEST.\n+\t* jit.dg/harness.h: Respond to new macro MAKE_DEJAGNU_H_THREADSAFE\n+\tby hacking up <dejagnu.h> to be threadsafe.  Rename\n+\tTEST_COMBINATION to COMBINED_TEST.\n+\t* jit.dg/jit.exp (proc jit-dg-test): Add \"-lpthread\" when building\n+\ttest-threads.exe.\n+\n+2014-08-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-accessing-union.c: New test case.\n+\t* jit.dg/test-combination.c: Add test-accessing-union.c.\n+\n+2014-08-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-combination.c (create_code): Add missing calls to\n+\tcreate_code_quadratic and create_code_reading_struct.\n+\t(verify_code): Add missing calls to verify_code_quadratic and\n+\tverify_code_reading_struct.\n+\n+2014-08-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-calling-function-ptr.c: New test case.\n+\t* jit.dg/test-combination.c: Add test-calling-function-ptr.c.\n+\t* jit.dg/test-error-call-through-ptr-with-mismatching-args.c: New\n+\ttest case.\n+\t* jit.dg/test-error-call-through-ptr-with-non-function.c: New test\n+\tcase.\n+\t* jit.dg/test-error-call-through-ptr-with-non-pointer.c: New test\n+\tcase.\n+\t* jit.dg/test-error-call-through-ptr-with-not-enough-args.c: New\n+\ttest case.\n+\n+2014-07-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-index-not-a-numeric-type.c: New test case.\n+\t* jit.dg/test-error-value-not-a-numeric-type.c: New test case.\n+\n+2014-03-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-array-as-pointer.c: New test case, verifying that\n+\tthere's a way to treat arrays as pointers.\n+\t* jit.dg/test-combination.c: Add test-array-as-pointer.c...\n+\t(create_code): ...here and...\n+\t(verify_code): ...here.\n+\n+\t* jit.dg/test-error-array-as-pointer.c: New test case, verifying\n+\tthat bogus casts from array to pointer are caught by the type\n+\tsystem, rather than leading to ICEs seen in:\n+\thttps://github.com/davidmalcolm/pygccjit/pull/3#issuecomment-37883129\n+\n+2014-03-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-combination.c: Add test-arrays.c and test-volatile.c.\n+\tAdd comment about test-error-*.c.  Remove comment about\n+\ttest-failure.c, which was removed in\n+\t96b218c9a1d5f39fb649e02c0e77586b180e8516.\n+\t(create_code): Call into test-arrays.c and test-volatile.c.\n+\t(verify_code): Likewise.\n+\n+2014-03-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-expressions.c (called_pointer_checking_function): New.\n+\t(make_tests_of_casts): Add test of casting from array to pointer.\n+\t(verify_casts): Likewise.\n+\n+2014-03-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-bad-cast.c: New test case.\n+\n+2014-03-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (set_options): Increase optimization level from\n+\t0 to 3.\n+\n+2014-03-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-functions.c (create_test_of_hidden_function): New,\n+\tadding test coverage for GCC_JIT_FUNCTION_ALWAYS_INLINE and\n+\tGCC_JIT_FUNCTION_INTERNAL.\n+\t(create_tests_of_hidden_functions): Likewise.\n+\t(verify_hidden_functions): Likewise.\n+\t(create_code): Add call to create_tests_of_hidden_functions.\n+\t(verify_code): Add call to verify_hidden_functions.\n+\t* jit.dg/test-quadratic.c (make_calc_discriminant): Convert\n+\tfrom GCC_JIT_FUNCTION_EXPORTED to GCC_JIT_FUNCTION_INTERNAL.\n+\n+2014-03-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-functions.c: Reorder function definitions, grouping\n+\tthem by subject-matter rather than by create-vs-verify phase.\n+\n+2014-03-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-nested-contexts.c (main): Dump the contexts to\n+\tfiles, setting up source locations, and adding test coverage for\n+\tgcc_jit_context_dump_to_file.\n+\n+2014-03-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-mismatching-types-in-call.c: New test case,\n+\tto ensure that a (struct foo *) vs (struct foo) type error is\n+\tgracefully handled.\n+\n+2014-03-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-volatile.c: New testcase, to exercise\n+\tgcc_jit_type_get_volatile, and show a way to work with pre-existing\n+\tglobal variables.\n+\n+2014-02-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-expressions.c (make_test_of_cast): New, to test new\n+\tentrypoint gcc_jit_context_new_cast.\n+\t(make_tests_of_casts): New.\n+\t(create_code): Add call to make_tests_of_casts.\n+\t(verify_code): Add call to verify_casts.\n+\n+2014-02-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-accessing-struct.c (create_code): Port to\n+\tblock-based API.\n+\t* jit.dg/test-calling-external-function.c (create_code): Likewise.\n+\t* jit.dg/test-error-accessing-field-in-other-struct.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-error-call-with-mismatching-args.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-error-call-with-not-enough-args.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-error-call-with-too-many-args.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-error-dereference-field-of-non-pointer.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-error-dereference-read: Likewise.\n+\t* jit.dg/test-error-mismatching-types-in-assignment.c: Likewise.\n+\t* jit.dg/test-error-return-within-void-function.c: Likewise.\n+\t* jit.dg/test-expressions.c: Likewise.\n+\t* jit.dg/test-factorial.c: Likewise.\n+\t* jit.dg/test-functions.c: Likewise.\n+\t* jit.dg/test-fuzzer.c: Likewise.\n+\t* jit.dg/test-hello-world.c (create_code): Likewise.\n+\t* jit.dg/test-nested-contexts.c: Likewise.\n+\t* jit.dg/test-operator-overloading.cc: Likewise.\n+\t* jit.dg/test-quadratic.c: Likewise.\n+\t* jit.dg/test-quadratic.cc: Likewise.\n+\t* jit.dg/test-reading-struct.c (create_code): Likewise.\n+\t* jit.dg/test-string-literal.c (create_code): Likewise.\n+\t* jit.dg/test-sum-of-squares.c (create_code): Likewise.\n+\t* jit.dg/test-types.c (create_code): Likewise.\n+\t* jit.dg/test-using-global.c (create_code): Likewise.\n+\n+\t* jit.dg/test-arrays.c (create_code): Likewise, eliminating use of\n+\tloop API.\n+\t* jit.dg/test-dot-product.c (create_code): Likewise.\n+\t* jit.dg/test-linked-list.c (create_code): Likewise.\n+\n+\t* jit.dg/test-error-adding-to-terminated-block.c: New testcase.\n+\t* jit.dg/test-error-block-in-wrong-function.c: Likewise.\n+\t* jit.dg/test-error-missing-return.c: Likewise.\n+\t* jit.dg/test-error-unreachable-block.c: Likewise.\n+\t* jit.dg/test-error-unterminated-block.c: Likewise.\n+\n+\t* jit.dg/test-error-label-already-placed.c: Delete obsolete testcase.\n+\t* jit.dg/test-error-unplaced-label.c: Likewise.\n+\n+2014-02-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-functions.c (create_use_of_void_return): New, to add\n+\ttest coverage for gcc_jit_function_add_void_return.\n+\t(verify_void_return): Likewise.\n+\t(create_code): Add call to create_use_of_void_return.\n+\t(verify_code): Add call to verify_void_return.\n+\n+2014-02-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-accessing-struct.c (create_code): Update for change to\n+\treturn type of gcc_jit_context_new_struct_type.\n+\t* jit.dg/test-arrays.c (create_code): Likewise.\n+\t* jit.dg/test-error-accessing-field-in-other-struct.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-error-dereference-field-of-non-pointer.c (create_code):\n+\tLikewise.\n+\t* jit.dg/test-fuzzer.c (make_random_type): Likewise.\n+\t* jit.dg/test-nested-contexts.c (make_types): Likewise.\n+\t* jit.dg/test-quadratic.c (make_types): Likewise.\n+\t* jit.dg/test-reading-struct.c (create_code): Likewise.\n+\t* jit.dg/test-types.c (create_code): Likewise.\n+\n+\t* jit.dg/test-linked-list.c: New selftest, exercising\n+\tgcc_jit_context_new_opaque_struct, gcc_jit_type_get_pointer, and\n+\tgcc_jit_context_null.\n+\t* jit.dg/test-combination.c: Add test-linked-list.c\n+\n+2014-02-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-operator-overloading.cc (make_test_quadratic): Use\n+\tthe new \"zero\" and \"one\" methods of gccjit::type.\n+\t* jit.dg/test-quadratic.cc (make_test_quadratic): Use the new\n+\t\"add_call\" method of gccjit::function.\n+\n+2014-02-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (CHECK_DOUBLE_VALUE): New macro.\n+\t(CHECK): New macro.\n+\t* jit.dg/test-functions.c: New testcase, exercising\n+\tgcc_jit_context_get_builtin_function.\n+\t* jit.dg/test-combination.c: Add test-functions.c to the combined\n+\ttest.\n+\n+2014-02-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-types.c: Add test coverage for getting type\n+\tGCC_JIT_TYPE_BOOL.\n+\t* jit.dg/test-expressions.c (make_test_of_comparison): Convert\n+\treturn type from int to bool.\n+\t(verify_comparisons): Likewise.\n+\n+2014-02-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-unplaced-label.c (verify_code): Update\n+\texpected error message to reflect commit\n+\t6cd4f82c5237cc328aea229cdaaa428ff09d6e98.\n+\n+2014-02-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-types.c (struct zoo): Add field m_sized_int_type,\n+\tto be populated by...\n+\t(create_code): Use gcc_jit_context_get_int_type.\n+\t(verify_code): Verify that type from gcc_jit_context_get_int_type\n+\tworks properly.\n+\t* jit.dg/test-operator-overloading.cc (make_types): Use the\n+\ttemplate form of get_int_type.\n+\t* jit.dg/test-quadratic.cc (make_types): Likewise.\n+\n+2014-02-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-operator-overloading.cc: New testcase, a\n+\trewrite of test-quadratic.cc to use operator overloading.\n+\n+2014-02-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-quadratic.cc (make_calc_discriminant): Make use of\n+\tnew methods of the C++ wrapper API to shorten the example code.\n+\t(make_test_quadratic): Likewise.\n+\n+2014-02-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-quadratic.cc (make_test_quadratic): Update for\n+\tchange to gccjit::context::new_call to pass args by reference\n+\trather than by value.\n+\n+2014-02-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (check_string_value): Add a forward declaration,\n+\tso that we can use CHECK_STRING_VALUE from within tests used by\n+\ttest-combination.c.\n+\n+\t* jit.dg/test-expressions.c (make_test_of_unary_op): Return a debug\n+\tstringification of the operation so that it be sanity-checked.\n+\t(make_test_of_binary_op): Likewise.\n+\t(make_test_of_comparison): Likewise.\n+\t(make_tests_of_unary_ops): Verify that said stringifications are\n+\tindeed sane.\n+\t(make_tests_of_binary_ops): Likewise.\n+\t(make_tests_of_comparisons): Likewise.\n+\n+\t* jit.dg/test-quadratic.cc (make_types): Verify that the\n+\tget_debug_string method works.\n+\t(make_test_quadratic): Likewise, also, verify that the <<\n+\toperator works.\n+\n+2014-01-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-quadratic.cc: New file - a translation of\n+\ttest-quadratic.c to the libgccjit++.h C++ API.\n+\n+2014-01-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-label-already-placed.c: New test case.\n+\t* jit.dg/test-error-unplaced-label.c: New test case.\n+\n+2014-01-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-call-with-mismatching-args.c: New test case.\n+\n+2014-01-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-accessing-field-in-other-struct.c: New test\n+\tcase.\n+\t* jit.dg/test-error-dereference-field-of-non-pointer.c: Likewise.\n+\t* jit.dg/test-error-dereference-read-of-non-pointer.c: Likewise.\n+\t* jit.dg/test-error-mismatching-types-in-assignment.c: Likewise.\n+\t* jit.dg/test-error-return-within-void-function.c: Likewise.\n+\n+2014-01-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-accessing-struct.c (create_code): Update for API change\n+\tfor accessing fields in terms of gcc_jit_field pointers rather than\n+\tby name.\n+\t* jit.dg/test-nested-contexts.c (make_calc_discriminant): Likewise.\n+\t(make_test_quadratic): Likewise.\n+\t* jit.dg/test-quadratic.c (make_calc_discriminant): Likewise.\n+\t(make_test_quadratic): Likewise.\n+\t* jit.dg/test-reading-struct.c (create_code): Likewise.\n+\t* jit.dg/test-types.c: Likewise.\n+\n+2014-01-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (test_jit): Add the possibility of turning off\n+\tthis function, if the newly-coined \"TEST_ESCHEWS_TEST_JIT\" is\n+\tdefined, for use by...\n+\t* jit.dg/test-nested-contexts.c: New test case, adapting\n+\ttest-quadratic.c, but splitting it into a 3-deep arrangement of\n+\tnested contexts, to test the implementation of child contexts.\n+\n+2014-01-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (test_jit): Move the various calls to set up\n+\toptions on the context into...\n+\t(set_options): ...this new function.\n+\n+2014-01-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-call-with-not-enough-args.c: New test case.\n+\t* jit.dg/test-error-call-with-too-many-args.c: New test case.\n+\t* jit.dg/test-null-passed-to-api.c: Rename to...\n+\t* jit.dg/test-error-null-passed-to-api.c: ...this, so that\n+\terror-handling test cases are consistently named.\n+\n+2014-01-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-empty.c: New test case.\n+\n+2014-01-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (code_making_callback): Rename to...\n+\t(create_code): ...this, and eliminate the returned\n+\terror-handling value: test cases will simply call into the\n+\tgcc_jit_ API, without needing to be run from a callback.\n+\t(test_jit): Don't register a callback, simply call the\n+\t\"create_code\" function for the testcase before compiling the\n+\tcontext.\n+\n+\t* jit.dg/test-accessing-struct.c: Rename \"code_making_callback\"\n+\tto \"create_code\" and eliminate the return code.\n+\t* jit.dg/test-calling-external-function.c: Likewise.\n+\t* jit.dg/test-combination.c: Likewise.\n+\t* jit.dg/test-dot-product.c: Likewise.\n+\t* jit.dg/test-expressions.c: Likewise.\n+\t* jit.dg/test-factorial.c: Likewise.\n+\t* jit.dg/test-fibonacci.c: Likewise.\n+\t* jit.dg/test-fuzzer.c: Likewise.\n+\t* jit.dg/test-hello-world.c: Likewise.\n+\t* jit.dg/test-null-passed-to-api.c: Likewise.\n+\t* jit.dg/test-quadratic.c: Likewise.\n+\t* jit.dg/test-reading-struct.c: Likewise.\n+\t* jit.dg/test-string-literal.c: Likewise.\n+\t* jit.dg/test-sum-of-squares.c: Likewise.\n+\t* jit.dg/test-types.c: Likewise.\n+\t* jit.dg/test-using-global.c: Likewise.\n+\n+\t* jit.dg/test-failure.c: Remove this test case, since it was\n+\tspecifically for testing the now-defunct callback-based API.\n+\n+2014-01-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-quadratic.c: New test case, written to achieve test\n+\tcoverage of gcc_jit_rvalue_access_field, but also exercising\n+\tdivision of doubles.\n+\n+\t* jit.dg/test-combination.c: Add test-quadratic.c\n+\n+\t* jit.dg/test-expressions.c: Add TODOs.\n+\n+2014-01-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-reading-struct.c: New test, to provide test coverage\n+\tof gcc_jit_type_get_const and gcc_jit_lvalue_access_field, in the\n+\tprocess uncovering bugs in how locals were handled.\n+\t* jit.dg/test-combination.c: Add usage of test-reading-struct.c.\n+\n+2014-01-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-hello-world.c (code_making_callback): Add usage of\n+\tgcc_jit_function_add_comment.\n+\n+2013-10-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (main): Wrap with #ifndef TEST_PROVIDES_MAIN\n+\t* jit.dg/test-fuzzer.c: New.\n+\n+2013-10-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (verify_code): Add context param so that\n+\ttest cases of failure can query errors on it.\n+\t(CHECK_STRING_VALUE): New.\n+\t(check_string_value): New.\n+\t(test_jit): Add user_data param and pass it to the code factory.\n+\tPass context to verify_code, calling it before releasing said\n+\tcontext.\n+\t(main): Add NULL user_data to test_jit call.\n+\t* jit.dg/test-accessing-struct.c (verify_code): Add context\n+\tparam.\n+\t* jit.dg/test-calling-external-function.c (verify_code):\n+\tLikewise.\n+\t* jit.dg/test-combination.c (verify_code): Likewise.\n+\t* jit.dg/test-dot-product.c (verify_code): Likewise.\n+\t* jit.dg/test-expressions.c (verify_code): Likewise.\n+\t* jit.dg/test-factorial.c (verify_code): Likewise.\n+\t* jit.dg/test-failure.c (verify_code): Likewise.\n+\t* jit.dg/test-fibonacci.c (verify_code): Likewise.\n+\t* jit.dg/test-hello-world.c (verify_code): Likewise.\n+\t* jit.dg/test-string-literal.c (verify_code): Likewise.\n+\t* jit.dg/test-sum-of-squares.c (verify_code): Likewise.\n+\t* jit.dg/test-types.c (verify_code): Likewise.\n+\t* jit.dg/test-using-global.c (verify_code): Likewise.\n+\t* jit.dg/test-null-passed-to-api.c (verify_code): Likewise;\n+\tuse context to verify that the library provides a sane error\n+\tmessage to the client code.\n+\n+2013-10-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-expressions.c (test_global): New.\n+\t(make_test_of_get_address): New.\n+\t(verify_get_address): New.\n+\t(code_making_callback): Add call to make_test_of_get_address.\n+\t(verify_code): Add call to verify_get_address.\n+\n+2013-10-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-expressions.c: New.\n+\t* jit.dg/test-combination.c: Add usage of test-expressions.c\n+\t* jit.dg/test-accessing-struct.c (code_making_callback): Update\n+\tfor changes to field-access API.\n+\t* jit.dg/test-types.c (code_making_callback): Likewise.\n+\n+2013-10-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-null-passed-to-api.c: New.\n+\n+2013-10-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-accessing-struct.c (code_making_callback): Update\n+\tfor changes to type API.\n+\t* jit.dg/test-calling-external-function.c (code_making_callback):\n+\tLikewise.\n+\t* jit.dg/test-dot-product.c (code_making_callback): Likewise.\n+\t* jit.dg/test-factorial.c (code_making_callback): Likewise.\n+\t* jit.dg/test-fibonacci.c (code_making_callback): Likewise.\n+\t* jit.dg/test-hello-world.c (code_making_callback): Likewise.\n+\t* jit.dg/test-string-literal.c (code_making_callback): Likewise.\n+\t* jit.dg/test-sum-of-squares.c (code_making_callback): Likewise.\n+\t* jit.dg/test-using-globals.c (code_making_callback): Likewise.\n+\t* jit.dg/test-types.c: New.\n+\t* jit.dg/test-combination.c (code_making_callback): Use code\n+\tfrom test-types.c.\n+\t(verify_code): ...and verify it.\n+\n+2013-10-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-dot-product.c (code_making_callback): Update for\n+\tAPI changes to locals.\n+\t* jit.dg/test-sum-of-squares.c (code_making_callback): Likewise.\n+\n+2013-10-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/jit.exp (jit-dg-test): Detect compilation errors and\n+\tmake them be test failures.\n+\n+2013-10-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-factorial.c (code_making_callback): Update\n+\tfor change to gcc_jit_function_place_forward_label.\n+\t* jit.dg/test-fibonacci.c (code_making_callback): Add line\n+\tnumbering to comment, and set up source locations throughout)\n+\tallowing stepping throught the comment in the debugger.\n+\t* jit.dg/test-sum-of-squares.c (code_making_callback): Update\n+\tfor change to gcc_jit_function_place_forward_label.\n+\n+2013-10-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h: Set GCC_JIT_BOOL_OPTION_DUMP_SUMMARY when\n+\trunning selftests.\n+\n+2013-10-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h: Wrap parts of harness within a\n+\t#ifndef TEST_COMBINATION so that it can be included multiple\n+\ttimes.\n+\t* jit.dg/test-accessing-struct.c (code_making_callback): Rename\n+\tthe generated function from test_fn to test_access to avoid a\n+\tnaming collision in the combined test.\n+\t(verify_code): Likewise.\n+\t* jit.dg/test-calling-external-function.c (code_making_callback):\n+\tRename the generated function from test_fn to test_caller.\n+\t(verify_code): Likewise.\n+\t* jit.dg/test-combination.c: New.\n+\t* jit.dg/test-string-literal.c (code_making_callback): Rename\n+\tthe generated function from test_fn to test_string_literal.\n+\t(verify_code): Likewise.\n+\t* jit.dg/test-using-global.c (code_making_callback): Rename\n+\tthe generated function from test_fn to test_using_global.\n+\t(verify_code): Likewise.\n+\n+2013-10-07  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (test_jit): Set\n+\tGCC_JIT_BOOL_OPTION_SELFCHECK_GC when running selftests.\n+\n+2013-10-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-using-global.c: New.\n+\n+2013-10-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg: New subdirectory\n+\t* jit.dg/harness.h: New.\n+\t* jit.dg/jit.exp: New.\n+\t* jit.dg/test-accessing-struct.c: New.\n+\t* jit.dg/test-calling-external-function.c: New.\n+\t* jit.dg/test-dot-product.c: New.\n+\t* jit.dg/test-factorial.c: New.\n+\t* jit.dg/test-failure.c: New.\n+\t* jit.dg/test-fibonacci.c: New.\n+\t* jit.dg/test-hello-world.c: New.\n+\t* jit.dg/test-string-literal.c: New.\n+\t* jit.dg/test-sum-of-squares.c: New.\n+\n+\f\n+Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "10d71993613009812afc326b0aa95f025a31d6ee", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,166 @@\n+/* This file is used by test-combination.c and test-threads.c to\n+   bring all of the non-failing test cases into one source file,\n+   renaming each \"create_code\" and \"verify_code\" hook so that they\n+   each have unique name.  */\n+\n+/* Include various other test cases, defining COMBINED_TEST so that\n+   harness.h doesn't duplicate copes of e.g. main, and renaming the\n+   hooks provided by each test case.  */\n+#define COMBINED_TEST\n+\n+/* test-accessing-struct.c */\n+#define create_code create_code_accessing_struct\n+#define verify_code verify_code_accessing_struct\n+#include \"test-accessing-struct.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-accessing-union.c */\n+#define create_code create_code_accessing_union\n+#define verify_code verify_code_accessing_union\n+#include \"test-accessing-union.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-array-as-pointer.c */\n+#define create_code create_code_array_as_pointer\n+#define verify_code verify_code_array_as_pointer\n+#include \"test-array-as-pointer.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-arrays.c */\n+#define create_code create_code_arrays\n+#define verify_code verify_code_arrays\n+#include \"test-arrays.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-calling-external-function.c */\n+#define create_code create_code_calling_external_function\n+#define verify_code verify_code_calling_external_function\n+#include \"test-calling-external-function.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-calling-function-ptr.c */\n+#define create_code create_code_calling_function_ptr\n+#define verify_code verify_code_calling_function_ptr\n+#include \"test-calling-function-ptr.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-dot-product.c */\n+#define create_code create_code_dot_product\n+#define verify_code verify_code_dot_product\n+#include \"test-dot-product.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-error-*.c: We don't use these test cases, since they deliberately\n+   introduce errors, which we don't want here.  */\n+\n+/* test-expressions.c */\n+#define create_code create_code_expressions\n+#define verify_code verify_code_expressions\n+#include \"test-expressions.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-factorial.c */\n+#define create_code create_code_factorial\n+#define verify_code verify_code_factorial\n+#include \"test-factorial.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-fibonacci.c */\n+#define create_code create_code_fibonacci\n+#define verify_code verify_code_fibonacci\n+#include \"test-fibonacci.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-functions.c */\n+#define create_code create_code_functions\n+#define verify_code verify_code_functions\n+#include \"test-functions.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-hello-world.c */\n+#define create_code create_code_hello_world\n+#define verify_code verify_code_hello_world\n+#include \"test-hello-world.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-linked-list.c */\n+#define create_code create_code_linked_list\n+#define verify_code verify_code_linked_list\n+#include \"test-linked-list.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-long-names.c */\n+#define create_code create_code_long_names\n+#define verify_code verify_code_long_names\n+#include \"test-long-names.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-quadratic.c */\n+#define create_code create_code_quadratic\n+#define verify_code verify_code_quadratic\n+#include \"test-quadratic.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-nested-loops.c */\n+#define create_code create_code_nested_loop\n+#define verify_code verify_code_nested_loop\n+#include \"test-nested-loops.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-reading-struct.c */\n+#define create_code create_code_reading_struct\n+#define verify_code verify_code_reading_struct\n+#include \"test-reading-struct.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-string-literal.c */\n+#define create_code create_code_string_literal\n+#define verify_code verify_code_string_literal\n+#include \"test-string-literal.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-sum-of-squares.c */\n+#define create_code create_code_sum_of_squares\n+#define verify_code verify_code_sum_of_squares\n+#include \"test-sum-of-squares.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-types.c */\n+#define create_code create_code_types\n+#define verify_code verify_code_types\n+#include \"test-types.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-using-global.c */\n+#define create_code create_code_using_global\n+#define verify_code verify_code_using_global\n+#include \"test-using-global.c\"\n+#undef create_code\n+#undef verify_code\n+\n+/* test-volatile.c */\n+#define create_code create_code_volatile\n+#define verify_code verify_code_volatile\n+#include \"test-volatile.c\"\n+#undef create_code\n+#undef verify_code"}, {"sha": "f326891c56defab481fa38412bdf5250b5361427", "filename": "gcc/testsuite/jit.dg/harness.h", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,242 @@\n+/*\n+  Code shared between multiple testcases.\n+\n+  This file contains \"main\" and support code.\n+  Each testcase should implement the following hooks:\n+\n+    extern void\n+    create_code (gcc_jit_context *ctxt, void * user_data);\n+\n+    extern void\n+    verify_code (gcc_jit_context *ctxt, gcc_jit_result *result);\n+\n+ */\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* test-threads.c use threads, but dejagnu.h isn't thread-safe; there's a\n+   shared \"buffer\", and the counts of passed/failed etc are globals.\n+\n+   The solution is to use macros to rename \"pass\" and \"fail\", replacing them\n+   with mutex-guarded alternatives.  */\n+#ifdef MAKE_DEJAGNU_H_THREADSAFE\n+#define pass dejagnu_pass\n+#define fail dejagnu_fail\n+#define note dejagnu_note\n+#endif\n+\n+#include <dejagnu.h>\n+\n+#ifdef MAKE_DEJAGNU_H_THREADSAFE\n+#undef pass\n+#undef fail\n+#undef note\n+#endif\n+\n+static char test[1024];\n+\n+#define CHECK_NON_NULL(PTR) \\\n+  do {                                       \\\n+    if ((PTR) != NULL)                       \\\n+      {                                      \\\n+\tpass (\"%s: %s is non-null\", test, #PTR); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                      \\\n+\tfail (\"%s: %s is NULL\", test, #PTR); \\\n+\tabort ();                            \\\n+    }                                        \\\n+  } while (0)\n+\n+#define CHECK_VALUE(ACTUAL, EXPECTED) \\\n+  do {                                       \\\n+    if ((ACTUAL) == (EXPECTED))              \\\n+      {                                      \\\n+\tpass (\"%s: actual: %s == expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                        \\\n+\tfail (\"%s: actual: %s != expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+\tfprintf (stderr, \"incorrect value\\n\"); \\\n+\tabort ();                              \\\n+    }                                        \\\n+  } while (0)\n+\n+#define CHECK_DOUBLE_VALUE(ACTUAL, EXPECTED) \\\n+  do {                                       \\\n+    double expected = (EXPECTED);\t     \\\n+    double actual = (ACTUAL);\t\t     \\\n+    if (abs (actual - expected) < 0.00001)   \\\n+      {                                      \\\n+\tpass (\"%s: actual: %s == expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                      \\\n+\tfail (\"%s: actual: %s != expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+\tfprintf (stderr, \"incorrect value: %f\\n\", actual); \\\n+\tabort ();                            \\\n+    }                                        \\\n+  } while (0)\n+\n+#define CHECK_STRING_VALUE(ACTUAL, EXPECTED) \\\n+  check_string_value ((ACTUAL), (EXPECTED));\n+\n+#define CHECK(COND) \\\n+  do {\t\t\t\t\t\\\n+    if (COND)\t\t\t\t\\\n+      {\t\t\t\t\\\n+\tpass (\"%s: %s\", test, #COND);\t\\\n+      }\t\t\t\t\\\n+    else\t\t\t\t\\\n+      {\t\t\t\t\\\n+\tfail (\"%s: %s\", test, #COND);\t\\\n+\tabort ();\t\t\t\\\n+      }\t\t\t\t\\\n+  } while (0)\n+\n+/* Hooks that testcases should provide.  */\n+extern void\n+create_code (gcc_jit_context *ctxt, void * user_data);\n+\n+extern void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result);\n+\n+extern void check_string_value (const char *actual, const char *expected);\n+\n+/* Implement framework needed for turning the testcase hooks into an\n+   executable.  test-combination.c and test-threads.c each combine multiple\n+   testcases into larger testcases, so we have COMBINED_TEST as a way of\n+   temporarily turning off this part of harness.h.  */\n+#ifndef COMBINED_TEST\n+\n+void check_string_value (const char *actual, const char *expected)\n+{\n+  if (actual && !expected)\n+    {\n+      fail (\"%s: actual: \\\"%s\\\" != expected: NULL\", test, actual);\n+\tfprintf (stderr, \"incorrect value\\n\");\n+\tabort ();\n+    }\n+    if (expected && !actual)\n+      {\n+\tfail (\"%s: actual: NULL != expected: \\\"%s\\\"\", test, expected);\n+\tfprintf (stderr, \"incorrect value\\n\");\n+\tabort ();\n+      }\n+    if (actual && expected)\n+      {\n+\tif (strcmp (actual, expected))\n+\t  {\n+\t    fail (\"%s: actual: \\\"%s\\\" != expected: \\\"%s\\\"\", test, actual, expected);\n+\t    fprintf (stderr, \"incorrect valuen\");\n+\t    abort ();\n+\t  }\n+\tpass (\"%s: actual: \\\"%s\\\" == expected: \\\"%s\\\"\", test, actual, expected);\n+      }\n+    else\n+      pass (\"%s: actual: NULL == expected: NULL\");\n+}\n+\n+static void set_options (gcc_jit_context *ctxt, const char *argv0)\n+{\n+  /* Set up options.  */\n+  gcc_jit_context_set_str_option (\n+    ctxt,\n+    GCC_JIT_STR_OPTION_PROGNAME,\n+    argv0);\n+  gcc_jit_context_set_int_option (\n+    ctxt,\n+    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+    3);\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+    1);\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE,\n+    0);\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+    0);\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_SELFCHECK_GC,\n+    1);\n+  gcc_jit_context_set_bool_option (\n+    ctxt,\n+    GCC_JIT_BOOL_OPTION_DUMP_SUMMARY,\n+    0);\n+}\n+\n+#ifndef TEST_ESCHEWS_TEST_JIT\n+/* Run one iteration of the test.  */\n+static void\n+test_jit (const char *argv0, void *user_data)\n+{\n+  gcc_jit_context *ctxt;\n+  gcc_jit_result *result;\n+\n+  ctxt = gcc_jit_context_acquire ();\n+     /* FIXME: error-handling */\n+\n+  set_options (ctxt, argv0);\n+\n+  create_code (ctxt, user_data);\n+\n+  /* This actually calls into GCC and runs the build, all\n+     in a mutex for now.  */\n+  result = gcc_jit_context_compile (ctxt);\n+\n+  verify_code (ctxt, result);\n+\n+  gcc_jit_context_release (ctxt);\n+\n+  /* Once we're done with the code, this unloads the built .so file: */\n+  gcc_jit_result_release (result);\n+}\n+#endif /* #ifndef TEST_ESCHEWS_TEST_JIT */\n+\n+/* We want to prefix all unit test results with the test, but dejagnu.exp's\n+   host_execute appears to get confused by the leading \"./\" of argv0,\n+   leading to all tests simply reporting as a single period character \".\".\n+\n+   Hence strip out the final component of the path to the program name,\n+   so that we can use that in unittest reports.  */\n+const char*\n+extract_progname (const char *argv0)\n+{\n+  const char *p;\n+\n+  p = argv0 + strlen (argv0);\n+  while (p != argv0 && p[-1] != '/')\n+    --p;\n+  return p;\n+}\n+\n+#ifndef TEST_PROVIDES_MAIN\n+int\n+main (int argc, char **argv)\n+{\n+  int i;\n+\n+  for (i = 1; i <= 5; i++)\n+    {\n+      snprintf (test, sizeof (test),\n+\t\t\"%s iteration %d of %d\",\n+                extract_progname (argv[0]),\n+                i, 5);\n+\n+      //printf (\"ITERATION %d\\n\", i);\n+      test_jit (argv[0], NULL);\n+      //printf (\"\\n\");\n+    }\n+\n+  totals ();\n+\n+  return 0;\n+}\n+#endif /* #ifndef TEST_PROVIDES_MAIN */\n+\n+#endif /* #ifndef COMBINED_TEST */"}, {"sha": "531e92971fb22a0ddef116524291769a7a030f2a", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,293 @@\n+# Test code for libgccjit.so\n+#\n+# We will compile each of jit.dg/test-*.c into an executable\n+# dynamically linked against libgccjit.so, and then run each\n+# such executable.\n+#\n+# These executables call into the libgccjit.so API to create\n+# code, compile it, and run it, verifying that the results\n+# are as expected.  See harness.h for shared code used by all\n+# such executables.\n+#\n+# The executables call into DejaGnu's unit testing C API to\n+# report PASS/FAIL results, which this script gathers back\n+# up into the Tcl world, reporting a summary of all results\n+# across all of the executables.\n+\n+load_lib dg.exp\n+load_lib prune.exp\n+load_lib target-supports.exp\n+load_lib gcc-defs.exp\n+load_lib timeout.exp\n+load_lib target-libpath.exp\n+load_lib gcc.exp\n+load_lib dejagnu.exp\n+\n+# This is host_execute from dejagnu.exp commit\n+#   126a089777158a7891ff975473939f08c0e31a1c\n+# with the following patch applied, and renaming to \"fixed_host_execute\".\n+# See the discussion at\n+#  http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00000.html\n+#\n+#  --- /usr/share/dejagnu/dejagnu.exp.old  2014-10-08 13:38:57.274068541 -0400\n+#  +++ /usr/share/dejagnu/dejagnu.exp      2014-10-10 12:27:51.113813659 -0400\n+#  @@ -113,8 +113,6 @@ proc host_execute {args} {\n+#       set timetol 0\n+#       set arguments \"\"\n+#   \n+#  -    expect_before buffer_full { perror \"Buffer full\" }\n+#  -\n+#       if { [llength $args] == 0} {\n+#          set executable $args\n+#       } else {\n+\n+\n+# Execute the executable file, and anaylyse the output for the\n+# test state keywords.\n+#    Returns:\n+#\tA \"\" (empty) string if everything worked, or an error message\n+#\tif there was a problem.\n+#\n+proc fixed_host_execute {args} {\n+    global text\n+    global spawn_id\n+\n+    set timeoutmsg \"Timed out: Never got started, \"\n+    set timeout 100\n+    set file all\n+    set timetol 0\n+    set arguments \"\"\n+\n+    if { [llength $args] == 0} {\n+\tset executable $args\n+    } else {\n+\tset executable [string trimleft [lindex [split $args \" \"] 0] \"\\{\"]\n+\tset params [string trimleft [lindex [split $args \" \"] 1] \"\\{\"]\n+\tset params [string trimright $params \"\\}\"]\n+    }\n+\n+    verbose \"The executable is $executable\" 2\n+    if {![file exists ${executable}]} {\n+\tperror \"The executable, \\\"$executable\\\" is missing\" 0\n+\treturn \"No source file found\"\n+    }\n+\n+    # spawn the executable and look for the DejaGnu output messages from the\n+    # test case.\n+    # spawn -noecho -open [open \"|./${executable}\" \"r\"]\n+    spawn -noecho \"./${executable}\" ${params}\n+    expect_after full_buffer {\terror \"got full_buffer\" }\n+\n+    set prefix \"\\[^\\r\\n\\]*\"\n+    expect {\n+\t-re \"^$prefix\\[0-9\\]\\[0-9\\]:..:..:${text}*\\r\\n\" {\n+\t    regsub \"\\[\\n\\r\\t\\]*NOTE: $text\\r\\n\" $expect_out(0,string) \"\" output\n+\t    verbose \"$output\" 3\n+\t    set timetol 0\n+\t    exp_continue\n+\t}\n+\t-re \"^$prefix\\tNOTE:${text}*\" {\n+\t    regsub \"\\[\\n\\r\\t\\]*NOTE: $text\\r\\n\" $expect_out(0,string) \"\" output\n+\t    set output [string range $output 6 end]\n+\t    verbose \"$output\" 2\n+\t    set timetol 0\n+\t    exp_continue\n+\t}\n+\t-re \"^$prefix\\tPASSED:${text}*\" {\n+\t    regsub \"\\[\\n\\r\\t\\]*PASSED: $text\\r\\n\" $expect_out(0,string) \"\" output\n+\t    set output [string range $output 8 end]\n+\t    pass \"$output\"\n+\t    set timetol 0\n+\t    exp_continue\n+\t}\n+\t-re \"^$prefix\\tFAILED:${text}*\" {\n+\t    regsub \"\\[\\n\\r\\t\\]*FAILED: $text\\r\\n\" $expect_out(0,string) \"\" output\n+\t    set output [string range $output 8 end]\n+\t    fail \"$output\"\n+\t    set timetol 0\n+\t    exp_continue\n+\t}\n+\t-re \"^$prefix\\tUNTESTED:${text}*\" {\n+\t    regsub \"\\[\\n\\r\\t\\]*TESTED: $text\\r\\n\" $expect_out(0,string) \"\" output\n+\t    set output [string range $output 8 end]\n+\t    untested \"$output\"\n+\t    set timetol 0\n+\t    exp_continue\n+\t}\n+\t-re \"^$prefix\\tUNRESOLVED:${text}*\" {\n+\t    regsub \"\\[\\n\\r\\t\\]*UNRESOLVED: $text\\r\\n\" $expect_out(0,string) \"\" output\n+\t    set output [string range $output 8 end]\n+\t    unresolved \"$output\"\n+\t    set timetol 0\n+\t    exp_continue\n+\t}\n+\t-re \"^Totals\" {\n+\t    verbose \"All done\" 2\n+\t}\n+\teof {\n+\t    #\t    unresolved \"${executable} died prematurely\"\n+\t    #\t    catch close\n+\t    #\t    return \"${executable} died prematurely\"\n+\t}\n+\ttimeout {\n+\t    warning \"Timed out executing test case\"\n+\t    if { $timetol <= 2 } {\n+\t\tincr timetol\n+\t\texp_continue\n+\t    } else {\n+\t\t-\t\tcatch close\n+\t\treturn \"Timed out executing test case\"\n+\t    }\n+\t}\n+\t-re \"^$prefix\\r\\n\" {\n+\t    exp_continue\n+\t}\n+    }\n+\n+    # force a close of the executable to be safe.\n+    catch close\n+\n+    return \"\"\n+}\n+\n+# (end of code from dejagnu.exp)\n+\n+# GCC_UNDER_TEST is needed by gcc_target_compile\n+global GCC_UNDER_TEST\n+if ![info exists GCC_UNDER_TEST] {\n+    set GCC_UNDER_TEST \"[find_gcc]\"\n+}\n+\n+# Initialize dg.\n+dg-init\n+\n+# Gather a list of all tests.\n+\n+# Tests within the testsuite: gcc/testsuite/jit.dg/test-*.c\n+set tests [lsort [find $srcdir/$subdir test-*.c]]\n+\n+# We also test the examples within the documentation, to ensure that\n+# they compile:\n+set tests [lsort [concat $tests [find $srcdir/../jit/docs/examples *.c]]]\n+\n+verbose \"tests: $tests\"\n+\n+# libgloss has found the driver (as \"xgcc\" or \"gcc) and stored\n+# its full path as GCC_UNDER_TEST.\n+proc get_path_of_driver {} {\n+    global GCC_UNDER_TEST\n+\n+    verbose \"GCC_UNDER_TEST: $GCC_UNDER_TEST\"\n+    set binary [lindex $GCC_UNDER_TEST 0]\n+    verbose \"binary: $binary\"\n+\n+    return [file dirname $binary]\n+}\n+\n+proc jit-dg-test { prog do_what extra_tool_flags } {\n+    verbose \"within jit-dg-test...\"\n+    verbose \"  prog: $prog\"\n+    verbose \"  do_what: $do_what\"\n+    verbose \"  extra_tool_flags: $extra_tool_flags\"\n+\n+    # test-threads.c needs to be linked against pthreads\n+    if {[string match \"*test-threads.c\" $prog]} {\n+\tappend extra_tool_flags \" -lpthread\"\n+    }\n+\n+    # Determine what to name the built executable.\n+    set output_file \"[file rootname [file tail $prog]].exe\"\n+    verbose \"output_file: $output_file\"\n+\n+    # Create the test executable:\n+    set comp_output [gcc_target_compile $prog $output_file $do_what \\\n+\t\t\t\"{additional_flags=$extra_tool_flags}\"]\n+    if ![jit_check_compile \"$prog\" \"initial compilation\" \\\n+\t    $output_file $comp_output] then {\n+      return\n+    }\n+\n+    # Run the test executable, capturing the PASS/FAIL textual output\n+    # from the C API, converting it into the Tcl API.\n+\n+    # We need to set LD_LIBRARY_PATH so that the test files can find\n+    # libgccjit.so\n+    # Do this using set_ld_library_path_env_vars from target-libpath.exp\n+    global ld_library_path\n+    global base_dir\n+    set ld_library_path \"$base_dir/../../\"\n+    set_ld_library_path_env_vars\n+\n+    # libgccjit uses the driver to convert .s files to .so libraries\n+    # via its *installed* name, FULL_DRIVER_NAME\n+    #   ${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}\n+    # e.g. \"x86_64-unknown-linux-gnu-gcc-5.0.0\"\n+    # looking for it on PATH.  Hence we need to prepend the location of\n+    # that executable to PATH when running the tests\n+    set dir_containing_driver [get_path_of_driver ]\n+    verbose \"dir_containing_driver: $dir_containing_driver\"\n+    global env\n+    set old_path $env(PATH)\n+    setenv \"PATH\" $dir_containing_driver:$old_path\n+    verbose -log \"PATH=[getenv PATH]\"\n+\n+    # We have:\n+    #   test-executables\n+    #     linked to -> libgccjit.so\n+    #                    -> invokes driver:\n+    #                         -> invokes the assembler\n+    #                         -> invokes the linker\n+    # We want to be able to run this from the builddir without installing\n+    # but the linker needs to be able to locate various libraries, or we\n+    # get:\n+    #   ld: cannot find crtbeginS.o: No such file or directory\n+    #   ld: cannot find -lgcc\n+    #   ld: cannot find -lgcc_s\n+    # These can be found in the \"gcc\" subdir of the build.\n+    # Hence to be able to run the testsuite without installing, we need\n+    # to set or prepend the \"gcc\" subdir of the build to LIBRARY_PATH:\n+    if { [info exists env(LIBRARY_PATH) ] } {\n+\tset old_library_path $env(LIBRARY_PATH)\n+\tsetenv \"LIBRARY_PATH\" $dir_containing_driver:$old_library_path\n+    } else {\n+\tsetenv \"LIBRARY_PATH\" $dir_containing_driver\n+    }\n+    verbose -log \"LIBRARY_PATH=[getenv LIBRARY_PATH]\"\n+\n+    # dejagnu.exp's host_execute has code to scrape out test results\n+    # from the DejaGnu C API and bring back into the tcl world, so we\n+    # use that to invoke the built code.\n+    # However, it appears to be buggy; see:\n+    #  http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00000.html\n+    # We instead call a patched local copy, \"fixed_host_execute\", defined\n+    # above.\n+    set result [fixed_host_execute $output_file]\n+    verbose \"result: $result\"\n+\n+    # Restore PATH\n+    setenv \"PATH\" $old_path\n+\n+    # Restore LIBRARY_PATH\n+    if { [info exists old_library_path] } {\n+\tsetenv \"LIBRARY_PATH\" $old_library_path\n+    } else {\n+\tunsetenv \"LIBRARY_PATH\"\n+    }\n+\n+    restore_ld_library_path_env_vars\n+}\n+\n+# We need to link with --export-dynamic for test-calling-external-function.c\n+# so that the JIT-built code can call into functions from the main program.\n+set DEFAULT_CFLAGS \"-I$srcdir/../jit -lgccjit -g -Wall -Werror -Wl,--export-dynamic\"\n+\n+# <dejagnu.h> assumes -fgnu89-inline\n+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63613\n+# and http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00011.html\n+append DEFAULT_CFLAGS \" -fgnu89-inline\"\n+\n+# Main loop.  This will invoke jig-dg-test on each test-*.c file.\n+dg-runtest $tests \"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "109a0d7f2cdd90041c8091ea26814dc036626637", "filename": "gcc/testsuite/jit.dg/test-accessing-struct.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-struct.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,112 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+struct foo\n+{\n+  int x;\n+  int y;\n+  int z;\n+};\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     test_access (struct foo *f)\n+     {\n+        f->z = f->x * f->y;\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_field *x =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"x\");\n+  gcc_jit_field *y =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"y\");\n+  gcc_jit_field *z =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"z\");\n+  gcc_jit_field *fields[] = {x, y, z};\n+  gcc_jit_struct *struct_type =\n+    gcc_jit_context_new_struct_type (ctxt, NULL, \"foo\", 3, fields);\n+  gcc_jit_type *ptr_type =\n+    gcc_jit_type_get_pointer (gcc_jit_struct_as_type (struct_type));\n+\n+  /* Build the test function.  */\n+  gcc_jit_param *param_f =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_type, \"f\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_access\",\n+                                  1, &param_f,\n+                                  0);\n+\n+  /* f->x * f->y */\n+  gcc_jit_rvalue *sum =\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT,\n+      int_type,\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_rvalue_dereference_field (\n+\t  gcc_jit_param_as_rvalue (param_f),\n+\t  NULL,\n+\t  x)),\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_rvalue_dereference_field (\n+\tgcc_jit_param_as_rvalue (param_f),\n+\tNULL,\n+\ty)));\n+\n+  /* f->z = ... */\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_assignment (\n+    block,\n+    NULL,\n+    gcc_jit_rvalue_dereference_field (\n+      gcc_jit_param_as_rvalue (param_f),\n+      NULL,\n+      z),\n+    sum);\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef void (*fn_type) (struct foo *);\n+  CHECK_NON_NULL (result);\n+\n+  fn_type test_access =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_access\");\n+  CHECK_NON_NULL (test_access);\n+\n+  struct foo tmp;\n+  tmp.x = 5;\n+  tmp.y = 7;\n+  tmp.z = 0;\n+\n+  /* Call the JIT-generated function.  */\n+  test_access (&tmp);\n+\n+  /* Verify that the code correctly modified the field \"z\".  */\n+  CHECK_VALUE (tmp.z, 35);\n+}\n+"}, {"sha": "658d1bc2eee104dc4aba02a9c95cae1d0f3969c8", "filename": "gcc/testsuite/jit.dg/test-accessing-union.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-union.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-union.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-union.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,97 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+union int_or_float\n+{\n+  int as_int;\n+  float as_float;\n+};\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     float\n+     test_union (int i)\n+     {\n+        union int_or_float u;\n+\tu.as_int = i;\n+\treturn u.as_float;\n+     }\n+  */\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *float_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_field *as_int =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"as_int\");\n+  gcc_jit_field *as_float =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               float_type,\n+                               \"as_float\");\n+  gcc_jit_field *fields[] = {as_int, as_float};\n+  gcc_jit_type *union_type =\n+    gcc_jit_context_new_union_type (ctxt, NULL,\n+\t\t\t\t    \"int_or_float\", 2, fields);\n+\n+  /* Build the test function.  */\n+  gcc_jit_param *param_i =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  float_type,\n+                                  \"test_union\",\n+                                  1, &param_i,\n+                                  0);\n+\n+  gcc_jit_lvalue *u =\n+    gcc_jit_function_new_local (test_fn, NULL,\n+\t\t\t\tunion_type, \"u\");\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+\n+  /* u.as_int = i; */\n+  gcc_jit_block_add_assignment (\n+    block,\n+    NULL,\n+    /* \"u.as_int = ...\" */\n+    gcc_jit_lvalue_access_field (u,\n+\t\t\t\t NULL,\n+\t\t\t\t as_int),\n+    gcc_jit_param_as_rvalue (param_i));\n+\n+  /* return u.as_float; */\n+  gcc_jit_block_end_with_return (\n+    block, NULL,\n+    gcc_jit_rvalue_access_field (gcc_jit_lvalue_as_rvalue (u),\n+\t\t\t\t NULL,\n+\t\t\t\t as_float));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef float (*fn_type) (int i);\n+  CHECK_NON_NULL (result);\n+\n+  fn_type test_union =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_union\");\n+  CHECK_NON_NULL (test_union);\n+\n+  /* Call the JIT-generated function.  */\n+  float f_result = test_union (42);\n+\n+  union int_or_float u;\n+  u.as_float = f_result;\n+\n+  CHECK_VALUE (u.as_int, 42);\n+}"}, {"sha": "1a240ac552cfa715b41d40ef6964aa8bf88ad8e8", "filename": "gcc/testsuite/jit.dg/test-array-as-pointer.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-array-as-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-array-as-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-array-as-pointer.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,101 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stddef.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+#define BUFFER_SIZE (1024)\n+\n+char test_buffer[1024];\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+        void test_of_array_as_pointer (const char *name)\n+        {\n+            snprintf (test_buffer, sizeof (test_buffer),\n+\t              \"hello %s\", name);\n+        }\n+    */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_type *char_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR);\n+  gcc_jit_type *char_ptr_type =\n+    gcc_jit_type_get_pointer (char_type);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *size_t_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_SIZE_T);\n+  gcc_jit_type *buf_type =\n+    gcc_jit_context_new_array_type (ctxt, NULL, char_type, BUFFER_SIZE);\n+\n+  /* extern int snprintf(char *str, size_t size, const char *format, ...); */\n+  gcc_jit_param *param_s =\n+    gcc_jit_context_new_param (ctxt, NULL, char_ptr_type, \"s\");\n+  gcc_jit_param *param_n =\n+    gcc_jit_context_new_param (ctxt, NULL, size_t_type, \"n\");\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_param *snprintf_params[3] = {param_s, param_n, param_format};\n+  gcc_jit_function *snprintf =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"snprintf\",\n+\t\t\t\t  3, snprintf_params,\n+\t\t\t\t  1);\n+\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"test_of_array_as_pointer\",\n+\t\t\t\t  1, &param_name,\n+\t\t\t\t  0);\n+\n+  gcc_jit_lvalue *buffer =\n+    gcc_jit_context_new_global (ctxt, NULL, buf_type, \"test_buffer\");\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block(test_fn, \"entry\");\n+\n+  /* snprintf(buffer, sizeof(buffer), \"hello %s\", name); */\n+  gcc_jit_rvalue *args[4];\n+  args[0] = gcc_jit_context_new_cast (\n+    ctxt, NULL,\n+    /* Here's the difference with test-error-array-as-pointer.c: */\n+    gcc_jit_lvalue_get_address (buffer,\n+\t\t\t\tNULL),\n+    char_ptr_type);\n+  args[1] = gcc_jit_context_new_rvalue_from_int (ctxt,\n+\t\t\t\t\t\t size_t_type,\n+\t\t\t\t\t\t BUFFER_SIZE);\n+  args[2] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\");\n+  args[3] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt, NULL, snprintf, 4, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_NON_NULL (result);\n+\n+  typedef void (*fn_type) (const char *);\n+  fn_type test_of_array_as_pointer =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_of_array_as_pointer\");\n+  CHECK_NON_NULL (test_of_array_as_pointer);\n+\n+  test_of_array_as_pointer (\"world\");\n+  CHECK_STRING_VALUE (test_buffer, \"hello world\");\n+}"}, {"sha": "378a2a31e96190d03332f7fb76cf708f1091ac18", "filename": "gcc/testsuite/jit.dg/test-arrays.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-arrays.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-arrays.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-arrays.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,165 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stddef.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+#define ARRAY_SIZE (4)\n+\n+/* Verify that struct layout works properly when adding an array field.  */\n+struct array_holder\n+{\n+  float m_before;\n+  int m_ints[ARRAY_SIZE];\n+  float m_after;\n+};\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     test_array (struct array_holder *ah)\n+     {\n+\tah->m_before = 4.0f;\n+\tfor i in 0 to (ARRAY_SIZE - 1):\n+\t  ah->m_ints[i] = (i * i);\n+\tah->m_after = 2.0f;\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *float_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_field *field_m_before =\n+    gcc_jit_context_new_field (ctxt, NULL, float_type, \"m_before\");\n+  gcc_jit_field *field_m_ints =\n+    gcc_jit_context_new_field (\n+    ctxt, NULL,\n+    gcc_jit_context_new_array_type (ctxt, NULL, int_type, ARRAY_SIZE),\n+    \"m_ints\");\n+  gcc_jit_field *field_m_after =\n+    gcc_jit_context_new_field (ctxt, NULL, float_type, \"m_after\");\n+\n+  gcc_jit_field *fields[] = {\n+    field_m_before,\n+    field_m_ints,\n+    field_m_after,\n+  };\n+\n+  gcc_jit_struct *struct_type =\n+    gcc_jit_context_new_struct_type (\n+      ctxt,\n+      NULL,\n+      \"array_holder\",\n+      3, fields);\n+\n+  gcc_jit_type *struct_ptr_type =\n+    gcc_jit_type_get_pointer (gcc_jit_struct_as_type (struct_type));\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_param *param_ah =\n+    gcc_jit_context_new_param (ctxt, NULL, struct_ptr_type, \"ah\");\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"test_array\",\n+\t\t\t\t  1, &param_ah,\n+\t\t\t\t  0);\n+\n+  gcc_jit_block *initial = gcc_jit_function_new_block (func, \"initial\");\n+  gcc_jit_block *loop_test = gcc_jit_function_new_block (func, \"loop_test\");\n+  gcc_jit_block *loop_body = gcc_jit_function_new_block (func, \"loop_body\");\n+  gcc_jit_block *final = gcc_jit_function_new_block (func, \"final\");\n+\n+  /* \"ah->m_before = 4.0f;\" */\n+  gcc_jit_block_add_assignment (\n+    initial, NULL,\n+    gcc_jit_rvalue_dereference_field (\n+      gcc_jit_param_as_rvalue (param_ah), NULL, field_m_before),\n+    gcc_jit_context_new_rvalue_from_int (ctxt, float_type, 4));\n+\n+  gcc_jit_block_add_comment (initial, NULL,\n+\t\t\t     \"for i in 0 to (ARRAY_SIZE - 1):\");\n+  gcc_jit_lvalue *i =\n+    gcc_jit_function_new_local (func, NULL, int_type, \"i\");\n+  gcc_jit_block_add_assignment (initial, NULL,\n+      i,\n+      gcc_jit_context_zero (ctxt, int_type));\n+\n+  gcc_jit_block_end_with_jump (initial, NULL, loop_test);\n+\n+  gcc_jit_block_end_with_conditional (loop_test, NULL,\n+    gcc_jit_context_new_comparison (\n+      ctxt, NULL,\n+      GCC_JIT_COMPARISON_LT,\n+      gcc_jit_lvalue_as_rvalue (i),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, int_type, ARRAY_SIZE)),\n+    loop_body,\n+    final);\n+\n+  gcc_jit_block_add_comment (loop_body, NULL, \"ah->m_ints[i] = (i * i);\");\n+  gcc_jit_block_add_assignment (\n+    loop_body, NULL,\n+    gcc_jit_context_new_array_access (\n+      ctxt, NULL,\n+      gcc_jit_lvalue_as_rvalue (gcc_jit_rvalue_dereference_field (\n+\tgcc_jit_param_as_rvalue (param_ah),\n+\tNULL,\n+\tfield_m_ints)),\n+      gcc_jit_lvalue_as_rvalue (i)),\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT,\n+      int_type,\n+      gcc_jit_lvalue_as_rvalue (i),\n+      gcc_jit_lvalue_as_rvalue (i)));\n+\n+  /* \"i++\" */\n+  gcc_jit_block_add_assignment_op (\n+    loop_body, NULL,\n+    i,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_one (ctxt, int_type));\n+\n+  gcc_jit_block_end_with_jump (loop_body, NULL, loop_test);\n+\n+ /* ah->m_after = 2.0f; */\n+  gcc_jit_block_add_assignment (\n+    final, NULL,\n+    gcc_jit_rvalue_dereference_field (\n+      gcc_jit_param_as_rvalue (param_ah), NULL, field_m_after),\n+    gcc_jit_context_new_rvalue_from_int (ctxt, float_type, 2));\n+  gcc_jit_block_end_with_void_return (final, NULL);\n+\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef void (*fn_type) (struct array_holder *ah);\n+\n+  CHECK_NON_NULL (result);\n+  fn_type test_array =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_array\");\n+  CHECK_NON_NULL (test_array);\n+\n+  struct array_holder ah;\n+  memset (&ah, 0xf0, sizeof (ah));\n+\n+  test_array (&ah);\n+  CHECK_VALUE (ah.m_before, 4.0f);\n+  CHECK_VALUE (ah.m_ints[0], 0);\n+  CHECK_VALUE (ah.m_ints[1], 1);\n+  CHECK_VALUE (ah.m_ints[2], 4);\n+  CHECK_VALUE (ah.m_ints[3], 9);\n+  CHECK_VALUE (ah.m_after, 2.0f);\n+\n+}"}, {"sha": "177f3296ac580de4c6e574c55c382cd4e4bd7f77", "filename": "gcc/testsuite/jit.dg/test-calling-external-function.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-calling-external-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-calling-external-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-calling-external-function.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,118 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+  extern void\n+  called_function (int i, int j, int k);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     extern void called_function (int i, int j, int k);\n+\n+     void\n+     test_caller (int a)\n+     {\n+        called_function (a * 3, a * 4, a * 5);\n+     }\n+  */\n+  int i;\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Declare the imported function.  */\n+  gcc_jit_param *params[3];\n+  params[0] =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n+  params[1] =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"j\");\n+  params[2] =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"k\");\n+  gcc_jit_function *called_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_IMPORTED,\n+                                  void_type,\n+                                  \"called_function\",\n+                                  3, params,\n+                                  0);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_param *param_a =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"a\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_caller\",\n+                                  1, &param_a,\n+                                  0);\n+  /* \"a * 3, a * 4, a * 5\"  */\n+  gcc_jit_rvalue *args[3];\n+  for (i = 0; i < 3; i++)\n+    args[i] =\n+      gcc_jit_context_new_binary_op (\n+        ctxt, NULL,\n+        GCC_JIT_BINARY_OP_MULT,\n+        int_type,\n+        gcc_jit_param_as_rvalue (param_a),\n+        gcc_jit_context_new_rvalue_from_int (\n+          ctxt,\n+          int_type,\n+          (i + 3) ));\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt,\n+                              NULL,\n+                              called_fn,\n+                              3, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+static int called_with[3];\n+\n+extern void\n+called_function (int i, int j, int k)\n+{\n+  called_with[0] = i;\n+  called_with[1] = j;\n+  called_with[2] = k;\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef void (*fn_type) (int);\n+  CHECK_NON_NULL (result);\n+\n+  fn_type test_caller =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_caller\");\n+  CHECK_NON_NULL (test_caller);\n+\n+  called_with[0] = 0;\n+  called_with[1] = 0;\n+  called_with[2] = 0;\n+\n+  /* Call the JIT-generated function.  */\n+  test_caller (5);\n+\n+  /* Verify that it correctly called \"called_function\".  */\n+  CHECK_VALUE (called_with[0], 15);\n+  CHECK_VALUE (called_with[1], 20);\n+  CHECK_VALUE (called_with[2], 25);\n+}\n+"}, {"sha": "e21bd15e303f8cfcd37d2eeb294188cc6702066f", "filename": "gcc/testsuite/jit.dg/test-calling-function-ptr.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-calling-function-ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-calling-function-ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-calling-function-ptr.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,118 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     test_calling_function_ptr (void (*fn_ptr) (int, int, int) fn_ptr,\n+                                int a)\n+     {\n+        fn_ptr (a * 3, a * 4, a * 5);\n+     }\n+  */\n+\n+  int i;\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Build the function ptr type.  */\n+  gcc_jit_type *param_types[3];\n+  param_types[0] = int_type;\n+  param_types[1] = int_type;\n+  param_types[2] = int_type;\n+\n+  gcc_jit_type *fn_ptr_type =\n+    gcc_jit_context_new_function_ptr_type (ctxt, NULL,\n+\t\t\t\t\t   void_type,\n+\t\t\t\t\t   3, param_types, 0);\n+\n+  /* Ensure that function ptr types have sane debug strings.  */\n+\n+  CHECK_STRING_VALUE (\n+    gcc_jit_object_get_debug_string (gcc_jit_type_as_object (fn_ptr_type)),\n+    \"void (*) (int, int, int)\");\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_param *param_fn_ptr =\n+    gcc_jit_context_new_param (ctxt, NULL, fn_ptr_type, \"fn_ptr\");\n+  gcc_jit_param *param_a =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"a\");\n+\n+  gcc_jit_param *params[2];\n+  params[0] = param_fn_ptr;\n+  params[1] = param_a;\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_calling_function_ptr\",\n+                                  2, params,\n+                                  0);\n+  /* \"a * 3, a * 4, a * 5\"  */\n+  gcc_jit_rvalue *args[3];\n+  for (i = 0; i < 3; i++)\n+    args[i] =\n+      gcc_jit_context_new_binary_op (\n+        ctxt, NULL,\n+        GCC_JIT_BINARY_OP_MULT,\n+        int_type,\n+        gcc_jit_param_as_rvalue (param_a),\n+        gcc_jit_context_new_rvalue_from_int (\n+          ctxt,\n+          int_type,\n+          (i + 3) ));\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call_through_ptr (\n+      ctxt,\n+      NULL,\n+      gcc_jit_param_as_rvalue (param_fn_ptr),\n+      3, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+static int called_through_ptr_with[3];\n+\n+static void\n+function_called_through_fn_ptr (int i, int j, int k)\n+{\n+  called_through_ptr_with[0] = i;\n+  called_through_ptr_with[1] = j;\n+  called_through_ptr_with[2] = k;\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef void (*fn_type) (void (*fn_ptr) (int, int, int),\n+\t\t\t   int);\n+  CHECK_NON_NULL (result);\n+\n+  fn_type test_caller =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_calling_function_ptr\");\n+  CHECK_NON_NULL (test_caller);\n+\n+  called_through_ptr_with[0] = 0;\n+  called_through_ptr_with[1] = 0;\n+  called_through_ptr_with[2] = 0;\n+\n+  /* Call the JIT-generated function.  */\n+  test_caller (function_called_through_fn_ptr, 5);\n+\n+  /* Verify that it correctly called \"function_called_through_fn_ptr\".  */\n+  CHECK_VALUE (called_through_ptr_with[0], 15);\n+  CHECK_VALUE (called_through_ptr_with[1], 20);\n+  CHECK_VALUE (called_through_ptr_with[2], 25);\n+}\n+"}, {"sha": "06ba90242a3f55371373b1d3faf38a6f0ecb93fd", "filename": "gcc/testsuite/jit.dg/test-combination.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-combination.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-combination.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-combination.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,67 @@\n+/* Construct a test case by combining other test cases, to try to shake\n+   out state issues: all of the test cases are run in one process, inside\n+   one gcc_jit_context (per iteration).  */\n+\n+#include \"all-non-failing-tests.h\"\n+\n+/* Now construct a test case from all the other test cases.\n+\n+   We undefine COMBINED_TEST so that we can now include harness.h\n+   \"for real\".  */\n+#undef COMBINED_TEST\n+#include \"harness.h\"\n+\n+/* Our testing hooks are the combination of the other test cases.  */\n+void\n+create_code (gcc_jit_context *ctxt, void * user_data)\n+{\n+  create_code_accessing_struct (ctxt, user_data);\n+  create_code_accessing_union (ctxt, user_data);\n+  create_code_array_as_pointer (ctxt, user_data);\n+  create_code_arrays (ctxt, user_data);\n+  create_code_calling_external_function (ctxt, user_data);\n+  create_code_calling_function_ptr (ctxt, user_data);\n+  create_code_dot_product (ctxt, user_data);\n+  create_code_expressions (ctxt, user_data);\n+  create_code_factorial (ctxt, user_data);\n+  create_code_fibonacci (ctxt, user_data);\n+  create_code_functions (ctxt, user_data);\n+  create_code_hello_world (ctxt, user_data);\n+  create_code_linked_list (ctxt, user_data);\n+  create_code_long_names (ctxt, user_data);\n+  create_code_quadratic (ctxt, user_data);\n+  create_code_nested_loop (ctxt, user_data);\n+  create_code_reading_struct  (ctxt, user_data);\n+  create_code_string_literal (ctxt, user_data);\n+  create_code_sum_of_squares (ctxt, user_data);\n+  create_code_types (ctxt, user_data);\n+  create_code_using_global (ctxt, user_data);\n+  create_code_volatile (ctxt, user_data);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  verify_code_accessing_struct (ctxt, result);\n+  verify_code_accessing_union (ctxt, result);\n+  verify_code_array_as_pointer (ctxt, result);\n+  verify_code_arrays (ctxt, result);\n+  verify_code_calling_external_function (ctxt, result);\n+  verify_code_calling_function_ptr (ctxt, result);\n+  verify_code_dot_product (ctxt, result);\n+  verify_code_expressions (ctxt, result);\n+  verify_code_factorial (ctxt, result);\n+  verify_code_fibonacci (ctxt, result);\n+  verify_code_functions (ctxt, result);\n+  verify_code_hello_world (ctxt, result);\n+  verify_code_linked_list (ctxt, result);\n+  verify_code_long_names (ctxt, result);\n+  verify_code_quadratic (ctxt, result);\n+  verify_code_nested_loop (ctxt, result);\n+  verify_code_reading_struct (ctxt, result);\n+  verify_code_string_literal (ctxt, result);\n+  verify_code_sum_of_squares (ctxt, result);\n+  verify_code_types (ctxt, result);\n+  verify_code_using_global (ctxt, result);\n+  verify_code_volatile (ctxt, result);\n+}"}, {"sha": "a41109a5d9f361d10b8ae79d882aebfb20ae7663", "filename": "gcc/testsuite/jit.dg/test-dot-product.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-dot-product.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-dot-product.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-dot-product.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,129 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+\tdouble\n+\tmy_dot_product (int n, double *a, double *b)\n+\t{\n+\t  double result = 0.;\n+\t  for (int i = 0; i < n; i++)\n+\t    result += a[i] * b[i];\n+\t  return result\n+\t}\n+\n+     and see what the optimizer can do.  */\n+  gcc_jit_type *val_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_DOUBLE);\n+  gcc_jit_type *ptr_type = gcc_jit_type_get_pointer (val_type);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_type *return_type = val_type;\n+  gcc_jit_param *param_n =\n+    gcc_jit_context_new_param (ctxt, NULL, int_type, \"n\");\n+  gcc_jit_param *param_a =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_type, \"a\");\n+  gcc_jit_param *param_b =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_type, \"b\");\n+  gcc_jit_param *params[3] = {param_n, param_a, param_b};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"my_dot_product\",\n+\t\t\t\t  3, params, 0);\n+\n+  gcc_jit_block *initial = gcc_jit_function_new_block (func, \"initial\");\n+  gcc_jit_block *loop_test = gcc_jit_function_new_block (func, \"loop_test\");\n+  gcc_jit_block *loop_body = gcc_jit_function_new_block (func, \"loop_body\");\n+  gcc_jit_block *final = gcc_jit_function_new_block (func, \"final\");\n+\n+  /* Build: \"double result = 0.;\" */\n+  gcc_jit_lvalue *result =\n+    gcc_jit_function_new_local (func, NULL, val_type, \"result\");\n+\n+  gcc_jit_block_add_assignment (initial, NULL,\n+    result, gcc_jit_context_zero (ctxt, val_type));\n+\n+  /* Build: \"for (int i = 0; i < n; i++)\" */\n+  gcc_jit_lvalue *i =\n+    gcc_jit_function_new_local (func, NULL, int_type, \"i\");\n+  gcc_jit_block_add_assignment (initial, NULL,\n+    i, gcc_jit_context_zero (ctxt, int_type));\n+\n+  gcc_jit_block_end_with_jump (initial, NULL, loop_test);\n+\n+  gcc_jit_block_end_with_conditional (\n+    loop_test, NULL,\n+\n+    /* (i < n) */\n+    gcc_jit_context_new_comparison (\n+      ctxt, NULL,\n+      GCC_JIT_COMPARISON_LT,\n+      gcc_jit_lvalue_as_rvalue (i),\n+      gcc_jit_param_as_rvalue (param_n)),\n+\n+    loop_body,\n+    final);\n+\n+  /* Build: \"result += a[i] * b[i];\" */\n+  gcc_jit_block_add_assignment_op (\n+    loop_body, NULL,\n+    result,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT,\n+      val_type,\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_context_new_array_access (\n+          ctxt, NULL,\n+\t  gcc_jit_param_as_rvalue (param_a),\n+\t  gcc_jit_lvalue_as_rvalue (i))),\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_context_new_array_access (\n+          ctxt, NULL,\n+\t  gcc_jit_param_as_rvalue (param_b),\n+\t  gcc_jit_lvalue_as_rvalue (i)))));\n+\n+  /* Build: \"i++\" */\n+  gcc_jit_block_add_assignment_op (\n+    loop_body, NULL,\n+    i,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    gcc_jit_context_one (ctxt, int_type));\n+\n+  gcc_jit_block_end_with_jump (loop_body, NULL, loop_test);\n+\n+  /* Build: \"return result;\" */\n+  gcc_jit_block_end_with_return (\n+    final,\n+    NULL,\n+    gcc_jit_lvalue_as_rvalue (result));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef double (*my_dot_product_fn_type) (int n, double *a, double *b);\n+  CHECK_NON_NULL (result);\n+\n+  my_dot_product_fn_type my_dot_product =\n+    (my_dot_product_fn_type)gcc_jit_result_get_code (result,\n+\t\t\t\t\t\t     \"my_dot_product\");\n+  CHECK_NON_NULL (my_dot_product);\n+  double test_array[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};\n+  double val = my_dot_product (10, test_array, test_array);\n+  note (\"my_dot_product returned: %f\", val);\n+  CHECK_VALUE (val, 385.0);\n+}\n+"}, {"sha": "820f232dfeeecf2f872d364c7c43729b32771837", "filename": "gcc/testsuite/jit.dg/test-empty.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-empty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-empty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-empty.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,20 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Do nothing.  */\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* We should have a non-NULL result, albeit one with nothing in it.  */\n+  CHECK_NON_NULL (result);\n+}\n+"}, {"sha": "f10954b434c119a8f0f0d1e2aa661beb841fe95a", "filename": "gcc/testsuite/jit.dg/test-error-accessing-field-in-other-struct.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-accessing-field-in-other-struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-accessing-field-in-other-struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-accessing-field-in-other-struct.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,114 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+struct foo\n+{\n+  int x;\n+  int y;\n+};\n+\n+struct bar\n+{\n+  int p;\n+  int q;\n+};\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     test_bogus_access (struct foo *f)\n+     {\n+        f->p = f->q;\n+     }\n+     i.e. using the wrong struct.\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Map \"struct foo\".  */\n+  gcc_jit_field *x =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"x\");\n+  gcc_jit_field *y =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"y\");\n+  gcc_jit_field *foo_fields[] = {x, y};\n+  gcc_jit_struct *struct_foo =\n+    gcc_jit_context_new_struct_type (ctxt, NULL, \"foo\", 2, foo_fields);\n+\n+  /* Map \"struct bar\".  */\n+  gcc_jit_field *p =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"p\");\n+  gcc_jit_field *q =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               int_type,\n+                               \"q\");\n+  /* We don't actually need a gcc_jit_type for \"struct bar\" for the test.  */\n+  gcc_jit_field *bar_fields[] = {p, q};\n+  (void)gcc_jit_context_new_struct_type (ctxt, NULL, \"foo\", 2, bar_fields);\n+\n+  gcc_jit_type *foo_ptr =\n+    gcc_jit_type_get_pointer (gcc_jit_struct_as_type (struct_foo));\n+\n+  /* Build the test function.  */\n+  gcc_jit_param *param_f =\n+    gcc_jit_context_new_param (ctxt, NULL, foo_ptr, \"f\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_bogus_access\",\n+                                  1, &param_f,\n+                                  0);\n+\n+  /* Erroneous: f->p = ... */\n+  gcc_jit_lvalue *lvalue =\n+    gcc_jit_rvalue_dereference_field (\n+      gcc_jit_param_as_rvalue (param_f),\n+      NULL,\n+      p);\n+\n+  /* Erroneous: ... = f->q; */\n+  gcc_jit_rvalue *rvalue =\n+    gcc_jit_lvalue_as_rvalue (\n+      gcc_jit_rvalue_dereference_field (\n+\tgcc_jit_param_as_rvalue (param_f),\n+\tNULL,\n+\tq));\n+\n+  gcc_jit_block *block =\n+    gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_assignment (\n+    block,\n+    NULL,\n+    lvalue, rvalue);\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_rvalue_dereference_field:\"\n+\t\t      \" p is not a field of struct foo\");\n+}\n+"}, {"sha": "9c39dd6a9fba19540263bf6984131e08a533f7fd", "filename": "gcc/testsuite/jit.dg/test-error-adding-to-terminated-block.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-adding-to-terminated-block.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-adding-to-terminated-block.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-adding-to-terminated-block.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,48 @@\n+#include <math.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+       void\n+       test_fn ()\n+       {\n+\t return;\n+\t return;\n+       }\n+  */\n+  gcc_jit_type *void_t =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_t,\n+                                  \"test_fn\",\n+                                  0, NULL,\n+                                  0);\n+  gcc_jit_block *initial =\n+    gcc_jit_function_new_block (test_fn, \"initial\");\n+\n+  gcc_jit_block_end_with_void_return (initial, NULL);\n+  /* Error: \"initial\" has already been terminated.  */\n+  gcc_jit_block_end_with_void_return (initial, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_block_end_with_void_return:\"\n+\t\t      \" adding to terminated block:\"\n+\t\t      \" initial (already terminated by: return;)\");\n+}"}, {"sha": "cd2b7f8c57cc5984b65df52e6576646ce402ffc6", "filename": "gcc/testsuite/jit.dg/test-error-array-as-pointer.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-array-as-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-array-as-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-array-as-pointer.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,99 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stddef.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+#define BUFFER_SIZE (1024)\n+\n+char test_buffer[1024];\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+        void test_of_array_as_pointer (const char *name)\n+        {\n+            snprintf (test_buffer, sizeof (test_buffer),\n+\t              \"hello %s\", name);\n+        }\n+    */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *const_char_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_type *char_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR);\n+  gcc_jit_type *char_ptr_type =\n+    gcc_jit_type_get_pointer (char_type);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *size_t_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_SIZE_T);\n+  gcc_jit_type *buf_type =\n+    gcc_jit_context_new_array_type (ctxt, NULL, char_type, BUFFER_SIZE);\n+\n+  /* extern int snprintf(char *str, size_t size, const char *format, ...); */\n+  gcc_jit_param *param_s =\n+    gcc_jit_context_new_param (ctxt, NULL, char_ptr_type, \"s\");\n+  gcc_jit_param *param_n =\n+    gcc_jit_context_new_param (ctxt, NULL, size_t_type, \"n\");\n+  gcc_jit_param *param_format =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n+  gcc_jit_param *snprintf_params[3] = {param_s, param_n, param_format};\n+  gcc_jit_function *snprintf =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"snprintf\",\n+\t\t\t\t  3, snprintf_params,\n+\t\t\t\t  1);\n+\n+  gcc_jit_param *param_name =\n+    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  void_type,\n+\t\t\t\t  \"test_of_array_as_pointer\",\n+\t\t\t\t  1, &param_name,\n+\t\t\t\t  0);\n+\n+  gcc_jit_lvalue *buffer =\n+    gcc_jit_context_new_global (ctxt, NULL, buf_type, \"test_buffer\");\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block(test_fn, \"entry\");\n+\n+  /* snprintf(buffer, sizeof(buffer), \"hello %s\", name); */\n+  gcc_jit_rvalue *args[4];\n+  args[0] = gcc_jit_context_new_cast (\n+    ctxt, NULL,\n+    /* Here's the difference with test-array-as-pointer.c: */\n+    gcc_jit_lvalue_as_rvalue (buffer),\n+    char_ptr_type);\n+  args[1] = gcc_jit_context_new_rvalue_from_int (ctxt,\n+\t\t\t\t\t\t size_t_type,\n+\t\t\t\t\t\t BUFFER_SIZE);\n+  args[2] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\");\n+  args[3] = gcc_jit_param_as_rvalue (param_name);\n+\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call (ctxt, NULL, snprintf, 4, args));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_cast:\"\n+\t\t      \" cannot cast test_buffer\"\n+\t\t      \" from type: char[1024]\"\n+\t\t      \" to type: char *\");\n+}"}, {"sha": "a0ab4137a5c3e856152cb30374c808289b042708", "filename": "gcc/testsuite/jit.dg/test-error-bad-cast.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-bad-cast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-bad-cast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-bad-cast.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,63 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     int\n+     test_fn ()\n+     {\n+       struct foo f;\n+       return (int)f;\n+     }\n+\n+     and verify that the API complains about the bad cast.\n+  */\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+\n+  gcc_jit_struct *struct_foo =\n+    gcc_jit_context_new_struct_type (ctxt, NULL, \"foo\",\n+\t\t\t\t     0, NULL);\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  int_type,\n+                                  \"test_fn\",\n+                                  0, NULL,\n+                                  0);\n+  gcc_jit_lvalue *f =\n+    gcc_jit_function_new_local (\n+      test_fn,\n+      NULL,\n+      gcc_jit_struct_as_type (struct_foo), \"f\");\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+\n+  gcc_jit_block_end_with_return (\n+    block, NULL,\n+    gcc_jit_context_new_cast (ctxt, NULL,\n+\t\t\t      gcc_jit_lvalue_as_rvalue (f),\n+\t\t\t      int_type));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_cast:\"\n+\t\t      \" cannot cast f from type: struct foo\"\n+\t\t      \" to type: int\");\n+}\n+"}, {"sha": "b7342a3a0558d019af14999334fe8afefc101ea2", "filename": "gcc/testsuite/jit.dg/test-error-block-in-wrong-function.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-block-in-wrong-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-block-in-wrong-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-block-in-wrong-function.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,65 @@\n+#include <math.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+       void\n+       test_fn ()\n+       {\n+\t goto label;\n+       }\n+\n+       void\n+       other_fn ()\n+       {\n+         label:\n+       };\n+     where the destination block is in another function.\n+  */\n+  gcc_jit_type *void_t =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_t,\n+                                  \"test_fn\",\n+                                  0, NULL,\n+                                  0);\n+  /* Build the other_fn.  */\n+  gcc_jit_function *other_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_t,\n+                                  \"other_fn\",\n+                                  0, NULL,\n+                                  0);\n+\n+  gcc_jit_block *initial =\n+    gcc_jit_function_new_block (test_fn, \"initial\");\n+  gcc_jit_block *block_within_other_fn =\n+    gcc_jit_function_new_block (other_fn, \"block_within_other_fn\");\n+\n+  gcc_jit_block_end_with_jump (initial, NULL, block_within_other_fn);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_block_end_with_jump:\"\n+\t\t      \" target block is not in same function:\"\n+\t\t      \" source block initial is in function test_fn\"\n+\t\t      \" whereas target block block_within_other_fn\"\n+\t\t      \" is in function other_fn\");\n+}"}, {"sha": "afe5a7c970c22e3841af6c85ddfec8e77f1726e5", "filename": "gcc/testsuite/jit.dg/test-error-call-through-ptr-with-mismatching-args.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-mismatching-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-mismatching-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-mismatching-args.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,74 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     test_fn (void (*some_fn_ptr) (void *))\n+     {\n+        some_fn_ptr (42);\n+     }\n+\n+     and verify that the API complains about the mismatching argument\n+     type (\"int\" vs \"void *\").  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *void_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID_PTR);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Build the function ptr type.  */\n+  gcc_jit_type *fn_ptr_type =\n+    gcc_jit_context_new_function_ptr_type (ctxt, NULL,\n+\t\t\t\t\t   void_type,\n+\t\t\t\t\t   1, &void_ptr_type, 0);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_param *param_fn_ptr =\n+    gcc_jit_context_new_param (ctxt, NULL, fn_ptr_type, \"some_fn_ptr\");\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_fn\",\n+                                  1, &param_fn_ptr,\n+                                  0);\n+  /* some_fn_ptr (42); */\n+  gcc_jit_rvalue *arg =\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 42);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call_through_ptr (\n+      ctxt,\n+      NULL,\n+      gcc_jit_param_as_rvalue (param_fn_ptr),\n+      1, &arg));\n+  /* the above has the wrong type for argument 1.  */\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_context_new_call_through_ptr:\"\n+\t\t       \" mismatching types for argument 1 of fn_ptr:\"\n+\t\t       \" some_fn_ptr:\"\n+\t\t       \" assignment to param 1 (type: void *)\"\n+\t\t       \" from (int)42 (type: int)\"));\n+}\n+"}, {"sha": "513e3d398960ed99958c88c2805c7e4c81122356", "filename": "gcc/testsuite/jit.dg/test-error-call-through-ptr-with-non-function.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-non-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-non-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-non-function.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,65 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     test_fn (void *some_ptr)\n+     {\n+        ((some_unspecified_fn_ptr_type)some_ptr) (42);\n+     }\n+\n+     and verify that the API complains about the 42 not being a\n+     function pointer.  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *void_ptr_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID_PTR);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_param *some_ptr =\n+    gcc_jit_context_new_param (ctxt, NULL, void_ptr_type, \"some_ptr\");\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_fn\",\n+                                  1, &some_ptr,\n+                                  0);\n+  gcc_jit_rvalue *arg =\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 42);\n+\n+  /* ((some_unspecified_fn_ptr_type)some_ptr) (42); */\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call_through_ptr (\n+      ctxt,\n+      NULL,\n+      /* This is not a function pointer.  */\n+      gcc_jit_param_as_rvalue (some_ptr),\n+      1, &arg));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_context_new_call_through_ptr:\"\n+\t\t       \" fn_ptr is not a function ptr: some_ptr type: void *\"));\n+}\n+"}, {"sha": "8bb50d972038ea6d5301d6998a3c41aa2110ff69", "filename": "gcc/testsuite/jit.dg/test-error-call-through-ptr-with-non-pointer.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-non-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-non-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-non-pointer.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,62 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     test_fn ()\n+     {\n+        ((some_unspecified_fn_ptr_type)42) (43);\n+     }\n+\n+     and verify that the API complains about the 42 not being a\n+     function pointer.  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_fn\",\n+                                  0, NULL,\n+                                  0);\n+  gcc_jit_rvalue *not_a_function =\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 42);\n+  gcc_jit_rvalue *arg =\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 43);\n+\n+  /* ((some_unspecified_fn_ptr_type)42) (43); */\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call_through_ptr (\n+      ctxt,\n+      NULL,\n+      /* This is not even a pointer, let alone a function pointer.  */\n+      not_a_function,\n+      1, &arg));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_context_new_call_through_ptr:\"\n+\t\t       \" fn_ptr is not a ptr: (int)42 type: int\"));\n+}\n+"}, {"sha": "3e160f4c441c0edfa3dc2e3be462a6c06d720927", "filename": "gcc/testsuite/jit.dg/test-error-call-through-ptr-with-not-enough-args.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-not-enough-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-not-enough-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-not-enough-args.c?ref=35485da996c21efc9a574520a737e10fcbeab654", "patch": "@@ -0,0 +1,70 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     void\n+     test_caller (void (*some_fn_ptr) (int p))\n+     {\n+        called_function (); // missing arg\n+     }\n+\n+     and verify that the API complains about the missing argument.\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Build the function ptr type.  */\n+  gcc_jit_type *fn_ptr_type =\n+    gcc_jit_context_new_function_ptr_type (ctxt, NULL,\n+\t\t\t\t\t   void_type,\n+\t\t\t\t\t   1, &int_type, 0);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_param *param_fn_ptr =\n+    gcc_jit_context_new_param (ctxt, NULL, fn_ptr_type, \"some_fn_ptr\");\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_caller\",\n+                                  1, &param_fn_ptr,\n+                                  0);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  /* called_function ();  */\n+  gcc_jit_block_add_eval (\n+    block, NULL,\n+    gcc_jit_context_new_call_through_ptr (\n+      ctxt,\n+      NULL,\n+      gcc_jit_param_as_rvalue (param_fn_ptr),\n+      0, NULL));\n+  /* the above has not enough args.  */\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that mismatching arg count leads to the API giving a NULL\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_context_new_call_through_ptr:\"\n+\t\t       \" not enough arguments to fn_ptr: some_fn_ptr\"\n+\t\t       \" (got 0 args, expected 1)\"));\n+}\n+"}, {"sha": "b8cb2f47e8a55e97ecf622bd7782dac8f5c32441", "filename": "gcc/testsuite/jit.dg/test-error-call-through-ptr-with-too-many-args.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-too-many-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-too-many-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-through-ptr-with-too-many-args.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "7306ffd0cbc5fc6ac212db3509eb716a6c467397", "filename": "gcc/testsuite/jit.dg/test-error-call-with-mismatching-args.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-mismatching-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-mismatching-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-mismatching-args.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "1e8dbbc54e73441a8fba0daf4f854d7e9736f32f", "filename": "gcc/testsuite/jit.dg/test-error-call-with-not-enough-args.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-not-enough-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-not-enough-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-not-enough-args.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "a50fc9753186bf19d490ea119d66d631c33c3b28", "filename": "gcc/testsuite/jit.dg/test-error-call-with-too-many-args.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-too-many-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-too-many-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-call-with-too-many-args.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "75171d722186c627c929abb902ca40424f7de682", "filename": "gcc/testsuite/jit.dg/test-error-dereference-field-of-non-pointer.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-dereference-field-of-non-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-dereference-field-of-non-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-dereference-field-of-non-pointer.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "7b97ab16658686009f2048f0b9909be51e47531f", "filename": "gcc/testsuite/jit.dg/test-error-dereference-read-of-non-pointer.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-dereference-read-of-non-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-dereference-read-of-non-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-dereference-read-of-non-pointer.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "67b712ee1850915b3433165959dde2704ff422e4", "filename": "gcc/testsuite/jit.dg/test-error-get-type-bad-enum.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-get-type-bad-enum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-get-type-bad-enum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-get-type-bad-enum.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "a3540b2cb3703066418f3e84c8162a834ab03712", "filename": "gcc/testsuite/jit.dg/test-error-index-not-a-numeric-type.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-index-not-a-numeric-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-index-not-a-numeric-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-index-not-a-numeric-type.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "83d212d09856145d8fb997f292c20334b5049371", "filename": "gcc/testsuite/jit.dg/test-error-mismatching-types-in-assignment.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-assignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-assignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-assignment.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "203c4cae5323be2e7e4ec775bf54fd89b23404f5", "filename": "gcc/testsuite/jit.dg/test-error-mismatching-types-in-call.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-call.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "5e2434671a1a15d690581e9f8753b65201fb5dd6", "filename": "gcc/testsuite/jit.dg/test-error-missing-return.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-missing-return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-missing-return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-missing-return.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "0592f55cffd6f02b18dc58fdea782fb6b57ed25b", "filename": "gcc/testsuite/jit.dg/test-error-new-binary-op-bad-op.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-binary-op-bad-op.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-binary-op-bad-op.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-binary-op-bad-op.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "f9772de2b6f90d0a054cd0bea7bbf76d0dfd206b", "filename": "gcc/testsuite/jit.dg/test-error-new-function-bad-kind.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-function-bad-kind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-function-bad-kind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-function-bad-kind.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "faab139c68593a12421161a12a8171cda2939ea7", "filename": "gcc/testsuite/jit.dg/test-error-new-unary-op-bad-op.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-unary-op-bad-op.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-unary-op-bad-op.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-new-unary-op-bad-op.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "ea4390b2b077ea96d4e791c4f81e81f68f9fc884", "filename": "gcc/testsuite/jit.dg/test-error-null-passed-to-api.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-null-passed-to-api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-null-passed-to-api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-null-passed-to-api.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "1b0e9c839d295df9de58434a4953e248a55046ad", "filename": "gcc/testsuite/jit.dg/test-error-return-within-void-function.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-return-within-void-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-return-within-void-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-return-within-void-function.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "10806bd69863c51003a0763cd8e3faf57549f48e", "filename": "gcc/testsuite/jit.dg/test-error-unreachable-block.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-unreachable-block.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-unreachable-block.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-unreachable-block.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "491f09f12a31194270341937717260d80af00081", "filename": "gcc/testsuite/jit.dg/test-error-unterminated-block.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-unterminated-block.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-unterminated-block.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-unterminated-block.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "46f4f4863d817a12fc4ebd25f36bdf7799251703", "filename": "gcc/testsuite/jit.dg/test-error-value-not-a-numeric-type.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-value-not-a-numeric-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-value-not-a-numeric-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-value-not-a-numeric-type.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "eb986f38e253cb88e43bc5e9bd74652b1f95ee8f", "filename": "gcc/testsuite/jit.dg/test-expressions.c", "status": "added", "additions": 896, "deletions": 0, "changes": 896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-expressions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-expressions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-expressions.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "b2aaece25e4c8afba23f69482726820922322516", "filename": "gcc/testsuite/jit.dg/test-factorial.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-factorial.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-factorial.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-factorial.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "607bd564221b79b179e4c91e82391626af15932b", "filename": "gcc/testsuite/jit.dg/test-fibonacci.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-fibonacci.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-fibonacci.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-fibonacci.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "3d03adae821f7cd847b435f12c622fe0127c21b7", "filename": "gcc/testsuite/jit.dg/test-functions.c", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-functions.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "f363f8f29a533cbe5d608be9db19094e47ab2a76", "filename": "gcc/testsuite/jit.dg/test-fuzzer.c", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-fuzzer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-fuzzer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-fuzzer.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "93f737b0624d7e5ed63b4b92e0b328ab059c216f", "filename": "gcc/testsuite/jit.dg/test-hello-world.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-hello-world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-hello-world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-hello-world.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "28871d9f00ac56d7570344817e7ff24b992873cd", "filename": "gcc/testsuite/jit.dg/test-linked-list.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-linked-list.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-linked-list.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-linked-list.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "0fc7e676b3975cc0f1f1be2ed2e963afe43b2232", "filename": "gcc/testsuite/jit.dg/test-long-names.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-long-names.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-long-names.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-long-names.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "16bc63f3e9deeea5e190d64f1b15a33b9803169a", "filename": "gcc/testsuite/jit.dg/test-nested-contexts.c", "status": "added", "additions": 641, "deletions": 0, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "1d1a2ba44684cea20d78e76447384c510388b578", "filename": "gcc/testsuite/jit.dg/test-nested-loops.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-loops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-loops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-loops.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "cbb1e98e1c36c24bd13c9004c5115f436820d61f", "filename": "gcc/testsuite/jit.dg/test-operator-overloading.cc", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-operator-overloading.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-operator-overloading.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-operator-overloading.cc?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "715174c92f02ca22ee20990f62bc7d8c8da9797d", "filename": "gcc/testsuite/jit.dg/test-quadratic.c", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-quadratic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-quadratic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-quadratic.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "f3476696f03d0daef0bcaa71a554085968162fec", "filename": "gcc/testsuite/jit.dg/test-quadratic.cc", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-quadratic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-quadratic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-quadratic.cc?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "a090ba9d2f5aec642e9b53efaf5b81232225a8e6", "filename": "gcc/testsuite/jit.dg/test-reading-struct.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-reading-struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-reading-struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-reading-struct.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "097830d05cb6109195897809fc1c176154565d55", "filename": "gcc/testsuite/jit.dg/test-string-literal.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-string-literal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-string-literal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-string-literal.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "d6fdcf6f92cd504e11ae1e3e83794de7402ca3ce", "filename": "gcc/testsuite/jit.dg/test-sum-of-squares.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-sum-of-squares.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-sum-of-squares.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-sum-of-squares.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "7c248ccde6d7fce475930a832bea8d0d02ed86f5", "filename": "gcc/testsuite/jit.dg/test-threads.c", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-threads.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "8debcd7eb82c898e08cc79e1618f721205fb381f", "filename": "gcc/testsuite/jit.dg/test-types.c", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-types.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "3ec949f76a38bd8687d02211b58aae693a3c35f7", "filename": "gcc/testsuite/jit.dg/test-using-global.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-using-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-using-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-using-global.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "3ef3ca5cf4a3b8855577e08611051e6524edd1e7", "filename": "gcc/testsuite/jit.dg/test-volatile.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-volatile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftestsuite%2Fjit.dg%2Ftest-volatile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-volatile.c?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "f3e7b8890696dadf2d4b7868cf1f45e05e58c6af", "filename": "gcc/timevar.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "093bc14a510b6bc7272a34beb8d9dcbb8900183d", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "84acd3314f16ffc4f070543153a1ac689f7d4498", "filename": "include/ChangeLog.jit", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/include%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/include%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "ec6fbc3494d7463d5122fe0e810129e875fc5290", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "6b60e3b3b07382a48c7ffbaf992876426234bdee", "filename": "libbacktrace/ChangeLog.jit", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libbacktrace%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libbacktrace%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "aa860b5ff1f7f37fe72c6a14b7a180868e19a455", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "5182b9cdb926c1d242decd9777713234f57e11c3", "filename": "libcpp/ChangeLog.jit", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libcpp%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libcpp%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "d3244b65a3690994cc9a335807fd8f510c55049e", "filename": "libdecnumber/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libdecnumber%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libdecnumber%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "5182b9cdb926c1d242decd9777713234f57e11c3", "filename": "libdecnumber/ChangeLog.jit", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libdecnumber%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libdecnumber%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "d82cce914897c177c2cd18eea22a30b15948f915", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "5b64f809de45764c8b096f3c5057df60b08bbd09", "filename": "libiberty/ChangeLog.jit", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/libiberty%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/libiberty%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}, {"sha": "64ba6e171a040b542e365e35987426ecca274545", "filename": "zlib/ChangeLog.jit", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35485da996c21efc9a574520a737e10fcbeab654/zlib%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35485da996c21efc9a574520a737e10fcbeab654/zlib%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog.jit?ref=35485da996c21efc9a574520a737e10fcbeab654"}]}