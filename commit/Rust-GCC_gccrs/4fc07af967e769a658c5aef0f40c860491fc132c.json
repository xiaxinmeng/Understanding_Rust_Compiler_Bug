{"sha": "4fc07af967e769a658c5aef0f40c860491fc132c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjMDdhZjk2N2U3NjlhNjU4YzVhZWYwZjQwYzg2MDQ5MWZjMTMyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-09T08:45:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-09T08:45:16Z"}, "message": "gimple.c (type_pair_hash, [...]): Arrange type pairs to be UID ordered.\n\n\t* gimple.c (type_pair_hash, type_pair_eq, lookup_type_pair):\n\tArrange type pairs to be UID ordered.\n\t(gimple_lookup_type_leader): Make inline.\n\nFrom-SVN: r173560", "tree": {"sha": "f4281d41c2f663d30508bd6551ad369dac896578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4281d41c2f663d30508bd6551ad369dac896578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc07af967e769a658c5aef0f40c860491fc132c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc07af967e769a658c5aef0f40c860491fc132c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc07af967e769a658c5aef0f40c860491fc132c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc07af967e769a658c5aef0f40c860491fc132c/comments", "author": null, "committer": null, "parents": [{"sha": "2cf320a89d0de024bac7d92771763f8e124ce152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf320a89d0de024bac7d92771763f8e124ce152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cf320a89d0de024bac7d92771763f8e124ce152"}], "stats": {"total": 30, "additions": 21, "deletions": 9}, "files": [{"sha": "059909b374f1e5f11f7ac5fecc1725e59cf47c60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc07af967e769a658c5aef0f40c860491fc132c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc07af967e769a658c5aef0f40c860491fc132c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fc07af967e769a658c5aef0f40c860491fc132c", "patch": "@@ -1,3 +1,9 @@\n+2011-05-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimple.c (type_pair_hash, type_pair_eq, lookup_type_pair):\n+\tArrange type pairs to be UID ordered.\n+\t(gimple_lookup_type_leader): Make inline.\n+\n 2011-05-09  Nick Clifton  <nickc@redhat.com>\n \n \tPR target/48897"}, {"sha": "385c098f4556f3a876ca5e47a6f21c81b58eff16", "filename": "gcc/gimple.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc07af967e769a658c5aef0f40c860491fc132c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc07af967e769a658c5aef0f40c860491fc132c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4fc07af967e769a658c5aef0f40c860491fc132c", "patch": "@@ -3240,8 +3240,7 @@ type_pair_hash (const void *p)\n   const struct type_pair_d *pair = (const struct type_pair_d *) p;\n   hashval_t val1 = pair->uid1;\n   hashval_t val2 = pair->uid2;\n-  return (iterative_hash_hashval_t (val2, val1)\n-\t  ^ iterative_hash_hashval_t (val1, val2));\n+  return iterative_hash_hashval_t (val1, val2);\n }\n \n /* Compare two type pairs pointed-to by P1 and P2.  */\n@@ -3251,8 +3250,7 @@ type_pair_eq (const void *p1, const void *p2)\n {\n   const struct type_pair_d *pair1 = (const struct type_pair_d *) p1;\n   const struct type_pair_d *pair2 = (const struct type_pair_d *) p2;\n-  return ((pair1->uid1 == pair2->uid1 && pair1->uid2 == pair2->uid2)\n-\t  || (pair1->uid1 == pair2->uid2 && pair1->uid2 == pair2->uid1));\n+  return (pair1->uid1 == pair2->uid1 && pair1->uid2 == pair2->uid2);\n }\n \n /* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n@@ -3271,17 +3269,25 @@ lookup_type_pair (tree t1, tree t2, htab_t *visited_p, struct obstack *ob_p)\n       gcc_obstack_init (ob_p);\n     }\n \n-  pair.uid1 = TYPE_UID (t1);\n-  pair.uid2 = TYPE_UID (t2);\n+  if (TYPE_UID (t1) < TYPE_UID (t2))\n+    {\n+      pair.uid1 = TYPE_UID (t1);\n+      pair.uid2 = TYPE_UID (t2);\n+    }\n+  else\n+    {\n+      pair.uid1 = TYPE_UID (t2);\n+      pair.uid2 = TYPE_UID (t1);\n+    }\n   slot = htab_find_slot (*visited_p, &pair, INSERT);\n \n   if (*slot)\n     p = *((type_pair_t *) slot);\n   else\n     {\n       p = XOBNEW (ob_p, struct type_pair_d);\n-      p->uid1 = TYPE_UID (t1);\n-      p->uid2 = TYPE_UID (t2);\n+      p->uid1 = pair.uid1;\n+      p->uid2 = pair.uid2;\n       p->same_p[0] = -2;\n       p->same_p[1] = -2;\n       *slot = (void *) p;\n@@ -3324,7 +3330,7 @@ static GTY((deletable, length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n /* Lookup an existing leader for T and return it or NULL_TREE, if\n    there is none in the cache.  */\n \n-static tree\n+static inline tree\n gimple_lookup_type_leader (tree t)\n {\n   gimple_type_leader_entry *leader;"}]}