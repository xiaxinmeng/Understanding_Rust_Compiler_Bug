{"sha": "ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwYWI0ZjcxOGI1Yzg1Yzk5OWRjM2NkZjE3NDViY2E2MjdlM2M2OQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-22T15:48:30Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-22T15:48:30Z"}, "message": "ira-build.c (ira_create_object): New arg SUBWORD; all callers changed.\n\n\t* ira-build.c (ira_create_object): New arg SUBWORD; all callers changed.\n\tInitialize OBJECT_SUBWORD.\n\t(ira_create_allocno): Clear ALLOCNO_NUM_OBJECTS.\n\t(ira_create_allocno_objects): Renamed from ira_create_allocno_object;\n\tall callers changed.\n\t(merge_hard_reg_conflicts): Iterate over allocno subobjects.\n\t(finish_allocno): Likewise.\n\t(move_allocno_live_ranges, copy_allocno_live_ranges): Likewise.\n\t(remove_low_level_allocnos): Likewise.\n\t(update_bad_spill_attribute): Likewise.\n\t(setup_min_max_allocno_live_range_point): Likewise.\n\t(sort_conflict_id_map): Likewise.\n\t(ira_flattening): Likewise.  Use ior_hard_reg_conflicts.\n\t(ior_hard_reg_conflicts): New function.\n\t(ior_allocate_object_conflicts): Renamed first argument to OBJ.\n\t(compress_conflict_vecs): Iterate over objects, not allocnos.\n\t(ira_add_live_range_to_object): New function.\n\t(object_range_compare_func): Renamed from allocno_range_compare_func.\n\tAll callers changed.\n\t(setup_min_max_conflict_allocno_ids): For allocnos with multiple\n\tsubobjects, widen the min/max range of the lowest-order object to\n\tpotentially include all other such low-order objects.\n\t* ira.c (ira_bad_reload_regno_1): Iterate over allocno subobjects.\n\t(check_allocation): Likewise.  Use more fine-grained tests for register\n\tconflicts.\n\t* ira-color.c (allocnos_have_intersected_live_ranges_p): Iterate over\n\tallocno subobjects.\n\t(assign_hard_reg): Keep multiple sets of conflicts.  Make finer-grained\n\tchoices about which bits to set in each set.  Don't use\n\tira_hard_reg_not_in_set_p, perform a more elaborate test for conflicts\n\tusing the multiple sets we computed.\n\t(push_allocno_to_stack): Iterate over allocno subobjects.\n\t(all_conflicting_hard_regs_coalesced): New static function.\n\t(setup_allocno_available_regs_num): Use it.\n\t(setup_allocno_left_conflicts_size): Likewise.  Iterate over allocno\n\tsubobjects.\n\t(coalesced_allocno_conflict): Test subobject 0 in each allocno.\n\t(setup_allocno_priorities): Divide ALLOCNO_EXCESS_PRESSURE_POINTS_NUM\n\tby ALLOCNO_NUM_OBJECTS.\n\t(calculate_spill_cost): Likewise.\n\t(color_pass): Express if statement in a more normal way.\n\t(ira_reassign_conflict_allocnos): Iterate over allocno subobjects.\n\t(slot_coalesced_allocno_live_ranges_intersect_p): Likewise.\n\t(setup_slot_coalesced_allocno_live_ranges): Likewise.\n\t(allocno_reload_assign): Likewise.\n\t(ira_reassign_pseudos): Likewise.\n\t(fast_allocation): Likewise.\n\t* ira-conflicts.c (build_conflict_bit_table): Likewise.\n\t(print_allocno_conflicts): Likewise.\n\t(ira_build_conflicts): Likewise.\n\t(allocnos_conflict_for_copy_p): Renamed from allocnos_conflict_p.  All\n\tcallers changed.  Test subword 0 of each allocno for conflicts.\n\t(build_object_conflicts): Renamed from build_allocno_conflicts.  All\n\tcallers changed.  Iterate over allocno subobjects.\n\t* ira-emit.c (modify_move_list): Iterate over allocno subobjects.\n\t* ira-int.h (struct ira_allocno): New member. num_objects.  Rename object\n\tto objects and change it into an array.\n\t(ALLOCNO_OBJECT): Add new argument N.\n\t(ALLOCNO_NUM_OBJECTS, OBJECT_SUBWORD): New macros.\n\t(ira_create_allocno_objects): Renamed from ira_create_allocno_object.\n\t(ior_hard_reg_conflicts): Declare.\n\t(ira_add_live_range_to_object): Declare.\n\t(ira_allocno_object_iterator): New.\n\t(ira_allocno_object_iter_init, ira_allocno_object_iter_cond): New.\n\t(FOR_EACH_ALLOCNO_OBJECT): New macro.\n\t* ira-lives.c (objects_live): Renamed from allocnos_live; all uses changed.\n\t(allocnos_processed): New sparseset.\n\t(make_object_born): Renamed from make_allocno_born; take an ira_object_t\n\targument.  All callers changed.\n\t(make_object_dead): Renamed from make_allocno_dead; take an ira_object t\n\targument.  All callers changed.\n\t(update_allocno_pressure_excess_length): Take an ira_obejct_t argument.\n\tAll callers changed.\n\t(mark_pseudo_regno_live): Iterate over allocno subobjects.\n\t(mark_pseudo_regno_dead): Likewise.\n\t(mark_pseudo_regno_subword_live, mark_pseudo_regno_subword_dead): New\n\tfunctions.\n\t(mark_ref_live): Detect subword accesses and call\n\tmark_pseudo_regno_subword_live as appropriate.\n\t(mark_ref_dead): Likewise for mark_pseudo_regno_subword_dead.\n\t(process_bb_nodes_live): Deal with object-related updates first; set\n\tand test bits in allocnos_processed to avoid computing allocno\n\tstatistics more than once.\n\t(create_start_finish_chains): Iterate over objects, not allocnos.\n\t(print_object_live_ranges): New function.\n\t(print_allocno_live_ranges): Use it.\n\t(ira_create_allocno_live_ranges): Allocate and free allocnos_processed\n\tand objects_live.\n\nFrom-SVN: r162418", "tree": {"sha": "eaa5d4c97bfefaad493c5a8a2a304340a3fe659c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa5d4c97bfefaad493c5a8a2a304340a3fe659c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/comments", "author": null, "committer": null, "parents": [{"sha": "cd1822b80e9d15792854bc6dd77c14cfbde966d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1822b80e9d15792854bc6dd77c14cfbde966d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1822b80e9d15792854bc6dd77c14cfbde966d0"}], "stats": {"total": 1981, "additions": 1314, "deletions": 667}, "files": [{"sha": "65f9d354f2082c91b10fb6dff8ee225c27488f18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -1,3 +1,94 @@\n+2010-07-22  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* ira-build.c (ira_create_object): New arg SUBWORD; all callers changed.\n+\tInitialize OBJECT_SUBWORD.\n+\t(ira_create_allocno): Clear ALLOCNO_NUM_OBJECTS.\n+\t(ira_create_allocno_objects): Renamed from ira_create_allocno_object;\n+\tall callers changed.\n+\t(merge_hard_reg_conflicts): Iterate over allocno subobjects.\n+\t(finish_allocno): Likewise.\n+\t(move_allocno_live_ranges, copy_allocno_live_ranges): Likewise.\n+\t(remove_low_level_allocnos): Likewise.\n+\t(update_bad_spill_attribute): Likewise.\n+\t(setup_min_max_allocno_live_range_point): Likewise.\n+\t(sort_conflict_id_map): Likewise.\n+\t(ira_flattening): Likewise.  Use ior_hard_reg_conflicts.\n+\t(ior_hard_reg_conflicts): New function.\n+\t(ior_allocate_object_conflicts): Renamed first argument to OBJ.\n+\t(compress_conflict_vecs): Iterate over objects, not allocnos.\n+\t(ira_add_live_range_to_object): New function.\n+\t(object_range_compare_func): Renamed from allocno_range_compare_func.\n+\tAll callers changed.\n+\t(setup_min_max_conflict_allocno_ids): For allocnos with multiple\n+\tsubobjects, widen the min/max range of the lowest-order object to\n+\tpotentially include all other such low-order objects.\n+\t* ira.c (ira_bad_reload_regno_1): Iterate over allocno subobjects.\n+\t(check_allocation): Likewise.  Use more fine-grained tests for register\n+\tconflicts.\n+\t* ira-color.c (allocnos_have_intersected_live_ranges_p): Iterate over\n+\tallocno subobjects.\n+\t(assign_hard_reg): Keep multiple sets of conflicts.  Make finer-grained\n+\tchoices about which bits to set in each set.  Don't use\n+\tira_hard_reg_not_in_set_p, perform a more elaborate test for conflicts\n+\tusing the multiple sets we computed.\n+\t(push_allocno_to_stack): Iterate over allocno subobjects.\n+\t(all_conflicting_hard_regs_coalesced): New static function.\n+\t(setup_allocno_available_regs_num): Use it.\n+\t(setup_allocno_left_conflicts_size): Likewise.  Iterate over allocno\n+\tsubobjects.\n+\t(coalesced_allocno_conflict): Test subobject 0 in each allocno.\n+\t(setup_allocno_priorities): Divide ALLOCNO_EXCESS_PRESSURE_POINTS_NUM\n+\tby ALLOCNO_NUM_OBJECTS.\n+\t(calculate_spill_cost): Likewise.\n+\t(color_pass): Express if statement in a more normal way.\n+\t(ira_reassign_conflict_allocnos): Iterate over allocno subobjects.\n+\t(slot_coalesced_allocno_live_ranges_intersect_p): Likewise.\n+\t(setup_slot_coalesced_allocno_live_ranges): Likewise.\n+\t(allocno_reload_assign): Likewise.\n+\t(ira_reassign_pseudos): Likewise.\n+\t(fast_allocation): Likewise.\n+\t* ira-conflicts.c (build_conflict_bit_table): Likewise.\n+\t(print_allocno_conflicts): Likewise.\n+\t(ira_build_conflicts): Likewise.\n+\t(allocnos_conflict_for_copy_p): Renamed from allocnos_conflict_p.  All\n+\tcallers changed.  Test subword 0 of each allocno for conflicts.\n+\t(build_object_conflicts): Renamed from build_allocno_conflicts.  All\n+\tcallers changed.  Iterate over allocno subobjects.\n+\t* ira-emit.c (modify_move_list): Iterate over allocno subobjects.\n+\t* ira-int.h (struct ira_allocno): New member. num_objects.  Rename object\n+\tto objects and change it into an array.\n+\t(ALLOCNO_OBJECT): Add new argument N.\n+\t(ALLOCNO_NUM_OBJECTS, OBJECT_SUBWORD): New macros.\n+\t(ira_create_allocno_objects): Renamed from ira_create_allocno_object.\n+\t(ior_hard_reg_conflicts): Declare.\n+\t(ira_add_live_range_to_object): Declare.\n+\t(ira_allocno_object_iterator): New.\n+\t(ira_allocno_object_iter_init, ira_allocno_object_iter_cond): New.\n+\t(FOR_EACH_ALLOCNO_OBJECT): New macro.\n+\t* ira-lives.c (objects_live): Renamed from allocnos_live; all uses changed.\n+\t(allocnos_processed): New sparseset.\n+\t(make_object_born): Renamed from make_allocno_born; take an ira_object_t\n+\targument.  All callers changed.\n+\t(make_object_dead): Renamed from make_allocno_dead; take an ira_object t\n+\targument.  All callers changed.\n+\t(update_allocno_pressure_excess_length): Take an ira_obejct_t argument.\n+\tAll callers changed.\n+\t(mark_pseudo_regno_live): Iterate over allocno subobjects.\n+\t(mark_pseudo_regno_dead): Likewise.\n+\t(mark_pseudo_regno_subword_live, mark_pseudo_regno_subword_dead): New\n+\tfunctions.\n+\t(mark_ref_live): Detect subword accesses and call\n+\tmark_pseudo_regno_subword_live as appropriate.\n+\t(mark_ref_dead): Likewise for mark_pseudo_regno_subword_dead.\n+\t(process_bb_nodes_live): Deal with object-related updates first; set\n+\tand test bits in allocnos_processed to avoid computing allocno\n+\tstatistics more than once.\n+\t(create_start_finish_chains): Iterate over objects, not allocnos.\n+\t(print_object_live_ranges): New function.\n+\t(print_allocno_live_ranges): Use it.\n+\t(ira_create_allocno_live_ranges): Allocate and free allocnos_processed\n+\tand objects_live.\n+\n 2010-07-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/42451"}, {"sha": "bf9124eca59a5b346ae648f1443a484c485c6b9a", "filename": "gcc/ira-build.c", "status": "modified", "additions": 272, "deletions": 136, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -422,12 +422,13 @@ initiate_allocnos (void)\n \n /* Create and return an object corresponding to a new allocno A.  */\n static ira_object_t\n-ira_create_object (ira_allocno_t a)\n+ira_create_object (ira_allocno_t a, int subword)\n {\n   enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n   ira_object_t obj = (ira_object_t) pool_alloc (object_pool);\n \n   OBJECT_ALLOCNO (obj) = a;\n+  OBJECT_SUBWORD (obj) = subword;\n   OBJECT_CONFLICT_ID (obj) = ira_objects_num;\n   OBJECT_CONFLICT_VEC_P (obj) = false;\n   OBJECT_CONFLICT_ARRAY (obj) = NULL;\n@@ -446,6 +447,7 @@ ira_create_object (ira_allocno_t a)\n   ira_object_id_map\n     = VEC_address (ira_object_t, ira_object_id_map_vec);\n   ira_objects_num = VEC_length (ira_object_t, ira_object_id_map_vec);\n+\n   return obj;\n }\n \n@@ -510,10 +512,12 @@ ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n   ALLOCNO_PREV_BUCKET_ALLOCNO (a) = NULL;\n   ALLOCNO_FIRST_COALESCED_ALLOCNO (a) = a;\n   ALLOCNO_NEXT_COALESCED_ALLOCNO (a) = a;\n+  ALLOCNO_NUM_OBJECTS (a) = 0;\n \n   VEC_safe_push (ira_allocno_t, heap, allocno_vec, a);\n   ira_allocnos = VEC_address (ira_allocno_t, allocno_vec);\n   ira_allocnos_num = VEC_length (ira_allocno_t, allocno_vec);\n+\n   return a;\n }\n \n@@ -524,37 +528,56 @@ ira_set_allocno_cover_class (ira_allocno_t a, enum reg_class cover_class)\n   ALLOCNO_COVER_CLASS (a) = cover_class;\n }\n \n-/* Allocate an object for allocno A and set ALLOCNO_OBJECT.  */\n+/* Determine the number of objects we should associate with allocno A\n+   and allocate them.  */\n void\n-ira_create_allocno_object (ira_allocno_t a)\n+ira_create_allocno_objects (ira_allocno_t a)\n {\n-  ALLOCNO_OBJECT (a) = ira_create_object (a);\n+  enum machine_mode mode = ALLOCNO_MODE (a);\n+  enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n+  int n = ira_reg_class_nregs[cover_class][mode];\n+  int i;\n+\n+  if (GET_MODE_SIZE (mode) != 2 * UNITS_PER_WORD || n != 2)\n+    n = 1;\n+\n+  ALLOCNO_NUM_OBJECTS (a) = n;\n+  for (i = 0; i < n; i++)\n+    ALLOCNO_OBJECT (a, i) = ira_create_object (a, i);\n }\n \n-/* For each allocno, create the corresponding ALLOCNO_OBJECT structure.  */\n+/* For each allocno, set ALLOCNO_NUM_OBJECTS and create the\n+   ALLOCNO_OBJECT structures.  This must be called after the cover\n+   classes are known.  */\n static void\n create_allocno_objects (void)\n {\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n   FOR_EACH_ALLOCNO (a, ai)\n-    ira_create_allocno_object (a);\n+    ira_create_allocno_objects (a);\n }\n \n-/* Merge hard register conflicts from allocno FROM into allocno TO.  If\n-   TOTAL_ONLY is true, we ignore ALLOCNO_CONFLICT_HARD_REGS.  */\n+/* Merge hard register conflict information for all objects associated with\n+   allocno TO into the corresponding objects associated with FROM.\n+   If TOTAL_ONLY is true, we only merge OBJECT_TOTAL_CONFLICT_HARD_REGS.  */\n static void\n merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n \t\t\t  bool total_only)\n {\n-  ira_object_t from_obj = ALLOCNO_OBJECT (from);\n-  ira_object_t to_obj = ALLOCNO_OBJECT (to);\n-  if (!total_only)\n-    IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj),\n-\t\t      OBJECT_CONFLICT_HARD_REGS (from_obj));\n-  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj),\n-\t\t    OBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj));\n+  int i;\n+  gcc_assert (ALLOCNO_NUM_OBJECTS (to) == ALLOCNO_NUM_OBJECTS (from));\n+  for (i = 0; i < ALLOCNO_NUM_OBJECTS (to); i++)\n+    {\n+      ira_object_t from_obj = ALLOCNO_OBJECT (from, i);\n+      ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n+      if (!total_only)\n+\tIOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj),\n+\t\t\t  OBJECT_CONFLICT_HARD_REGS (from_obj));\n+      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj),\n+\t\t\tOBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj));\n+    }\n #ifdef STACK_REGS\n   if (!total_only && ALLOCNO_NO_STACK_REG_P (from))\n     ALLOCNO_NO_STACK_REG_P (to) = true;\n@@ -563,6 +586,20 @@ merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n #endif\n }\n \n+/* Update hard register conflict information for all objects associated with\n+   A to include the regs in SET.  */\n+void\n+ior_hard_reg_conflicts (ira_allocno_t a, HARD_REG_SET *set)\n+{\n+  ira_allocno_object_iterator i;\n+  ira_object_t obj;\n+  FOR_EACH_ALLOCNO_OBJECT (a, obj, i)\n+    {\n+      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), *set);\n+      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), *set);\n+    }\n+}\n+\n /* Return TRUE if a conflict vector with NUM elements is more\n    profitable than a conflict bit vector for OBJ.  */\n bool\n@@ -617,14 +654,14 @@ allocate_conflict_bit_vec (ira_object_t obj)\n }\n \n /* Allocate and initialize the conflict vector or conflict bit vector\n-   of A for NUM conflicting allocnos whatever is more profitable.  */\n+   of OBJ for NUM conflicting allocnos whatever is more profitable.  */\n void\n-ira_allocate_object_conflicts (ira_object_t a, int num)\n+ira_allocate_object_conflicts (ira_object_t obj, int num)\n {\n-  if (ira_conflict_vector_profitable_p (a, num))\n-    ira_allocate_conflict_vec (a, num);\n+  if (ira_conflict_vector_profitable_p (obj, num))\n+    ira_allocate_conflict_vec (obj, num);\n   else\n-    allocate_conflict_bit_vec (a);\n+    allocate_conflict_bit_vec (obj);\n }\n \n /* Add OBJ2 to the conflicts of OBJ1.  */\n@@ -772,15 +809,14 @@ compress_conflict_vec (ira_object_t obj)\n static void\n compress_conflict_vecs (void)\n {\n-  ira_allocno_t a;\n-  ira_allocno_iterator ai;\n+  ira_object_t obj;\n+  ira_object_iterator oi;\n \n   conflict_check = (int *) ira_allocate (sizeof (int) * ira_objects_num);\n   memset (conflict_check, 0, sizeof (int) * ira_objects_num);\n   curr_conflict_check_tick = 0;\n-  FOR_EACH_ALLOCNO (a, ai)\n+  FOR_EACH_OBJECT (obj, oi)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n       if (OBJECT_CONFLICT_VEC_P (obj))\n \tcompress_conflict_vec (obj);\n     }\n@@ -823,7 +859,7 @@ create_cap_allocno (ira_allocno_t a)\n   ALLOCNO_MODE (cap) = ALLOCNO_MODE (a);\n   cover_class = ALLOCNO_COVER_CLASS (a);\n   ira_set_allocno_cover_class (cap, cover_class);\n-  ira_create_allocno_object (cap);\n+  ira_create_allocno_objects (cap);\n   ALLOCNO_AVAILABLE_REGS_NUM (cap) = ALLOCNO_AVAILABLE_REGS_NUM (a);\n   ALLOCNO_CAP_MEMBER (cap) = a;\n   ALLOCNO_CAP (a) = cap;\n@@ -838,7 +874,9 @@ create_cap_allocno (ira_allocno_t a)\n   ALLOCNO_NREFS (cap) = ALLOCNO_NREFS (a);\n   ALLOCNO_FREQ (cap) = ALLOCNO_FREQ (a);\n   ALLOCNO_CALL_FREQ (cap) = ALLOCNO_CALL_FREQ (a);\n+\n   merge_hard_reg_conflicts (a, cap, false);\n+\n   ALLOCNO_CALLS_CROSSED_NUM (cap) = ALLOCNO_CALLS_CROSSED_NUM (a);\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     {\n@@ -849,7 +887,7 @@ create_cap_allocno (ira_allocno_t a)\n   return cap;\n }\n \n-/* Create and return allocno live range with given attributes.  */\n+/* Create and return a live range for OBJECT with given attributes.  */\n live_range_t\n ira_create_live_range (ira_object_t obj, int start, int finish,\n \t\t       live_range_t next)\n@@ -864,6 +902,17 @@ ira_create_live_range (ira_object_t obj, int start, int finish,\n   return p;\n }\n \n+/* Create a new live range for OBJECT and queue it at the head of its\n+   live range list.  */\n+void\n+ira_add_live_range_to_object (ira_object_t object, int start, int finish)\n+{\n+  live_range_t p;\n+  p = ira_create_live_range (object, start, finish,\n+\t\t\t     OBJECT_LIVE_RANGES (object));\n+  OBJECT_LIVE_RANGES (object) = p;\n+}\n+\n /* Copy allocno live range R and return the result.  */\n static live_range_t\n copy_live_range (live_range_t r)\n@@ -1032,13 +1081,17 @@ static void\n finish_allocno (ira_allocno_t a)\n {\n   enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n-  ira_object_t obj = ALLOCNO_OBJECT (a);\n+  ira_object_t obj;\n+  ira_allocno_object_iterator oi;\n \n-  ira_finish_live_range_list (OBJECT_LIVE_RANGES (obj));\n-  ira_object_id_map[OBJECT_CONFLICT_ID (obj)] = NULL;\n-  if (OBJECT_CONFLICT_ARRAY (obj) != NULL)\n-    ira_free (OBJECT_CONFLICT_ARRAY (obj));\n-  pool_free (object_pool, obj);\n+  FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n+    {\n+      ira_finish_live_range_list (OBJECT_LIVE_RANGES (obj));\n+      ira_object_id_map[OBJECT_CONFLICT_ID (obj)] = NULL;\n+      if (OBJECT_CONFLICT_ARRAY (obj) != NULL)\n+\tira_free (OBJECT_CONFLICT_ARRAY (obj));\n+      pool_free (object_pool, obj);\n+    }\n \n   ira_allocnos[ALLOCNO_NUM (a)] = NULL;\n   if (ALLOCNO_HARD_REG_COSTS (a) != NULL)\n@@ -1708,44 +1761,58 @@ change_object_in_range_list (live_range_t r, ira_object_t obj)\n static void\n move_allocno_live_ranges (ira_allocno_t from, ira_allocno_t to)\n {\n-  ira_object_t from_obj = ALLOCNO_OBJECT (from);\n-  ira_object_t to_obj = ALLOCNO_OBJECT (to);\n-  live_range_t lr = OBJECT_LIVE_RANGES (from_obj);\n+  int i;\n+  int n = ALLOCNO_NUM_OBJECTS (from);\n+\n+  gcc_assert (n == ALLOCNO_NUM_OBJECTS (to));\n \n-  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+  for (i = 0; i < n; i++)\n     {\n-      fprintf (ira_dump_file,\n-\t       \"      Moving ranges of a%dr%d to a%dr%d: \",\n-\t       ALLOCNO_NUM (from), ALLOCNO_REGNO (from),\n-\t       ALLOCNO_NUM (to), ALLOCNO_REGNO (to));\n-      ira_print_live_range_list (ira_dump_file, lr);\n+      ira_object_t from_obj = ALLOCNO_OBJECT (from, i);\n+      ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n+      live_range_t lr = OBJECT_LIVE_RANGES (from_obj);\n+\n+      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+\t{\n+\t  fprintf (ira_dump_file,\n+\t\t   \"      Moving ranges of a%dr%d to a%dr%d: \",\n+\t\t   ALLOCNO_NUM (from), ALLOCNO_REGNO (from),\n+\t\t   ALLOCNO_NUM (to), ALLOCNO_REGNO (to));\n+\t  ira_print_live_range_list (ira_dump_file, lr);\n+\t}\n+      change_object_in_range_list (lr, to_obj);\n+      OBJECT_LIVE_RANGES (to_obj)\n+\t= ira_merge_live_ranges (lr, OBJECT_LIVE_RANGES (to_obj));\n+      OBJECT_LIVE_RANGES (from_obj) = NULL;\n     }\n-  change_object_in_range_list (lr, to_obj);\n-  OBJECT_LIVE_RANGES (to_obj)\n-    = ira_merge_live_ranges (lr, OBJECT_LIVE_RANGES (to_obj));\n-  OBJECT_LIVE_RANGES (from_obj) = NULL;\n }\n \n-/* Copy all live ranges associated with allocno FROM to allocno TO.  */\n static void\n copy_allocno_live_ranges (ira_allocno_t from, ira_allocno_t to)\n {\n-  ira_object_t from_obj = ALLOCNO_OBJECT (from);\n-  ira_object_t to_obj = ALLOCNO_OBJECT (to);\n-  live_range_t lr = OBJECT_LIVE_RANGES (from_obj);\n+  int i;\n+  int n = ALLOCNO_NUM_OBJECTS (from);\n \n-  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+  gcc_assert (n == ALLOCNO_NUM_OBJECTS (to));\n+\n+  for (i = 0; i < n; i++)\n     {\n-      fprintf (ira_dump_file,\n-\t       \"      Copying ranges of a%dr%d to a%dr%d: \",\n-\t       ALLOCNO_NUM (from), ALLOCNO_REGNO (from),\n-\t       ALLOCNO_NUM (to), ALLOCNO_REGNO (to));\n-      ira_print_live_range_list (ira_dump_file, lr);\n+      ira_object_t from_obj = ALLOCNO_OBJECT (from, i);\n+      ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n+      live_range_t lr = OBJECT_LIVE_RANGES (from_obj);\n+\n+      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+\t{\n+\t  fprintf (ira_dump_file, \"      Copying ranges of a%dr%d to a%dr%d: \",\n+\t\t   ALLOCNO_NUM (from), ALLOCNO_REGNO (from),\n+\t\t   ALLOCNO_NUM (to), ALLOCNO_REGNO (to));\n+\t  ira_print_live_range_list (ira_dump_file, lr);\n+\t}\n+      lr = ira_copy_live_range_list (lr);\n+      change_object_in_range_list (lr, to_obj);\n+      OBJECT_LIVE_RANGES (to_obj)\n+\t= ira_merge_live_ranges (lr, OBJECT_LIVE_RANGES (to_obj));\n     }\n-  lr = ira_copy_live_range_list (lr);\n-  change_object_in_range_list (lr, to_obj);\n-  OBJECT_LIVE_RANGES (to_obj)\n-    = ira_merge_live_ranges (lr, OBJECT_LIVE_RANGES (to_obj));\n }\n \n /* Return TRUE if NODE represents a loop with low register\n@@ -2125,13 +2192,15 @@ remove_low_level_allocnos (void)\n       regno = ALLOCNO_REGNO (a);\n       if (ira_loop_tree_root->regno_allocno_map[regno] == a)\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t  ira_object_t obj;\n+\t  ira_allocno_object_iterator oi;\n \n \t  ira_regno_allocno_map[regno] = a;\n \t  ALLOCNO_NEXT_REGNO_ALLOCNO (a) = NULL;\n \t  ALLOCNO_CAP_MEMBER (a) = NULL;\n-\t  COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t     OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+\t  FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n+\t    COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t       OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n #ifdef STACK_REGS\n \t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n \t    ALLOCNO_NO_STACK_REG_P (a) = true;\n@@ -2194,6 +2263,8 @@ update_bad_spill_attribute (void)\n   int i;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n+  ira_allocno_object_iterator aoi;\n+  ira_object_t obj;\n   live_range_t r;\n   enum reg_class cover_class;\n   bitmap_head dead_points[N_REG_CLASSES];\n@@ -2205,31 +2276,36 @@ update_bad_spill_attribute (void)\n     }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n       cover_class = ALLOCNO_COVER_CLASS (a);\n       if (cover_class == NO_REGS)\n \tcontinue;\n-      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n-\tbitmap_set_bit (&dead_points[cover_class], r->finish);\n+      FOR_EACH_ALLOCNO_OBJECT (a, obj, aoi)\n+\tfor (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+\t  bitmap_set_bit (&dead_points[cover_class], r->finish);\n     }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n       cover_class = ALLOCNO_COVER_CLASS (a);\n       if (cover_class == NO_REGS)\n \tcontinue;\n       if (! ALLOCNO_BAD_SPILL_P (a))\n \tcontinue;\n-      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+      FOR_EACH_ALLOCNO_OBJECT (a, obj, aoi)\n \t{\n-\t  for (i = r->start + 1; i < r->finish; i++)\n-\t    if (bitmap_bit_p (&dead_points[cover_class], i))\n+\t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+\t    {\n+\t      for (i = r->start + 1; i < r->finish; i++)\n+\t\tif (bitmap_bit_p (&dead_points[cover_class], i))\n+\t\t  break;\n+\t      if (i < r->finish)\n+\t\tbreak;\n+\t    }\n+\t  if (r != NULL)\n+\t    {\n+\t      ALLOCNO_BAD_SPILL_P (a) = false;\n \t      break;\n-\t  if (i < r->finish)\n-\t    break;\n+\t    }\n \t}\n-      if (r != NULL)\n-\tALLOCNO_BAD_SPILL_P (a) = false;\n     }\n   for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n@@ -2247,57 +2323,69 @@ setup_min_max_allocno_live_range_point (void)\n   int i;\n   ira_allocno_t a, parent_a, cap;\n   ira_allocno_iterator ai;\n+#ifdef ENABLE_IRA_CHECKING\n+  ira_object_iterator oi;\n+  ira_object_t obj;\n+#endif\n   live_range_t r;\n   ira_loop_tree_node_t parent;\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      r = OBJECT_LIVE_RANGES (obj);\n-      if (r == NULL)\n-\tcontinue;\n-      OBJECT_MAX (obj) = r->finish;\n-      for (; r->next != NULL; r = r->next)\n-\t;\n-      OBJECT_MIN (obj) = r->start;\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  r = OBJECT_LIVE_RANGES (obj);\n+\t  if (r == NULL)\n+\t    continue;\n+\t  OBJECT_MAX (obj) = r->finish;\n+\t  for (; r->next != NULL; r = r->next)\n+\t    ;\n+\t  OBJECT_MIN (obj) = r->start;\n+\t}\n     }\n   for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     for (a = ira_regno_allocno_map[i];\n \t a != NULL;\n \t a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n       {\n-\tira_object_t obj = ALLOCNO_OBJECT (a);\n-\tira_object_t parent_obj;\n-\n-\tif (OBJECT_MAX (obj) < 0)\n-\t  continue;\n-\tira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n-\t/* Accumulation of range info.  */\n-\tif (ALLOCNO_CAP (a) != NULL)\n+\tint j;\n+\tint n = ALLOCNO_NUM_OBJECTS (a);\n+\tfor (j = 0; j < n; j++)\n \t  {\n-\t    for (cap = ALLOCNO_CAP (a); cap != NULL; cap = ALLOCNO_CAP (cap))\n+\t    ira_object_t obj = ALLOCNO_OBJECT (a, j);\n+\t    ira_object_t parent_obj;\n+\n+\t    if (OBJECT_MAX (obj) < 0)\n+\t      continue;\n+\t    ira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n+\t    /* Accumulation of range info.  */\n+\t    if (ALLOCNO_CAP (a) != NULL)\n \t      {\n-\t\tira_object_t cap_obj = ALLOCNO_OBJECT (cap);\n-\t\tif (OBJECT_MAX (cap_obj) < OBJECT_MAX (obj))\n-\t\t  OBJECT_MAX (cap_obj) = OBJECT_MAX (obj);\n-\t\tif (OBJECT_MIN (cap_obj) > OBJECT_MIN (obj))\n-\t\t  OBJECT_MIN (cap_obj) = OBJECT_MIN (obj);\n+\t\tfor (cap = ALLOCNO_CAP (a); cap != NULL; cap = ALLOCNO_CAP (cap))\n+\t\t  {\n+\t\t    ira_object_t cap_obj = ALLOCNO_OBJECT (cap, j);\n+\t\t    if (OBJECT_MAX (cap_obj) < OBJECT_MAX (obj))\n+\t\t      OBJECT_MAX (cap_obj) = OBJECT_MAX (obj);\n+\t\t    if (OBJECT_MIN (cap_obj) > OBJECT_MIN (obj))\n+\t\t      OBJECT_MIN (cap_obj) = OBJECT_MIN (obj);\n+\t\t  }\n+\t\tcontinue;\n \t      }\n-\t    continue;\n+\t    if ((parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) == NULL)\n+\t      continue;\n+\t    parent_a = parent->regno_allocno_map[i];\n+\t    parent_obj = ALLOCNO_OBJECT (parent_a, j);\n+\t    if (OBJECT_MAX (parent_obj) < OBJECT_MAX (obj))\n+\t      OBJECT_MAX (parent_obj) = OBJECT_MAX (obj);\n+\t    if (OBJECT_MIN (parent_obj) > OBJECT_MIN (obj))\n+\t      OBJECT_MIN (parent_obj) = OBJECT_MIN (obj);\n \t  }\n-\tif ((parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) == NULL)\n-\t  continue;\n-\tparent_a = parent->regno_allocno_map[i];\n-\tparent_obj = ALLOCNO_OBJECT (parent_a);\n-\tif (OBJECT_MAX (parent_obj) < OBJECT_MAX (obj))\n-\t  OBJECT_MAX (parent_obj) = OBJECT_MAX (obj);\n-\tif (OBJECT_MIN (parent_obj) > OBJECT_MIN (obj))\n-\t  OBJECT_MIN (parent_obj) = OBJECT_MIN (obj);\n       }\n #ifdef ENABLE_IRA_CHECKING\n-  FOR_EACH_ALLOCNO (a, ai)\n+  FOR_EACH_OBJECT (obj, oi)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n       if ((0 <= OBJECT_MIN (obj) && OBJECT_MIN (obj) <= ira_max_point)\n \t  && (0 <= OBJECT_MAX (obj) && OBJECT_MAX (obj) <= ira_max_point))\n \tcontinue;\n@@ -2312,7 +2400,7 @@ setup_min_max_allocno_live_range_point (void)\n    (min).  Allocnos with the same start are ordered according their\n    finish (max).  */\n static int\n-allocno_range_compare_func (const void *v1p, const void *v2p)\n+object_range_compare_func (const void *v1p, const void *v2p)\n {\n   int diff;\n   ira_object_t obj1 = *(const ira_object_t *) v1p;\n@@ -2340,9 +2428,15 @@ sort_conflict_id_map (void)\n \n   num = 0;\n   FOR_EACH_ALLOCNO (a, ai)\n-    ira_object_id_map[num++] = ALLOCNO_OBJECT (a);\n+    {\n+      ira_allocno_object_iterator oi;\n+      ira_object_t obj;\n+\n+      FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n+\tira_object_id_map[num++] = obj;\n+    }\n   qsort (ira_object_id_map, num, sizeof (ira_object_t),\n-\t allocno_range_compare_func);\n+\t object_range_compare_func);\n   for (i = 0; i < num; i++)\n     {\n       ira_object_t obj = ira_object_id_map[i];\n@@ -2361,7 +2455,9 @@ setup_min_max_conflict_allocno_ids (void)\n   int cover_class;\n   int i, j, min, max, start, finish, first_not_finished, filled_area_start;\n   int *live_range_min, *last_lived;\n+  int word0_min, word0_max;\n   ira_allocno_t a;\n+  ira_allocno_iterator ai;\n \n   live_range_min = (int *) ira_allocate (sizeof (int) * ira_objects_num);\n   cover_class = -1;\n@@ -2388,10 +2484,10 @@ setup_min_max_conflict_allocno_ids (void)\n \t  /* If we skip an allocno, the allocno with smaller ids will\n \t     be also skipped because of the secondary sorting the\n \t     range finishes (see function\n-\t     allocno_range_compare_func).  */\n+\t     object_range_compare_func).  */\n \t  while (first_not_finished < i\n \t\t && start > OBJECT_MAX (ira_object_id_map\n-\t\t\t\t\t [first_not_finished]))\n+\t\t\t\t\t[first_not_finished]))\n \t    first_not_finished++;\n \t  min = first_not_finished;\n \t}\n@@ -2442,6 +2538,38 @@ setup_min_max_conflict_allocno_ids (void)\n     }\n   ira_free (last_lived);\n   ira_free (live_range_min);\n+\n+  /* For allocnos with more than one object, we may later record extra conflicts in\n+     subobject 0 that we cannot really know about here.\n+     For now, simply widen the min/max range of these subobjects.  */\n+\n+  word0_min = INT_MAX;\n+  word0_max = INT_MIN;\n+\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n+      ira_object_t obj0;\n+      if (n < 2)\n+\tcontinue;\n+      obj0 = ALLOCNO_OBJECT (a, 0);\n+      if (OBJECT_CONFLICT_ID (obj0) < word0_min)\n+\tword0_min = OBJECT_CONFLICT_ID (obj0);\n+      if (OBJECT_CONFLICT_ID (obj0) > word0_max)\n+\tword0_max = OBJECT_CONFLICT_ID (obj0);\n+    }\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n+      ira_object_t obj0;\n+      if (n < 2)\n+\tcontinue;\n+      obj0 = ALLOCNO_OBJECT (a, 0);\n+      if (OBJECT_MIN (obj0) > word0_min)\n+\tOBJECT_MIN (obj0) = word0_min;\n+      if (OBJECT_MAX (obj0) < word0_max)\n+\tOBJECT_MAX (obj0) = word0_max;\n+    }\n }\n \n \f\n@@ -2529,6 +2657,7 @@ copy_info_to_removed_store_destinations (int regno)\n       if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))])\n \t/* This allocno will be removed.  */\n \tcontinue;\n+\n       /* Caps will be removed.  */\n       ira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n       for (parent = ALLOCNO_LOOP_TREE_NODE (a)->parent;\n@@ -2541,8 +2670,10 @@ copy_info_to_removed_store_destinations (int regno)\n \t  break;\n       if (parent == NULL || parent_a == NULL)\n \tcontinue;\n+\n       copy_allocno_live_ranges (a, parent_a);\n       merge_hard_reg_conflicts (a, parent_a, true);\n+\n       ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n       ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n@@ -2582,14 +2713,16 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   new_pseudos_p = merged_p = false;\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      ira_allocno_object_iterator oi;\n+      ira_object_t obj;\n       if (ALLOCNO_CAP_MEMBER (a) != NULL)\n \t/* Caps are not in the regno allocno maps and they are never\n \t   will be transformed into allocnos existing after IR\n \t   flattening.  */\n \tcontinue;\n-      COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t OBJECT_CONFLICT_HARD_REGS (obj));\n+      FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n+\tCOPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t   OBJECT_CONFLICT_HARD_REGS (obj));\n #ifdef STACK_REGS\n       ALLOCNO_TOTAL_NO_STACK_REG_P (a) = ALLOCNO_NO_STACK_REG_P (a);\n #endif\n@@ -2674,13 +2807,17 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n       /* Rebuild conflicts.  */\n       FOR_EACH_ALLOCNO (a, ai)\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t  ira_allocno_object_iterator oi;\n+\t  ira_object_t obj;\n \t  if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))]\n \t      || ALLOCNO_CAP_MEMBER (a) != NULL)\n \t    continue;\n-\t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n-\t    ira_assert (r->object == obj);\n-\t  clear_conflicts (obj);\n+\t  FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n+\t    {\n+\t      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+\t\tira_assert (r->object == obj);\n+\t      clear_conflicts (obj);\n+\t    }\n \t}\n       objects_live = sparseset_alloc (ira_objects_num);\n       for (i = 0; i < ira_max_point; i++)\n@@ -2692,14 +2829,14 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t      if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))]\n \t\t  || ALLOCNO_CAP_MEMBER (a) != NULL)\n \t\tcontinue;\n+\n \t      cover_class = ALLOCNO_COVER_CLASS (a);\n \t      sparseset_set_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n \t      EXECUTE_IF_SET_IN_SPARSESET (objects_live, n)\n \t\t{\n \t\t  ira_object_t live_obj = ira_object_id_map[n];\n \t\t  ira_allocno_t live_a = OBJECT_ALLOCNO (live_obj);\n \t\t  enum reg_class live_cover = ALLOCNO_COVER_CLASS (live_a);\n-\n \t\t  if (ira_reg_classes_intersect_p[cover_class][live_cover]\n \t\t      /* Don't set up conflict for the allocno with itself.  */\n \t\t      && live_a != a)\n@@ -2931,40 +3068,39 @@ ira_build (bool loops_p)\n \t allocno crossing calls.  */\n       FOR_EACH_ALLOCNO (a, ai)\n \tif (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t  {\n-\t    ira_object_t obj = ALLOCNO_OBJECT (a);\n-\t    IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t      call_used_reg_set);\n-\t    IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t      call_used_reg_set);\n-\t  }\n+\t  ior_hard_reg_conflicts (a, &call_used_reg_set);\n     }\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_copies (ira_dump_file);\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     {\n-      int n, nr;\n+      int n, nr, nr_big;\n       ira_allocno_t a;\n       live_range_t r;\n       ira_allocno_iterator ai;\n \n       n = 0;\n+      nr = 0;\n+      nr_big = 0;\n       FOR_EACH_ALLOCNO (a, ai)\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n-\t  n += OBJECT_NUM_CONFLICTS (obj);\n+\t  int j, nobj = ALLOCNO_NUM_OBJECTS (a);\n+\t  if (nobj > 1)\n+\t    nr_big++;\n+\t  for (j = 0; j < nobj; j++)\n+\t    {\n+\t      ira_object_t obj = ALLOCNO_OBJECT (a, j);\n+\t      n += OBJECT_NUM_CONFLICTS (obj);\n+\t      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+\t\tnr++;\n+\t    }\n \t}\n-      nr = 0;\n-      FOR_EACH_ALLOCNO (a, ai)\n-\tfor (r = OBJECT_LIVE_RANGES (ALLOCNO_OBJECT (a)); r != NULL;\n-\t     r = r->next)\n-\t  nr++;\n       fprintf (ira_dump_file, \"  regions=%d, blocks=%d, points=%d\\n\",\n \t       VEC_length (loop_p, ira_loops.larray), n_basic_blocks,\n \t       ira_max_point);\n       fprintf (ira_dump_file,\n-\t       \"    allocnos=%d, copies=%d, conflicts=%d, ranges=%d\\n\",\n-\t       ira_allocnos_num, ira_copies_num, n, nr);\n+\t       \"    allocnos=%d (big %d), copies=%d, conflicts=%d, ranges=%d\\n\",\n+\t       ira_allocnos_num, nr_big, ira_copies_num, n, nr);\n     }\n   return loops_p;\n }"}, {"sha": "6aefdd1ae136ea681c9082475c3842adbaa6c5ff", "filename": "gcc/ira-color.c", "status": "modified", "additions": 320, "deletions": 195, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -94,16 +94,29 @@ static VEC(ira_allocno_t,heap) *removed_splay_allocno_vec;\n static bool\n allocnos_have_intersected_live_ranges_p (ira_allocno_t a1, ira_allocno_t a2)\n {\n-  ira_object_t obj1 = ALLOCNO_OBJECT (a1);\n-  ira_object_t obj2 = ALLOCNO_OBJECT (a2);\n+  int i, j;\n+  int n1 = ALLOCNO_NUM_OBJECTS (a1);\n+  int n2 = ALLOCNO_NUM_OBJECTS (a2);\n+\n   if (a1 == a2)\n     return false;\n   if (ALLOCNO_REG (a1) != NULL && ALLOCNO_REG (a2) != NULL\n       && (ORIGINAL_REGNO (ALLOCNO_REG (a1))\n \t  == ORIGINAL_REGNO (ALLOCNO_REG (a2))))\n     return false;\n-  return ira_live_ranges_intersect_p (OBJECT_LIVE_RANGES (obj1),\n-\t\t\t\t      OBJECT_LIVE_RANGES (obj2));\n+\n+  for (i = 0; i < n1; i++)\n+    {\n+      ira_object_t c1 = ALLOCNO_OBJECT (a1, i);\n+      for (j = 0; j < n2; j++)\n+\t{\n+\t  ira_object_t c2 = ALLOCNO_OBJECT (a2, j);\n+\t  if (ira_live_ranges_intersect_p (OBJECT_LIVE_RANGES (c1),\n+\t\t\t\t\t   OBJECT_LIVE_RANGES (c2)))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n }\n \n #ifdef ENABLE_IRA_CHECKING\n@@ -442,12 +455,11 @@ print_coalesced_allocno (ira_allocno_t allocno)\n static bool\n assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n {\n-  HARD_REG_SET conflicting_regs;\n-  int i, j, k, hard_regno, best_hard_regno, class_size;\n-  int cost, mem_cost, min_cost, full_cost, min_full_cost;\n+  HARD_REG_SET conflicting_regs[2];\n+  int i, j, hard_regno, nregs, best_hard_regno, class_size;\n+  int cost, mem_cost, min_cost, full_cost, min_full_cost, nwords;\n   int *a_costs;\n-  int *conflict_costs;\n-  enum reg_class cover_class, conflict_cover_class;\n+  enum reg_class cover_class;\n   enum machine_mode mode;\n   ira_allocno_t a;\n   static int costs[FIRST_PSEUDO_REGISTER], full_costs[FIRST_PSEUDO_REGISTER];\n@@ -459,11 +471,13 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   bool no_stack_reg_p;\n #endif\n \n+  nwords = ALLOCNO_NUM_OBJECTS (allocno);\n   ira_assert (! ALLOCNO_ASSIGNED_P (allocno));\n   cover_class = ALLOCNO_COVER_CLASS (allocno);\n   class_size = ira_class_hard_regs_num[cover_class];\n   mode = ALLOCNO_MODE (allocno);\n-  CLEAR_HARD_REG_SET (conflicting_regs);\n+  for (i = 0; i < nwords; i++)\n+    CLEAR_HARD_REG_SET (conflicting_regs[i]);\n   best_hard_regno = -1;\n   memset (full_costs, 0, sizeof (int) * class_size);\n   mem_cost = 0;\n@@ -478,13 +492,9 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      ira_object_t conflict_obj;\n-      ira_object_conflict_iterator oci;\n-\n+      int word;\n       mem_cost += ALLOCNO_UPDATED_MEMORY_COST (a);\n-      IOR_HARD_REG_SET (conflicting_regs,\n-\t\t\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+\n       ira_allocate_and_copy_costs (&ALLOCNO_UPDATED_HARD_REG_COSTS (a),\n \t\t\t\t   cover_class, ALLOCNO_HARD_REG_COSTS (a));\n       a_costs = ALLOCNO_UPDATED_HARD_REG_COSTS (a);\n@@ -503,44 +513,68 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t    costs[i] += cost;\n \t    full_costs[i] += cost;\n \t  }\n-      /* Take preferences of conflicting allocnos into account.  */\n-      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+      for (word = 0; word < nwords; word++)\n \t{\n-\t  ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_t obj = ALLOCNO_OBJECT (allocno, word);\n+\t  ira_object_conflict_iterator oci;\n \n-\t  /* Reload can give another class so we need to check all\n-\t     allocnos.  */\n-\t  if (retry_p || bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t\t       ALLOCNO_NUM (conflict_allocno)))\n+\t  IOR_HARD_REG_SET (conflicting_regs[word],\n+\t\t\t    OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+\t  /* Take preferences of conflicting allocnos into account.  */\n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t    {\n+\t      ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\t      enum reg_class conflict_cover_class;\n+\t      /* Reload can give another class so we need to check all\n+\t\t allocnos.  */\n+\t      if (!retry_p && !bitmap_bit_p (consideration_allocno_bitmap,\n+\t\t\t\t\t     ALLOCNO_NUM (conflict_allocno)))\n+\t\tcontinue;\n \t      conflict_cover_class = ALLOCNO_COVER_CLASS (conflict_allocno);\n \t      ira_assert (ira_reg_classes_intersect_p\n \t\t\t  [cover_class][conflict_cover_class]);\n-\t      if (allocno_coalesced_p)\n-\t\t{\n-\t\t  if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n-\t\t    continue;\n-\t\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\t  ALLOCNO_NUM (conflict_allocno));\n-\t\t}\n \t      if (ALLOCNO_ASSIGNED_P (conflict_allocno))\n \t\t{\n-\t\t  if ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno)) >= 0\n+\t\t  hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno);\n+\t\t  if (hard_regno >= 0\n \t\t      && ira_class_hard_reg_index[cover_class][hard_regno] >= 0)\n \t\t    {\n-\t\t      IOR_HARD_REG_SET\n-\t\t\t(conflicting_regs,\n-\t\t\t ira_reg_mode_hard_regset\n-\t\t\t [hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n+\t\t      enum machine_mode mode = ALLOCNO_MODE (conflict_allocno);\n+\t\t      int conflict_nregs = hard_regno_nregs[hard_regno][mode];\n+\t\t      int n_objects = ALLOCNO_NUM_OBJECTS (conflict_allocno);\n+\t\t      if (conflict_nregs == n_objects && conflict_nregs > 1)\n+\t\t\t{\n+\t\t\t  int num = OBJECT_SUBWORD (conflict_obj);\n+\t\t\t  if (WORDS_BIG_ENDIAN)\n+\t\t\t    SET_HARD_REG_BIT (conflicting_regs[word],\n+\t\t\t\t\t      hard_regno + n_objects - num - 1);\n+\t\t\t  else\n+\t\t\t    SET_HARD_REG_BIT (conflicting_regs[word],\n+\t\t\t\t\t      hard_regno + num);\n+\t\t\t}\n+\t\t      else\n+\t\t\tIOR_HARD_REG_SET (conflicting_regs[word],\n+\t\t\t\t\t  ira_reg_mode_hard_regset[hard_regno][mode]);\n \t\t      if (hard_reg_set_subset_p (reg_class_contents[cover_class],\n-\t\t\t\t\t\t conflicting_regs))\n+\t\t\t\t\t\t conflicting_regs[word]))\n \t\t\tgoto fail;\n \t\t    }\n \t\t}\n \t      else if (! ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n \t\t\t\t\t\t   (conflict_allocno)))\n \t\t{\n+\t\t  int k, *conflict_costs;\n+\n+\t\t  if (allocno_coalesced_p)\n+\t\t    {\n+\t\t      if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n+\t\t\t\t\tALLOCNO_NUM (conflict_allocno)))\n+\t\t\tcontinue;\n+\t\t      bitmap_set_bit (processed_coalesced_allocno_bitmap,\n+\t\t\t\t      ALLOCNO_NUM (conflict_allocno));\n+\t\t    }\n+\n \t\t  ira_allocate_and_copy_costs\n \t\t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno),\n \t\t     conflict_cover_class,\n@@ -581,21 +615,42 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n     }\n   update_conflict_hard_regno_costs (full_costs, cover_class, false);\n   min_cost = min_full_cost = INT_MAX;\n+\n   /* We don't care about giving callee saved registers to allocnos no\n      living through calls because call clobbered registers are\n      allocated first (it is usual practice to put them first in\n      REG_ALLOC_ORDER).  */\n   for (i = 0; i < class_size; i++)\n     {\n       hard_regno = ira_class_hard_regs[cover_class][i];\n+      nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (allocno)];\n #ifdef STACK_REGS\n       if (no_stack_reg_p\n \t  && FIRST_STACK_REG <= hard_regno && hard_regno <= LAST_STACK_REG)\n \tcontinue;\n #endif\n-      if (! ira_hard_reg_not_in_set_p (hard_regno, mode, conflicting_regs)\n-\t  || TEST_HARD_REG_BIT (prohibited_class_mode_regs[cover_class][mode],\n-\t\t\t\thard_regno))\n+      if (TEST_HARD_REG_BIT (prohibited_class_mode_regs[cover_class][mode],\n+\t\t\t     hard_regno))\n+\tcontinue;\n+      for (j = 0; j < nregs; j++)\n+\t{\n+\t  int k;\n+\t  int set_to_test_start = 0, set_to_test_end = nwords;\n+\t  if (nregs == nwords)\n+\t    {\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\tset_to_test_start = nwords - j - 1;\n+\t      else\n+\t\tset_to_test_start = j;\n+\t      set_to_test_end = set_to_test_start + 1;\n+\t    }\n+\t  for (k = set_to_test_start; k < set_to_test_end; k++)\n+\t    if (TEST_HARD_REG_BIT (conflicting_regs[k], hard_regno + j))\n+\t      break;\n+\t  if (k != set_to_test_end)\n+\t    break;\n+\t}\n+      if (j != nregs)\n \tcontinue;\n       cost = costs[i];\n       full_cost = full_costs[i];\n@@ -876,7 +931,7 @@ static splay_tree uncolorable_allocnos_splay_tree[N_REG_CLASSES];\n static void\n push_allocno_to_stack (ira_allocno_t allocno)\n {\n-  int left_conflicts_size, conflict_size, size;\n+  int size;\n   ira_allocno_t a;\n   enum reg_class cover_class;\n \n@@ -886,77 +941,90 @@ push_allocno_to_stack (ira_allocno_t allocno)\n   if (cover_class == NO_REGS)\n     return;\n   size = ira_reg_class_nregs[cover_class][ALLOCNO_MODE (allocno)];\n+  if (ALLOCNO_NUM_OBJECTS (allocno) > 1)\n+    {\n+      /* We will deal with the subwords individually.  */\n+      gcc_assert (size == ALLOCNO_NUM_OBJECTS (allocno));\n+      size = 1;\n+    }\n   if (allocno_coalesced_p)\n     bitmap_clear (processed_coalesced_allocno_bitmap);\n+\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      ira_object_t conflict_obj;\n-      ira_object_conflict_iterator oci;\n-\n-      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+      int i, n = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < n; i++)\n \t{\n-\t  ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  int conflict_size;\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_conflict_iterator oci;\n \n-\t  conflict_allocno = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n-\t  if (bitmap_bit_p (coloring_allocno_bitmap,\n-\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t    {\n+\t      ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\t      int left_conflicts_size;\n+\n+\t      conflict_allocno = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n+\t      if (!bitmap_bit_p (coloring_allocno_bitmap,\n+\t\t\t\t ALLOCNO_NUM (conflict_allocno)))\n+\t\tcontinue;\n+\n \t      ira_assert (cover_class\n \t\t\t  == ALLOCNO_COVER_CLASS (conflict_allocno));\n \t      if (allocno_coalesced_p)\n \t\t{\n+\t\t  conflict_obj = ALLOCNO_OBJECT (conflict_allocno,\n+\t\t\t\t\t\t OBJECT_SUBWORD (conflict_obj));\n \t\t  if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n+\t\t\t\t    OBJECT_CONFLICT_ID (conflict_obj)))\n \t\t    continue;\n \t\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\t  ALLOCNO_NUM (conflict_allocno));\n+\t\t\t\t  OBJECT_CONFLICT_ID (conflict_obj));\n \t\t}\n-\t      if (ALLOCNO_IN_GRAPH_P (conflict_allocno)\n-\t\t  && ! ALLOCNO_ASSIGNED_P (conflict_allocno))\n+\n+\t      if (!ALLOCNO_IN_GRAPH_P (conflict_allocno)\n+\t\t  || ALLOCNO_ASSIGNED_P (conflict_allocno))\n+\t\tcontinue;\n+\n+\t      left_conflicts_size = ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno);\n+\t      conflict_size\n+\t\t= (ira_reg_class_nregs\n+\t\t   [cover_class][ALLOCNO_MODE (conflict_allocno)]);\n+\t      ira_assert (left_conflicts_size >= size);\n+\t      if (left_conflicts_size + conflict_size\n+\t\t  <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n+\t\t{\n+\t\t  ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno) -= size;\n+\t\t  continue;\n+\t\t}\n+\t      left_conflicts_size -= size;\n+\t      if (uncolorable_allocnos_splay_tree[cover_class] != NULL\n+\t\t  && !ALLOCNO_SPLAY_REMOVED_P (conflict_allocno)\n+\t\t  && USE_SPLAY_P (cover_class))\n \t\t{\n-\t\t  left_conflicts_size\n-\t\t    = ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno);\n-\t\t  conflict_size\n-\t\t    = (ira_reg_class_nregs\n-\t\t       [cover_class][ALLOCNO_MODE (conflict_allocno)]);\n \t\t  ira_assert\n-\t\t    (ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno) >= size);\n-\t\t  if (left_conflicts_size + conflict_size\n-\t\t      <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n-\t\t    {\n-\t\t      ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno) -= size;\n-\t\t      continue;\n-\t\t    }\n-\t\t  left_conflicts_size\n-\t\t    = ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno) - size;\n-\t\t  if (uncolorable_allocnos_splay_tree[cover_class] != NULL\n-\t\t      && !ALLOCNO_SPLAY_REMOVED_P (conflict_allocno)\n-\t\t      && USE_SPLAY_P (cover_class))\n-\t\t    {\n-\t\t      ira_assert\n-\t\t      (splay_tree_lookup\n-\t\t       (uncolorable_allocnos_splay_tree[cover_class],\n-\t\t\t(splay_tree_key) conflict_allocno) != NULL);\n-\t\t      splay_tree_remove\n-\t\t\t(uncolorable_allocnos_splay_tree[cover_class],\n-\t\t\t (splay_tree_key) conflict_allocno);\n-\t\t      ALLOCNO_SPLAY_REMOVED_P (conflict_allocno) = true;\n-\t\t      VEC_safe_push (ira_allocno_t, heap,\n-\t\t\t\t     removed_splay_allocno_vec,\n-\t\t\t\t     conflict_allocno);\n-\t\t    }\n-\t\t  ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno)\n-\t\t    = left_conflicts_size;\n-\t\t  if (left_conflicts_size + conflict_size\n-\t\t      <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n-\t\t    {\n-\t\t      delete_allocno_from_bucket\n-\t\t\t(conflict_allocno, &uncolorable_allocno_bucket);\n-\t\t      add_allocno_to_ordered_bucket\n-\t\t\t(conflict_allocno, &colorable_allocno_bucket);\n-\t\t    }\n+\t\t    (splay_tree_lookup\n+\t\t     (uncolorable_allocnos_splay_tree[cover_class],\n+\t\t      (splay_tree_key) conflict_allocno) != NULL);\n+\t\t  splay_tree_remove\n+\t\t    (uncolorable_allocnos_splay_tree[cover_class],\n+\t\t     (splay_tree_key) conflict_allocno);\n+\t\t  ALLOCNO_SPLAY_REMOVED_P (conflict_allocno) = true;\n+\t\t  VEC_safe_push (ira_allocno_t, heap,\n+\t\t\t\t removed_splay_allocno_vec,\n+\t\t\t\t conflict_allocno);\n+\t\t}\n+\t      ALLOCNO_LEFT_CONFLICTS_SIZE (conflict_allocno)\n+\t\t= left_conflicts_size;\n+\t      if (left_conflicts_size + conflict_size\n+\t\t  <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n+\t\t{\n+\t\t  delete_allocno_from_bucket\n+\t\t    (conflict_allocno, &uncolorable_allocno_bucket);\n+\t\t  add_allocno_to_ordered_bucket\n+\t\t    (conflict_allocno, &colorable_allocno_bucket);\n \t\t}\n \t    }\n \t}\n@@ -1370,14 +1438,35 @@ pop_allocnos_from_stack (void)\n     }\n }\n \n+/* Loop over all coalesced allocnos of ALLOCNO and their subobjects, collecting\n+   total hard register conflicts in PSET (which the caller must initialize).  */\n+static void\n+all_conflicting_hard_regs_coalesced (ira_allocno_t allocno, HARD_REG_SET *pset)\n+{\n+  ira_allocno_t a;\n+\n+  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n+       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n+    {\n+      int i;\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  IOR_HARD_REG_SET (*pset, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+\t}\n+      if (a == allocno)\n+\tbreak;\n+    }\n+}\n+\n /* Set up number of available hard registers for ALLOCNO.  */\n static void\n setup_allocno_available_regs_num (ira_allocno_t allocno)\n {\n   int i, n, hard_regs_num, hard_regno;\n   enum machine_mode mode;\n   enum reg_class cover_class;\n-  ira_allocno_t a;\n   HARD_REG_SET temp_set;\n \n   cover_class = ALLOCNO_COVER_CLASS (allocno);\n@@ -1387,14 +1476,8 @@ setup_allocno_available_regs_num (ira_allocno_t allocno)\n   CLEAR_HARD_REG_SET (temp_set);\n   ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) == allocno);\n   hard_regs_num = ira_class_hard_regs_num[cover_class];\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      IOR_HARD_REG_SET (temp_set, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-      if (a == allocno)\n-\tbreak;\n-    }\n+  all_conflicting_hard_regs_coalesced (allocno, &temp_set);\n+\n   mode = ALLOCNO_MODE (allocno);\n   for (n = 0, i = hard_regs_num - 1; i >= 0; i--)\n     {\n@@ -1423,16 +1506,11 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n   hard_regs_num = ira_class_hard_regs_num[cover_class];\n   CLEAR_HARD_REG_SET (temp_set);\n   ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) == allocno);\n-  for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n-       a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-    {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      IOR_HARD_REG_SET (temp_set, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-      if (a == allocno)\n-\tbreak;\n-    }\n+  all_conflicting_hard_regs_coalesced (allocno, &temp_set);\n+\n   AND_HARD_REG_SET (temp_set, reg_class_contents[cover_class]);\n   AND_COMPL_HARD_REG_SET (temp_set, ira_no_alloc_regs);\n+\n   conflict_allocnos_size = 0;\n   if (! hard_reg_set_empty_p (temp_set))\n     for (i = 0; i < (int) hard_regs_num; i++)\n@@ -1453,19 +1531,23 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n     for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n \t a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n       {\n-\tira_object_t obj = ALLOCNO_OBJECT (a);\n-\tira_object_t conflict_obj;\n-\tira_object_conflict_iterator oci;\n-\n-\tFOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\tint n = ALLOCNO_NUM_OBJECTS (a);\n+\tfor (i = 0; i < n; i++)\n \t  {\n-\t    ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\t    ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t    ira_object_t conflict_obj;\n+\t    ira_object_conflict_iterator oci;\n \n-\t    conflict_allocno\n-\t      = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n-\t    if (bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t      ALLOCNO_NUM (conflict_allocno)))\n+\t    FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t      {\n+\t\tira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n+\n+\t\tconflict_allocno\n+\t\t  = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n+\t\tif (!bitmap_bit_p (consideration_allocno_bitmap,\n+\t\t\t\t   ALLOCNO_NUM (conflict_allocno)))\n+\t\t  continue;\n+\n \t\tira_assert (cover_class\n \t\t\t    == ALLOCNO_COVER_CLASS (conflict_allocno));\n \t\tif (allocno_coalesced_p)\n@@ -1476,6 +1558,7 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n \t\t    bitmap_set_bit (processed_coalesced_allocno_bitmap,\n \t\t\t\t    ALLOCNO_NUM (conflict_allocno));\n \t\t  }\n+\n \t\tif (! ALLOCNO_ASSIGNED_P (conflict_allocno))\n \t\t  conflict_allocnos_size\n \t\t    += (ira_reg_class_nregs\n@@ -1485,7 +1568,7 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n \t\t  {\n \t\t    int last = (hard_regno\n \t\t\t\t+ hard_regno_nregs\n-\t\t\t        [hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n+\t\t\t\t[hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n \n \t\t    while (hard_regno < last)\n \t\t      {\n@@ -1568,25 +1651,30 @@ merge_allocnos (ira_allocno_t a1, ira_allocno_t a2)\n   ALLOCNO_NEXT_COALESCED_ALLOCNO (last) = next;\n }\n \n-/* Return TRUE if there are conflicting allocnos from two sets of\n-   coalesced allocnos given correspondingly by allocnos A1 and A2.  If\n-   RELOAD_P is TRUE, we use live ranges to find conflicts because\n+/* Given two sets of coalesced sets of allocnos, A1 and A2, this\n+   function determines if any conflicts exist between the two sets.\n+   If RELOAD_P is TRUE, we use live ranges to find conflicts because\n    conflicts are represented only for allocnos of the same cover class\n    and during the reload pass we coalesce allocnos for sharing stack\n    memory slots.  */\n static bool\n coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n \t\t\t      bool reload_p)\n {\n-  ira_allocno_t a;\n+  ira_allocno_t a, conflict_allocno;\n \n+  /* When testing for conflicts, it is sufficient to examine only the\n+     subobjects of order 0, due to the canonicalization of conflicts\n+     we do in record_object_conflict.  */\n+\n+  bitmap_clear (processed_coalesced_allocno_bitmap);\n   if (allocno_coalesced_p)\n     {\n-      bitmap_clear (processed_coalesced_allocno_bitmap);\n       for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n \t   a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n \t{\n-\t  bitmap_set_bit (processed_coalesced_allocno_bitmap, ALLOCNO_NUM (a));\n+\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n+\t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (a, 0)));\n \t  if (a == a1)\n \t    break;\n \t}\n@@ -1596,7 +1684,6 @@ coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n     {\n       if (reload_p)\n \t{\n-\t  ira_allocno_t conflict_allocno;\n \t  for (conflict_allocno = ALLOCNO_NEXT_COALESCED_ALLOCNO (a1);;\n \t       conflict_allocno\n \t\t = ALLOCNO_NEXT_COALESCED_ALLOCNO (conflict_allocno))\n@@ -1610,20 +1697,17 @@ coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n \t}\n       else\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t  ira_object_t a_obj = ALLOCNO_OBJECT (a, 0);\n \t  ira_object_t conflict_obj;\n \t  ira_object_conflict_iterator oci;\n-\n-\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n-\t    {\n-\t      ira_allocno_t conflict_allocno = OBJECT_ALLOCNO (conflict_obj);\n-\t      if (conflict_allocno == a1\n-\t\t  || (allocno_coalesced_p\n-\t\t      && bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t       ALLOCNO_NUM (conflict_allocno))))\n-\t\treturn true;\n-\t    }\n+\t  FOR_EACH_OBJECT_CONFLICT (a_obj, conflict_obj, oci)\n+\t    if (conflict_obj == ALLOCNO_OBJECT (a1, 0)\n+\t\t|| (allocno_coalesced_p\n+\t\t    && bitmap_bit_p (processed_coalesced_allocno_bitmap,\n+\t\t\t\t     OBJECT_CONFLICT_ID (conflict_obj))))\n+\t      return true;\n \t}\n+\n       if (a == a2)\n \tbreak;\n     }\n@@ -1760,6 +1844,8 @@ setup_allocno_priorities (ira_allocno_t *consideration_allocnos, int n)\n     {\n       a = consideration_allocnos[i];\n       length = ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n+      if (ALLOCNO_NUM_OBJECTS (a) > 1)\n+\tlength /= ALLOCNO_NUM_OBJECTS (a);\n       if (length <= 0)\n \tlength = 1;\n       allocno_priorities[ALLOCNO_NUM (a)]\n@@ -1969,9 +2055,8 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n   EXECUTE_IF_SET_IN_BITMAP (consideration_allocno_bitmap, 0, j, bi)\n     {\n       a = ira_allocnos[j];\n-      if (! ALLOCNO_ASSIGNED_P (a))\n-\tcontinue;\n-      bitmap_clear_bit (coloring_allocno_bitmap, ALLOCNO_NUM (a));\n+      if (ALLOCNO_ASSIGNED_P (a))\n+\tbitmap_clear_bit (coloring_allocno_bitmap, ALLOCNO_NUM (a));\n     }\n   /* Color all mentioned allocnos including transparent ones.  */\n   color_allocnos ();\n@@ -2322,9 +2407,7 @@ ira_reassign_conflict_allocnos (int start_regno)\n   allocnos_to_color_num = 0;\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      ira_object_t conflict_obj;\n-      ira_object_conflict_iterator oci;\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n \n       if (! ALLOCNO_ASSIGNED_P (a)\n \t  && ! bitmap_bit_p (allocnos_to_color, ALLOCNO_NUM (a)))\n@@ -2343,15 +2426,21 @@ ira_reassign_conflict_allocnos (int start_regno)\n       if (ALLOCNO_REGNO (a) < start_regno\n \t  || (cover_class = ALLOCNO_COVER_CLASS (a)) == NO_REGS)\n \tcontinue;\n-      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+      for (i = 0; i < n; i++)\n \t{\n-\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n-\t  ira_assert (ira_reg_classes_intersect_p\n-\t\t      [cover_class][ALLOCNO_COVER_CLASS (conflict_a)]);\n-\t  if (bitmap_bit_p (allocnos_to_color, ALLOCNO_NUM (conflict_a)))\n-\t    continue;\n-\t  bitmap_set_bit (allocnos_to_color, ALLOCNO_NUM (conflict_a));\n-\t  sorted_allocnos[allocnos_to_color_num++] = conflict_a;\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_conflict_iterator oci;\n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t    {\n+\t      ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t      ira_assert (ira_reg_classes_intersect_p\n+\t\t\t  [cover_class][ALLOCNO_COVER_CLASS (conflict_a)]);\n+\t      if (bitmap_bit_p (allocnos_to_color, ALLOCNO_NUM (conflict_a)))\n+\t\tcontinue;\n+\t      bitmap_set_bit (allocnos_to_color, ALLOCNO_NUM (conflict_a));\n+\t      sorted_allocnos[allocnos_to_color_num++] = conflict_a;\n+\t    }\n \t}\n     }\n   ira_free_bitmap (allocnos_to_color);\n@@ -2539,10 +2628,15 @@ slot_coalesced_allocno_live_ranges_intersect_p (ira_allocno_t allocno, int n)\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      if (ira_live_ranges_intersect_p\n-\t  (slot_coalesced_allocnos_live_ranges[n], OBJECT_LIVE_RANGES (obj)))\n-\treturn true;\n+      int i;\n+      int nr = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < nr; i++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  if (ira_live_ranges_intersect_p (slot_coalesced_allocnos_live_ranges[n],\n+\t\t\t\t\t   OBJECT_LIVE_RANGES (obj)))\n+\t    return true;\n+\t}\n       if (a == allocno)\n \tbreak;\n     }\n@@ -2554,19 +2648,23 @@ slot_coalesced_allocno_live_ranges_intersect_p (ira_allocno_t allocno, int n)\n static void\n setup_slot_coalesced_allocno_live_ranges (ira_allocno_t allocno)\n {\n-  int n;\n+  int i, n;\n   ira_allocno_t a;\n   live_range_t r;\n \n   n = ALLOCNO_TEMP (allocno);\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      r = ira_copy_live_range_list (OBJECT_LIVE_RANGES (obj));\n-      slot_coalesced_allocnos_live_ranges[n]\n-\t= ira_merge_live_ranges\n-\t  (slot_coalesced_allocnos_live_ranges[n], r);\n+      int nr = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < nr; i++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  r = ira_copy_live_range_list (OBJECT_LIVE_RANGES (obj));\n+\t  slot_coalesced_allocnos_live_ranges[n]\n+\t    = ira_merge_live_ranges\n+\t    (slot_coalesced_allocnos_live_ranges[n], r);\n+\t}\n       if (a == allocno)\n \tbreak;\n     }\n@@ -2823,13 +2921,19 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n   int hard_regno;\n   enum reg_class cover_class;\n   int regno = ALLOCNO_REGNO (a);\n-  HARD_REG_SET saved;\n-  ira_object_t obj = ALLOCNO_OBJECT (a);\n+  HARD_REG_SET saved[2];\n+  int i, n;\n \n-  COPY_HARD_REG_SET (saved, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), forbidden_regs);\n-  if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-    IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), call_used_reg_set);\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  for (i = 0; i < n; i++)\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      COPY_HARD_REG_SET (saved[i], OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), forbidden_regs);\n+      if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+\tIOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t  call_used_reg_set);\n+    }\n   ALLOCNO_ASSIGNED_P (a) = false;\n   cover_class = ALLOCNO_COVER_CLASS (a);\n   update_curr_costs (a);\n@@ -2868,7 +2972,11 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n     }\n   else if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"\\n\");\n-  COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), saved);\n+  for (i = 0; i < n; i++)\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), saved[i]);\n+    }\n   return reg_renumber[regno] >= 0;\n }\n \n@@ -2916,25 +3024,31 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n \n   for (i = 0, n = num; i < n; i++)\n     {\n-      ira_object_t obj, conflict_obj;\n-      ira_object_conflict_iterator oci;\n+      int nr, j;\n       int regno = spilled_pseudo_regs[i];\n       bitmap_set_bit (temp, regno);\n \n       a = ira_regno_allocno_map[regno];\n-      obj = ALLOCNO_OBJECT (a);\n-      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+      nr = ALLOCNO_NUM_OBJECTS (a);\n+      for (j = 0; j < nr; j++)\n \t{\n-\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n-\t  if (ALLOCNO_HARD_REGNO (conflict_a) < 0\n-\t      && ! ALLOCNO_DONT_REASSIGN_P (conflict_a)\n-\t      && ! bitmap_bit_p (temp, ALLOCNO_REGNO (conflict_a)))\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, j);\n+\t  ira_object_conflict_iterator oci;\n+\n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t    {\n-\t      spilled_pseudo_regs[num++] = ALLOCNO_REGNO (conflict_a);\n-\t      bitmap_set_bit (temp, ALLOCNO_REGNO (conflict_a));\n-\t      /* ?!? This seems wrong.  */\n-\t      bitmap_set_bit (consideration_allocno_bitmap,\n-\t\t\t      ALLOCNO_NUM (conflict_a));\n+\t      ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t      if (ALLOCNO_HARD_REGNO (conflict_a) < 0\n+\t\t  && ! ALLOCNO_DONT_REASSIGN_P (conflict_a)\n+\t\t  && ! bitmap_bit_p (temp, ALLOCNO_REGNO (conflict_a)))\n+\t\t{\n+\t\t  spilled_pseudo_regs[num++] = ALLOCNO_REGNO (conflict_a);\n+\t\t  bitmap_set_bit (temp, ALLOCNO_REGNO (conflict_a));\n+\t\t  /* ?!? This seems wrong.  */\n+\t\t  bitmap_set_bit (consideration_allocno_bitmap,\n+\t\t\t\t  ALLOCNO_NUM (conflict_a));\n+\t\t}\n \t    }\n \t}\n     }\n@@ -3147,7 +3261,7 @@ calculate_spill_cost (int *regnos, rtx in, rtx out, rtx insn,\n       hard_regno = reg_renumber[regno];\n       ira_assert (hard_regno >= 0);\n       a = ira_regno_allocno_map[regno];\n-      length += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n+      length += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a) / ALLOCNO_NUM_OBJECTS (a);\n       cost += ALLOCNO_MEMORY_COST (a) - ALLOCNO_COVER_CLASS_COST (a);\n       nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (a)];\n       for (j = 0; j < nregs; j++)\n@@ -3301,13 +3415,20 @@ fast_allocation (void)\n \t allocno_priority_compare_func);\n   for (i = 0; i < num; i++)\n     {\n-      ira_object_t obj;\n+      int nr, l;\n+\n       a = sorted_allocnos[i];\n-      obj = ALLOCNO_OBJECT (a);\n-      COPY_HARD_REG_SET (conflict_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n-      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n-\tfor (j =  r->start; j <= r->finish; j++)\n-\t  IOR_HARD_REG_SET (conflict_hard_regs, used_hard_regs[j]);\n+      nr = ALLOCNO_NUM_OBJECTS (a);\n+      CLEAR_HARD_REG_SET (conflict_hard_regs);\n+      for (l = 0; l < nr; l++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, l);\n+\t  IOR_HARD_REG_SET (conflict_hard_regs,\n+\t\t\t    OBJECT_CONFLICT_HARD_REGS (obj));\n+\t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+\t    for (j = r->start; j <= r->finish; j++)\n+\t      IOR_HARD_REG_SET (conflict_hard_regs, used_hard_regs[j]);\n+\t}\n       cover_class = ALLOCNO_COVER_CLASS (a);\n       ALLOCNO_ASSIGNED_P (a) = true;\n       ALLOCNO_HARD_REGNO (a) = -1;\n@@ -3332,10 +3453,14 @@ fast_allocation (void)\n \t\t  (prohibited_class_mode_regs[cover_class][mode], hard_regno)))\n \t    continue;\n \t  ALLOCNO_HARD_REGNO (a) = hard_regno;\n-\t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n-\t    for (k = r->start; k <= r->finish; k++)\n-\t      IOR_HARD_REG_SET (used_hard_regs[k],\n-\t\t\t\tira_reg_mode_hard_regset[hard_regno][mode]);\n+\t  for (l = 0; l < nr; l++)\n+\t    {\n+\t      ira_object_t obj = ALLOCNO_OBJECT (a, l);\n+\t      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+\t\tfor (k = r->start; k <= r->finish; k++)\n+\t\t  IOR_HARD_REG_SET (used_hard_regs[k],\n+\t\t\t\t    ira_reg_mode_hard_regset[hard_regno][mode]);\n+\t    }\n \t  break;\n \t}\n     }"}, {"sha": "0ce1bbc0a8f6137efb037d06963c7a1d9fe7f1b7", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 195, "deletions": 130, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -48,18 +48,48 @@ along with GCC; see the file COPYING3.  If not see\n    allocno's conflict (can't go in the same hardware register).\n \n    Some arrays will be used as conflict bit vector of the\n-   corresponding allocnos see function build_allocno_conflicts.  */\n+   corresponding allocnos see function build_object_conflicts.  */\n static IRA_INT_TYPE **conflicts;\n \n /* Macro to test a conflict of C1 and C2 in `conflicts'.  */\n-#define OBJECTS_CONFLICT_P(C1, C2)\t\t\t\t\\\n+#define OBJECTS_CONFLICT_P(C1, C2)\t\t\t\t\t\\\n   (OBJECT_MIN (C1) <= OBJECT_CONFLICT_ID (C2)\t\t\t\t\\\n    && OBJECT_CONFLICT_ID (C2) <= OBJECT_MAX (C1)\t\t\t\\\n    && TEST_MINMAX_SET_BIT (conflicts[OBJECT_CONFLICT_ID (C1)],\t\t\\\n \t\t\t   OBJECT_CONFLICT_ID (C2),\t\t\t\\\n \t\t\t   OBJECT_MIN (C1), OBJECT_MAX (C1)))\n \n \f\n+/* Record a conflict between objects OBJ1 and OBJ2.  If necessary,\n+   canonicalize the conflict by recording it for lower-order subobjects\n+   of the corresponding allocnos. */\n+static void\n+record_object_conflict (ira_object_t obj1, ira_object_t obj2)\n+{\n+  ira_allocno_t a1 = OBJECT_ALLOCNO (obj1);\n+  ira_allocno_t a2 = OBJECT_ALLOCNO (obj2);\n+  int w1 = OBJECT_SUBWORD (obj1);\n+  int w2 = OBJECT_SUBWORD (obj2);\n+  int id1, id2;\n+\n+  /* Canonicalize the conflict.  If two identically-numbered words\n+     conflict, always record this as a conflict between words 0.  That\n+     is the only information we need, and it is easier to test for if\n+     it is collected in each allocno's lowest-order object.  */\n+  if (w1 == w2 && w1 > 0)\n+    {\n+      obj1 = ALLOCNO_OBJECT (a1, 0);\n+      obj2 = ALLOCNO_OBJECT (a2, 0);\n+    }\n+  id1 = OBJECT_CONFLICT_ID (obj1);\n+  id2 = OBJECT_CONFLICT_ID (obj2);\n+\n+  SET_MINMAX_SET_BIT (conflicts[id1], id2, OBJECT_MIN (obj1),\n+\t\t      OBJECT_MAX (obj1));\n+  SET_MINMAX_SET_BIT (conflicts[id2], id1, OBJECT_MIN (obj2),\n+\t\t      OBJECT_MAX (obj2));\n+}\n+\n /* Build allocno conflict table by processing allocno live ranges.\n    Return true if the table was built.  The table is not built if it\n    is too big.  */\n@@ -74,51 +104,53 @@ build_conflict_bit_table (void)\n   ira_allocno_t allocno;\n   ira_allocno_iterator ai;\n   sparseset objects_live;\n+  ira_object_t obj;\n+  ira_allocno_object_iterator aoi;\n \n   allocated_words_num = 0;\n   FOR_EACH_ALLOCNO (allocno, ai)\n-    {\n-      ira_object_t obj = ALLOCNO_OBJECT (allocno);\n-      if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n+    FOR_EACH_ALLOCNO_OBJECT (allocno, obj, aoi)\n+      {\n+\tif (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n \t  continue;\n-      conflict_bit_vec_words_num\n-\t= ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n-\t   / IRA_INT_BITS);\n-      allocated_words_num += conflict_bit_vec_words_num;\n-      if ((unsigned long long) allocated_words_num * sizeof (IRA_INT_TYPE)\n-\t  > (unsigned long long) IRA_MAX_CONFLICT_TABLE_SIZE * 1024 * 1024)\n-\t{\n-\t  if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n-\t    fprintf\n-\t      (ira_dump_file,\n-\t       \"+++Conflict table will be too big(>%dMB) -- don't use it\\n\",\n-\t       IRA_MAX_CONFLICT_TABLE_SIZE);\n-\t  return false;\n-\t}\n-    }\n+\tconflict_bit_vec_words_num\n+\t  = ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n+\t     / IRA_INT_BITS);\n+\tallocated_words_num += conflict_bit_vec_words_num;\n+\tif ((unsigned long long) allocated_words_num * sizeof (IRA_INT_TYPE)\n+\t    > (unsigned long long) IRA_MAX_CONFLICT_TABLE_SIZE * 1024 * 1024)\n+\t  {\n+\t    if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n+\t      fprintf\n+\t\t(ira_dump_file,\n+\t\t \"+++Conflict table will be too big(>%dMB) -- don't use it\\n\",\n+\t\t IRA_MAX_CONFLICT_TABLE_SIZE);\n+\t    return false;\n+\t  }\n+      }\n \n   conflicts = (IRA_INT_TYPE **) ira_allocate (sizeof (IRA_INT_TYPE *)\n \t\t\t\t\t      * ira_objects_num);\n   allocated_words_num = 0;\n   FOR_EACH_ALLOCNO (allocno, ai)\n-    {\n-      ira_object_t obj = ALLOCNO_OBJECT (allocno);\n-      int id = OBJECT_CONFLICT_ID (obj);\n-      if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n-\t{\n-\t  conflicts[id] = NULL;\n-\t  continue;\n-\t}\n-      conflict_bit_vec_words_num\n-\t= ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n-\t   / IRA_INT_BITS);\n-      allocated_words_num += conflict_bit_vec_words_num;\n-      conflicts[id]\n-\t= (IRA_INT_TYPE *) ira_allocate (sizeof (IRA_INT_TYPE)\n-\t\t\t\t\t * conflict_bit_vec_words_num);\n-      memset (conflicts[id], 0,\n-\t      sizeof (IRA_INT_TYPE) * conflict_bit_vec_words_num);\n-    }\n+    FOR_EACH_ALLOCNO_OBJECT (allocno, obj, aoi)\n+      {\n+\tint id = OBJECT_CONFLICT_ID (obj);\n+\tif (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n+\t  {\n+\t    conflicts[id] = NULL;\n+\t    continue;\n+\t  }\n+\tconflict_bit_vec_words_num\n+\t  = ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n+\t     / IRA_INT_BITS);\n+\tallocated_words_num += conflict_bit_vec_words_num;\n+\tconflicts[id]\n+\t  = (IRA_INT_TYPE *) ira_allocate (sizeof (IRA_INT_TYPE)\n+\t\t\t\t\t   * conflict_bit_vec_words_num);\n+\tmemset (conflicts[id], 0,\n+\t\tsizeof (IRA_INT_TYPE) * conflict_bit_vec_words_num);\n+      }\n \n   object_set_words = (ira_objects_num + IRA_INT_BITS - 1) / IRA_INT_BITS;\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n@@ -137,33 +169,27 @@ build_conflict_bit_table (void)\n \t  ira_allocno_t allocno = OBJECT_ALLOCNO (obj);\n \t  int id = OBJECT_CONFLICT_ID (obj);\n \n+\t  gcc_assert (id < ira_objects_num);\n+\n \t  cover_class = ALLOCNO_COVER_CLASS (allocno);\n \t  sparseset_set_bit (objects_live, id);\n \t  EXECUTE_IF_SET_IN_SPARSESET (objects_live, j)\n \t    {\n-\t      ira_object_t live_cr = ira_object_id_map[j];\n-\t      ira_allocno_t live_a = OBJECT_ALLOCNO (live_cr);\n+\t      ira_object_t live_obj = ira_object_id_map[j];\n+\t      ira_allocno_t live_a = OBJECT_ALLOCNO (live_obj);\n \t      enum reg_class live_cover_class = ALLOCNO_COVER_CLASS (live_a);\n \n \t      if (ira_reg_classes_intersect_p[cover_class][live_cover_class]\n \t\t  /* Don't set up conflict for the allocno with itself.  */\n-\t\t  && id != (int) j)\n+\t\t  && live_a != allocno)\n \t\t{\n-\t\t  SET_MINMAX_SET_BIT (conflicts[id], j,\n-\t\t\t\t      OBJECT_MIN (obj),\n-\t\t\t\t      OBJECT_MAX (obj));\n-\t\t  SET_MINMAX_SET_BIT (conflicts[j], id,\n-\t\t\t\t      OBJECT_MIN (live_cr),\n-\t\t\t\t      OBJECT_MAX (live_cr));\n+\t\t  record_object_conflict (obj, live_obj);\n \t\t}\n \t    }\n \t}\n \n       for (r = ira_finish_point_ranges[i]; r != NULL; r = r->finish_next)\n-\t{\n-\t  ira_object_t obj = r->object;\n-\t  sparseset_clear_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n-\t}\n+\tsparseset_clear_bit (objects_live, OBJECT_CONFLICT_ID (r->object));\n     }\n   sparseset_free (objects_live);\n   return true;\n@@ -173,10 +199,13 @@ build_conflict_bit_table (void)\n    register due to conflicts.  */\n \n static bool\n-allocnos_conflict_p (ira_allocno_t a1, ira_allocno_t a2)\n+allocnos_conflict_for_copy_p (ira_allocno_t a1, ira_allocno_t a2)\n {\n-  ira_object_t obj1 = ALLOCNO_OBJECT (a1);\n-  ira_object_t obj2 = ALLOCNO_OBJECT (a2);\n+  /* Due to the fact that we canonicalize conflicts (see\n+     record_object_conflict), we only need to test for conflicts of\n+     the lowest order words.  */\n+  ira_object_t obj1 = ALLOCNO_OBJECT (a1, 0);\n+  ira_object_t obj2 = ALLOCNO_OBJECT (a2, 0);\n   return OBJECTS_CONFLICT_P (obj1, obj2);\n }\n \n@@ -387,7 +416,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n     {\n       ira_allocno_t a1 = ira_curr_regno_allocno_map[REGNO (reg1)];\n       ira_allocno_t a2 = ira_curr_regno_allocno_map[REGNO (reg2)];\n-      if (!allocnos_conflict_p (a1, a2) && offset1 == offset2)\n+      if (!allocnos_conflict_for_copy_p (a1, a2) && offset1 == offset2)\n \t{\n \t  cp = ira_add_allocno_copy (a1, a2, freq, constraint_p, insn,\n \t\t\t\t     ira_curr_loop_tree_node);\n@@ -560,7 +589,7 @@ propagate_copies (void)\n       parent_a1 = ira_parent_or_cap_allocno (a1);\n       parent_a2 = ira_parent_or_cap_allocno (a2);\n       ira_assert (parent_a1 != NULL && parent_a2 != NULL);\n-      if (! allocnos_conflict_p (parent_a1, parent_a2))\n+      if (! allocnos_conflict_for_copy_p (parent_a1, parent_a2))\n \tira_add_allocno_copy (parent_a1, parent_a2, cp->freq,\n \t\t\t      cp->constraint_p, cp->insn, cp->loop_tree_node);\n     }\n@@ -570,23 +599,20 @@ propagate_copies (void)\n static ira_object_t *collected_conflict_objects;\n \n /* Build conflict vectors or bit conflict vectors (whatever is more\n-   profitable) for allocno A from the conflict table and propagate the\n-   conflicts to upper level allocno.  */\n+   profitable) for object OBJ from the conflict table.  */\n static void\n-build_allocno_conflicts (ira_allocno_t a)\n+build_object_conflicts (ira_object_t obj)\n {\n   int i, px, parent_num;\n-  int conflict_bit_vec_words_num;\n   ira_allocno_t parent_a, another_parent_a;\n-  ira_object_t *vec;\n-  IRA_INT_TYPE *allocno_conflicts;\n-  ira_object_t obj, parent_obj;\n+  ira_object_t parent_obj;\n+  ira_allocno_t a = OBJECT_ALLOCNO (obj);\n+  IRA_INT_TYPE *object_conflicts;\n   minmax_set_iterator asi;\n \n-  obj = ALLOCNO_OBJECT (a);\n-  allocno_conflicts = conflicts[OBJECT_CONFLICT_ID (obj)];\n+  object_conflicts = conflicts[OBJECT_CONFLICT_ID (obj)];\n   px = 0;\n-  FOR_EACH_BIT_IN_MINMAX_SET (allocno_conflicts,\n+  FOR_EACH_BIT_IN_MINMAX_SET (object_conflicts,\n \t\t\t      OBJECT_MIN (obj), OBJECT_MAX (obj), i, asi)\n     {\n       ira_object_t another_obj = ira_object_id_map[i];\n@@ -597,6 +623,7 @@ build_allocno_conflicts (ira_allocno_t a)\n     }\n   if (ira_conflict_vector_profitable_p (obj, px))\n     {\n+      ira_object_t *vec;\n       ira_allocate_conflict_vec (obj, px);\n       vec = OBJECT_CONFLICT_VEC (obj);\n       memcpy (vec, collected_conflict_objects, sizeof (ira_object_t) * px);\n@@ -605,7 +632,8 @@ build_allocno_conflicts (ira_allocno_t a)\n     }\n   else\n     {\n-      OBJECT_CONFLICT_ARRAY (obj) = allocno_conflicts;\n+      int conflict_bit_vec_words_num;\n+      OBJECT_CONFLICT_ARRAY (obj) = object_conflicts;\n       if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n \tconflict_bit_vec_words_num = 0;\n       else\n@@ -615,28 +643,35 @@ build_allocno_conflicts (ira_allocno_t a)\n       OBJECT_CONFLICT_ARRAY_SIZE (obj)\n \t= conflict_bit_vec_words_num * sizeof (IRA_INT_TYPE);\n     }\n+\n   parent_a = ira_parent_or_cap_allocno (a);\n   if (parent_a == NULL)\n     return;\n   ira_assert (ALLOCNO_COVER_CLASS (a) == ALLOCNO_COVER_CLASS (parent_a));\n-  parent_obj = ALLOCNO_OBJECT (parent_a);\n+  ira_assert (ALLOCNO_NUM_OBJECTS (a) == ALLOCNO_NUM_OBJECTS (parent_a));\n+  parent_obj = ALLOCNO_OBJECT (parent_a, OBJECT_SUBWORD (obj));\n   parent_num = OBJECT_CONFLICT_ID (parent_obj);\n-  FOR_EACH_BIT_IN_MINMAX_SET (allocno_conflicts,\n+  FOR_EACH_BIT_IN_MINMAX_SET (object_conflicts,\n \t\t\t      OBJECT_MIN (obj), OBJECT_MAX (obj), i, asi)\n     {\n       ira_object_t another_obj = ira_object_id_map[i];\n       ira_allocno_t another_a = OBJECT_ALLOCNO (another_obj);\n+      int another_word = OBJECT_SUBWORD (another_obj);\n \n       ira_assert (ira_reg_classes_intersect_p\n \t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n+\n       another_parent_a = ira_parent_or_cap_allocno (another_a);\n       if (another_parent_a == NULL)\n \tcontinue;\n       ira_assert (ALLOCNO_NUM (another_parent_a) >= 0);\n       ira_assert (ALLOCNO_COVER_CLASS (another_a)\n \t\t  == ALLOCNO_COVER_CLASS (another_parent_a));\n+      ira_assert (ALLOCNO_NUM_OBJECTS (another_a)\n+\t\t  == ALLOCNO_NUM_OBJECTS (another_parent_a));\n       SET_MINMAX_SET_BIT (conflicts[parent_num],\n-\t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (another_parent_a)),\n+\t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (another_parent_a,\n+\t\t\t\t\t\t     another_word)),\n \t\t\t  OBJECT_MIN (parent_obj),\n \t\t\t  OBJECT_MAX (parent_obj));\n     }\n@@ -658,9 +693,18 @@ build_conflicts (void)\n \t a != NULL;\n \t a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n       {\n-\tbuild_allocno_conflicts (a);\n-\tfor (cap = ALLOCNO_CAP (a); cap != NULL; cap = ALLOCNO_CAP (cap))\n-\t  build_allocno_conflicts (cap);\n+\tint j, nregs = ALLOCNO_NUM_OBJECTS (a);\n+\tfor (j = 0; j < nregs; j++)\n+\t  {\n+\t    ira_object_t obj = ALLOCNO_OBJECT (a, j);\n+\t    build_object_conflicts (obj);\n+\t    for (cap = ALLOCNO_CAP (a); cap != NULL; cap = ALLOCNO_CAP (cap))\n+\t      {\n+\t\tira_object_t cap_obj = ALLOCNO_OBJECT (cap, j);\n+\t\tgcc_assert (ALLOCNO_NUM_OBJECTS (cap) == ALLOCNO_NUM_OBJECTS (a));\n+\t\tbuild_object_conflicts (cap_obj);\n+\t      }\n+\t  }\n       }\n   ira_free (collected_conflict_objects);\n }\n@@ -700,9 +744,8 @@ static void\n print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n {\n   HARD_REG_SET conflicting_hard_regs;\n-  ira_object_t obj, conflict_obj;\n-  ira_object_conflict_iterator oci;\n   basic_block bb;\n+  int n, i;\n \n   if (reg_p)\n     fprintf (file, \";; r%d\", ALLOCNO_REGNO (a));\n@@ -717,39 +760,52 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n     }\n \n   fputs (\" conflicts:\", file);\n-  obj = ALLOCNO_OBJECT (a);\n-  if (OBJECT_CONFLICT_ARRAY (obj) != NULL)\n-    FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n-      {\n-\tira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n-        if (reg_p)\n-          fprintf (file, \" r%d,\", ALLOCNO_REGNO (conflict_a));\n-        else\n-          {\n-\t    fprintf (file, \" a%d(r%d,\", ALLOCNO_NUM (conflict_a),\n-\t\t     ALLOCNO_REGNO (conflict_a));\n-\t    if ((bb = ALLOCNO_LOOP_TREE_NODE (conflict_a)->bb) != NULL)\n-\t      fprintf (file, \"b%d)\", bb->index);\n-\t    else\n-\t      fprintf (file, \"l%d)\",\n-\t\t       ALLOCNO_LOOP_TREE_NODE (conflict_a)->loop->num);\n-\t  }\n-      }\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  for (i = 0; i < n; i++)\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      ira_object_t conflict_obj;\n+      ira_object_conflict_iterator oci;\n+\n+      if (OBJECT_CONFLICT_ARRAY (obj) == NULL)\n+\tcontinue;\n+      if (n > 1)\n+\tfprintf (file, \"\\n;;   subobject %d:\", i);\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t{\n+\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t  if (reg_p)\n+\t    fprintf (file, \" r%d,\", ALLOCNO_REGNO (conflict_a));\n+\t  else\n+\t    {\n+\t      fprintf (file, \" a%d(r%d\", ALLOCNO_NUM (conflict_a),\n+\t\t       ALLOCNO_REGNO (conflict_a));\n+\t      if (ALLOCNO_NUM_OBJECTS (conflict_a) > 1)\n+\t\tfprintf (file, \",w%d\", OBJECT_SUBWORD (conflict_obj));\n+\t      if ((bb = ALLOCNO_LOOP_TREE_NODE (conflict_a)->bb) != NULL)\n+\t\tfprintf (file, \",b%d\", bb->index);\n+\t      else\n+\t\tfprintf (file, \",l%d\",\n+\t\t\t ALLOCNO_LOOP_TREE_NODE (conflict_a)->loop->num);\n+\t      putc (')', file);\n+\t    }\n+\t}\n+      COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+      AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n+      AND_HARD_REG_SET (conflicting_hard_regs,\n+\t\t\treg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n+      print_hard_reg_set (file, \"\\n;;     total conflict hard regs:\",\n+\t\t\t  conflicting_hard_regs);\n+\n+      COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n+      AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n+      AND_HARD_REG_SET (conflicting_hard_regs,\n+\t\t\treg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n+      print_hard_reg_set (file, \";;     conflict hard regs:\",\n+\t\t\t  conflicting_hard_regs);\n+      putc ('\\n', file);\n+    }\n \n-  COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-  AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n-  AND_HARD_REG_SET (conflicting_hard_regs,\n-\t\t    reg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n-  print_hard_reg_set (file, \"\\n;;     total conflict hard regs:\",\n-\t\t      conflicting_hard_regs);\n-\n-  COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n-  AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n-  AND_HARD_REG_SET (conflicting_hard_regs,\n-\t\t    reg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n-  print_hard_reg_set (file, \";;     conflict hard regs:\",\n-\t\t      conflicting_hard_regs);\n-  putc ('\\n', file);\n }\n \n /* Print information about allocno or only regno (if REG_P) conflicts\n@@ -799,7 +855,7 @@ ira_build_conflicts (void)\n \t    propagate_copies ();\n \n \t  /* Now we can free memory for the conflict table (see function\n-\t     build_allocno_conflicts for details).  */\n+\t     build_object_conflicts for details).  */\n \t  FOR_EACH_OBJECT (obj, oi)\n \t    {\n \t      if (OBJECT_CONFLICT_ARRAY (obj) != conflicts[OBJECT_CONFLICT_ID (obj)])\n@@ -819,29 +875,38 @@ ira_build_conflicts (void)\n     }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      reg_attrs *attrs;\n-      tree decl;\n-\n-      if ((! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t  /* For debugging purposes don't put user defined variables in\n-\t     callee-clobbered registers.  */\n-\t  || (optimize == 0\n-\t      && (attrs = REG_ATTRS (regno_reg_rtx [ALLOCNO_REGNO (a)])) != NULL\n-\t      && (decl = attrs->decl) != NULL\n-\t      && VAR_OR_FUNCTION_DECL_P (decl)\n-\t      && ! DECL_ARTIFICIAL (decl)))\n-\t{\n-\t  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), call_used_reg_set);\n-\t  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), call_used_reg_set);\n-\t}\n-      else if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+      int i, n = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < n; i++)\n \t{\n-\t  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t    no_caller_save_reg_set);\n-\t  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), temp_hard_reg_set);\n-\t  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), no_caller_save_reg_set);\n-\t  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), temp_hard_reg_set);\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  reg_attrs *attrs = REG_ATTRS (regno_reg_rtx [ALLOCNO_REGNO (a)]);\n+\t  tree decl;\n+\n+\t  if ((! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+\t      /* For debugging purposes don't put user defined variables in\n+\t\t callee-clobbered registers.  */\n+\t      || (optimize == 0\n+\t\t  && attrs != NULL\n+\t\t  && (decl = attrs->decl) != NULL\n+\t\t  && VAR_OR_FUNCTION_DECL_P (decl)\n+\t\t  && ! DECL_ARTIFICIAL (decl)))\n+\t    {\n+\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t\tcall_used_reg_set);\n+\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t\tcall_used_reg_set);\n+\t    }\n+\t  else if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+\t    {\n+\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t\tno_caller_save_reg_set);\n+\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t\ttemp_hard_reg_set);\n+\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t\tno_caller_save_reg_set);\n+\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t\ttemp_hard_reg_set);\n+\t    }\n \t}\n     }\n   if (optimize && ira_conflicts_p"}, {"sha": "c75974b4bc62e73c363f70c7a7a22aff3f89869c", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 81, "deletions": 55, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -715,8 +715,8 @@ modify_move_list (move_t list)\n \t\t&& ALLOCNO_HARD_REGNO\n \t\t   (hard_regno_last_set[hard_regno + i]->to) >= 0)\n \t      {\n+\t\tint n, j;\n \t\tira_allocno_t new_allocno;\n-\t\tira_object_t new_obj;\n \n \t\tset_move = hard_regno_last_set[hard_regno + i];\n \t\t/* It does not matter what loop_tree_node (of TO or\n@@ -729,19 +729,25 @@ modify_move_list (move_t list)\n \t\tALLOCNO_MODE (new_allocno) = ALLOCNO_MODE (set_move->to);\n \t\tira_set_allocno_cover_class\n \t\t  (new_allocno, ALLOCNO_COVER_CLASS (set_move->to));\n-\t\tira_create_allocno_object (new_allocno);\n+\t\tira_create_allocno_objects (new_allocno);\n \t\tALLOCNO_ASSIGNED_P (new_allocno) = true;\n \t\tALLOCNO_HARD_REGNO (new_allocno) = -1;\n \t\tALLOCNO_REG (new_allocno)\n \t\t  = create_new_reg (ALLOCNO_REG (set_move->to));\n \n-\t\tnew_obj = ALLOCNO_OBJECT (new_allocno);\n-\n \t\t/* Make it possibly conflicting with all earlier\n \t\t   created allocnos.  Cases where temporary allocnos\n \t\t   created to remove the cycles are quite rare.  */\n-\t\tOBJECT_MIN (new_obj) = 0;\n-\t\tOBJECT_MAX (new_obj) = ira_objects_num - 1;\n+\t\tn = ALLOCNO_NUM_OBJECTS (new_allocno);\n+\t\tgcc_assert (n == ALLOCNO_NUM_OBJECTS (set_move->to));\n+\t\tfor (j = 0; j < n; j++)\n+\t\t  {\n+\t\t    ira_object_t new_obj = ALLOCNO_OBJECT (new_allocno, j);\n+\n+\t\t    OBJECT_MIN (new_obj) = 0;\n+\t\t    OBJECT_MAX (new_obj) = ira_objects_num - 1;\n+\t\t  }\n+\n \t\tnew_move = create_move (set_move->to, new_allocno);\n \t\tset_move->to = new_allocno;\n \t\tVEC_safe_push (move_t, heap, move_vec, new_move);\n@@ -937,21 +943,26 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n     {\n       ira_allocno_t from = move->from;\n       ira_allocno_t to = move->to;\n-      ira_object_t from_obj = ALLOCNO_OBJECT (from);\n-      ira_object_t to_obj = ALLOCNO_OBJECT (to);\n-      if (OBJECT_CONFLICT_ARRAY (to_obj) == NULL)\n-\t{\n-\t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file, \"    Allocate conflicts for a%dr%d\\n\",\n-\t\t     ALLOCNO_NUM (to), REGNO (ALLOCNO_REG (to)));\n-\t  ira_allocate_object_conflicts (to_obj, n);\n-\t}\n+      int nr, i;\n+\n       bitmap_clear_bit (live_through, ALLOCNO_REGNO (from));\n       bitmap_clear_bit (live_through, ALLOCNO_REGNO (to));\n-      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (from_obj), hard_regs_live);\n-      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj), hard_regs_live);\n-      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj), hard_regs_live);\n-      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj), hard_regs_live);\n+\n+      nr = ALLOCNO_NUM_OBJECTS (to);\n+      for (i = 0; i < nr; i++)\n+\t{\n+\t  ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n+\t  if (OBJECT_CONFLICT_ARRAY (to_obj) == NULL)\n+\t    {\n+\t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n+\t\tfprintf (ira_dump_file, \"    Allocate conflicts for a%dr%d\\n\",\n+\t\t\t ALLOCNO_NUM (to), REGNO (ALLOCNO_REG (to)));\n+\t      ira_allocate_object_conflicts (to_obj, n);\n+\t    }\n+\t}\n+      ior_hard_reg_conflicts (from, &hard_regs_live);\n+      ior_hard_reg_conflicts (to, &hard_regs_live);\n+\n       update_costs (from, true, freq);\n       update_costs (to, false, freq);\n       cp = ira_add_allocno_copy (from, to, freq, false, move->insn, NULL);\n@@ -960,58 +971,73 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n \t\t cp->num, ALLOCNO_NUM (cp->first),\n \t\t REGNO (ALLOCNO_REG (cp->first)), ALLOCNO_NUM (cp->second),\n \t\t REGNO (ALLOCNO_REG (cp->second)));\n-      r = OBJECT_LIVE_RANGES (from_obj);\n-      if (r == NULL || r->finish >= 0)\n+\n+      nr = ALLOCNO_NUM_OBJECTS (from);\n+      for (i = 0; i < nr; i++)\n \t{\n-\t  OBJECT_LIVE_RANGES (from_obj)\n-\t    = ira_create_live_range (from_obj, start, ira_max_point, r);\n-\t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file,\n-\t\t     \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n-\t\t     start, ira_max_point, ALLOCNO_NUM (from),\n-\t\t     REGNO (ALLOCNO_REG (from)));\n+\t  ira_object_t from_obj = ALLOCNO_OBJECT (from, i);\n+\t  r = OBJECT_LIVE_RANGES (from_obj);\n+\t  if (r == NULL || r->finish >= 0)\n+\t    {\n+\t      ira_add_live_range_to_object (from_obj, start, ira_max_point);\n+\t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n+\t\tfprintf (ira_dump_file,\n+\t\t\t \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n+\t\t\t start, ira_max_point, ALLOCNO_NUM (from),\n+\t\t\t REGNO (ALLOCNO_REG (from)));\n+\t    }\n+\t  else\n+\t    {\n+\t      r->finish = ira_max_point;\n+\t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n+\t\tfprintf (ira_dump_file,\n+\t\t\t \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n+\t\t\t r->start, ira_max_point, ALLOCNO_NUM (from),\n+\t\t\t REGNO (ALLOCNO_REG (from)));\n+\t    }\n \t}\n-      else\n+      ira_max_point++;\n+      nr = ALLOCNO_NUM_OBJECTS (to);\n+      for (i = 0; i < nr; i++)\n \t{\n-\t  r->finish = ira_max_point;\n-\t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file,\n-\t\t     \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n-\t\t     r->start, ira_max_point, ALLOCNO_NUM (from),\n-\t\t     REGNO (ALLOCNO_REG (from)));\n+\t  ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n+\t  ira_add_live_range_to_object (to_obj, ira_max_point, -1);\n \t}\n       ira_max_point++;\n-      OBJECT_LIVE_RANGES (to_obj)\n-\t= ira_create_live_range (to_obj, ira_max_point, -1,\n-\t\t\t\t OBJECT_LIVE_RANGES (to_obj));\n-      ira_max_point++;\n     }\n   for (move = list; move != NULL; move = move->next)\n     {\n-      ira_object_t to_obj = ALLOCNO_OBJECT (move->to);\n-      r = OBJECT_LIVE_RANGES (to_obj);\n-      if (r->finish < 0)\n+      int nr, i;\n+      nr = ALLOCNO_NUM_OBJECTS (move->to);\n+      for (i = 0; i < nr; i++)\n \t{\n-\t  r->finish = ira_max_point - 1;\n-\t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file,\n-\t\t     \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n-\t\t     r->start, r->finish, ALLOCNO_NUM (move->to),\n-\t\t     REGNO (ALLOCNO_REG (move->to)));\n+\t  ira_object_t to_obj = ALLOCNO_OBJECT (move->to, i);\n+\t  r = OBJECT_LIVE_RANGES (to_obj);\n+\t  if (r->finish < 0)\n+\t    {\n+\t      r->finish = ira_max_point - 1;\n+\t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n+\t\tfprintf (ira_dump_file,\n+\t\t\t \"    Adding range [%d..%d] to allocno a%dr%d\\n\",\n+\t\t\t r->start, r->finish, ALLOCNO_NUM (move->to),\n+\t\t\t REGNO (ALLOCNO_REG (move->to)));\n+\t    }\n \t}\n     }\n   EXECUTE_IF_SET_IN_BITMAP (live_through, FIRST_PSEUDO_REGISTER, regno, bi)\n     {\n       ira_allocno_t to;\n-      ira_object_t obj;\n+      int nr, i;\n+\n       a = node->regno_allocno_map[regno];\n-      to = ALLOCNO_MEM_OPTIMIZED_DEST (a);\n-      if (to != NULL)\n+      if ((to = ALLOCNO_MEM_OPTIMIZED_DEST (a)) != NULL)\n \ta = to;\n-      obj = ALLOCNO_OBJECT (a);\n-      OBJECT_LIVE_RANGES (obj)\n-\t= ira_create_live_range (obj, start, ira_max_point - 1,\n-\t\t\t\t OBJECT_LIVE_RANGES (obj));\n+      nr = ALLOCNO_NUM_OBJECTS (a);\n+      for (i = 0; i < nr; i++)\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  ira_add_live_range_to_object (obj, start, ira_max_point - 1);\n+\t}\n       if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \tfprintf\n \t  (ira_dump_file,"}, {"sha": "d06ce4e57cb463f129265c26eddaa6b8c93c1f6e", "filename": "gcc/ira-int.h", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -192,7 +192,6 @@ extern ira_loop_tree_node_t ira_loop_nodes;\n #define IRA_LOOP_NODE(loop) IRA_LOOP_NODE_BY_INDEX ((loop)->num)\n \n \f\n-\n /* The structure describes program points where a given allocno lives.\n    To save memory we store allocno conflicts only for the same cover\n    class allocnos which is enough to assign hard registers.  To find\n@@ -201,7 +200,7 @@ extern ira_loop_tree_node_t ira_loop_nodes;\n    intersected, the allocnos are in conflict.  */\n struct live_range\n {\n-  /* Allocno whose live range is described by given structure.  */\n+  /* Object whose live range is described by given structure.  */\n   ira_object_t object;\n   /* Program point range.  */\n   int start, finish;\n@@ -233,33 +232,35 @@ struct ira_object\n   ira_allocno_t allocno;\n   /* Vector of accumulated conflicting conflict_redords with NULL end\n      marker (if OBJECT_CONFLICT_VEC_P is true) or conflict bit vector\n-     otherwise.  Only objects belonging to allocnos with the\n+     otherwise.  Only ira_objects belonging to allocnos with the\n      same cover class are in the vector or in the bit vector.  */\n   void *conflicts_array;\n   /* Pointer to structures describing at what program point the\n      object lives.  We always maintain the list in such way that *the\n      ranges in the list are not intersected and ordered by decreasing\n      their program points*.  */\n   live_range_t live_ranges;\n+  /* The subword within ALLOCNO which is represented by this object.\n+     Zero means the lowest-order subword (or the entire allocno in case\n+     it is not being tracked in subwords).  */\n+  int subword;\n   /* Allocated size of the conflicts array.  */\n   unsigned int conflicts_array_size;\n-  /* A unique number for every instance of this structure which is used\n+  /* A unique number for every instance of this structure, which is used\n      to represent it in conflict bit vectors.  */\n   int id;\n   /* Before building conflicts, MIN and MAX are initialized to\n      correspondingly minimal and maximal points of the accumulated\n-     allocno live ranges.  Afterwards, they hold the minimal and\n-     maximal ids of other objects that this one can conflict\n-     with.  */\n+     live ranges.  Afterwards, they hold the minimal and maximal ids\n+     of other ira_objects that this one can conflict with.  */\n   int min, max;\n   /* Initial and accumulated hard registers conflicting with this\n-     conflict record and as a consequences can not be assigned to the\n-     allocno.  All non-allocatable hard regs and hard regs of cover\n-     classes different from given allocno one are included in the\n-     sets.  */\n+     object and as a consequences can not be assigned to the allocno.\n+     All non-allocatable hard regs and hard regs of cover classes\n+     different from given allocno one are included in the sets.  */\n   HARD_REG_SET conflict_hard_regs, total_conflict_hard_regs;\n   /* Number of accumulated conflicts in the vector of conflicting\n-     conflict records.  */\n+     objects.  */\n   int num_accumulated_conflicts;\n   /* TRUE if conflicts are represented by a vector of pointers to\n      ira_object structures.  Otherwise, we use a bit vector indexed\n@@ -346,9 +347,13 @@ struct ira_allocno\n      list is chained by NEXT_COALESCED_ALLOCNO.  */\n   ira_allocno_t first_coalesced_allocno;\n   ira_allocno_t next_coalesced_allocno;\n-  /* Pointer to a structure describing conflict information about this\n-     allocno.  */\n-  ira_object_t object;\n+  /* The number of objects tracked in the following array.  */\n+  int num_objects;\n+  /* An array of structures describing conflict information and live\n+     ranges for each object associated with the allocno.  There may be\n+     more than one such object in cases where the allocno represents a\n+     multi-word register.  */\n+  ira_object_t objects[2];\n   /* Accumulated frequency of calls which given allocno\n      intersects.  */\n   int call_freq;\n@@ -483,9 +488,11 @@ struct ira_allocno\n #define ALLOCNO_TEMP(A) ((A)->temp)\n #define ALLOCNO_FIRST_COALESCED_ALLOCNO(A) ((A)->first_coalesced_allocno)\n #define ALLOCNO_NEXT_COALESCED_ALLOCNO(A) ((A)->next_coalesced_allocno)\n-#define ALLOCNO_OBJECT(A) ((A)->object)\n+#define ALLOCNO_OBJECT(A,N) ((A)->objects[N])\n+#define ALLOCNO_NUM_OBJECTS(A) ((A)->num_objects)\n \n #define OBJECT_ALLOCNO(C) ((C)->allocno)\n+#define OBJECT_SUBWORD(C) ((C)->subword)\n #define OBJECT_CONFLICT_ARRAY(C) ((C)->conflicts_array)\n #define OBJECT_CONFLICT_VEC(C) ((ira_object_t *)(C)->conflicts_array)\n #define OBJECT_CONFLICT_BITVEC(C) ((IRA_INT_TYPE *)(C)->conflicts_array)\n@@ -497,7 +504,7 @@ struct ira_allocno\n #define OBJECT_MIN(C) ((C)->min)\n #define OBJECT_MAX(C) ((C)->max)\n #define OBJECT_CONFLICT_ID(C) ((C)->id)\n-#define OBJECT_LIVE_RANGES(C) ((C)->live_ranges)\n+#define OBJECT_LIVE_RANGES(A) ((A)->live_ranges)\n \n /* Map regno -> allocnos with given regno (see comments for\n    allocno member `next_regno_allocno').  */\n@@ -593,6 +600,7 @@ extern int ira_move_loops_num, ira_additional_jumps_num;\n \n /* The type used as elements in the array, and the number of bits in\n    this type.  */\n+\n #define IRA_INT_BITS HOST_BITS_PER_WIDE_INT\n #define IRA_INT_TYPE HOST_WIDE_INT\n \n@@ -690,7 +698,7 @@ minmax_set_iter_init (minmax_set_iterator *i, IRA_INT_TYPE *vec, int min,\n   i->word = i->nel == 0 ? 0 : vec[0];\n }\n \n-/* Return TRUE if we have more elements to visit, in which case *N is\n+/* Return TRUE if we have more allocnos to visit, in which case *N is\n    set to the number of the element to be visited.  Otherwise, return\n    FALSE.  */\n static inline bool\n@@ -929,12 +937,14 @@ extern void ira_traverse_loop_tree (bool, ira_loop_tree_node_t,\n extern ira_allocno_t ira_parent_allocno (ira_allocno_t);\n extern ira_allocno_t ira_parent_or_cap_allocno (ira_allocno_t);\n extern ira_allocno_t ira_create_allocno (int, bool, ira_loop_tree_node_t);\n-extern void ira_create_allocno_object (ira_allocno_t);\n+extern void ira_create_allocno_objects (ira_allocno_t);\n extern void ira_set_allocno_cover_class (ira_allocno_t, enum reg_class);\n extern bool ira_conflict_vector_profitable_p (ira_object_t, int);\n extern void ira_allocate_conflict_vec (ira_object_t, int);\n extern void ira_allocate_object_conflicts (ira_object_t, int);\n+extern void ior_hard_reg_conflicts (ira_allocno_t, HARD_REG_SET *);\n extern void ira_print_expanded_allocno (ira_allocno_t);\n+extern void ira_add_live_range_to_object (ira_object_t, int, int);\n extern live_range_t ira_create_live_range (ira_object_t, int, int,\n \t\t\t\t\t   live_range_t);\n extern live_range_t ira_copy_live_range_list (live_range_t);\n@@ -1059,7 +1069,7 @@ ira_allocno_iter_cond (ira_allocno_iterator *i, ira_allocno_t *a)\n \f\n /* The iterator for all objects.  */\n typedef struct {\n-  /* The number of the current element in IRA_OBJECT_ID_MAP.  */\n+  /* The number of the current element in ira_object_id_map.  */\n   int n;\n } ira_object_iterator;\n \n@@ -1087,13 +1097,44 @@ ira_object_iter_cond (ira_object_iterator *i, ira_object_t *obj)\n   return false;\n }\n \n-/* Loop over all objects.  In each iteration, A is set to the next\n-   conflict.  ITER is an instance of ira_object_iterator used to iterate\n+/* Loop over all objects.  In each iteration, OBJ is set to the next\n+   object.  ITER is an instance of ira_object_iterator used to iterate\n    the objects.  */\n #define FOR_EACH_OBJECT(OBJ, ITER)\t\t\t\\\n   for (ira_object_iter_init (&(ITER));\t\t\t\\\n        ira_object_iter_cond (&(ITER), &(OBJ));)\n \f\n+/* The iterator for objects associated with an allocno.  */\n+typedef struct {\n+  /* The number of the element the allocno's object array.  */\n+  int n;\n+} ira_allocno_object_iterator;\n+\n+/* Initialize the iterator I.  */\n+static inline void\n+ira_allocno_object_iter_init (ira_allocno_object_iterator *i)\n+{\n+  i->n = 0;\n+}\n+\n+/* Return TRUE if we have more objects to visit in allocno A, in which\n+   case *O is set to the object to be visited.  Otherwise, return\n+   FALSE.  */\n+static inline bool\n+ira_allocno_object_iter_cond (ira_allocno_object_iterator *i, ira_allocno_t a,\n+\t\t\t      ira_object_t *o)\n+{\n+  *o = ALLOCNO_OBJECT (a, i->n);\n+  return i->n++ < ALLOCNO_NUM_OBJECTS (a);\n+}\n+\n+/* Loop over all objects associated with allocno A.  In each\n+   iteration, O is set to the next object.  ITER is an instance of\n+   ira_allocno_object_iterator used to iterate the conflicts.  */\n+#define FOR_EACH_ALLOCNO_OBJECT(A, O, ITER)\t\t\t\\\n+  for (ira_allocno_object_iter_init (&(ITER));\t\t\t\\\n+       ira_allocno_object_iter_cond (&(ITER), (A), &(O));)\n+\f\n \n /* The iterator for copies.  */\n typedef struct {\n@@ -1132,9 +1173,10 @@ ira_copy_iter_cond (ira_copy_iterator *i, ira_copy_t *cp)\n   for (ira_copy_iter_init (&(ITER));\t\t\t\\\n        ira_copy_iter_cond (&(ITER), &(C));)\n \f\n-/* The iterator for allocno conflicts.  */\n+/* The iterator for object conflicts.  */\n typedef struct {\n-  /* TRUE if the conflicts are represented by vector of objects.  */\n+\n+  /* TRUE if the conflicts are represented by vector of allocnos.  */\n   bool conflict_vec_p;\n \n   /* The conflict vector or conflict bit vector.  */"}, {"sha": "5b75f54e5d3b3d54a86c1f329f58825fd017ab72", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 238, "deletions": 106, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -68,8 +68,12 @@ static int curr_point;\n    classes.  */\n static int high_pressure_start_point[N_REG_CLASSES];\n \n-/* Allocnos live at current point in the scan.  */\n-static sparseset allocnos_live;\n+/* Objects live at current point in the scan.  */\n+static sparseset objects_live;\n+\n+/* A temporary bitmap used in functions that wish to avoid visiting an allocno\n+   multiple times.  */\n+static sparseset allocnos_processed;\n \n /* Set of hard regs (except eliminable ones) currently live.  */\n static HARD_REG_SET hard_regs_live;\n@@ -82,18 +86,17 @@ static int last_call_num;\n /* The number of last call at which given allocno was saved.  */\n static int *allocno_saved_at_call;\n \n-/* Record the birth of hard register REGNO, updating hard_regs_live\n-   and hard reg conflict information for living allocno.  */\n+/* Record the birth of hard register REGNO, updating hard_regs_live and\n+   hard reg conflict information for living allocnos.  */\n static void\n make_hard_regno_born (int regno)\n {\n   unsigned int i;\n \n   SET_HARD_REG_BIT (hard_regs_live, regno);\n-  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n+  EXECUTE_IF_SET_IN_SPARSESET (objects_live, i)\n     {\n-      ira_allocno_t allocno = ira_allocnos[i];\n-      ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+      ira_object_t obj = ira_object_id_map[i];\n       SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n       SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno);\n     }\n@@ -107,29 +110,29 @@ make_hard_regno_dead (int regno)\n   CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n }\n \n-/* Record the birth of allocno A, starting a new live range for\n-   it if necessary, and updating hard reg conflict information.  We also\n-   record it in allocnos_live.  */\n+/* Record the birth of object OBJ.  Set a bit for it in objects_live,\n+   start a new live range for it if necessary and update hard register\n+   conflicts.  */\n static void\n-make_allocno_born (ira_allocno_t a)\n+make_object_born (ira_object_t obj)\n {\n-  ira_object_t obj = ALLOCNO_OBJECT (a);\n-  live_range_t p = OBJECT_LIVE_RANGES (obj);\n+  live_range_t lr = OBJECT_LIVE_RANGES (obj);\n \n-  sparseset_set_bit (allocnos_live, ALLOCNO_NUM (a));\n+  sparseset_set_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n   IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), hard_regs_live);\n   IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), hard_regs_live);\n \n-  if (p == NULL\n-      || (p->finish != curr_point && p->finish + 1 != curr_point))\n-    OBJECT_LIVE_RANGES (obj)\n-      = ira_create_live_range (obj, curr_point, -1, p);\n+  if (lr == NULL\n+      || (lr->finish != curr_point && lr->finish + 1 != curr_point))\n+    ira_add_live_range_to_object (obj, curr_point, -1);\n }\n \n-/* Update ALLOCNO_EXCESS_PRESSURE_POINTS_NUM for allocno A.  */\n+/* Update ALLOCNO_EXCESS_PRESSURE_POINTS_NUM for the allocno\n+   associated with object OBJ.  */\n static void\n-update_allocno_pressure_excess_length (ira_allocno_t a)\n+update_allocno_pressure_excess_length (ira_object_t obj)\n {\n+  ira_allocno_t a = OBJECT_ALLOCNO (obj);\n   int start, i;\n   enum reg_class cover_class, cl;\n   live_range_t p;\n@@ -139,7 +142,6 @@ update_allocno_pressure_excess_length (ira_allocno_t a)\n        (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n        i++)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n       if (high_pressure_start_point[cl] < 0)\n \tcontinue;\n       p = OBJECT_LIVE_RANGES (obj);\n@@ -150,18 +152,18 @@ update_allocno_pressure_excess_length (ira_allocno_t a)\n     }\n }\n \n-/* Process the death of allocno A.  This finishes the current live\n-   range for it.  */\n+/* Process the death of object OBJ, which is associated with allocno\n+   A.  This finishes the current live range for it.  */\n static void\n-make_allocno_dead (ira_allocno_t a)\n+make_object_dead (ira_object_t obj)\n {\n-  ira_object_t obj = ALLOCNO_OBJECT (a);\n-  live_range_t p = OBJECT_LIVE_RANGES (obj);\n+  live_range_t lr;\n \n-  ira_assert (p != NULL);\n-  p->finish = curr_point;\n-  update_allocno_pressure_excess_length (a);\n-  sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n+  sparseset_clear_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n+  lr = OBJECT_LIVE_RANGES (obj);\n+  ira_assert (lr != NULL);\n+  lr->finish = curr_point;\n+  update_allocno_pressure_excess_length (obj);\n }\n \n /* The current register pressures for each cover class for the current\n@@ -216,8 +218,8 @@ dec_register_pressure (enum reg_class cover_class, int nregs)\n     }\n   if (set_p)\n     {\n-      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n-\tupdate_allocno_pressure_excess_length (ira_allocnos[j]);\n+      EXECUTE_IF_SET_IN_SPARSESET (objects_live, j)\n+\tupdate_allocno_pressure_excess_length (ira_object_id_map[j]);\n       for (i = 0;\n \t   (cl = ira_reg_class_super_classes[cover_class][i])\n \t     != LIM_REG_CLASSES;\n@@ -234,27 +236,75 @@ static void\n mark_pseudo_regno_live (int regno)\n {\n   ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  int i, n, nregs;\n   enum reg_class cl;\n-  int nregs;\n \n   if (a == NULL)\n     return;\n \n   /* Invalidate because it is referenced.  */\n   allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n \n-  if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+  if (n > 1)\n+    {\n+      /* We track every subobject separately.  */\n+      gcc_assert (nregs == n);\n+      nregs = 1;\n+    }\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      if (sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj)))\n+\tcontinue;\n+\n+      inc_register_pressure (cl, nregs);\n+      make_object_born (obj);\n+    }\n+}\n+\n+/* Like mark_pseudo_regno_live, but try to only mark one subword of\n+   the pseudo as live.  SUBWORD indicates which; a value of 0\n+   indicates the low part.  */\n+static void\n+mark_pseudo_regno_subword_live (int regno, int subword)\n+{\n+  ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  int n, nregs;\n+  enum reg_class cl;\n+  ira_object_t obj;\n+\n+  if (a == NULL)\n     return;\n \n+  /* Invalidate because it is referenced.  */\n+  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n+\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  if (n == 1)\n+    {\n+      mark_pseudo_regno_live (regno);\n+      return;\n+    }\n+\n   cl = ALLOCNO_COVER_CLASS (a);\n   nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+  gcc_assert (nregs == n);\n+  obj = ALLOCNO_OBJECT (a, subword);\n+\n+  if (sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj)))\n+    return;\n+\n   inc_register_pressure (cl, nregs);\n-  make_allocno_born (a);\n+  make_object_born (obj);\n }\n \n-/* Mark the hard register REG as live.  Store a 1 in hard_regs_live\n-   for this register, record how many consecutive hardware registers\n-   it actually needs.  */\n+/* Mark the register REG as live.  Store a 1 in hard_regs_live for\n+   this register, record how many consecutive hardware registers it\n+   actually needs.  */\n static void\n mark_hard_reg_live (rtx reg)\n {\n@@ -282,13 +332,22 @@ mark_hard_reg_live (rtx reg)\n static void\n mark_ref_live (df_ref ref)\n {\n-  rtx reg;\n+  rtx reg = DF_REF_REG (ref);\n+  rtx orig_reg = reg;\n \n-  reg = DF_REF_REG (ref);\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n+\n   if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    mark_pseudo_regno_live (REGNO (reg));\n+    {\n+      if (df_read_modify_subreg_p (orig_reg))\n+\t{\n+\t  mark_pseudo_regno_subword_live (REGNO (reg),\n+\t\t\t\t\t  subreg_lowpart_p (orig_reg) ? 0 : 1);\n+\t}\n+      else\n+\tmark_pseudo_regno_live (REGNO (reg));\n+    }\n   else\n     mark_hard_reg_live (reg);\n }\n@@ -299,27 +358,70 @@ static void\n mark_pseudo_regno_dead (int regno)\n {\n   ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  int n, i, nregs;\n   enum reg_class cl;\n-  int nregs;\n \n   if (a == NULL)\n     return;\n \n   /* Invalidate because it is referenced.  */\n   allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n \n-  if (! sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+  if (n > 1)\n+    {\n+      /* We track every subobject separately.  */\n+      gcc_assert (nregs == n);\n+      nregs = 1;\n+    }\n+  for (i = 0; i < n; i++)\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      if (!sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj)))\n+\tcontinue;\n+\n+      dec_register_pressure (cl, nregs);\n+      make_object_dead (obj);\n+    }\n+}\n+\n+/* Like mark_pseudo_regno_dead, but called when we know that only part of the\n+   register dies.  SUBWORD indicates which; a value of 0 indicates the low part.  */\n+static void\n+mark_pseudo_regno_subword_dead (int regno, int subword)\n+{\n+  ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  int n, nregs;\n+  enum reg_class cl;\n+  ira_object_t obj;\n+\n+  if (a == NULL)\n+    return;\n+\n+  /* Invalidate because it is referenced.  */\n+  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n+\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  if (n == 1)\n+    /* The allocno as a whole doesn't die in this case.  */\n     return;\n \n   cl = ALLOCNO_COVER_CLASS (a);\n   nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n-  dec_register_pressure (cl, nregs);\n+  gcc_assert (nregs == n);\n+\n+  obj = ALLOCNO_OBJECT (a, subword);\n+  if (!sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj)))\n+    return;\n \n-  make_allocno_dead (a);\n+  dec_register_pressure (cl, 1);\n+  make_object_dead (obj);\n }\n \n-/* Mark the hard register REG as dead.  Store a 0 in hard_regs_live\n-   for the register.  */\n+/* Mark the hard register REG as dead.  Store a 0 in hard_regs_live for the\n+   register.  */\n static void\n mark_hard_reg_dead (rtx reg)\n {\n@@ -347,17 +449,31 @@ mark_hard_reg_dead (rtx reg)\n static void\n mark_ref_dead (df_ref def)\n {\n-  rtx reg;\n+  rtx reg = DF_REF_REG (def);\n+  rtx orig_reg = reg;\n \n-  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n-      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n+  if (DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n     return;\n \n-  reg = DF_REF_REG (def);\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n+\n+  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n+      && (GET_CODE (orig_reg) != SUBREG\n+\t  || REGNO (reg) < FIRST_PSEUDO_REGISTER\n+\t  || !df_read_modify_subreg_p (orig_reg)))\n+    return;\n+\n   if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    mark_pseudo_regno_dead (REGNO (reg));\n+    {\n+      if (df_read_modify_subreg_p (orig_reg))\n+\t{\n+\t  mark_pseudo_regno_subword_dead (REGNO (reg),\n+\t\t\t\t\t  subreg_lowpart_p (orig_reg) ? 0 : 1);\n+\t}\n+      else\n+\tmark_pseudo_regno_dead (REGNO (reg));\n+    }\n   else\n     mark_hard_reg_dead (reg);\n }\n@@ -468,7 +584,7 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n \n       /* If there's any alternative that allows USE to match DEF, do not\n \t record a conflict.  If that causes us to create an invalid\n-\t instruction due to the earlyclobber, reload must fix it up.  */\t \n+\t instruction due to the earlyclobber, reload must fix it up.  */\n       for (alt1 = 0; alt1 < recog_data.n_alternatives; alt1++)\n \tif (recog_op_alt[use][alt1].matches == def\n \t    || (use < recog_data.n_operands - 1\n@@ -836,13 +952,12 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t    }\n \t}\n \n-      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, px)\n+      EXECUTE_IF_SET_IN_SPARSESET (objects_live, px)\n         {\n-\t  a = ira_allocnos[px];\n+\t  ira_object_t obj = ira_object_id_map[px];\n+\t  a = OBJECT_ALLOCNO (obj);\n \t  if (a != operand_a)\n \t    {\n-\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n-\n \t      /* We could increase costs of A instead of making it\n \t\t conflicting with the hard register.  But it works worse\n \t\t because it will be spilled in reload in anyway.  */\n@@ -897,7 +1012,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t}\n       curr_bb_node = loop_tree_node;\n       reg_live_out = DF_LR_OUT (bb);\n-      sparseset_clear (allocnos_live);\n+      sparseset_clear (objects_live);\n       REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n       AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n       AND_COMPL_HARD_REG_SET (hard_regs_live, ira_no_alloc_regs);\n@@ -1011,40 +1126,46 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  if (call_p)\n \t    {\n \t      last_call_num++;\n+\t      sparseset_clear (allocnos_processed);\n \t      /* The current set of live allocnos are live across the call.  */\n-\t      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n+\t      EXECUTE_IF_SET_IN_SPARSESET (objects_live, i)\n \t        {\n-\t\t  ira_allocno_t a = ira_allocnos[i];\n+\t\t  ira_object_t obj = ira_object_id_map[i];\n+\t\t  ira_allocno_t a = OBJECT_ALLOCNO (obj);\n+\t\t  int num = ALLOCNO_NUM (a);\n \n-\t\t  if (allocno_saved_at_call[i] != last_call_num)\n-\t\t    /* Here we are mimicking caller-save.c behaviour\n-\t\t       which does not save hard register at a call if\n-\t\t       it was saved on previous call in the same basic\n-\t\t       block and the hard register was not mentioned\n-\t\t       between the two calls.  */\n-\t\t    ALLOCNO_CALL_FREQ (a) += freq;\n-\t\t  /* Mark it as saved at the next call.  */\n-\t\t  allocno_saved_at_call[i] = last_call_num + 1;\n-\t\t  ALLOCNO_CALLS_CROSSED_NUM (a)++;\n \t\t  /* Don't allocate allocnos that cross setjmps or any\n \t\t     call, if this function receives a nonlocal\n \t\t     goto.  */\n \t\t  if (cfun->has_nonlocal_label\n \t\t      || find_reg_note (insn, REG_SETJMP,\n \t\t\t\t\tNULL_RTX) != NULL_RTX)\n \t\t    {\n-\t\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n \t\t      SET_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj));\n \t\t      SET_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n \t\t    }\n \t\t  if (can_throw_internal (insn))\n \t\t    {\n-\t\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n-\t\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\t\tcall_used_reg_set);\n \t\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n \t\t\t\t\tcall_used_reg_set);\n+\t\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t\t\tcall_used_reg_set);\n \t\t    }\n+\n+\t\t  if (sparseset_bit_p (allocnos_processed, num))\n+\t\t    continue;\n+\t\t  sparseset_set_bit (allocnos_processed, num);\n+\n+\t\t  if (allocno_saved_at_call[num] != last_call_num)\n+\t\t    /* Here we are mimicking caller-save.c behaviour\n+\t\t       which does not save hard register at a call if\n+\t\t       it was saved on previous call in the same basic\n+\t\t       block and the hard register was not mentioned\n+\t\t       between the two calls.  */\n+\t\t    ALLOCNO_CALL_FREQ (a) += freq;\n+\t\t  /* Mark it as saved at the next call.  */\n+\t\t  allocno_saved_at_call[num] = last_call_num + 1;\n+\t\t  ALLOCNO_CALLS_CROSSED_NUM (a)++;\n \t\t}\n \t    }\n \n@@ -1102,10 +1223,11 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n       if (bb_has_abnormal_pred (bb))\n \t{\n #ifdef STACK_REGS\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, px)\n+\t  EXECUTE_IF_SET_IN_SPARSESET (objects_live, px)\n \t    {\n-\t      ALLOCNO_NO_STACK_REG_P (ira_allocnos[px]) = true;\n-\t      ALLOCNO_TOTAL_NO_STACK_REG_P (ira_allocnos[px]) = true;\n+\t      ira_allocno_t a = OBJECT_ALLOCNO (ira_object_id_map[px]);\n+\t      ALLOCNO_NO_STACK_REG_P (a) = true;\n+\t      ALLOCNO_TOTAL_NO_STACK_REG_P (a) = true;\n \t    }\n \t  for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n \t    make_hard_regno_born (px);\n@@ -1119,8 +1241,8 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\tmake_hard_regno_born (px);\n \t}\n \n-      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\tmake_allocno_dead (ira_allocnos[i]);\n+      EXECUTE_IF_SET_IN_SPARSESET (objects_live, i)\n+\tmake_object_dead (ira_object_id_map[i]);\n \n       curr_point++;\n \n@@ -1144,31 +1266,24 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n static void\n create_start_finish_chains (void)\n {\n-  ira_allocno_t a;\n-  ira_allocno_iterator ai;\n+  ira_object_t obj;\n+  ira_object_iterator oi;\n   live_range_t r;\n \n   ira_start_point_ranges\n-    = (live_range_t *) ira_allocate (ira_max_point\n-\t\t\t\t\t     * sizeof (live_range_t));\n-  memset (ira_start_point_ranges, 0,\n-\t  ira_max_point * sizeof (live_range_t));\n+    = (live_range_t *) ira_allocate (ira_max_point * sizeof (live_range_t));\n+  memset (ira_start_point_ranges, 0, ira_max_point * sizeof (live_range_t));\n   ira_finish_point_ranges\n-    = (live_range_t *) ira_allocate (ira_max_point\n-\t\t\t\t\t     * sizeof (live_range_t));\n-  memset (ira_finish_point_ranges, 0,\n-\t  ira_max_point * sizeof (live_range_t));\n-  FOR_EACH_ALLOCNO (a, ai)\n-    {\n-      ira_object_t obj = ALLOCNO_OBJECT (a);\n-      for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n-\t{\n-\t  r->start_next = ira_start_point_ranges[r->start];\n-\t  ira_start_point_ranges[r->start] = r;\n-\t  r->finish_next = ira_finish_point_ranges[r->finish];\n+    = (live_range_t *) ira_allocate (ira_max_point * sizeof (live_range_t));\n+  memset (ira_finish_point_ranges, 0, ira_max_point * sizeof (live_range_t));\n+  FOR_EACH_OBJECT (obj, oi)\n+    for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+      {\n+\tr->start_next = ira_start_point_ranges[r->start];\n+\tira_start_point_ranges[r->start] = r;\n+\tr->finish_next = ira_finish_point_ranges[r->finish];\n  \t  ira_finish_point_ranges[r->finish] = r;\n-\t}\n-    }\n+      }\n }\n \n /* Rebuild IRA_START_POINT_RANGES and IRA_FINISH_POINT_RANGES after\n@@ -1202,7 +1317,7 @@ remove_some_program_points_and_update_live_ranges (void)\n       {\n \tira_assert (r->start <= r->finish);\n \tbitmap_set_bit (born_or_died, r->start);\n-\t  bitmap_set_bit (born_or_died, r->finish);\n+\tbitmap_set_bit (born_or_died, r->finish);\n       }\n \n   map = (int *) ira_allocate (sizeof (int) * ira_max_point);\n@@ -1223,6 +1338,7 @@ remove_some_program_points_and_update_live_ranges (void)\n \tr->start = map[r->start];\n \tr->finish = map[r->finish];\n       }\n+\n   ira_free (map);\n }\n \n@@ -1242,13 +1358,27 @@ ira_debug_live_range_list (live_range_t r)\n   ira_print_live_range_list (stderr, r);\n }\n \n+/* Print live ranges of object OBJ to file F.  */\n+static void\n+print_object_live_ranges (FILE *f, ira_object_t obj)\n+{\n+  ira_print_live_range_list (f, OBJECT_LIVE_RANGES (obj));\n+}\n+\n /* Print live ranges of allocno A to file F.  */\n static void\n print_allocno_live_ranges (FILE *f, ira_allocno_t a)\n {\n-  ira_object_t obj = ALLOCNO_OBJECT (a);\n-  fprintf (f, \" a%d(r%d):\", ALLOCNO_NUM (a), ALLOCNO_REGNO (a));\n-  ira_print_live_range_list (f, OBJECT_LIVE_RANGES (obj));\n+  int n = ALLOCNO_NUM_OBJECTS (a);\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      fprintf (f, \" a%d(r%d\", ALLOCNO_NUM (a), ALLOCNO_REGNO (a));\n+      if (n > 1)\n+\tfprintf (f, \" [%d]\", i);\n+      fprintf (f, \"):\");\n+      print_object_live_ranges (f, ALLOCNO_OBJECT (a, i));\n+    }\n }\n \n /* Print live ranges of allocno A to stderr.  */\n@@ -1277,12 +1407,13 @@ ira_debug_live_ranges (void)\n }\n \n /* The main entry function creates live ranges, set up\n-   CONFLICT_HARD_REGS and TOTAL_CONFLICT_HARD_REGS for allocnos, and\n+   CONFLICT_HARD_REGS and TOTAL_CONFLICT_HARD_REGS for objects, and\n    calculate register pressure info.  */\n void\n ira_create_allocno_live_ranges (void)\n {\n-  allocnos_live = sparseset_alloc (ira_allocnos_num);\n+  objects_live = sparseset_alloc (ira_objects_num);\n+  allocnos_processed = sparseset_alloc (ira_allocnos_num);\n   curr_point = 0;\n   last_call_num = 0;\n   allocno_saved_at_call\n@@ -1296,7 +1427,8 @@ ira_create_allocno_live_ranges (void)\n     print_live_ranges (ira_dump_file);\n   /* Clean up.  */\n   ira_free (allocno_saved_at_call);\n-  sparseset_free (allocnos_live);\n+  sparseset_free (objects_live);\n+  sparseset_free (allocnos_processed);\n }\n \n /* Compress allocno live ranges.  */"}, {"sha": "8aaaf0e8d4f95d13e3e058314066e72e8ef1b853", "filename": "gcc/ira.c", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab4f718b5c85c999dc3cdf1745bca627e3c69/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ac0ab4f718b5c85c999dc3cdf1745bca627e3c69", "patch": "@@ -1241,9 +1241,8 @@ setup_prohibited_mode_move_regs (void)\n static bool\n ira_bad_reload_regno_1 (int regno, rtx x)\n {\n-  int x_regno;\n+  int x_regno, n, i;\n   ira_allocno_t a;\n-  ira_object_t obj;\n   enum reg_class pref;\n \n   /* We only deal with pseudo regs.  */\n@@ -1263,10 +1262,13 @@ ira_bad_reload_regno_1 (int regno, rtx x)\n   /* If the pseudo conflicts with REGNO, then we consider REGNO a\n      poor choice for a reload regno.  */\n   a = ira_regno_allocno_map[x_regno];\n-  obj = ALLOCNO_OBJECT (a);\n-  if (TEST_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno))\n-    return true;\n-\n+  n = ALLOCNO_NUM_OBJECTS (a);\n+  for (i = 0; i < n; i++)\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+      if (TEST_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno))\n+\treturn true;\n+    }\n   return false;\n }\n \n@@ -1610,32 +1612,60 @@ static void\n check_allocation (void)\n {\n   ira_allocno_t a;\n-  int hard_regno, nregs;\n+  int hard_regno, nregs, conflict_nregs;\n   ira_allocno_iterator ai;\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      ira_object_t obj, conflict_obj;\n-      ira_object_conflict_iterator oci;\n+      int n = ALLOCNO_NUM_OBJECTS (a);\n+      int i;\n \n       if (ALLOCNO_CAP_MEMBER (a) != NULL\n \t  || (hard_regno = ALLOCNO_HARD_REGNO (a)) < 0)\n \tcontinue;\n       nregs = hard_regno_nregs[hard_regno][ALLOCNO_MODE (a)];\n-      obj = ALLOCNO_OBJECT (a);\n-      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+      if (n > 1)\n+\t{\n+\t  gcc_assert (n == nregs);\n+\t  nregs = 1;\n+\t}\n+      for (i = 0; i < n; i++)\n \t{\n-\t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n-\t  int conflict_hard_regno = ALLOCNO_HARD_REGNO (conflict_a);\n-\t  if (conflict_hard_regno >= 0)\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a, i);\n+\t  ira_object_t conflict_obj;\n+\t  ira_object_conflict_iterator oci;\n+\t  int this_regno = hard_regno;\n+\t  if (n > 1)\n \t    {\n-\t      int conflict_nregs\n-\t\t= (hard_regno_nregs\n-\t\t   [conflict_hard_regno][ALLOCNO_MODE (conflict_a)]);\n-\t      if ((conflict_hard_regno <= hard_regno\n-\t\t   && hard_regno < conflict_hard_regno + conflict_nregs)\n-\t\t  || (hard_regno <= conflict_hard_regno\n-\t\t      && conflict_hard_regno < hard_regno + nregs))\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\tthis_regno += n - i - 1;\n+\t      else\n+\t\tthis_regno += i;\n+\t    }\n+\t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\t    {\n+\t      ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\t      int conflict_hard_regno = ALLOCNO_HARD_REGNO (conflict_a);\n+\t      if (conflict_hard_regno < 0)\n+\t\tcontinue;\n+\t      if (ALLOCNO_NUM_OBJECTS (conflict_a) > 1)\n+\t\t{\n+\t\t  if (WORDS_BIG_ENDIAN)\n+\t\t    conflict_hard_regno += (ALLOCNO_NUM_OBJECTS (conflict_a)\n+\t\t\t\t\t    - OBJECT_SUBWORD (conflict_obj) - 1);\n+\t\t  else\n+\t\t    conflict_hard_regno += OBJECT_SUBWORD (conflict_obj);\n+\t\t  conflict_nregs = 1;\n+\t\t}\n+\t      else\n+\t\tconflict_nregs\n+\t\t  = (hard_regno_nregs\n+\t\t     [conflict_hard_regno][ALLOCNO_MODE (conflict_a)]);\n+\n+\t      if ((conflict_hard_regno <= this_regno\n+\t\t && this_regno < conflict_hard_regno + conflict_nregs)\n+\t\t|| (this_regno <= conflict_hard_regno\n+\t\t    && conflict_hard_regno < this_regno + nregs))\n \t\t{\n \t\t  fprintf (stderr, \"bad allocation for %d and %d\\n\",\n \t\t\t   ALLOCNO_REGNO (a), ALLOCNO_REGNO (conflict_a));"}]}