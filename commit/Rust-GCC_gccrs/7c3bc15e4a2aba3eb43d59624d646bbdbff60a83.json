{"sha": "7c3bc15e4a2aba3eb43d59624d646bbdbff60a83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzYmMxNWU0YTJhYmEzZWI0M2Q1OTYyNGQ2NDZiYmRiZmY2MGE4Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-15T19:13:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-15T19:13:47Z"}, "message": "compiler: make sure variables captured by defer closure live\n    \n    Local variables captured by the deferred closure need to be live\n    until the function finishes, especially when the deferred\n    function runs. In Function::build, for function that has a defer,\n    we wrap the function body in a try block. So the backend sees\n    the local variables only live in the try block, without knowing\n    that they are needed also in the finally block where we invoke\n    the deferred function. Fix this by creating top-level\n    declarations for non-escaping address-taken locals when there\n    is a defer.\n    \n    An example of miscompilation without this CL:\n    \n    func F(fn func()) {\n            didPanic := true\n            defer func() {\n                    println(didPanic)\n            }()\n            fn()\n            didPanic = false\n    }\n    \n    With escape analysis turned on, at optimization level -O1 or -O2,\n    the store \"didPanic = false\" is elided by the backend's\n    optimizer, presumably because it thinks \"didPanic\" is not live\n    after the store, so the store is useless.\n    \n    Reviewed-on: https://go-review.googlesource.com/86241\n\nFrom-SVN: r256706", "tree": {"sha": "cc0acfcf32f205c7abfac4cada88e3136e992ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc0acfcf32f205c7abfac4cada88e3136e992ca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83/comments", "author": null, "committer": null, "parents": [{"sha": "64b1806b2d94fd325759761b64fb7507ca83d5d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b1806b2d94fd325759761b64fb7507ca83d5d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b1806b2d94fd325759761b64fb7507ca83d5d2"}], "stats": {"total": 37, "additions": 31, "deletions": 6}, "files": [{"sha": "8f5e4ba6866f9491cc30b559623eb6e6f2a67a59", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7c3bc15e4a2aba3eb43d59624d646bbdbff60a83", "patch": "@@ -1,4 +1,4 @@\n-4aa531c1765bba52848c6d71b9f57b593063d3ba\n+afac7d7bed07ebe3add1784aaa9547c4d660d0ed\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e8bc7aea9bfca19f64472d5ea1ad43213edb5a85", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3bc15e4a2aba3eb43d59624d646bbdbff60a83/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=7c3bc15e4a2aba3eb43d59624d646bbdbff60a83", "patch": "@@ -5568,6 +5568,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n   // initial values.\n   std::vector<Bvariable*> vars;\n   std::vector<Bexpression*> var_inits;\n+  std::vector<Statement*> var_decls_stmts;\n   for (Bindings::const_definitions_iterator p =\n \t this->block_->bindings()->begin_definitions();\n        p != this->block_->bindings()->end_definitions();\n@@ -5642,6 +5643,24 @@ Function::build(Gogo* gogo, Named_object* named_function)\n           vars.push_back(bvar);\n           var_inits.push_back(init);\n \t}\n+      else if (this->defer_stack_ != NULL\n+               && (*p)->is_variable()\n+               && (*p)->var_value()->is_non_escaping_address_taken()\n+               && !(*p)->var_value()->is_in_heap())\n+        {\n+          // Local variable captured by deferred closure needs to be live\n+          // until the end of the function. We create a top-level\n+          // declaration for it.\n+          // TODO: we don't need to do this if the variable is not captured\n+          // by the defer closure. There is no easy way to check it here,\n+          // so we do this for all address-taken variables for now.\n+          Variable* var = (*p)->var_value();\n+          Temporary_statement* ts =\n+            Statement::make_temporary(var->type(), NULL, var->location());\n+          ts->set_is_address_taken();\n+          var->set_toplevel_decl(ts);\n+          var_decls_stmts.push_back(ts);\n+        }\n     }\n   if (!gogo->backend()->function_set_parameters(this->fndecl_, param_vars))\n     {\n@@ -5661,7 +5680,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n     {\n       // Declare variables if necessary.\n       Bblock* var_decls = NULL;\n-\n+      std::vector<Bstatement*> var_decls_bstmt_list;\n       Bstatement* defer_init = NULL;\n       if (!vars.empty() || this->defer_stack_ != NULL)\n \t{\n@@ -5675,6 +5694,14 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t      Translate_context dcontext(gogo, named_function, this->block_,\n                                          var_decls);\n               defer_init = this->defer_stack_->get_backend(&dcontext);\n+              var_decls_bstmt_list.push_back(defer_init);\n+              for (std::vector<Statement*>::iterator p = var_decls_stmts.begin();\n+                   p != var_decls_stmts.end();\n+                   ++p)\n+                {\n+                  Bstatement* bstmt = (*p)->get_backend(&dcontext);\n+                  var_decls_bstmt_list.push_back(bstmt);\n+                }\n \t    }\n \t}\n \n@@ -5693,8 +5720,6 @@ Function::build(Gogo* gogo, Named_object* named_function)\n                                               var_inits[i]);\n           init.push_back(init_stmt);\n \t}\n-      if (defer_init != NULL)\n-\tinit.push_back(defer_init);\n       Bstatement* var_init = gogo->backend()->statement_list(init);\n \n       // Initialize all variables before executing this code block.\n@@ -5722,8 +5747,8 @@ Function::build(Gogo* gogo, Named_object* named_function)\n       // we built one.\n       if (var_decls != NULL)\n         {\n-          std::vector<Bstatement*> code_stmt_list(1, code_stmt);\n-          gogo->backend()->block_add_statements(var_decls, code_stmt_list);\n+          var_decls_bstmt_list.push_back(code_stmt);\n+          gogo->backend()->block_add_statements(var_decls, var_decls_bstmt_list);\n           code_stmt = gogo->backend()->block_statement(var_decls);\n         }\n "}]}