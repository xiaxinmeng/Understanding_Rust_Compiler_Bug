{"sha": "28188747cb6d8088ed4ee3af90e55c64b814c737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxODg3NDdjYjZkODA4OGVkNGVlM2FmOTBlNTVjNjRiODE0YzczNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-10-16T06:07:09Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-10-16T06:07:09Z"}, "message": "re PR fortran/41648 ([OOP] Type-bound procedures refused)\n\n2009-10-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/41648\n\tPR fortran/41656\n\t* trans-expr.c (select_class_proc): Convert the expression for the\n\tvindex, carried on the first member of the esym list.\n\t* gfortran.h : Add the vindex field to the esym_list structure.\n\tand eliminate the class_object field.\n\t* resolve.c (check_class_members): Remove the setting of the\n\tclass_object field.\n\t(vindex_expr): New function.\n\t(get_class_from_expr): New function.\n\t(resolve_class_compcall): Call the above to find the ultimate\n\tclass or derived component.  If derived, do not generate the\n\tesym list.  Add and expression for the vindex to the esym list\n\tby calling the above.\n\t(resolve_class_typebound_call): The same.\n\n2009-10-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/41648\n\t* gfortran.dg/dynamic_dispatch_4.f03 : New test.\n\n\tPR fortran/41656\n\t* gfortran.dg/dynamic_dispatch_5.f03 : New test.\n\nFrom-SVN: r152890", "tree": {"sha": "89d54c12310628c9e52849e45e8f933aba1b6f3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89d54c12310628c9e52849e45e8f933aba1b6f3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28188747cb6d8088ed4ee3af90e55c64b814c737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28188747cb6d8088ed4ee3af90e55c64b814c737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28188747cb6d8088ed4ee3af90e55c64b814c737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28188747cb6d8088ed4ee3af90e55c64b814c737/comments", "author": null, "committer": null, "parents": [{"sha": "8e200755cfb45e4a71b45621ac79f508f71141cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e200755cfb45e4a71b45621ac79f508f71141cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e200755cfb45e4a71b45621ac79f508f71141cd"}], "stats": {"total": 458, "additions": 435, "deletions": 23}, "files": [{"sha": "fd3a2bc6dd564c843dc3d112c5af1f2eb116b7ec", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=28188747cb6d8088ed4ee3af90e55c64b814c737", "patch": "@@ -1,3 +1,21 @@\n+2009-10-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/41648\n+\tPR fortran/41656\n+\t* trans-expr.c (select_class_proc): Convert the expression for the\n+\tvindex, carried on the first member of the esym list.\n+\t* gfortran.h : Add the vindex field to the esym_list structure.\n+\tand eliminate the class_object field.\n+\t* resolve.c (check_class_members): Remove the setting of the\n+\tclass_object field.\n+\t(vindex_expr): New function.\n+\t(get_class_from_expr): New function.\n+\t(resolve_class_compcall): Call the above to find the ultimate\n+\tclass or derived component.  If derived, do not generate the\n+\tesym list.  Add and expression for the vindex to the esym list\n+\tby calling the above.\n+\t(resolve_class_typebound_call): The same.\n+\n 2009-10-15  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/41712"}, {"sha": "d0911b485abbfcb0ba0b21dde9325750981a5779", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 115, "deletions": 12, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=28188747cb6d8088ed4ee3af90e55c64b814c737", "patch": "@@ -5161,8 +5161,6 @@ check_class_members (gfc_symbol *derived)\n \t\t= gfc_get_class_esym_list();\n       list_e->value.function.class_esym->next = etmp;\n       list_e->value.function.class_esym->derived = derived;\n-      list_e->value.function.class_esym->class_object\n-\t\t= class_object;\n       list_e->value.function.class_esym->esym\n \t\t= e->value.function.esym;\n     }\n@@ -5206,19 +5204,101 @@ resolve_class_esym (gfc_expr *e)\n }\n \n \n+/* Generate an expression for the vindex, given the reference to\n+   the class of the final expression (class_ref), the base of the\n+   full reference list (new_ref), the declared type and the class\n+   object (st).  */\n+static gfc_expr*\n+vindex_expr (gfc_ref *class_ref, gfc_ref *new_ref,\n+\t     gfc_symbol *declared, gfc_symtree *st)\n+{\n+  gfc_expr *vindex;\n+  gfc_ref *ref;\n+\n+  /* Build an expression for the correct vindex; ie. that of the last\n+     CLASS reference.  */\n+  ref = gfc_get_ref();\n+  ref->type = REF_COMPONENT;\n+  ref->u.c.component = declared->components->next;\n+  ref->u.c.sym = declared;\n+  ref->next = NULL;\n+  if (class_ref)\n+    {\n+      class_ref->next = ref;\n+    }\n+  else\n+    {\n+      gfc_free_ref_list (new_ref);\n+      new_ref = ref;\n+    }\n+  vindex = gfc_get_expr ();\n+  vindex->expr_type = EXPR_VARIABLE;\n+  vindex->symtree = st;\n+  vindex->symtree->n.sym->refs++;\n+  vindex->ts = ref->u.c.component->ts;\n+  vindex->ref = new_ref;\n+\n+  return vindex;\n+}\n+\n+\n+/* Get the ultimate declared type from an expression.  In addition,\n+   return the last class/derived type reference and the copy of the\n+   reference list.  */\n+static gfc_symbol*\n+get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n+\t\t\tgfc_expr *e)\n+{\n+  gfc_symbol *declared;\n+  gfc_ref *ref;\n+\n+  declared = NULL;\n+  *class_ref = NULL;\n+  *new_ref = gfc_copy_ref (e->ref);\n+  for (ref = *new_ref; ref; ref = ref->next)\n+    {\n+      if (ref->type != REF_COMPONENT)\n+\tcontinue;\n+\n+      if (ref->u.c.component->ts.type == BT_CLASS\n+\t    || ref->u.c.component->ts.type == BT_DERIVED)\n+\t{\n+\t  declared = ref->u.c.component->ts.u.derived;\n+\t  *class_ref = ref;\n+\t}\n+    }\n+\n+  if (declared == NULL)\n+    declared = e->symtree->n.sym->ts.u.derived;\n+\n+  return declared;\n+}\n+\n+\n /* Resolve a CLASS typebound function, or 'method'.  */\n static gfc_try\n resolve_class_compcall (gfc_expr* e)\n {\n-  gfc_symbol *derived;\n+  gfc_symbol *derived, *declared;\n+  gfc_ref *new_ref;\n+  gfc_ref *class_ref;\n+  gfc_symtree *st;\n+\n+  st = e->symtree;\n+  class_object = st->n.sym;\n \n-  class_object = e->symtree->n.sym;\n+  /* Get the CLASS declared type.  */\n+  declared = get_declared_from_expr (&class_ref, &new_ref, e);\n \n-  /* Get the CLASS type.  */\n-  derived = e->symtree->n.sym->ts.u.derived;\n+  /* Weed out cases of the ultimate component being a derived type.  */\n+  if (class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+    {\n+      gfc_free_ref_list (new_ref);\n+      return resolve_compcall (e, true);\n+    } \n \n   /* Get the data component, which is of the declared type.  */\n-  derived = derived->components->ts.u.derived;\n+  derived = declared->components->ts.u.derived;\n \n   /* Resolve the function call for each member of the class.  */\n   class_try = SUCCESS;\n@@ -5238,22 +5318,39 @@ resolve_class_compcall (gfc_expr* e)\n \n   resolve_class_esym (e);\n \n+  /* More than one typebound procedure so transmit an expression for\n+     the vindex as the selector.  */\n+  if (e->value.function.class_esym != NULL)\n+    e->value.function.class_esym->vindex\n+\t\t= vindex_expr (class_ref, new_ref, declared, st);\n+\n   return class_try;\n }\n \n /* Resolve a CLASS typebound subroutine, or 'method'.  */\n static gfc_try\n resolve_class_typebound_call (gfc_code *code)\n {\n-  gfc_symbol *derived;\n+  gfc_symbol *derived, *declared;\n+  gfc_ref *new_ref;\n+  gfc_ref *class_ref;\n+  gfc_symtree *st;\n+\n+  st = code->expr1->symtree;\n+  class_object = st->n.sym;\n \n-  class_object = code->expr1->symtree->n.sym;\n+  /* Get the CLASS declared type.  */\n+  declared = get_declared_from_expr (&class_ref, &new_ref, code->expr1);\n \n-  /* Get the CLASS type.  */\n-  derived = code->expr1->symtree->n.sym->ts.u.derived;\n+  /* Weed out cases of the ultimate component being a derived type.  */\n+  if (class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+    {\n+      gfc_free_ref_list (new_ref);\n+      return resolve_typebound_call (code);\n+    } \n \n   /* Get the data component, which is of the declared type.  */\n-  derived = derived->components->ts.u.derived;\n+  derived = declared->components->ts.u.derived;\n \n   class_try = SUCCESS;\n   fcn_flag = false;\n@@ -5273,6 +5370,12 @@ resolve_class_typebound_call (gfc_code *code)\n \n   resolve_class_esym (code->expr1);\n \n+  /* More than one typebound procedure so transmit an expression for\n+     the vindex as the selector.  */\n+  if (code->expr1->value.function.class_esym != NULL)\n+    code->expr1->value.function.class_esym->vindex\n+\t\t= vindex_expr (class_ref, new_ref, declared, st);\n+\n   return class_try;\n }\n "}, {"sha": "331ca6a4ee459184223d6d11cea4a5772586bf41", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=28188747cb6d8088ed4ee3af90e55c64b814c737", "patch": "@@ -1527,24 +1527,24 @@ get_proc_ptr_comp (gfc_expr *e)\n /* Select a class typebound procedure at runtime.  */\n static void\n select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n-\t\t   tree declared, locus *where)\n+\t\t   tree declared, gfc_expr *expr)\n {\n   tree end_label;\n   tree label;\n   tree tmp;\n   tree vindex;\n   stmtblock_t body;\n   gfc_class_esym_list *next_elist, *tmp_elist;\n+  gfc_se tmpse;\n \n-  /* Calculate the switch expression: class_object.vindex.  */\n-  gcc_assert (elist->class_object->ts.type == BT_CLASS);\n-  tmp = elist->class_object->ts.u.derived->components->next->backend_decl;\n-  vindex = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t\telist->class_object->backend_decl,\n-\t\t\ttmp, NULL_TREE);\n-  vindex = gfc_evaluate_now (vindex, &se->pre);\n+  /* Convert the vindex expression.  */\n+  gfc_init_se (&tmpse, NULL);\n+  gfc_conv_expr (&tmpse, elist->vindex);\n+  gfc_add_block_to_block (&se->pre, &tmpse.pre);\n+  vindex = gfc_evaluate_now (tmpse.expr, &se->pre);\n+  gfc_add_block_to_block (&se->post, &tmpse.post);\n \n-  /* Fix the function type to be that of the declared type.  */\n+  /* Fix the function type to be that of the declared type method.  */\n   declared = gfc_create_var (TREE_TYPE (declared), \"method\");\n \n   end_label = gfc_build_label_decl (NULL_TREE);\n@@ -1603,6 +1603,8 @@ select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n \t segfaults because it occurs too early and too often.  */\n     free_elist:\n       next_elist = elist->next;\n+      if (elist->vindex)\n+\tgfc_free_expr (elist->vindex);\n       gfc_free (elist);\n       elist = NULL;\n     }\n@@ -1612,7 +1614,7 @@ select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n   tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n \t\t     NULL_TREE, NULL_TREE, label);\n   gfc_add_expr_to_block (&body, tmp);\n-  tmp = gfc_trans_runtime_error (true, where,\n+  tmp = gfc_trans_runtime_error (true, &expr->where,\n \t\t\"internal error: bad vindex in dynamic dispatch\");\n   gfc_add_expr_to_block (&body, tmp);\n \n@@ -1649,7 +1651,7 @@ conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n \t}\n \n       select_class_proc (se, expr->value.function.class_esym,\n-\t\t\t tmp, &expr->where);\n+\t\t\t tmp, expr);\n       return;\n     }\n "}, {"sha": "7e166317e4de1c5f3ffbc76651dbcdba9c6824c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28188747cb6d8088ed4ee3af90e55c64b814c737", "patch": "@@ -1,3 +1,11 @@\n+2009-10-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/41648\n+\t* gfortran.dg/dynamic_dispatch_4.f03 : New test.\n+\n+\tPR fortran/41656\n+\t* gfortran.dg/dynamic_dispatch_5.f03 : New test.\n+\n 2009-10-15  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/23983"}, {"sha": "b72819acc4ceb8b5fcc8ef423c2713af5b1a68fd", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_4.f03", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_4.f03?ref=28188747cb6d8088ed4ee3af90e55c64b814c737", "patch": "@@ -0,0 +1,96 @@\n+! { dg-do run }\n+! Tests the fix for PR41648 in which the reference a%a%getit () was wrongly\n+! identified as a recursive call to getit.\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module foo_mod\n+  type foo\n+    integer :: i \n+  contains\n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+  end type foo\n+  \n+  private doit,getit\n+contains\n+  subroutine  doit(a) \n+    class(foo) :: a\n+    \n+    a%i = 1\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(foo) :: a\n+    integer :: res\n+\n+    res = a%i\n+  end function getit\n+    \n+end module foo_mod\n+\n+module s_bar_mod \n+  use foo_mod\n+  type, extends(foo) :: s_bar \n+    type(foo), allocatable :: a\n+  contains \n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+  end type s_bar\n+  private doit,getit\n+  \n+contains\n+  subroutine doit(a)\n+    class(s_bar) :: a\n+    allocate (a%a)   \n+    call a%a%doit()\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(s_bar) :: a\n+    integer :: res\n+\n+    res = a%a%getit () * 2\n+  end function getit\n+end module s_bar_mod\n+\n+module a_bar_mod \n+  use foo_mod\n+  type, extends(foo) :: a_bar \n+    type(foo), allocatable :: a(:)\n+  contains \n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+  end type a_bar\n+  private doit,getit\n+  \n+contains\n+  subroutine doit(a)\n+    class(a_bar) :: a\n+    allocate (a%a(1))   \n+    call a%a(1)%doit ()\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(a_bar) :: a\n+    integer :: res\n+\n+    res = a%a(1)%getit () * 3\n+  end function getit\n+end module a_bar_mod\n+\n+  use s_bar_mod\n+  use a_bar_mod\n+  type(foo), target :: b\n+  type(s_bar), target :: c\n+  type(a_bar), target :: d\n+  class(foo), pointer :: a\n+  a => b\n+  call a%doit\n+  if (a%getit () .ne. 1) call abort\n+  a => c\n+  call a%doit\n+  if (a%getit () .ne. 2) call abort\n+  a => d\n+  call a%doit\n+  if (a%getit () .ne. 3) call abort\n+end\n+! { dg-final { cleanup-modules \"foo_mod s_bar_mod a_bar_mod\" } }\n+"}, {"sha": "8533508bcdcb1c381c18d9c416951421727c4d9d", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_5.f03", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28188747cb6d8088ed4ee3af90e55c64b814c737/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_5.f03?ref=28188747cb6d8088ed4ee3af90e55c64b814c737", "patch": "@@ -0,0 +1,185 @@\n+! { dg-do compile }\n+! Tests the fix for PR4164656 in which the call to a%a%scal failed to compile.\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module const_mod\n+  integer, parameter  :: longndig=12\n+  integer, parameter  :: long_int_k_ = selected_int_kind(longndig)\n+  integer, parameter  :: dpk_ = kind(1.d0)\n+  integer, parameter  :: spk_ = kind(1.e0)\n+end module const_mod\n+\n+module base_mat_mod  \n+  use const_mod \n+  type  :: base_sparse_mat\n+    integer, private     :: m, n\n+    integer, private     :: state, duplicate \n+    logical, private     :: triangle, unitd, upper, sorted\n+  contains \n+    procedure, pass(a) :: get_nzeros\n+  end type base_sparse_mat\n+  private ::  get_nzeros\n+contains\n+  function get_nzeros(a) result(res)\n+    implicit none \n+    class(base_sparse_mat), intent(in) :: a\n+    integer :: res\n+    integer :: err_act\n+    character(len=20)  :: name='base_get_nzeros'\n+    logical, parameter :: debug=.false.\n+    res = -1\n+  end function get_nzeros\n+end module base_mat_mod\n+\n+module s_base_mat_mod\n+  use base_mat_mod\n+  type, extends(base_sparse_mat) :: s_base_sparse_mat\n+  contains\n+    procedure, pass(a) :: s_scals\n+    procedure, pass(a) :: s_scal\n+    generic, public    :: scal => s_scals, s_scal \n+  end type s_base_sparse_mat\n+  private :: s_scals, s_scal\n+\n+  type, extends(s_base_sparse_mat) :: s_coo_sparse_mat\n+    \n+    integer              :: nnz\n+    integer, allocatable :: ia(:), ja(:)\n+    real(spk_), allocatable :: val(:)\n+  contains\n+    procedure, pass(a) :: get_nzeros => s_coo_get_nzeros\n+    procedure, pass(a) :: s_scals => s_coo_scals\n+    procedure, pass(a) :: s_scal => s_coo_scal\n+  end type s_coo_sparse_mat\n+  private :: s_coo_scals, s_coo_scal, s_coo_get_nzeros\n+contains \n+  subroutine s_scals(d,a,info) \n+    implicit none \n+    class(s_base_sparse_mat), intent(in) :: a\n+    real(spk_), intent(in)      :: d\n+    integer, intent(out)            :: info\n+\n+    Integer :: err_act\n+    character(len=20)  :: name='s_scals'\n+    logical, parameter :: debug=.false.\n+\n+    ! This is the base version. If we get here\n+    ! it means the derived class is incomplete,\n+    ! so we throw an error.\n+    info = 700\n+  end subroutine s_scals\n+\n+\n+  subroutine s_scal(d,a,info) \n+    implicit none \n+    class(s_base_sparse_mat), intent(in) :: a\n+    real(spk_), intent(in)      :: d(:)\n+    integer, intent(out)            :: info\n+\n+    Integer :: err_act\n+    character(len=20)  :: name='s_scal'\n+    logical, parameter :: debug=.false.\n+\n+    ! This is the base version. If we get here\n+    ! it means the derived class is incomplete,\n+    ! so we throw an error.\n+    info = 700\n+  end subroutine s_scal\n+\n+  function s_coo_get_nzeros(a) result(res)\n+    implicit none \n+    class(s_coo_sparse_mat), intent(in) :: a\n+    integer :: res\n+    res  = a%nnz\n+  end function s_coo_get_nzeros\n+\n+\n+  subroutine s_coo_scal(d,a,info) \n+    use const_mod\n+    implicit none \n+    class(s_coo_sparse_mat), intent(inout) :: a\n+    real(spk_), intent(in)      :: d(:)\n+    integer, intent(out)            :: info\n+\n+    Integer :: err_act,mnm, i, j, m\n+    character(len=20)  :: name='scal'\n+    logical, parameter :: debug=.false.\n+    info  = 0\n+    do i=1,a%get_nzeros()\n+      j        = a%ia(i)\n+      a%val(i) = a%val(i) * d(j)\n+    enddo\n+  end subroutine s_coo_scal\n+\n+  subroutine s_coo_scals(d,a,info) \n+    use const_mod\n+    implicit none \n+    class(s_coo_sparse_mat), intent(inout) :: a\n+    real(spk_), intent(in)      :: d\n+    integer, intent(out)            :: info\n+\n+    Integer :: err_act,mnm, i, j, m\n+    character(len=20)  :: name='scal'\n+    logical, parameter :: debug=.false.\n+\n+    info  = 0\n+    do i=1,a%get_nzeros()\n+      a%val(i) = a%val(i) * d\n+    enddo\n+  end subroutine s_coo_scals\n+end module s_base_mat_mod\n+\n+module s_mat_mod\n+  use s_base_mat_mod\n+  type :: s_sparse_mat\n+    class(s_base_sparse_mat), pointer  :: a\n+  contains\n+    procedure, pass(a) :: s_scals\n+    procedure, pass(a) :: s_scal\n+    generic, public    :: scal => s_scals, s_scal \n+  end type s_sparse_mat\n+  interface scal\n+    module procedure s_scals, s_scal\n+  end interface\n+contains \n+  subroutine s_scal(d,a,info)\n+    use const_mod\n+    implicit none \n+    class(s_sparse_mat), intent(inout) :: a\n+    real(spk_), intent(in)              :: d(:)\n+    integer, intent(out)                    :: info\n+    integer :: err_act\n+    character(len=20)  :: name='csnmi'\n+    logical, parameter :: debug=.false.\n+    print *, \"s_scal\"\n+    call a%a%scal(d,info)\n+    return\n+  end subroutine s_scal\n+\n+  subroutine s_scals(d,a,info)\n+    use const_mod\n+    implicit none \n+    class(s_sparse_mat), intent(inout) :: a\n+    real(spk_), intent(in)              :: d\n+    integer, intent(out)                    :: info\n+    integer :: err_act\n+    character(len=20)  :: name='csnmi'\n+    logical, parameter :: debug=.false.\n+    print *, \"s_scals\"\n+    call a%a%scal(d,info)\n+    return\n+  end subroutine s_scals\n+end module s_mat_mod\n+\n+    use s_mat_mod\n+    class (s_sparse_mat), pointer :: a\n+    type (s_sparse_mat), target :: b\n+    type (s_base_sparse_mat), target :: c\n+    integer info\n+    b%a => c\n+    a => b\n+    call a%scal (1.0_spk_, info)\n+end\n+! { dg-final { cleanup-modules \"const_mod base_mat_mod s_base_mat_mod s_mat_mod\" } }\n+"}]}