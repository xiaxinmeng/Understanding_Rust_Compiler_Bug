{"sha": "4d73fac958abe4d2728b952a076361bc2b469f9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3M2ZhYzk1OGFiZTRkMjcyOGI5NTJhMDc2MzYxYmMyYjQ2OWY5Yg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-02-01T13:30:34Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-02-01T13:30:34Z"}, "message": "cpp_type_traits.h: Rename _M_type fields to __value...\n\n2005-02-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/cpp_type_traits.h: Rename _M_type fields to\n\t__value, except for __enable_if, _M_type -> __type, consistently\n\twith the other traits.\n\t* include/bits/stl_algobase.h: Tweak consistently.\n\t* include/bits/stl_tree.h: Likewise.\n\t* include/bits/valarray_array.h: Likewise.\n\t* include/c_std/std_cmath.h: Likewise.\n\t* include/debug/safe_iterator.h: Likewise.\n\t* include/std/std_complex.h: Likewise.\n\nFrom-SVN: r94538", "tree": {"sha": "ef8365e2ad9f69adc048d74eff957ed4c0348df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef8365e2ad9f69adc048d74eff957ed4c0348df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d73fac958abe4d2728b952a076361bc2b469f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d73fac958abe4d2728b952a076361bc2b469f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d73fac958abe4d2728b952a076361bc2b469f9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d73fac958abe4d2728b952a076361bc2b469f9b/comments", "author": null, "committer": null, "parents": [{"sha": "bbcb0c056be0883aa970eb5552bb713d516d9c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcb0c056be0883aa970eb5552bb713d516d9c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbcb0c056be0883aa970eb5552bb713d516d9c1e"}], "stats": {"total": 184, "additions": 96, "deletions": 88}, "files": [{"sha": "0145a6eff691dc9259ff7bae1db83dedb6e06fac", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -1,3 +1,15 @@\n+2005-02-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/cpp_type_traits.h: Rename _M_type fields to\n+\t__value, except for __enable_if, _M_type -> __type, consistently\n+\twith the other traits.\n+\t* include/bits/stl_algobase.h: Tweak consistently.\n+\t* include/bits/stl_tree.h: Likewise.\n+\t* include/bits/valarray_array.h: Likewise.\n+\t* include/c_std/std_cmath.h: Likewise.\n+\t* include/debug/safe_iterator.h: Likewise.\n+\t* include/std/std_complex.h: Likewise.\n+\n 2005-01-31  Brad Spencer  <spencer@infointeractive.com>\n \n \t* crossconfig.m4: Repair Solaris cross bits for strtold and strtof."}, {"sha": "367a9d305523ac494b6906b48ea7306316537e90", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -77,10 +77,10 @@ namespace __gnu_internal\n   typedef char __one;\n   typedef char __two[2];\n \n-  template <typename _Tp>\n-  __one __test_type (int _Tp::*);\n-  template <typename _Tp>\n-  __two& __test_type (...);\n+  template<typename _Tp>\n+  __one __test_type(int _Tp::*);\n+  template<typename _Tp>\n+  __two& __test_type(...);\n } // namespace __gnu_internal\n \n // Forward declaration hack, should really include this from somewhere.\n@@ -106,27 +106,23 @@ namespace std\n   template<class _Sp, class _Tp>\n     struct __traitor\n     {\n-      enum { _M_type = _Sp::_M_type || _Tp::_M_type };\n-      typedef typename __truth_type<_M_type>::__type __type;\n+      enum { __value = _Sp::__value || _Tp::__value };\n+      typedef typename __truth_type<__value>::__type __type;\n     };\n \n   // Compare for equality of types.\n   template<typename, typename>\n     struct __are_same\n     {\n-      enum\n-\t{\n-\t  _M_type = 0\n-\t};\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n     };\n \n   template<typename _Tp>\n     struct __are_same<_Tp, _Tp>\n     {\n-      enum\n-\t{\n-\t  _M_type = 1\n-\t};\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n     };\n \n   // Define a nested type if some predicate holds.\n@@ -138,21 +134,21 @@ namespace std\n   template<typename _Tp>\n     struct __enable_if<_Tp, true>\n     {\n-      typedef _Tp _M_type;\n+      typedef _Tp __type;\n     };\n \n   // Holds if the template-argument is a void type.\n   template<typename _Tp>\n     struct __is_void\n     {\n-      enum { _M_type = 0 };\n+      enum { __value = 0 };\n       typedef __false_type __type;\n     };\n \n   template<>\n     struct __is_void<void>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n@@ -162,7 +158,7 @@ namespace std\n   template<typename _Tp>\n     struct __is_integer\n     {\n-      enum { _M_type = 0 };\n+      enum { __value = 0 };\n       typedef __false_type __type;\n     };\n \n@@ -172,93 +168,93 @@ namespace std\n   template<>\n     struct __is_integer<bool>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<char>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<signed char>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<unsigned char>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n # ifdef _GLIBCXX_USE_WCHAR_T\n   template<>\n     struct __is_integer<wchar_t>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n # endif\n \n   template<>\n     struct __is_integer<short>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<unsigned short>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<int>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<unsigned int>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<long>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<unsigned long>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<long long>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_integer<unsigned long long>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n@@ -268,29 +264,29 @@ namespace std\n   template<typename _Tp>\n     struct __is_floating\n     {\n-      enum { _M_type = 0 };\n+      enum { __value = 0 };\n       typedef __false_type __type;\n     };\n \n   // three specializations (float, double and 'long double')\n   template<>\n     struct __is_floating<float>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_floating<double>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n   template<>\n     struct __is_floating<long double>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n@@ -300,14 +296,14 @@ namespace std\n   template<typename _Tp>\n     struct __is_pointer\n     {\n-      enum { _M_type = 0 };\n+      enum { __value = 0 };\n       typedef __false_type __type;\n     };\n \n   template<typename _Tp>\n     struct __is_pointer<_Tp*>\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n@@ -317,15 +313,15 @@ namespace std\n   template<typename _Tp>\n     struct __is_normal_iterator\n     {\n-      enum { _M_type = 0 };\n+      enum { __value = 0 };\n       typedef __false_type __type;\n     };\n \n   template<typename _Iterator, typename _Container>\n     struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,\n \t\t\t\t\t\t\t      _Container> >\n     {\n-      enum { _M_type = 1 };\n+      enum { __value = 1 };\n       typedef __true_type __type;\n     };\n \n@@ -361,7 +357,7 @@ namespace std\n     {\n       enum\n \t{\n-\t  _M_type = (sizeof(__gnu_internal::__test_type<_Tp>(0))\n+\t  __value = (sizeof(__gnu_internal::__test_type<_Tp>(0))\n \t\t     != sizeof(__gnu_internal::__one))\n \t};\n     };"}, {"sha": "a67d2a9a320ec4e82832207b9479af3c367994b0", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -155,7 +155,7 @@ namespace std\n \t\t\t\t  _ValueType2>)\n       __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,\n \t\t\t\t  _ValueType1>)\n-      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::_M_type>::\n+      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value>::\n \titer_swap(__a, __b);\n     }\n \n@@ -302,10 +302,10 @@ namespace std\n       typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n       typedef typename iterator_traits<_OI>::value_type _ValueTypeO;\n       typedef typename iterator_traits<_II>::iterator_category _Category;\n-      const bool __simple = (__is_scalar<_ValueTypeI>::_M_type\n-\t                     && __is_pointer<_II>::_M_type\n-\t                     && __is_pointer<_OI>::_M_type\n-\t\t\t     && __are_same<_ValueTypeI, _ValueTypeO>::_M_type);\n+      const bool __simple = (__is_scalar<_ValueTypeI>::__value\n+\t                     && __is_pointer<_II>::__value\n+\t                     && __is_pointer<_OI>::__value\n+\t\t\t     && __are_same<_ValueTypeI, _ValueTypeO>::__value);\n \n       return std::__copy<__simple, _Category>::copy(__first, __last, __result);\n     }\n@@ -374,8 +374,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-       const bool __in = __is_normal_iterator<_InputIterator>::_M_type;\n-       const bool __out = __is_normal_iterator<_OutputIterator>::_M_type;\n+       const bool __in = __is_normal_iterator<_InputIterator>::__value;\n+       const bool __out = __is_normal_iterator<_OutputIterator>::__value;\n        return std::__copy_normal<__in, __out>::copy_n(__first, __last,\n \t\t\t\t\t\t      __result);\n     }\n@@ -427,10 +427,10 @@ namespace std\n       typedef typename iterator_traits<_BI1>::value_type _ValueType1;\n       typedef typename iterator_traits<_BI2>::value_type _ValueType2;\n       typedef typename iterator_traits<_BI1>::iterator_category _Category;\n-      const bool __simple = (__is_scalar<_ValueType1>::_M_type\n-\t                     && __is_pointer<_BI1>::_M_type\n-\t                     && __is_pointer<_BI2>::_M_type\n-\t\t\t     && __are_same<_ValueType1, _ValueType2>::_M_type);\n+      const bool __simple = (__is_scalar<_ValueType1>::__value\n+\t                     && __is_pointer<_BI1>::__value\n+\t                     && __is_pointer<_BI2>::__value\n+\t\t\t     && __are_same<_ValueType1, _ValueType2>::__value);\n \n       return std::__copy_backward<__simple, _Category>::copy_b(__first, __last,\n \t\t\t\t\t\t\t       __result);\n@@ -504,8 +504,8 @@ namespace std\n \t    typename iterator_traits<_BI2>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      const bool __bi1 = __is_normal_iterator<_BI1>::_M_type;\n-      const bool __bi2 = __is_normal_iterator<_BI2>::_M_type;\n+      const bool __bi1 = __is_normal_iterator<_BI1>::__value;\n+      const bool __bi2 = __is_normal_iterator<_BI2>::__value;\n       return std::__copy_backward_normal<__bi1, __bi2>::copy_b_n(__first, __last,\n \t\t\t\t\t\t\t\t __result);\n     }\n@@ -557,7 +557,7 @@ namespace std\n \t\t\t\t  _ForwardIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      const bool __scalar = __is_scalar<_Tp>::_M_type;\n+      const bool __scalar = __is_scalar<_Tp>::__value;\n       std::__fill<__scalar>::fill(__first, __last, __value);\n     }\n \n@@ -631,7 +631,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _Tp>)\n \n-      const bool __scalar = __is_scalar<_Tp>::_M_type;\n+      const bool __scalar = __is_scalar<_Tp>::__value;\n       return std::__fill_n<__scalar>::fill_n(__first, __n, __value);\n     }\n "}, {"sha": "4da42c168fe1a8bc48e5bd532acbd21fe0554b7f", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -392,7 +392,7 @@ namespace std\n \n     protected:\n       template<typename _Key_compare, \n-\t       bool _Is_pod_comparator = std::__is_pod<_Key_compare>::_M_type>\n+\t       bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>\n         struct _Rb_tree_impl : public _Node_allocator\n         {\n \t  _Key_compare\t\t_M_key_compare;"}, {"sha": "2cb69758426fc53ce22a4f4f7a03e0c56b92c89d", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- internal _Array helper class.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2003, 2004\n+// Copyright (C) 1997, 1998, 1999, 2000, 2003, 2004, 2005\n //  Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -98,7 +98,7 @@ namespace std\n     inline void\n     __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n     {\n-      _Array_default_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _Array_default_ctor<_Tp, __is_fundamental<_Tp>::__value>::\n \t_S_do_it(__b, __e);\n     }\n \n@@ -134,7 +134,7 @@ namespace std\n     __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n \t\t\t      const _Tp __t)\n     {\n-      _Array_init_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _Array_init_ctor<_Tp, __is_fundamental<_Tp>::__value>::\n \t_S_do_it(__b, __e, __t);\n     }\n \n@@ -171,7 +171,7 @@ namespace std\n \t\t\t      const _Tp* __restrict__ __e,\n \t\t\t      _Tp* __restrict__ __o)\n     {\n-      _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::__value>::\n \t_S_do_it(__b, __e, __o);\n     }\n \n@@ -181,7 +181,7 @@ namespace std\n     __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n \t\t\t       size_t __s, _Tp* __restrict__ __o)\n     {\n-      if (__is_fundamental<_Tp>::_M_type)\n+      if (__is_fundamental<_Tp>::__value)\n \twhile (__n--)\n \t  {\n \t    *__o++ = *__a;\n@@ -202,7 +202,7 @@ namespace std\n \t\t\t       const size_t* __restrict__ __i,\n \t\t\t       _Tp* __restrict__ __o, size_t __n)\n     {\n-      if (__is_fundamental<_Tp>::_M_type)\n+      if (__is_fundamental<_Tp>::__value)\n \twhile (__n--)\n \t  *__o++ = __a[*__i++];\n       else\n@@ -215,7 +215,7 @@ namespace std\n     inline void\n     __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n     {\n-      if (!__is_fundamental<_Tp>::_M_type)\n+      if (!__is_fundamental<_Tp>::__value)\n \twhile (__b != __e)\n \t  {\n \t    __b->~_Tp();\n@@ -279,7 +279,7 @@ namespace std\n     __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n \t\t    _Tp* __restrict__ __b)\n     {\n-      _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _Array_copier<_Tp, __is_fundamental<_Tp>::__value>::\n \t_S_do_it(__a, __n, __b);\n     }\n "}, {"sha": "5aefe0ff8ac6c925d93162d20396cb7c9e49e517", "filename": "libstdc++-v3/include/c_std/std_cmath.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -107,7 +107,7 @@ namespace std\n   { return __builtin_acosl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     acos(_Tp __x)\n     {\n       return __builtin_acos(__x);\n@@ -124,7 +124,7 @@ namespace std\n   { return __builtin_asinl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     asin(_Tp __x)\n     { return __builtin_asin(__x); }\n \n@@ -139,7 +139,7 @@ namespace std\n   { return __builtin_atanl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     atan(_Tp __x)\n     { return __builtin_atan(__x); }\n \n@@ -154,8 +154,8 @@ namespace std\n   { return __builtin_atan2l(__y, __x); }\n \n   template<typename _Tp, typename _Up>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type\n-                                        && __is_integer<_Up>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value\n+                                        && __is_integer<_Up>::__value>::__type\n     atan2(_Tp __y, _Up __x)\n     { return __builtin_atan2(__y, __x); }\n \n@@ -170,7 +170,7 @@ namespace std\n   { return __builtin_ceill(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     ceil(_Tp __x)\n     { return __builtin_ceil(__x); }\n \n@@ -185,7 +185,7 @@ namespace std\n   { return __builtin_cosl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     cos(_Tp __x)\n     { return __builtin_cos(__x); }\n \n@@ -200,7 +200,7 @@ namespace std\n   { return __builtin_coshl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     cosh(_Tp __x)\n     { return __builtin_cosh(__x); }\n \n@@ -215,7 +215,7 @@ namespace std\n   { return __builtin_expl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     exp(_Tp __x)\n     { return __builtin_exp(__x); }\n \n@@ -230,7 +230,7 @@ namespace std\n   { return __builtin_fabsl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     fabs(_Tp __x)\n     { return __builtin_fabs(__x); }\n \n@@ -245,7 +245,7 @@ namespace std\n   { return __builtin_floorl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     floor(_Tp __x)\n     { return __builtin_floor(__x); }\n \n@@ -270,7 +270,7 @@ namespace std\n   { return __builtin_frexpl(__x, __exp); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     frexp(_Tp __x, int* __exp)\n     { return __builtin_frexp(__x, __exp); }\n \n@@ -285,7 +285,7 @@ namespace std\n   { return __builtin_ldexpl(__x, __exp); }\n \n   template<typename _Tp>\n-  inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+  inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n   ldexp(_Tp __x, int __exp)\n   { return __builtin_ldexp(__x, __exp); }\n \n@@ -300,7 +300,7 @@ namespace std\n   { return __builtin_logl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     log(_Tp __x)\n     { return __builtin_log(__x); }\n \n@@ -315,7 +315,7 @@ namespace std\n   { return __builtin_log10l(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     log10(_Tp __x)\n     { return __builtin_log10(__x); }\n \n@@ -371,7 +371,7 @@ namespace std\n   { return __builtin_sinl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     sin(_Tp __x)\n     { return __builtin_sin(__x); }\n \n@@ -386,7 +386,7 @@ namespace std\n   { return __builtin_sinhl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     sinh(_Tp __x)\n     { return __builtin_sinh(__x); }\n \n@@ -401,7 +401,7 @@ namespace std\n   { return __builtin_sqrtl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     sqrt(_Tp __x)\n     { return __builtin_sqrt(__x); }\n \n@@ -416,7 +416,7 @@ namespace std\n   { return __builtin_tanl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     tan(_Tp __x)\n     { return __builtin_tan(__x); }\n \n@@ -431,7 +431,7 @@ namespace std\n   { return __builtin_tanhl(__x); }\n \n   template<typename _Tp>\n-    inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n+    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type\n     tanh(_Tp __x)\n     { return __builtin_tanh(__x); }\n }"}, {"sha": "1f5b0f65e450aa766da79fb0e5826b33bb2705d7", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -1,6 +1,6 @@\n // Safe iterator implementation  -*- C++ -*-\n \n-// Copyright (C) 2003, 2004\n+// Copyright (C) 2003, 2004, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -139,8 +139,8 @@ namespace __gnu_debug\n           typename std::__enable_if<\n                      _Sequence,\n                      (std::__are_same<_MutableIterator,\n-                      typename _Sequence::iterator::_Base_iterator>::_M_type)\n-                   >::_M_type>& __x)\n+                      typename _Sequence::iterator::_Base_iterator>::__value)\n+                   >::__type>& __x)\n \t: _Safe_iterator_base(__x, _M_constant()), _M_current(__x.base())\n         {\n \t  _GLIBCXX_DEBUG_VERIFY(!__x._M_singular(),"}, {"sha": "1a5c6a0a2592eab4f74e0777abc576911d1aaf07", "filename": "libstdc++-v3/include/std/std_complex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d73fac958abe4d2728b952a076361bc2b469f9b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h?ref=4d73fac958abe4d2728b952a076361bc2b469f9b", "patch": "@@ -640,7 +640,7 @@ namespace std\n     inline _Tp\n     norm(const complex<_Tp>& __z)\n     {\n-      return _Norm_helper<__is_floating<_Tp>::_M_type \n+      return _Norm_helper<__is_floating<_Tp>::__value \n \t&& !_GLIBCXX_FAST_MATH>::_S_do_it(__z);\n     }\n "}]}