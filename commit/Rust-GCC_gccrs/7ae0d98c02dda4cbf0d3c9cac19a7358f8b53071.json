{"sha": "7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FlMGQ5OGMwMmRkYTRjYmYwZDNjOWNhYzE5YTczNThmOGI1MzA3MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:20:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:20:09Z"}, "message": "[multiple changes]\n\n2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Build_Raise_Statement): Remove the specialized\n\tprocessing for .NET/JVM. These targets can now benefit from\n\tRaise_From_Controlled_Operation and they share the same processing with\n\tstandard targets.\n\t(Establish_Transient_Scope): Remove the restriction for .NET/JVM.\n\tThese targets need transient scopes in order to properly finalize short\n\tlived controlled objects.\n\t(Make_Handler_For_Ctrl_Operation): Remove the specialized processing for\n\t NET/JVM. These targets can now benefit from\n\tRaise_From_Controlled_Operation and they share the same processing with\n\tstandard targets.\n\n2011-08-04  Geert Bosch  <bosch@adacore.com>\n\n\t* tracebak.c (STOP_FRAME): Stop at any next pointer outside the stack\n\n2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Has_Visible_Private_Ancestor): subsidiary routine to\n\tExpand_Record_Aggregate, to determine whether aggregate must be\n\texpanded into assignments. This is the case if the ancestor part is\n\tprivate, regarless of the setting of the flag Has_Private_Ancestor.\n\n2011-08-04  Ed Falis  <falis@adacore.com>\n\n\t* vxaddr2line.adb: Add support for e500v2 and for Linux hosts\n\n2011-08-04  Bob Duff  <duff@adacore.com>\n\n\t* sinfo.ads: Fix comment.\n\n2011-08-04  Steve Baird  <baird@adacore.com>\n\n\t* bindgen.adb (Get_Ada_Main_Name): If CodePeer_Mode is set, then\n\tchoose a package name in much the same way as is\n\tdone for JGNAT when VM_Target /= No_VM, except that\n\ta slightly more distinctive prefix string is used.\n\n2011-08-04  Emmanuel Briot  <briot@adacore.com>\n\n\t* makeutl.adb (Complete_Mains): no longer accept unit names on the\n\tgnatmake command line.\n\tThis behavior was never documented (and was supported only because of\n\tan early bug in the code). This case might lead to ambiguous cases\n\t(between unit names and truncated base names without suffixes).\n\nFrom-SVN: r177379", "tree": {"sha": "39361a5755bcb3bd0cba43f0fae7414de9b2893a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39361a5755bcb3bd0cba43f0fae7414de9b2893a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/comments", "author": null, "committer": null, "parents": [{"sha": "87729e5ae139eab93fad42e938accc2890e63894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87729e5ae139eab93fad42e938accc2890e63894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87729e5ae139eab93fad42e938accc2890e63894"}], "stats": {"total": 332, "additions": 208, "deletions": 124}, "files": [{"sha": "62df17c5acd576b602385d1473584898303debaf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -1,3 +1,51 @@\n+2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Raise_Statement): Remove the specialized\n+\tprocessing for .NET/JVM. These targets can now benefit from\n+\tRaise_From_Controlled_Operation and they share the same processing with\n+\tstandard targets.\n+\t(Establish_Transient_Scope): Remove the restriction for .NET/JVM.\n+\tThese targets need transient scopes in order to properly finalize short\n+\tlived controlled objects.\n+\t(Make_Handler_For_Ctrl_Operation): Remove the specialized processing for\n+\t NET/JVM. These targets can now benefit from\n+\tRaise_From_Controlled_Operation and they share the same processing with\n+\tstandard targets.\n+\n+2011-08-04  Geert Bosch  <bosch@adacore.com>\n+\n+\t* tracebak.c (STOP_FRAME): Stop at any next pointer outside the stack\n+\n+2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Has_Visible_Private_Ancestor): subsidiary routine to\n+\tExpand_Record_Aggregate, to determine whether aggregate must be\n+\texpanded into assignments. This is the case if the ancestor part is\n+\tprivate, regarless of the setting of the flag Has_Private_Ancestor.\n+\n+2011-08-04  Ed Falis  <falis@adacore.com>\n+\n+\t* vxaddr2line.adb: Add support for e500v2 and for Linux hosts\n+\n+2011-08-04  Bob Duff  <duff@adacore.com>\n+\n+\t* sinfo.ads: Fix comment.\n+\n+2011-08-04  Steve Baird  <baird@adacore.com>\n+\n+\t* bindgen.adb (Get_Ada_Main_Name): If CodePeer_Mode is set, then\n+\tchoose a package name in much the same way as is\n+\tdone for JGNAT when VM_Target /= No_VM, except that\n+\ta slightly more distinctive prefix string is used.\n+\n+2011-08-04  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* makeutl.adb (Complete_Mains): no longer accept unit names on the\n+\tgnatmake command line.\n+\tThis behavior was never documented (and was supported only because of\n+\tan early bug in the code). This case might lead to ambiguous cases\n+\t(between unit names and truncated base names without suffixes).\n+\n 2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* a-tags.ads, a-tags.adb (Unregister_Tag): New routine."}, {"sha": "7ee7511687973173293fab3ddddeeec45ebf2508", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -3783,12 +3783,21 @@ package body Bindgen is\n    begin\n       --  The main program generated by JGNAT expects a package called\n       --  ada_<main procedure>.\n-\n       if VM_Target /= No_VM then\n          Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n          return \"ada_\" & Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len - 2));\n       end if;\n \n+      --  For CodePeer, we want reproducible names (independent of other\n+      --  mains that may or may not be present) that don't collide\n+      --  when analyzing multiple mains and which are easily recognizable\n+      --  as \"ada_main\" names.\n+      if CodePeer_Mode then\n+         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+         return \"ada_main_for_\" &\n+           Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len - 2));\n+      end if;\n+\n       --  This loop tries the following possibilities in order\n       --    <Ada_Main>\n       --    <Ada_Main>_01"}, {"sha": "d6b53d442f6cbc9d92f0131f09fb80e7fa2f70be", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -5178,6 +5178,33 @@ package body Exp_Aggr is\n       Comp      : Entity_Id;\n       New_Comp  : Node_Id;\n \n+      function Has_Visible_Private_Ancestor (Id : E) return Boolean;\n+      --  If any ancestor of the current type is private, the aggregate\n+      --  cannot be built in place. We canot rely on Has_Private_Ancestor,\n+      --  because it will not be set when type and its parent are in the\n+      --  same scope, and the parent component needs expansion.\n+\n+      -----------------------------------\n+      --  Has_Visible_Private_Ancestor --\n+      -----------------------------------\n+\n+      function Has_Visible_Private_Ancestor (Id : E) return Boolean is\n+         R  : constant Entity_Id := Root_Type (Id);\n+         T1 : Entity_Id := Id;\n+      begin\n+         loop\n+            if Is_Private_Type (T1) then\n+               return True;\n+\n+            elsif T1 = R then\n+               return False;\n+\n+            else\n+               T1 := Etype (T1);\n+            end if;\n+         end loop;\n+      end Has_Visible_Private_Ancestor;\n+\n    --  Start of processing for Expand_Record_Aggregate\n \n    begin\n@@ -5261,7 +5288,7 @@ package body Exp_Aggr is\n       --  If an ancestor is private, some components are not inherited and\n       --  we cannot expand into a record aggregate\n \n-      elsif Has_Private_Ancestor (Typ) then\n+      elsif Has_Visible_Private_Ancestor (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n       --  ??? The following was done to compile fxacc00.ads in the ACVCs. Gigi"}, {"sha": "a679c294c8930f5b4afbbc0b03cb5dfd24b67689", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -3064,15 +3064,10 @@ package body Exp_Ch7 is\n \n       Params := New_List (New_Reference_To (E_Id, Loc));\n \n-      --  .NET/JVM\n+      --  Standard run-time, .NET/JVM targets, this case handles finalization\n+      --  exceptions raised during an abort.\n \n-      if VM_Target /= No_VM then\n-         Proc_Id := RTE (RE_Reraise_Occurrence);\n-\n-      --  Standard run-time library, this case handles finalization exceptions\n-      --  raised during an abort.\n-\n-      elsif RTE_Available (RE_Raise_From_Controlled_Operation) then\n+      if RTE_Available (RE_Raise_From_Controlled_Operation) then\n          Proc_Id := RTE (RE_Raise_From_Controlled_Operation);\n          Append_To (Params, New_Reference_To (Abort_Id, Loc));\n \n@@ -3494,12 +3489,6 @@ package body Exp_Ch7 is\n       Wrap_Node : Node_Id;\n \n    begin\n-      --  Nothing to do for virtual machines where memory is GCed\n-\n-      if VM_Target /= No_VM then\n-         return;\n-      end if;\n-\n       --  Do not create a transient scope if we are already inside one\n \n       for S in reverse Scope_Stack.First .. Scope_Stack.Last loop\n@@ -3515,7 +3504,6 @@ package body Exp_Ch7 is\n \n          elsif Scope_Stack.Table (S).Entity = Standard_Standard then\n             exit;\n-\n          end if;\n       end loop;\n \n@@ -7228,23 +7216,12 @@ package body Exp_Ch7 is\n       --  Procedure call or raise statement\n \n    begin\n-      --  .NET/JVM runtime: add choice parameter E and pass it to Reraise_\n-      --  Occurrence.\n-\n-      if VM_Target /= No_VM then\n-         E_Occ := Make_Defining_Identifier (Loc, Name_E);\n-         Raise_Node :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Reference_To (RTE (RE_Reraise_Occurrence), Loc),\n-             Parameter_Associations => New_List (\n-               New_Reference_To (E_Occ, Loc)));\n-\n-      --  Standard runtime: add choice parameter E and pass it to Raise_From_\n-      --  Controlled_Operation so that the original exception name and message\n-      --  can be recorded in the exception message for Program_Error.\n+      --  Standard runtime, .NET/JVM targets: add choice parameter E and pass\n+      --  it to Raise_From_Controlled_Operation so that the original exception\n+      --  name and message can be recorded in the exception message for\n+      --  Program_Error.\n \n-      elsif RTE_Available (RE_Raise_From_Controlled_Operation) then\n+      if RTE_Available (RE_Raise_From_Controlled_Operation) then\n          E_Occ := Make_Defining_Identifier (Loc, Name_E);\n          Raise_Node :=\n            Make_Procedure_Call_Statement (Loc,"}, {"sha": "b51e7fb297fafadfa4e9993d50821deea486a0dd", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 48, "deletions": 65, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -1290,7 +1290,6 @@ package body Makeutl is\n \n          function Find_File_Add_Extension\n            (Tree         : Project_Tree_Ref;\n-            Root_Project : Project_Id;\n             Base_Main    : String) return Prj.Source_Id;\n          --  Search for Main in the project, adding body or spec extensions.\n \n@@ -1346,66 +1345,57 @@ package body Makeutl is\n \n          function Find_File_Add_Extension\n            (Tree         : Project_Tree_Ref;\n-            Root_Project : Project_Id;\n             Base_Main    : String) return Prj.Source_Id\n          is\n             Spec_Source : Prj.Source_Id := No_Source;\n             Source      : Prj.Source_Id;\n-            Project     : Project_Id;\n             Iter        : Source_Iterator;\n             Suffix      : File_Name_Type;\n \n          begin\n             Source  := No_Source;\n-            Project := Root_Project;\n-            while Source = No_Source\n-              and then Project /= No_Project\n+            Iter := For_Each_Source (Tree);  --  In all projects\n             loop\n-               Iter := For_Each_Source (Tree, Project);\n-               loop\n-                  Source := Prj.Element (Iter);\n-                  exit when Source = No_Source;\n+               Source := Prj.Element (Iter);\n+               exit when Source = No_Source;\n \n-                  if Source.Kind = Impl then\n-                     Get_Name_String (Source.File);\n+               if Source.Kind = Impl then\n+                  Get_Name_String (Source.File);\n \n-                     if Name_Len > Base_Main'Length\n-                       and then Name_Buffer (1 .. Base_Main'Length) = Base_Main\n-                     then\n-                        Suffix :=\n-                          Source.Language.Config.Naming_Data.Body_Suffix;\n+                  if Name_Len > Base_Main'Length\n+                    and then Name_Buffer (1 .. Base_Main'Length) = Base_Main\n+                  then\n+                     Suffix :=\n+                       Source.Language.Config.Naming_Data.Body_Suffix;\n \n-                        exit when Suffix /= No_File and then\n-                          Name_Buffer (Base_Main'Length + 1 .. Name_Len) =\n-                          Get_Name_String (Suffix);\n-                     end if;\n+                     exit when Suffix /= No_File and then\n+                       Name_Buffer (Base_Main'Length + 1 .. Name_Len) =\n+                       Get_Name_String (Suffix);\n+                  end if;\n \n-                  elsif Source.Kind = Spec then\n-                     --  A spec needs to be taken into account unless there is\n-                     --  also a body. So we delay the decision for them.\n+               elsif Source.Kind = Spec then\n+                  --  A spec needs to be taken into account unless there is\n+                  --  also a body. So we delay the decision for them.\n \n-                     Get_Name_String (Source.File);\n+                  Get_Name_String (Source.File);\n \n-                     if Name_Len > Base_Main'Length\n-                       and then Name_Buffer (1 .. Base_Main'Length) = Base_Main\n-                     then\n-                        Suffix :=\n-                          Source.Language.Config.Naming_Data.Spec_Suffix;\n+                  if Name_Len > Base_Main'Length\n+                    and then Name_Buffer (1 .. Base_Main'Length) = Base_Main\n+                  then\n+                     Suffix :=\n+                       Source.Language.Config.Naming_Data.Spec_Suffix;\n \n-                        if Suffix /= No_File\n-                          and then\n-                            Name_Buffer (Base_Main'Length + 1 .. Name_Len) =\n-                            Get_Name_String (Suffix)\n-                        then\n-                           Spec_Source := Source;\n-                        end if;\n+                     if Suffix /= No_File\n+                       and then\n+                         Name_Buffer (Base_Main'Length + 1 .. Name_Len) =\n+                         Get_Name_String (Suffix)\n+                     then\n+                        Spec_Source := Source;\n                      end if;\n                   end if;\n+               end if;\n \n-                  Next (Iter);\n-               end loop;\n-\n-               Project := Project.Extends;\n+               Next (Iter);\n             end loop;\n \n             if Source = No_Source then\n@@ -1496,7 +1486,7 @@ package body Makeutl is\n \n                         if Source = No_Source then\n                            Source := Find_File_Add_Extension\n-                             (Tree, File.Project, Get_Name_String (Main_Id));\n+                             (Tree, Get_Name_String (Main_Id));\n                         end if;\n \n                         if Is_Absolute\n@@ -1510,29 +1500,6 @@ package body Makeutl is\n                            Source := No_Source;\n                         end if;\n \n-                        if Source = No_Source\n-                          and then not Is_Absolute\n-                        then\n-\n-                           --  Still not found? Maybe we have a unit name\n-\n-                           declare\n-                              Unit : constant Unit_Index :=\n-                                       Units_Htable.Get\n-                                         (File.Tree.Units_HT,\n-                                          Name_Id (Main_Id));\n-\n-                           begin\n-                              if Unit /= No_Unit_Index then\n-                                 Source := Unit.File_Names (Impl);\n-\n-                                 if Source = No_Source then\n-                                    Source := Unit.File_Names (Spec);\n-                                 end if;\n-                              end if;\n-                           end;\n-                        end if;\n-\n                         if Source /= No_Source then\n \n                            --  If we have found a multi-unit source file but\n@@ -2988,6 +2955,22 @@ package body Makeutl is\n                         Shared                  => Project_Tree.Shared,\n                         Force_Lower_Case_Index  => False,\n                         Allow_Wildcards         => True);\n+\n+                     --  If not found, try without extension.\n+                     --  That's because gnatmake accepts truncated file names\n+                     --  in Builder'Switches\n+\n+                     if Switches_For_Main = Nil_Variable_Value\n+                       and then Source.Unit /= null\n+                     then\n+                        Switches_For_Main := Value_Of\n+                          (Name                    => Source.Unit.Name,\n+                           Attribute_Or_Array_Name => Name_Switches,\n+                           In_Package              => Builder_Package,\n+                           Shared                  => Project_Tree.Shared,\n+                           Force_Lower_Case_Index  => False,\n+                           Allow_Wildcards         => True);\n+                     end if;\n                   end if;\n \n                   if Index = 1 then"}, {"sha": "a7134754a6ebc68d3bd058bf88d880fab9c9c518", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -5894,23 +5894,32 @@ package Sinfo is\n       --  used only internally currently, but is considered to be syntactic.\n       --  At the moment, the only cleanup action allowed is a single call to\n       --  a parameterless procedure, and the Identifier field of the node is\n-      --  the procedure to be called. Also there is a current restriction\n-      --  that exception handles and a cleanup cannot be present in the same\n-      --  frame, so at least one of Exception_Handlers or the Identifier must\n-      --  be missing.\n-\n-      --  Actually, more accurately, this restriction applies to the original\n-      --  source program. In the expanded tree, if the At_End_Proc field is\n-      --  present, then there will also be an exception handler of the form:\n+      --  the procedure to be called. The cleanup action occurs whenever the\n+      --  sequence of statements is left for any reason. The possible reasons\n+      --  are:\n+      --      1. reaching the end of the sequence\n+      --      2. exit, return, or goto\n+      --      3. exception or abort\n+      --  For some back ends, such as gcc with ZCX, \"at end\" is implemented\n+      --  entirely in the back end. In this case, a handled sequence of\n+      --  statements with an \"at end\" cannot also have exception handlers.\n+      --  For other back ends, such as gcc with SJLJ and .NET, the\n+      --  implementation is split between the front end and back end; the front\n+      --  end implements 3, and the back end implements 1 and 2. In this case,\n+      --  if there is an \"at end\", the front end inserts the appropriate\n+      --  exception handler, and this handler takes precedence over \"at end\"\n+      --  in case of exception.\n+\n+      --  The inserted exception handler is of the form:\n \n       --     when all others =>\n       --        cleanup;\n       --        raise;\n \n-      --  where cleanup is the procedure to be generated. The reason we do\n-      --  this is so that the front end can handle the necessary entries in\n-      --  the exception tables, and other exception handler actions required\n-      --  as part of the normal handling for exception handlers.\n+      --  where cleanup is the procedure to be called. The reason we do this is\n+      --  so that the front end can handle the necessary entries in the\n+      --  exception tables, and other exception handler actions required as\n+      --  part of the normal handling for exception handlers.\n \n       --  The AT END cleanup handler protects only the sequence of statements\n       --  (not the associated declarations of the parent), just like exception"}, {"sha": "eedc715a2e5faded4dda03c9938373f4e1653280", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -339,7 +339,8 @@ struct layout\n #define STOP_FRAME(CURRENT, TOP_STACK) \\\n   (IS_BAD_PTR((long)(CURRENT)) \\\n    || IS_BAD_PTR((long)(CURRENT)->return_address) \\\n-   || (CURRENT)->return_address == 0|| (CURRENT)->next == 0  \\\n+   || (CURRENT)->return_address == 0 \\\n+   || (void *) ((CURRENT)->next) < (TOP_STACK)  \\\n    || (void *) (CURRENT) < (TOP_STACK))\n \n #define BASE_SKIP (1+FRAME_LEVEL)"}, {"sha": "028de5e5fbf49cf69705a28a3b4229fefeadb850", "filename": "gcc/ada/vxaddr2line.adb", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fvxaddr2line.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071/gcc%2Fada%2Fvxaddr2line.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvxaddr2line.adb?ref=7ae0d98c02dda4cbf0d3c9cac19a7358f8b53071", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2009, AdaCore                     --\n+--                     Copyright (C) 2002-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -83,12 +83,17 @@ procedure VxAddr2Line is\n \n    --  All supported architectures\n    type Architecture is\n-     (SOLARIS_I586,\n-      WINDOWS_POWERPC,\n+     (DEC_ALPHA,\n+      LINUX_E500V2,\n+      LINUX_I586,\n+      LINUX_POWERPC,\n+      WINDOWS_E500V2,\n       WINDOWS_I586,\n       WINDOWS_M68K,\n-      SOLARIS_POWERPC,\n-      DEC_ALPHA);\n+      WINDOWS_POWERPC,\n+      SOLARIS_E500V2,\n+      SOLARIS_I586,\n+      SOLARIS_POWERPC);\n \n    type Arch_Record is record\n       Addr2line_Binary : String_Access;\n@@ -114,17 +119,32 @@ procedure VxAddr2Line is\n \n    --  Configuration for each of the architectures\n    Arch_List : array (Architecture'Range) of Arch_Record :=\n-     (WINDOWS_POWERPC =>\n+     (DEC_ALPHA =>\n+        (Addr2line_Binary    => null,\n+         Nm_Binary           => null,\n+         Addr_Digits_To_Skip => 8,\n+         Bt_Offset_From_Call => 0),\n+      LINUX_E500V2 =>\n         (Addr2line_Binary    => null,\n          Nm_Binary           => null,\n          Addr_Digits_To_Skip => 0,\n          Bt_Offset_From_Call => -4),\n-      WINDOWS_M68K =>\n+      LINUX_I586 =>\n+        (Addr2line_Binary    => null,\n+         Nm_Binary           => null,\n+         Addr_Digits_To_Skip => 0,\n+         Bt_Offset_From_Call => -2),\n+      LINUX_POWERPC =>\n         (Addr2line_Binary    => null,\n          Nm_Binary           => null,\n          Addr_Digits_To_Skip => 0,\n          Bt_Offset_From_Call => -4),\n-      WINDOWS_I586 =>\n+      SOLARIS_E500V2 =>\n+        (Addr2line_Binary    => null,\n+         Nm_Binary           => null,\n+         Addr_Digits_To_Skip => 0,\n+         Bt_Offset_From_Call => -4),\n+      SOLARIS_I586 =>\n         (Addr2line_Binary    => null,\n          Nm_Binary           => null,\n          Addr_Digits_To_Skip => 0,\n@@ -133,17 +153,27 @@ procedure VxAddr2Line is\n         (Addr2line_Binary    => null,\n          Nm_Binary           => null,\n          Addr_Digits_To_Skip => 0,\n-         Bt_Offset_From_Call => 0),\n-      SOLARIS_I586 =>\n+         Bt_Offset_From_Call => -4),\n+      WINDOWS_E500V2 =>\n+        (Addr2line_Binary    => null,\n+         Nm_Binary           => null,\n+         Addr_Digits_To_Skip => 0,\n+         Bt_Offset_From_Call => -4),\n+      WINDOWS_I586 =>\n         (Addr2line_Binary    => null,\n          Nm_Binary           => null,\n          Addr_Digits_To_Skip => 0,\n          Bt_Offset_From_Call => -2),\n-      DEC_ALPHA =>\n+      WINDOWS_M68K =>\n         (Addr2line_Binary    => null,\n          Nm_Binary           => null,\n-         Addr_Digits_To_Skip => 8,\n-         Bt_Offset_From_Call => 0)\n+         Addr_Digits_To_Skip => 0,\n+         Bt_Offset_From_Call => -4),\n+      WINDOWS_POWERPC =>\n+        (Addr2line_Binary    => null,\n+         Nm_Binary           => null,\n+         Addr_Digits_To_Skip => 0,\n+         Bt_Offset_From_Call => -4)\n      );\n \n    --  Current architecture"}]}