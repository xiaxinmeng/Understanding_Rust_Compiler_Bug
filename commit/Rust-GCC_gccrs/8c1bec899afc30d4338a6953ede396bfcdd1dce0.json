{"sha": "8c1bec899afc30d4338a6953ede396bfcdd1dce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxYmVjODk5YWZjMzBkNDMzOGE2OTUzZWRlMzk2YmZjZGQxZGNlMA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2020-03-04T19:22:44Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-11T09:53:37Z"}, "message": "[Ada] Crash on dispatching conditional entry call\n\n2020-06-11  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch9.adb (Expand_N_Conditional_Entry_Call): Replace call to\n\tNew_Copy_List by calls to the new routine\n\tNew_Copy_Separate_List.\n\t* sem_util.ads (New_Copy_Separate_List, New_Copy_Separate_Tree):\n\tNew routines.\n\n\t* sem_util.adb (New_Copy_Separate_List, New_Copy_Separate_Tree):\n\tNew routines.\n\t(New_Copy_Tree): Extend the machinery that detects syntactic\n\tnodes to handle lists of indentifiers with field More_Ids;\n\totherwise such nodes are erroneously handled as semantic nodes.\n\tCopy aspect specifications attached to nodes.\n\t* sem_ch12.adb (Copy_Generic_Node): Protect reading attribute\n\tEtype.", "tree": {"sha": "c54ae48ddeea24461c2829c54d590c7cc737c18e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c54ae48ddeea24461c2829c54d590c7cc737c18e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c1bec899afc30d4338a6953ede396bfcdd1dce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1bec899afc30d4338a6953ede396bfcdd1dce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1bec899afc30d4338a6953ede396bfcdd1dce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1bec899afc30d4338a6953ede396bfcdd1dce0/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dd9f1b83fd8349556b5397002e505a873b866aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd9f1b83fd8349556b5397002e505a873b866aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dd9f1b83fd8349556b5397002e505a873b866aa"}], "stats": {"total": 193, "additions": 190, "deletions": 3}, "files": [{"sha": "49d3c1f324b4985413d2c4abe5c970d1385e492e", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8c1bec899afc30d4338a6953ede396bfcdd1dce0", "patch": "@@ -8124,7 +8124,7 @@ package body Exp_Ch9 is\n          --       <else-statements>\n          --    end if;\n \n-         N_Stats := New_Copy_List_Tree (Statements (Alt));\n+         N_Stats := New_Copy_Separate_List (Statements (Alt));\n \n          Prepend_To (N_Stats,\n            Make_Implicit_If_Statement (N,\n@@ -8168,7 +8168,7 @@ package body Exp_Ch9 is\n          --    <dispatching-call>;\n          --    <triggering-statements>\n \n-         Lim_Typ_Stmts := New_Copy_List_Tree (Statements (Alt));\n+         Lim_Typ_Stmts := New_Copy_Separate_List (Statements (Alt));\n          Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (Blk));\n \n          --  Generate:"}, {"sha": "93a3ca59d5cdf64280443c9bfa985838d2a05507", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8c1bec899afc30d4338a6953ede396bfcdd1dce0", "patch": "@@ -8098,6 +8098,7 @@ package body Sem_Ch12 is\n                      elsif Nkind (Assoc) = N_Identifier\n                        and then Nkind (Parent (Assoc)) = N_Type_Conversion\n                        and then Subtype_Mark (Parent (Assoc)) = Assoc\n+                       and then Present (Etype (Assoc))\n                        and then Is_Access_Type (Etype (Assoc))\n                        and then Present (Etype (Expression (Parent (Assoc))))\n                        and then"}, {"sha": "cce55a6c58ae1d73ffec86e9b795ee1a7f0f81c5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8c1bec899afc30d4338a6953ede396bfcdd1dce0", "patch": "@@ -20323,6 +20323,118 @@ package body Sem_Util is\n       end if;\n    end New_Copy_List_Tree;\n \n+   ----------------------------\n+   -- New_Copy_Separate_List --\n+   ----------------------------\n+\n+   function New_Copy_Separate_List (List : List_Id) return List_Id is\n+   begin\n+      if List = No_List then\n+         return No_List;\n+\n+      else\n+         declare\n+            List_Copy : constant List_Id := New_List;\n+            N         : Node_Id := First (List);\n+\n+         begin\n+            while Present (N) loop\n+               Append (New_Copy_Separate_Tree (N), List_Copy);\n+               Next (N);\n+            end loop;\n+\n+            return List_Copy;\n+         end;\n+      end if;\n+   end New_Copy_Separate_List;\n+\n+   ----------------------------\n+   -- New_Copy_Separate_Tree --\n+   ----------------------------\n+\n+   function New_Copy_Separate_Tree (Source : Node_Id) return Node_Id is\n+      function Search_Decl (N : Node_Id) return Traverse_Result;\n+      --  Subtree visitor which collects declarations\n+\n+      procedure Search_Declarations is new Traverse_Proc (Search_Decl);\n+      --  Subtree visitor instantiation\n+\n+      -----------------\n+      -- Search_Decl --\n+      -----------------\n+\n+      Decls : Elist_Id;\n+\n+      function Search_Decl (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) in N_Declaration then\n+            if No (Decls) then\n+               Decls := New_Elmt_List;\n+            end if;\n+\n+            Append_Elmt (N, Decls);\n+         end if;\n+\n+         return OK;\n+      end Search_Decl;\n+\n+      --  Local variables\n+\n+      Source_Copy : constant Node_Id := New_Copy_Tree (Source);\n+\n+   --  Start of processing for New_Copy_Separate_Tree\n+\n+   begin\n+      Decls := No_Elist;\n+      Search_Declarations (Source_Copy);\n+\n+      --  Associate a new Entity with all the subtree declarations (keeping\n+      --  their original name).\n+\n+      if Present (Decls) then\n+         declare\n+            Elmt  : Elmt_Id;\n+            Decl  : Node_Id;\n+            New_E : Entity_Id;\n+\n+         begin\n+            Elmt := First_Elmt (Decls);\n+            while Present (Elmt) loop\n+               Decl  := Node (Elmt);\n+               New_E := Make_Defining_Identifier (Sloc (Decl),\n+                          New_Internal_Name ('P'));\n+\n+               if Nkind (Decl) = N_Expression_Function then\n+                  Decl := Specification (Decl);\n+               end if;\n+\n+               if Nkind_In (Decl, N_Function_Instantiation,\n+                                  N_Function_Specification,\n+                                  N_Generic_Function_Renaming_Declaration,\n+                                  N_Generic_Package_Renaming_Declaration,\n+                                  N_Generic_Procedure_Renaming_Declaration,\n+                                  N_Package_Body,\n+                                  N_Package_Instantiation,\n+                                  N_Package_Renaming_Declaration,\n+                                  N_Package_Specification,\n+                                  N_Procedure_Instantiation,\n+                                  N_Procedure_Specification)\n+               then\n+                  Set_Chars (New_E, Chars (Defining_Unit_Name (Decl)));\n+                  Set_Defining_Unit_Name (Decl, New_E);\n+               else\n+                  Set_Chars (New_E, Chars (Defining_Identifier (Decl)));\n+                  Set_Defining_Identifier (Decl, New_E);\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end;\n+      end if;\n+\n+      return Source_Copy;\n+   end New_Copy_Separate_Tree;\n+\n    -------------------\n    -- New_Copy_Tree --\n    -------------------\n@@ -20751,6 +20863,65 @@ package body Sem_Util is\n          New_Par  : Node_Id := Empty;\n          Semantic : Boolean := False) return Union_Id\n       is\n+         function Has_More_Ids (N : Node_Id) return Boolean;\n+         --  Return True when N has attribute More_Ids set to True\n+\n+         function Is_Syntactic_Node return Boolean;\n+         --  Return True when Field is a syntactic node\n+\n+         ------------------\n+         -- Has_More_Ids --\n+         ------------------\n+\n+         function Has_More_Ids (N : Node_Id) return Boolean is\n+         begin\n+            if Nkind_In (N, N_Component_Declaration,\n+                            N_Discriminant_Specification,\n+                            N_Exception_Declaration,\n+                            N_Formal_Object_Declaration,\n+                            N_Number_Declaration,\n+                            N_Object_Declaration,\n+                            N_Parameter_Specification,\n+                            N_Use_Package_Clause,\n+                            N_Use_Type_Clause)\n+            then\n+               return More_Ids (N);\n+            else\n+               return False;\n+            end if;\n+         end Has_More_Ids;\n+\n+         -----------------------\n+         -- Is_Syntactic_Node --\n+         -----------------------\n+\n+         function Is_Syntactic_Node return Boolean is\n+            Old_N : constant Node_Id := Node_Id (Field);\n+\n+         begin\n+            if Parent (Old_N) = Old_Par then\n+               return True;\n+\n+            elsif not Has_More_Ids (Old_Par) then\n+               return False;\n+\n+            --  Perform the check using the last last id in the syntactic chain\n+\n+            else\n+               declare\n+                  N : Node_Id := Old_Par;\n+\n+               begin\n+                  while Present (N) and then More_Ids (N) loop\n+                     Next (N);\n+                  end loop;\n+\n+                  pragma Assert (Prev_Ids (N));\n+                  return Parent (Old_N) = N;\n+               end;\n+            end if;\n+         end Is_Syntactic_Node;\n+\n       begin\n          --  The field is empty\n \n@@ -20762,7 +20933,7 @@ package body Sem_Util is\n          elsif Field in Node_Range then\n             declare\n                Old_N     : constant Node_Id := Node_Id (Field);\n-               Syntactic : constant Boolean := Parent (Old_N) = Old_Par;\n+               Syntactic : constant Boolean := Is_Syntactic_Node;\n \n                New_N : Node_Id;\n \n@@ -20990,6 +21161,11 @@ package body Sem_Util is\n                   Set_Chars (Result, Chars (Entity (Result)));\n                end if;\n             end if;\n+\n+            if Has_Aspects (N) then\n+               Set_Aspect_Specifications (Result,\n+                 Copy_List_With_Replacement (Aspect_Specifications (N)));\n+            end if;\n          end if;\n \n          return Result;"}, {"sha": "b794e8098224710efee6c1a1a85fa3569e518c8a", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1bec899afc30d4338a6953ede396bfcdd1dce0/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8c1bec899afc30d4338a6953ede396bfcdd1dce0", "patch": "@@ -2291,6 +2291,16 @@ package Sem_Util is\n    --  below. As for New_Copy_Tree, it is illegal to attempt to copy extended\n    --  nodes (entities) either directly or indirectly using this function.\n \n+   function New_Copy_Separate_List (List : List_Id) return List_Id;\n+   --  Copy recursively a list of nodes using New_Copy_Separate_Tree\n+\n+   function New_Copy_Separate_Tree (Source : Node_Id) return Node_Id;\n+   --  Perform a deep copy of the subtree rooted at Source using New_Copy_Tree\n+   --  replacing entities of local declarations by new entities. This behavior\n+   --  is required by the backend to ensure entities uniqueness when a copy of\n+   --  a subtree is attached to the tree. The new entities keep their original\n+   --  names to facilitate debugging the tree copy.\n+\n    function New_Copy_Tree\n      (Source           : Node_Id;\n       Map              : Elist_Id   := No_Elist;"}]}