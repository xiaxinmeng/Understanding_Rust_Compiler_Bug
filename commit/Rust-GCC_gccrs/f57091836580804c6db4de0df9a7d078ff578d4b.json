{"sha": "f57091836580804c6db4de0df9a7d078ff578d4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3MDkxODM2NTgwODA0YzZkYjRkZTBkZjlhN2QwNzhmZjU3OGQ0Yg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2012-03-15T16:36:48Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-03-15T16:36:48Z"}, "message": "tree-vectorizer.h (vect_pattern_recog): Add new argument.\n\nChangeLog:\n\n\t* tree-vectorizer.h (vect_pattern_recog): Add new argument.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Update call to\n\tvect_pattern_recog.\n\t* tree-vect-patterns.c (widened_name_p): Pass basic block\n\tinfo to vect_is_simple_use.\n\t(vect_recog_dot_prod_pattern): Fail for basic blocks.\n\t(vect_recog_widen_sum_pattern): Likewise.\n\t(vect_handle_widen_op_by_const): Support basic blocks.\n\t(vect_operation_fits_smaller_type,\n\tvect_recog_over_widening_pattern): Likewise.\n\t(vect_recog_vector_vector_shift_pattern): Support basic blocks.\n\tUpdate call to vect_is_simple_use.\n\t(vect_recog_mixed_size_cond_pattern): Support basic blocks.\n\tAdd printing.\n\t(check_bool_pattern): Add an argument, update call to\n\tvect_is_simple_use and the recursive calls.\n\t(vect_recog_bool_pattern): Update relevant function calls.\n\tAdd printing.\n\t(vect_mark_pattern_stmts): Update calls to new_stmt_vec_info.\n\t(vect_pattern_recog_1): Check for reduction only in loops.\n\t(vect_pattern_recog): Add new argument.  Support basic blocks.\n\t* tree-vect-stmts.c (vectorizable_conversion): Pass basic block\n\tinfo to vect_is_simple_use_1.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Support basic\n\tblocks.\n\t(vect_slp_analyze_bb_1): Call vect_pattern_recog.\n\ntestsuite/ChangeLog:\n\n\t* gcc.dg/vect/bb-slp-pattern-1.c: New test.\n\t* gcc.dg/vect/bb-slp-pattern-2.c: New test.\n\nCo-Authored-By: Ulrich Weigand <ulrich.weigand@linaro.org>\n\nFrom-SVN: r185436", "tree": {"sha": "2a28d3a8b37d54e3f51817138fc3f5a2fee20af8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a28d3a8b37d54e3f51817138fc3f5a2fee20af8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57091836580804c6db4de0df9a7d078ff578d4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57091836580804c6db4de0df9a7d078ff578d4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57091836580804c6db4de0df9a7d078ff578d4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57091836580804c6db4de0df9a7d078ff578d4b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37b659dd29908f5b5320f15fbe89f5c560d62464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b659dd29908f5b5320f15fbe89f5c560d62464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b659dd29908f5b5320f15fbe89f5c560d62464"}], "stats": {"total": 309, "additions": 266, "deletions": 43}, "files": [{"sha": "04751862a855654a9872f4fbb8f8b79de6380091", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -1,3 +1,33 @@\n+2012-03-15  Ira Rosen  <irar@il.ibm.com>\n+\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* tree-vectorizer.h (vect_pattern_recog): Add new argument.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Update call to\n+\tvect_pattern_recog.\n+\t* tree-vect-patterns.c (widened_name_p): Pass basic block\n+\tinfo to vect_is_simple_use.\n+\t(vect_recog_dot_prod_pattern): Fail for basic blocks.\n+\t(vect_recog_widen_sum_pattern): Likewise.\n+\t(vect_handle_widen_op_by_const): Support basic blocks.\n+\t(vect_operation_fits_smaller_type,\n+\tvect_recog_over_widening_pattern): Likewise.\n+\t(vect_recog_vector_vector_shift_pattern): Support basic blocks.\n+\tUpdate call to vect_is_simple_use.\n+\t(vect_recog_mixed_size_cond_pattern): Support basic blocks.\n+\tAdd printing.\n+\t(check_bool_pattern): Add an argument, update call to\n+\tvect_is_simple_use and the recursive calls.\n+\t(vect_recog_bool_pattern): Update relevant function calls.\n+\tAdd printing.\n+\t(vect_mark_pattern_stmts): Update calls to new_stmt_vec_info.\n+\t(vect_pattern_recog_1): Check for reduction only in loops.\n+\t(vect_pattern_recog): Add new argument.  Support basic blocks.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Pass basic block\n+\tinfo to vect_is_simple_use_1.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Support basic\n+\tblocks.\n+\t(vect_slp_analyze_bb_1): Call vect_pattern_recog.\n+\n 2012-03-15  Jakub Jelinek  <jakub@redhat.com>\n \t    Andrew Pinski  <apinski@cavium.com>\n "}, {"sha": "dd803871bc21a3506fc1b81547c490c23dacb0bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -1,3 +1,9 @@\n+2012-03-15  Ira Rosen  <irar@il.ibm.com>\n+\t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* gcc.dg/vect/bb-slp-pattern-1.c: New test.\n+\t* gcc.dg/vect/bb-slp-pattern-2.c: New test.\n+\n 2012-03-15  Janne Blomqvist  <jb@gcc.gnu.org>\n \n         PR libfortran/52434"}, {"sha": "ff520c06f5265b5a421481617eae5d0d8bed1953", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pattern-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pattern-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pattern-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pattern-1.c?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+\n+unsigned short X[N];\n+unsigned short Y[N];\n+unsigned int result[N];\n+\n+/* unsigned short->unsigned int widening-mult.  */\n+__attribute__ ((noinline, noclone)) void\n+foo (void)\n+{\n+  result[0] = (unsigned int) (X[0] * Y[0]);\n+  result[1] = (unsigned int) (X[1] * Y[1]);\n+  result[2] = (unsigned int) (X[2] * Y[2]);\n+  result[3] = (unsigned int) (X[3] * Y[3]);\n+  result[4] = (unsigned int) (X[4] * Y[4]);\n+  result[5] = (unsigned int) (X[5] * Y[5]);\n+  result[6] = (unsigned int) (X[6] * Y[6]);\n+  result[7] = (unsigned int) (X[7] * Y[7]);\n+}\n+\n+int main (void)\n+{\n+  int i, tmp;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      X[i] = i;\n+      Y[i] = 64-i;\n+    }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      tmp = X[i] * Y[i];\n+      if (result[i] != tmp)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"slp\" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 8 \"slp\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 8 \"slp\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */"}, {"sha": "30fa487cbf6a6303673901e2c4cf4d0c67cb4003", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pattern-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pattern-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pattern-2.c?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+__attribute__((noinline, noclone)) void\n+foo (short * __restrict__ a, int * __restrict__ b, int stride)\n+{\n+  int i;\n+\n+  for (i = 0; i < N/stride; i++, a += stride, b += stride)\n+   {\n+     a[0] = b[0] ? 1 : 7;\n+     a[1] = b[1] ? 2 : 0;\n+     a[2] = b[2] ? 3 : 0;\n+     a[3] = b[3] ? 4 : 0;\n+     a[4] = b[4] ? 5 : 0;\n+     a[5] = b[5] ? 6 : 0;\n+     a[6] = b[6] ? 7 : 0;\n+     a[7] = b[7] ? 8 : 0;\n+   }\n+}\n+\n+short a[N];\n+int b[N];\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = -i;\n+    }\n+\n+  foo (a, b, 8);\n+\n+  for (i = 1; i < N; i++)\n+    if (a[i] != i%8 + 1)\n+      abort ();\n+\n+  if (a[0] != 7)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target { vect_element_align && vect_pack_trunc } } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */"}, {"sha": "5733bc8d24465c8416bc838086bde1b85a7b0d48", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -1514,7 +1514,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n \n   vect_analyze_scalar_cycles (loop_vinfo);\n \n-  vect_pattern_recog (loop_vinfo);\n+  vect_pattern_recog (loop_vinfo, NULL);\n \n   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */\n "}, {"sha": "8772c0a9893df6ada1fdca204c1962ce8a63594f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 111, "deletions": 34, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -105,12 +105,13 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n   tree oprnd0;\n   enum vect_def_type dt;\n   tree def;\n+  bb_vec_info bb_vinfo;\n \n   stmt_vinfo = vinfo_for_stmt (use_stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-\n-  if (!vect_is_simple_use (name, use_stmt, loop_vinfo, NULL, def_stmt, &def,\n-\t\t\t   &dt))\n+  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  if (!vect_is_simple_use (name, use_stmt, loop_vinfo, bb_vinfo, def_stmt,\n+\t\t\t   &def, &dt))\n     return false;\n \n   if (dt != vect_internal_def\n@@ -135,7 +136,7 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n     return false;\n \n   if (!vect_is_simple_use (oprnd0, *def_stmt, loop_vinfo,\n-\t\t\t   NULL, &dummy_gimple, &dummy, &dt))\n+\t\t\t   bb_vinfo, &dummy_gimple, &dummy, &dt))\n     return false;\n \n   return true;\n@@ -211,9 +212,14 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   gimple pattern_stmt;\n   tree prod_type;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n+  struct loop *loop;\n   tree var;\n \n+  if (!loop_info)\n+    return NULL;\n+\n+  loop = LOOP_VINFO_LOOP (loop_info);\n+\n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n \n@@ -383,8 +389,16 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n {\n   tree new_type, new_oprnd, tmp;\n   gimple new_stmt;\n-  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt));\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n+  loop_vec_info loop_vinfo;\n+  struct loop *loop = NULL;\n+  bb_vec_info bb_vinfo;\n+  stmt_vec_info stmt_vinfo;\n+\n+  stmt_vinfo = vinfo_for_stmt (stmt);\n+  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (code != MULT_EXPR && code != LSHIFT_EXPR)\n     return false;\n@@ -402,7 +416,9 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n \n   if (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 4)\n       || !gimple_bb (def_stmt)\n-      || !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n+      || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n+      || (!loop && gimple_bb (def_stmt) != BB_VINFO_BB (bb_vinfo)\n+\t  && gimple_code (def_stmt) != GIMPLE_PHI)\n       || !vinfo_for_stmt (def_stmt))\n     return false;\n \n@@ -798,9 +814,14 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   tree type, half_type;\n   gimple pattern_stmt;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n+  struct loop *loop;\n   tree var;\n \n+  if (!loop_info)\n+    return NULL;\n+\n+  loop = LOOP_VINFO_LOOP (loop_info);\n+\n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n \n@@ -899,7 +920,11 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n   gimple def_stmt, new_stmt;\n   bool first = false;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (vinfo_for_stmt (stmt));\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n+  bb_vec_info bb_info = STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt));\n+  struct loop *loop = NULL;\n+\n+  if (loop_info)\n+    loop = LOOP_VINFO_LOOP (loop_info);\n \n   *op0 = NULL_TREE;\n   *op1 = NULL_TREE;\n@@ -933,7 +958,9 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n       first = true;\n       if (!widened_name_p (oprnd, stmt, &half_type, &def_stmt, false)\n           || !gimple_bb (def_stmt)\n-          || !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n+          || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n+\t  || (!loop && gimple_bb (def_stmt) != BB_VINFO_BB (bb_info)\n+\t      && gimple_code (def_stmt) != GIMPLE_PHI)\n           || !vinfo_for_stmt (def_stmt))\n         return false;\n     }\n@@ -1107,8 +1134,17 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n   int nuses = 0;\n   tree var = NULL_TREE, new_type = NULL_TREE, tmp, new_oprnd;\n   bool first;\n-  struct loop *loop = (gimple_bb (stmt))->loop_father;\n   tree type = NULL;\n+  loop_vec_info loop_vinfo;\n+  struct loop *loop = NULL;\n+  bb_vec_info bb_vinfo;\n+  stmt_vec_info stmt_vinfo;\n+\n+  stmt_vinfo = vinfo_for_stmt (stmt);\n+  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   first = true;\n   while (1)\n@@ -1141,7 +1177,8 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n \n       if (nuses != 1 || !is_gimple_assign (use_stmt)\n           || !gimple_bb (use_stmt)\n-          || !flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+          || (loop && !flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+\t  || (!loop && gimple_bb (use_stmt) != BB_VINFO_BB (bb_vinfo)))\n         return NULL;\n \n       /* Create pattern statement for STMT.  */\n@@ -1518,6 +1555,7 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n   enum vect_def_type dt;\n   tree def;\n \n@@ -1551,7 +1589,7 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n \t != TYPE_PRECISION (TREE_TYPE (oprnd0)))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, last_stmt, loop_vinfo, NULL, &def_stmt,\n+  if (!vect_is_simple_use (oprnd1, last_stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t   &def, &dt))\n     return NULL;\n \n@@ -1840,6 +1878,7 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   enum machine_mode cmpmode;\n   gimple pattern_stmt, def_stmt;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n \n   if (!is_gimple_assign (last_stmt)\n       || gimple_assign_rhs_code (last_stmt) != COND_EXPR\n@@ -1907,12 +1946,15 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n \t\t\t\t    gimple_assign_lhs (def_stmt), NULL_TREE);\n \n   new_pattern_def_seq (stmt_vinfo, def_stmt);\n-  def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+  def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n   set_vinfo_for_stmt (def_stmt, def_stmt_info);\n   STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n   *type_in = vecitype;\n   *type_out = vectype;\n \n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_recog_mixed_size_cond_pattern: detected: \");\n+\n   return pattern_stmt;\n }\n \n@@ -1921,14 +1963,15 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n    true if bool VAR can be optimized that way.  */\n \n static bool\n-check_bool_pattern (tree var, loop_vec_info loop_vinfo)\n+check_bool_pattern (tree var, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n   gimple def_stmt;\n   enum vect_def_type dt;\n   tree def, rhs1;\n   enum tree_code rhs_code;\n \n-  if (!vect_is_simple_use (var, NULL, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (var, NULL, loop_vinfo, bb_vinfo, &def_stmt, &def,\n+\t\t\t   &dt))\n     return false;\n \n   if (dt != vect_internal_def)\n@@ -1945,24 +1988,25 @@ check_bool_pattern (tree var, loop_vec_info loop_vinfo)\n   switch (rhs_code)\n     {\n     case SSA_NAME:\n-      return check_bool_pattern (rhs1, loop_vinfo);\n+      return check_bool_pattern (rhs1, loop_vinfo, bb_vinfo);\n \n     CASE_CONVERT:\n       if ((TYPE_PRECISION (TREE_TYPE (rhs1)) != 1\n \t   || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n \t  && TREE_CODE (TREE_TYPE (rhs1)) != BOOLEAN_TYPE)\n \treturn false;\n-      return check_bool_pattern (rhs1, loop_vinfo);\n+      return check_bool_pattern (rhs1, loop_vinfo, bb_vinfo);\n \n     case BIT_NOT_EXPR:\n-      return check_bool_pattern (rhs1, loop_vinfo);\n+      return check_bool_pattern (rhs1, loop_vinfo, bb_vinfo);\n \n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      if (!check_bool_pattern (rhs1, loop_vinfo))\n+      if (!check_bool_pattern (rhs1, loop_vinfo, bb_vinfo))\n \treturn false;\n-      return check_bool_pattern (gimple_assign_rhs2 (def_stmt), loop_vinfo);\n+      return check_bool_pattern (gimple_assign_rhs2 (def_stmt), loop_vinfo,\n+\t\t\t\t bb_vinfo);\n \n     default:\n       if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n@@ -2260,6 +2304,7 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   tree var, lhs, rhs, vectype;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n   gimple pattern_stmt;\n \n   if (!is_gimple_assign (last_stmt))\n@@ -2283,7 +2328,7 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n-      if (!check_bool_pattern (var, loop_vinfo))\n+      if (!check_bool_pattern (var, loop_vinfo, bb_vinfo))\n \treturn NULL;\n \n       rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n@@ -2297,6 +2342,9 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       *type_out = vectype;\n       *type_in = vectype;\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"vect_recog_bool_pattern: detected: \");\n+\n       return pattern_stmt;\n     }\n   else if (rhs_code == SSA_NAME\n@@ -2307,7 +2355,7 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       gcc_assert (vectype != NULL_TREE);\n       if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n \treturn NULL;\n-      if (!check_bool_pattern (var, loop_vinfo))\n+      if (!check_bool_pattern (var, loop_vinfo, bb_vinfo))\n \treturn NULL;\n \n       rhs = adjust_bool_pattern (var, TREE_TYPE (vectype), NULL_TREE, stmts);\n@@ -2322,7 +2370,8 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n \t}\n       pattern_stmt\n \t= gimple_build_assign_with_ops (SSA_NAME, lhs, rhs, NULL_TREE);\n-      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL);\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo,\n+\t\t\t\t\t\tbb_vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n       STMT_VINFO_DATA_REF (pattern_stmt_info)\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n@@ -2338,6 +2387,8 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       *type_out = vectype;\n       *type_in = vectype;\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"vect_recog_bool_pattern: detected: \");\n       return pattern_stmt;\n     }\n   else\n@@ -2354,12 +2405,14 @@ vect_mark_pattern_stmts (gimple orig_stmt, gimple pattern_stmt,\n   stmt_vec_info pattern_stmt_info, def_stmt_info;\n   stmt_vec_info orig_stmt_info = vinfo_for_stmt (orig_stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (orig_stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (orig_stmt_info);\n   gimple def_stmt;\n \n   pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n   if (pattern_stmt_info == NULL)\n     {\n-      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL);\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo,\n+\t\t\t\t\t\tbb_vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n     }\n   gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt));\n@@ -2382,7 +2435,8 @@ vect_mark_pattern_stmts (gimple orig_stmt, gimple pattern_stmt,\n \t  def_stmt_info = vinfo_for_stmt (def_stmt);\n \t  if (def_stmt_info == NULL)\n \t    {\n-\t      def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t      def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo,\n+\t\t\t\t\t\t bb_vinfo);\n \t      set_vinfo_for_stmt (def_stmt, def_stmt_info);\n \t    }\n \t  gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n@@ -2493,9 +2547,10 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n \n   /* Patterns cannot be vectorized using SLP, because they change the order of\n      computation.  */\n-  FOR_EACH_VEC_ELT (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, next)\n-    if (next == stmt)\n-      VEC_ordered_remove (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i); \n+  if (loop_vinfo)\n+    FOR_EACH_VEC_ELT (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, next)\n+      if (next == stmt)\n+        VEC_ordered_remove (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i);\n \n   /* It is possible that additional pattern stmts are created and inserted in\n      STMTS_TO_REPLACE.  We create a stmt_info for each of them, and mark the\n@@ -2595,26 +2650,46 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n    be recorded in S3.  */\n \n void\n-vect_pattern_recog (loop_vec_info loop_vinfo)\n+vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  unsigned int nbbs = loop->num_nodes;\n+  struct loop *loop;\n+  basic_block *bbs, bb;\n+  unsigned int nbbs;\n   gimple_stmt_iterator si;\n   unsigned int i, j;\n   vect_recog_func_ptr vect_recog_func;\n   VEC (gimple, heap) *stmts_to_replace = VEC_alloc (gimple, heap, 1);\n+  gimple stmt;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_pattern_recog ===\");\n \n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      bbs = LOOP_VINFO_BBS (loop_vinfo);\n+      nbbs = loop->num_nodes;\n+    }\n+  else\n+    {\n+      bb = BB_VINFO_BB (bb_vinfo);\n+      nbbs = 1;\n+      bbs = XNEW (basic_block);\n+      bbs[0] = bb;\n+    }\n+\n   /* Scan through the loop stmts, applying the pattern recognition\n      functions starting at each stmt visited:  */\n   for (i = 0; i < nbbs; i++)\n     {\n       basic_block bb = bbs[i];\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n+\t  if (bb_vinfo && (stmt = gsi_stmt (si))\n+\t      && vinfo_for_stmt (stmt)\n+\t      && !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n+\t   continue;\n+\n           /* Scan over all generic vect_recog_xxx_pattern functions.  */\n           for (j = 0; j < NUM_PATTERNS; j++)\n             {\n@@ -2626,4 +2701,6 @@ vect_pattern_recog (loop_vec_info loop_vinfo)\n     }\n \n   VEC_free (gimple, heap, stmts_to_replace);\n+  if (bb_vinfo)\n+    free (bbs);\n }"}, {"sha": "3ba984e3bd74d270fa66297406e703fb3734d099", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -249,12 +249,14 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       /* Check if DEF_STMT is a part of a pattern in LOOP and get the def stmt\n          from the pattern.  Check that all the stmts of the node are in the\n          pattern.  */\n-      if (loop && def_stmt && gimple_bb (def_stmt)\n-          && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n+      if (def_stmt && gimple_bb (def_stmt)\n+          && ((loop && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n+\t      || (!loop && gimple_bb (def_stmt) == BB_VINFO_BB (bb_vinfo)\n+\t\t  && gimple_code (def_stmt) != GIMPLE_PHI))\n           && vinfo_for_stmt (def_stmt)\n           && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt))\n-          && !STMT_VINFO_RELEVANT (vinfo_for_stmt (def_stmt))\n-          && !STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n+\t  && !STMT_VINFO_RELEVANT (vinfo_for_stmt (def_stmt))\n+\t  && !STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n         {\n           pattern = true;\n           if (!first && !oprnd_info->first_pattern)\n@@ -2015,7 +2017,9 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n+  vect_pattern_recog (NULL, bb_vinfo);\n+\n+  if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n        || min_vf > max_vf)\n      {\n        if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))"}, {"sha": "0e7914f026eb7a5bcdaa2a121c5438aba6308eed", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -2271,10 +2271,10 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n       /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n \t OP1.  */\n       if (CONSTANT_CLASS_P (op0))\n-\tok = vect_is_simple_use_1 (op1, stmt, loop_vinfo, NULL,\n+\tok = vect_is_simple_use_1 (op1, stmt, loop_vinfo, bb_vinfo,\n \t\t\t\t   &def_stmt, &def, &dt[1], &vectype_in);\n       else\n-\tok = vect_is_simple_use (op1, stmt, loop_vinfo, NULL, &def_stmt,\n+\tok = vect_is_simple_use (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t\t &def, &dt[1]);\n \n       if (!ok)"}, {"sha": "14eb201733303f4b5695c7a89d0960fff8086543", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57091836580804c6db4de0df9a7d078ff578d4b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f57091836580804c6db4de0df9a7d078ff578d4b", "patch": "@@ -933,7 +933,7 @@ extern void vect_slp_transform_bb (basic_block);\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n #define NUM_PATTERNS 10\n-void vect_pattern_recog (loop_vec_info);\n+void vect_pattern_recog (loop_vec_info, bb_vec_info);\n \n /* In tree-vectorizer.c.  */\n unsigned vectorize_loops (void);"}]}