{"sha": "4a4412b9de23b153481a60cd69abcee71c3e34fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE0NDEyYjlkZTIzYjE1MzQ4MWE2MGNkNjlhYmNlZTcxYzNlMzRmYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-07-20T15:37:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-07-20T15:37:23Z"}, "message": "Add \"-fsave-optimization-record\"\n\nThis patch implements a -fsave-optimization-record option, which\nleads to a JSON file being written out, recording the dump_* calls\nmade (via the optinfo infrastructure).\n\nThe patch includes a minimal version of the JSON patch I posted last\nyear, with just enough support needed for optimization records (I\nremoved all of the parser code, leaving just the code for building\nin-memory JSON trees and writing them to a pretty_printer).\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add json.o and optinfo-emit-json.o.\n\t(CFLAGS-optinfo-emit-json.o): Define TARGET_NAME.\n\t* common.opt (fsave-optimization-record): New option.\n\t* coretypes.h (struct kv_pair): Move here from dumpfile.c.\n\t* doc/invoke.texi (-fsave-optimization-record): New option.\n\t* dumpfile.c: Include \"optinfo-emit-json.h\".\n\t(struct kv_pair): Move to coretypes.h.\n\t(optgroup_options): Make non-static.\n\t(dump_context::end_scope): Call\n\toptimization_records_maybe_pop_dump_scope.\n\t* dumpfile.h (optgroup_options): New decl.\n\t* json.cc: New file.\n\t* json.h: New file.\n\t* optinfo-emit-json.cc: New file.\n\t* optinfo-emit-json.h: New file.\n\t* optinfo.cc: Include \"optinfo-emit-json.h\".\n\t(optinfo::emit): Call optimization_records_maybe_record_optinfo.\n\t(optinfo_enabled_p): Check optimization_records_enabled_p.\n\t(optinfo_wants_inlining_info_p): Likewise.\n\t* optinfo.h: Update comment.\n\t* profile-count.c (profile_quality_as_string): New function.\n\t* profile-count.h (profile_quality_as_string): New decl.\n\t(profile_count::quality): New accessor.\n\t* selftest-run-tests.c (selftest::run_tests): Call json_cc_tests\n\tand optinfo_emit_json_cc_tests.\n\t* selftest.h (selftest::json_cc_tests): New decl.\n\t(selftest::optinfo_emit_json_cc_tests): New decl.\n\t* toplev.c: Include \"optinfo-emit-json.h\".\n\t(compile_file): Call optimization_records_finish.\n\t(do_compile): Call optimization_records_start.\n\t* tree-ssa-live.c: Include optinfo.h.\n\t(remove_unused_scope_block_p): Retain inlining information if\n\toptinfo_wants_inlining_info_p returns true.\n\nFrom-SVN: r262905", "tree": {"sha": "bfca81ed27910bef95adb2304ad0b3e69af27dd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfca81ed27910bef95adb2304ad0b3e69af27dd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a4412b9de23b153481a60cd69abcee71c3e34fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a4412b9de23b153481a60cd69abcee71c3e34fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a4412b9de23b153481a60cd69abcee71c3e34fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a4412b9de23b153481a60cd69abcee71c3e34fb/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf0086f1c8ff9998fb55a27f6606bccbba873e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf0086f1c8ff9998fb55a27f6606bccbba873e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf0086f1c8ff9998fb55a27f6606bccbba873e09"}], "stats": {"total": 1241, "additions": 1219, "deletions": 22}, "files": [{"sha": "36a43a11a06dbeb63e21d223d03a9536478495a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -1,3 +1,39 @@\n+2018-07-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add json.o and optinfo-emit-json.o.\n+\t(CFLAGS-optinfo-emit-json.o): Define TARGET_NAME.\n+\t* common.opt (fsave-optimization-record): New option.\n+\t* coretypes.h (struct kv_pair): Move here from dumpfile.c.\n+\t* doc/invoke.texi (-fsave-optimization-record): New option.\n+\t* dumpfile.c: Include \"optinfo-emit-json.h\".\n+\t(struct kv_pair): Move to coretypes.h.\n+\t(optgroup_options): Make non-static.\n+\t(dump_context::end_scope): Call\n+\toptimization_records_maybe_pop_dump_scope.\n+\t* dumpfile.h (optgroup_options): New decl.\n+\t* json.cc: New file.\n+\t* json.h: New file.\n+\t* optinfo-emit-json.cc: New file.\n+\t* optinfo-emit-json.h: New file.\n+\t* optinfo.cc: Include \"optinfo-emit-json.h\".\n+\t(optinfo::emit): Call optimization_records_maybe_record_optinfo.\n+\t(optinfo_enabled_p): Check optimization_records_enabled_p.\n+\t(optinfo_wants_inlining_info_p): Likewise.\n+\t* optinfo.h: Update comment.\n+\t* profile-count.c (profile_quality_as_string): New function.\n+\t* profile-count.h (profile_quality_as_string): New decl.\n+\t(profile_count::quality): New accessor.\n+\t* selftest-run-tests.c (selftest::run_tests): Call json_cc_tests\n+\tand optinfo_emit_json_cc_tests.\n+\t* selftest.h (selftest::json_cc_tests): New decl.\n+\t(selftest::optinfo_emit_json_cc_tests): New decl.\n+\t* toplev.c: Include \"optinfo-emit-json.h\".\n+\t(compile_file): Call optimization_records_finish.\n+\t(do_compile): Call optimization_records_start.\n+\t* tree-ssa-live.c: Include optinfo.h.\n+\t(remove_unused_scope_block_p): Retain inlining information if\n+\toptinfo_wants_inlining_info_p returns true.\n+\n 2018-07-20  Richard Biener  <rguenther@suse.de>\n \n \tPR debug/86585"}, {"sha": "b871640653303b924150682ad87a11e510ece390", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -1387,6 +1387,7 @@ OBJS = \\\n \tira-color.o \\\n \tira-emit.o \\\n \tira-lives.o \\\n+\tjson.o \\\n \tjump.o \\\n \tlanghooks.o \\\n \tlcm.o \\\n@@ -1428,6 +1429,7 @@ OBJS = \\\n \toptabs-query.o \\\n \toptabs-tree.o \\\n \toptinfo.o \\\n+\toptinfo-emit-json.o \\\n \toptions-save.o \\\n \topts-global.o \\\n \tpasses.o \\\n@@ -2251,6 +2253,7 @@ s-bversion: BASE-VER\n \t$(STAMP) s-bversion\n \n CFLAGS-toplev.o += -DTARGET_NAME=\\\"$(target_noncanonical)\\\"\n+CFLAGS-optinfo-emit-json.o += -DTARGET_NAME=\\\"$(target_noncanonical)\\\"\n \n pass-instances.def: $(srcdir)/passes.def $(PASSES_EXTRA) \\\n \t\t    $(srcdir)/gen-pass-instances.awk"}, {"sha": "21ed9715da1a37fb7d6f63174f719c05eecaccb6", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -1955,6 +1955,10 @@ fopt-info-\n Common Joined RejectNegative Var(common_deferred_options) Defer\n -fopt-info[-<type>=filename]\tDump compiler optimization details.\n \n+fsave-optimization-record\n+Common Report Var(flag_save_optimization_record) Optimization\n+Write a SRCFILE.opt-record.json file detailing what optimizations were performed.\n+\n foptimize-register-move\n Common Ignore\n Does nothing. Preserved for backward compatibility."}, {"sha": "24f82d8ea4f9e10cc746e12f4365d353919c1228", "filename": "gcc/coretypes.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -332,6 +332,14 @@ namespace gcc {\n \n typedef std::pair <tree, tree> tree_pair;\n \n+/* Define a name->value mapping.  */\n+template <typename ValueType>\n+struct kv_pair\n+{\n+  const char *const name;\t/* the name of the value */\n+  const ValueType value;\t/* the value of the name */\n+};\n+\n #else\n \n struct _dont_use_rtx_here_;"}, {"sha": "9d75edbd069a0c99cb739a6d78def2b85eaf5281", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -419,7 +419,8 @@ Objective-C and Objective-C++ Dialects}.\n -freorder-blocks-algorithm=@var{algorithm} @gol\n -freorder-blocks-and-partition  -freorder-functions @gol\n -frerun-cse-after-loop  -freschedule-modulo-scheduled-loops @gol\n--frounding-math  -fsched2-use-superblocks  -fsched-pressure @gol\n+-frounding-math  -fsave-optimization-record @gol\n+-fsched2-use-superblocks  -fsched-pressure @gol\n -fsched-spec-load  -fsched-spec-load-dangerous @gol\n -fsched-stalled-insns-dep[=@var{n}]  -fsched-stalled-insns[=@var{n}] @gol\n -fsched-group-heuristic  -fsched-critical-path-heuristic @gol\n@@ -13969,6 +13970,51 @@ the first option takes effect and the subsequent options are\n ignored. Thus only @file{vec.miss} is produced which contains\n dumps from the vectorizer about missed opportunities.\n \n+@item -fsave-optimization-record\n+@opindex fsave-optimization-record\n+Write a SRCFILE.opt-record.json file detailing what optimizations\n+were performed, for those optimizations that support @option{-fopt-info}.\n+\n+This option is experimental and the format of the data within the JSON\n+file is subject to change.\n+\n+It is roughly equivalent to a machine-readable version of\n+@option{-fopt-info-all}, as a collection of messages with source file,\n+line number and column number, with the following additional data for\n+each message:\n+\n+@itemize @bullet\n+\n+@item\n+the execution count of the code being optimized, along with metadata about\n+whether this was from actual profile data, or just an estimate, allowing\n+consumers to prioritize messages by code hotness,\n+\n+@item\n+the function name of the code being optimized, where applicable,\n+\n+@item\n+the ``inlining chain'' for the code being optimized, so that when\n+a function is inlined into several different places (which might\n+themselves be inlined), the reader can distinguish between the copies,\n+\n+@item\n+objects identifying those parts of the message that refer to expressions,\n+statements or symbol-table nodes, which of these categories they are, and,\n+when available, their source code location,\n+\n+@item\n+the GCC pass that emitted the message, and\n+\n+@item\n+the location in GCC's own code from which the message was emitted\n+\n+@end itemize\n+\n+Additionally, some messages are logically nested within other\n+messages, reflecting implementation details of the optimization\n+passes.\n+\n @item -fsched-verbose=@var{n}\n @opindex fsched-verbose\n On targets that use instruction scheduling, this option controls the"}, {"sha": "6c9920c6bd2ffb02297cc15754f2055fcc2bef1e", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dump-context.h\"\n #include \"cgraph.h\"\n #include \"tree-pass.h\" /* for \"current_pass\".  */\n+#include \"optinfo-emit-json.h\"\n \n /* If non-NULL, return one past-the-end of the matching SUBPART of\n    the WHOLE string.  */\n@@ -118,14 +119,6 @@ static struct dump_file_info dump_files[TDI_end] =\n   DUMP_FILE_INFO (NULL, \"ipa-all\", DK_ipa, 0),\n };\n \n-/* Define a name->number mapping for a dump flag value.  */\n-template <typename ValueType>\n-struct kv_pair\n-{\n-  const char *const name;\t/* the name of the value */\n-  const ValueType value;\t/* the value of the name */\n-};\n-\n /* Table of dump options. This must be consistent with the TDF_* flags\n    in dumpfile.h and opt_info_options below. */\n static const kv_pair<dump_flags_t> dump_options[] =\n@@ -176,7 +169,7 @@ static const kv_pair<dump_flags_t> optinfo_verbosity_options[] =\n };\n \n /* Flags used for -fopt-info groups.  */\n-static const kv_pair<optgroup_flags_t> optgroup_options[] =\n+const kv_pair<optgroup_flags_t> optgroup_options[] =\n {\n   {\"ipa\", OPTGROUP_IPA},\n   {\"loop\", OPTGROUP_LOOP},\n@@ -801,6 +794,7 @@ dump_context::end_scope ()\n {\n   end_any_optinfo ();\n   m_scope_depth--;\n+  optimization_records_maybe_pop_dump_scope ();\n }\n \n /* Return the optinfo currently being accumulated, creating one if\n@@ -827,8 +821,7 @@ dump_context::begin_next_optinfo (const dump_location_t &loc)\n }\n \n /* End any optinfo that has been accumulated within this context; emitting\n-   it to any destinations as appropriate - though none have currently been\n-   implemented.  */\n+   it to any destinations as appropriate, such as optimization records.  */\n \n void\n dump_context::end_any_optinfo ()"}, {"sha": "ad14acdfc9abe179139170a08079b0e949e039d5", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -420,6 +420,7 @@ extern FILE *dump_begin (int, dump_flags_t *, int part=-1);\n extern void dump_end (int, FILE *);\n extern int opt_info_switch_p (const char *);\n extern const char *dump_flag_name (int);\n+extern const kv_pair<optgroup_flags_t> optgroup_options[];\n \n /* Global variables used to communicate with passes.  */\n extern FILE *dump_file;\n@@ -442,13 +443,15 @@ dump_enabled_p (void)\n    (a) the active dump_file, if any\n    (b) the -fopt-info destination, if any\n    (c) to the \"optinfo\" destinations, if any:\n+       (c.1) as optimization records\n \n    dump_* (MSG_*) --> dumpfile.c --+--> (a) dump_file\n                                    |\n                                    +--> (b) alt_dump_file\n                                    |\n                                    `--> (c) optinfo\n                                             `---> optinfo destinations\n+                                                  (c.1) optimization records\n \n    For optinfos, the dump_*_loc mark the beginning of an optinfo\n    instance: all subsequent dump_* calls are consolidated into"}, {"sha": "3c2aa77fb8dccccf96f36670b60b6e3a13fcb960", "filename": "gcc/json.cc", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fjson.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fjson.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjson.cc?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -0,0 +1,293 @@\n+/* JSON trees\n+   Copyright (C) 2017-2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"json.h\"\n+#include \"pretty-print.h\"\n+#include \"math.h\"\n+#include \"selftest.h\"\n+\n+using namespace json;\n+\n+/* class json::value.  */\n+\n+/* Dump this json::value tree to OUTF.\n+   No formatting is done.  There are no guarantees about the order\n+   in which the key/value pairs of json::objects are printed.  */\n+\n+void\n+value::dump (FILE *outf) const\n+{\n+  pretty_printer pp;\n+  pp_buffer (&pp)->stream = outf;\n+  print (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* class json::object, a subclass of json::value, representing\n+   an unordered collection of key/value pairs.  */\n+\n+/* json:object's dtor.  */\n+\n+object::~object ()\n+{\n+  for (map_t::iterator it = m_map.begin (); it != m_map.end (); ++it)\n+    {\n+      free (const_cast <char *>((*it).first));\n+      delete ((*it).second);\n+    }\n+}\n+\n+/* Implementation of json::value::print for json::object.  */\n+\n+void\n+object::print (pretty_printer *pp) const\n+{\n+  /* Note that the order is not guaranteed.  */\n+  pp_character (pp, '{');\n+  for (map_t::iterator it = m_map.begin (); it != m_map.end (); ++it)\n+    {\n+      if (it != m_map.begin ())\n+\tpp_string (pp, \", \");\n+      const char *key = const_cast <char *>((*it).first);\n+      value *value = (*it).second;\n+      pp_printf (pp, \"\\\"%s\\\": \", key); // FIXME: escaping?\n+      value->print (pp);\n+    }\n+  pp_character (pp, '}');\n+}\n+\n+/* Set the json::value * for KEY, taking ownership of VALUE\n+   (and taking a copy of KEY if necessary).  */\n+\n+void\n+object::set (const char *key, value *v)\n+{\n+  value **ptr = m_map.get (key);\n+  if (ptr)\n+    {\n+      /* If the key is already present, delete the existing value\n+\t and overwrite it.  */\n+      delete *ptr;\n+      *ptr = v;\n+    }\n+  else\n+    /* If the key wasn't already present, take a copy of the key,\n+       and store the value.  */\n+    m_map.put (xstrdup (key), v);\n+}\n+\n+/* class json::array, a subclass of json::value, representing\n+   an ordered collection of values.  */\n+\n+/* json::array's dtor.  */\n+\n+array::~array ()\n+{\n+  unsigned i;\n+  value *v;\n+  FOR_EACH_VEC_ELT (m_elements, i, v)\n+    delete v;\n+}\n+\n+/* Implementation of json::value::print for json::array.  */\n+\n+void\n+array::print (pretty_printer *pp) const\n+{\n+  pp_character (pp, '[');\n+  unsigned i;\n+  value *v;\n+  FOR_EACH_VEC_ELT (m_elements, i, v)\n+    {\n+      if (i)\n+\tpp_string (pp, \", \");\n+      v->print (pp);\n+    }\n+  pp_character (pp, ']');\n+}\n+\n+/* class json::number, a subclass of json::value, wrapping a double.  */\n+\n+/* Implementation of json::value::print for json::number.  */\n+\n+void\n+number::print (pretty_printer *pp) const\n+{\n+  char tmp[1024];\n+  snprintf (tmp, sizeof (tmp), \"%g\", m_value);\n+  pp_string (pp, tmp);\n+}\n+\n+/* class json::string, a subclass of json::value.  */\n+\n+void\n+string::print (pretty_printer *pp) const\n+{\n+  pp_character (pp, '\"');\n+  for (const char *ptr = m_utf8; *ptr; ptr++)\n+    {\n+      char ch = *ptr;\n+      switch (ch)\n+\t{\n+\tcase '\"':\n+\t  pp_string (pp, \"\\\\\\\"\");\n+\t  break;\n+\tcase '\\\\':\n+\t  pp_string (pp, \"\\\\n\");\n+\t  break;\n+\tcase '\\b':\n+\t  pp_string (pp, \"\\\\b\");\n+\t  break;\n+\tcase '\\f':\n+\t  pp_string (pp, \"\\\\f\");\n+\t  break;\n+\tcase '\\n':\n+\t  pp_string (pp, \"\\\\n\");\n+\t  break;\n+\tcase '\\r':\n+\t  pp_string (pp, \"\\\\r\");\n+\t  break;\n+\tcase '\\t':\n+\t  pp_string (pp, \"\\\\t\");\n+\t  break;\n+\n+\tdefault:\n+\t  pp_character (pp, ch);\n+\t}\n+    }\n+  pp_character (pp, '\"');\n+}\n+\n+/* class json::literal, a subclass of json::value.  */\n+\n+/* Implementation of json::value::print for json::literal.  */\n+\n+void\n+literal::print (pretty_printer *pp) const\n+{\n+  switch (m_kind)\n+    {\n+    case JSON_TRUE:\n+      pp_string (pp, \"true\");\n+      break;\n+    case JSON_FALSE:\n+      pp_string (pp, \"false\");\n+      break;\n+    case JSON_NULL:\n+      pp_string (pp, \"null\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\f\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests.  */\n+\n+/* Verify that JV->print () prints EXPECTED_JSON.  */\n+\n+static void\n+assert_print_eq (const json::value &jv, const char *expected_json)\n+{\n+  pretty_printer pp;\n+  jv.print (&pp);\n+  ASSERT_STREQ (expected_json, pp_formatted_text (&pp));\n+}\n+\n+/* Verify that JSON objects are written correctly.  We can't test more than\n+   one key/value pair, as we don't impose a guaranteed ordering.  */\n+\n+static void\n+test_writing_objects ()\n+{\n+  object obj;\n+  obj.set (\"foo\", new json::string (\"bar\"));\n+  assert_print_eq (obj, \"{\\\"foo\\\": \\\"bar\\\"}\");\n+}\n+\n+/* Verify that JSON arrays are written correctly.  */\n+\n+static void\n+test_writing_arrays ()\n+{\n+  array arr;\n+  assert_print_eq (arr, \"[]\");\n+\n+  arr.append (new json::string (\"foo\"));\n+  assert_print_eq (arr, \"[\\\"foo\\\"]\");\n+\n+  arr.append (new json::string (\"bar\"));\n+  assert_print_eq (arr, \"[\\\"foo\\\", \\\"bar\\\"]\");\n+}\n+\n+/* Verify that JSON numbers are written correctly.  */\n+\n+static void\n+test_writing_numbers ()\n+{\n+  assert_print_eq (number (0), \"0\");\n+  assert_print_eq (number (42), \"42\");\n+  assert_print_eq (number (-100), \"-100\");\n+}\n+\n+/* Verify that JSON strings are written correctly.  */\n+\n+static void\n+test_writing_strings ()\n+{\n+  string foo (\"foo\");\n+  assert_print_eq (foo, \"\\\"foo\\\"\");\n+\n+  string contains_quotes (\"before \\\"quoted\\\" after\");\n+  assert_print_eq (contains_quotes, \"\\\"before \\\\\\\"quoted\\\\\\\" after\\\"\");\n+}\n+\n+/* Verify that JSON strings are written correctly.  */\n+\n+static void\n+test_writing_literals ()\n+{\n+  assert_print_eq (literal (JSON_TRUE), \"true\");\n+  assert_print_eq (literal (JSON_FALSE), \"false\");\n+  assert_print_eq (literal (JSON_NULL), \"null\");\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+json_cc_tests ()\n+{\n+  test_writing_objects ();\n+  test_writing_arrays ();\n+  test_writing_numbers ();\n+  test_writing_strings ();\n+  test_writing_literals ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "5c3274cab79be2fba1642118d09019f70eb8db50", "filename": "gcc/json.h", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fjson.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fjson.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjson.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -0,0 +1,166 @@\n+/* JSON trees\n+   Copyright (C) 2017-2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_JSON_H\n+#define GCC_JSON_H\n+\n+/* Implementation of JSON, a lightweight data-interchange format.\n+\n+   See http://www.json.org/\n+   and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf\n+   and https://tools.ietf.org/html/rfc7159\n+\n+   Supports creating a DOM-like tree of json::value *, and then dumping\n+   json::value * to text.  */\n+\n+namespace json\n+{\n+\n+/* Forward decls of json::value and its subclasses (using indentation\n+   to denote inheritance.  */\n+\n+class value;\n+  class object;\n+  class array;\n+  class number;\n+  class string;\n+  class literal;\n+\n+/* An enum for discriminating the subclasses of json::value.  */\n+\n+enum kind\n+{\n+  /* class json::object.  */\n+  JSON_OBJECT,\n+\n+  /* class json::array.  */\n+  JSON_ARRAY,\n+\n+  /* class json::number.  */\n+  JSON_NUMBER,\n+\n+  /* class json::string.  */\n+  JSON_STRING,\n+\n+  /* class json::literal uses these three values to identify the\n+     particular literal.  */\n+  JSON_TRUE,\n+  JSON_FALSE,\n+  JSON_NULL\n+};\n+\n+/* Base class of JSON value.  */\n+\n+class value\n+{\n+ public:\n+  virtual ~value () {}\n+  virtual enum kind get_kind () const = 0;\n+  virtual void print (pretty_printer *pp) const = 0;\n+\n+  void dump (FILE *) const;\n+};\n+\n+/* Subclass of value for objects: an unordered collection of\n+   key/value pairs.  */\n+\n+class object : public value\n+{\n+ public:\n+  ~object ();\n+\n+  enum kind get_kind () const FINAL OVERRIDE { return JSON_OBJECT; }\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  void set (const char *key, value *v);\n+\n+ private:\n+  typedef hash_map <char *, value *,\n+    simple_hashmap_traits<nofree_string_hash, value *> > map_t;\n+  map_t m_map;\n+};\n+\n+/* Subclass of value for arrays.  */\n+\n+class array : public value\n+{\n+ public:\n+  ~array ();\n+\n+  enum kind get_kind () const FINAL OVERRIDE { return JSON_ARRAY; }\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  void append (value *v) { m_elements.safe_push (v); }\n+\n+ private:\n+  auto_vec<value *> m_elements;\n+};\n+\n+/* Subclass of value for numbers.  */\n+\n+class number : public value\n+{\n+ public:\n+  number (double value) : m_value (value) {}\n+\n+  enum kind get_kind () const FINAL OVERRIDE { return JSON_NUMBER; }\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  double get () const { return m_value; }\n+\n+ private:\n+  double m_value;\n+};\n+\n+/* Subclass of value for strings.  */\n+\n+class string : public value\n+{\n+ public:\n+  string (const char *utf8) : m_utf8 (xstrdup (utf8)) {}\n+  ~string () { free (m_utf8); }\n+\n+  enum kind get_kind () const FINAL OVERRIDE { return JSON_STRING; }\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  const char *get_string () const { return m_utf8; }\n+\n+ private:\n+  char *m_utf8;\n+};\n+\n+/* Subclass of value for the three JSON literals \"true\", \"false\",\n+   and \"null\".  */\n+\n+class literal : public value\n+{\n+ public:\n+  literal (enum kind kind) : m_kind (kind) {}\n+\n+  enum kind get_kind () const FINAL OVERRIDE { return m_kind; }\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+ private:\n+  enum kind m_kind;\n+};\n+\n+} // namespace json\n+\n+#endif  /* GCC_JSON_H  */"}, {"sha": "bf1172a2e09f0859c85cebd6973bdc923b4b5cd0", "filename": "gcc/optinfo-emit-json.cc", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo-emit-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo-emit-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.cc?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -0,0 +1,568 @@\n+/* Emit optimization information as JSON files.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"diagnostic-core.h\"\n+\n+#include \"profile.h\"\n+#include \"output.h\"\n+#include \"tree-pass.h\"\n+\n+#include \"optinfo.h\"\n+#include \"optinfo-emit-json.h\"\n+#include \"json.h\"\n+#include \"pretty-print.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cgraph.h\"\n+\n+#include \"langhooks.h\"\n+#include \"version.h\"\n+#include \"context.h\"\n+#include \"pass_manager.h\"\n+#include \"selftest.h\"\n+#include \"dump-context.h\"\n+\n+/* A class for writing out optimization records in JSON format.  */\n+\n+class optrecord_json_writer\n+{\n+public:\n+  optrecord_json_writer ();\n+  ~optrecord_json_writer ();\n+  void write () const;\n+  void add_record (const optinfo *optinfo);\n+  void pop_scope ();\n+\n+  void add_record (json::object *obj);\n+  json::object *impl_location_to_json (dump_impl_location_t loc);\n+  json::object *location_to_json (location_t loc);\n+  json::object *profile_count_to_json (profile_count count);\n+  json::string *get_id_value_for_pass (opt_pass *pass);\n+  json::object *pass_to_json (opt_pass *pass);\n+  json::value *inlining_chain_to_json (location_t loc);\n+  json::object *optinfo_to_json (const optinfo *optinfo);\n+  void add_pass_list (json::array *arr, opt_pass *pass);\n+\n+private:\n+  /* The root value for the JSON file.\n+     Currently the JSON values are stored in memory, and flushed when the\n+     compiler exits.  It would probably be better to simply write out\n+     the JSON as we go.  */\n+  json::array *m_root_tuple;\n+\n+  /* The currently open scopes, for expressing nested optimization records.  */\n+  vec<json::array *> m_scopes;\n+};\n+\n+/* optrecord_json_writer's ctor.  Populate the top-level parts of the\n+   in-memory JSON representation.  */\n+\n+optrecord_json_writer::optrecord_json_writer ()\n+  : m_root_tuple (NULL), m_scopes ()\n+{\n+  m_root_tuple = new json::array ();\n+\n+  /* Populate with metadata; compare with toplev.c: print_version.  */\n+  json::object *metadata = new json::object ();\n+  m_root_tuple->append (metadata);\n+  metadata->set (\"format\", new json::string (\"1\"));\n+  json::object *generator = new json::object ();\n+  metadata->set (\"generator\", generator);\n+  generator->set (\"name\", new json::string (lang_hooks.name));\n+  generator->set (\"pkgversion\", new json::string (pkgversion_string));\n+  generator->set (\"version\", new json::string (version_string));\n+  /* TARGET_NAME is passed in by the Makefile.  */\n+  generator->set (\"target\", new json::string (TARGET_NAME));\n+\n+  /* TODO: capture command-line?\n+     see gen_producer_string in dwarf2out.c (currently static).  */\n+\n+  /* TODO: capture \"any plugins?\" flag (or the plugins themselves).  */\n+\n+  json::array *passes = new json::array ();\n+  m_root_tuple->append (passes);\n+\n+  /* Call add_pass_list for all of the pass lists.  */\n+  {\n+#define DEF_PASS_LIST(LIST) \\\n+    add_pass_list (passes, g->get_passes ()->LIST);\n+    GCC_PASS_LISTS\n+#undef DEF_PASS_LIST\n+  }\n+\n+  json::array *records = new json::array ();\n+  m_root_tuple->append (records);\n+\n+  m_scopes.safe_push (records);\n+}\n+\n+/* optrecord_json_writer's ctor.\n+   Delete the in-memory JSON representation.  */\n+\n+optrecord_json_writer::~optrecord_json_writer ()\n+{\n+  delete m_root_tuple;\n+}\n+\n+/* Choose an appropriate filename, and write the saved records to it.  */\n+\n+void\n+optrecord_json_writer::write () const\n+{\n+  char *filename = concat (dump_base_name, \".opt-record.json\", NULL);\n+  FILE *outfile = fopen (filename, \"w\");\n+  if (outfile)\n+    {\n+      m_root_tuple->dump (outfile);\n+      fclose (outfile);\n+    }\n+  else\n+    error_at (UNKNOWN_LOCATION, \"unable to write optimization records to %qs\",\n+\t      filename); // FIXME: more info?\n+  free (filename);\n+}\n+\n+/* Add a record for OPTINFO to the queue of records to be written.  */\n+\n+void\n+optrecord_json_writer::add_record (const optinfo *optinfo)\n+{\n+  json::object *obj = optinfo_to_json (optinfo);\n+\n+  add_record (obj);\n+\n+  /* Potentially push the scope.  */\n+  if (optinfo->get_kind () == OPTINFO_KIND_SCOPE)\n+    {\n+      json::array *children = new json::array ();\n+      obj->set (\"children\", children);\n+      m_scopes.safe_push (children);\n+    }\n+}\n+\n+/* Private methods of optrecord_json_writer.  */\n+\n+/* Add record OBJ to the the innermost scope.  */\n+\n+void\n+optrecord_json_writer::add_record (json::object *obj)\n+{\n+  /* Add to innermost scope.  */\n+  gcc_assert (m_scopes.length () > 0);\n+  m_scopes[m_scopes.length () - 1]->append (obj);\n+}\n+\n+/* Pop the innermost scope.  */\n+\n+void\n+optrecord_json_writer::pop_scope ()\n+{\n+  m_scopes.pop ();\n+}\n+\n+/* Create a JSON object representing LOC.  */\n+\n+json::object *\n+optrecord_json_writer::impl_location_to_json (dump_impl_location_t loc)\n+{\n+  json::object *obj = new json::object ();\n+  obj->set (\"file\", new json::string (loc.m_file));\n+  obj->set (\"line\", new json::number (loc.m_line));\n+  if (loc.m_function)\n+    obj->set (\"function\", new json::string (loc.m_function));\n+  return obj;\n+}\n+\n+/* Create a JSON object representing LOC.  */\n+\n+json::object *\n+optrecord_json_writer::location_to_json (location_t loc)\n+{\n+  json::object *obj = new json::object ();\n+  obj->set (\"file\", new json::string (LOCATION_FILE (loc)));\n+  obj->set (\"line\", new json::number (LOCATION_LINE (loc)));\n+  obj->set (\"column\", new json::number (LOCATION_COLUMN (loc)));\n+  return obj;\n+}\n+\n+/* Create a JSON object representing COUNT.  */\n+\n+json::object *\n+optrecord_json_writer::profile_count_to_json (profile_count count)\n+{\n+  json::object *obj = new json::object ();\n+  obj->set (\"value\", new json::number (count.to_gcov_type ()));\n+  obj->set (\"quality\",\n+\t    new json::string (profile_quality_as_string (count.quality ())));\n+  return obj;\n+}\n+\n+/* Get a string for use when referring to PASS in the saved optimization\n+   records.  */\n+\n+json::string *\n+optrecord_json_writer::get_id_value_for_pass (opt_pass *pass)\n+{\n+  pretty_printer pp;\n+  /* this is host-dependent, but will be consistent for a given host.  */\n+  pp_pointer (&pp, static_cast<void *> (pass));\n+  return new json::string (pp_formatted_text (&pp));\n+}\n+\n+/* Create a JSON object representing PASS.  */\n+\n+json::object *\n+optrecord_json_writer::pass_to_json (opt_pass *pass)\n+{\n+  json::object *obj = new json::object ();\n+  const char *type = NULL;\n+  switch (pass->type)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case GIMPLE_PASS:\n+      type = \"gimple\";\n+      break;\n+    case RTL_PASS:\n+      type = \"rtl\";\n+      break;\n+    case SIMPLE_IPA_PASS:\n+      type = \"simple_ipa\";\n+      break;\n+    case IPA_PASS:\n+      type = \"ipa\";\n+      break;\n+    }\n+  obj->set (\"id\", get_id_value_for_pass (pass));\n+  obj->set (\"type\", new json::string (type));\n+  obj->set (\"name\", new json::string (pass->name));\n+  /* Represent the optgroup flags as an array.  */\n+  {\n+    json::array *optgroups = new json::array ();\n+    obj->set (\"optgroups\", optgroups);\n+    for (const kv_pair<optgroup_flags_t> *optgroup = optgroup_options;\n+\t optgroup->name != NULL; optgroup++)\n+      if (optgroup->value != OPTGROUP_ALL\n+\t  && (pass->optinfo_flags & optgroup->value))\n+\toptgroups->append (new json::string (optgroup->name));\n+  }\n+  obj->set (\"num\", new json::number (pass->static_pass_number));\n+  return obj;\n+}\n+\n+/* Create a JSON array for LOC representing the chain of inlining\n+   locations.\n+   Compare with lhd_print_error_function and cp_print_error_function.  */\n+\n+json::value *\n+optrecord_json_writer::inlining_chain_to_json (location_t loc)\n+{\n+  json::array *array = new json::array ();\n+\n+  tree abstract_origin = LOCATION_BLOCK (loc);\n+\n+  while (abstract_origin)\n+    {\n+      location_t *locus;\n+      tree block = abstract_origin;\n+\n+      locus = &BLOCK_SOURCE_LOCATION (block);\n+      tree fndecl = NULL;\n+      block = BLOCK_SUPERCONTEXT (block);\n+      while (block && TREE_CODE (block) == BLOCK\n+\t     && BLOCK_ABSTRACT_ORIGIN (block))\n+\t{\n+\t  tree ao = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+\t  while (TREE_CODE (ao) == BLOCK\n+\t\t && BLOCK_ABSTRACT_ORIGIN (ao)\n+\t\t && BLOCK_ABSTRACT_ORIGIN (ao) != ao)\n+\t    ao = BLOCK_ABSTRACT_ORIGIN (ao);\n+\n+\t  if (TREE_CODE (ao) == FUNCTION_DECL)\n+\t    {\n+\t      fndecl = ao;\n+\t      break;\n+\t    }\n+\t  else if (TREE_CODE (ao) != BLOCK)\n+\t    break;\n+\n+\t  block = BLOCK_SUPERCONTEXT (block);\n+\t}\n+      if (fndecl)\n+\tabstract_origin = block;\n+      else\n+\t{\n+\t  while (block && TREE_CODE (block) == BLOCK)\n+\t    block = BLOCK_SUPERCONTEXT (block);\n+\n+\t  if (block && TREE_CODE (block) == FUNCTION_DECL)\n+\t    fndecl = block;\n+\t  abstract_origin = NULL;\n+\t}\n+      if (fndecl)\n+\t{\n+\t  json::object *obj = new json::object ();\n+\t  const char *printable_name\n+\t    = lang_hooks.decl_printable_name (fndecl, 2);\n+\t  obj->set (\"fndecl\", new json::string (printable_name));\n+\t  if (*locus != UNKNOWN_LOCATION)\n+\t    obj->set (\"site\", location_to_json (*locus));\n+\t  array->append (obj);\n+\t}\n+    }\n+\n+  return array;\n+}\n+\n+/* Create a JSON object representing OPTINFO.  */\n+\n+json::object *\n+optrecord_json_writer::optinfo_to_json (const optinfo *optinfo)\n+{\n+  json::object *obj = new json::object ();\n+\n+  obj->set (\"impl_location\",\n+\t    impl_location_to_json (optinfo->get_impl_location ()));\n+\n+  const char *kind_str = optinfo_kind_to_string (optinfo->get_kind ());\n+  obj->set (\"kind\", new json::string (kind_str));\n+  json::array *message = new json::array ();\n+  obj->set (\"message\", message);\n+  for (unsigned i = 0; i < optinfo->num_items (); i++)\n+    {\n+      const optinfo_item *item = optinfo->get_item (i);\n+      switch (item->get_kind ())\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase OPTINFO_ITEM_KIND_TEXT:\n+\t  {\n+\t    message->append (new json::string (item->get_text ()));\n+\t  }\n+\t  break;\n+\tcase OPTINFO_ITEM_KIND_TREE:\n+\t  {\n+\t    json::object *json_item = new json::object ();\n+\t    json_item->set (\"expr\", new json::string (item->get_text ()));\n+\n+\t    /* Capture any location for the node.  */\n+\t    if (item->get_location () != UNKNOWN_LOCATION)\n+\t      json_item->set (\"location\", location_to_json (item->get_location ()));\n+\n+\t    message->append (json_item);\n+\t  }\n+\t  break;\n+\tcase OPTINFO_ITEM_KIND_GIMPLE:\n+\t  {\n+\t    json::object *json_item = new json::object ();\n+\t    json_item->set (\"stmt\", new json::string (item->get_text ()));\n+\n+\t    /* Capture any location for the stmt.  */\n+\t    if (item->get_location () != UNKNOWN_LOCATION)\n+\t      json_item->set (\"location\", location_to_json (item->get_location ()));\n+\n+\t    message->append (json_item);\n+\t  }\n+\t  break;\n+\tcase OPTINFO_ITEM_KIND_SYMTAB_NODE:\n+\t  {\n+\t    json::object *json_item = new json::object ();\n+\t    json_item->set (\"symtab_node\", new json::string (item->get_text ()));\n+\n+\t    /* Capture any location for the node.  */\n+\t    if (item->get_location () != UNKNOWN_LOCATION)\n+\t      json_item->set (\"location\", location_to_json (item->get_location ()));\n+\t    message->append (json_item);\n+\t  }\n+\t  break;\n+\t}\n+   }\n+\n+  if (optinfo->get_pass ())\n+    obj->set (\"pass\", get_id_value_for_pass (optinfo->get_pass ()));\n+\n+  profile_count count = optinfo->get_count ();\n+  if (count.initialized_p ())\n+    obj->set (\"count\", profile_count_to_json (count));\n+\n+  /* Record any location, handling the case where of an UNKNOWN_LOCATION\n+     within an inlined block.  */\n+  location_t loc = optinfo->get_location_t ();\n+  if (get_pure_location (line_table, loc) != UNKNOWN_LOCATION)\n+    {\n+      // TOOD: record the location (just caret for now)\n+      // TODO: start/finish also?\n+      obj->set (\"location\", location_to_json (loc));\n+    }\n+\n+  if (current_function_decl)\n+    {\n+      const char *fnname = get_fnname_from_decl (current_function_decl);\n+      obj->set (\"function\", new json::string (fnname));\n+    }\n+\n+  if (loc != UNKNOWN_LOCATION)\n+    obj->set (\"inlining_chain\", inlining_chain_to_json (loc));\n+\n+  return obj;\n+}\n+\n+/* Add a json description of PASS and its siblings to ARR, recursing into\n+   child passes (adding their descriptions within a \"children\" array).  */\n+\n+void\n+optrecord_json_writer::add_pass_list (json::array *arr, opt_pass *pass)\n+{\n+  do\n+    {\n+      json::object *pass_obj = pass_to_json (pass);\n+      arr->append (pass_obj);\n+      if (pass->sub)\n+\t{\n+\t  json::array *sub = new json::array ();\n+\t  pass_obj->set (\"children\", sub);\n+\t  add_pass_list (sub, pass->sub);\n+\t}\n+      pass = pass->next;\n+    }\n+  while (pass);\n+}\n+\n+/* File-level interface to rest of compiler (to avoid exposing\n+   class optrecord_json_writer outside of this file).  */\n+\n+static optrecord_json_writer *the_json_writer;\n+\n+/* Perform startup activity for -fsave-optimization-record.  */\n+\n+void\n+optimization_records_start ()\n+{\n+  /* Bail if recording not enabled.  */\n+  if (!flag_save_optimization_record)\n+    return;\n+\n+  the_json_writer = new optrecord_json_writer ();\n+}\n+\n+/* Perform cleanup activity for -fsave-optimization-record.\n+\n+   Currently, the file is written out here in one go, before cleaning\n+   up.  */\n+\n+void\n+optimization_records_finish ()\n+{\n+  /* Bail if recording not enabled.  */\n+  if (!the_json_writer)\n+    return;\n+\n+  the_json_writer->write ();\n+\n+  delete the_json_writer;\n+  the_json_writer = NULL;\n+}\n+\n+/* Did the user request optimization records to be written out?  */\n+\n+bool\n+optimization_records_enabled_p ()\n+{\n+  return the_json_writer != NULL;\n+}\n+\n+/* If optimization records were requested, then add a record for OPTINFO\n+   to the queue of records to be written.  */\n+\n+void\n+optimization_records_maybe_record_optinfo (const optinfo *optinfo)\n+{\n+  /* Bail if recording not enabled.  */\n+  if (!the_json_writer)\n+    return;\n+\n+  the_json_writer->add_record (optinfo);\n+}\n+\n+/* Handling for the end of a dump scope for the\n+   optimization records sink.  */\n+\n+void\n+optimization_records_maybe_pop_dump_scope ()\n+{\n+  /* Bail if recording not enabled.  */\n+  if (!the_json_writer)\n+    return;\n+\n+  the_json_writer->pop_scope ();\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that we can build a JSON optimization record from dump_*\n+   calls.  */\n+\n+static void\n+test_building_json_from_dump_calls ()\n+{\n+  temp_dump_context tmp (true);\n+  dump_location_t loc;\n+  dump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n+  dump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n+  optinfo *info = tmp.get_pending_optinfo ();\n+  ASSERT_TRUE (info != NULL);\n+  ASSERT_EQ (info->num_items (), 2);\n+\n+  optrecord_json_writer writer;\n+  json::object *json_obj = writer.optinfo_to_json (info);\n+  ASSERT_TRUE (json_obj != NULL);\n+\n+  /* Verify that the json is sane.  */\n+  pretty_printer pp;\n+  json_obj->print (&pp);\n+  const char *json_str = pp_formatted_text (&pp);\n+  ASSERT_STR_CONTAINS (json_str, \"impl_location\");\n+  ASSERT_STR_CONTAINS (json_str, \"\\\"kind\\\": \\\"note\\\"\");\n+  ASSERT_STR_CONTAINS (json_str,\n+\t\t       \"\\\"message\\\": [\\\"test of tree: \\\", {\\\"expr\\\": \\\"0\\\"}]\");\n+  delete json_obj;\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+optinfo_emit_json_cc_tests ()\n+{\n+  test_building_json_from_dump_calls ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "3628d56e2556c7090469a1764aaf31b043f4a1de", "filename": "gcc/optinfo-emit-json.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo-emit-json.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo-emit-json.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -0,0 +1,36 @@\n+/* Emit optimization information as JSON files.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OPTINFO_EMIT_JSON_H\n+#define GCC_OPTINFO_EMIT_JSON_H\n+\n+class optinfo;\n+struct opt_pass;\n+\n+extern void optimization_records_start ();\n+extern void optimization_records_finish ();\n+\n+extern bool optimization_records_enabled_p ();\n+\n+extern void optimization_records_maybe_record_optinfo (const optinfo *);\n+extern void optimization_records_maybe_pop_dump_scope ();\n+\n+\n+#endif /* #ifndef GCC_OPTINFO_EMIT_JSON_H */"}, {"sha": "93de9d9388a0d5d95cbb5e6bb3c6db8f2ebdc0a8", "filename": "gcc/optinfo.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.cc?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n \n #include \"optinfo.h\"\n+#include \"optinfo-emit-json.h\"\n #include \"dump-context.h\"\n #include \"pretty-print.h\"\n #include \"gimple-pretty-print.h\"\n@@ -85,7 +86,8 @@ optinfo::~optinfo ()\n void\n optinfo::emit ()\n {\n-  /* currently this is a no-op.  */\n+  /* -fsave-optimization-record.  */\n+  optimization_records_maybe_record_optinfo (this);\n }\n \n /* Update the optinfo's kind based on DUMP_KIND.  */\n@@ -221,9 +223,8 @@ optinfo::add_dec (const wide_int_ref &wi, signop sgn)\n \n bool optinfo_enabled_p ()\n {\n-  /* Currently no destinations are implemented, just a hook for\n-     selftests.  */\n-  return dump_context::get ().forcibly_enable_optinfo_p ();\n+  return (dump_context::get ().forcibly_enable_optinfo_p ()\n+\t  || optimization_records_enabled_p ());\n }\n \n /* Return true if any of the active optinfo destinations make use\n@@ -232,5 +233,5 @@ bool optinfo_enabled_p ()\n \n bool optinfo_wants_inlining_info_p ()\n {\n-  return false;\n+  return optimization_records_enabled_p ();\n }"}, {"sha": "c4cf8adeaff0be1bc35f08717ffb1f18c65fd4da", "filename": "gcc/optinfo.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Foptinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -25,12 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n    optimization, which can be emitted to zero or more of several\n    destinations, such as:\n \n-   * as a \"remark\" through the diagnostics subsystem\n-\n    * saved to a file as an \"optimization record\"\n \n-   Currently no such destinations are implemented.\n-\n    They are generated in response to calls to the \"dump_*\" API in\n    dumpfile.h; repeated calls to the \"dump_*\" API are consolidated\n    into a pending optinfo instance, with a \"dump_*_loc\" starting a new"}, {"sha": "716ffcc8eb08a6545029b7642d8bcc43ca0b276a", "filename": "gcc/profile-count.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -33,6 +33,34 @@ along with GCC; see the file COPYING3.  If not see\n #include \"wide-int.h\"\n #include \"sreal.h\"\n \n+/* Get a string describing QUALITY.  */\n+\n+const char *\n+profile_quality_as_string (enum profile_quality quality)\n+{\n+  switch (quality)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case profile_uninitialized:\n+      return \"uninitialized\";\n+    case profile_guessed_local:\n+      return \"guessed_local\";\n+    case profile_guessed_global0:\n+      return \"guessed_global0\";\n+    case profile_guessed_global0adjusted:\n+      return \"guessed_global0adjusted\";\n+    case profile_guessed:\n+      return \"guessed\";\n+    case profile_afdo:\n+      return \"afdo\";\n+    case profile_adjusted:\n+      return \"adjusted\";\n+    case profile_precise:\n+      return \"precise\";\n+    }\n+}\n+\n /* Dump THIS to F.  */\n \n void"}, {"sha": "f4d0c340a0a999e26ac9f8e1f5b3ad940d5fcbe9", "filename": "gcc/profile-count.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -59,6 +59,8 @@ enum profile_quality {\n   profile_precise\n };\n \n+extern const char *profile_quality_as_string (enum profile_quality);\n+\n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n \n@@ -721,6 +723,9 @@ class GTY(()) profile_count\n       return m_quality == profile_precise;\n     }\n \n+  /* Get the quality of the count.  */\n+  enum profile_quality quality () const { return m_quality; }\n+\n   /* When merging basic blocks, the two different profile counts are unified.\n      Return true if this can be done without losing info about profile.\n      The only case we care about here is when first BB contains something"}, {"sha": "5adb03391c253e2272cc5cd1eccf7f2b0aeac94a", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -72,6 +72,8 @@ selftest::run_tests ()\n   typed_splay_tree_c_tests ();\n   unique_ptr_tests_cc_tests ();\n   opt_proposer_c_tests ();\n+  json_cc_tests ();\n+  optinfo_emit_json_cc_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "ede77324453dd2f6625de0777750397056df195c", "filename": "gcc/selftest.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -228,6 +228,8 @@ extern void gimple_c_tests ();\n extern void hash_map_tests_c_tests ();\n extern void hash_set_tests_c_tests ();\n extern void input_c_tests ();\n+extern void json_cc_tests ();\n+extern void optinfo_emit_json_cc_tests ();\n extern void predict_c_tests ();\n extern void pretty_print_c_tests ();\n extern void read_rtl_function_c_tests ();"}, {"sha": "8908105f5481fedb277bfbbd6c46a77c2792a5ef", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -83,6 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dumpfile.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"optinfo-emit-json.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n #include \"dbxout.h\"\n@@ -487,6 +488,8 @@ compile_file (void)\n   if (lang_hooks.decls.post_compilation_parsing_cleanups)\n     lang_hooks.decls.post_compilation_parsing_cleanups ();\n \n+  optimization_records_finish ();\n+\n   if (seen_error ())\n     return;\n \n@@ -2118,6 +2121,8 @@ do_compile ()\n \n       timevar_start (TV_PHASE_SETUP);\n \n+      optimization_records_start ();\n+\n       /* This must be run always, because it is needed to compute the FP\n \t predefined macros, such as __LDBL_MAX__, for targets using non\n \t default FP formats.  */"}, {"sha": "2623d9b2b0005e5ef4641c87cdce544eb2d42452", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a4412b9de23b153481a60cd69abcee71c3e34fb/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=4a4412b9de23b153481a60cd69abcee71c3e34fb", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"optinfo.h\"\n \n static void verify_live_on_entry (tree_live_info_p);\n \n@@ -552,7 +553,8 @@ remove_unused_scope_block_p (tree scope, bool in_ctor_dtor_block)\n      ;\n    /* When not generating debug info we can eliminate info on unused\n       variables.  */\n-   else if (!flag_auto_profile && debug_info_level == DINFO_LEVEL_NONE)\n+   else if (!flag_auto_profile && debug_info_level == DINFO_LEVEL_NONE\n+\t    && !optinfo_wants_inlining_info_p ())\n      {\n        /* Even for -g0 don't prune outer scopes from artificial\n \t  functions, otherwise diagnostics using tree_nonartificial_location"}]}