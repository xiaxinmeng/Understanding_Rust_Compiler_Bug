{"sha": "d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIxMTFlMmYxNGE2NWRkZjY3N2M3ZGQzZmYxNTU2NmRjY2UyY2U4Yw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-10-24T09:39:09Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-10-24T09:39:09Z"}, "message": "avr.c: Break long lines.\n\n\t* config/avr/avr.c: Break long lines.\n\tDefine target hooks on the fly if applicable.\n\t(TARGET_ASM_FUNCTION_RODATA_SECTION): Remove first definition\n\toverridden later.\n\t(targetm): Move definition to end of file.\n\t(avr_can_eliminate): Make static on the fly.\n\t(avr_frame_pointer_required_p): Ditto.\n\t(avr_hard_regno_scratch_ok): Ditto.\n\t(avr_builtin_setjmp_frame_value): Make static on the fly.\n\tIndent according to coding rules.\n\t(avr_case_values_threshold): Ditto.\n\t(avr_attribute_table): Move down.\n\nFrom-SVN: r180371", "tree": {"sha": "7206e233621a24b2d9e5ff7f14e43b5f24db29cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7206e233621a24b2d9e5ff7f14e43b5f24db29cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "292689c213a6cbf75983bf9274b2a336ae0ae910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292689c213a6cbf75983bf9274b2a336ae0ae910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/292689c213a6cbf75983bf9274b2a336ae0ae910"}], "stats": {"total": 189, "additions": 91, "deletions": 98}, "files": [{"sha": "8b4286105e49cd816e08c3303f1abe78a3d8812f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c", "patch": "@@ -1,3 +1,18 @@\n+2011-10-24  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr.c: Break long lines.\n+\tDefine target hooks on the fly if applicable.\n+\t(TARGET_ASM_FUNCTION_RODATA_SECTION): Remove first definition\n+\toverridden later.\n+\t(targetm): Move definition to end of file.\n+\t(avr_can_eliminate): Make static on the fly.\n+\t(avr_frame_pointer_required_p): Ditto.\n+\t(avr_hard_regno_scratch_ok): Ditto.\n+\t(avr_builtin_setjmp_frame_value): Make static on the fly.\n+\tIndent according to coding rules.\n+\t(avr_case_values_threshold): Ditto.\n+\t(avr_attribute_table): Move down.\n+\n 2011-10-24  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/50730"}, {"sha": "87ecdfe627178070465a404256c0dcb714914521", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 76, "deletions": 98, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=d2111e2f14a65ddf677c7dd3ff15566dcce2ce8c", "patch": "@@ -56,7 +56,9 @@\n \n #define AVR_SECTION_PROGMEM (SECTION_MACH_DEP << 0)\n \n-static void avr_option_override (void);\n+\n+/* Prototypes for local helper functions.  */\n+\n static int avr_naked_function_p (tree);\n static int interrupt_function_p (tree);\n static int signal_function_p (tree);\n@@ -68,53 +70,15 @@ static int sequent_regs_live (void);\n static const char *ptrreg_to_str (int);\n static const char *cond_string (enum rtx_code);\n static int avr_num_arg_regs (enum machine_mode, const_tree);\n-\n-static rtx avr_legitimize_address (rtx, rtx, enum machine_mode);\n-static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);\n-static tree avr_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n-static tree avr_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n-static bool avr_assemble_integer (rtx, unsigned int, int);\n-static void avr_file_start (void);\n-static void avr_file_end (void);\n-static bool avr_legitimate_address_p (enum machine_mode, rtx, bool);\n-static void avr_asm_function_end_prologue (FILE *);\n-static void avr_asm_function_begin_epilogue (FILE *);\n-static bool avr_cannot_modify_jumps_p (void);\n-static rtx avr_function_value (const_tree, const_tree, bool);\n-static rtx avr_libcall_value (enum machine_mode, const_rtx);\n-static bool avr_function_value_regno_p (const unsigned int);\n-static void avr_insert_attributes (tree, tree *);\n-static void avr_asm_init_sections (void);\n-static unsigned int avr_section_type_flags (tree, const char *, int);\n-\n-static void avr_reorg (void);\n-static void avr_asm_out_ctor (rtx, int);\n-static void avr_asm_out_dtor (rtx, int);\n-static int avr_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n-static int avr_memory_move_cost (enum machine_mode, reg_class_t, bool);\n static int avr_operand_rtx_cost (rtx, enum machine_mode, enum rtx_code,\n \t\t\t\t int, bool);\n-static bool avr_rtx_costs (rtx, int, int, int, int *, bool);\n-static int avr_address_cost (rtx, bool);\n-static bool avr_return_in_memory (const_tree, const_tree);\n static struct machine_function * avr_init_machine_status (void);\n-static void avr_init_builtins (void);\n-static rtx avr_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-static rtx avr_builtin_setjmp_frame_value (void);\n-static bool avr_hard_regno_scratch_ok (unsigned int);\n-static unsigned int avr_case_values_threshold (void);\n-static bool avr_frame_pointer_required_p (void);\n-static bool avr_can_eliminate (const int, const int);\n-static bool avr_class_likely_spilled_p (reg_class_t c);\n-static rtx avr_function_arg (cumulative_args_t , enum machine_mode,\n-\t\t\t     const_tree, bool);\n-static void avr_function_arg_advance (cumulative_args_t, enum machine_mode,\n-\t\t\t\t      const_tree, bool);\n-static bool avr_function_ok_for_sibcall (tree, tree);\n-static void avr_asm_named_section (const char *name, unsigned int flags, tree decl);\n-static void avr_encode_section_info (tree, rtx, int);\n-static section* avr_asm_function_rodata_section (tree);\n-static section* avr_asm_select_section (tree, int, unsigned HOST_WIDE_INT);\n+\n+\n+/* Prototypes for hook implementors if needed before their implementation.  */\n+\n+static bool avr_rtx_costs (rtx, int, int, int, int *, bool);\n+\n \n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n@@ -147,25 +111,6 @@ static GTY(()) section *progmem_section;\n bool avr_need_clear_bss_p = false;\n bool avr_need_copy_data_p = false;\n \n-/* AVR attributes.  */\n-static const struct attribute_spec avr_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"progmem\",   0, 0, false, false, false,  avr_handle_progmem_attribute,\n-    false },\n-  { \"signal\",    0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n-    false },\n-  { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n-    false },\n-  { \"naked\",     0, 0, false, true,  true,   avr_handle_fntype_attribute,\n-    false },\n-  { \"OS_task\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n-    false },\n-  { \"OS_main\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n-    false },\n-  { NULL,        0, 0, false, false, false, NULL, false }\n-};\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -197,8 +142,6 @@ static const struct attribute_spec avr_attribute_table[] =\n \n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE avr_attribute_table\n-#undef TARGET_ASM_FUNCTION_RODATA_SECTION\n-#define TARGET_ASM_FUNCTION_RODATA_SECTION default_no_function_rodata_section\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES avr_insert_attributes\n #undef TARGET_SECTION_TYPE_FLAGS\n@@ -274,7 +217,6 @@ static const struct attribute_spec avr_attribute_table[] =\n #undef TARGET_ASM_FUNCTION_RODATA_SECTION\n #define TARGET_ASM_FUNCTION_RODATA_SECTION avr_asm_function_rodata_section\n \n-struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n /* Custom function to replace string prefix.\n@@ -535,7 +477,7 @@ avr_regs_to_save (HARD_REG_SET *set)\n \n /* Return true if register FROM can be eliminated via register TO.  */\n \n-bool\n+static bool\n avr_can_eliminate (const int from, const int to)\n {\n   return ((from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n@@ -566,10 +508,11 @@ avr_initial_elimination_offset (int from, int to)\n    Using saved frame = virtual_stack_vars_rtx - STARTING_FRAME_OFFSET\n    avoids creating add/sub of offset in nonlocal goto and setjmp.  */\n \n-rtx avr_builtin_setjmp_frame_value (void)\n+static rtx\n+avr_builtin_setjmp_frame_value (void)\n {\n   return gen_rtx_MINUS (Pmode, virtual_stack_vars_rtx, \n-\t\t\t gen_int_mode (STARTING_FRAME_OFFSET, Pmode));\n+                        gen_int_mode (STARTING_FRAME_OFFSET, Pmode));\n }\n \n /* Return contents of MEM at frame pointer + stack size + 1 (+2 if 3 byte PC).\n@@ -1474,7 +1417,8 @@ ptrreg_to_str (int regno)\n     case REG_Y: return \"Y\";\n     case REG_Z: return \"Z\";\n     default:\n-      output_operand_lossage (\"address operand requires constraint for X, Y, or Z register\");\n+      output_operand_lossage (\"address operand requires constraint for\"\n+                              \" X, Y, or Z register\");\n     }\n   return NULL;\n }\n@@ -1539,14 +1483,15 @@ print_operand_address (FILE *file, rtx addr)\n \t  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x,1)) == CONST_INT)\n \t    {\n \t      /* Assembler gs() will implant word address. Make offset \n-\t\t a byte offset inside gs() for assembler. This is \n-\t\t needed because the more logical (constant+gs(sym)) is not \n-\t\t accepted by gas. For 128K and lower devices this is ok. For\n-\t\t large devices it will create a Trampoline to offset from symbol \n-\t\t which may not be what the user really wanted.  */\n+                 a byte offset inside gs() for assembler. This is \n+                 needed because the more logical (constant+gs(sym)) is not \n+                 accepted by gas. For 128K and lower devices this is ok.\n+                 For large devices it will create a Trampoline to offset\n+                 from symbol which may not be what the user really wanted.  */\n \t      fprintf (file, \"gs(\");\n \t      output_addr_const (file, XEXP (x,0));\n-\t      fprintf (file,\"+\" HOST_WIDE_INT_PRINT_DEC \")\", 2 * INTVAL (XEXP (x,1)));\n+              fprintf (file, \"+\" HOST_WIDE_INT_PRINT_DEC \")\",\n+                       2 * INTVAL (XEXP (x, 1)));\n \t      if (AVR_3_BYTE_PC)\n \t        if (warning (0, \"pointer offset from symbol maybe incorrect\"))\n \t\t  {\n@@ -1598,19 +1543,21 @@ print_operand (FILE *file, rtx x, int code)\n     fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) + abcd);\n   else if (GET_CODE (x) == MEM)\n     {\n-      rtx addr = XEXP (x,0);\n+      rtx addr = XEXP (x, 0);\n+      \n       if (code == 'm')\n \t{\n-\t   if (!CONSTANT_P (addr))\n-\t    fatal_insn (\"bad address, not a constant):\", addr);\n-\t  /* Assembler template with m-code is data - not progmem section */\n-\t  if (text_segment_operand (addr, VOIDmode))\n-\t    if (warning ( 0, \"accessing data memory with program memory address\"))\n-\t      {\n-\t\toutput_addr_const (stderr, addr);\n-\t\tfprintf(stderr,\"\\n\");\n-\t      }\n-\t  output_addr_const (file, addr);\n+          if (!CONSTANT_P (addr))\n+            fatal_insn (\"bad address, not a constant):\", addr);\n+          /* Assembler template with m-code is data - not progmem section */\n+          if (text_segment_operand (addr, VOIDmode))\n+            if (warning (0, \"accessing data memory with\"\n+                         \" program memory address\"))\n+              {\n+                output_addr_const (stderr, addr);\n+                fprintf(stderr,\"\\n\");\n+              }\n+          output_addr_const (file, addr);\n \t}\n       else if (code == 'o')\n \t{\n@@ -1645,7 +1592,8 @@ print_operand (FILE *file, rtx x, int code)\n     {\n       /* Constant progmem address - like used in jmp or call */\n       if (0 == text_segment_operand (x, VOIDmode))\n-\t    if (warning ( 0, \"accessing program  memory with data memory address\"))\n+        if (warning (0, \"accessing program memory\"\n+                     \" with data memory address\"))\n \t  {\n \t    output_addr_const (stderr, x);\n \t    fprintf(stderr,\"\\n\");\n@@ -3117,7 +3065,7 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n \n /* Return 1 if frame pointer for current function required.  */\n \n-bool\n+static bool\n avr_frame_pointer_required_p (void)\n {\n   return (cfun->calls_alloca\n@@ -5636,6 +5584,28 @@ avr_handle_fntype_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+\n+/* AVR attributes.  */\n+static const struct attribute_spec\n+avr_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity } */\n+  { \"progmem\",   0, 0, false, false, false,  avr_handle_progmem_attribute,\n+    false },\n+  { \"signal\",    0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n+    false },\n+  { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n+    false },\n+  { \"naked\",     0, 0, false, true,  true,   avr_handle_fntype_attribute,\n+    false },\n+  { \"OS_task\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n+    false },\n+  { \"OS_main\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n+    false },\n+  { NULL,        0, 0, false, false, false, NULL, false }\n+};\n+\n /* Look for attribute `progmem' in DECL\n    if found return 1, otherwise 0.  */\n \n@@ -5701,8 +5671,10 @@ avr_insert_attributes (tree node, tree *attributes)\n /* Track need of __do_clear_bss.  */\n \n void\n-avr_asm_output_aligned_decl_common (FILE * stream, const_tree decl ATTRIBUTE_UNUSED,\n-                                    const char *name, unsigned HOST_WIDE_INT size,\n+avr_asm_output_aligned_decl_common (FILE * stream,\n+                                    const_tree decl ATTRIBUTE_UNUSED,\n+                                    const char *name,\n+                                    unsigned HOST_WIDE_INT size,\n                                     unsigned int align, bool local_p)\n {\n   avr_need_clear_bss_p = true;\n@@ -5821,7 +5793,8 @@ avr_asm_function_rodata_section (tree decl)\n \n           if (STR_PREFIX_P (name, old_prefix))\n             {\n-              const char *rname = avr_replace_prefix (name, old_prefix, new_prefix);\n+              const char *rname = avr_replace_prefix (name,\n+                                                      old_prefix, new_prefix);\n \n               flags &= ~SECTION_CODE;\n               flags |= AVR_HAVE_JMP_CALL ? 0 : SECTION_CODE;\n@@ -5936,7 +5909,8 @@ avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n \n           if (STR_PREFIX_P (name, old_prefix))\n             {\n-              const char *sname = avr_replace_prefix (name, old_prefix, new_prefix);\n+              const char *sname = avr_replace_prefix (name,\n+                                                      old_prefix, new_prefix);\n \n               return get_section (sname, sect->common.flags, sect->named.decl);\n             }\n@@ -6062,7 +6036,8 @@ avr_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Implement `TARGET_MEMORY_MOVE_COST' */\n \n static int\n-avr_memory_move_cost (enum machine_mode mode, reg_class_t rclass ATTRIBUTE_UNUSED,\n+avr_memory_move_cost (enum machine_mode mode,\n+                      reg_class_t rclass ATTRIBUTE_UNUSED,\n                       bool in ATTRIBUTE_UNUSED)\n {\n   return (mode == QImode ? 2\n@@ -7750,7 +7725,7 @@ avr_output_addr_vec_elt (FILE *stream, int value)\n /* Returns true if SCRATCH are safe to be allocated as a scratch\n    registers (for a define_peephole2) in the current function.  */\n \n-bool\n+static bool\n avr_hard_regno_scratch_ok (unsigned int regno)\n {\n   /* Interrupt functions can only use registers that have already been saved\n@@ -7904,7 +7879,8 @@ avr_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \n /* Worker function for CASE_VALUES_THRESHOLD.  */\n \n-unsigned int avr_case_values_threshold (void)\n+static unsigned int\n+avr_case_values_threshold (void)\n {\n   return (!AVR_HAVE_JMP_CALL || TARGET_CALL_PROLOGUES) ? 8 : 17;\n }\n@@ -8210,7 +8186,8 @@ avr_expand_builtin (tree exp, rtx target,\n         op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \n         if (! CONST_INT_P (op0))\n-          error (\"__builtin_avr_delay_cycles expects a compile time integer constant.\");\n+          error (\"__builtin_avr_delay_cycles expects a\"\n+                 \" compile time integer constant.\");\n \n         avr_expand_delay_cycles (op0);\n         return 0;\n@@ -8228,5 +8205,6 @@ avr_expand_builtin (tree exp, rtx target,\n   gcc_unreachable ();\n }\n \n+struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-avr.h\""}]}