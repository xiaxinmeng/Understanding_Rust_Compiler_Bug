{"sha": "461c6fce5605433279d0d67efa907b87a53db54e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYxYzZmY2U1NjA1NDMzMjc5ZDBkNjdlZmE5MDdiODdhNTNkYjU0ZQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-11-15T10:34:06Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-11-15T10:34:06Z"}, "message": "Friend class name lookup 1/n, PR c++/18471\n\n\tFriend class name lookup 1/n, PR c++/18471\n\t* decl.c (lookup_and_check_tag): New function.\n\t(xref_tag, start_enum): Use it.\n\t(check_elaborated_type_specifier): Move TEMPLATE_TYPE_PARM check\n\tbefore !DECL_IMPLICIT_TYPEDEF_P.  Also display previously declared\n\tlocation.\n\t* name-lookup.c (lookup_name_current_level): Rename to ...\n\t(lookup_name_innermost_nonclass_level): ... this.\n\t(lookup_type_scope): New function.\n\t* name-lookup.h (lookup_name_current_level): Rename to ...\n\t(lookup_name_innermost_nonclass_level): ... this.\n\t(lookup_type_scope): Add declaration.\n\n\t* g++.dg/lookup/struct1.C: Adjust expected error.\n\t* g++.dg/parse/elab1.C: Likewise.\n\t* g++.dg/parse/elab2.C: Likewise.\n\t* g++.dg/parse/int-as-enum1.C: Likewise.\n\t* g++.dg/parse/struct-as-enum1.C: Likewise.\n\t* g++.dg/parse/typedef1.C: Likewise.\n\t* g++.dg/parse/typedef3.C: Likewise.\n\t* g++.dg/parse/typedef4.C: Likewise.\n\t* g++.dg/parse/typedef5.C: Likewise.\n\t* g++.dg/template/nontype4.C: Likewise.\n\t* g++.old-deja/g++.benjamin/typedef01.C: Likewise.\n\t* g++.old-deja/g++.other/elab1.C: Likewise.\n\t* g++.old-deja/g++.other/syntax4.C: Likewise.\n\nFrom-SVN: r90657", "tree": {"sha": "7d0dde0911de811100f87808e5c389d6fecd8f85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d0dde0911de811100f87808e5c389d6fecd8f85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/461c6fce5605433279d0d67efa907b87a53db54e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461c6fce5605433279d0d67efa907b87a53db54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/461c6fce5605433279d0d67efa907b87a53db54e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461c6fce5605433279d0d67efa907b87a53db54e/comments", "author": null, "committer": null, "parents": [{"sha": "e24b3cc0aa9b5e8d9c37e21ca974fe89a7a04021", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24b3cc0aa9b5e8d9c37e21ca974fe89a7a04021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24b3cc0aa9b5e8d9c37e21ca974fe89a7a04021"}], "stats": {"total": 370, "additions": 255, "deletions": 115}, "files": [{"sha": "23d6b6a9b91428ea93fefa151739634b0df6de77", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -1,3 +1,18 @@\n+2004-11-15  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 1/n, PR c++/18471\n+\t* decl.c (lookup_and_check_tag): New function.\n+\t(xref_tag, start_enum): Use it.\n+\t(check_elaborated_type_specifier): Move TEMPLATE_TYPE_PARM check\n+\tbefore !DECL_IMPLICIT_TYPEDEF_P.  Also display previously declared\n+\tlocation.\n+\t* name-lookup.c (lookup_name_current_level): Rename to ...\n+\t(lookup_name_innermost_nonclass_level): ... this.\n+\t(lookup_type_scope): New function.\n+\t* name-lookup.h (lookup_name_current_level): Rename to ...\n+\t(lookup_name_innermost_nonclass_level): ... this.\n+\t(lookup_type_scope): Add declaration.\n+\n 2004-11-14  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/17344"}, {"sha": "f82ec87a1d3a3448e177e2dcc0e4a071ef10b500", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 105, "deletions": 86, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -81,7 +81,8 @@ static hashval_t typename_hash (const void *);\n static int typename_compare (const void *, const void *);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n static tree record_builtin_java_type (const char *, int);\n-static const char *tag_name (enum tag_types code);\n+static const char *tag_name (enum tag_types);\n+static tree lookup_and_check_tag (enum tag_types, tree, bool globalize, bool);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static int walk_globals_r (tree, void*);\n static int walk_vtables_r (tree, void*);\n@@ -9056,6 +9057,14 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \n   type = TREE_TYPE (decl);\n \n+  /* Check TEMPLATE_TYPE_PARM first because DECL_IMPLICIT_TYPEDEF_P\n+     is false for this case as well.  */\n+  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+    {\n+      error (\"using template type parameter %qT after %qs\",\n+\t     type, tag_name (tag_code));\n+      return error_mark_node;\n+    }\n   /*   [dcl.type.elab]\n \n        If the identifier resolves to a typedef-name or a template\n@@ -9064,29 +9073,25 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n      In other words, the only legitimate declaration to use in the\n      elaborated type specifier is the implicit typedef created when\n      the type is declared.  */\n-  if (!DECL_IMPLICIT_TYPEDEF_P (decl))\n+  else if (!DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n       error (\"using typedef-name %qD after %qs\", decl, tag_name (tag_code));\n-      return IS_AGGR_TYPE (type) ? type : error_mark_node;\n-    }\n-\n-  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-    {\n-      error (\"using template type parameter %qT after %qs\",\n-\t     type, tag_name (tag_code));\n+      cp_error_at (\"%qD has a previous declaration here\", decl);\n       return error_mark_node;\n     }\n   else if (TREE_CODE (type) != RECORD_TYPE\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && tag_code != enum_type)\n     {\n       error (\"%qT referred to as %qs\", type, tag_name (tag_code));\n+      cp_error_at (\"%qT has a previous declaration here\", type);\n       return error_mark_node;\n     }\n   else if (TREE_CODE (type) != ENUMERAL_TYPE\n \t   && tag_code == enum_type)\n     {\n       error (\"%qT referred to as enum\", type);\n+      cp_error_at (\"%qT has a previous declaration here\", type);\n       return error_mark_node;\n     }\n   else if (!allow_template_p\n@@ -9110,6 +9115,53 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n   return type;\n }\n \n+/* Lookup NAME in elaborate type specifier in scope according to\n+   GLOBALIZE and issue diagnostics if necessary.\n+   Return *_TYPE node upon success, NULL_TREE when the NAME is not\n+   found, and ERROR_MARK_NODE for type error.  */\n+\n+static tree\n+lookup_and_check_tag (enum tag_types tag_code, tree name,\n+\t\t      bool globalize, bool template_header_p)\n+{\n+  tree t;\n+  tree decl;\n+  if (globalize)\n+    decl = lookup_name (name, 2);\n+  else\n+    decl = lookup_type_scope (name);\n+\n+  if (decl && DECL_CLASS_TEMPLATE_P (decl))\n+    decl = DECL_TEMPLATE_RESULT (decl);\n+\n+  if (decl && TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      /* Two cases we need to consider when deciding if a class\n+\t template is allowed as an elaborated type specifier:\n+\t 1. It is a self reference to its own class.\n+\t 2. It comes with a template header.\n+\n+\t For example:\n+\n+\t   template <class T> class C {\n+\t     class C *c1;\t\t// DECL_SELF_REFERENCE_P is true\n+\t     class D;\n+\t   };\n+\t   template <class U> class C; // template_header_p is true\n+\t   template <class T> class C<T>::D {\n+\t     class C *c2;\t\t// DECL_SELF_REFERENCE_P is true\n+\t   };  */\n+\n+      t = check_elaborated_type_specifier (tag_code,\n+\t\t\t\t\t   decl,\n+\t\t\t\t\t   template_header_p\n+\t\t\t\t\t   | DECL_SELF_REFERENCE_P (decl));\n+      return t;\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Get the struct, enum or union (TAG_CODE says which) with tag NAME.\n    Define the tag as a forward-reference if it is not defined.\n \n@@ -9129,7 +9181,6 @@ xref_tag (enum tag_types tag_code, tree name,\n {\n   enum tree_code code;\n   tree t;\n-  struct cp_binding_level *b = current_binding_level;\n   tree context = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -9152,90 +9203,59 @@ xref_tag (enum tag_types tag_code, tree name,\n       gcc_unreachable ();\n     }\n \n-  if (! globalize)\n-    {\n-      /* If we know we are defining this tag, only look it up in\n-\t this scope and don't try to find it as a type.  */\n-      t = lookup_tag (code, name, b, 1);\n-    }\n+  /* In case of anonymous name, xref_tag is only called to\n+     make type node and push name.  Name lookup is not required.  */\n+  if (ANON_AGGRNAME_P (name))\n+    t = NULL_TREE;\n   else\n-    {\n-      tree decl = lookup_name (name, 2);\n+    t = lookup_and_check_tag  (tag_code, name,\n+\t\t\t       globalize, template_header_p);\n \n-      if (decl && DECL_CLASS_TEMPLATE_P (decl))\n-\tdecl = DECL_TEMPLATE_RESULT (decl);\n+  if (t == error_mark_node)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n-      if (decl && TREE_CODE (decl) == TYPE_DECL)\n-\t{\n-\t  /* Two cases we need to consider when deciding if a class\n-\t     template is allowed as an elaborated type specifier:\n-\t     1. It is a self reference to its own class.\n-\t     2. It comes with a template header.\n-\n-\t     For example:\n-\n-\t       template <class T> class C {\n-\t\t class C *c1;\t\t// DECL_SELF_REFERENCE_P is true\n-\t \t class D;\n-\t       };\n-\t       template <class U> class C; // template_header_p is true\n-\t       template <class T> class C<T>::D {\n-\t\t class C *c2;\t\t// DECL_SELF_REFERENCE_P is true\n-\t       };  */\n-\n-\t  t = check_elaborated_type_specifier (tag_code,\n-\t\t\t\t\t       decl,\n-\t\t\t\t\t       template_header_p\n-\t\t\t\t\t       | DECL_SELF_REFERENCE_P (decl));\n-\t  if (t == error_mark_node)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\t}\n-      else\n-\tt = NULL_TREE;\n-\n-      if (t && current_class_type\n-\t  && template_class_depth (current_class_type)\n-\t  && template_header_p)\n-\t{\n-\t  /* Since GLOBALIZE is nonzero, we are not looking at a\n-\t     definition of this tag.  Since, in addition, we are currently\n-\t     processing a (member) template declaration of a template\n-\t     class, we must be very careful; consider:\n+  if (globalize && t && current_class_type\n+      && template_class_depth (current_class_type)\n+      && template_header_p)\n+    {\n+      /* Since GLOBALIZE is nonzero, we are not looking at a\n+\t definition of this tag.  Since, in addition, we are currently\n+\t processing a (member) template declaration of a template\n+\t class, we must be very careful; consider:\n \n-\t       template <class X>\n-\t       struct S1\n+\t   template <class X>\n+\t   struct S1\n \n-\t       template <class U>\n-\t       struct S2\n-\t       { template <class V>\n-\t       friend struct S1; };\n+\t   template <class U>\n+\t   struct S2\n+\t   { template <class V>\n+\t   friend struct S1; };\n \n-\t     Here, the S2::S1 declaration should not be confused with the\n-\t     outer declaration.  In particular, the inner version should\n-\t     have a template parameter of level 2, not level 1.  This\n-\t     would be particularly important if the member declaration\n-\t     were instead:\n+\t Here, the S2::S1 declaration should not be confused with the\n+\t outer declaration.  In particular, the inner version should\n+\t have a template parameter of level 2, not level 1.  This\n+\t would be particularly important if the member declaration\n+\t were instead:\n \n-\t       template <class V = U> friend struct S1;\n+\t   template <class V = U> friend struct S1;\n \n-\t     say, when we should tsubst into `U' when instantiating\n-\t     S2.  On the other hand, when presented with:\n+\t say, when we should tsubst into `U' when instantiating\n+\t S2.  On the other hand, when presented with:\n \n-\t         template <class T>\n-\t         struct S1 {\n-\t\t   template <class U>\n-\t           struct S2 {};\n-\t\t   template <class U>\n-\t\t   friend struct S2;\n-\t\t };\n+\t   template <class T>\n+\t   struct S1 {\n+\t     template <class U>\n+\t     struct S2 {};\n+\t     template <class U>\n+\t     friend struct S2;\n+\t   };\n \n-              we must find the inner binding eventually.  We\n-\t      accomplish this by making sure that the new type we\n-\t      create to represent this declaration has the right\n-\t      TYPE_CONTEXT.  */\n-\t  context = TYPE_CONTEXT (t);\n-\t  t = NULL_TREE;\n-\t}\n+\t we must find the inner binding eventually.  We\n+\t accomplish this by making sure that the new type we\n+\t create to represent this declaration has the right\n+\t TYPE_CONTEXT.  */\n+      context = TYPE_CONTEXT (t);\n+      t = NULL_TREE;\n     }\n \n   if (! t)\n@@ -9482,14 +9502,13 @@ tree\n start_enum (tree name)\n {\n   tree enumtype = NULL_TREE;\n-  struct cp_binding_level *b = current_binding_level;\n \n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n      forward reference.  */\n \n   if (name != NULL_TREE)\n-    enumtype = lookup_tag (ENUMERAL_TYPE, name, b, 1);\n+    enumtype = lookup_and_check_tag (enum_type, name, 0, 0);\n \n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {"}, {"sha": "0abe1eca9cf9a5fd2feb9f17833ccfbc5d377091", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 86, "deletions": 7, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -43,7 +43,7 @@ struct scope_binding {\n static cxx_scope *innermost_nonclass_level (void);\n static tree select_decl (const struct scope_binding *, int);\n static cxx_binding *binding_for_name (cxx_scope *, tree);\n-static tree lookup_name_current_level (tree);\n+static tree lookup_name_innermost_nonclass_level (tree);\n static tree push_overloaded_decl (tree, int);\n static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n                                     tree, int);\n@@ -678,7 +678,7 @@ pushdecl (tree x)\n       if (DECL_NAMESPACE_SCOPE_P (x) && namespace_bindings_p ())\n \tt = namespace_binding (name, DECL_CONTEXT (x));\n       else\n-\tt = lookup_name_current_level (name);\n+\tt = lookup_name_innermost_nonclass_level (name);\n \n       /* [basic.link] If there is a visible declaration of an entity\n \t with linkage having the same name and type, ignoring entities\n@@ -1111,7 +1111,7 @@ push_local_binding (tree id, tree decl, int flags)\n      push_local_binding with a friend decl of a local class.  */\n   b = innermost_nonclass_level ();\n \n-  if (lookup_name_current_level (id))\n+  if (lookup_name_innermost_nonclass_level (id))\n     {\n       /* Supplement the existing binding.  */\n       if (!supplement_binding (IDENTIFIER_BINDING (id), decl))\n@@ -1998,7 +1998,7 @@ push_overloaded_decl (tree decl, int flags)\n   if (doing_global)\n     old = namespace_binding (name, DECL_CONTEXT (decl));\n   else\n-    old = lookup_name_current_level (name);\n+    old = lookup_name_innermost_nonclass_level (name);\n \n   if (old)\n     {\n@@ -2286,7 +2286,7 @@ do_local_using_decl (tree decl, tree scope, tree name)\n       && at_function_scope_p ())\n     add_decl_expr (decl);\n \n-  oldval = lookup_name_current_level (name);\n+  oldval = lookup_name_innermost_nonclass_level (name);\n   oldtype = lookup_type_current_level (name);\n \n   do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n@@ -4122,11 +4122,90 @@ lookup_name (tree name, int prefer_type)\n \t\t\t   0, LOOKUP_COMPLAIN);\n }\n \n+/* Look up NAME for type used in elaborated name specifier in\n+   the current scope (possibly more if cleanup or template parameter\n+   scope is encounter).  Unlike lookup_name_real, we make sure that\n+   NAME is actually declared in the desired scope, not from inheritance,\n+   using declaration, nor using directive.  A TYPE_DECL best matching\n+   the NAME is returned.  Catching error and issuing diagnostics are\n+   caller's responsibility.  */\n+\n+tree\n+lookup_type_scope (tree name)\n+{\n+  cxx_binding *iter = NULL;\n+  tree val = NULL_TREE;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+\n+  /* Look in non-namespace scope first.  */\n+  if (current_binding_level->kind != sk_namespace)\n+    iter = outer_binding (name, NULL, /*class_p=*/ true);\n+  for (; iter; iter = outer_binding (name, iter, /*class_p=*/ true))\n+    {\n+      /* Check if this is the kind of thing we're looking for.\n+\t Make sure it doesn't come from base class.  For ITER->VALUE,\n+\t we can simply use INHERITED_VALUE_BINDING_P.  For ITER->TYPE,\n+\t we have to use our own check.\n+\n+\t We check ITER->TYPE before ITER->VALUE in order to handle\n+\t   typedef struct C {} C;\n+\t correctly.  */\n+\n+      if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES)\n+\t  && (LOCAL_BINDING_P (iter)\n+\t      || DECL_CONTEXT (iter->type) == iter->scope->this_entity))\n+\tval = iter->type;\n+      else if (!INHERITED_VALUE_BINDING_P (iter)\n+\t       && qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n+\tval = iter->value;\n+\n+      if (val)\n+\tbreak;\n+    }\n+\n+  /* Look in namespace scope.  */\n+  if (!val)\n+    {\n+      iter = cxx_scope_find_binding_for_name\n+\t       (NAMESPACE_LEVEL (current_decl_namespace ()), name);\n+\n+      if (iter)\n+\t{\n+\t  /* If this is the kind of thing we're looking for, we're done.  */\n+\t  if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES))\n+\t    val = iter->type;\n+\t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n+\t    val = iter->value;\n+\t}\n+\t\n+    }\n+\n+  /* Type found, check if it is in the current scope, ignoring cleanup\n+     and template parameter scopes.  */\n+  if (val)\n+    {\n+      struct cp_binding_level *b = current_binding_level;\n+      while (b)\n+\t{\n+\t  if (iter->scope == b)\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+\n+\t  if (b->kind == sk_cleanup || b->kind == sk_template_parms)\n+\t    b = b->level_chain;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+}\n+\n /* Similar to `lookup_name' but look only in the innermost non-class\n    binding level.  */\n \n static tree\n-lookup_name_current_level (tree name)\n+lookup_name_innermost_nonclass_level (tree name)\n {\n   struct cp_binding_level *b;\n   tree t = NULL_TREE;\n@@ -4164,7 +4243,7 @@ lookup_name_current_level (tree name)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n-/* Like lookup_name_current_level, but for types.  */\n+/* Like lookup_name_innermost_nonclass_level, but for types.  */\n \n static tree\n lookup_type_current_level (tree name)"}, {"sha": "b43fa1e4f323de2c0c101a19ca42e0033efe8d32", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -303,6 +303,7 @@ extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n extern tree lookup_tag_reverse (tree, tree);\n extern tree lookup_name\t(tree, int);\n extern tree lookup_name_real (tree, int, int, bool, int, int);\n+extern tree lookup_type_scope (tree);\n extern tree namespace_binding (tree, tree);\n extern void set_namespace_binding (tree, tree, tree);\n extern tree lookup_namespace_name (tree, tree);"}, {"sha": "d3653718546c6ff3df52716dff003794a46815fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -1,3 +1,21 @@\n+2004-11-15  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 1/n, PR c++/18471\n+\t* g++.dg/template/crash26.C: New test.\n+\t* g++.dg/lookup/struct1.C: Adjust expected error.\n+\t* g++.dg/parse/elab1.C: Likewise.\n+\t* g++.dg/parse/elab2.C: Likewise.\n+\t* g++.dg/parse/int-as-enum1.C: Likewise.\n+\t* g++.dg/parse/struct-as-enum1.C: Likewise.\n+\t* g++.dg/parse/typedef1.C: Likewise.\n+\t* g++.dg/parse/typedef3.C: Likewise.\n+\t* g++.dg/parse/typedef4.C: Likewise.\n+\t* g++.dg/parse/typedef5.C: Likewise.\n+\t* g++.dg/template/nontype4.C: Likewise.\n+\t* g++.old-deja/g++.benjamin/typedef01.C: Likewise.\n+\t* g++.old-deja/g++.other/elab1.C: Likewise.\n+\t* g++.old-deja/g++.other/syntax4.C: Likewise.\n+\n 2004-11-15  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/intmax_t-1.c: XFAIL on Solaris 2.5.1."}, {"sha": "f4b83ecf6b8b568287cf077ee70db88cff9e6baa", "filename": "gcc/testsuite/g++.dg/lookup/struct1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fstruct1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fstruct1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fstruct1.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -3,10 +3,10 @@\n \n struct A;\n typedef struct A B;\t\t// { dg-error \"previous declaration\" }\n-struct B;\t\t\t// { dg-error \"conflicting declaration\" }\n+struct B;\t\t\t// { dg-error \"using typedef-name\" }\n \n typedef struct { int i; } C;\t// { dg-error \"previous declaration\" }\n-struct C;\t\t\t// { dg-error \"conflicting declaration\" }\n+struct C;\t\t\t// { dg-error \"using typedef-name\" }\n \n struct D;\n typedef struct D D;"}, {"sha": "92fcd1ca69c425fafdb98dff4b983a02102121b0", "filename": "gcc/testsuite/g++.dg/parse/elab1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab1.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -1,6 +1,6 @@\n namespace Name {\n \n-    typedef void *(*Function)( void *, int );\n+    typedef void *(*Function)( void *, int ); // { dg-error \"previous declaration\" }\n \n     struct Foo {\n       struct Function xyz[5]; // { dg-error \"\" }"}, {"sha": "6b42aed67a4c3df37a6fe4b47c91748cec1c4757", "filename": "gcc/testsuite/g++.dg/parse/elab2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab2.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -2,6 +2,6 @@ struct A {};\n \n struct B\n {\n-  typedef A T;\n+  typedef A T; // { dg-error \"previous declaration\" }\n   friend struct T; // { dg-error \"\" }\n };"}, {"sha": "7c37eb08792b0e71e2de5981862f5e1ebba6ea5c", "filename": "gcc/testsuite/g++.dg/parse/int-as-enum1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fint-as-enum1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fint-as-enum1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fint-as-enum1.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -2,5 +2,5 @@\n // Origin: <wanderer@rsu.ru>\n // { dg-do compile }\n \n-typedef int A;\n-enum ::A {}; // { dg-error \"\" }\n+typedef int A;\t// { dg-error \"previous\" }\n+enum ::A {};\t// { dg-error \"typedef-name|expected unqualified-id\" }"}, {"sha": "bc8c5b530f6b87fa5b19169700aea901566bbb02", "filename": "gcc/testsuite/g++.dg/parse/struct-as-enum1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fstruct-as-enum1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fstruct-as-enum1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fstruct-as-enum1.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -4,7 +4,7 @@\n \n namespace N\n {\n-    struct A {};\n+    struct A {};\t// { dg-error \"previous declaration\" }\n }\n \n-typedef enum N::A B; // { dg-error \"enum\" }\n+typedef enum N::A B;\t// { dg-error \"enum\" }"}, {"sha": "c4fbb950cf1acf20fe8d27aa5601222e55068590", "filename": "gcc/testsuite/g++.dg/parse/typedef1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef1.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -1,3 +1,3 @@\n // PR c++/6477\n-typedef struct A_ *A;\n-typedef struct A B;\t// { dg-error \"\" }\n+typedef struct A_ *A;\t// { dg-error \"previous declaration\" }\n+typedef struct A B;\t// { dg-error \"typedef|invalid type\" }"}, {"sha": "6b4e531b677293423d173b0ae4042d6fbf9575bc", "filename": "gcc/testsuite/g++.dg/parse/typedef3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef3.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -2,6 +2,6 @@\n // Origin: Travis J.I. Corcoran <tjic@permabit.com>\n // { dg-do compile }\n \n-struct A { typedef A* Ptr; };\n+struct A { typedef A* Ptr; };\t// { dg-error \"previous declaration\" }\n \n-struct A::Ptr; // { dg-error \"\" }\n+struct A::Ptr;\t\t\t// { dg-error \"typedef|not declare anything\" }"}, {"sha": "8599fd1d88410ac36ceebeffbf12222024e7fed4", "filename": "gcc/testsuite/g++.dg/parse/typedef4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef4.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -7,6 +7,6 @@\n template<class T> class smart_ptr2 {\n     T* real_ptr;\n  public:\n-    typedef typename T::subT  td;\n-    friend class td; // { dg-error \"typedef\" }\n+    typedef typename T::subT  td; // { dg-error \"previous declaration\" }\n+    friend class td; // { dg-error \"typedef|not name a class\" }\n };"}, {"sha": "22ba85e0aea561fc6b8f221967b208b412821001", "filename": "gcc/testsuite/g++.dg/parse/typedef5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef5.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -1,6 +1,6 @@\n namespace A\n {\n-  typedef int T;\n+  typedef int T;\t// { dg-error \"previous declaration\" }\n }\n \n-class A::T x; // { dg-error \"\" }\n+class A::T x;\t\t// { dg-error \"using typedef-name\" }"}, {"sha": "f1bc399a31da981a083d19449c2f292b8780c791", "filename": "gcc/testsuite/g++.dg/template/crash26.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash26.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile }\n+\n+// Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n+\n+// PR c++/18471: ICE redeclaration of typedef as class template\n+\n+typedef int X;\t\t\t// { dg-error \"previous\" }\n+template<X> struct X {};\t// { dg-error \"typedef-name\" }"}, {"sha": "ab39ed443976216cc6997a69e5ec7f7d7e80b088", "filename": "gcc/testsuite/g++.dg/template/nontype4.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype4.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -7,8 +7,8 @@\n \n template <int> struct A\n {\n-    typedef A<0> B;\t\t// { dg-error \"not a valid type|conflict\" }\n-    template <B> struct B {};\t// { dg-error \"not a valid type|declaration\" }\n+    typedef A<0> B;\t\t// { dg-error \"previous declaration\" }\n+    template <B> struct B {};\t// { dg-error \"not a valid type|typedef\" }\n };\n \n-A<0> a;\t\t\t\t// { dg-error \"instantiated\" }\n+A<0> a;"}, {"sha": "79a965b16f2539664152cca2677ef8e33ea20899", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/typedef01.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftypedef01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftypedef01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftypedef01.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -37,7 +37,7 @@ struct S {\n   ~S();\n };\n \n-typedef struct S T;\n+typedef struct S T;\t\t// { dg-error \"previous declaration\" }\n \n S a = T();                      // OK \n struct T * p;                   // { dg-error \"\" } using typedef after struct"}, {"sha": "5588651dfe5fef4152fe6ca9423b0fbebed92df8", "filename": "gcc/testsuite/g++.old-deja/g++.other/elab1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Felab1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Felab1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Felab1.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -1,5 +1,5 @@\n // { dg-do assemble  }\n-typedef struct {} S;\n+typedef struct {} S; // { dg-error \"\" } Previous declaration of S\n \n S s1;\n struct S* s2; // { dg-error \"\" } S is a typedef name"}, {"sha": "7aed1f5b14070c963f49629bf9268e5247b8c248", "filename": "gcc/testsuite/g++.old-deja/g++.other/syntax4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsyntax4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/461c6fce5605433279d0d67efa907b87a53db54e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsyntax4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsyntax4.C?ref=461c6fce5605433279d0d67efa907b87a53db54e", "patch": "@@ -17,7 +17,7 @@ class X {\n \n class Y {\n   public:\n-  typedef ::X W;\n+  typedef ::X W;   // { dg-error \"\" } previous declaration\n   class Z;\n };\n "}]}