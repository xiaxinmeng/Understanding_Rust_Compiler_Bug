{"sha": "a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBiYTg2YzNiZWY4NTNmZjhhMGMyODJjMTBjM2UwY2IxODExYTUwNw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-11T14:44:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-11T14:44:18Z"}, "message": "Merge #623\n\n623: Add mappings for canonical paths r=philberty a=philberty\n\nWe need to be able to lookup canonical paths in order\r\nto do proper name mangling as well as give more meaning\r\nfull names to the GENERIC IR. This is important since\r\nthe gcc IR is flat and makes it hard to distinguish which function\r\nis which, especially when modules support will be added.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "1503b24e108ce680a9f959917c2ac8edc02e9746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1503b24e108ce680a9f959917c2ac8edc02e9746"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhE+JCCRBK7hj4Ov3rIwAA7vEIAKCmh3RiIfeM/YehCj1KDKNQ\nrbSaAy4YTV+Sq40tJ5zVhSuaYxePqegAtVxflrGoGuXaHYwrEdaPwI8YZlUeO23b\nRYkKzOfdsGTByK5LkOG1cbyMFU3NWUE6XNqZCpL7fG2GhX0cdFc70LTbAX7fK1pD\n9P19DviwJjAVNG8OQ7/Mv+294jk5ZG7OPQ2maTIIFRBY1SJCGV3iaskhYB7MGX7e\nW3Pgkz6h1Bjp6ezhlHInXlElLk7qyWdXlTaqSlHp5/C8P3Jz38UbbMLnF/0EcAQL\ngq2xHJZGFSSiWYwtiYe/SymGYceCgjtmwGHQ2Zs7YFl9xkuOLzeH0uJV9G8xt9Q=\n=liRv\n-----END PGP SIGNATURE-----\n", "payload": "tree 1503b24e108ce680a9f959917c2ac8edc02e9746\nparent ed64f39213d764206997ee88c2ef89c601763eca\nparent 06ce0a66557f7989a945733e9e51250a7d05f266\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628693058 +0000\ncommitter GitHub <noreply@github.com> 1628693058 +0000\n\nMerge #623\n\n623: Add mappings for canonical paths r=philberty a=philberty\n\nWe need to be able to lookup canonical paths in order\r\nto do proper name mangling as well as give more meaning\r\nfull names to the GENERIC IR. This is important since\r\nthe gcc IR is flat and makes it hard to distinguish which function\r\nis which, especially when modules support will be added.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed64f39213d764206997ee88c2ef89c601763eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed64f39213d764206997ee88c2ef89c601763eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed64f39213d764206997ee88c2ef89c601763eca"}, {"sha": "06ce0a66557f7989a945733e9e51250a7d05f266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ce0a66557f7989a945733e9e51250a7d05f266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ce0a66557f7989a945733e9e51250a7d05f266"}], "stats": {"total": 405, "additions": 270, "deletions": 135}, "files": [{"sha": "7608599391c4062dc8c8e03365f051d81e607668", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "patch": "@@ -52,7 +52,12 @@ class CompileInherentImplItem : public HIRCompileBase\n     ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n-    std::string ident = self->get_name () + \"_\" + constant.get_identifier ();\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      constant.get_mappings ().get_crate_num (),\n+      constant.get_mappings ().get_nodeid (), &canonical_path));\n+\n+    std::string ident = canonical_path->get ();\n     Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n@@ -121,13 +126,18 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (function.has_visibility ())\n       flags |= Backend::function_is_visible;\n \n-    std::string fn_identifier\n-      = self->get_name () + \"_\" + function.get_function_name ();\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      function.get_mappings ().get_crate_num (),\n+      function.get_mappings ().get_nodeid (), &canonical_path));\n+\n+    std::string ir_symbol_name\n+      = canonical_path->get () + fntype->subst_as_string ();\n     std::string asm_name\n       = ctx->mangle_impl_item (self, fntype, function.get_function_name ());\n \n     Bfunction *fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n+      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n "}, {"sha": "719d51c57266e3a4fa2c82bea5653118908e5713", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "patch": "@@ -53,7 +53,12 @@ class CompileItem : public HIRCompileBase\n     Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n \n-    std::string name = var.get_identifier ();\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      var.get_mappings ().get_crate_num (), var.get_mappings ().get_nodeid (),\n+      &canonical_path));\n+\n+    std::string name = canonical_path->get ();\n     std::string asm_name = ctx->mangle_item (resolved_type, name);\n \n     bool is_external = false;\n@@ -81,8 +86,15 @@ class CompileItem : public HIRCompileBase\n     ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n-      type, constant.get_identifier (), value, constant.get_locus ());\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      constant.get_mappings ().get_crate_num (),\n+      constant.get_mappings ().get_nodeid (), &canonical_path));\n+\n+    std::string ident = canonical_path->get ();\n+    Bexpression *const_expr\n+      = ctx->get_backend ()->named_constant_expression (type, ident, value,\n+\t\t\t\t\t\t\tconstant.get_locus ());\n \n     ctx->push_const (const_expr);\n     ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n@@ -149,7 +161,13 @@ class CompileItem : public HIRCompileBase\n     if (is_main_fn || function.has_visibility ())\n       flags |= Backend::function_is_visible;\n \n-    std::string ir_symbol_name = function.get_function_name ();\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      function.get_mappings ().get_crate_num (),\n+      function.get_mappings ().get_nodeid (), &canonical_path));\n+\n+    std::string ir_symbol_name\n+      = canonical_path->get () + fntype->subst_as_string ();\n     std::string asm_name = function.get_function_name ();\n \n     // we don't mangle the main fn since we haven't implemented the main shim"}, {"sha": "1b26a46ff85d51af63728cec556e38db3eb57a18", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 4, "deletions": 106, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "patch": "@@ -20,118 +20,13 @@\n #define RUST_NAME_RESOLVER_H\n \n #include \"rust-system.h\"\n+#include \"rust-canonical-path.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n-//\n-// struct X - path X\n-// impl X { fn test - path X::test }\n-//\n-// struct X<T> - path X\n-//\n-// impl X<T>   { fn test - path X::test}\n-// impl X<i32> { fn test - path X<i32>::test }\n-// impl X<f32> { fn test - path X<f32>::test }\n-//\n-// pub trait Trait { // ::a::Trait\n-//   fn f(&self); // ::a::Trait::f\n-// }\n-//\n-// impl Trait for Struct {\n-//    fn f(&self) {} // <::a::Struct as ::a::Trait>::f\n-// }\n-class CanonicalPath\n-{\n-public:\n-  CanonicalPath (const CanonicalPath &other) : segs (other.segs) {}\n-\n-  CanonicalPath &operator= (const CanonicalPath &other)\n-  {\n-    segs = other.segs;\n-    return *this;\n-  }\n-\n-  static CanonicalPath new_seg (NodeId id, const std::string &path)\n-  {\n-    rust_assert (!path.empty ());\n-    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)});\n-  }\n-\n-  std::string get () const\n-  {\n-    std::string buf;\n-    for (size_t i = 0; i < segs.size (); i++)\n-      {\n-\tbool have_more = (i + 1) < segs.size ();\n-\tconst std::string &seg = segs.at (i).second;\n-\tbuf += seg + (have_more ? \"::\" : \"\");\n-      }\n-    return buf;\n-  }\n-\n-  static CanonicalPath get_big_self (NodeId id)\n-  {\n-    return CanonicalPath::new_seg (id, \"Self\");\n-  }\n-\n-  static CanonicalPath create_empty () { return CanonicalPath ({}); }\n-\n-  bool is_empty () const { return segs.size () == 0; }\n-\n-  CanonicalPath append (const CanonicalPath &other) const\n-  {\n-    rust_assert (!other.is_empty ());\n-    if (is_empty ())\n-      return CanonicalPath (other.segs);\n-\n-    std::vector<std::pair<NodeId, std::string>> copy (segs);\n-    for (auto &s : other.segs)\n-      copy.push_back (s);\n-\n-    return CanonicalPath (copy);\n-  }\n-\n-  // if we have the path A::B::C this will give a callback for each segment\n-  // example:\n-  //   A\n-  //   A::B\n-  //   A::B::C\n-  void iterate (std::function<bool (const CanonicalPath &)> cb) const\n-  {\n-    std::vector<std::pair<NodeId, std::string>> buf;\n-    for (auto &seg : segs)\n-      {\n-\tbuf.push_back (seg);\n-\tif (!cb (CanonicalPath (buf)))\n-\t  return;\n-      }\n-  }\n-\n-  NodeId get_id () const\n-  {\n-    rust_assert (!segs.empty ());\n-    return segs.back ().first;\n-  }\n-\n-  bool operator== (const CanonicalPath &b) const\n-  {\n-    return get ().compare (b.get ()) == 0;\n-  }\n-\n-  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n-\n-private:\n-  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path)\n-    : segs (path)\n-  {}\n-\n-  std::vector<std::pair<NodeId, std::string>> segs;\n-};\n-\n class Rib\n {\n public:\n@@ -167,6 +62,9 @@ class Rib\n     reverse_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n     decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n+\n+    auto mappings = Analysis::Mappings::get ();\n+    mappings->insert_canonical_path (mappings->get_current_crate (), id, path);\n   }\n \n   bool lookup_name (const CanonicalPath &ident, NodeId *id)"}, {"sha": "d6ba90da99532cba1f29b90590914bd5742c6e64", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "patch": "@@ -0,0 +1,141 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CANONICAL_PATH\n+#define RUST_CANONICAL_PATH\n+\n+#include \"rust-system.h\"\n+#include \"rust-mapping-common.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n+//\n+// struct X - path X\n+// impl X { fn test - path X::test }\n+//\n+// struct X<T> - path X\n+//\n+// impl X<T>   { fn test - path X::test}\n+// impl X<i32> { fn test - path X<i32>::test }\n+// impl X<f32> { fn test - path X<f32>::test }\n+//\n+// pub trait Trait { // ::a::Trait\n+//   fn f(&self); // ::a::Trait::f\n+// }\n+//\n+// impl Trait for Struct {\n+//    fn f(&self) {} // <::a::Struct as ::a::Trait>::f\n+// }\n+class CanonicalPath\n+{\n+public:\n+  CanonicalPath (const CanonicalPath &other) : segs (other.segs) {}\n+\n+  CanonicalPath &operator= (const CanonicalPath &other)\n+  {\n+    segs = other.segs;\n+    return *this;\n+  }\n+\n+  static CanonicalPath new_seg (NodeId id, const std::string &path)\n+  {\n+    rust_assert (!path.empty ());\n+    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)});\n+  }\n+\n+  std::string get () const\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < segs.size (); i++)\n+      {\n+\tbool have_more = (i + 1) < segs.size ();\n+\tconst std::string &seg = segs.at (i).second;\n+\tbuf += seg + (have_more ? \"::\" : \"\");\n+      }\n+    return buf;\n+  }\n+\n+  static CanonicalPath get_big_self (NodeId id)\n+  {\n+    return CanonicalPath::new_seg (id, \"Self\");\n+  }\n+\n+  static CanonicalPath create_empty () { return CanonicalPath ({}); }\n+\n+  bool is_empty () const { return segs.size () == 0; }\n+\n+  CanonicalPath append (const CanonicalPath &other) const\n+  {\n+    rust_assert (!other.is_empty ());\n+    if (is_empty ())\n+      return CanonicalPath (other.segs);\n+\n+    std::vector<std::pair<NodeId, std::string>> copy (segs);\n+    for (auto &s : other.segs)\n+      copy.push_back (s);\n+\n+    return CanonicalPath (copy);\n+  }\n+\n+  // if we have the path A::B::C this will give a callback for each segment\n+  // example:\n+  //   A\n+  //   A::B\n+  //   A::B::C\n+  void iterate (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    std::vector<std::pair<NodeId, std::string>> buf;\n+    for (auto &seg : segs)\n+      {\n+\tbuf.push_back (seg);\n+\tif (!cb (CanonicalPath (buf)))\n+\t  return;\n+      }\n+  }\n+\n+  size_t size () const { return segs.size (); }\n+\n+  NodeId get_id () const\n+  {\n+    rust_assert (!segs.empty ());\n+    return segs.back ().first;\n+  }\n+\n+  bool is_equal (const CanonicalPath &b) const\n+  {\n+    return get ().compare (b.get ()) == 0;\n+  }\n+\n+  bool operator== (const CanonicalPath &b) const { return is_equal (b); }\n+\n+  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n+\n+private:\n+  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path)\n+    : segs (path)\n+  {}\n+\n+  std::vector<std::pair<NodeId, std::string>> segs;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_CANONICAL_PATH"}, {"sha": "5c839b0af586712ddf181247b61a79eb608591b1", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "patch": "@@ -21,32 +21,13 @@\n \n #include \"rust-system.h\"\n #include \"rust-location.h\"\n+#include \"rust-mapping-common.h\"\n+#include \"rust-canonical-path.h\"\n \n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n \n namespace Rust {\n-\n-// refers to a Crate\n-typedef uint32_t CrateNum;\n-// refers to any node in the AST in current Crate\n-typedef uint32_t NodeId;\n-// refers to any node in the HIR for the current crate\n-typedef uint32_t HirId;\n-// refers to any top-level decl in HIR\n-typedef uint32_t LocalDefId;\n-// refers to <Crate><DefId>\n-typedef uint64_t DefId;\n-\n-#define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n-#define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n-\n-#define UNKNOWN_CREATENUM ((uint32_t) (0))\n-#define UNKNOWN_NODEID ((uint32_t) (0))\n-#define UNKNOWN_HIRID ((uint32_t) (0))\n-#define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n-#define UNKNOWN_DEFID ((uint64_t) (0))\n-\n namespace Analysis {\n \n class NodeMapping\n@@ -247,6 +228,42 @@ class Mappings\n     return lookup->second;\n   }\n \n+  void insert_canonical_path (CrateNum crate, NodeId id,\n+\t\t\t      const Resolver::CanonicalPath path)\n+  {\n+    const Resolver::CanonicalPath *p = nullptr;\n+    if (lookup_canonical_path (crate, id, &p))\n+      {\n+\t// if we have already stored a canonical path this is ok so long as this\n+\t// new path is equal or is smaller that the existing one but in that\n+\t// case we ignore it.\n+\tif (p->is_equal (path))\n+\t  return;\n+\telse\n+\t  {\n+\t    rust_assert (p->size () >= path.size ());\n+\t    return;\n+\t  }\n+      }\n+\n+    paths[crate].emplace (id, std::move (path));\n+  }\n+\n+  bool lookup_canonical_path (CrateNum crate, NodeId id,\n+\t\t\t      const Resolver::CanonicalPath **path)\n+  {\n+    auto it = paths.find (crate);\n+    if (it == paths.end ())\n+      return false;\n+\n+    auto iy = it->second.find (id);\n+    if (iy == it->second.end ())\n+      return false;\n+\n+    *path = &iy->second;\n+    return true;\n+  }\n+\n private:\n   Mappings ();\n \n@@ -283,6 +300,9 @@ class Mappings\n     hirGenericParamMappings;\n   std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n \n+  // canonical paths\n+  std::map<CrateNum, std::map<NodeId, const Resolver::CanonicalPath> > paths;\n+\n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;\n "}, {"sha": "45af11b253528d000179cdf3f799f0302a50f896", "filename": "gcc/rust/util/rust-mapping-common.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Futil%2Frust-mapping-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ba86c3bef853ff8a0c282c10c3e0cb1811a507/gcc%2Frust%2Futil%2Frust-mapping-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-mapping-common.h?ref=a0ba86c3bef853ff8a0c282c10c3e0cb1811a507", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MAPPING_COMMON\n+#define RUST_MAPPING_COMMON\n+\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+\n+// refers to a Crate\n+typedef uint32_t CrateNum;\n+// refers to any node in the AST in current Crate\n+typedef uint32_t NodeId;\n+// refers to any node in the HIR for the current crate\n+typedef uint32_t HirId;\n+// refers to any top-level decl in HIR\n+typedef uint32_t LocalDefId;\n+// refers to <Crate><DefId>\n+typedef uint64_t DefId;\n+\n+#define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n+#define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n+\n+#define UNKNOWN_CREATENUM ((uint32_t) (0))\n+#define UNKNOWN_NODEID ((uint32_t) (0))\n+#define UNKNOWN_HIRID ((uint32_t) (0))\n+#define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n+#define UNKNOWN_DEFID ((uint64_t) (0))\n+\n+} // namespace Rust\n+\n+#endif // RUST_MAPPING_COMMON"}]}