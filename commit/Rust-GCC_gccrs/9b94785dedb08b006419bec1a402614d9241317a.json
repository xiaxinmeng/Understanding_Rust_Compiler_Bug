{"sha": "9b94785dedb08b006419bec1a402614d9241317a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5NDc4NWRlZGIwOGIwMDY0MTliZWMxYTQwMjYxNGQ5MjQxMzE3YQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-27T16:36:39Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-27T16:36:39Z"}, "message": "c++: Relax rule for non-type arguments in partial specs [CWG1315]\n\nThis implements the wording changes of CWG 1315, which permits non-type\ntemplate arguments in a partial specialization to use template\nparameters more freely.  Delightfully, it seems the only change needed\nis to remove a single check from process_partial_specialization (amidst\na bunch of whitespace changes).\n\nBut that change alone revealed a latent problem with for_each_template_parm:\nit ends up looking into some non-deduced contexts even when\ninclude_nondeduced_p is false.  This causes us to silently accept some\npartial specializations within the testsuite that contain non-deducible\nnon-type template parameters (and that were previously rejected due to\nthe rule that CWG 1315 relaxed).  For now this patch makes a minimal\namount of changes to for_each_template_parm_r so that we continue to\nreject existing ill-formed partial specializations within the testsuite.\nI opened PR c++/100779 to track this issue.\n\n\tDR 1315\n\tPR c++/67593\n\tPR c++/96555\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (process_partial_specialization): Don't error on a\n\tnon-simple non-type template argument that involves template\n\tparameters.\n\t(for_each_template_parm_r): Don't walk TRAIT_EXPR, PLUS_EXPR,\n\tMULT_EXPR, or SCOPE_REF when include_nondeduced_p is false.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/partial16.C: New test.\n\t* g++.dg/template/partial17.C: New test.\n\t* g++.dg/template/partial18.C: New test.\n\t* g++.dg/template/partial19.C: New test.\n\t* g++.dg/cpp0x/pr68724.C: Adjust expected diagnostic for\n\till-formed partial specialization.\n\t* g++.dg/cpp0x/variadic38.C: Likewise.\n\t* g++.dg/cpp1z/pr81016.C: Likewise.\n\t* g++.dg/template/partial5.C: Likewise.\n\t* g++.old-deja/g++.pt/spec21.C: Likewise.", "tree": {"sha": "59096fb71206556a3ed33d90926ca9163c895a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59096fb71206556a3ed33d90926ca9163c895a19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b94785dedb08b006419bec1a402614d9241317a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b94785dedb08b006419bec1a402614d9241317a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b94785dedb08b006419bec1a402614d9241317a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b94785dedb08b006419bec1a402614d9241317a/comments", "author": null, "committer": null, "parents": [{"sha": "6c67afaf524a5e0e9220f78271a0f5764ca27bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c67afaf524a5e0e9220f78271a0f5764ca27bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c67afaf524a5e0e9220f78271a0f5764ca27bd0"}], "stats": {"total": 185, "additions": 114, "deletions": 71}, "files": [{"sha": "e4950aa448a575549ebb7be9a5e9609b5437038c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 57, "deletions": 65, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -5157,11 +5157,7 @@ process_partial_specialization (tree decl)\n \t\tmaintmpl);\n     }\n \n-  /* [temp.class.spec]\n-\n-     A partially specialized non-type argument expression shall not\n-     involve template parameters of the partial specialization except\n-     when the argument expression is a simple identifier.\n+  /* [temp.spec.partial]\n \n      The type of a template parameter corresponding to a specialized\n      non-type argument shall not be dependent on a parameter of the\n@@ -5222,63 +5218,55 @@ process_partial_specialization (tree decl)\n \t\t    || TREE_CODE (arg) == VIEW_CONVERT_EXPR)\n \t\t   && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_PARM_INDEX))\n             {\n-              if ((!packed_args && tpd.arg_uses_template_parms[i])\n-                  || (packed_args && uses_template_parms (arg)))\n-\t\terror_at (cp_expr_loc_or_input_loc (arg),\n-\t\t\t  \"template argument %qE involves template \"\n-\t\t\t  \"parameter(s)\", arg);\n-              else \n-                {\n-                  /* Look at the corresponding template parameter,\n-                     marking which template parameters its type depends\n-                     upon.  */\n-                  tree type = TREE_TYPE (parm);\n+\t      /* Look at the corresponding template parameter,\n+\t\t marking which template parameters its type depends\n+\t\t upon.  */\n+\t      tree type = TREE_TYPE (parm);\n \n-                  if (!tpd2.parms)\n-                    {\n-                      /* We haven't yet initialized TPD2.  Do so now.  */\n-                      tpd2.arg_uses_template_parms = XALLOCAVEC (int, nargs);\n-                      /* The number of parameters here is the number in the\n-                         main template, which, as checked in the assertion\n-                         above, is NARGS.  */\n-                      tpd2.parms = XALLOCAVEC (int, nargs);\n-                      tpd2.level = \n-                        TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (maintmpl));\n-                    }\n+\t      if (!tpd2.parms)\n+\t\t{\n+\t\t  /* We haven't yet initialized TPD2.  Do so now.  */\n+\t\t  tpd2.arg_uses_template_parms = XALLOCAVEC (int, nargs);\n+\t\t  /* The number of parameters here is the number in the\n+\t\t     main template, which, as checked in the assertion\n+\t\t     above, is NARGS.  */\n+\t\t  tpd2.parms = XALLOCAVEC (int, nargs);\n+\t\t  tpd2.level =\n+\t\t    TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (maintmpl));\n+\t\t}\n \n-                  /* Mark the template parameters.  But this time, we're\n-                     looking for the template parameters of the main\n-                     template, not in the specialization.  */\n-                  tpd2.current_arg = i;\n-                  tpd2.arg_uses_template_parms[i] = 0;\n-                  memset (tpd2.parms, 0, sizeof (int) * nargs);\n-                  for_each_template_parm (type,\n-                                          &mark_template_parm,\n-                                          &tpd2,\n-                                          NULL,\n-\t\t\t\t\t  /*include_nondeduced_p=*/false);\n-\n-                  if (tpd2.arg_uses_template_parms [i])\n-                    {\n-                      /* The type depended on some template parameters.\n-                         If they are fully specialized in the\n-                         specialization, that's OK.  */\n-                      int j;\n-                      int count = 0;\n-                      for (j = 0; j < nargs; ++j)\n-                        if (tpd2.parms[j] != 0\n-                            && tpd.arg_uses_template_parms [j])\n-                          ++count;\n-                      if (count != 0)\n-                        error_n (input_location, count,\n-                                 \"type %qT of template argument %qE depends \"\n-                                 \"on a template parameter\",\n-                                 \"type %qT of template argument %qE depends \"\n-                                 \"on template parameters\",\n-                                 type,\n-                                 arg);\n-                    }\n-                }\n+\t      /* Mark the template parameters.  But this time, we're\n+\t\t looking for the template parameters of the main\n+\t\t template, not in the specialization.  */\n+\t      tpd2.current_arg = i;\n+\t      tpd2.arg_uses_template_parms[i] = 0;\n+\t      memset (tpd2.parms, 0, sizeof (int) * nargs);\n+\t      for_each_template_parm (type,\n+\t\t\t\t      &mark_template_parm,\n+\t\t\t\t      &tpd2,\n+\t\t\t\t      NULL,\n+\t\t\t\t      /*include_nondeduced_p=*/false);\n+\n+\t      if (tpd2.arg_uses_template_parms [i])\n+\t\t{\n+\t\t  /* The type depended on some template parameters.\n+\t\t     If they are fully specialized in the\n+\t\t     specialization, that's OK.  */\n+\t\t  int j;\n+\t\t  int count = 0;\n+\t\t  for (j = 0; j < nargs; ++j)\n+\t\t    if (tpd2.parms[j] != 0\n+\t\t\t&& tpd.arg_uses_template_parms [j])\n+\t\t      ++count;\n+\t\t  if (count != 0)\n+\t\t    error_n (input_location, count,\n+\t\t\t     \"type %qT of template argument %qE depends \"\n+\t\t\t     \"on a template parameter\",\n+\t\t\t     \"type %qT of template argument %qE depends \"\n+\t\t\t     \"on template parameters\",\n+\t\t\t     type,\n+\t\t\t     arg);\n+\t\t}\n             }\n         }\n     }\n@@ -10502,6 +10490,15 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \treturn error_mark_node;\n       break;\n \n+    case TRAIT_EXPR:\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case SCOPE_REF:\n+      /* These are non-deduced contexts.  */\n+      if (!pfd->include_nondeduced_p)\n+\t*walk_subtrees = 0;\n+      break;\n+\n     case MODOP_EXPR:\n     case CAST_EXPR:\n     case IMPLICIT_CONV_EXPR:\n@@ -10517,11 +10514,6 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \treturn error_mark_node;\n       break;\n \n-    case SCOPE_REF:\n-      if (pfd->include_nondeduced_p)\n-\tWALK_SUBTREE (TREE_OPERAND (t, 0));\n-      break;\n-\n     case REQUIRES_EXPR:\n       {\n \tif (!fn)"}, {"sha": "6df7f718a7e10f45a43be68a193298aa5f164a4c", "filename": "gcc/testsuite/g++.dg/cpp0x/pr68724.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr68724.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr68724.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr68724.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -9,7 +9,7 @@ struct integral_constant\n integral_constant<bool, true> inst;\n \n template <typename _Tp>\n-struct integral_constant<bool, __is_enum(_Tp)> // { dg-error \"32:template argument\" }\n+struct integral_constant<bool, __is_enum(_Tp)> // { dg-error \"not deducible\" }\n {\n };\n "}, {"sha": "49fa48c3bd2944f5dcf6d8db0348df8cb7ee7170", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic38.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic38.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -3,4 +3,4 @@ template<int... Values>\n struct int_vec {};\n \n template<int... Values>\n-struct int_vec<0, (Values+1)...> {}; // { dg-error \"26:template argument\" }\n+struct int_vec<0, (Values+1)...> {}; // { dg-error \"not deducible\" }"}, {"sha": "a17afcc6b65f33bdabc74d19fea71a9617b0bb8d", "filename": "gcc/testsuite/g++.dg/cpp1z/pr81016.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fpr81016.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fpr81016.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fpr81016.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -1,4 +1,4 @@\n // { dg-do compile { target c++17 } }\n \n template <typename a, a> struct b;\n-template <typename c> struct b<bool, c::d>; // { dg-error \"template parameter\" }\n+template <typename c> struct b<bool, c::d>; // { dg-error \"not deducible\" }"}, {"sha": "30c34c3e0d988b64e5312e5fdb7a9001e2277762", "filename": "gcc/testsuite/g++.dg/template/partial16.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial16.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -0,0 +1,8 @@\n+// [temp.spec.partial.general]/9\n+\n+template <class T, T t> struct C {};\n+template <class T> struct C<T, 1>;              // { dg-error \"depends on a template parameter\" }\n+\n+template< int X, int (*array_ptr)[X] > class A {};\n+int array[5];\n+template< int X > class A<X,&array> { };        // { dg-error \"depends on a template parameter\" }"}, {"sha": "d5c82d26db309de1b1e143d9fd406ebf742550d3", "filename": "gcc/testsuite/g++.dg/template/partial17.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial17.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -0,0 +1,14 @@\n+// [temp.spec.partial.match]/3\n+\n+template <int I, int J> struct A;\n+template <int I> struct A<I+5, I*2> {};     // { dg-error \"not deducible\" }\n+\n+template <int I> struct A<I, I> {};         // OK\n+\n+template <int I, int J, int K> struct B;\n+template <int I> struct B<I, I*2, I> {};    // OK\n+template <int I> struct B<I, I*2, 2> { typedef int type; };    // OK\n+\n+B<1, 2, 1> b1;\n+B<1, 2, 2>::type b2;\n+B<1, 2, 3> b3; // { dg-error \"incomplete\" }"}, {"sha": "7b7614ebc6b3df27e5ec7a6ff3e28fb43708bce1", "filename": "gcc/testsuite/g++.dg/template/partial18.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial18.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/96555\n+\n+template<class T, int i>\n+struct X;\n+\n+template<class T>\n+struct X<T, sizeof(T)> {};\n+\n+X<int, sizeof(int)> x1;\n+X<int, sizeof(int)+1> x2; // { dg-error \"incomplete\" }\n+\n+\n+struct A { int x; } a;\n+template<int, int> struct B;\n+template<int y>\n+struct B<y, sizeof(a.x)> { };\n+\n+B<0, sizeof(int)> b1;\n+B<0, sizeof(int)+1> b2; // { dg-error \"incomplete\" }"}, {"sha": "39149d220b46977a1321017bab71b6529a4aee5a", "filename": "gcc/testsuite/g++.dg/template/partial19.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial19.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/67593\n+// { dg-do compile { target c++11 } }\n+\n+template<class T>\n+struct outer {\n+  template<T...> struct inner;\n+  template<T... Vs> struct inner<T{}, Vs...> {};\n+};\n+\n+outer<int>::inner<0, 0> x1;\n+outer<int>::inner<1, 0> x2; // { dg-error \"incomplete\" }"}, {"sha": "037f684cbd2a64da13d7634a8098b6e018692d8f", "filename": "gcc/testsuite/g++.dg/template/partial5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -21,4 +21,4 @@ template<typename T, T V>\n struct Z { };\n \n template<typename T>\n-struct Z<T, (T)0> { }; // { dg-error \"13:template argument\" }\n+struct Z<T, (T)0> { }; // { dg-error \"depends on a template parameter\" }"}, {"sha": "bf25c0ebb39e36da9f300f77e7ca262de076a9af", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec21.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94785dedb08b006419bec1a402614d9241317a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec21.C?ref=9b94785dedb08b006419bec1a402614d9241317a", "patch": "@@ -4,8 +4,7 @@ template <class T> struct S {};\n template <class T = int> struct S<T*> {}; // { dg-error \"\" } default argument\n \n template <int I, int J> struct A {};\n-template <int I> struct A<I+5, I*2> {}; // { dg-error \"28:template argument\" }\n-// { dg-error \"33:template argument\" \"\" { target *-*-* } .-1 }\n+template <int I> struct A<I+5, I*2> {}; // { dg-error \"not deducible\" }\n template <class T, T t> struct C {};\n template <class T> struct C<T, 1>;  // { dg-error \"\" } type depends on parameter\n int i;"}]}