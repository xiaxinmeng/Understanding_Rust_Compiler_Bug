{"sha": "894d8b416343817776946da50d0b660f20742921", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0ZDhiNDE2MzQzODE3Nzc2OTQ2ZGE1MGQwYjY2MGYyMDc0MjkyMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-28T21:04:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-28T21:04:51Z"}, "message": "target.def (min_arithmetic_precision): New hook.\n\n\t* target.def (min_arithmetic_precision): New hook.\n\t* doc/tm.texi.in (Misc): Add TARGET_MIN_ARITHMETIC_PRECISION.\n\t* doc/tm.texi: Regenerate.\n\t* internal-fn.c (expand_arith_overflow): Adjust handling of target\n\tdependent support by means of TARGET_MIN_ARITHMETIC_PRECISION.\n\t* targhooks.c (default_min_arithmetic_precision): New function.\n\t* targhooks.h (default_min_arithmetic_precision): Declare.\n\t* config/sparc/sparc.c (TARGET_MIN_ARITHMETIC_PRECISION): Define.\n\t(sparc_min_arithmetic_precision): New function.\n\nFrom-SVN: r241665", "tree": {"sha": "6629e80a0c1643c5764bfcff920a90bf7a2fa59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6629e80a0c1643c5764bfcff920a90bf7a2fa59c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/894d8b416343817776946da50d0b660f20742921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894d8b416343817776946da50d0b660f20742921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894d8b416343817776946da50d0b660f20742921", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894d8b416343817776946da50d0b660f20742921/comments", "author": null, "committer": null, "parents": [{"sha": "9a5e1efcaca6305711e7d44b355e98c923f27c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5e1efcaca6305711e7d44b355e98c923f27c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5e1efcaca6305711e7d44b355e98c923f27c6d"}], "stats": {"total": 201, "additions": 180, "deletions": 21}, "files": [{"sha": "3687ecd4a367c5752f6426ff3decc2ca31127060", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -1,3 +1,15 @@\n+2016-10-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* target.def (min_arithmetic_precision): New hook.\n+\t* doc/tm.texi.in (Misc): Add TARGET_MIN_ARITHMETIC_PRECISION.\n+\t* doc/tm.texi: Regenerate.\n+\t* internal-fn.c (expand_arith_overflow): Adjust handling of target\n+\tdependent support by means of TARGET_MIN_ARITHMETIC_PRECISION.\n+\t* targhooks.c (default_min_arithmetic_precision): New function.\n+\t* targhooks.h (default_min_arithmetic_precision): Declare.\n+\t* config/sparc/sparc.c (TARGET_MIN_ARITHMETIC_PRECISION): Define.\n+\t(sparc_min_arithmetic_precision): New function.\n+\n 2016-10-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/71847\n@@ -13,7 +25,7 @@\n \n \tPR tree-optimization/43721\n \t* target.def: New hook expand_divmod_libfunc.\n-\t* doc/tm.texi.in: Add hook for TARGET_EXPAND_DIVMOD_LIBFUNC\n+\t* doc/tm.texi.in: Add hook for TARGET_EXPAND_DIVMOD_LIBFUNC.\n \t* doc/tm.texi: Regenerate.\n \t* internal-fn.def: Add new entry for DIVMOD ifn.\n \t* internal-fn.c (expand_DIVMOD): New.\n@@ -23,10 +35,9 @@\n \t(target_supports_divmod_p): New.\n \t(divmod_candidate_p): Likewise.\n \t(convert_to_divmod): Likewise.\n-\t(pass_optimize_widening_mul::execute): Call\n-\tcalculate_dominance_info(), renumber_gimple_stmt_uids() at\n-\tbeginning of function. Call convert_to_divmod()\n-\tand record stats for divmod.\n+\t(pass_optimize_widening_mul::execute): Call calculate_dominance_info,\n+\trenumber_gimple_stmt_uids at beginning of function. Call\n+\tconvert_to_divmod and record stats for divmod.\n \t* config/arm/arm.c (arm_expand_divmod_libfunc): Override hook\n \tTARGET_EXPAND_DIVMOD_LIBFUNC.\n \t* doc/sourcebuild.texi: Add items for arm_divmod_simode, divmod,"}, {"sha": "2d1f598434bfa5e9f333530def64a9cb9c451dc9", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -648,6 +648,7 @@ static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n static machine_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n+static unsigned int sparc_min_arithmetic_precision (void);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -866,6 +867,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_FIXED_CONDITION_CODE_REGS\n #define TARGET_FIXED_CONDITION_CODE_REGS sparc_fixed_condition_code_regs\n \n+#undef TARGET_MIN_ARITHMETIC_PRECISION\n+#define TARGET_MIN_ARITHMETIC_PRECISION sparc_min_arithmetic_precision\n+\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n@@ -2749,6 +2753,14 @@ sparc_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n   return true;\n }\n \n+/* Implement TARGET_MIN_ARITHMETIC_PRECISION.  */\n+\n+static unsigned int\n+sparc_min_arithmetic_precision (void)\n+{\n+  return 32;\n+}\n+\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n    CCFP[E]mode is used.  CCNZmode should be used when the first operand"}, {"sha": "0aed3d4f1bbc8e6fe9c6a936ae7ae0ce7fea5ac5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -10623,6 +10623,23 @@ smaller than a word are always performed on the entire register.\n Most RISC machines have this property and most CISC machines do not.\n @end defmac\n \n+@deftypefn {Target Hook} {unsigned int} TARGET_MIN_ARITHMETIC_PRECISION (void)\n+On some RISC architectures with 64-bit registers, the processor also\n+maintains 32-bit condition codes that make it possible to do real 32-bit\n+arithmetic, although the operations are performed on the full registers.\n+\n+On such architectures, defining this hook to 32 tells the compiler to try\n+using 32-bit arithmetical operations setting the condition codes instead\n+of doing full 64-bit arithmetic.\n+\n+More generally, define this hook on RISC architectures if you want the\n+compiler to try using arithmetical operations setting the condition codes\n+with a precision lower than the word precision.\n+\n+You need not define this hook if @code{WORD_REGISTER_OPERATIONS} is not\n+defined to 1.\n+@end deftypefn\n+\n @defmac LOAD_EXTEND_OP (@var{mem_mode})\n Define this macro to be a C expression indicating when insns that read\n memory in @var{mem_mode}, an integral mode narrower than a word, set the"}, {"sha": "9e5b45661a942d3f9ac15a1ba205c64bb804c474", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -7577,6 +7577,8 @@ smaller than a word are always performed on the entire register.\n Most RISC machines have this property and most CISC machines do not.\n @end defmac\n \n+@hook TARGET_MIN_ARITHMETIC_PRECISION\n+\n @defmac LOAD_EXTEND_OP (@var{mem_mode})\n Define this macro to be a C expression indicating when insns that read\n memory in @var{mem_mode}, an integral mode narrower than a word, set the"}, {"sha": "168adc68105924dda28103f381e1f962e7f5111d", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -1836,12 +1836,11 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n \t  return;\n \t}\n \n-      /* For sub-word operations, if target doesn't have them, start\n-\t with precres widening right away, otherwise do it only\n-\t if the most simple cases can't be used.  */\n-      if (WORD_REGISTER_OPERATIONS\n-\t  && orig_precres == precres\n-\t  && precres < BITS_PER_WORD)\n+      /* For operations with low precision, if target doesn't have them, start\n+\t with precres widening right away, otherwise do it only if the most\n+\t simple cases can't be used.  */\n+      const int min_precision = targetm.min_arithmetic_precision ();\n+      if (orig_precres == precres && precres < min_precision)\n \t;\n       else if ((uns0_p && uns1_p && unsr_p && prec0 <= precres\n \t\t&& prec1 <= precres)\n@@ -1876,7 +1875,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n       /* For sub-word operations, retry with a wider type first.  */\n       if (orig_precres == precres && precop <= BITS_PER_WORD)\n \t{\n-\t  int p = WORD_REGISTER_OPERATIONS ? BITS_PER_WORD : precop;\n+\t  int p = MAX (min_precision, precop);\n \t  enum machine_mode m = smallest_mode_for_size (p, MODE_INT);\n \t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n \t\t\t\t\t\t\tuns0_p && uns1_p"}, {"sha": "c3c87b031b38c2c650dad7b804c789e7d89ae3a3", "filename": "gcc/target.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -5941,6 +5941,24 @@ comparison code or operands.\",\n  void, (int *code, rtx *op0, rtx *op1, bool op0_preserve_value),\n  default_canonicalize_comparison)\n \n+DEFHOOK\n+(min_arithmetic_precision,\n+ \"On some RISC architectures with 64-bit registers, the processor also\\n\\\n+maintains 32-bit condition codes that make it possible to do real 32-bit\\n\\\n+arithmetic, although the operations are performed on the full registers.\\n\\\n+\\n\\\n+On such architectures, defining this hook to 32 tells the compiler to try\\n\\\n+using 32-bit arithmetical operations setting the condition codes instead\\n\\\n+of doing full 64-bit arithmetic.\\n\\\n+\\n\\\n+More generally, define this hook on RISC architectures if you want the\\n\\\n+compiler to try using arithmetical operations setting the condition codes\\n\\\n+with a precision lower than the word precision.\\n\\\n+\\n\\\n+You need not define this hook if @code{WORD_REGISTER_OPERATIONS} is not\\n\\\n+defined to 1.\",\n+ unsigned int, (void), default_min_arithmetic_precision)\n+\n DEFHOOKPOD\n (atomic_test_and_set_trueval,\n  \"This value should be set if the result written by\\"}, {"sha": "866747a9ddf57d71afdb8882bcc1edf683497fa8", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -2127,4 +2127,12 @@ default_max_noce_ifcvt_seq_cost (edge e)\n     return BRANCH_COST (true, predictable_p) * COSTS_N_INSNS (3);\n }\n \n+/* Default implementation of TARGET_MIN_ARITHMETIC_PRECISION.  */\n+\n+unsigned int\n+default_min_arithmetic_precision (void)\n+{\n+  return WORD_REGISTER_OPERATIONS ? BITS_PER_WORD : BITS_PER_UNIT;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "94f5e31f80f7d66bc963dfc657b05c9cf7eea74a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -260,7 +260,7 @@ extern void default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE\n \t\t\t\t\t\t  int second_time ATTRIBUTE_UNUSED);\n extern bool default_optab_supported_p (int, machine_mode, machine_mode,\n \t\t\t\t       optimization_type);\n-\n extern unsigned int default_max_noce_ifcvt_seq_cost (edge);\n+extern unsigned int default_min_arithmetic_precision (void);\n \n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "087d4f3b359af57d77c6ba6fac3bbd199cfeb720", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -1,3 +1,9 @@\n+2016-10-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/overflow-3.c: Replace and move old one to...\n+\t* gcc.target/sparc/overflow-4.c: ...here.\n+\t* gcc.target/sparc/overflow-5.c: New test.\n+\n 2016-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \t    Kugan Vivekanandarajah  <kuganv@linaro.org>\n \t    Jim Wilson  <jim.wilson@linaro.org>"}, {"sha": "8cb24f52f7b45312a67748aa45fcd4a5798c9ab8", "filename": "gcc/testsuite/gcc.target/sparc/overflow-3.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-3.c?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -5,40 +5,39 @@\n #include <stdbool.h>\n #include <stdint.h>\n \n-bool my_uadd_overflow (uint64_t a, uint64_t b, uint64_t *res)\n+bool my_uadd_overflow (uint32_t a, uint32_t b, uint32_t *res)\n {\n   return __builtin_add_overflow (a, b, res);\n }\n \n-bool my_usub_overflow (uint64_t a, uint64_t b, uint64_t *res)\n+bool my_usub_overflow (uint32_t a, uint32_t b, uint32_t *res)\n {\n   return __builtin_sub_overflow (a, b, res);\n }\n \n-bool my_uneg_overflow (uint64_t a, uint64_t *res)\n+bool my_uneg_overflow (uint32_t a, uint32_t *res)\n {\n   return __builtin_sub_overflow (0, a, res);\n }\n \n-bool my_add_overflow (int64_t a, int64_t b, int64_t *res)\n+bool my_add_overflow (int32_t a, int32_t b, int32_t *res)\n {\n   return __builtin_add_overflow (a, b, res);\n }\n \n-bool my_sub_overflow (int64_t a, int64_t b, int64_t *res)\n+bool my_sub_overflow (int32_t a, int32_t b, int32_t *res)\n {\n   return __builtin_sub_overflow (a, b, res);\n }\n \n-bool my_neg_overflow (int64_t a, int64_t *res)\n+bool my_neg_overflow (int32_t a, int32_t *res)\n {\n   return __builtin_sub_overflow (0, a, res);\n }\n \n /* { dg-final { scan-assembler-times \"addcc\\t%\" 2 } } */\n /* { dg-final { scan-assembler-times \"subcc\\t%\" 4 } } */\n-/* { dg-final { scan-assembler-times \"movlu\\t%\" 1 } } */\n-/* { dg-final { scan-assembler-times \"blu\" 2 } } */\n+/* { dg-final { scan-assembler-times \"addx\\t%\" 3 } } */\n /* { dg-final { scan-assembler-times \"bvs\" 3 } } */\n /* { dg-final { scan-assembler-not \"cmp\\t%\" } } */\n /* { dg-final { scan-assembler-not \"save\\t%\" } } */"}, {"sha": "31b326486ee9108a9b5aa4cc0bdae3c3915f15e0", "filename": "gcc/testsuite/gcc.target/sparc/overflow-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-4.c?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdbool.h>\n+#include <stdint.h>\n+\n+bool my_uadd_overflow (uint64_t a, uint64_t b, uint64_t *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_usub_overflow (uint64_t a, uint64_t b, uint64_t *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_uneg_overflow (uint64_t a, uint64_t *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+bool my_add_overflow (int64_t a, int64_t b, int64_t *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_sub_overflow (int64_t a, int64_t b, int64_t *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_neg_overflow (int64_t a, int64_t *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+/* { dg-final { scan-assembler-times \"addcc\\t%\" 2 } } */\n+/* { dg-final { scan-assembler-times \"subcc\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"movlu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"blu\" 2 } } */\n+/* { dg-final { scan-assembler-times \"bvs\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmp\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"save\\t%\" } } */"}, {"sha": "501ce04f7a12c3c2168dc41bd680ccddbb1e228b", "filename": "gcc/testsuite/gcc.target/sparc/overflow-5.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/894d8b416343817776946da50d0b660f20742921/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Foverflow-5.c?ref=894d8b416343817776946da50d0b660f20742921", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mvis3\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdbool.h>\n+#include <stdint.h>\n+\n+bool my_uadd_overflow (uint64_t a, uint64_t b, uint64_t *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_usub_overflow (uint64_t a, uint64_t b, uint64_t *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_uneg_overflow (uint64_t a, uint64_t *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+bool my_add_overflow (int64_t a, int64_t b, int64_t *res)\n+{\n+  return __builtin_add_overflow (a, b, res);\n+}\n+\n+bool my_sub_overflow (int64_t a, int64_t b, int64_t *res)\n+{\n+  return __builtin_sub_overflow (a, b, res);\n+}\n+\n+bool my_neg_overflow (int64_t a, int64_t *res)\n+{\n+  return __builtin_sub_overflow (0, a, res);\n+}\n+\n+/* { dg-final { scan-assembler-times \"addcc\\t%\" 2 } } */\n+/* { dg-final { scan-assembler-times \"subcc\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"addxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"bvs\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmp\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"save\\t%\" } } */"}]}