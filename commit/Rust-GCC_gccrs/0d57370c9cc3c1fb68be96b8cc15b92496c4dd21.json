{"sha": "0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ1NzM3MGM5Y2MzYzFmYjY4YmU5NmI4Y2MxNWI5MjQ5NmM0ZGQyMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-06T13:31:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-07T14:09:03Z"}, "message": "libstdc++: Optimize C++20 comparison category types\n\nThis reduces the size and alignment of all three comparison category\ntypes to a single byte. The partial_ordering::_M_is_ordered flag is\nreplaced by the value 0x02 in the _M_value member.\n\nThis also optimizes conversion and comparison operators to avoid\nconditional branches where possible, by comparing _M_value to constants\nor using bitwise operations to correctly handle the unordered state.\n\n\t* libsupc++/compare (__cmp_cat::type): Define typedef for underlying\n\ttype of enumerations and comparison category types.\n\t(__cmp_cat::_Ord, __cmp_cat::_Ncmp): Add underlying type.\n\t(__cmp_cat::_Ncmp::unordered): Change value to 2.\n\t(partial_ordering::_M_value, weak_ordering::_M_value)\n\t(strong_ordering::_M_value): Change type to __cmp_cat::type.\n\t(partial_ordering::_M_is_ordered): Remove data member.\n\t(partial_ordering): Use second bit of _M_value for unordered. Adjust\n\tcomparison operators.\n\t(weak_ordering::operator partial_ordering): Simplify to remove\n\tbranches.\n\t(operator<=>(unspecified, weak_ordering)): Likewise.\n\t(strong_ordering::operator partial_ordering): Likewise.\n\t(strong_ordering::operator weak_ordering): Likewise.\n\t(operator<=>(unspecified, strong_ordering)): Likewise.\n\t* testsuite/18_support/comparisons/categories/partialord.cc: New test.\n\t* testsuite/18_support/comparisons/categories/strongord.cc: New test.\n\t* testsuite/18_support/comparisons/categories/weakord.cc: New test.", "tree": {"sha": "b30d5474e4cbbf0241e2178fee75a909338e8777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b30d5474e4cbbf0241e2178fee75a909338e8777"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82aee6dd61e2a5b4e4b124f896c8403169688f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82aee6dd61e2a5b4e4b124f896c8403169688f41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82aee6dd61e2a5b4e4b124f896c8403169688f41"}], "stats": {"total": 374, "additions": 311, "deletions": 63}, "files": [{"sha": "0fce279775aafbbf6f60c6b5282da93fdf68fb0d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "patch": "@@ -1,5 +1,24 @@\n 2020-02-07  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* libsupc++/compare (__cmp_cat::type): Define typedef for underlying\n+\ttype of enumerations and comparison category types.\n+\t(__cmp_cat::_Ord, __cmp_cat::_Ncmp): Add underlying type.\n+\t(__cmp_cat::_Ncmp::unordered): Change value to 2.\n+\t(partial_ordering::_M_value, weak_ordering::_M_value)\n+\t(strong_ordering::_M_value): Change type to __cmp_cat::type.\n+\t(partial_ordering::_M_is_ordered): Remove data member.\n+\t(partial_ordering): Use second bit of _M_value for unordered. Adjust\n+\tcomparison operators.\n+\t(weak_ordering::operator partial_ordering): Simplify to remove\n+\tbranches.\n+\t(operator<=>(unspecified, weak_ordering)): Likewise.\n+\t(strong_ordering::operator partial_ordering): Likewise.\n+\t(strong_ordering::operator weak_ordering): Likewise.\n+\t(operator<=>(unspecified, strong_ordering)): Likewise.\n+\t* testsuite/18_support/comparisons/categories/partialord.cc: New test.\n+\t* testsuite/18_support/comparisons/categories/strongord.cc: New test.\n+\t* testsuite/18_support/comparisons/categories/weakord.cc: New test.\n+\n \t* include/std/ranges (iota_view::_Iterator): Fix typo in name of\n \t__cpp_lib_three_way_comparison macro and use deduced return type for\n \toperator<=>."}, {"sha": "b2d64ef74a4795e01151fc4262d4304e089a9d70", "filename": "libstdc++-v3/libsupc++/compare", "status": "modified", "additions": 33, "deletions": 63, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "patch": "@@ -48,9 +48,11 @@ namespace std\n \n   namespace __cmp_cat\n   {\n-    enum class _Ord { equivalent = 0, less = -1, greater = 1 };\n+    using type = signed char;\n \n-    enum class _Ncmp { _Unordered = -127 };\n+    enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };\n+\n+    enum class _Ncmp : type { _Unordered = 2 };\n \n     struct __unspec\n     {\n@@ -60,19 +62,22 @@ namespace std\n \n   class partial_ordering\n   {\n-    int _M_value;\n-    bool _M_is_ordered;\n+    // less=0xff, equiv=0x00, greater=0x01, unordered=0x02\n+    __cmp_cat::type _M_value;\n \n     constexpr explicit\n     partial_ordering(__cmp_cat::_Ord __v) noexcept\n-    : _M_value(int(__v)), _M_is_ordered(true)\n+    : _M_value(__cmp_cat::type(__v))\n     { }\n \n     constexpr explicit\n     partial_ordering(__cmp_cat::_Ncmp __v) noexcept\n-    : _M_value(int(__v)), _M_is_ordered(false)\n+    : _M_value(__cmp_cat::type(__v))\n     { }\n \n+    friend class weak_ordering;\n+    friend class strong_ordering;\n+\n   public:\n     // valid values\n     static const partial_ordering less;\n@@ -83,42 +88,42 @@ namespace std\n     // comparisons\n     friend constexpr bool\n     operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_is_ordered && __v._M_value == 0; }\n+    { return __v._M_value == 0; }\n \n     friend constexpr bool\n     operator==(partial_ordering, partial_ordering) noexcept = default;\n \n     friend constexpr bool\n     operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_is_ordered && __v._M_value < 0; }\n+    { return __v._M_value == -1; }\n \n     friend constexpr bool\n     operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_is_ordered && __v._M_value > 0; }\n+    { return __v._M_value == 1; }\n \n     friend constexpr bool\n     operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_is_ordered && __v._M_value <= 0; }\n+    { return __v._M_value <= 0; }\n \n     friend constexpr bool\n     operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept\n-    { return __v._M_is_ordered && __v._M_value >= 0; }\n+    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }\n \n     friend constexpr bool\n     operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept\n-    { return __v._M_is_ordered && 0 < __v._M_value; }\n+    { return __v._M_value == 1; }\n \n     friend constexpr bool\n     operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept\n-    { return __v._M_is_ordered && 0 > __v._M_value; }\n+    { return __v._M_value == -1; }\n \n     friend constexpr bool\n     operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept\n-    { return __v._M_is_ordered && 0 <= __v._M_value; }\n+    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }\n \n     friend constexpr bool\n     operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept\n-    { return __v._M_is_ordered && 0 >= __v._M_value; }\n+    { return 0 >= __v._M_value; }\n \n     friend constexpr partial_ordering\n     operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept\n@@ -127,10 +132,8 @@ namespace std\n     friend constexpr partial_ordering\n     operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept\n     {\n-      if (__v < 0)\n-\treturn  partial_ordering::greater;\n-      else if (__v > 0)\n-\treturn partial_ordering::less;\n+      if (__v._M_value & 1)\n+\treturn partial_ordering(__cmp_cat::_Ord(-__v._M_value));\n       else\n \treturn __v;\n     }\n@@ -151,27 +154,22 @@ namespace std\n \n   class weak_ordering\n   {\n-    int _M_value;\n+    __cmp_cat::type _M_value;\n \n     constexpr explicit\n-    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(int(__v))\n+    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))\n     { }\n \n+    friend class strong_ordering;\n+\n   public:\n     // valid values\n     static const weak_ordering less;\n     static const weak_ordering equivalent;\n     static const weak_ordering greater;\n \n     constexpr operator partial_ordering() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn partial_ordering::equivalent;\n-      else if (_M_value < 0)\n-\treturn partial_ordering::less;\n-      else\n-\treturn partial_ordering::greater;\n-    }\n+    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }\n \n     // comparisons\n     friend constexpr bool\n@@ -219,14 +217,7 @@ namespace std\n \n     friend constexpr weak_ordering\n     operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept\n-    {\n-      if (__v < 0)\n-\treturn  weak_ordering::greater;\n-      else if (__v > 0)\n-\treturn weak_ordering::less;\n-      else\n-\treturn __v;\n-    }\n+    { return weak_ordering(__cmp_cat::_Ord(-__v._M_value)); }\n   };\n \n   // valid values' definitions\n@@ -241,11 +232,11 @@ namespace std\n \n   class strong_ordering\n   {\n-    int _M_value;\n+    __cmp_cat::type _M_value;\n \n     constexpr explicit\n     strong_ordering(__cmp_cat::_Ord __v) noexcept\n-    : _M_value(int(__v))\n+    : _M_value(__cmp_cat::type(__v))\n     { }\n \n   public:\n@@ -256,24 +247,10 @@ namespace std\n     static const strong_ordering greater;\n \n     constexpr operator partial_ordering() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn partial_ordering::equivalent;\n-      else if (_M_value < 0)\n-\treturn partial_ordering::less;\n-      else\n-\treturn partial_ordering::greater;\n-    }\n+    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }\n \n     constexpr operator weak_ordering() const noexcept\n-    {\n-      if (_M_value == 0)\n-\treturn weak_ordering::equivalent;\n-      else if (_M_value < 0)\n-\treturn weak_ordering::less;\n-      else\n-\treturn weak_ordering::greater;\n-    }\n+    { return weak_ordering(__cmp_cat::_Ord(_M_value)); }\n \n     // comparisons\n     friend constexpr bool\n@@ -321,14 +298,7 @@ namespace std\n \n     friend constexpr strong_ordering\n     operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept\n-    {\n-      if (__v < 0)\n-\treturn  strong_ordering::greater;\n-      else if (__v > 0)\n-\treturn strong_ordering::less;\n-      else\n-\treturn __v;\n-    }\n+    { return strong_ordering(__cmp_cat::_Ord(-__v._M_value)); }\n   };\n \n   // valid values' definitions"}, {"sha": "01db2ca055ea34efbc0d2b7837b0746dbd0757d2", "filename": "libstdc++-v3/testsuite/18_support/comparisons/categories/partialord.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fpartialord.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fpartialord.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fpartialord.cc?ref=0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+\n+using std::partial_ordering;\n+\n+static_assert( partial_ordering::less == partial_ordering::less );\n+static_assert( partial_ordering::less != partial_ordering::equivalent );\n+static_assert( partial_ordering::less != partial_ordering::greater );\n+static_assert( partial_ordering::less != partial_ordering::unordered );\n+static_assert( partial_ordering::equivalent == partial_ordering::equivalent );\n+static_assert( partial_ordering::equivalent != partial_ordering::greater );\n+static_assert( partial_ordering::equivalent != partial_ordering::unordered );\n+static_assert( partial_ordering::greater == partial_ordering::greater );\n+static_assert( partial_ordering::greater != partial_ordering::unordered );\n+static_assert( partial_ordering::unordered == partial_ordering::unordered );\n+\n+static_assert( ! (partial_ordering::less == 0)\t);\n+static_assert(    partial_ordering::less <  0\t);\n+static_assert( ! (partial_ordering::less >  0)\t);\n+static_assert(    partial_ordering::less <= 0\t);\n+static_assert( ! (partial_ordering::less >= 0)\t);\n+static_assert( ! (0 == partial_ordering::less)\t);\n+static_assert( ! (0 <  partial_ordering::less)\t);\n+static_assert(    0 >  partial_ordering::less\t);\n+static_assert( ! (0 <= partial_ordering::less)\t);\n+static_assert(    0 >= partial_ordering::less\t);\n+static_assert( (partial_ordering::less <=> 0) == partial_ordering::less );\n+static_assert( (0 <=> partial_ordering::less) == partial_ordering::greater );\n+\n+static_assert(   (partial_ordering::equivalent == 0)\t);\n+static_assert( ! (partial_ordering::equivalent <  0)\t);\n+static_assert( ! (partial_ordering::equivalent >  0)\t);\n+static_assert(    partial_ordering::equivalent <= 0\t);\n+static_assert(    partial_ordering::equivalent >= 0\t);\n+static_assert(    0 == partial_ordering::equivalent\t);\n+static_assert( ! (0 <  partial_ordering::equivalent)\t);\n+static_assert( ! (0 >  partial_ordering::equivalent)\t);\n+static_assert(    0 <= partial_ordering::equivalent\t);\n+static_assert(    0 >= partial_ordering::equivalent\t);\n+static_assert( (partial_ordering::equivalent <=> 0) == partial_ordering::equivalent );\n+static_assert( (0 <=> partial_ordering::equivalent) == partial_ordering::equivalent );\n+\n+static_assert( ! (partial_ordering::greater == 0)\t);\n+static_assert( ! (partial_ordering::greater <  0)\t);\n+static_assert(    partial_ordering::greater >  0\t);\n+static_assert( ! (partial_ordering::greater <= 0)\t);\n+static_assert(    partial_ordering::greater >= 0\t);\n+static_assert( ! (0 == partial_ordering::greater)\t);\n+static_assert(    0 <  partial_ordering::greater\t);\n+static_assert( ! (0 >  partial_ordering::greater)\t);\n+static_assert(    0 <= partial_ordering::greater\t);\n+static_assert( ! (0 >= partial_ordering::greater)\t);\n+static_assert( (partial_ordering::greater <=> 0) == partial_ordering::greater );\n+static_assert( (0 <=> partial_ordering::greater) == partial_ordering::less );\n+\n+static_assert( ! (partial_ordering::unordered == 0)\t);\n+static_assert( ! (partial_ordering::unordered <  0)\t);\n+static_assert( ! (partial_ordering::unordered >  0)\t);\n+static_assert( ! (partial_ordering::unordered <= 0)\t);\n+static_assert( ! (partial_ordering::unordered >= 0)\t);\n+static_assert( ! (0 == partial_ordering::unordered)\t);\n+static_assert( ! (0 <  partial_ordering::unordered)\t);\n+static_assert( ! (0 >  partial_ordering::unordered)\t);\n+static_assert( ! (0 <= partial_ordering::unordered)\t);\n+static_assert( ! (0 >= partial_ordering::unordered)\t);\n+static_assert( (partial_ordering::unordered <=> 0) == partial_ordering::unordered );\n+static_assert( (0 <=> partial_ordering::unordered) == partial_ordering::unordered );"}, {"sha": "0485e5a14636cf7886b05f78338dec5a05fcafea", "filename": "libstdc++-v3/testsuite/18_support/comparisons/categories/strongord.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fstrongord.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fstrongord.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fstrongord.cc?ref=0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+\n+using std::strong_ordering;\n+\n+static_assert( strong_ordering::less == strong_ordering::less );\n+static_assert( strong_ordering::less != strong_ordering::equal );\n+static_assert( strong_ordering::less != strong_ordering::equivalent );\n+static_assert( strong_ordering::less != strong_ordering::greater );\n+static_assert( strong_ordering::equivalent == strong_ordering::equivalent );\n+static_assert( strong_ordering::equivalent == strong_ordering::equal );\n+static_assert( strong_ordering::equivalent != strong_ordering::greater );\n+static_assert( strong_ordering::equal == strong_ordering::equal );\n+static_assert( strong_ordering::equal != strong_ordering::greater );\n+static_assert( strong_ordering::greater == strong_ordering::greater );\n+\n+static_assert( ! (strong_ordering::less == 0)\t);\n+static_assert(    strong_ordering::less <  0\t);\n+static_assert( ! (strong_ordering::less >  0)\t);\n+static_assert(    strong_ordering::less <= 0\t);\n+static_assert( ! (strong_ordering::less >= 0)\t);\n+static_assert( ! (0 == strong_ordering::less)\t);\n+static_assert( ! (0 <  strong_ordering::less)\t);\n+static_assert(    0 >  strong_ordering::less\t);\n+static_assert( ! (0 <= strong_ordering::less)\t);\n+static_assert(    0 >= strong_ordering::less\t);\n+static_assert( (strong_ordering::less <=> 0) == strong_ordering::less );\n+static_assert( (0 <=> strong_ordering::less) == strong_ordering::greater );\n+\n+static_assert(   (strong_ordering::equal == 0)\t);\n+static_assert( ! (strong_ordering::equal <  0)\t);\n+static_assert( ! (strong_ordering::equal >  0)\t);\n+static_assert(    strong_ordering::equal <= 0\t);\n+static_assert(    strong_ordering::equal >= 0\t);\n+static_assert(    0 == strong_ordering::equal\t);\n+static_assert( ! (0 <  strong_ordering::equal)\t);\n+static_assert( ! (0 >  strong_ordering::equal)\t);\n+static_assert(    0 <= strong_ordering::equal\t);\n+static_assert(    0 >= strong_ordering::equal\t);\n+static_assert( (strong_ordering::equal <=> 0) == strong_ordering::equal );\n+static_assert( (0 <=> strong_ordering::equal) == strong_ordering::equal );\n+\n+static_assert(   (strong_ordering::equivalent == 0)\t);\n+static_assert( ! (strong_ordering::equivalent <  0)\t);\n+static_assert( ! (strong_ordering::equivalent >  0)\t);\n+static_assert(    strong_ordering::equivalent <= 0\t);\n+static_assert(    strong_ordering::equivalent >= 0\t);\n+static_assert(    0 == strong_ordering::equivalent\t);\n+static_assert( ! (0 <  strong_ordering::equivalent)\t);\n+static_assert( ! (0 >  strong_ordering::equivalent)\t);\n+static_assert(    0 <= strong_ordering::equivalent\t);\n+static_assert(    0 >= strong_ordering::equivalent\t);\n+static_assert( (strong_ordering::equivalent <=> 0) == strong_ordering::equivalent );\n+static_assert( (0 <=> strong_ordering::equivalent) == strong_ordering::equivalent );\n+\n+static_assert( ! (strong_ordering::greater == 0)\t);\n+static_assert( ! (strong_ordering::greater <  0)\t);\n+static_assert(    strong_ordering::greater >  0\t);\n+static_assert( ! (strong_ordering::greater <= 0)\t);\n+static_assert(    strong_ordering::greater >= 0\t);\n+static_assert( ! (0 == strong_ordering::greater)\t);\n+static_assert(    0 <  strong_ordering::greater\t);\n+static_assert( ! (0 >  strong_ordering::greater)\t);\n+static_assert(    0 <= strong_ordering::greater\t);\n+static_assert( ! (0 >= strong_ordering::greater)\t);\n+static_assert( (strong_ordering::greater <=> 0) == strong_ordering::greater );\n+static_assert( (0 <=> strong_ordering::greater) == strong_ordering::less );\n+\n+// Conversions\n+using std::partial_ordering;\n+static_assert( partial_ordering(strong_ordering::less) == partial_ordering::less );\n+static_assert( partial_ordering(strong_ordering::equal) == partial_ordering::equivalent );\n+static_assert( partial_ordering(strong_ordering::equivalent) == partial_ordering::equivalent );\n+static_assert( partial_ordering(strong_ordering::greater) == partial_ordering::greater );\n+using std::weak_ordering;\n+static_assert( weak_ordering(strong_ordering::less) == weak_ordering::less );\n+static_assert( partial_ordering(strong_ordering::equal) == weak_ordering::equivalent );\n+static_assert( partial_ordering(strong_ordering::equivalent) == weak_ordering::equivalent );\n+static_assert( weak_ordering(strong_ordering::greater) == weak_ordering::greater );"}, {"sha": "0720e1f86af743aa12bd7d9cdff38d86662ddc2f", "filename": "libstdc++-v3/testsuite/18_support/comparisons/categories/weakord.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fweakord.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fweakord.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Fcategories%2Fweakord.cc?ref=0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+\n+using std::weak_ordering;\n+\n+static_assert( weak_ordering::less == weak_ordering::less );\n+static_assert( weak_ordering::less != weak_ordering::equivalent );\n+static_assert( weak_ordering::less != weak_ordering::greater );\n+static_assert( weak_ordering::equivalent == weak_ordering::equivalent );\n+static_assert( weak_ordering::equivalent != weak_ordering::greater );\n+static_assert( weak_ordering::greater == weak_ordering::greater );\n+\n+static_assert( ! (weak_ordering::less == 0)\t);\n+static_assert(    weak_ordering::less <  0\t);\n+static_assert( ! (weak_ordering::less >  0)\t);\n+static_assert(    weak_ordering::less <= 0\t);\n+static_assert( ! (weak_ordering::less >= 0)\t);\n+static_assert( ! (0 == weak_ordering::less)\t);\n+static_assert( ! (0 <  weak_ordering::less)\t);\n+static_assert(    0 >  weak_ordering::less\t);\n+static_assert( ! (0 <= weak_ordering::less)\t);\n+static_assert(    0 >= weak_ordering::less\t);\n+static_assert( (weak_ordering::less <=> 0) == weak_ordering::less );\n+static_assert( (0 <=> weak_ordering::less) == weak_ordering::greater );\n+\n+static_assert(   (weak_ordering::equivalent == 0)\t);\n+static_assert( ! (weak_ordering::equivalent <  0)\t);\n+static_assert( ! (weak_ordering::equivalent >  0)\t);\n+static_assert(    weak_ordering::equivalent <= 0\t);\n+static_assert(    weak_ordering::equivalent >= 0\t);\n+static_assert(    0 == weak_ordering::equivalent\t);\n+static_assert( ! (0 <  weak_ordering::equivalent)\t);\n+static_assert( ! (0 >  weak_ordering::equivalent)\t);\n+static_assert(    0 <= weak_ordering::equivalent\t);\n+static_assert(    0 >= weak_ordering::equivalent\t);\n+static_assert( (weak_ordering::equivalent <=> 0) == weak_ordering::equivalent );\n+static_assert( (0 <=> weak_ordering::equivalent) == weak_ordering::equivalent );\n+\n+static_assert( ! (weak_ordering::greater == 0)\t);\n+static_assert( ! (weak_ordering::greater <  0)\t);\n+static_assert(    weak_ordering::greater >  0\t);\n+static_assert( ! (weak_ordering::greater <= 0)\t);\n+static_assert(    weak_ordering::greater >= 0\t);\n+static_assert( ! (0 == weak_ordering::greater)\t);\n+static_assert(    0 <  weak_ordering::greater\t);\n+static_assert( ! (0 >  weak_ordering::greater)\t);\n+static_assert(    0 <= weak_ordering::greater\t);\n+static_assert( ! (0 >= weak_ordering::greater)\t);\n+static_assert( (weak_ordering::greater <=> 0) == weak_ordering::greater );\n+static_assert( (0 <=> weak_ordering::greater) == weak_ordering::less );\n+\n+// Conversions\n+using std::partial_ordering;\n+static_assert( partial_ordering(weak_ordering::less) == partial_ordering::less );\n+static_assert( partial_ordering(weak_ordering::equivalent) == partial_ordering::equivalent );\n+static_assert( partial_ordering(weak_ordering::greater) == partial_ordering::greater );"}]}