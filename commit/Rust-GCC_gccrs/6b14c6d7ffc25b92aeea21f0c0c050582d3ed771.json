{"sha": "6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIxNGM2ZDdmZmMyNWI5MmFlZWEyMWYwYzBjMDUwNTgyZDNlZDc3MQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2011-06-14T15:09:14Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-06-14T15:09:14Z"}, "message": "functional: Use noexcept.\n\n2011-06-14  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/functional: Use noexcept.\n\t* include/bits/stl_tempbuf.h: Likewise.\n\nFrom-SVN: r175026", "tree": {"sha": "c671c1113f3eae64ad5ac223bb49ec0ffa3dfa66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c671c1113f3eae64ad5ac223bb49ec0ffa3dfa66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/comments", "author": null, "committer": null, "parents": [{"sha": "5e59d472ed3a8a191d443aa8093c61d1a351c6f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e59d472ed3a8a191d443aa8093c61d1a351c6f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e59d472ed3a8a191d443aa8093c61d1a351c6f3"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "ebe9f200cd8344be1dd6e088cc002b710e894572", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "patch": "@@ -1,3 +1,8 @@\n+2011-06-14  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/functional: Use noexcept.\n+\t* include/bits/stl_tempbuf.h: Likewise.\n+\n 2011-06-12  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "c4b0ddd57155c71df4685b20103cd2ce4000637e", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "patch": "@@ -1,6 +1,7 @@\n // Temporary buffer implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+// 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -83,7 +84,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   template<typename _Tp>\n     pair<_Tp*, ptrdiff_t>\n-    get_temporary_buffer(ptrdiff_t __len)\n+    get_temporary_buffer(ptrdiff_t __len) _GLIBCXX_NOEXCEPT\n     {\n       const ptrdiff_t __max =\n \t__gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);"}, {"sha": "85df22017f6f91ac932c3da30111e1d321e3e198", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b14c6d7ffc25b92aeea21f0c0c050582d3ed771/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=6b14c6d7ffc25b92aeea21f0c0c050582d3ed771", "patch": "@@ -437,28 +437,28 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     public:\n       typedef _Tp type;\n \n-      reference_wrapper(_Tp& __indata)\n+      reference_wrapper(_Tp& __indata) noexcept\n       : _M_data(std::__addressof(__indata))\n       { }\n \n       reference_wrapper(_Tp&&) = delete;\n \n-      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n-      _M_data(__inref._M_data)\n+      reference_wrapper(const reference_wrapper<_Tp>& __inref) noexcept\n+      : _M_data(__inref._M_data)\n       { }\n \n       reference_wrapper&\n-      operator=(const reference_wrapper<_Tp>& __inref)\n+      operator=(const reference_wrapper<_Tp>& __inref) noexcept\n       {\n \t_M_data = __inref._M_data;\n \treturn *this;\n       }\n \n-      operator _Tp&() const\n+      operator _Tp&() const noexcept\n       { return this->get(); }\n \n       _Tp&\n-      get() const\n+      get() const noexcept\n       { return *_M_data; }\n \n       template<typename... _Args>\n@@ -473,13 +473,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   /// Denotes a reference should be taken to a variable.\n   template<typename _Tp>\n     inline reference_wrapper<_Tp>\n-    ref(_Tp& __t)\n+    ref(_Tp& __t) noexcept\n     { return reference_wrapper<_Tp>(__t); }\n \n   /// Denotes a const reference should be taken to a variable.\n   template<typename _Tp>\n     inline reference_wrapper<const _Tp>\n-    cref(const _Tp& __t)\n+    cref(const _Tp& __t) noexcept\n     { return reference_wrapper<const _Tp>(__t); }\n \n   template<typename _Tp>\n@@ -491,13 +491,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   /// Partial specialization.\n   template<typename _Tp>\n     inline reference_wrapper<_Tp>\n-    ref(reference_wrapper<_Tp> __t)\n+    ref(reference_wrapper<_Tp> __t) noexcept\n     { return ref(__t.get()); }\n \n   /// Partial specialization.\n   template<typename _Tp>\n     inline reference_wrapper<const _Tp>\n-    cref(reference_wrapper<_Tp> __t)\n+    cref(reference_wrapper<_Tp> __t) noexcept\n     { return cref(__t.get()); }\n \n   // @} group functors\n@@ -1913,13 +1913,15 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *  @brief Default construct creates an empty function call wrapper.\n        *  @post @c !(bool)*this\n        */\n-      function() : _Function_base() { }\n+      function() noexcept\n+      : _Function_base() { }\n \n       /**\n        *  @brief Creates an empty function call wrapper.\n        *  @post @c !(bool)*this\n        */\n-      function(nullptr_t) : _Function_base() { }\n+      function(nullptr_t) noexcept\n+      : _Function_base() { }\n \n       /**\n        *  @brief %Function copy constructor.\n@@ -2050,7 +2052,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       /// @overload\n       template<typename _Functor>\n \ttypename enable_if<!is_integral<_Functor>::value, function&>::type\n-\toperator=(reference_wrapper<_Functor> __f)\n+\toperator=(reference_wrapper<_Functor> __f) noexcept\n \t{\n \t  function(__f).swap(*this);\n \t  return *this;\n@@ -2093,7 +2095,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *\n        *  This function will not throw an %exception.\n        */\n-      explicit operator bool() const\n+      explicit operator bool() const noexcept\n       { return !_M_empty(); }\n \n       // [3.7.2.4] function invocation\n@@ -2119,7 +2121,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *\n        *  This function will not throw an %exception.\n        */\n-      const type_info& target_type() const;\n+      const type_info& target_type() const noexcept;\n \n       /**\n        *  @brief Access the stored target function object.\n@@ -2130,10 +2132,10 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *\n        * This function will not throw an %exception.\n        */\n-      template<typename _Functor>       _Functor* target();\n+      template<typename _Functor>       _Functor* target() noexcept;\n \n       /// @overload\n-      template<typename _Functor> const _Functor* target() const;\n+      template<typename _Functor> const _Functor* target() const noexcept;\n #endif\n \n     private:\n@@ -2187,7 +2189,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   template<typename _Res, typename... _ArgTypes>\n     const type_info&\n     function<_Res(_ArgTypes...)>::\n-    target_type() const\n+    target_type() const noexcept\n     {\n       if (_M_manager)\n \t{\n@@ -2203,7 +2205,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     template<typename _Functor>\n       _Functor*\n       function<_Res(_ArgTypes...)>::\n-      target()\n+      target() noexcept\n       {\n \tif (typeid(_Functor) == target_type() && _M_manager)\n \t  {\n@@ -2222,7 +2224,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     template<typename _Functor>\n       const _Functor*\n       function<_Res(_ArgTypes...)>::\n-      target() const\n+      target() const noexcept\n       {\n \tif (typeid(_Functor) == target_type() && _M_manager)\n \t  {\n@@ -2246,13 +2248,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    */\n   template<typename _Res, typename... _Args>\n     inline bool\n-    operator==(const function<_Res(_Args...)>& __f, nullptr_t)\n+    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n     { return !static_cast<bool>(__f); }\n \n   /// @overload\n   template<typename _Res, typename... _Args>\n     inline bool\n-    operator==(nullptr_t, const function<_Res(_Args...)>& __f)\n+    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n     { return !static_cast<bool>(__f); }\n \n   /**\n@@ -2264,13 +2266,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    */\n   template<typename _Res, typename... _Args>\n     inline bool\n-    operator!=(const function<_Res(_Args...)>& __f, nullptr_t)\n+    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n     { return static_cast<bool>(__f); }\n \n   /// @overload\n   template<typename _Res, typename... _Args>\n     inline bool\n-    operator!=(nullptr_t, const function<_Res(_Args...)>& __f)\n+    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n     { return static_cast<bool>(__f); }\n \n   // [20.7.15.2.7] specialized algorithms"}]}