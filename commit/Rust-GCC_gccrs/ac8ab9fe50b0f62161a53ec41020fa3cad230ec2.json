{"sha": "ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM4YWI5ZmU1MGIwZjYyMTYxYTUzZWM0MTAyMGZhM2NhZDIzMGVjMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-08-02T14:55:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-08-02T14:55:08Z"}, "message": "config.gcc: Don't include mips/abi64.h in $tm_file.\n\n\t* config.gcc: Don't include mips/abi64.h in $tm_file.\n\t* hard-reg-set.h (call_really_used_regs): Declare.\n\t* config/mips/abi64.h: Remove file.\n\t* config/mips/linux.h,\n\t* config/mips/iris6.h: Don't include it.\n\t* config/mips/mips-protos.h (mips_conditional_register_usage): Declare.\n\t* config/mips/mips.h (CONDITIONAL_REGISTER_USAGE): Use it.\n\t(REG_PARM_STACK_SPACE, STACK_BOUNDARY, STRICT_ARGUMENT_NAMING,\n\tFUNCTION_ARG_PASS_BY_REFERENCE, FUNCTION_ARG_PADDING,\n\tFUNCTION_ARG_CALLEE_COPIES, MUST_PASS_IN_STACK, MIPS_STACK_ALIGN):\n\tBring across definitions from abi64.h.\n\t(GP_ARG_LAST, FP_ARG_LAST): Use MAX_ARGS_IN_REGISTERS.\n\t(BIGGEST_MAX_ARGS_IN_REGISTERS): New.\n\t(struct mips_args): Use it.\n\t* config/mips/mips.c (mips_conditional_register_usage): Define.\n\nFrom-SVN: r55986", "tree": {"sha": "60ac76e618836461ad24d9238984fb2222853176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60ac76e618836461ad24d9238984fb2222853176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/comments", "author": null, "committer": null, "parents": [{"sha": "2b1a40704643808e702356fe13a267664317dd5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1a40704643808e702356fe13a267664317dd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1a40704643808e702356fe13a267664317dd5e"}], "stats": {"total": 371, "additions": 145, "deletions": 226}, "files": [{"sha": "8c76df3198fd97c16741a62ac872142ef8bdbcaf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -1,3 +1,21 @@\n+2002-08-02  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config.gcc: Don't include mips/abi64.h in $tm_file.\n+\t* hard-reg-set.h (call_really_used_regs): Declare.\n+\t* config/mips/abi64.h: Remove file.\n+\t* config/mips/linux.h,\n+\t* config/mips/iris6.h: Don't include it.\n+\t* config/mips/mips-protos.h (mips_conditional_register_usage): Declare.\n+\t* config/mips/mips.h (CONDITIONAL_REGISTER_USAGE): Use it.\n+\t(REG_PARM_STACK_SPACE, STACK_BOUNDARY, STRICT_ARGUMENT_NAMING,\n+\tFUNCTION_ARG_PASS_BY_REFERENCE, FUNCTION_ARG_PADDING,\n+\tFUNCTION_ARG_CALLEE_COPIES, MUST_PASS_IN_STACK, MIPS_STACK_ALIGN):\n+\tBring across definitions from abi64.h.\n+\t(GP_ARG_LAST, FP_ARG_LAST): Use MAX_ARGS_IN_REGISTERS.\n+\t(BIGGEST_MAX_ARGS_IN_REGISTERS): New.\n+\t(struct mips_args): Use it.\n+\t* config/mips/mips.c (mips_conditional_register_usage): Define.\n+\n 2002-08-02  Jason Merrill  <jason@redhat.com>\n \n \t* langhooks-def.h (LANG_HOOKS_EXPR_SIZE): New macro."}, {"sha": "127ae9107524ae6092b11c4f784c0efbf784e989", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -1895,18 +1895,18 @@ mips-*-ecoff* | mipsel-*-ecoff*)\n \ttmake_file=mips/t-ecoff\n \t;;\n mipsisa32-*-elf* | mipsisa32el-*-elf*)\n-\ttm_file=\"${tm_file} mips/elf.h mips/abi64.h\"\n+\ttm_file=\"${tm_file} mips/elf.h\"\n \ttmake_file=mips/t-isa3264\n \ttm_defines=\"MIPS_ISA_DEFAULT=32 MIPS_ABI_DEFAULT=ABI_MEABI\"\n \t;;\n mipsisa64-*-elf* | mipsisa64el-*-elf*)\n-\ttm_file=\"${tm_file} mips/elf.h mips/abi64.h\"\n+\ttm_file=\"${tm_file} mips/elf.h\"\n \ttmake_file=mips/t-isa3264\n \ttarget_cpu_default=\"MASK_64BIT|MASK_FLOAT64|MASK_GAS\"\n \ttm_defines=\"MIPS_ISA_DEFAULT=64 MIPS_ABI_DEFAULT=ABI_MEABI\"\n \t;;\n mipsisa64sb1-*-elf* | mipsisa64sb1el-*-elf*)\n-\ttm_file=\"${tm_file} mips/elf.h mips/abi64.h\"\n+\ttm_file=\"${tm_file} mips/elf.h\"\n \ttmake_file=mips/t-elf\n \ttarget_cpu_default=\"MASK_64BIT|MASK_FLOAT64|MASK_GAS\"\n \ttm_defines=\"MIPS_ISA_DEFAULT=64 MIPS_CPU_STRING_DEFAULT=\\\\\\\"sb1\\\\\\\" MIPS_ABI_DEFAULT=ABI_O64\"\n@@ -1948,7 +1948,7 @@ mips*-*-rtems*)\n \tfi\n \t;;\n mipstx39-*-elf* | mipstx39el-*-elf*)\n-\ttm_file=\"${tm_file} mips/r3900.h mips/elf.h mips/abi64.h\"\n+\ttm_file=\"${tm_file} mips/r3900.h mips/elf.h\"\n \ttmake_file=mips/t-r3900\n \t;;\n mmix-knuth-mmixware)"}, {"sha": "86b8aa819d18cdebdb9c3e9a4a6e2a0748bd2168", "filename": "gcc/config/mips/abi64.h", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1a40704643808e702356fe13a267664317dd5e/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1a40704643808e702356fe13a267664317dd5e/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=2b1a40704643808e702356fe13a267664317dd5e", "patch": "@@ -1,132 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  64 bit ABI support.\n-   Copyright (C) 1994, 1995, 1996, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Macros to implement the 64 bit ABI.  This file is meant to be included\n-   after mips.h.  */\n-\n-#undef STACK_BOUNDARY\n-#define STACK_BOUNDARY \\\n-  ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI) \\\n-   ? 64 : 128)\n-\n-#undef MIPS_STACK_ALIGN\n-#define MIPS_STACK_ALIGN(LOC)\t\t\t\t\t\t\\\n-  ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI)\t\\\n-   ? ((LOC) + 7) & ~7\t\t\t\t\t\t\t\\\n-   : ((LOC) + 15) & ~15)\n-\n-#undef GP_ARG_LAST\n-#define GP_ARG_LAST  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\\\n-\t\t      ? GP_REG_FIRST + 7 : GP_REG_FIRST + 11)\n-#undef FP_ARG_LAST\n-#define FP_ARG_LAST  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\\\n-\t\t      ? FP_REG_FIRST + 15 : FP_REG_FIRST + 19)\n-\n-#undef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n-#define SUBTARGET_CONDITIONAL_REGISTER_USAGE \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* fp20-23 are now caller saved.  */\t\t\t\t\t\\\n-  if (mips_abi == ABI_64)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\t\\\n-      for (regno = FP_REG_FIRST + 20; regno < FP_REG_FIRST + 24; regno++) \\\n-\tcall_really_used_regs[regno] = call_used_regs[regno] = 1;\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* odd registers from fp21 to fp31 are now caller saved.  */\t\t\\\n-  if (mips_abi == ABI_N32 || mips_abi == ABI_MEABI)  \t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\t\\\n-      for (regno = FP_REG_FIRST + 21; regno <= FP_REG_FIRST + 31; regno+=2) \\\n-\tcall_really_used_regs[regno] = call_used_regs[regno] = 1;\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#undef MAX_ARGS_IN_REGISTERS\n-#define MAX_ARGS_IN_REGISTERS ((mips_abi == ABI_32 || mips_abi == ABI_O64) \\\n-\t\t\t       ? 4 : 8)\n-\n-#undef REG_PARM_STACK_SPACE\n-#define REG_PARM_STACK_SPACE(FNDECL) \t\t\t\t\t \\\n-  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\t\t \\\n-   ? (MAX_ARGS_IN_REGISTERS*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL) \\\n-   : 0)\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n-   ? upward\t\t\t\t\t\t\t\t\\\n-   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n-       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n-       : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n-\t  && (mips_abi == ABI_32\t\t\t\t\t\\\n-\t      || mips_abi == ABI_O64\t\t\t\t\t\\\n-\t      || mips_abi == ABI_EABI\t\t\t\t\t\\\n-\t      || GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n-      ? downward : upward))\n-\n-/* Modified version of the macro in expr.h.  */\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n-       || ((MODE) == BLKmode \t\t\t\t\\\n-\t   && mips_abi != ABI_32 && mips_abi != ABI_O64 \\\n-\t   && ! ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n-\t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n-\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n-\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n-\t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n-\n-#define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32 && mips_abi != ABI_O64)\n-\n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of the\n-   argument itself.  The pointer is passed in whatever way is appropriate\n-   for passing a pointer to that type.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n-\n-/* A C expression that indicates when it is the called function's\n-   responsibility to make a copy of arguments passed by invisible\n-   reference.  Normally, the caller makes a copy and passes the\n-   address of the copy to the routine being called.  When\n-   FUNCTION_ARG_CALLEE_COPIES is defined and is nonzero, the caller\n-   does not make a copy.  Instead, it passes a pointer to the \"live\"\n-   value.  The called function must not modify this value.  If it can\n-   be determined that the value won't be modified, it need not make a\n-   copy; otherwise a copy must be made.  */\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (mips_abi == ABI_EABI && (NAMED)\t\t\t\t\t\\\n-   && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n-\n-/* ??? Unimplemented stuff follows.  */\n-\n-/* ??? Add support for 16 byte/128 bit long doubles here when\n-   mips_abi != ABI32.  */\n-\n-/* ??? Make main return zero if user did not specify return value.  */\n-\n-/* ??? Add support for .interfaces section, so as to get linker warnings\n-   when stdarg functions called without prototype in scope?  */\n-\n-/* ??? Could optimize structure passing by putting the right register rtx\n-   into the field decl, so that if we use the field, we can take the value from\n-   a register instead of from memory.  */"}, {"sha": "4761aa5a883347a79a0804fc4ba89c1066d05185", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -32,7 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #include \"mips/iris5.h\"\n-#include \"mips/abi64.h\"\n \n /* Irix6 assembler does handle DWARF2 directives.  Override setting in\n    irix5.h file.  */"}, {"sha": "5564ad1e273e7f73434a1d008e27ce55ada26347", "filename": "gcc/config/mips/linux.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux.h?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -18,8 +18,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include \"mips/abi64.h\"\n-\n #undef WCHAR_TYPE\n #define WCHAR_TYPE \"int\"\n "}, {"sha": "d9b12ba02dc2a6734f2c9a1cdabd86571c186fdc", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -104,6 +104,7 @@ extern const char      *mips_restore_gp PARAMS ((rtx *, rtx));\n extern const char      *output_block_move PARAMS ((rtx, rtx *, int,\n \t\t\t\t\t\t   enum block_move_type));\n extern void\t\toverride_options PARAMS ((void));\n+extern void\t\tmips_conditional_register_usage PARAMS ((void));\n extern void\t\tprint_operand_address PARAMS ((FILE *, rtx));\n extern void\t\tprint_operand PARAMS ((FILE *, rtx, int));\n extern int\t\tdouble_memory_operand PARAMS ((rtx,enum machine_mode));"}, {"sha": "c0795dc6cb49c75086eba95ad9c6a3aa6a0dfcf6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -5408,6 +5408,62 @@ override_options ()\n   init_machine_status = &mips_init_machine_status;\n }\n \n+/* Implement CONDITIONAL_REGISTER_USAGE.  */\n+\n+void\n+mips_conditional_register_usage ()\n+{\n+  if (!TARGET_HARD_FLOAT)\n+    {\n+      int regno;\n+\n+      for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\n+      for (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\n+    }\n+  else if (! ISA_HAS_8CC)\n+    {\n+      int regno;\n+\n+      /* We only have a single condition code register.  We\n+\t implement this by hiding all the condition code registers,\n+\t and generating RTL that refers directly to ST_REG_FIRST.  */\n+      for (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\n+    }\n+  /* In mips16 mode, we permit the $t temporary registers to be used\n+     for reload.  We prohibit the unused $s registers, since they\n+     are caller saved, and saving them via a mips16 register would\n+     probably waste more time than just reloading the value.  */\n+  if (TARGET_MIPS16)\n+    {\n+      fixed_regs[18] = call_used_regs[18] = 1;\n+      fixed_regs[19] = call_used_regs[19] = 1;\n+      fixed_regs[20] = call_used_regs[20] = 1;\n+      fixed_regs[21] = call_used_regs[21] = 1;\n+      fixed_regs[22] = call_used_regs[22] = 1;\n+      fixed_regs[23] = call_used_regs[23] = 1;\n+      fixed_regs[26] = call_used_regs[26] = 1;\n+      fixed_regs[27] = call_used_regs[27] = 1;\n+      fixed_regs[30] = call_used_regs[30] = 1;\n+    }\n+  /* fp20-23 are now caller saved.  */\n+  if (mips_abi == ABI_64)\n+    {\n+      int regno;\n+      for (regno = FP_REG_FIRST + 20; regno < FP_REG_FIRST + 24; regno++)\n+\tcall_really_used_regs[regno] = call_used_regs[regno] = 1;\n+    }\n+  /* odd registers from fp21 to fp31 are now caller saved.  */\n+  if (mips_abi == ABI_N32 || mips_abi == ABI_MEABI)\n+    {\n+      int regno;\n+      for (regno = FP_REG_FIRST + 21; regno <= FP_REG_FIRST + 31; regno+=2)\n+\tcall_really_used_regs[regno] = call_used_regs[regno] = 1;\n+    }\n+}\n+\n /* Allocate a chunk of memory for per-function machine-dependent data.  */\n static struct machine_function *\n mips_init_machine_status ()"}, {"sha": "7bdee66074f8f8cac58aa28adbe1572f97b2da2a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 62, "deletions": 87, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -77,11 +77,9 @@ enum processor_type {\n /* Recast the cpu class to be the cpu attribute.  */\n #define mips_cpu_attr ((enum attr_cpu)mips_tune)\n \n-/* Which ABI to use.  These are constants because abi64.h must check their\n-   value at preprocessing time.\n-\n-   ABI_32 (original 32, or o32), ABI_N32 (n32), ABI_64 (n64) are all\n-   defined by SGI.  ABI_O64 is o32 extended to work on a 64 bit machine.  */\n+/* Which ABI to use.  ABI_32 (original 32, or o32), ABI_N32 (n32),\n+   ABI_64 (n64) are all defined by SGI.  ABI_O64 is o32 extended\n+   to work on a 64 bit machine.  */\n \n #define ABI_32  0\n #define ABI_N32 1\n@@ -868,73 +866,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \n #define OVERRIDE_OPTIONS override_options ()\n \n-/* Zero or more C statements that may conditionally modify two\n-   variables `fixed_regs' and `call_used_regs' (both of type `char\n-   []') after they have been initialized from the two preceding\n-   macros.\n-\n-   This is necessary in case the fixed or call-clobbered registers\n-   depend on target flags.\n-\n-   You need not define this macro if it has no work to do.\n-\n-   If the usage of an entire class of registers depends on the target\n-   flags, you may indicate this to GCC by using this macro to modify\n-   `fixed_regs' and `call_used_regs' to 1 for each of the registers in\n-   the classes which should not be used by GCC.  Also define the macro\n-   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a\n-   letter for a class that shouldn't be used.\n-\n-   (However, if this class is not included in `GENERAL_REGS' and all\n-   of the insn patterns whose constraints permit this class are\n-   controlled by target switches, then GCC will automatically avoid\n-   using these registers when the target switches are opposed to\n-   them.)  */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_HARD_FLOAT)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\t\\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-\tfor (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\t\\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (! ISA_HAS_8CC)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t/* We only have a single condition code register.  We\t\t\\\n-           implement this by hiding all the condition code registers,\t\\\n-           and generating RTL that refers directly to ST_REG_FIRST.  */\t\\\n-\tfor (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\t\\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    /* In mips16 mode, we permit the $t temporary registers to be used\t\\\n-       for reload.  We prohibit the unused $s registers, since they\t\\\n-       are caller saved, and saving them via a mips16 register would\t\\\n-       probably waste more time than just reloading the value.  */\t\\\n-    if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[18] = call_used_regs[18] = 1;                        \\\n-\tfixed_regs[19] = call_used_regs[19] = 1;                        \\\n-\tfixed_regs[20] = call_used_regs[20] = 1;                        \\\n-\tfixed_regs[21] = call_used_regs[21] = 1;                        \\\n-\tfixed_regs[22] = call_used_regs[22] = 1;                        \\\n-\tfixed_regs[23] = call_used_regs[23] = 1;                        \\\n-\tfixed_regs[26] = call_used_regs[26] = 1;                        \\\n-\tfixed_regs[27] = call_used_regs[27] = 1;                        \\\n-\tfixed_regs[30] = call_used_regs[30] = 1;                        \\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* This is meant to be redefined in the host dependent files.  */\n-#define SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+#define CONDITIONAL_REGISTER_USAGE mips_conditional_register_usage ()\n \n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n@@ -2552,8 +2484,10 @@ extern enum reg_class mips_char_to_class[256];\n    in register. In case an argument list is of form GF used registers\n    are a0 (a2,a3), but we should push over a1...  */\n \n-#define REG_PARM_STACK_SPACE(FNDECL)\t\\\n-  ((MAX_ARGS_IN_REGISTERS*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL))\n+#define REG_PARM_STACK_SPACE(FNDECL) \t\t\t\t\t \\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\t\t \\\n+   ? (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL) \\\n+   : 0)\n \n /* Define this if it is the responsibility of the caller to\n    allocate the area reserved for arguments passed in registers.\n@@ -2562,10 +2496,9 @@ extern enum reg_class mips_char_to_class[256];\n    `current_function_outgoing_args_size'.  */\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n-/* Align stack frames on 64 bits (Double Word ).  */\n-#ifndef STACK_BOUNDARY\n-#define STACK_BOUNDARY 64\n-#endif\n+#define STACK_BOUNDARY \\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI) \\\n+   ? 64 : 128)\n \n /* Make sure 4 words are always allocated on the stack.  */\n \n@@ -2613,14 +2546,19 @@ extern enum reg_class mips_char_to_class[256];\n #define GP_RETURN (GP_REG_FIRST + 2)\n #define FP_RETURN ((TARGET_SOFT_FLOAT) ? GP_RETURN : (FP_REG_FIRST + 0))\n \n+#define MAX_ARGS_IN_REGISTERS \\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64) ? 4 : 8)\n+\n+/* Largest possible value of MAX_ARGS_IN_REGISTERS.  */\n+\n+#define BIGGEST_MAX_ARGS_IN_REGISTERS 8\n+\n /* Symbolic macros for the first/last argument registers.  */\n \n #define GP_ARG_FIRST (GP_REG_FIRST + 4)\n-#define GP_ARG_LAST  (GP_REG_FIRST + 7)\n+#define GP_ARG_LAST  (GP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n #define FP_ARG_FIRST (FP_REG_FIRST + 12)\n-#define FP_ARG_LAST  (FP_REG_FIRST + 15)\n-\n-#define MAX_ARGS_IN_REGISTERS\t4\n+#define FP_ARG_LAST  (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  Because we define\n@@ -2683,6 +2621,8 @@ extern enum reg_class mips_char_to_class[256];\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n \f\n+#define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32 && mips_abi != ABI_O64)\n+\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n@@ -2757,7 +2697,7 @@ typedef struct mips_args {\n      the shift patterns, and function_arg, which returns them when given\n      a VOIDmode argument.  */\n   unsigned int num_adjusts;\n-  rtx adjust[MAX_ARGS_IN_REGISTERS];\n+  rtx adjust[BIGGEST_MAX_ARGS_IN_REGISTERS];\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -2812,6 +2752,39 @@ typedef struct mips_args {\n \t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n \t\t: GET_MODE_ALIGNMENT(MODE)))\n \n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n+   ? upward\t\t\t\t\t\t\t\t\\\n+   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n+       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n+\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n+       : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n+\t  && (mips_abi == ABI_32\t\t\t\t\t\\\n+\t      || mips_abi == ABI_O64\t\t\t\t\t\\\n+\t      || mips_abi == ABI_EABI\t\t\t\t\t\\\n+\t      || GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n+      ? downward : upward))\n+\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n+  (mips_abi == ABI_EABI && (NAMED)\t\t\t\t\t\\\n+   && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+\n+/* Modified version of the macro in expr.h.  */\n+#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n+  ((TYPE) != 0\t\t\t\t\t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n+       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n+       || ((MODE) == BLKmode \t\t\t\t\\\n+\t   && mips_abi != ABI_32 && mips_abi != ABI_O64 \\\n+\t   && ! ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n+\t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n+\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n+\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n+\t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n+\n /* True if using EABI and varargs can be passed in floating-point\n    registers.  Under these conditions, we need a more complex form\n    of va_list, which tracks GPR, FPR and stack arguments separately.  */\n@@ -2826,10 +2799,12 @@ typedef struct mips_args {\n   || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n   || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n \n-/* ALIGN FRAMES on double word boundaries */\n-#ifndef MIPS_STACK_ALIGN\n-#define MIPS_STACK_ALIGN(LOC) (((LOC) + 7) & ~7)\n-#endif\n+/* Treat LOC as a byte offset from the stack pointer and round it up\n+   to the next fully-aligned offset.  */\n+#define MIPS_STACK_ALIGN(LOC)\t\t\t\t\t\t\\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI)\t\\\n+   ? ((LOC) + 7) & ~7\t\t\t\t\t\t\t\\\n+   : ((LOC) + 15) & ~15)\n \n \f\n /* Define the `__builtin_va_list' type for the ABI.  */"}, {"sha": "9cdd96835c94616568d4450bb139be86bd4a47b4", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8ab9fe50b0f62161a53ec41020fa3cad230ec2/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=ac8ab9fe50b0f62161a53ec41020fa3cad230ec2", "patch": "@@ -405,6 +405,10 @@ extern HARD_REG_SET fixed_reg_set;\n \n extern char call_used_regs[FIRST_PSEUDO_REGISTER];\n \n+#ifdef CALL_REALLY_USED_REGISTERS\n+extern char call_really_used_regs[];\n+#endif\n+\n /* The same info as a HARD_REG_SET.  */\n \n extern HARD_REG_SET call_used_reg_set;"}]}