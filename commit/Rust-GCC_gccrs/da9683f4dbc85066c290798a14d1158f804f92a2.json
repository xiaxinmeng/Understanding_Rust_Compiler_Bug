{"sha": "da9683f4dbc85066c290798a14d1158f804f92a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5NjgzZjRkYmM4NTA2NmMyOTA3OThhMTRkMTE1OGY4MDRmOTJhMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:24:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:24:28Z"}, "message": "[multiple changes]\n\n2017-01-13  Yannick Moy  <moy@adacore.com>\n\n\t* inline.adb (Remove_Aspects_And_Pragmas): Add Unused to the\n\tlist of pragmas to remove.  Remove pragmas from the list of\n\tstatements in the body to inline.\n\t* namet.adb, namet.ads (Nam_In): New version with 12 parameters.\n\n2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Resolve_Aspects): New procedure, subsidiary of\n\tAnalyze_Declarations, to analyze and resolve the expressions of\n\taspect specifications in the current declarative list, so that\n\tthe expressions have proper entity and type info.  This is needed\n\tfor ASIS when there is no subsequent expansion to generate this\n\tsemantic information.\n\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): Use Etype of\n\toriginal expression, to suppress cascaded errors when expression\n\thas been constant-folded.\n\t(Resolve_Aspect_Expressions, Resolve_Name): Preserve entities in\n\tASIS mode, because there is no subsequent expansion to decorate\n\tthe tree.\n\nFrom-SVN: r244409", "tree": {"sha": "c30d14feaa65425fda4394198a472a663338db04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c30d14feaa65425fda4394198a472a663338db04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da9683f4dbc85066c290798a14d1158f804f92a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9683f4dbc85066c290798a14d1158f804f92a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9683f4dbc85066c290798a14d1158f804f92a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9683f4dbc85066c290798a14d1158f804f92a2/comments", "author": null, "committer": null, "parents": [{"sha": "3de3a1be9ee8c46efce3714cbbecaae0c7efe3f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de3a1be9ee8c46efce3714cbbecaae0c7efe3f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3de3a1be9ee8c46efce3714cbbecaae0c7efe3f0"}], "stats": {"total": 427, "additions": 269, "deletions": 158}, "files": [{"sha": "a0f6f81c12296ad6131eebed196fe769978bd344", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=da9683f4dbc85066c290798a14d1158f804f92a2", "patch": "@@ -1,3 +1,25 @@\n+2017-01-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* inline.adb (Remove_Aspects_And_Pragmas): Add Unused to the\n+\tlist of pragmas to remove.  Remove pragmas from the list of\n+\tstatements in the body to inline.\n+\t* namet.adb, namet.ads (Nam_In): New version with 12 parameters.\n+\n+2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Resolve_Aspects): New procedure, subsidiary of\n+\tAnalyze_Declarations, to analyze and resolve the expressions of\n+\taspect specifications in the current declarative list, so that\n+\tthe expressions have proper entity and type info.  This is needed\n+\tfor ASIS when there is no subsequent expansion to generate this\n+\tsemantic information.\n+\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): Use Etype of\n+\toriginal expression, to suppress cascaded errors when expression\n+\thas been constant-folded.\n+\t(Resolve_Aspect_Expressions, Resolve_Name): Preserve entities in\n+\tASIS mode, because there is no subsequent expansion to decorate\n+\tthe tree.\n+\n 2017-01-13  Yannick Moy  <moy@adacore.com>\n \n \t* inline.adb, inline.ads (Call_Can_Be_Inlined_In_GNATprove_Mode):"}, {"sha": "7389105966a93a31ed45734279b6a152f7e9df26", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 149, "deletions": 141, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=da9683f4dbc85066c290798a14d1158f804f92a2", "patch": "@@ -1223,7 +1223,7 @@ package body Inline is\n            and then not Same_Type (Etype (F), Etype (A))\n            and then\n              (Is_By_Reference_Type (Etype (A))\n-              or else Is_Limited_Type (Etype (A)))\n+               or else Is_Limited_Type (Etype (A)))\n          then\n             return False;\n          end if;\n@@ -1235,139 +1235,6 @@ package body Inline is\n       return True;\n    end Call_Can_Be_Inlined_In_GNATprove_Mode;\n \n-   -------------------\n-   -- Cannot_Inline --\n-   -------------------\n-\n-   procedure Cannot_Inline\n-     (Msg        : String;\n-      N          : Node_Id;\n-      Subp       : Entity_Id;\n-      Is_Serious : Boolean := False)\n-   is\n-   begin\n-      --  In GNATprove mode, inlining is the technical means by which the\n-      --  higher-level goal of contextual analysis is reached, so issue\n-      --  messages about failure to apply contextual analysis to a\n-      --  subprogram, rather than failure to inline it.\n-\n-      if GNATprove_Mode\n-        and then Msg (Msg'First .. Msg'First + 12) = \"cannot inline\"\n-      then\n-         declare\n-            Len1 : constant Positive :=\n-              String (String'(\"cannot inline\"))'Length;\n-            Len2 : constant Positive :=\n-              String (String'(\"info: no contextual analysis of\"))'Length;\n-\n-            New_Msg : String (1 .. Msg'Length + Len2 - Len1);\n-\n-         begin\n-            New_Msg (1 .. Len2) := \"info: no contextual analysis of\";\n-            New_Msg (Len2 + 1 .. Msg'Length + Len2 - Len1) :=\n-              Msg (Msg'First + Len1 .. Msg'Last);\n-            Cannot_Inline (New_Msg, N, Subp, Is_Serious);\n-            return;\n-         end;\n-      end if;\n-\n-      pragma Assert (Msg (Msg'Last) = '?');\n-\n-      --  Legacy front end inlining model\n-\n-      if not Back_End_Inlining then\n-\n-         --  Do not emit warning if this is a predefined unit which is not\n-         --  the main unit. With validity checks enabled, some predefined\n-         --  subprograms may contain nested subprograms and become ineligible\n-         --  for inlining.\n-\n-         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n-           and then not In_Extended_Main_Source_Unit (Subp)\n-         then\n-            null;\n-\n-         --  In GNATprove mode, issue a warning, and indicate that the\n-         --  subprogram is not always inlined by setting flag Is_Inlined_Always\n-         --  to False.\n-\n-         elsif GNATprove_Mode then\n-            Set_Is_Inlined_Always (Subp, False);\n-            Error_Msg_NE (Msg & \"p?\", N, Subp);\n-\n-         elsif Has_Pragma_Inline_Always (Subp) then\n-\n-            --  Remove last character (question mark) to make this into an\n-            --  error, because the Inline_Always pragma cannot be obeyed.\n-\n-            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n-\n-         elsif Ineffective_Inline_Warnings then\n-            Error_Msg_NE (Msg & \"p?\", N, Subp);\n-         end if;\n-\n-      --  New semantics relying on back end inlining\n-\n-      elsif Is_Serious then\n-\n-         --  Remove last character (question mark) to make this into an error.\n-\n-         Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n-\n-      --  In GNATprove mode, issue a warning, and indicate that the subprogram\n-      --  is not always inlined by setting flag Is_Inlined_Always to False.\n-\n-      elsif GNATprove_Mode then\n-         Set_Is_Inlined_Always (Subp, False);\n-         Error_Msg_NE (Msg & \"p?\", N, Subp);\n-\n-      else\n-\n-         --  Do not emit warning if this is a predefined unit which is not\n-         --  the main unit. This behavior is currently provided for backward\n-         --  compatibility but it will be removed when we enforce the\n-         --  strictness of the new rules.\n-\n-         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n-           and then not In_Extended_Main_Source_Unit (Subp)\n-         then\n-            null;\n-\n-         elsif Has_Pragma_Inline_Always (Subp) then\n-\n-            --  Emit a warning if this is a call to a runtime subprogram\n-            --  which is located inside a generic. Previously this call\n-            --  was silently skipped.\n-\n-            if Is_Generic_Instance (Subp) then\n-               declare\n-                  Gen_P : constant Entity_Id := Generic_Parent (Parent (Subp));\n-               begin\n-                  if Is_Predefined_File_Name\n-                       (Unit_File_Name (Get_Source_Unit (Gen_P)))\n-                  then\n-                     Set_Is_Inlined (Subp, False);\n-                     Error_Msg_NE (Msg & \"p?\", N, Subp);\n-                     return;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Remove last character (question mark) to make this into an\n-            --  error, because the Inline_Always pragma cannot be obeyed.\n-\n-            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n-\n-         else\n-            Set_Is_Inlined (Subp, False);\n-\n-            if Ineffective_Inline_Warnings then\n-               Error_Msg_NE (Msg & \"p?\", N, Subp);\n-            end if;\n-         end if;\n-      end if;\n-   end Cannot_Inline;\n-\n    --------------------------------------\n    -- Can_Be_Inlined_In_GNATprove_Mode --\n    --------------------------------------\n@@ -1521,7 +1388,8 @@ package body Inline is\n \n       --  Local declarations\n \n-      Id : Entity_Id;  --  Procedure or function entity for the subprogram\n+      Id : Entity_Id;\n+      --  Procedure or function entity for the subprogram\n \n    --  Start of processing for Can_Be_Inlined_In_GNATprove_Mode\n \n@@ -1624,6 +1492,139 @@ package body Inline is\n       end if;\n    end Can_Be_Inlined_In_GNATprove_Mode;\n \n+   -------------------\n+   -- Cannot_Inline --\n+   -------------------\n+\n+   procedure Cannot_Inline\n+     (Msg        : String;\n+      N          : Node_Id;\n+      Subp       : Entity_Id;\n+      Is_Serious : Boolean := False)\n+   is\n+   begin\n+      --  In GNATprove mode, inlining is the technical means by which the\n+      --  higher-level goal of contextual analysis is reached, so issue\n+      --  messages about failure to apply contextual analysis to a\n+      --  subprogram, rather than failure to inline it.\n+\n+      if GNATprove_Mode\n+        and then Msg (Msg'First .. Msg'First + 12) = \"cannot inline\"\n+      then\n+         declare\n+            Len1 : constant Positive :=\n+              String (String'(\"cannot inline\"))'Length;\n+            Len2 : constant Positive :=\n+              String (String'(\"info: no contextual analysis of\"))'Length;\n+\n+            New_Msg : String (1 .. Msg'Length + Len2 - Len1);\n+\n+         begin\n+            New_Msg (1 .. Len2) := \"info: no contextual analysis of\";\n+            New_Msg (Len2 + 1 .. Msg'Length + Len2 - Len1) :=\n+              Msg (Msg'First + Len1 .. Msg'Last);\n+            Cannot_Inline (New_Msg, N, Subp, Is_Serious);\n+            return;\n+         end;\n+      end if;\n+\n+      pragma Assert (Msg (Msg'Last) = '?');\n+\n+      --  Legacy front end inlining model\n+\n+      if not Back_End_Inlining then\n+\n+         --  Do not emit warning if this is a predefined unit which is not\n+         --  the main unit. With validity checks enabled, some predefined\n+         --  subprograms may contain nested subprograms and become ineligible\n+         --  for inlining.\n+\n+         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n+           and then not In_Extended_Main_Source_Unit (Subp)\n+         then\n+            null;\n+\n+         --  In GNATprove mode, issue a warning, and indicate that the\n+         --  subprogram is not always inlined by setting flag Is_Inlined_Always\n+         --  to False.\n+\n+         elsif GNATprove_Mode then\n+            Set_Is_Inlined_Always (Subp, False);\n+            Error_Msg_NE (Msg & \"p?\", N, Subp);\n+\n+         elsif Has_Pragma_Inline_Always (Subp) then\n+\n+            --  Remove last character (question mark) to make this into an\n+            --  error, because the Inline_Always pragma cannot be obeyed.\n+\n+            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n+\n+         elsif Ineffective_Inline_Warnings then\n+            Error_Msg_NE (Msg & \"p?\", N, Subp);\n+         end if;\n+\n+      --  New semantics relying on back end inlining\n+\n+      elsif Is_Serious then\n+\n+         --  Remove last character (question mark) to make this into an error.\n+\n+         Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n+\n+      --  In GNATprove mode, issue a warning, and indicate that the subprogram\n+      --  is not always inlined by setting flag Is_Inlined_Always to False.\n+\n+      elsif GNATprove_Mode then\n+         Set_Is_Inlined_Always (Subp, False);\n+         Error_Msg_NE (Msg & \"p?\", N, Subp);\n+\n+      else\n+\n+         --  Do not emit warning if this is a predefined unit which is not\n+         --  the main unit. This behavior is currently provided for backward\n+         --  compatibility but it will be removed when we enforce the\n+         --  strictness of the new rules.\n+\n+         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n+           and then not In_Extended_Main_Source_Unit (Subp)\n+         then\n+            null;\n+\n+         elsif Has_Pragma_Inline_Always (Subp) then\n+\n+            --  Emit a warning if this is a call to a runtime subprogram\n+            --  which is located inside a generic. Previously this call\n+            --  was silently skipped.\n+\n+            if Is_Generic_Instance (Subp) then\n+               declare\n+                  Gen_P : constant Entity_Id := Generic_Parent (Parent (Subp));\n+               begin\n+                  if Is_Predefined_File_Name\n+                       (Unit_File_Name (Get_Source_Unit (Gen_P)))\n+                  then\n+                     Set_Is_Inlined (Subp, False);\n+                     Error_Msg_NE (Msg & \"p?\", N, Subp);\n+                     return;\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Remove last character (question mark) to make this into an\n+            --  error, because the Inline_Always pragma cannot be obeyed.\n+\n+            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n+\n+         else\n+            Set_Is_Inlined (Subp, False);\n+\n+            if Ineffective_Inline_Warnings then\n+               Error_Msg_NE (Msg & \"p?\", N, Subp);\n+            end if;\n+         end if;\n+      end if;\n+   end Cannot_Inline;\n+\n    --------------------------------------------\n    -- Check_And_Split_Unconstrained_Function --\n    --------------------------------------------\n@@ -3102,8 +3103,8 @@ package body Inline is\n \n          if (Is_Entity_Name (A)\n               and then\n-               (not Is_Scalar_Type (Etype (A))\n-                 or else Ekind (Entity (A)) = E_Enumeration_Literal)\n+                (not Is_Scalar_Type (Etype (A))\n+                  or else Ekind (Entity (A)) = E_Enumeration_Literal)\n               and then not GNATprove_Mode)\n \n          --  When the actual is an identifier and the corresponding formal is\n@@ -3112,9 +3113,10 @@ package body Inline is\n          --  GNATprove mode, to make sure any check on a type conversion\n          --  will be issued.\n \n-           or else (Nkind (A) = N_Identifier\n-             and then Formal_Is_Used_Once (F)\n-             and then not GNATprove_Mode)\n+           or else\n+             (Nkind (A) = N_Identifier\n+               and then Formal_Is_Used_Once (F)\n+               and then not GNATprove_Mode)\n \n            or else\n              (Nkind_In (A, N_Real_Literal,\n@@ -4210,7 +4212,8 @@ package body Inline is\n                                                 Name_Refined_Post,\n                                                 Name_Test_Case,\n                                                 Name_Unmodified,\n-                                                Name_Unreferenced)\n+                                                Name_Unreferenced,\n+                                                Name_Unused)\n             then\n                Remove (Item);\n             end if;\n@@ -4224,6 +4227,11 @@ package body Inline is\n    begin\n       Remove_Items (Aspect_Specifications (Body_Decl));\n       Remove_Items (Declarations          (Body_Decl));\n+\n+      --  Pragmas Unmodified, Unreferenced and Unused may additionally appear\n+      --  in the body of the subprogram.\n+\n+      Remove_Items (Statements (Handled_Statement_Sequence (Body_Decl)));\n    end Remove_Aspects_And_Pragmas;\n \n    --------------------------"}, {"sha": "1fdc37ca731158fea455c4b9475b209dcff1c669", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=da9683f4dbc85066c290798a14d1158f804f92a2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1435,6 +1435,36 @@ package body Namet is\n              T = V11;\n    end Nam_In;\n \n+   function Nam_In\n+     (T   : Name_Id;\n+      V1  : Name_Id;\n+      V2  : Name_Id;\n+      V3  : Name_Id;\n+      V4  : Name_Id;\n+      V5  : Name_Id;\n+      V6  : Name_Id;\n+      V7  : Name_Id;\n+      V8  : Name_Id;\n+      V9  : Name_Id;\n+      V10 : Name_Id;\n+      V11 : Name_Id;\n+      V12 : Name_Id) return Boolean\n+   is\n+   begin\n+      return T = V1  or else\n+             T = V2  or else\n+             T = V3  or else\n+             T = V4  or else\n+             T = V5  or else\n+             T = V6  or else\n+             T = V7  or else\n+             T = V8  or else\n+             T = V9  or else\n+             T = V10 or else\n+             T = V11 or else\n+             T = V12;\n+   end Nam_In;\n+\n    -----------------\n    -- Name_Equals --\n    -----------------"}, {"sha": "9c25b4f78540e11365d7d0f20ae8e69ecf0de935", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=da9683f4dbc85066c290798a14d1158f804f92a2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -311,6 +311,21 @@ package Namet is\n       V10 : Name_Id;\n       V11 : Name_Id) return Boolean;\n \n+   function Nam_In\n+     (T   : Name_Id;\n+      V1  : Name_Id;\n+      V2  : Name_Id;\n+      V3  : Name_Id;\n+      V4  : Name_Id;\n+      V5  : Name_Id;\n+      V6  : Name_Id;\n+      V7  : Name_Id;\n+      V8  : Name_Id;\n+      V9  : Name_Id;\n+      V10 : Name_Id;\n+      V11 : Name_Id;\n+      V12 : Name_Id) return Boolean;\n+\n    pragma Inline (Nam_In);\n    --  Inline all above functions\n "}, {"sha": "142ac8eeadf9dbbf6fe4c8f3a6053bbeb95b8ee1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=da9683f4dbc85066c290798a14d1158f804f92a2", "patch": "@@ -8963,10 +8963,12 @@ package body Sem_Ch13 is\n       --  Expression to be analyzed at end of declarations\n \n       Freeze_Expr : constant Node_Id := Expression (ASN);\n-      --  Expression from call to Check_Aspect_At_Freeze_Point\n+      --  Expression from call to Check_Aspect_At_Freeze_Point. We use\n \n-      T : constant Entity_Id := Etype (Freeze_Expr);\n-      --  Type required for preanalyze call\n+      T : constant Entity_Id := Etype (Original_Node (Freeze_Expr));\n+      --  Type required for preanalyze call. We use the originsl\n+      --  expression to get the proper type, to prevent cascaded errors\n+      --  when the expression is constant-folded.\n \n       Err : Boolean;\n       --  Set False if error\n@@ -12681,6 +12683,9 @@ package body Sem_Ch13 is\n       --  introduce a local identifier that would require proper expansion to\n       --  handle properly.\n \n+      --  In ASIS_Mode we preserve the entity in the source because there is\n+      --  no subsequent expansion to decorate the tree.\n+\n       ------------------\n       -- Resolve_Name --\n       ------------------\n@@ -12698,7 +12703,10 @@ package body Sem_Ch13 is\n \n          elsif Nkind (N) = N_Identifier and then Chars (N) /= Chars (E) then\n             Find_Direct_Name (N);\n-            Set_Entity (N, Empty);\n+\n+            if not ASIS_Mode then\n+               Set_Entity (N, Empty);\n+            end if;\n \n          elsif Nkind (N) = N_Quantified_Expression then\n             return Skip;"}, {"sha": "24ac69fd923b78ebeedc4db13b2bd02f9e4420c3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9683f4dbc85066c290798a14d1158f804f92a2/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=da9683f4dbc85066c290798a14d1158f804f92a2", "patch": "@@ -2178,6 +2178,10 @@ package body Sem_Ch3 is\n       --  If the states have visible refinement, remove the visibility of each\n       --  constituent at the end of the package body declaration.\n \n+      procedure Resolve_Aspects;\n+      --  Utility to resolve the expressions of aspects at the end of a list of\n+      --  declarations.\n+\n       -----------------\n       -- Adjust_Decl --\n       -----------------\n@@ -2369,6 +2373,21 @@ package body Sem_Ch3 is\n          end if;\n       end Remove_Visible_Refinements;\n \n+      ---------------------\n+      -- Resolve_Aspects --\n+      ---------------------\n+\n+      procedure Resolve_Aspects is\n+         E : Entity_Id;\n+\n+      begin\n+         E := First_Entity (Current_Scope);\n+         while Present (E) loop\n+            Resolve_Aspect_Expressions (E);\n+            Next_Entity (E);\n+         end loop;\n+      end Resolve_Aspects;\n+\n       --  Local variables\n \n       Context     : Node_Id   := Empty;\n@@ -2451,13 +2470,31 @@ package body Sem_Ch3 is\n               and then not Is_Child_Unit (Current_Scope)\n               and then No (Generic_Parent (Parent (L)))\n             then\n-               null;\n+               --  This is needed in all cases to catch visibility errors in\n+               --  aspect expressions, but several large user tests are now\n+               --  rejected. Pending notification we restrict this call to\n+               --  ASIS mode.\n+\n+               if ASIS_Mode then\n+                  Resolve_Aspects;\n+               end if;\n \n             elsif L /= Visible_Declarations (Parent (L))\n               or else No (Private_Declarations (Parent (L)))\n               or else Is_Empty_List (Private_Declarations (Parent (L)))\n             then\n                Adjust_Decl;\n+\n+               --  In compilation mode the expansion of freeze node takes care\n+               --  of resolving expressions of all aspects in the list. In ASIS\n+               --  mode this must be done explicitly.\n+\n+               if ASIS_Mode\n+                 and then Scope (Current_Scope) = Standard_Standard\n+               then\n+                  Resolve_Aspects;\n+               end if;\n+\n                Freeze_All (First_Entity (Current_Scope), Decl);\n                Freeze_From := Last_Entity (Current_Scope);\n \n@@ -2473,16 +2510,7 @@ package body Sem_Ch3 is\n             --  pragmas do not appear in the original generic tree.\n \n             elsif Serious_Errors_Detected = 0 then\n-               declare\n-                  E : Entity_Id;\n-\n-               begin\n-                  E := First_Entity (Current_Scope);\n-                  while Present (E) loop\n-                     Resolve_Aspect_Expressions (E);\n-                     Next_Entity (E);\n-                  end loop;\n-               end;\n+               Resolve_Aspects;\n             end if;\n \n          --  If next node is a body then freeze all types before the body."}]}