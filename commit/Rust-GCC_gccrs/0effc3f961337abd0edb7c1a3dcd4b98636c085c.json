{"sha": "0effc3f961337abd0edb7c1a3dcd4b98636c085c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVmZmMzZjk2MTMzN2FiZDBlZGI3YzFhM2RjZDRiOTg2MzZjMDg1Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-07T01:16:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-07T01:16:20Z"}, "message": "libgo: Implement and use runtime.Caller, runtime.Func.FileLine.\n\nFrom-SVN: r185025", "tree": {"sha": "28d4e50a31f7428050763b36e3c7bbdeeb541a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28d4e50a31f7428050763b36e3c7bbdeeb541a0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0effc3f961337abd0edb7c1a3dcd4b98636c085c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0effc3f961337abd0edb7c1a3dcd4b98636c085c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0effc3f961337abd0edb7c1a3dcd4b98636c085c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0effc3f961337abd0edb7c1a3dcd4b98636c085c/comments", "author": null, "committer": null, "parents": [{"sha": "1f3d0afc2623f1728a73971d415ca2991f7b9c18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3d0afc2623f1728a73971d415ca2991f7b9c18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3d0afc2623f1728a73971d415ca2991f7b9c18"}], "stats": {"total": 929, "additions": 861, "deletions": 68}, "files": [{"sha": "99294f12c12c1f7f512b06decdfda0801149b408", "filename": "libgo/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -1024,12 +1024,14 @@ go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n \tgo/debug/dwarf/entry.go \\\n+\tgo/debug/dwarf/line.go \\\n \tgo/debug/dwarf/open.go \\\n \tgo/debug/dwarf/type.go \\\n \tgo/debug/dwarf/unit.go\n go_debug_elf_files = \\\n \tgo/debug/elf/elf.go \\\n-\tgo/debug/elf/file.go\n+\tgo/debug/elf/file.go \\\n+\tgo/debug/elf/runtime.go\n go_debug_gosym_files = \\\n \tgo/debug/gosym/pclntab.go \\\n \tgo/debug/gosym/symtab.go"}, {"sha": "b57d92919b5a1c178d84eca67e15a3a1f85b36f2", "filename": "libgo/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -1340,13 +1340,15 @@ go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n \tgo/debug/dwarf/const.go \\\n \tgo/debug/dwarf/entry.go \\\n+\tgo/debug/dwarf/line.go \\\n \tgo/debug/dwarf/open.go \\\n \tgo/debug/dwarf/type.go \\\n \tgo/debug/dwarf/unit.go\n \n go_debug_elf_files = \\\n \tgo/debug/elf/elf.go \\\n-\tgo/debug/elf/file.go\n+\tgo/debug/elf/file.go \\\n+\tgo/debug/elf/runtime.go\n \n go_debug_gosym_files = \\\n \tgo/debug/gosym/pclntab.go \\"}, {"sha": "5301edc461ad98b3d9799827cfa3ced542161b02", "filename": "libgo/go/debug/dwarf/const.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -431,3 +431,30 @@ const (\n \tencUnsignedChar   = 0x08\n \tencImaginaryFloat = 0x09\n )\n+\n+// Line number opcodes.\n+const (\n+\tLineExtendedOp     = 0\n+\tLineCopy           = 1\n+\tLineAdvancePC      = 2\n+\tLineAdvanceLine    = 3\n+\tLineSetFile        = 4\n+\tLineSetColumn      = 5\n+\tLineNegateStmt     = 6\n+\tLineSetBasicBlock  = 7\n+\tLineConstAddPC     = 8\n+\tLineFixedAdvancePC = 9\n+\t// next 3 are DWARF 3\n+\tLineSetPrologueEnd   = 10\n+\tLineSetEpilogueBegin = 11\n+\tLineSetISA           = 12\n+)\n+\n+// Line number extended opcodes.\n+const (\n+\tLineExtEndSequence = 1\n+\tLineExtSetAddress  = 2\n+\tLineExtDefineFile  = 3\n+\t// next 1 is DWARF 4\n+\tLineExtSetDiscriminator = 4\n+)"}, {"sha": "f9a4c1b4119744fd1fc746c074be5e87b68a4dc9", "filename": "libgo/go/debug/dwarf/entry.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -246,6 +246,15 @@ func (d *Data) Reader() *Reader {\n \treturn r\n }\n \n+// unitReader returns a new reader starting at a specific unit.\n+func (d *Data) unitReader(i int) *Reader {\n+\tr := &Reader{d: d}\n+\tr.unit = i\n+\tu := &d.unit[i]\n+\tr.b = makeBuf(d, \"info\", u.off, u.data, u.addrsize)\n+\treturn r\n+}\n+\n // Seek positions the Reader at offset off in the encoded entry stream.\n // Offset 0 can be used to denote the first entry.\n func (r *Reader) Seek(off Offset) {"}, {"sha": "091ebe0d17d675365044b2d56de5a8711ccf7737", "filename": "libgo/go/debug/dwarf/line.go", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -0,0 +1,416 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// DWARF line number information.\n+\n+package dwarf\n+\n+import (\n+\t\"errors\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+)\n+\n+// A Line holds all the available information about the source code\n+// corresponding to a specific program counter address.\n+type Line struct {\n+\tFilename      string // source file name\n+\tOpIndex       int    // index of operation in VLIW instruction\n+\tLine          int    // line number\n+\tColumn        int    // column number\n+\tISA           int    // instruction set code\n+\tDiscriminator int    // block discriminator\n+\tStmt          bool   // instruction starts statement\n+\tBlock         bool   // instruction starts basic block\n+\tEndPrologue   bool   // instruction ends function prologue\n+\tBeginEpilogue bool   // instruction begins function epilogue\n+}\n+\n+// LineForPc returns the line number information for a program counter\n+// address, if any.  When this returns multiple Line structures in a\n+// context where only one can be used, the last one is the best.\n+func (d *Data) LineForPC(pc uint64) ([]*Line, error) {\n+\tfor i := range d.unit {\n+\t\tu := &d.unit[i]\n+\t\tif u.pc == nil {\n+\t\t\tif err := d.readUnitLine(i, u); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t\tfor _, ar := range u.pc {\n+\t\t\tif pc >= ar.low && pc < ar.high {\n+\t\t\t\treturn d.findLine(u, pc)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil, nil\n+}\n+\n+// readUnitLine reads in the line number information for a compilation\n+// unit.\n+func (d *Data) readUnitLine(i int, u *unit) error {\n+\tr := d.unitReader(i)\n+\tsetLineOff := false\n+\tfor {\n+\t\te, err := r.Next()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif e == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tif r.unit != i {\n+\t\t\tbreak\n+\t\t}\n+\t\tswitch e.Tag {\n+\t\tcase TagCompileUnit, TagSubprogram, TagEntryPoint, TagInlinedSubroutine:\n+\t\t\tlow, lowok := e.Val(AttrLowpc).(uint64)\n+\t\t\thigh, highok := e.Val(AttrHighpc).(uint64)\n+\t\t\tif lowok && highok {\n+\t\t\t\tu.pc = append(u.pc, addrRange{low, high})\n+\t\t\t} else if f, ok := e.Val(AttrRanges).(Offset); ok {\n+\t\t\t\t// TODO: Handle AttrRanges and .debug_ranges.\n+\t\t\t\t_ = f\n+\t\t\t}\n+\t\t\tif off, ok := e.Val(AttrStmtList).(int64); ok {\n+\t\t\t\tu.lineoff = Offset(off)\n+\t\t\t\tsetLineOff = true\n+\t\t\t}\n+\t\t\tif dir, ok := e.Val(AttrCompDir).(string); ok {\n+\t\t\t\tu.dir = dir\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif !setLineOff {\n+\t\tu.lineoff = Offset(0)\n+\t\tu.lineoff--\n+\t}\n+\treturn nil\n+}\n+\n+// findLine finds the line information for a PC value, given the unit\n+// containing the information.\n+func (d *Data) findLine(u *unit, pc uint64) ([]*Line, error) {\n+\tif u.lines == nil {\n+\t\tif err := d.parseLine(u); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tfor _, ln := range u.lines {\n+\t\tif pc < ln.addrs[0].pc || pc > ln.addrs[len(ln.addrs)-1].pc {\n+\t\t\tcontinue\n+\t\t}\n+\t\ti := sort.Search(len(ln.addrs),\n+\t\t\tfunc(i int) bool { return ln.addrs[i].pc > pc })\n+\t\ti--\n+\t\tp := new(Line)\n+\t\t*p = ln.line\n+\t\tp.Line = ln.addrs[i].line\n+\t\tret := []*Line{p}\n+\t\tfor i++; i < len(ln.addrs) && ln.addrs[i].pc == pc; i++ {\n+\t\t\tp = new(Line)\n+\t\t\t*p = ln.line\n+\t\t\tp.Line = ln.addrs[i].line\n+\t\t\tret = append(ret, p)\n+\t\t}\n+\t\treturn ret, nil\n+\t}\n+\n+\treturn nil, nil\n+}\n+\n+// FileLine returns the file name and line number for a program\n+// counter address, or \"\", 0 if unknown.\n+func (d *Data) FileLine(pc uint64) (string, int, error) {\n+\tr, err := d.LineForPC(pc)\n+\tif err != nil {\n+\t\treturn \"\", 0, err\n+\t}\n+\tif r == nil {\n+\t\treturn \"\", 0, nil\n+\t}\n+\tln := r[len(r)-1]\n+\treturn ln.Filename, ln.Line, nil\n+}\n+\n+// A mapLineInfo holds the PC values and line numbers associated with\n+// a single Line structure.  This representation is chosen to reduce\n+// memory usage based on typical debug info.\n+type mapLineInfo struct {\n+\tline  Line      // line.Line will be zero\n+\taddrs lineAddrs // sorted by PC\n+}\n+\n+// A list of lines.  This will be sorted by PC.\n+type lineAddrs []oneLineInfo\n+\n+func (p lineAddrs) Len() int           { return len(p) }\n+func (p lineAddrs) Less(i, j int) bool { return p[i].pc < p[j].pc }\n+func (p lineAddrs) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n+\n+// A oneLineInfo is a single PC and line number.\n+type oneLineInfo struct {\n+\tpc   uint64\n+\tline int\n+}\n+\n+// A lineHdr holds the relevant information from a line number\n+// program header.\n+type lineHdr struct {\n+\tversion       uint16   // version of line number encoding\n+\tminInsnLen    uint8    // minimum instruction length\n+\tmaxOpsPerInsn uint8    // maximum number of ops per instruction\n+\tdefStmt       bool     // initial value of stmt register\n+\tlineBase      int8     // line adjustment base\n+\tlineRange     uint8    // line adjustment step\n+\topBase        uint8    // base of special opcode values\n+\topLen         []uint8  // lengths of standard opcodes\n+\tdirs          []string // directories\n+\tfiles         []string // file names\n+}\n+\n+// parseLine parses the line number information for a compilation unit\n+func (d *Data) parseLine(u *unit) error {\n+\tif u.lineoff+1 == 0 {\n+\t\treturn errors.New(\"unknown line offset\")\n+\t}\n+\tb := makeBuf(d, \"line\", u.lineoff, d.line, u.addrsize)\n+\tlen := uint64(b.uint32())\n+\toffSize := 4\n+\tif len == 0xffffffff {\n+\t\tlen = b.uint64()\n+\t\toffSize = 8\n+\t}\n+\tend := b.off + Offset(len)\n+\thdr := d.parseLineHdr(u, &b, offSize)\n+\tif b.err == nil {\n+\t\td.parseLineProgram(u, &b, hdr, end)\n+\t}\n+\treturn b.err\n+}\n+\n+// parseLineHdr parses a line number program header.\n+func (d *Data) parseLineHdr(u *unit, b *buf, offSize int) (hdr lineHdr) {\n+\thdr.version = b.uint16()\n+\tif hdr.version < 2 || hdr.version > 4 {\n+\t\tb.error(\"unsupported DWARF version \" + strconv.Itoa(int(hdr.version)))\n+\t\treturn\n+\t}\n+\n+\tb.bytes(offSize) // header length\n+\n+\thdr.minInsnLen = b.uint8()\n+\tif hdr.version < 4 {\n+\t\thdr.maxOpsPerInsn = 1\n+\t} else {\n+\t\thdr.maxOpsPerInsn = b.uint8()\n+\t}\n+\n+\tif b.uint8() == 0 {\n+\t\thdr.defStmt = false\n+\t} else {\n+\t\thdr.defStmt = true\n+\t}\n+\thdr.lineBase = int8(b.uint8())\n+\thdr.lineRange = b.uint8()\n+\thdr.opBase = b.uint8()\n+\thdr.opLen = b.bytes(int(hdr.opBase - 1))\n+\n+\tfor d := b.string(); len(d) > 0; d = b.string() {\n+\t\thdr.dirs = append(hdr.dirs, d)\n+\t}\n+\n+\tfor f := b.string(); len(f) > 0; f = b.string() {\n+\t\td := b.uint()\n+\t\tif !filepath.IsAbs(f) {\n+\t\t\tif d > 0 {\n+\t\t\t\tif d > uint64(len(hdr.dirs)) {\n+\t\t\t\t\tb.error(\"DWARF directory index out of range\")\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tf = filepath.Join(hdr.dirs[d-1], f)\n+\t\t\t} else if u.dir != \"\" {\n+\t\t\t\tf = filepath.Join(u.dir, f)\n+\t\t\t}\n+\t\t}\n+\t\tb.uint() // file's last mtime\n+\t\tb.uint() // file length\n+\t\thdr.files = append(hdr.files, f)\n+\t}\n+\n+\treturn\n+}\n+\n+// parseLineProgram parses a line program, adding information to\n+// d.lineInfo as it goes.\n+func (d *Data) parseLineProgram(u *unit, b *buf, hdr lineHdr, end Offset) {\n+\taddress := uint64(0)\n+\tline := 1\n+\tresetLineInfo := Line{\n+\t\tFilename:      \"\",\n+\t\tOpIndex:       0,\n+\t\tLine:          0,\n+\t\tColumn:        0,\n+\t\tISA:           0,\n+\t\tDiscriminator: 0,\n+\t\tStmt:          hdr.defStmt,\n+\t\tBlock:         false,\n+\t\tEndPrologue:   false,\n+\t\tBeginEpilogue: false,\n+\t}\n+\tif len(hdr.files) > 0 {\n+\t\tresetLineInfo.Filename = hdr.files[0]\n+\t}\n+\tlineInfo := resetLineInfo\n+\n+\tvar lines []mapLineInfo\n+\n+\tminInsnLen := uint64(hdr.minInsnLen)\n+\tmaxOpsPerInsn := uint64(hdr.maxOpsPerInsn)\n+\tlineBase := int(hdr.lineBase)\n+\tlineRange := hdr.lineRange\n+\tnewLineInfo := true\n+\tfor b.off < end && b.err == nil {\n+\t\top := b.uint8()\n+\t\tif op >= hdr.opBase {\n+\t\t\t// This is a special opcode.\n+\t\t\top -= hdr.opBase\n+\t\t\tadvance := uint64(op / hdr.lineRange)\n+\t\t\topIndex := uint64(lineInfo.OpIndex)\n+\t\t\taddress += minInsnLen * ((opIndex + advance) / maxOpsPerInsn)\n+\t\t\tnewOpIndex := int((opIndex + advance) % maxOpsPerInsn)\n+\t\t\tline += lineBase + int(op%lineRange)\n+\t\t\tif newOpIndex != lineInfo.OpIndex {\n+\t\t\t\tlineInfo.OpIndex = newOpIndex\n+\t\t\t\tnewLineInfo = true\n+\t\t\t}\n+\t\t\tlines, lineInfo, newLineInfo = d.addLine(lines, lineInfo, address, line, newLineInfo)\n+\t\t} else if op == LineExtendedOp {\n+\t\t\tc := b.uint()\n+\t\t\top = b.uint8()\n+\t\t\tswitch op {\n+\t\t\tcase LineExtEndSequence:\n+\t\t\t\tu.lines = append(u.lines, lines...)\n+\t\t\t\tlineInfo = resetLineInfo\n+\t\t\t\tlines = nil\n+\t\t\tcase LineExtSetAddress:\n+\t\t\t\taddress = b.addr()\n+\t\t\tcase LineExtDefineFile:\n+\t\t\t\tf := b.string()\n+\t\t\t\td := b.uint()\n+\t\t\t\tb.uint() // mtime\n+\t\t\t\tb.uint() // length\n+\t\t\t\tif d > 0 && !filepath.IsAbs(f) {\n+\t\t\t\t\tif d >= uint64(len(hdr.dirs)) {\n+\t\t\t\t\t\tb.error(\"DWARF directory index out of range\")\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tf = filepath.Join(hdr.dirs[d-1], f)\n+\t\t\t\t}\n+\t\t\t\thdr.files = append(hdr.files, f)\n+\t\t\tcase LineExtSetDiscriminator:\n+\t\t\t\tlineInfo.Discriminator = int(b.uint())\n+\t\t\t\tnewLineInfo = true\n+\t\t\tdefault:\n+\t\t\t\tif c > 0 {\n+\t\t\t\t\tb.bytes(int(c) - 1)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tswitch op {\n+\t\t\tcase LineCopy:\n+\t\t\t\tlines, lineInfo, newLineInfo = d.addLine(lines, lineInfo, address, line, newLineInfo)\n+\t\t\tcase LineAdvancePC:\n+\t\t\t\tadvance := b.uint()\n+\t\t\t\topIndex := uint64(lineInfo.OpIndex)\n+\t\t\t\taddress += minInsnLen * ((opIndex + advance) / maxOpsPerInsn)\n+\t\t\t\tnewOpIndex := int((opIndex + advance) % maxOpsPerInsn)\n+\t\t\t\tif newOpIndex != lineInfo.OpIndex {\n+\t\t\t\t\tlineInfo.OpIndex = newOpIndex\n+\t\t\t\t\tnewLineInfo = true\n+\t\t\t\t}\n+\t\t\tcase LineAdvanceLine:\n+\t\t\t\tline += int(b.int())\n+\t\t\tcase LineSetFile:\n+\t\t\t\ti := b.uint()\n+\t\t\t\tif i > uint64(len(hdr.files)) {\n+\t\t\t\t\tb.error(\"DWARF file number out of range\")\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tlineInfo.Filename = hdr.files[i]\n+\t\t\t\tnewLineInfo = true\n+\t\t\tcase LineSetColumn:\n+\t\t\t\tlineInfo.Column = int(b.uint())\n+\t\t\t\tnewLineInfo = true\n+\t\t\tcase LineNegateStmt:\n+\t\t\t\tlineInfo.Stmt = !lineInfo.Stmt\n+\t\t\t\tnewLineInfo = true\n+\t\t\tcase LineSetBasicBlock:\n+\t\t\t\tlineInfo.Block = true\n+\t\t\t\tnewLineInfo = true\n+\t\t\tcase LineConstAddPC:\n+\t\t\t\top = 255 - hdr.opBase\n+\t\t\t\tadvance := uint64(op / hdr.lineRange)\n+\t\t\t\topIndex := uint64(lineInfo.OpIndex)\n+\t\t\t\taddress += minInsnLen * ((opIndex + advance) / maxOpsPerInsn)\n+\t\t\t\tnewOpIndex := int((opIndex + advance) % maxOpsPerInsn)\n+\t\t\t\tif newOpIndex != lineInfo.OpIndex {\n+\t\t\t\t\tlineInfo.OpIndex = newOpIndex\n+\t\t\t\t\tnewLineInfo = true\n+\t\t\t\t}\n+\t\t\tcase LineFixedAdvancePC:\n+\t\t\t\taddress += uint64(b.uint16())\n+\t\t\t\tif lineInfo.OpIndex != 0 {\n+\t\t\t\t\tlineInfo.OpIndex = 0\n+\t\t\t\t\tnewLineInfo = true\n+\t\t\t\t}\n+\t\t\tcase LineSetPrologueEnd:\n+\t\t\t\tlineInfo.EndPrologue = true\n+\t\t\t\tnewLineInfo = true\n+\t\t\tcase LineSetEpilogueBegin:\n+\t\t\t\tlineInfo.BeginEpilogue = true\n+\t\t\t\tnewLineInfo = true\n+\t\t\tcase LineSetISA:\n+\t\t\t\tlineInfo.ISA = int(b.uint())\n+\t\t\t\tnewLineInfo = true\n+\t\t\tdefault:\n+\t\t\t\tif int(op) >= len(hdr.opLen) {\n+\t\t\t\t\tb.error(\"DWARF line opcode has unknown length\")\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tfor i := hdr.opLen[op-1]; i > 0; i-- {\n+\t\t\t\t\tb.int()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// addLine adds the current address and line to lines using lineInfo.\n+// If newLineInfo is true this is a new lineInfo.  This returns the\n+// updated lines, lineInfo, and newLineInfo.\n+func (d *Data) addLine(lines []mapLineInfo, lineInfo Line, address uint64, line int, newLineInfo bool) ([]mapLineInfo, Line, bool) {\n+\tif newLineInfo {\n+\t\tif len(lines) > 0 {\n+\t\t\tsort.Sort(lines[len(lines)-1].addrs)\n+\t\t}\n+\t\tlines = append(lines, mapLineInfo{line: lineInfo})\n+\t}\n+\tp := &lines[len(lines)-1]\n+\tp.addrs = append(p.addrs, oneLineInfo{address, line})\n+\n+\tif lineInfo.Block || lineInfo.EndPrologue || lineInfo.BeginEpilogue || lineInfo.Discriminator != 0 {\n+\t\tlineInfo.Block = false\n+\t\tlineInfo.EndPrologue = false\n+\t\tlineInfo.BeginEpilogue = false\n+\t\tlineInfo.Discriminator = 0\n+\t\tnewLineInfo = true\n+\t} else {\n+\t\tnewLineInfo = false\n+\t}\n+\n+\treturn lines, lineInfo, newLineInfo\n+}"}, {"sha": "2476a6faf53ec2e20511720e31f65ccf3f3c1f5b", "filename": "libgo/go/debug/dwarf/line_test.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package dwarf_test\n+\n+import (\n+\t. \"debug/dwarf\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+type lineTest struct {\n+\tpc   uint64\n+\tfile string\n+\tline int\n+}\n+\n+var elfLineTests = [...]lineTest{\n+\t{0x4004c4, \"typedef.c\", 83},\n+\t{0x4004c8, \"typedef.c\", 84},\n+\t{0x4004ca, \"typedef.c\", 84},\n+\t{0x4003e0, \"\", 0},\n+}\n+\n+var machoLineTests = [...]lineTest{\n+\t{0x0, \"typedef.c\", 83},\n+}\n+\n+func TestLineElf(t *testing.T) {\n+\ttestLine(t, elfData(t, \"testdata/typedef.elf\"), elfLineTests[:], \"elf\")\n+}\n+\n+func TestLineMachO(t *testing.T) {\n+\ttestLine(t, machoData(t, \"testdata/typedef.macho\"), machoLineTests[:], \"macho\")\n+}\n+\n+func testLine(t *testing.T, d *Data, tests []lineTest, kind string) {\n+\tfor _, v := range tests {\n+\t\tfile, line, err := d.FileLine(v.pc)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %v\", kind, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif file != \"\" {\n+\t\t\tfile = filepath.Base(file)\n+\t\t}\n+\t\tif file != v.file || line != v.line {\n+\t\t\tt.Errorf(\"%s: for %d have %q:%d want %q:%d\",\n+\t\t\t\tkind, v.pc, file, line, v.file, v.line)\n+\t\t}\n+\t}\n+}"}, {"sha": "931468a3718e22464e828a0d8f6a8554364635a8", "filename": "libgo/go/debug/dwarf/unit.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -12,9 +12,19 @@ import \"strconv\"\n type unit struct {\n \tbase     Offset // byte offset of header within the aggregate info\n \toff      Offset // byte offset of data within the aggregate info\n+\tlineoff  Offset // byte offset of data within the line info\n \tdata     []byte\n \tatable   abbrevTable\n \taddrsize int\n+\tdir      string\n+\tpc       []addrRange   // PC ranges in this compilation unit\n+\tlines    []mapLineInfo // PC -> line mapping\n+}\n+\n+// A range is an address range.\n+type addrRange struct {\n+\tlow  uint64\n+\thigh uint64\n }\n \n func (d *Data) parseUnits() ([]unit, error) {"}, {"sha": "b8cdbcc7e518010ad056ae7cab6e50c62931fd3c", "filename": "libgo/go/debug/elf/elf_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Felf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Felf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -2,9 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package elf\n+package elf_test\n \n import (\n+\t. \"debug/elf\"\n \t\"fmt\"\n \t\"testing\"\n )"}, {"sha": "c2c03d2c64720ea975eb6d500a43c627da2e560d", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -563,7 +563,7 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \t// There are many other DWARF sections, but these\n \t// are the required ones, and the debug/dwarf package\n \t// does not use the others, so don't bother loading them.\n-\tvar names = [...]string{\"abbrev\", \"info\", \"str\"}\n+\tvar names = [...]string{\"abbrev\", \"info\", \"line\", \"str\"}\n \tvar dat [len(names)][]byte\n \tfor i, name := range names {\n \t\tname = \".debug_\" + name\n@@ -592,8 +592,8 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \t\t}\n \t}\n \n-\tabbrev, info, str := dat[0], dat[1], dat[2]\n-\treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n+\tabbrev, info, line, str := dat[0], dat[1], dat[2], dat[3]\n+\treturn dwarf.New(abbrev, nil, nil, info, line, nil, nil, str)\n }\n \n // Symbols returns the symbol table for f."}, {"sha": "105b697a4fb7ea7eb622e0239f3a8886c2b7a300", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -2,10 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package elf\n+package elf_test\n \n import (\n \t\"debug/dwarf\"\n+\t. \"debug/elf\"\n \t\"encoding/binary\"\n \t\"net\"\n \t\"os\""}, {"sha": "23e79bff5db2f354d69d416b94ec830d2974b7a5", "filename": "libgo/go/debug/elf/runtime.go", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Felf%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Fruntime.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This is gccgo-specific code that uses DWARF information to fetch\n+// file/line information for PC values.  This package registers itself\n+// with the runtime package.\n+\n+package elf\n+\n+import (\n+\t\"debug/dwarf\"\n+\t\"debug/macho\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"sort\"\n+\t\"sync\"\n+)\n+\n+func init() {\n+\t// Register our lookup functions with the runtime package.\n+\truntime.RegisterDebugLookup(funcFileLine, symbolValue)\n+}\n+\n+// The file struct holds information for a specific file that is part\n+// of the execution.\n+type file struct {\n+\telf   *File       // If ELF\n+\tmacho *macho.File // If Mach-O\n+\tdwarf *dwarf.Data // DWARF information\n+\n+\tsymsByName []sym // Sorted by name\n+\tsymsByAddr []sym // Sorted by address\n+}\n+\n+// Sort symbols by name.\n+type symsByName []sym\n+\n+func (s symsByName) Len() int           { return len(s) }\n+func (s symsByName) Less(i, j int) bool { return s[i].name < s[j].name }\n+func (s symsByName) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n+\n+// Sort symbols by address.\n+type symsByAddr []sym\n+\n+func (s symsByAddr) Len() int           { return len(s) }\n+func (s symsByAddr) Less(i, j int) bool { return s[i].addr < s[j].addr }\n+func (s symsByAddr) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n+\n+// The sym structure holds the information we care about for a symbol,\n+// namely name and address.\n+type sym struct {\n+\tname string\n+\taddr uintptr\n+}\n+\n+// Open an input file.\n+func open(name string) (*file, error) {\n+\tefile, err := Open(name)\n+\tvar mfile *macho.File\n+\tif err != nil {\n+\t\tvar merr error\n+\t\tmfile, merr = macho.Open(name)\n+\t\tif merr != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tr := &file{elf: efile, macho: mfile}\n+\n+\tif efile != nil {\n+\t\tr.dwarf, err = efile.DWARF()\n+\t} else {\n+\t\tr.dwarf, err = mfile.DWARF()\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar syms []sym\n+\tif efile != nil {\n+\t\tesyms, err := efile.Symbols()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tsyms = make([]sym, 0, len(esyms))\n+\t\tfor _, s := range esyms {\n+\t\t\tif ST_TYPE(s.Info) == STT_FUNC {\n+\t\t\t\tsyms = append(syms, sym{s.Name, uintptr(s.Value)})\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tsyms = make([]sym, 0, len(mfile.Symtab.Syms))\n+\t\tfor _, s := range mfile.Symtab.Syms {\n+\t\t\tsyms = append(syms, sym{s.Name, uintptr(s.Value)})\n+\t\t}\n+\t}\n+\n+\tr.symsByName = make([]sym, len(syms))\n+\tcopy(r.symsByName, syms)\n+\tsort.Sort(symsByName(r.symsByName))\n+\n+\tr.symsByAddr = syms\n+\tsort.Sort(symsByAddr(r.symsByAddr))\n+\n+\treturn r, nil\n+}\n+\n+// The main executable\n+var executable *file\n+\n+// Only open the executable once.\n+var executableOnce sync.Once\n+\n+func openExecutable() {\n+\texecutableOnce.Do(func() {\n+\t\tf, err := open(\"/proc/self/exe\")\n+\t\tif err != nil {\n+\t\t\tf, err = open(os.Args[0])\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\texecutable = f\n+\t})\n+}\n+\n+// The funcFileLine function looks up the function name, file name,\n+// and line number for a PC value.\n+func funcFileLine(pc uintptr, function *string, file *string, line *int) bool {\n+\topenExecutable()\n+\tif executable.dwarf == nil {\n+\t\treturn false\n+\t}\n+\tf, ln, err := executable.dwarf.FileLine(uint64(pc))\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\t*file = f\n+\t*line = ln\n+\n+\t*function = \"\"\n+\tif len(executable.symsByAddr) > 0 && pc >= executable.symsByAddr[0].addr {\n+\t\ti := sort.Search(len(executable.symsByAddr),\n+\t\t\tfunc(i int) bool { return executable.symsByAddr[i].addr > pc })\n+\t\t*function = executable.symsByAddr[i-1].name\n+\t}\n+\n+\treturn true\n+}\n+\n+// The symbolValue function fetches the value of a symbol.\n+func symbolValue(name string, val *uintptr) bool {\n+\ti := sort.Search(len(executable.symsByName),\n+\t\tfunc(i int) bool { return executable.symsByName[i].name >= name })\n+\tif i >= len(executable.symsByName) || executable.symsByName[i].name != name {\n+\t\treturn false\n+\t}\n+\t*val = executable.symsByName[i].addr\n+\treturn true\n+}"}, {"sha": "6577803a07513f220c48926f3917c9d38a655743", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -467,7 +467,7 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \t// There are many other DWARF sections, but these\n \t// are the required ones, and the debug/dwarf package\n \t// does not use the others, so don't bother loading them.\n-\tvar names = [...]string{\"abbrev\", \"info\", \"str\"}\n+\tvar names = [...]string{\"abbrev\", \"info\", \"line\", \"str\"}\n \tvar dat [len(names)][]byte\n \tfor i, name := range names {\n \t\tname = \"__debug_\" + name\n@@ -482,8 +482,8 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \t\tdat[i] = b\n \t}\n \n-\tabbrev, info, str := dat[0], dat[1], dat[2]\n-\treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n+\tabbrev, info, line, str := dat[0], dat[1], dat[2], dat[3]\n+\treturn dwarf.New(abbrev, nil, nil, info, line, nil, nil, str)\n }\n \n // ImportedSymbols returns the names of all symbols"}, {"sha": "ecc6f68a947db20ab9c94db071e7584508195b3f", "filename": "libgo/go/debug/macho/file_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -2,9 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package macho\n+package macho_test\n \n import (\n+\t. \"debug/macho\"\n \t\"reflect\"\n \t\"testing\"\n )"}, {"sha": "dec47a1894f941e739e37e57219c2bffb4a1d6e6", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -2,10 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package binary\n+package binary_test\n \n import (\n \t\"bytes\"\n+\t. \"encoding/binary\"\n \t\"io\"\n \t\"math\"\n \t\"reflect\"\n@@ -187,7 +188,7 @@ func BenchmarkReadStruct(b *testing.B) {\n \tbsr := &byteSliceReader{}\n \tvar buf bytes.Buffer\n \tWrite(&buf, BigEndian, &s)\n-\tn := dataSize(reflect.ValueOf(s))\n+\tn := DataSize(reflect.ValueOf(s))\n \tb.SetBytes(int64(n))\n \tt := s\n \tb.ResetTimer()"}, {"sha": "9eae2a961fce87346e245dbf152b40ac3f71206d", "filename": "libgo/go/encoding/binary/export_test.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fencoding%2Fbinary%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fencoding%2Fbinary%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fexport_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package binary\n+\n+import \"reflect\"\n+\n+// Export for testing.\n+\n+func DataSize(v reflect.Value) int {\n+\treturn dataSize(v)\n+}\n+\n+var Overflow = overflow"}, {"sha": "f67ca6321bd68853fa9a3217d6c8f089d78eaf2e", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -2,10 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package binary\n+package binary_test\n \n import (\n \t\"bytes\"\n+\t. \"encoding/binary\"\n \t\"io\"\n \t\"testing\"\n )\n@@ -134,8 +135,8 @@ func testOverflow(t *testing.T, buf []byte, n0 int, err0 error) {\n }\n \n func TestOverflow(t *testing.T) {\n-\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, -10, overflow)\n-\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, -13, overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, -10, Overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, -13, Overflow)\n }\n \n func TestNonCanonicalZero(t *testing.T) {"}, {"sha": "02a407ebc60f4ea77348930b2d6c67877cfc8765", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -14,6 +14,7 @@ package log\n \n import (\n \t\"bytes\"\n+\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\""}, {"sha": "158c3d93c7e2fb8262579d855767cabf381517f0", "filename": "libgo/go/log/log_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Flog%2Flog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Flog%2Flog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -17,9 +17,9 @@ const (\n \tRdate         = `[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9]`\n \tRtime         = `[0-9][0-9]:[0-9][0-9]:[0-9][0-9]`\n \tRmicroseconds = `\\.[0-9][0-9][0-9][0-9][0-9][0-9]`\n-\tRline         = `[0-9]+:` // must update if the calls to l.Printf / l.Print below move\n-\tRlongfile     = `.*/[A-Za-z0-9_\\-]+\\.go:|\\?\\?\\?:` + Rline\n-\tRshortfile    = `[A-Za-z0-9_\\-]+\\.go:|\\?\\?\\?:` + Rline\n+\tRline         = `(54|56):` // must update if the calls to l.Printf / l.Print below move\n+\tRlongfile     = `.*/[A-Za-z0-9_\\-]+\\.go:` + Rline\n+\tRshortfile    = `[A-Za-z0-9_\\-]+\\.go:` + Rline\n )\n \n type tester struct {"}, {"sha": "b8874f35d2f717fb40a97d25d8a1f5372be41bc0", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -35,6 +35,7 @@ package pprof\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"html/template\"\n \t\"io\""}, {"sha": "d0e987b85f7bd19ac2f650cc2f2671a71607bccb", "filename": "libgo/go/net/ip_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fnet%2Fip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fnet%2Fip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip_test.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -6,6 +6,7 @@ package net\n \n import (\n \t\"bytes\"\n+\t_ \"debug/elf\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"testing\""}, {"sha": "fc74e537b754d06d443c1abc81672a518ce19120", "filename": "libgo/go/runtime/debug/stack.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -8,6 +8,7 @@ package debug\n \n import (\n \t\"bytes\"\n+\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\""}, {"sha": "2c097b0c013d59718b828577d7979f44e8537021", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -32,16 +32,8 @@ func Caller(skip int) (pc uintptr, file string, line int, ok bool)\n func Callers(skip int, pc []uintptr) int\n \n type Func struct { // Keep in sync with runtime.h:struct Func\n-\tname   string\n-\ttyp    string  // go type string\n-\tsrc    string  // src file name\n-\tpcln   []byte  // pc/ln tab for this func\n-\tentry  uintptr // entry pc\n-\tpc0    uintptr // starting pc, ln for table\n-\tln0    int32\n-\tframe  int32 // stack frame size\n-\targs   int32 // number of 32-bit in/out args\n-\tlocals int32 // number of 32-bit locals\n+\tname  string\n+\tentry uintptr // entry pc\n }\n \n // FuncForPC returns a *Func describing the function that contains the\n@@ -65,6 +57,10 @@ func (f *Func) FileLine(pc uintptr) (file string, line int) {\n // implemented in symtab.c\n func funcline_go(*Func, uintptr) (string, int)\n \n+// A gccgo specific hook to use debug info to get file/line info.\n+func RegisterDebugLookup(func(pc uintptr, function *string, file *string, line *int) bool,\n+\tfunc(sym string, val *uintptr) bool)\n+\n // mid returns the current os thread (m) id.\n func mid() uint32\n "}, {"sha": "87f17d2db1243fee8ae9d85ba3c391f82aa1bb58", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -11,6 +11,7 @@ package pprof\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"io\"\n \t\"runtime\""}, {"sha": "7072262a91d0bed897484f31337f78e52f47b52c", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -79,6 +79,7 @@\n package testing\n \n import (\n+\t_ \"debug/elf\"\n \t\"flag\"\n \t\"fmt\"\n \t\"os\""}, {"sha": "f2bebeba5192eb46aa601369a9a26bb11a4b7d83", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 110, "deletions": 15, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -8,8 +8,64 @@\n \n #include <stdint.h>\n \n+#include \"runtime.h\"\n #include \"go-string.h\"\n \n+/* Get the function name, file name, and line number for a PC value.\n+   We use the DWARF debug information to get this.  Rather than write\n+   a whole new library in C, we use the existing Go library.\n+   Unfortunately, the Go library is only available if the debug/elf\n+   package is imported (we use debug/elf for both ELF and Mach-O, in\n+   this case).  We arrange for the debug/elf package to register\n+   itself, and tweak the various packages that need this information\n+   to import debug/elf where possible.  */\n+\n+/* The function that returns function/file/line information.  */\n+\n+typedef _Bool (*infofn_type) (uintptr_t, struct __go_string *,\n+\t\t\t      struct __go_string *, int *);\n+static infofn_type infofn;\n+\n+/* The function that returns the value of a symbol, used to get the\n+   entry address of a function.  */\n+\n+typedef _Bool (*symvalfn_type) (struct __go_string, uintptr_t *);\n+static symvalfn_type symvalfn;\n+\n+/* This is called by debug/elf to register the function that returns\n+   function/file/line information.  */\n+\n+void RegisterDebugLookup (infofn_type, symvalfn_type)\n+  __asm__ (\"libgo_runtime.runtime.RegisterDebugLookup\");\n+\n+void\n+RegisterDebugLookup (infofn_type pi, symvalfn_type ps)\n+{\n+  infofn = pi;\n+  symvalfn = ps;\n+}\n+\n+/* Return function/file/line information for PC.  */\n+\n+_Bool\n+__go_file_line (uintptr_t pc, struct __go_string *fn, struct __go_string *file,\n+\t\tint *line)\n+{\n+  if (infofn == NULL)\n+    return 0;\n+  return infofn (pc, fn, file, line);\n+}\n+\n+/* Return the value of a symbol.  */\n+\n+_Bool\n+__go_symbol_value (struct __go_string sym, uintptr_t *val)\n+{\n+  if (symvalfn == NULL)\n+    return 0;\n+  return symvalfn (sym, val);\n+}\n+\n /* The values returned by runtime.Caller.  */\n \n struct caller_ret\n@@ -20,32 +76,71 @@ struct caller_ret\n   _Bool ok;\n };\n \n-/* Implement runtime.Caller.  */\n-\n struct caller_ret Caller (int n) asm (\"libgo_runtime.runtime.Caller\");\n \n+Func *FuncForPC (uintptr_t) asm (\"libgo_runtime.runtime.FuncForPC\");\n+\n+/* Implement runtime.Caller.  */\n+\n struct caller_ret\n-Caller (int n __attribute__ ((unused)))\n+Caller (int skip)\n {\n   struct caller_ret ret;\n+  uintptr pc;\n+  int32 n;\n+  struct __go_string fn;\n \n-  /* A proper implementation needs to dig through the debugging\n-     information.  */\n-  ret.pc = (uint64_t) (uintptr_t) __builtin_return_address (0);\n-  ret.file.__data = NULL;\n-  ret.file.__length = 0;\n-  ret.line = 0;\n-  ret.ok = 0;\n-\n+  runtime_memclr (&ret, sizeof ret);\n+  n = runtime_callers (skip + 1, &pc, 1);\n+  if (n < 1)\n+    return ret;\n+  ret.pc = pc;\n+  ret.ok = __go_file_line (pc, &fn, &ret.file, &ret.line);\n   return ret;\n }\n \n /* Implement runtime.FuncForPC.  */\n \n-void *FuncForPC (uintptr_t) asm (\"libgo_runtime.runtime.FuncForPC\");\n+Func *\n+FuncForPC (uintptr_t pc)\n+{\n+  Func *ret;\n+  struct __go_string fn;\n+  struct __go_string file;\n+  int line;\n+  uintptr_t val;\n \n-void *\n-FuncForPC(uintptr_t pc __attribute__ ((unused)))\n+  if (!__go_file_line (pc, &fn, &file, &line))\n+    return NULL;\n+  if (!__go_symbol_value (fn, &val))\n+    return NULL;\n+\n+  ret = (Func *) runtime_malloc (sizeof (*ret));\n+  ret->name = fn;\n+  ret->entry = val;\n+  return ret;\n+}\n+\n+/* Look up the file and line information for a PC within a\n+   function.  */\n+\n+struct funcline_go_return\n {\n-  return NULL;\n+  struct __go_string retfile;\n+  int retline;\n+};\n+\n+struct funcline_go_return\n+runtime_funcline_go (Func *f, uintptr targetpc)\n+  __asm__ (\"libgo_runtime.runtime.funcline_go\");\n+\n+struct funcline_go_return\n+runtime_funcline_go (Func *f __attribute__((unused)), uintptr targetpc)\n+{\n+  struct funcline_go_return ret;\n+  struct __go_string fn;\n+\n+  if (!__go_file_line (targetpc, &fn, &ret.retfile,  &ret.retline))\n+    runtime_memclr (&ret, sizeof ret);\n+  return ret;\n }"}, {"sha": "09556c33c7ac8c1f266deb6d7f8755d4978512ac", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -25,8 +25,13 @@ backtrace (struct _Unwind_Context *context, void *varg)\n {\n   struct callers_data *arg = (struct callers_data *) varg;\n   uintptr pc;\n+  int ip_before_insn = 0;\n \n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n   pc = _Unwind_GetIP (context);\n+#endif\n \n   /* FIXME: If PC is in the __morestack routine, we should ignore\n      it.  */\n@@ -37,6 +42,11 @@ backtrace (struct _Unwind_Context *context, void *varg)\n     return _URC_END_OF_STACK;\n   else\n     {\n+      /* Here PC will be the return address.  We actually want the\n+\t address of the call instruction, so back up one byte and\n+\t count on the lookup routines handling that correctly.  */\n+      if (!ip_before_insn)\n+\t--pc;\n       arg->pcbuf[arg->index] = pc;\n       ++arg->index;\n     }\n@@ -48,7 +58,7 @@ runtime_callers (int32 skip, uintptr *pcbuf, int32 m)\n {\n   struct callers_data arg;\n \n-  arg.skip = skip;\n+  arg.skip = skip + 1;\n   arg.pcbuf = pcbuf;\n   arg.index = 0;\n   arg.max = m;"}, {"sha": "c61c65ccee3551abb633b5bb567bc79a9123ea9b", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -225,11 +225,7 @@ runtime_MProf_Malloc(void *p, uintptr size)\n \t\treturn;\n \n \tm->nomemprof++;\n-#if 0\n \tnstk = runtime_callers(1, stk, 32);\n-#else\n-\tnstk = 0;\n-#endif\n \truntime_lock(&proflock);\n \tb = stkbucket(stk, nstk, true);\n \tb->recent_allocs++;"}, {"sha": "d1ce26db49991c01b2e9ac17074e6d03aa230940", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -211,22 +211,3 @@ runtime_cputicks(void)\n   return 0;\n #endif\n }\n-\n-struct funcline_go_return\n-{\n-  String retfile;\n-  int32 retline;\n-};\n-\n-struct funcline_go_return\n-runtime_funcline_go(void *f, uintptr targetpc)\n-  __asm__(\"libgo_runtime.runtime.funcline_go\");\n-\n-struct funcline_go_return\n-runtime_funcline_go(void *f __attribute__((unused)),\n-\t\t    uintptr targetpc __attribute__((unused)))\n-{\n-  struct funcline_go_return ret;\n-  runtime_memclr(&ret, sizeof ret);\n-  return ret;\n-}"}, {"sha": "e012e1833bb2b210998e5a66f90a22a3bb125f51", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0effc3f961337abd0edb7c1a3dcd4b98636c085c/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=0effc3f961337abd0edb7c1a3dcd4b98636c085c", "patch": "@@ -48,6 +48,7 @@ typedef unsigned int uintptr __attribute__ ((mode (pointer)));\n \n typedef\tuint8\t\t\tbool;\n typedef\tuint8\t\t\tbyte;\n+typedef\tstruct\tFunc\t\tFunc;\n typedef\tstruct\tG\t\tG;\n typedef\tunion\tLock\t\tLock;\n typedef\tstruct\tM\t\tM;\n@@ -201,6 +202,14 @@ enum\n #define NSIG 32\n #endif\n \n+// NOTE(rsc): keep in sync with extern.go:/type.Func.\n+// Eventually, the loaded symbol table should be closer to this form.\n+struct\tFunc\n+{\n+\tString\tname;\n+\tuintptr\tentry;\t// entry pc\n+};\n+\n /* Macros.  */\n \n #ifdef GOOS_windows"}]}