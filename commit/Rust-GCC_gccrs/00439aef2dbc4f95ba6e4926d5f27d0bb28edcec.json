{"sha": "00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0MzlhZWYyZGJjNGY5NWJhNmU0OTI2ZDVmMjdkMGJiMjhlZGNlYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-12-06T21:03:33Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-12-06T21:03:33Z"}, "message": "print_rtx: implement support for reuse IDs (v2)\n\ngcc/ChangeLog:\n\t* config/i386/i386.c: Include print-rtl.h.\n\t(selftest::ix86_test_dumping_memory_blockage): New function.\n\t(selftest::ix86_run_selftests): Call it.\n\t* print-rtl-function.c (print_rtx_function): Create an\n\trtx_reuse_manager and use it.\n\t* print-rtl.c: Include \"rtl-iter.h\".\n\t(rtx_writer::rtx_writer): Add reuse_manager param.\n\t(rtx_reuse_manager::rtx_reuse_manager): New ctor.\n\t(uses_rtx_reuse_p): New function.\n\t(rtx_reuse_manager::preprocess): New function.\n\t(rtx_reuse_manager::has_reuse_id): New function.\n\t(rtx_reuse_manager::seen_def_p): New function.\n\t(rtx_reuse_manager::set_seen_def): New function.\n\t(rtx_writer::print_rtx): If \"in_rtx\" has a reuse ID, print it as a\n\tprefix the first time in_rtx is seen, and print reuse_rtx\n\tsubsequently.\n\t(print_inline_rtx): Supply NULL for new reuse_manager param.\n\t(debug_rtx): Likewise.\n\t(print_rtl): Likewise.\n\t(print_rtl_single): Likewise.\n\t(rtx_writer::print_rtl_single_with_indent): Likewise.\n\t* print-rtl.h: Include bitmap.h when building for host.\n\t(rtx_writer::rtx_writer): Add reuse_manager param.\n\t(rtx_writer::m_rtx_reuse_manager): New field.\n\t(class rtx_reuse_manager): New class.\n\t* rtl-tests.c (selftest::assert_rtl_dump_eq): Add reuse_manager\n\tparam and use it when constructing rtx_writer.\n\t(selftest::test_dumping_rtx_reuse): New function.\n\t(selftest::rtl_tests_c_tests): Call it.\n\t* selftest-rtl.h (class rtx_reuse_manager): New forward decl.\n\t(selftest::assert_rtl_dump_eq): Add reuse_manager param.\n\t(ASSERT_RTL_DUMP_EQ): Supply NULL for reuse_manager param.\n\t(ASSERT_RTL_DUMP_EQ_WITH_REUSE): New macro.\n\nFrom-SVN: r243317", "tree": {"sha": "6b5d45747cd0e0cd9296318d0fa03ac636f2b7d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5d45747cd0e0cd9296318d0fa03ac636f2b7d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a38b8b940299eeceb51652bc070834809bb126e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a38b8b940299eeceb51652bc070834809bb126e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a38b8b940299eeceb51652bc070834809bb126e"}], "stats": {"total": 353, "additions": 336, "deletions": 17}, "files": [{"sha": "85916c155759a99342222b3f77a5602a9a8c0e14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -1,3 +1,39 @@\n+2016-12-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* config/i386/i386.c: Include print-rtl.h.\n+\t(selftest::ix86_test_dumping_memory_blockage): New function.\n+\t(selftest::ix86_run_selftests): Call it.\n+\t* print-rtl-function.c (print_rtx_function): Create an\n+\trtx_reuse_manager and use it.\n+\t* print-rtl.c: Include \"rtl-iter.h\".\n+\t(rtx_writer::rtx_writer): Add reuse_manager param.\n+\t(rtx_reuse_manager::rtx_reuse_manager): New ctor.\n+\t(uses_rtx_reuse_p): New function.\n+\t(rtx_reuse_manager::preprocess): New function.\n+\t(rtx_reuse_manager::has_reuse_id): New function.\n+\t(rtx_reuse_manager::seen_def_p): New function.\n+\t(rtx_reuse_manager::set_seen_def): New function.\n+\t(rtx_writer::print_rtx): If \"in_rtx\" has a reuse ID, print it as a\n+\tprefix the first time in_rtx is seen, and print reuse_rtx\n+\tsubsequently.\n+\t(print_inline_rtx): Supply NULL for new reuse_manager param.\n+\t(debug_rtx): Likewise.\n+\t(print_rtl): Likewise.\n+\t(print_rtl_single): Likewise.\n+\t(rtx_writer::print_rtl_single_with_indent): Likewise.\n+\t* print-rtl.h: Include bitmap.h when building for host.\n+\t(rtx_writer::rtx_writer): Add reuse_manager param.\n+\t(rtx_writer::m_rtx_reuse_manager): New field.\n+\t(class rtx_reuse_manager): New class.\n+\t* rtl-tests.c (selftest::assert_rtl_dump_eq): Add reuse_manager\n+\tparam and use it when constructing rtx_writer.\n+\t(selftest::test_dumping_rtx_reuse): New function.\n+\t(selftest::rtl_tests_c_tests): Call it.\n+\t* selftest-rtl.h (class rtx_reuse_manager): New forward decl.\n+\t(selftest::assert_rtl_dump_eq): Add reuse_manager param.\n+\t(ASSERT_RTL_DUMP_EQ): Supply NULL for reuse_manager param.\n+\t(ASSERT_RTL_DUMP_EQ_WITH_REUSE): New macro.\n+\n 2016-12-06  Vladimir Makarov  <vmakarov@redhat.com>\n \n \ttarget/77761"}, {"sha": "2e6be02c53f00bf3188707e5eea62017442119d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssanames.h\"\n #include \"selftest.h\"\n #include \"selftest-rtl.h\"\n+#include \"print-rtl.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -51175,12 +51176,35 @@ ix86_test_dumping_hard_regs ()\n   ASSERT_RTL_DUMP_EQ (\"(reg:SI dx)\", gen_raw_REG (SImode, 1));\n }\n \n+/* Test dumping an insn with repeated references to the same SCRATCH,\n+   to verify the rtx_reuse code.  */\n+\n+static void\n+ix86_test_dumping_memory_blockage ()\n+{\n+  set_new_first_and_last_insn (NULL, NULL);\n+\n+  rtx pat = gen_memory_blockage ();\n+  rtx_reuse_manager r;\n+  r.preprocess (pat);\n+\n+  /* Verify that the repeated references to the SCRATCH show use\n+     reuse IDS.  The first should be prefixed with a reuse ID,\n+     and the second should be dumped as a \"reuse_rtx\" of that ID.  */\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE\n+    (\"(cinsn 1 (set (mem/v:BLK (0|scratch:DI) [0  A8])\\n\"\n+     \"        (unspec:BLK [\\n\"\n+     \"                (mem/v:BLK (reuse_rtx 0) [0  A8])\\n\"\n+     \"            ] UNSPEC_MEMORY_BLOCKAGE)))\\n\", pat, &r);\n+}\n+\n /* Run all target-specific selftests.  */\n \n static void\n ix86_run_selftests (void)\n {\n   ix86_test_dumping_hard_regs ();\n+  ix86_test_dumping_memory_blockage ();\n }\n \n } // namespace selftest"}, {"sha": "dea84fe02ebbf590a488f63d7fc9e1ab6fae4e3f", "filename": "gcc/print-rtl-function.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fprint-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fprint-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl-function.c?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -221,7 +221,12 @@ print_param (FILE *outfile, rtx_writer &w, tree arg)\n DEBUG_FUNCTION void\n print_rtx_function (FILE *outfile, function *fn, bool compact)\n {\n-  rtx_writer w (outfile, 0, false, compact);\n+  rtx_reuse_manager r;\n+  rtx_writer w (outfile, 0, false, compact, &r);\n+\n+  /* Support \"reuse_rtx\" in the dump.  */\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    r.preprocess (insn);\n \n   tree fdecl = fn->decl;\n "}, {"sha": "3bbd395c5b49b2f711bd084553e5a4b079e57f0e", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 128, "deletions": 11, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #include \"print-rtl.h\"\n+#include \"rtl-iter.h\"\n \n /* String printed at beginning of each RTL when it is dumped.\n    This string is set to ASM_COMMENT_START when the RTL is dumped in\n@@ -74,12 +75,102 @@ int flag_dump_unnumbered_links = 0;\n \n /* Constructor for rtx_writer.  */\n \n-rtx_writer::rtx_writer (FILE *outf, int ind, bool simple, bool compact)\n+rtx_writer::rtx_writer (FILE *outf, int ind, bool simple, bool compact,\n+\t\t\trtx_reuse_manager *reuse_manager)\n : m_outfile (outf), m_sawclose (0), m_indent (ind),\n-  m_in_call_function_usage (false), m_simple (simple), m_compact (compact)\n+  m_in_call_function_usage (false), m_simple (simple), m_compact (compact),\n+  m_rtx_reuse_manager (reuse_manager)\n {\n }\n \n+#ifndef GENERATOR_FILE\n+\n+/* rtx_reuse_manager's ctor.  */\n+\n+rtx_reuse_manager::rtx_reuse_manager ()\n+: m_next_id (0)\n+{\n+  bitmap_initialize (&m_defs_seen, NULL);\n+}\n+\n+/* Determine if X is of a kind suitable for dumping via reuse_rtx.  */\n+\n+static bool\n+uses_rtx_reuse_p (const_rtx x)\n+{\n+  if (x == NULL)\n+    return false;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case DEBUG_EXPR:\n+    case VALUE:\n+    case SCRATCH:\n+      return true;\n+\n+    /* We don't use reuse_rtx for consts.  */\n+    CASE_CONST_UNIQUE:\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Traverse X and its descendents, determining if we see any rtx more than\n+   once.  Any rtx suitable for \"reuse_rtx\" that is seen more than once is\n+   assigned an ID.  */\n+\n+void\n+rtx_reuse_manager::preprocess (const_rtx x)\n+{\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, x, NONCONST)\n+    if (uses_rtx_reuse_p (*iter))\n+      {\n+\tif (int *count = m_rtx_occurrence_count.get (*iter))\n+\t  {\n+\t    if (*(count++) == 1)\n+\t      m_rtx_reuse_ids.put (*iter, m_next_id++);\n+\t  }\n+\telse\n+\t  m_rtx_occurrence_count.put (*iter, 1);\n+      }\n+}\n+\n+/* Return true iff X has been assigned a reuse ID.  If it has,\n+   and OUT is non-NULL, then write the reuse ID to *OUT.  */\n+\n+bool\n+rtx_reuse_manager::has_reuse_id (const_rtx x, int *out)\n+{\n+  int *id = m_rtx_reuse_ids.get (x);\n+  if (id)\n+    {\n+      if (out)\n+\t*out = *id;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Determine if set_seen_def has been called for the given reuse ID.  */\n+\n+bool\n+rtx_reuse_manager::seen_def_p (int reuse_id)\n+{\n+  return bitmap_bit_p (&m_defs_seen, reuse_id);\n+}\n+\n+/* Record that the definition of the given reuse ID has been seen.  */\n+\n+void\n+rtx_reuse_manager::set_seen_def (int reuse_id)\n+{\n+  bitmap_set_bit (&m_defs_seen, reuse_id);\n+}\n+\n+#endif /* #ifndef GENERATOR_FILE */\n+\n #ifndef GENERATOR_FILE\n void\n print_mem_expr (FILE *outfile, const_tree expr)\n@@ -631,8 +722,34 @@ rtx_writer::print_rtx (const_rtx in_rtx)\n        return;\n     }\n \n+  fputc ('(', m_outfile);\n+\n   /* Print name of expression code.  */\n \n+  /* Handle reuse.  */\n+#ifndef GENERATOR_FILE\n+  if (m_rtx_reuse_manager)\n+    {\n+      int reuse_id;\n+      if (m_rtx_reuse_manager->has_reuse_id (in_rtx, &reuse_id))\n+\t{\n+\t  /* Have we already seen the defn of this rtx?  */\n+\t  if (m_rtx_reuse_manager->seen_def_p (reuse_id))\n+\t    {\n+\t      fprintf (m_outfile, \"reuse_rtx %i)\", reuse_id);\n+\t      m_sawclose = 1;\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* First time we've seen this reused-rtx.  */\n+\t      fprintf (m_outfile, \"%i|\", reuse_id);\n+\t      m_rtx_reuse_manager->set_seen_def (reuse_id);\n+\t    }\n+\t}\n+    }\n+#endif /* #ifndef GENERATOR_FILE */\n+\n   /* In compact mode, prefix the code of insns with \"c\",\n      giving \"cinsn\", \"cnote\" etc.  */\n   if (m_compact && is_a <const rtx_insn *, const struct rtx_def> (in_rtx))\n@@ -641,14 +758,14 @@ rtx_writer::print_rtx (const_rtx in_rtx)\n \t just \"clabel\".  */\n       rtx_code code = GET_CODE (in_rtx);\n       if (code == CODE_LABEL)\n-\tfprintf (m_outfile, \"(clabel\");\n+\tfprintf (m_outfile, \"clabel\");\n       else\n-\tfprintf (m_outfile, \"(c%s\", GET_RTX_NAME (code));\n+\tfprintf (m_outfile, \"c%s\", GET_RTX_NAME (code));\n     }\n   else if (m_simple && CONST_INT_P (in_rtx))\n-    fputc ('(', m_outfile);\n+    ; /* no code.  */\n   else\n-    fprintf (m_outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n+    fprintf (m_outfile, \"%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n \n   if (! m_simple)\n     {\n@@ -819,7 +936,7 @@ rtx_writer::finish_directive ()\n void\n print_inline_rtx (FILE *outf, const_rtx x, int ind)\n {\n-  rtx_writer w (outf, ind, false, false);\n+  rtx_writer w (outf, ind, false, false, NULL);\n   w.print_rtx (x);\n }\n \n@@ -828,7 +945,7 @@ print_inline_rtx (FILE *outf, const_rtx x, int ind)\n DEBUG_FUNCTION void\n debug_rtx (const_rtx x)\n {\n-  rtx_writer w (stderr, 0, false, false);\n+  rtx_writer w (stderr, 0, false, false, NULL);\n   w.print_rtx (x);\n   fprintf (stderr, \"\\n\");\n }\n@@ -975,7 +1092,7 @@ rtx_writer::print_rtl (const_rtx rtx_first)\n void\n print_rtl (FILE *outf, const_rtx rtx_first)\n {\n-  rtx_writer w (outf, 0, false, false);\n+  rtx_writer w (outf, 0, false, false, NULL);\n   w.print_rtl (rtx_first);\n }\n \n@@ -985,7 +1102,7 @@ print_rtl (FILE *outf, const_rtx rtx_first)\n int\n print_rtl_single (FILE *outf, const_rtx x)\n {\n-  rtx_writer w (outf, 0, false, false);\n+  rtx_writer w (outf, 0, false, false, NULL);\n   return w.print_rtl_single_with_indent (x, 0);\n }\n \n@@ -1016,7 +1133,7 @@ rtx_writer::print_rtl_single_with_indent (const_rtx x, int ind)\n void\n print_simple_rtl (FILE *outf, const_rtx x)\n {\n-  rtx_writer w (outf, 0, true, false);\n+  rtx_writer w (outf, 0, true, false, NULL);\n   w.print_rtl (x);\n }\n "}, {"sha": "5f7cefb870441c455142429c4ee243862d264325", "filename": "gcc/print-rtl.h", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fprint-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fprint-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.h?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -20,12 +20,19 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_PRINT_RTL_H\n #define GCC_PRINT_RTL_H\n \n+#ifndef GENERATOR_FILE\n+#include \"bitmap.h\"\n+#endif /* #ifndef GENERATOR_FILE */\n+\n+class rtx_reuse_manager;\n+\n /* A class for writing rtx to a FILE *.  */\n \n class rtx_writer\n {\n  public:\n-  rtx_writer (FILE *outfile, int ind, bool simple, bool compact);\n+  rtx_writer (FILE *outfile, int ind, bool simple, bool compact,\n+\t      rtx_reuse_manager *reuse_manager);\n \n   void print_rtx (const_rtx in_rtx);\n   void print_rtl (const_rtx rtx_first);\n@@ -60,6 +67,9 @@ class rtx_writer\n        printed with a '%' sigil e.g. \"%0\" for (LAST_VIRTUAL_REGISTER + 1),\n      - insn names are prefixed with \"c\" (e.g. \"cinsn\", \"cnote\", etc).  */\n   bool m_compact;\n+\n+  /* An optional instance of rtx_reuse_manager.  */\n+  rtx_reuse_manager *m_rtx_reuse_manager;\n };\n \n #ifdef BUFSIZ\n@@ -80,4 +90,73 @@ extern const char *str_pattern_slim (const_rtx);\n \n extern void print_rtx_function (FILE *file, function *fn, bool compact);\n \n+#ifndef GENERATOR_FILE\n+\n+/* For some rtx codes (such as SCRATCH), instances are defined to only be\n+   equal for pointer equality: two distinct SCRATCH instances are non-equal.\n+   copy_rtx preserves this equality by reusing the SCRATCH instance.\n+\n+   For example, in this x86 instruction:\n+\n+      (cinsn (set (mem/v:BLK (scratch:DI) [0  A8])\n+                    (unspec:BLK [\n+                            (mem/v:BLK (scratch:DI) [0  A8])\n+                        ] UNSPEC_MEMORY_BLOCKAGE)) \"test.c\":2\n+                 (nil))\n+\n+   the two instances of \"(scratch:DI)\" are actually the same underlying\n+   rtx pointer (and thus \"equal\"), and the insn will only be recognized\n+   (as \"*memory_blockage\") if this pointer-equality is preserved.\n+\n+   To be able to preserve this pointer-equality when round-tripping\n+   through dumping/loading the rtl, we need some syntax.  The first\n+   time a reused rtx is encountered in the dump, we prefix it with\n+   a reuse ID:\n+\n+      (0|scratch:DI)\n+\n+   Subsequent references to the rtx in the dump can be expressed using\n+   \"reuse_rtx\" e.g.:\n+\n+      (reuse_rtx 0)\n+\n+   This class is responsible for tracking a set of reuse IDs during a dump.\n+\n+   Dumping with reuse-support is done in two passes:\n+\n+   (a) a first pass in which \"preprocess\" is called on each top-level rtx\n+       to be seen in the dump.  This traverses the rtx and its descendents,\n+       identifying rtx that will be seen more than once in the actual dump,\n+       and assigning them reuse IDs.\n+\n+   (b) the actual dump, via print_rtx etc.  print_rtx detect the presence\n+       of a live rtx_reuse_manager and uses it if there is one.  Any rtx\n+       that were assigned reuse IDs will be printed with it the first time\n+       that they are seen, and then printed as \"(reuse_rtx ID)\" subsequently.\n+\n+   The first phase is needed since otherwise there would be no way to tell\n+   if an rtx will be reused when first encountering it.  */\n+\n+class rtx_reuse_manager\n+{\n+ public:\n+  rtx_reuse_manager ();\n+\n+  /* The first pass.  */\n+  void preprocess (const_rtx x);\n+\n+  /* The second pass (within print_rtx).  */\n+  bool has_reuse_id (const_rtx x, int *out);\n+  bool seen_def_p (int reuse_id);\n+  void set_seen_def (int reuse_id);\n+\n+ private:\n+  hash_map<const_rtx, int> m_rtx_occurrence_count;\n+  hash_map<const_rtx, int> m_rtx_reuse_ids;\n+  bitmap_head m_defs_seen;\n+  int m_next_id;\n+};\n+\n+#endif /* #ifndef GENERATOR_FILE */\n+\n #endif  // GCC_PRINT_RTL_H"}, {"sha": "8edddfbca86a9456e9f91517cf05d43b7a285344", "filename": "gcc/rtl-tests.c", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Frtl-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Frtl-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-tests.c?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -62,11 +62,12 @@ verify_print_pattern (const char *expected, rtx pat)\n    Use LOC as the effective location when reporting errors.  */\n \n void\n-assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x)\n+assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x,\n+\t\t    rtx_reuse_manager *reuse_manager)\n {\n   named_temp_file tmp_out (\".rtl\");\n   FILE *outfile = fopen (tmp_out.get_filename (), \"w\");\n-  rtx_writer w (outfile, 0, false, true);\n+  rtx_writer w (outfile, 0, false, true, reuse_manager);\n   w.print_rtl (x);\n   fclose (outfile);\n \n@@ -128,6 +129,53 @@ test_dumping_insns ()\n   ASSERT_RTL_DUMP_EQ (\"(clabel 0 42 (\\\"some_label\\\"))\\n\", label);\n }\n \n+/* Manually exercise the rtx_reuse_manager code.  */\n+\n+static void\n+test_dumping_rtx_reuse ()\n+{\n+  rtx_reuse_manager r;\n+\n+  rtx x = rtx_alloc (SCRATCH);\n+  rtx y = rtx_alloc (SCRATCH);\n+  rtx z = rtx_alloc (SCRATCH);\n+\n+  /* x and y will be seen more than once.  */\n+  r.preprocess (x);\n+  r.preprocess (x);\n+  r.preprocess (y);\n+  r.preprocess (y);\n+\n+  /* z will be only seen once.  */\n+  r.preprocess (z);\n+\n+  /* Verify that x and y have been assigned reuse IDs.  */\n+  int reuse_id_for_x;\n+  ASSERT_TRUE (r.has_reuse_id (x, &reuse_id_for_x));\n+  ASSERT_EQ (0, reuse_id_for_x);\n+\n+  int reuse_id_for_y;\n+  ASSERT_TRUE (r.has_reuse_id (y, &reuse_id_for_y));\n+  ASSERT_EQ (1, reuse_id_for_y);\n+\n+  /* z is only seen once and thus shouldn't get a reuse ID.  */\n+  ASSERT_FALSE (r.has_reuse_id (z, NULL));\n+\n+  /* The first dumps of x and y should be prefixed by reuse ID;\n+     all subsequent dumps of them should show up as \"reuse_rtx\".  */\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(0|scratch)\", x, &r);\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(reuse_rtx 0)\", x, &r);\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(reuse_rtx 0)\", x, &r);\n+\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(1|scratch)\", y, &r);\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(reuse_rtx 1)\", y, &r);\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(reuse_rtx 1)\", y, &r);\n+\n+  /* z only appears once and thus shouldn't be prefixed with a\n+     reuse ID.  */\n+  ASSERT_RTL_DUMP_EQ_WITH_REUSE (\"(scratch)\", z, &r);\n+}\n+\n /* Unit testing of \"single_set\".  */\n \n static void\n@@ -187,6 +235,7 @@ rtl_tests_c_tests ()\n {\n   test_dumping_regs ();\n   test_dumping_insns ();\n+  test_dumping_rtx_reuse ();\n   test_single_set ();\n   test_uncond_jump ();\n "}, {"sha": "f50501819e88f9b14bb4cfc7a8834b799111d526", "filename": "gcc/selftest-rtl.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fselftest-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00439aef2dbc4f95ba6e4926d5f27d0bb28edcec/gcc%2Fselftest-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-rtl.h?ref=00439aef2dbc4f95ba6e4926d5f27d0bb28edcec", "patch": "@@ -25,18 +25,27 @@ along with GCC; see the file COPYING3.  If not see\n \n #if CHECKING_P\n \n+class rtx_reuse_manager;\n+\n namespace selftest {\n \n /* Verify that X is dumped as EXPECTED_DUMP, using compact mode.\n    Use LOC as the effective location when reporting errors.  */\n \n extern void\n-assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x);\n+assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x,\n+\t\t    rtx_reuse_manager *reuse_manager);\n \n /* Verify that RTX is dumped as EXPECTED_DUMP, using compact mode.  */\n \n #define ASSERT_RTL_DUMP_EQ(EXPECTED_DUMP, RTX) \\\n-  assert_rtl_dump_eq (SELFTEST_LOCATION, (EXPECTED_DUMP), (RTX))\n+  assert_rtl_dump_eq (SELFTEST_LOCATION, (EXPECTED_DUMP), (RTX), NULL)\n+\n+/* As above, but using REUSE_MANAGER when dumping.  */\n+\n+#define ASSERT_RTL_DUMP_EQ_WITH_REUSE(EXPECTED_DUMP, RTX, REUSE_MANAGER) \\\n+  assert_rtl_dump_eq (SELFTEST_LOCATION, (EXPECTED_DUMP), (RTX), \\\n+\t\t      (REUSE_MANAGER))\n \n } /* end of namespace selftest.  */\n "}]}