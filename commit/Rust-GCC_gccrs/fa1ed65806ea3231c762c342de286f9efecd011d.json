{"sha": "fa1ed65806ea3231c762c342de286f9efecd011d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmExZWQ2NTgwNmVhMzIzMWM3NjJjMzQyZGUyODZmOWVmZWNkMDExZA==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-11-06T10:15:42Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-11-06T10:15:42Z"}, "message": "re PR fortran/54917 ([OOP] TRANSFER on polymorphic variable causes ICE)\n\n2012-11-06  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/54917\n\t* target-memory.c (gfc_target_expr_size,gfc_target_interpret_expr):\n\tHandle BT_CLASS.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_transfer): Add support for\n\tpolymorphic arguments.\n\n2012-11-06  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/54917\n\t* gfortran.dg/transfer_class_1.f90: New.\n\t* gfortran.dg/transfer_class_2.f90: New.\n\nFrom-SVN: r193226", "tree": {"sha": "b26083b0efe29026a710c5dc51c38186134c4d9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b26083b0efe29026a710c5dc51c38186134c4d9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa1ed65806ea3231c762c342de286f9efecd011d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1ed65806ea3231c762c342de286f9efecd011d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1ed65806ea3231c762c342de286f9efecd011d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1ed65806ea3231c762c342de286f9efecd011d/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b887f1a033ac9c5daae593722a985e3dc79457c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b887f1a033ac9c5daae593722a985e3dc79457c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b887f1a033ac9c5daae593722a985e3dc79457c7"}], "stats": {"total": 156, "additions": 139, "deletions": 17}, "files": [{"sha": "f33dffb0f647cc710bc94c7a5aa456914683b5ba", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fa1ed65806ea3231c762c342de286f9efecd011d", "patch": "@@ -1,3 +1,11 @@\n+2012-11-06  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/54917\n+\t* target-memory.c (gfc_target_expr_size,gfc_target_interpret_expr):\n+\tHandle BT_CLASS.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_transfer): Add support for\n+\tpolymorphic arguments.\n+\n 2012-11-04  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/55199"}, {"sha": "437a3df8304027ec46f28833eb4b0834f8dfe5b0", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=fa1ed65806ea3231c762c342de286f9efecd011d", "patch": "@@ -121,6 +121,7 @@ gfc_target_expr_size (gfc_expr *e)\n     case BT_HOLLERITH:\n       return e->representation.length;\n     case BT_DERIVED:\n+    case BT_CLASS:\n       {\n \t/* Determine type size without clobbering the typespec for ISO C\n \t   binding types.  */\n@@ -572,6 +573,9 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n         gfc_interpret_character (buffer, buffer_size, result);\n       break;\n \n+    case BT_CLASS:\n+      result->ts = CLASS_DATA (result)->ts;\n+      /* Fall through.  */\n     case BT_DERIVED:\n       result->representation.length = \n         gfc_interpret_derived (buffer, buffer_size, result);"}, {"sha": "b101cb4672853397bcc2daa7f2a74eef90d746eb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=fa1ed65806ea3231c762c342de286f9efecd011d", "patch": "@@ -5348,6 +5348,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   stmtblock_t block;\n   int n;\n   bool scalar_mold;\n+  gfc_expr *source_expr, *mold_expr;\n \n   info = NULL;\n   if (se->loop)\n@@ -5357,6 +5358,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \tsource_bytes = length of the source in bytes\n \tsource = pointer to the source data.  */\n   arg = expr->value.function.actual;\n+  source_expr = arg->expr;\n \n   /* Ensure double transfer through LOGICAL preserves all\n      the needed bits.  */\n@@ -5376,18 +5378,28 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   if (arg->expr->rank == 0)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n-      source = argse.expr;\n-\n-      source_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t\targse.expr));\n+      if (arg->expr->ts.type == BT_CLASS)\n+\tsource = gfc_class_data_get (argse.expr);\n+      else\n+\tsource = argse.expr;\n \n       /* Obtain the source word length.  */\n-      if (arg->expr->ts.type == BT_CHARACTER)\n-\ttmp = size_of_string_in_bytes (arg->expr->ts.kind,\n-\t\t\t\t       argse.string_length);\n-      else\n-\ttmp = fold_convert (gfc_array_index_type,\n-\t\t\t    size_in_bytes (source_type)); \n+      switch (arg->expr->ts.type)\n+\t{\n+\tcase BT_CHARACTER:\n+\t  tmp = size_of_string_in_bytes (arg->expr->ts.kind,\n+\t\t\t\t\t argse.string_length);\n+\t  break;\n+\tcase BT_CLASS:\n+\t  tmp = gfc_vtable_size_get (argse.expr);\n+\t  break;\n+\tdefault:\n+\t  source_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t\tsource));\n+\t  tmp = fold_convert (gfc_array_index_type,\n+\t\t\t      size_in_bytes (source_type));\n+\t  break;\n+\t}\n     }\n   else\n     {\n@@ -5464,6 +5476,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \tmold_type = the TREE type of MOLD\n \tdest_word_len = destination word length in bytes.  */\n   arg = arg->next;\n+  mold_expr = arg->expr;\n \n   gfc_init_se (&argse, NULL);\n \n@@ -5473,7 +5486,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n       mold_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t      argse.expr));\n+\t\t\t\t\t\t\t  argse.expr));\n     }\n   else\n     {\n@@ -5494,15 +5507,20 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \tmold_type = gfc_get_int_type (arg->expr->ts.kind);\n     }\n \n-  if (arg->expr->ts.type == BT_CHARACTER)\n+  /* Obtain the destination word length.  */\n+  switch (arg->expr->ts.type)\n     {\n+    case BT_CHARACTER:\n       tmp = size_of_string_in_bytes (arg->expr->ts.kind, argse.string_length);\n       mold_type = gfc_get_character_type_len (arg->expr->ts.kind, tmp);\n+      break;\n+    case BT_CLASS:\n+      tmp = gfc_vtable_size_get (argse.expr);\n+      break;\n+    default:\n+      tmp = fold_convert (gfc_array_index_type, size_in_bytes (mold_type));\n+      break;\n     }\n-  else\n-    tmp = fold_convert (gfc_array_index_type,\n-\t\t\tsize_in_bytes (mold_type)); \n- \n   dest_word_len = gfc_create_var (gfc_array_index_type, NULL);\n   gfc_add_modify (&se->pre, dest_word_len, tmp);\n \n@@ -5650,15 +5668,40 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n       ptr = convert (build_pointer_type (mold_type), source);\n \n+      /* For CLASS results, allocate the needed memory first.  */\n+      if (mold_expr->ts.type == BT_CLASS)\n+\t{\n+\t  tree cdata;\n+\t  cdata = gfc_class_data_get (tmpdecl);\n+\t  tmp = gfc_call_malloc (&se->pre, TREE_TYPE (cdata), dest_word_len);\n+\t  gfc_add_modify (&se->pre, cdata, tmp);\n+\t}\n+\n       /* Use memcpy to do the transfer.  */\n-      tmp = gfc_build_addr_expr (NULL_TREE, tmpdecl);\n+      if (mold_expr->ts.type == BT_CLASS)\n+\ttmp = gfc_class_data_get (tmpdecl);\n+      else\n+\ttmp = gfc_build_addr_expr (NULL_TREE, tmpdecl);\n+\n       tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n \t\t\t     fold_convert (pvoid_type_node, tmp),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n \t\t\t     extent);\n       gfc_add_expr_to_block (&se->pre, tmp);\n \n+      /* For CLASS results, set the _vptr.  */\n+      if (mold_expr->ts.type == BT_CLASS)\n+\t{\n+\t  tree vptr;\n+\t  gfc_symbol *vtab;\n+\t  vptr = gfc_class_vptr_get (tmpdecl);\n+\t  vtab = gfc_find_derived_vtab (source_expr->ts.u.derived);\n+\t  gcc_assert (vtab);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n+\t  gfc_add_modify (&se->pre, vptr, fold_convert (TREE_TYPE (vptr), tmp));\n+\t}\n+\n       se->expr = tmpdecl;\n     }\n }"}, {"sha": "c4d388dfba2897e0b76b9207104178e202db6a6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa1ed65806ea3231c762c342de286f9efecd011d", "patch": "@@ -1,3 +1,9 @@\n+2012-11-06  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/54917\n+\t* gfortran.dg/transfer_class_1.f90: New.\n+\t* gfortran.dg/transfer_class_2.f90: New.\n+\n 2012-11-05  Sriraman Tallam  <tmsriram@google.com>\n \n \t* testsuite/g++.dg/mv1.C: New test."}, {"sha": "00b3a2405f3e5f88ed83beeea35562b7ca6cfc57", "filename": "gcc/testsuite/gfortran.dg/transfer_class_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_class_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_class_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_class_1.f90?ref=fa1ed65806ea3231c762c342de286f9efecd011d", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! { dg-options \"-Wsurprising\" }\n+!\n+! PR 54917: [4.7/4.8 Regression] [OOP] TRANSFER on polymorphic variable causes ICE\n+!\n+! Contributed by Sean Santos <quantheory@gmail.com>\n+\n+subroutine test_routine1(arg)\n+  implicit none\n+  type test_type\n+    integer :: test_comp\n+  end type\n+  class(test_type) :: arg\n+  integer :: i\n+  i = transfer(arg, 1)\n+end subroutine"}, {"sha": "d75b640f10f96e1fa047cc56cc8929b6927d64f7", "filename": "gcc/testsuite/gfortran.dg/transfer_class_2.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_class_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1ed65806ea3231c762c342de286f9efecd011d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_class_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_class_2.f90?ref=fa1ed65806ea3231c762c342de286f9efecd011d", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+!\n+! PR 54917: [OOP] TRANSFER on polymorphic variable causes ICE\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+  implicit none\n+  type test_type\n+    integer :: i = 0\n+  contains\n+    procedure :: ass\n+    generic :: assignment(=) => ass\n+  end type\n+contains\n+  subroutine ass (a, b)\n+    class(test_type), intent(out) :: a\n+    class(test_type), intent(in)  :: b\n+    a%i = b%i\n+  end subroutine\n+end module\n+\n+\n+program p\n+  use m\n+  implicit none\n+\n+  class(test_type), allocatable :: c\n+  type(test_type) :: t\n+\n+  allocate(c)\n+\n+  ! (1) check CLASS-to-TYPE transfer\n+  c%i=3\n+  t = transfer(c, t)\n+  if (t%i /= 3) call abort()\n+\n+  ! (2) check TYPE-to-CLASS transfer\n+  t%i=4\n+  c = transfer(t, c)\n+  if (c%i /= 4) call abort()\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}