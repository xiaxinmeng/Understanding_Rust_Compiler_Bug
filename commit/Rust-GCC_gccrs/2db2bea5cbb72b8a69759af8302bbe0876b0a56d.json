{"sha": "2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRiMmJlYTVjYmI3MmI4YTY5NzU5YWY4MzAyYmJlMDg3NmIwYTU2ZA==", "commit": {"author": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1992-04-13T11:43:08Z"}, "committer": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1992-04-13T11:43:08Z"}, "message": "Check in after array version of run-time works.\n\nExpect more changes as hash version and other changes are made.\n\nFrom-SVN: r734", "tree": {"sha": "d73b503186e758caac86ae0e993fb692b0d92301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d73b503186e758caac86ae0e993fb692b0d92301"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/comments", "author": null, "committer": null, "parents": [{"sha": "1a5b457d5730b4f83540da3a814c5909d9ada14b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5b457d5730b4f83540da3a814c5909d9ada14b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5b457d5730b4f83540da3a814c5909d9ada14b"}], "stats": {"total": 251, "additions": 197, "deletions": 54}, "files": [{"sha": "4c095cd14b7729411223a6c55cf7da99337fbc79", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 69, "deletions": 28, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "patch": "@@ -16,10 +16,14 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.10 1991/12/10 12:05:28 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/hash/RCS/hash.c,v 0.11 1992/01/03 02:55:03 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/12/10 12:05:28 $\n+  $Date: 1992/01/03 02:55:03 $\n   $Log: hash.c,v $\n+ * Revision 0.11  1992/01/03  02:55:03  dennisg\n+ * modified to handle new initialization scheme.\n+ * fixed code structure.\n+ *\n  * Revision 0.10  1991/12/10  12:05:28  dennisg\n  * Cleaned up file format for a distribution.\n  *\n@@ -65,9 +69,9 @@\n  \n \n #include  <hash.h>\n-#include  <hash-inline.h>\n-#include  <ObjC.h>\n-#include  <ObjC-private.h>\n+#include  <objc.h>\n+#include  <objcP.h>\n+#include  <objc-protoP.h>\n \n #include  <assert.h>\n #include  <math.h>\n@@ -85,24 +89,19 @@\n #define FULLNESS(cache) \\\n    ((((cache)->sizeOfHash * 75  ) / 100) <= (cache)->entriesInHash)\n #define EXPANSION(cache) \\\n-  (((cache)->sizeOfHash * 175 ) / 100 )\n-\n-#define MEMORY_ALLOCATION_ADJUST(i) \\\n-  ((i&0x01)?i:(i-1))\n+  ((cache)->sizeOfHash * 2 )\n \n-Cache_t hash_new (u_int sizeOfHash) {\n+Cache_t \n+hash_new (u_int sizeOfHash, HashFunc aHashFunc, CompareFunc aCompareFunc) {\n \n   Cache_t retCache;\n   \n \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Pass me a value greater\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthan 0 and a power of 2. */\n   assert(sizeOfHash);\n+\tassert( !(sizeOfHash & (sizeOfHash - 1)));\n   \n-                                                /* Memory is allocated on this\n-                                                  machine in even address\n-                                                  chunks.  Therefore the\n-                                                  modulus must be odd. */\n-  sizeOfHash = MEMORY_ALLOCATION_ADJUST(sizeOfHash);\n-\n                                                 /* Allocate the cache \n                                                   structure.  calloc () insures\n                                                   its initialization for\n@@ -112,23 +111,39 @@ Cache_t hash_new (u_int sizeOfHash) {\n   \n                                                 /* Allocate the array of \n                                                   buckets for the cache.  \n-                                                  calloc () initializes all of \n+                                                  calloc() initializes all of \n                                                   the pointers to NULL. */\n   retCache->theNodeTable = calloc (sizeOfHash, sizeof (CacheNode_t));\n   assert(retCache->theNodeTable);\n   \n   retCache->sizeOfHash  = sizeOfHash;\n \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* This should work for all\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocessor architectures? */\n+\tretCache->mask = ( sizeOfHash - 1 );\n+\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Store the hashing function\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tso that codes can be \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomputed. */\n+\tretCache->hashFunc = aHashFunc;\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Store the function that\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompares hash keys to \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdetermine if they are \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tequal. */\n+\tretCache->compareFunc = aCompareFunc;\n+\n   return retCache;\n }\n \n \n-void hash_delete (Cache_t theCache) {\n+void \n+hash_delete (Cache_t theCache) {\n \n   CacheNode_t aNode;\n   \n \n-                                                /* Purge all key/value pairs \n+                                               /* Purge all key/value pairs \n                                                   from the table. */\n   while (aNode = hash_next (theCache, NULL))\n     hash_remove (theCache, aNode->theKey);\n@@ -140,9 +155,10 @@ void hash_delete (Cache_t theCache) {\n }\n \n \n-void hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n+void \n+hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n \n-  u_int       indx = hashIndex(*theCache, aKey);\n+  u_int       indx = (* (*theCache)->hashFunc)(*theCache, aKey);\n   CacheNode_t aCacheNode = calloc (1, sizeof (CacheNode));\n \n \n@@ -191,8 +207,9 @@ void hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n                                                   increasing its \n                                                   correctness. */\n     CacheNode_t aNode = NULL;\n-    Cache_t     newCache = \n-                  hash_new (MEMORY_ALLOCATION_ADJUST( EXPANSION (*theCache)));\n+    Cache_t     newCache = hash_new (EXPANSION (*theCache), \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*theCache)->hashFunc, \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*theCache)->compareFunc);\n \n     DEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n       *theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n@@ -213,9 +230,10 @@ void hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n }\n \n \n-void hash_remove (Cache_t theCache, void* aKey) {\n+void \n+hash_remove (Cache_t theCache, void* aKey) {\n \n-  u_int       indx = hashIndex(theCache, aKey);\n+  u_int       indx = (*theCache->hashFunc)(theCache, aKey);\n   CacheNode_t aCacheNode = (*theCache->theNodeTable)[ indx ];\n   \n   \n@@ -227,7 +245,7 @@ void hash_remove (Cache_t theCache, void* aKey) {\n                                                 /* Special case.  First element \n                                                   is the key/value pair to be \n                                                   removed. */\n-  if (aCacheNode->theKey == aKey) {\n+  if ((*theCache->compareFunc)(aCacheNode->theKey, aKey)) {\n     (*theCache->theNodeTable)[ indx ] = aCacheNode->nextNode;\n     free (aCacheNode);\n   } else {\n@@ -238,7 +256,7 @@ void hash_remove (Cache_t theCache, void* aKey) {\n     \n     do {\n     \n-      if (aCacheNode->theKey == aKey) {\n+      if ((*theCache->compareFunc)(aCacheNode->theKey, aKey)) {\n         prevHashNode->nextNode = aCacheNode->nextNode, removed = YES;\n         free (aCacheNode);\n       } else\n@@ -253,7 +271,8 @@ void hash_remove (Cache_t theCache, void* aKey) {\n }\n \n \n-CacheNode_t hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n+CacheNode_t \n+hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n \n   CacheNode_t theCacheNode = aCacheNode;\n   \n@@ -303,3 +322,25 @@ CacheNode_t hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n }\n \n \n+                                                /* Given key, return its \n+                                                  value.  Return NULL if the\n+                                                  key/value pair isn't in\n+                                                  the hash. */\n+void* \n+hash_value_for_key (Cache_t theCache, void* aKey) {\n+\n+  CacheNode_t aCacheNode = \n+              (*theCache->theNodeTable)[(*theCache->hashFunc)(theCache, aKey)];\n+  void*       retVal = NULL;\n+  \n+\n+  if (aCacheNode)\n+    do {\n+      if ((*theCache->compareFunc)(aCacheNode->theKey, aKey))\n+        retVal = aCacheNode->theValue;\n+      else\n+        aCacheNode = aCacheNode->nextNode;\n+    } while (!retVal && aCacheNode);\n+  \n+  return retVal;\n+}"}, {"sha": "e2fc776482e078654eea3ced91f7cca02c4a36aa", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 115, "deletions": 11, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "patch": "@@ -21,10 +21,13 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.7 1991/12/03 02:01:23 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/hash/RCS/hash.h,v 0.8 1991/12/10 12:05:28 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/12/03 02:01:23 $\n+  $Date: 1991/12/10 12:05:28 $\n   $Log: hash.h,v $\n+ * Revision 0.8  1991/12/10  12:05:28  dennisg\n+ * Cleaned up file format for a distribution.\n+ *\n  * Revision 0.7  1991/12/03  02:01:23  dennisg\n  * fixed assert macro.\n  * added memory allocation adjustment macro for hash size allocation.\n@@ -65,8 +68,10 @@\n extern \"C\" {\n #endif\n \n+#include\t<assert.h>\n #include  <sys/types.h>\n \n+#include\t<mutex.h>\n \n /*\n  * This data structure is used to hold items\n@@ -89,6 +94,27 @@ typedef struct cache_node {\n } CacheNode, *CacheNode_t;\n \n \n+/*\n+ * This data type is the function that computes a hash code given a key.\n+ * Therefore, the key can be a pointer to anything and the function specific\n+ * to the key type. \n+ *\n+ * Unfortunately there is a mutual data structure reference problem with this\n+ * typedef.  Therefore, to remove compiler warnings the functions passed to\n+ * hash_new() will have to be casted to this type. \n+ */\n+typedef u_int\t(*HashFunc)(void*, void*);\n+\n+/*\n+ * This data type is the function that compares two hash keys and returns an\n+ * integer greater than, equal to, or less than 0, according as the first\n+ * parameter is lexico-graphically greater than, equal to, or less than the\n+ * second. \n+ */\n+\n+typedef int\t(*CompareFunc)(void*, void*);\n+\n+\n /*\n  * This data structure is the cache.\n  *\n@@ -112,28 +138,40 @@ typedef struct cache {\n                                                     entries allocated for\n                                                     \"theNodeTable\").  Must be\n                                                     a power of two. */\n-              entriesInHash;                      /* Current number of entries\n-                                                    in ther hash table. */\n+              entriesInHash,                      /* Current number of entries\n+                                                    in the hash table. */\n+\t\t\t\t\t\t\tmask;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Precomputed mask. */\n   /*\n    * Variables used to implement indexing\n    *  through the hash table.\n    */\n   u_int       lastBucket;                         /* Tracks which entry in the\n                                                     array where the last value\n                                                     was returned. */\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Function used to compute\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta hash code given a key. \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis function is specified \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhen the hash table is \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreated. */\n+\tHashFunc\t\thashFunc;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Function used to compare \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttwo hash keys to determine\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif they are equal. */\n+\tCompareFunc\tcompareFunc;\n } Cache, *Cache_t;\n \n \n                                                 /* Prototypes for hash\n                                                   functions. */\n                                                 /* Allocate and initialize \n-                                                  a hash table.  Hash table \n-                                                  size taken as a parameter. */ \n-Cache_t hash_new (u_int sizeOfHash);\n+                                                  a hash table. */ \n+Cache_t \n+hash_new (u_int sizeOfHash, HashFunc aHashFunc, CompareFunc aCompareFunc);\n                                                 /* Deallocate all of the\n                                                   hash nodes and the cache\n                                                   itself. */\n-void hash_delete (Cache_t theCache);\n+void \n+hash_delete (Cache_t theCache);\n                                                 /* Add the key/value pair\n                                                   to the hash table.  If the\n                                                   hash table reaches a \n@@ -142,12 +180,14 @@ void hash_delete (Cache_t theCache);\n                                                    \n                                                   assert() if the key is \n                                                   already in the hash. */\n-void hash_add (Cache_t* theCache, void* aKey, void* aValue);\n+void \n+hash_add (Cache_t* theCache, void* aKey, void* aValue);\n                                                 /* Remove the key/value pair\n                                                   from the hash table.  \n                                                   assert() if the key isn't \n                                                   in the table. */\n-void hash_remove (Cache_t theCache, void* aKey);\n+void \n+hash_remove (Cache_t theCache, void* aKey);\n                                                 /* Used to index through the\n                                                   hash table.  Start with NULL\n                                                   to get the first entry.\n@@ -160,7 +200,71 @@ void hash_remove (Cache_t theCache, void* aKey);\n                                                   Cache nodes are returned\n                                                   such that key or value can\n                                                   ber extracted. */\n-CacheNode_t hash_next (Cache_t theCache, CacheNode_t aCacheNode);\n+CacheNode_t \n+hash_next (Cache_t theCache, CacheNode_t aCacheNode);\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Used to return a value from \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta hash table using a given \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey.  */\n+void* \n+hash_value_for_key (Cache_t theCache, void* aKey);\n+\n+\n+/************************************************\n+\n+\tUseful hashing functions.  \n+\t\n+\tDeclared inline for your pleaseure. \n+\t\n+************************************************/\n+\n+                                                /* Calculate a hash code by \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tperforming some manipulation \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tof the key pointer. */\n+static inline u_int \n+intHash(Cache_t theCache, void* aKey) {\n+\n+\n+  assert(sizeof (u_int) == sizeof (aKey));\n+\n+\treturn ((u_int)aKey >> (sizeof(void*) - 1)) & theCache->mask ;\n+}\n+\n+                                                /* Calculate a hash code by \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titerating over a NULL \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tterminate string. */\n+static inline u_int \n+strHash(Cache_t theCache, void* aKey) {\n+\n+\tu_int\tret = 0;\n+\tu_int\tctr = 0;\n+\t\n+\t\n+\twhile(*(char*)aKey) {\n+\t\tret ^= *(char*)aKey++ << ctr;\n+\t\tctr = (ctr + 1) % sizeof(void*);\n+\t}\n+\n+\treturn ret & theCache->mask ;\n+}\n+\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Compare two integers. */\n+static inline int \n+intCmp(void* k1, void* k2) {\n+\n+\n+\treturn !((int)k1 - (int)k2);\n+}\n+\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Compare two strings. */\n+static inline int \n+strCmp(void* k1, void* k2) {\n+\n+\n+\treturn !strcmp( k1, k2 );\n+}\n \n \n #ifdef __cplusplus"}, {"sha": "0ba6716f688ffd3fc6d54f7dff7847812f0ba4aa", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db2bea5cbb72b8a69759af8302bbe0876b0a56d/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=2db2bea5cbb72b8a69759af8302bbe0876b0a56d", "patch": "@@ -19,10 +19,14 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/include/RCS/ObjC.h,v 0.9 1991/12/10 12:04:22 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/include/RCS/ObjC.h,v 0.10 1991/12/31 20:16:08 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/12/10 12:04:22 $\n+  $Date: 1991/12/31 20:16:08 $\n   $Log: ObjC.h,v $\n+ * Revision 0.10  1991/12/31  20:16:08  dennisg\n+ * Deleted index variable stuff.  Index variables are a hack to the language.\n+ * Cleaned up some documentation.\n+ *\n  * Revision 0.9  1991/12/10  12:04:22  dennisg\n  * Cleaned up file format for a distribution.\n  *\n@@ -69,12 +73,12 @@ extern \"C\" {\n #endif\n \n #include  <sys/types.h>\n-#include  <hash.h>\n+#include  <record-inline.h>\n #include  <stdarg.h>\n \n \n-#define nil ( id )0                             /* id of Nil instance */\n-#define Nil ( Class_t )0                        /* id of Nil class */\n+#define nil (id)0                               /* id of Nil instance */\n+#define Nil (Class_t)0                          /* id of Nil class */\n typedef char* STR;                              /* String alias */\n \n                                                 /* Boolean typedefs */\n@@ -292,11 +296,8 @@ typedef struct objc_metaClass {\n                                                 Object.  Should be ignored. */\n   MethodList_t            methods;            /* Linked List of factory methods \n                                                 for the class. */\n-  Cache_t                 cache;              /* Used to cache factory methods\n-                                                defined for the class and its \n-                                                super classes.  Entries are\n-                                                made to the cache as the\n-                                                messager receives them. */\n+  Record_t*               cache;              /* Pointer to factory method\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch table. */\n } MetaClass, *MetaClass_t;\n \n \n@@ -334,11 +335,8 @@ typedef struct objc_class {\n   MethodList_t        methods;                /* Linked list of instance\n                                                 methods defined for the \n                                                 class. */\n-  Cache_t             cache;                  /* Used to cache instance methods\n-                                                defined for the class and its \n-                                                super classes.  Entries are\n-                                                made to the cache as the\n-                                                messager receives them. */\n+  Record_t*           cache;                  /* Pointer to instance method \n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch table. */\n } Class, *Class_t;\n \n "}]}