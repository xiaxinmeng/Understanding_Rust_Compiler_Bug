{"sha": "d86c7648fb9643640d8c82be19d49927aa488768", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg2Yzc2NDhmYjk2NDM2NDBkOGM4MmJlMTlkNDk5MjdhYTQ4ODc2OA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-28T07:11:16Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-28T07:11:16Z"}, "message": "Come up with new --completion option.\n\n2018-06-28  Martin Liska  <mliska@suse.cz>\n\n\t* common.opt: Introduce -completion option.\n\t* gcc.c (driver_handle_option): Handle it.\n\t(driver::main): Print completions if completion\n        is set.\n\t* opt-suggestions.c (option_proposer::get_completions):\n        New function.\n\t(option_proposer::suggest_completion): Likewise.\n\t(option_proposer::find_param_completions): Likewise.\n\t(verify_autocompletions): Likewise.\n\t(test_completion_valid_options): Likewise.\n\t(test_completion_valid_params): Likewise.\n\t(in_completion_p): Likewise.\n\t(empty_completion_p): Likewise.\n\t(test_completion_partial_match): Likewise.\n\t(test_completion_garbage): Likewise.\n\t(opt_proposer_c_tests): Likewise.\n\t* opt-suggestions.h: Declare new functions.\n\t* opts.c (common_handle_option): Handle OPT__completion_.\n\t* selftest-run-tests.c (selftest::run_tests): Add\n        opt_proposer_c_tests.\n\t* selftest.c (assert_str_startswith): New.\n\t* selftest.h (assert_str_startswith): Likewise.\n\t(opt_proposer_c_tests): New.\n\t(ASSERT_STR_STARTSWITH): Likewise.\n\nFrom-SVN: r262210", "tree": {"sha": "b45fc0d4134e27d198b87360705d0182c44f8f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b45fc0d4134e27d198b87360705d0182c44f8f25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d86c7648fb9643640d8c82be19d49927aa488768", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86c7648fb9643640d8c82be19d49927aa488768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d86c7648fb9643640d8c82be19d49927aa488768", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86c7648fb9643640d8c82be19d49927aa488768/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98086b2ba2bd021e887788cea410410e61eaee42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98086b2ba2bd021e887788cea410410e61eaee42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98086b2ba2bd021e887788cea410410e61eaee42"}], "stats": {"total": 412, "additions": 412, "deletions": 0}, "files": [{"sha": "d4d1d86e2d88f0b003cb78b407d9bf137974b356", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -1,3 +1,30 @@\n+2018-06-28  Martin Liska  <mliska@suse.cz>\n+\n+\t* common.opt: Introduce -completion option.\n+\t* gcc.c (driver_handle_option): Handle it.\n+\t(driver::main): Print completions if completion\n+        is set.\n+\t* opt-suggestions.c (option_proposer::get_completions):\n+        New function.\n+\t(option_proposer::suggest_completion): Likewise.\n+\t(option_proposer::find_param_completions): Likewise.\n+\t(verify_autocompletions): Likewise.\n+\t(test_completion_valid_options): Likewise.\n+\t(test_completion_valid_params): Likewise.\n+\t(in_completion_p): Likewise.\n+\t(empty_completion_p): Likewise.\n+\t(test_completion_partial_match): Likewise.\n+\t(test_completion_garbage): Likewise.\n+\t(opt_proposer_c_tests): Likewise.\n+\t* opt-suggestions.h: Declare new functions.\n+\t* opts.c (common_handle_option): Handle OPT__completion_.\n+\t* selftest-run-tests.c (selftest::run_tests): Add\n+        opt_proposer_c_tests.\n+\t* selftest.c (assert_str_startswith): New.\n+\t* selftest.h (assert_str_startswith): Likewise.\n+\t(opt_proposer_c_tests): New.\n+\t(ASSERT_STR_STARTSWITH): Likewise.\n+\n 2018-06-28  Martin Liska  <mliska@suse.cz>\n \n \t* Makefile.in: Add opt-suggestions.o."}, {"sha": "5a50bc27710a9a38204249de3e9e4da72686f632", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -255,6 +255,10 @@ Driver Alias(S)\n -compile\n Driver Alias(c)\n \n+-completion=\n+Common Driver Joined Undocumented\n+Provide bash completion for options starting with provided string.\n+\n -coverage\n Driver Alias(coverage)\n "}, {"sha": "9ed8a03af0a2aa017be1fc75a81823dda94d7816", "filename": "gcc/gcc.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -221,6 +221,10 @@ static int print_help_list;\n \n static int print_version;\n \n+/* Flag that stores string prefix for which we provide bash completion.  */\n+\n+static const char *completion = NULL;\n+\n /* Flag indicating whether we should ONLY print the command and\n    arguments (like verbose_flag) without executing the command.\n    Displayed arguments are quoted so that the generated command\n@@ -3890,6 +3894,11 @@ driver_handle_option (struct gcc_options *opts,\n       add_linker_option (\"--version\", strlen (\"--version\"));\n       break;\n \n+    case OPT__completion_:\n+      validated = true;\n+      completion = decoded->arg;\n+      break;\n+\n     case OPT__help:\n       print_help_list = 1;\n \n@@ -7300,6 +7309,12 @@ driver::main (int argc, char **argv)\n   maybe_putenv_OFFLOAD_TARGETS ();\n   handle_unrecognized_options ();\n \n+  if (completion)\n+    {\n+      m_option_proposer.suggest_completion (completion);\n+      return 0;\n+    }\n+\n   if (!maybe_print_and_exit ())\n     return 0;\n "}, {"sha": "894eea5f37c0bd01a90039ba106571114961c903", "filename": "gcc/opt-suggestions.c", "status": "modified", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fopt-suggestions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fopt-suggestions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-suggestions.c?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -47,6 +47,66 @@ option_proposer::suggest_option (const char *bad_opt)\n      (auto_vec <const char *> *) m_option_suggestions);\n }\n \n+/* Populate RESULTS with valid completions of options that begin\n+   with OPTION_PREFIX.  */\n+\n+void\n+option_proposer::get_completions (const char *option_prefix,\n+\t\t\t\t  auto_string_vec &results)\n+{\n+  /* Bail out for an invalid input.  */\n+  if (option_prefix == NULL || option_prefix[0] == '\\0')\n+    return;\n+\n+  /* Option suggestions are built without first leading dash character.  */\n+  if (option_prefix[0] == '-')\n+    option_prefix++;\n+\n+  size_t length = strlen (option_prefix);\n+\n+  /* Handle OPTION_PREFIX starting with \"-param\".  */\n+  const char *prefix = \"-param\";\n+  if (length >= strlen (prefix)\n+      && strstr (option_prefix, prefix) == option_prefix)\n+    {\n+      /* We support both '-param-xyz=123' and '-param xyz=123' */\n+      option_prefix += strlen (prefix);\n+      char separator = option_prefix[0];\n+      option_prefix++;\n+      if (separator == ' ' || separator == '=')\n+\tfind_param_completions (separator, option_prefix, results);\n+    }\n+  else\n+    {\n+      /* Lazily populate m_option_suggestions.  */\n+      if (!m_option_suggestions)\n+\tbuild_option_suggestions ();\n+      gcc_assert (m_option_suggestions);\n+\n+      for (unsigned i = 0; i < m_option_suggestions->length (); i++)\n+\t{\n+\t  char *candidate = (*m_option_suggestions)[i];\n+\t  if (strlen (candidate) >= length\n+\t      && strstr (candidate, option_prefix) == candidate)\n+\t    results.safe_push (concat (\"-\", candidate, NULL));\n+\t}\n+    }\n+}\n+\n+/* Print on stdout a list of valid options that begin with OPTION_PREFIX,\n+   one per line, suitable for use by Bash completion.\n+\n+   Implementation of the \"-completion=\" option.  */\n+\n+void\n+option_proposer::suggest_completion (const char *option_prefix)\n+{\n+  auto_string_vec results;\n+  get_completions (option_prefix, results);\n+  for (unsigned i = 0; i < results.length (); i++)\n+    printf (\"%s\\n\", results[i]);\n+}\n+\n void\n option_proposer::build_option_suggestions (void)\n {\n@@ -120,3 +180,236 @@ option_proposer::build_option_suggestions (void)\n \t}\n     }\n }\n+\n+/* Find parameter completions for --param format with SEPARATOR.\n+   Again, save the completions into results.  */\n+\n+void\n+option_proposer::find_param_completions (const char separator,\n+\t\t\t\t\t const char *param_prefix,\n+\t\t\t\t\t auto_string_vec &results)\n+{\n+  char separator_str[] = {separator, '\\0'};\n+  size_t length = strlen (param_prefix);\n+  for (unsigned i = 0; i < get_num_compiler_params (); ++i)\n+    {\n+      const char *candidate = compiler_params[i].option;\n+      if (strlen (candidate) >= length\n+\t  && strstr (candidate, param_prefix) == candidate)\n+\tresults.safe_push (concat (\"--param\", separator_str, candidate, NULL));\n+    }\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that PROPOSER generates sane auto-completion suggestions\n+   for OPTION_PREFIX.  */\n+\n+static void\n+verify_autocompletions (option_proposer &proposer, const char *option_prefix)\n+{\n+  auto_string_vec suggestions;\n+  proposer.get_completions (option_prefix, suggestions);\n+\n+  /* There must be at least one suggestion, and every suggestion must\n+     indeed begin with OPTION_PREFIX.  */\n+\n+  ASSERT_GT (suggestions.length (), 0);\n+\n+  for (unsigned i = 0; i < suggestions.length (); i++)\n+    ASSERT_STR_STARTSWITH (suggestions[i], option_prefix);\n+}\n+\n+/* Verify that valid options are auto-completed correctly.  */\n+\n+static void\n+test_completion_valid_options (option_proposer &proposer)\n+{\n+  const char *option_prefixes[] =\n+  {\n+    \"-fno-var-tracking-assignments-toggle\",\n+    \"-fpredictive-commoning\",\n+    \"--param=stack-clash-protection-guard-size\",\n+    \"--param=max-predicted-iterations\",\n+    \"-ftree-loop-distribute-patterns\",\n+    \"-fno-var-tracking\",\n+    \"-Walloc-zero\",\n+    \"--param=ipa-cp-value-list-size\",\n+    \"-Wsync-nand\",\n+    \"-Wno-attributes\",\n+    \"--param=tracer-dynamic-coverage-feedback\",\n+    \"-Wno-format-contains-nul\",\n+    \"-Wnamespaces\",\n+    \"-fisolate-erroneous-paths-attribute\",\n+    \"-Wno-underflow\",\n+    \"-Wtarget-lifetime\",\n+    \"--param=asan-globals\",\n+    \"-Wno-empty-body\",\n+    \"-Wno-odr\",\n+    \"-Wformat-zero-length\",\n+    \"-Wstringop-truncation\",\n+    \"-fno-ipa-vrp\",\n+    \"-fmath-errno\",\n+    \"-Warray-temporaries\",\n+    \"-Wno-unused-label\",\n+    \"-Wreturn-local-addr\",\n+    \"--param=sms-dfa-history\",\n+    \"--param=asan-instrument-reads\",\n+    \"-Wreturn-type\",\n+    \"-Wc++17-compat\",\n+    \"-Wno-effc++\",\n+    \"--param=max-fields-for-field-sensitive\",\n+    \"-fisolate-erroneous-paths-dereference\",\n+    \"-fno-defer-pop\",\n+    \"-Wcast-align=strict\",\n+    \"-foptimize-strlen\",\n+    \"-Wpacked-not-aligned\",\n+    \"-funroll-loops\",\n+    \"-fif-conversion2\",\n+    \"-Wdesignated-init\",\n+    \"--param=max-iterations-computation-cost\",\n+    \"-Wmultiple-inheritance\",\n+    \"-fno-sel-sched-reschedule-pipelined\",\n+    \"-Wassign-intercept\",\n+    \"-Wno-format-security\",\n+    \"-fno-sched-stalled-insns\",\n+    \"-fbtr-bb-exclusive\",\n+    \"-fno-tree-tail-merge\",\n+    \"-Wlong-long\",\n+    \"-Wno-unused-but-set-parameter\",\n+    NULL\n+  };\n+\n+  for (const char **ptr = option_prefixes; *ptr != NULL; ptr++)\n+    verify_autocompletions (proposer, *ptr);\n+}\n+\n+/* Verify that valid parameters are auto-completed correctly,\n+   both with the \"--param=PARAM\" form and the \"--param PARAM\" form.  */\n+\n+static void\n+test_completion_valid_params (option_proposer &proposer)\n+{\n+  const char *option_prefixes[] =\n+  {\n+    \"--param=sched-state-edge-prob-cutoff\",\n+    \"--param=iv-consider-all-candidates-bound\",\n+    \"--param=align-threshold\",\n+    \"--param=prefetch-min-insn-to-mem-ratio\",\n+    \"--param=max-unrolled-insns\",\n+    \"--param=max-early-inliner-iterations\",\n+    \"--param=max-vartrack-reverse-op-size\",\n+    \"--param=ipa-cp-loop-hint-bonus\",\n+    \"--param=tracer-min-branch-ratio\",\n+    \"--param=graphite-max-arrays-per-scop\",\n+    \"--param=sink-frequency-threshold\",\n+    \"--param=max-cse-path-length\",\n+    \"--param=sra-max-scalarization-size-Osize\",\n+    \"--param=prefetch-latency\",\n+    \"--param=dse-max-object-size\",\n+    \"--param=asan-globals\",\n+    \"--param=max-vartrack-size\",\n+    \"--param=case-values-threshold\",\n+    \"--param=max-slsr-cand-scan\",\n+    \"--param=min-insn-to-prefetch-ratio\",\n+    \"--param=tracer-min-branch-probability\",\n+    \"--param sink-frequency-threshold\",\n+    \"--param max-cse-path-length\",\n+    \"--param sra-max-scalarization-size-Osize\",\n+    \"--param prefetch-latency\",\n+    \"--param dse-max-object-size\",\n+    \"--param asan-globals\",\n+    \"--param max-vartrack-size\",\n+    NULL\n+  };\n+\n+  for (const char **ptr = option_prefixes; *ptr != NULL; ptr++)\n+    verify_autocompletions (proposer, *ptr);\n+}\n+\n+/* Return true when EXPECTED is one of completions for OPTION_PREFIX string.  */\n+\n+static bool\n+in_completion_p (option_proposer &proposer, const char *option_prefix,\n+\t\t const char *expected)\n+{\n+  auto_string_vec suggestions;\n+  proposer.get_completions (option_prefix, suggestions);\n+\n+  for (unsigned i = 0; i < suggestions.length (); i++)\n+    {\n+      char *r = suggestions[i];\n+      if (strcmp (r, expected) == 0)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true when PROPOSER does not find any partial completion\n+   for OPTION_PREFIX.  */\n+\n+static bool\n+empty_completion_p (option_proposer &proposer, const char *option_prefix)\n+{\n+  auto_string_vec suggestions;\n+  proposer.get_completions (option_prefix, suggestions);\n+  return suggestions.is_empty ();\n+}\n+\n+/* Verify autocompletions of partially-complete options.  */\n+\n+static void\n+test_completion_partial_match (option_proposer &proposer)\n+{\n+  ASSERT_TRUE (in_completion_p (proposer, \"-fsani\", \"-fsanitize=address\"));\n+  ASSERT_TRUE (in_completion_p (proposer, \"-fsani\",\n+\t\t\t\t\"-fsanitize-address-use-after-scope\"));\n+  ASSERT_TRUE (in_completion_p (proposer, \"-fipa-icf\", \"-fipa-icf-functions\"));\n+  ASSERT_TRUE (in_completion_p (proposer, \"-fipa-icf\", \"-fipa-icf\"));\n+  ASSERT_TRUE (in_completion_p (proposer, \"--param=\",\n+\t\t\t\t\"--param=max-vartrack-reverse-op-size\"));\n+  ASSERT_TRUE (in_completion_p (proposer, \"--param \",\n+\t\t\t\t\"--param max-vartrack-reverse-op-size\"));\n+\n+  ASSERT_FALSE (in_completion_p (proposer, \"-fipa-icf\", \"-fipa\"));\n+  ASSERT_FALSE (in_completion_p (proposer, \"-fipa-icf-functions\", \"-fipa-icf\"));\n+\n+  ASSERT_FALSE (empty_completion_p (proposer, \"-\"));\n+  ASSERT_FALSE (empty_completion_p (proposer, \"-fipa\"));\n+  ASSERT_FALSE (empty_completion_p (proposer, \"--par\"));\n+}\n+\n+/* Verify that autocompletion does not return any match for garbage inputs.  */\n+\n+static void\n+test_completion_garbage (option_proposer &proposer)\n+{\n+  ASSERT_TRUE (empty_completion_p (proposer, NULL));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"\"));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"- \"));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"123456789\"));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"---------\"));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"#########\"));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"- - - - - -\"));\n+  ASSERT_TRUE (empty_completion_p (proposer, \"-fsanitize=address2\"));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+opt_proposer_c_tests ()\n+{\n+  option_proposer proposer;\n+\n+  test_completion_valid_options (proposer);\n+  test_completion_valid_params (proposer);\n+  test_completion_partial_match (proposer);\n+  test_completion_garbage (proposer);\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "222bafa12cd4969c574a4e64659798fa78aad71c", "filename": "gcc/opt-suggestions.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fopt-suggestions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fopt-suggestions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-suggestions.h?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -45,12 +45,27 @@ class option_proposer\n      The returned string is owned by the option_proposer instance.  */\n   const char *suggest_option (const char *bad_opt);\n \n+  /* Print on stdout a list of valid options that begin with OPTION_PREFIX,\n+     one per line, suitable for use by Bash completion.\n+\n+     Implementation of the \"-completion=\" option.  */\n+  void suggest_completion (const char *option_prefix);\n+\n+  /* Populate RESULTS with valid completions of options that begin\n+     with OPTION_PREFIX.  */\n+  void get_completions (const char *option_prefix, auto_string_vec &results);\n+\n private:\n   /* Helper function for option_proposer::suggest_option.  Populate\n      m_option_suggestions with candidate strings for misspelled options.\n      The strings will be freed by the option_proposer's dtor.  */\n   void build_option_suggestions ();\n \n+  /* Find parameter completions for --param format with SEPARATOR.\n+     Again, save the completions into results.  */\n+  void find_param_completions (const char separator, const char *param_prefix,\n+\t\t\t       auto_string_vec &results);\n+\n private:\n   /* Cache with all suggestions.  */\n   auto_string_vec *m_option_suggestions;"}, {"sha": "ed102c05c222ae918a64807f89f68c0f9f3ac2e5", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -1982,6 +1982,9 @@ common_handle_option (struct gcc_options *opts,\n       opts->x_exit_after_options = true;\n       break;\n \n+    case OPT__completion_:\n+      break;\n+\n     case OPT_fsanitize_:\n       opts->x_flag_sanitize\n \t= parse_sanitizer_options (arg, loc, code,"}, {"sha": "7f4d6f3a246ab36d04179a8329c738e3039390ec", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -71,6 +71,7 @@ selftest::run_tests ()\n   fibonacci_heap_c_tests ();\n   typed_splay_tree_c_tests ();\n   unique_ptr_tests_cc_tests ();\n+  opt_proposer_c_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "27de9a41b794688952004fdd17808ade64896ca9", "filename": "gcc/selftest.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -125,6 +125,40 @@ assert_str_contains (const location &loc,\n \t desc_haystack, desc_needle, val_haystack, val_needle);\n }\n \n+/* Implementation detail of ASSERT_STR_STARTSWITH.\n+   Determine if VAL_STR starts with VAL_PREFIX.\n+   ::selftest::pass if VAL_STR does start with VAL_PREFIX.\n+   ::selftest::fail if it does not, or either is NULL (using\n+   DESC_STR and DESC_PREFIX in the error message).  */\n+\n+void\n+assert_str_startswith (const location &loc,\n+\t\t       const char *desc_str,\n+\t\t       const char *desc_prefix,\n+\t\t       const char *val_str,\n+\t\t       const char *val_prefix)\n+{\n+  /* If val_str is NULL, fail with a custom error message.  */\n+  if (val_str == NULL)\n+    fail_formatted (loc, \"ASSERT_STR_STARTSWITH (%s, %s) str=NULL\",\n+\t\t    desc_str, desc_prefix);\n+\n+  /* If val_prefix is NULL, fail with a custom error message.  */\n+  if (val_prefix == NULL)\n+    fail_formatted (loc,\n+\t\t    \"ASSERT_STR_STARTSWITH (%s, %s) str=\\\"%s\\\" prefix=NULL\",\n+\t\t    desc_str, desc_prefix, val_str);\n+\n+  const char *test = strstr (val_str, val_prefix);\n+  if (test == val_str)\n+    pass (loc, \"ASSERT_STR_STARTSWITH\");\n+  else\n+    fail_formatted\n+\t(loc, \"ASSERT_STR_STARTSWITH (%s, %s) str=\\\"%s\\\" prefix=\\\"%s\\\"\",\n+\t desc_str, desc_prefix, val_str, val_prefix);\n+}\n+\n+\n /* Constructor.  Generate a name for the file.  */\n \n named_temp_file::named_temp_file (const char *suffix)"}, {"sha": "d66fb93d1a59a7ec88116186b63d1e9e2c9ca4b7", "filename": "gcc/selftest.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86c7648fb9643640d8c82be19d49927aa488768/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=d86c7648fb9643640d8c82be19d49927aa488768", "patch": "@@ -78,6 +78,15 @@ extern void assert_str_contains (const location &loc,\n \t\t\t\t const char *val_haystack,\n \t\t\t\t const char *val_needle);\n \n+/* Implementation detail of ASSERT_STR_STARTSWITH.  */\n+\n+extern void assert_str_startswith (const location &loc,\n+\t\t\t\t   const char *desc_str,\n+\t\t\t\t   const char *desc_prefix,\n+\t\t\t\t   const char *val_str,\n+\t\t\t\t   const char *val_prefix);\n+\n+\n /* A named temporary file for use in selftests.\n    Usable for writing out files, and as the base class for\n    temp_source_file.\n@@ -217,6 +226,7 @@ extern void unique_ptr_tests_cc_tests ();\n extern void vec_c_tests ();\n extern void vec_perm_indices_c_tests ();\n extern void wide_int_cc_tests ();\n+extern void opt_proposer_c_tests ();\n \n extern int num_passes;\n \n@@ -402,6 +412,16 @@ extern int num_passes;\n \t\t\t\t   (HAYSTACK), (NEEDLE));\t\t\\\n   SELFTEST_END_STMT\n \n+/* Evaluate STR and PREFIX and determine if STR starts with PREFIX.\n+     ::selftest::pass if STR does start with PREFIX.\n+     ::selftest::fail if does not, or either is NULL.  */\n+\n+#define ASSERT_STR_STARTSWITH(STR, PREFIX)\t\t\t\t    \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t    \\\n+  ::selftest::assert_str_startswith (SELFTEST_LOCATION, #STR, #PREFIX,\t    \\\n+\t\t\t\t     (STR), (PREFIX));\t\t\t    \\\n+  SELFTEST_END_STMT\n+\n /* Evaluate PRED1 (VAL1), calling ::selftest::pass if it is true,\n    ::selftest::fail if it is false.  */\n "}]}