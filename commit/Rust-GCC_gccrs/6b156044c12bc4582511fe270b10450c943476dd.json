{"sha": "6b156044c12bc4582511fe270b10450c943476dd", "node_id": "C_kwDOANBUbNoAKDZiMTU2MDQ0YzEyYmM0NTgyNTExZmUyNzBiMTA0NTBjOTQzNDc2ZGQ", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-03-24T19:28:43Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-13T13:45:35Z"}, "message": "Make range_from_dom more effective.\n\nAdd modes to range_from_dom such that we can simply query, or adjust the\ncache and deal with multiple predecessor blocks.\n\n\t* gimple-range-cache.cc (ranger_cache::ranger_cache): Start with\n\tworlist truncated.\n\t(ranger_cache::entry_range): Add rfd_mode parameter.\n\t(ranger_cache::exit_range): Ditto.\n\t(ranger_cache::edge_range): New.  Incorporate from range_on_edge.\n\t(ranger_cache::range_of_expr): Adjust call to entry_range.\n\t(ranger_cache::range_on_edge): Split to edge_range and call.\n\t(ranger_cache::fill_block_cache): Always invoke range_from_dom.\n\t(ranger_cache::range_from_dom): Make reentrant, add search mode, handle\n\tmutiple predecessors.\n\t(ranger_cache::update_to_nonnull): Adjust call to exit_range.\n\t* gimple-range-cache.h (ranger_cache): Add enum rfd_mode.  Adjust\n\tprototypes.", "tree": {"sha": "7e588128b0f0f94d8386f248f8dac1812490257c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e588128b0f0f94d8386f248f8dac1812490257c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b156044c12bc4582511fe270b10450c943476dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b156044c12bc4582511fe270b10450c943476dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b156044c12bc4582511fe270b10450c943476dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b156044c12bc4582511fe270b10450c943476dd/comments", "author": null, "committer": null, "parents": [{"sha": "b584cbdb0829bb0ad4e6ed7488a304ae4e76b870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b584cbdb0829bb0ad4e6ed7488a304ae4e76b870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b584cbdb0829bb0ad4e6ed7488a304ae4e76b870"}], "stats": {"total": 148, "additions": 98, "deletions": 50}, "files": [{"sha": "bdb30460345d7520f8ef9131c91789a70abe9bce", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 88, "deletions": 47, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b156044c12bc4582511fe270b10450c943476dd/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b156044c12bc4582511fe270b10450c943476dd/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=6b156044c12bc4582511fe270b10450c943476dd", "patch": "@@ -864,6 +864,7 @@ ranger_cache::ranger_cache (int not_executable_flag)\n {\n   m_workback.create (0);\n   m_workback.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+  m_workback.truncate (0);\n   m_temporal = new temporal_cache;\n   // If DOM info is available, spawn an oracle as well.\n   if (dom_info_available_p (CDI_DOMINATORS))\n@@ -1008,10 +1009,12 @@ ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n     }\n }\n \n-// Get the range of NAME as it occurs on entry to block BB.\n+// Get the range of NAME as it occurs on entry to block BB.  Use MODE for\n+// lookups.\n \n void\n-ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n+ranger_cache::entry_range (irange &r, tree name, basic_block bb,\n+\t\t\t   enum rfd_mode mode)\n {\n   if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     {\n@@ -1022,13 +1025,16 @@ ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n   // Look for the on-entry value of name in BB from the cache.\n   // Otherwise pick up the best available global value.\n   if (!m_on_entry.get_bb_range (r, name, bb))\n-    range_of_def (r, name);\n+    if (!range_from_dom (r, name, bb, mode))\n+      range_of_def (r, name);\n }\n \n-// Get the range of NAME as it occurs on exit from block BB.\n+// Get the range of NAME as it occurs on exit from block BB.  Use MODE for\n+// lookups.\n \n void\n-ranger_cache::exit_range (irange &r, tree name, basic_block bb)\n+ranger_cache::exit_range (irange &r, tree name, basic_block bb,\n+\t\t\t  enum rfd_mode mode)\n {\n   if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     {\n@@ -1041,8 +1047,25 @@ ranger_cache::exit_range (irange &r, tree name, basic_block bb)\n   if (def_bb == bb)\n     range_of_def (r, name, bb);\n   else\n-    entry_range (r, name, bb);\n- }\n+    entry_range (r, name, bb, mode);\n+}\n+\n+// Get the range of NAME on edge E using MODE, return the result in R.\n+// Always returns a range and true.\n+\n+bool\n+ranger_cache::edge_range (irange &r, edge e, tree name, enum rfd_mode mode)\n+{\n+  exit_range (r, name, e->src, mode);\n+  // If this is not an abnormal edge, check for a non-null exit.\n+  if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n+    m_non_null.adjust_range (r, name, e->src, false);\n+  int_range_max er;\n+  if (m_gori.outgoing_edge_range_p (er, e, name, *this))\n+    r.intersect (er);\n+  return true;\n+}\n+\n \n \n // Implement range_of_expr.\n@@ -1063,32 +1086,22 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n   if (bb == def_bb)\n     range_of_def (r, name, bb);\n   else\n-    entry_range (r, name, bb);\n+    entry_range (r, name, bb, RFD_NONE);\n   return true;\n }\n \n \n-// Implement range_on_edge.  Always return the best available range.\n-\n- bool\n- ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n- {\n-   if (gimple_range_ssa_p (expr))\n-    {\n-      exit_range (r, expr, e->src);\n-      // If this is not an abnormal edge, check for a non-null exit.\n-      if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n-\tm_non_null.adjust_range (r, expr, e->src, false);\n-      int_range_max edge_range;\n-      if (m_gori.outgoing_edge_range_p (edge_range, e, expr, *this))\n-\tr.intersect (edge_range);\n-      return true;\n-    }\n+// Implement range_on_edge.  Always return the best available range using\n+// the current cache values.\n \n+bool\n+ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n+{\n+  if (gimple_range_ssa_p (expr))\n+    return edge_range (r, e, expr, RFD_NONE);\n   return get_tree_range (r, expr, NULL);\n }\n \n-\n // Return a static range for NAME on entry to basic block BB in R.  If\n // calc is true, fill any cache entries required between BB and the\n // def block for NAME.  Otherwise, return false if the cache is empty.\n@@ -1281,30 +1294,21 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n   // At this point we shouldn't be looking at the def, entry or exit block.\n   gcc_checking_assert (bb != def_bb && bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) &&\n \t\t       bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n+  gcc_checking_assert (m_workback.length () == 0);\n \n   // If the block cache is set, then we've already visited this block.\n   if (m_on_entry.bb_range_p (name, bb))\n     return;\n \n-  // Visit each block back to the DEF.  Initialize each one to UNDEFINED.\n-  // m_visited at the end will contain all the blocks that we needed to set\n-  // the range_on_entry cache for.\n-  m_workback.truncate (0);\n-  m_workback.quick_push (bb);\n-  undefined.set_undefined ();\n-  m_on_entry.set_bb_range (name, bb, undefined);\n-  gcc_checking_assert (m_update->empty_p ());\n-\n   if (DEBUG_RANGE_CACHE)\n     {\n       fprintf (dump_file, \"\\n\");\n       print_generic_expr (dump_file, name, TDF_SLIM);\n       fprintf (dump_file, \" : \");\n     }\n \n-  // If there are dominators, check if a dominators can supply the range.\n-  if (dom_info_available_p (CDI_DOMINATORS)\n-      && range_from_dom (block_result, name, bb))\n+  // Check if a dominators can supply the range.\n+  if (range_from_dom (block_result, name, bb, RFD_FILL))\n     {\n       m_on_entry.set_bb_range (name, bb, block_result);\n       if (DEBUG_RANGE_CACHE)\n@@ -1313,9 +1317,18 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t  block_result.dump (dump_file);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n+      gcc_checking_assert (m_workback.length () == 0);\n       return;\n     }\n \n+  // Visit each block back to the DEF.  Initialize each one to UNDEFINED.\n+  // m_visited at the end will contain all the blocks that we needed to set\n+  // the range_on_entry cache for.\n+  m_workback.quick_push (bb);\n+  undefined.set_undefined ();\n+  m_on_entry.set_bb_range (name, bb, undefined);\n+  gcc_checking_assert (m_update->empty_p ());\n+\n   while (m_workback.length () > 0)\n     {\n       basic_block node = m_workback.pop ();\n@@ -1399,12 +1412,14 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n }\n \n \n-// Get the range of NAME from dominators of BB and return it in R.\n+// Get the range of NAME from dominators of BB and return it in R.  Search the\n+// dominator tree based on MODE.\n \n bool\n-ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb)\n+ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n+\t\t\t      enum rfd_mode mode)\n {\n-  if (!dom_info_available_p (CDI_DOMINATORS))\n+  if (mode == RFD_NONE || !dom_info_available_p (CDI_DOMINATORS))\n     return false;\n \n   // Search back to the definition block or entry block.\n@@ -1419,7 +1434,7 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb)\n \n   // Range on entry to the DEF block should not be queried.\n   gcc_checking_assert (start_bb != def_bb);\n-  m_workback.truncate (0);\n+  unsigned start_limit = m_workback.length ();\n \n   // Default value is global range.\n   get_global_range (r, name);\n@@ -1436,10 +1451,36 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb)\n       if (m_gori.has_edge_range_p (name, bb))\n \t{\n \t  // Only outgoing ranges to single_pred blocks are dominated by\n-\t  // outgoing edge ranges, so only those need to be considered.\n+\t  // outgoing edge ranges, so those can be simply adjusted on the fly.\n \t  edge e = find_edge (bb, prev_bb);\n \t  if (e && single_pred_p (prev_bb))\n \t    m_workback.quick_push (prev_bb);\n+\t  else if (mode == RFD_FILL)\n+\t    {\n+\t      // Multiple incoming edges, so recursively satisfy this block,\n+\t      // store the range, then calculate the incoming range for PREV_BB.\n+\t      if (def_bb != bb)\n+\t\t{\n+\t\t  range_from_dom (r, name, bb, RFD_FILL);\n+\t\t  // If the range can't be store, don't try to accumulate\n+\t\t  // the range in PREV_BB due to excessive recalculations.\n+\t\t  if (!m_on_entry.set_bb_range (name, bb, r))\n+\t\t    break;\n+\t\t}\n+\t      // With the dominator set, we should be able to cheaply query\n+\t      // each incoming edge now and accumulate the results.\n+\t      r.set_undefined ();\n+\t      edge_iterator ei;\n+\t      int_range_max er;\n+\t      FOR_EACH_EDGE (e, ei, prev_bb->preds)\n+\t\t{\n+\t\t  edge_range (er, e, name, RFD_READ_ONLY);\n+\t\t  r.union_ (er);\n+\t\t}\n+\t      // Set the cache in PREV_BB so it is not calculated again.\n+\t      m_on_entry.set_bb_range (name, prev_bb, r);\n+\t      break;\n+\t    }\n \t}\n \n       if (def_bb == bb)\n@@ -1460,16 +1501,16 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb)\n     }\n \n   // Now process any outgoing edges that we seen along the way.\n-  while (m_workback.length () > 0)\n+  while (m_workback.length () > start_limit)\n     {\n-      int_range_max edge_range;\n+      int_range_max er;\n       prev_bb = m_workback.pop ();\n       edge e = single_pred_edge (prev_bb);\n       bb = e->src;\n \n-      if (m_gori.outgoing_edge_range_p (edge_range, e, name, *this))\n+      if (m_gori.outgoing_edge_range_p (er, e, name, *this))\n \t{\n-\t  r.intersect (edge_range);\n+\t  r.intersect (er);\n \t  if (r.varying_p () && ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0))\n \t    {\n \t      if (m_non_null.non_null_deref_p (name, bb, false))\n@@ -1518,7 +1559,7 @@ ranger_cache::update_to_nonnull (basic_block bb, tree name)\n       // Update the on-entry cache for BB to be non-zero.  Note this can set\n       // the on entry value in the DEF block, which can override the def.\n       int_range_max r;\n-      exit_range (r, name, bb);\n+      exit_range (r, name, bb, RFD_READ_ONLY);\n       if (r.varying_p ())\n \t{\n \t  r.set_nonzero (type);"}, {"sha": "560403b534ee1a667eb46223b48fd29f8be4fe68", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b156044c12bc4582511fe270b10450c943476dd/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b156044c12bc4582511fe270b10450c943476dd/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=6b156044c12bc4582511fe270b10450c943476dd", "patch": "@@ -129,7 +129,6 @@ class ranger_cache : public range_query\n   virtual bool range_of_expr (irange &r, tree name, gimple *stmt);\n   virtual bool range_on_edge (irange &r, edge e, tree expr);\n   bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n-  bool range_from_dom (irange &r, tree name, basic_block bb);\n \n   bool get_global_range (irange &r, tree name) const;\n   bool get_global_range (irange &r, tree name, bool &current_p);\n@@ -151,9 +150,17 @@ class ranger_cache : public range_query\n   void fill_block_cache (tree name, basic_block bb, basic_block def_bb);\n   void propagate_cache (tree name);\n \n+  enum rfd_mode\n+    {\n+      RFD_NONE,\t\t// Only look at current block cache.\n+      RFD_READ_ONLY,\t// Scan DOM tree, do not write to cache.\n+      RFD_FILL\t\t// Scan DOM tree, updating important nodes.\n+    };\n+  bool range_from_dom (irange &r, tree name, basic_block bb, enum rfd_mode);\n   void range_of_def (irange &r, tree name, basic_block bb = NULL);\n-  void entry_range (irange &r, tree expr, basic_block bb);\n-  void exit_range (irange &r, tree expr, basic_block bb);\n+  void entry_range (irange &r, tree expr, basic_block bb, enum rfd_mode);\n+  void exit_range (irange &r, tree expr, basic_block bb, enum rfd_mode);\n+  bool edge_range (irange &r, edge e, tree name, enum rfd_mode);\n \n   vec<basic_block> m_workback;\n   class update_list *m_update;"}]}