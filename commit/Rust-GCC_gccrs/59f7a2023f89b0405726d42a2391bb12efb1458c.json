{"sha": "59f7a2023f89b0405726d42a2391bb12efb1458c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlmN2EyMDIzZjg5YjA0MDU3MjZkNDJhMjM5MWJiMTJlZmIxNDU4Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-07-13T16:31:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-07-13T16:31:23Z"}, "message": "fold-const.c (fold_binary): When comparing two simple ADDR_EXPR expressions...\n\n        * fold-const.c (fold_binary): When comparing two simple ADDR_EXPR\n        expressions, test their _DECL operands for pointer equality rather\n        than using operand_equal_p.\n\n        * gcc.dg/tree-ssa/pr22321.c: New test.\n\nFrom-SVN: r101974", "tree": {"sha": "74485a550b11de6d6b4c0f96a5a04ad88b50adb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74485a550b11de6d6b4c0f96a5a04ad88b50adb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59f7a2023f89b0405726d42a2391bb12efb1458c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f7a2023f89b0405726d42a2391bb12efb1458c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f7a2023f89b0405726d42a2391bb12efb1458c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f7a2023f89b0405726d42a2391bb12efb1458c/comments", "author": null, "committer": null, "parents": [{"sha": "4969c0d82c8bc9a2815883e3c968d81287c83483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4969c0d82c8bc9a2815883e3c968d81287c83483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4969c0d82c8bc9a2815883e3c968d81287c83483"}], "stats": {"total": 50, "additions": 47, "deletions": 3}, "files": [{"sha": "622cec8fd94caa4ecbdbac3095321efd7c86866c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59f7a2023f89b0405726d42a2391bb12efb1458c", "patch": "@@ -1,3 +1,9 @@\n+2005-07-13  Jeff Law  <law@redhat.com>\n+\n+\t* fold-const.c (fold_binary): When comparing two simple ADDR_EXPR\n+\texpressions, test their _DECL operands for pointer equality rather\n+\tthan using operand_equal_p.\n+\n 2005-07-13  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/alpha/linux.h (TARGET_HAS_F_SETLKW): Renamed to ..."}, {"sha": "3bc27eb5d3bdbad05fe3af29429872e579817c32", "filename": "gcc/fold-const.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=59f7a2023f89b0405726d42a2391bb12efb1458c", "patch": "@@ -8757,9 +8757,23 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && ! lookup_attribute (\"alias\",\n \t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg1, 0)))\n \t  && ! DECL_EXTERNAL (TREE_OPERAND (arg1, 0)))\n-\treturn constant_boolean_node (operand_equal_p (arg0, arg1, 0)\n-\t\t\t\t      ? code == EQ_EXPR : code != EQ_EXPR,\n-\t\t\t\t      type);\n+\t{\n+\t  /* We know that we're looking at the address of two\n+\t     non-weak, unaliased, static _DECL nodes.\n+\n+\t     It is both wasteful and incorrect to call operand_equal_p\n+\t     to compare the two ADDR_EXPR nodes.  It is wasteful in that\n+\t     all we need to do is test pointer equality for the arguments\n+\t     to the two ADDR_EXPR nodes.  It is incorrect to use\n+\t     operand_equal_p as that function is NOT equivalent to a\n+\t     C equality test.  It can in fact return false for two\n+\t     objects which would test as equal using the C equality\n+\t     operator.  */\n+\t  bool equal = TREE_OPERAND (arg0, 0) == TREE_OPERAND (arg1, 0);\n+\t  return constant_boolean_node (equal\n+\t\t\t\t        ? code == EQ_EXPR : code != EQ_EXPR,\n+\t\t\t\t        type);\n+\t}\n \n       /* If this is a comparison of two exprs that look like an\n \t ARRAY_REF of the same object, then we can fold this to a"}, {"sha": "145830f8c5d1d68843725bba3ee353486eab55d7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=59f7a2023f89b0405726d42a2391bb12efb1458c", "patch": "@@ -1,3 +1,7 @@\n+2005-07-13  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/pr22321.c: New test\n+\n 2005-07-13  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR tree-optimization/21921"}, {"sha": "64a94ab2d76b21578232dbb77526a81210c743aa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22321.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22321.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f7a2023f89b0405726d42a2391bb12efb1458c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22321.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22321.c?ref=59f7a2023f89b0405726d42a2391bb12efb1458c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-tree-vrp -fno-tree-copy-prop -fno-tree-ccp -fdump-tree-optimized\" } */\n+\n+\n+volatile int x;\n+\n+int main ()\n+{\n+  volatile int *vip;\n+  vip = &x;\n+  volatile int *cvip;\n+  cvip = vip;\n+\n+  if (vip != cvip) return -1;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+"}]}