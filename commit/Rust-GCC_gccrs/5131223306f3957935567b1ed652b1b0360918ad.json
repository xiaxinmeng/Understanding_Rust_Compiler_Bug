{"sha": "5131223306f3957935567b1ed652b1b0360918ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEzMTIyMzMwNmYzOTU3OTM1NTY3YjFlZDY1MmIxYjAzNjA5MThhZA==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-06-16T12:08:37Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-06-16T12:08:37Z"}, "message": "tree-vectorizer.h (vect_recog_func_ptr): Change the first argument to be a VEC of statements.\n\n\n        * tree-vectorizer.h (vect_recog_func_ptr): Change the first\n        argument to be a VEC of statements.\n        * tree-vect-loop.c (vect_determine_vectorization_factor):\n        Remove the assert that pattern statements have to have their\n        vector type set.\n        * tree-vect-patterns.c (vect_recog_widen_sum_pattern):\n        Change the first argument to be a VEC of statements.  Update\n        documentation.\n        (vect_recog_dot_prod_pattern, vect_recog_pow_pattern): Likewise.\n        (vect_handle_widen_mult_by_const): New function.\n        (vect_recog_widen_mult_pattern):  Change the first argument to\n        be a VEC of statements.  Update documentation.  Check that the\n        constant is INTEGER_CST.  Support multiplication by a constant\n        that fits an intermediate type - call\n        vect_handle_widen_mult_by_const.\n        (vect_pattern_recog_1): Update vect_recog_func_ptr and its\n        call.  Handle additional pattern statements if necessary.\n\nFrom-SVN: r175102", "tree": {"sha": "098eab87cbc4dbcae32e5b5c691afee994cab4c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/098eab87cbc4dbcae32e5b5c691afee994cab4c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5131223306f3957935567b1ed652b1b0360918ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5131223306f3957935567b1ed652b1b0360918ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5131223306f3957935567b1ed652b1b0360918ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5131223306f3957935567b1ed652b1b0360918ad/comments", "author": null, "committer": null, "parents": [{"sha": "9c9eacb9b4d7b9f2866da3352e12722aedc846df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c9eacb9b4d7b9f2866da3352e12722aedc846df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c9eacb9b4d7b9f2866da3352e12722aedc846df"}], "stats": {"total": 350, "additions": 275, "deletions": 75}, "files": [{"sha": "cf413e31dbfeda99a0557d09b32f02763535fa8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5131223306f3957935567b1ed652b1b0360918ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5131223306f3957935567b1ed652b1b0360918ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5131223306f3957935567b1ed652b1b0360918ad", "patch": "@@ -1,3 +1,23 @@\n+2011-06-16  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vectorizer.h (vect_recog_func_ptr): Change the first\n+\targument to be a VEC of statements.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor):\n+\tRemove the assert that pattern statements have to have their\n+\tvector type set.\n+\t* tree-vect-patterns.c (vect_recog_widen_sum_pattern):\n+\tChange the first argument to be a VEC of statements.  Update\n+\tdocumentation.\n+\t(vect_recog_dot_prod_pattern, vect_recog_pow_pattern): Likewise.\n+\t(vect_handle_widen_mult_by_const): New function.\n+\t(vect_recog_widen_mult_pattern):  Change the first argument to\n+\tbe a VEC of statements.  Update documentation.  Check that the\n+\tconstant is INTEGER_CST.  Support multiplication by a constant\n+\tthat fits an intermediate type - call\n+\tvect_handle_widen_mult_by_const.\n+\t(vect_pattern_recog_1): Update vect_recog_func_ptr and its\n+\tcall.  Handle additional pattern statements if necessary.\n+\n 2011-06-16  Nick Clifton  <nickc@redhat.com>\n \n \tPR target/49427"}, {"sha": "84e0d93999ba8f0d84f9a40ec7ad90eb2aeca893", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5131223306f3957935567b1ed652b1b0360918ad", "patch": "@@ -1,3 +1,7 @@\n+2011-06-16  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/vect-widen-mult-half-u8.c: New test.\n+\n 2011-06-16  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/49417"}, {"sha": "39078dfc4f3abc0bc4a98591e1fd98fb8b2a8bc6", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-half-u8.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-half-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-half-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-half-u8.c?ref=5131223306f3957935567b1ed652b1b0360918ad", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+#include <stdlib.h>\n+\n+#define N 32\n+#define COEF 32470\n+\n+unsigned char in[N];\n+int out[N];\n+\n+__attribute__ ((noinline)) void\n+foo ()\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    out[i] = in[i] * COEF;\n+}\n+\n+__attribute__ ((noinline)) void\n+bar ()\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    out[i] = COEF * in[i];\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    if (out[i] != in[i] * COEF)\n+      abort ();\n+\n+  bar ();\n+\n+  for (i = 0; i < N; i++)\n+    if (out[i] != in[i] * COEF)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "27305f3db66b324fa77a1dac04fd1c564df1f18e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=5131223306f3957935567b1ed652b1b0360918ad", "patch": "@@ -311,9 +311,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    }\n \t  else\n \t    {\n-\t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info)\n-\t\t\t  && !is_pattern_stmt_p (stmt_info));\n-\n+\t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n \t      scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{"}, {"sha": "ce941425e0c0137afaeed3bccf0c24569357c329", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 190, "deletions": 71, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=5131223306f3957935567b1ed652b1b0360918ad", "patch": "@@ -39,10 +39,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n \n /* Pattern recognition functions  */\n-static gimple vect_recog_widen_sum_pattern (gimple *, tree *, tree *);\n-static gimple vect_recog_widen_mult_pattern (gimple *, tree *, tree *);\n-static gimple vect_recog_dot_prod_pattern (gimple *, tree *, tree *);\n-static gimple vect_recog_pow_pattern (gimple *, tree *, tree *);\n+static gimple vect_recog_widen_sum_pattern (VEC (gimple, heap) **, tree *,\n+\t\t\t\t\t    tree *);\n+static gimple vect_recog_widen_mult_pattern (VEC (gimple, heap) **, tree *,\n+\t\t\t\t\t     tree *);\n+static gimple vect_recog_dot_prod_pattern (VEC (gimple, heap) **, tree *,\n+\t\t\t\t\t   tree *);\n+static gimple vect_recog_pow_pattern (VEC (gimple, heap) **, tree *, tree *);\n static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n@@ -142,9 +145,9 @@ vect_recog_temp_ssa_var (tree type, gimple stmt)\n \n    Input:\n \n-   * LAST_STMT: A stmt from which the pattern search begins. In the example,\n-   when this function is called with S7, the pattern {S3,S4,S5,S6,S7} will be\n-   detected.\n+   * STMTS: Contains a stmt from which the pattern search begins.  In the\n+   example, when this function is called with S7, the pattern {S3,S4,S5,S6,S7}\n+   will be detected.\n \n    Output:\n \n@@ -165,23 +168,24 @@ vect_recog_temp_ssa_var (tree type, gimple stmt)\n          inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple\n-vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n+vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n+\t\t\t     tree *type_out)\n {\n-  gimple stmt;\n+  gimple stmt, last_stmt = VEC_index (gimple, *stmts, 0);\n   tree oprnd0, oprnd1;\n   tree oprnd00, oprnd01;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (*last_stmt);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   tree type, half_type;\n   gimple pattern_stmt;\n   tree prod_type;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n   tree var;\n \n-  if (!is_gimple_assign (*last_stmt))\n+  if (!is_gimple_assign (last_stmt))\n     return NULL;\n \n-  type = gimple_expr_type (*last_stmt);\n+  type = gimple_expr_type (last_stmt);\n \n   /* Look for the following pattern\n           DX = (TYPE1) X;\n@@ -207,7 +211,7 @@ vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (*last_stmt) != PLUS_EXPR)\n+  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n     return NULL;\n \n   if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n@@ -228,12 +232,12 @@ vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n \n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n         return NULL;\n-      oprnd0 = gimple_assign_rhs1 (*last_stmt);\n-      oprnd1 = gimple_assign_rhs2 (*last_stmt);\n+      oprnd0 = gimple_assign_rhs1 (last_stmt);\n+      oprnd1 = gimple_assign_rhs2 (last_stmt);\n       if (!types_compatible_p (TREE_TYPE (oprnd0), type)\n \t  || !types_compatible_p (TREE_TYPE (oprnd1), type))\n         return NULL;\n-      stmt = *last_stmt;\n+      stmt = last_stmt;\n \n       if (widened_name_p (oprnd0, stmt, &half_type, &def_stmt, true))\n         {\n@@ -244,7 +248,7 @@ vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n         half_type = type;\n     }\n \n-  /* So far so good.  Since *last_stmt was detected as a (summation) reduction,\n+  /* So far so good.  Since last_stmt was detected as a (summation) reduction,\n      we know that oprnd1 is the reduction variable (defined by a loop-header\n      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n      Left to check that oprnd0 is defined by a (widen_)mult_expr  */\n@@ -319,11 +323,80 @@ vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n \n   /* We don't allow changing the order of the computation in the inner-loop\n      when doing outer-loop vectorization.  */\n-  gcc_assert (!nested_in_vect_loop_p (loop, *last_stmt));\n+  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n \n   return pattern_stmt;\n }\n \n+\n+/* Handle two cases of multiplication by a constant.  The first one is when\n+   the constant, CONST_OPRND, fits the type (HALF_TYPE) of the second\n+   operand (OPRND).  In that case, we can peform widen-mult from HALF_TYPE to\n+   TYPE.\n+\n+   Otherwise, if the type of the result (TYPE) is at least 4 times bigger than\n+   HALF_TYPE, and CONST_OPRND fits an intermediate type (2 times smaller than\n+   TYPE), we can perform widen-mult from the intermediate type to TYPE and\n+   replace a_T = (TYPE) a_t; with a_it - (interm_type) a_t;  */\n+\n+static bool\n+vect_handle_widen_mult_by_const (tree const_oprnd, tree *oprnd,\n+   \t\t\t         VEC (gimple, heap) **stmts, tree type,\n+\t\t\t         tree *half_type, gimple def_stmt)\n+{\n+  tree new_type, new_oprnd, tmp;\n+  gimple new_stmt;\n+\n+  if (int_fits_type_p (const_oprnd, *half_type))\n+    {\n+      /* CONST_OPRND is a constant of HALF_TYPE.  */\n+      *oprnd = gimple_assign_rhs1 (def_stmt);\n+      return true;\n+    }\n+\n+  if (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 4)\n+      || !vinfo_for_stmt (def_stmt))\n+    return false;\n+\n+  /* TYPE is 4 times bigger than HALF_TYPE, try widen-mult for\n+     a type 2 times bigger than HALF_TYPE.  */\n+  new_type = build_nonstandard_integer_type (TYPE_PRECISION (type) / 2,\n+                                             TYPE_UNSIGNED (type));\n+  if (!int_fits_type_p (const_oprnd, new_type))\n+    return false;\n+\n+  /* Use NEW_TYPE for widen_mult.  */\n+  if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)))\n+    {\n+      new_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n+      /* Check if the already created pattern stmt is what we need.  */\n+      if (!is_gimple_assign (new_stmt)\n+          || gimple_assign_rhs_code (new_stmt) != NOP_EXPR\n+          || TREE_TYPE (gimple_assign_lhs (new_stmt)) != new_type)\n+        return false;\n+\n+      *oprnd = gimple_assign_lhs (new_stmt);\n+    }\n+  else\n+    {\n+      /* Create a_T = (NEW_TYPE) a_t;  */\n+      *oprnd = gimple_assign_rhs1 (def_stmt);\n+      tmp = create_tmp_var (new_type, NULL);\n+      add_referenced_var (tmp);\n+      new_oprnd = make_ssa_name (tmp, NULL);\n+      new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd, *oprnd,\n+\t\t\t\t\t       NULL_TREE);\n+      SSA_NAME_DEF_STMT (new_oprnd) = new_stmt;\n+      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n+      VEC_safe_push (gimple, heap, *stmts, def_stmt);\n+      *oprnd = new_oprnd;\n+    }\n+\n+  *half_type = new_type;\n+  return true;\n+}\n+\n+\n /* Function vect_recog_widen_mult_pattern\n \n    Try to find the following pattern:\n@@ -361,11 +434,30 @@ vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n      S3  a_T = (TYPE) a_t;\n      S5  prod_T = a_T * CONST;\n \n-   Input:\n+   A special case of multiplication by constants is when 'TYPE' is 4 times\n+   bigger than 'type', but CONST fits an intermediate type 2 times smaller\n+   than 'TYPE'.  In that case we create an additional pattern stmt for S3\n+   to create a variable of the intermediate type, and perform widen-mult\n+   on the intermediate type as well:\n+\n+     type a_t;\n+     interm_type a_it;\n+     TYPE a_T, prod_T,  prod_T';\n+\n+     S1  a_t = ;\n+     S3  a_T = (TYPE) a_t;\n+           '--> a_it = (interm_type) a_t;\n+     S5  prod_T = a_T * CONST;\n+           '--> prod_T' = a_it w* CONST;\n \n-   * LAST_STMT: A stmt from which the pattern search begins.  In the example,\n-   when this function is called with S5, the pattern {S3,S4,S5,(S6)} is\n-   detected.\n+   Input/Output:\n+\n+   * STMTS: Contains a stmt from which the pattern search begins.  In the\n+   example, when this function is called with S5, the pattern {S3,S4,S5,(S6)}\n+   is detected.  In case of unsigned widen-mult, the original stmt (S5) is\n+   replaced with S6 in STMTS.  In case of multiplication by a constant\n+   of an intermediate type (the last case above), STMTS also contains S3\n+   (inserted before S5).\n \n    Output:\n \n@@ -379,10 +471,10 @@ vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n */\n \n static gimple\n-vect_recog_widen_mult_pattern (gimple *last_stmt,\n-\t\t\t       tree *type_in,\n-\t\t\t       tree *type_out)\n+vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n+                               tree *type_in, tree *type_out)\n {\n+  gimple last_stmt = VEC_pop (gimple, *stmts);\n   gimple def_stmt0, def_stmt1;\n   tree oprnd0, oprnd1;\n   tree type, half_type0, half_type1;\n@@ -395,27 +487,27 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n   VEC (tree, heap) *dummy_vec;\n   bool op0_ok, op1_ok;\n \n-  if (!is_gimple_assign (*last_stmt))\n+  if (!is_gimple_assign (last_stmt))\n     return NULL;\n \n-  type = gimple_expr_type (*last_stmt);\n+  type = gimple_expr_type (last_stmt);\n \n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (*last_stmt) != MULT_EXPR)\n+  if (gimple_assign_rhs_code (last_stmt) != MULT_EXPR)\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (*last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (*last_stmt);\n+  oprnd0 = gimple_assign_rhs1 (last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (last_stmt);\n   if (!types_compatible_p (TREE_TYPE (oprnd0), type)\n       || !types_compatible_p (TREE_TYPE (oprnd1), type))\n     return NULL;\n \n   /* Check argument 0.  */\n-  op0_ok = widened_name_p (oprnd0, *last_stmt, &half_type0, &def_stmt0, false);\n+  op0_ok = widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0, false);\n   /* Check argument 1.  */\n-  op1_ok = widened_name_p (oprnd1, *last_stmt, &half_type1, &def_stmt1, false);\n+  op1_ok = widened_name_p (oprnd1, last_stmt, &half_type1, &def_stmt1, false);\n \n   /* In case of multiplication by a constant one of the operands may not match\n      the pattern, but not both.  */\n@@ -429,29 +521,21 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n     }\t       \n   else if (!op0_ok)\n     {\n-      if (CONSTANT_CLASS_P (oprnd0)\n+      if (TREE_CODE (oprnd0) == INTEGER_CST\n \t  && TREE_CODE (half_type1) == INTEGER_TYPE\n-\t  && tree_int_cst_lt (oprnd0, TYPE_MAXVAL (half_type1))\n-          && tree_int_cst_lt (TYPE_MINVAL (half_type1), oprnd0))\n-        {\n-\t  /* OPRND0 is a constant of HALF_TYPE1.  */\n- \t  half_type0 = half_type1;\n-          oprnd1 = gimple_assign_rhs1 (def_stmt1);\n-        }\n+          && vect_handle_widen_mult_by_const (oprnd0, &oprnd1, stmts, type,\n+\t\t\t\t \t      &half_type1, def_stmt1))\n+        half_type0 = half_type1;\n       else\n \treturn NULL;\n     }\n   else if (!op1_ok)\n     {\n-      if (CONSTANT_CLASS_P (oprnd1)\n+      if (TREE_CODE (oprnd1) == INTEGER_CST\n           && TREE_CODE (half_type0) == INTEGER_TYPE\n-          && tree_int_cst_lt (oprnd1, TYPE_MAXVAL (half_type0))\n-          && tree_int_cst_lt (TYPE_MINVAL (half_type0), oprnd1))\n-        {\n-\t  /* OPRND1 is a constant of HALF_TYPE0.  */\n-          half_type1 = half_type0;\n-          oprnd0 = gimple_assign_rhs1 (def_stmt0);\n-        }\n+          && vect_handle_widen_mult_by_const (oprnd1, &oprnd0, stmts, type,\n+\t\t\t\t\t      &half_type0, def_stmt0))\n+        half_type1 = half_type0;\n       else\n         return NULL;\n     }\n@@ -461,7 +545,7 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n      Use unsigned TYPE as the type for WIDEN_MULT_EXPR.  */\n   if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n     {\n-      tree lhs = gimple_assign_lhs (*last_stmt), use_lhs;\n+      tree lhs = gimple_assign_lhs (last_stmt), use_lhs;\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n       int nuses = 0;\n@@ -489,7 +573,7 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n         return NULL;\n \n       type = use_type;\n-      *last_stmt = use_stmt;\n+      last_stmt = use_stmt;\n     }\n \n   if (!types_compatible_p (half_type0, half_type1))\n@@ -504,7 +588,7 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n   vectype_out = get_vectype_for_scalar_type (type);\n   if (!vectype\n       || !vectype_out\n-      || !supportable_widening_operation (WIDEN_MULT_EXPR, *last_stmt,\n+      || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n \t\t\t\t\t  vectype_out, vectype,\n \t\t\t\t\t  &dummy, &dummy, &dummy_code,\n \t\t\t\t\t  &dummy_code, &dummy_int, &dummy_vec))\n@@ -522,6 +606,7 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n \n+  VEC_safe_push (gimple, heap, *stmts, last_stmt);\n   return pattern_stmt;\n }\n \n@@ -553,16 +638,18 @@ vect_recog_widen_mult_pattern (gimple *last_stmt,\n */\n \n static gimple\n-vect_recog_pow_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n+vect_recog_pow_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n+\t\t\ttree *type_out)\n {\n+  gimple last_stmt = VEC_index (gimple, *stmts, 0);\n   tree fn, base, exp = NULL;\n   gimple stmt;\n   tree var;\n \n-  if (!is_gimple_call (*last_stmt) || gimple_call_lhs (*last_stmt) == NULL)\n+  if (!is_gimple_call (last_stmt) || gimple_call_lhs (last_stmt) == NULL)\n     return NULL;\n \n-  fn = gimple_call_fndecl (*last_stmt);\n+  fn = gimple_call_fndecl (last_stmt);\n   if (fn == NULL_TREE || DECL_BUILT_IN_CLASS (fn) != BUILT_IN_NORMAL)\n    return NULL;\n \n@@ -572,8 +659,8 @@ vect_recog_pow_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n     case BUILT_IN_POWI:\n     case BUILT_IN_POWF:\n     case BUILT_IN_POW:\n-      base = gimple_call_arg (*last_stmt, 0);\n-      exp = gimple_call_arg (*last_stmt, 1);\n+      base = gimple_call_arg (last_stmt, 0);\n+      exp = gimple_call_arg (last_stmt, 1);\n       if (TREE_CODE (exp) != REAL_CST\n \t  && TREE_CODE (exp) != INTEGER_CST)\n         return NULL;\n@@ -665,21 +752,22 @@ vect_recog_pow_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n \t inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple\n-vect_recog_widen_sum_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n+vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n+\t\t\t      tree *type_out)\n {\n-  gimple stmt;\n+  gimple stmt, last_stmt = VEC_index (gimple, *stmts, 0);\n   tree oprnd0, oprnd1;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (*last_stmt);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   tree type, half_type;\n   gimple pattern_stmt;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n   tree var;\n \n-  if (!is_gimple_assign (*last_stmt))\n+  if (!is_gimple_assign (last_stmt))\n     return NULL;\n \n-  type = gimple_expr_type (*last_stmt);\n+  type = gimple_expr_type (last_stmt);\n \n   /* Look for the following pattern\n           DX = (TYPE) X;\n@@ -691,25 +779,25 @@ vect_recog_widen_sum_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (*last_stmt) != PLUS_EXPR)\n+  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n     return NULL;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (*last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (*last_stmt);\n+  oprnd0 = gimple_assign_rhs1 (last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (last_stmt);\n   if (!types_compatible_p (TREE_TYPE (oprnd0), type)\n       || !types_compatible_p (TREE_TYPE (oprnd1), type))\n     return NULL;\n \n-  /* So far so good.  Since *last_stmt was detected as a (summation) reduction,\n+  /* So far so good.  Since last_stmt was detected as a (summation) reduction,\n      we know that oprnd1 is the reduction variable (defined by a loop-header\n      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n      Left to check that oprnd0 is defined by a cast from type 'type' to type\n      'TYPE'.  */\n \n-  if (!widened_name_p (oprnd0, *last_stmt, &half_type, &stmt, true))\n+  if (!widened_name_p (oprnd0, last_stmt, &half_type, &stmt, true))\n     return NULL;\n \n   oprnd0 = gimple_assign_rhs1 (stmt);\n@@ -730,7 +818,7 @@ vect_recog_widen_sum_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n \n   /* We don't allow changing the order of the computation in the inner-loop\n      when doing outer-loop vectorization.  */\n-  gcc_assert (!nested_in_vect_loop_p (loop, *last_stmt));\n+  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n \n   return pattern_stmt;\n }\n@@ -760,7 +848,7 @@ vect_recog_widen_sum_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n \n static void\n vect_pattern_recog_1 (\n-\tgimple (* vect_recog_func) (gimple *, tree *, tree *),\n+\tgimple (* vect_recog_func) (VEC (gimple, heap) **, tree *, tree *),\n \tgimple_stmt_iterator si)\n {\n   gimple stmt = gsi_stmt (si), pattern_stmt;\n@@ -772,12 +860,14 @@ vect_pattern_recog_1 (\n   enum tree_code code;\n   int i;\n   gimple next;\n+  VEC (gimple, heap) *stmts_to_replace = VEC_alloc (gimple, heap, 1);\n \n-  pattern_stmt = (* vect_recog_func) (&stmt, &type_in, &type_out);\n+  VEC_quick_push (gimple, stmts_to_replace, stmt);\n+  pattern_stmt = (* vect_recog_func) (&stmts_to_replace, &type_in, &type_out);\n   if (!pattern_stmt)\n     return;\n \n-  si = gsi_for_stmt (stmt);\n+  stmt = VEC_last (gimple, stmts_to_replace);\n   stmt_info = vinfo_for_stmt (stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n  \n@@ -847,6 +937,35 @@ vect_pattern_recog_1 (\n   FOR_EACH_VEC_ELT (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, next)\n     if (next == stmt)\n       VEC_ordered_remove (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i); \n+\n+  /* In case of widen-mult by a constant, it is possible that an additional\n+     pattern stmt is created and inserted in STMTS_TO_REPLACE.  We create a\n+     stmt_info for it, and mark the relevant statements.  */\n+  for (i = 0; VEC_iterate (gimple, stmts_to_replace, i, stmt)\n+              && (unsigned) i < (VEC_length (gimple, stmts_to_replace) - 1);\n+       i++)\n+    {\n+      stmt_info = vinfo_for_stmt (stmt);\n+      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"additional pattern stmt: \");\n+          print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n+        }\n+\n+      set_vinfo_for_stmt (pattern_stmt,\n+                      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n+      gimple_set_bb (pattern_stmt, gimple_bb (stmt));\n+      pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n+\n+      STMT_VINFO_RELATED_STMT (pattern_stmt_info) = stmt;\n+      STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n+        = STMT_VINFO_DEF_TYPE (stmt_info);\n+      STMT_VINFO_VECTYPE (pattern_stmt_info) = STMT_VINFO_VECTYPE (stmt_info);\n+      STMT_VINFO_IN_PATTERN_P (stmt_info) = true;\n+    }\n+\n+  VEC_free (gimple, heap, stmts_to_replace);\n }\n \n \n@@ -923,7 +1042,7 @@ vect_pattern_recog (loop_vec_info loop_vinfo)\n   unsigned int nbbs = loop->num_nodes;\n   gimple_stmt_iterator si;\n   unsigned int i, j;\n-  gimple (* vect_recog_func_ptr) (gimple *, tree *, tree *);\n+  gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_pattern_recog ===\");"}, {"sha": "3f3350320fd6a8e863bb55d29d098dc1f6c3b95c", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5131223306f3957935567b1ed652b1b0360918ad/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5131223306f3957935567b1ed652b1b0360918ad", "patch": "@@ -896,7 +896,7 @@ extern void vect_slp_transform_bb (basic_block);\n /* Pattern recognition functions.\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n-typedef gimple (* vect_recog_func_ptr) (gimple *, tree *, tree *);\n+typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n #define NUM_PATTERNS 4\n void vect_pattern_recog (loop_vec_info);\n "}]}