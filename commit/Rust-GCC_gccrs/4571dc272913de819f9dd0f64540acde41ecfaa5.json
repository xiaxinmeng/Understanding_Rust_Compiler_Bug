{"sha": "4571dc272913de819f9dd0f64540acde41ecfaa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU3MWRjMjcyOTEzZGU4MTlmOWRkMGY2NDU0MGFjZGU0MWVjZmFhNQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-01-22T04:18:41Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-01-22T04:18:41Z"}, "message": "cpphash.c (change_newlines): Delete function.\n\n\t* cpphash.c (change_newlines): Delete function.\n\t(struct argdata): Delete 'newlines' and 'use_count' fields.\n\t(macroexpand): Remove code referencing those fields.\n\nFrom-SVN: r31559", "tree": {"sha": "42b207ca79ba57c666b2f7a2c539c421348dc791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b207ca79ba57c666b2f7a2c539c421348dc791"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4571dc272913de819f9dd0f64540acde41ecfaa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4571dc272913de819f9dd0f64540acde41ecfaa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4571dc272913de819f9dd0f64540acde41ecfaa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4571dc272913de819f9dd0f64540acde41ecfaa5/comments", "author": null, "committer": null, "parents": [{"sha": "8694a43cced5e6b11ddd3cc13a8c28f6b3cefddb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8694a43cced5e6b11ddd3cc13a8c28f6b3cefddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8694a43cced5e6b11ddd3cc13a8c28f6b3cefddb"}], "stats": {"total": 83, "additions": 10, "deletions": 73}, "files": [{"sha": "f3559350f3a9b7f884bdba0e6efc5f396f4f1145", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4571dc272913de819f9dd0f64540acde41ecfaa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4571dc272913de819f9dd0f64540acde41ecfaa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4571dc272913de819f9dd0f64540acde41ecfaa5", "patch": "@@ -1,3 +1,9 @@\n+2000-01-21  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c (change_newlines): Delete function.\n+\t(struct argdata): Delete 'newlines' and 'use_count' fields.\n+\t(macroexpand): Remove code referencing those fields.\n+\n 2000-01-22  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.c (loops_info): New variable."}, {"sha": "8a0c887e5803ec8b00f36f2a9dce991da64d81a9", "filename": "gcc/cpphash.c", "status": "modified", "additions": 4, "deletions": 73, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4571dc272913de819f9dd0f64540acde41ecfaa5/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4571dc272913de819f9dd0f64540acde41ecfaa5/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=4571dc272913de819f9dd0f64540acde41ecfaa5", "patch": "@@ -30,7 +30,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n static int comp_def_part\t PARAMS ((int, U_CHAR *, int, U_CHAR *,\n \t\t\t\t\t  int, int));\n-static int change_newlines\t PARAMS ((U_CHAR *, int));\n static void push_macro_expansion PARAMS ((cpp_reader *,\n \t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n static int unsafe_chars\t\t PARAMS ((int, int));\n@@ -74,10 +73,7 @@ static DEFINITION *collect_expansion PARAMS ((cpp_reader *, U_CHAR *, U_CHAR *,\n    `expanded' points to the argument's macro-expansion\n    (its length is `expand_length').\n    `stringified_length' is the length the argument would have\n-   if stringified.\n-   `use_count' is the number of times this macro arg is substituted\n-   into the macro.  If the actual use count exceeds 10, \n-   the value stored is 10.  */\n+   if stringified.  */\n \n /* raw and expanded are relative to ARG_BASE */\n #define ARG_BASE ((pfile)->token_buffer)\n@@ -88,8 +84,6 @@ struct argdata\n   long raw, expanded, stringified;\n   int raw_length, expand_length;\n   int stringified_length;\n-  char newlines;\n-  char use_count;\n };\n \n \n@@ -313,7 +307,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n      Leading and trailing whitespace chars need 2 bytes each.\n      Each other input char may or may not need 1 byte,\n      so this is an upper bound.  The extra 5 are for invented\n-     leading and trailing newline-marker and final null.  */\n+     leading and trailing escape-marker and final null.  */\n   maxsize = (sizeof (DEFINITION)\n \t     + (limit - p) + 5);\n   defn = (DEFINITION *) xcalloc (1, maxsize);\n@@ -833,52 +827,6 @@ macarg (pfile, rest_args)\n   return token;\n }\n \f\n-/* Turn newlines to spaces in the string of length LENGTH at START,\n-   except inside of string constants.\n-   The string is copied into itself with its beginning staying fixed.  */\n-\n-static int\n-change_newlines (start, length)\n-     U_CHAR *start;\n-     int length;\n-{\n-  register U_CHAR *ibp;\n-  register U_CHAR *obp;\n-  register U_CHAR *limit;\n-  register int c;\n-\n-  ibp = start;\n-  limit = start + length;\n-  obp = start;\n-\n-  while (ibp < limit)\n-    {\n-      *obp++ = c = *ibp++;\n-      switch (c)\n-\t{\n-\n-\tcase '\\'':\n-\tcase '\\\"':\n-\t  /* Notice and skip strings, so that we don't\n-\t     delete newlines in them.  */\n-\t  {\n-\t    int quotec = c;\n-\t    while (ibp < limit)\n-\t      {\n-\t\t*obp++ = c = *ibp++;\n-\t\tif (c == quotec)\n-\t\t  break;\n-\t\tif (c == '\\n' && quotec == '\\'')\n-\t\t  break;\n-\t      }\n-\t  }\n-\t  break;\n-\t}\n-    }\n-\n-  return obp - start;\n-}\n-\f\n \n static struct tm *\n timestamp (pfile)\n@@ -1096,7 +1044,6 @@ macroexpand (pfile, hp)\n \t  args[i].raw = args[i].expanded = 0;\n \t  args[i].raw_length = 0;\n \t  args[i].expand_length = args[i].stringified_length = -1;\n-\t  args[i].use_count = 0;\n \t}\n \n       /* Parse all the macro args that are supplied.  I counts them.\n@@ -1119,7 +1066,6 @@ macroexpand (pfile, hp)\n \t      args[i].raw = CPP_WRITTEN (pfile);\n \t      token = macarg (pfile, rest_args);\n \t      args[i].raw_length = CPP_WRITTEN (pfile) - args[i].raw;\n-\t      args[i].newlines = 0;\t/* FIXME */\n \t    }\n \t  else\n \t    token = macarg (pfile, 0);\n@@ -1281,7 +1227,7 @@ macroexpand (pfile, hp)\n \t      xbuf_len += args[ap->argno].stringified_length;\n \t    }\n \t  else if (ap->raw_before || ap->raw_after || CPP_TRADITIONAL (pfile))\n-\t    /* Add 4 for two newline-space markers to prevent\n+\t    /* Add 4 for two \\r-space markers to prevent\n \t       token concatenation.  */\n \t    xbuf_len += args[ap->argno].raw_length + 4;\n \t  else\n@@ -1299,12 +1245,10 @@ macroexpand (pfile, hp)\n \t\t    = CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n \t\t}\n \n-\t      /* Add 4 for two newline-space markers to prevent\n+\t      /* Add 4 for two \\r-space markers to prevent\n \t         token concatenation.  */\n \t      xbuf_len += args[ap->argno].expand_length + 4;\n \t    }\n-\t  if (args[ap->argno].use_count < 10)\n-\t    args[ap->argno].use_count++;\n \t}\n \n       xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n@@ -1416,19 +1360,6 @@ macroexpand (pfile, hp)\n \t\t  xbuf[totlen++] = '\\r';\n \t\t  xbuf[totlen++] = ' ';\n \t\t}\n-\n-\t      /* If a macro argument with newlines is used multiple times,\n-\t         then only expand the newlines once.  This avoids creating\n-\t         output lines which don't correspond to any input line,\n-\t         which confuses gdb and gcov.  */\n-\t      if (arg->use_count > 1 && arg->newlines > 0)\n-\t\t{\n-\t\t  /* Don't bother doing change_newlines for subsequent\n-\t\t     uses of arg.  */\n-\t\t  arg->use_count = 1;\n-\t\t  arg->expand_length\n-\t\t    = change_newlines (expanded, arg->expand_length);\n-\t\t}\n \t    }\n \n \t  if (totlen > xbuf_len)"}]}