{"sha": "e98e406fcc1d898d8d59d8a65395631e698be55e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk4ZTQwNmZjYzFkODk4ZDhkNTlkOGE2NTM5NTYzMWU2OThiZTU1ZQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-03-25T10:44:07Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-03-25T10:44:07Z"}, "message": "Add support for ARM's Thumb instruction set.\n\nFrom-SVN: r18822", "tree": {"sha": "ad9018810e7eb3c6870ac03f1343c3f5d53837fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad9018810e7eb3c6870ac03f1343c3f5d53837fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e98e406fcc1d898d8d59d8a65395631e698be55e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98e406fcc1d898d8d59d8a65395631e698be55e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98e406fcc1d898d8d59d8a65395631e698be55e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98e406fcc1d898d8d59d8a65395631e698be55e/comments", "author": null, "committer": null, "parents": [{"sha": "8cf619daa1ecd43d122b22621fde7f6271a9cb05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf619daa1ecd43d122b22621fde7f6271a9cb05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf619daa1ecd43d122b22621fde7f6271a9cb05"}], "stats": {"total": 5187, "additions": 5185, "deletions": 2}, "files": [{"sha": "d6817a0a78f8d30ac42d98aab6890379b3aec8de", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -1,3 +1,8 @@\n+Wed Mar 25 10:04:18 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* configure.in: Add thumb-coff target.\n+\t* config.sub: Add thumb-coff target.\n+\n Fri Mar 20 09:32:14 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* Makefile.in (install-gcc): Don't specify LANGUAGES here."}, {"sha": "75a0a134e1fc3304d01458d14a905ab0402be2e7", "filename": "config.sub", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/config.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/config.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config.sub?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -173,6 +173,9 @@ case $basic_machine in\n \tm88110 | m680[01234]0 | m683?2 | m68360 | z8k | v70 | h8500 | w65) # CYGNUS LOCAL\n \t\tbasic_machine=$basic_machine-unknown\n \t\t;;\n+\tthumb)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n \tmips64vr4300 | mips64vr4300el) # CYGNUS LOCAL jsmith/vr4300\n \t\tbasic_machine=$basic_machine-unknown\n \t\t;;\n@@ -216,6 +219,8 @@ case $basic_machine in\n \t\t;;\n \tm88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | h8500-* | d10v-*) # CYGNUS LOCAL\n \t\t;;\n+\tthumb-*)\n+\t\t;;\n \tmips64vr4300-* | mips64vr4300el-*) # CYGNUS LOCAL jsmith/vr4300\n \t\t;;\n \tmips64vr4100-* | mips64vr4100el-*) # CYGNUS LOCAL jsmith/vr4100"}, {"sha": "21c0b4b6e700b3f4805870328fc949a721fc1139", "filename": "configure.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -540,6 +540,9 @@ case \"${target}\" in\n   arm-*-riscix*)\n     noconfigdirs=\"$noconfigdirs ld target-libgloss\"\n     ;;\n+  thumb-*-coff)\n+    noconfigdirs=\"$noconfigdirs target-libgloss\"\n+    ;;\n   d10v-*-*)\n     noconfigdirs=\"$noconfigdirs target-librx target-libg++ target-libstdc++ target-libio target-libgloss\"\n     ;;"}, {"sha": "9e95bc21a1e69239fd0b142fc971ff678aec7874", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -1,3 +1,17 @@\n+Wed Mar 25 10:05:19 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.c: New File.  Support for ARM's Thumb\n+\tinstruction set. \n+\t* config/arm/thumb.h: New File.  Thumb definitions.\n+\t* config/arm/thumb.md: New File.  Thumb machine description.\n+\t* config/arm/tcoff.h: New File.  Thumb COFF support.\n+\t* config/arm/t-thumb: New File.  Thumb makefile fragment.\n+\t* config/arm/lib1thumb.asm: New File.  Thumb libgcc support functions.\n+\n+\t* configure.in: Add Thumb-coff target.\n+\t* configure: Add Thumb-coff target.\n+\t* config.sub: Add Thumb-coff target.\n+\n Wed Mar 25 10:30:32 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* loop.c (scan_loop): Initialize move_insn_first to zero."}, {"sha": "dd52e87aee8565d3ac1de3e70807ed38513f2f6a", "filename": "gcc/config.sub", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.sub?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -159,6 +159,9 @@ case $basic_machine in\n \t\t| sparc | sparclet | sparclite | sparc64 | v850)\n \t\tbasic_machine=$basic_machine-unknown\n \t\t;;\n+\tthumb | thumbel)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n \t# We use `pc' rather than `unknown'\n \t# because (1) that's what they normally are, and\n \t# (2) the word \"unknown\" tends to confuse beginning users."}, {"sha": "8df1ae79e7d3ffedb805abd4a0e9190c1879f17e", "filename": "gcc/config/arm/lib1thumb.asm", "status": "added", "additions": 702, "deletions": 0, "changes": 702, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Flib1thumb.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Flib1thumb.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1thumb.asm?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -0,0 +1,702 @@\n+@ libgcc1 routines for ARM cpu.\n+@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)\n+\n+/* Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\t.code\t 16\n+\t\n+#ifndef __USER_LABEL_PREFIX__\n+#error USER_LABEL_PREFIX not defined\n+#endif\n+\n+#define RET\tmov\tpc, lr\n+\t\n+/* ANSI concatenation macros.  */\n+\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+\n+/* Use the right prefix for global labels.  */\n+\n+#define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n+\n+work\t\t.req\tr4\t@ XXXX is this safe ?\n+\n+#ifdef L_udivsi3\n+\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+result\t\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t\n+\t.text\n+\t.globl SYM (__udivsi3)\n+\t.align 0\n+\t.thumb_func\n+SYM (__udivsi3):\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\t\n+\tpush\t{ work }\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\n+\t@ Load the constant 0x10000000 into our work register\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tbcs     Lbignum\n+\tcmp\tdivisor, dividend\n+\tbcs     Lbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit,  #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ Set work to 0x80000000\n+\tlsl\twork, #3\n+Loop2:\t\t\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, work\n+\tbcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tbcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit,  #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions, and note which bits\n+\t@ are done in the result.  On the final pass, this may subtract\n+\t@ too much from the dividend, but the result will be ok, since the\n+\t@ \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tbcc     Over1\n+\tsub\tdividend, dividend, divisor\n+\torr\tresult, result, curbit\n+Over1:\t\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbcc\tOver2\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #1\n+\torr\tresult, work\n+Over2:\t\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbcc\tOver3\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #2\n+\torr\tresult, work\n+Over3:\t\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #3\n+\torr\tresult, work\n+Over4:\t\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tbeq\tLgot_result\n+\tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n+\tbeq\tLgot_result\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+Lgot_result:\n+\tmov\tr0, result\n+\tpop\t{ work }\n+\tRET\n+\n+Ldiv0:\n+\tpush\t{ lr }\n+\tbl\tSYM (__div0)\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\n+#endif /* L_udivsi3 */\n+\n+#ifdef L_umodsi3\n+\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+overdone\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n+\t.globl SYM (__umodsi3)\n+\t.align 0\n+\t.thumb_func\n+SYM (__umodsi3):\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tmov\tcurbit, #1\n+\tcmp\tdividend, divisor\n+\tbcs\tOver1\n+\tRET\t\n+\n+Over1:\t\n+\t@ Load the constant 0x10000000 into our work register\n+\tpush\t{ work }\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tbcs\tLbignum\n+\tcmp\tdivisor, dividend\n+\tbcs\tLbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit, #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ Set work to 0x80000000\n+\tlsl\twork, #3\n+Loop2:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, work\n+\tbcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tbcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit, #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend, so keep track of which\n+\t@ subtractions are done, we can fix them up afterwards...\n+\tmov\toverdone, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tOver2\n+\tsub\tdividend, dividend, divisor\n+Over2:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbcc\tOver3\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over3:\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over4:\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbcc\tOver5\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over5:\n+\tmov\tip, curbit\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tbeq\tOver6\n+\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n+\tbeq\tOver6\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+\n+Over6:\t\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of \"overdone\".  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in ip.\n+\t@ If we terminated early, because dividend became zero,\n+\t@ then none of the below will match, since the bit in ip will not be\n+\t@ in the bottom nibble.\n+\n+\tmov\twork, #0xe\n+\tlsl\twork, #28\t\n+\tand\toverdone, work\n+\tbne\tOver7\n+\tpop\t{ work }\n+\tRET\t\t\t\t\t@ No fixups needed\n+Over7:\n+\tmov\tcurbit, ip\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver8\n+\tlsr\twork, divisor, #3\n+\tadd\tdividend, dividend, work\n+Over8:\n+\tmov\tcurbit, ip\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver9\n+\tlsr\twork, divisor, #2\n+\tadd\tdividend, dividend, work\n+Over9:\n+\tmov\tcurbit, ip\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver10\n+\tlsr\twork, divisor, #1\n+\tadd\tdividend, dividend, work\n+Over10:\n+\tpop\t{ work }\n+\tRET\t\n+\n+Ldiv0:\n+\tpush\t{ lr }\n+\tbl\tSYM (__div0)\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\n+#endif /* L_umodsi3 */\n+\n+#ifdef L_divsi3\n+\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+result\t\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n+\t.globl SYM (__divsi3)\n+\t.align 0\n+\t.thumb_func\n+SYM (__divsi3):\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\t\n+\tpush\t{ work }\n+\tmov\twork, dividend\n+\teor\twork, divisor\t\t@ Save the sign of the result.\n+\tmov\tip, work\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\tcmp\tdivisor, #0\n+\tbpl\tOver1\n+\tneg\tdivisor, divisor\t@ Loops below use unsigned.\n+Over1:\t\n+\tcmp\tdividend, #0\n+\tbpl\tOver2\n+\tneg\tdividend, dividend\n+Over2:\t\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tBcs\tLbignum\n+\tcmp\tdivisor, dividend\n+\tBcs\tLbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit, #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tlsl\twork, #3\n+Loop2:\t\t\n+\tcmp\tdivisor, work\n+\tBcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tBcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit, #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions, and note which bits\n+\t@ are done in the result.  On the final pass, this may subtract\n+\t@ too much from the dividend, but the result will be ok, since the\n+\t@ \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tBcc\tOver3\n+\tsub\tdividend, dividend, divisor\n+\torr\tresult, result, curbit\n+Over3:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tBcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #1\n+\torr\tresult, work\n+Over4:\t\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tBcc\tOver5\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #2\n+\torr\tresult, result, work\n+Over5:\t\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tBcc\tOver6\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #3\n+\torr\tresult, result, work\n+Over6:\t\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tBeq\tLgot_result\n+\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n+\tBeq\tLgot_result\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+\t\n+Lgot_result:\n+\tmov\tr0, result\n+\tmov\twork, ip\n+\tcmp\twork, #0\n+\tBpl\tOver7\n+\tneg\tr0, r0\n+Over7:\n+\tpop\t{ work }\n+\tRET\t\n+\n+Ldiv0:\n+\tpush\t{ lr }\n+\tbl\tSYM (__div0)\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\n+#endif /* L_divsi3 */\n+\n+#ifdef L_modsi3\n+\n+dividend\t.req\tr0\n+divisor\t\t.req\tr1\n+overdone\t.req\tr2\n+curbit\t\t.req\tr3\n+ip\t\t.req\tr12\n+sp\t\t.req\tr13\n+lr\t\t.req\tr14\n+pc\t\t.req\tr15\n+\t.text\n+\t.globl SYM (__modsi3)\n+\t.align 0\n+\t.thumb_func\n+SYM (__modsi3):\n+\tmov\tcurbit, #1\n+\tcmp\tdivisor, #0\n+\tbeq\tLdiv0\n+\tBpl\tOver1\n+\tneg\tdivisor, divisor\t\t@ Loops below use unsigned.\n+Over1:\t\n+\tpush\t{ work }\n+\t@ Need to save the sign of the dividend, unfortunately, we need\n+\t@ ip later on.  Must do this after saving the original value of\n+\t@ the work register, because we will pop this value off first.\n+\tpush\t{ dividend }\n+\tcmp\tdividend, #0\n+\tBpl\tOver2\n+\tneg\tdividend, dividend\n+Over2:\t\n+\tcmp\tdividend, divisor\n+\tbcc\tLgot_result\n+\tmov\twork, #1\n+\tlsl\twork, #28\n+Loop1:\n+\t@ Unless the divisor is very big, shift it up in multiples of\n+\t@ four bits, since this is the amount of unwinding in the main\n+\t@ division loop.  Continue shifting until the divisor is \n+\t@ larger than the dividend.\n+\tcmp\tdivisor, work\n+\tbcs\tLbignum\n+\tcmp\tdivisor, dividend\n+\tbcs\tLbignum\n+\tlsl\tdivisor, #4\n+\tlsl\tcurbit, #4\n+\tb\tLoop1\n+\n+Lbignum:\n+\t@ Set work to 0x80000000\n+\tlsl\twork, #3\n+Loop2:\n+\t@ For very big divisors, we must shift it a bit at a time, or\n+\t@ we will be in danger of overflowing.\n+\tcmp\tdivisor, work\n+\tbcs\tLoop3\n+\tcmp\tdivisor, dividend\n+\tbcs\tLoop3\n+\tlsl\tdivisor, #1\n+\tlsl\tcurbit, #1\n+\tb\tLoop2\n+\n+Loop3:\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend, so keep track of which\n+\t@ subtractions are done, we can fix them up afterwards...\n+\tmov\toverdone, #0\n+\tcmp\tdividend, divisor\n+\tbcc\tOver3\n+\tsub\tdividend, dividend, divisor\n+Over3:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbcc\tOver4\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over4:\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbcc\tOver5\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over5:\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbcc\tOver6\n+\tsub\tdividend, dividend, work\n+\tmov\tip, curbit\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\torr\toverdone, curbit\n+\tmov\tcurbit, ip\n+Over6:\n+\tmov\tip, curbit\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tbeq\tOver7\n+\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n+\tbeq\tOver7\n+\tlsr\tdivisor, #4\n+\tb\tLoop3\n+\n+Over7:\t\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of \"overdone\".  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in ip.\n+\t@ If we terminated early, because dividend became zero,\n+\t@ then none of the below will match, since the bit in ip will not be\n+\t@ in the bottom nibble.\n+\tmov\twork, #0xe\n+\tlsl\twork, #28\n+\tand\toverdone, work\n+\tbeq\tLgot_result\n+\t\n+\tmov\tcurbit, ip\n+\tmov\twork, #3\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver8\n+\tlsr\twork, divisor, #3\n+\tadd\tdividend, dividend, work\n+Over8:\n+\tmov\tcurbit, ip\n+\tmov\twork, #2\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tOver9\n+\tlsr\twork, divisor, #2\n+\tadd\tdividend, dividend, work\n+Over9:\n+\tmov\tcurbit, ip\n+\tmov\twork, #1\n+\tror\tcurbit, work\n+\ttst\toverdone, curbit\n+\tbeq\tLgot_result\n+\tlsr\twork, divisor, #1\n+\tadd\tdividend, dividend, work\n+Lgot_result:\n+\tpop\t{ work }\n+\tcmp\twork, #0\n+\tbpl\tOver10\n+\tneg\tdividend, dividend\n+Over10:\n+\tpop\t{ work }\n+\tRET\t\n+\n+Ldiv0:\n+\tpush    { lr }\n+\tbl\tSYM (__div0)\n+\tmov\tr0, #0\t\t\t@ about as wrong as it could be\n+\tpop\t{ pc }\n+\t\n+#endif /* L_modsi3 */\n+\n+#ifdef L_dvmd_tls\n+\n+\t.globl SYM (__div0)\n+\t.align 0\n+\t.thumb_func\n+SYM (__div0):\n+\tRET\t\n+\n+#endif /* L_divmodsi_tools */\n+\n+\t\n+#ifdef L_call_via_rX\n+\n+/* These labels & instructions are used by the Arm/Thumb interworking code. \n+   The address of function to be called is loaded into a register and then \n+   one of these labels is called via a BL instruction.  This puts the \n+   return address into the link register with the bottom bit set, and the \n+   code here switches to the correct mode before executing the function.  */\n+\n+\t.text\n+\t.align 0\n+\t\n+\t.globl\tSYM (_call_via_r0)\n+\t.thumb_func\n+SYM (_call_via_r0):\n+\tbx\tr0 \n+\tnop\n+\n+\t.globl\tSYM (_call_via_r1)\n+\t.thumb_func\n+SYM (_call_via_r1):\n+\tbx \tr1\n+\tnop\n+\n+\t.globl\tSYM (_call_via_r2)\n+\t.thumb_func\n+SYM (_call_via_r2):\n+\tbx \tr2 \n+\tnop\n+\n+\t.globl\tSYM (_call_via_r3)\n+\t.thumb_func\n+SYM (_call_via_r3):\n+\tbx \tr3 \n+\tnop\n+\n+\t.globl\tSYM (_call_via_r4)\n+\t.thumb_func\n+SYM (_call_via_r4):\n+\tbx \tr4\n+\tnop\n+\n+\t.globl\tSYM (_call_via_r5)\n+\t.thumb_func\n+SYM (_call_via_r5):\n+\tbx \tr5\n+\tnop\n+\n+\t.globl\tSYM (_call_via_r6)\n+\t.thumb_func\n+SYM (_call_via_r6):\n+\tbx \tr6\n+\tnop\n+\n+\t.globl\tSYM (_call_via_r7)\n+\t.thumb_func\n+SYM (_call_via_r7):\n+\tbx \tr7\n+\tnop\n+\n+\t.globl\tSYM (_call_via_r8)\n+\t.thumb_func\n+SYM (_call_via_r8):\n+\tbx \tr8\n+\tnop\n+\n+\t.globl\tSYM (_call_via_r9)\n+\t.thumb_func\n+SYM (_call_via_r9):\n+\tbx \tr9\n+\tnop\n+\n+\t.globl\tSYM (_call_via_sl)\n+\t.thumb_func\n+SYM (_call_via_sl):\n+\tbx \tsl \n+\tnop\n+\n+\t.globl\tSYM (_call_via_fp)\n+\t.thumb_func\n+SYM (_call_via_fp):\n+\tbx \tfp \n+\tnop\n+\n+\t.globl\tSYM (_call_via_ip)\n+\t.thumb_func\n+SYM (_call_via_ip):\n+\tbx \tip\n+\tnop\n+\n+\t.globl\tSYM (_call_via_sp)\n+\t.thumb_func\n+SYM (_call_via_sp):\n+\tbx \tsp \n+\tnop\n+\n+\t.globl\tSYM (_call_via_lr)\n+\t.thumb_func\n+SYM (_call_via_lr):\n+\tbx \tlr \n+\tnop\n+\n+#endif /* L_call_via_rX */"}, {"sha": "1701258e06f61cd3826b2cce2c7a110063503b0d", "filename": "gcc/config/arm/t-thumb", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Ft-thumb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Ft-thumb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-thumb?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -0,0 +1,32 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1thumb.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX\n+# adddi3/subdi3 added to machine description\n+#LIB1ASMFUNCS = _adddi3 _subdi3 _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+# Avoid building a duplicate set of libraries for the default endian-ness.\n+MULTILIB_OPTIONS = mlittle-endian/mbig-endian mno-thumb-interwork/mthumb-interwork\n+MULTILIB_DIRNAMES = le be normal interwork\n+MULTILIB_MATCHES = mbig-endian=mbe mlittle-endian=mle\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "5fabe5dd555e35b0569b480f4dc6a63818e4a356", "filename": "gcc/config/arm/tcoff.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Ftcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Ftcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftcoff.h?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -0,0 +1,192 @@\n+/* Definitions of target machine for GNU compiler,\n+   for Thumb with COFF obj format.\n+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Derived from arm/coff.h originally by Doug Evans (dje@cygnus.com).\n+   \n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"arm/thumb.h\"\n+\f\n+/* Run-time Target Specification.  */\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (Thumb/coff)\", stderr)\n+\n+#define MULTILIB_DEFAULTS { \"mlittle-endian\" }\n+\f\n+/* Setting this to 32 produces more efficient code, but the value set in previous\n+   versions of this toolchain was 8, which produces more compact structures. The\n+   command line option -mstructure_size_boundary=<n> can be used to change this\n+   value.  */\n+#undef STRUCTURE_SIZE_BOUNDARY\n+#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n+\n+extern int arm_structure_size_boundary;\n+\f\n+/* This is COFF, but prefer stabs.  */\n+#define SDB_DEBUGGING_INFO\n+\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#include \"dbxcoff.h\"\n+\f\n+/* Note - it is important that these definitions match those in semi.h for the ARM port.  */\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+/* A C statement to output assembler commands which will identify the\n+   object file as having been compiled with GNU CC (or another GNU\n+   compiler).  */\n+#define ASM_IDENTIFY_GCC(STREAM)\t\t\t\t\\\n+     fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern char *version_string;\t\t\t\t\t\\\n+  fprintf ((STREAM), \"%s Generated by gcc %s for Thumb/coff\\n\", \\\n+\t   ASM_COMMENT_START, version_string);\t                \\\n+  fprintf ((STREAM), ASM_APP_OFF);                              \\\n+} while (0)\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+} while (0)\n+\f\n+/* Support the ctors/dtors and other sections.  */\n+\n+#undef INIT_SECTION_ASM_OP\n+\n+/* Define this macro if jump tables (for `tablejump' insns) should be\n+   output in the text section, along with the assembler instructions.\n+   Otherwise, the readonly data section is used.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION\trdata_section\n+#undef RDATA_SECTION_ASM_OP\n+#define RDATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section .ctors,\\\"x\\\"\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section .dtors,\\\"x\\\"\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_rdata, in_ctors, in_dtors\n+\n+#define SUBTARGET_EXTRA_SECTIONS\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS \\\n+  RDATA_SECTION_FUNCTION\t\\\n+  CTORS_SECTION_FUNCTION\t\\\n+  DTORS_SECTION_FUNCTION\t\\\n+  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+\n+#define RDATA_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+rdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_rdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Support the ctors/dtors sections for g++.  */\n+\n+#define INT_ASM_OP \".word\"\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n+do {\t\t\t\t\t\t\\\n+  ctors_section ();\t\t\t\t\\\n+  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+  assemble_name (STREAM, NAME);\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+} while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n+do {\t\t\t\t\t\t\\\n+  dtors_section ();                   \t\t\\\n+  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+  assemble_name (STREAM, NAME);              \t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+} while (0)\n+\n+/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n+#define CTOR_LISTS_DEFINED_EXTERNALLY\n+\n+#undef DO_GLOBAL_CTORS_BODY\n+#undef DO_GLOBAL_DTORS_BODY\n+\n+/* The ARM development system has atexit and doesn't have _exit,\n+   so define this for now.  */\n+#define HAVE_ATEXIT\n+\n+/* The ARM development system defines __main.  */\n+#define NAME__MAIN \"__gccmain\"\n+#define SYMBOL__MAIN __gccmain"}, {"sha": "1a2eb18ff8dcff81793e493ee5cf04e74d8796b9", "filename": "gcc/config/arm/thumb.c", "status": "added", "additions": 1965, "deletions": 0, "changes": 1965, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -0,0 +1,1965 @@\n+/* Output routines for GCC for ARM/Thumb\n+   Copyright (C) 1996 Cygnus Software Technologies Ltd\n+   The basis of this contribution was generated by\n+   \t\tRichard Earnshaw, Advanced RISC Machines Ltd\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"regs.h\"\n+#include \"output.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+\n+\f\n+int current_function_anonymous_args = 0;\n+\n+/* Used to parse -mstructure_size_boundary command line option.  */\n+char * structure_size_string = NULL;\n+int    arm_structure_size_boundary = 32; /* Used to be 8 */\n+\n+\f\n+/* Predicates */\n+int\n+reload_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int regno = true_regnum (op);\n+\n+  return (! CONSTANT_P (op)\n+\t  && (regno == -1\n+\t      || (GET_CODE (op) == REG\n+\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n+}\n+\n+/* Return nonzero if op is suitable for the RHS of a cmp instruction.  */\n+int\n+thumb_cmp_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == CONST_INT\n+\t   && (unsigned HOST_WIDE_INT) (INTVAL (op)) < 256)\n+\t  || register_operand (op, mode));\n+}\n+\n+int\n+thumb_shiftable_const (val)\n+     HOST_WIDE_INT val;\n+{\n+  unsigned HOST_WIDE_INT x = val;\n+  unsigned HOST_WIDE_INT mask = 0xff;\n+  int i;\n+\n+  for (i = 0; i < 25; i++)\n+    if ((val & (mask << i)) == val)\n+      return 1;\n+\n+  return 0;\n+}\n+\n+int\n+thumb_trivial_epilogue ()\n+{\n+  int regno;\n+\n+  /* ??? If this function ever returns 1, we get a function without any\n+     epilogue at all.  It appears that the intent was to cause a \"return\"\n+     insn to be emitted, but that does not happen.  */\n+  return 0;\n+\n+#if 0\n+  if (get_frame_size () \n+      || current_function_outgoing_args_size\n+      || current_function_pretend_args_size)\n+    return 0;\n+\n+  for (regno = 8; regno < 13; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      return 0;\n+\n+  return 1;\n+#endif\n+}\n+\n+\f\n+/* Routines for handling the constant pool */\n+/* This is unashamedly hacked from the version in sh.c, since the problem is\n+   extremely similar.  */\n+\n+/* Thumb instructions cannot load a large constant into a register,\n+   constants have to come from a pc relative load.  The reference of a pc\n+   relative load instruction must be less than 1k infront of the instruction.\n+   This means that we often have to dump a constant inside a function, and\n+   generate code to branch around it.\n+ \n+   It is important to minimize this, since the branches will slow things\n+   down and make things bigger.\n+ \n+   Worst case code looks like:\n+ \n+\tldr\trn, L1\n+\tb\tL2\n+\talign\n+\tL1:   .long value\n+\tL2:\n+\t..\n+ \n+\tldr\trn, L3\n+\tb\tL4\n+\talign\n+\tL3:   .long value\n+\tL4:\n+\t..\n+ \n+   We fix this by performing a scan before scheduling, which notices which\n+   instructions need to have their operands fetched from the constant table\n+   and builds the table.\n+ \n+ \n+   The algorithm is:\n+ \n+   scan, find an instruction which needs a pcrel move.  Look forward, find the\n+   last barrier which is within MAX_COUNT bytes of the requirement.\n+   If there isn't one, make one.  Process all the instructions between\n+   the find and the barrier.\n+ \n+   In the above example, we can tell that L3 is within 1k of L1, so\n+   the first move can be shrunk from the 2 insn+constant sequence into\n+   just 1 insn, and the constant moved to L3 to make:\n+ \n+\tldr\trn, L1\n+\t..\n+\tldr\trn, L3\n+\tb\tL4\n+\talign\n+\tL1:\t.long value\n+\tL3:\t.long value\n+\tL4:\n+ \n+   Then the second move becomes the target for the shortening process.\n+ \n+ */\n+ \n+typedef struct\n+{\n+  rtx value;\t\t\t/* Value in table */\n+  HOST_WIDE_INT next_offset;\n+  enum machine_mode mode;\t/* Mode of value */\n+} pool_node;\n+\n+/* The maximum number of constants that can fit into one pool, since\n+   the pc relative range is 0...1020 bytes and constants are at least 4\n+   bytes long */\n+\n+#define MAX_POOL_SIZE (1020/4)\n+static pool_node pool_vector[MAX_POOL_SIZE];\n+static int pool_size;\n+static rtx pool_vector_label;\n+\n+/* Add a constant to the pool and return its label.  */\n+ \n+static HOST_WIDE_INT\n+add_constant (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  int i;\n+  rtx lab;\n+  HOST_WIDE_INT offset;\n+\n+  if (mode == SImode && GET_CODE (x) == MEM && CONSTANT_P (XEXP (x, 0))\n+      && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n+    x = get_pool_constant (XEXP (x, 0));\n+\n+  /* First see if we've already got it */\n+ \n+  for (i = 0; i < pool_size; i++)\n+    {\n+      if (x->code == pool_vector[i].value->code\n+          && mode == pool_vector[i].mode)\n+        {\n+          if (x->code == CODE_LABEL)\n+            {\n+              if (XINT (x, 3) != XINT (pool_vector[i].value, 3))\n+                continue;\n+            }\n+          if (rtx_equal_p (x, pool_vector[i].value))\n+            return pool_vector[i].next_offset - GET_MODE_SIZE (mode);\n+        }\n+    }\n+ \n+  /* Need a new one */\n+ \n+  pool_vector[pool_size].next_offset = GET_MODE_SIZE (mode);\n+  offset = 0;\n+  if (pool_size == 0)\n+    pool_vector_label = gen_label_rtx ();\n+  else\n+    pool_vector[pool_size].next_offset \n+      += (offset = pool_vector[pool_size - 1].next_offset);\n+\n+  pool_vector[pool_size].value = x;\n+  pool_vector[pool_size].mode = mode;\n+  pool_size++;\n+  return offset;\n+}\n+ \n+/* Output the literal table */\n+                    \n+static void         \n+dump_table (scan)\n+     rtx scan;\n+{\n+  int i;\n+\n+  scan = emit_label_after (gen_label_rtx (), scan);\n+  scan = emit_insn_after (gen_align_4 (), scan);\n+  scan = emit_label_after (pool_vector_label, scan);\n+\n+  for (i = 0; i < pool_size; i++)\n+    {\n+      pool_node *p = pool_vector + i;\n+\n+      switch (GET_MODE_SIZE (p->mode))\n+\t{\n+\tcase 4:\n+\t  scan = emit_insn_after (gen_consttable_4 (p->value), scan);\n+\t  break;\n+\n+\tcase 8:\n+\t  scan = emit_insn_after (gen_consttable_8 (p->value), scan);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t  break;\n+\t}\n+    }\n+\n+  scan = emit_insn_after (gen_consttable_end (), scan);\n+  scan = emit_barrier_after (scan);\n+  pool_size = 0;\n+}\n+\n+/* Non zero if the src operand needs to be fixed up */\n+static\n+int\n+fixit (src, mode)\n+     rtx src;\n+     enum machine_mode mode;\n+{\n+  return ((CONSTANT_P (src)\n+\t   && (GET_CODE (src) != CONST_INT\n+\t       || ! (CONST_OK_FOR_LETTER_P (INTVAL (src), 'I')\n+\t\t     || CONST_OK_FOR_LETTER_P (INTVAL (src), 'J')\n+\t\t     || (mode != DImode\n+\t\t\t && CONST_OK_FOR_LETTER_P (INTVAL (src), 'K')))))\n+\t  || (mode == SImode && GET_CODE (src) == MEM\n+\t      && GET_CODE (XEXP (src, 0)) == SYMBOL_REF\n+\t      && CONSTANT_POOL_ADDRESS_P (XEXP (src, 0))));\n+}\n+\n+/* Find the last barrier less than MAX_COUNT bytes from FROM, or create one. */\n+\n+#define MAX_COUNT_SI 1000\n+ \n+static rtx\n+find_barrier (from)\n+     rtx from;\n+{\n+  int count = 0;\n+  rtx found_barrier = 0;\n+  rtx label;\n+\n+  while (from && count < MAX_COUNT_SI)\n+    {\n+      if (GET_CODE (from) == BARRIER)\n+\treturn from;\n+\n+      /* Count the length of this insn */\n+      if (GET_CODE (from) == INSN\n+\t  && GET_CODE (PATTERN (from)) == SET\n+\t  && CONSTANT_P (SET_SRC (PATTERN (from)))\n+\t  && CONSTANT_POOL_ADDRESS_P (SET_SRC (PATTERN (from))))\n+\t{\n+\t  rtx src = SET_SRC (PATTERN (from));\n+\t  count += 2;\n+\t}\n+      else\n+\tcount += get_attr_length (from);\n+\n+      from = NEXT_INSN (from);\n+    }\n+\n+  /* We didn't find a barrier in time to\n+     dump our stuff, so we'll make one */\n+  label = gen_label_rtx ();\n+  \n+  if (from)\n+    from = PREV_INSN (from);\n+  else\n+    from = get_last_insn ();\n+  \n+  /* Walk back to be just before any jump */\n+  while (GET_CODE (from) == JUMP_INSN\n+\t || GET_CODE (from) == NOTE\n+\t || GET_CODE (from) == CODE_LABEL)\n+    from = PREV_INSN (from);\n+  \n+  from = emit_jump_insn_after (gen_jump (label), from);\n+  JUMP_LABEL (from) = label;\n+  found_barrier = emit_barrier_after (from);\n+  emit_label_after (label, found_barrier);\n+  return found_barrier;\n+}\n+\n+/* Non zero if the insn is a move instruction which needs to be fixed. */\n+ \n+static int\n+broken_move (insn)\n+     rtx insn;\n+{\n+  if (!INSN_DELETED_P (insn)\n+      && GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET)\n+    {\n+      rtx pat = PATTERN (insn);\n+      rtx src = SET_SRC (pat);\n+      rtx dst = SET_DEST (pat);\n+      enum machine_mode mode = GET_MODE (dst);\n+      if (dst == pc_rtx)\n+\treturn 0;\n+      return fixit (src, mode);\n+    }\n+  return 0;\n+}\n+\n+#ifdef DBX_DEBUGGING_INFO\n+\n+/* Recursively search through all of the blocks in a function\n+   checking to see if any of the variables created in that\n+   function match the RTX called 'orig'.  If they do then\n+   replace them with the RTX called 'new'.  */\n+\n+static void\n+replace_symbols_in_block (tree block, rtx orig, rtx new)\n+{\n+  for (; block; block = BLOCK_CHAIN (block))\n+    {\n+      tree sym;\n+      \n+      if (! TREE_USED (block))\n+\tcontinue;\n+\n+      for (sym = BLOCK_VARS (block); sym; sym = TREE_CHAIN (sym))\n+\t{\n+\t  if (  (DECL_NAME (sym) == 0 && TREE_CODE (sym) != TYPE_DECL)\n+\t      || DECL_IGNORED_P (sym)\n+\t      || TREE_CODE (sym) != VAR_DECL\n+\t      || DECL_EXTERNAL (sym)\n+\t      || ! rtx_equal_p (DECL_RTL (sym), orig)\n+\t      )\n+\t    continue;\n+\n+\t  DECL_RTL (sym) = new;\n+\t}\n+      \n+      replace_symbols_in_block (BLOCK_SUBBLOCKS (block), orig, new);\n+    }\n+}\n+#endif\n+\n+void\n+thumb_reorg (first)\n+     rtx first;\n+{\n+  rtx insn;\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (broken_move (insn))\n+\t{\n+\t  /* This is a broken move instruction, scan ahead looking for\n+\t     a barrier to stick the constant table behind */\n+\t  rtx scan;\n+\t  rtx barrier = find_barrier (insn);\n+\n+\t  /* Now find all the moves between the points and modify them */\n+\t  for (scan = insn; scan != barrier; scan = NEXT_INSN (scan))\n+\t    {\n+\t      if (broken_move (scan))\n+\t\t{\n+\t\t  /* This is a broken move instruction, add it to the pool */\n+\t\t  rtx pat = PATTERN (scan);\n+\t\t  rtx src = SET_SRC (pat);\n+\t\t  rtx dst = SET_DEST (pat);\n+\t\t  enum machine_mode mode = GET_MODE (dst);\n+\t\t  HOST_WIDE_INT offset;\n+\t\t  rtx newinsn;\n+\t\t  rtx newsrc;\n+\n+\t\t  /* If this is an HImode constant load, convert it into\n+\t\t     an SImode constant load.  Since the register is always\n+\t\t     32 bits this is safe.  We have to do this, since the\n+\t\t     load pc-relative instruction only does a 32-bit load. */\n+\t\t  if (mode == HImode)\n+\t\t    {\n+\t\t      mode = SImode;\n+\t\t      if (GET_CODE (dst) != REG)\n+\t\t\tabort ();\n+\t\t      PUT_MODE (dst, SImode);\n+\t\t    }\n+\n+\t\t  offset = add_constant (src, mode);\n+\t\t  newsrc = gen_rtx (MEM, mode,\n+\t\t\t\t    plus_constant (gen_rtx (LABEL_REF,\n+\t\t\t\t\t\t\t    VOIDmode, \n+\t\t\t\t\t\t\t    pool_vector_label),\n+\t\t\t\t\t\t   offset));\n+\n+\t\t  /* Build a jump insn wrapper around the move instead\n+\t\t     of an ordinary insn, because we want to have room for\n+\t\t     the target label rtx in fld[7], which an ordinary\n+\t\t     insn doesn't have. */\n+\t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t\t\t   dst, newsrc), scan);\n+\t\t  JUMP_LABEL (newinsn) = pool_vector_label;\n+\n+\t\t  /* But it's still an ordinary insn */\n+\t\t  PUT_CODE (newinsn, INSN);\n+\n+#ifdef DBX_DEBUGGING_INFO\n+\t\t  /* If debugging information is going to be emitted then we must\n+\t\t     make sure that any refences to symbols which are removed by\n+\t\t     the above code are also removed in the descriptions of the\n+\t\t     function's variables.  Failure to do this means that the\n+\t\t     debugging information emitted could refer to symbols which\n+\t\t     are not emited by output_constant_pool() because\n+\t\t     mark_constant_pool() never sees them as being used.  */\n+\t\t  \n+\t\t  if (optimize > 0\t\t\t          /* These are the tests used in output_constant_pool() */\n+\t\t      && flag_expensive_optimizations             /*  to decide if the constant pool will be marked.  */\n+\t\t      && write_symbols == DBX_DEBUG               /* Only necessary if debugging info is being emitted.  */\n+\t\t      && GET_CODE (src) == MEM                    /* Only necessary for references to memory ... */\n+\t\t      && GET_CODE (XEXP (src, 0)) == SYMBOL_REF)  /*  ... whose address is given by a symbol.  */\n+\t\t    {\n+\t\t      replace_symbols_in_block (DECL_INITIAL (current_function_decl), src, newsrc);\n+\t\t    }\n+#endif\n+\t\t  \n+\t\t  /* Kill old insn */\n+\t\t  delete_insn (scan);\n+\t\t  scan = newinsn;\n+\t\t}\n+\t    }\n+\t  dump_table (barrier);\n+\t}\n+    }\n+}\n+\n+\f\n+/* Routines for generating rtl */\n+\n+void\n+thumb_expand_movstrqi (operands)\n+     rtx *operands;\n+{\n+  rtx out = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n+  rtx in = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+  HOST_WIDE_INT len = INTVAL (operands[2]);\n+  HOST_WIDE_INT offset = 0;\n+\n+  while (len >= 12)\n+    {\n+      emit_insn (gen_movmem12b (out, in));\n+      len -= 12;\n+    }\n+  if (len >= 8)\n+    {\n+      emit_insn (gen_movmem8b (out, in));\n+      len -= 8;\n+    }\n+  if (len >= 4)\n+    {\n+      rtx reg = gen_reg_rtx (SImode);\n+      emit_insn (gen_movsi (reg, gen_rtx (MEM, SImode, in)));\n+      emit_insn (gen_movsi (gen_rtx (MEM, SImode, out), reg));\n+      len -= 4;\n+      offset += 4;\n+    }\n+  if (len >= 2)\n+    {\n+      rtx reg = gen_reg_rtx (HImode);\n+      emit_insn (gen_movhi (reg, gen_rtx (MEM, HImode, \n+\t\t\t\t\t  plus_constant (in, offset))));\n+      emit_insn (gen_movhi (gen_rtx (MEM, HImode, plus_constant (out, offset)),\n+\t\t\t    reg));\n+      len -= 2;\n+      offset += 2;\n+    }\n+  if (len)\n+    {\n+      rtx reg = gen_reg_rtx (QImode);\n+      emit_insn (gen_movqi (reg, gen_rtx (MEM, QImode,\n+\t\t\t\t\t  plus_constant (in, offset))));\n+      emit_insn (gen_movqi (gen_rtx (MEM, QImode, plus_constant (out, offset)),\n+\t\t\t    reg));\n+    }\n+}\n+\n+\f\n+/* Routines for reloading */\n+\n+void\n+thumb_reload_out_si (operands)\n+     rtx operands;\n+{\n+  abort ();\n+}\n+\n+\f\n+/* Routines for emitting code */\n+\n+void\n+final_prescan_insn(insn)\n+     rtx insn;\n+{\n+  extern int *insn_addresses;\n+\n+  if (flag_print_asm_name)\n+    fprintf (asm_out_file, \"%s 0x%04x\\n\", ASM_COMMENT_START,\n+\t     insn_addresses[INSN_UID (insn)]);\n+}\n+\n+\n+static void thumb_pushpop ( FILE *, int, int ); /* Forward declaration.  */\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+static int\n+number_of_first_bit_set (mask)\n+     int mask;\n+{\n+  int bit;\n+\n+  for (bit = 0;\n+       (mask & (1 << bit)) == 0;\n+       ++ bit)\n+    continue;\n+\n+  return bit;\n+}\n+\n+#define ARG_1_REGISTER   0\n+#define ARG_2_REGISTER   1\n+#define ARG_3_REGISTER   2\n+#define ARG_4_REGISTER   3\n+#define WORK_REGISTER    7\n+#define FRAME_POINTER\t11\n+#define IP_REGISTER\t12\n+#define STACK_POINTER\tSTACK_POINTER_REGNUM\n+#define LINK_REGISTER\t14\n+#define PROGRAM_COUNTER 15\n+\n+/* Generate code to return from a thumb function.\n+   If 'reg_containing_return_addr' is -1, then the\n+   address is actually on the stack, at the stack\n+   pointer.  */\n+\n+static void\n+thumb_exit (f, reg_containing_return_addr)\n+     FILE * f;\n+     int    reg_containing_return_addr;\n+{\n+  int regs_available_for_popping;\n+  int regs_to_pop;\n+  int pops_needed;\n+  int reg;\n+  int available;\n+  int required;\n+  int mode;\n+  int size;\n+  int restore_a4 = FALSE;\n+\n+  /* Compute the registers we need to pop.  */\n+\n+  regs_to_pop = 0;\n+  pops_needed = 0;\n+  \n+  if (reg_containing_return_addr == -1)\n+    {\n+      regs_to_pop |= 1 << LINK_REGISTER;\n+      ++ pops_needed;\n+    }\n+\n+  if (TARGET_BACKTRACE)\n+    {\n+      /* Restore frame pointer and stack pointer.  */\n+      \n+      regs_to_pop |= (1 << FRAME_POINTER) | (1 << STACK_POINTER);\n+      pops_needed += 2;\n+    }\n+\n+  /* If there is nothing to pop then just emit the BX instruction and return.  */\n+  \n+  if (pops_needed == 0)\n+    {\n+      asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names[ reg_containing_return_addr ]);\n+\n+      return;\n+    }\n+\n+  /* Otherwise if we are not supporting interworking and we have not created\n+     a backtrace structure then just pop the return address straight into the PC.  */\n+  \n+  else if (! TARGET_THUMB_INTERWORK && ! TARGET_BACKTRACE)\n+    {\n+      asm_fprintf (f, \"\\tpop\\t{pc}\\n\" );\n+\n+      return;\n+    }\n+\n+  /* Find out how many of the (return) argument registers we can corrupt. */\n+  \n+  regs_available_for_popping = 0;\n+  \n+#ifdef RTX_CODE\n+  /* If we can deduce the registers used from the function's return value.\n+     This is more reliable that examining regs_ever_live[] because that\n+     will be set if the register is ever used in the function, not just if\n+     the register is used to hold a return value.  */\n+\n+  if (current_function_return_rtx != 0)\n+    {\n+      mode = GET_MODE (current_function_return_rtx);\n+    }\n+  else\n+#endif\n+    {\n+      mode = DECL_MODE (DECL_RESULT (current_function_decl));\n+    }\n+\n+  size = GET_MODE_SIZE (mode);\n+\n+  if (size == 0)\n+    {\n+      /* In a void function we can use any argument register.\n+\t In a function that returns a structure on the stack\n+\t we can use the second and third argument registers.  */\n+      \n+      if (mode == VOIDmode)\n+\tregs_available_for_popping = (1 << ARG_1_REGISTER) | (1 << ARG_2_REGISTER) | (1 << ARG_3_REGISTER);\n+      else\n+\tregs_available_for_popping = (1 << ARG_2_REGISTER) | (1 << ARG_3_REGISTER);\n+    }\n+  else if (size <= 4) regs_available_for_popping = (1 << ARG_2_REGISTER) | (1 << ARG_3_REGISTER);\n+  else if (size <= 8) regs_available_for_popping = (1 << ARG_3_REGISTER);\n+  \n+  /* Match registers to be popped with registers into which we pop them.  */\n+\n+  for (available = regs_available_for_popping,\n+       required  = regs_to_pop;\n+       required != 0 && available != 0;\n+       available &= ~(available & - available),\n+       required  &= ~(required  & - required))\n+    -- pops_needed;\n+\n+  /* If we have any popping registers left over, remove them.  */\n+\n+  if (available > 0)\n+    regs_available_for_popping &= ~ available;\n+  \n+  /* Otherwise if we need another popping register we can use\n+     the fourth argument register.  */\n+  \n+  else if (pops_needed)\n+    {\n+      /* If we have not found any free argument registers and\n+\t reg a4 contains the return address, we must move it.  */\n+\n+      if (regs_available_for_popping == 0 && reg_containing_return_addr == ARG_4_REGISTER)\n+\t{\n+\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n+\t\t       reg_names[ LINK_REGISTER ],\n+\t\t       reg_names[ ARG_4_REGISTER ]);\n+\t  reg_containing_return_addr = LINK_REGISTER;\n+\t}\n+      else if (size > 12)\n+\t{\n+\t  /* Register a4 is being used to hold part of the return value,\n+\t     but we have dire need of a free, low register.  */\n+\t  \n+\t  restore_a4 = TRUE;\n+\t  \n+\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n+\t\t       reg_names[ IP_REGISTER ],\n+\t\t       reg_names[ ARG_4_REGISTER ]);\n+\t}\n+      \n+      if (reg_containing_return_addr != ARG_4_REGISTER)\n+\t{\n+\t  /* The fourth argument register is available.  */\n+  \n+\t  regs_available_for_popping |= 1 << ARG_4_REGISTER;\n+\t  \n+\t  -- pops_needed;\n+\t}\n+    }\n+\n+  /* Pop as many registers as we can.  */\n+  \n+  thumb_pushpop (f, regs_available_for_popping, FALSE );\n+\n+  /* Process the registers we popped.  */\n+  \n+  if (reg_containing_return_addr == -1)\n+    {\n+      /* The return address was popped into the lowest numbered register.  */\n+\n+      regs_to_pop &= ~ (1 << LINK_REGISTER);\n+      \n+      reg_containing_return_addr = number_of_first_bit_set (regs_available_for_popping);\n+\n+      /* Remove this register for the mask of available registers, so that\n+         the return address will not be corrupted by futher pops.  */\n+      \n+      regs_available_for_popping &= ~ (1 << reg_containing_return_addr);\n+    }\n+\n+  /* If we popped other registers then handle them here.  */\n+\n+  if (regs_available_for_popping)\n+    {\n+      int frame_pointer;\n+      \n+      /* Work out which register currently contains the frame pointer.  */\n+      \n+      frame_pointer = number_of_first_bit_set (regs_available_for_popping);\n+\n+      /* Move it into the correct place.  */\n+      \n+      asm_fprintf (f, \"\\tmov\\tfp, %s\\n\", reg_names[ frame_pointer ]);\n+\n+      /* (Temporarily) remove it from the mask of popped registers.  */\n+      \n+      regs_available_for_popping &= ~ (1 << frame_pointer);\n+      regs_to_pop &= ~ (1 << FRAME_POINTER);\n+      \n+      if (regs_available_for_popping)\n+\t{\n+\t  int stack_pointer;\n+\t  \n+\t  /* We popped the stack pointer as well, find the register that contains it.  */\n+\t  \n+\t  stack_pointer = number_of_first_bit_set (regs_available_for_popping);\n+\n+\t  /* Move it into the stack register.  */\n+\t  \n+\t  asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names[ stack_pointer ]);\n+\t  \n+\t  /* At this point we have popped all necessary registers, so\n+\t     do not worry about restoring regs_available_for_popping\n+\t     to its correct value:\n+\n+\t     assert (pops_needed == 0)\n+\t     assert (regs_available_for_popping == (1 << stack_frame_pointer))\n+\t     assert (regs_to_pop == (1 << STACK_POINTER))  */\n+\t}\n+      else\n+\t{\n+\t  /* Since we have just move the popped value into the frame\n+\t     pointer, the popping register is available for reuse, and\n+\t     we know that we still have the stack pointer left to pop.  */\n+\t  \n+\t  regs_available_for_popping |= (1 << frame_pointer);\n+\t}\n+    }\n+  \n+  /* If we still have registers left on the stack, but we no longer\n+     have any registers into which we can pop them, then we must\n+     move the return address into the link register and make\n+     available the register that contained it.  */\n+  \n+  if (regs_available_for_popping == 0 && pops_needed > 0)\n+    {\n+      regs_available_for_popping |= 1 << reg_containing_return_addr;\n+      \n+      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n+\t\t   reg_names[ LINK_REGISTER ],\n+\t\t   reg_names[ reg_containing_return_addr ]);\n+      \n+      reg_containing_return_addr = LINK_REGISTER;\n+    }\n+\n+  /* If we have registers left on the stack then pop some more.\n+     We know that we will only be popping one register here for\n+     the following reasons:\n+\n+     1. We know that at most we want to pop LR, FP and SP.\n+     2. We have already popped at least one register.\n+     3. If there were 3 registers available for popping then\n+        we have already popped all three of the registers.\n+     4. If there were 2 registers available for popping then\n+        we have already popped LR and FP, so there can only\n+\tbe one register left on the stack: SP.  And since we\n+\thad two\tregisters available for popping we will have\n+\tleft the LR in one of those registers and leaving\n+\tonly one register left for popping the SP.\n+     5. If there was only 1 register available for popping\n+        then we can only be popping one register here.\t*/\n+  \n+  if (pops_needed > 0)\n+    {\n+      int  popped_into;\n+      int  move_to;\n+      \n+      thumb_pushpop (f, regs_available_for_popping, FALSE);\n+\n+      /* We have popped either FP or SP.  Move whichever one\n+\t it is into the correct register.  */\n+      \n+      popped_into = number_of_first_bit_set (regs_available_for_popping);\n+      move_to     = number_of_first_bit_set (regs_to_pop);\n+\n+      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[ move_to ], reg_names[ popped_into ]);\n+\n+      regs_to_pop &= ~ (1 << move_to);\n+\n+      -- pops_needed;\n+    }\n+\n+  /* If we still have not popped everything then we must have\n+     only had one register available to us and we are now\n+     popping the SP.  */\n+  \n+  if (pops_needed > 0)\n+    {\n+      int  popped_into;\n+      \n+      thumb_pushpop (f, regs_available_for_popping, FALSE);\n+\n+      popped_into = number_of_first_bit_set (regs_available_for_popping);\n+\n+      asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names[ popped_into ]);\n+\n+      /*\n+\tassert (regs_to_pop == (1 << STACK_POINTER))\n+\tassert (pops_needed == 1)\n+      */\n+    }\n+\n+  /* If necessary restore the a4 register.  */\n+  if (restore_a4)\n+    {\n+      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[ LINK_REGISTER ], reg_names[ ARG_4_REGISTER ]);\n+      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[ ARG_4_REGISTER ], reg_names[ IP_REGISTER ]);\n+      reg_containing_return_addr = LINK_REGISTER;\n+    }\n+    \n+  /* Return to caller.  */\n+  \n+  asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names[ reg_containing_return_addr ]);\n+}\n+\n+/* Emit code to push or pop registers to or from the stack.  */\n+\n+static void\n+thumb_pushpop (f, mask, push)\n+     FILE *f;\n+     int mask;\n+     int push;\n+{\n+  int regno;\n+  int lo_mask = mask & 0xFF;\n+\n+  if (lo_mask == 0 && ! push && (mask & (1 << 15)))\n+    {\n+      /* Special case.  Do not generate a POP PC statement here, do it in thumb_exit() */\n+      \n+      thumb_exit (f, -1);\n+      return;\n+    }\n+      \n+  asm_fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n+\n+  /* Look at the low registers first.  */\n+  \n+  for (regno = 0; regno < 8; regno ++, lo_mask >>= 1)\n+    {\n+      if (lo_mask & 1)\n+\t{\n+\t  asm_fprintf (f, reg_names[regno]);\n+\t  \n+\t  if ((lo_mask & ~1) != 0)\n+\t    asm_fprintf (f, \", \");\n+\t}\n+    }\n+  \n+  if (push && (mask & (1 << 14)))\n+    {\n+      /* Catch pushing the LR.  */\n+\n+      if (mask & 0xFF)\n+\tasm_fprintf (f, \", \");\n+      \n+      asm_fprintf (f, \"%s\", reg_names[14]);\n+    }\n+  else if (!push && (mask & (1 << 15)))\n+    {\n+      /* Catch popping the PC.  */\n+      \n+      if (TARGET_THUMB_INTERWORK || TARGET_BACKTRACE)\n+\t{\n+\t  /* The PC is never poped directly, instead\n+\t     it is popped into r3 and then BX is used. */\n+\t  \n+\t  asm_fprintf (f, \"}\\n\");\n+\n+\t  thumb_exit (f, -1);\n+\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  if (mask & 0xFF)\n+\t    asm_fprintf (f, \", \");\n+\t  \n+\t  asm_fprintf (f, \"%s\", reg_names[15]);\n+\t}\n+    }\n+       \n+  asm_fprintf (f, \"}\\n\");\n+}\n+\n+/* Returns non-zero if the current function contains a far jump */\n+\n+int\n+far_jump_used_p (void)\n+{\n+  rtx insn;\n+  \n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == JUMP_INSN\n+\t  /* Ignore tablejump patterns.  */\n+\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n+\t  && get_attr_far_jump (insn) == FAR_JUMP_YES)\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+static int return_used_this_function = 0;\n+\n+char *\n+output_return ()\n+{\n+  int regno;\n+  int live_regs_mask = 0;\n+\n+  return_used_this_function = 1;\n+\n+  for (regno = 0; regno < 8; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      live_regs_mask |= 1 << regno;\n+\n+  if (live_regs_mask == 0)\n+    {\n+      if (leaf_function_p () && ! far_jump_used_p())\n+\t{\n+\t  thumb_exit (asm_out_file, 14);\t      \n+\t}\n+      else if (TARGET_THUMB_INTERWORK || TARGET_BACKTRACE)\n+\t{\n+\t  thumb_exit (asm_out_file, -1);\n+\t}\n+      else\n+\tasm_fprintf (asm_out_file, \"\\tpop\\t{pc}\\n\");\n+    }\n+  else\n+    {\n+      asm_fprintf (asm_out_file,  \"\\tpop\\t{\");\n+      \n+      for (regno = 0; live_regs_mask; regno ++, live_regs_mask >>= 1)\n+\tif (live_regs_mask & 1)\n+\t  {\n+\t    asm_fprintf (asm_out_file, reg_names[regno]);\n+\t    if (live_regs_mask & ~1)\n+\t\tasm_fprintf (asm_out_file, \", \");\n+\t  }\n+\n+      if (TARGET_THUMB_INTERWORK || TARGET_BACKTRACE)\n+\t{\n+\t  asm_fprintf (asm_out_file, \"}\\n\");\n+\t  thumb_exit (asm_out_file, -1);\n+\t}\n+      else\n+\tasm_fprintf (asm_out_file, \", pc}\\n\");\n+    }\n+  \n+  return \"\";\n+}\n+\n+void\n+thumb_function_prologue (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+  int amount = frame_size + current_function_outgoing_args_size;\n+  int live_regs_mask = 0;\n+  int high_regs_pushed = 0;\n+  int store_arg_regs = 0;\n+  int regno;\n+\n+  if (current_function_anonymous_args && current_function_pretend_args_size)\n+    store_arg_regs = 1;\n+\n+  if (current_function_pretend_args_size)\n+    {\n+      if (store_arg_regs)\n+\t{\n+\t  asm_fprintf (f, \"\\tpush\\t{\");\n+\t  for (regno = 4 - current_function_pretend_args_size / 4 ; regno < 4;\n+\t       regno++)\n+\t    asm_fprintf (f, \"%s%s\", reg_names[regno], regno == 3 ? \"\" : \", \");\n+\t  asm_fprintf (f, \"}\\n\");\n+\t}\n+      else\n+\tasm_fprintf (f, \"\\tsub\\t%Rsp, %Rsp, #%d\\n\", \n+\t\t     current_function_pretend_args_size);\n+    }\n+\n+  for (regno = 0; regno < 8; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      live_regs_mask |= 1 << regno;\n+\n+  if (live_regs_mask || ! leaf_function_p () || far_jump_used_p())\n+    live_regs_mask |= 1 << 14;\n+\n+  if (TARGET_BACKTRACE)\n+    {\n+      char * name;\n+      int    offset;\n+      int    work_register = 0;\n+      \n+      \n+      /* We have been asked to create a stack backtrace structure.\n+         The code looks like this:\n+\t \n+\t 0   .align 2\n+\t 0   func:\n+         0     sub   SP, #16         Reserve space for 4 registers.\n+\t 2     push  {R7}            Get a work register.\n+         4     add   R7, SP, #20     Get the stack pointer before the push.\n+         6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).\n+         8     mov   R7, PC          Get hold of the start of this code plus 12.\n+        10     str   R7, [SP, #16]   Store it.\n+        12     mov   R7, FP          Get hold of the current frame pointer.\n+        14     str   R7, [SP, #4]    Store it.\n+        16     mov   R7, LR          Get hold of the current return address.\n+        18     str   R7, [SP, #12]   Store it.\n+        20     add   R7, SP, #16     Point at the start of the backtrace structure.\n+        22     mov   FP, R7          Put this value into the frame pointer.  */\n+\n+      if ((live_regs_mask & 0xFF) == 0)\n+\t{\n+\t  /* See if the a4 register is free.  */\n+\n+\t  if (regs_ever_live[ 3 ] == 0)\n+\t    work_register = 3;\n+\t  else\t  /* We must push a register of our own */\n+\t    live_regs_mask |= (1 << 7);\n+\t}\n+\n+      if (work_register == 0)\n+\t{\n+\t  /* Select a register from the list that will be pushed to use as our work register. */\n+\n+\t  for (work_register = 8; work_register--;)\n+\t    if ((1 << work_register) & live_regs_mask)\n+\t      break;\n+\t}\n+      \n+      name = reg_names[ work_register ];\n+      \n+      asm_fprintf (f, \"\\tsub\\tsp, sp, #16\\t@ Create stack backtrace structure\\n\");\n+      \n+      if (live_regs_mask)\n+\tthumb_pushpop (f, live_regs_mask, 1);\n+      \n+      for (offset = 0, work_register = 1 << 15; work_register; work_register >>= 1)\n+\tif (work_register & live_regs_mask)\n+\t  offset += 4;\n+      \n+      asm_fprintf (f, \"\\tadd\\t%s, sp, #%d\\n\",\n+\t\t   name, offset + 16 + current_function_pretend_args_size);\n+      \n+      asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 4);\n+\n+      /* Make sure that the instruction fetching the PC is in the right place\n+\t to calculate \"start of backtrace creation code + 12\".  */\n+      \n+      if (live_regs_mask)\n+\t{\n+\t  asm_fprintf (f, \"\\tmov\\t%s, pc\\n\", name);\n+\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 12);\n+\t  asm_fprintf (f, \"\\tmov\\t%s, fp\\n\", name);\n+\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset);\n+\t}\n+      else\n+\t{\n+\t  asm_fprintf (f, \"\\tmov\\t%s, fp\\n\", name);\n+\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset);\n+\t  asm_fprintf (f, \"\\tmov\\t%s, pc\\n\", name);\n+\t  asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 12);\n+\t}\n+      \n+      asm_fprintf (f, \"\\tmov\\t%s, lr\\n\", name);\n+      asm_fprintf (f, \"\\tstr\\t%s, [sp, #%d]\\n\", name, offset + 8);\n+      asm_fprintf (f, \"\\tadd\\t%s, sp, #%d\\n\", name, offset + 12);\n+      asm_fprintf (f, \"\\tmov\\tfp, %s\\t\\t@ Backtrace structure created\\n\", name);\n+    }\n+  else if (live_regs_mask)\n+    thumb_pushpop (f, live_regs_mask, 1);\n+\n+  for (regno = 8; regno < 13; regno++)\n+    {\n+      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\thigh_regs_pushed++;\n+    }\n+\n+  if (high_regs_pushed)\n+    {\n+      int pushable_regs = 0;\n+      int mask = live_regs_mask & 0xff;\n+      int next_hi_reg;\n+\n+      for (next_hi_reg = 12; next_hi_reg > 7; next_hi_reg--)\n+\t{\n+\t  if (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg])\n+\t    break;\n+\t}\n+\n+      pushable_regs = mask;\n+\n+      if (pushable_regs == 0)\n+\t{\n+\t  /* desperation time -- this probably will never happen */\n+\t  if (regs_ever_live[3] || ! call_used_regs[3])\n+\t    asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[12], reg_names[3]);\n+\t  mask = 1 << 3;\n+\t}\n+\n+      while (high_regs_pushed > 0)\n+\t{\n+\t  for (regno = 7; regno >= 0; regno--)\n+\t    {\n+\t      if (mask & (1 << regno))\n+\t\t{\n+\t\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[regno],\n+\t\t\t       reg_names[next_hi_reg]);\n+\t\t  high_regs_pushed--;\n+\t\t  if (high_regs_pushed)\n+\t\t    for (next_hi_reg--; next_hi_reg > 7; next_hi_reg--)\n+\t\t      {\n+\t\t\tif (regs_ever_live[next_hi_reg]\n+\t\t\t    && ! call_used_regs[next_hi_reg])\n+\t\t\t  break;\n+\t\t      }\n+\t\t  else\n+\t\t    {\n+\t\t      mask &= ~ ((1 << regno) - 1);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  thumb_pushpop (f, mask, 1);\n+\t}\n+\n+      if (pushable_regs == 0 && (regs_ever_live[3] || ! call_used_regs[3]))\n+\t    asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[3], reg_names[12]);\n+    }\n+}\n+\n+void\n+thumb_expand_prologue ()\n+{\n+  HOST_WIDE_INT amount = (get_frame_size ()\n+\t\t\t  + current_function_outgoing_args_size);\n+  int regno;\n+  int live_regs_mask;\n+\n+  if (amount)\n+    {\n+      live_regs_mask = 0;\n+      for (regno = 0; regno < 8; regno++)\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t  live_regs_mask |= 1 << regno;\n+\n+      if (amount < 512)\n+\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (-amount)));\n+      else\n+\t{\n+\t  rtx reg, spare;\n+\n+\t  if ((live_regs_mask & 0xff) == 0) /* Very unlikely */\n+\t    emit_insn (gen_movsi (spare = gen_rtx (REG, SImode, 12),\n+\t\t\t\t  reg = gen_rtx (REG, SImode, 4)));\n+\t  else\n+\t    {\n+\t      for (regno = 0; regno < 8; regno++)\n+\t\tif (live_regs_mask & (1 << regno))\n+\t\t  break;\n+\t      reg = gen_rtx (REG, SImode, regno);\n+\t    }\n+\n+\t  emit_insn (gen_movsi (reg, GEN_INT (-amount)));\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n+\t  if ((live_regs_mask & 0xff) == 0)\n+\t    emit_insn (gen_movsi (reg, spare));\n+\t}\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      if (current_function_outgoing_args_size)\n+\t{\n+\t  rtx offset = GEN_INT (current_function_outgoing_args_size);\n+\n+\t  if (current_function_outgoing_args_size < 1024)\n+\t    emit_insn (gen_addsi3 (frame_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   offset));\n+\t  else\n+\t    {\n+\t      emit_insn (gen_movsi (frame_pointer_rtx, offset));\n+\t      emit_insn (gen_addsi3 (frame_pointer_rtx, frame_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx));\n+\t    }\n+\t}\n+      else\n+\temit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+    }\n+\n+  /* if (profile_flag || profile_block_flag) */\n+  emit_insn (gen_blockage ());\n+}\n+\n+void\n+thumb_expand_epilogue ()\n+{\n+  HOST_WIDE_INT amount = (get_frame_size ()\n+\t\t\t  + current_function_outgoing_args_size);\n+  int regno;\n+\n+  if (amount)\n+    {\n+      if (amount < 512)\n+\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (amount)));\n+      else\n+\t{\n+\t  rtx reg = gen_rtx (REG, SImode, 3); /* Always free in the epilogue */\n+\n+\t  emit_insn (gen_movsi (reg, GEN_INT (amount)));\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n+\t}\n+      /* if (profile_flag || profile_block_flag) */\n+      emit_insn (gen_blockage ());\n+    }\n+}\n+\n+void\n+thumb_function_epilogue (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+  /* ??? Probably not safe to set this here, since it assumes that a\n+     function will be emitted as assembly immediately after we generate\n+     RTL for it.  This does not happen for inline functions.  */\n+  return_used_this_function = 0;\n+#if 0 /* TODO : comment not really needed */\n+  fprintf (f, \"%s THUMB Epilogue\\n\", ASM_COMMENT_START);\n+#endif\n+}\n+\n+/* The bits which aren't usefully expanded as rtl. */\n+char *\n+thumb_unexpanded_epilogue ()\n+{\n+  int regno;\n+  int live_regs_mask = 0;\n+  int high_regs_pushed = 0;\n+  int leaf_function = leaf_function_p ();\n+  int had_to_push_lr;\n+  \n+  if (return_used_this_function)\n+    return \"\";\n+\n+  for (regno = 0; regno < 8; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      live_regs_mask |= 1 << regno;\n+\n+  for (regno = 8; regno < 13; regno++)\n+    {\n+      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\thigh_regs_pushed++;\n+    }\n+\n+  /* The prolog may have pushed some high registers to use as\n+     work registers.  eg the testuite file:\n+     gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c\n+     compiles to produce:\n+\tpush\t{r4, r5, r6, r7, lr}\n+\tmov\tr7, r9\n+\tmov\tr6, r8\n+\tpush\t{r6, r7}\n+     as part of the prolog.  We have to undo that pushing here.  */\n+  \n+  if (high_regs_pushed)\n+    {\n+      int mask = live_regs_mask;\n+      int next_hi_reg;\n+      int size;\n+      int mode;\n+       \n+#ifdef RTX_CODE\n+      /* If we can deduce the registers used from the function's return value.\n+\t This is more reliable that examining regs_ever_live[] because that\n+\t will be set if the register is ever used in the function, not just if\n+\t the register is used to hold a return value.  */\n+\n+      if (current_function_return_rtx != 0)\n+\t{\n+\t  mode = GET_MODE (current_function_return_rtx);\n+\t}\n+      else\n+#endif\n+\t{\n+\t  mode = DECL_MODE (DECL_RESULT (current_function_decl));\n+\t}\n+\n+      size = GET_MODE_SIZE (mode);\n+\n+      /* Unless we are returning a type of size > 12 register r3 is available.  */\n+      if (size < 13)\n+\tmask |=  1 << 3;\n+\n+      if (mask == 0)\n+\t{\n+\t  /* Oh dear!  We have no low registers into which we can pop high registers!  */\n+\n+\t  fatal (\"No low registers available for popping high registers\");\n+\t}\n+      \n+      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n+\tif (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg])\n+\t  break;\n+\n+      while (high_regs_pushed)\n+\t{\n+\t  /* Find low register(s) into which the high register(s) can be popped.  */\n+\t  \n+\t  for (regno = 0; regno < 8; regno++)\n+\t    {\n+\t      if (mask & (1 << regno))\n+\t\thigh_regs_pushed--;\n+\t      if (high_regs_pushed == 0)\n+\t\tbreak;\n+\t    }\n+\n+\t  mask &= (2 << regno) - 1;\t/* A noop if regno == 8 */\n+\n+\t  /* Pop the values into the low register(s). */\n+\t  \n+\t  thumb_pushpop (asm_out_file, mask, 0);\n+\n+\t  /* Move the value(s) into the high registers.  */\n+\t  \n+\t  for (regno = 0; regno < 8; regno++)\n+\t    {\n+\t      if (mask & (1 << regno))\n+\t\t{\n+\t\t  asm_fprintf (asm_out_file, \"\\tmov\\t%s, %s\\n\", \n+\t\t\t       reg_names[next_hi_reg], reg_names[regno]);\n+\t\t  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)\n+\t\t    if (regs_ever_live[next_hi_reg] && \n+\t\t\t! call_used_regs[next_hi_reg])\n+\t\t      break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  had_to_push_lr = (live_regs_mask || ! leaf_function || far_jump_used_p());\n+  \n+  if (had_to_push_lr)\n+    {\n+      live_regs_mask |= 1 << PROGRAM_COUNTER;\n+    }\n+\n+  if (TARGET_BACKTRACE && ((live_regs_mask & 0xFF) == 0) && regs_ever_live[ ARG_4_REGISTER ] != 0)\n+    {\n+      /* The stack backtrace structure creation code had to\n+\t push R7 in order to get a work register, so we pop\n+\t it now.   */\n+      \n+      live_regs_mask |= (1 << WORK_REGISTER);\n+    }\n+  \n+  if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n+    {\n+      /* Either no argument registers were pushed or a backtrace\n+\t structure was created which includes an adjusted stack\n+\t pointer, so just pop everything.  */\n+      \n+      if (live_regs_mask)\n+\tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n+      \n+      /* We have either just popped the return address into the\n+\t PC or it is was kept in LR for the entire function.  */\n+      \n+      if (! had_to_push_lr)\n+\tthumb_exit (asm_out_file, LINK_REGISTER);\n+    }\n+  else\n+    {\n+      /* Pop everything but the return address.  */\n+      \n+      live_regs_mask &= ~ (1 << PROGRAM_COUNTER);\n+      \n+      if (live_regs_mask)\n+\tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n+\n+      if (had_to_push_lr)\n+\t{\n+\t  /* Get the return address into a temporary register.  */\n+      \n+\t  thumb_pushpop (asm_out_file, 1 << ARG_4_REGISTER, 0);\n+\t}\n+      \n+      /* Remove the argument registers that were pushed onto the stack.  */\n+      \n+      asm_fprintf (asm_out_file, \"\\tadd\\t%s, %s, #%d\\n\",\n+\t\t   reg_names[STACK_POINTER],\n+\t\t   reg_names[STACK_POINTER],\n+\t\t   current_function_pretend_args_size);\n+      \n+      thumb_exit (asm_out_file, had_to_push_lr ? ARG_4_REGISTER : LINK_REGISTER);\n+    }\n+\n+  return \"\";\n+}\n+\n+/* Handle the case of a double word load into a low register from\n+   a computed memory address.  The computed address may involve a\n+   register which is overwritten by the load.  */\n+\n+char *\n+thumb_load_double_from_address (operands)\n+     rtx * operands;\n+{\n+  rtx addr;\n+  rtx base;\n+  rtx offset;\n+  rtx arg1;\n+  rtx arg2;\n+  \n+  if (GET_CODE (operands[0]) != REG)\n+    fatal (\"thumb_load_double_from_address: destination is not a register\");\n+  \n+  if (GET_CODE (operands[1]) != MEM)\n+    fatal (\"thumb_load_double_from_address: source is not a computed memory address\");\n+\n+  /* Get the memory address.  */\n+  \n+  addr = XEXP (operands[1], 0);\n+      \n+  /* Work out how the memory address is computed.  */\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n+\n+      if (REGNO (operands[0]) == REGNO (addr))\n+\t{\n+\t  output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t  output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t  output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t}\n+      break;\n+      \n+    case CONST:\n+      /* Compute <address> + 4 for the high order load.  */\n+\t  \n+      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n+\t  \n+      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+      break;\n+\t  \n+    case PLUS:\n+      arg1   = XEXP (addr, 0);\n+      arg2   = XEXP (addr, 1);\n+\t    \n+      if (CONSTANT_P (arg1))\n+\tbase = arg2, offset = arg1;\n+      else\n+\tbase = arg1, offset = arg2;\n+  \n+      if (GET_CODE (base) != REG)\n+\tfatal (\"thumb_load_double_from_address: base is not a register\");\n+\n+      /* Catch the case of <address> = <reg> + <reg> */\n+  \n+      if (GET_CODE (offset) == REG)\n+\t{\n+\t  int reg_offset = REGNO (offset);\n+\t  int reg_base   = REGNO (base);\n+\t  int reg_dest   = REGNO (operands[0]);\n+\t  \n+\t  /* Add the base and offset registers together into the higher destination register.  */\n+\t  \n+\t  fprintf (asm_out_file, \"\\tadd\\t%s, %s, %s\\t\\t%s created by thumb_load_double_from_address\",\n+\t\t   reg_names[ reg_dest + 1 ],\n+\t\t   reg_names[ reg_base     ],\n+\t\t   reg_names[ reg_offset   ],\n+\t\t   ASM_COMMENT_START);\n+\t  \n+\t  /* Load the lower destination register from the address in the higher destination register.  */\n+\t  \n+\t  fprintf (asm_out_file, \"\\tldr\\t%s, [%s, #0]\\t\\t%s created by thumb_load_double_from_address\",\n+\t\t   reg_names[ reg_dest ],\n+\t\t   reg_names[ reg_dest + 1],\n+\t\t   ASM_COMMENT_START);\n+\t  \n+\t  /* Load the higher destination register from its own address plus 4.  */\n+\t  \n+\t  fprintf (asm_out_file, \"\\tldr\\t%s, [%s, #4]\\t\\t%s created by thumb_load_double_from_address\",\n+\t\t   reg_names[ reg_dest + 1 ],\n+\t\t   reg_names[ reg_dest + 1 ],\n+\t\t   ASM_COMMENT_START);\n+\t}\n+      else\n+\t{\n+\t  /* Compute <address> + 4 for the high order load.  */\n+\t  \n+\t  operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n+\t  \n+\t  /* If the computed address is held in the low order register\n+\t     then load the high order register first, otherwise always\n+\t     load the low order register first.  */\n+      \n+\t  if (REGNO (operands[0]) == REGNO (base))\n+\t    {\n+\t      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+\t    }\n+\t}\n+      break;\n+\n+    case LABEL_REF:\n+      /* With no registers to worry about we can just load the value directly.  */\n+      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[1], 0), 4));\n+\t  \n+      output_asm_insn (\"ldr\\t%H0, %2\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+      output_asm_insn (\"ldr\\t%0, %1\\t\\t%@ created by thumb_load_double_from_address\", operands);\n+      break;\n+      \n+    default:\n+      debug_rtx (operands[1]);\n+      fatal (\"thumb_load_double_from_address: Unhandled address calculation\");\n+      break;\n+    }\n+  \n+  return \"\";\n+}\n+\n+char *\n+output_move_mem_multiple (n, operands)\n+     int n;\n+     rtx *operands;\n+{\n+  rtx tmp;\n+\n+  switch (n)\n+    {\n+    case 2:\n+      if (REGNO (operands[2]) > REGNO (operands[3]))\n+\t{\n+\t  tmp = operands[2];\n+\t  operands[2] = operands[3];\n+\t  operands[3] = tmp;\n+\t}\n+      output_asm_insn (\"ldmia\\t%1!, {%2, %3}\", operands);\n+      output_asm_insn (\"stmia\\t%0!, {%2, %3}\", operands);\n+      break;\n+\n+    case 3:\n+      if (REGNO (operands[2]) > REGNO (operands[3]))\n+\t{\n+\t  tmp = operands[2];\n+\t  operands[2] = operands[3];\n+\t  operands[3] = tmp;\n+\t}\n+      if (REGNO (operands[3]) > REGNO (operands[4]))\n+\t{\n+\t  tmp = operands[3];\n+\t  operands[3] = operands[4];\n+\t  operands[4] = tmp;\n+\t}\n+      if (REGNO (operands[2]) > REGNO (operands[3]))\n+\t{\n+\t  tmp = operands[2];\n+\t  operands[2] = operands[3];\n+\t  operands[3] = tmp;\n+\t}\n+      output_asm_insn (\"ldmia\\t%1!, {%2, %3, %4}\", operands);\n+      output_asm_insn (\"stmia\\t%0!, {%2, %3, %4}\", operands);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return \"\";\n+}\n+\n+  \n+int\n+thumb_epilogue_size ()\n+{\n+  return 42; /* The answer to .... */\n+}\n+\n+static char *conds[] =\n+{\n+  \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\", \n+  \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\"\n+};\n+\n+static char *\n+thumb_condition_code (x, invert)\n+     rtx x;\n+     int invert;\n+{\n+  int val;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case EQ: val = 0; break;\n+    case NE: val = 1; break;\n+    case GEU: val = 2; break;\n+    case LTU: val = 3; break;\n+    case GTU: val = 8; break;\n+    case LEU: val = 9; break;\n+    case GE: val = 10; break;\n+    case LT: val = 11; break;\n+    case GT: val = 12; break;\n+    case LE: val = 13; break;\n+    default:\n+      abort ();\n+    }\n+\n+  return conds[val ^ invert];\n+}\n+\n+void\n+thumb_print_operand (f, x, code)\n+     FILE *f;\n+     rtx x;\n+     int code;\n+{\n+  if (code)\n+    {\n+      switch (code)\n+\t{\n+\tcase '@':\n+\t  fputs (ASM_COMMENT_START, f);\n+\t  return;\n+\n+\tcase 'D':\n+\t  if (x)\n+\t    fputs (thumb_condition_code (x, 1), f);\n+\t  return;\n+\n+\tcase 'd':\n+\t  if (x)\n+\t    fputs (thumb_condition_code (x, 0), f);\n+\t  return;\n+\n+\t  /* An explanation of the 'Q', 'R' and 'H' register operands:\n+\t     \n+\t     In a pair of registers containing a DI or DF value the 'Q'\n+\t     operand returns the register number of the register containing\n+\t     the least signficant part of the value.  The 'R' operand returns\n+\t     the register number of the register containing the most\n+\t     significant part of the value.\n+\n+\t     The 'H' operand returns the higher of the two register numbers.\n+\t     On a run where WORDS_BIG_ENDIAN is true the 'H' operand is the\n+\t     same as the 'Q' operand, since the most signficant part of the\n+\t     value is held in the lower number register.  The reverse is true\n+\t     on systems where WORDS_BIG_ENDIAN is false.\n+\n+\t     The purpose of these operands is to distinguish between cases\n+\t     where the endian-ness of the values is important (for example\n+\t     when they are added together), and cases where the endian-ness\n+\t     is irrelevant, but the order of register operations is important.\n+\t     For example when loading a value from memory into a register\n+\t     pair, the endian-ness does not matter.  Provided that the value\n+\t     from the lower memory address is put into the lower numbered\n+\t     register, and the value from the higher address is put into the\n+\t     higher numbered register, the load will work regardless of whether\n+\t     the value being loaded is big-wordian or little-wordian.  The\n+\t     order of the two register loads can matter however, if the address\n+\t     of the memory location is actually held in one of the registers\n+\t     being overwritten by the load.  */\n+\tcase 'Q':\n+\t  if (REGNO (x) > 15)\n+\t    abort ();\n+\t  fputs (reg_names[REGNO (x) + (WORDS_BIG_ENDIAN ? 1 : 0)], f);\n+\t  return;\n+\t  \n+\tcase 'R':\n+\t  if (REGNO (x) > 15)\n+\t    abort ();\n+\t  fputs (reg_names[REGNO (x) + (WORDS_BIG_ENDIAN ? 0 : 1)], f);\n+\t  return;\n+\n+\tcase 'H':\n+\t  if (REGNO (x) > 15)\n+\t    abort ();\n+\t  fputs (reg_names[REGNO (x) + 1], f);\n+\t  return;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  if (GET_CODE (x) == REG)\n+    fputs (reg_names[REGNO (x)], f);\n+  else if (GET_CODE (x) == MEM)\n+    output_address (XEXP (x, 0));\n+  else if (GET_CODE (x) == CONST_INT)\n+    {\n+      fputc ('#', f);\n+      output_addr_const (f, x);\n+    }\n+  else\n+    abort ();\n+}\n+\n+#ifdef AOF_ASSEMBLER\n+int arm_text_section_count = 1;\n+\n+char *\n+aof_text_section (in_readonly)\n+     int in_readonly;\n+{\n+  static char buf[100];\n+  if (in_readonly)\n+    return \"\";\n+  sprintf (buf, \"\\tCODE16\\n\\tAREA |C$$code%d|, CODE, READONLY\",\n+\t   arm_text_section_count++);\n+  return buf;\n+}\n+\n+static int arm_data_section_count = 1;\n+\n+char *\n+aof_data_section ()\n+{\n+  static char buf[100];\n+  sprintf (buf, \"\\tAREA |C$$data%d|, DATA\", arm_data_section_count++);\n+  return buf;\n+}\n+\n+/* The AOF thumb assembler is religiously strict about declarations of\n+   imported and exported symbols, so that it is impossible to declare a\n+   function as imported near the begining of the file, and then to export\n+   it later on.  It is, however, possible to delay the decision until all \n+   the functions in the file have been compiled.  To get around this, we\n+   maintain a list of the imports and exports, and delete from it any that\n+   are subsequently defined.  At the end of compilation we spit the \n+   remainder of the list out before the END directive.  */\n+\n+struct import\n+{\n+  struct import *next;\n+  char *name;\n+};\n+\n+static struct import *imports_list = NULL;\n+\n+void\n+thumb_aof_add_import (name)\n+     char *name;\n+{\n+  struct import *new;\n+\n+  for (new = imports_list; new; new = new->next)\n+    if (new->name == name)\n+      return;\n+\n+  new = (struct import *) xmalloc (sizeof (struct import));\n+  new->next = imports_list;\n+  imports_list = new;\n+  new->name = name;\n+}\n+\n+void\n+thumb_aof_delete_import (name)\n+     char *name;\n+{\n+  struct import **old;\n+\n+  for (old = &imports_list; *old; old = & (*old)->next)\n+    {\n+      if ((*old)->name == name)\n+\t{\n+\t  *old = (*old)->next;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+void\n+thumb_aof_dump_imports (f)\n+     FILE *f;\n+{\n+  while (imports_list)\n+    {\n+      fprintf (f, \"\\tIMPORT\\t\");\n+      assemble_name (f, imports_list->name);\n+      fputc ('\\n', f);\n+      imports_list = imports_list->next;\n+    }\n+}\n+#endif\n+\n+/* Decide whether a type should be returned in memory (true)\n+   or in a register (false).  This is called by the macro\n+   RETURN_IN_MEMORY.  */\n+\n+int\n+thumb_return_in_memory (type)\n+     tree type;\n+{\n+  if (! AGGREGATE_TYPE_P (type))\n+    {\n+      /* All simple types are returned in registers. */\n+\n+      return 0;\n+    }\n+  else if (int_size_in_bytes (type) > 4)\n+    {\n+      /* All structures/unions bigger than one word are returned in memory. */\n+      \n+      return 1;\n+    }\n+  else if (TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      tree field;\n+\n+      /* For a struct the APCS says that we must return in a register if\n+\t every addressable element has an offset of zero.  For practical\n+\t purposes this means that the structure can have at most one non-\n+\t bit-field element and that this element must be the first one in\n+\t the structure.  */\n+\n+      /* Find the first field, ignoring non FIELD_DECL things which will\n+\t have been created by C++. */\n+      for (field = TYPE_FIELDS (type);\n+\t   field && TREE_CODE (field) != FIELD_DECL;\n+\t   field = TREE_CHAIN (field))\n+\tcontinue;\n+\n+      if (field == NULL)\n+\treturn 0; /* An empty structure.  Allowed by an extension to ANSI C. */\n+\n+      /* Now check the remaining fields, if any. */\n+      for (field = TREE_CHAIN (field); field;  field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\t  \n+\t  if (! DECL_BIT_FIELD_TYPE (field))\n+\t    return 1;\n+\t}\n+\n+      return 0;\n+    }\n+  else if (TREE_CODE (type) == UNION_TYPE)\n+    {\n+      tree field;\n+\n+      /* Unions can be returned in registers if every element is\n+\t integral, or can be returned in an integer register.  */\n+      \n+      for (field = TYPE_FIELDS (type);\n+\t   field;\n+\t   field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\t  \n+\t  if (RETURN_IN_MEMORY (TREE_TYPE (field)))\n+\t    return 1;\n+\t}\n+      \n+      return 0;\n+    }\n+  /* XXX Not sure what should be done for other aggregates, so put them in\n+     memory. */\n+  return 1;\n+}\n+\n+void thumb_override_options()\n+{\n+  if (structure_size_string != NULL)\n+    {\n+      int size = strtol (structure_size_string, NULL, 0);\n+      \n+      if (size == 8 || size == 32)\n+\tarm_structure_size_boundary = size;\n+      else\n+\twarning (\"Structure size boundary can only be set to 8 or 32\");\n+    }\n+}"}, {"sha": "61218661b7e30a3b9727880d72a503009b1e9206", "filename": "gcc/config/arm/thumb.h", "status": "added", "additions": 1102, "deletions": 0, "changes": 1102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -0,0 +1,1102 @@\n+/* Definitions of target machine for GNU compiler, for ARM/Thumb.\n+   Copyright (C) 19996, 1997, 1998 Free Software Foundation, Inc.\n+   The basis of this contribution was generated by\n+   \t\tRichard Earnshaw, Advanced RISC Machines Ltd\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* ??? The files thumb.{c,h,md} are all seriously lacking comments.  */\n+\n+/* ??? The files thumb.{c,h,md} need to be reviewed by an experienced\n+   gcc hacker in their entirety.  */\n+\n+/* ??? The files thumb.{c,h,md} and tcoff.h are all separate from the arm\n+   files, which will lead to many maintenance problems.  These files are\n+   likely missing all bug fixes made to the arm port since they diverged.  */\n+\n+/* ??? Many patterns in the md file accept operands that will require a\n+   reload.  These should be eliminated if possible by tightening the\n+   predicates and/or constraints.  This will give faster/smaller code.  */\n+\n+/* ??? There is no pattern for the TST instuction.  Check for other unsupported\n+   instructions.  */\n+\n+/* Run Time Target Specifications */\n+#ifndef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dthumb -D__thumb -Acpu(arm) -Amachine(arm)\"\n+#endif\n+\n+#ifndef CPP_SPEC\n+#define CPP_SPEC \"\\\n+%{mbig-endian:-D__ARMEB__ -D__THUMBEB__} \\\n+%{mbe:-D__ARMEB__ -D__THUMBEB__} \\\n+%{!mbe: %{!mbig-endian:-D__ARMEL__ -D__THUMBEL__}} \\\n+\"\n+#endif\n+\n+#define ASM_SPEC \"-marm7tdmi %{mthumb-interwork:-mthumb-interwork} %{mbig-endian:-EB}\"\n+#define LINK_SPEC \"%{mbig-endian:-EB} -X\"\n+\n+#define TARGET_VERSION  fputs (\" (ARM/THUMB:generic)\", stderr);\n+\n+/* Nonzero if we should compile with BYTES_BIG_ENDIAN set to 1.  */\n+#define THUMB_FLAG_BIG_END      \t(0x0001)\n+#define THUMB_FLAG_BACKTRACE    \t(0x0002)\n+#define THUMB_FLAG_LEAF_BACKTRACE\t(0x0004)\n+#define ARM_FLAG_THUMB\t\t\t(0x1000)\t/* same as in arm.h */\n+\n+/* Run-time compilation parameters selecting different hardware/software subsets.  */\n+extern int target_flags;\n+#define TARGET_DEFAULT          0 /* ARM_FLAG_THUMB */\n+#define TARGET_BIG_END          (target_flags & THUMB_FLAG_BIG_END)\n+#define TARGET_THUMB_INTERWORK\t(target_flags & ARM_FLAG_THUMB)\n+#define TARGET_BACKTRACE\t(leaf_function_p()\t\t\t\t\\\n+\t\t\t\t ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE)\t\\\n+\t\t\t\t : (target_flags & THUMB_FLAG_BACKTRACE))\n+\n+#define TARGET_SWITCHES                                 \\\n+{                                                       \\\n+  {\"big-endian\",\t\tTHUMB_FLAG_BIG_END},\t\\\n+  {\"little-endian\",\t       -THUMB_FLAG_BIG_END},\t\\\n+  {\"thumb-interwork\",\t\tARM_FLAG_THUMB},\t\\\n+  {\"no-thumb-interwork\",       -ARM_FLAG_THUMB},\t\\\n+  {\"tpcs-frame\",\t\tTHUMB_FLAG_BACKTRACE},\t\\\n+  {\"no-tpcs-frame\",            -THUMB_FLAG_BACKTRACE},\t\\\n+  {\"tpcs-leaf-frame\",\t\tTHUMB_FLAG_LEAF_BACKTRACE},\t\\\n+  {\"no-tpcs-leaf-frame\",       -THUMB_FLAG_LEAF_BACKTRACE},\t\\\n+  {\"\",                          TARGET_DEFAULT}         \\\n+}\n+\n+#define TARGET_OPTIONS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  { \"structure-size-boundary=\", & structure_size_string }, \\\n+}\n+\n+#define REGISTER_PREFIX \"\"\n+\n+#define CAN_DEBUG_WITHOUT_FP 1\n+\f\n+#define ASM_APP_ON  \"\"\n+#define ASM_APP_OFF \"\\t.code\\t16\\n\"\n+\n+/* Output a gap.  In fact we fill it with nulls.  */\n+#define ASM_OUTPUT_SKIP(STREAM, NBYTES)  \\\n+  fprintf ((STREAM), \"\\t.space\\t%u\\n\", (NBYTES))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(STREAM,LOG)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\", (LOG));\t\t\t\t\\\n+}\n+\n+/* Output a common block */\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n+  (fprintf ((STREAM), \"\\t.comm\\t\"), \t\t     \t\t\t\\\n+   assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n+   fprintf((STREAM), \", %d\\t%s %d\\n\", (ROUNDED), (ASM_COMMENT_START), (SIZE)))\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING,PREFIX,NUM)        \\\n+  sprintf ((STRING), \"*%s%s%d\", (LOCAL_LABEL_PREFIX), (PREFIX), (NUM))\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM,PREFIX,NUM)\t\t\t\\\n+  fprintf ((STREAM), \"%s%s%d:\\n\", (LOCAL_LABEL_PREFIX), (PREFIX), (NUM))\n+\n+/* This is how to output a label which precedes a jumptable.  Since\n+   instructions are 2 bytes, we need explicit alignment here.  */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\t\\\n+    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n+  } while (0)\n+\n+/* This says how to define a local common symbol (ie, not visible to\n+   linker).  */\n+#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n+  (fprintf((STREAM),\"\\n\\t.lcomm\\t\"),                                    \\\n+   assemble_name((STREAM),(NAME)),                                      \\\n+   fprintf((STREAM),\",%u\\n\",(SIZE)))\n+\n+/* Output a reference to a label.  */\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n+  fprintf ((STREAM), \"%s%s\", USER_LABEL_PREFIX, (NAME))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(STREAM,VALUE)\t\t\t\t\t\\\n+  fprintf ((STREAM), \"\\t.byte\\t0x%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n+  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.short\\t\");\t\t\t\t\t\\\n+  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_CHAR(STREAM,VALUE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.byte\\t\");\t\t\t\t\t\\\n+  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     long l[3];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+     fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\", \\\n+\t      l[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \t\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     long l[2];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n+     fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n+\t      l[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     long l;\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n+     fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\t\\\n+\t      ASM_COMMENT_START, dstr);\t\t\t\t\t\\\n+   } while (0);\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\n+/* This is how to output a string.  */\n+#define ASM_OUTPUT_ASCII(STREAM, STRING, LEN)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  register int i, c, len = (LEN), cur_pos = 17;\t\t\t\t\\\n+  register unsigned char *string = (unsigned char *)(STRING);\t\t\\\n+  fprintf ((STREAM), \"\\t.ascii\\t\\\"\");\t\t\t\t\t\\\n+  for (i = 0; i < len; i++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register int c = string[i];\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      switch (c)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase '\\\"':\t\t\t\t\t\t\t\\\n+\tcase '\\\\':\t\t\t\t\t\t\t\\\n+\t  putc ('\\\\', (STREAM));\t\t\t\t\t\\\n+\t  putc (c, (STREAM));\t\t\t\t\t\t\\\n+\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase TARGET_NEWLINE:\t\t\t\t\t\t\\\n+\t  fputs (\"\\\\n\", (STREAM));\t\t\t\t\t\\\n+\t  if (i+1 < len\t\t\t\t\t\t\t\\\n+\t      && (((c = string[i+1]) >= '\\040' && c <= '~')\t\t\\\n+\t\t  || c == TARGET_TAB))\t\t\t\t\t\\\n+\t    cur_pos = 32767;\t\t/* break right here */\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    cur_pos += 2;\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase TARGET_TAB:\t\t\t\t\t\t\\\n+\t  fputs (\"\\\\t\", (STREAM));\t\t\t\t\t\\\n+\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase TARGET_FF:\t\t\t\t\t\t\t\\\n+\t  fputs (\"\\\\f\", (STREAM));\t\t\t\t\t\\\n+\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase TARGET_BS:\t\t\t\t\t\t\t\\\n+\t  fputs (\"\\\\b\", (STREAM));\t\t\t\t\t\\\n+\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tcase TARGET_CR:\t\t\t\t\t\t\t\\\n+\t  fputs (\"\\\\r\", (STREAM));\t\t\t\t\t\\\n+\t  cur_pos += 2;\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\t\\\n+\t  if (c >= ' ' && c < 0177)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      putc (c, (STREAM));\t\t\t\t\t\\\n+\t      cur_pos++;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf ((STREAM), \"\\\\%03o\", c);\t\t\t\t\\\n+\t      cur_pos += 4;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (cur_pos > 72 && i+1 < len)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  cur_pos = 17;\t\t\t\t\t\t\t\\\n+\t  fprintf ((STREAM), \"\\\"\\n\\t.ascii\\t\\\"\");\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((STREAM), \"\\\"\\n\");\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Output and Generation of Labels */\n+#define ASM_OUTPUT_LABEL(STREAM,NAME) \\\n+  (assemble_name ((STREAM), (NAME)),  \\\n+   fprintf ((STREAM), \":\\n\"))\n+\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)      \\\n+ (fprintf ((STREAM), \"\\t.globl\\t\"),           \\\n+  assemble_name ((STREAM), (NAME)),           \\\n+  fputc ('\\n', (STREAM)))\n+\n+/* Construct a private name.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n+   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \".text\"\n+#define DATA_SECTION_ASM_OP  \".data\"\n+#define BSS_SECTION_ASM_OP   \".bss\"\n+\n+/* The assembler's names for the registers.  */\n+#ifndef REGISTER_NAMES\n+#define REGISTER_NAMES  \\\n+{\t\t\t\t                   \\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n+  \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\", \"ap\"   \\\n+}\n+#endif\n+\n+#ifndef ADDITIONAL_REGISTER_NAMES\n+#define ADDITIONAL_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"a1\", 0},\t\t\t\t\t\\\n+  {\"a2\", 1},\t\t\t\t\t\\\n+  {\"a3\", 2},\t\t\t\t\t\\\n+  {\"a4\", 3},\t\t\t\t\t\\\n+  {\"v1\", 4},\t\t\t\t\t\\\n+  {\"v2\", 5},\t\t\t\t\t\\\n+  {\"v3\", 6},\t\t\t\t\t\\\n+  {\"v4\", 7},\t\t\t\t\t\\\n+  {\"v5\", 8},\t\t\t\t\t\\\n+  {\"v6\", 9},\t\t\t\t\t\\\n+  {\"sb\", 9},\t\t\t\t\t\\\n+  {\"v7\", 10},\t\t\t\t\t\\\n+  {\"r10\", 10},\t/* sl */\t\t\t\\\n+  {\"r11\", 11},\t/* fp */\t\t\t\\\n+  {\"r12\", 12},\t/* ip */\t\t\t\\\n+  {\"r13\", 13},\t/* sp */\t\t\t\\\n+  {\"r14\", 14},\t/* lr */\t\t\t\\\n+  {\"r15\", 15}\t/* pc */\t\t\t\\\n+}\n+#endif\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \"@\"\n+#endif\n+\n+/* Output an element of a dispatch table.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n+   fprintf (STREAM, \"\\t.word\\t%sL%d\\n\", (LOCAL_LABEL_PREFIX), (VALUE))\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \\\n+   fprintf (STREAM, \"\\tb\\t%sL%d\\n\", (LOCAL_LABEL_PREFIX), (VALUE))\n+\f\n+/* Storage Layout */\n+\n+/* Define this is most significant bit is lowest numbered in\n+   instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest\n+   numbered.  */\n+#define BYTES_BIG_ENDIAN (TARGET_BIG_END != 0)\n+\n+#define WORDS_BIG_ENDIAN (BYTES_BIG_ENDIAN)\n+\n+/* LIBGCC2_WORDS_BIG_ENDIAN has to be a constant, so we define this based\n+   on processor pre-defineds when compiling libgcc2.c.  */\n+#if defined(__THUMBEB__) && !defined(__THUMBEL__)\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN 0\n+#endif\n+\n+#define FLOAT_WORDS_BIG_ENDIAN 1\n+\n+#define BITS_PER_UNIT 8\n+#define BITS_PER_WORD 32\n+\n+#define UNITS_PER_WORD 4\n+\n+#define POINTER_SIZE 32\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n+{\t\t\t\t\t\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4)\t\t\\\n+    {\t\t\t\t\t\t\\\n+      (UNSIGNEDP) = 1;\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+#define PARM_BOUNDARY 32\n+#define STACK_BOUNDARY 32\n+\n+#define FUNCTION_BOUNDARY 32\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST        \\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n+/* Used when parsing command line option -mstructure_size_boundary.  */\n+extern char * structure_size_string;\n+\n+#define STRICT_ALIGNMENT 1\n+\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+\f\n+/* Layout of Source Language Data Types  */\n+\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\n+\f\n+/* Register Usage */\n+\n+/* Note there are 16 hard registers on the Thumb.  We invent a 17th register\n+   which is assigned to ARG_POINTER_REGNUM, but this is later removed by\n+   elimination passes in the compiler.  */\n+#define FIRST_PSEUDO_REGISTER 17\n+\n+/* ??? This is questionable.  */\n+#define FIXED_REGISTERS \\\n+{\t\t\t\\\n+  0,0,0,0,\t\t\\\n+  0,0,0,0,\t\t\\\n+  0,0,0,1,\t\t\\\n+  0,1,1,1,1\t\t\\\n+}\n+\n+/* ??? This is questionable.  */\n+#define CALL_USED_REGISTERS\t\\\n+{\t\t\t\t\\\n+  1,1,1,1,\t\t\t\\\n+  0,0,0,0,\t\t\t\\\n+  0,0,0,1,\t\t\t\\\n+  1,1,1,1,1\t\t\t\\\n+}\n+\n+#define HARD_REGNO_NREGS(REGNO,MODE)\t\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)\t\\\n+   / UNITS_PER_WORD)\n+\n+/* ??? Probably should only allow DImode/DFmode in even numbered registers.  */\n+#define HARD_REGNO_MODE_OK(REGNO,MODE) ((GET_MODE_SIZE (MODE) > UNITS_PER_WORD) ? (REGNO < 7) : 1)\n+\n+#define MODES_TIEABLE_P(MODE1,MODE2) 1\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  LO_REGS,\n+  STACK_REG,\n+  BASE_REGS,\n+  HI_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES \\\n+{\t\t\t\\\n+  \"NO_REGS\",\t\t\\\n+  \"LO_REGS\",\t\t\\\n+  \"STACK_REG\",\t\t\\\n+  \"BASE_REGS\",\t\t\\\n+  \"HI_REGS\",\t\t\\\n+  \"ALL_REGS\"\t\t\\\n+}\n+\n+#define REG_CLASS_CONTENTS\t\\\n+{\t\t\t\t\\\n+  0x00000,\t\t\t\\\n+  0x000ff,\t\t\t\\\n+  0x02000,\t\t\t\\\n+  0x020ff,\t\t\t\\\n+  0x0ff00,\t\t\t\\\n+  0x1ffff,\t\t\t\\\n+}\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\\\n+ ((REGNO) == STACK_POINTER_REGNUM ? STACK_REG\t\\\n+  : (REGNO) < 8 ? LO_REGS\t\t\t\\\n+  : HI_REGS)\n+\n+#define BASE_REG_CLASS BASE_REGS\n+\n+#define INDEX_REG_CLASS LO_REGS\n+\n+/* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers. */\n+\n+#define SMALL_REGISTER_CLASSES 1\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'l' ? LO_REGS\t\t\\\n+   : (C) == 'h' ? HI_REGS\t\\\n+   : (C) == 'b' ? BASE_REGS\t\\\n+   : (C) == 'k' ? STACK_REG\t\\\n+   : NO_REGS)\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n+  ((REGNO) < 8\t\t\t\t\t\t\t\\\n+   || (REGNO) == STACK_POINTER_REGNUM\t\t\t\t\\\n+   || (unsigned) reg_renumber[REGNO] < 8\t\t\t\\\n+   || (unsigned) reg_renumber[REGNO] == STACK_POINTER_REGNUM)\n+\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t\t\t\\\n+  ((REGNO) < 8\t\t\t\t\t\t\t\\\n+   || (unsigned) reg_renumber[REGNO] < 8\t\t\t\\\n+   || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+       && ((REGNO) == STACK_POINTER_REGNUM\t\t\t\\\n+\t   || (unsigned) reg_renumber[REGNO] == STACK_POINTER_REGNUM)))\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\\\n+  ((REGNO) < 8\t\t\t\t\t\\\n+   || (unsigned) reg_renumber[REGNO] < 8)\n+\n+/* ??? This looks suspiciously wrong.  */\n+/* We need to leave BASE_REGS reloads alone, in order to avoid caller_save\n+   lossage.  Caller_saves requests a BASE_REGS reload (caller_save_spill_class)\n+   and then later we verify that one was allocated.  If PREFERRED_RELOAD_CLASS\n+   says to allocate a LO_REGS spill instead, then this mismatch gives an\n+   abort.  Alternatively, this could be fixed by modifying BASE_REG_CLASS\n+   to be LO_REGS instead of BASE_REGS.  It is not clear what affect this\n+   change would have.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+  ((CLASS) == BASE_REGS ? (CLASS)\t\\\n+   : LO_REGS)\n+/*\n+  ((CONSTANT_P ((X)) && GET_CODE ((X)) != CONST_INT\t\t\\\n+    && ! CONSTANT_POOL_ADDRESS_P((X))) ? NO_REGS\t\t\\\n+   : (GET_CODE ((X)) == CONST_INT\t\t\t\t\\\n+      && (unsigned HOST_WIDE_INT) INTVAL ((X)) > 255) ? NO_REGS\t\\\n+   : LO_REGS) */\n+\n+/* Must leave BASE_REGS reloads alone, see comment above.  */\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,X)\t\t\t\t\\\n+   ((CLASS) != LO_REGS && (CLASS) != BASE_REGS\t\t\t\t\\\n+   ? ((true_regnum (X) == -1 ? LO_REGS\t\t\t\t\t\\\n+       : (true_regnum (X) + HARD_REGNO_NREGS (0, MODE) > 8) ? LO_REGS\t\\\n+       : NO_REGS)) \t\t\t\t\t\t\t\\\n+   : NO_REGS)\n+\n+#define CLASS_MAX_NREGS(CLASS,MODE) HARD_REGNO_NREGS(0,(MODE))\n+\n+int thumb_shiftable_const ();\n+\n+#define CONST_OK_FOR_LETTER_P(VAL,C)\t\t\t\t\\\n+  ((C) == 'I' ? (unsigned HOST_WIDE_INT) (VAL) < 256\t\t\\\n+   : (C) == 'J' ? (VAL) > -256 && (VAL) <= 0\t\t\t\\\n+   : (C) == 'K' ? thumb_shiftable_const (VAL)\t\t\t\\\n+   : (C) == 'L' ? (VAL) > -8 && (VAL) < 8\t\t\t\\\n+   : (C) == 'M' ? ((unsigned HOST_WIDE_INT) (VAL) < 1024\t\\\n+\t\t   && ((VAL) & 3) == 0)\t\t\t\t\\\n+   : (C) == 'N' ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\t\\\n+   : (C) == 'O' ? ((VAL) >= -508 && (VAL) <= 508)\t\t\\\n+   : 0)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VAL,C) 0\n+\n+#define EXTRA_CONSTRAINT(X,C)\t\t\t\t\t\t\\\n+  ((C) == 'Q' ? (GET_CODE (X) == MEM\t\t\t\t\t\\\n+\t\t && GET_CODE (XEXP (X, 0)) == LABEL_REF) : 0)\n+\f\n+/* Stack Layout and Calling Conventions */\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+/* #define FRAME_GROWS_DOWNWARD 1 */\n+\n+/* #define ARGS_GROW_DOWNWARD 1 */\n+\n+#define STARTING_FRAME_OFFSET 0\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Registers that address the stack frame */\n+\n+#define STACK_POINTER_REGNUM  13\t/* Defined by the TPCS.  */\n+\n+#define FRAME_POINTER_REGNUM  7\t\t/* TPCS defines this as 11 but it does not really mean it.  */\n+\n+#define ARG_POINTER_REGNUM    16\t/* A fake hard register that is eliminated later on.  */\n+\n+#define STATIC_CHAIN_REGNUM 9\n+\n+#define FRAME_POINTER_REQUIRED 0\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+ {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+/* On the Thumb we always want to perform the eliminations as we\n+   actually only have one real register pointing to the stashed\n+   variables: the stack pointer, and we never use the frame pointer.  */\n+#define CAN_ELIMINATE(FROM,TO)  1\n+\n+/* Note:  This macro must match the code in thumb_function_prologue() in thumb.c.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM,TO,OFFSET)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+  if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int count_regs = 0;\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\\\n+      (OFFSET) += get_frame_size (); \t\t\t\t\\\n+      for (regno = 8; regno < 13; regno++)\t\t\t\\\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+\t  count_regs++;\t\t\t\t\t\t\\\n+      if (count_regs)\t\t\t\t\t\t\\\n+\t(OFFSET) += 4 * count_regs;\t \t\t\t\\\n+      count_regs = 0;\t\t\t\t\t\t\\\n+      for (regno = 0; regno < 8; regno++)\t\t\t\\\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+\t  count_regs++;\t\t\t\t\t\t\\\n+      if (count_regs || ! leaf_function_p () || far_jump_used_p())\t\\\n+\t(OFFSET) += 4 * (count_regs + 1);\t\t\t\\\n+      if (TARGET_BACKTRACE) {\t\t\t\t\t\\\n+\tif ((count_regs & 0xFF) == 0 && (regs_ever_live[3] != 0))\t\\\n+\t  (OFFSET) += 20;\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  (OFFSET) += 16; }\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n+    (OFFSET) += current_function_outgoing_args_size;\t\t\\\n+}\n+\n+/* Passing Arguments on the stack */\n+\n+#define PROMOTE_PROTOTYPES 1\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+#define FUNCTION_ARG(CUM,MODE,TYPE,NAMED)\t\t\t\t\\\n+ ((NAMED) ? ((CUM) >= 16 ? 0 : gen_rtx (REG, (MODE), (CUM) / 4))\t\\\n+  : 0)\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM,MODE,TYPE,NAMED)\t\t\t\\\n+ (((CUM) < 16 && (CUM) + (((MODE) == BLKmode)\t\t\t\t\\\n+\t\t\t  ? int_size_in_bytes (TYPE)\t\t\t\\\n+\t\t\t  : HARD_REGNO_NREGS (0, (MODE)) * 4) > 16)\t\\\n+  ? 4 - (CUM) / 4 : 0)\n+\n+#define CUMULATIVE_ARGS int\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t\t\\\n+ ((CUM) = ((FNTYPE) && aggregate_value_p (TREE_TYPE (FNTYPE))) ? 4 : 0)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM,MODE,TYPE,NAMED)\t\\\n+ (CUM) += ((((MODE) == BLKmode)\t\t\t\t\\\n+\t    ? int_size_in_bytes (TYPE)\t\t\t\\\n+\t    : GET_MODE_SIZE (MODE)) + 3) & ~3\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t\\\n+  ((REGNO) >=0 && (REGNO) <= 3)\n+\n+#define FUNCTION_VALUE(VALTYPE,FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+#define LIBCALL_VALUE(MODE) gen_rtx (REG, (MODE), 0)\n+\n+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == 0)\n+\n+     /* How large values are returned */\n+/* A C expression which can inhibit the returning of certain function values\n+   in registers, based on the type of value. */\n+#define RETURN_IN_MEMORY(TYPE) thumb_return_in_memory (TYPE)\n+     \n+/* Define DEFAULT_PCC_STRUCT_RETURN to 1 if all structure and union return\n+   values must be in memory.  On the ARM, they need only do so if larger\n+   than a word, or if they contain elements offset from zero in the struct. */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+\n+#define STRUCT_VALUE_REGNUM 0\n+\n+#define FUNCTION_PROLOGUE(FILE,SIZE) thumb_function_prologue((FILE),(SIZE))\n+\n+#define FUNCTION_EPILOGUE(FILE,SIZE) thumb_function_epilogue((FILE),(SIZE))\n+\n+/* Generating code for profiling */\n+#define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  fprintf ((STREAM), \"\\tmov\\\\tip, lr\\n\");\t\t\\\n+  fprintf ((STREAM), \"\\tbl\\tmcount\\n\");\t\t\t\\\n+  fprintf ((STREAM), \"\\t.word\\tLP%d\\n\", (LABELNO));\t\\\n+}\n+\n+/* Implementing the Varargs Macros */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern int current_function_anonymous_args;\t\t\t\t\\\n+  current_function_anonymous_args = 1;\t\t\t\t\t\\\n+  if ((CUM) < 16)\t\t\t\t\t\t\t\\\n+    (PRETEND_SIZE) = 16 - (CUM);\t\t\t\t\t\\\n+}\n+\n+/* Trampolines for nested functions */\n+\n+/* Output assembler code for a block containing the constant parts of\n+   a trampoline, leaving space for the variable parts.\n+\n+   On the Thumb we always switch into ARM mode to execute the trampoline.\n+   Why - because it is easier.  This code will always be branched to via\n+   a BX instruction and since the compiler magically generates the address\n+   of the function the linker has no opportunity to ensure that the\n+   bottom bit is set.  Thus the processor will be in ARM mode when it\n+   reaches this code.  So we duplicate the ARM trampoline code and add\n+   a switch into Thumb mode as well.\n+   \n+   On the ARM, (if r8 is the static chain regnum, and remembering that\n+   referencing pc adds an offset of 8) the trampoline looks like:\n+\t   ldr \t\tr8, [pc, #0]\n+\t   ldr\t\tpc, [pc]\n+\t   .word\tstatic chain value\n+\t   .word\tfunction's address\n+   ??? FIXME: When the trampoline returns, r8 will be clobbered.  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.code 32\\n\");\t\t\t\t\\\n+  fprintf ((FILE), \".Ltrampoline_start:\\n\");\t\t\t\\\n+  fprintf ((FILE), \"\\tldr\\t%s, [%spc, #8]\\n\",\t\t\t\\\n+\t   reg_names[STATIC_CHAIN_REGNUM], REGISTER_PREFIX);\t\\\n+  fprintf ((FILE), \"\\tldr\\t%sip, [%spc, #8]\\n\",\t\t\t\\\n+\t   REGISTER_PREFIX, REGISTER_PREFIX);\t\t\t\\\n+  fprintf ((FILE), \"\\torr\\t%sip, %sip, #1\\n\",                   \\\n+\t   REGISTER_PREFIX, REGISTER_PREFIX);                   \\\n+  fprintf ((FILE), \"\\tbx\\t%sip\\n\", REGISTER_PREFIX);\t        \\\n+  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.code 16\\n\");\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE  24\n+\n+/* Alignment required for a trampoline in units.  */\n+#define TRAMPOLINE_ALIGN  4\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR,FNADDR,CHAIN)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((ADDR), 16)),\t\\\n+\t\t  (CHAIN));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((ADDR), 20)),\t\\\n+\t\t  (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Implicit Calls to Library Routines */\n+\n+#define TARGET_MEM_FUNCTIONS 1\n+\n+#define OVERRIDE_OPTIONS  thumb_override_options ()\n+\n+\f\n+/* Addressing Modes */\n+\n+#define HAVE_POST_INCREMENT 1\n+\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n+ (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X))\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+#ifdef REG_OK_STRICT\n+\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n+#define REG_MODE_OK_FOR_BASE_P(X,MODE)\t\t\t\\\n+  REGNO_MODE_OK_FOR_BASE_P (REGNO (X), MODE)\n+\n+#else /* REG_OK_STRICT */\n+\n+#define REG_OK_FOR_BASE_P(X)\t\t\t\t\\\n+ (REGNO (X) < 8 || REGNO (X) == STACK_POINTER_REGNUM\t\\\n+  || (X) == arg_pointer_rtx\t\t\t\t\\\n+  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#define REG_MODE_OK_FOR_BASE_P(X,MODE)\t\t\t\\\n+ (REGNO (X) < 8\t\t\t\t\t\t\\\n+  || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\t\t\\\n+  || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+      && (REGNO (X) == STACK_POINTER_REGNUM\t\t\\\n+\t  || (X) == arg_pointer_rtx)))\n+\n+#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\\\n+ (REGNO (X) < 8\t\t\t\t\t\t\\\n+  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#endif /* REG_OK_STRICT */\n+\n+/* In a REG+REG address, both must be INDEX registers.  */\n+#define REG_OK_FOR_INDEXED_BASE_P(X) REG_OK_FOR_INDEX_P(X)\n+\n+#define LEGITIMATE_OFFSET(MODE,VAL)\t\t\t\t\\\n+(GET_MODE_SIZE (MODE) == 1 ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\\\n+ : GET_MODE_SIZE (MODE) == 2 ? ((unsigned HOST_WIDE_INT) (VAL) < 64\t\\\n+\t\t\t\t&& ((VAL) & 1) == 0)\t\t\t\\\n+ : ((VAL) >= 0 && ((VAL) + GET_MODE_SIZE (MODE)) <= 128\t\t\t\\\n+    && ((VAL) & 3) == 0))\n+\n+/* The AP may be eliminated to either the SP or the FP, so we use the\n+   least common denominator, e.g. SImode, and offsets from 0 to 64.  */\n+\n+/* ??? Verify whether the above is the right approach.  */\n+\n+/* ??? Also, the FP may be eliminated to the SP, so perhaps that\n+   needs special handling also.  */\n+\n+/* ??? Look at how the mips16 port solves this problem.  It probably uses\n+   better ways to solve some of these problems.  */\n+\n+/* Although it is not incorrect, we don't accept QImode and HImode\n+   addresses based on the frame pointer or arg pointer until the reload pass starts.\n+   This is so that eliminating such addresses into stack based ones\n+   won't produce impossible code.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* ??? Not clear if this is right.  Experiment.  */\t\t\t\\\n+  if (GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\t\\\n+      && ! (reload_in_progress || reload_completed)\t\t\t\\\n+      && (reg_mentioned_p (frame_pointer_rtx, X)\t\t\t\\\n+\t  || reg_mentioned_p (arg_pointer_rtx, X)\t\t\t\\\n+\t  || reg_mentioned_p (virtual_incoming_args_rtx, X)\t\t\\\n+\t  || reg_mentioned_p (virtual_outgoing_args_rtx, X)\t\t\\\n+\t  || reg_mentioned_p (virtual_stack_dynamic_rtx, X)\t\t\\\n+\t  || reg_mentioned_p (virtual_stack_vars_rtx, X)))\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  /* Accept any base register.  SP only in SImode or larger.  */\t\\\n+  else if (GET_CODE (X) == REG && REG_MODE_OK_FOR_BASE_P(X, MODE))\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\t\\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && CONSTANT_P (X)\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X))\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\t\\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n+\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n+\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n+\t\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\\\n+\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF\t\\\n+\t\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)))\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  /* Post-inc indexing only supported for SImode and larger.  */\t\\\n+  else if (GET_CODE (X) == POST_INC && GET_MODE_SIZE (MODE) >= 4\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* REG+REG address can be any two index registers.  */\t\t\\\n+      /* ??? Normally checking the mode here is wrong, since it isn't\t\\\n+\t impossible to use REG+REG with DFmode.  However, the movdf\t\\\n+\t pattern requires offsettable addresses, and REG+REG is not\t\\\n+\t offsettable, so it must be rejected somehow.  Trying to use\t\\\n+\t 'o' fails, because offsettable_address_p does a QImode check.\t\\\n+\t QImode is not valid for stack addresses, and has a smaller\t\\\n+\t range for non-stack bases, and this causes valid addresses\t\\\n+\t to be rejected.  So we just eliminate REG+REG here by checking\t\\\n+\t the mode.  */\t\t\t\t\t\t\t\\\n+      /* We also disallow FRAME+REG addressing since we know that FRAME \\\n+\t will be replaced with STACK, and SP relative addressing only   \\\n+\t permits SP+OFFSET.  */\t\t\t\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t  && REGNO (XEXP (X, 0)) != FRAME_POINTER_REGNUM\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      /* REG+const has 5-7 bit offset for non-SP registers.  */\t\t\\\n+      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t       && (REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n+\t\t   || XEXP (X, 0) == arg_pointer_rtx)\t\t\t\\\n+\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t       && LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      /* REG+const has 10 bit offset for SP, but only SImode and\t\\\n+\t larger is supported.  */\t\t\t\t\t\\\n+      /* ??? Should probably check for DI/DFmode overflow here\t\t\\\n+\t just like GO_IF_LEGITIMATE_OFFSET does.  */\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t       && REGNO (XEXP (X, 0)) == STACK_POINTER_REGNUM\t\t\\\n+\t       && GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+\t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t       && (unsigned HOST_WIDE_INT) INTVAL (XEXP (X, 1)) < 1024\t\\\n+\t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\n+\n+#define LEGITIMATE_CONSTANT_P(X)\t\\\n+ (GET_CODE (X) == CONST_INT\t\t\\\n+  || GET_CODE (X) == CONST_DOUBLE\t\\\n+  || CONSTANT_ADDRESS_P (X))\n+\n+\f\n+/* Condition Code Status */\n+\n+#define NOTICE_UPDATE_CC(EXP,INSN)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (get_attr_conds ((INSN)) != CONDS_UNCHANGED)\t\\\n+    CC_STATUS_INIT;\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Describing Relative Costs of Operations */\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+#define SLOW_UNALIGNED_ACCESS 1\n+\n+#define NO_FUNCTION_CSE 1\n+\n+#define NO_RECURSIVE_FUNCTION_CSE 1\n+\n+#define REGISTER_MOVE_COST(FROM,TO) \\\n+  (((FROM) == HI_REGS || (TO) == HI_REGS) ? 4 : 2)\n+\n+#define MEMORY_MOVE_COST(M,CLASS,IN) \\\n+     ((GET_MODE_SIZE(M) < 4 ? 8 : 2 * GET_MODE_SIZE(M)) * (CLASS == LO_REGS ? 1 : 2))\n+\n+/* This will allow better space optimization when compiling with -O */\n+#define BRANCH_COST (optimize > 1 ? 1 : 0)\n+\n+#define RTX_COSTS(X,CODE,OUTER)\t\t\t\t\t\\\n+ case MULT:\t\t\t\t\t\t\t\\\n+   if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+       int cycles = 0;\t\t\t\t\t\t\\\n+       unsigned HOST_WIDE_INT i = INTVAL (XEXP (X, 1));\t\t\\\n+       while (i)\t\t\t\t\t\t\\\n+\t {\t\t\t\t\t\t\t\\\n+\t   i >>= 2;\t\t\t\t\t\t\\\n+\t   cycles++;\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\\\n+       return COSTS_N_INSNS (2) + cycles;\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\\\n+   return COSTS_N_INSNS (1) + 16;\t\t\t\t\\\n+ case ASHIFT: case ASHIFTRT: case LSHIFTRT: case ROTATERT:\t\\\n+ case PLUS: case MINUS: case COMPARE: case NEG: case NOT:\t\\\n+   return COSTS_N_INSNS (1);\t\t\t\t\t\\\n+ case SET:\t\t\t\t\t\t\t\\\n+   return (COSTS_N_INSNS (1)\t\t\t\t\t\\\n+\t   + 4 * ((GET_CODE (SET_SRC (X)) == MEM)\t\t\\\n+\t\t  + GET_CODE (SET_DEST (X)) == MEM))\n+\n+#define CONST_COSTS(X,CODE,OUTER)\t\t\t\t\\\n+ case CONST_INT:\t\t\t\t\t\t\\\n+   if ((OUTER) == SET)\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+       if ((unsigned HOST_WIDE_INT) INTVAL (X) < 256)\t\t\\\n+\t return 0;\t\t\t\t\t\t\\\n+       if (thumb_shiftable_const (INTVAL (X)))\t\t\t\\\n+\t return COSTS_N_INSNS (2);\t\t\t\t\\\n+       return COSTS_N_INSNS (3);\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\\\n+   else if (OUTER == PLUS\t\t\t\t\t\\\n+\t    && INTVAL (X) < 256 && INTVAL (X) > -256)\t\t\\\n+     return 0;\t\t\t\t\t\t\t\\\n+   else if (OUTER == COMPARE\t\t\t\t\t\\\n+\t    && (unsigned HOST_WIDE_INT) INTVAL (X) < 256)\t\\\n+     return 0;\t\t\t\t\t\t\t\\\n+   else if (OUTER == ASHIFT || OUTER == ASHIFTRT\t\t\\\n+\t    || OUTER == LSHIFTRT)\t\t\t\t\\\n+     return 0;\t\t\t\t\t\t\t\\\n+   return COSTS_N_INSNS (2);\t\t\t\t\t\\\n+ case CONST:\t\t\t\t\t\t\t\\\n+ case CONST_DOUBLE:\t\t\t\t\t\t\\\n+ case LABEL_REF:\t\t\t\t\t\t\\\n+ case SYMBOL_REF:\t\t\t\t\t\t\\\n+   return COSTS_N_INSNS(3);\n+\n+#define ADDRESS_COST(X) \t\t\t\t\t\\\n+  ((GET_CODE (X) == REG \t\t\t\t\t\\\n+    || (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == CONST_INT))\t\t\\\n+   ? 1 : 2)\n+\n+\f\n+/* Position Independent Code */\n+\n+#define PRINT_OPERAND(STREAM,X,CODE) \\\n+  thumb_print_operand((STREAM), (X), (CODE))\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM,X)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE ((X)) == REG)\t\t\t\t\t\\\n+    fprintf ((STREAM), \"[%s]\", reg_names[REGNO ((X))]);\t\t\\\n+  else if (GET_CODE ((X)) == POST_INC)\t\t\t\t\\\n+    fprintf ((STREAM), \"%s!\", reg_names[REGNO (XEXP (X, 0))]);\t\\\n+  else if (GET_CODE ((X)) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP ((X), 1)) == CONST_INT)\t\t\\\n+\tfprintf ((STREAM), \"[%s, #%d]\", \t\t\t\\\n+\t\t reg_names[REGNO (XEXP ((X), 0))],\t\t\\\n+\t\t (int) INTVAL (XEXP ((X), 1)));\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf ((STREAM), \"[%s, %s]\",\t\t\t\t\\\n+\t\t reg_names[REGNO (XEXP ((X), 0))],\t\t\\\n+\t\t reg_names[REGNO (XEXP ((X), 1))]);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    output_addr_const ((STREAM), (X));\t\t\t\t\\\n+}\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '@')\n+\n+/* Emit a special directive when defining a function name.\n+   This is used by the assembler to assit with interworking.  */\n+#define ASM_DECLARE_FUNCTION_NAME(file, name, decl)             \\\n+  fprintf (file, \".thumb_func\\n\") ; \t\t\t\t\\\n+  ASM_OUTPUT_LABEL (file, name)\n+\n+#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\\\n+  asm_fprintf ((STREAM), \"\\tpush {%R%s}\\n\", reg_names[(REGNO)])\n+\n+#define ASM_OUTPUT_REG_POP(STREAM,REGNO)\t\t\t\\\n+  fprintf ((STREAM), \"\\tpop {%R%s}\\n\", reg_names[(REGNO)])\n+\n+#define FINAL_PRESCAN_INSN(INSN,OPVEC,NOPERANDS) \\\n+  final_prescan_insn((INSN))\n+\f\n+/* Controlling Debugging Information Format */\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Specific options for DBX Output */\n+\n+#define DBX_DEBUGGING_INFO 1\n+\n+#define DEFAULT_GDB_EXTENSIONS 1\n+\n+\f\n+/* Cross Compilation and Floating Point */\n+\n+#define REAL_ARITHMETIC\n+\n+\f\n+/* Miscellaneous Parameters */\n+\n+#define PREDICATE_CODES \\\n+  {\"thumb_cmp_operand\", {SUBREG, REG, CONST_INT}},\n+\n+#define CASE_VECTOR_MODE Pmode\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+#define MOVE_MAX 4\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC) 1\n+\n+#define STORE_FLAG_VALUE 1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE SImode\n+\n+#define DOLLARS_IN_IDENTIFIERS 0\n+\n+#define NO_DOLLAR_IN_LABEL 1\n+\n+#define HAVE_ATEXIT\n+\n+/* The literal pool needs to reside in the text area due to the\n+   limited PC addressing range: */\n+#define MACHINE_DEPENDENT_REORG(INSN) thumb_reorg ((INSN))\n+\n+\f\n+/* Options specific to Thumb */\n+\n+/* True if a return instruction can be used in this function. */\n+int thumb_trivial_epilogue ();\n+#define USE_RETURN (reload_completed && thumb_trivial_epilogue ())\n+\n+extern char *thumb_unexpanded_epilogue ();\n+extern char *output_move_mem_multiple ();\n+extern char *thumb_load_double_from_address ();\n+extern char *output_return ();\n+extern int   far_jump_used_p();"}, {"sha": "1e0ee38051d01d07b720f7e2b7a29d21e29535b1", "filename": "gcc/config/arm/thumb.md", "status": "added", "additions": 1144, "deletions": 0, "changes": 1144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Fthumb.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfig%2Farm%2Fthumb.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.md?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -0,0 +1,1144 @@\n+;; thumb.md\tMachine description for ARM/Thumb processors\n+;; Copyright (C) 19996, 1997, 1998 Free Software Foundation, Inc.\n+;; The basis of this contribution was generated by\n+;;\t\tRichard Earnshaw, Advanced RISC Machines Ltd\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; LENGTH of an instruction is 2 bytes\n+(define_attr \"length\" \"\" (const_int 2))\n+\n+;; CONDS is set to UNCHANGED when an insn does not affect the condition codes\n+;; Most insns change the condition codes\n+(define_attr \"conds\" \"changed,unchanged\" (const_string \"changed\"))\n+\n+;; FAR_JUMP is \"yes\" if a BL instruction is used to generate a branch to a\n+;; distant label.\n+(define_attr \"far_jump\" \"yes,no\" (const_string \"no\"))\n+\n+;; Start with move insns\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+  if (! (reload_in_progress || reload_completed))\n+    {\n+      if (GET_CODE (operands[0]) != REG)\n+\toperands[1] = force_reg (SImode, operands[1]);\n+    }\n+\")\n+\n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=l,l,l,l,l,>,l,m,*r,*h\")\n+\t(match_operand:SI 1 \"general_operand\" \"l,I,J,K,>,l,mi,l,*h,*r\"))]\n+  \"register_operand (operands[0], SImode) \n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+   add\\\\t%0, %1, #0\n+   mov\\\\t%0, %1\n+   #\n+   #\n+   ldmia\\\\t%1, {%0}\n+   stmia\\\\t%0, {%1}\n+   ldr\\\\t%0, %1\n+   str\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\"\n+[(set_attr \"length\" \"2,2,4,4,2,2,2,2,2,2\")])\n+\n+(define_split \n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"thumb_shiftable_const (INTVAL (operands[1]))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))]\n+  \"\n+{\n+  unsigned HOST_WIDE_INT val = INTVAL (operands[1]);\n+  unsigned HOST_WIDE_INT mask = 0xff;\n+  int i;\n+  for (i = 0; i < 25; i++)\n+    if ((val & (mask << i)) == val)\n+      break;\n+\n+  if (i == 0)\n+    FAIL;\n+\n+  operands[1] = GEN_INT (val >> i);\n+  operands[2] = GEN_INT (i);\n+}\")\n+\n+(define_split \n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"INTVAL (operands[1]) < 0 && INTVAL (operands[1]) > -256\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 0) (neg:SI (match_dup 0)))]\n+  \"\n+  operands[1] = GEN_INT (- INTVAL (operands[1]));\n+\")\n+\n+;;(define_expand \"reload_outsi\"\n+;;  [(set (match_operand:SI 2 \"register_operand\" \"=&l\")\n+;;\t(match_operand:SI 1 \"register_operand\" \"h\"))\n+;;   (set (match_operand:SI 0 \"reload_memory_operand\" \"=o\")\n+;;\t(match_dup 2))]\n+;;  \"\"\n+;;  \"\n+;;/*  thumb_reload_out_si (operands);\n+;;  DONE; */\n+;;\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (! (reload_in_progress || reload_completed))\n+    {\n+      if (GET_CODE (operands[0]) != REG)\n+\toperands[1] = force_reg (HImode, operands[1]);\n+\n+      /* ??? We shouldn't really get invalid addresses here, but this can\n+\t happen if we are passed a SP (never OK for HImode/QImode) or virtual\n+\tregister (rejected by GO_IF_LEGITIMATE_ADDRESS for HImode/QImode)\n+\trelative address.  */\n+      /* ??? This should perhaps be fixed elsewhere, for instance, in\n+\t fixup_stack_1, by checking for other kinds of invalid addresses,\n+\t e.g. a bare reference to a virtual register.  This may confuse the\n+\t alpha though, which must handle this case differently.  */\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && ! memory_address_p (GET_MODE (operands[0]),\n+\t\t\t\t XEXP (operands[0], 0)))\n+\t{\n+\t  rtx temp = copy_to_reg (XEXP (operands[0], 0));\n+\t  operands[0] = change_address (operands[0], VOIDmode, temp);\n+\t}\n+      if (GET_CODE (operands[1]) == MEM\n+\t  && ! memory_address_p (GET_MODE (operands[1]),\n+\t\t\t\t XEXP (operands[1], 0)))\n+\t{\n+\t  rtx temp = copy_to_reg (XEXP (operands[1], 0));\n+\t  operands[1] = change_address (operands[1], VOIDmode, temp);\n+\t}\n+    }\n+  /* Handle loading a large integer during reload */\n+  else if (GET_CODE (operands[1]) == CONST_INT\n+\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+    {\n+      /* Writing a constant to memory needs a scratch, which should\n+\t be handled with SECONDARY_RELOADs.  */\n+      if (GET_CODE (operands[0]) != REG)\n+\tabort ();\n+\n+      operands[0] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+      emit_insn (gen_movsi (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n+\t(match_operand:HI 1 \"general_operand\"       \"l,m,l,*h,*r,I\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"@\n+   add\\\\t%0, %1, #0\n+   ldrh\\\\t%0, %1\n+   strh\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\")\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (! (reload_in_progress || reload_completed))\n+    {\n+      if (GET_CODE (operands[0]) != REG)\n+\toperands[1] = force_reg (QImode, operands[1]);\n+\n+      /* ??? We shouldn't really get invalid addresses here, but this can\n+\t happen if we are passed a SP (never OK for HImode/QImode) or virtual\n+\tregister (rejected by GO_IF_LEGITIMATE_ADDRESS for HImode/QImode)\n+\trelative address.  */\n+      /* ??? This should perhaps be fixed elsewhere, for instance, in\n+\t fixup_stack_1, by checking for other kinds of invalid addresses,\n+\t e.g. a bare reference to a virtual register.  This may confuse the\n+\t alpha though, which must handle this case differently.  */\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && ! memory_address_p (GET_MODE (operands[0]),\n+\t\t\t\t XEXP (operands[0], 0)))\n+\t{\n+\t  rtx temp = copy_to_reg (XEXP (operands[0], 0));\n+\t  operands[0] = change_address (operands[0], VOIDmode, temp);\n+\t}\n+      if (GET_CODE (operands[1]) == MEM\n+\t  && ! memory_address_p (GET_MODE (operands[1]),\n+\t\t\t\t XEXP (operands[1], 0)))\n+\t{\n+\t  rtx temp = copy_to_reg (XEXP (operands[1], 0));\n+\t  operands[1] = change_address (operands[1], VOIDmode, temp);\n+\t}\n+    }\n+  /* Handle loading a large integer during reload */\n+  else if (GET_CODE (operands[1]) == CONST_INT\n+\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+    {\n+      /* Writing a constant to memory needs a scratch, which should\n+\t be handled with SECONDARY_RELOADs.  */\n+      if (GET_CODE (operands[0]) != REG)\n+\tabort ();\n+\n+      operands[0] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+      emit_insn (gen_movsi (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n+\t(match_operand:QI 1 \"general_operand\" \"l,m,l,*h,*r,I\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+   add\\\\t%0, %1, #0\n+   ldrb\\\\t%0, %1\n+   strb\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\")\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+  if (! (reload_in_progress || reload_completed))\n+    {\n+      if (GET_CODE (operands[0]) != REG)\n+\toperands[1] = force_reg (DImode, operands[1]);\n+    }\n+\")\n+\n+;;; ??? This should have alternatives for constants.\n+;;; ??? This was originally identical to the movdf_insn pattern.\n+;;; ??? The 'i' constraint looks funny, but it should always be replaced by\n+;;; thumb_reorg with a memory reference.\n+(define_insn \"*movdi_insn\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=l,l,l,l,>,l,m,*r\")\n+\t(match_operand:DI 1 \"general_operand\" \"l,I,J,>,l,mi,l,*r\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"add\\\\t%0, %1, #0\\;add\\\\t%H0, %H1, #0\\\";\n+      return \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0, %1, #0\\\";\n+    case 1:\n+      return \\\"mov\\\\t%Q0, %1\\;mov\\\\t%R0, #0\\\";\n+    case 2:\n+      operands[1] = GEN_INT (- INTVAL (operands[1]));\n+      return \\\"mov\\\\t%Q0, %1\\;neg\\\\t%Q0, %Q0\\;asr\\\\t%R0, %Q0, #31\\\";\n+    case 3:\n+      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n+    case 4:\n+      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n+    case 5:\n+      return thumb_load_double_from_address (operands);\n+    case 6:\n+      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[0], 0), 4));\n+      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n+      return \\\"\\\";\n+    case 7:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n+      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n+    }\n+}\"[(set_attr \"length\" \"4,4,6,2,2,6,4,4\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+  if (! (reload_in_progress || reload_completed))\n+    {\n+      if (GET_CODE (operands[0]) != REG)\n+\toperands[1] = force_reg (DFmode, operands[1]);\n+    }\n+\")\n+\n+;;; ??? This should have alternatives for constants.\n+;;; ??? This was originally identical to the movdi_insn pattern.\n+;;; ??? The 'F' constraint looks funny, but it should always be replaced by\n+;;; thumb_reorg with a memory reference.\n+(define_insn \"*movdf_insn\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=l,l,>,l,m,*r\")\n+\t(match_operand:DF 1 \"general_operand\"  \"l,>,l,mF,l,*r\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"add\\\\t%0, %1, #0\\;add\\\\t%H0, %H1, #0\\\";\n+      return \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0, %1, #0\\\";\n+    case 1:\n+      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n+    case 2:\n+      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n+    case 3:\n+      return thumb_load_double_from_address (operands);\n+    case 4:\n+      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[0], 0), 4));\n+      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n+      return \\\"\\\";\n+    case 5:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n+      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n+    }\n+\"[(set_attr \"length\" \"4,2,2,6,4,4\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+  if (! (reload_in_progress || reload_completed))\n+    {\n+      if (GET_CODE (operands[0]) != REG)\n+\toperands[1] = force_reg (SFmode, operands[1]);\n+    }\n+\")\n+\n+;;; ??? This should have alternatives for constants.\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=l,l,>,l,m,*r,*h\")\n+\t(match_operand:SF 1 \"general_operand\"       \"l,>,l,mF,l,*h,*r\"))]\n+  \"register_operand (operands[0], SFmode) \n+   || register_operand (operands[1], SFmode)\"\n+  \"@\n+   add\\\\t%0, %1, #0\n+   ldmia\\\\t%1, {%0}\n+   stmia\\\\t%0, {%1}\n+   ldr\\\\t%0, %1\n+   str\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\")\n+\n+;; Widening move insns\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      \n+      operands[1] = force_reg (HImode, operands[1]);\n+      operands[1] = gen_lowpart (SImode, operands[1]);\n+      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (16)));\n+      emit_insn (gen_lshrsi3 (operands[0], temp, GEN_INT (16)));\n+      DONE;\n+    }\n+\")\n+\n+(define_insn \"*zero_extendhisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldrh\\\\t%0, %1\")\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+\n+      operands[1] = force_reg (QImode, operands[1]);\n+      operands[1] = gen_lowpart (SImode, operands[1]);\n+      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (24)));\n+      emit_insn (gen_lshrsi3 (operands[0], temp, GEN_INT (24)));\n+      DONE;\n+    }\n+\")\n+\n+(define_insn \"*zero_extendqisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldrb\\\\t%0, %1\")\n+\n+(define_expand \"extendhisi2\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n+\t      (clobber (match_scratch:SI 2 \"\"))])]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      \n+      operands[1] = force_reg (HImode, operands[1]);\n+      operands[1] = gen_lowpart (SImode, operands[1]);\n+      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (16)));\n+      emit_insn (gen_ashrsi3 (operands[0], temp, GEN_INT (16)));\n+      DONE;\n+    }\n+\")\n+\n+(define_insn \"*extendhisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))\n+   (clobber (match_scratch:SI 2 \"=&l\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx ops[4];\n+  /* This code used to try to use 'V', and fix the address only if it was\n+     offsettable, but this fails for e.g. REG+48 because 48 is outside the\n+     range of QImode offsets, and offsettable_address_p does a QImode\n+     address check.  */\n+\n+  if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n+    {\n+      ops[1] = XEXP (XEXP (operands[1], 0), 0);\n+      ops[2] = XEXP (XEXP (operands[1], 0), 1);\n+    }\n+  else\n+    {\n+      ops[1] = XEXP (operands[1], 0);\n+      ops[2] = const0_rtx;\n+    }\n+  if (GET_CODE (ops[2]) == REG)\n+    return \\\"ldrsh\\\\t%0, %1\\\";\n+\n+  ops[0] = operands[0];\n+  ops[3] = operands[2];\n+  output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"length\" \"4\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+\n+      operands[1] = force_reg (QImode, operands[1]);\n+      operands[1] = gen_lowpart (SImode, operands[1]);\n+      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (24)));\n+      emit_insn (gen_ashrsi3 (operands[0], temp, GEN_INT (24)));\n+      DONE;\n+    }\n+\")\n+\n+(define_insn \"*extendqisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,&l\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"V,m\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx ops[3];\n+\n+  if (which_alternative == 0)\n+    return \\\"ldrsb\\\\t%0, %1\\\";\n+  ops[0] = operands[0];\n+  if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n+    {\n+      ops[1] = XEXP (XEXP (operands[1], 0), 0);\n+      ops[2] = XEXP (XEXP (operands[1], 0), 1);\n+    }\n+  else\n+    {\n+      ops[1] = XEXP (operands[1], 0);\n+      ops[2] = const0_rtx;\n+    }\n+  output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"length\" \"2,4\")])\n+\n+;; We don't really have extzv, but defining this using shifts helps\n+;; to reduce register pressure later on.\n+\n+(define_expand \"extzv\"\n+  [(set (match_dup 4)\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_dup 4)\n+\t\t     (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  HOST_WIDE_INT lshift = 32 - INTVAL (operands[2]) - INTVAL (operands[3]);\n+  HOST_WIDE_INT rshift = 32 - INTVAL (operands[2]);\n+  operands[3] = GEN_INT (rshift);\n+  if (lshift == 0)\n+    {\n+      emit_insn (gen_lshrsi3 (operands[0], operands[1], operands[3]));\n+      DONE;\n+    }\n+  operands[2] = GEN_INT (lshift);\n+  operands[4] = gen_reg_rtx (SImode);\n+}\n+\")\n+\n+;; Block-move insns\n+\n+(define_expand \"movstrqi\"\n+  [(match_operand:BLK 0 \"general_operand\" \"\")\n+   (match_operand:BLK 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"\" \"\")\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"\"\n+  \"\n+  if (INTVAL (operands[3]) != 4\n+      || GET_CODE (operands[2]) != CONST_INT\n+      || INTVAL (operands[2]) > 48)\n+    FAIL;\n+\n+  thumb_expand_movstrqi (operands);\n+  DONE;\n+\")\n+\n+(define_insn \"movmem12b\"\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"+&l\"))\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+&l\")))\n+   (set (mem:SI (plus:SI (match_dup 0) (const_int 4)))\n+\t(mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+   (set (mem:SI (plus:SI (match_dup 0) (const_int 8)))\n+\t(mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 12)))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 12)))\n+   (clobber (match_scratch:SI 2 \"=&l\"))\n+   (clobber (match_scratch:SI 3 \"=&l\"))\n+   (clobber (match_scratch:SI 4 \"=&l\"))]\n+  \"\"\n+  \"* return output_move_mem_multiple (3, operands);\"\n+[(set_attr \"length\" \"4\")])\n+\n+(define_insn \"movmem8b\"\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"+&l\"))\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+&l\")))\n+   (set (mem:SI (plus:SI (match_dup 0) (const_int 4)))\n+\t(mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 8)))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 8)))\n+   (clobber (match_scratch:SI 2 \"=&l\"))\n+   (clobber (match_scratch:SI 3 \"=&l\"))]\n+  \"\"\n+  \"* return output_move_mem_multiple (2, operands);\"\n+[(set_attr \"length\" \"4\")])\n+\n+;; Arithmetic insns\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"add\\\\t%Q0, %Q0, %Q2\\;adc\\\\t%R0, %R0, %R2\"\n+[(set_attr \"conds\" \"changed\")\n+ (set_attr \"length\" \"8\")])\n+\n+;; register group 'k' is a single register group containing only the stack\n+;; register.  Trying to reload it will always fail catastrophically,\n+;; so never allow those alternatives to match if reloading is needed.\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,l,*r,*h,l,!k\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,!k,!k\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"I,J,lL,*h,*r,!M,!O\")))]\n+  \"\"\n+  \"*\n+   static char *asms[] = \n+{\n+  \\\"add\\\\t%0, %0, %2\\\",\n+  \\\"sub\\\\t%0, %0, #%n2\\\",\n+  \\\"add\\\\t%0, %1, %2\\\",\n+  \\\"add\\\\t%0, %0, %2\\\",\n+  \\\"add\\\\t%0, %0, %2\\\",\n+  \\\"add\\\\t%0, %1, %2\\\",\n+  \\\"add\\\\t%0, %1, %2\\\"\n+};\n+  if (which_alternative == 2 && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0)\n+    return \\\"sub\\\\t%0, %1, #%n2\\\";\n+  return asms[which_alternative];\n+\")\n+\n+; reloading and elimination of the frame pointer can sometimes cause this\n+; optimization to be missed.\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"M\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (match_operand:SI 2 \"register_operand\" \"k\")))]\n+  \"REGNO (operands[2]) == STACK_POINTER_REGNUM \n+   && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024\n+   && (INTVAL (operands[1]) & 3) == 0\"\n+  \"add\\\\t%0, %2, %1\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"sub\\\\t%Q0, %Q0, %Q2\\;sbc\\\\t%R0, %R0, %R2\"\n+[(set_attr \"conds\" \"changed\")\n+ (set_attr \"length\" \"8\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"l\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"sub\\\\t%0, %1, %2\")\n+\n+;; We must ensure that one input matches the output, and that the other input\n+;; does not match the output.  Using 0 satisfies the first, and using &\n+;; satisfies the second.  Unfortunately, this fails when operands 1 and 2\n+;; are the same, because reload will make operand 0 match operand 1 without\n+;; realizing that this conflicts with operand 2.  We fix this by adding another\n+;; alternative to match this case, and then `reload' it ourselves.  This\n+;; alternative must come first.\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&l,&l,&l\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%l,*h,0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"l,l,l\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative < 2)\n+    return \\\"mov\\\\t%0, %1\\;mul\\\\t%0, %0, %2\\\";\n+  else\n+    return \\\"mul\\\\t%0, %0, %2\\\";\n+}\"\n+  [(set_attr \"length\" \"4,4,2\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"neg\\\\t%0, %1\")\n+\n+;; Logical insns\n+\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = force_reg (SImode, operands[2]);\n+  else\n+    {\n+      int i;\n+      if (((unsigned HOST_WIDE_INT) ~ INTVAL (operands[2])) < 256)\n+\t{\n+\t  operands[2] = force_reg (SImode, GEN_INT (~INTVAL (operands[2])));\n+\t  emit_insn (gen_bicsi3 (operands[0], operands[2], operands[1]));\n+\t  DONE;\n+\t}\n+\n+      for (i = 9; i <= 31; i++)\n+\tif ((((HOST_WIDE_INT) 1) << i) - 1 == INTVAL (operands[2]))\n+\t  {\n+\t    emit_insn (gen_extzv (operands[0], operands[1], GEN_INT (i),\n+\t\t\t\t  const0_rtx));\n+\t    DONE;\n+\t  }\n+\telse if ((((HOST_WIDE_INT) 1) << i) - 1 == ~ INTVAL (operands[2]))\n+\t  {\n+\t    rtx shift = GEN_INT (i);\n+\t    rtx reg = gen_reg_rtx (SImode);\n+\t    emit_insn (gen_lshrsi3 (reg, operands[1], shift));\n+\t    emit_insn (gen_ashlsi3 (operands[0], reg, shift));\n+\t    DONE;\n+\t  }\n+\n+      operands[2] = force_reg (SImode, operands[2]);\n+    }\n+\")\n+\n+(define_insn \"*andsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"and\\\\t%0, %0, %2\")\n+\n+(define_insn \"bicsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"l\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"bic\\\\t%0, %0, %1\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"orr\\\\t%0, %0, %2\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"eor\\\\t%0, %0, %2\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"mvn\\\\t%0, %1\")\n+\n+;; Shift and rotation insns\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n+  \"\"\n+  \"@\n+   lsl\\\\t%0, %1, %2\n+   lsl\\\\t%0, %0, %2\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n+  \"\"\n+  \"@\n+   asr\\\\t%0, %1, %2\n+   asr\\\\t%0, %0, %2\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n+  \"\"\n+  \"@\n+   lsr\\\\t%0, %1, %2\n+   lsr\\\\t%0, %0, %2\")\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"ror\\\\t%0, %0, %2\")\n+\n+;; Comparison insns\n+\n+(define_expand \"cmpsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+  if (GET_CODE (operands[1]) != REG && GET_CODE (operands[1]) != SUBREG)\n+    {\n+      if (GET_CODE (operands[1]) != CONST_INT\n+\t  || (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) >= 256)\n+\t{\n+\t  if (GET_CODE (operands[1]) != CONST_INT\n+\t      || INTVAL (operands[1]) < -255\n+\t      || INTVAL (operands[1]) > 0)\n+\t    operands[1] = force_reg (SImode, operands[1]);\n+\t  else\n+\t    {\n+\t      operands[1] = force_reg (SImode, \n+\t\t\t\t       GEN_INT (- INTVAL (operands[1])));\n+\t      emit_insn (gen_cmnsi (operands[0], operands[1]));\n+\t      DONE;\n+\t    }\n+        }\n+    }\n+\")\n+\n+(define_insn \"*cmpsi_insn\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"l,*r,*h\")\n+\t\t       (match_operand:SI 1 \"thumb_cmp_operand\" \"lI,*h,*r\")))]\n+  \"\"\n+  \"@\n+   cmp\\\\t%0, %1\n+   cmp\\\\t%0, %1\n+   cmp\\\\t%0, %1\")\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"l\"))]\n+  \"\"\n+  \"cmp\\\\t%0, #0\")\n+\n+(define_insn \"cmnsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"l\")\n+\t\t       (neg:SI (match_operand:SI 1 \"register_operand\" \"l\"))))]\n+  \"\"\n+  \"cmn\\\\t%0, %1\")\n+\n+;; Jump insns\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+  if (get_attr_length (insn) == 2)\n+    return \\\"b\\\\t%l0\\\";\n+  return \\\"bl\\\\t%l0\\\\t%@ far jump\\\";\n+\"[(set (attr \"far_jump\")\n+       (if_then_else (eq_attr \"length\" \"4\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\")))\n+  (set (attr \"length\") \n+       (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2048))\n+\t\t\t  (le (minus (match_dup 0) (pc)) (const_int 2044)))\n+\t\t     (const_int 2)\n+\t\t     (const_int 4)))])\n+\n+\n+(define_expand \"beq\"\n+  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc) (if_then_else (ne (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"ble\"\n+  [(set (pc) (if_then_else (le (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc) (if_then_else (gt (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc) (if_then_else (geu (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc) (if_then_else (leu (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc) (if_then_else (gtu (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc) (if_then_else (ltu (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*cond_branch\"\n+  [(set (pc) (if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"*\n+  switch (get_attr_length (insn))\n+    {\n+    case 2:  return \\\"b%d1\\\\t%l0\\\\t%@cond_branch\\\";\n+    case 4:  return \\\"b%D1\\\\t.LCB%=\\;b\\\\t%l0\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D1\\\\t.LCB%=\\;bl\\\\t%l0\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+\"[(set (attr \"far_jump\")\n+       (if_then_else (eq_attr \"length\" \"6\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\")))\n+  (set (attr \"length\") \n+       (if_then_else\n+\t(and (ge (minus (match_dup 0) (pc)) (const_int -252))\n+\t     (le (minus (match_dup 0) (pc)) (const_int 254)))\n+\t(const_int 2)\n+\t(if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n+\t\t\t   (le (minus (match_dup 0) (pc)) (const_int 2044)))\n+\t\t      (const_int 4)\n+\t\t      (const_int 6))))])\n+\n+(define_insn \"*cond_branch_reversed\"\n+  [(set (pc) (if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  switch (get_attr_length (insn))\n+    {\n+    case 2:  return \\\"b%D1\\\\t%l0\\\\t%@cond_branch_reversed\\\";\n+    case 4:  return \\\"b%d1\\\\t.LCBR%=\\;b\\\\t%l0\\\\t%@long jump\\\\n.LCBR%=:\\\";\n+    default: return \\\"b%d1\\\\t.LCBR%=\\;bl\\\\t%l0\\\\t%@far jump\\\\n.LCBR%=:\\\";\n+    }\n+  return \\\"\\\";\n+\"[(set (attr \"far_jump\")\n+       (if_then_else (eq_attr \"length\" \"6\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\")))\n+   (set (attr \"length\") \n+       (if_then_else\n+\t(and (ge (minus (match_dup 0) (pc)) (const_int -252))\n+\t     (le (minus (match_dup 0) (pc)) (const_int 254)))\n+\t(const_int 2)\n+\t(if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n+\t\t\t   (le (minus (match_dup 0) (pc)) (const_int 2044)))\n+\t\t      (const_int 4)\n+\t\t      (const_int 6))))])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))]\n+  \"\"\n+  \"mov\\\\tpc, %0\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"mov\\\\tpc, %0\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"USE_RETURN\"\n+  \"* return output_return ();\"\n+[(set_attr \"length\" \"18\")])\n+\n+;; Call insns\n+\n+(define_expand \"call\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call_indirect\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"TARGET_THUMB_INTERWORK\"\n+  \"bl\\\\t__call_via_%0\"\n+[(set_attr \"length\" \"4\")])\n+\n+\n+(define_insn \"*call_indirect\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"! TARGET_THUMB_INTERWORK\"\n+  \"bl\\\\t__call_via_%0\"\n+[(set_attr \"length\" \"4\")])\n+;; used to be: \"mov\\\\tlr,pc\\;bx\\\\t%0\"\n+;; but this does not set bottom bit of lr\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand 1 \"memory_operand\" \"\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call_value_indirect\"\n+  [(set (match_operand 0 \"\" \"=l\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"TARGET_THUMB_INTERWORK\"\n+  \"bl\\\\t__call_via_%1\"\n+[(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*call_value_indirect\"\n+  [(set (match_operand 0 \"\" \"=l\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"! TARGET_THUMB_INTERWORK\"\n+  \"bl\\\\t__call_via_%1\"\n+[(set_attr \"length\" \"4\")])\n+;; used to be  \"mov\\\\tlr,pc\\;bx\\\\t%1\"\n+;; but this does not set bottom bit of lr\n+\n+(define_insn \"*call_insn\"\n+  [(call (mem:SI (match_operand:SI 0 \"\" \"i\"))\n+\t (match_operand:SI 1 \"\" \"\"))]\n+  \"GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"bl\\\\t%a0\"\n+[(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*call_value_insn\"\n+  [(set (match_operand 0 \"register_operand\" \"=l\")\n+\t(call (mem:SI (match_operand 1 \"\" \"i\"))\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"GET_CODE (operands[1]) == SYMBOL_REF\"\n+  \"bl\\\\t%a1\"\n+[(set_attr \"length\" \"4\")])\n+\n+;; Untyped call not required, since all funcs return in r0\n+\n+;; Miscellaneous patterns\n+\n+(define_insn \"nop\"\n+  [(clobber (const_int 0))]\n+  \"\"\n+  \"mov\\\\tr8, r8\")\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\n+  thumb_expand_prologue ();\n+  DONE;\n+\")\n+\n+(define_expand \"epilogue\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"! thumb_trivial_epilogue ()\"\n+  \"\n+  thumb_expand_epilogue ();\n+\")\n+\n+(define_insn \"*epilogue_insns\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"*\n+  return thumb_unexpanded_epilogue ();\n+\"\n+[(set_attr \"length\" \"42\")])\n+\n+;; Special patterns for dealing with the constant pool\n+\n+(define_insn \"consttable_4\"\n+ [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n+ \"\"\n+ \"*\n+{\n+  switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n+    {\n+    case MODE_FLOAT:\n+    {\n+      union real_extract u;\n+      bcopy ((char *) &CONST_DOUBLE_LOW (operands[0]), (char *) &u, sizeof u);\n+      assemble_real (u.d, GET_MODE (operands[0]));\n+      break;\n+    }\n+    default:\n+      assemble_integer (operands[0], 4, 1);\n+      break;\n+    }\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"length\" \"4\")])\n+\n+(define_insn \"consttable_8\"\n+ [(unspec_volatile [(match_operand 0 \"\" \"\")] 3)]\n+ \"\"\n+ \"*\n+{\n+  switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n+    {\n+    case MODE_FLOAT:\n+    {\n+      union real_extract u;\n+      bcopy ((char *) &CONST_DOUBLE_LOW (operands[0]), (char *) &u, sizeof u);\n+      assemble_real (u.d, GET_MODE (operands[0]));\n+      break;\n+    }\n+    default:\n+      assemble_integer (operands[0], 8, 1);\n+      break;\n+    }\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"length\" \"8\")])\n+\n+(define_insn \"consttable_end\"\n+  [(unspec_volatile [(const_int 0)] 4)]\n+  \"\"\n+  \"*\n+  /* Nothing to do (currently).  */\n+  return \\\"\\\";\n+\")\n+\n+(define_insn \"align_4\"\n+ [(unspec_volatile [(const_int 0)] 5)]\n+ \"\"\n+ \"*\n+   assemble_align (32);\n+   return \\\"\\\";\n+\")"}, {"sha": "90b43098d6242df7f44bda35dabebed5635cd8dd", "filename": "gcc/configure", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -4168,6 +4168,13 @@ for machine in $build $host $target; do\n #\t\t;;\n #\ttahoe-*-bsd*)\t\t\t# tahoe running BSD\n #\t\t;;\n+\tthumb-*-coff* | thumbel-*-coff*)\n+\t\ttm_file=arm/tcoff.h\n+\t\tout_file=arm/thumb.c\n+\t\txm_file=arm/xm-thumb.h\n+\t\tmd_file=arm/thumb.md\n+\t\ttmake_file=arm/t-thumb\n+\t\t;;\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro\n@@ -4445,7 +4452,8 @@ then extra_headers=; fi\n if [ x\"$xm_file\" = x ]\n then xm_file=$cpu_type/xm-$cpu_type.h; fi\n \n-md_file=$cpu_type/$cpu_type.md\n+if [ x$md_file = x ]\n+then md_file=$cpu_type/$cpu_type.md; fi\n \n if [ x$out_file = x ]\n then out_file=$cpu_type/$cpu_type.c; fi"}, {"sha": "0a0fc4100f1f3bf82127536813d7b78d26d93d46", "filename": "gcc/configure.in", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98e406fcc1d898d8d59d8a65395631e698be55e/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=e98e406fcc1d898d8d59d8a65395631e698be55e", "patch": "@@ -2485,6 +2485,13 @@ for machine in $build $host $target; do\n #\t\t;;\n #\ttahoe-*-bsd*)\t\t\t# tahoe running BSD\n #\t\t;;\n+\tthumb-*-coff* | thumbel-*-coff*)\n+\t\ttm_file=arm/tcoff.h\n+\t\tout_file=arm/thumb.c\n+\t\txm_file=arm/xm-thumb.h\n+\t\tmd_file=arm/thumb.md\n+\t\ttmake_file=arm/t-thumb\n+\t\t;;\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro\n@@ -2762,7 +2769,8 @@ then extra_headers=; fi\n if [[ x\"$xm_file\" = x ]]\n then xm_file=$cpu_type/xm-$cpu_type.h; fi\n \n-md_file=$cpu_type/$cpu_type.md\n+if [[ x$md_file = x ]]\n+then md_file=$cpu_type/$cpu_type.md; fi\n \n if [[ x$out_file = x ]]\n then out_file=$cpu_type/$cpu_type.c; fi"}]}