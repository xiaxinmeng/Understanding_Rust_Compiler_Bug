{"sha": "e376fe584282938a72a287a467a408ec4619e5fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM3NmZlNTg0MjgyOTM4YTcyYTI4N2E0NjdhNDA4ZWM0NjE5ZTVmYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-29T02:15:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-29T02:15:00Z"}, "message": "tree-ssa-threadupdate.c (create_block_for_threading): Request that no outgoing edges be left in the duplicate block.\n\n\n\t* tree-ssa-threadupdate.c (create_block_for_threading):  Request\n\tthat no outgoing edges be left in the duplicate block.  Do no\n\tupdate information on outgoing edges or PHI nodes in target\n\tblocks here.\n\t(remove_ctrl_stmt_and_useless_edges): Renamed from\n\tremove_last_stmt_and_useless_edges.  Handle case where the\n\tblock is empty or has no control statements.  Do not update edge\n\tflags here.\n\t(thread_block): Create a template block rather than copying the\n\toriginal block every time.  Create outgoing edges from the\n\tduplicate blocks and update PHIs at the target of the outgoing\n\tedges here.  Fix edge flags for the original block if necessary.\n\t* cfghooks (duplicate_block): No longer assert that the original\n\tblock has incoming edges.\n\nFrom-SVN: r88267", "tree": {"sha": "aafb518095845c31b96e9a8794e0eb9718961eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aafb518095845c31b96e9a8794e0eb9718961eea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e376fe584282938a72a287a467a408ec4619e5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e376fe584282938a72a287a467a408ec4619e5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e376fe584282938a72a287a467a408ec4619e5fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e376fe584282938a72a287a467a408ec4619e5fb/comments", "author": null, "committer": null, "parents": [{"sha": "805c33df1366e3f86fde31be556ca843ef1bac5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805c33df1366e3f86fde31be556ca843ef1bac5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/805c33df1366e3f86fde31be556ca843ef1bac5a"}], "stats": {"total": 124, "additions": 82, "deletions": 42}, "files": [{"sha": "2212c39b42cde508372a611c68bd6b32f7cb755f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e376fe584282938a72a287a467a408ec4619e5fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e376fe584282938a72a287a467a408ec4619e5fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e376fe584282938a72a287a467a408ec4619e5fb", "patch": "@@ -1,3 +1,20 @@\n+2004-09-28 Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (create_block_for_threading):  Request\n+\tthat no outgoing edges be left in the duplicate block.  Do no\n+\tupdate information on outgoing edges or PHI nodes in target\n+\tblocks here.\n+\t(remove_ctrl_stmt_and_useless_edges): Renamed from\n+\tremove_last_stmt_and_useless_edges.  Handle case where the\n+\tblock is empty or has no control statements.  Do not update edge\n+\tflags here.\n+\t(thread_block): Create a template block rather than copying the\n+\toriginal block every time.  Create outgoing edges from the\n+\tduplicate blocks and update PHIs at the target of the outgoing\n+\tedges here.  Fix edge flags for the original block if necessary.\n+\t* cfghooks (duplicate_block): No longer assert that the original\n+\tblock has incoming edges.\n+\n 2004-09-29  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* doc/extend.texi (Extended Asm): Add blurb about using Explicit"}, {"sha": "e6a624c355076642656694809b8920ce7a446692", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e376fe584282938a72a287a467a408ec4619e5fb/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e376fe584282938a72a287a467a408ec4619e5fb/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=e376fe584282938a72a287a467a408ec4619e5fb", "patch": "@@ -691,7 +691,7 @@ duplicate_block (basic_block bb, edge e)\n \n   if (bb->count < new_count)\n     new_count = bb->count;\n-  gcc_assert (EDGE_COUNT (bb->preds) > 0);\n+\n #ifdef ENABLE_CHECKING\n   gcc_assert (can_duplicate_block_p (bb));\n #endif"}, {"sha": "2a39c2cace76e5b4118ade1ddc6f7a61a2d0dec1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e376fe584282938a72a287a467a408ec4619e5fb/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e376fe584282938a72a287a467a408ec4619e5fb/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=e376fe584282938a72a287a467a408ec4619e5fb", "patch": "@@ -129,27 +129,29 @@ copy_phis_to_block (basic_block new_bb, basic_block bb, edge e)\n     }\n }\n \n-/* Remove the last statement in block BB which must be a COND_EXPR or\n-   SWITCH_EXPR.  Also remove all outgoing edges except the edge which\n-   reaches DEST_BB.\n-\n-   This is only used by jump threading which knows the last statement in\n-   BB should be a COND_EXPR or SWITCH_EXPR.  If the block ends with any other\n-   statement, then we abort.  */\n+/* Remove the last statement in block BB if it is a control statement\n+   Also remove all outgoing edges except the edge which reaches DEST_BB.\n+   If DEST_BB is NULL, then remove all outgoing edges.  */\n \n static void\n-remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n+remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n {\n   block_stmt_iterator bsi;\n   edge e;\n   edge_iterator ei;\n \n   bsi = bsi_last (bb);\n \n-  gcc_assert (TREE_CODE (bsi_stmt (bsi)) == COND_EXPR\n-\t      || TREE_CODE (bsi_stmt (bsi)) == SWITCH_EXPR);\n+  /* If the duplicate ends with a control statement, then remove it.\n \n-  bsi_remove (&bsi);\n+     Note that if we are duplicating the template block rather than the\n+     original basic block, then the duplicate might not have any real\n+     statements in it.  */\n+  if (!bsi_end_p (bsi)\n+      && bsi_stmt (bsi)\n+      && (TREE_CODE (bsi_stmt (bsi)) == COND_EXPR\n+\t  || TREE_CODE (bsi_stmt (bsi)) == SWITCH_EXPR))\n+    bsi_remove (&bsi);\n \n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n@@ -158,11 +160,6 @@ remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n       else\n \tei_next (&ei);\n     }\n-\n-  /* BB now has a single outgoing edge. We need to update the flags for\n-     that single outgoing edge.  */\n-  EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-  EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n }\n \n /* Create a duplicate of BB which only reaches the destination of the edge\n@@ -171,10 +168,6 @@ remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n static void\n create_block_for_threading (basic_block bb, struct redirection_data *rd)\n {\n-  tree phi;\n-  edge e;\n-  edge_iterator ei;\n-\n   /* We can use the generic block duplication code and simply remove\n      the stuff we do not need.  */\n   rd->dup_block = duplicate_block (bb, NULL);\n@@ -184,25 +177,12 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n   rd->dup_block->count = 0;\n \n   /* The call to duplicate_block will copy everything, including the\n-     useless COND_EXPR or SWITCH_EXPR at the end of the block.  We just remove\n+     useless COND_EXPR or SWITCH_EXPR at the end of BB.  We just remove\n      the useless COND_EXPR or SWITCH_EXPR here rather than having a\n-     specialized block copier.  */\n-  remove_last_stmt_and_useless_edges (rd->dup_block, rd->outgoing_edge->dest);\n-\n-  FOR_EACH_EDGE (e, ei, rd->dup_block->succs)\n-    e->count = 0;\n-\n-  /* If there are any PHI nodes at the destination of the outgoing edge\n-     from the duplicate block, then we will need to add a new argument\n-     to them.  The argument should have the same value as the argument\n-     associated with the outgoing edge stored in RD.  */\n-  for (phi = phi_nodes (EDGE_SUCC (rd->dup_block, 0)->dest); phi;\n-       phi = PHI_CHAIN (phi))\n-    {\n-      int indx = phi_arg_from_edge (phi, rd->outgoing_edge);\n-      add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx),\n-\t\t   EDGE_SUCC (rd->dup_block, 0));\n-    }\n+     specialized block copier.  We also remove all outgoing edges\n+     from the duplicate block.  The appropriate edge will be created\n+     later.  */\n+  remove_ctrl_stmt_and_useless_edges (rd->dup_block, NULL);\n }\n \n /* BB is a block which ends with a COND_EXPR or SWITCH_EXPR and when BB\n@@ -241,6 +221,7 @@ thread_block (basic_block bb)\n      redirect to a duplicate of BB.  */\n   edge e;\n   edge_iterator ei;\n+  basic_block template_block;\n \n   /* ALL indicates whether or not all incoming edges into BB should\n      be threaded to a duplicate of BB.  */\n@@ -293,11 +274,51 @@ thread_block (basic_block bb)\n   /* Now create duplicates of BB.  Note that if all incoming edges are\n      threaded, then BB is going to become unreachable.  In that case\n      we use BB for one of the duplicates rather than wasting memory\n-     duplicating BB.  Thus the odd starting condition for the loop.  */\n+     duplicating BB.  Thus the odd starting condition for the loop.\n+\n+     Note that for a block with a high outgoing degree we can waste\n+     a lot of time and memory creating and destroying useless edges.\n+\n+     So we first duplicate BB and remove the control structure at the\n+     tail of the duplicate as well as all outgoing edges from the\n+     duplicate.  We then use that duplicate block as a template for\n+     the rest of the duplicates.  */\n+  template_block = NULL;\n+  for (i = (all ? 1 : 0); i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n+    {\n+      struct redirection_data *rd = VARRAY_GENERIC_PTR (redirection_data, i);\n+\n+      if (template_block == NULL)\n+\t{\n+\t  create_block_for_threading (bb, rd);\n+\t  template_block = rd->dup_block;\n+\t}\n+      else\n+\t{\n+\t  create_block_for_threading (template_block, rd);\n+\t}\n+    }\n+\n+  /* Now created up edges from the duplicate blocks to their new\n+     destinations.  Doing this as a separate loop after block creation\n+     allows us to avoid creating lots of useless edges.  */\n   for (i = (all ? 1 : 0); i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n     {\n       struct redirection_data *rd = VARRAY_GENERIC_PTR (redirection_data, i);\n-      create_block_for_threading (bb, rd);\n+      tree phi;\n+      edge e;\n+\n+      e = make_edge (rd->dup_block, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n+\n+      /* If there are any PHI nodes at the destination of the outgoing edge\n+\t from the duplicate block, then we will need to add a new argument\n+\t to them.  The argument should have the same value as the argument\n+\t associated with the outgoing edge stored in RD.  */\n+      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  int indx = phi_arg_from_edge (phi, rd->outgoing_edge);\n+\t  add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx), e);\n+\t}\n     }\n \n   /* The loop above created the duplicate blocks (and the statements\n@@ -375,7 +396,9 @@ thread_block (basic_block bb)\n \t\t EDGE_PRED (bb, 0)->src->index, bb->index,\n \t\t EDGE_SUCC (bb, 0)->dest->index);\n \n-      remove_last_stmt_and_useless_edges (bb, rd->outgoing_edge->dest);\n+      remove_ctrl_stmt_and_useless_edges (bb, rd->outgoing_edge->dest);\n+      EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n     }\n \n   /* Done with this block.  Clear REDIRECTION_DATA.  */"}]}