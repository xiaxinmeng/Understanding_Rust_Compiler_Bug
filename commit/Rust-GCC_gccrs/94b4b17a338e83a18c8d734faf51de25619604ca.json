{"sha": "94b4b17a338e83a18c8d734faf51de25619604ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRiNGIxN2EzMzhlODNhMThjOGQ3MzRmYWY1MWRlMjU2MTk2MDRjYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-22T13:28:02Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-22T13:28:02Z"}, "message": "(make_extraction): Use is_mode, not inner_mode,\n\nfor BYTES_BIG_ENDIAN adjustment to offset for non-bitfield case.\nUpdate is_mode when stripping subreg from around a mem.\n\nFrom-SVN: r2556", "tree": {"sha": "d7fb16b9f4a3e9208644fa2586efcdd886b77115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7fb16b9f4a3e9208644fa2586efcdd886b77115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94b4b17a338e83a18c8d734faf51de25619604ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94b4b17a338e83a18c8d734faf51de25619604ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94b4b17a338e83a18c8d734faf51de25619604ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94b4b17a338e83a18c8d734faf51de25619604ca/comments", "author": null, "committer": null, "parents": [{"sha": "1880be65a8843d5b3df18a63201c7a27bbc0a7e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1880be65a8843d5b3df18a63201c7a27bbc0a7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1880be65a8843d5b3df18a63201c7a27bbc0a7e7"}], "stats": {"total": 28, "additions": 20, "deletions": 8}, "files": [{"sha": "de46091a89def77a42c9c0ec7cb8df520b7a4301", "filename": "gcc/combine.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94b4b17a338e83a18c8d734faf51de25619604ca/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94b4b17a338e83a18c8d734faf51de25619604ca/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=94b4b17a338e83a18c8d734faf51de25619604ca", "patch": "@@ -4536,6 +4536,9 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n      int unsignedp;\n      int in_dest, in_compare;\n {\n+  /* This mode describes the size of the storage area\n+     to fetch the overall value from.  Within that, we\n+     ignore the POS lowest bits, etc.  */\n   enum machine_mode is_mode = GET_MODE (inner);\n   enum machine_mode inner_mode;\n   enum machine_mode wanted_mem_mode = byte_mode;\n@@ -4547,11 +4550,21 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* Get some information about INNER and get the innermost object.  */\n   if (GET_CODE (inner) == USE)\n+    /* (use:SI (mem:QI foo)) stands for (mem:SI foo).  */\n     /* We don't need to adjust the position because we set up the USE\n        to pretend that it was a full-word object.  */\n     spans_byte = 1, inner = XEXP (inner, 0);\n   else if (GET_CODE (inner) == SUBREG && subreg_lowpart_p (inner))\n-    inner = SUBREG_REG (inner);\n+    {\n+      /* If going from (subreg:SI (mem:QI ...)) to (mem:QI ...),\n+\t consider just the QI as the memory to extract from.\n+\t The subreg adds or removes high bits; its mode is\n+\t irrelevant to the meaning of this extraction,\n+\t since POS and LEN count from the lsb.  */\n+      if (GET_CODE (SUBREG_REG (inner)) == MEM)\n+\tis_mode = GET_MODE (SUBREG_REG (inner));\n+      inner = SUBREG_REG (inner);\n+    }\n \n   inner_mode = GET_MODE (inner);\n \n@@ -4589,8 +4602,6 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t  || (! mode_dependent_address_p (XEXP (inner, 0))\n \t\t      && ! MEM_VOLATILE_P (inner))))))\n     {\n-      int offset = pos / BITS_PER_UNIT;\n-\t  \n       /* If INNER is a MEM, make a new MEM that encompasses just the desired\n \t field.  If the original and current mode are the same, we need not\n \t adjust the offset.  Otherwise, we do if bytes big endian.  \n@@ -4600,11 +4611,12 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n       if (GET_CODE (inner) == MEM)\n \t{\n-#if BYTES_BIG_ENDIAN\n-\t  if (inner_mode != tmode)\n-\t    offset = (GET_MODE_SIZE (inner_mode)\n-\t\t      - GET_MODE_SIZE (tmode) - offset);\n-#endif\n+\t  int offset;\n+\t  /* POS counts from lsb, but make OFFSET count in memory order.  */\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset = (GET_MODE_BITSIZE (is_mode) - len - pos) / BITS_PER_UNIT;\n+\t  else\n+\t    offset = pos / BITS_PER_UNIT;\n \n \t  new = gen_rtx (MEM, tmode, plus_constant (XEXP (inner, 0), offset));\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (inner);"}]}