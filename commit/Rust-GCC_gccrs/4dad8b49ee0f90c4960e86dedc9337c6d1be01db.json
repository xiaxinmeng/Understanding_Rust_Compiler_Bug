{"sha": "4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhZDhiNDllZTBmOTBjNDk2MGU4NmRlZGM5MzM3YzZkMWJlMDFkYg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2012-04-13T00:33:10Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2012-04-13T00:33:10Z"}, "message": "unordered_map.h (__unordered_map): Remove.\n\n2012-04-12  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/unordered_map.h (__unordered_map): Remove.\n\t(__unordered_multimap): Remove.\n\tAdd aliases for __umap_traits, __umap_hashtable, __ummap_traits,\n\t__ummap_hashtable.\n\t(unordered_map): Derive from __umap_hashtable.\n\t(unordered_multimap): Derive from __ummap_hashtable.\n\t* include/bits/unordered_set.h (__unordered_set): Remove.\n\t(__unordered_multiset): Remove.\n\tAdd aliases for __uset_traits, __uset_hashtable, __umset_traits,\n\t__umset_hashtable.\n\t(unordered_set): Derive from __uset_hashtable.\n\t(unordered_multiset): Derive from __umset_hashtable.\n\t* include/bits/hashtable.h (__cache_default): New, consolidated\n\tcache defaults for _Hashtable. Adjust comments for doxygen.\n\t(_Hashtable): Consolidate bool template parameters into new,\n\t_Traits class. Inherited base classes synthesize _Hashtable in\n\tCRTP via original 10 parameters. Prefer using declarations to\n\ttypedefs, add __node_type, __bucket_type, etc. Push many nested\n\ttypes down hierarchy to _Hashtable_base. Add constructors\n\tnecessary for top-level unordered_containers. Consolidate insert\n\tmember functions and logic in new base class, __detail::_Insert\n\tand __detail::_Insert_base.\n\t(_Hashtable::operator=(initializer_list)): Add.\n\t* include/bits/hashtable_policy.h: Convert to doxygen markup.\n\t(_Hashtable_traits) New. Consolidate bool template parameters here.\n\t(_Insert, _Insert_base): New, consolidated insert member functions.\n\t(_Map_base, _Equality, _Rehash_base): Adjust template parameters,\n\tuse base types.\n\t(_Hashtable_base): Move type declarations useful to other base\n\tclasses into this class.\n\t* python/libstdcxx/v6/printers.py (Tr1HashtableIterator): Update.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n\tAdjust traits, line numbers.\n\nFrom-SVN: r186403", "tree": {"sha": "2baf8a866dd26e2f495ffa33742cff6b7e007bc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2baf8a866dd26e2f495ffa33742cff6b7e007bc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/comments", "author": null, "committer": null, "parents": [{"sha": "3f5c27c683116b3892b0471aa5735d820675d17b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5c27c683116b3892b0471aa5735d820675d17b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5c27c683116b3892b0471aa5735d820675d17b"}], "stats": {"total": 3103, "additions": 1629, "deletions": 1474}, "files": [{"sha": "eb9936f423ba637868ba66cde9ebf038e4151629", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -1,3 +1,39 @@\n+2012-04-12  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/unordered_map.h (__unordered_map): Remove.\n+\t(__unordered_multimap): Remove.\n+\tAdd aliases for __umap_traits, __umap_hashtable, __ummap_traits,\n+\t__ummap_hashtable.\n+\t(unordered_map): Derive from __umap_hashtable.\n+\t(unordered_multimap): Derive from __ummap_hashtable.\n+\t* include/bits/unordered_set.h (__unordered_set): Remove.\n+\t(__unordered_multiset): Remove.\n+\tAdd aliases for __uset_traits, __uset_hashtable, __umset_traits,\n+\t__umset_hashtable.\n+\t(unordered_set): Derive from __uset_hashtable.\n+\t(unordered_multiset): Derive from __umset_hashtable.\n+\t* include/bits/hashtable.h (__cache_default): New, consolidated\n+\tcache defaults for _Hashtable. Adjust comments for doxygen.\n+\t(_Hashtable): Consolidate bool template parameters into new,\n+\t_Traits class. Inherited base classes synthesize _Hashtable in\n+\tCRTP via original 10 parameters. Prefer using declarations to\n+\ttypedefs, add __node_type, __bucket_type, etc. Push many nested\n+\ttypes down hierarchy to _Hashtable_base. Add constructors\n+\tnecessary for top-level unordered_containers. Consolidate insert\n+\tmember functions and logic in new base class, __detail::_Insert\n+\tand __detail::_Insert_base.\n+\t(_Hashtable::operator=(initializer_list)): Add.\n+\t* include/bits/hashtable_policy.h: Convert to doxygen markup.\n+\t(_Hashtable_traits) New. Consolidate bool template parameters here.\n+\t(_Insert, _Insert_base): New, consolidated insert member functions.\n+\t(_Map_base, _Equality, _Rehash_base): Adjust template parameters,\n+\tuse base types.\n+\t(_Hashtable_base): Move type declarations useful to other base\n+\tclasses into this class.\n+\t* python/libstdcxx/v6/printers.py (Tr1HashtableIterator): Update.\n+\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n+\tAdjust traits, line numbers.\n+\n 2012-04-12   Jeffrey Yasskin  <jyasskin@google.com>\n \n \tPR libstdc++/52822"}, {"sha": "8c17035b5c8b91f204fbedbc0fc90632f5722467", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 672, "deletions": 643, "changes": 1315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -1,6 +1,7 @@\n // hashtable.h header -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -38,254 +39,305 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  // Class template _Hashtable, class definition.\n+  template<typename _Tp, typename _Hash>\n+    using __cache_default =  __not_<__and_<is_integral<_Tp>,\n+\t\t\t\t\t   is_empty<_Hash>,\n+\t\t\t\t  integral_constant<bool, !__is_final(_Hash)>,\n+\t\t\t\t __detail::__is_noexcept_hash<_Tp, _Hash> >>;\n \n-  // Meaning of class template _Hashtable's template parameters\n-\n-  // _Key and _Value: arbitrary CopyConstructible types.\n-\n-  // _Allocator: an allocator type ([lib.allocator.requirements]) whose\n-  // value type is Value.  As a conforming extension, we allow for\n-  // value type != Value.\n-\n-  // _ExtractKey: function object that takes an object of type Value\n-  // and returns a value of type _Key.\n-\n-  // _Equal: function object that takes two objects of type k and returns\n-  // a bool-like value that is true if the two objects are considered equal.\n-\n-  // _H1: the hash function.  A unary function object with argument type\n-  // Key and result type size_t.  Return values should be distributed\n-  // over the entire range [0, numeric_limits<size_t>:::max()].\n-\n-  // _H2: the range-hashing function (in the terminology of Tavori and\n-  // Dreizin).  A binary function object whose argument types and result\n-  // type are all size_t.  Given arguments r and N, the return value is\n-  // in the range [0, N).\n-\n-  // _Hash: the ranged hash function (Tavori and Dreizin). A binary function\n-  // whose argument types are _Key and size_t and whose result type is\n-  // size_t.  Given arguments k and N, the return value is in the range\n-  // [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other\n-  // than the default, _H1 and _H2 are ignored.\n-\n-  // _RehashPolicy: Policy class with three members, all of which govern\n-  // the bucket count. _M_next_bkt(n) returns a bucket count no smaller\n-  // than n.  _M_bkt_for_elements(n) returns a bucket count appropriate\n-  // for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)\n-  // determines whether, if the current bucket count is n_bkt and the\n-  // current element count is n_elt, we need to increase the bucket\n-  // count.  If so, returns make_pair(true, n), where n is the new\n-  // bucket count.  If not, returns make_pair(false, <anything>).\n-\n-  // __cache_hash_code: bool.  true if we store the value of the hash\n-  // function along with the value.  This is a time-space tradeoff.\n-  // Storing it may improve lookup speed by reducing the number of times\n-  // we need to call the Equal function.\n-\n-  // __constant_iterators: bool.  true if iterator and const_iterator are\n-  // both constant iterator types.  This is true for unordered_set and\n-  // unordered_multiset, false for unordered_map and unordered_multimap.\n-\n-  // __unique_keys: bool.  true if the return value of _Hashtable::count(k)\n-  // is always at most one, false if it may be an arbitrary number.  This\n-  // true for unordered_set and unordered_map, false for unordered_multiset\n-  // and unordered_multimap.\n   /**\n-   * Here's _Hashtable data structure, each _Hashtable has:\n-   * - _Bucket[]       _M_buckets\n-   * - _Hash_node_base _M_before_begin\n-   * - size_type       _M_bucket_count\n-   * - size_type       _M_element_count\n+   *  Primary class template _Hashtable.\n+   *\n+   *  @ingroup hashtable-detail\n+   *\n+   *  @tparam _Value  CopyConstructible type.\n+   *\n+   *  @tparam _Key    CopyConstructible type.\n+   *\n+   *  @tparam _Alloc  An allocator type\n+   *  ([lib.allocator.requirements]) whose _Alloc::value_type is\n+   *  _Value.  As a conforming extension, we allow for\n+   *  _Alloc::value_type != _Value.\n+   *\n+   *  @tparam _ExtractKey  Function object that takes an object of type\n+   *  _Value and returns a value of type _Key.\n+   *\n+   *  @tparam _Equal  Function object that takes two objects of type k\n+   *  and returns a bool-like value that is true if the two objects\n+   *  are considered equal.\n+   *\n+   *  @tparam _H1  The hash function. A unary function object with\n+   *  argument type _Key and result type size_t. Return values should\n+   *  be distributed over the entire range [0, numeric_limits<size_t>:::max()].\n+   *\n+   *  @tparam _H2  The range-hashing function (in the terminology of\n+   *  Tavori and Dreizin).  A binary function object whose argument\n+   *  types and result type are all size_t.  Given arguments r and N,\n+   *  the return value is in the range [0, N).\n+   *\n+   *  @tparam _Hash  The ranged hash function (Tavori and Dreizin). A\n+   *  binary function whose argument types are _Key and size_t and\n+   *  whose result type is size_t.  Given arguments k and N, the\n+   *  return value is in the range [0, N).  Default: hash(k, N) =\n+   *  h2(h1(k), N).  If _Hash is anything other than the default, _H1\n+   *  and _H2 are ignored.\n+   *\n+   *  @tparam _RehashPolicy  Policy class with three members, all of\n+   *  which govern the bucket count. _M_next_bkt(n) returns a bucket\n+   *  count no smaller than n.  _M_bkt_for_elements(n) returns a\n+   *  bucket count appropriate for an element count of n.\n+   *  _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the\n+   *  current bucket count is n_bkt and the current element count is\n+   *  n_elt, we need to increase the bucket count.  If so, returns\n+   *  make_pair(true, n), where n is the new bucket count.  If not,\n+   *  returns make_pair(false, <anything>)\n+   *\n+   *  @tparam _Traits  Compile-time class with three boolean\n+   *  std::integral_constant members:  __cache_hash_code, __constant_iterators,\n+   *   __unique_keys.\n    *\n-   * with _Bucket being _Hash_node* and _Hash_node constaining:\n-   * - _Hash_node*   _M_next\n-   * - Tp            _M_value\n-   * - size_t        _M_code if cache_hash_code is true\n+   *  Each _Hashtable data structure has:\n    *\n-   * In terms of Standard containers the hastable is like the aggregation of:\n-   * - std::forward_list<_Node> containing the elements\n-   * - std::vector<std::forward_list<_Node>::iterator> representing the buckets\n+   *  - _Bucket[]       _M_buckets\n+   *  - _Hash_node_base _M_before_begin\n+   *  - size_type       _M_bucket_count\n+   *  - size_type       _M_element_count\n    *\n-   * The non-empty buckets contain the node before the first bucket node. This\n-   * design allow to implement something like a std::forward_list::insert_after\n-   * on container insertion and std::forward_list::erase_after on container\n-   * erase calls. _M_before_begin is equivalent to\n-   * std::foward_list::before_begin. Empty buckets are containing nullptr.\n-   * Note that one of the non-empty bucket contains &_M_before_begin which is\n-   * not a derefenrenceable node so the node pointers in buckets shall never be\n-   * derefenrenced, only its next node can be.\n-   * \n-   * Walk through a bucket nodes require a check on the hash code to see if the\n-   * node is still in the bucket. Such a design impose a quite efficient hash\n-   * functor and is one of the reasons it is highly advise to set\n-   * __cache_hash_code to true.\n+   *  with _Bucket being _Hash_node* and _Hash_node constaining:\n    *\n-   * The container iterators are simply built from nodes. This way incrementing\n-   * the iterator is perfectly efficient independent of how many empty buckets\n-   * there are in the container.\n+   *  - _Hash_node*   _M_next\n+   *  - Tp            _M_value\n+   *  - size_t        _M_code if cache_hash_code is true\n    *\n-   * On insert we compute element hash code and thanks to it find the bucket\n-   * index. If the element must be inserted on an empty bucket we add it at the\n-   * beginning of the singly linked list and make the bucket point to\n-   * _M_before_begin. The bucket that used to point to _M_before_begin, if any,\n-   * is updated to point to its new before begin node.\n+   *  In terms of Standard containers the hastable is like the aggregation of:\n    *\n-   * On erase, the simple iterator design impose to use the hash functor to get\n-   * the index of the bucket to update. For this reason, when __cache_hash_code\n-   * is set to false, there is a static assertion that the hash functor cannot\n-   * throw.\n+   *  - std::forward_list<_Node> containing the elements\n+   *  - std::vector<std::forward_list<_Node>::iterator> representing the buckets\n+   *\n+   *  The non-empty buckets contain the node before the first bucket\n+   *  node. This design allow to implement something like a\n+   *  std::forward_list::insert_after on container insertion and\n+   *  std::forward_list::erase_after on container erase\n+   *  calls. _M_before_begin is equivalent to\n+   *  std::foward_list::before_begin. Empty buckets are containing\n+   *  nullptr.  Note that one of the non-empty bucket contains\n+   *  &_M_before_begin which is not a derefenrenceable node so the\n+   *  node pointers in buckets shall never be derefenrenced, only its\n+   *  next node can be.\n+   *\n+   *  Walk through a bucket nodes require a check on the hash code to\n+   *  see if the node is still in the bucket. Such a design impose a\n+   *  quite efficient hash functor and is one of the reasons it is\n+   *  highly advise to set __cache_hash_code to true.\n+   *\n+   *  The container iterators are simply built from nodes. This way\n+   *  incrementing the iterator is perfectly efficient independent of\n+   *  how many empty buckets there are in the container.\n+   *\n+   *  On insert we compute element hash code and thanks to it find the\n+   *  bucket index. If the element must be inserted on an empty bucket\n+   *  we add it at the beginning of the singly linked list and make the\n+   *  bucket point to _M_before_begin. The bucket that used to point to\n+   *  _M_before_begin, if any, is updated to point to its new before\n+   *  begin node.\n+   *\n+   *  On erase, the simple iterator design impose to use the hash\n+   *  functor to get the index of the bucket to update. For this\n+   *  reason, when __cache_hash_code is set to false, there is a static\n+   *  assertion that the hash functor cannot throw.\n+   *\n+   *  Functionality is implemented by decomposition into base classes,\n+   *  where the derived _Hashtable class is used in _Map_base,\n+   *  _Insert, _Rehash_base, and _Equality base classes to access the\n+   *  \"this\" pointer. _Hashtable_base is used in the base classes as a\n+   *  non-recursive, fully-completed-type so that detailed nested type\n+   *  information, such as iterator type and node type, can be\n+   *  used. This is similar to the \"Curiously Recurring Template\n+   *  Pattern\" (CRTP) technique, but uses a reconstructed, not\n+   *  explicitly passed, template pattern.\n+   *\n+   *  Base class templates are: \n+   *    __detail::_Hashtable_base\n+   *    __detail::_Map_base\n+   *    __detail::_Insert\n+   *    __detail::_Rehash_base\n+   *    __detail::_Equality\n    */\n-\n-  template<typename _Key, typename _Value, typename _Allocator,\n+  template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n-\t   typename _RehashPolicy,\n-\t   bool __cache_hash_code,\n-\t   bool __constant_iterators,\n-\t   bool __unique_keys>\n+\t   typename _RehashPolicy, typename _Traits>\n     class _Hashtable\n-    : public __detail::_Rehash_base<_RehashPolicy,\n-\t\t\t\t    _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t\t       _ExtractKey,\n-\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t       _RehashPolicy,\n-\t\t\t\t\t       __cache_hash_code,\n-\t\t\t\t\t       __constant_iterators,\n-\t\t\t\t\t       __unique_keys> >,\n-      public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t       _H1, _H2, _Hash, __cache_hash_code>,\n-      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,\n-\t\t\t\t _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t\t    _ExtractKey,\n-\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t    _RehashPolicy,\n-\t\t\t\t\t    __cache_hash_code,\n-\t\t\t\t\t    __constant_iterators,\n-\t\t\t\t\t    __unique_keys> >,\n-      public __detail::_Equality_base<_ExtractKey, __unique_keys,\n-\t\t\t\t      _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t\t\t _ExtractKey,\n-\t\t\t\t\t\t _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t\t _RehashPolicy,\n-\t\t\t\t\t\t __cache_hash_code,\n-\t\t\t\t\t\t __constant_iterators,\n-\t\t\t\t\t\t __unique_keys> >\n+    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t       _H1, _H2, _Hash, _Traits>,\n+      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t    _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>\n     {\n+    public:\n+      typedef _Key                                    key_type;\n+      typedef _Value                                  value_type;\n+      typedef _Alloc                                  allocator_type;\n+      typedef _Equal                                  key_equal;\n+\n+      // mapped_type, if present, comes from _Map_base.\n+      // hasher, if present, comes from _Hash_code_base/_Hashtable_base.\n+      typedef typename _Alloc::pointer\t\t      pointer;\n+      typedef typename _Alloc::const_pointer          const_pointer;\n+      typedef typename _Alloc::reference              reference;\n+      typedef typename _Alloc::const_reference        const_reference;\n+\n+    private:\n+      using __rehash_type = _RehashPolicy;\n+      using __rehash_state = typename __rehash_type::_State;\n+\n+      using __traits_type = _Traits;\n+      using __hash_cached = typename __traits_type::__hash_cached;\n+      using __constant_iterators = typename __traits_type::__constant_iterators;\n+      using __unique_keys = typename __traits_type::__unique_keys;\n+\n+      using __key_extract = typename std::conditional<\n+\t\t\t\t\t     __constant_iterators::value,\n+\t\t\t\t       \t     std::_Identity<value_type>,\n+\t\t\t\t\t     std::_Select1st<value_type>>::type;\n+\n+      using __hashtable_base = __detail::\n+\t\t\t       _Hashtable_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t      _Equal, _H1, _H2, _Hash, _Traits>;\n+\n+      using __hash_code_base =  typename __hashtable_base::__hash_code_base;\n+      using __hash_code =  typename __hashtable_base::__hash_code;\n+      using __node_type = typename __hashtable_base::__node_type;\n+      using __node_base = typename __hashtable_base::__node_base;\n+      using __bucket_type = typename __hashtable_base::__bucket_type;\n+      using __ireturn_type = typename __hashtable_base::__ireturn_type;\n+      using __iconv_type = typename __hashtable_base::__iconv_type;\n+\n+      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t     _RehashPolicy, _Traits>;\n+\n+      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,\n+\t\t\t\t\t\t   _ExtractKey, _Equal,\n+\t\t\t\t\t\t   _H1, _H2, _Hash,\n+\t\t\t\t\t\t   _RehashPolicy, _Traits>;\n+\n+      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t    _RehashPolicy, _Traits>;\n+\n+      // Metaprogramming for picking apart hash caching.\n+      using __hash_noexcept = __detail::__is_noexcept_hash<_Key, _H1>;\n+\n       template<typename _Cond>\n-\tusing __if_hash_code_cached\n-\t  = __or_<__not_<integral_constant<bool, __cache_hash_code>>, _Cond>;\n+\tusing __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;\n \n       template<typename _Cond>\n-\tusing __if_hash_code_not_cached\n-\t  = __or_<integral_constant<bool, __cache_hash_code>, _Cond>;\n-\n-      // When hash codes are not cached the hash functor shall not throw\n-      // because it is used in methods (erase, swap...) that shall not throw.\n-      static_assert(__if_hash_code_not_cached<__detail::__is_noexcept_hash<_Key,\n-\t\t\t\t\t\t\t\t_H1>>::value,\n-      \t    \"Cache the hash code or qualify your hash functor with noexcept\");\n-\n-      // Following two static assertions are necessary to guarantee that\n-      // swapping two hashtable instances won't invalidate associated local\n-      // iterators.\n-\n-      // When hash codes are cached local iterator only uses H2 which must then\n-      // be empty.\n-      static_assert(__if_hash_code_cached<is_empty<_H2>>::value,\n-\t    \"Functor used to map hash code to bucket index must be empty\");\n-\n-      typedef __detail::_Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t_H1, _H2, _Hash,\n-\t\t\t\t       \t__cache_hash_code> _HCBase;\n-\n-      // When hash codes are not cached local iterator is going to use _HCBase\n-      // above to compute node bucket index so it has to be empty.\n-      static_assert(__if_hash_code_not_cached<is_empty<_HCBase>>::value,\n-\t    \"Cache the hash code or make functors involved in hash code\"\n-\t    \" and bucket index computation empty\");\n+\tusing __if_hash_not_cached = __or_<__hash_cached, _Cond>;\n+\n+      // Compile-time diagnostics.\n+\n+      // When hash codes are not cached the hash functor shall not\n+      // throw because it is used in methods (erase, swap...) that\n+      // shall not throw.\n+      static_assert(__if_hash_not_cached<__hash_noexcept>::value,\n+\t\t    \"Cache the hash code\"\n+\t\t    \" or qualify your hash functor with noexcept\");\n+\n+      // Following two static assertions are necessary to guarantee\n+      // that swapping two hashtable instances won't invalidate\n+      // associated local iterators.\n+\n+      // When hash codes are cached local iterator only uses H2 which\n+      // must then be empty.\n+      static_assert(__if_hash_cached<is_empty<_H2>>::value,\n+\t\t    \"Functor used to map hash code to bucket index\"\n+\t\t    \" must be empty\");\n+\n+      // When hash codes are not cached local iterator is going to use\n+      // __hash_code_base above to compute node bucket index so it has\n+      // to be empty.\n+      static_assert(__if_hash_not_cached<is_empty<__hash_code_base>>::value,\n+\t\t   \"Cache the hash code or make functors involved in hash code\"\n+\t\t   \" and bucket index computation empty\");\n \n     public:\n-      typedef _Allocator                                  allocator_type;\n-      typedef _Value                                      value_type;\n-      typedef _Key                                        key_type;\n-      typedef _Equal                                      key_equal;\n-      // mapped_type, if present, comes from _Map_base.\n-      // hasher, if present, comes from _Hash_code_base.\n-      typedef typename _Allocator::pointer                pointer;\n-      typedef typename _Allocator::const_pointer          const_pointer;\n-      typedef typename _Allocator::reference              reference;\n-      typedef typename _Allocator::const_reference        const_reference;\n-\n-      typedef std::size_t                                 size_type;\n-      typedef std::ptrdiff_t                              difference_type;\n-      typedef __detail::_Local_iterator<key_type, value_type, _ExtractKey,\n-\t\t\t\t\t_H1, _H2, _Hash,\n-\t\t\t\t\t__constant_iterators,\n-\t\t\t\t\t__cache_hash_code>\n-\t\t\t\t\t\t\t  local_iterator;\n-      typedef __detail::_Local_const_iterator<key_type, value_type, _ExtractKey,\n-\t\t\t\t\t      _H1, _H2, _Hash,\n-\t\t\t\t\t      __constant_iterators,\n-\t\t\t\t\t      __cache_hash_code>\n-\t\t\t\t\t\t\t  const_local_iterator;\n-      typedef __detail::_Node_iterator<value_type, __constant_iterators,\n-\t\t\t\t       __cache_hash_code>\n-\t\t\t\t\t\t\t  iterator;\n-      typedef __detail::_Node_const_iterator<value_type,\n-\t\t\t\t\t     __constant_iterators,\n-\t\t\t\t\t     __cache_hash_code>\n-\t\t\t\t\t\t\t  const_iterator;\n-\n-      template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,\n-\t       typename _Hashtable2>\n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa,\n+\t       bool _Unique_keysa>\n \tfriend struct __detail::_Map_base;\n \n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa>\n+\tfriend struct __detail::_Insert_base;\n+\n+      template<typename _Keya, typename _Valuea, typename _Alloca,\n+\t       typename _ExtractKeya, typename _Equala,\n+\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _RehashPolicya, typename _Traitsa,\n+\t       bool _Constant_iteratorsa, bool _Unique_keysa>\n+\tfriend struct __detail::_Insert;\n+\n+      using size_type = typename __hashtable_base::size_type;\n+      using difference_type = typename __hashtable_base::difference_type;\n+\n+      using iterator = typename __hashtable_base::iterator;\n+      using const_iterator = typename __hashtable_base::const_iterator;\n+\n+      using local_iterator = typename __hashtable_base::local_iterator;\n+      using const_local_iterator = typename __hashtable_base::\n+\t\t\t\t   const_local_iterator;\n+\n     private:\n-      typedef typename _RehashPolicy::_State _RehashPolicyState;\n-      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;\n-      typedef typename _Allocator::template rebind<_Node>::other\n+      typedef typename _Alloc::template rebind<__node_type>::other\n \t\t\t\t\t\t\t_Node_allocator_type;\n-      typedef __detail::_Hash_node_base _BaseNode;\n-      typedef _BaseNode* _Bucket;\n-      typedef typename _Allocator::template rebind<_Bucket>::other\n+      typedef typename _Alloc::template rebind<__bucket_type>::other\n \t\t\t\t\t\t\t_Bucket_allocator_type;\n-\n-      typedef typename _Allocator::template rebind<_Value>::other\n+      typedef typename _Alloc::template rebind<value_type>::other\n \t\t\t\t\t\t\t_Value_allocator_type;\n \n+\n       _Node_allocator_type\t_M_node_allocator;\n-      _Bucket*\t\t\t_M_buckets;\n+      __bucket_type*\t\t_M_buckets;\n       size_type\t\t\t_M_bucket_count;\n-      _BaseNode\t\t\t_M_before_begin;\n+      __node_base\t       \t_M_before_begin;\n       size_type\t\t\t_M_element_count;\n       _RehashPolicy\t\t_M_rehash_policy;\n \n       template<typename... _Args>\n-\t_Node*\n+\t__node_type*\n \t_M_allocate_node(_Args&&... __args);\n \n       void\n-      _M_deallocate_node(_Node* __n);\n+      _M_deallocate_node(__node_type* __n);\n \n       // Deallocate the linked list of nodes pointed to by __n\n       void\n-      _M_deallocate_nodes(_Node* __n);\n+      _M_deallocate_nodes(__node_type* __n);\n \n-      _Bucket*\n+      __bucket_type*\n       _M_allocate_buckets(size_type __n);\n \n       void\n-      _M_deallocate_buckets(_Bucket*, size_type __n);\n+      _M_deallocate_buckets(__bucket_type*, size_type __n);\n \n       // Gets bucket begin, deals with the fact that non-empty buckets contain\n       // their before begin node.\n-      _Node*\n+      __node_type*\n       _M_bucket_begin(size_type __bkt) const;\n \n-      _Node*\n+      __node_type*\n       _M_begin() const\n-      { return static_cast<_Node*>(_M_before_begin._M_nxt); }\n+      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }\n \n     public:\n       // Constructor, destructor, assignment, swap\n@@ -305,6 +357,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Hashtable(_Hashtable&&);\n \n+      // Use delegating construtors.\n+      explicit\n+      _Hashtable(size_type __n = 10,\n+\t\t const _H1& __hf = _H1(),\n+\t\t const key_equal& __eql = key_equal(),\n+\t\t const allocator_type& __a = allocator_type())\n+      : _Hashtable(__n, __hf, __detail::_Mod_range_hashing(),\n+\t\t   __detail::_Default_ranged_hash(), __eql,\n+\t\t   __key_extract(), __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+\t_Hashtable(_InputIterator __f, _InputIterator __l,\n+\t\t   size_type __n = 0,\n+\t\t   const _H1& __hf = _H1(),\n+\t\t   const key_equal& __eql = key_equal(),\n+\t\t   const allocator_type& __a = allocator_type())\n+\t: _Hashtable(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t     __detail::_Default_ranged_hash(), __eql,\n+\t\t     __key_extract(), __a)\n+\t{ }\n+\n+      _Hashtable(initializer_list<value_type> __l,\n+\t\t size_type __n = 0,\n+\t\t const _H1& __hf = _H1(),\n+\t\t const key_equal& __eql = key_equal(),\n+\t\t const allocator_type& __a = allocator_type())\n+      : _Hashtable(__l.begin(), __l.end(), __n, __hf,\n+\t\t   __detail::_Mod_range_hashing(),\n+\t\t   __detail::_Default_ranged_hash(), __eql,\n+\t\t   __key_extract(), __a)\n+      { }\n+\n       _Hashtable&\n       operator=(const _Hashtable& __ht)\n       {\n@@ -323,6 +408,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+      _Hashtable&\n+      operator=(initializer_list<value_type> __l)\n+      {\n+\tthis->clear();\n+\tthis->insert(__l.begin(), __l.end());\n+\treturn *this;\n+      }\n+\n       ~_Hashtable() noexcept;\n \n       void swap(_Hashtable&);\n@@ -394,8 +487,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       local_iterator\n       begin(size_type __n)\n-      { return local_iterator(_M_bucket_begin(__n), __n,\n-\t\t\t      _M_bucket_count); }\n+      { return local_iterator(_M_bucket_begin(__n), __n, _M_bucket_count); }\n \n       local_iterator\n       end(size_type __n)\n@@ -428,8 +520,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // max_load_factor, if present, comes from _Rehash_base.\n \n-      // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n-      // useful if _RehashPolicy is something other than the default.\n+      // Generalization of max_load_factor.  Extension, not found in\n+      // TR1.  Only useful if _RehashPolicy is something other than\n+      // the default.\n       const _RehashPolicy&\n       __rehash_policy() const\n       { return _M_rehash_policy; }\n@@ -453,63 +546,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __k) const;\n \n-    private:\n+    protected:\n       // Bucket index computation helpers.\n       size_type\n-      _M_bucket_index(_Node* __n) const\n-      { return _HCBase::_M_bucket_index(__n, _M_bucket_count); }\n+      _M_bucket_index(__node_type* __n) const\n+      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }\n \n       size_type\n-      _M_bucket_index(const key_type& __k,\n-\t\t      typename _Hashtable::_Hash_code_type __c) const\n-      { return _HCBase::_M_bucket_index(__k, __c, _M_bucket_count); }\n+      _M_bucket_index(const key_type& __k, __hash_code __c) const\n+      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }\n \n       // Find and insert helper functions and types\n       // Find the node before the one matching the criteria.\n-      _BaseNode*\n-      _M_find_before_node(size_type, const key_type&,\n-\t\t\t  typename _Hashtable::_Hash_code_type) const;\n+      __node_base*\n+      _M_find_before_node(size_type, const key_type&, __hash_code) const;\n \n-      _Node*\n+      __node_type*\n       _M_find_node(size_type __bkt, const key_type& __key,\n-\t\t   typename _Hashtable::_Hash_code_type __c) const\n+\t\t   __hash_code __c) const\n       {\n-\t_BaseNode* __before_n = _M_find_before_node(__bkt, __key, __c);\n+\t__node_base* __before_n = _M_find_before_node(__bkt, __key, __c);\n \tif (__before_n)\n-\t  return static_cast<_Node*>(__before_n->_M_nxt);\n+\t  return static_cast<__node_type*>(__before_n->_M_nxt);\n \treturn nullptr;\n       }\n \n       // Insert a node at the beginning of a bucket.\n       void\n-      _M_insert_bucket_begin(size_type, _Node*);\n+      _M_insert_bucket_begin(size_type, __node_type*);\n \n       // Remove the bucket first node\n       void\n-      _M_remove_bucket_begin(size_type __bkt, _Node* __next_n,\n+      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,\n \t\t\t     size_type __next_bkt);\n \n       // Get the node before __n in the bucket __bkt\n-      _BaseNode*\n-      _M_get_previous_node(size_type __bkt, _BaseNode* __n);\n+      __node_base*\n+      _M_get_previous_node(size_type __bkt, __node_base* __n);\n \n       template<typename _Arg>\n \titerator\n-\t_M_insert_bucket(_Arg&&, size_type,\n-\t\t\t typename _Hashtable::_Hash_code_type);\n+\t_M_insert_bucket(_Arg&&, size_type, __hash_code);\n \n-      typedef typename std::conditional<__unique_keys,\n-\t\t\t\t\tstd::pair<iterator, bool>,\n-\t\t\t\t\titerator>::type\n-\t_Insert_Return_Type;\n \n-      typedef typename std::conditional<__unique_keys,\n-\t\t\t\t\tstd::_Select1st<_Insert_Return_Type>,\n-\t\t\t\t\tstd::_Identity<_Insert_Return_Type>\n-\t\t\t\t   >::type\n-\t_Insert_Conv_Type;\n-\n-    protected:\n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n \t_M_emplace(std::true_type, _Args&&... __args);\n@@ -527,51 +606,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_insert(_Arg&&, std::false_type);\n \n     public:\n-      // Emplace, insert and erase\n+      // Emplace\n       template<typename... _Args>\n-\t_Insert_Return_Type\n+\t__ireturn_type\n \templace(_Args&&... __args)\n-\t{ return _M_emplace(integral_constant<bool, __unique_keys>(),\n-\t\t\t    std::forward<_Args>(__args)...); }\n+\t{ return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }\n \n       template<typename... _Args>\n \titerator\n \templace_hint(const_iterator, _Args&&... __args)\n-\t{ return _Insert_Conv_Type()(emplace(std::forward<_Args>(__args)...)); }\n+\t{ return __iconv_type()(emplace(std::forward<_Args>(__args)...)); }\n \n-      _Insert_Return_Type\n-      insert(const value_type& __v)\n-      { return _M_insert(__v, integral_constant<bool, __unique_keys>()); }\n-\n-      iterator\n-      insert(const_iterator, const value_type& __v)\n-      { return _Insert_Conv_Type()(insert(__v)); }\n-\n-      template<typename _Pair, typename = typename\n-\tstd::enable_if<__and_<integral_constant<bool, !__constant_iterators>,\n-\t\t\t      std::is_convertible<_Pair,\n-\t\t\t\t\t\t  value_type>>::value>::type>\n-\t_Insert_Return_Type\n-\tinsert(_Pair&& __v)\n-\t{ return _M_insert(std::forward<_Pair>(__v),\n-\t\t\t   integral_constant<bool, __unique_keys>()); }\n-\n-      template<typename _Pair, typename = typename\n-        std::enable_if<__and_<integral_constant<bool, !__constant_iterators>,\n-\t\t\t      std::is_convertible<_Pair,\n-\t\t\t\t\t\t  value_type>>::value>::type>\n-\titerator\n-\tinsert(const_iterator, _Pair&& __v)\n-\t{ return _Insert_Conv_Type()(insert(std::forward<_Pair>(__v))); }\n-\n-      template<typename _InputIterator>\n-\tvoid\n-\tinsert(_InputIterator __first, _InputIterator __last);\n-\n-      void\n-      insert(initializer_list<value_type> __l)\n-      { this->insert(__l.begin(), __l.end()); }\n+      // Insert member functions via inheritance.\n \n+      // Erase\n       iterator\n       erase(const_iterator);\n \n@@ -602,26 +650,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Helper rehash method used when keys can be non-unique.\n       void _M_rehash_aux(size_type __n, std::false_type);\n \n-      // Unconditionally change size of bucket array to n, restore hash policy\n-      // state to __state on exception.\n-      void _M_rehash(size_type __n, const _RehashPolicyState& __state);\n+      // Unconditionally change size of bucket array to n, restore\n+      // hash policy state to __state on exception.\n+      void _M_rehash(size_type __n, const __rehash_state& __state);\n     };\n \n \n   // Definitions of class template _Hashtable's out-of-line member functions.\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename... _Args>\n-      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  __chc, __cit, __uk>::_Node*\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t  _H1, _H2, _Hash, _RehashPolicy, _Traits>::__node_type*\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_allocate_node(_Args&&... __args)\n       {\n-\t_Node* __n = _M_node_allocator.allocate(1);\n+\t__node_type* __n = _M_node_allocator.allocate(1);\n \t__try\n \t  {\n \t    _M_node_allocator.construct(__n, std::forward<_Args>(__args)...);\n@@ -635,125 +682,122 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_node(_Node* __n)\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_deallocate_node(__node_type* __n)\n     {\n       _M_node_allocator.destroy(__n);\n       _M_node_allocator.deallocate(__n, 1);\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_nodes(_Node* __n)\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_deallocate_nodes(__node_type* __n)\n     {\n       while (__n)\n \t{\n-\t  _Node* __tmp = __n;\n+\t  __node_type* __tmp = __n;\n \t  __n = __n->_M_next();\n \t  _M_deallocate_node(__tmp);\n \t}\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Bucket*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy, _Traits>::__bucket_type*\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_allocate_buckets(size_type __n)\n     {\n       _Bucket_allocator_type __alloc(_M_node_allocator);\n \n-      _Bucket* __p = __alloc.allocate(__n);\n-      __builtin_memset(__p, 0, __n * sizeof(_Bucket));\n+      __bucket_type* __p = __alloc.allocate(__n);\n+      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));\n       return __p;\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_buckets(_Bucket* __p, size_type __n)\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_deallocate_buckets(__bucket_type* __p, size_type __n)\n     {\n       _Bucket_allocator_type __alloc(_M_node_allocator);\n       __alloc.deallocate(__p, __n);\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::__node_type*\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_bucket_begin(size_type __bkt) const\n     {\n-      _BaseNode* __n = _M_buckets[__bkt];\n-      return __n ? static_cast<_Node*>(__n->_M_nxt) : nullptr;\n+      __node_base* __n = _M_buckets[__bkt];\n+      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _Hashtable(size_type __bucket_hint,\n \t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n \t       const _Equal& __eq, const _ExtractKey& __exk,\n \t       const allocator_type& __a)\n-    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n-      __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __h1, __h2, __h,\n-\t\t\t\t\t\t\t__eq),\n-      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+    : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n+      __map_base(),\n+      __rehash_base(),\n       _M_node_allocator(__a),\n       _M_bucket_count(0),\n       _M_element_count(0),\n       _M_rehash_policy()\n     {\n       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-      // We don't want the rehash policy to ask for the hashtable to shrink\n-      // on the first insertion so we need to reset its previous resize level.\n+\n+      // We don't want the rehash policy to ask for the hashtable to\n+      // shrink on the first insertion so we need to reset its\n+      // previous resize level.\n       _M_rehash_policy._M_prev_resize = 0;\n       _M_buckets = _M_allocate_buckets(_M_bucket_count);\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename _InputIterator>\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _Hashtable(_InputIterator __f, _InputIterator __l,\n \t\t size_type __bucket_hint,\n \t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n \t\t const _Equal& __eq, const _ExtractKey& __exk,\n \t\t const allocator_type& __a)\n-      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n-\t__detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __h1, __h2, __h,\n-\t\t\t\t\t\t\t  __eq),\n-\t__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+      : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n+\t__map_base(),\n+\t__rehash_base(),\n \t_M_node_allocator(__a),\n \t_M_bucket_count(0),\n \t_M_element_count(0),\n@@ -764,9 +808,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t   _M_bkt_for_elements(__detail::\n \t\t\t\t\t\t       __distance_fw(__f,\n \t\t\t\t\t\t\t\t     __l)));\n-        // We don't want the rehash policy to ask for the hashtable to shrink\n-        // on the first insertion so we need to reset its previous resize\n-\t// level.\n+\n+\t// We don't want the rehash policy to ask for the hashtable to\n+\t// shrink on the first insertion so we need to reset its\n+\t// previous resize level.\n \t_M_rehash_policy._M_prev_resize = 0;\n \t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n \t__try\n@@ -783,16 +828,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _Hashtable(const _Hashtable& __ht)\n-    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n-      __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n-      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+    : __hashtable_base(__ht),\n+      __map_base(__ht),\n+      __rehash_base(__ht),\n       _M_node_allocator(__ht._M_node_allocator),\n       _M_bucket_count(__ht._M_bucket_count),\n       _M_element_count(__ht._M_element_count),\n@@ -806,14 +850,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \t  // First deal with the special first node pointed to by\n \t  // _M_before_begin.\n-\t  const _Node* __ht_n = __ht._M_begin();\n-\t  _Node* __this_n = _M_allocate_node(__ht_n->_M_v);\n+\t  const __node_type* __ht_n = __ht._M_begin();\n+\t  __node_type* __this_n = _M_allocate_node(__ht_n->_M_v);\n \t  this->_M_copy_code(__this_n, __ht_n);\n \t  _M_before_begin._M_nxt = __this_n;\n \t  _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;\n \n \t  // Then deal with other nodes.\n-\t  _BaseNode* __prev_n = __this_n;\n+\t  __node_base* __prev_n = __this_n;\n \t  for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n \t    {\n \t      __this_n = _M_allocate_node(__ht_n->_M_v);\n@@ -834,16 +878,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _Hashtable(_Hashtable&& __ht)\n-    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n-      __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n-      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+    : __hashtable_base(__ht),\n+      __map_base(__ht),\n+      __rehash_base(__ht),\n       _M_node_allocator(std::move(__ht._M_node_allocator)),\n       _M_buckets(__ht._M_buckets),\n       _M_bucket_count(__ht._M_bucket_count),\n@@ -862,29 +905,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t   typename _Traits>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     ~_Hashtable() noexcept\n     {\n       clear();\n       _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     swap(_Hashtable& __x)\n     {\n-      // The only base class with member variables is hash_code_base.  We\n-      // define _Hash_code_base::_M_swap because different specializations\n-      // have different members.\n+      // The only base class with member variables is hash_code_base.\n+      // We define _Hash_code_base::_M_swap because different\n+      // specializations have different members.\n       this->_M_swap(__x);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -897,8 +940,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::swap(_M_bucket_count, __x._M_bucket_count);\n       std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);\n       std::swap(_M_element_count, __x._M_element_count);\n-      // Fix buckets containing the _M_before_begin pointers that can't be\n-      // swapped.\n+\n+      // Fix buckets containing the _M_before_begin pointers that\n+      // can't be swapped.\n       if (_M_begin())\n \t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n       if (__x._M_begin())\n@@ -907,12 +951,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     __rehash_policy(const _RehashPolicy& __pol)\n     {\n       size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n@@ -922,53 +966,53 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k)\n     {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n-      _Node* __p = _M_find_node(__n, __k, __code);\n+      __node_type* __p = _M_find_node(__n, __k, __code);\n       return __p ? iterator(__p) : this->end();\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::const_iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::const_iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k) const\n     {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n-      _Node* __p = _M_find_node(__n, __k, __code);\n+      __node_type* __p = _M_find_node(__n, __k, __code);\n       return __p ? const_iterator(__p) : this->end();\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::size_type\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::size_type\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     count(const key_type& __k) const\n     {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n-      _Node* __p = _M_bucket_begin(__n);\n+      __node_type* __p = _M_bucket_begin(__n);\n       if (!__p)\n \treturn 0;\n \n@@ -978,9 +1022,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (this->_M_equals(__k, __code, __p))\n \t    ++__result;\n \t  else if (__result)\n-\t    // All equivalent values are next to each other, if we found a not\n-\t    // equivalent value after an equivalent one it means that we won't\n-\t    // find anymore an equivalent value.\n+\t    // All equivalent values are next to each other, if we\n+\t    // found a not equivalent value after an equivalent one it\n+\t    // means that we won't find anymore an equivalent value.\n \t    break;\n \t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n@@ -989,28 +1033,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t   typename _Traits>\n+    std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t  _ExtractKey, _Equal, _H1,\n \t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::iterator,\n-\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _Traits>::iterator,\n+\t      typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t  _ExtractKey, _Equal, _H1,\n \t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::iterator>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t\t  _Traits>::iterator>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k)\n     {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n-      _Node* __p = _M_find_node(__n, __k, __code);\n+      __node_type* __p = _M_find_node(__n, __k, __code);\n \n       if (__p)\n \t{\n-\t  _Node* __p1 = __p->_M_next();\n+\t  __node_type* __p1 = __p->_M_next();\n \t  while (__p1 && _M_bucket_index(__p1) == __n\n \t\t && this->_M_equals(__k, __code, __p1))\n \t    __p1 = __p1->_M_next();\n@@ -1022,28 +1066,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t   typename _Traits>\n+    std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t  _ExtractKey, _Equal, _H1,\n \t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::const_iterator,\n-\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _Traits>::const_iterator,\n+\t      typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t  _ExtractKey, _Equal, _H1,\n \t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::const_iterator>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t\t  _Traits>::const_iterator>\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k) const\n     {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n-      _Node* __p = _M_find_node(__n, __k, __code);\n+      __node_type* __p = _M_find_node(__n, __k, __code);\n \n       if (__p)\n \t{\n-\t  _Node* __p1 = __p->_M_next();\n+\t  __node_type* __p1 = __p->_M_next();\n \t  while (__p1 && _M_bucket_index(__p1) == __n\n \t\t && this->_M_equals(__k, __code, __p1))\n \t    __p1 = __p1->_M_next();\n@@ -1054,24 +1098,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn std::make_pair(this->end(), this->end());\n     }\n \n-  // Find the node whose key compares equal to k in the bucket n. Return nullptr\n-  // if no node is found.\n+  // Find the node whose key compares equal to k in the bucket n.\n+  // Return nullptr if no node is found.\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_BaseNode*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::__node_base*\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_find_before_node(size_type __n, const key_type& __k,\n-\t\t\ttypename _Hashtable::_Hash_code_type __code) const\n+\t\t\t__hash_code __code) const\n     {\n-      _BaseNode* __prev_p = _M_buckets[__n];\n+      __node_base* __prev_p = _M_buckets[__n];\n       if (!__prev_p)\n \treturn nullptr;\n-      _Node* __p = static_cast<_Node*>(__prev_p->_M_nxt);\n+      __node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);\n       for (;; __p = __p->_M_next())\n \t{\n \t  if (this->_M_equals(__k, __code, __p))\n@@ -1084,51 +1128,53 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert_bucket_begin(size_type __bkt, _Node* __new_node)\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)\n     {\n       if (_M_buckets[__bkt])\n \t{\n-\t  // Bucket is not empty, we just need to insert the new node after the\n-\t  // bucket before begin.\n-\t  __new_node->_M_nxt = _M_buckets[__bkt]->_M_nxt;\n-\t  _M_buckets[__bkt]->_M_nxt = __new_node;\n+\t  // Bucket is not empty, we just need to insert the new node\n+\t  // after the bucket before begin.\n+\t  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;\n+\t  _M_buckets[__bkt]->_M_nxt = __node;\n \t}\n       else\n \t{\n-\t  // The bucket is empty, the new node is inserted at the beginning of\n-\t  // the singly linked list and the bucket will contain _M_before_begin\n-\t  // pointer.\n-\t  __new_node->_M_nxt = _M_before_begin._M_nxt;\n-\t  _M_before_begin._M_nxt = __new_node;\n-\t  if (__new_node->_M_nxt)\n+\t  // The bucket is empty, the new node is inserted at the\n+\t  // beginning of the singly linked list and the bucket will\n+\t  // contain _M_before_begin pointer.\n+\t  __node->_M_nxt = _M_before_begin._M_nxt;\n+\t  _M_before_begin._M_nxt = __node;\n+\t  if (__node->_M_nxt)\n \t    // We must update former begin bucket that is pointing to\n \t    // _M_before_begin.\n-\t    _M_buckets[_M_bucket_index(__new_node->_M_next())] = __new_node;\n+\t    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;\n \t  _M_buckets[__bkt] = &_M_before_begin;\n \t}\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_remove_bucket_begin(size_type __bkt, _Node* __next, size_type __next_bkt)\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,\n+\t\t\t   size_type __next_bkt)\n     {\n       if (!__next || __next_bkt != __bkt)\n \t{\n \t  // Bucket is now empty\n \t  // First update next bucket if any\n \t  if (__next)\n \t    _M_buckets[__next_bkt] = _M_buckets[__bkt];\n+\n \t  // Second update before begin node if necessary\n \t  if (&_M_before_begin == _M_buckets[__bkt])\n \t    _M_before_begin._M_nxt = __next;\n@@ -1137,54 +1183,53 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_BaseNode*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_get_previous_node(size_type __bkt, _BaseNode* __n)\n+\t\t\t_Traits>::__node_base*\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_get_previous_node(size_type __bkt, __node_base* __n)\n     {\n-      _BaseNode* __prev_n = _M_buckets[__bkt];\n+      __node_base* __prev_n = _M_buckets[__bkt];\n       while (__prev_n->_M_nxt != __n)\n \t__prev_n = __prev_n->_M_nxt;\n       return __prev_n;\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename... _Args>\n-      std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+      std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t    _ExtractKey, _Equal, _H1,\n \t\t\t\t    _H2, _Hash, _RehashPolicy,\n-\t\t\t\t    __chc, __cit, __uk>::iterator, bool>\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t\t    _Traits>::iterator, bool>\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_emplace(std::true_type, _Args&&... __args)\n       {\n \t// First build the node to get access to the hash code\n-\t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n+\t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n \t__try\n \t  {\n-\t    const key_type& __k = this->_M_extract()(__new_node->_M_v);\n-\t    typename _Hashtable::_Hash_code_type __code\n-\t      = this->_M_hash_code(__k);\n+\t    const key_type& __k = this->_M_extract()(__node->_M_v);\n+\t    __hash_code __code = this->_M_hash_code(__k);\n \t    size_type __bkt = _M_bucket_index(__k, __code);\n \n-\t    if (_Node* __p = _M_find_node(__bkt, __k, __code))\n+\t    if (__node_type* __p = _M_find_node(__bkt, __k, __code))\n \t      {\n \t\t// There is already an equivalent node, no insertion\n-\t\t_M_deallocate_node(__new_node);\n+\t\t_M_deallocate_node(__node);\n \t\treturn std::make_pair(iterator(__p), false);\n \t      }\n \n \t    // We are going to insert this node\n-\t    this->_M_store_code(__new_node, __code);\n-\t    const _RehashPolicyState& __saved_state\n+\t    this->_M_store_code(__node, __code);\n+\t    const __rehash_state& __saved_state\n \t      = _M_rehash_policy._M_state();\n \t    std::pair<bool, std::size_t> __do_rehash\n \t      = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n@@ -1196,244 +1241,225 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t__bkt = _M_bucket_index(__k, __code);\n \t      }\n \n-\t    _M_insert_bucket_begin(__bkt, __new_node);\n+\t    _M_insert_bucket_begin(__bkt, __node);\n \t    ++_M_element_count;\n-\t    return std::make_pair(iterator(__new_node), true);\n+\t    return std::make_pair(iterator(__node), true);\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_deallocate_node(__new_node);\n+\t    _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n       }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename... _Args>\n-      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  __chc, __cit, __uk>::iterator\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t  _Traits>::iterator\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_emplace(std::false_type, _Args&&... __args)\n       {\n-\tconst _RehashPolicyState& __saved_state = _M_rehash_policy._M_state();\n+\tconst __rehash_state& __saved_state = _M_rehash_policy._M_state();\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n \n \t// First build the node to get its hash code.\n-\t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n+\t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n \t__try\n \t  {\n-\t    const key_type& __k = this->_M_extract()(__new_node->_M_v);\n-\t    typename _Hashtable::_Hash_code_type __code\n-\t      = this->_M_hash_code(__k);\n-\t    this->_M_store_code(__new_node, __code);\n+\t    const key_type& __k = this->_M_extract()(__node->_M_v);\n+\t    __hash_code __code = this->_M_hash_code(__k);\n+\t    this->_M_store_code(__node, __code);\n \n \t    // Second, do rehash if necessary.\n \t    if (__do_rehash.first)\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n \n \t    // Third, find the node before an equivalent one.\n \t    size_type __bkt = _M_bucket_index(__k, __code);\n-\t    _BaseNode* __prev = _M_find_before_node(__bkt, __k, __code);\n-\t    \n+\t    __node_base* __prev = _M_find_before_node(__bkt, __k, __code);\n+\n \t    if (__prev)\n \t      {\n \t\t// Insert after the node before the equivalent one.\n-\t\t__new_node->_M_nxt = __prev->_M_nxt;\n-\t\t__prev->_M_nxt = __new_node;\n+\t\t__node->_M_nxt = __prev->_M_nxt;\n+\t\t__prev->_M_nxt = __node;\n \t      }\n \t    else\n-\t      // The inserted node has no equivalent in the hashtable. We must\n-\t      // insert the new node at the beginning of the bucket to preserve\n-\t      // equivalent elements relative positions.\n-\t      _M_insert_bucket_begin(__bkt, __new_node);\n+\t      // The inserted node has no equivalent in the\n+\t      // hashtable. We must insert the new node at the\n+\t      // beginning of the bucket to preserve equivalent\n+\t      // elements relative positions.\n+\t      _M_insert_bucket_begin(__bkt, __node);\n \t    ++_M_element_count;\n-\t    return iterator(__new_node);\n+\t    return iterator(__node);\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_deallocate_node(__new_node);\n+\t    _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n       }\n \n   // Insert v in bucket n (assumes no element with its key already present).\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename _Arg>\n-      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  __chc, __cit, __uk>::iterator\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      _M_insert_bucket(_Arg&& __v, size_type __n,\n-\t\t       typename _Hashtable::_Hash_code_type __code)\n+\t\t\t  _Traits>::iterator\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+      _M_insert_bucket(_Arg&& __v, size_type __n, __hash_code __code)\n       {\n-\tconst _RehashPolicyState& __saved_state = _M_rehash_policy._M_state();\n+\tconst __rehash_state& __saved_state = _M_rehash_policy._M_state();\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n \n \tif (__do_rehash.first)\n \t  {\n \t    const key_type& __k = this->_M_extract()(__v);\n-\t    __n = _HCBase::_M_bucket_index(__k, __code, __do_rehash.second);\n+\t    __n = __hash_code_base::_M_bucket_index(__k, __code,\n+\t\t\t\t\t\t    __do_rehash.second);\n \t  }\n \n-\t_Node* __new_node = nullptr;\n+\t__node_type* __node = nullptr;\n \t__try\n \t  {\n \t    // Allocate the new node before doing the rehash so that we\n \t    // don't do a rehash if the allocation throws.\n-\t    __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n-\t    this->_M_store_code(__new_node, __code);\n+\t    __node = _M_allocate_node(std::forward<_Arg>(__v));\n+\t    this->_M_store_code(__node, __code);\n \t    if (__do_rehash.first)\n \t      _M_rehash(__do_rehash.second, __saved_state);\n \n-\t    _M_insert_bucket_begin(__n, __new_node);\n+\t    _M_insert_bucket_begin(__n, __node);\n \t    ++_M_element_count;\n-\t    return iterator(__new_node);\n+\t    return iterator(__node);\n \t  }\n \t__catch(...)\n \t  {\n-\t    if (!__new_node)\n+\t    if (!__node)\n \t      _M_rehash_policy._M_reset(__saved_state);\n \t    else\n-\t      _M_deallocate_node(__new_node);\n+\t      _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n       }\n \n   // Insert v if no element with its key is already present.\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename _Arg>\n-      std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+      std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t    _ExtractKey, _Equal, _H1,\n \t\t\t\t    _H2, _Hash, _RehashPolicy,\n-\t\t\t\t    __chc, __cit, __uk>::iterator, bool>\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t\t    _Traits>::iterator, bool>\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(_Arg&& __v, std::true_type)\n       {\n \tconst key_type& __k = this->_M_extract()(__v);\n-\ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+\t__hash_code __code = this->_M_hash_code(__k);\n \tsize_type __n = _M_bucket_index(__k, __code);\n \n-\tif (_Node* __p = _M_find_node(__n, __k, __code))\n+\tif (__node_type* __p = _M_find_node(__n, __k, __code))\n \t  return std::make_pair(iterator(__p), false);\n \treturn std::make_pair(_M_insert_bucket(std::forward<_Arg>(__v),\n \t\t\t      __n, __code), true);\n       }\n \n   // Insert v unconditionally.\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     template<typename _Arg>\n-      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  __chc, __cit, __uk>::iterator\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t  _Traits>::iterator\n+      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(_Arg&& __v, std::false_type)\n       {\n-\tconst _RehashPolicyState& __saved_state = _M_rehash_policy._M_state();\n+\tconst __rehash_state& __saved_state = _M_rehash_policy._M_state();\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n \n-\t// First compute the hash code so that we don't do anything if it throws.\n-\ttypename _Hashtable::_Hash_code_type __code\n-\t  = this->_M_hash_code(this->_M_extract()(__v));\n+\t// First compute the hash code so that we don't do anything if\n+\t// it throws.\n+\t__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));\n \n-\t_Node* __new_node = nullptr;\n+\t__node_type* __node = nullptr;\n \t__try\n \t  {\n \t    // Second allocate new node so that we don't rehash if it throws.\n-\t    __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n-\t    this->_M_store_code(__new_node, __code);\n+\t    __node = _M_allocate_node(std::forward<_Arg>(__v));\n+\t    this->_M_store_code(__node, __code);\n \t    if (__do_rehash.first)\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n \n \t    // Third, find the node before an equivalent one.\n-\t    size_type __bkt = _M_bucket_index(__new_node);\n-\t    _BaseNode* __prev\n-\t      = _M_find_before_node(__bkt, this->_M_extract()(__new_node->_M_v),\n+\t    size_type __bkt = _M_bucket_index(__node);\n+\t    __node_base* __prev\n+\t      = _M_find_before_node(__bkt, this->_M_extract()(__node->_M_v),\n \t\t\t\t    __code);\n \t    if (__prev)\n \t      {\n \t\t// Insert after the node before the equivalent one.\n-\t\t__new_node->_M_nxt = __prev->_M_nxt;\n-\t\t__prev->_M_nxt = __new_node;\n+\t\t__node->_M_nxt = __prev->_M_nxt;\n+\t\t__prev->_M_nxt = __node;\n \t      }\n \t    else\n-\t      // The inserted node has no equivalent in the hashtable. We must\n-\t      // insert the new node at the beginning of the bucket to preserve\n-\t      // equivalent elements relative positions.\n-\t      _M_insert_bucket_begin(__bkt, __new_node);\n+\t      // The inserted node has no equivalent in the\n+\t      // hashtable. We must insert the new node at the\n+\t      // beginning of the bucket to preserve equivalent\n+\t      // elements relative positions.\n+\t      _M_insert_bucket_begin(__bkt, __node);\n \t    ++_M_element_count;\n-\t    return iterator(__new_node);\n+\t    return iterator(__node);\n \t  }\n \t__catch(...)\n \t  {\n-\t    if (!__new_node)\n+\t    if (!__node)\n \t      _M_rehash_policy._M_reset(__saved_state);\n \t    else\n-\t      _M_deallocate_node(__new_node);\n+\t      _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    template<typename _InputIterator>\n-      void\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      insert(_InputIterator __first, _InputIterator __last)\n-      {\n-\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n-\tconst _RehashPolicyState& __saved_state = _M_rehash_policy._M_state();\n-\tstd::pair<bool, std::size_t> __do_rehash\n-\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t    _M_element_count, __n_elt);\n-\tif (__do_rehash.first)\n-\t  _M_rehash(__do_rehash.second, __saved_state);\n-\n-\tfor (; __first != __last; ++__first)\n-\t  this->insert(*__first);\n-      }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     erase(const_iterator __it)\n     {\n-      _Node* __n = __it._M_cur;\n+      __node_type* __n = __it._M_cur;\n       std::size_t __bkt = _M_bucket_index(__n);\n \n-      // Look for previous node to unlink it from the erased one, this is why\n-      // we need buckets to contain the before begin to make this research fast.\n-      _BaseNode* __prev_n = _M_get_previous_node(__bkt, __n);\n+      // Look for previous node to unlink it from the erased one, this\n+      // is why we need buckets to contain the before begin to make\n+      // this research fast.\n+      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n       if (__n == _M_bucket_begin(__bkt))\n \t_M_remove_bucket_begin(__bkt, __n->_M_next(),\n \t   __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n@@ -1453,34 +1479,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::size_type\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::size_type\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     erase(const key_type& __k)\n     {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__k, __code);\n+\n       // Look for the node before the first matching node.\n-      _BaseNode* __prev_n = _M_find_before_node(__bkt, __k, __code);\n+      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n       if (!__prev_n)\n \treturn 0;\n-      _Node* __n = static_cast<_Node*>(__prev_n->_M_nxt);\n+      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n       bool __is_bucket_begin = _M_buckets[__bkt] == __prev_n;\n \n       // We found a matching node, start deallocation loop from it\n       std::size_t __next_bkt = __bkt;\n-      _Node* __next_n = __n;\n+      __node_type* __next_n = __n;\n       size_type __result = 0;\n-      _Node* __saved_n = nullptr;\n+      __node_type* __saved_n = nullptr;\n       do\n \t{\n-\t  _Node* __p = __next_n;\n+\t  __node_type* __p = __next_n;\n \t  __next_n = __p->_M_next();\n+\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // 526. Is it undefined if a function in the standard changes\n \t  // in parameters?\n@@ -1509,31 +1537,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+\t\t\t_Traits>::iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     erase(const_iterator __first, const_iterator __last)\n     {\n-      _Node* __n = __first._M_cur;\n-      _Node* __last_n = __last._M_cur;\n+      __node_type* __n = __first._M_cur;\n+      __node_type* __last_n = __last._M_cur;\n       if (__n == __last_n)\n \treturn iterator(__n);\n \n       std::size_t __bkt = _M_bucket_index(__n);\n \n-      _BaseNode* __prev_n = _M_get_previous_node(__bkt, __n);\n+      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n       bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);\n       std::size_t __n_bkt = __bkt;\n       for (;;)\n \t{\n \t  do\n \t    {\n-\t      _Node* __tmp = __n;\n+\t      __node_type* __tmp = __n;\n \t      __n = __n->_M_next();\n \t      _M_deallocate_node(__tmp);\n \t      --_M_element_count;\n@@ -1557,48 +1585,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     clear() noexcept\n     {\n       _M_deallocate_nodes(_M_begin());\n-      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(_Bucket));\n+      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));\n       _M_element_count = 0;\n       _M_before_begin._M_nxt = nullptr;\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     rehash(size_type __n)\n     {\n-      const _RehashPolicyState& __saved_state = _M_rehash_policy._M_state();\n+      const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),\n \t\t\t _M_rehash_policy._M_bkt_for_elements(_M_element_count\n \t\t\t\t\t\t\t      + 1)),\n \t\t__saved_state);\n     }\n \n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_rehash(size_type __n, const _RehashPolicyState& __state)\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_rehash(size_type __n, const __rehash_state& __state)\n     {\n       __try\n \t{\n-\t  _M_rehash_aux(__n, integral_constant<bool, __uk>());\n+\t  _M_rehash_aux(__n, __unique_keys());\n \t}\n       __catch(...)\n \t{\n@@ -1611,22 +1639,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Rehash when there is no equivalent elements.\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __n, std::true_type)\n     {\n-      _Bucket* __new_buckets = _M_allocate_buckets(__n);\n-      _Node* __p = _M_begin();\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n+      __node_type* __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n       std::size_t __bbegin_bkt;\n       while (__p)\n \t{\n-\t  _Node* __next = __p->_M_next();\n-\t  std::size_t __bkt = _HCBase::_M_bucket_index(__p, __n);\n+\t  __node_type* __next = __p->_M_next();\n+\t  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);\n \t  if (!__new_buckets[__bkt])\n \t    {\n \t      __p->_M_nxt = _M_before_begin._M_nxt;\n@@ -1651,28 +1679,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Rehash when there can be equivalent elements, preserve their relative\n   // order.\n   template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n+\t   typename _Traits>\n     void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __n, std::false_type)\n     {\n-      _Bucket* __new_buckets = _M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n \n-      _Node* __p = _M_begin();\n+      __node_type* __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n       std::size_t __bbegin_bkt;\n       std::size_t __prev_bkt;\n-      _Node* __prev_p = nullptr;\n+      __node_type* __prev_p = nullptr;\n       bool __check_bucket = false;\n \n       while (__p)\n \t{\n \t  bool __check_now = true;\n-\t  _Node* __next = __p->_M_next();\n-\t  std::size_t __bkt = _HCBase::_M_bucket_index(__p, __n);\n+\t  __node_type* __next = __p->_M_next();\n+\t  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);\n \n \t  if (!__new_buckets[__bkt])\n \t    {\n@@ -1707,15 +1735,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  __new_buckets[__bkt]->_M_nxt = __p;\n \t\t}\n \t    }\n-\t  \n+\n \t  if (__check_now && __check_bucket)\n \t    {\n \t      // Check if we shall update the next bucket because of insertions\n \t      // into __prev_bkt bucket.\n \t      if (__prev_p->_M_nxt)\n \t\t{\n \t\t  std::size_t __next_bkt\n-\t\t    = _HCBase::_M_bucket_index(__prev_p->_M_next(), __n);\n+\t\t    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n+\t\t\t\t\t\t\t__n);\n \t\t  if (__next_bkt != __prev_bkt)\n \t\t    __new_buckets[__next_bkt] = __prev_p;\n \t\t}\n@@ -1729,7 +1758,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__check_bucket && __prev_p->_M_nxt)\n \t{\n \t  std::size_t __next_bkt\n-\t    = _HCBase::_M_bucket_index(__prev_p->_M_next(), __n);\n+\t    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);\n \t  if (__next_bkt != __prev_bkt)\n \t    __new_buckets[__next_bkt] = __prev_p;\n \t}"}, {"sha": "2c66645e2c49742e3240c6256acffc21fe58e382", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 779, "deletions": 318, "changes": 1097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -33,10 +33,26 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    class _Hashtable;\n+\n namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  /**\n+   *  @defgroup hashtable-detail Base and Implementation Classes\n+   *  @ingroup unordered_associative_containers\n+   *  @{\n+   */\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _Traits>\n+    struct _Hashtable_base;\n+\n   // Helper function: return distance(first, last) for forward\n   // iterators, or 0 for input iterators.\n   template<class _Iterator>\n@@ -64,28 +80,68 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template <typename _Key, typename _Hash>\n     struct __is_noexcept_hash : std::integral_constant<bool,\n \tnoexcept(declval<const _Hash&>()(declval<const _Key&>()))>\n-    {};\n+    { };\n \n-  // Auxiliary types used for all instantiations of _Hashtable: nodes\n+  // Auxiliary types used for all instantiations of _Hashtable nodes\n   // and iterators.\n \n-  // Nodes, used to wrap elements stored in the hash table.  A policy\n-  // template parameter of class template _Hashtable controls whether\n-  // nodes also store a hash code. In some cases (e.g. strings) this\n-  // may be a performance win.\n+  /**\n+   *  struct _Hashtable_traits\n+   *\n+   *  Important traits for hash tables.\n+   *\n+   *  @tparam __cache_hash_code  Boolean value. True if the value of\n+   *  the hash function is stored along with the value. This is a\n+   *  time-space tradeoff.  Storing it may improve lookup speed by\n+   *  reducing the number of times we need to call the _Equal\n+   *  function.\n+   *\n+   *  @tparam __constant_iterators  Boolean value. True if iterator and\n+   *  const_iterator are both constant iterator types. This is true\n+   *  for unordered_set and unordered_multiset, false for\n+   *  unordered_map and unordered_multimap.\n+   *\n+   *  @tparam __unique_keys  Boolean value. True if the return value\n+   *  of _Hashtable::count(k) is always at most one, false if it may\n+   *  be an arbitrary number. This true for unordered_set and\n+   *  unordered_map, false for unordered_multiset and\n+   *  unordered_multimap.\n+   */\n+  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>\n+    struct _Hashtable_traits\n+    {\n+      template<bool _Cond>\n+\tusing __bool_constant = integral_constant<bool, _Cond>;\n+\n+      using __hash_cached = __bool_constant<_Cache_hash_code>;\n+      using __constant_iterators = __bool_constant<_Constant_iterators>;\n+      using __unique_keys = __bool_constant<_Unique_keys>;\n+    };\n+\n+  /**\n+   *  struct _Hash_node_base\n+   *\n+   * Nodes, used to wrap elements stored in the hash table.  A policy\n+   * template parameter of class template _Hashtable controls whether\n+   * nodes also store a hash code. In some cases (e.g. strings) this\n+   * may be a performance win.\n+   */\n   struct _Hash_node_base\n   {\n     _Hash_node_base* _M_nxt;\n \n-    _Hash_node_base()\n-      : _M_nxt() { }\n-    _Hash_node_base(_Hash_node_base* __next)\n-      : _M_nxt(__next) { }\n+    _Hash_node_base() : _M_nxt() { }\n+\n+    _Hash_node_base(_Hash_node_base* __next) : _M_nxt(__next) { }\n   };\n \n-  template<typename _Value, bool __cache_hash_code>\n+  /**\n+   *  Primary template struct _Hash_node.\n+   */\n+  template<typename _Value, bool _Cache_hash_code>\n     struct _Hash_node;\n \n+  /// Specialization.\n   template<typename _Value>\n     struct _Hash_node<_Value, true> : _Hash_node_base\n     {\n@@ -96,10 +152,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Hash_node(_Args&&... __args)\n \t: _M_v(std::forward<_Args>(__args)...), _M_hash_code() { }\n \n-      _Hash_node* _M_next() const\n-      { return static_cast<_Hash_node*>(_M_nxt); }\n+      _Hash_node*\n+      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }\n     };\n \n+  /// Specialization.\n   template<typename _Value>\n     struct _Hash_node<_Value, false> : _Hash_node_base\n     {\n@@ -109,56 +166,64 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Hash_node(_Args&&... __args)\n \t: _M_v(std::forward<_Args>(__args)...) { }\n \n-      _Hash_node* _M_next() const\n-      { return static_cast<_Hash_node*>(_M_nxt); }\n+      _Hash_node*\n+      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }\n     };\n \n-  // Node iterators, used to iterate through all the hashtable.\n-  template<typename _Value, bool __cache>\n+  /// Base class for node iterators.\n+  template<typename _Value, bool _Cache_hash_code>\n     struct _Node_iterator_base\n     {\n-      _Node_iterator_base(_Hash_node<_Value, __cache>* __p)\n+      typedef _Hash_node<_Value, _Cache_hash_code>    \t__node_type;\n+\n+      __node_type*  _M_cur;\n+\n+      _Node_iterator_base(__node_type* __p)\n       : _M_cur(__p) { }\n \n       void\n       _M_incr()\n       { _M_cur = _M_cur->_M_next(); }\n-\n-      _Hash_node<_Value, __cache>*  _M_cur;\n     };\n \n-  template<typename _Value, bool __cache>\n+  template<typename _Value, bool _Cache_hash_code>\n     inline bool\n-    operator==(const _Node_iterator_base<_Value, __cache>& __x,\n-\t       const _Node_iterator_base<_Value, __cache>& __y)\n+    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,\n+\t       const _Node_iterator_base<_Value, _Cache_hash_code >& __y)\n     { return __x._M_cur == __y._M_cur; }\n \n-  template<typename _Value, bool __cache>\n+  template<typename _Value, bool _Cache_hash_code>\n     inline bool\n-    operator!=(const _Node_iterator_base<_Value, __cache>& __x,\n-\t       const _Node_iterator_base<_Value, __cache>& __y)\n+    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,\n+\t       const _Node_iterator_base<_Value, _Cache_hash_code>& __y)\n     { return __x._M_cur != __y._M_cur; }\n \n+  /// Node iterators, used to iterate through all the hashtable.\n   template<typename _Value, bool __constant_iterators, bool __cache>\n     struct _Node_iterator\n     : public _Node_iterator_base<_Value, __cache>\n     {\n+    private:\n+      using __base_type = _Node_iterator_base<_Value, __cache>;\n+      using __node_type = typename __base_type::__node_type;\n+\n+    public:\n       typedef _Value                                   value_type;\n-      typedef typename std::conditional<__constant_iterators,\n-\t\t\t\t\tconst _Value*, _Value*>::type\n-\t\t\t\t\t\t       pointer;\n-      typedef typename std::conditional<__constant_iterators,\n-\t\t\t\t\tconst _Value&, _Value&>::type\n-\t\t\t\t\t\t       reference;\n       typedef std::ptrdiff_t                           difference_type;\n       typedef std::forward_iterator_tag                iterator_category;\n \n+      using pointer = typename std::conditional<__constant_iterators,\n+\t\t\t\t\t\tconst _Value*, _Value*>::type;\n+\n+      using reference = typename std::conditional<__constant_iterators,\n+\t\t\t\t\t\t  const _Value&, _Value&>::type;\n+\n       _Node_iterator()\n-      : _Node_iterator_base<_Value, __cache>(0) { }\n+      : __base_type(0) { }\n \n       explicit\n-      _Node_iterator(_Hash_node<_Value, __cache>* __p)\n-      : _Node_iterator_base<_Value, __cache>(__p) { }\n+      _Node_iterator(__node_type* __p)\n+      : __base_type(__p) { }\n \n       reference\n       operator*() const\n@@ -184,26 +249,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+  /// Node const_iterators, used to iterate through all the hashtable.\n   template<typename _Value, bool __constant_iterators, bool __cache>\n     struct _Node_const_iterator\n     : public _Node_iterator_base<_Value, __cache>\n     {\n+     private:\n+      using __base_type = _Node_iterator_base<_Value, __cache>;\n+      using __node_type = typename __base_type::__node_type;\n+\n+    public:\n       typedef _Value                                   value_type;\n-      typedef const _Value*                            pointer;\n-      typedef const _Value&                            reference;\n       typedef std::ptrdiff_t                           difference_type;\n       typedef std::forward_iterator_tag                iterator_category;\n \n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n+\n       _Node_const_iterator()\n-      : _Node_iterator_base<_Value, __cache>(0) { }\n+      : __base_type(0) { }\n \n       explicit\n-      _Node_const_iterator(_Hash_node<_Value, __cache>* __p)\n-      : _Node_iterator_base<_Value, __cache>(__p) { }\n+      _Node_const_iterator(__node_type* __p)\n+      : __base_type(__p) { }\n \n       _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,\n \t\t\t   __cache>& __x)\n-      : _Node_iterator_base<_Value, __cache>(__x._M_cur) { }\n+      : __base_type(__x._M_cur) { }\n \n       reference\n       operator*() const\n@@ -232,8 +304,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Many of class template _Hashtable's template parameters are policy\n   // classes.  These are defaults for the policies.\n \n-  // Default range hashing function: use division to fold a large number\n-  // into the range [0, N).\n+  /// Default range hashing function: use division to fold a large number\n+  /// into the range [0, N).\n   struct _Mod_range_hashing\n   {\n     typedef std::size_t first_argument_type;\n@@ -245,15 +317,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __num % __den; }\n   };\n \n-  // Default ranged hash function H.  In principle it should be a\n-  // function object composed from objects of type H1 and H2 such that\n-  // h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n-  // h1 and h2.  So instead we'll just use a tag to tell class template\n-  // hashtable to do that composition.\n+  /// Default ranged hash function H.  In principle it should be a\n+  /// function object composed from objects of type H1 and H2 such that\n+  /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n+  /// h1 and h2.  So instead we'll just use a tag to tell class template\n+  /// hashtable to do that composition.\n   struct _Default_ranged_hash { };\n \n-  // Default value for rehash policy.  Bucket size is (usually) the\n-  // smallest prime that keeps the load factor small enough.\n+  /// Default value for rehash policy.  Bucket size is (usually) the\n+  /// smallest prime that keeps the load factor small enough.\n   struct _Prime_rehash_policy\n   {\n     _Prime_rehash_policy(float __z = 1.0)\n@@ -385,157 +457,435 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   }\n \n   // Base classes for std::_Hashtable.  We define these base classes\n-  // because in some cases we want to do different things depending\n-  // on the value of a policy class.  In some cases the policy class\n+  // because in some cases we want to do different things depending on\n+  // the value of a policy class.  In some cases the policy class\n   // affects which member functions and nested typedefs are defined;\n   // we handle that by specializing base class templates.  Several of\n   // the base class templates need to access other members of class\n-  // template _Hashtable, so we use the \"curiously recurring template\n-  // pattern\" for them.\n-\n-  // class template _Map_base.  If the hashtable has a value type of\n-  // the form pair<T1, T2> and a key extraction policy that returns the\n-  // first part of the pair, the hashtable gets a mapped_type typedef.\n-  // If it satisfies those criteria and also has unique keys, then it\n-  // also gets an operator[].\n-  template<typename _Key, typename _Value, typename _Ex, bool __unique,\n-\t   typename _Hashtable>\n+  // template _Hashtable, so we use a variant of the \"Curiously\n+  // Recurring Template Pattern\" (CRTP) technique.\n+\n+  /**\n+   *  Primary class template _Map_base.\n+   *\n+   *  If the hashtable has a value type of the form pair<T1, T2> and a\n+   *  key extraction policy (_ExtractKey) that returns the first part\n+   *  of the pair, the hashtable gets a mapped_type typedef.  If it\n+   *  satisfies those criteria and also has unique keys, then it also\n+   *  gets an operator[].\n+   */\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits,\n+\t   bool _Unique_keys = _Traits::__unique_keys::value>\n     struct _Map_base { };\n \n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>\n+  /// Partial specialization, __unique_keys set to false.\n+  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>\n     {\n-      typedef typename _Pair::second_type mapped_type;\n+      using mapped_type = typename _Pair::second_type;\n     };\n \n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>\n+  /// Partial specialization, __unique_keys set to true.\n+  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n     {\n-      typedef typename _Pair::second_type mapped_type;\n+    private:\n+      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,\n+\t\t\t\t\t\t\t std::_Select1st<_Pair>,\n+\t\t\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t\t\t  _Traits>;\n+\n+      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,\n+\t\t\t\t     std::_Select1st<_Pair>, _Equal,\n+\t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n+\n+      using __hash_code = typename __hashtable_base::__hash_code;\n+      using __node_type = typename __hashtable_base::__node_type;\n+\n+    public:\n+      using key_type = typename __hashtable_base::key_type;\n+      using iterator = typename __hashtable_base::iterator;\n+      using mapped_type = typename _Pair::second_type;\n \n       mapped_type&\n-      operator[](const _Key& __k);\n+      operator[](const key_type& __k);\n \n       mapped_type&\n-      operator[](_Key&& __k);\n+      operator[](key_type&& __k);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 761. unordered_map needs an at() member function.\n       mapped_type&\n-      at(const _Key& __k);\n+      at(const key_type& __k);\n \n       const mapped_type&\n-      at(const _Key& __k) const;\n+      at(const key_type& __k) const;\n     };\n \n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n-\t\t       true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    operator[](const _Key& __k)\n+  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    typename _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t\t       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+\t\t       ::mapped_type&\n+    _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+    operator[](const key_type& __k)\n     {\n-      _Hashtable* __h = static_cast<_Hashtable*>(this);\n-      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      __hashtable* __h = static_cast<__hashtable*>(this);\n+      __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __n = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n \n-      typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n \treturn __h->_M_insert_bucket(std::make_pair(__k, mapped_type()),\n \t\t\t\t     __n, __code)->second;\n       return (__p->_M_v).second;\n     }\n \n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n-\t\t       true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    operator[](_Key&& __k)\n+  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    typename _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t\t       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+\t\t       ::mapped_type&\n+    _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+    operator[](key_type&& __k)\n     {\n-      _Hashtable* __h = static_cast<_Hashtable*>(this);\n-      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      __hashtable* __h = static_cast<__hashtable*>(this);\n+      __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __n = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n \n-      typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n \treturn __h->_M_insert_bucket(std::make_pair(std::move(__k),\n \t\t\t\t\t\t    mapped_type()),\n \t\t\t\t     __n, __code)->second;\n       return (__p->_M_v).second;\n     }\n \n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n-\t\t       true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    at(const _Key& __k)\n+  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    typename _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t\t       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+\t\t       ::mapped_type&\n+    _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+    at(const key_type& __k)\n     {\n-      _Hashtable* __h = static_cast<_Hashtable*>(this);\n-      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      __hashtable* __h = static_cast<__hashtable*>(this);\n+      __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __n = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n \n-      typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n       return (__p->_M_v).second;\n     }\n \n-  template<typename _Key, typename _Pair, typename _Hashtable>\n-    const typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n-\t\t\t     true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    at(const _Key& __k) const\n+  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    const typename _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>,\n+\t\t\t     _Equal,\n+\t\t       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+\t\t       ::mapped_type&\n+    _Map_base<_Key, _Pair, _Alloc, std::_Select1st<_Pair>, _Equal,\n+\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+    at(const key_type& __k) const\n     {\n-      const _Hashtable* __h = static_cast<const _Hashtable*>(this);\n-      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      const __hashtable* __h = static_cast<const __hashtable*>(this);\n+      __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __n = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n \n-      typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n       return (__p->_M_v).second;\n     }\n \n-  // class template _Rehash_base.  Give hashtable the max_load_factor\n-  // functions and reserve iff the rehash policy is _Prime_rehash_policy.\n-  template<typename _RehashPolicy, typename _Hashtable>\n-    struct _Rehash_base { };\n+  /**\n+   *  Primary class template _Insert_base.\n+   *\n+   *  insert member functions appropriate to all _Hashtables.\n+   */\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Insert_base\n+    {\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+\n+      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t       _Traits>;\n+\n+      using value_type = typename __hashtable_base::value_type;\n+      using iterator = typename __hashtable_base::iterator;\n+      using const_iterator =  typename __hashtable_base::const_iterator;\n+      using size_type = typename __hashtable_base::size_type;\n+\n+      using __unique_keys = typename __hashtable_base::__unique_keys;\n+      using __ireturn_type = typename __hashtable_base::__ireturn_type;\n+      using __iconv_type = typename __hashtable_base::__iconv_type;\n+\n+      __hashtable&\n+      _M_conjure_hashtable()\n+      { return *(static_cast<__hashtable*>(this)); }\n+\n+      __ireturn_type\n+      insert(const value_type& __v)\n+      {\n+\t__hashtable& __h = _M_conjure_hashtable();\n+\treturn __h._M_insert(__v, __unique_keys());\n+      }\n+\n+      iterator\n+      insert(const_iterator, const value_type& __v)\n+      { return __iconv_type()(insert(__v)); }\n \n-  template<typename _Hashtable>\n-    struct _Rehash_base<_Prime_rehash_policy, _Hashtable>\n+      void\n+      insert(initializer_list<value_type> __l)\n+      { this->insert(__l.begin(), __l.end()); }\n+\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last);\n+    };\n+\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _InputIterator>\n+      void\n+      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t    _RehashPolicy, _Traits>::\n+      insert(_InputIterator __first, _InputIterator __last)\n+      {\n+\tusing __rehash_type = typename __hashtable::__rehash_type;\n+\tusing __rehash_state = typename __hashtable::__rehash_state;\n+\tusing pair_type = std::pair<bool, std::size_t>;\n+\n+\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\n+\t__hashtable& __h = _M_conjure_hashtable();\n+\t__rehash_type& __rehash = __h._M_rehash_policy;\n+\tconst __rehash_state& __saved_state = __rehash._M_state();\n+\tpair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,\n+\t\t\t\t\t\t\t__h._M_element_count,\n+\t\t\t\t\t\t\t__n_elt);\n+\n+\tif (__do_rehash.first)\n+\t  __h._M_rehash(__do_rehash.second, __saved_state);\n+\n+\tfor (; __first != __last; ++__first)\n+\t  this->insert(*__first);\n+      }\n+\n+  /**\n+   *  Primary class template _Insert.\n+   *\n+   *  Select insert member functions appropriate to _Hashtable policy choices.\n+   */\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits,\n+\t   bool _Constant_iterators = _Traits::__constant_iterators::value,\n+\t   bool _Unique_keys = _Traits::__unique_keys::value>\n+    struct _Insert;\n+\n+  /// Specialization.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t   _RehashPolicy, _Traits, true, true>\n+    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n+    {\n+      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t_RehashPolicy, _Traits>;\n+      using value_type = typename __base_type::value_type;\n+      using iterator = typename __base_type::iterator;\n+      using const_iterator =  typename __base_type::const_iterator;\n+\n+      using __unique_keys = typename __base_type::__unique_keys;\n+      using __hashtable = typename __base_type::__hashtable;\n+\n+      using __base_type::insert;\n+\n+      std::pair<iterator, bool>\n+      insert(value_type&& __v)\n+      {\n+\t__hashtable& __h = this->_M_conjure_hashtable();\n+\treturn __h._M_insert(std::move(__v), __unique_keys());\n+      }\n+\n+      iterator\n+      insert(const_iterator, value_type&& __v)\n+      { return insert(std::move(__v)).first; }\n+    };\n+\n+  /// Specialization.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t   _RehashPolicy, _Traits, true, false>\n+    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n+    {\n+      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t_RehashPolicy, _Traits>;\n+      using value_type = typename __base_type::value_type;\n+      using iterator = typename __base_type::iterator;\n+      using const_iterator =  typename __base_type::const_iterator;\n+\n+      using __unique_keys = typename __base_type::__unique_keys;\n+      using __hashtable = typename __base_type::__hashtable;\n+\n+      using __base_type::insert;\n+\n+      iterator\n+      insert(value_type&& __v)\n+      {\n+\t__hashtable& __h = this->_M_conjure_hashtable();\n+\treturn __h._M_insert(std::move(__v), __unique_keys());\n+      }\n+\n+      iterator\n+      insert(const_iterator, value_type&& __v)\n+      { return insert(std::move(__v)); }\n+     };\n+\n+  /// Specialization.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits, bool _Unique_keys>\n+    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t   _RehashPolicy, _Traits, false, _Unique_keys>\n+    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n     {\n+      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t       _RehashPolicy, _Traits>;\n+      using value_type = typename __base_type::value_type;\n+      using iterator = typename __base_type::iterator;\n+      using const_iterator =  typename __base_type::const_iterator;\n+\n+      using __unique_keys = typename __base_type::__unique_keys;\n+      using __hashtable = typename __base_type::__hashtable;\n+      using __ireturn_type = typename __base_type::__ireturn_type;\n+      using __iconv_type = typename __base_type::__iconv_type;\n+\n+      using __base_type::insert;\n+\n+      template<typename _Pair>\n+\tusing __is_convertible = std::is_convertible<_Pair, value_type>;\n+\n+      template<typename _Pair>\n+\tusing _IFconv = std::enable_if<__is_convertible<_Pair>::value>;\n+\n+      template<typename _Pair>\n+\tusing _IFconvp = typename _IFconv<_Pair>::type;\n+\n+      template<typename _Pair, typename = _IFconvp<_Pair>>\n+\t__ireturn_type\n+\tinsert(_Pair&& __v)\n+\t{\n+\t  __hashtable& __h = this->_M_conjure_hashtable();\n+\t  return __h._M_insert(std::forward<_Pair>(__v), __unique_keys());\n+\t}\n+\n+      template<typename _Pair, typename = _IFconvp<_Pair>>\n+\titerator\n+\tinsert(const_iterator, _Pair&& __v)\n+\t{ return __iconv_type()(insert(std::forward<_Pair>(__v))); }\n+   };\n+\n+  /**\n+   *  Primary class template  _Rehash_base.\n+   *\n+   *  Give hashtable the max_load_factor functions and reserve iff the\n+   *  rehash policy is _Prime_rehash_policy.\n+  */\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Rehash_base;\n+\n+  /// Specialization.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _Traits>\n+    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _Prime_rehash_policy, _Traits>\n+    {\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _Prime_rehash_policy, _Traits>;\n+\n       float\n       max_load_factor() const noexcept\n       {\n-\tconst _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+\tconst __hashtable* __this = static_cast<const __hashtable*>(this);\n \treturn __this->__rehash_policy().max_load_factor();\n       }\n \n       void\n       max_load_factor(float __z)\n       {\n-\t_Hashtable* __this = static_cast<_Hashtable*>(this);\n+\t__hashtable* __this = static_cast<__hashtable*>(this);\n \t__this->__rehash_policy(_Prime_rehash_policy(__z));\n       }\n \n       void\n       reserve(std::size_t __n)\n       {\n-\t_Hashtable* __this = static_cast<_Hashtable*>(this);\n+\t__hashtable* __this = static_cast<__hashtable*>(this);\n \t__this->rehash(__builtin_ceil(__n / max_load_factor()));\n       }\n     };\n \n-  // Helper class using EBO when it is not forbidden, type is not final,\n-  // and when it worth it, type is empty.\n+  /**\n+   *  Primary class template _Hashtable_ebo_helper.\n+   *\n+   *  Helper class using EBO when it is not forbidden, type is not\n+   *  final, and when it worth it, type is empty.\n+   */\n   template<int _Nm, typename _Tp,\n \t   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>\n     struct _Hashtable_ebo_helper;\n \n-  // Specialization using EBO.\n+  /// Specialization using EBO.\n   template<int _Nm, typename _Tp>\n     struct _Hashtable_ebo_helper<_Nm, _Tp, true> : private _Tp\n     {\n       _Hashtable_ebo_helper() = default;\n+\n       _Hashtable_ebo_helper(const _Tp& __tp) : _Tp(__tp)\n       { }\n \n@@ -548,11 +898,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return static_cast<_Tp&>(__eboh); }\n     };\n \n-  // Specialization not using EBO.\n+  /// Specialization not using EBO.\n   template<int _Nm, typename _Tp>\n     struct _Hashtable_ebo_helper<_Nm, _Tp, false>\n     {\n       _Hashtable_ebo_helper() = default;\n+\n       _Hashtable_ebo_helper(const _Tp& __tp) : _M_tp(__tp)\n       { }\n \n@@ -568,70 +919,72 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Tp _M_tp;\n     };\n \n-  // Class template _Hash_code_base.  Encapsulates two policy issues that\n-  // aren't quite orthogonal.\n-  //   (1) the difference between using a ranged hash function and using\n-  //       the combination of a hash function and a range-hashing function.\n-  //       In the former case we don't have such things as hash codes, so\n-  //       we have a dummy type as placeholder.\n-  //   (2) Whether or not we cache hash codes.  Caching hash codes is\n-  //       meaningless if we have a ranged hash function.\n-  // We also put the key extraction objects here, for convenience.\n-  //\n-  // Each specialization derives from one or more of the template parameters to\n-  // benefit from Ebo. This is important as this type is inherited in some cases\n-  // by the _Local_iterator_base type used to implement local_iterator and\n-  // const_local_iterator. As with any iterator type we prefer to make it as\n-  // small as possible.\n-\n-  // Primary template: unused except as a hook for specializations.\n+  /**\n+   *  Primary class template _Hash_code_base.\n+   *\n+   *  Encapsulates two policy issues that aren't quite orthogonal.\n+   *   (1) the difference between using a ranged hash function and using\n+   *       the combination of a hash function and a range-hashing function.\n+   *       In the former case we don't have such things as hash codes, so\n+   *       we have a dummy type as placeholder.\n+   *   (2) Whether or not we cache hash codes.  Caching hash codes is\n+   *       meaningless if we have a ranged hash function.\n+   *\n+   *  We also put the key extraction objects here, for convenience.\n+   *  Each specialization derives from one or more of the template\n+   *  parameters to benefit from Ebo. This is important as this type\n+   *  is inherited in some cases by the _Local_iterator_base type used\n+   *  to implement local_iterator and const_local_iterator. As with\n+   *  any iterator type we prefer to make it as small as possible.\n+   *\n+   *  Primary template is unused except as a hook for specializations.\n+   */\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   bool __cache_hash_code>\n     struct _Hash_code_base;\n \n-  // Specialization: ranged hash function, no caching hash codes.  H1\n-  // and H2 are provided but ignored.  We define a dummy hash code type.\n-  template<typename _Key, typename _Value, typename _ExtractKey, \n+  /// Specialization: ranged hash function, no caching hash codes.  H1\n+  /// and H2 are provided but ignored.  We define a dummy hash code type.\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash>\n     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>\n     : private _Hashtable_ebo_helper<0, _ExtractKey>,\n       private _Hashtable_ebo_helper<1, _Hash>\n     {\n     private:\n-      typedef _Hashtable_ebo_helper<0, _ExtractKey> _EboExtractKey;\n-      typedef _Hashtable_ebo_helper<1, _Hash> _EboHash;\n+      typedef _Hashtable_ebo_helper<0, _ExtractKey> \t_EboExtractKey;\n+      typedef _Hashtable_ebo_helper<1, _Hash> \t\t_EboHash;\n \n     protected:\n+      typedef void* \t\t\t\t\t__hash_code;\n+      typedef _Hash_node<_Value, false>\t\t\t__node_type;\n+\n       // We need the default constructor for the local iterators.\n       _Hash_code_base() = default;\n-      _Hash_code_base(const _ExtractKey& __ex,\n-\t\t      const _H1&, const _H2&, const _Hash& __h)\n-\t: _EboExtractKey(__ex), _EboHash(__h) { }\n \n-      typedef void* _Hash_code_type;\n+      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,\n+\t\t      const _Hash& __h)\n+      : _EboExtractKey(__ex), _EboHash(__h) { }\n \n-      _Hash_code_type\n+      __hash_code\n       _M_hash_code(const _Key& __key) const\n       { return 0; }\n \n       std::size_t\n-      _M_bucket_index(const _Key& __k, _Hash_code_type,\n-\t\t      std::size_t __n) const\n+      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const\n       { return _M_ranged_hash()(__k, __n); }\n \n       std::size_t\n-      _M_bucket_index(const _Hash_node<_Value, false>* __p,\n-\t\t      std::size_t __n) const\n+      _M_bucket_index(const __node_type* __p, std::size_t __n) const\n       { return _M_ranged_hash()(_M_extract()(__p->_M_v), __n); }\n \n       void\n-      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n+      _M_store_code(__node_type*, __hash_code) const\n       { }\n \n       void\n-      _M_copy_code(_Hash_node<_Value, false>*,\n-\t\t   const _Hash_node<_Value, false>*) const\n+      _M_copy_code(__node_type*, const __node_type*) const\n       { }\n \n       void\n@@ -644,27 +997,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     protected:\n       const _ExtractKey&\n       _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+\n       _ExtractKey&\n       _M_extract() { return _EboExtractKey::_S_get(*this); }\n+\n       const _Hash&\n       _M_ranged_hash() const { return _EboHash::_S_cget(*this); }\n+\n       _Hash&\n       _M_ranged_hash() { return _EboHash::_S_get(*this); }\n     };\n \n   // No specialization for ranged hash function while caching hash codes.\n   // That combination is meaningless, and trying to do it is an error.\n \n-  // Specialization: ranged hash function, cache hash codes.  This\n-  // combination is meaningless, so we provide only a declaration\n-  // and no definition.\n+  /// Specialization: ranged hash function, cache hash codes.  This\n+  /// combination is meaningless, so we provide only a declaration\n+  /// and no definition.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash>\n     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;\n \n-  // Specialization: hash function and range-hashing function, no\n-  // caching of hash codes.\n-  // Provides typedef and accessor required by TR1.\n+  /// Specialization: hash function and range-hashing function, no\n+  /// caching of hash codes.\n+  /// Provides typedef and accessor required by TR1.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2>\n     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n@@ -674,48 +1030,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private _Hashtable_ebo_helper<2, _H2>\n     {\n     private:\n-      typedef _Hashtable_ebo_helper<0, _ExtractKey> _EboExtractKey;\n-      typedef _Hashtable_ebo_helper<1, _H1> _EboH1;\n-      typedef _Hashtable_ebo_helper<2, _H2> _EboH2;\n+      typedef _Hashtable_ebo_helper<0, _ExtractKey> \t_EboExtractKey;\n+      typedef _Hashtable_ebo_helper<1, _H1> \t\t_EboH1;\n+      typedef _Hashtable_ebo_helper<2, _H2> \t\t_EboH2;\n \n     public:\n-      typedef _H1 hasher;\n+      typedef _H1 \t\t\t\t\thasher;\n \n       hasher\n       hash_function() const\n       { return _M_h1(); }\n \n+      typedef std::size_t \t\t\t\t__hash_code;\n+      typedef _Hash_node<_Value, false>\t\t\t__node_type;\n+\n     protected:\n       // We need the default constructor for the local iterators.\n       _Hash_code_base() = default;\n+\n       _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1& __h1, const _H2& __h2,\n \t\t      const _Default_ranged_hash&)\n       : _EboExtractKey(__ex), _EboH1(__h1), _EboH2(__h2) { }\n \n-      typedef std::size_t _Hash_code_type;\n-\n-      _Hash_code_type\n+      __hash_code\n       _M_hash_code(const _Key& __k) const\n       { return _M_h1()(__k); }\n \n       std::size_t\n-      _M_bucket_index(const _Key&, _Hash_code_type __c,\n-\t\t      std::size_t __n) const\n+      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const\n       { return _M_h2()(__c, __n); }\n \n       std::size_t\n-      _M_bucket_index(const _Hash_node<_Value, false>* __p,\n+      _M_bucket_index(const __node_type* __p,\n \t\t      std::size_t __n) const\n       { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v)), __n); }\n \n       void\n-      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n+      _M_store_code(__node_type*, __hash_code) const\n       { }\n \n       void\n-      _M_copy_code(_Hash_node<_Value, false>*,\n-\t\t   const _Hash_node<_Value, false>*) const\n+      _M_copy_code(__node_type*, const __node_type*) const\n       { }\n \n       void\n@@ -726,24 +1082,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstd::swap(_M_h2(), __x._M_h2());\n       }\n \n-    protected:\n       const _ExtractKey&\n       _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+\n       _ExtractKey&\n       _M_extract() { return _EboExtractKey::_S_get(*this); }\n+\n       const _H1&\n       _M_h1() const { return _EboH1::_S_cget(*this); }\n+\n       _H1&\n       _M_h1() { return _EboH1::_S_get(*this); }\n+\n       const _H2&\n       _M_h2() const { return _EboH2::_S_cget(*this); }\n+\n       _H2&\n       _M_h2() { return _EboH2::_S_get(*this); }\n     };\n \n-  // Specialization: hash function and range-hashing function,\n-  // caching hash codes.  H is provided but ignored.  Provides\n-  // typedef and accessor required by TR1.\n+  /// Specialization: hash function and range-hashing function,\n+  /// caching hash codes.  H is provided but ignored.  Provides\n+  /// typedef and accessor required by TR1.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2>\n     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n@@ -753,46 +1113,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private _Hashtable_ebo_helper<2, _H2>\n     {\n     private:\n-      typedef _Hashtable_ebo_helper<0, _ExtractKey> _EboExtractKey;\n-      typedef _Hashtable_ebo_helper<1, _H1> _EboH1;\n-      typedef _Hashtable_ebo_helper<2, _H2> _EboH2;\n+      typedef _Hashtable_ebo_helper<0, _ExtractKey>\t_EboExtractKey;\n+      typedef _Hashtable_ebo_helper<1, _H1> \t\t_EboH1;\n+      typedef _Hashtable_ebo_helper<2, _H2> \t\t_EboH2;\n \n     public:\n-      typedef _H1 hasher;\n+      typedef _H1 \t\t\t\t\thasher;\n \n       hasher\n       hash_function() const\n       { return _M_h1(); }\n \n+      typedef std::size_t \t\t\t\t__hash_code;\n+      typedef _Hash_node<_Value, true>\t\t\t__node_type;\n+\n     protected:\n       _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1& __h1, const _H2& __h2,\n \t\t      const _Default_ranged_hash&)\n       : _EboExtractKey(__ex), _EboH1(__h1), _EboH2(__h2) { }\n \n-      typedef std::size_t _Hash_code_type;\n-\n-      _Hash_code_type\n+      __hash_code\n       _M_hash_code(const _Key& __k) const\n       { return _M_h1()(__k); }\n \n       std::size_t\n-      _M_bucket_index(const _Key&, _Hash_code_type __c,\n+      _M_bucket_index(const _Key&, __hash_code __c,\n \t\t      std::size_t __n) const\n       { return _M_h2()(__c, __n); }\n \n       std::size_t\n-      _M_bucket_index(const _Hash_node<_Value, true>* __p,\n-\t\t      std::size_t __n) const\n+      _M_bucket_index(const __node_type* __p, std::size_t __n) const\n       { return _M_h2()(__p->_M_hash_code, __n); }\n \n       void\n-      _M_store_code(_Hash_node<_Value, true>* __n, _Hash_code_type __c) const\n+      _M_store_code(__node_type* __n, __hash_code __c) const\n       { __n->_M_hash_code = __c; }\n \n       void\n-      _M_copy_code(_Hash_node<_Value, true>* __to,\n-\t\t   const _Hash_node<_Value, true>* __from) const\n+      _M_copy_code(__node_type* __to, const __node_type* __from) const\n       { __to->_M_hash_code = __from->_M_hash_code; }\n \n       void\n@@ -803,105 +1162,69 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstd::swap(_M_h2(), __x._M_h2());\n       }\n \n-    protected:\n       const _ExtractKey&\n       _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+\n       _ExtractKey&\n       _M_extract() { return _EboExtractKey::_S_get(*this); }\n+\n       const _H1&\n       _M_h1() const { return _EboH1::_S_cget(*this); }\n+\n       _H1&\n       _M_h1() { return _EboH1::_S_get(*this); }\n+\n       const _H2&\n       _M_h2() const { return _EboH2::_S_cget(*this); }\n+\n       _H2&\n       _M_h2() { return _EboH2::_S_get(*this); }\n     };\n \n+  /**\n+   *  Primary class template _Equal_helper.\n+   *\n+   */\n   template <typename _Key, typename _Value, typename _ExtractKey,\n \t    typename _Equal, typename _HashCodeType,\n \t    bool __cache_hash_code>\n   struct _Equal_helper;\n \n+  /// Specialization.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _Equal, typename _HashCodeType>\n   struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>\n   {\n     static bool\n     _S_equals(const _Equal& __eq, const _ExtractKey& __extract,\n-\t      const _Key& __k, _HashCodeType __c,\n-\t      _Hash_node<_Value, true>* __n)\n-    { return __c == __n->_M_hash_code\n-\t     && __eq(__k, __extract(__n->_M_v)); }\n+\t      const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)\n+    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v)); }\n   };\n \n+  /// Specialization.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _Equal, typename _HashCodeType>\n   struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>\n   {\n     static bool\n     _S_equals(const _Equal& __eq, const _ExtractKey& __extract,\n-\t      const _Key& __k, _HashCodeType,\n-\t      _Hash_node<_Value, false>* __n)\n+\t      const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)\n     { return __eq(__k, __extract(__n->_M_v)); }\n   };\n \n-  // Helper class adding management of _Equal functor to _Hash_code_base\n-  // type.\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n-\t   bool __cache_hash_code>\n-  struct _Hashtable_base\n-  : public  _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n-\t\t\t    __cache_hash_code>,\n-    private _Hashtable_ebo_helper<0, _Equal>\n-  {\n-  private:\n-    typedef _Hashtable_ebo_helper<0, _Equal> _EboEqual;\n-\n-  protected:\n-    typedef _Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t    _H1, _H2, _Hash, __cache_hash_code> _HCBase;\n-    typedef typename _HCBase::_Hash_code_type _Hash_code_type;\n-\n-    _Hashtable_base(const _ExtractKey& __ex,\n-\t\t    const _H1& __h1, const _H2& __h2,\n-\t\t    const _Hash& __hash, const _Equal& __eq)\n-      : _HCBase(__ex, __h1, __h2, __hash), _EboEqual(__eq) { }\n-\n-    bool\n-    _M_equals(const _Key& __k, _Hash_code_type __c,\n-\t      _Hash_node<_Value, __cache_hash_code>* __n) const\n-    {\n-      typedef _Equal_helper<_Key, _Value, _ExtractKey,\n-\t\t\t   _Equal, _Hash_code_type,\n-\t\t\t   __cache_hash_code> _EqualHelper;\n-      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),\n-\t\t\t\t     __k, __c, __n);\n-    }\n \n-    void\n-    _M_swap(_Hashtable_base& __x)\n-    {\n-      _HCBase::_M_swap(__x);\n-      std::swap(_M_eq(), __x._M_eq());\n-    }\n-\n-  protected:\n-    const _Equal&\n-    _M_eq() const { return _EboEqual::_S_cget(*this); }\n-    _Equal&\n-    _M_eq() { return _EboEqual::_S_get(*this); }\n-  };\n-\n-  // Local iterators, used to iterate within a bucket but not between\n-  // buckets.\n+  /**\n+   *  Primary class template _Local_iterator_base.\n+   *\n+   *  Base class for local iterators, used to iterate within a bucket\n+   *  but not between buckets.\n+   */\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   bool __cache_hash_code>\n     struct _Local_iterator_base;\n \n+  /// Specialization.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash>\n     struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n@@ -933,6 +1256,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::size_t _M_bucket_count;\n     };\n \n+  /// Specialization.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash>\n     struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n@@ -980,6 +1304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t  _H1, _H2, _Hash, __cache>& __y)\n     { return __x._M_cur != __y._M_cur; }\n \n+  /// local iterators\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   bool __constant_iterators, bool __cache>\n@@ -1030,6 +1355,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+  /// local const_iterators\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   bool __constant_iterators, bool __cache>\n@@ -1085,27 +1411,200 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+  /**\n+   *  Primary class template _Hashtable_base.\n+   *\n+   *  Base class for _Hashtable. Helper class adding management of\n+   *  _Equal functor to _Hash_code_base type.\n+   */\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _Traits>\n+  struct _Hashtable_base\n+  : public  _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n+\t\t\t    _Traits::__hash_cached::value>,\n+    private _Hashtable_ebo_helper<0, _Equal>\n+  {\n+  public:\n+    typedef _Key                                    key_type;\n+    typedef _Value                                  value_type;\n+    typedef _Equal                                  key_equal;\n+    typedef std::size_t                             size_type;\n+    typedef std::ptrdiff_t                          difference_type;\n+\n+    using __traits_type = _Traits;\n+    using __hash_cached = typename __traits_type::__hash_cached;\n+    using __constant_iterators = typename __traits_type::__constant_iterators;\n+    using __unique_keys = typename __traits_type::__unique_keys;\n+\n+    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t     _H1, _H2, _Hash,\n+\t\t\t\t\t     __hash_cached::value>;\n+\n+    using __hash_code = typename __hash_code_base::__hash_code;\n+    using __node_type = typename __hash_code_base::__node_type;\n+\n+    using iterator = __detail::_Node_iterator<value_type,\n+\t\t\t\t\t      __constant_iterators::value,\n+\t\t\t\t\t      __hash_cached::value>;\n+\n+    using const_iterator = __detail::_Node_const_iterator<value_type,\n+\t\t\t\t\t\t   __constant_iterators::value,\n+\t\t\t\t\t\t   __hash_cached::value>;\n+\n+    using local_iterator = __detail::_Local_iterator<key_type, value_type,\n+\t\t\t\t\t\t  _ExtractKey, _H1, _H2, _Hash,\n+\t\t\t\t\t\t  __constant_iterators::value,\n+\t\t\t\t\t\t     __hash_cached::value>;\n+\n+    using const_local_iterator = __detail::_Local_const_iterator<key_type,\n+\t\t\t\t\t\t\t\t value_type,\n+\t\t\t\t\t_ExtractKey, _H1, _H2, _Hash,\n+\t\t\t\t\t__constant_iterators::value,\n+\t\t\t\t\t__hash_cached::value>;\n+\n+    using __ireturn_type = typename std::conditional<__unique_keys::value,\n+\t\t\t\t\t\t     std::pair<iterator, bool>,\n+\t\t\t\t\t\t     iterator>::type;\n+\n+    using __iconv_type = typename  std::conditional<__unique_keys::value,\n+\t\t\t\t\t       std::_Select1st<__ireturn_type>,\n+\t\t\t\t\t       std::_Identity<__ireturn_type>\n+\t\t\t\t\t\t    >::type;\n+  private:\n+    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;\n+    using _EqualHelper =  _Equal_helper<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t\t__hash_code, __hash_cached::value>;\n+\n+  protected:\n+    using __node_base = __detail::_Hash_node_base;\n+    using __bucket_type = __node_base*;\n+\n+    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,\n+\t\t    const _Hash& __hash, const _Equal& __eq)\n+    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)\n+    { }\n+\n+    bool\n+    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const\n+    {\n+      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),\n+\t\t\t\t     __k, __c, __n);\n+    }\n+\n+    void\n+    _M_swap(_Hashtable_base& __x)\n+    {\n+      __hash_code_base::_M_swap(__x);\n+      std::swap(_M_eq(), __x._M_eq());\n+    }\n+\n+    const _Equal&\n+    _M_eq() const { return _EqualEBO::_S_cget(*this); }\n+\n+    _Equal&\n+    _M_eq() { return _EqualEBO::_S_get(*this); }\n+  };\n \n-  // Class template _Equality_base.  This is for implementing equality\n-  // comparison for unordered containers, per N3068, by John Lakos and\n-  // Pablo Halpern.  Algorithmically, we follow closely the reference\n-  // implementations therein.\n-  template<typename _ExtractKey, bool __unique_keys,\n-\t   typename _Hashtable>\n-    struct _Equality_base;\n+  /**\n+   *  struct _Equality_base.\n+   *\n+   *  Common types and functions for class _Equality.\n+   */\n+  struct _Equality_base\n+  {\n+  protected:\n+    template<typename _Uiterator>\n+      static bool\n+      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);\n+  };\n \n-  template<typename _ExtractKey, typename _Hashtable>\n-    struct _Equality_base<_ExtractKey, true, _Hashtable>\n+  // See std::is_permutation in N3068.\n+  template<typename _Uiterator>\n+    bool\n+    _Equality_base::\n+    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,\n+\t\t      _Uiterator __first2)\n     {\n-      bool _M_equal(const _Hashtable&) const;\n+      for (; __first1 != __last1; ++__first1, ++__first2)\n+\tif (!(*__first1 == *__first2))\n+\t  break;\n+\n+      if (__first1 == __last1)\n+\treturn true;\n+\n+      _Uiterator __last2 = __first2;\n+      std::advance(__last2, std::distance(__first1, __last1));\n+\n+      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)\n+\t{\n+\t  _Uiterator __tmp =  __first1;\n+\t  while (__tmp != __it1 && !bool(*__tmp == *__it1))\n+\t    ++__tmp;\n+\n+\t  // We've seen this one before.\n+\t  if (__tmp != __it1)\n+\t    continue;\n+\n+\t  std::ptrdiff_t __n2 = 0;\n+\t  for (__tmp = __first2; __tmp != __last2; ++__tmp)\n+\t    if (*__tmp == *__it1)\n+\t      ++__n2;\n+\n+\t  if (!__n2)\n+\t    return false;\n+\n+\t  std::ptrdiff_t __n1 = 0;\n+\t  for (__tmp = __it1; __tmp != __last1; ++__tmp)\n+\t    if (*__tmp == *__it1)\n+\t      ++__n1;\n+\n+\t  if (__n1 != __n2)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  /**\n+   *  Primary class template  _Equality.\n+   *\n+   *  This is for implementing equality comparison for unordered\n+   *  containers, per N3068, by John Lakos and Pablo Halpern.\n+   *  Algorithmically, we follow closely the reference implementations\n+   *  therein.\n+   */\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits,\n+\t   bool _Unique_keys = _Traits::__unique_keys::value>\n+    struct _Equality;\n+\n+  /// Specialization.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+    {\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n+\n+      bool\n+      _M_equal(const __hashtable&) const;\n     };\n \n-  template<typename _ExtractKey, typename _Hashtable>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n     bool\n-    _Equality_base<_ExtractKey, true, _Hashtable>::\n-    _M_equal(const _Hashtable& __other) const\n+    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+    _M_equal(const __hashtable& __other) const\n     {\n-      const _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+      const __hashtable* __this = static_cast<const __hashtable*>(this);\n \n       if (__this->size() != __other.size())\n \treturn false;\n@@ -1119,70 +1618,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n-  template<typename _ExtractKey, typename _Hashtable>\n-    struct _Equality_base<_ExtractKey, false, _Hashtable>\n+  /// Specialization.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>\n+    : public _Equality_base\n     {\n-      bool _M_equal(const _Hashtable&) const;\n-\n-    private:\n-      template<typename _Uiterator>\n-\tstatic bool\n-\t_S_is_permutation(_Uiterator, _Uiterator, _Uiterator);\n-    };\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n \n-  // See std::is_permutation in N3068.\n-  template<typename _ExtractKey, typename _Hashtable>\n-    template<typename _Uiterator>\n       bool\n-      _Equality_base<_ExtractKey, false, _Hashtable>::\n-      _S_is_permutation(_Uiterator __first1, _Uiterator __last1,\n-\t\t\t_Uiterator __first2)\n-      {\n-\tfor (; __first1 != __last1; ++__first1, ++__first2)\n-\t  if (!(*__first1 == *__first2))\n-\t    break;\n-\n-\tif (__first1 == __last1)\n-\t  return true;\n-\n-\t_Uiterator __last2 = __first2;\n-\tstd::advance(__last2, std::distance(__first1, __last1));\n-\n-\tfor (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)\n-\t  {\n-\t    _Uiterator __tmp =  __first1;\n-\t    while (__tmp != __it1 && !bool(*__tmp == *__it1))\n-\t      ++__tmp;\n-\n-\t    // We've seen this one before.\n-\t    if (__tmp != __it1)\n-\t      continue;\n-\n-\t    std::ptrdiff_t __n2 = 0;\n-\t    for (__tmp = __first2; __tmp != __last2; ++__tmp)\n-\t      if (*__tmp == *__it1)\n-\t\t++__n2;\n-\n-\t    if (!__n2)\n-\t      return false;\n-\n-\t    std::ptrdiff_t __n1 = 0;\n-\t    for (__tmp = __it1; __tmp != __last1; ++__tmp)\n-\t      if (*__tmp == *__it1)\n-\t\t++__n1;\n-\n-\t    if (__n1 != __n2)\n-\t      return false;\n-\t  }\n-\treturn true;\n-      }\n+      _M_equal(const __hashtable&) const;\n+    };\n \n-  template<typename _ExtractKey, typename _Hashtable>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n     bool\n-    _Equality_base<_ExtractKey, false, _Hashtable>::\n-    _M_equal(const _Hashtable& __other) const\n+    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::\n+    _M_equal(const __hashtable& __other) const\n     {\n-      const _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+      const __hashtable* __this = static_cast<const __hashtable*>(this);\n \n       if (__this->size() != __other.size())\n \treturn false;\n@@ -1196,8 +1657,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      != std::distance(__yrange.first, __yrange.second))\n \t    return false;\n \n-\t  if (!_S_is_permutation(__xrange.first,\n-\t\t\t\t __xrange.second,\n+\t  if (!_S_is_permutation(__xrange.first, __xrange.second,\n \t\t\t\t __yrange.first))\n \t    return false;\n \n@@ -1206,6 +1666,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n+ //@} hashtable-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail\n } // namespace std"}, {"sha": "dd08b2645c180a26cdab8b967bf683297e0e6c3e", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 70, "deletions": 245, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -1,6 +1,6 @@\n // unordered_map implementation -*- C++ -*-\n \n-// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2010, 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,208 +34,41 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n-  // NB: When we get typedef templates these class definitions\n-  // will be unnecessary.\n-  template<class _Key, class _Tp,\n-\t   class _Hash = hash<_Key>,\n-\t   class _Pred = std::equal_to<_Key>,\n-\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n-\t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Key>, is_empty<_Hash>,\n-\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n-\t\t\t   __detail::__is_noexcept_hash<_Key, _Hash>>>::value>\n-    class __unordered_map\n-    : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n-\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred, \n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, false, true>\n-    {\n-      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n-\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, false, true>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      explicit\n-      __unordered_map(size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(),\n-\t\t      const key_equal& __eql = key_equal(),\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-      { }\n-\n-      template<typename _InputIterator>\n-        __unordered_map(_InputIterator __f, _InputIterator __l, \n-\t\t\tsize_type __n = 0,\n-\t\t\tconst hasher& __hf = hasher(), \n-\t\t\tconst key_equal& __eql = key_equal(), \n-\t\t\tconst allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(),\n-\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-\t{ }\n-\n-      __unordered_map(initializer_list<value_type> __l,\n-\t\t      size_type __n = 0,\n-\t\t      const hasher& __hf = hasher(),\n-\t\t      const key_equal& __eql = key_equal(),\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf,\n-\t      __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-      { }\n-\n-      __unordered_map&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-    };\n-  \n-  template<class _Key, class _Tp,\n-\t   class _Hash = hash<_Key>,\n-\t   class _Pred = std::equal_to<_Key>,\n-\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n-\t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Key>, is_empty<_Hash>,\n-\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n-\t\t\t   __detail::__is_noexcept_hash<_Key, _Hash>>>::value>\n-    class __unordered_multimap\n-    : public _Hashtable<_Key, std::pair<const _Key, _Tp>,\n-\t\t\t_Alloc,\n-\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, false, false>\n-    {\n-      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,\n-\t\t\t _Alloc,\n-\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, false, false>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      \n-      explicit\n-      __unordered_multimap(size_type __n = 10,\n-\t\t\t   const hasher& __hf = hasher(),\n-\t\t\t   const key_equal& __eql = key_equal(),\n-\t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-      { }\n-\n-\n-      template<typename _InputIterator>\n-        __unordered_multimap(_InputIterator __f, _InputIterator __l, \n-\t\t\t     size_type __n = 0,\n-\t\t\t     const hasher& __hf = hasher(), \n-\t\t\t     const key_equal& __eql = key_equal(), \n-\t\t\t     const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(),\n-\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-        { }\n-\n-      __unordered_multimap(initializer_list<value_type> __l,\n-\t\t\t   size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(),\n-\t\t\t   const key_equal& __eql = key_equal(),\n-\t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf,\n-\t      __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n-      { }\n-\n-      __unordered_multimap&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-    };\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_map<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __x,\n-\t __unordered_map<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_multimap<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __x,\n-\t __unordered_multimap<_Key, _Tp, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator==(const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return __x._M_equal(__y); }\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator!=(const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return !(__x == __y); }\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator==(const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return __x._M_equal(__y); }\n-\n-  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator!=(const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return !(__x == __y); }\n+  /// Base types for unordered_map.\n+  template<bool _Cache>\n+    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;\n+\n+  template<typename _Key,\n+\t   typename _Tp,\n+\t   typename _Hash = hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+\t   typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>\n+    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,\n+\t\t\t\t\t_Alloc,\n+\t\t\t\t   std::_Select1st<std::pair<const _Key, _Tp>>,\n+\t\t\t\t       _Pred, _Hash,\n+\t\t\t\t       __detail::_Mod_range_hashing,\n+\t\t\t\t       __detail::_Default_ranged_hash,\n+\t\t\t\t       __detail::_Prime_rehash_policy, _Tr>;\n+\n+  /// Base types for unordered_multimap.\n+  template<bool _Cache>\n+    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;\n+\n+  template<typename _Key,\n+\t   typename _Tp,\n+\t   typename _Hash = hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+\t   typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>\n+    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,\n+\t\t\t\t\t _Alloc,\n+\t\t\t\t  std::_Select1st<std::pair<const _Key, _Tp>>,\n+\t\t\t\t\t _Pred, _Hash,\n+\t\t\t\t\t __detail::_Mod_range_hashing,\n+\t\t\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t\t\t __detail::_Prime_rehash_policy, _Tr>;\n \n   /**\n    *  @brief A standard container composed of unique keys (containing\n@@ -247,22 +80,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n    *  <a href=\"tables.html#xx\">unordered associative container</a>\n    *\n-   *  @param  Key  Type of key objects.\n-   *  @param  Tp  Type of mapped objects.\n-   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n-   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n-   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *  @tparam  _Key  Type of key objects.\n+   *  @tparam  _Tp  Type of mapped objects.\n+   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.\n+   *  @tparam  _Pred  Predicate function object type, defaults\n+   *                  to equal_to<_Value>.\n+   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.\n    *\n-   * The resulting value type of the container is std::pair<const Key, Tp>.\n+   * The resulting value type of the container is std::pair<const _Key, _Tp>.\n+   *\n+   *  Base is _Hashtable, dispatched at compile time via template\n+   *  alias __umap_hashtable.\n    */\n   template<class _Key, class _Tp,\n \t   class _Hash = hash<_Key>,\n \t   class _Pred = std::equal_to<_Key>,\n \t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_map\n-    : public __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n+    : public __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>\n     {\n-      typedef __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n \n     public:\n       typedef typename _Base::value_type      value_type;\n@@ -280,13 +117,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { }\n \n       template<typename _InputIterator>\n-        unordered_map(_InputIterator __f, _InputIterator __l, \n+\tunordered_map(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const hasher& __hf = hasher(),\n+\t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t{ }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n@@ -295,16 +132,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t    const allocator_type& __a = allocator_type())\n       : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n       { }\n-\n-      unordered_map&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n     };\n-  \n+\n   /**\n    *  @brief A standard container composed of equivalent keys\n    *  (possibly containing multiple of each key value) that associates\n@@ -315,30 +144,34 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n    *  <a href=\"tables.html#xx\">unordered associative container</a>\n    *\n-   *  @param  Key  Type of key objects.\n-   *  @param  Tp  Type of mapped objects.\n-   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n-   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n-   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *  @tparam  _Key  Type of key objects.\n+   *  @tparam  _Tp  Type of mapped objects.\n+   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.\n+   *  @tparam  _Pred  Predicate function object type, defaults\n+   *                  to equal_to<_Value>.\n+   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.\n+   *\n+   * The resulting value type of the container is std::pair<const _Key, _Tp>.\n    *\n-   * The resulting value type of the container is std::pair<const Key, Tp>.\n+   *  Base is _Hashtable, dispatched at compile time via template\n+   *  alias __ummap_hashtable.\n    */\n   template<class _Key, class _Tp,\n \t   class _Hash = hash<_Key>,\n \t   class _Pred = std::equal_to<_Key>,\n \t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_multimap\n-    : public __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n+    : public __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>\n     {\n-      typedef __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;\n \n     public:\n       typedef typename _Base::value_type      value_type;\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n       typedef typename _Base::key_equal       key_equal;\n       typedef typename _Base::allocator_type  allocator_type;\n-      \n+\n       explicit\n       unordered_multimap(size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n@@ -348,13 +181,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { }\n \n       template<typename _InputIterator>\n-        unordered_multimap(_InputIterator __f, _InputIterator __l, \n+\tunordered_multimap(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(), \n-\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const hasher& __hf = hasher(),\n+\t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t{ }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n@@ -363,14 +196,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t const allocator_type& __a = allocator_type())\n       : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n       { }\n-\n-      unordered_multimap&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n     };\n \n   template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>"}, {"sha": "bd0deb0717c2cf75d03396a463170cd86018c952", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 63, "deletions": 262, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -1,6 +1,6 @@\n // unordered_set implementation -*- C++ -*-\n \n-// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2010, 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,228 +34,36 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n-  // NB: When we get typedef templates these class definitions\n-  // will be unnecessary.\n-  template<class _Value,\n-\t   class _Hash = hash<_Value>,\n-\t   class _Pred = std::equal_to<_Value>,\n-\t   class _Alloc = std::allocator<_Value>,\n-\t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Value>, is_empty<_Hash>,\n-\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n-\t\t\t   __detail::__is_noexcept_hash<_Value, _Hash>>>::value>\n-    class __unordered_set\n-    : public _Hashtable<_Value, _Value, _Alloc,\n-\t\t\tstd::_Identity<_Value>, _Pred,\n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, true, true>\n-    {\n-      typedef _Hashtable<_Value, _Value, _Alloc,\n-\t\t\t std::_Identity<_Value>, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, true, true>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      typedef typename _Base::iterator        iterator;\n-      typedef typename _Base::const_iterator  const_iterator;\n-\n-      explicit\n-      __unordered_set(size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(),\n-\t\t      const key_equal& __eql = key_equal(),\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(), __eql,\n-\t      std::_Identity<value_type>(), __a)\n-      { }\n-\n-      template<typename _InputIterator>\n-        __unordered_set(_InputIterator __f, _InputIterator __l, \n-\t\t\tsize_type __n = 0,\n-\t\t\tconst hasher& __hf = hasher(), \n-\t\t\tconst key_equal& __eql = key_equal(), \n-\t\t\tconst allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(), __eql,\n-\t\tstd::_Identity<value_type>(), __a)\n-        { }\n-\n-      __unordered_set(initializer_list<value_type> __l,\n-\t\t      size_type __n = 0,\n-\t\t      const hasher& __hf = hasher(),\n-\t\t      const key_equal& __eql = key_equal(),\n-\t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf,\n-\t      __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(), __eql,\n-\t      std::_Identity<value_type>(), __a)\n-      { }\n-\n-      __unordered_set&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-\n-      using _Base::insert;\n-\n-      std::pair<iterator, bool>\n-      insert(value_type&& __v)\n-      { return this->_M_insert(std::move(__v), std::true_type()); }\n-\n-      iterator\n-      insert(const_iterator, value_type&& __v)\n-      { return insert(std::move(__v)).first; }\n-    };\n-\n-  template<class _Value,\n-\t   class _Hash = hash<_Value>,\n-\t   class _Pred = std::equal_to<_Value>,\n-\t   class _Alloc = std::allocator<_Value>,\n-\t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Value>, is_empty<_Hash>,\n-\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n-\t\t\t   __detail::__is_noexcept_hash<_Value, _Hash>>>::value>\n-    class __unordered_multiset\n-    : public _Hashtable<_Value, _Value, _Alloc,\n-\t\t\tstd::_Identity<_Value>, _Pred,\n-\t\t\t_Hash, __detail::_Mod_range_hashing,\n-\t\t\t__detail::_Default_ranged_hash,\n-\t\t\t__detail::_Prime_rehash_policy,\n-\t\t\t__cache_hash_code, true, false>\n-    {\n-      typedef _Hashtable<_Value, _Value, _Alloc,\n-\t\t\t std::_Identity<_Value>, _Pred,\n-\t\t\t _Hash, __detail::_Mod_range_hashing,\n-\t\t\t __detail::_Default_ranged_hash,\n-\t\t\t __detail::_Prime_rehash_policy,\n-\t\t\t __cache_hash_code, true, false>\n-        _Base;\n-\n-    public:\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      typedef typename _Base::iterator        iterator;\n-      typedef typename _Base::const_iterator  const_iterator;\n-\n-      explicit\n-      __unordered_multiset(size_type __n = 10,\n-\t\t\t   const hasher& __hf = hasher(),\n-\t\t\t   const key_equal& __eql = key_equal(),\n-\t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(), __eql,\n-\t      std::_Identity<value_type>(), __a)\n-      { }\n-\n-\n-      template<typename _InputIterator>\n-        __unordered_multiset(_InputIterator __f, _InputIterator __l, \n-\t\t\t     size_type __n = 0,\n-\t\t\t     const hasher& __hf = hasher(), \n-\t\t\t     const key_equal& __eql = key_equal(), \n-\t\t\t     const allocator_type& __a = allocator_type())\n-\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n-\t\t__detail::_Default_ranged_hash(), __eql,\n-\t\tstd::_Identity<value_type>(), __a)\n-        { }\n-\n-      __unordered_multiset(initializer_list<value_type> __l,\n-\t\t\t   size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(),\n-\t\t\t   const key_equal& __eql = key_equal(),\n-\t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__l.begin(), __l.end(), __n, __hf,\n-\t      __detail::_Mod_range_hashing(),\n-\t      __detail::_Default_ranged_hash(), __eql,\n-\t      std::_Identity<value_type>(), __a)\n-      { }\n-\n-      __unordered_multiset&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n-\n-      using _Base::insert;\n-\n-      iterator\n-      insert(value_type&& __v)\n-      { return this->_M_insert(std::move(__v), std::false_type()); }\n-\n-      iterator\n-      insert(const_iterator, value_type&& __v)\n-      { return insert(std::move(__v)); }\n-    };\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_set<_Value, _Hash, _Pred, _Alloc, __cache_hash_code>& __x,\n-\t __unordered_set<_Value, _Hash, _Pred, _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline void\n-    swap(__unordered_multiset<_Value, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __x,\n-\t __unordered_multiset<_Value, _Hash, _Pred,\n-\t _Alloc, __cache_hash_code>& __y)\n-    { __x.swap(__y); }\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator==(const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return __x._M_equal(__y); }\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator!=(const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return !(__x == __y); }\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator==(const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return __x._M_equal(__y); }\n-\n-  template<class _Value, class _Hash, class _Pred, class _Alloc,\n-\t   bool __cache_hash_code>\n-    inline bool\n-    operator!=(const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __x,\n-\t       const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n-\t       __cache_hash_code>& __y)\n-    { return !(__x == __y); }\n+  /// Base types for unordered_set.\n+  template<bool _Cache>\n+    using __uset_traits = __detail::_Hashtable_traits<_Cache, true, true>;\n+\n+  template<typename _Value,\n+\t   typename _Hash = hash<_Value>,\n+\t   typename _Pred = std::equal_to<_Value>,\n+  \t   typename _Alloc = std::allocator<_Value>,\n+\t   typename _Tr = __uset_traits<__cache_default<_Value, _Hash>::value>>\n+    using __uset_hashtable = _Hashtable<_Value, _Value, _Alloc,\n+\t\t\t\t\tstd::_Identity<_Value>, _Pred, _Hash,\n+\t\t\t\t\t__detail::_Mod_range_hashing,\n+\t\t\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t\t\t__detail::_Prime_rehash_policy, _Tr>;\n+\n+  /// Base types for unordered_multiset.\n+  template<bool _Cache>\n+    using __umset_traits = __detail::_Hashtable_traits<_Cache, true, false>;\n+\n+  template<typename _Value,\n+\t   typename _Hash = hash<_Value>,\n+\t   typename _Pred = std::equal_to<_Value>,\n+\t   typename _Alloc = std::allocator<_Value>,\n+\t   typename _Tr = __umset_traits<__cache_default<_Value, _Hash>::value>>\n+    using __umset_hashtable = _Hashtable<_Value, _Value, _Alloc,\n+\t\t\t\t\t std::_Identity<_Value>,\n+\t\t\t\t\t _Pred, _Hash,\n+\t\t\t\t\t __detail::_Mod_range_hashing,\n+\t\t\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t\t\t __detail::_Prime_rehash_policy, _Tr>;\n \n   /**\n    *  @brief A standard container composed of unique keys (containing\n@@ -267,27 +75,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n    *  <a href=\"tables.html#xx\">unordered associative container</a>\n    *\n-   *  @param  Value  Type of key objects.\n-   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n-   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n-   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *  @tparam  _Value  Type of key objects.\n+   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.\n+\n+   *  @tparam _Pred Predicate function object type, defaults to\n+   *                equal_to<_Value>.\n+   *\n+   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.\n+   *\n+   *  Base is _Hashtable, dispatched at compile time via template\n+   *  alias __uset_hashtable.\n    */\n   template<class _Value,\n \t   class _Hash = hash<_Value>,\n \t   class _Pred = std::equal_to<_Value>,\n \t   class _Alloc = std::allocator<_Value> >\n     class unordered_set\n-    : public __unordered_set<_Value, _Hash, _Pred, _Alloc>\n+    : public __uset_hashtable<_Value, _Hash, _Pred, _Alloc>\n     {\n-      typedef __unordered_set<_Value, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __uset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Base;\n \n     public:\n       typedef typename _Base::value_type      value_type;\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n       typedef typename _Base::key_equal       key_equal;\n       typedef typename _Base::allocator_type  allocator_type;\n-      \n+\n       explicit\n       unordered_set(size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n@@ -297,13 +111,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { }\n \n       template<typename _InputIterator>\n-        unordered_set(_InputIterator __f, _InputIterator __l, \n+\tunordered_set(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const hasher& __hf = hasher(),\n+\t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t{ }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n@@ -312,14 +126,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t    const allocator_type& __a = allocator_type())\n       : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n       { }\n-\n-      unordered_set&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n     };\n \n   /**\n@@ -332,27 +138,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, and\n    *  <a href=\"tables.html#xx\">unordered associative container</a>\n    *\n-   *  @param  Value  Type of key objects.\n-   *  @param  Hash  Hashing function object type, defaults to hash<Value>.\n-   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.\n-   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *  @tparam  _Value  Type of key objects.\n+   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.\n+   *  @tparam  _Pred  Predicate function object type, defaults\n+   *                  to equal_to<_Value>.\n+   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.\n+   *\n+   *  Base is _Hashtable, dispatched at compile time via template\n+   *  alias __umset_hashtable.\n    */\n   template<class _Value,\n \t   class _Hash = hash<_Value>,\n \t   class _Pred = std::equal_to<_Value>,\n \t   class _Alloc = std::allocator<_Value> >\n     class unordered_multiset\n-    : public __unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n+    : public __umset_hashtable<_Value, _Hash, _Pred, _Alloc>\n     {\n-      typedef __unordered_multiset<_Value, _Hash, _Pred, _Alloc>  _Base;\n+      typedef __umset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Base;\n \n     public:\n       typedef typename _Base::value_type      value_type;\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n       typedef typename _Base::key_equal       key_equal;\n       typedef typename _Base::allocator_type  allocator_type;\n-      \n+\n       explicit\n       unordered_multiset(size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n@@ -363,13 +173,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n \n       template<typename _InputIterator>\n-        unordered_multiset(_InputIterator __f, _InputIterator __l, \n+\tunordered_multiset(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n-\t\t\t   const hasher& __hf = hasher(), \n-\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const hasher& __hf = hasher(),\n+\t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t{ }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n@@ -378,14 +188,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t const allocator_type& __a = allocator_type())\n       : _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)\n       { }\n-\n-      unordered_multiset&\n-      operator=(initializer_list<value_type> __l)\n-      {\n-\tthis->clear();\n-\tthis->insert(__l.begin(), __l.end());\n-\treturn *this;\n-      }\n     };\n \n   template<class _Value, class _Hash, class _Pred, class _Alloc>\n@@ -428,4 +230,3 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n } // namespace std\n \n #endif /* _UNORDERED_SET_H */\n-"}, {"sha": "4520f32ac13522b7ca1312635e07f4cc56f3732f", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -611,7 +611,7 @@ def display_hint (self):\n class Tr1HashtableIterator:\n     def __init__ (self, hash):\n         self.node = hash['_M_before_begin']['_M_nxt']\n-        self.node_type = find_type(hash.type, '_Node').pointer()\n+        self.node_type = find_type(hash.type, '__node_type').pointer()\n \n     def __iter__ (self):\n         return self"}, {"sha": "ac304776cadc3444af820831e4aa3610c49ebf76", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dad8b49ee0f90c4960e86dedc9337c6d1be01db/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=4dad8b49ee0f90c4960e86dedc9337c6d1be01db", "patch": "@@ -2,7 +2,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-require-normal-mode \"\" }\n \n-// Copyright (C) 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 185 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 248 }\n \n #include <unordered_set>\n \n@@ -35,7 +35,10 @@ namespace\n void\n test01()\n {\n-  std::__unordered_set<int, hash_without_noexcept,\n-\t\t       std::equal_to<int>, std::allocator<int>,\n-\t\t       false> us;\n+  using traits = std::__detail::_Hashtable_traits<false, true, true>;\n+  using hashtable = std::__uset_hashtable<int, hash_without_noexcept,\n+\t\t\t\t\t  std::equal_to<int>,\n+\t\t\t\t\t  std::allocator<int>, traits>;\n+\n+  hashtable ht;\n }"}]}