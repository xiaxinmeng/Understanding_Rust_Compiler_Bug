{"sha": "c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFmZDg3NTNjNWViZTM0Mjc3ZmE3ZTc1ZTRlOTJjMWU4YmMwODI3Nw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-05-03T16:34:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-05-03T16:34:20Z"}, "message": "trans.c (gigi): Call build_function_type_list instead of build_function_type.\n\n\t* gcc-interface/trans.c (gigi): Call build_function_type_list instead\n\tof build_function_type.  Adjust calls to...\n\t(build_raise_check): ...this.  Do not take a void_tree parameter.\n\tCall build_function_type_list instead of build_function_type.\n\tFix head comment and swap couple of conditional blocks.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@adacore.com>\n\nFrom-SVN: r173325", "tree": {"sha": "6964f59c886278b30b9d8b82290cdfa0e10e5b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6964f59c886278b30b9d8b82290cdfa0e10e5b1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277/comments", "author": null, "committer": null, "parents": [{"sha": "f0b568f3c4108c65eeb0123e2d64988b172f9e75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b568f3c4108c65eeb0123e2d64988b172f9e75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0b568f3c4108c65eeb0123e2d64988b172f9e75"}], "stats": {"total": 160, "additions": 73, "deletions": 87}, "files": [{"sha": "b78355d0556bd243b985ae4a83af20e510abaf1e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277", "patch": "@@ -1,3 +1,12 @@\n+2011-05-03  Nathan Froyd  <froydnj@codesourcery.com>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gigi): Call build_function_type_list instead\n+\tof build_function_type.  Adjust calls to...\n+\t(build_raise_check): ...this.  Do not take a void_tree parameter.\n+\tCall build_function_type_list instead of build_function_type.\n+\tFix head comment and swap couple of conditional blocks.\n+\n 2011-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnatvsn.ads (Library_Version): Bump to 4.7."}, {"sha": "9e3d2e240d10ae703f3635a195c9953a44cf75a6", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 64, "deletions": 87, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=c1fd8753c5ebe34277fa7e75e4e92c1e8bc08277", "patch": "@@ -214,7 +214,7 @@ static void set_expr_location_from_node (tree, Node_Id);\n static bool set_end_locus_from_node (tree, Node_Id);\n static void set_gnu_expr_location_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, bool, bool, bool);\n-static tree build_raise_check (int, tree, enum exception_info_kind);\n+static tree build_raise_check (int, enum exception_info_kind);\n \n /* Hooks for debug info back-ends, only supported and used in a restricted set\n    of configurations.  */\n@@ -236,7 +236,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       Entity_Id standard_exception_type, Int gigi_operating_mode)\n {\n   Entity_Id gnat_literal;\n-  tree long_long_float_type, exception_type, t;\n+  tree long_long_float_type, exception_type, t, ftype;\n   tree int64_type = gnat_type_for_size (64, 0);\n   struct elab_info *info;\n   int i;\n@@ -344,39 +344,34 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   DECL_IGNORED_P (t) = 1;\n   save_gnu_tree (gnat_literal, t, false);\n \n-  void_ftype = build_function_type (void_type_node, NULL_TREE);\n+  void_ftype = build_function_type_list (void_type_node, NULL_TREE);\n   ptr_void_ftype = build_pointer_type (void_ftype);\n \n   /* Now declare run-time functions.  */\n-  t = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+  ftype = build_function_type_list (ptr_void_type_node, sizetype, NULL_TREE);\n \n   /* malloc is a function declaration tree for a function to allocate\n      memory.  */\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n-\t\t\t   build_function_type (ptr_void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   sizetype, t)),\n-\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n   /* malloc32 is a function declaration tree for a function to allocate\n      32-bit memory on a 64-bit system.  Needed only on 64-bit VMS.  */\n   malloc32_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc32\"), NULL_TREE,\n-\t\t\t   build_function_type (ptr_void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   sizetype, t)),\n-\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IS_MALLOC (malloc32_decl) = 1;\n \n   /* free is a function declaration tree for a function to free memory.  */\n   free_decl\n     = create_subprog_decl (get_identifier (\"__gnat_free\"), NULL_TREE,\n-\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t\t   t)),\n+\t\t\t   build_function_type_list (void_type_node,\n+\t\t\t\t\t\t     ptr_void_type_node,\n+\t\t\t\t\t\t     NULL_TREE),\n \t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n@@ -403,27 +398,26 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   /* Functions to get and set the jumpbuf pointer for the current thread.  */\n   get_jmpbuf_decl\n     = create_subprog_decl\n-    (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n-     NULL_TREE, build_function_type (jmpbuf_ptr_type, NULL_TREE),\n-     NULL_TREE, false, true, true, true, NULL, Empty);\n+      (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n+       NULL_TREE, build_function_type_list (jmpbuf_ptr_type, NULL_TREE),\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (get_jmpbuf_decl) = 1;\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n-    (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n-     NULL_TREE,\n-     build_function_type (void_type_node,\n-\t\t\t  tree_cons (NULL_TREE, jmpbuf_ptr_type, t)),\n-     NULL_TREE, false, true, true, true, NULL, Empty);\n+      (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n+       NULL_TREE, build_function_type_list (void_type_node, jmpbuf_ptr_type,\n+\t\t\t\t\t    NULL_TREE),\n+       NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (set_jmpbuf_decl) = 1;\n \n   /* setjmp returns an integer and has one operand, which is a pointer to\n      a jmpbuf.  */\n   setjmp_decl\n     = create_subprog_decl\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n-       build_function_type (integer_type_node,\n-\t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, t)),\n+       build_function_type_list (integer_type_node, jmpbuf_ptr_type,\n+\t\t\t\t NULL_TREE),\n        NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n@@ -433,29 +427,25 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   update_setjmp_buf_decl\n     = create_subprog_decl\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n-       build_function_type (void_type_node,\n-\t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, t)),\n+       build_function_type_list (void_type_node, jmpbuf_ptr_type, NULL_TREE),\n        NULL_TREE, false, true, true, true, NULL, Empty);\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n   /* Hooks to call when entering/leaving an exception handler.  */\n+  ftype\n+    = build_function_type_list (void_type_node, ptr_void_type_node, NULL_TREE);\n+\n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n-\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t\t   t)),\n-\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IGNORED_P (begin_handler_decl) = 1;\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n-\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t\t   t)),\n-\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n+\t\t\t   Empty);\n   DECL_IGNORED_P (end_handler_decl) = 1;\n \n   /* If in no exception handlers mode, all raise statements are redirected to\n@@ -466,13 +456,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       tree decl\n \t= create_subprog_decl\n \t  (get_identifier (\"__gnat_last_chance_handler\"), NULL_TREE,\n-\t   build_function_type (void_type_node,\n-\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t   build_pointer_type\n-\t\t\t\t\t   (unsigned_char_type_node),\n-\t\t\t\t\t   tree_cons (NULL_TREE,\n-\t\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t\t      t))),\n+\t   build_function_type_list (void_type_node,\n+\t\t\t\t     build_pointer_type\n+\t\t\t\t     (unsigned_char_type_node),\n+\t\t\t\t     integer_type_node, NULL_TREE),\n \t   NULL_TREE, false, true, true, true, NULL, Empty);\n       TREE_THIS_VOLATILE (decl) = 1;\n       TREE_SIDE_EFFECTS (decl) = 1;\n@@ -485,10 +472,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     {\n       /* Otherwise, make one decl for each exception reason.  */\n       for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls); i++)\n-\tgnat_raise_decls[i] = build_raise_check (i, t, exception_simple);\n+\tgnat_raise_decls[i] = build_raise_check (i, exception_simple);\n       for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls_ext); i++)\n \tgnat_raise_decls_ext[i]\n-\t  = build_raise_check (i, t,\n+\t  = build_raise_check (i,\n \t\t\t       i == CE_Index_Check_Failed\n \t\t\t       || i == CE_Range_Check_Failed\n \t\t\t       || i == CE_Invalid_Data\n@@ -503,21 +490,20 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   /* Make other functions used for exception processing.  */\n   get_excptr_decl\n     = create_subprog_decl\n-    (get_identifier (\"system__soft_links__get_gnat_exception\"),\n-     NULL_TREE,\n-     build_function_type (build_pointer_type (except_type_node), NULL_TREE),\n+      (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n+       build_function_type_list (build_pointer_type (except_type_node),\n+\t\t\t\t NULL_TREE),\n      NULL_TREE, false, true, true, true, NULL, Empty);\n \n   raise_nodefer_decl\n     = create_subprog_decl\n       (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n-       build_function_type (void_type_node,\n-\t\t\t    tree_cons (NULL_TREE,\n-\t\t\t\t       build_pointer_type (except_type_node),\n-\t\t\t\t       t)),\n+       build_function_type_list (void_type_node,\n+\t\t\t\t build_pointer_type (except_type_node),\n+\t\t\t\t NULL_TREE),\n        NULL_TREE, false, true, true, true, NULL, Empty);\n \n-  /* Indicate that these never return.  */\n+  /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n   TREE_SIDE_EFFECTS (raise_nodefer_decl) = 1;\n   TREE_TYPE (raise_nodefer_decl)\n@@ -638,49 +624,40 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n }\n \f\n /* Return a subprogram decl corresponding to __gnat_rcheck_xx for the given\n-   CHECK (if EXTENDED is false), or __gnat_rcheck_xx_ext (if EXTENDED is\n-   true).  */\n+   CHECK if KIND is EXCEPTION_SIMPLE, or else to __gnat_rcheck_xx_ext.  */\n \n static tree\n-build_raise_check (int check, tree void_tree, enum exception_info_kind kind)\n+build_raise_check (int check, enum exception_info_kind kind)\n {\n   char name[21];\n-  tree result;\n+  tree result, ftype;\n \n-  if (kind != exception_simple)\n+  if (kind == exception_simple)\n     {\n-      sprintf (name, \"__gnat_rcheck_%.2d_ext\", check);\n-      result\n-\t= create_subprog_decl\n-\t  (get_identifier (name), NULL_TREE,\n-\t   build_function_type\n-\t   (void_type_node,\n-\t    tree_cons\n-\t    (NULL_TREE, build_pointer_type (unsigned_char_type_node),\n-\t     tree_cons (NULL_TREE, integer_type_node,\n-\t\t\ttree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t   kind == exception_column\n-\t\t\t\t   ? void_tree\n-\t\t\t\t   : tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   integer_type_node,\n-\t\t\t\t\t\t\t   void_tree)))))),\n-\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+      sprintf (name, \"__gnat_rcheck_%.2d\", check);\n+      ftype\n+\t= build_function_type_list (void_type_node,\n+\t\t\t\t    build_pointer_type\n+\t\t\t\t    (unsigned_char_type_node),\n+\t\t\t\t    integer_type_node, NULL_TREE);\n     }\n   else\n     {\n-      sprintf (name, \"__gnat_rcheck_%.2d\", check);\n-      result\n-\t= create_subprog_decl\n-\t  (get_identifier (name), NULL_TREE,\n-\t   build_function_type\n-\t   (void_type_node,\n-\t    tree_cons\n-\t    (NULL_TREE, build_pointer_type (unsigned_char_type_node),\n-\t     tree_cons (NULL_TREE, integer_type_node, void_tree))),\n-\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+      tree t = (kind == exception_column ? NULL_TREE : integer_type_node);\n+      sprintf (name, \"__gnat_rcheck_%.2d_ext\", check);\n+      ftype\n+\t= build_function_type_list (void_type_node,\n+\t\t\t\t    build_pointer_type\n+\t\t\t\t    (unsigned_char_type_node),\n+\t\t\t\t    integer_type_node, integer_type_node,\n+\t\t\t\t    t, t, NULL_TREE);\n     }\n \n+  result\n+    = create_subprog_decl (get_identifier (name), NULL_TREE, ftype, NULL_TREE,\n+\t\t\t   false, true, true, true, NULL, Empty);\n+\n+  /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (result) = 1;\n   TREE_SIDE_EFFECTS (result) = 1;\n   TREE_TYPE (result)"}]}