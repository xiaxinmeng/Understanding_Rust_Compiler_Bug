{"sha": "08f835dc74bccf078cb1cad4f3e20dda6d457d74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhmODM1ZGM3NGJjY2YwNzhjYjFjYWQ0ZjNlMjBkZGE2ZDQ1N2Q3NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-01T17:47:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-01T17:47:21Z"}, "message": "Makefile.in: Add ipa-profile.o\n\n\t* Makefile.in: Add ipa-profile.o\n\t(ipa.o, ipa-devrit.o, ipa-inline-analysis.o): Adjust dependencies.\n\t* cgraph.c (struct cgraph_propagate_frequency_data,\n\tcgraph_propagate_frequency_1, cgraph_propagate_frequency): Move to\n\tipa-profile.c; replace cgraph_ by ipa_ prefix.\n\t* cgraph.h (cgraph_propagate_frequency): Remove.\n\t* ipa-inline-analysis.c: Include ipa-utils.h; drop duplicated cfgloop.h.\n\t(inline_update_callee_summaries): Update.\n\t* ipa-profile.c: New file.\n\t* ipa-utils.h (ipa_propagate_frequency): Declare.\n\t* ipa.c: Do not include pointer-set.h, hash-table.h, lto-streamer.h,\n\tdata-streamer.h, value-prof.h\n\t(symtab_remove_unreachable_nodes): Update profile.\n\t(struct histogram_entry, histogram, histogram_pool, histogram_hash,\n\taccount_time_size, cmp_counts, dump_histogram,\n\tipa_profile_generate_summary, ipa_profile_write_summary,\n\tipa_profile_read_summary, ipa_profile, gate_ipa_profile,\n\tpass_data_ipa_profile, pass_ipa_profile, make_pass_ipa_profile):\n\tMove to ipa-profile.c\n\nFrom-SVN: r202154", "tree": {"sha": "e2e4f83196fb64438ea666e999658cda183b0cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e4f83196fb64438ea666e999658cda183b0cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08f835dc74bccf078cb1cad4f3e20dda6d457d74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f835dc74bccf078cb1cad4f3e20dda6d457d74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08f835dc74bccf078cb1cad4f3e20dda6d457d74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f835dc74bccf078cb1cad4f3e20dda6d457d74/comments", "author": null, "committer": null, "parents": [{"sha": "0adad9c5b470715ead5e012b9114cc87198531fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0adad9c5b470715ead5e012b9114cc87198531fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0adad9c5b470715ead5e012b9114cc87198531fd"}], "stats": {"total": 1343, "additions": 704, "deletions": 639}, "files": [{"sha": "a4954b360e6a1d654207867e7e4aebb49cbac6da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -1,3 +1,25 @@\n+2013-09-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in: Add ipa-profile.o\n+\t(ipa.o, ipa-devrit.o, ipa-inline-analysis.o): Adjust dependencies.\n+\t* cgraph.c (struct cgraph_propagate_frequency_data,\n+\tcgraph_propagate_frequency_1, cgraph_propagate_frequency): Move to\n+\tipa-profile.c; replace cgraph_ by ipa_ prefix.\n+\t* cgraph.h (cgraph_propagate_frequency): Remove.\n+\t* ipa-inline-analysis.c: Include ipa-utils.h; drop duplicated cfgloop.h.\n+\t(inline_update_callee_summaries): Update.\n+\t* ipa-profile.c: New file.\n+\t* ipa-utils.h (ipa_propagate_frequency): Declare.\n+\t* ipa.c: Do not include pointer-set.h, hash-table.h, lto-streamer.h,\n+\tdata-streamer.h, value-prof.h\n+\t(symtab_remove_unreachable_nodes): Update profile.\n+\t(struct histogram_entry, histogram, histogram_pool, histogram_hash,\n+\taccount_time_size, cmp_counts, dump_histogram,\n+\tipa_profile_generate_summary, ipa_profile_write_summary,\n+\tipa_profile_read_summary, ipa_profile, gate_ipa_profile,\n+\tpass_data_ipa_profile, pass_ipa_profile, make_pass_ipa_profile):\n+\tMove to ipa-profile.c\n+\n 2013-09-01  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa.md: Allow \"const 0\" operand 1 in \"scc\" insns."}, {"sha": "a07924bb2176797e5e8b05ea1f4dc98b602db0fa", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -1280,6 +1280,7 @@ OBJS = \\\n \tipa-inline.o \\\n \tipa-inline-analysis.o \\\n \tipa-inline-transform.o \\\n+\tipa-profile.o \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n \tipa-reference.o \\\n@@ -2952,11 +2953,15 @@ varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_FLOW_H) \n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \\\n-   $(IPA_UTILS_H) tree-inline.h $(HASH_TABLE_H) profile.h $(PARAMS_H) \\\n-   $(LTO_STREAMER_H) $(DATA_STREAMER_H)\n+   $(IPA_UTILS_H) tree-inline.h profile.h $(PARAMS_H) \n+ipa-profile.o : ipa-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n+   $(TREE_PASS_H) $(GIMPLE_H) $(TARGET_H) $(GGC_H)  \\\n+   $(IPA_UTILS_H) $(HASH_TABLE_H) profile.h $(PARAMS_H) \\\n+   value-prof.h alloc-pool.h tree-inline.h $(LTO_STREAMER_H) $(DATA_STREAMER_H) \\\n+   ipa-inline.h\n ipa-devirt.o : ipa-devirt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \\\n-   $(IPA_UTILS_H) $(HASH_TABLE_H) \n+   $(IPA_UTILS_H) $(HASH_TABLE_H) ipa-inline.h ipa-utils.h $(TREE_PRETTY_PRINT_H)\n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\\n@@ -2986,7 +2991,8 @@ ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.\n    $(DIAGNOSTIC_H) $(PARAMS_H) $(TREE_PASS_H) $(CFGLOOP_H) \\\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(LTO_STREAMER_H) $(DATA_STREAMER_H) \\\n-   $(TREE_STREAMER_H)\n+   $(TREE_STREAMER_H) ipa-utils.h tree-scalar-evolution.h $(CFGLOOP_H) \\\n+   alloc-pool.h\n ipa-inline-transform.o : ipa-inline-transform.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(TREE_PASS_H) \\"}, {"sha": "5fc87ae339d9434feff2df774fba6f1b3518ed1a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -2279,131 +2279,6 @@ cgraph_set_pure_flag (struct cgraph_node *node, bool pure, bool looping)\n \t\t\t\t      false);\n }\n \n-/* Data used by cgraph_propagate_frequency.  */\n-\n-struct cgraph_propagate_frequency_data\n-{\n-  bool maybe_unlikely_executed;\n-  bool maybe_executed_once;\n-  bool only_called_at_startup;\n-  bool only_called_at_exit;\n-};\n-\n-/* Worker for cgraph_propagate_frequency_1.  */\n-\n-static bool\n-cgraph_propagate_frequency_1 (struct cgraph_node *node, void *data)\n-{\n-  struct cgraph_propagate_frequency_data *d;\n-  struct cgraph_edge *edge;\n-\n-  d = (struct cgraph_propagate_frequency_data *)data;\n-  for (edge = node->callers;\n-       edge && (d->maybe_unlikely_executed || d->maybe_executed_once\n-\t        || d->only_called_at_startup || d->only_called_at_exit);\n-       edge = edge->next_caller)\n-    {\n-      if (edge->caller != node)\n-\t{\n-          d->only_called_at_startup &= edge->caller->only_called_at_startup;\n-\t  /* It makes sense to put main() together with the static constructors.\n-\t     It will be executed for sure, but rest of functions called from\n-\t     main are definitely not at startup only.  */\n-\t  if (MAIN_NAME_P (DECL_NAME (edge->caller->symbol.decl)))\n-\t    d->only_called_at_startup = 0;\n-          d->only_called_at_exit &= edge->caller->only_called_at_exit;\n-\t}\n-      if (!edge->frequency)\n-\tcontinue;\n-      switch (edge->caller->frequency)\n-        {\n-\tcase NODE_FREQUENCY_UNLIKELY_EXECUTED:\n-\t  break;\n-\tcase NODE_FREQUENCY_EXECUTED_ONCE:\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n-\t\t     cgraph_node_name (edge->caller));\n-\t  d->maybe_unlikely_executed = false;\n-\t  if (inline_edge_summary (edge)->loop_depth)\n-\t    {\n-\t      d->maybe_executed_once = false;\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"  Called in loop\\n\");\n-\t    }\n-\t  break;\n-\tcase NODE_FREQUENCY_HOT:\n-\tcase NODE_FREQUENCY_NORMAL:\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  Called by %s that is normal or hot\\n\",\n-\t\t     cgraph_node_name (edge->caller));\n-\t  d->maybe_unlikely_executed = false;\n-\t  d->maybe_executed_once = false;\n-\t  break;\n-\t}\n-    }\n-  return edge != NULL;\n-}\n-\n-/* See if the frequency of NODE can be updated based on frequencies of its\n-   callers.  */\n-bool\n-cgraph_propagate_frequency (struct cgraph_node *node)\n-{\n-  struct cgraph_propagate_frequency_data d = {true, true, true, true};\n-  bool changed = false;\n-\n-  /* We can not propagate anything useful about externally visible functions\n-     nor about virtuals.  */\n-  if (!node->local.local\n-      || (flag_devirtualize && DECL_VIRTUAL_P (node->symbol.decl)))\n-    return false;\n-  gcc_assert (node->symbol.analyzed);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n-\n-  cgraph_for_node_and_aliases (node, cgraph_propagate_frequency_1, &d, true);\n-\n-  if ((d.only_called_at_startup && !d.only_called_at_exit)\n-      && !node->only_called_at_startup)\n-    {\n-       node->only_called_at_startup = true;\n-       if (dump_file)\n-         fprintf (dump_file, \"Node %s promoted to only called at startup.\\n\",\n-\t\t  cgraph_node_name (node));\n-       changed = true;\n-    }\n-  if ((d.only_called_at_exit && !d.only_called_at_startup)\n-      && !node->only_called_at_exit)\n-    {\n-       node->only_called_at_exit = true;\n-       if (dump_file)\n-         fprintf (dump_file, \"Node %s promoted to only called at exit.\\n\",\n-\t\t  cgraph_node_name (node));\n-       changed = true;\n-    }\n-  /* These come either from profile or user hints; never update them.  */\n-  if (node->frequency == NODE_FREQUENCY_HOT\n-      || node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n-    return changed;\n-  if (d.maybe_unlikely_executed)\n-    {\n-      node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n-      if (dump_file)\n-\tfprintf (dump_file, \"Node %s promoted to unlikely executed.\\n\",\n-\t\t cgraph_node_name (node));\n-      changed = true;\n-    }\n-  else if (d.maybe_executed_once && node->frequency != NODE_FREQUENCY_EXECUTED_ONCE)\n-    {\n-      node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n-      if (dump_file)\n-\tfprintf (dump_file, \"Node %s promoted to executed once.\\n\",\n-\t\t cgraph_node_name (node));\n-      changed = true;\n-    }\n-  return changed;\n-}\n-\n /* Return true when NODE can not return or throw and thus\n    it is safe to ignore its side effects for IPA analysis.  */\n "}, {"sha": "ea8a04dbd199dc1674c224ee242e86f2a7bc1c9e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -722,7 +722,6 @@ void cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *);\n struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_hook, void *);\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n-bool cgraph_propagate_frequency (struct cgraph_node *node);\n struct cgraph_node * cgraph_function_node (struct cgraph_node *,\n \t\t\t\t\t   enum availability *avail = NULL);\n bool cgraph_get_body (struct cgraph_node *node);"}, {"sha": "fb0c8382020def35538ff3a4662345d9ba887835", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -87,8 +87,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"alloc-pool.h\"\n #include \"cfgloop.h\"\n-#include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"ipa-utils.h\"\n \n /* Estimate runtime of function can easilly run into huge numbers with many\n    nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE * 2 in an\n@@ -3102,7 +3102,7 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n     + callee_info->estimated_self_stack_size;\n   if (inline_summary (node->global.inlined_to)->estimated_stack_size < peak)\n       inline_summary (node->global.inlined_to)->estimated_stack_size = peak;\n-  cgraph_propagate_frequency (node);\n+  ipa_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       if (!e->inline_failed)"}, {"sha": "cb42c8f0f4593367427a03b3d73e96d9e08f1730", "filename": "gcc/ipa-profile.c", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -0,0 +1,666 @@\n+/* Basic IPA optimizations based on profile.\n+   Copyright (C) 2003-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple.h\"\n+#include \"ggc.h\"\n+#include \"flags.h\"\n+#include \"target.h\"\n+#include \"tree-iterator.h\"\n+#include \"ipa-utils.h\"\n+#include \"hash-table.h\"\n+#include \"profile.h\"\n+#include \"params.h\"\n+#include \"value-prof.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-inline.h\"\n+#include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"ipa-inline.h\"\n+\n+/* Entry in the histogram.  */\n+\n+struct histogram_entry\n+{\n+  gcov_type count;\n+  int time;\n+  int size;\n+};\n+\n+/* Histogram of profile values.\n+   The histogram is represented as an ordered vector of entries allocated via\n+   histogram_pool. During construction a separate hashtable is kept to lookup\n+   duplicate entries.  */\n+\n+vec<histogram_entry *> histogram;\n+static alloc_pool histogram_pool;\n+\n+/* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */\n+\n+struct histogram_hash : typed_noop_remove <histogram_entry>\n+{\n+  typedef histogram_entry value_type;\n+  typedef histogram_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+histogram_hash::hash (const histogram_entry *val)\n+{\n+  return val->count;\n+}\n+\n+inline int\n+histogram_hash::equal (const histogram_entry *val, const histogram_entry *val2)\n+{\n+  return val->count == val2->count;\n+}\n+\n+/* Account TIME and SIZE executed COUNT times into HISTOGRAM.\n+   HASHTABLE is the on-side hash kept to avoid duplicates.  */\n+\n+static void\n+account_time_size (hash_table <histogram_hash> hashtable,\n+\t\t   vec<histogram_entry *> &histogram,\n+\t\t   gcov_type count, int time, int size)\n+{\n+  histogram_entry key = {count, 0, 0};\n+  histogram_entry **val = hashtable.find_slot (&key, INSERT);\n+\n+  if (!*val)\n+    {\n+      *val = (histogram_entry *) pool_alloc (histogram_pool);\n+      **val = key;\n+      histogram.safe_push (*val);\n+    }\n+  (*val)->time += time;\n+  (*val)->size += size;\n+}\n+\n+int\n+cmp_counts (const void *v1, const void *v2)\n+{\n+  const histogram_entry *h1 = *(const histogram_entry * const *)v1;\n+  const histogram_entry *h2 = *(const histogram_entry * const *)v2;\n+  if (h1->count < h2->count)\n+    return 1;\n+  if (h1->count > h2->count)\n+    return -1;\n+  return 0;\n+}\n+\n+/* Dump HISTOGRAM to FILE.  */\n+\n+static void\n+dump_histogram (FILE *file, vec<histogram_entry *> histogram)\n+{\n+  unsigned int i;\n+  gcov_type overall_time = 0, cumulated_time = 0, cumulated_size = 0, overall_size = 0;\n+  \n+  fprintf (dump_file, \"Histogram:\\n\");\n+  for (i = 0; i < histogram.length (); i++)\n+    {\n+      overall_time += histogram[i]->count * histogram[i]->time;\n+      overall_size += histogram[i]->size;\n+    }\n+  if (!overall_time)\n+    overall_time = 1;\n+  if (!overall_size)\n+    overall_size = 1;\n+  for (i = 0; i < histogram.length (); i++)\n+    {\n+      cumulated_time += histogram[i]->count * histogram[i]->time;\n+      cumulated_size += histogram[i]->size;\n+      fprintf (file, \"  \"HOST_WIDEST_INT_PRINT_DEC\": time:%i (%2.2f) size:%i (%2.2f)\\n\",\n+\t       (HOST_WIDEST_INT) histogram[i]->count,\n+\t       histogram[i]->time,\n+\t       cumulated_time * 100.0 / overall_time,\n+\t       histogram[i]->size,\n+\t       cumulated_size * 100.0 / overall_size);\n+   }\n+}\n+\n+/* Collect histogram from CFG profiles.  */\n+\n+static void\n+ipa_profile_generate_summary (void)\n+{\n+  struct cgraph_node *node;\n+  gimple_stmt_iterator gsi;\n+  hash_table <histogram_hash> hashtable;\n+  basic_block bb;\n+\n+  hashtable.create (10);\n+  histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n+\t\t\t\t      10);\n+  \n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->symbol.decl))\n+      {\n+\tint time = 0;\n+\tint size = 0;\n+        for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    gimple stmt = gsi_stmt (gsi);\n+\t    if (gimple_code (stmt) == GIMPLE_CALL\n+\t\t&& !gimple_call_fndecl (stmt))\n+\t      {\n+\t\thistogram_value h;\n+\t\th = gimple_histogram_value_of_type\n+\t\t      (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t       stmt, HIST_TYPE_INDIR_CALL);\n+\t\t/* No need to do sanity check: gimple_ic_transform already\n+\t\t   takes away bad histograms.  */\n+\t\tif (h)\n+\t\t  {\n+\t\t    /* counter 0 is target, counter 1 is number of execution we called target,\n+\t\t       counter 2 is total number of executions.  */\n+\t\t    if (h->hvalue.counters[2])\n+\t\t      {\n+\t\t\tstruct cgraph_edge * e = cgraph_edge (node, stmt);\n+\t\t\te->indirect_info->common_target_id\n+\t\t\t  = h->hvalue.counters [0];\n+\t\t\te->indirect_info->common_target_probability\n+\t\t\t  = GCOV_COMPUTE_SCALE (h->hvalue.counters [1], h->hvalue.counters [2]);\n+\t\t\tif (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n+\t\t\t  {\n+\t\t\t    if (dump_file)\n+\t\t\t      fprintf (dump_file, \"Probability capped to 1\\n\");\n+\t\t\t    e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n+\t\t\t  }\n+\t\t      }\n+\t\t    gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t\t\t\t\t    stmt, h);\n+\t\t  }\n+\t      }\n+\t    time += estimate_num_insns (stmt, &eni_time_weights);\n+\t    size += estimate_num_insns (stmt, &eni_size_weights);\n+\t  }\n+\taccount_time_size (hashtable, histogram, bb->count, time, size);\n+      }\n+  hashtable.dispose ();\n+  histogram.qsort (cmp_counts);\n+}\n+\n+/* Serialize the ipa info for lto.  */\n+\n+static void\n+ipa_profile_write_summary (void)\n+{\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_ipa_profile);\n+  unsigned int i;\n+\n+  streamer_write_uhwi_stream (ob->main_stream, histogram.length());\n+  for (i = 0; i < histogram.length (); i++)\n+    {\n+      streamer_write_gcov_count_stream (ob->main_stream, histogram[i]->count);\n+      streamer_write_uhwi_stream (ob->main_stream, histogram[i]->time);\n+      streamer_write_uhwi_stream (ob->main_stream, histogram[i]->size);\n+    }\n+  lto_destroy_simple_output_block (ob);\n+}\n+\n+/* Deserialize the ipa info for lto.  */\n+\n+static void\n+ipa_profile_read_summary (void)\n+{\n+  struct lto_file_decl_data ** file_data_vec\n+    = lto_get_file_decl_data ();\n+  struct lto_file_decl_data * file_data;\n+  hash_table <histogram_hash> hashtable;\n+  int j = 0;\n+\n+  hashtable.create (10);\n+  histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n+\t\t\t\t      10);\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data,\n+\t\t\t\t\t LTO_section_ipa_profile,\n+\t\t\t\t\t &data, &len);\n+      if (ib)\n+\t{\n+          unsigned int num = streamer_read_uhwi (ib);\n+\t  unsigned int n;\n+\t  for (n = 0; n < num; n++)\n+\t    {\n+\t      gcov_type count = streamer_read_gcov_count (ib);\n+\t      int time = streamer_read_uhwi (ib);\n+\t      int size = streamer_read_uhwi (ib);\n+\t      account_time_size (hashtable, histogram,\n+\t\t\t\t count, time, size);\n+\t    }\n+\t  lto_destroy_simple_input_block (file_data,\n+\t\t\t\t\t  LTO_section_ipa_profile,\n+\t\t\t\t\t  ib, data, len);\n+\t}\n+    }\n+  hashtable.dispose ();\n+  histogram.qsort (cmp_counts);\n+}\n+\n+/* Data used by ipa_propagate_frequency.  */\n+\n+struct ipa_propagate_frequency_data\n+{\n+  bool maybe_unlikely_executed;\n+  bool maybe_executed_once;\n+  bool only_called_at_startup;\n+  bool only_called_at_exit;\n+};\n+\n+/* Worker for ipa_propagate_frequency_1.  */\n+\n+static bool\n+ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n+{\n+  struct ipa_propagate_frequency_data *d;\n+  struct cgraph_edge *edge;\n+\n+  d = (struct ipa_propagate_frequency_data *)data;\n+  for (edge = node->callers;\n+       edge && (d->maybe_unlikely_executed || d->maybe_executed_once\n+\t        || d->only_called_at_startup || d->only_called_at_exit);\n+       edge = edge->next_caller)\n+    {\n+      if (edge->caller != node)\n+\t{\n+          d->only_called_at_startup &= edge->caller->only_called_at_startup;\n+\t  /* It makes sense to put main() together with the static constructors.\n+\t     It will be executed for sure, but rest of functions called from\n+\t     main are definitely not at startup only.  */\n+\t  if (MAIN_NAME_P (DECL_NAME (edge->caller->symbol.decl)))\n+\t    d->only_called_at_startup = 0;\n+          d->only_called_at_exit &= edge->caller->only_called_at_exit;\n+\t}\n+      if (!edge->frequency)\n+\tcontinue;\n+      switch (edge->caller->frequency)\n+        {\n+\tcase NODE_FREQUENCY_UNLIKELY_EXECUTED:\n+\t  break;\n+\tcase NODE_FREQUENCY_EXECUTED_ONCE:\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n+\t\t     cgraph_node_name (edge->caller));\n+\t  d->maybe_unlikely_executed = false;\n+\t  if (inline_edge_summary (edge)->loop_depth)\n+\t    {\n+\t      d->maybe_executed_once = false;\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file, \"  Called in loop\\n\");\n+\t    }\n+\t  break;\n+\tcase NODE_FREQUENCY_HOT:\n+\tcase NODE_FREQUENCY_NORMAL:\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Called by %s that is normal or hot\\n\",\n+\t\t     cgraph_node_name (edge->caller));\n+\t  d->maybe_unlikely_executed = false;\n+\t  d->maybe_executed_once = false;\n+\t  break;\n+\t}\n+    }\n+  return edge != NULL;\n+}\n+\n+/* See if the frequency of NODE can be updated based on frequencies of its\n+   callers.  */\n+bool\n+ipa_propagate_frequency (struct cgraph_node *node)\n+{\n+  struct ipa_propagate_frequency_data d = {true, true, true, true};\n+  bool changed = false;\n+\n+  /* We can not propagate anything useful about externally visible functions\n+     nor about virtuals.  */\n+  if (!node->local.local\n+      || (flag_devirtualize && DECL_VIRTUAL_P (node->symbol.decl)))\n+    return false;\n+  gcc_assert (node->symbol.analyzed);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n+\n+  cgraph_for_node_and_aliases (node, ipa_propagate_frequency_1, &d, true);\n+\n+  if ((d.only_called_at_startup && !d.only_called_at_exit)\n+      && !node->only_called_at_startup)\n+    {\n+       node->only_called_at_startup = true;\n+       if (dump_file)\n+         fprintf (dump_file, \"Node %s promoted to only called at startup.\\n\",\n+\t\t  cgraph_node_name (node));\n+       changed = true;\n+    }\n+  if ((d.only_called_at_exit && !d.only_called_at_startup)\n+      && !node->only_called_at_exit)\n+    {\n+       node->only_called_at_exit = true;\n+       if (dump_file)\n+         fprintf (dump_file, \"Node %s promoted to only called at exit.\\n\",\n+\t\t  cgraph_node_name (node));\n+       changed = true;\n+    }\n+  /* These come either from profile or user hints; never update them.  */\n+  if (node->frequency == NODE_FREQUENCY_HOT\n+      || node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+    return changed;\n+  if (d.maybe_unlikely_executed)\n+    {\n+      node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Node %s promoted to unlikely executed.\\n\",\n+\t\t cgraph_node_name (node));\n+      changed = true;\n+    }\n+  else if (d.maybe_executed_once && node->frequency != NODE_FREQUENCY_EXECUTED_ONCE)\n+    {\n+      node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Node %s promoted to executed once.\\n\",\n+\t\t cgraph_node_name (node));\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n+/* Simple ipa profile pass propagating frequencies across the callgraph.  */\n+\n+static unsigned int\n+ipa_profile (void)\n+{\n+  struct cgraph_node **order;\n+  struct cgraph_edge *e;\n+  int order_pos;\n+  bool something_changed = false;\n+  int i;\n+  gcov_type overall_time = 0, cutoff = 0, cumulated = 0, overall_size = 0;\n+  struct cgraph_node *n,*n2;\n+  int nindirect = 0, ncommon = 0, nunknown = 0, nuseless = 0, nconverted = 0;\n+  bool node_map_initialized = false;\n+\n+  if (dump_file)\n+    dump_histogram (dump_file, histogram);\n+  for (i = 0; i < (int)histogram.length (); i++)\n+    {\n+      overall_time += histogram[i]->count * histogram[i]->time;\n+      overall_size += histogram[i]->size;\n+    }\n+  if (overall_time)\n+    {\n+      gcov_type threshold;\n+\n+      gcc_assert (overall_size);\n+      if (dump_file)\n+\t{\n+\t  gcov_type min, cumulated_time = 0, cumulated_size = 0;\n+\n+\t  fprintf (dump_file, \"Overall time: \"HOST_WIDEST_INT_PRINT_DEC\"\\n\", \n+\t\t   (HOST_WIDEST_INT)overall_time);\n+\t  min = get_hot_bb_threshold ();\n+          for (i = 0; i < (int)histogram.length () && histogram[i]->count >= min;\n+\t       i++)\n+\t    {\n+\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n+\t      cumulated_size += histogram[i]->size;\n+\t    }\n+\t  fprintf (dump_file, \"GCOV min count: \"HOST_WIDEST_INT_PRINT_DEC\n+\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n+\t\t   (HOST_WIDEST_INT)min,\n+\t\t   cumulated_time * 100.0 / overall_time,\n+\t\t   cumulated_size * 100.0 / overall_size);\n+\t}\n+      cutoff = (overall_time * PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE) + 500) / 1000;\n+      threshold = 0;\n+      for (i = 0; cumulated < cutoff; i++)\n+\t{\n+\t  cumulated += histogram[i]->count * histogram[i]->time;\n+          threshold = histogram[i]->count;\n+\t}\n+      if (!threshold)\n+\tthreshold = 1;\n+      if (dump_file)\n+\t{\n+\t  gcov_type cumulated_time = 0, cumulated_size = 0;\n+\n+          for (i = 0;\n+\t       i < (int)histogram.length () && histogram[i]->count >= threshold;\n+\t       i++)\n+\t    {\n+\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n+\t      cumulated_size += histogram[i]->size;\n+\t    }\n+\t  fprintf (dump_file, \"Determined min count: \"HOST_WIDEST_INT_PRINT_DEC\n+\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n+\t\t   (HOST_WIDEST_INT)threshold,\n+\t\t   cumulated_time * 100.0 / overall_time,\n+\t\t   cumulated_size * 100.0 / overall_size);\n+\t}\n+      if (threshold > get_hot_bb_threshold ()\n+\t  || in_lto_p)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Threshold updated.\\n\");\n+          set_hot_bb_threshold (threshold);\n+\t}\n+    }\n+  histogram.release();\n+  free_alloc_pool (histogram_pool);\n+\n+  /* Produce speculative calls: we saved common traget from porfiling into\n+     e->common_target_id.  Now, at link time, we can look up corresponding\n+     function node and produce speculative call.  */\n+\n+  FOR_EACH_DEFINED_FUNCTION (n)\n+    {\n+      bool update = false;\n+\n+      for (e = n->indirect_calls; e; e = e->next_callee)\n+\t{\n+\t  if (n->count)\n+\t    nindirect++;\n+\t  if (e->indirect_info->common_target_id)\n+\t    {\n+\t      if (!node_map_initialized)\n+\t        init_node_map (false);\n+\t      node_map_initialized = true;\n+\t      ncommon++;\n+\t      n2 = find_func_by_profile_id (e->indirect_info->common_target_id);\n+\t      if (n2)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n+\t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n+\t\t\t       xstrdup (cgraph_node_name (n)), n->symbol.order,\n+\t\t\t       xstrdup (cgraph_node_name (n2)), n2->symbol.order,\n+\t\t\t       e->indirect_info->common_target_probability\n+\t\t\t       / (float)REG_BR_PROB_BASE);\n+\t\t    }\n+\t\t  if (e->indirect_info->common_target_probability\n+\t\t      < REG_BR_PROB_BASE / 2)\n+\t\t    {\n+\t\t      nuseless++;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Not speculating: probability is too low.\\n\");\n+\t\t    }\n+\t\t  else if (!cgraph_maybe_hot_edge_p (e))\n+\t\t    {\n+\t\t      nuseless++;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Not speculating: call is cold.\\n\");\n+\t\t    }\n+\t\t  else if (cgraph_function_body_availability (n2)\n+\t\t\t   <= AVAIL_OVERWRITABLE\n+\t\t\t   && symtab_can_be_discarded ((symtab_node) n2))\n+\t\t    {\n+\t\t      nuseless++;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Not speculating: target is overwritable \"\n+\t\t\t\t \"and can be discarded.\\n\");\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Target may be overwritable, but profile says that\n+\t\t\t control flow goes to this particular implementation\n+\t\t\t of N2.  Speculate on the local alias to allow inlining.\n+\t\t       */\n+\t\t      if (!symtab_can_be_discarded ((symtab_node) n2))\n+\t\t\tn2 = cgraph (symtab_nonoverwritable_alias ((symtab_node)n2));\n+\t\t      nconverted++;\n+\t\t      cgraph_turn_edge_to_speculative\n+\t\t\t(e, n2,\n+\t\t\t apply_scale (e->count,\n+\t\t\t\t      e->indirect_info->common_target_probability),\n+\t\t\t apply_scale (e->frequency,\n+\t\t\t\t      e->indirect_info->common_target_probability));\n+\t\t      update = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n+\t\t\t     e->indirect_info->common_target_id);\n+\t\t  nunknown++;\n+\t\t}\n+\t    }\n+\t }\n+       if (update)\n+\t inline_update_overall_summary (n);\n+     }\n+  if (node_map_initialized)\n+    del_node_map ();\n+  if (dump_file && nindirect)\n+    fprintf (dump_file,\n+\t     \"%i indirect calls trained.\\n\"\n+\t     \"%i (%3.2f%%) have common target.\\n\"\n+\t     \"%i (%3.2f%%) targets was not found.\\n\"\n+\t     \"%i (%3.2f%%) speculations seems useless.\\n\"\n+\t     \"%i (%3.2f%%) speculations produced.\\n\",\n+\t     nindirect,\n+\t     ncommon, ncommon * 100.0 / nindirect,\n+\t     nunknown, nunknown * 100.0 / nindirect,\n+\t     nuseless, nuseless * 100.0 / nindirect,\n+\t     nconverted, nconverted * 100.0 / nindirect);\n+\n+  order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  order_pos = ipa_reverse_postorder (order);\n+  for (i = order_pos - 1; i >= 0; i--)\n+    {\n+      if (order[i]->local.local && ipa_propagate_frequency (order[i]))\n+\t{\n+\t  for (e = order[i]->callees; e; e = e->next_callee)\n+\t    if (e->callee->local.local && !e->callee->symbol.aux)\n+\t      {\n+\t        something_changed = true;\n+\t        e->callee->symbol.aux = (void *)1;\n+\t      }\n+\t}\n+      order[i]->symbol.aux = NULL;\n+    }\n+\n+  while (something_changed)\n+    {\n+      something_changed = false;\n+      for (i = order_pos - 1; i >= 0; i--)\n+\t{\n+\t  if (order[i]->symbol.aux && ipa_propagate_frequency (order[i]))\n+\t    {\n+\t      for (e = order[i]->callees; e; e = e->next_callee)\n+\t\tif (e->callee->local.local && !e->callee->symbol.aux)\n+\t\t  {\n+\t\t    something_changed = true;\n+\t\t    e->callee->symbol.aux = (void *)1;\n+\t\t  }\n+\t    }\n+\t  order[i]->symbol.aux = NULL;\n+\t}\n+    }\n+  free (order);\n+  return 0;\n+}\n+\n+static bool\n+gate_ipa_profile (void)\n+{\n+  return flag_ipa_profile;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_profile =\n+{\n+  IPA_PASS, /* type */\n+  \"profile_estimate\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_PROFILE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_ipa_profile : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_profile(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_profile, ctxt,\n+\t\t     ipa_profile_generate_summary, /* generate_summary */\n+\t\t     ipa_profile_write_summary, /* write_summary */\n+\t\t     ipa_profile_read_summary, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ipa_profile (); }\n+  unsigned int execute () { return ipa_profile (); }\n+\n+}; // class pass_ipa_profile\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_profile (gcc::context *ctxt)\n+{\n+  return new pass_ipa_profile (ctxt);\n+}"}, {"sha": "5619b5dcda35f3ced2efcba32f2d96cdabdf1cfa", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -47,6 +47,9 @@ tree get_base_var (tree);\n void ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t struct cgraph_node *src);\n \n+/* In ipa-profile.c  */\n+bool ipa_propagate_frequency (struct cgraph_node *node);\n+\n /* In ipa-devirt.c  */\n \n struct odr_type_d;"}, {"sha": "b1759ae876cb1d30605d459181057115cf5e44b9", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 507, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f835dc74bccf078cb1cad4f3e20dda6d457d74/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=08f835dc74bccf078cb1cad4f3e20dda6d457d74", "patch": "@@ -30,15 +30,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"tree-iterator.h\"\n #include \"ipa-utils.h\"\n-#include \"pointer-set.h\"\n #include \"ipa-inline.h\"\n-#include \"hash-table.h\"\n #include \"tree-inline.h\"\n #include \"profile.h\"\n #include \"params.h\"\n-#include \"lto-streamer.h\"\n-#include \"data-streamer.h\"\n-#include \"value-prof.h\"\n \n /* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n \n@@ -484,7 +479,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   /* If we removed something, perhaps profile could be improved.  */\n   if (changed && optimize && inline_edge_summary_vec.exists ())\n     FOR_EACH_DEFINED_FUNCTION (node)\n-      cgraph_propagate_frequency (node);\n+      ipa_propagate_frequency (node);\n \n   return changed;\n }\n@@ -1168,507 +1163,6 @@ make_pass_ipa_whole_program_visibility (gcc::context *ctxt)\n   return new pass_ipa_whole_program_visibility (ctxt);\n }\n \n-/* Entry in the histogram.  */\n-\n-struct histogram_entry\n-{\n-  gcov_type count;\n-  int time;\n-  int size;\n-};\n-\n-/* Histogram of profile values.\n-   The histogram is represented as an ordered vector of entries allocated via\n-   histogram_pool. During construction a separate hashtable is kept to lookup\n-   duplicate entries.  */\n-\n-vec<histogram_entry *> histogram;\n-static alloc_pool histogram_pool;\n-\n-/* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */\n-\n-struct histogram_hash : typed_noop_remove <histogram_entry>\n-{\n-  typedef histogram_entry value_type;\n-  typedef histogram_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n-};\n-\n-inline hashval_t\n-histogram_hash::hash (const histogram_entry *val)\n-{\n-  return val->count;\n-}\n-\n-inline int\n-histogram_hash::equal (const histogram_entry *val, const histogram_entry *val2)\n-{\n-  return val->count == val2->count;\n-}\n-\n-/* Account TIME and SIZE executed COUNT times into HISTOGRAM.\n-   HASHTABLE is the on-side hash kept to avoid duplicates.  */\n-\n-static void\n-account_time_size (hash_table <histogram_hash> hashtable,\n-\t\t   vec<histogram_entry *> &histogram,\n-\t\t   gcov_type count, int time, int size)\n-{\n-  histogram_entry key = {count, 0, 0};\n-  histogram_entry **val = hashtable.find_slot (&key, INSERT);\n-\n-  if (!*val)\n-    {\n-      *val = (histogram_entry *) pool_alloc (histogram_pool);\n-      **val = key;\n-      histogram.safe_push (*val);\n-    }\n-  (*val)->time += time;\n-  (*val)->size += size;\n-}\n-\n-int\n-cmp_counts (const void *v1, const void *v2)\n-{\n-  const histogram_entry *h1 = *(const histogram_entry * const *)v1;\n-  const histogram_entry *h2 = *(const histogram_entry * const *)v2;\n-  if (h1->count < h2->count)\n-    return 1;\n-  if (h1->count > h2->count)\n-    return -1;\n-  return 0;\n-}\n-\n-/* Dump HISTOGRAM to FILE.  */\n-\n-static void\n-dump_histogram (FILE *file, vec<histogram_entry *> histogram)\n-{\n-  unsigned int i;\n-  gcov_type overall_time = 0, cumulated_time = 0, cumulated_size = 0, overall_size = 0;\n-  \n-  fprintf (dump_file, \"Histogram:\\n\");\n-  for (i = 0; i < histogram.length (); i++)\n-    {\n-      overall_time += histogram[i]->count * histogram[i]->time;\n-      overall_size += histogram[i]->size;\n-    }\n-  if (!overall_time)\n-    overall_time = 1;\n-  if (!overall_size)\n-    overall_size = 1;\n-  for (i = 0; i < histogram.length (); i++)\n-    {\n-      cumulated_time += histogram[i]->count * histogram[i]->time;\n-      cumulated_size += histogram[i]->size;\n-      fprintf (file, \"  \"HOST_WIDEST_INT_PRINT_DEC\": time:%i (%2.2f) size:%i (%2.2f)\\n\",\n-\t       (HOST_WIDEST_INT) histogram[i]->count,\n-\t       histogram[i]->time,\n-\t       cumulated_time * 100.0 / overall_time,\n-\t       histogram[i]->size,\n-\t       cumulated_size * 100.0 / overall_size);\n-   }\n-}\n-\n-/* Collect histogram from CFG profiles.  */\n-\n-static void\n-ipa_profile_generate_summary (void)\n-{\n-  struct cgraph_node *node;\n-  gimple_stmt_iterator gsi;\n-  hash_table <histogram_hash> hashtable;\n-  basic_block bb;\n-\n-  hashtable.create (10);\n-  histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n-\t\t\t\t      10);\n-  \n-  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-    FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->symbol.decl))\n-      {\n-\tint time = 0;\n-\tint size = 0;\n-        for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  {\n-\t    gimple stmt = gsi_stmt (gsi);\n-\t    if (gimple_code (stmt) == GIMPLE_CALL\n-\t\t&& !gimple_call_fndecl (stmt))\n-\t      {\n-\t\thistogram_value h;\n-\t\th = gimple_histogram_value_of_type\n-\t\t      (DECL_STRUCT_FUNCTION (node->symbol.decl),\n-\t\t       stmt, HIST_TYPE_INDIR_CALL);\n-\t\t/* No need to do sanity check: gimple_ic_transform already\n-\t\t   takes away bad histograms.  */\n-\t\tif (h)\n-\t\t  {\n-\t\t    /* counter 0 is target, counter 1 is number of execution we called target,\n-\t\t       counter 2 is total number of executions.  */\n-\t\t    if (h->hvalue.counters[2])\n-\t\t      {\n-\t\t\tstruct cgraph_edge * e = cgraph_edge (node, stmt);\n-\t\t\te->indirect_info->common_target_id\n-\t\t\t  = h->hvalue.counters [0];\n-\t\t\te->indirect_info->common_target_probability\n-\t\t\t  = GCOV_COMPUTE_SCALE (h->hvalue.counters [1], h->hvalue.counters [2]);\n-\t\t\tif (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n-\t\t\t  {\n-\t\t\t    if (dump_file)\n-\t\t\t      fprintf (dump_file, \"Probability capped to 1\\n\");\n-\t\t\t    e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n-\t\t\t  }\n-\t\t      }\n-\t\t    gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->symbol.decl),\n-\t\t\t\t\t\t    stmt, h);\n-\t\t  }\n-\t      }\n-\t    time += estimate_num_insns (stmt, &eni_time_weights);\n-\t    size += estimate_num_insns (stmt, &eni_size_weights);\n-\t  }\n-\taccount_time_size (hashtable, histogram, bb->count, time, size);\n-      }\n-  hashtable.dispose ();\n-  histogram.qsort (cmp_counts);\n-}\n-\n-/* Serialize the ipa info for lto.  */\n-\n-static void\n-ipa_profile_write_summary (void)\n-{\n-  struct lto_simple_output_block *ob\n-    = lto_create_simple_output_block (LTO_section_ipa_profile);\n-  unsigned int i;\n-\n-  streamer_write_uhwi_stream (ob->main_stream, histogram.length());\n-  for (i = 0; i < histogram.length (); i++)\n-    {\n-      streamer_write_gcov_count_stream (ob->main_stream, histogram[i]->count);\n-      streamer_write_uhwi_stream (ob->main_stream, histogram[i]->time);\n-      streamer_write_uhwi_stream (ob->main_stream, histogram[i]->size);\n-    }\n-  lto_destroy_simple_output_block (ob);\n-}\n-\n-/* Deserialize the ipa info for lto.  */\n-\n-static void\n-ipa_profile_read_summary (void)\n-{\n-  struct lto_file_decl_data ** file_data_vec\n-    = lto_get_file_decl_data ();\n-  struct lto_file_decl_data * file_data;\n-  hash_table <histogram_hash> hashtable;\n-  int j = 0;\n-\n-  hashtable.create (10);\n-  histogram_pool = create_alloc_pool (\"IPA histogram\", sizeof (struct histogram_entry),\n-\t\t\t\t      10);\n-\n-  while ((file_data = file_data_vec[j++]))\n-    {\n-      const char *data;\n-      size_t len;\n-      struct lto_input_block *ib\n-\t= lto_create_simple_input_block (file_data,\n-\t\t\t\t\t LTO_section_ipa_profile,\n-\t\t\t\t\t &data, &len);\n-      if (ib)\n-\t{\n-          unsigned int num = streamer_read_uhwi (ib);\n-\t  unsigned int n;\n-\t  for (n = 0; n < num; n++)\n-\t    {\n-\t      gcov_type count = streamer_read_gcov_count (ib);\n-\t      int time = streamer_read_uhwi (ib);\n-\t      int size = streamer_read_uhwi (ib);\n-\t      account_time_size (hashtable, histogram,\n-\t\t\t\t count, time, size);\n-\t    }\n-\t  lto_destroy_simple_input_block (file_data,\n-\t\t\t\t\t  LTO_section_ipa_profile,\n-\t\t\t\t\t  ib, data, len);\n-\t}\n-    }\n-  hashtable.dispose ();\n-  histogram.qsort (cmp_counts);\n-}\n-\n-/* Simple ipa profile pass propagating frequencies across the callgraph.  */\n-\n-static unsigned int\n-ipa_profile (void)\n-{\n-  struct cgraph_node **order;\n-  struct cgraph_edge *e;\n-  int order_pos;\n-  bool something_changed = false;\n-  int i;\n-  gcov_type overall_time = 0, cutoff = 0, cumulated = 0, overall_size = 0;\n-  struct cgraph_node *n,*n2;\n-  int nindirect = 0, ncommon = 0, nunknown = 0, nuseless = 0, nconverted = 0;\n-  bool node_map_initialized = false;\n-\n-  if (dump_file)\n-    dump_histogram (dump_file, histogram);\n-  for (i = 0; i < (int)histogram.length (); i++)\n-    {\n-      overall_time += histogram[i]->count * histogram[i]->time;\n-      overall_size += histogram[i]->size;\n-    }\n-  if (overall_time)\n-    {\n-      gcov_type threshold;\n-\n-      gcc_assert (overall_size);\n-      if (dump_file)\n-\t{\n-\t  gcov_type min, cumulated_time = 0, cumulated_size = 0;\n-\n-\t  fprintf (dump_file, \"Overall time: \"HOST_WIDEST_INT_PRINT_DEC\"\\n\", \n-\t\t   (HOST_WIDEST_INT)overall_time);\n-\t  min = get_hot_bb_threshold ();\n-          for (i = 0; i < (int)histogram.length () && histogram[i]->count >= min;\n-\t       i++)\n-\t    {\n-\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n-\t      cumulated_size += histogram[i]->size;\n-\t    }\n-\t  fprintf (dump_file, \"GCOV min count: \"HOST_WIDEST_INT_PRINT_DEC\n-\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n-\t\t   (HOST_WIDEST_INT)min,\n-\t\t   cumulated_time * 100.0 / overall_time,\n-\t\t   cumulated_size * 100.0 / overall_size);\n-\t}\n-      cutoff = (overall_time * PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE) + 500) / 1000;\n-      threshold = 0;\n-      for (i = 0; cumulated < cutoff; i++)\n-\t{\n-\t  cumulated += histogram[i]->count * histogram[i]->time;\n-          threshold = histogram[i]->count;\n-\t}\n-      if (!threshold)\n-\tthreshold = 1;\n-      if (dump_file)\n-\t{\n-\t  gcov_type cumulated_time = 0, cumulated_size = 0;\n-\n-          for (i = 0;\n-\t       i < (int)histogram.length () && histogram[i]->count >= threshold;\n-\t       i++)\n-\t    {\n-\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n-\t      cumulated_size += histogram[i]->size;\n-\t    }\n-\t  fprintf (dump_file, \"Determined min count: \"HOST_WIDEST_INT_PRINT_DEC\n-\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n-\t\t   (HOST_WIDEST_INT)threshold,\n-\t\t   cumulated_time * 100.0 / overall_time,\n-\t\t   cumulated_size * 100.0 / overall_size);\n-\t}\n-      if (threshold > get_hot_bb_threshold ()\n-\t  || in_lto_p)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Threshold updated.\\n\");\n-          set_hot_bb_threshold (threshold);\n-\t}\n-    }\n-  histogram.release();\n-  free_alloc_pool (histogram_pool);\n-\n-  /* Produce speculative calls: we saved common traget from porfiling into\n-     e->common_target_id.  Now, at link time, we can look up corresponding\n-     function node and produce speculative call.  */\n-\n-  FOR_EACH_DEFINED_FUNCTION (n)\n-    {\n-      bool update = false;\n-\n-      for (e = n->indirect_calls; e; e = e->next_callee)\n-\t{\n-\t  if (n->count)\n-\t    nindirect++;\n-\t  if (e->indirect_info->common_target_id)\n-\t    {\n-\t      if (!node_map_initialized)\n-\t        init_node_map (false);\n-\t      node_map_initialized = true;\n-\t      ncommon++;\n-\t      n2 = find_func_by_profile_id (e->indirect_info->common_target_id);\n-\t      if (n2)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n-\t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n-\t\t\t       xstrdup (cgraph_node_name (n)), n->symbol.order,\n-\t\t\t       xstrdup (cgraph_node_name (n2)), n2->symbol.order,\n-\t\t\t       e->indirect_info->common_target_probability\n-\t\t\t       / (float)REG_BR_PROB_BASE);\n-\t\t    }\n-\t\t  if (e->indirect_info->common_target_probability\n-\t\t      < REG_BR_PROB_BASE / 2)\n-\t\t    {\n-\t\t      nuseless++;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: probability is too low.\\n\");\n-\t\t    }\n-\t\t  else if (!cgraph_maybe_hot_edge_p (e))\n-\t\t    {\n-\t\t      nuseless++;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: call is cold.\\n\");\n-\t\t    }\n-\t\t  else if (cgraph_function_body_availability (n2)\n-\t\t\t   <= AVAIL_OVERWRITABLE\n-\t\t\t   && symtab_can_be_discarded ((symtab_node) n2))\n-\t\t    {\n-\t\t      nuseless++;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: target is overwritable \"\n-\t\t\t\t \"and can be discarded.\\n\");\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Target may be overwritable, but profile says that\n-\t\t\t control flow goes to this particular implementation\n-\t\t\t of N2.  Speculate on the local alias to allow inlining.\n-\t\t       */\n-\t\t      if (!symtab_can_be_discarded ((symtab_node) n2))\n-\t\t\tn2 = cgraph (symtab_nonoverwritable_alias ((symtab_node)n2));\n-\t\t      nconverted++;\n-\t\t      cgraph_turn_edge_to_speculative\n-\t\t\t(e, n2,\n-\t\t\t apply_scale (e->count,\n-\t\t\t\t      e->indirect_info->common_target_probability),\n-\t\t\t apply_scale (e->frequency,\n-\t\t\t\t      e->indirect_info->common_target_probability));\n-\t\t      update = true;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n-\t\t\t     e->indirect_info->common_target_id);\n-\t\t  nunknown++;\n-\t\t}\n-\t    }\n-\t }\n-       if (update)\n-\t inline_update_overall_summary (n);\n-     }\n-  if (node_map_initialized)\n-    del_node_map ();\n-  if (dump_file && nindirect)\n-    fprintf (dump_file,\n-\t     \"%i indirect calls trained.\\n\"\n-\t     \"%i (%3.2f%%) have common target.\\n\"\n-\t     \"%i (%3.2f%%) targets was not found.\\n\"\n-\t     \"%i (%3.2f%%) speculations seems useless.\\n\"\n-\t     \"%i (%3.2f%%) speculations produced.\\n\",\n-\t     nindirect,\n-\t     ncommon, ncommon * 100.0 / nindirect,\n-\t     nunknown, nunknown * 100.0 / nindirect,\n-\t     nuseless, nuseless * 100.0 / nindirect,\n-\t     nconverted, nconverted * 100.0 / nindirect);\n-\n-  order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  order_pos = ipa_reverse_postorder (order);\n-  for (i = order_pos - 1; i >= 0; i--)\n-    {\n-      if (order[i]->local.local && cgraph_propagate_frequency (order[i]))\n-\t{\n-\t  for (e = order[i]->callees; e; e = e->next_callee)\n-\t    if (e->callee->local.local && !e->callee->symbol.aux)\n-\t      {\n-\t        something_changed = true;\n-\t        e->callee->symbol.aux = (void *)1;\n-\t      }\n-\t}\n-      order[i]->symbol.aux = NULL;\n-    }\n-\n-  while (something_changed)\n-    {\n-      something_changed = false;\n-      for (i = order_pos - 1; i >= 0; i--)\n-\t{\n-\t  if (order[i]->symbol.aux && cgraph_propagate_frequency (order[i]))\n-\t    {\n-\t      for (e = order[i]->callees; e; e = e->next_callee)\n-\t\tif (e->callee->local.local && !e->callee->symbol.aux)\n-\t\t  {\n-\t\t    something_changed = true;\n-\t\t    e->callee->symbol.aux = (void *)1;\n-\t\t  }\n-\t    }\n-\t  order[i]->symbol.aux = NULL;\n-\t}\n-    }\n-  free (order);\n-  return 0;\n-}\n-\n-static bool\n-gate_ipa_profile (void)\n-{\n-  return flag_ipa_profile;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_ipa_profile =\n-{\n-  IPA_PASS, /* type */\n-  \"profile_estimate\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_IPA_PROFILE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_ipa_profile : public ipa_opt_pass_d\n-{\n-public:\n-  pass_ipa_profile(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_profile, ctxt,\n-\t\t     ipa_profile_generate_summary, /* generate_summary */\n-\t\t     ipa_profile_write_summary, /* write_summary */\n-\t\t     ipa_profile_read_summary, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_ipa_profile (); }\n-  unsigned int execute () { return ipa_profile (); }\n-\n-}; // class pass_ipa_profile\n-\n-} // anon namespace\n-\n-ipa_opt_pass_d *\n-make_pass_ipa_profile (gcc::context *ctxt)\n-{\n-  return new pass_ipa_profile (ctxt);\n-}\n-\n /* Generate and emit a static constructor or destructor.  WHICH must\n    be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n    is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the"}]}