{"sha": "8865133614f09caadf48c0b7d05f0331959b3bc1", "node_id": "C_kwDOANBUbNoAKDg4NjUxMzM2MTRmMDljYWFkZjQ4YzBiN2QwNWYwMzMxOTU5YjNiYzE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-11T13:05:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-11T14:01:26Z"}, "message": "tree-optimization/103188 - avoid running ranger on not-up-to-date SSA\n\nThe following splits loop header copying into an analysis phase\nthat uses ranger and a transform phase that can do without to avoid\nrunning ranger on IL that has SSA form not updated.\n\n2021-11-11  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/103188\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p):\n\tRemove query parameter, split out check for size\n\toptimization.\n\t(ch_base::m_ranger, cb_base::m_query): Remove.\n\t(ch_base::copy_headers): Split processing loop into\n\tanalysis around which we allocate and use ranger and\n\ttransform where we do not.\n\t(pass_ch::execute): Do not allocate/free ranger here.\n\t(pass_ch_vect::execute): Likewise.\n\n\t* gcc.dg/torture/pr103188.c: New testcase.", "tree": {"sha": "504e33799e8d37fe93b9335eefb2a6b19c60bdd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/504e33799e8d37fe93b9335eefb2a6b19c60bdd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8865133614f09caadf48c0b7d05f0331959b3bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8865133614f09caadf48c0b7d05f0331959b3bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8865133614f09caadf48c0b7d05f0331959b3bc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8865133614f09caadf48c0b7d05f0331959b3bc1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e30c48120500ef2e8643a7574636ed02567dbb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e30c48120500ef2e8643a7574636ed02567dbb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e30c48120500ef2e8643a7574636ed02567dbb6"}], "stats": {"total": 110, "additions": 78, "deletions": 32}, "files": [{"sha": "0412f6f9b79756bc6ad7544cb9ec19e8c6b367e6", "filename": "gcc/testsuite/gcc.dg/torture/pr103188.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8865133614f09caadf48c0b7d05f0331959b3bc1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr103188.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8865133614f09caadf48c0b7d05f0331959b3bc1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr103188.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr103188.c?ref=8865133614f09caadf48c0b7d05f0331959b3bc1", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+\n+int a, b, c, d = 10, e = 1, f, g, h, i;\n+int main()\n+{\n+  int j = -1;\n+k:\n+  h = c;\n+l:\n+  c = ~c;\n+  if (e)\n+  m:\n+    a = 0;\n+  if (j > 1)\n+    goto m;\n+  if (!e)\n+    goto l;\n+  if (c)\n+    goto p;\n+n:\n+  goto m;\n+o:\n+  if (f) {\n+    if (g)\n+      goto k;\n+    j = 0;\n+  p:\n+    if (d)\n+      goto o;\n+    goto n;\n+  }\n+  if (i)\n+    goto l;\n+  for (; a < 1; a++)\n+    while (a > d)\n+      b++;\n+  return 0;\n+}"}, {"sha": "b87361c374148bddf9d87206820e8e2ef8ff4e55", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8865133614f09caadf48c0b7d05f0331959b3bc1/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8865133614f09caadf48c0b7d05f0331959b3bc1/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=8865133614f09caadf48c0b7d05f0331959b3bc1", "patch": "@@ -83,26 +83,12 @@ entry_loop_condition_is_static (class loop *l, path_range_query *query)\n \n static bool\n should_duplicate_loop_header_p (basic_block header, class loop *loop,\n-\t\t\t\tint *limit, path_range_query *query)\n+\t\t\t\tint *limit)\n {\n   gimple_stmt_iterator bsi;\n \n   gcc_assert (!header->aux);\n \n-  /* Avoid loop header copying when optimizing for size unless we can\n-     determine that the loop condition is static in the first\n-     iteration.  */\n-  if (optimize_loop_for_size_p (loop)\n-      && !loop->force_vectorize\n-      && !entry_loop_condition_is_static (loop, query))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"  Not duplicating bb %i: optimizing for size.\\n\",\n-\t\t header->index);\n-      return false;\n-    }\n-\n   gcc_assert (EDGE_COUNT (header->succs) > 0);\n   if (single_succ_p (header))\n     {\n@@ -237,8 +223,6 @@ should_duplicate_loop_header_p (basic_block header, class loop *loop,\n       return false;\n     }\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"    Will duplicate bb %i\\n\", header->index); \n   return true;\n }\n \n@@ -303,9 +287,6 @@ class ch_base : public gimple_opt_pass\n \n   /* Return true to copy headers of LOOP or false to skip.  */\n   virtual bool process_loop_p (class loop *loop) = 0;\n-\n-  gimple_ranger *m_ranger = NULL;\n-  path_range_query *m_query = NULL;\n };\n \n const pass_data pass_data_ch =\n@@ -400,8 +381,11 @@ ch_base::copy_headers (function *fun)\n   copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n   bbs_size = n_basic_blocks_for_fn (fun);\n \n+  auto_vec<loop_p> candidates;\n   auto_vec<std::pair<edge, loop_p> > copied;\n \n+  gimple_ranger *ranger = new gimple_ranger;\n+  path_range_query *query = new path_range_query (*ranger, /*resolve=*/true);\n   for (auto loop : loops_list (cfun, 0))\n     {\n       int initial_limit = param_max_loop_header_insns;\n@@ -420,6 +404,37 @@ ch_base::copy_headers (function *fun)\n \t  || !process_loop_p (loop))\n \tcontinue;\n \n+      /* Avoid loop header copying when optimizing for size unless we can\n+\t determine that the loop condition is static in the first\n+\t iteration.  */\n+      if (optimize_loop_for_size_p (loop)\n+\t  && !loop->force_vectorize\n+\t  && !entry_loop_condition_is_static (loop, query))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Not duplicating bb %i: optimizing for size.\\n\",\n+\t\t     header->index);\n+\t  continue;\n+\t}\n+\n+      if (should_duplicate_loop_header_p (header, loop, &remaining_limit))\n+\tcandidates.safe_push (loop);\n+    }\n+  /* Do not use ranger after we change the IL and not have updated SSA.  */\n+  delete query;\n+  delete ranger;\n+\n+  for (auto loop : candidates)\n+    {\n+      int initial_limit = param_max_loop_header_insns;\n+      int remaining_limit = initial_limit;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Copying headers of loop %i\\n\", loop->num);\n+\n+      header = loop->header;\n+\n       /* Iterate the header copying up to limit; this takes care of the cases\n \t like while (a && b) {...}, where we want to have both of the conditions\n \t copied.  TODO -- handle while (a || b) - like cases, by not requiring\n@@ -428,9 +443,11 @@ ch_base::copy_headers (function *fun)\n \n       exit = NULL;\n       n_bbs = 0;\n-      while (should_duplicate_loop_header_p (header, loop, &remaining_limit,\n-\t\t\t\t\t     m_query))\n+      while (should_duplicate_loop_header_p (header, loop, &remaining_limit))\n \t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"    Will duplicate bb %i\\n\", header->index);\n+\n \t  /* Find a successor of header that is inside a loop; i.e. the new\n \t     header after the condition is copied.  */\n \t  if (flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 0)->dest))\n@@ -566,13 +583,9 @@ pass_ch::execute (function *fun)\n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n \t\t       | LOOPS_HAVE_SIMPLE_LATCHES\n \t\t       | LOOPS_HAVE_RECORDED_EXITS);\n-  m_ranger = new gimple_ranger;\n-  m_query = new path_range_query (*m_ranger, /*resolve=*/true);\n \n   unsigned int res = copy_headers (fun);\n \n-  delete m_query;\n-  delete m_ranger;\n   loop_optimizer_finalize ();\n   return res;\n }\n@@ -584,12 +597,7 @@ pass_ch::execute (function *fun)\n unsigned int\n pass_ch_vect::execute (function *fun)\n {\n-  m_ranger = new gimple_ranger;\n-  m_query = new path_range_query (*m_ranger, /*resolve=*/true);\n-  unsigned int res = copy_headers (fun);\n-  delete m_query;\n-  delete m_ranger;\n-  return res;\n+  return copy_headers (fun);\n }\n \n /* Apply header copying according to a very simple test of do-while shape.  */"}]}