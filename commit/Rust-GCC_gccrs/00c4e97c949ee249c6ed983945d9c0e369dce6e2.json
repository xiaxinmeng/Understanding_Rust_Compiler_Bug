{"sha": "00c4e97c949ee249c6ed983945d9c0e369dce6e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBjNGU5N2M5NDllZTI0OWM2ZWQ5ODM5NDVkOWMwZTM2OWRjZTZlMg==", "commit": {"author": {"name": "Andrey Belevantsev", "email": "abel@ispras.ru", "date": "2010-12-08T13:55:57Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2010-12-08T13:55:57Z"}, "message": "re PR target/43603 (gcc-4.4.3 ICE on ia64 with -O3)\n\n        PR target/43603\n        * haifa-sched.c (sched_create_recovery_edges): Update\n        dominator info.\n        * sel-sched-ir.c (maybe_tidy_empty_bb): Update dominator info\n        after deleting an empty block.\n        (tidy_control_flow): Also verify dominators.\n        (sel_remove_bb): Update dominator info after removing a block.\n        (sel_redirect_edge_and_branch_force): Assert that no unreachable\n        blocks will be created. Update dominator info.\n        (sel_redirect_edge_and_branch): Update dominator info when\n        basic blocks do not become unreachable.\n        (sel_remove_loop_preheader): Update dominator info.\n\nFrom-SVN: r167588", "tree": {"sha": "9de16294b5bf2aded7c916f41b6b50f5f2bb4670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9de16294b5bf2aded7c916f41b6b50f5f2bb4670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00c4e97c949ee249c6ed983945d9c0e369dce6e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c4e97c949ee249c6ed983945d9c0e369dce6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c4e97c949ee249c6ed983945d9c0e369dce6e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c4e97c949ee249c6ed983945d9c0e369dce6e2/comments", "author": {"login": "abonzo", "id": 20396542, "node_id": "MDQ6VXNlcjIwMzk2NTQy", "avatar_url": "https://avatars.githubusercontent.com/u/20396542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonzo", "html_url": "https://github.com/abonzo", "followers_url": "https://api.github.com/users/abonzo/followers", "following_url": "https://api.github.com/users/abonzo/following{/other_user}", "gists_url": "https://api.github.com/users/abonzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonzo/subscriptions", "organizations_url": "https://api.github.com/users/abonzo/orgs", "repos_url": "https://api.github.com/users/abonzo/repos", "events_url": "https://api.github.com/users/abonzo/events{/privacy}", "received_events_url": "https://api.github.com/users/abonzo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c61f6330e845b0f734f657711bae897f5b0ae1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c61f6330e845b0f734f657711bae897f5b0ae1c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c61f6330e845b0f734f657711bae897f5b0ae1c0"}], "stats": {"total": 161, "additions": 155, "deletions": 6}, "files": [{"sha": "4c5932d9e30619aa3977779706c4bf4b900062f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00c4e97c949ee249c6ed983945d9c0e369dce6e2", "patch": "@@ -1,3 +1,18 @@\n+2010-12-07  Andrey Belevantsev  <abel@ispras.ru>\n+\n+\tPR target/43603\n+\t* haifa-sched.c (sched_create_recovery_edges): Update\n+\tdominator info.\n+\t* sel-sched-ir.c (maybe_tidy_empty_bb): Update dominator info\n+\tafter deleting an empty block.\n+\t(tidy_control_flow): Also verify dominators.\n+\t(sel_remove_bb): Update dominator info after removing a block.\n+\t(sel_redirect_edge_and_branch_force): Assert that no unreachable\n+\tblocks will be created. Update dominator info.\n+\t(sel_redirect_edge_and_branch): Update dominator info when\n+\tbasic blocks do not become unreachable.\n+\t(sel_remove_loop_preheader): Update dominator info. \n+\n 2010-12-07  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):"}, {"sha": "bd3b84c5c2306db3858d4ab1393cd01d0aec98c1", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=00c4e97c949ee249c6ed983945d9c0e369dce6e2", "patch": "@@ -4467,6 +4467,8 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n     edge_flags = 0;\n \n   make_single_succ_edge (rec, second_bb, edge_flags);\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    set_immediate_dominator (CDI_DOMINATORS, rec, first_bb);\n }\n \n /* This function creates recovery code for INSN.  If MUTATE_P is nonzero,"}, {"sha": "e1c687641840c50f192dc48b2241f12fbd4a7e4c", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=00c4e97c949ee249c6ed983945d9c0e369dce6e2", "patch": "@@ -3571,6 +3571,7 @@ static bool\n maybe_tidy_empty_bb (basic_block bb)\n {\n   basic_block succ_bb, pred_bb;\n+  VEC (basic_block, heap) *dom_bbs;\n   edge e;\n   edge_iterator ei;\n   bool rescan_p;\n@@ -3606,6 +3607,7 @@ maybe_tidy_empty_bb (basic_block bb)\n   succ_bb = single_succ (bb);\n   rescan_p = true;\n   pred_bb = NULL;\n+  dom_bbs = NULL;\n \n   /* Redirect all non-fallthru edges to the next bb.  */\n   while (rescan_p)\n@@ -3619,7 +3621,14 @@ maybe_tidy_empty_bb (basic_block bb)\n           if (!(e->flags & EDGE_FALLTHRU))\n             {\n \t      /* We can not invalidate computed topological order by moving\n-\t         the edge destination block (E->SUCC) along a fallthru edge.  */\n+\t         the edge destination block (E->SUCC) along a fallthru edge.\n+\n+\t\t We will update dominators here only when we'll get\n+\t\t an unreachable block when redirecting, otherwise\n+\t\t sel_redirect_edge_and_branch will take care of it.  */\n+\t      if (e->dest != bb\n+\t\t  && single_pred_p (e->dest))\n+\t\tVEC_safe_push (basic_block, heap, dom_bbs, e->dest);\n               sel_redirect_edge_and_branch (e, succ_bb);\n               rescan_p = true;\n               break;\n@@ -3656,6 +3665,13 @@ maybe_tidy_empty_bb (basic_block bb)\n       remove_empty_bb (bb, true);\n     }\n \n+  if (!VEC_empty (basic_block, dom_bbs))\n+    {\n+      VEC_safe_push (basic_block, heap, dom_bbs, succ_bb);\n+      iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n+      VEC_free (basic_block, heap, dom_bbs);\n+    }\n+\n   return true;\n }\n \n@@ -3740,6 +3756,7 @@ tidy_control_flow (basic_block xbb, bool full_tidying)\n \n #ifdef ENABLE_CHECKING\n   verify_backedges ();\n+  verify_dominators (CDI_DOMINATORS);\n #endif\n \n   return changed;\n@@ -5075,7 +5092,12 @@ sel_remove_bb (basic_block bb, bool remove_from_cfg_p)\n   bitmap_clear_bit (blocks_to_reschedule, idx);\n \n   if (remove_from_cfg_p)\n-    delete_and_free_basic_block (bb);\n+    {\n+      basic_block succ = single_succ (bb);\n+      delete_and_free_basic_block (bb);\n+      set_immediate_dominator (CDI_DOMINATORS, succ,\n+                               recompute_dominator (CDI_DOMINATORS, succ));\n+    }\n \n   rgn_setup_region (CONTAINING_RGN (idx));\n }\n@@ -5410,12 +5432,15 @@ sel_merge_blocks (basic_block a, basic_block b)\n void\n sel_redirect_edge_and_branch_force (edge e, basic_block to)\n {\n-  basic_block jump_bb, src;\n+  basic_block jump_bb, src, orig_dest = e->dest;\n   int prev_max_uid;\n   rtx jump;\n \n-  gcc_assert (!sel_bb_empty_p (e->src));\n-\n+  /* This function is now used only for bookkeeping code creation, where\n+     we'll never get the single pred of orig_dest block and thus will not\n+     hit unreachable blocks when updating dominator info.  */\n+  gcc_assert (!sel_bb_empty_p (e->src)\n+              && !single_pred_p (orig_dest));\n   src = e->src;\n   prev_max_uid = get_max_uid ();\n   jump_bb = redirect_edge_and_branch_force (e, to);\n@@ -5432,6 +5457,10 @@ sel_redirect_edge_and_branch_force (edge e, basic_block to)\n   jump = find_new_jump (src, jump_bb, prev_max_uid);\n   if (jump)\n     sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP);\n+  set_immediate_dominator (CDI_DOMINATORS, to,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, to));\n+  set_immediate_dominator (CDI_DOMINATORS, orig_dest,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, orig_dest));\n }\n \n /* A wrapper for redirect_edge_and_branch.  Return TRUE if blocks connected by\n@@ -5440,11 +5469,12 @@ bool\n sel_redirect_edge_and_branch (edge e, basic_block to)\n {\n   bool latch_edge_p;\n-  basic_block src;\n+  basic_block src, orig_dest = e->dest;\n   int prev_max_uid;\n   rtx jump;\n   edge redirected;\n   bool recompute_toporder_p = false;\n+  bool maybe_unreachable = single_pred_p (orig_dest);\n \n   latch_edge_p = (pipelining_p\n                   && current_loop_nest\n@@ -5475,6 +5505,15 @@ sel_redirect_edge_and_branch (edge e, basic_block to)\n   if (jump)\n     sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP);\n \n+  /* Only update dominator info when we don't have unreachable blocks.\n+     Otherwise we'll update in maybe_tidy_empty_bb.  */\n+  if (!maybe_unreachable)\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, to,\n+                               recompute_dominator (CDI_DOMINATORS, to));\n+      set_immediate_dominator (CDI_DOMINATORS, orig_dest,\n+                               recompute_dominator (CDI_DOMINATORS, orig_dest));\n+    }\n   return recompute_toporder_p;\n }\n \n@@ -6201,6 +6240,10 @@ sel_remove_loop_preheader (void)\n                   if (BB_END (prev_bb) == bb_note (prev_bb))\n                     free_data_sets (prev_bb);\n                 }\n+\n+              set_immediate_dominator (CDI_DOMINATORS, next_bb,\n+                                       recompute_dominator (CDI_DOMINATORS,\n+                                                            next_bb));\n             }\n         }\n       VEC_free (basic_block, heap, preheader_blocks);"}, {"sha": "8743d366b79219c13f7e29fe8a77050b8c3c4a48", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=00c4e97c949ee249c6ed983945d9c0e369dce6e2", "patch": "@@ -1,3 +1,9 @@\n+2010-12-07  Andrey Belevantsev  <abel@ispras.ru>\n+\n+\tPR target/43603\n+\t* gcc.target/ia64/pr43603.c: New.\n+\t* gcc/testsuite/g++.dg/opt/pr46640.C: New.\n+\n 2010-12-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/44352"}, {"sha": "0892c9ac861cd05b36a0f76f2ca40253288aa34e", "filename": "gcc/testsuite/g++.dg/opt/pr46640.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr46640.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr46640.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr46640.C?ref=00c4e97c949ee249c6ed983945d9c0e369dce6e2", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile { target x86_64-*-* } }\n+// { dg-options \"-fschedule-insns2 -fsel-sched-pipelining -fselective-scheduling2 -fno-exceptions -O\" }\n+\n+struct QBasicAtomicInt\n+{\n+  int i, j;\n+  bool deref ()\n+  {\n+    asm volatile (\"\":\"=m\" (i), \"=qm\" (j));\n+  }\n+};\n+\n+struct Data\n+{\n+  QBasicAtomicInt ref;\n+  void *data;\n+};\n+\n+struct QByteArray\n+{\n+  Data * d;\n+  ~QByteArray ()\n+  {\n+    d->ref.deref ();\n+  }\n+};\n+\n+int indexOf (unsigned);\n+int stat (void *, int *);\n+QByteArray encodeName ();\n+\n+bool makeDir (unsigned len)\n+{\n+  unsigned i = 0;\n+  while (len)\n+    {\n+      int st;\n+      int pos = indexOf (i);\n+      QByteArray baseEncoded = encodeName ();\n+      if (stat (baseEncoded.d->data, &st) && stat (baseEncoded.d, &st))\n+        return false;\n+      i = pos;\n+    }\n+}"}, {"sha": "ad3a5b114bc965c5e5320982b7b9c63fad8837ac", "filename": "gcc/testsuite/gcc.target/ia64/pr43603.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr43603.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4e97c949ee249c6ed983945d9c0e369dce6e2/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr43603.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr43603.c?ref=00c4e97c949ee249c6ed983945d9c0e369dce6e2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+int \n+foo( long * np, int * dp, int qn)\n+{\n+  int i;\n+  int n0;\n+  int d0;\n+  int a;\n+  int b;\n+  int c;\n+  int d;\n+\n+  a = 1;\n+  b = 0;\n+  c = 1;\n+  d = 1;\n+\n+  d0 = dp[0];\n+\n+  for (i = qn; i >= 0; i--) {\n+    if (bar((c == 0)) && (np[1] == d0)) {\n+      car(np - 3, dp, 3);\n+    } else { \n+      __asm__ (\"xma.hu %0 = %2, %3, f0\\n\\txma.l %1 = %2, %3, f0\" : \"=&f\" ((a)), \n+\"=f\" (b) : \"f\" ((c)), \"f\" ((d))); \n+      n0 = np[0]; \n+      if (n0 < d0) \n+        c = 1; \n+      else \n+        c = 0; \n+\n+    }\n+    *--np = a;\n+  }\n+\n+  return 0;\n+}"}]}