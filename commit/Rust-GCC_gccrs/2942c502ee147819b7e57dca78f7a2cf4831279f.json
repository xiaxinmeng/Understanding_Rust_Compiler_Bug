{"sha": "2942c502ee147819b7e57dca78f7a2cf4831279f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0MmM1MDJlZTE0NzgxOWI3ZTU3ZGNhNzhmN2EyY2Y0ODMxMjc5Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-29T07:10:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-29T07:10:38Z"}, "message": "* lto-symtab.c (lto_symtab_entry_def) Add vnode.\n\n\t(lto_varpool_replace_node): New.\n\t(lto_symtab_resolve_symbols): Resolve varpool nodes.\n\t(lto_symtab_merge_decls_1): Prefer decls with varpool node.\n\t(lto_symtab_merge_cgraph_nodes_1): Merge varpools.\n\t* cgraph.h (varpool_node_ptr): New type.\n\t(varpool_node_ptr): New vector.\n\t(varpool_node_set_def): New structure.\n\t(varpool_node_set): New type.\n\t(varpool_node_set): New vector.\n\t(varpool_node_set_element_def): New structure.\n\t(varpool_node_set_element, const_varpool_node_set_element): New types.\n\t(varpool_node_set_iterator): New type.\n\t(varpool_node): Add prev pointers, add used_from_other_partition,\n\tin_other_partition.\n\t(varpool_node_set_new, varpool_node_set_find, varpool_node_set_add,\n\tvarpool_node_set_remove, dump_varpool_node_set, debug_varpool_node_set,\n\tvarpool_get_node, varpool_remove_node): Declare.\n\t(vsi_end_p, vsi_next, vsi_node, vsi_start, varpool_node_in_set_p,\n\tvarpool_node_set_size): New inlines.\n\t* cgraph.c (dump_cgraph_node): Dump asm names of aliases.\n\t* tree-pass.h (varpool_node_set_def): Forward declare.\n\t(ipa_opt_pass_d): Summary writting takes vnode sets too.\n\t(ipa_write_optimization_summaries): Update prototype.\n\t* ipa-cp.c (ipcp_write_summary): Update.\n\t* ipa-reference.c (ipa_reference_write_summary): Update.\n\t* lto-cgraph.c (lto_output_varpool_node): New static function.\n\t(output_varpool): New function.\n\t(input_varpool_node): New static function.\n\t(input_varpool_1): New function.\n\t(input_cgraph): Input varpool.\n\t* ipa-pure-const.c (pure_const_write_summary): Update.\n\t* lto-streamer-out.c (lto_output): Update, output varpool too.\n\t(write_global_stream): Kill WPA hack.\n\t(produce_asm_for_decls): Update.\n\t(output_alias_pair_p): Handle variables.\n\t(output_unreferenced_globals): Output only needed partition of varpool.\n\t* ipa-inline.c (inline_write_summary): Update.\n\t* lto-streamer-in.c (lto_input_tree_ref, lto_input_tree): Do not build cgraph.\n\t* lto-section-in.c (lto_section_name): Add varpool and jump funcs.\n\t* ipa.c (hash_varpool_node_set_element, eq_varpool_node_set_element,\n\tvarpool_node_set_new, varpool_node_set_add,\n\tvarpool_node_set_remove, varpool_node_set_find, dump_varpool_node_set,\n\tdebug_varpool_node_set): New functions.\n\t* passes.c (rest_of_decl_compilation): when in LTO do not finalize.\n\t(execute_one_pass): Process new decls too.\n\t(ipa_write_summaries_2): Pass around vsets.\n\t(ipa_write_summaries_1): Likewise.\n\t(ipa_write_summaries): Build vset; be more selective about cgraph nodes\n\tto add.\n\t(ipa_write_optimization_summaries_1): Pass around vsets.\n\t(ipa_write_optimization_summaries): Likewise.\n\t* varpool.c (varpool_get_node): New.\n\t(varpool_node): Update doubly linked lists.\n\t(varpool_remove_node): New.\n\t(dump_varpool_node): More dumping.\n\t(varpool_enqueue_needed_node): Update doubly linked lists.\n\t(decide_is_variable_needed): Kill ltrans hack.\n\t(varpool_finalize_decl): Kill lto hack.\n\t(varpool_assemble_decl): Skip decls in other partitions.\n\t(varpool_assemble_pending_decls): Update doubly linkes lists.\n\t(varpool_empty_needed_queue): Likewise.\n\t(varpool_extra_name_alias): Likewise.\n\t* lto-streamer.c (lto_get_section_name): Add vars section.\n\t* lto-streamer.h (lto_section_type): Update.\n\t(output_varpool, input_varpool): Declare.\n\n\t* lto.c (lto_varpool_node_sets): New.\n\t(lto_1_to_1_map): Partition varpool too.\n\t(globalize_context_t, globalize_cross_file_statics,\n\tlto_scan_statics_in_ref_table, lto_scan_statics_in_cgraph_node,\n\tlto_scan_statics_in_remaining_global_vars): Remove.\n\t(lto_promote_cross_file_statics): Rewrite.\n\t(get_filename_for_set): Take vset argument.\n\t(lto_wpa_write_files): Pass around vsets.\n\nFrom-SVN: r158854", "tree": {"sha": "517f6bc2231e5c3e319637f9c9277e4cc2e99ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/517f6bc2231e5c3e319637f9c9277e4cc2e99ffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2942c502ee147819b7e57dca78f7a2cf4831279f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2942c502ee147819b7e57dca78f7a2cf4831279f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2942c502ee147819b7e57dca78f7a2cf4831279f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2942c502ee147819b7e57dca78f7a2cf4831279f/comments", "author": null, "committer": null, "parents": [{"sha": "74ca33936f5a1c543a71033f32d59b8d2e0957a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74ca33936f5a1c543a71033f32d59b8d2e0957a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74ca33936f5a1c543a71033f32d59b8d2e0957a4"}], "stats": {"total": 1076, "additions": 757, "deletions": 319}, "files": [{"sha": "6da5d352b55b2fbc30637e95f5538b0c995cd9c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -1,3 +1,72 @@\n+2010-04-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_symtab_entry_def) Add vnode.\n+\t(lto_varpool_replace_node): New.\n+\t(lto_symtab_resolve_symbols): Resolve varpool nodes.\n+\t(lto_symtab_merge_decls_1): Prefer decls with varpool node.\n+\t(lto_symtab_merge_cgraph_nodes_1): Merge varpools.\n+\t* cgraph.h (varpool_node_ptr): New type.\n+\t(varpool_node_ptr): New vector.\n+\t(varpool_node_set_def): New structure.\n+\t(varpool_node_set): New type.\n+\t(varpool_node_set): New vector.\n+\t(varpool_node_set_element_def): New structure.\n+\t(varpool_node_set_element, const_varpool_node_set_element): New types.\n+\t(varpool_node_set_iterator): New type.\n+\t(varpool_node): Add prev pointers, add used_from_other_partition,\n+\tin_other_partition.\n+\t(varpool_node_set_new, varpool_node_set_find, varpool_node_set_add,\n+\tvarpool_node_set_remove, dump_varpool_node_set, debug_varpool_node_set,\n+\tvarpool_get_node, varpool_remove_node): Declare.\n+\t(vsi_end_p, vsi_next, vsi_node, vsi_start, varpool_node_in_set_p,\n+\tvarpool_node_set_size): New inlines.\n+\t* cgraph.c (dump_cgraph_node): Dump asm names of aliases.\n+\t* tree-pass.h (varpool_node_set_def): Forward declare.\n+\t(ipa_opt_pass_d): Summary writting takes vnode sets too.\n+\t(ipa_write_optimization_summaries): Update prototype.\n+\t* ipa-cp.c (ipcp_write_summary): Update.\n+\t* ipa-reference.c (ipa_reference_write_summary): Update.\n+\t* lto-cgraph.c (lto_output_varpool_node): New static function.\n+\t(output_varpool): New function.\n+\t(input_varpool_node): New static function.\n+\t(input_varpool_1): New function.\n+\t(input_cgraph): Input varpool.\n+\t* ipa-pure-const.c (pure_const_write_summary): Update.\n+\t* lto-streamer-out.c (lto_output): Update, output varpool too.\n+\t(write_global_stream): Kill WPA hack.\n+\t(produce_asm_for_decls): Update.\n+\t(output_alias_pair_p): Handle variables.\n+\t(output_unreferenced_globals): Output only needed partition of varpool.\n+\t* ipa-inline.c (inline_write_summary): Update.\n+\t* lto-streamer-in.c (lto_input_tree_ref, lto_input_tree): Do not build cgraph.\n+\t* lto-section-in.c (lto_section_name): Add varpool and jump funcs.\n+\t* ipa.c (hash_varpool_node_set_element, eq_varpool_node_set_element,\n+\tvarpool_node_set_new, varpool_node_set_add,\n+\tvarpool_node_set_remove, varpool_node_set_find, dump_varpool_node_set,\n+\tdebug_varpool_node_set): New functions.\n+\t* passes.c (rest_of_decl_compilation): when in LTO do not finalize.\n+\t(execute_one_pass): Process new decls too.\n+\t(ipa_write_summaries_2): Pass around vsets.\n+\t(ipa_write_summaries_1): Likewise.\n+\t(ipa_write_summaries): Build vset; be more selective about cgraph nodes\n+\tto add.\n+\t(ipa_write_optimization_summaries_1): Pass around vsets.\n+\t(ipa_write_optimization_summaries): Likewise.\n+\t* varpool.c (varpool_get_node): New.\n+\t(varpool_node): Update doubly linked lists.\n+\t(varpool_remove_node): New.\n+\t(dump_varpool_node): More dumping.\n+\t(varpool_enqueue_needed_node): Update doubly linked lists.\n+\t(decide_is_variable_needed): Kill ltrans hack.\n+\t(varpool_finalize_decl): Kill lto hack.\n+\t(varpool_assemble_decl): Skip decls in other partitions.\n+\t(varpool_assemble_pending_decls): Update doubly linkes lists.\n+\t(varpool_empty_needed_queue): Likewise.\n+\t(varpool_extra_name_alias): Likewise.\n+\t* lto-streamer.c (lto_get_section_name): Add vars section.\n+\t* lto-streamer.h (lto_section_type): Update.\n+\t(output_varpool, input_varpool): Declare.\n+\n 2010-04-28  Mike Stump  <mikestump@comcast.net>\n \n \t* config/i386/darwin.h (CC1_SPEC): Ignore -mdynamic-no-pic for now."}, {"sha": "424c3f21aeb472a0557bbd10b5e8b9710352f635", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -1877,6 +1877,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t\t       (int)n->thunk.virtual_offset_p);\n \t      fprintf (f, \")\");\n \t    }\n+\t  if (DECL_ASSEMBLER_NAME_SET_P (n->decl))\n+\t    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->decl)));\n \t}\n       fprintf (f, \"\\n\");\n     }"}, {"sha": "f063cb4a41fdd923690e417351631187e721398f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 104, "deletions": 3, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -274,7 +274,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n-  /* Set when function is available in the other LTO partition.  */\n+  /* Set when function is available in the other LTRANS partition.  */\n   unsigned in_other_partition : 1;\n   /* Set when function is scheduled to be processed by local passes.  */\n   unsigned process : 1;\n@@ -305,12 +305,33 @@ struct GTY(()) cgraph_node_set_def\n   PTR GTY ((skip)) aux;\n };\n \n+typedef struct varpool_node *varpool_node_ptr;\n+\n+DEF_VEC_P(varpool_node_ptr);\n+DEF_VEC_ALLOC_P(varpool_node_ptr,heap);\n+DEF_VEC_ALLOC_P(varpool_node_ptr,gc);\n+\n+/* A varpool node set is a collection of varpool nodes.  A varpool node\n+   can appear in multiple sets.  */\n+struct GTY(()) varpool_node_set_def\n+{\n+  htab_t GTY((param_is (struct varpool_node_set_element_def))) hashtab;\n+  VEC(varpool_node_ptr, gc) *nodes;\n+  PTR GTY ((skip)) aux;\n+};\n+\n typedef struct cgraph_node_set_def *cgraph_node_set;\n \n DEF_VEC_P(cgraph_node_set);\n DEF_VEC_ALLOC_P(cgraph_node_set,gc);\n DEF_VEC_ALLOC_P(cgraph_node_set,heap);\n \n+typedef struct varpool_node_set_def *varpool_node_set;\n+\n+DEF_VEC_P(varpool_node_set);\n+DEF_VEC_ALLOC_P(varpool_node_set,gc);\n+DEF_VEC_ALLOC_P(varpool_node_set,heap);\n+\n /* A cgraph node set element contains an index in the vector of nodes in\n    the set.  */\n struct GTY(()) cgraph_node_set_element_def\n@@ -329,6 +350,24 @@ typedef struct\n   unsigned index;\n } cgraph_node_set_iterator;\n \n+/* A varpool node set element contains an index in the vector of nodes in\n+   the set.  */\n+struct GTY(()) varpool_node_set_element_def\n+{\n+  struct varpool_node *node;\n+  HOST_WIDE_INT index;\n+};\n+\n+typedef struct varpool_node_set_element_def *varpool_node_set_element;\n+typedef const struct varpool_node_set_element_def *const_varpool_node_set_element;\n+\n+/* Iterator structure for varpool node sets.  */\n+typedef struct\n+{\n+  varpool_node_set set;\n+  unsigned index;\n+} varpool_node_set_iterator;\n+\n #define DEFCIFCODE(code, string)\tCIF_ ## code,\n /* Reasons for inlining failures.  */\n typedef enum {\n@@ -398,9 +437,9 @@ DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n struct GTY((chain_next (\"%h.next\"))) varpool_node {\n   tree decl;\n   /* Pointer to the next function in varpool_nodes.  */\n-  struct varpool_node *next;\n+  struct varpool_node *next, *prev;\n   /* Pointer to the next function in varpool_nodes_queue.  */\n-  struct varpool_node *next_needed;\n+  struct varpool_node *next_needed, *prev_needed;\n   /* For normal nodes a pointer to the first extra name alias.  For alias\n      nodes a pointer to the normal node.  */\n   struct varpool_node *extra_name;\n@@ -425,6 +464,10 @@ struct GTY((chain_next (\"%h.next\"))) varpool_node {\n   /* Set for aliases once they got through assemble_alias.  Also set for\n      extra name aliases in varpool_extra_name_alias.  */\n   unsigned alias : 1;\n+  /* Set when variable is used from other LTRANS partition.  */\n+  unsigned used_from_other_partition : 1;\n+  /* Set when variable is available in the other LTRANS partition.  */\n+  unsigned in_other_partition : 1;\n };\n \n /* Every top level asm statement is put into a cgraph_asm_node.  */\n@@ -594,6 +637,13 @@ void cgraph_node_set_remove (cgraph_node_set, struct cgraph_node *);\n void dump_cgraph_node_set (FILE *, cgraph_node_set);\n void debug_cgraph_node_set (cgraph_node_set);\n \n+varpool_node_set varpool_node_set_new (void);\n+varpool_node_set_iterator varpool_node_set_find (varpool_node_set,\n+\t\t\t\t\t       struct varpool_node *);\n+void varpool_node_set_add (varpool_node_set, struct varpool_node *);\n+void varpool_node_set_remove (varpool_node_set, struct varpool_node *);\n+void dump_varpool_node_set (FILE *, varpool_node_set);\n+void debug_varpool_node_set (varpool_node_set);\n \n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n@@ -616,6 +666,9 @@ void cgraph_make_decl_local (tree);\n void cgraph_make_node_local (struct cgraph_node *);\n bool cgraph_node_can_be_local_p (struct cgraph_node *);\n \n+\n+struct varpool_node * varpool_get_node (tree decl);\n+void varpool_remove_node (struct varpool_node *node);\n bool varpool_assemble_pending_decls (void);\n bool varpool_assemble_decl (struct varpool_node *node);\n bool varpool_analyze_pending_decls (void);\n@@ -734,6 +787,54 @@ cgraph_node_set_size (cgraph_node_set set)\n   return htab_elements (set->hashtab);\n }\n \n+/* Return true if iterator VSI points to nothing.  */\n+static inline bool\n+vsi_end_p (varpool_node_set_iterator vsi)\n+{\n+  return vsi.index >= VEC_length (varpool_node_ptr, vsi.set->nodes);\n+}\n+\n+/* Advance iterator VSI.  */\n+static inline void\n+vsi_next (varpool_node_set_iterator *vsi)\n+{\n+  vsi->index++;\n+}\n+\n+/* Return the node pointed to by VSI.  */\n+static inline struct varpool_node *\n+vsi_node (varpool_node_set_iterator vsi)\n+{\n+  return VEC_index (varpool_node_ptr, vsi.set->nodes, vsi.index);\n+}\n+\n+/* Return an iterator to the first node in SET.  */\n+static inline varpool_node_set_iterator\n+vsi_start (varpool_node_set set)\n+{\n+  varpool_node_set_iterator vsi;\n+\n+  vsi.set = set;\n+  vsi.index = 0;\n+  return vsi;\n+}\n+\n+/* Return true if SET contains NODE.  */\n+static inline bool\n+varpool_node_in_set_p (struct varpool_node *node, varpool_node_set set)\n+{\n+  varpool_node_set_iterator vsi;\n+  vsi = varpool_node_set_find (set, node);\n+  return !vsi_end_p (vsi);\n+}\n+\n+/* Return number of nodes in SET.  */\n+static inline size_t\n+varpool_node_set_size (varpool_node_set set)\n+{\n+  return htab_elements (set->hashtab);\n+}\n+\n /* Uniquize all constants that appear in memory.\n    Each constant in memory thus far output is recorded\n    in `const_desc_table'.  */"}, {"sha": "cd67f2a7a59e38ba906f5b8d81f8c3cb360f0e56", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -382,6 +382,7 @@ cgraph_process_new_functions (void)\n   tree fndecl;\n   struct cgraph_node *node;\n \n+  varpool_analyze_pending_decls ();\n   /*  Note that this queue may grow as its being processed, as the new\n       functions may generate new ones.  */\n   while (cgraph_new_nodes)\n@@ -437,6 +438,7 @@ cgraph_process_new_functions (void)\n \t  break;\n \t}\n       cgraph_call_function_insertion_hooks (node);\n+      varpool_analyze_pending_decls ();\n     }\n   return output;\n }"}, {"sha": "6e83b899b439647568a1f2abc19a335a23decc41", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -1304,7 +1304,8 @@ ipcp_generate_summary (void)\n \n /* Write ipcp summary for nodes in SET.  */\n static void\n-ipcp_write_summary (cgraph_node_set set)\n+ipcp_write_summary (cgraph_node_set set,\n+\t\t    varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   ipa_prop_write_jump_functions (set);\n }"}, {"sha": "5146c3c3cadb95e3b4009e38a87bc0d40579ee46", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -2097,7 +2097,8 @@ inline_read_summary (void)\n    active, we don't need to write them twice.  */\n \n static void\n-inline_write_summary (cgraph_node_set set)\n+inline_write_summary (cgraph_node_set set,\n+\t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   if (flag_indirect_inlining && !flag_ipa_cp)\n     ipa_prop_write_jump_functions (set);"}, {"sha": "b7a8de3540d1b6b2b604e4ac580c5e54fe067a6e", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -771,7 +771,8 @@ generate_summary (void)\n /* Serialize the ipa info for lto.  */\n \n static void\n-pure_const_write_summary (cgraph_node_set set)\n+pure_const_write_summary (cgraph_node_set set,\n+\t\t\t  varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   struct cgraph_node *node;\n   struct lto_simple_output_block *ob"}, {"sha": "2617072eb8a185aa27efc0a2e3674d66f054b8f8", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -1040,7 +1040,8 @@ write_node_summary_p (struct cgraph_node *node)\n /* Serialize the ipa info for lto.  */\n \n static void\n-ipa_reference_write_summary (cgraph_node_set set)\n+ipa_reference_write_summary (cgraph_node_set set,\n+\t\t\t     varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   struct cgraph_node *node;\n   struct lto_simple_output_block *ob"}, {"sha": "36fe714abb3c0358eafc90c079ec093950971a21", "filename": "gcc/ipa.c", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -762,6 +762,164 @@ debug_cgraph_node_set (cgraph_node_set set)\n   dump_cgraph_node_set (stderr, set);\n }\n \n+/* Hash a varpool node set element.  */\n+\n+static hashval_t\n+hash_varpool_node_set_element (const void *p)\n+{\n+  const_varpool_node_set_element element = (const_varpool_node_set_element) p;\n+  return htab_hash_pointer (element->node);\n+}\n+\n+/* Compare two varpool node set elements.  */\n+\n+static int\n+eq_varpool_node_set_element (const void *p1, const void *p2)\n+{\n+  const_varpool_node_set_element e1 = (const_varpool_node_set_element) p1;\n+  const_varpool_node_set_element e2 = (const_varpool_node_set_element) p2;\n+\n+  return e1->node == e2->node;\n+}\n+\n+/* Create a new varpool node set.  */\n+\n+varpool_node_set\n+varpool_node_set_new (void)\n+{\n+  varpool_node_set new_node_set;\n+\n+  new_node_set = GGC_NEW (struct varpool_node_set_def);\n+  new_node_set->hashtab = htab_create_ggc (10,\n+\t\t\t\t\t   hash_varpool_node_set_element,\n+\t\t\t\t\t   eq_varpool_node_set_element,\n+\t\t\t\t\t   NULL);\n+  new_node_set->nodes = NULL;\n+  return new_node_set;\n+}\n+\n+/* Add varpool_node NODE to varpool_node_set SET.  */\n+\n+void\n+varpool_node_set_add (varpool_node_set set, struct varpool_node *node)\n+{\n+  void **slot;\n+  varpool_node_set_element element;\n+  struct varpool_node_set_element_def dummy;\n+\n+  dummy.node = node;\n+  slot = htab_find_slot (set->hashtab, &dummy, INSERT);\n+\n+  if (*slot != HTAB_EMPTY_ENTRY)\n+    {\n+      element = (varpool_node_set_element) *slot;\n+      gcc_assert (node == element->node\n+\t\t  && (VEC_index (varpool_node_ptr, set->nodes, element->index)\n+\t\t      == node));\n+      return;\n+    }\n+\n+  /* Insert node into hash table.  */\n+  element =\n+    (varpool_node_set_element) GGC_NEW (struct varpool_node_set_element_def);\n+  element->node = node;\n+  element->index = VEC_length (varpool_node_ptr, set->nodes);\n+  *slot = element;\n+\n+  /* Insert into node vector.  */\n+  VEC_safe_push (varpool_node_ptr, gc, set->nodes, node);\n+}\n+\n+/* Remove varpool_node NODE from varpool_node_set SET.  */\n+\n+void\n+varpool_node_set_remove (varpool_node_set set, struct varpool_node *node)\n+{\n+  void **slot, **last_slot;\n+  varpool_node_set_element element, last_element;\n+  struct varpool_node *last_node;\n+  struct varpool_node_set_element_def dummy;\n+\n+  dummy.node = node;\n+  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n+  if (slot == NULL)\n+    return;\n+\n+  element = (varpool_node_set_element) *slot;\n+  gcc_assert (VEC_index (varpool_node_ptr, set->nodes, element->index)\n+\t      == node);\n+\n+  /* Remove from vector. We do this by swapping node with the last element\n+     of the vector.  */\n+  last_node = VEC_pop (varpool_node_ptr, set->nodes);\n+  if (last_node != node)\n+    {\n+      dummy.node = last_node;\n+      last_slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n+      last_element = (varpool_node_set_element) *last_slot;\n+      gcc_assert (last_element);\n+\n+      /* Move the last element to the original spot of NODE.  */\n+      last_element->index = element->index;\n+      VEC_replace (varpool_node_ptr, set->nodes, last_element->index,\n+\t\t   last_node);\n+    }\n+\n+  /* Remove element from hash table.  */\n+  htab_clear_slot (set->hashtab, slot);\n+  ggc_free (element);\n+}\n+\n+/* Find NODE in SET and return an iterator to it if found.  A null iterator\n+   is returned if NODE is not in SET.  */\n+\n+varpool_node_set_iterator\n+varpool_node_set_find (varpool_node_set set, struct varpool_node *node)\n+{\n+  void **slot;\n+  struct varpool_node_set_element_def dummy;\n+  varpool_node_set_element element;\n+  varpool_node_set_iterator vsi;\n+\n+  dummy.node = node;\n+  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n+  if (slot == NULL)\n+    vsi.index = (unsigned) ~0;\n+  else\n+    {\n+      element = (varpool_node_set_element) *slot;\n+      gcc_assert (VEC_index (varpool_node_ptr, set->nodes, element->index)\n+\t\t  == node);\n+      vsi.index = element->index;\n+    }\n+  vsi.set = set;\n+\n+  return vsi;\n+}\n+\n+/* Dump content of SET to file F.  */\n+\n+void\n+dump_varpool_node_set (FILE *f, varpool_node_set set)\n+{\n+  varpool_node_set_iterator iter;\n+\n+  for (iter = vsi_start (set); !vsi_end_p (iter); vsi_next (&iter))\n+    {\n+      struct varpool_node *node = vsi_node (iter);\n+      dump_varpool_node (f, node);\n+    }\n+}\n+\n+/* Dump content of SET to stderr.  */\n+\n+void\n+debug_varpool_node_set (varpool_node_set set)\n+{\n+  dump_varpool_node_set (stderr, set);\n+}\n+\n+\n /* Simple ipa profile pass propagating frequencies across the callgraph.  */\n \n static unsigned int"}, {"sha": "6405432da3be9439091f285bb3341f59acc3178a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -378,6 +378,45 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     lto_output_uleb128_stream (ob->main_stream, 0);\n }\n \n+/* Output the varpool NODE to OB. \n+   If NODE is not in SET, then NODE is a boundary.  */\n+\n+static void\n+lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n+\t\t         varpool_node_set set)\n+{\n+  bool boundary_p = !varpool_node_in_set_p (node, set) && node->analyzed;\n+  struct bitpack_d *bp;\n+  struct varpool_node *alias;\n+  int count = 0;\n+\n+  lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n+  bp = bitpack_create ();\n+  bp_pack_value (bp, node->externally_visible, 1);\n+  bp_pack_value (bp, node->force_output, 1);\n+  bp_pack_value (bp, node->finalized, 1);\n+  gcc_assert (node->finalized || !node->analyzed);\n+  gcc_assert (node->needed);\n+  gcc_assert (!node->alias);\n+  /* FIXME: We have no idea how we move references around.  For moment assume that\n+     everything is used externally.  */\n+  bp_pack_value (bp, flag_wpa, 1);  /* used_from_other_parition.  */\n+  bp_pack_value (bp, boundary_p, 1);  /* in_other_partition.  */\n+  /* Also emit any extra name aliases.  */\n+  for (alias = node->extra_name; alias; alias = alias->next)\n+    count++;\n+  bp_pack_value (bp, count != 0, 1);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+\n+  if (count)\n+    {\n+      lto_output_uleb128_stream (ob->main_stream, count);\n+      for (alias = node->extra_name; alias; alias = alias->next)\n+\tlto_output_var_decl_index (ob->decl_state, ob->main_stream, alias->decl);\n+    }\n+}\n+\n /* Stream out profile_summary to OB.  */\n \n static void\n@@ -564,6 +603,32 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n }\n \n+/* Output the part of the cgraph in SET.  */\n+\n+void\n+output_varpool (varpool_node_set set)\n+{\n+  struct varpool_node *node;\n+  struct lto_simple_output_block *ob;\n+  int len = 0;\n+\n+  ob = lto_create_simple_output_block (LTO_section_varpool);\n+\n+  for (node = varpool_nodes; node; node = node->next)\n+    if (node->needed && node->analyzed)\n+      len++;\n+\n+  lto_output_uleb128_stream (ob->main_stream, len);\n+\n+  /* Write out the nodes.  We must first output a node and then its clones,\n+     otherwise at a time reading back the node there would be nothing to clone\n+     from.  */\n+  for (node = varpool_nodes; node; node = node->next)\n+    if (node->needed && node->analyzed)\n+      lto_output_varpool_node (ob, node, set);\n+\n+  lto_destroy_simple_output_block (ob);\n+}\n \n /* Read a node from input_block IB.  TAG is the node's tag just read.\n    Return the node read or overwriten.  */\n@@ -683,6 +748,48 @@ input_node (struct lto_file_decl_data *file_data,\n   return node;\n }\n \n+/* Read a node from input_block IB.  TAG is the node's tag just read.\n+   Return the node read or overwriten.  */\n+\n+static struct varpool_node *\n+input_varpool_node (struct lto_file_decl_data *file_data,\n+\t\t    struct lto_input_block *ib)\n+{\n+  int decl_index;\n+  tree var_decl;\n+  struct varpool_node *node;\n+  struct bitpack_d *bp;\n+  bool aliases_p;\n+  int count;\n+\n+  decl_index = lto_input_uleb128 (ib);\n+  var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n+  node = varpool_node (var_decl);\n+\n+  bp = lto_input_bitpack (ib);\n+  node->externally_visible = bp_unpack_value (bp, 1);\n+  node->force_output = bp_unpack_value (bp, 1);\n+  node->finalized = bp_unpack_value (bp, 1);\n+  node->analyzed = 1; \n+  node->used_from_other_partition = bp_unpack_value (bp, 1);\n+  node->in_other_partition = bp_unpack_value (bp, 1);\n+  aliases_p = bp_unpack_value (bp, 1);\n+  if (node->finalized)\n+    varpool_mark_needed_node (node);\n+  bitpack_delete (bp);\n+  if (aliases_p)\n+    {\n+      count = lto_input_uleb128 (ib);\n+      for (; count > 0; count --)\n+\t{\n+\t  tree decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t       lto_input_uleb128 (ib));\n+\t  varpool_extra_name_alias (decl, var_decl);\n+\t}\n+    }\n+  return node;\n+}\n+\n \n /* Read an edge from IB.  NODES points to a vector of previously read nodes for\n    decoding caller and callee of the edge to be read.  If INDIRECT is true, the\n@@ -812,6 +919,22 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   VEC_free (cgraph_node_ptr, heap, nodes);\n }\n \n+/* Read a varpool from IB using the info in FILE_DATA.  */\n+\n+static void\n+input_varpool_1 (struct lto_file_decl_data *file_data,\n+\t\tstruct lto_input_block *ib)\n+{\n+  unsigned HOST_WIDE_INT len;\n+\n+  len = lto_input_uleb128 (ib);\n+  while (len)\n+    {\n+      input_varpool_node (file_data, ib);\n+      len--;\n+    }\n+}\n+\n static struct gcov_ctr_summary lto_gcov_summary;\n \n /* Input profile_info from IB.  */\n@@ -867,6 +990,12 @@ input_cgraph (void)\n       lto_destroy_simple_input_block (file_data, LTO_section_cgraph,\n \t\t\t\t      ib, data, len);\n \n+      ib = lto_create_simple_input_block (file_data, LTO_section_varpool,\n+\t\t\t\t\t  &data, &len);\n+      input_varpool_1 (file_data, ib);\n+      lto_destroy_simple_input_block (file_data, LTO_section_varpool,\n+\t\t\t\t      ib, data, len);\n+\n       /* Assume that every file read needs to be processed by LTRANS.  */\n       if (flag_wpa)\n \tlto_mark_file_for_ltrans (file_data);"}, {"sha": "16fd0867805b1260dd9b3191403a8f29737acfd5", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -52,6 +52,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"function_body\",\n   \"static_initializer\",\n   \"cgraph\",\n+  \"varpool\",\n+  \"jump_funcs\"\n   \"ipa_pure_const\",\n   \"ipa_reference\",\n   \"symtab\","}, {"sha": "c45bfd0964a935fcba0d060613103321c7771b72", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -358,8 +358,6 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n     case LTO_label_decl_ref:\n       ix_u = lto_input_uleb128 (ib);\n       result = lto_file_decl_data_get_var_decl (data_in->file_data, ix_u);\n-      if (TREE_CODE (result) == VAR_DECL)\n-\tvarpool_mark_needed_node (varpool_node (result));\n       break;\n \n     default:\n@@ -2727,17 +2725,6 @@ lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n \t the code and class.  */\n       result = lto_get_builtin_tree (ib, data_in);\n     }\n-  else if (tag == LTO_var_decl_alias)\n-    {\n-      /* An extra_name alias for a variable.  */\n-      unsigned HOST_WIDE_INT ix;\n-      tree target;\n-      ix = lto_input_uleb128 (ib);\n-      result = lto_file_decl_data_get_var_decl (data_in->file_data, ix);\n-      ix = lto_input_uleb128 (ib);\n-      target = lto_file_decl_data_get_var_decl (data_in->file_data, ix);\n-      varpool_extra_name_alias (result, target);\n-    }\n   else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n     {\n       /* For integer constants we only need the type and its hi/low"}, {"sha": "0c8544cdb689a3473170cc26b5bd28a796756979", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 24, "deletions": 57, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -1930,30 +1930,22 @@ output_function (struct cgraph_node *node)\n    the file processed by LTRANS.  */\n \n static bool\n-output_alias_pair_p (alias_pair *p, cgraph_node_set set)\n+output_alias_pair_p (alias_pair *p, cgraph_node_set set, varpool_node_set vset)\n {\n-  cgraph_node_set_iterator csi;\n-  struct cgraph_node *target_node;\n-\n-  /* Always emit VAR_DECLs.  FIXME lto, we should probably only emit\n-     those VAR_DECLs that are instantiated in this file partition, but\n-     we have no easy way of knowing this based on SET.  */\n   if (TREE_CODE (p->decl) == VAR_DECL)\n-    return true;\n+    return varpool_node_in_set_p (varpool_node_for_asm (p->target), vset);\n \n   /* Check if the assembler name for P->TARGET has its cgraph node in SET.  */\n   gcc_assert (TREE_CODE (p->decl) == FUNCTION_DECL);\n-  target_node = cgraph_node_for_asm (p->target);\n-  csi = cgraph_node_set_find (set, target_node);\n-  return (!csi_end_p (csi));\n+  return cgraph_node_in_set_p (cgraph_node_for_asm (p->target), set);\n }\n \n \n /* Output any unreferenced global symbol defined in SET, alias pairs\n    and labels.  */\n \n static void\n-output_unreferenced_globals (cgraph_node_set set)\n+output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n {\n   struct output_block *ob;\n   alias_pair *p;\n@@ -1974,40 +1966,28 @@ output_unreferenced_globals (cgraph_node_set set)\n      symbols at link time if a file defines a global symbol but\n      never references it.  */\n   FOR_EACH_STATIC_VARIABLE (vnode)\n-    {\n-      tree var = vnode->decl;\n-\n-      if (TREE_CODE (var) == VAR_DECL)\n-        {\n-\t  struct varpool_node *alias;\n-\n-          /* Output the object in order to output references used in the\n-             initialization. */\n-          lto_output_tree (ob, var, true);\n-\n-          /* If it is public we also need a reference to the object itself. */\n-          if (TREE_PUBLIC (var))\n-            lto_output_tree_ref (ob, var);\n-\n-\t  /* Also output any extra_name aliases for this variable.  */\n-\t  for (alias = vnode->extra_name; alias; alias = alias->next)\n-\t    {\n-\t      lto_output_tree (ob, alias->decl, true);\n-\t      output_record_start (ob, LTO_var_decl_alias);\n-\t      lto_output_var_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\t\t alias->decl);\n-\t      lto_output_var_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\t\t var);\n-\t    }\n-        }\n-    }\n+   if (vnode->needed && varpool_node_in_set_p (vnode, vset))\n+      {\n+\ttree var = vnode->decl;\n+\n+\tif (TREE_CODE (var) == VAR_DECL)\n+\t  {\n+\t    /* Output the object in order to output references used in the\n+\t       initialization. */\n+\t    lto_output_tree (ob, var, true);\n+\n+\t    /* If it is public we also need a reference to the object itself. */\n+\t    if (TREE_PUBLIC (var))\n+\t      lto_output_tree_ref (ob, var);\n+\t  }\n+      }\n \n   output_zero (ob);\n \n   /* Emit the alias pairs for the nodes in SET.  */\n   for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n     {\n-      if (output_alias_pair_p (p, set))\n+      if (output_alias_pair_p (p, set, vset))\n \t{\n \t  lto_output_tree_ref (ob, p->decl);\n \t  lto_output_tree_ref (ob, p->target);\n@@ -2091,7 +2071,7 @@ lto_writer_init (void)\n /* Main entry point from the pass manager.  */\n \n static void\n-lto_output (cgraph_node_set set)\n+lto_output (cgraph_node_set set, varpool_node_set vset)\n {\n   struct cgraph_node *node;\n   struct lto_out_decl_state *decl_state;\n@@ -2124,6 +2104,7 @@ lto_output (cgraph_node_set set)\n      have been renumbered so that edges can be associated with call\n      statements using the statement UIDs.  */\n   output_cgraph (set);\n+  output_varpool (vset);\n \n   lto_bitmap_free (output);\n }\n@@ -2178,20 +2159,6 @@ write_global_stream (struct output_block *ob,\n       t = lto_tree_ref_encoder_get_tree (encoder, index);\n       if (!lto_streamer_cache_lookup (ob->writer_cache, t, NULL))\n \tlto_output_tree (ob, t, false);\n-\n-      if (flag_wpa)\n-\t{\n-\t  /* In WPA we should not emit multiple definitions of the\n-\t     same symbol to all the files in the link set.  If\n-\t     T had already been emitted as the pervailing definition\n-\t     in one file, do not emit it in the others.  */\n-\t  /* FIXME lto.  We should check if T belongs to the\n-\t     file we are writing to.  */\n-\t  if (TREE_CODE (t) == VAR_DECL\n-\t      && TREE_PUBLIC (t)\n-\t      && !DECL_EXTERNAL (t))\n-\t    TREE_ASM_WRITTEN (t) = 1;\n-\t}\n     }\n }\n \n@@ -2444,7 +2411,7 @@ produce_symtab (struct lto_streamer_cache_d *cache)\n    recover these on other side.  */\n \n static void\n-produce_asm_for_decls (cgraph_node_set set)\n+produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_out_decl_state *out_state;\n   struct lto_out_decl_state *fn_out_state;\n@@ -2462,7 +2429,7 @@ produce_asm_for_decls (cgraph_node_set set)\n   /* Write out unreferenced globals, alias pairs and labels.  We defer\n      doing this until now so that we can write out only what is\n      needed.  */\n-  output_unreferenced_globals (set);\n+  output_unreferenced_globals (set, vset);\n \n   memset (&header, 0, sizeof (struct lto_decl_header));\n "}, {"sha": "ec2a308f89f83027c0848b407e0d1b643c6fba80", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -160,6 +160,9 @@ lto_get_section_name (int section_type, const char *name)\n     case LTO_section_cgraph:\n       return concat (LTO_SECTION_NAME_PREFIX, \".cgraph\", NULL);\n \n+    case LTO_section_varpool:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".vars\", NULL);\n+\n     case LTO_section_jump_functions:\n       return concat (LTO_SECTION_NAME_PREFIX, \".jmpfuncs\", NULL);\n "}, {"sha": "c33feb62b01400c0538c921166641a145a63448a", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -217,9 +217,6 @@ enum LTO_tags\n   /* Special for global streamer. Reference to previously-streamed node.  */\n   LTO_tree_pickle_reference,\n \n-  /* A decl which exists only to provide an extra symbol for another var.  */\n-  LTO_var_decl_alias,\n-\n   /* References to indexable tree nodes.  These objects are stored in\n      tables that are written separately from the function bodies that\n      reference them.  This way they can be instantiated even when the\n@@ -259,11 +256,11 @@ enum lto_section_type\n   LTO_section_function_body,\n   LTO_section_static_initializer,\n   LTO_section_cgraph,\n+  LTO_section_varpool,\n   LTO_section_jump_functions,\n   LTO_section_ipa_pure_const,\n   LTO_section_ipa_reference,\n   LTO_section_symtab,\n-  LTO_section_wpa_fixup,\n   LTO_section_opts,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n@@ -834,6 +831,8 @@ int lto_cgraph_encoder_encode (lto_cgraph_encoder_t, struct cgraph_node *);\n void lto_cgraph_encoder_delete (lto_cgraph_encoder_t encoder);\n void output_cgraph (cgraph_node_set);\n void input_cgraph (void);\n+void output_varpool (varpool_node_set);\n+void input_varpool (void);\n \n \n /* In lto-symtab.c.  */"}, {"sha": "a35d82fe3d42ee981f9d0f169d873fc14e11e2e0", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -44,6 +44,9 @@ struct GTY(()) lto_symtab_entry_def\n   /* The cgraph node if decl is a function decl.  Filled in during the\n      merging process.  */\n   struct cgraph_node *node;\n+  /* The varpool node if decl is a variable decl.  Filled in during the\n+     merging process.  */\n+  struct varpool_node *vnode;\n   /* LTO file-data and symbol resolution for this decl.  */\n   struct lto_file_decl_data * GTY((skip (\"\"))) file_data;\n   enum ld_plugin_symbol_resolution resolution;\n@@ -244,6 +247,26 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   cgraph_remove_node (node);\n }\n \n+/* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n+   all edges and removing the old node.  */\n+\n+static void\n+lto_varpool_replace_node (struct varpool_node *vnode,\n+\t\t\t  struct varpool_node *prevailing_node)\n+{\n+  /* Merge node flags.  */\n+  if (vnode->needed)\n+    {\n+      gcc_assert (prevailing_node->analyzed);\n+      varpool_mark_needed_node (prevailing_node);\n+    }\n+  gcc_assert (!vnode->finalized || prevailing_node->finalized);\n+  gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n+\n+  /* Finally remove the replaced node.  */\n+  varpool_remove_node (vnode);\n+}\n+\n /* Merge two variable or function symbol table entries PREVAILING and ENTRY.\n    Return false if the symbols are not fully compatible and a diagnostic\n    should be emitted.  */\n@@ -406,6 +429,8 @@ lto_symtab_resolve_symbols (void **slot)\n     {\n       if (TREE_CODE (e->decl) == FUNCTION_DECL)\n \te->node = cgraph_get_node (e->decl);\n+      else if (TREE_CODE (e->decl) == VAR_DECL)\n+\te->vnode = varpool_get_node (e->decl);\n     }\n \n   e = (lto_symtab_entry_t) *slot;\n@@ -559,6 +584,10 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n \twhile (!prevailing->node\n \t       && prevailing->next)\n \t  prevailing = prevailing->next;\n+      if (TREE_CODE (prevailing->decl) == VAR_DECL)\n+\twhile (!prevailing->vnode\n+\t       && prevailing->next)\n+\t  prevailing = prevailing->next;\n       /* We do not stream varpool nodes, so the first decl has to\n \t be good enough for now.\n \t ???  For QOI choose a variable with readonly initializer\n@@ -625,7 +654,8 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n   lto_symtab_merge_decls_2 (slot);\n \n   /* Drop all but the prevailing decl from the symtab.  */\n-  if (TREE_CODE (prevailing->decl) != FUNCTION_DECL)\n+  if (TREE_CODE (prevailing->decl) != FUNCTION_DECL\n+      && TREE_CODE (prevailing->decl) != VAR_DECL)\n     prevailing->next = NULL;\n \n   return 1;\n@@ -650,8 +680,6 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n   if (!prevailing->next)\n     return 1;\n \n-  gcc_assert (TREE_CODE (prevailing->decl) == FUNCTION_DECL);\n-\n   /* Replace the cgraph node of each entry with the prevailing one.  */\n   for (e = prevailing->next; e; e = e->next)\n     {\n@@ -672,6 +700,8 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n \t    }\n \t  lto_cgraph_replace_node (e->node, prevailing->node);\n \t}\n+      if (e->vnode != NULL)\n+\tlto_varpool_replace_node (e->vnode, prevailing->vnode);\n     }\n \n   /* Drop all but the prevailing decl from the symtab.  */"}, {"sha": "5bf7a293f027fecfc237eccde46194677787c187", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -1,3 +1,14 @@\n+2010-04-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_varpool_node_sets): New.\n+\t(lto_1_to_1_map): Partition varpool too.\n+\t(globalize_context_t, globalize_cross_file_statics,\n+\tlto_scan_statics_in_ref_table, lto_scan_statics_in_cgraph_node,\n+\tlto_scan_statics_in_remaining_global_vars): Remove.\n+\t(lto_promote_cross_file_statics): Rewrite.\n+\t(get_filename_for_set): Take vset argument.\n+\t(lto_wpa_write_files): Pass around vsets.\n+\n 2010-04-27  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \tPR lto/42776"}, {"sha": "7aa1f3ecdbe92592df62ac2849bb2a9cb797f43c", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 91, "deletions": 199, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -523,6 +523,7 @@ free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n \n /* Vector of all cgraph node sets. */\n static GTY (()) VEC(cgraph_node_set, gc) *lto_cgraph_node_sets;\n+static GTY (()) VEC(varpool_node_set, gc) *lto_varpool_node_sets;\n \n \n /* Group cgrah nodes by input files.  This is used mainly for testing\n@@ -532,32 +533,31 @@ static void\n lto_1_to_1_map (void)\n {\n   struct cgraph_node *node;\n+  struct varpool_node *vnode;\n   struct lto_file_decl_data *file_data;\n   struct pointer_map_t *pmap;\n+  struct pointer_map_t *vpmap;\n   cgraph_node_set set;\n+  varpool_node_set vset;\n   void **slot;\n \n   timevar_push (TV_WHOPR_WPA);\n \n   lto_cgraph_node_sets = VEC_alloc (cgraph_node_set, gc, 1);\n-\n-  /* If the cgraph is empty, create one cgraph node set so that there is still\n-     an output file for any variables that need to be exported in a DSO.  */\n-  if (!cgraph_nodes)\n-    {\n-      set = cgraph_node_set_new ();\n-      VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n-      goto finish;\n-    }\n+  lto_varpool_node_sets = VEC_alloc (varpool_node_set, gc, 1);\n \n   pmap = pointer_map_create ();\n+  vpmap = pointer_map_create ();\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       /* We will get proper partition based on function they are inlined to or\n \t cloned from.  */\n       if (node->global.inlined_to || node->clone_of)\n \tcontinue;\n+      /* Nodes without a body do not need partitioning.  */\n+      if (!node->analyzed || node->same_body_alias)\n+\tcontinue;\n       /* We only need to partition the nodes that we read from the\n \t gimple bytecode files.  */\n       file_data = node->local.lto_file_data;\n@@ -573,14 +573,50 @@ lto_1_to_1_map (void)\n \t  slot = pointer_map_insert (pmap, file_data);\n \t  *slot = set;\n \t  VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n+\t  vset = varpool_node_set_new ();\n+\t  slot = pointer_map_insert (vpmap, file_data);\n+\t  *slot = vset;\n+\t  VEC_safe_push (varpool_node_set, gc, lto_varpool_node_sets, vset);\n \t}\n \n       cgraph_node_set_add (set, node);\n     }\n \n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    {\n+      if (vnode->alias)\n+\tcontinue;\n+      slot = pointer_map_contains (vpmap, file_data);\n+      if (slot)\n+\tvset = (varpool_node_set) *slot;\n+      else\n+\t{\n+\t  set = cgraph_node_set_new ();\n+\t  slot = pointer_map_insert (pmap, file_data);\n+\t  *slot = set;\n+\t  VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n+\t  vset = varpool_node_set_new ();\n+\t  slot = pointer_map_insert (vpmap, file_data);\n+\t  *slot = vset;\n+\t  VEC_safe_push (varpool_node_set, gc, lto_varpool_node_sets, vset);\n+\t}\n+\n+      varpool_node_set_add (vset, vnode);\n+    }\n+\n+  /* If the cgraph is empty, create one cgraph node set so that there is still\n+     an output file for any variables that need to be exported in a DSO.  */\n+  if (!lto_cgraph_node_sets)\n+    {\n+      set = cgraph_node_set_new ();\n+      VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n+      vset = varpool_node_set_new ();\n+      VEC_safe_push (varpool_node_set, gc, lto_varpool_node_sets, vset);\n+    }\n+\n   pointer_map_destroy (pmap);\n+  pointer_map_destroy (vpmap);\n \n-finish:\n   timevar_pop (TV_WHOPR_WPA);\n \n   lto_stats.num_cgraph_partitions += VEC_length (cgraph_node_set, \n@@ -672,214 +708,68 @@ lto_add_all_inlinees (cgraph_node_set set)\n   lto_bitmap_free (original_decls);\n }\n \n-/* Owing to inlining, we may need to promote a file-scope variable\n-   to a global variable.  Consider this case:\n-\n-   a.c:\n-   static int var;\n-\n-   void\n-   foo (void)\n-   {\n-     var++;\n-   }\n-\n-   b.c:\n-\n-   extern void foo (void);\n-\n-   void\n-   bar (void)\n-   {\n-     foo ();\n-   }\n-\n-   If WPA inlines FOO inside BAR, then the static variable VAR needs to\n-   be promoted to global because BAR and VAR may be in different LTRANS\n-   files. */\n-\n-/* This struct keeps track of states used in globalization.  */\n-\n-typedef struct\n-{\n-  /* Current cgraph node set.  */  \n-  cgraph_node_set set;\n-\n-  /* Function DECLs of cgraph nodes seen.  */\n-  bitmap seen_node_decls;\n-\n-  /* Use in walk_tree to avoid multiple visits of a node.  */\n-  struct pointer_set_t *visited;\n-\n-  /* static vars in this set.  */\n-  bitmap static_vars_in_set;\n-\n-  /* static vars in all previous set.  */\n-  bitmap all_static_vars;\n-\n-  /* all vars in all previous set.  */\n-  bitmap all_vars;\n-} globalize_context_t;\n-\n-/* Callback for walk_tree.  Examine the tree pointer to by TP and see if\n-   if its a file-scope static variable of function that need to be turned\n-   into a global.  */\n-\n-static tree\n-globalize_cross_file_statics (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t\t      void *data)\n-{\n-  globalize_context_t *context = (globalize_context_t *) data;\n-  tree t = *tp;\n-\n-  if (t == NULL_TREE)\n-    return NULL;\n-\n-  /* The logic for globalization of VAR_DECLs and FUNCTION_DECLs are\n-     different.  For functions, we can simply look at the cgraph node sets\n-     to tell if there are references to static functions outside the set.\n-     The cgraph node sets do not keep track of vars, we need to traverse\n-     the trees to determine what vars need to be globalized.  */\n-  if (TREE_CODE (t) == VAR_DECL)\n-    {\n-      if (!TREE_PUBLIC (t))\n-\t{\n-\t  /* This file-scope static variable is reachable from more\n-\t     that one set.  Make it global but with hidden visibility\n-\t     so that we do not export it in dynamic linking.  */\n-\t  if (bitmap_bit_p (context->all_static_vars, DECL_UID (t)))\n-\t    {\n-\t      TREE_PUBLIC (t) = 1;\n-\t      DECL_VISIBILITY (t) = VISIBILITY_HIDDEN;\n-\t    }\n-\t  bitmap_set_bit (context->static_vars_in_set, DECL_UID (t));\n-\t}\n-      bitmap_set_bit (context->all_vars, DECL_UID (t));\n-      walk_tree (&DECL_INITIAL (t), globalize_cross_file_statics, context,\n-\t\t context->visited);\n-    }\n-  else if (TREE_CODE (t) == FUNCTION_DECL && !TREE_PUBLIC (t))\n-    {\n-      if (!cgraph_node_in_set_p (cgraph_node (t), context->set)\n-\t  || cgraph_node (t)->address_taken)\n-\t{\n-\t  /* This file-scope static function is reachable from a set\n-\t     which does not contain the function DECL.  Make it global\n-\t     but with hidden visibility.  */\n-\t  TREE_PUBLIC (t) = 1;\n-\t  DECL_VISIBILITY (t) = VISIBILITY_HIDDEN;\n-\t}\n-    }\n-\n-  return NULL; \n-}\n-\n-/* Helper of lto_scan_statics_in_cgraph_node below.  Scan TABLE for\n-   static decls that may be used in more than one LTRANS file.\n-   CONTEXT is a globalize_context_t for storing scanning states.  */\n-\n-static void\n-lto_scan_statics_in_ref_table (struct lto_tree_ref_table *table,\n-\t\t\t       globalize_context_t *context)\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < table->size; i++)\n-    walk_tree (&table->trees[i], globalize_cross_file_statics, context,\n-\t       context->visited);\n-}\n-\n-/* Promote file-scope decl reachable from NODE if necessary to global.\n-   CONTEXT is a globalize_context_t storing scanning states.  */\n-\n-static void\n-lto_scan_statics_in_cgraph_node (struct cgraph_node *node,\n-\t\t\t\t globalize_context_t *context)\n-{\n-  struct lto_in_decl_state *state;\n-  \n-  /* Do nothing if NODE has no function body.  */\n-  if (!node->analyzed)\n-    return;\n-  \n-  /* Return if the DECL of nodes has been visited before.  */\n-  if (bitmap_bit_p (context->seen_node_decls, DECL_UID (node->decl)))\n-    return;\n-\n-  bitmap_set_bit (context->seen_node_decls, DECL_UID (node->decl));\n-\n-  state = lto_get_function_in_decl_state (node->local.lto_file_data,\n-\t\t\t\t\t  node->decl);\n-  gcc_assert (state);\n-\n-  lto_scan_statics_in_ref_table (&state->streams[LTO_DECL_STREAM_VAR_DECL],\n-\t\t\t\t context);\n-  lto_scan_statics_in_ref_table (&state->streams[LTO_DECL_STREAM_FN_DECL],\n-\t\t\t\t context);\n-}\n-\n-/* Scan all global variables that we have not yet seen so far.  CONTEXT\n-   is a globalize_context_t storing scanning states.  */\n-\n-static void\n-lto_scan_statics_in_remaining_global_vars (globalize_context_t *context)\n-{\n-  tree var, var_context;\n-  struct varpool_node *vnode;\n-\n-  FOR_EACH_STATIC_VARIABLE (vnode)\n-    {\n-      var = vnode->decl;\n-      var_context = DECL_CONTEXT (var);\n-      if (TREE_STATIC (var)\n-\t  && TREE_PUBLIC (var)\n-          && (!var_context || TREE_CODE (var_context) != FUNCTION_DECL)\n-          && !bitmap_bit_p (context->all_vars, DECL_UID (var)))\n-\twalk_tree (&var, globalize_cross_file_statics, context,\n-\t\t   context->visited);\n-    }\n-}\n-\n /* Find out all static decls that need to be promoted to global because\n    of cross file sharing.  This function must be run in the WPA mode after\n    all inlinees are added.  */\n \n static void\n lto_promote_cross_file_statics (void)\n {\n+  struct varpool_node *vnode;\n   unsigned i, n_sets;\n   cgraph_node_set set;\n   cgraph_node_set_iterator csi;\n-  globalize_context_t context;\n \n-  memset (&context, 0, sizeof (context));\n-  context.all_vars = lto_bitmap_alloc ();\n-  context.all_static_vars = lto_bitmap_alloc ();\n+  gcc_assert (flag_wpa);\n \n+  /* At moment we make no attempt to figure out who is refering the variables,\n+     so all must become global.  */\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (!vnode->externally_visible && vnode->analyzed)\n+       {\n+\t  TREE_PUBLIC (vnode->decl) = 1;\n+\t  DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n+       }\n   n_sets = VEC_length (cgraph_node_set, lto_cgraph_node_sets);\n   for (i = 0; i < n_sets; i++)\n     {\n       set = VEC_index (cgraph_node_set, lto_cgraph_node_sets, i);\n-      context.set = set;\n-      context.visited = pointer_set_create ();\n-      context.static_vars_in_set = lto_bitmap_alloc ();\n-      context.seen_node_decls = lto_bitmap_alloc ();\n \n+      /* If node has either address taken (and we have no clue from where)\n+\t or it is called from other partition, it needs to be globalized.  */\n       for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-\tlto_scan_statics_in_cgraph_node (csi_node (csi), &context);\n-\n-      if (i == n_sets - 1)\n-        lto_scan_statics_in_remaining_global_vars (&context);\n-\n-      bitmap_ior_into (context.all_static_vars, context.static_vars_in_set);\n+\t{\n+\t  struct cgraph_node *node = csi_node (csi);\n+\t  bool globalize = node->address_taken || node->local.vtable_method;\n+\t  struct cgraph_edge *e;\n+\t  if (node->local.externally_visible)\n+\t    continue;\n+\t  for (e = node->callers; e && !globalize; e = e->next_caller)\n+\t    {\n+\t      struct cgraph_node *caller = e->caller;\n+\t      if (caller->global.inlined_to)\n+\t\tcaller = caller->global.inlined_to;\n+\t      if (!cgraph_node_in_set_p (caller, set))\n+\t\tglobalize = true;\n+\t    }\n+\t  if (globalize)\n+\t     {\n+\t\tTREE_PUBLIC (node->decl) = 1;\n+\t\tDECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n+\t\tif (node->same_body)\n+\t\t  {\n+\t\t    struct cgraph_node *alias;\n+\t\t    for (alias = node->same_body;\n+\t\t\t alias; alias = alias->next)\n+\t\t      {\n+\t\t\tTREE_PUBLIC (alias->decl) = 1;\n+\t\t\tDECL_VISIBILITY (alias->decl) = VISIBILITY_HIDDEN;\n+\t\t      }\n+\t\t  }\n+\t     }\n+\t}\n \n-      pointer_set_destroy (context.visited);\n-      lto_bitmap_free (context.static_vars_in_set);\n-      lto_bitmap_free (context.seen_node_decls);\n     }\n-\n-  lto_bitmap_free (context.all_vars);\n-  lto_bitmap_free (context.all_static_vars);\n }\n \n \n@@ -999,6 +889,7 @@ lto_wpa_write_files (void)\n   unsigned i, n_sets, last_out_file_ix, num_out_files;\n   lto_file *file;\n   cgraph_node_set set;\n+  varpool_node_set vset;\n \n   timevar_push (TV_WHOPR_WPA);\n \n@@ -1034,6 +925,7 @@ lto_wpa_write_files (void)\n       char *temp_filename;\n \n       set = VEC_index (cgraph_node_set, lto_cgraph_node_sets, i);\n+      vset = VEC_index (varpool_node_set, lto_varpool_node_sets, i);\n       temp_filename = get_filename_for_set (set);\n       output_files[i] = temp_filename;\n \n@@ -1046,7 +938,7 @@ lto_wpa_write_files (void)\n \n \t  lto_set_current_out_file (file);\n \n-\t  ipa_write_optimization_summaries (set);\n+\t  ipa_write_optimization_summaries (set, vset);\n \n \t  lto_set_current_out_file (NULL);\n \t  lto_obj_file_close (file);"}, {"sha": "7a5d16f8a247ae5e40c3e94e496dac5652bca6b8", "filename": "gcc/passes.c", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -191,7 +191,11 @@ rest_of_decl_compilation (tree decl,\n \t   || DECL_INITIAL (decl))\n \t  && !DECL_EXTERNAL (decl))\n \t{\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t  /* When reading LTO unit, we also read varpool, so do not\n+\t     rebuild it.  */\n+\t  if (in_lto_p && !at_end)\n+\t    ;\n+\t  else if (TREE_CODE (decl) != FUNCTION_DECL)\n \t    varpool_finalize_decl (decl);\n \t  else\n \t    assemble_variable (decl, top_level, at_end, 0);\n@@ -218,7 +222,9 @@ rest_of_decl_compilation (tree decl,\n     }\n \n   /* Let cgraph know about the existence of variables.  */\n-  if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+  if (in_lto_p && !at_end)\n+    ;\n+  else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n     varpool_node (decl);\n }\n \n@@ -1649,6 +1655,7 @@ execute_pass_list (struct opt_pass *pass)\n \n static void\n ipa_write_summaries_2 (struct opt_pass *pass, cgraph_node_set set,\n+\t\t       varpool_node_set vset,\n \t\t       struct lto_out_decl_state *state)\n {\n   while (pass)\n@@ -1665,15 +1672,15 @@ ipa_write_summaries_2 (struct opt_pass *pass, cgraph_node_set set,\n \t  if (pass->tv_id)\n \t    timevar_push (pass->tv_id);\n \n-\t  ipa_pass->write_summary (set);\n+\t  ipa_pass->write_summary (set,vset);\n \n \t  /* If a timevar is present, start it.  */\n \t  if (pass->tv_id)\n \t    timevar_pop (pass->tv_id);\n \t}\n \n       if (pass->sub && pass->sub->type != GIMPLE_PASS)\n-\tipa_write_summaries_2 (pass->sub, set, state);\n+\tipa_write_summaries_2 (pass->sub, set, vset, state);\n \n       pass = pass->next;\n     }\n@@ -1684,14 +1691,14 @@ ipa_write_summaries_2 (struct opt_pass *pass, cgraph_node_set set,\n    summaries.  SET is the set of nodes to be written.  */\n \n static void\n-ipa_write_summaries_1 (cgraph_node_set set)\n+ipa_write_summaries_1 (cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n   lto_push_out_decl_state (state);\n \n   gcc_assert (!flag_wpa);\n-  ipa_write_summaries_2 (all_regular_ipa_passes, set, state);\n-  ipa_write_summaries_2 (all_lto_gen_passes, set, state);\n+  ipa_write_summaries_2 (all_regular_ipa_passes, set, vset, state);\n+  ipa_write_summaries_2 (all_lto_gen_passes, set, vset, state);\n \n   gcc_assert (lto_get_out_decl_state () == state);\n   lto_pop_out_decl_state ();\n@@ -1704,7 +1711,9 @@ void\n ipa_write_summaries (void)\n {\n   cgraph_node_set set;\n+  varpool_node_set vset;\n   struct cgraph_node **order;\n+  struct varpool_node *vnode;\n   int i, order_pos;\n \n   if (!flag_generate_lto || errorcount || sorrycount)\n@@ -1736,13 +1745,20 @@ ipa_write_summaries (void)\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n-      cgraph_node_set_add (set, node);\n+      if (node->needed || node->reachable || node->address_taken)\n+\tcgraph_node_set_add (set, node);\n     }\n+  vset = varpool_node_set_new ();\n \n-  ipa_write_summaries_1 (set);\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (vnode->needed && !vnode->alias)\n+      varpool_node_set_add (vset, vnode);\n+\n+  ipa_write_summaries_1 (set, vset);\n \n   free (order);\n   ggc_free (set);\n+  ggc_free (vset);\n }\n \n /* Same as execute_pass_list but assume that subpasses of IPA passes\n@@ -1751,6 +1767,7 @@ ipa_write_summaries (void)\n \n static void\n ipa_write_optimization_summaries_1 (struct opt_pass *pass, cgraph_node_set set,\n+\t\t       varpool_node_set vset,\n \t\t       struct lto_out_decl_state *state)\n {\n   while (pass)\n@@ -1767,15 +1784,15 @@ ipa_write_optimization_summaries_1 (struct opt_pass *pass, cgraph_node_set set,\n \t  if (pass->tv_id)\n \t    timevar_push (pass->tv_id);\n \n-\t  ipa_pass->write_optimization_summary (set);\n+\t  ipa_pass->write_optimization_summary (set, vset);\n \n \t  /* If a timevar is present, start it.  */\n \t  if (pass->tv_id)\n \t    timevar_pop (pass->tv_id);\n \t}\n \n       if (pass->sub && pass->sub->type != GIMPLE_PASS)\n-\tipa_write_optimization_summaries_1 (pass->sub, set, state);\n+\tipa_write_optimization_summaries_1 (pass->sub, set, vset, state);\n \n       pass = pass->next;\n     }\n@@ -1785,14 +1802,14 @@ ipa_write_optimization_summaries_1 (struct opt_pass *pass, cgraph_node_set set,\n    NULL, write out all summaries of all nodes. */\n \n void\n-ipa_write_optimization_summaries (cgraph_node_set set)\n+ipa_write_optimization_summaries (cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n   lto_push_out_decl_state (state);\n \n   gcc_assert (flag_wpa);\n-  ipa_write_optimization_summaries_1 (all_regular_ipa_passes, set, state);\n-  ipa_write_optimization_summaries_1 (all_lto_gen_passes, set, state);\n+  ipa_write_optimization_summaries_1 (all_regular_ipa_passes, set, vset, state);\n+  ipa_write_optimization_summaries_1 (all_lto_gen_passes, set, vset, state);\n \n   gcc_assert (lto_get_out_decl_state () == state);\n   lto_pop_out_decl_state ();"}, {"sha": "8542aabc79cffb804841f531ce6e6d67458966b8", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -168,6 +168,7 @@ struct rtl_opt_pass\n struct varpool_node;\n struct cgraph_node;\n struct cgraph_node_set_def;\n+struct varpool_node_set_def;\n \n /* Description of IPA pass with generate summary, write, execute, read and\n    transform stages.  */\n@@ -180,13 +181,15 @@ struct ipa_opt_pass_d\n   void (*generate_summary) (void);\n \n   /* This hook is used to serialize IPA summaries on disk.  */\n-  void (*write_summary) (struct cgraph_node_set_def *);\n+  void (*write_summary) (struct cgraph_node_set_def *,\n+\t\t\t struct varpool_node_set_def *);\n \n   /* This hook is used to deserialize IPA summaries from disk.  */\n   void (*read_summary) (void);\n \n   /* This hook is used to serialize IPA optimization summaries on disk.  */\n-  void (*write_optimization_summary) (struct cgraph_node_set_def *);\n+  void (*write_optimization_summary) (struct cgraph_node_set_def *,\n+\t\t\t\t      struct varpool_node_set_def *);\n \n   /* This hook is used to deserialize IPA summaries from disk.  */\n   void (*read_optimization_summary) (void);\n@@ -607,7 +610,8 @@ extern const char *get_current_pass_name (void);\n extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n extern void ipa_write_summaries (void);\n-extern void ipa_write_optimization_summaries (struct cgraph_node_set_def *);\n+extern void ipa_write_optimization_summaries (struct cgraph_node_set_def *,\n+\t\t\t\t\t      struct varpool_node_set_def *);\n extern void ipa_read_summaries (void);\n extern void ipa_read_optimization_summaries (void);\n extern void register_one_dump_file (struct opt_pass *);"}, {"sha": "77f52c3dee651075a1e0b53af0a007cbcc05a858", "filename": "gcc/varpool.c", "status": "modified", "additions": 80, "deletions": 19, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2942c502ee147819b7e57dca78f7a2cf4831279f/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=2942c502ee147819b7e57dca78f7a2cf4831279f", "patch": "@@ -105,6 +105,22 @@ eq_varpool_node (const void *p1, const void *p2)\n   return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n+/* Return varpool node assigned to DECL without creating new one.  */\n+struct varpool_node *\n+varpool_get_node (tree decl)\n+{\n+  struct varpool_node key, **slot;\n+\n+  gcc_assert (DECL_P (decl) && TREE_CODE (decl) != FUNCTION_DECL);\n+\n+  if (!varpool_hash)\n+    return NULL;\n+  key.decl = decl;\n+  slot = (struct varpool_node **)\n+    htab_find_slot (varpool_hash, &key, INSERT);\n+  return *slot;\n+}\n+\n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n struct varpool_node *\n varpool_node (tree decl)\n@@ -125,11 +141,50 @@ varpool_node (tree decl)\n   node->decl = decl;\n   node->order = cgraph_order++;\n   node->next = varpool_nodes;\n+  if (varpool_nodes)\n+    varpool_nodes->prev = node;\n   varpool_nodes = node;\n   *slot = node;\n   return node;\n }\n \n+/* Remove node from the varpool.  */\n+void\n+varpool_remove_node (struct varpool_node *node)\n+{\n+  void **slot;\n+  slot = htab_find_slot (varpool_hash, node, NO_INSERT);\n+  gcc_assert (*slot == node);\n+  htab_clear_slot (varpool_hash, slot);\n+  gcc_assert (!varpool_assembled_nodes_queue);\n+  if (node->next)\n+    node->next->prev = node->prev;\n+  if (node->prev)\n+    node->prev->next = node->next;\n+  else if (node->next)\n+    {\n+      gcc_assert (varpool_nodes == node);\n+      varpool_nodes = node->next;\n+    }\n+  if (varpool_first_unanalyzed_node == node)\n+    varpool_first_unanalyzed_node = node->next_needed;\n+  if (node->next_needed)\n+    node->next_needed->prev_needed = node->prev_needed;\n+  else if (node->prev_needed)\n+    {\n+      gcc_assert (varpool_last_needed_node);\n+      varpool_last_needed_node = node->prev_needed;\n+    }\n+  if (node->prev_needed)\n+    node->prev_needed->next_needed = node->next_needed;\n+  else if (node->next_needed)\n+    {\n+      gcc_assert (varpool_nodes_queue == node);\n+      varpool_nodes_queue = node->next_needed;\n+    }\n+  node->decl = NULL;\n+}\n+\n /* Dump given cgraph node.  */\n void\n dump_varpool_node (FILE *f, struct varpool_node *node)\n@@ -139,8 +194,12 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n \t   cgraph_function_flags_ready\n \t   ? cgraph_availability_names[cgraph_variable_initializer_availability (node)]\n \t   : \"not-ready\");\n+  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n+    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n   if (DECL_INITIAL (node->decl))\n     fprintf (f, \" initialized\");\n+  if (TREE_ASM_WRITTEN (node->decl))\n+    fprintf (f, \" (asm written)\");\n   if (node->needed)\n     fprintf (f, \" needed\");\n   if (node->analyzed)\n@@ -151,6 +210,10 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n     fprintf (f, \" output\");\n   if (node->externally_visible)\n     fprintf (f, \" externally_visible\");\n+  if (node->in_other_partition)\n+    fprintf (f, \" in_other_partition\");\n+  else if (node->used_from_other_partition)\n+    fprintf (f, \" used_from_other_partition\");\n   fprintf (f, \"\\n\");\n }\n \n@@ -192,7 +255,10 @@ static void\n varpool_enqueue_needed_node (struct varpool_node *node)\n {\n   if (varpool_last_needed_node)\n-    varpool_last_needed_node->next_needed = node;\n+    {\n+      varpool_last_needed_node->next_needed = node;\n+      node->prev_needed = varpool_last_needed_node;\n+    }\n   varpool_last_needed_node = node;\n   node->next_needed = NULL;\n   if (!varpool_nodes_queue)\n@@ -230,11 +296,7 @@ varpool_reset_queue (void)\n bool\n decide_is_variable_needed (struct varpool_node *node, tree decl)\n {\n-  /* We do not track variable references at all and thus have no idea if the\n-     variable was referenced in some other partition or not.  \n-     FIXME: We really need address taken edges in callgraph and varpool to\n-     drive WPA and decide whether other partition might reference it or not.  */\n-  if (flag_ltrans)\n+  if (node->used_from_other_partition)\n     return true;\n   /* If the user told us it is used, then it must be so.  */\n   if ((node->externally_visible && !DECL_COMDAT (decl))\n@@ -288,17 +350,6 @@ varpool_finalize_decl (tree decl)\n {\n   struct varpool_node *node = varpool_node (decl);\n \n-  /* FIXME: We don't really stream varpool datastructure and instead rebuild it\n-     by varpool_finalize_decl.  This is not quite correct since this way we can't\n-     attach any info to varpool.  Eventually we will want to stream varpool nodes\n-     and the flags.\n-\n-     For the moment just prevent analysis of varpool nodes to happen again, so\n-     we will re-try to compute \"address_taken\" flag of varpool that breaks\n-     in presence of clones.  */\n-  if (in_lto_p)\n-    node->analyzed = true;\n-\n   /* The first declaration of a variable that comes through this function\n      decides whether it is global (in C, has external linkage)\n      or local (in C, has internal linkage).  So do nothing more\n@@ -364,7 +415,7 @@ varpool_analyze_pending_decls (void)\n \t We however don't want to re-analyze already analyzed nodes.  */\n       if (!analyzed)\n \t{\n-\t  gcc_assert (!in_lto_p);\n+\t  gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n           /* Compute the alignment early so function body expanders are\n \t     already informed about increased alignment.  */\n           align_variable (decl, 0);\n@@ -385,6 +436,7 @@ varpool_assemble_decl (struct varpool_node *node)\n \n   if (!TREE_ASM_WRITTEN (decl)\n       && !node->alias\n+      && !node->in_other_partition\n       && !DECL_EXTERNAL (decl)\n       && (TREE_CODE (decl) != VAR_DECL || !DECL_HAS_VALUE_EXPR_P (decl)))\n     {\n@@ -394,6 +446,9 @@ varpool_assemble_decl (struct varpool_node *node)\n \t  struct varpool_node *alias;\n \n \t  node->next_needed = varpool_assembled_nodes_queue;\n+\t  node->prev_needed = NULL;\n+\t  if (varpool_assembled_nodes_queue)\n+\t    varpool_assembled_nodes_queue->prev_needed = node;\n \t  varpool_assembled_nodes_queue = node;\n \t  node->finalized = 1;\n \n@@ -476,7 +531,10 @@ varpool_assemble_pending_decls (void)\n       if (varpool_assemble_decl (node))\n \tchanged = true;\n       else\n-        node->next_needed = NULL;\n+\t{\n+\t  node->prev_needed = NULL;\n+          node->next_needed = NULL;\n+\t}\n     }\n   /* varpool_nodes_queue is now empty, clear the pointer to the last element\n      in the queue.  */\n@@ -498,6 +556,7 @@ varpool_empty_needed_queue (void)\n       struct varpool_node *node = varpool_nodes_queue;\n       varpool_nodes_queue = varpool_nodes_queue->next_needed;\n       node->next_needed = NULL;\n+      node->prev_needed = NULL;\n     }\n   /* varpool_nodes_queue is now empty, clear the pointer to the last element\n      in the queue.  */\n@@ -559,6 +618,8 @@ varpool_extra_name_alias (tree alias, tree decl)\n   alias_node->alias = 1;\n   alias_node->extra_name = decl_node;\n   alias_node->next = decl_node->extra_name;\n+  if (decl_node->extra_name)\n+    decl_node->extra_name->prev = alias_node;\n   decl_node->extra_name = alias_node;\n   *slot = alias_node;\n   return true;"}]}