{"sha": "fa6098f8177ea7e73cfdcc291209cd47d40196ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE2MDk4ZjgxNzdlYTdlNzNjZmRjYzI5MTIwOWNkNDdkNDAxOTZlZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-04-19T16:58:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-04-19T16:58:23Z"}, "message": "re PR c++/27102 (ICE with invalid class name in function template)\n\n\tPR c++/27102\n\t* class.c (currently_open_class): Tidy.\n\t* decl.c (grokdeclarator): If we encounter an erroneous\n\tdeclarator, assume that we have already issued an error message\n\tand return.  Return error_mark_node instead of NULL_TREE in more\n\tplaces.  Issue errors about function definitions that do not have\n\ta function declarator.  Check for complete types for all function\n\tdefinitions. \n\t* cp-tree.h (cp_error_declarator): Remove.\n\t(currently_open_class): Change return type.\n\t* parser.c (cp_parser_id_expression): Add optional_p parameter.\n\t(cp_parser_parse_diagnose_invalid_type_name): Adjust calls.\n\t(cp_parser_id_expression): Likewise.\n\t(cp_parser_unqualified_id): If the name is optional, return\n\tNULL_TREE.\n\t(cp_parser_postfix_dot_deref_expression): Adjust calls.\n\t(cp_parser_type_parameter): Likewise.\n\t(cp_parser_unqualified_id): Likewise.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_declarator_id): Add optional_p parameter.\n\t(cp_parser_function_definition_from_specifiers_and_declarator):\n\tAssume that start_function indicates failure only if it has issued\n\tan error.\n\t(cp_parser_omp_var_list_no_open): Adjust calls.\n\t\n\tPR c++/27102\n\t* g++.dg/template/crash35.C: Tweak error markers.\n\t* g++.dg/template/crash46.C: New test.\n\t* g++.old-deja/g++.brendan/friend4.C: Tweak error markers.\n\t* g++.old-deja/g++.pt/incomplete1.C: Likewise.\n\nFrom-SVN: r113081", "tree": {"sha": "8697179a09947548fbbcca23b0493738bd1f5cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8697179a09947548fbbcca23b0493738bd1f5cb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa6098f8177ea7e73cfdcc291209cd47d40196ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa6098f8177ea7e73cfdcc291209cd47d40196ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa6098f8177ea7e73cfdcc291209cd47d40196ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa6098f8177ea7e73cfdcc291209cd47d40196ee/comments", "author": null, "committer": null, "parents": [{"sha": "74c96e0c149acb69337d704bfcd32d1e60724307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c96e0c149acb69337d704bfcd32d1e60724307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c96e0c149acb69337d704bfcd32d1e60724307"}], "stats": {"total": 202, "additions": 136, "deletions": 66}, "files": [{"sha": "2d80e524bd619fc74fa2f449ac6e4e1813451c36", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -1,3 +1,30 @@\n+2006-04-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/27102\n+\t* class.c (currently_open_class): Tidy.\n+\t* decl.c (grokdeclarator): If we encounter an erroneous\n+\tdeclarator, assume that we have already issued an error message\n+\tand return.  Return error_mark_node instead of NULL_TREE in more\n+\tplaces.  Issue errors about function definitions that do not have\n+\ta function declarator.  Check for complete types for all function\n+\tdefinitions. \n+\t* cp-tree.h (cp_error_declarator): Remove.\n+\t(currently_open_class): Change return type.\n+\t* parser.c (cp_parser_id_expression): Add optional_p parameter.\n+\t(cp_parser_parse_diagnose_invalid_type_name): Adjust calls.\n+\t(cp_parser_id_expression): Likewise.\n+\t(cp_parser_unqualified_id): If the name is optional, return\n+\tNULL_TREE.\n+\t(cp_parser_postfix_dot_deref_expression): Adjust calls.\n+\t(cp_parser_type_parameter): Likewise.\n+\t(cp_parser_unqualified_id): Likewise.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_declarator_id): Add optional_p parameter.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator):\n+\tAssume that start_function indicates failure only if it has issued\n+\tan error.\n+\t(cp_parser_omp_var_list_no_open): Adjust calls.\n+\t\n 2006-04-17  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR c++/26114, c++/26115"}, {"sha": "cc26cb8f56c55d2e5219136cbe6b08a77491983d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -5496,25 +5496,33 @@ pop_class_stack (void)\n     --current_class_stack[current_class_depth - 1].hidden;\n }\n \n-/* Returns 1 if current_class_type is either T or a nested type of T.\n-   We start looking from 1 because entry 0 is from global scope, and has\n-   no type.  */\n+/* Returns 1 if the class type currently being defined is either T or\n+   a nested type of T.  */\n \n-int\n+bool\n currently_open_class (tree t)\n {\n   int i;\n-  if (current_class_type && same_type_p (t, current_class_type))\n-    return 1;\n-  for (i = current_class_depth - 1; i > 0; --i)\n+\n+  /* We start looking from 1 because entry 0 is from global scope,\n+     and has no type.  */\n+  for (i = current_class_depth; i > 0; --i)\n     {\n-      if (current_class_stack[i].hidden)\n-\tbreak;\n-      if (current_class_stack[i].type\n-\t  && same_type_p (current_class_stack [i].type, t))\n-\treturn 1;\n+      tree c;\n+      if (i == current_class_depth)\n+\tc = current_class_type;\n+      else\n+\t{\n+\t  if (current_class_stack[i].hidden)\n+\t    break;\n+\t  c = current_class_stack[i].type;\n+\t}\n+      if (!c)\n+\tcontinue;\n+      if (same_type_p (c, t))\n+\treturn true;\n     }\n-  return 0;\n+  return false;\n }\n \n /* If either current_class_type or one of its enclosing classes are derived"}, {"sha": "f82ab32f8d23613642eaeee3ca28cd3e7f344bc6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -3691,9 +3691,6 @@ struct cp_declarator {\n   } u;\n };\n \n-/* An erroneous declarator.  */\n-extern cp_declarator *cp_error_declarator;\n-\n /* A parameter list indicating for a function with no parameters,\n    e.g  \"int f(void)\".  */\n extern cp_parameter_declarator *no_parameters;\n@@ -3750,7 +3747,7 @@ extern tree get_vtable_decl\t\t\t(tree, int);\n extern void resort_type_method_vec\t\t(void *, void *,\n \t\t\t\t\t\t gt_pointer_operator, void *);\n extern bool add_method\t\t\t\t(tree, tree, tree);\n-extern int currently_open_class\t\t\t(tree);\n+extern bool currently_open_class\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n extern tree finish_struct\t\t\t(tree, tree);\n extern void finish_struct_1\t\t\t(tree);"}, {"sha": "9e101c15eab84a125383a885f91bce0dd1df5eb6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -6956,7 +6956,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    break;\n \n \t  case cdk_error:\n-\t    break;\n+\t    return error_mark_node;\n \n \t  default:\n \t    gcc_unreachable ();\n@@ -6966,11 +6966,15 @@ grokdeclarator (const cp_declarator *declarator,\n \tbreak;\n     }\n \n-  /* A function definition's declarator must have the form of\n-     a function declarator.  */\n-\n+  /* [dcl.fct.edf]\n+     \n+     The declarator in a function-definition shall have the form\n+     D1 ( parameter-declaration-clause) ...  */\n   if (funcdef_flag && innermost_code != cdk_function)\n-    return NULL_TREE;\n+    {\n+      error (\"function definition does not declare parameters\");\n+      return error_mark_node;\n+    }\n \n   if (((dname && IDENTIFIER_OPNAME_P (dname)) || flags == TYPENAME_FLAG)\n       && innermost_code != cdk_function\n@@ -7711,6 +7715,20 @@ grokdeclarator (const cp_declarator *declarator,\n \t    pedwarn (\"extra qualification %<%T::%> on member %qs\",\n \t\t     ctype, name);\n \t}\n+      else if (/* If the qualifying type is already complete, then we\n+\t\t  can skip the following checks.  */\n+\t       !COMPLETE_TYPE_P (ctype)\n+\t       /* If a function is being defined, then the qualifing\n+\t\t  type must be complete.  The qualifing type may be\n+\t\t  incomplete for a declaration only if the qualitying\n+\t\t  type is one of the classes presently being defined,\n+\t\t  or if it is a dependent type.  */\n+\t       && (funcdef_flag \n+\t\t   || !(dependent_type_p (ctype)\n+\t\t\t|| currently_open_class (ctype)))\n+\t       /* Check that the qualifing type is complete.  */\n+\t       && !complete_type_or_else (ctype, NULL_TREE))\n+\treturn error_mark_node;\n       else if (TREE_CODE (type) == FUNCTION_TYPE)\n \t{\n \t  tree sname = declarator->u.id.unqualified_name;\n@@ -7736,23 +7754,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t\t\t       TYPE_ARG_TYPES (type));\n \t}\n       else if (declspecs->specs[(int)ds_typedef]\n-\t       || COMPLETE_TYPE_P (complete_type (ctype)))\n-\t{\n-\t  /* Have to move this code elsewhere in this function.\n-\t     this code is used for i.e., typedef int A::M; M *pm;\n-\n-\t     It is?  How? jason 10/2/94 */\n-\n-\t  if (current_class_type)\n-\t    {\n-\t      error (\"cannot declare member %<%T::%s%> within %qT\",\n-\t\t     ctype, name, current_class_type);\n-\t      return void_type_node;\n-\t    }\n-\t}\n-      else\n+\t       && current_class_type)\n \t{\n-\t  cxx_incomplete_type_error (NULL_TREE, ctype);\n+\t  error (\"cannot declare member %<%T::%s%> within %qT\",\n+\t\t ctype, name, current_class_type);\n \t  return error_mark_node;\n \t}\n     }"}, {"sha": "13c73627e1c3baead7e37162bf89a5d3eb3c4c27", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -780,7 +780,8 @@ static cp_parameter_declarator *make_parameter_declarator\n static cp_declarator *make_ptrmem_declarator\n   (cp_cv_quals, tree, cp_declarator *);\n \n-cp_declarator *cp_error_declarator;\n+/* An erroneous declarator.  */\n+static cp_declarator *cp_error_declarator;\n \n /* The obstack on which declarators and related data structures are\n    allocated.  */\n@@ -1389,9 +1390,9 @@ static bool cp_parser_translation_unit\n static tree cp_parser_primary_expression\n   (cp_parser *, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_id_expression\n-  (cp_parser *, bool, bool, bool *, bool);\n+  (cp_parser *, bool, bool, bool *, bool, bool);\n static tree cp_parser_unqualified_id\n-  (cp_parser *, bool, bool, bool);\n+  (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier_opt\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier\n@@ -1536,7 +1537,7 @@ static enum tree_code cp_parser_ptr_operator\n static cp_cv_quals cp_parser_cv_qualifier_seq_opt\n   (cp_parser *);\n static tree cp_parser_declarator_id\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_type_id\n   (cp_parser *);\n static void cp_parser_type_specifier_seq\n@@ -2142,7 +2143,8 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n \t\t\t\t/*template_keyword_p=*/false,\n \t\t\t\t/*check_dependency_p=*/true,\n \t\t\t\t/*template_p=*/NULL,\n-\t\t\t\t/*declarator_p=*/true);\n+\t\t\t\t/*declarator_p=*/true,\n+\t\t\t\t/*optional_p=*/false);\n   /* After the id-expression, there should be a plain identifier,\n      otherwise this is not a simple variable declaration. Also, if\n      the scope is dependent, we cannot do much.  */\n@@ -3021,7 +3023,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t\t     /*template_keyword_p=*/false,\n \t\t\t\t     /*check_dependency_p=*/true,\n \t\t\t\t     &template_p,\n-\t\t\t\t     /*declarator_p=*/false);\n+\t\t\t\t     /*declarator_p=*/false,\n+\t\t\t\t     /*optional_p=*/false);\n \tif (id_expression == error_mark_node)\n \t  return error_mark_node;\n \ttoken = cp_lexer_peek_token (parser->lexer);\n@@ -3154,7 +3157,8 @@ cp_parser_id_expression (cp_parser *parser,\n \t\t\t bool template_keyword_p,\n \t\t\t bool check_dependency_p,\n \t\t\t bool *template_p,\n-\t\t\t bool declarator_p)\n+\t\t\t bool declarator_p,\n+\t\t\t bool optional_p)\n {\n   bool global_scope_p;\n   bool nested_name_specifier_p;\n@@ -3197,7 +3201,8 @@ cp_parser_id_expression (cp_parser *parser,\n       /* Process the final unqualified-id.  */\n       unqualified_id = cp_parser_unqualified_id (parser, *template_p,\n \t\t\t\t\t\t check_dependency_p,\n-\t\t\t\t\t\t declarator_p);\n+\t\t\t\t\t\t declarator_p,\n+\t\t\t\t\t\t /*optional_p=*/false);\n       /* Restore the SAVED_SCOPE for our caller.  */\n       parser->scope = saved_scope;\n       parser->object_scope = saved_object_scope;\n@@ -3255,7 +3260,8 @@ cp_parser_id_expression (cp_parser *parser,\n   else\n     return cp_parser_unqualified_id (parser, template_keyword_p,\n \t\t\t\t     /*check_dependency_p=*/true,\n-\t\t\t\t     declarator_p);\n+\t\t\t\t     declarator_p,\n+\t\t\t\t     optional_p);\n }\n \n /* Parse an unqualified-id.\n@@ -3284,7 +3290,8 @@ static tree\n cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t  bool template_keyword_p,\n \t\t\t  bool check_dependency_p,\n-\t\t\t  bool declarator_p)\n+\t\t\t  bool declarator_p, \n+\t\t\t  bool optional_p)\n {\n   cp_token *token;\n \n@@ -3505,6 +3512,8 @@ cp_parser_unqualified_id (cp_parser* parser,\n       /* Fall through.  */\n \n     default:\n+      if (optional_p)\n+\treturn NULL_TREE;\n       cp_parser_error (parser, \"expected unqualified-id\");\n       return error_mark_node;\n     }\n@@ -4501,7 +4510,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t       cp_parser_optional_template_keyword (parser),\n \t       /*check_dependency_p=*/true,\n \t       &template_p,\n-\t       /*declarator_p=*/false));\n+\t       /*declarator_p=*/false,\n+\t       /*optional_p=*/false));\n       /* In general, build a SCOPE_REF if the member name is qualified.\n \t However, if the name was not dependent and has already been\n \t resolved; there is no need to build the SCOPE_REF.  For example;\n@@ -8623,7 +8633,8 @@ cp_parser_type_parameter (cp_parser* parser)\n \t\t\t\t\t /*template_keyword_p=*/false,\n \t\t\t\t\t /*check_dependency_p=*/true,\n \t\t\t\t\t /*template_p=*/&is_template,\n-\t\t\t\t\t /*declarator_p=*/false);\n+\t\t\t\t\t /*declarator_p=*/false,\n+\t\t\t\t\t /*optional_p=*/false);\n \t    if (TREE_CODE (default_argument) == TYPE_DECL)\n \t      /* If the id-expression was a template-id that refers to\n \t\t a template-class, we already have the declaration here,\n@@ -9177,7 +9188,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t      /*template_keyword_p=*/false,\n \t\t\t\t      /*check_dependency_p=*/true,\n \t\t\t\t      &template_p,\n-\t\t\t\t      /*declarator_p=*/false);\n+\t\t\t\t      /*declarator_p=*/false,\n+\t\t\t\t      /*optional_p=*/false);\n   /* If the next token isn't a `,' or a `>', then this argument wasn't\n      really finished.  */\n   if (!cp_parser_next_token_ends_template_argument_p (parser))\n@@ -10624,7 +10636,8 @@ cp_parser_using_declaration (cp_parser* parser)\n   identifier = cp_parser_unqualified_id (parser,\n \t\t\t\t\t /*template_keyword_p=*/false,\n \t\t\t\t\t /*check_dependency_p=*/true,\n-\t\t\t\t\t /*declarator_p=*/true);\n+\t\t\t\t\t /*declarator_p=*/true,\n+\t\t\t\t\t /*optional_p=*/false);\n \n   /* The function we call to handle a using-declaration is different\n      depending on what scope we are in.  */\n@@ -11515,25 +11528,31 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  tree qualifying_scope;\n \t  tree unqualified_name;\n \t  special_function_kind sfk;\n+\t  bool abstract_ok;\n \n \t  /* Parse a declarator-id */\n-\t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n+\t  abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);\n+\t  if (abstract_ok)\n \t    cp_parser_parse_tentatively (parser);\n-\t  unqualified_name = cp_parser_declarator_id (parser);\n+\t  unqualified_name \n+\t    = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);\n \t  qualifying_scope = parser->scope;\n-\t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n+\t  if (abstract_ok)\n \t    {\n \t      if (!cp_parser_parse_definitely (parser))\n \t\tunqualified_name = error_mark_node;\n-\t      else if (qualifying_scope\n-\t\t       || (TREE_CODE (unqualified_name)\n-\t\t\t   != IDENTIFIER_NODE))\n+\t      else if (unqualified_name\n+\t\t       && (qualifying_scope\n+\t\t\t   || (TREE_CODE (unqualified_name)\n+\t\t\t       != IDENTIFIER_NODE)))\n \t\t{\n \t\t  cp_parser_error (parser, \"expected unqualified-id\");\n \t\t  unqualified_name = error_mark_node;\n \t\t}\n \t    }\n \n+\t  if (!unqualified_name)\n+\t    return NULL;\n \t  if (unqualified_name == error_mark_node)\n \t    {\n \t      declarator = cp_error_declarator;\n@@ -11853,7 +11872,7 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n    unqualified-id.  */\n \n static tree\n-cp_parser_declarator_id (cp_parser* parser)\n+cp_parser_declarator_id (cp_parser* parser, bool optional_p)\n {\n   tree id;\n   /* The expression must be an id-expression.  Assume that qualified\n@@ -11874,8 +11893,9 @@ cp_parser_declarator_id (cp_parser* parser)\n \t\t\t\t/*template_keyword_p=*/false,\n \t\t\t\t/*check_dependency_p=*/false,\n \t\t\t\t/*template_p=*/NULL,\n-\t\t\t\t/*declarator_p=*/true);\n-  if (BASELINK_P (id))\n+\t\t\t\t/*declarator_p=*/true,\n+\t\t\t\toptional_p);\n+  if (id && BASELINK_P (id))\n     id = BASELINK_FUNCTIONS (id);\n   return id;\n }\n@@ -15298,7 +15318,6 @@ cp_parser_function_definition_from_specifiers_and_declarator\n   if (!success_p)\n     {\n       /* Skip the entire function.  */\n-      error (\"invalid function declaration\");\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n       fn = error_mark_node;\n     }\n@@ -17786,7 +17805,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n       name = cp_parser_id_expression (parser, /*template_p=*/false,\n \t\t\t\t      /*check_dependency_p=*/true,\n \t\t\t\t      /*template_p=*/NULL,\n-\t\t\t\t      /*declarator_p=*/false);\n+\t\t\t\t      /*declarator_p=*/false,\n+\t\t\t\t      /*optional_p=*/false);\n       if (name == error_mark_node)\n \tgoto skip_comma;\n "}, {"sha": "f3783b449da34e4cf50b149e2d7a1847c1414866", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -1,3 +1,11 @@\n+2006-04-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/27102\n+\t* g++.dg/template/crash35.C: Tweak error markers.\n+\t* g++.dg/template/crash46.C: New test.\n+\t* g++.old-deja/g++.brendan/friend4.C: Tweak error markers.\n+\t* g++.old-deja/g++.pt/incomplete1.C: Likewise.\n+\n 2006-04-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \tPR rtl-optimization/14261"}, {"sha": "348d91d0cafa2be887f008bc9ce0accbf1856b5f", "filename": "gcc/testsuite/g++.dg/template/crash35.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash35.C?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -5,5 +5,5 @@ template <typename T> struct C; // { dg-error \"declaration\" }\n \n template <typename T> void C<T>::f() // { dg-error \"invalid|template\" }\n {\n-  const foo bar; // { dg-error \"name a type\" }\n+  const foo bar;\n }"}, {"sha": "6fbda7c07672eece55f3d98a962da6cb2ad3d21f", "filename": "gcc/testsuite/g++.dg/template/crash46.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash46.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash46.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash46.C?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/27102\n+\n+template <class T>\n+void T::foo() {} // { dg-error \"invalid\" }\n+"}, {"sha": "4d436e5c9c6772f8aefeb1761e9d764b4321967a", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/friend4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Ffriend4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Ffriend4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Ffriend4.C?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -2,5 +2,5 @@\n // GROUPS passed friends\n // do_friend should complain that foo was declared as a friend of\n // A before A was defined\n-struct A;\n+struct A; // { dg-error \"forward\" } \n struct B { friend A::foo (); };// { dg-error \"\" } .*"}, {"sha": "9189df2227687eee3de65424dcc57c652257c9f2", "filename": "gcc/testsuite/g++.old-deja/g++.pt/incomplete1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fincomplete1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6098f8177ea7e73cfdcc291209cd47d40196ee/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fincomplete1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fincomplete1.C?ref=fa6098f8177ea7e73cfdcc291209cd47d40196ee", "patch": "@@ -6,6 +6,6 @@\n // Inspired by by 756. We'd ICE when trying to define a member of an\n // incomplete template type.\n \n-template<class X> struct ObjCount;  // { dg-error \"\" } forward decl\n+template<class X> struct ObjCount;\n \n template<class X> int ObjCount<X>::m; // { dg-error \"\" } undefined type"}]}