{"sha": "91ebb981ec251976ec43c36e7f2de101855d2b45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlYmI5ODFlYzI1MTk3NmVjNDNjMzZlN2YyZGUxMDE4NTVkMmI0NQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-11-06T10:48:18Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-11-06T10:48:18Z"}, "message": "NS/CF String format syntax parsing.\n\ngcc:\n\n\tPR target/44981\n\t* doc/extend.tex (format): Document NSString extension.\n\t(format_arg): Likewise.\n\t(Darwin Format Checks): New section.\n\t* doc/tm.texi: Document string object hooks (generated).\n\t* doc/tm.texi.in (TARGET_OBJC_CONSTRUCT_STRING_OBJECT) Rename.\n\t(TARGET_STRING_OBJECT_REF_TYPE_P): New.\n\t(TARGET_CHECK_STRING_OBJECT_FORMAT_ARG): New.\n\t* target.def (objc_construct_string_object): Rename, amend \n\tdocumentation.\n\t(string_object_ref_type_p): New hook.\n\t(check_string_object_format_arg): New hook.\n\t* c-parser.c (c_parser_attributes): Allow objective-c class names as\n\tattribute identifiers.\n\t* config/darwin-c.c (darwin_cfstring_ref_p): New.\n\t(darwin_check_cfstring_format_arg): New.\n\t(darwin_additional_format_types): New.\n\t* config/darwin-protos.h (darwin_cfstring_ref_p) New.\n\t(darwin_check_cfstring_format_arg): New.\n\t* config/darwin.h (TARGET_OBJC_CONSTRUCT_STRING_OBJECT) Renamed.\n\t(TARGET_STRING_OBJECT_REF_TYPE_P): New.\n\t(TARGET_N_FORMAT_TYPES): New.\n\t(TARGET_CHECK_STRING_OBJECT_FORMAT_ARG): New.\n\ngcc/c-family:\n\n\tPR target/44981\n\t* c-format.c (format_type): New type gcc_objc_string_format_type.\n\t(valid_stringptr_type_p): New.\n\t(handle_format_arg_attribute): Use valid_stringptr_type_p ().\n\t(check_format_string): Pass expected type, use \n\tvalid_stringptr_type_p (), check that the format string types are\n\tconsistent with the format specification.\n\t(decode_format_attr): Warn if NSString is used outside objective-c.\n\t(format_types_orig): Add NSString.\n\t(format_name): New.\n\t(format_flags): New.\n\t(check_format_arg): Handle format strings requiring an external parser.\n\tfirst_target_format_type: New variable.\n\t(handle_format_attribute): Set up first_target_format_type, pass the\n\texpected format arg string type to check_format_string().\n\t* c-common.h (FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL):  New flag.\n\t* stub-objc.c (objc_string_ref_type_p): New.\n\t(objc_check_format_arg): New.\n\ngcc/objc:\n\n\tPR target/44981\n\t* objc-act.c (objc_build_string_object): Amend for renamed hook.\n\t(objc_string_ref_type_p): New.\n\t(objc_check_format_arg): New.\n\ngcc/testsuite:\n\n\tPR target/44981\n\t* gcc.dg/darwin-cfstring-format-1.c: New.\n\t* gcc.dg/warn-nsstring.c: New.\n\t* objc.dg/fsf-nsstring-format-1.m: New.\n\t* obj-c++.dg/fsf-nsstring-format-1.mm: New.\n\t* obj-c++.dg/torture/strings/const-cfstring-1.mm: Update for darwin10\n\tlinker warning.\n\nFrom-SVN: r166398", "tree": {"sha": "af63074e9f4040f49a64cedb2d17c074c3c9f236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af63074e9f4040f49a64cedb2d17c074c3c9f236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91ebb981ec251976ec43c36e7f2de101855d2b45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ebb981ec251976ec43c36e7f2de101855d2b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ebb981ec251976ec43c36e7f2de101855d2b45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ebb981ec251976ec43c36e7f2de101855d2b45/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2952a37e88596fa92a77bb8ae9c7afac7e727d46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2952a37e88596fa92a77bb8ae9c7afac7e727d46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2952a37e88596fa92a77bb8ae9c7afac7e727d46"}], "stats": {"total": 601, "additions": 569, "deletions": 32}, "files": [{"sha": "e3f26e8969bb0f9ada648a29ed2f060c709da774", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1,3 +1,29 @@\n+2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/44981\n+\t* doc/extend.tex (format): Document NSString extension.\n+\t(format_arg): Likewise.\n+\t(Darwin Format Checks): New section.\n+\t* doc/tm.texi: Document string object hooks (generated).\n+\t* doc/tm.texi.in (TARGET_OBJC_CONSTRUCT_STRING_OBJECT) Rename.\n+\t(TARGET_STRING_OBJECT_REF_TYPE_P): New.\n+\t(TARGET_CHECK_STRING_OBJECT_FORMAT_ARG): New.\n+\t* target.def (objc_construct_string_object): Rename, amend \n+\tdocumentation.\n+\t(string_object_ref_type_p): New hook.\n+\t(check_string_object_format_arg): New hook.\n+\t* c-parser.c (c_parser_attributes): Allow objective-c class names as\n+\tattribute identifiers.\n+\t* config/darwin-c.c (darwin_cfstring_ref_p): New.\n+\t(darwin_check_cfstring_format_arg): New.\n+\t(darwin_additional_format_types): New.\n+\t* config/darwin-protos.h (darwin_cfstring_ref_p) New.\n+\t(darwin_check_cfstring_format_arg): New.\n+\t* config/darwin.h (TARGET_OBJC_CONSTRUCT_STRING_OBJECT) Renamed.\n+\t(TARGET_STRING_OBJECT_REF_TYPE_P): New.\n+\t(TARGET_N_FORMAT_TYPES): New.\n+\t(TARGET_CHECK_STRING_OBJECT_FORMAT_ARG): New.\n+\n 2010-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n             Pascal Obry  <obry@adacore.com>\n "}, {"sha": "1164d919d0eb249c2e79f4ba1073db6035a689da", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1,3 +1,24 @@\n+2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/44981\n+\t* c-format.c (format_type): New type gcc_objc_string_format_type.\n+\t(valid_stringptr_type_p): New.\n+\t(handle_format_arg_attribute): Use valid_stringptr_type_p ().\n+\t(check_format_string): Pass expected type, use \n+\tvalid_stringptr_type_p (), check that the format string types are\n+\tconsistent with the format specification.\n+\t(decode_format_attr): Warn if NSString is used outside objective-c.\n+\t(format_types_orig): Add NSString.\n+\t(format_name): New.\n+\t(format_flags): New.\n+\t(check_format_arg): Handle format strings requiring an external parser.\n+\tfirst_target_format_type: New variable.\n+\t(handle_format_attribute): Set up first_target_format_type, pass the\n+\texpected format arg string type to check_format_string().\n+\t* c-common.h (FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL):  New flag.\n+\t* stub-objc.c (objc_string_ref_type_p): New.\n+\t(objc_check_format_arg): New.\n+\n 2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tFixed using the Objective-C 2.0 dot-syntax with class names.\t"}, {"sha": "58d3a321e0f6bab82510c7d3b62fdfb256a3846b", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1043,6 +1043,8 @@ extern void objc_add_synthesize_declaration (location_t, tree);\n extern void objc_add_dynamic_declaration (location_t, tree);\n extern const char * objc_maybe_printable_name (tree, int);\n extern bool objc_is_property_ref (tree);\n+extern bool objc_string_ref_type_p (tree);\n+extern void objc_check_format_arg (tree, tree);\n \n /* The following are provided by the C and C++ front-ends, and called by\n    ObjC/ObjC++.  */"}, {"sha": "a64717a5510040fac8f492e6378d0fdbcc43211a", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 178, "deletions": 14, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"c-format.h\"\n #include \"alloc-pool.h\"\n+#include \"target.h\"\n \f\n /* Set format warning options according to a -Wformat=n option.  */\n \n@@ -63,6 +64,7 @@ enum format_type { printf_format_type, asm_fprintf_format_type,\n \t\t   gcc_diag_format_type, gcc_tdiag_format_type,\n \t\t   gcc_cdiag_format_type,\n \t\t   gcc_cxxdiag_format_type, gcc_gfc_format_type,\n+\t\t   gcc_objc_string_format_type,\n \t\t   format_type_error = -1};\n \n typedef struct function_format_info\n@@ -77,12 +79,38 @@ static int decode_format_type (const char *);\n \n static bool check_format_string (tree argument,\n \t\t\t\t unsigned HOST_WIDE_INT format_num,\n-\t\t\t\t int flags, bool *no_add_attrs);\n+\t\t\t\t int flags, bool *no_add_attrs,\n+\t\t\t\t int expected_format_type);\n static bool get_constant (tree expr, unsigned HOST_WIDE_INT *value,\n \t\t\t  int validated_p);\n static const char *convert_format_name_to_system_name (const char *attr_name);\n static bool cmp_attribs (const char *tattr_name, const char *attr_name);\n \n+static int first_target_format_type;\n+static const char *format_name (int format_num);\n+static int format_flags (int format_num);\n+\n+/* Check that we have a pointer to a string suitable for use as a format.\n+   The default is to check for a char type.\n+   For objective-c dialects, this is extended to include references to string\n+   objects validated by objc_string_ref_type_p ().  \n+   Targets may also provide a string object type that can be used within c and \n+   c++ and shared with their respective objective-c dialects. In this case the\n+   reference to a format string is checked for validity via a hook.\n+   \n+   The function returns true if strref points to any string type valid for the \n+   language dialect and target.  */\n+\n+static bool\n+valid_stringptr_type_p (tree strref)\n+{\n+  return (strref != NULL\n+\t  && TREE_CODE (strref) == POINTER_TYPE\n+\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (strref)) == char_type_node\n+\t      || objc_string_ref_type_p (strref)\n+\t      || (*targetcm.string_object_ref_type_p) ((const_tree) strref)));\n+}\n+\n /* Handle a \"format_arg\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n@@ -104,13 +132,13 @@ handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n   argument = TYPE_ARG_TYPES (type);\n   if (argument)\n     {\n-      if (!check_format_string (argument, format_num, flags, no_add_attrs))\n+      /* The format arg can be any string reference valid for the language and\n+         target.  We cannot be more specific in this case.  */\n+      if (!check_format_string (argument, format_num, flags, no_add_attrs, -1))\n \treturn NULL_TREE;\n     }\n \n-  if (TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n-      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n-\t  != char_type_node))\n+  if (!valid_stringptr_type_p (TREE_TYPE (type)))\n     {\n       if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n \terror (\"function does not return string type\");\n@@ -121,13 +149,18 @@ handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n   return NULL_TREE;\n }\n \n-/* Verify that the format_num argument is actually a string, in case\n-   the format attribute is in error.  */\n+/* Verify that the format_num argument is actually a string reference suitable,\n+   for the language dialect and target (in case the format attribute is in \n+   error).  When we know the specific reference type expected, this is also \n+   checked.  */\n static bool\n check_format_string (tree argument, unsigned HOST_WIDE_INT format_num,\n-\t\t     int flags, bool *no_add_attrs)\n+\t\t     int flags, bool *no_add_attrs, int expected_format_type)\n {\n   unsigned HOST_WIDE_INT i;\n+  bool is_objc_sref, is_target_sref, is_char_ref;\n+  tree ref;\n+  int fmt_flags;\n \n   for (i = 1; i != format_num; i++)\n     {\n@@ -137,17 +170,78 @@ check_format_string (tree argument, unsigned HOST_WIDE_INT format_num,\n     }\n \n   if (!argument\n-      || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t  != char_type_node))\n+      || !(ref = TREE_VALUE (argument))\n+      || !valid_stringptr_type_p (ref))\n     {\n       if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\terror (\"format string argument not a string type\");\n+\terror (\"format string argument is not a string type\");\n       *no_add_attrs = true;\n       return false;\n     }\n \n-  return true;\n+  /* We only know that we want a suitable string reference.  */\n+  if (expected_format_type < 0)\n+    return true;\n+\n+  /* Now check that the arg matches the expected type.  */\n+  is_char_ref = \n+    (TYPE_MAIN_VARIANT (TREE_TYPE (ref)) == char_type_node);\n+\n+  fmt_flags = format_flags (expected_format_type);\n+  is_objc_sref = is_target_sref = false;\n+  if (!is_char_ref)\n+    is_objc_sref = objc_string_ref_type_p (ref);\n+\n+  if (!(fmt_flags & FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL))\n+    {\n+      if (is_char_ref)\n+\treturn true; /* OK, we expected a char and found one.  */\n+      else\n+\t{\n+\t  /* We expected a char but found an extended string type.  */\n+\t  if (is_objc_sref)\n+\t    error (\"found a %<%s%> reference but the format argument should\"\n+\t\t   \" be a string\", format_name (gcc_objc_string_format_type));\n+\t  else\n+\t    error (\"found a %qT but the format argument should be a string\",\n+\t\t   ref);\n+\t  *no_add_attrs = true;\n+\t  return false;\n+\t}\n+    }\n+\n+  /* We expect a string object type as the format arg.  */\n+  if (is_char_ref)\n+    {\n+      error (\"format argument should be a %<%s%> reference but\"\n+\t     \" a string was found\", format_name (expected_format_type));\n+      *no_add_attrs = true;\n+      return false;\n+    }\n+  \n+  /* We will assert that objective-c will support either its own string type\n+     or the target-supplied variant.  */\n+  if (!is_objc_sref)\n+    is_target_sref = (*targetcm.string_object_ref_type_p) ((const_tree) ref);\n+\n+  if (expected_format_type == (int) gcc_objc_string_format_type \n+      && (is_objc_sref || is_target_sref))\n+    return true;\n+\n+  /* We will allow a target string ref to match only itself.  */\n+  if (first_target_format_type \n+      && expected_format_type >= first_target_format_type\n+      && is_target_sref)\n+    return true;\n+  else\n+    {\n+      error (\"format argument should be a %<%s%> reference\", \n+\t      format_name (expected_format_type));\n+      *no_add_attrs = true;\n+      return false;\n+    }\n+\n+  gcc_unreachable ();\n }\n \n /* Verify EXPR is a constant, and store its value.\n@@ -195,6 +289,16 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n       p = convert_format_name_to_system_name (p);\n \n       info->format_type = decode_format_type (p);\n+      \n+      if (!c_dialect_objc ()\n+\t   && info->format_type == gcc_objc_string_format_type)\n+\t{\n+\t  gcc_assert (!validated_p);\n+\t  warning (OPT_Wformat, \"%qE is only allowed in Objective-C dialects\",\n+\t\t   format_type_id);\n+\t  info->format_type = format_type_error;\n+\t  return false;\n+\t}\n \n       if (info->format_type == format_type_error)\n \t{\n@@ -750,6 +854,11 @@ static const format_kind_info format_types_orig[] =\n     0, 0, 0, 0, 0, 0,\n     NULL, NULL\n   },\n+  { \"NSString\",   NULL,  NULL, NULL, NULL,\n+    NULL, NULL,\n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL, 0, 0, 0, 0, 0, 0,\n+    NULL, NULL\n+  },\n   { \"gnu_scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL,\n     scanf_flag_specs, scanf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,\n@@ -812,6 +921,26 @@ typedef struct\n   tree params;\n } format_check_context;\n \n+/* Return the format name (as specified in the original table) for the format\n+   type indicated by format_num.  */\n+static const char *\n+format_name (int format_num)\n+{\n+  if (format_num >= 0 && format_num < n_format_types)\n+    return format_types[format_num].name;\n+  gcc_unreachable ();\n+}\n+\n+/* Return the format flags (as specified in the original table) for the format\n+   type indicated by format_num.  */\n+static int\n+format_flags (int format_num)\n+{\n+  if (format_num >= 0 && format_num < n_format_types)\n+    return format_types[format_num].flags;\n+  gcc_unreachable ();\n+}\n+\n static void check_format_info (function_format_info *, tree);\n static void check_format_arg (void *, tree, unsigned HOST_WIDE_INT);\n static void check_format_info_main (format_check_results *,\n@@ -1349,6 +1478,39 @@ check_format_arg (void *ctx, tree format_tree,\n       return;\n     }\n   format_tree = TREE_OPERAND (format_tree, 0);\n+  if (format_types[info->format_type].flags \n+      & (int) FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL)\n+    {\n+      bool objc_str = (info->format_type == gcc_objc_string_format_type);\n+      /* We cannot examine this string here - but we can check that it is\n+         a valid type.  */\n+      if (TREE_CODE (format_tree) != CONST_DECL\n+\t  || !((objc_str && objc_string_ref_type_p (TREE_TYPE (format_tree)))\n+\t\t|| (*targetcm.string_object_ref_type_p) \n+\t\t\t\t     ((const_tree) TREE_TYPE (format_tree))))\n+\t{\n+\t  res->number_non_literal++;\n+\t  return;\n+\t}\n+      /* Skip to first argument to check.  */\n+      while (arg_num + 1 < info->first_arg_num)\n+\t{\n+\t  if (params == 0)\n+\t    return;\n+\t  params = TREE_CHAIN (params);\n+\t  ++arg_num;\n+\t}\n+      /* So, we have a valid literal string object and one or more params.\n+         We need to use an external helper to parse the string into format\n+         info.  For Objective-C variants we provide the resource within the\n+         objc tree, for target variants, via a hook.  */\n+      if (objc_str)\n+\tobjc_check_format_arg (format_tree, params);\n+      else if (targetcm.check_string_object_format_arg)\n+\t(*targetcm.check_string_object_format_arg) (format_tree, params);\n+      /* Else we can't handle it and retire quietly.  */\n+      return;\n+    }\n   if (TREE_CODE (format_tree) == ARRAY_REF\n       && host_integerp (TREE_OPERAND (format_tree, 1), 0)\n       && (offset += tree_low_cst (TREE_OPERAND (format_tree, 1), 0)) >= 0)\n@@ -2785,6 +2947,8 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t      TARGET_N_FORMAT_TYPES * sizeof (dynamic_format_types[0]));\n \n       format_types = dynamic_format_types;\n+      /* Provide a reference for the first potential external type.  */\n+      first_target_format_type = n_format_types;\n       n_format_types += TARGET_N_FORMAT_TYPES;\n     }\n #endif\n@@ -2799,7 +2963,7 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   if (argument)\n     {\n       if (!check_format_string (argument, info.format_num, flags,\n-\t\t\t\tno_add_attrs))\n+\t\t\t\tno_add_attrs, info.format_type))\n \treturn NULL_TREE;\n \n       if (info.first_arg_num != 0)"}, {"sha": "286219b16df9b3f81de356fa2e012445a5d89785", "filename": "gcc/c-family/c-format.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.h?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1,6 +1,6 @@\n /* Check calls to formatted I/O functions (-Wformat).\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2007, 2008, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -73,7 +73,10 @@ enum\n   FMT_FLAG_EMPTY_PREC_OK = 64,\n   /* Gaps are allowed in the arguments with $ operand numbers if all\n      arguments are pointers (scanf).  */\n-  FMT_FLAG_DOLLAR_GAP_POINTER_OK = 128\n+  FMT_FLAG_DOLLAR_GAP_POINTER_OK = 128,\n+  /* The format arg is an opaque object that will be parsed by an external\n+     facility.  */\n+  FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL = 256\n   /* Not included here: details of whether width or precision may occur\n      (controlled by width_char and precision_char); details of whether\n      '*' can be used for these (width_type and precision_type); details"}, {"sha": "9dd6ef52f89a63c5b4c1fae985682bce8f3a2e6c", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -2,7 +2,7 @@\n    that are called from within the C and C++ front-ends,\n    respectively.\n    Copyright (C) 1991, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n-   2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   2004, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -440,3 +440,15 @@ void\n objc_write_global_declarations (void)\n {\n }\n+\n+bool\n+objc_string_ref_type_p (tree ARG_UNUSED (strp))\n+{\n+   return false;\n+}\n+\n+void\n+objc_check_format_arg (tree ARG_UNUSED (format_arg), \n+\t\t       tree ARG_UNUSED (args_list))\n+{\n+}"}, {"sha": "e7403b2b182129a4afe73e0548292c089df83ac8", "filename": "gcc/c-parser.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -3278,9 +3278,12 @@ c_parser_attributes (c_parser *parser)\n \t  /* Parse the attribute contents.  If they start with an\n \t     identifier which is followed by a comma or close\n \t     parenthesis, then the arguments start with that\n-\t     identifier; otherwise they are an expression list.  */\n+\t     identifier; otherwise they are an expression list.  \n+\t     In objective-c the identifier may be a classname.  */\n \t  if (c_parser_next_token_is (parser, CPP_NAME)\n-\t      && c_parser_peek_token (parser)->id_kind == C_ID_ID\n+\t      && (c_parser_peek_token (parser)->id_kind == C_ID_ID\n+\t\t  || (c_dialect_objc () \n+\t\t      && c_parser_peek_token (parser)->id_kind == C_ID_CLASSNAME))\n \t      && ((c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n \t\t  || (c_parser_peek_2nd_token (parser)->type\n \t\t      == CPP_CLOSE_PAREN)))"}, {"sha": "99b6db1637d38aa6f17cd3e7daee24451db68d22", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1,5 +1,5 @@\n /* Darwin support needed only by C/C++ frontends.\n-   Copyright (C) 2001, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2001, 2003, 2004, 2005, 2007, 2008, 2010\n    Free Software Foundation, Inc.\n    Contributed by Apple Computer Inc.\n \n@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"incpath.h\"\n #include \"c-family/c-common.h\"\n #include \"c-family/c-pragma.h\"\n+#include \"c-family/c-format.h\"\n #include \"diagnostic-core.h\"\n #include \"toplev.h\"\n #include \"flags.h\"\n@@ -678,3 +679,37 @@ darwin_objc_construct_string (tree str)\n \n   return darwin_build_constant_cfstring (str);\n }\n+\n+/* The string ref type is created as CFStringRef by <CFBase.h> therefore, we\n+   must match for it explicitly, since it's outside the gcc code.  */\n+\n+bool\n+darwin_cfstring_ref_p (const_tree strp)\n+{\n+  tree tn;\n+  if (!strp || TREE_CODE (strp) != POINTER_TYPE)\n+    return false;\n+\n+  tn = TYPE_NAME (strp);\n+  if (tn) \n+    tn = DECL_NAME (tn);\n+  return (tn \n+\t  && IDENTIFIER_POINTER (tn)\n+\t  && !strncmp (IDENTIFIER_POINTER (tn), \"CFStringRef\", 8));\n+}\n+\n+/* At present the behavior of this is undefined and it does nothing.  */\n+void\n+darwin_check_cfstring_format_arg (tree ARG_UNUSED (format_arg), \n+\t\t\t\t  tree ARG_UNUSED (args_list))\n+{\n+}\n+\n+/* The extra format types we recognize.  */\n+const format_kind_info darwin_additional_format_types[] = {\n+  { \"CFString\",   NULL,  NULL, NULL, NULL, \n+    NULL, NULL, \n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL, 0, 0, 0, 0, 0, 0,\n+    NULL, NULL\n+  }\n+};"}, {"sha": "e70de1bee80433b24b04a839c36fd4c7881640f8", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -97,7 +97,9 @@ extern void darwin_init_cfstring_builtins (unsigned);\n extern tree darwin_fold_builtin (tree, int, tree *, bool);\n extern tree darwin_objc_construct_string (tree);\n extern bool darwin_cfstring_p (tree);\n-extern tree darwin_build_constant_cfstring (tree str);\n+extern bool darwin_cfstring_ref_p (const_tree);\n+extern void darwin_check_cfstring_format_arg (tree, tree);\n+extern tree darwin_build_constant_cfstring (tree);\n extern void darwin_enter_string_into_cfstring_table (tree);\n \n extern void darwin_asm_output_anchor (rtx symbol);"}, {"sha": "ffed58a1300ef4d3a54ecf1130b081706614c60f", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1023,9 +1023,18 @@ __enable_execute_stack (void *addr)                                     \\\n /* We have target-specific builtins.  */\n #define TARGET_FOLD_BUILTIN darwin_fold_builtin\n \n-#define TARGET_OBJC_CONSTRUCT_STRING \\\n+#define TARGET_OBJC_CONSTRUCT_STRING_OBJECT \\\n   darwin_objc_construct_string\n \n+#define TARGET_STRING_OBJECT_REF_TYPE_P \\\n+  darwin_cfstring_ref_p\n+\n+#define TARGET_N_FORMAT_TYPES 1\n+#define TARGET_FORMAT_TYPES darwin_additional_format_types\n+\n+#define TARGET_CHECK_STRING_OBJECT_FORMAT_ARG \\\n+  darwin_check_cfstring_format_arg\n+\n #define TARGET_HAS_TARGETCM 1\n \n #ifndef CROSS_DIRECTORY_STRUCTURE"}, {"sha": "577c35a15adc107dbe25c3c77e828f897c574cac", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -2418,7 +2418,13 @@ standard modes, the X/Open function @code{strfmon} is also checked as\n are @code{printf_unlocked} and @code{fprintf_unlocked}.\n @xref{C Dialect Options,,Options Controlling C Dialect}.\n \n-The target may provide additional types of format checks.\n+For Objective-C dialects, @code{NSString} (or @code{__NSString__}) is \n+recognized in the same context.  Declarations including these format attributes\n+will be parsed for correct syntax, however the result of checking of such format\n+strings is not yet defined, and will not be carried out by this version of the \n+compiler.\n+\n+The target may also provide additional types of format checks.\n @xref{Target Format Checks,,Format Checks Specific to Particular\n Target Machines}.\n \n@@ -2467,6 +2473,14 @@ requested by @option{-ansi} or an appropriate @option{-std} option, or\n is used.  @xref{C Dialect Options,,Options\n Controlling C Dialect}.\n \n+For Objective-C dialects, the @code{format-arg} attribute may refer to an\n+@code{NSString} reference for compatibility with the @code{format} attribute\n+above.\n+\n+The target may also allow additional types in @code{format-arg} attributes.\n+@xref{Target Format Checks,,Format Checks Specific to Particular\n+Target Machines}.\n+\n @item function_vector\n @cindex calling functions through the function vector on H8/300, M16C, M32C and SH2A processors\n Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified\n@@ -12426,6 +12440,7 @@ format attribute\n \n @menu\n * Solaris Format Checks::\n+* Darwin Format Checks::\n @end menu\n \n @node Solaris Format Checks\n@@ -12436,6 +12451,20 @@ check.  @code{cmn_err} accepts a subset of the standard @code{printf}\n conversions, and the two-argument @code{%b} conversion for displaying\n bit-fields.  See the Solaris man page for @code{cmn_err} for more information.\n \n+@node Darwin Format Checks\n+@subsection Darwin Format Checks\n+\n+Darwin targets support the @code{CFString} (or @code{__CFString__}) in the format \n+attribute context.  Declarations made with such attribution will be parsed for correct syntax\n+and format argument types.  However, parsing of the format string itself is currently undefined\n+and will not be carried out by this version of the compiler.  \n+\n+Additionally, @code{CFStringRefs} (defined by the @code{CoreFoundation} headers) may\n+also be used as format arguments.  Note that the relevant headers are only likely to be\n+available on Darwin (OSX) installations.  On such installations, the XCode and system\n+documentation provide descriptions of @code{CFString}, @code{CFStringRefs} and\n+associated functions.\n+\n @node Pragmas\n @section Pragmas Accepted by GCC\n @cindex pragmas"}, {"sha": "7666fcfd401d5dd006b21ecce1d9a6af284f62c5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -715,8 +715,16 @@ only available in the C (and related language) front ends, then you\n should use @code{TARGET_HANDLE_C_OPTION} instead.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_OBJC_CONSTRUCT_STRING (tree @var{string})\n-Construct a constant string representation for @var{string}\n+@deftypefn {Target Hook} tree TARGET_OBJC_CONSTRUCT_STRING_OBJECT (tree @var{string})\n+Targets may provide a string object type that can be used within and between C, C++ and their respective Objective-C dialects. A string object might, for example, embed encoding and length information. These objects are considered opaque to the compiler and handled as references. An ideal implementation makes the composition of the string object match that of the Objective-C @code{NSString} (@code{NXString} for GNUStep), allowing efficient interworking between C-only and Objective-C code. If a target implements string objects then this hook should return a reference to such an object constructed from the normal `C' string representation provided in @var{string}. At present, the hook is used by Objective-C only, to obtain a common-format string object when the target provides one.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_STRING_OBJECT_REF_TYPE_P (const_tree @var{stringref})\n+If a target implements string objects then this hook should return @code{true} if @var{stringref} is a valid reference to such an object.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_CHECK_STRING_OBJECT_FORMAT_ARG (tree @var{format_arg}, tree @var{args_list})\n+If a target implements string objects then this hook should should  provide a facility to check the function arguments in @var{args_list}  against the format specifiers in @var{format_arg} where the type of  @var{format_arg} is one recognized as a valid string reference type.\n @end deftypefn\n \n @defmac TARGET_VERSION"}, {"sha": "b0c4bccc70422aee35abfabb43c6ab8ff345d81f", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -715,7 +715,11 @@ only available in the C (and related language) front ends, then you\n should use @code{TARGET_HANDLE_C_OPTION} instead.\n @end deftypefn\n \n-@hook TARGET_OBJC_CONSTRUCT_STRING\n+@hook TARGET_OBJC_CONSTRUCT_STRING_OBJECT\n+\n+@hook TARGET_STRING_OBJECT_REF_TYPE_P\n+\n+@hook TARGET_CHECK_STRING_OBJECT_FORMAT_ARG\n \n @defmac TARGET_VERSION\n This macro is a C statement to print on @code{stderr} a string"}, {"sha": "104948ba908b507b56f277472ee19b1aff660840", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1,3 +1,10 @@\n+2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/44981\n+\t* objc-act.c (objc_build_string_object): Amend for renamed hook.\n+\t(objc_string_ref_type_p): New.\n+\t(objc_check_format_arg): New.\n+\n 2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tFixed using the Objective-C 2.0 dot-syntax with class names.\t"}, {"sha": "02966a89fdf1cce44fcd9b59c9a31f46829944f0", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"c-family/c-common.h\"\n #include \"c-family/c-pragma.h\"\n+#include \"c-family/c-format.h\"\n #include \"flags.h\"\n #include \"langhooks.h\"\n #include \"objc-act.h\"\n@@ -2755,9 +2756,9 @@ objc_build_string_object (tree string)\n      literal.  On Darwin (Mac OS X), for example, we may wish to obtain a \n      constant CFString reference instead.\n      At present, this is only supported for the NeXT runtime.  */\n-  if (flag_next_runtime && targetcm.objc_construct_string)\n+  if (flag_next_runtime && targetcm.objc_construct_string_object)\n     {\n-      tree constructor = (*targetcm.objc_construct_string) (string);\n+      tree constructor = (*targetcm.objc_construct_string_object) (string);\n       if (constructor)\n \treturn build1 (NOP_EXPR, objc_object_type, constructor);\n     }\n@@ -12673,4 +12674,28 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   /* Done by c-parser.c  */\n }\n \n+/* Return true if we have an NxString object pointer.  */\n+\n+bool\n+objc_string_ref_type_p (tree strp)\n+{\n+  tree tmv;\n+  if (!strp || TREE_CODE (strp) != POINTER_TYPE)\n+    return false;\n+\n+  tmv = TYPE_MAIN_VARIANT (TREE_TYPE (strp));\n+  tmv = OBJC_TYPE_NAME (tmv);\n+  return (tmv\n+  \t  && TREE_CODE (tmv) == IDENTIFIER_NODE\n+  \t  && IDENTIFIER_POINTER (tmv)\n+\t  && !strncmp (IDENTIFIER_POINTER (tmv), \"NSString\", 8));\n+}\n+\n+/* At present the behavior of this is undefined and it does nothing.  */\n+void\n+objc_check_format_arg (tree ARG_UNUSED (format_arg), \n+\t\t       tree ARG_UNUSED (args_list))\n+{\n+}\n+\n #include \"gt-objc-objc-act.h\""}, {"sha": "7e014c7e625edd45d973cfd17e006a5db21db785", "filename": "gcc/target.def", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -2648,10 +2648,40 @@ DEFHOOK\n  bool, (size_t code, const char *arg, int value),\n  default_handle_c_option)\n \n-DEFHOOK\n-(objc_construct_string,\n- \"Construct a constant string representation for @var{string}\",\n+/* Targets may provide a string object type that can be used within\n+   and between C, C++, and Objective-C dialects.  */\n+\n+DEFHOOK\n+(objc_construct_string_object,\n+ \"Targets may provide a string object type that can be used within\\\n+ and between C, C++ and their respective Objective-C dialects.\\\n+ A string object might, for example, embed encoding and length information.\\\n+ These objects are considered opaque to the compiler and handled as references.\\\n+ An ideal implementation makes the composition of the string object\\\n+ match that of the Objective-C @code{NSString} (@code{NXString} for GNUStep),\\\n+ allowing efficient interworking between C-only and Objective-C code.\\\n+ If a target implements string objects then this hook should return a\\\n+ reference to such an object constructed from the normal `C' string\\\n+ representation provided in @var{string}.\\\n+ At present, the hook is used by Objective-C only, to obtain a\\\n+ common-format string object when the target provides one.\",\n  tree, (tree string),\n  NULL)\n+ \n+DEFHOOK\n+(string_object_ref_type_p,\n+ \"If a target implements string objects then this hook should return\\\n+ @code{true} if @var{stringref} is a valid reference to such an object.\",\n+ bool, (const_tree stringref),\n+ hook_bool_const_tree_false)\n \n+DEFHOOK\n+(check_string_object_format_arg,\n+ \"If a target implements string objects then this hook should should\\\n+  provide a facility to check the function arguments in @var{args_list}\\\n+  against the format specifiers in @var{format_arg} where the type of\\\n+  @var{format_arg} is one recognized as a valid string reference type.\",\n+ void, (tree format_arg, tree args_list),\n+ NULL)\n+ \n HOOK_VECTOR_END (C90_EMPTY_HACK)"}, {"sha": "4db13137877ba1086a89b7e7f29313d17755fe32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -1,3 +1,13 @@\n+2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/44981\n+\t* gcc.dg/darwin-cfstring-format-1.c: New.\n+\t* gcc.dg/warn-nsstring.c: New.\n+\t* objc.dg/fsf-nsstring-format-1.m: New.\n+\t* obj-c++.dg/fsf-nsstring-format-1.mm: New.\n+\t* obj-c++.dg/torture/strings/const-cfstring-1.mm: Update for darwin10\n+\tlinker warning.\n+\n 2010-11-05  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/45473"}, {"sha": "8771d526fe04e775178e26855b05e0f379bee684", "filename": "gcc/testsuite/gcc.dg/darwin-cfstring-format-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-cfstring-format-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-cfstring-format-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-cfstring-format-1.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -0,0 +1,36 @@\n+/* Check CFString format extensions.  */\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-Wall\" } */\n+\n+extern int printf (const char *fmt, ...);\n+\n+typedef const struct __CFString * CFStringRef;\n+\n+#ifdef __CONSTANT_CFSTRINGS__\n+#define CFSTR(cStr)  ((CFStringRef) __builtin___CFStringMakeConstantString (\"\" cStr \"\"))\n+#else\n+#error requires CFString\n+#endif\n+\n+int s1 (CFStringRef fmt, ...) __attribute__((format(CFString, 1, 2))) ; /* OK */\n+int s2 (int a, CFStringRef fmt, ... ) __attribute__((format(__CFString__, 2, 3))) ; /* OK */\n+\n+int s2a (int a, CFStringRef fmt, ... ) __attribute__((format(CFString, 2, 2))) ; /* { dg-error \"format string argument follows the args to be formatted\" } */\n+\n+int s3 (const char *fmt, ... ) __attribute__((format(__CFString__, 1, 2))) ; /* { dg-error \"format argument should be a .CFString. reference but a string was found\" } */\n+int s4 (CFStringRef fmt, ... ) __attribute__((format(printf, 1, 2))) ; /* { dg-error \"found a .CFStringRef. but the format argument should be a string\" } */\n+\n+char *s5 (char dum, char *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+CFStringRef s6 (CFStringRef dum, CFStringRef fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+\n+char *s7 (int dum, void *fmt1, ... ) __attribute__((format_arg(2))) ; /* { dg-error \"format string argument is not a string type\" } */\n+int s8 (CFStringRef dum, CFStringRef fmt1, ... ) __attribute__((format_arg(2))) ; /* { dg-error \"function does not return string type\" } */\n+\n+void foo (void)\n+{\n+  CFStringRef notchk = CFSTR (\"here is an unchecked %d %s string\");\n+  s1 (notchk, 5, 6, 7);\n+  printf(\"this one is checked %d %s\", 3, 4, 5); /* { dg-warning \"format .%s. expects type .char .., but argument 3 has type .int.\" } */\n+\t\t\t/* { dg-warning \"too many arguments for format\" \"\" { target *-*-* } 33 } */\n+  printf(s5 (1, \"and so is this %d %d %s\", 3, 4, \"hey\", 6), 5, 6, 12);/* { dg-warning \"format .%s. expects type .char .., but argument 4 has type .int.\" } */\n+}\n\\ No newline at end of file"}, {"sha": "3795fb7376b33c02067fd3fc4e540efbb13a16d8", "filename": "gcc/testsuite/gcc.dg/warn-nsstring.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-nsstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-nsstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-nsstring.c?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -0,0 +1,7 @@\n+/* Check that the NSString format extension is rejected in c.  */\n+/* { dg-do compile } */\n+\n+extern void NSLog (void *fmt, ...) __attribute__((format(__NSString__, 1, 2))); /* { dg-warning \"is only allowed in Objective-C dialects\" } */\n+extern void NSLog1 (void *fmt, ...) __attribute__((format(NSString, 1, 2))); /* { dg-warning \"is only allowed in Objective-C dialects\" } */\n+\n+"}, {"sha": "324995be725e571378ca9b6c2c2674b1e479d216", "filename": "gcc/testsuite/lib/gcc-defs.exp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -223,8 +223,14 @@ proc dg-additional-files-options { options source } {\n \tset additional_sources \"\"\n     }\n     if { $additional_files != \"\" } then { \n-\tregsub -all \" \" $additional_files \" [file dirname $source]/\" additional_files\n+\tregsub -all \"^| \" $additional_files \" [file dirname $source]/\" additional_files\n \tset to_download [concat $to_download $additional_files]\n+\tsend_log \"add files: $to_download\\n\"\n+\tif ![is_remote host] {\n+\t    foreach file $to_download {\n+\t\tremote_download host $file\n+\t    }\n+\t}\n \tset additional_files \"\"\n     }\n     if [is_remote host] {"}, {"sha": "6e58e65dc7b77fe4fafe13fb7525f56f1258b25e", "filename": "gcc/testsuite/obj-c++.dg/fsf-nsstring-format-1.mm", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ffsf-nsstring-format-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ffsf-nsstring-format-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ffsf-nsstring-format-1.mm?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -0,0 +1,51 @@\n+/* Check NSString format extensions.  */\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+/* { dg-options \"-Wall\" } */\n+\n+#ifndef __CONSTANT_CFSTRINGS__\n+#error requires CFString\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern int printf (const char *fmt, ...);\n+typedef const struct __CFString * CFStringRef;\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+@class NSString;\n+\n+int s1 (NSString *fmt, ...) __attribute__((format(NSString, 1, 2))) ; /* OK */\n+/* A CFString can represent an NSString.  */\n+int s1a (CFStringRef fmt, ...) __attribute__((format(NSString, 1, 2))) ; /* OK */\n+/* But... it is possible that a CFString format might imply functionality that\n+   is not present in objective-c.  */\n+int s1b (NSString *fmt, ...) __attribute__((format(CFString, 1, 2))) ; /* { dg-error \"format argument should be a .CFString. reference\" } */\n+\n+int s2 (int a, NSString *fmt, ... ) __attribute__((format(__NSString__, 2, 3))) ; /* OK */\n+\n+int s2a (int a, NSString *fmt, ... ) __attribute__((format(NSString, 2, 2))) ; /* { dg-error \"format string argument follows the args to be formatted\" } */\n+\n+int s3 (const char *fmt, ... ) __attribute__((format(__NSString__, 1, 2))) ; /* { dg-error \"format argument should be a .NSString. reference but a string was found\" } */\n+int s4 (NSString *fmt, ... ) __attribute__((format(printf, 1, 2))) ; /* { dg-error \"found a .NSString. reference but the format argument should be a string\" } */\n+\n+char *s5 (char dum, char *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+NSString *s6 (NSString *dum, NSString *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+\n+char *s7 (int dum, void *fmt1, ... ) __attribute__((format_arg(2))) ; /* { dg-error \"format string argument is not a string type\" } */\n+int s8 (NSString *dum, NSString *fmt1, ... ) __attribute__((format_arg(2))) ; /* { dg-error \"function does not return string type\" } */\n+\n+char *s9 (int dum, char *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+NSString *s10 (int dum, NSString *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+\n+void foo (void)\n+{\n+  s1 (@\"this format not checked %d %s\", 3, 4);\n+  printf(\"this one is checked %d %s\", 3, 4, 5); /* { dg-warning \"format .%s. expects type .char.., but argument 3 has type 'int'\" } */\n+\t\t\t/* { dg-warning \"too many arguments for format\" \"\" { target *-*-* } 48 } */\n+  printf(s9 (1, (char *)\"and so is this %d %d %s\" , 3, 4, \"hm\"), 5, 6, 12); /* { dg-warning \"format .%s. expects type .char.., but argument 4 has type .int.\" } */\n+}"}, {"sha": "2983c43c445a0e43b4c70c5459e2f669f26ae2b4", "filename": "gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-cfstring-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-cfstring-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ftorture%2Fstrings%2Fconst-cfstring-1.mm?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -9,6 +9,9 @@\n /* { dg-skip-if \"NeXT only\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n /* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n /* { dg-options \"-mconstant-cfstrings -framework Cocoa\" } */\n+/* Darwin10's linker emits a warning that the constant strings are incompatible with writable ones.\n+   well, we don't implement writable ones at this juncture.  */\n+/* { dg-options \"-mconstant-cfstrings -framework Cocoa -Wl,-w\" { target *-*-darwin[123]* } } */\n \n #import <Foundation/NSString.h>\n #import <CoreFoundation/CFString.h>"}, {"sha": "2550a550168c0de260f9f0e7b10592114c308e76", "filename": "gcc/testsuite/objc.dg/fsf-nsstring-format-1.m", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fobjc.dg%2Ffsf-nsstring-format-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ebb981ec251976ec43c36e7f2de101855d2b45/gcc%2Ftestsuite%2Fobjc.dg%2Ffsf-nsstring-format-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ffsf-nsstring-format-1.m?ref=91ebb981ec251976ec43c36e7f2de101855d2b45", "patch": "@@ -0,0 +1,44 @@\n+/* Check NSString format extensions.  */\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+/* { dg-options \"-Wall\" } */\n+\n+extern int printf (const char *fmt, ...);\n+\n+#ifndef __CONSTANT_CFSTRINGS__\n+#error requires CFString\n+#endif\n+\n+typedef const struct __CFString * CFStringRef;\n+@class NSString;\n+\n+int s1 (NSString *fmt, ...) __attribute__((format(NSString, 1, 2))) ; /* OK */\n+/* A CFString can represent an NSString.  */\n+int s1a (CFStringRef fmt, ...) __attribute__((format(NSString, 1, 2))) ; /* OK */\n+/* But... it is possible that a CFString format might imply functionality that\n+   is not present in objective-c.  */\n+int s1b (NSString *fmt, ...) __attribute__((format(CFString, 1, 2))) ; /* { dg-error \"format argument should be a .CFString. reference\" } */\n+\n+int s2 (int a, NSString *fmt, ... ) __attribute__((format(__NSString__, 2, 3))) ; /* OK */\n+\n+int s2a (int a, NSString *fmt, ... ) __attribute__((format(NSString, 2, 2))) ; /* { dg-error \"format string argument follows the args to be formatted\" } */\n+\n+int s3 (const char *fmt, ... ) __attribute__((format(__NSString__, 1, 2))) ; /* { dg-error \"format argument should be a .NSString. reference but a string was found\" } */\n+int s4 (NSString *fmt, ... ) __attribute__((format(printf, 1, 2))) ; /* { dg-error \"found a .NSString. reference but the format argument should be a string\" } */\n+\n+char *s5 (char dum, char *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+NSString *s6 (NSString *dum, NSString *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+\n+char *s7 (int dum, void *fmt1, ... ) __attribute__((format_arg(2))) ; /* { dg-error \"format string argument is not a string type\" } */\n+int s8 (NSString *dum, NSString *fmt1, ... ) __attribute__((format_arg(2))) ; /* { dg-error \"function does not return string type\" } */\n+\n+char *s9 (int dum, char *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+NSString *s10 (int dum, NSString *fmt1, ... ) __attribute__((format_arg(2))) ; /* OK */\n+\n+void foo (void)\n+{\n+  s1 (@\"format not checked %d %s\", 3, 4);\n+  printf(\"this one is checked %d %s\", 3, 4, 5); /* { dg-warning \"format .%s. expects type .char .., but argument 3 has type .int.\" } */\n+\t\t\t/* { dg-warning \"too many arguments for format\" \"\" { target *-*-* } 41 } */\n+  printf(s9 (1, \"and so is this %d %d %s\", 3, 4), 5, 6, 12); /* { dg-warning \"format .%s. expects type .char .., but argument 4 has type .int.\" } */\n+}"}]}