{"sha": "f3552158261c9ddfa03b4f944a307eda4761cb44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1NTIxNTgyNjFjOWRkZmEwM2I0Zjk0NGEzMDdlZGE0NzYxY2I0NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-11-04T16:58:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-04T16:58:52Z"}, "message": "nvptx.c: Include gimple headers.\n\n\t* config/nvptx/nvptx.c: Include gimple headers.\n\t(worker_red_size, worker_red_align, worker_red_name,\n\tworker_red_sym): New.\n\t(nvptx_option_override): Initialize worker reduction buffer.\n\t(nvptx_file_end): Write out worker reduction buffer var.\n\t(nvptx_expand_shuffle, nvptx_expand_worker_addr,\n\tnvptx_expand_cmp_swap): New builtin expanders.\n\t(enum nvptx_builtins): New.\n\t(nvptx_builtin_decls): New.\n\t(nvptx_builtin_decl, nvptx_init_builtins, nvptx_expand_builtin): New\n\t(PTX_VECTOR_LENGTH, PTX_WORKER_LENGTH): New.\n\t(nvptx_get_worker_red_addr, nvptx_generate_vector_shuffle,\n\tnvptx_lockless_update): New helpers.\n\t(nvptx_goacc_reduction_setup, nvptx_goacc_reduction_init,\n\tnvptx_goacc_reduction_fini, nvptx_goacc_reduction_teaddown): New.\n\t(nvptx_goacc_reduction): New.\n\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN,\n\tTARGET_BUILTIN_DECL): Override.\n\t(TARGET_GOACC_REDUCTION): Override.\n\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\n\nFrom-SVN: r229768", "tree": {"sha": "e0563b3de2d42b112924d0a71dc8274bbd0680b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0563b3de2d42b112924d0a71dc8274bbd0680b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3552158261c9ddfa03b4f944a307eda4761cb44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3552158261c9ddfa03b4f944a307eda4761cb44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3552158261c9ddfa03b4f944a307eda4761cb44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3552158261c9ddfa03b4f944a307eda4761cb44/comments", "author": null, "committer": null, "parents": [{"sha": "e50146711b7200e8f822c6d8239430c682b76e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50146711b7200e8f822c6d8239430c682b76e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e50146711b7200e8f822c6d8239430c682b76e4f"}], "stats": {"total": 655, "additions": 650, "deletions": 5}, "files": [{"sha": "db1f93f8bfebbd2852a3a995cd2cd7a4ab7cf74d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3552158261c9ddfa03b4f944a307eda4761cb44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3552158261c9ddfa03b4f944a307eda4761cb44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3552158261c9ddfa03b4f944a307eda4761cb44", "patch": "@@ -1,3 +1,26 @@\n+2015-11-04  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* config/nvptx/nvptx.c: Include gimple headers.\n+\t(worker_red_size, worker_red_align, worker_red_name,\n+\tworker_red_sym): New.\n+\t(nvptx_option_override): Initialize worker reduction buffer.\n+\t(nvptx_file_end): Write out worker reduction buffer var.\n+\t(nvptx_expand_shuffle, nvptx_expand_worker_addr,\n+\tnvptx_expand_cmp_swap): New builtin expanders.\n+\t(enum nvptx_builtins): New.\n+\t(nvptx_builtin_decls): New.\n+\t(nvptx_builtin_decl, nvptx_init_builtins, nvptx_expand_builtin): New\n+\t(PTX_VECTOR_LENGTH, PTX_WORKER_LENGTH): New.\n+\t(nvptx_get_worker_red_addr, nvptx_generate_vector_shuffle,\n+\tnvptx_lockless_update): New helpers.\n+\t(nvptx_goacc_reduction_setup, nvptx_goacc_reduction_init,\n+\tnvptx_goacc_reduction_fini, nvptx_goacc_reduction_teaddown): New.\n+\t(nvptx_goacc_reduction): New.\n+\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN,\n+\tTARGET_BUILTIN_DECL): Override.\n+\t(TARGET_GOACC_REDUCTION): Override.\n+\n 2015-11-04  Nathan Sidwell  <nathan@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "79ef4f703fe447a93095d4682879b1e0b2db4c6c", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 627, "deletions": 5, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3552158261c9ddfa03b4f944a307eda4761cb44/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3552158261c9ddfa03b4f944a307eda4761cb44/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=f3552158261c9ddfa03b4f944a307eda4761cb44", "patch": "@@ -57,6 +57,15 @@\n #include \"omp-low.h\"\n #include \"gomp-constants.h\"\n #include \"dumpfile.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-iterator.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-ssanames.h\"\n+#include \"gimplify.h\"\n+#include \"tree-phinodes.h\"\n+#include \"cfgloop.h\"\n+#include \"fold-const.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -88,16 +97,23 @@ struct tree_hasher : ggc_cache_ptr_hash<tree_node>\n static GTY((cache)) hash_table<tree_hasher> *declared_fndecls_htab;\n static GTY((cache)) hash_table<tree_hasher> *needed_fndecls_htab;\n \n-/* Size of buffer needed to broadcast across workers.  This is used\n-   for both worker-neutering and worker broadcasting.   It is shared\n-   by all functions emitted.  The buffer is placed in shared memory.\n-   It'd be nice if PTX supported common blocks, because then this\n-   could be shared across TUs (taking the largest size).  */\n+/* Buffer needed to broadcast across workers.  This is used for both\n+   worker-neutering and worker broadcasting.  It is shared by all\n+   functions emitted.  The buffer is placed in shared memory.  It'd be\n+   nice if PTX supported common blocks, because then this could be\n+   shared across TUs (taking the largest size).  */\n static unsigned worker_bcast_size;\n static unsigned worker_bcast_align;\n #define worker_bcast_name \"__worker_bcast\"\n static GTY(()) rtx worker_bcast_sym;\n \n+/* Buffer needed for worker reductions.  This has to be distinct from\n+   the worker broadcast array, as both may be live concurrently.  */\n+static unsigned worker_red_size;\n+static unsigned worker_red_align;\n+#define worker_red_name \"__worker_red\"\n+static GTY(()) rtx worker_red_sym;\n+\n /* Allocate a new, cleared machine_function structure.  */\n \n static struct machine_function *\n@@ -128,6 +144,9 @@ nvptx_option_override (void)\n \n   worker_bcast_sym = gen_rtx_SYMBOL_REF (Pmode, worker_bcast_name);\n   worker_bcast_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n+\n+  worker_red_sym = gen_rtx_SYMBOL_REF (Pmode, worker_red_name);\n+  worker_red_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n }\n \n /* Return the mode to be used when declaring a ptx object for OBJ.\n@@ -3246,8 +3265,203 @@ nvptx_file_end (void)\n \t       worker_bcast_align,\n \t       worker_bcast_name, worker_bcast_size);\n     }\n+\n+  if (worker_red_size)\n+    {\n+      /* Define the reduction buffer.  */\n+\n+      worker_red_size = ((worker_red_size + worker_red_align - 1)\n+\t\t\t & ~(worker_red_align - 1));\n+      \n+      fprintf (asm_out_file, \"// BEGIN VAR DEF: %s\\n\", worker_red_name);\n+      fprintf (asm_out_file, \".shared .align %d .u8 %s[%d];\\n\",\n+\t       worker_red_align,\n+\t       worker_red_name, worker_red_size);\n+    }\n+}\n+\n+/* Expander for the shuffle builtins.  */\n+\n+static rtx\n+nvptx_expand_shuffle (tree exp, rtx target, machine_mode mode, int ignore)\n+{\n+  if (ignore)\n+    return target;\n+  \n+  rtx src = expand_expr (CALL_EXPR_ARG (exp, 0),\n+\t\t\t NULL_RTX, mode, EXPAND_NORMAL);\n+  if (!REG_P (src))\n+    src = copy_to_mode_reg (mode, src);\n+\n+  rtx idx = expand_expr (CALL_EXPR_ARG (exp, 1),\n+\t\t\t NULL_RTX, SImode, EXPAND_NORMAL);\n+  rtx op = expand_expr (CALL_EXPR_ARG  (exp, 2),\n+\t\t\tNULL_RTX, SImode, EXPAND_NORMAL);\n+  \n+  if (!REG_P (idx) && GET_CODE (idx) != CONST_INT)\n+    idx = copy_to_mode_reg (SImode, idx);\n+\n+  rtx pat = nvptx_gen_shuffle (target, src, idx, INTVAL (op));\n+  if (pat)\n+    emit_insn (pat);\n+\n+  return target;\n+}\n+\n+/* Worker reduction address expander.  */\n+\n+static rtx\n+nvptx_expand_worker_addr (tree exp, rtx target,\n+\t\t\t  machine_mode ARG_UNUSED (mode), int ignore)\n+{\n+  if (ignore)\n+    return target;\n+\n+  unsigned align = TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 2));\n+  if (align > worker_red_align)\n+    worker_red_align = align;\n+\n+  unsigned offset = TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 0));\n+  unsigned size = TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 1));\n+  if (size + offset > worker_red_size)\n+    worker_red_size = size + offset;\n+\n+  emit_insn (gen_rtx_SET (target, worker_red_sym));\n+\n+  if (offset)\n+    emit_insn (gen_rtx_SET (target,\n+\t\t\t    gen_rtx_PLUS (Pmode, target, GEN_INT (offset))));\n+\n+  emit_insn (gen_rtx_SET (target,\n+\t\t\t  gen_rtx_UNSPEC (Pmode, gen_rtvec (1, target),\n+\t\t\t\t\t  UNSPEC_FROM_SHARED)));\n+\n+  return target;\n+}\n+\n+/* Expand the CMP_SWAP PTX builtins.  We have our own versions that do\n+   not require taking the address of any object, other than the memory\n+   cell being operated on.  */\n+\n+static rtx\n+nvptx_expand_cmp_swap (tree exp, rtx target,\n+\t\t       machine_mode ARG_UNUSED (m), int ARG_UNUSED (ignore))\n+{\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+  \n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+\n+  rtx mem = expand_expr (CALL_EXPR_ARG (exp, 0),\n+\t\t\t NULL_RTX, Pmode, EXPAND_NORMAL);\n+  rtx cmp = expand_expr (CALL_EXPR_ARG (exp, 1),\n+\t\t\t NULL_RTX, mode, EXPAND_NORMAL);\n+  rtx src = expand_expr (CALL_EXPR_ARG (exp, 2),\n+\t\t\t NULL_RTX, mode, EXPAND_NORMAL);\n+  rtx pat;\n+\n+  mem = gen_rtx_MEM (mode, mem);\n+  if (!REG_P (cmp))\n+    cmp = copy_to_mode_reg (mode, cmp);\n+  if (!REG_P (src))\n+    src = copy_to_mode_reg (mode, src);\n+  \n+  if (mode == SImode)\n+    pat = gen_atomic_compare_and_swapsi_1 (target, mem, cmp, src, const0_rtx);\n+  else\n+    pat = gen_atomic_compare_and_swapdi_1 (target, mem, cmp, src, const0_rtx);\n+\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\n+\n+/* Codes for all the NVPTX builtins.  */\n+enum nvptx_builtins\n+{\n+  NVPTX_BUILTIN_SHUFFLE,\n+  NVPTX_BUILTIN_SHUFFLELL,\n+  NVPTX_BUILTIN_WORKER_ADDR,\n+  NVPTX_BUILTIN_CMP_SWAP,\n+  NVPTX_BUILTIN_CMP_SWAPLL,\n+  NVPTX_BUILTIN_MAX\n+};\n+\n+static GTY(()) tree nvptx_builtin_decls[NVPTX_BUILTIN_MAX];\n+\n+/* Return the NVPTX builtin for CODE.  */\n+\n+static tree\n+nvptx_builtin_decl (unsigned code, bool ARG_UNUSED (initialize_p))\n+{\n+  if (code >= NVPTX_BUILTIN_MAX)\n+    return error_mark_node;\n+\n+  return nvptx_builtin_decls[code];\n+}\n+\n+/* Set up all builtin functions for this target.  */\n+\n+static void\n+nvptx_init_builtins (void)\n+{\n+#define DEF(ID, NAME, T)\t\t\t\t\t\t\\\n+  (nvptx_builtin_decls[NVPTX_BUILTIN_ ## ID]\t\t\t\t\\\n+   = add_builtin_function (\"__builtin_nvptx_\" NAME,\t\t\t\\\n+\t\t\t   build_function_type_list T,\t\t\t\\\n+\t\t\t   NVPTX_BUILTIN_ ## ID, BUILT_IN_MD, NULL, NULL))\n+#define ST sizetype\n+#define UINT unsigned_type_node\n+#define LLUINT long_long_unsigned_type_node\n+#define PTRVOID ptr_type_node\n+\n+  DEF (SHUFFLE, \"shuffle\", (UINT, UINT, UINT, UINT, NULL_TREE));\n+  DEF (SHUFFLELL, \"shufflell\", (LLUINT, LLUINT, UINT, UINT, NULL_TREE));\n+  DEF (WORKER_ADDR, \"worker_addr\",\n+       (PTRVOID, ST, UINT, UINT, NULL_TREE));\n+  DEF (CMP_SWAP, \"cmp_swap\", (UINT, PTRVOID, UINT, UINT, NULL_TREE));\n+  DEF (CMP_SWAPLL, \"cmp_swapll\", (LLUINT, PTRVOID, LLUINT, LLUINT, NULL_TREE));\n+\n+#undef DEF\n+#undef ST\n+#undef UINT\n+#undef LLUINT\n+#undef PTRVOID\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+nvptx_expand_builtin (tree exp, rtx target, rtx ARG_UNUSED (subtarget),\n+\t\t      machine_mode mode, int ignore)\n+{\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case NVPTX_BUILTIN_SHUFFLE:\n+    case NVPTX_BUILTIN_SHUFFLELL:\n+      return nvptx_expand_shuffle (exp, target, mode, ignore);\n+\n+    case NVPTX_BUILTIN_WORKER_ADDR:\n+      return nvptx_expand_worker_addr (exp, target, mode, ignore);\n+\n+    case NVPTX_BUILTIN_CMP_SWAP:\n+    case NVPTX_BUILTIN_CMP_SWAPLL:\n+      return nvptx_expand_cmp_swap (exp, target, mode, ignore);\n+\n+    default: gcc_unreachable ();\n+    }\n }\n \f\n+/* Define dimension sizes for known hardware.  */\n+#define PTX_VECTOR_LENGTH 32\n+#define PTX_WORKER_LENGTH 32\n+\n /* Validate compute dimensions of an OpenACC offload or routine, fill\n    in non-unity defaults.  FN_LEVEL indicates the level at which a\n    routine might spawn a loop.  It is negative for non-routines.  */\n@@ -3284,6 +3498,404 @@ nvptx_goacc_fork_join (gcall *call, const int dims[],\n   return true;\n }\n \n+/* Generate a PTX builtin function call that returns the address in\n+   the worker reduction buffer at OFFSET.  TYPE is the type of the\n+   data at that location.  */\n+\n+static tree\n+nvptx_get_worker_red_addr (tree type, tree offset)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  tree fndecl = nvptx_builtin_decl (NVPTX_BUILTIN_WORKER_ADDR, true);\n+  tree size = build_int_cst (unsigned_type_node, GET_MODE_SIZE (mode));\n+  tree align = build_int_cst (unsigned_type_node,\n+\t\t\t      GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT);\n+  tree call = build_call_expr (fndecl, 3, offset, size, align);\n+\n+  return fold_convert (build_pointer_type (type), call);\n+}\n+\n+/* Emit a SHFL.DOWN using index SHFL of VAR into DEST_VAR.  This function\n+   will cast the variable if necessary.  */\n+\n+static void\n+nvptx_generate_vector_shuffle (location_t loc,\n+\t\t\t       tree dest_var, tree var, unsigned shift,\n+\t\t\t       gimple_seq *seq)\n+{\n+  unsigned fn = NVPTX_BUILTIN_SHUFFLE;\n+  tree_code code = NOP_EXPR;\n+  tree type = unsigned_type_node;\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (var));\n+\n+  if (!INTEGRAL_MODE_P (mode))\n+    code = VIEW_CONVERT_EXPR;\n+  if (GET_MODE_SIZE (mode) == GET_MODE_SIZE (DImode))\n+    {\n+      fn = NVPTX_BUILTIN_SHUFFLELL;\n+      type = long_long_unsigned_type_node;\n+    }\n+\n+  tree call = nvptx_builtin_decl (fn, true);\n+  call = build_call_expr_loc\n+    (loc, call, 3, fold_build1 (code, type, var),\n+     build_int_cst (unsigned_type_node, shift),\n+     build_int_cst (unsigned_type_node, SHUFFLE_DOWN));\n+\n+  call = fold_build1 (code, TREE_TYPE (dest_var), call);\n+\n+  gimplify_assign (dest_var, call, seq);\n+}\n+\n+/* Insert code to locklessly update  *PTR with *PTR OP VAR just before\n+   GSI.  */\n+\n+static tree\n+nvptx_lockless_update (location_t loc, gimple_stmt_iterator *gsi,\n+\t\t       tree ptr, tree var, tree_code op)\n+{\n+  unsigned fn = NVPTX_BUILTIN_CMP_SWAP;\n+  tree_code code = NOP_EXPR;\n+  tree type = unsigned_type_node;\n+\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (var));\n+\n+  if (!INTEGRAL_MODE_P (mode))\n+    code = VIEW_CONVERT_EXPR;\n+  if (GET_MODE_SIZE (mode) == GET_MODE_SIZE (DImode))\n+    {\n+      fn = NVPTX_BUILTIN_CMP_SWAPLL;\n+      type = long_long_unsigned_type_node;\n+    }\n+\n+  gimple_seq init_seq = NULL;\n+  tree init_var = make_ssa_name (type);\n+  tree init_expr = omp_reduction_init_op (loc, op, TREE_TYPE (var));\n+  init_expr = fold_build1 (code, type, init_expr);\n+  gimplify_assign (init_var, init_expr, &init_seq);\n+  gimple *init_end = gimple_seq_last (init_seq);\n+\n+  gsi_insert_seq_before (gsi, init_seq, GSI_SAME_STMT);\n+  \n+  gimple_seq loop_seq = NULL;\n+  tree expect_var = make_ssa_name (type);\n+  tree actual_var = make_ssa_name (type);\n+  tree write_var = make_ssa_name (type);\n+  \n+  tree write_expr = fold_build1 (code, TREE_TYPE (var), expect_var);\n+  write_expr = fold_build2 (op, TREE_TYPE (var), write_expr, var);\n+  write_expr = fold_build1 (code, type, write_expr);\n+  gimplify_assign (write_var, write_expr, &loop_seq);\n+\n+  tree swap_expr = nvptx_builtin_decl (fn, true);\n+  swap_expr = build_call_expr_loc (loc, swap_expr, 3,\n+\t\t\t\t   ptr, expect_var, write_var);\n+  gimplify_assign (actual_var, swap_expr, &loop_seq);\n+\n+  gcond *cond = gimple_build_cond (EQ_EXPR, actual_var, expect_var,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+  gimple_seq_add_stmt (&loop_seq, cond);\n+\n+  /* Split the block just after the init stmts.  */\n+  basic_block pre_bb = gsi_bb (*gsi);\n+  edge pre_edge = split_block (pre_bb, init_end);\n+  basic_block loop_bb = pre_edge->dest;\n+  pre_bb = pre_edge->src;\n+  /* Reset the iterator.  */\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  /* Insert the loop statements.  */\n+  gimple *loop_end = gimple_seq_last (loop_seq);\n+  gsi_insert_seq_before (gsi, loop_seq, GSI_SAME_STMT);\n+\n+  /* Split the block just after the loop stmts.  */\n+  edge post_edge = split_block (loop_bb, loop_end);\n+  basic_block post_bb = post_edge->dest;\n+  loop_bb = post_edge->src;\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  post_edge->flags ^= EDGE_TRUE_VALUE | EDGE_FALLTHRU;\n+  edge loop_edge = make_edge (loop_bb, loop_bb, EDGE_FALSE_VALUE);\n+  set_immediate_dominator (CDI_DOMINATORS, loop_bb, pre_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, post_bb, loop_bb);\n+\n+  gphi *phi = create_phi_node (expect_var, loop_bb);\n+  add_phi_arg (phi, init_var, pre_edge, loc);\n+  add_phi_arg (phi, actual_var, loop_edge, loc);\n+\n+  loop *loop = alloc_loop ();\n+  loop->header = loop_bb;\n+  loop->latch = loop_bb;\n+  add_loop (loop, loop_bb->loop_father);\n+\n+  return fold_build1 (code, TREE_TYPE (var), write_var);\n+}\n+\n+/* NVPTX implementation of GOACC_REDUCTION_SETUP.  */\n+\n+static void\n+nvptx_goacc_reduction_setup (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  gimple_seq seq = NULL;\n+\n+  push_gimplify_context (true);\n+\n+  if (level != GOMP_DIM_GANG)\n+    {\n+      /* Copy the receiver object.  */\n+      tree ref_to_res = gimple_call_arg (call, 1);\n+\n+      if (!integer_zerop (ref_to_res))\n+\tvar = build_simple_mem_ref (ref_to_res);\n+    }\n+  \n+  if (level == GOMP_DIM_WORKER)\n+    {\n+      /* Store incoming value to worker reduction buffer.  */\n+      tree offset = gimple_call_arg (call, 5);\n+      tree call = nvptx_get_worker_red_addr (TREE_TYPE (var), offset);\n+      tree ptr = make_ssa_name (TREE_TYPE (call));\n+\n+      gimplify_assign (ptr, call, &seq);\n+      tree ref = build_simple_mem_ref (ptr);\n+      TREE_THIS_VOLATILE (ref) = 1;\n+      gimplify_assign (ref, var, &seq);\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, var, &seq);\n+\n+  pop_gimplify_context (NULL);\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* NVPTX implementation of GOACC_REDUCTION_INIT. */\n+\n+static void\n+nvptx_goacc_reduction_init (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  enum tree_code rcode\n+    = (enum tree_code)TREE_INT_CST_LOW (gimple_call_arg (call, 4));\n+  tree init = omp_reduction_init_op (gimple_location (call), rcode,\n+\t\t\t\t     TREE_TYPE (var));\n+  gimple_seq seq = NULL;\n+  \n+  push_gimplify_context (true);\n+\n+  if (level == GOMP_DIM_VECTOR)\n+    {\n+      /* Initialize vector-non-zeroes to INIT_VAL (OP).  */\n+      tree tid = make_ssa_name (integer_type_node);\n+      tree dim_vector = gimple_call_arg (call, 3);\n+      gimple *tid_call = gimple_build_call_internal (IFN_GOACC_DIM_POS, 1,\n+\t\t\t\t\t\t     dim_vector);\n+      gimple *cond_stmt = gimple_build_cond (NE_EXPR, tid, integer_zero_node,\n+\t\t\t\t\t     NULL_TREE, NULL_TREE);\n+\n+      gimple_call_set_lhs (tid_call, tid);\n+      gimple_seq_add_stmt (&seq, tid_call);\n+      gimple_seq_add_stmt (&seq, cond_stmt);\n+\n+      /* Split the block just after the call.  */\n+      edge init_edge = split_block (gsi_bb (gsi), call);\n+      basic_block init_bb = init_edge->dest;\n+      basic_block call_bb = init_edge->src;\n+\n+      /* Fixup flags from call_bb to init_bb.  */\n+      init_edge->flags ^= EDGE_FALLTHRU | EDGE_TRUE_VALUE;\n+      \n+      /* Set the initialization stmts.  */\n+      gimple_seq init_seq = NULL;\n+      tree init_var = make_ssa_name (TREE_TYPE (var));\n+      gimplify_assign (init_var, init, &init_seq);\n+      gsi = gsi_start_bb (init_bb);\n+      gsi_insert_seq_before (&gsi, init_seq, GSI_SAME_STMT);\n+\n+      /* Split block just after the init stmt.  */\n+      gsi_prev (&gsi);\n+      edge inited_edge = split_block (gsi_bb (gsi), gsi_stmt (gsi));\n+      basic_block dst_bb = inited_edge->dest;\n+      \n+      /* Create false edge from call_bb to dst_bb.  */\n+      edge nop_edge = make_edge (call_bb, dst_bb, EDGE_FALSE_VALUE);\n+\n+      /* Create phi node in dst block.  */\n+      gphi *phi = create_phi_node (lhs, dst_bb);\n+      add_phi_arg (phi, init_var, inited_edge, gimple_location (call));\n+      add_phi_arg (phi, var, nop_edge, gimple_location (call));\n+\n+      /* Reset dominator of dst bb.  */\n+      set_immediate_dominator (CDI_DOMINATORS, dst_bb, call_bb);\n+\n+      /* Reset the gsi.  */\n+      gsi = gsi_for_stmt (call);\n+    }\n+  else\n+    {\n+      if (level == GOMP_DIM_GANG)\n+\t{\n+\t  /* If there's no receiver object, propagate the incoming VAR.  */\n+\t  tree ref_to_res = gimple_call_arg (call, 1);\n+\t  if (integer_zerop (ref_to_res))\n+\t    init = var;\n+\t}\n+\n+      gimplify_assign (lhs, init, &seq);\n+    }\n+\n+  pop_gimplify_context (NULL);\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* NVPTX implementation of GOACC_REDUCTION_FINI.  */\n+\n+static void\n+nvptx_goacc_reduction_fini (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree ref_to_res = gimple_call_arg (call, 1);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  enum tree_code op\n+    = (enum tree_code)TREE_INT_CST_LOW (gimple_call_arg (call, 4));\n+  gimple_seq seq = NULL;\n+  tree r = NULL_TREE;;\n+\n+  push_gimplify_context (true);\n+\n+  if (level == GOMP_DIM_VECTOR)\n+    {\n+      /* Emit binary shuffle tree.  TODO. Emit this as an actual loop,\n+\t but that requires a method of emitting a unified jump at the\n+\t gimple level.  */\n+      for (int shfl = PTX_VECTOR_LENGTH / 2; shfl > 0; shfl = shfl >> 1)\n+\t{\n+\t  tree other_var = make_ssa_name (TREE_TYPE (var));\n+\t  nvptx_generate_vector_shuffle (gimple_location (call),\n+\t\t\t\t\t other_var, var, shfl, &seq);\n+\n+\t  r = make_ssa_name (TREE_TYPE (var));\n+\t  gimplify_assign (r, fold_build2 (op, TREE_TYPE (var),\n+\t\t\t\t\t   var, other_var), &seq);\n+\t  var = r;\n+\t}\n+    }\n+  else\n+    {\n+      tree accum = NULL_TREE;\n+\n+      if (level == GOMP_DIM_WORKER)\n+\t{\n+\t  /* Get reduction buffer address.  */\n+\t  tree offset = gimple_call_arg (call, 5);\n+\t  tree call = nvptx_get_worker_red_addr (TREE_TYPE (var), offset);\n+\t  tree ptr = make_ssa_name (TREE_TYPE (call));\n+\n+\t  gimplify_assign (ptr, call, &seq);\n+\t  accum = ptr;\n+\t}\n+      else if (integer_zerop (ref_to_res))\n+\tr = var;\n+      else\n+\taccum = ref_to_res;\n+\n+      if (accum)\n+\t{\n+\t  /* Locklessly update the accumulator.  */\n+\t  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+\t  seq = NULL;\n+\t  r = nvptx_lockless_update (gimple_location (call), &gsi,\n+\t\t\t\t     accum, var, op);\n+\t}\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, r, &seq);\n+  pop_gimplify_context (NULL);\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* NVPTX implementation of GOACC_REDUCTION_TEARDOWN.  */\n+\n+static void\n+nvptx_goacc_reduction_teardown (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  gimple_seq seq = NULL;\n+  \n+  push_gimplify_context (true);\n+  if (level == GOMP_DIM_WORKER)\n+    {\n+      /* Read the worker reduction buffer.  */\n+      tree offset = gimple_call_arg (call, 5);\n+      tree call = nvptx_get_worker_red_addr(TREE_TYPE (var), offset);\n+      tree ptr = make_ssa_name (TREE_TYPE (call));\n+\n+      gimplify_assign (ptr, call, &seq);\n+      var = build_simple_mem_ref (ptr);\n+      TREE_THIS_VOLATILE (var) = 1;\n+    }\n+\n+  if (level != GOMP_DIM_GANG)\n+    {\n+      /* Write to the receiver object.  */\n+      tree ref_to_res = gimple_call_arg (call, 1);\n+\n+      if (!integer_zerop (ref_to_res))\n+\tgimplify_assign (build_simple_mem_ref (ref_to_res), var, &seq);\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, var, &seq);\n+  \n+  pop_gimplify_context (NULL);\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* NVPTX reduction expander.  */\n+\n+void\n+nvptx_goacc_reduction (gcall *call)\n+{\n+  unsigned code = (unsigned)TREE_INT_CST_LOW (gimple_call_arg (call, 0));\n+\n+  switch (code)\n+    {\n+    case IFN_GOACC_REDUCTION_SETUP:\n+      nvptx_goacc_reduction_setup (call);\n+      break;\n+\n+    case IFN_GOACC_REDUCTION_INIT:\n+      nvptx_goacc_reduction_init (call);\n+      break;\n+\n+    case IFN_GOACC_REDUCTION_FINI:\n+      nvptx_goacc_reduction_fini (call);\n+      break;\n+\n+    case IFN_GOACC_REDUCTION_TEARDOWN:\n+      nvptx_goacc_reduction_teardown (call);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE nvptx_option_override\n \n@@ -3373,12 +3985,22 @@ nvptx_goacc_fork_join (gcall *call, const int dims[],\n #undef TARGET_CANNOT_COPY_INSN_P\n #define TARGET_CANNOT_COPY_INSN_P nvptx_cannot_copy_insn_p\n \n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS nvptx_init_builtins\n+#undef TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN nvptx_expand_builtin\n+#undef  TARGET_BUILTIN_DECL\n+#define TARGET_BUILTIN_DECL nvptx_builtin_decl\n+\n #undef TARGET_GOACC_VALIDATE_DIMS\n #define TARGET_GOACC_VALIDATE_DIMS nvptx_goacc_validate_dims\n \n #undef TARGET_GOACC_FORK_JOIN\n #define TARGET_GOACC_FORK_JOIN nvptx_goacc_fork_join\n \n+#undef TARGET_GOACC_REDUCTION\n+#define TARGET_GOACC_REDUCTION nvptx_goacc_reduction\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-nvptx.h\""}]}