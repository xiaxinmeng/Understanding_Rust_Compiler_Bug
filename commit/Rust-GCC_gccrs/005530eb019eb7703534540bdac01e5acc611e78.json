{"sha": "005530eb019eb7703534540bdac01e5acc611e78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1NTMwZWIwMTllYjc3MDM1MzQ1NDBiZGFjMDFlNWFjYzYxMWU3OA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-02T15:35:45Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-02T16:57:40Z"}, "message": "coroutines: Don't make duplicate frame copies of awaitables.\n\nIn general, we need to manage the lifetime of compiler-\ngenerated awaitable instances in the coroutine frame, since\nthese must persist across suspension points.\n\nHowever, it is quite possible that the user might provide the\nawaitable instances, either as function params or as a local\nvariable.  We will already generate a frame entry for these as\nrequired.\n\nAt present, under this circumstance, we are duplicating these,\nawaitable, initialising a second frame copy for them (which we\nthen subsequently destroy manually after the suspension point).\nThat's not efficient - so an undesirable thinko in the first place.\nHowever, there is also an actual bug; if the compiler elects to\nelide the copy (which is perfectly legal), it does not have visibility\nof the manual management of the post-suspend destruction\n- this subsequently leads to double-free errors.\n\nThe solution is not to make the second copy (as noted, params\nand local vars already have frame copies with managed lifetimes).\n\ngcc/cp/ChangeLog:\n\n2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc (build_co_await): Do not build frame\n\tproxy vars when the co_await expression is a function\n\tparameter or local var.\n\t(co_await_expander): Do not initialise a frame var with\n\titself.\n\t(transform_await_expr): Only substitute the awaitable\n\tframe var if it's needed.\n\t(register_awaits): Do not make frame copies for param\n\tor local vars that are awaitables.\n\ngcc/testsuite/ChangeLog:\n\n2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/torture/func-params-09-awaitable-parms.C: New test.\n\t* g++.dg/coroutines/torture/local-var-5-awaitable.C: New test.", "tree": {"sha": "f1c25920e5292a40c306aae78a79736766ae4ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1c25920e5292a40c306aae78a79736766ae4ea3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/005530eb019eb7703534540bdac01e5acc611e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005530eb019eb7703534540bdac01e5acc611e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005530eb019eb7703534540bdac01e5acc611e78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005530eb019eb7703534540bdac01e5acc611e78/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5879399fc0dcdd6b1ebe9a3b0d03db5ca30150a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5879399fc0dcdd6b1ebe9a3b0d03db5ca30150a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5879399fc0dcdd6b1ebe9a3b0d03db5ca30150a"}], "stats": {"total": 284, "additions": 258, "deletions": 26}, "files": [{"sha": "ca1e1fc52b9666d84821be400da16805f32e81a5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=005530eb019eb7703534540bdac01e5acc611e78", "patch": "@@ -1,3 +1,15 @@\n+2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc (build_co_await): Do not build frame\n+\tawaitable proxy vars when the co_await expression is\n+\ta function parameter or local var.\n+\t(co_await_expander): Do not initialise a frame var with\n+\titself.\n+\t(transform_await_expr): Only substitute the awaitable\n+\tframe var if it's needed.\n+\t(register_awaits): Do not make frame copies for param\n+\tor local vars that are awaitables.\n+\n 2020-02-28  Jason Merrill  <jason@redhat.com>\n \n \tImplement P2092R0, Disambiguating Nested-Requirements"}, {"sha": "3e06f079787deccba26eb2d3f969aa90ebcc4b45", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=005530eb019eb7703534540bdac01e5acc611e78", "patch": "@@ -738,8 +738,21 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)\n   /* To complete the lookups, we need an instance of 'e' which is built from\n      'o' according to [expr.await] 3.4.  However, we don't want to materialize\n      'e' here (it might need to be placed in the coroutine frame) so we will\n-     make a temp placeholder instead.  */\n-  tree e_proxy = build_lang_decl (VAR_DECL, NULL_TREE, o_type);\n+     make a temp placeholder instead.  If 'o' is a parameter or a local var,\n+     then we do not need an additional var (parms and local vars are already\n+     copied into the frame and will have lifetimes according to their original\n+     scope).  */\n+  tree e_proxy = STRIP_NOPS (o);\n+  if (INDIRECT_REF_P (e_proxy))\n+    e_proxy = TREE_OPERAND (e_proxy, 0);\n+  if (TREE_CODE (e_proxy) == PARM_DECL\n+      || (TREE_CODE (e_proxy) == VAR_DECL && !DECL_ARTIFICIAL (e_proxy)))\n+    e_proxy = o;\n+  else\n+    {\n+      e_proxy = build_lang_decl (VAR_DECL, NULL_TREE, o_type);\n+      DECL_ARTIFICIAL (e_proxy) = true;\n+    }\n \n   /* I suppose we could check that this is contextually convertible to bool.  */\n   tree awrd_func = NULL_TREE;\n@@ -1452,10 +1465,17 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n \t\t\t\t      tf_warning_or_error);\n \n   tree stmt_list = NULL;\n+  tree t_expr = STRIP_NOPS (expr);\n+  tree r;\n+  if (t_expr == var)\n+    dtor = NULL_TREE;\n+  else\n+    {\n   /* Initialize the var from the provided 'o' expression.  */\n-  tree r = build2 (INIT_EXPR, await_type, var, expr);\n+    r = build2 (INIT_EXPR, await_type, var, expr);\n   r = coro_build_cvt_void_expr_stmt (r, loc);\n   append_to_statement_list (r, &stmt_list);\n+    }\n \n   /* Use the await_ready() call to test if we need to suspend.  */\n   tree ready_cond = TREE_VEC_ELT (awaiter_calls, 0); /* await_ready().  */\n@@ -1687,20 +1707,26 @@ transform_await_expr (tree await_expr, await_xform_data *xform)\n      and an empty pointer for void return.  */\n   TREE_OPERAND (await_expr, 0) = ah;\n \n-  /* Get a reference to the initial suspend var in the frame.  */\n-  tree as_m\n-    = lookup_member (coro_frame_type, si->await_field_id,\n-\t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n-  tree as = build_class_member_access_expr (xform->actor_frame, as_m, NULL_TREE,\n-\t\t\t\t\t    true, tf_warning_or_error);\n+  /* If we have a frame var for the awaitable, get a reference to it.  */\n+  proxy_replace data;\n+  if (si->await_field_id)\n+    {\n+      tree as_m\n+\t = lookup_member (coro_frame_type, si->await_field_id,\n+\t\t\t  /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n+      tree as = build_class_member_access_expr (xform->actor_frame, as_m,\n+\t\t\t\t\t\tNULL_TREE, true,\n+\t\t\t\t\t\ttf_warning_or_error);\n \n-  /* Replace references to the instance proxy with the frame entry now\n-     computed.  */\n-  proxy_replace data = {TREE_OPERAND (await_expr, 1), as};\n-  cp_walk_tree (&await_expr, replace_proxy, &data, NULL);\n+      /* Replace references to the instance proxy with the frame entry now\n+\t computed.  */\n+      data.from = TREE_OPERAND (await_expr, 1);\n+      data.to = as;\n+      cp_walk_tree (&await_expr, replace_proxy, &data, NULL);\n \n-  /* .. and replace.  */\n-  TREE_OPERAND (await_expr, 1) = as;\n+      /* .. and replace.  */\n+      TREE_OPERAND (await_expr, 1) = as;\n+    }\n \n   /* Now do the self_handle.  */\n   data.from = xform->self_h_proxy;\n@@ -2643,15 +2669,25 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n      as the counter used for the function-wide await point number.  */\n   data->saw_awaits++;\n \n-  /* The required field has the same type as the proxy stored in the\n-      await expr.  */\n-  tree aw_field_type = TREE_TYPE (TREE_OPERAND (aw_expr, 1));\n-\n-  size_t bufsize = sizeof (\"__aw_s.\") + 10;\n-  char *buf = (char *) alloca (bufsize);\n-  snprintf (buf, bufsize, \"__aw_s.%d\", data->count);\n-  tree aw_field_nam\n-    = coro_make_frame_entry (data->field_list, buf, aw_field_type, aw_loc);\n+  /* If the awaitable is a parm or a local variable, then we already have\n+     a frame copy, so don't make a new one.  */\n+  tree aw = TREE_OPERAND (aw_expr, 1);\n+  tree aw_field_type = TREE_TYPE (aw);\n+  tree aw_field_nam = NULL_TREE;\n+  if (INDIRECT_REF_P (aw))\n+    aw = TREE_OPERAND (aw, 0);\n+  if (TREE_CODE (aw) == PARM_DECL\n+      || (TREE_CODE (aw) == VAR_DECL && !DECL_ARTIFICIAL (aw)))\n+    ; /* Don't make an additional copy.  */\n+  else\n+    {\n+      /* The required field has the same type as the proxy stored in the\n+\t await expr.  */\n+      char *nam = xasprintf (\"__aw_s.%d\", data->count);\n+      aw_field_nam = coro_make_frame_entry (data->field_list, nam,\n+\t\t\t\t\t    aw_field_type, aw_loc);\n+      free (nam);\n+    }\n \n   /* Find out what we have to do with the awaiter's suspend method (this\n      determines if we need somewhere to stash the suspend method's handle).\n@@ -2671,9 +2707,10 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n     handle_field_nam = NULL_TREE; /* no handle is needed.  */\n   else\n     {\n-      snprintf (buf, bufsize, \"__aw_h.%u\", data->count);\n+      char *nam = xasprintf (\"__aw_h.%u\", data->count);\n       handle_field_nam\n-\t= coro_make_frame_entry (data->field_list, buf, susp_typ, aw_loc);\n+\t= coro_make_frame_entry (data->field_list, nam, susp_typ, aw_loc);\n+      free (nam);\n     }\n   register_await_info (aw_expr, aw_field_type, aw_field_nam, susp_typ,\n \t\t       handle_field_nam);"}, {"sha": "79fe37d5a179c749866767a10ff8978c6b4f4233", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=005530eb019eb7703534540bdac01e5acc611e78", "patch": "@@ -1,3 +1,8 @@\n+2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/torture/func-params-09-awaitable-parms.C: New test.\n+\t* g++.dg/coroutines/torture/local-var-5-awaitable.C: New test.\n+\n 2020-03-02  Jeff Law  <law@redhat.com>\n \n \t* gcc.target/arm/fuse-caller-save.c: Update expected output."}, {"sha": "7d376b91f13bddbce89cbc58a06227f882d13cbd", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-09-awaitable-parms.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-09-awaitable-parms.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-09-awaitable-parms.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-09-awaitable-parms.C?ref=005530eb019eb7703534540bdac01e5acc611e78", "patch": "@@ -0,0 +1,105 @@\n+// { dg-do run }\n+\n+// Check that we correctly handle params with non-trivial DTORs and\n+// use the correct copy/move CTORs.\n+\n+#include \"../coro.h\"\n+#include <vector>\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int regular = 0;\n+int copy = 0;\n+int move = 0;\n+\n+/* This is a more sophisticated awaitable... */\n+\n+struct FooAwaitable {\n+  FooAwaitable(int _v) : value(_v), x(1, _v)\n+    {\n+      regular++;\n+      PRINTF (\"FooAwaitable(%d)\\n\",_v);\n+    }\n+\n+  FooAwaitable(const FooAwaitable& t)\n+    {\n+      value = t.value;\n+      x = t.x;\n+      copy++;\n+      PRINTF (\"FooAwaitable(&), %d\\n\",value);\n+    }\n+\n+  FooAwaitable(FooAwaitable&& s)\n+    {\n+      value = s.value;\n+      s.value = -1;\n+      x = std::move(s.x);\n+      s.x = std::vector<int> ();\n+      move++;\n+      PRINTF (\"FooAwaitable(&&), %d\\n\", value);\n+    }\n+\n+  ~FooAwaitable() {PRINTF (\"~FooAwaitable(), %d\\n\", value);}\n+\n+  bool await_ready() { return false; }\n+  void await_suspend(coro::coroutine_handle<>) {}\n+  int await_resume() { return value + x[0];}\n+\n+  void return_value(int _v) { value = _v;}\n+\n+  int value;\n+  std::vector<int> x;\n+};\n+\n+coro1\n+my_coro (FooAwaitable t_lv, FooAwaitable& t_ref, FooAwaitable&& t_rv_ref)\n+{\n+  PRINT (\"my_coro\");\n+  // We are created suspended, so correct operation depends on\n+  // the parms being copied.\n+  int sum = co_await t_lv;\n+  PRINT (\"my_coro 1\");\n+  sum += co_await t_ref;\n+  PRINT (\"my_coro 2\");\n+  sum += co_await t_rv_ref;\n+  PRINT (\"my_coro 3\");\n+  co_return sum;\n+}\n+\n+int main ()\n+{\n+\n+  PRINT (\"main: create coro1\");\n+  FooAwaitable thing (4);\n+  coro1 x = my_coro (FooAwaitable (1), thing, FooAwaitable (2));\n+  PRINT (\"main: done ramp\");\n+\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  // now do the three co_awaits.\n+  while(!x.handle.done())\n+    x.handle.resume();\n+  PRINT (\"main: after resuming 3 co_awaits\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if (y != 14)\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (regular != 3 || copy != 1 || move != 1)\n+    {\n+      PRINTF (\"main: unexpected ctor use (R:%d, C:%d, M:%d)\\n\",\n+\t      regular, copy, move);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "7ea00434c87371eb70ce931c3908194df671362e", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-5-awaitable.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-5-awaitable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005530eb019eb7703534540bdac01e5acc611e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-5-awaitable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-5-awaitable.C?ref=005530eb019eb7703534540bdac01e5acc611e78", "patch": "@@ -0,0 +1,73 @@\n+//  { dg-do run }\n+\n+// Test the case where the awaitables are local vars, and therefore already\n+// have a frame representation - and should not be copied to a second frame\n+// entry (since elision of that copy would break the assumptions made in the\n+// management of the lifetime of the awaitable).\n+\n+#include \"../coro.h\"\n+#include <vector>\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Make a non-trivial awaitable.  */\n+struct Awaitable\n+{\n+  int v;\n+  std::vector<int> x;\n+  Awaitable () : v(0), x(1,0) {PRINTF (\"Awaitable()\\n\");} \n+  Awaitable (int _v) : v(_v), x(1,_v) {PRINTF (\"Awaitable(%d)\\n\",_v);}\n+\n+  bool await_ready () { return false; }\n+  void await_suspend(coro::coroutine_handle<>) {}\n+  int await_resume() { return v + x[0];}\n+\n+  ~Awaitable () {PRINTF (\"~Awaitable(%d)\\n\",v);}\n+};\n+\n+coro1\n+my_coro (int start) noexcept\n+{\n+  PRINT (\"my_coro\");\n+  Awaitable aw0 = Awaitable (start);\n+  Awaitable aw1 = Awaitable (4);\n+  Awaitable aw2 = Awaitable (10);\n+\n+  int sum;\n+  /* We are started with a suspend_always init suspend expr.  */\n+  sum = co_await aw0;\n+  PRINT (\"my_coro 1\");\n+  sum += co_await aw1;\n+  PRINT (\"my_coro 2\");\n+  sum += co_await aw2;\n+  PRINT (\"my_coro 3\");\n+\n+  co_return sum;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create my_coro\");\n+  struct coro1 x = my_coro (7);\n+  PRINT (\"main: ramp done, resuming init suspend\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+\n+  // now do the three co_awaits.\n+  while(!x.handle.done())\n+    x.handle.resume();\n+  PRINT (\"main: after resuming 3 co_awaits\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}]}