{"sha": "9f71de84041df7821e0544e96ec3cea9416c4290", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY3MWRlODQwNDFkZjc4MjFlMDU0NGU5NmVjM2NlYTk0MTZjNDI5MA==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2012-09-04T21:16:18Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2012-09-04T21:16:18Z"}, "message": "Enhances the gcov program summary by adding a histogram of arc counter entries.\n\nEnhances the gcov program summary by adding a histogram of arc counter\nentries. This is used to compute working set information in the compiler\nfor use by optimizations that need information on hot vs cold counter\nvalues or the rough working set size in terms of the number of counters.\nEach working set data point is the minimum counter value and number of\ncounters required to reach a given percentage of the cumulative counter\nsum across the profiled execution (sum_all in the program summary).\n\n2012-09-04  Teresa Johnson  <tejohnson@google.com>\n\n\t* libgcc/libgcov.c (struct gcov_summary_buffer): New structure.\n\t(gcov_histogram_insert): New function.\n\t(gcov_compute_histogram): Ditto.\n\t(gcov_exit): Invoke gcov_compute_histogram, and perform merging of\n\thistograms during summary merging.\n\t* gcc/gcov-io.c (gcov_write_summary): Write out non-zero histogram\n\tentries to function summary along with an occupancy bit vector.\n\t(gcov_read_summary): Read in the histogram entries.\n\t(gcov_histo_index): New function.\n\t(void gcov_histogram_merge): Ditto.\n\t* gcc/gcov-io.h (gcov_type_unsigned): New type.\n\t(struct gcov_bucket_type): Ditto.\n\t(struct gcov_ctr_summary): Include histogram.\n\t(GCOV_TAG_SUMMARY_LENGTH): Update to include histogram entries.\n\t(GCOV_HISTOGRAM_SIZE): New macro.\n\t(GCOV_HISTOGRAM_BITVECTOR_SIZE): Ditto.\n\t* gcc/profile.c (NUM_GCOV_WORKING_SETS): Ditto.\n\t(gcov_working_sets): New global variable.\n\t(compute_working_sets): New function.\n\t(find_working_set): Ditto.\n\t(get_exec_counts): Invoke compute_working_sets.\n\t* gcc/coverage.c (read_counts_file): Merge histograms, and\n\tfix bug with accessing summary info for non-summable counters.\n\t* gcc/basic-block.h (gcov_type_unsigned): New type.\n\t(struct gcov_working_set_info): Ditto.\n\t(find_working_set): Declare.\n\t* gcc/gcov-dump.c (tag_summary): Dump out histogram.\n\nFrom-SVN: r190952", "tree": {"sha": "c9108c2ac0250e06b19698c7d374c820ed352432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9108c2ac0250e06b19698c7d374c820ed352432"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f71de84041df7821e0544e96ec3cea9416c4290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f71de84041df7821e0544e96ec3cea9416c4290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f71de84041df7821e0544e96ec3cea9416c4290", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f71de84041df7821e0544e96ec3cea9416c4290/comments", "author": null, "committer": null, "parents": [{"sha": "bde6de5d4ba6258094a7a6fb47af74935711d3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde6de5d4ba6258094a7a6fb47af74935711d3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde6de5d4ba6258094a7a6fb47af74935711d3c6"}], "stats": {"total": 627, "additions": 609, "deletions": 18}, "files": [{"sha": "288127f566083a35aa131564fadfdd243117ae17", "filename": "gcc/basic-block.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n    flow graph is manipulated by various optimizations.  A signed type\n    makes those easy to detect.  */\n typedef HOST_WIDEST_INT gcov_type;\n+typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n \n /* Control flow edge information.  */\n struct GTY((user)) edge_def {\n@@ -91,6 +92,16 @@ enum cfg_edge_flags {\n    profile.c.  */\n extern const struct gcov_ctr_summary *profile_info;\n \n+/* Working set size statistics for a given percentage of the entire\n+   profile (sum_all from the counter summary).  */\n+typedef struct gcov_working_set_info\n+{\n+  /* Number of hot counters included in this working set.  */\n+  unsigned num_counters;\n+  /* Smallest counter included in this working set.  */\n+  gcov_type min_counter;\n+} gcov_working_set_t;\n+\n /* Declared in cfgloop.h.  */\n struct loop;\n \n@@ -897,4 +908,7 @@ extern void rtl_profile_for_bb (basic_block);\n extern void rtl_profile_for_edge (edge);\n extern void default_rtl_profile (void);\n \n+/* In profile.c.  */\n+extern gcov_working_set_t *find_working_set(unsigned pct_times_10);\n+\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "f9b12e8b6f64450b74b1dd9f11d4efdd59ef847a", "filename": "gcc/coverage.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -248,6 +248,13 @@ read_counts_file (void)\n \t\tsummary.ctrs[ix].run_max = sum.ctrs[ix].run_max;\n \t      summary.ctrs[ix].sum_max += sum.ctrs[ix].sum_max;\n \t    }\n+          if (new_summary)\n+            memcpy (summary.ctrs[GCOV_COUNTER_ARCS].histogram,\n+                    sum.ctrs[GCOV_COUNTER_ARCS].histogram,\n+                    sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+          else\n+            gcov_histogram_merge (summary.ctrs[GCOV_COUNTER_ARCS].histogram,\n+                                  sum.ctrs[GCOV_COUNTER_ARCS].histogram);\n \t  new_summary = 0;\n \t}\n       else if (GCOV_TAG_IS_COUNTER (tag) && fn_ident)\n@@ -268,8 +275,9 @@ read_counts_file (void)\n \t      entry->ctr = elt.ctr;\n \t      entry->lineno_checksum = lineno_checksum;\n \t      entry->cfg_checksum = cfg_checksum;\n-\t      entry->summary = summary.ctrs[elt.ctr];\n-\t      entry->summary.num = n_counts;\n+              if (elt.ctr < GCOV_COUNTERS_SUMMABLE)\n+                entry->summary = summary.ctrs[elt.ctr];\n+              entry->summary.num = n_counts;\n \t      entry->counts = XCNEWVEC (gcov_type, n_counts);\n \t    }\n \t  else if (entry->lineno_checksum != lineno_checksum"}, {"sha": "fb01108946c6173ad714be031ee9f2dc1d236485", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -447,7 +447,8 @@ tag_summary (const char *filename ATTRIBUTE_UNUSED,\n \t     unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   struct gcov_summary summary;\n-  unsigned ix;\n+  unsigned ix, h_ix;\n+  gcov_bucket_type *histo_bucket;\n \n   gcov_read_summary (&summary);\n   printf (\" checksum=0x%08x\", summary.checksum);\n@@ -465,5 +466,24 @@ tag_summary (const char *filename ATTRIBUTE_UNUSED,\n \t      (HOST_WIDEST_INT)summary.ctrs[ix].run_max);\n       printf (\", sum_max=\" HOST_WIDEST_INT_PRINT_DEC,\n \t      (HOST_WIDEST_INT)summary.ctrs[ix].sum_max);\n+      if (ix != GCOV_COUNTER_ARCS)\n+        continue;\n+      printf (\"\\n\");\n+      print_prefix (filename, 0, 0);\n+      printf (\"\\t\\tcounter histogram:\");\n+      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+        {\n+          histo_bucket = &summary.ctrs[ix].histogram[h_ix];\n+          if (!histo_bucket->num_counters)\n+            continue;\n+          printf (\"\\n\");\n+          print_prefix (filename, 0, 0);\n+          printf (\"\\t\\t%d: num counts=%u, min counter=\"\n+              HOST_WIDEST_INT_PRINT_DEC \", cum_counter=\"\n+              HOST_WIDEST_INT_PRINT_DEC,\n+\t      h_ix, histo_bucket->num_counters,\n+              (HOST_WIDEST_INT)histo_bucket->min_value,\n+              (HOST_WIDEST_INT)histo_bucket->cum_value);\n+        }\n     }\n }"}, {"sha": "d64fb42c3c2868cb7c072a65b5ad09f789449078", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 255, "deletions": 4, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -368,10 +368,25 @@ gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n GCOV_LINKAGE void\n gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n {\n-  unsigned ix;\n+  unsigned ix, h_ix, bv_ix, h_cnt = 0;\n   const struct gcov_ctr_summary *csum;\n-\n-  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH);\n+  unsigned histo_bitvector[GCOV_HISTOGRAM_BITVECTOR_SIZE];\n+\n+  /* Count number of non-zero histogram entries, and fill in a bit vector\n+     of non-zero indices. The histogram is only currently computed for arc\n+     counters.  */\n+  for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n+    histo_bitvector[bv_ix] = 0;\n+  csum = &summary->ctrs[GCOV_COUNTER_ARCS];\n+  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+    {\n+      if (csum->histogram[h_ix].num_counters > 0)\n+        {\n+          histo_bitvector[h_ix / 32] |= 1 << (h_ix % 32);\n+          h_cnt++;\n+        }\n+    }\n+  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH(h_cnt));\n   gcov_write_unsigned (summary->checksum);\n   for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n     {\n@@ -380,6 +395,22 @@ gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n       gcov_write_counter (csum->sum_all);\n       gcov_write_counter (csum->run_max);\n       gcov_write_counter (csum->sum_max);\n+      if (ix != GCOV_COUNTER_ARCS)\n+        {\n+          for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n+            gcov_write_unsigned (0);\n+          continue;\n+        }\n+      for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n+        gcov_write_unsigned (histo_bitvector[bv_ix]);\n+      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+        {\n+          if (!csum->histogram[h_ix].num_counters)\n+            continue;\n+          gcov_write_unsigned (csum->histogram[h_ix].num_counters);\n+          gcov_write_counter (csum->histogram[h_ix].min_value);\n+          gcov_write_counter (csum->histogram[h_ix].cum_value);\n+        }\n     }\n }\n #endif /* IN_LIBGCOV */\n@@ -488,8 +519,10 @@ gcov_read_string (void)\n GCOV_LINKAGE void\n gcov_read_summary (struct gcov_summary *summary)\n {\n-  unsigned ix;\n+  unsigned ix, h_ix, bv_ix, h_cnt = 0;\n   struct gcov_ctr_summary *csum;\n+  unsigned histo_bitvector[GCOV_HISTOGRAM_BITVECTOR_SIZE];\n+  unsigned cur_bitvector;\n \n   summary->checksum = gcov_read_unsigned ();\n   for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n@@ -499,6 +532,43 @@ gcov_read_summary (struct gcov_summary *summary)\n       csum->sum_all = gcov_read_counter ();\n       csum->run_max = gcov_read_counter ();\n       csum->sum_max = gcov_read_counter ();\n+      memset (csum->histogram, 0,\n+              sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+      for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n+        {\n+          histo_bitvector[bv_ix] = gcov_read_unsigned ();\n+          h_cnt += __builtin_popcountll (histo_bitvector[bv_ix]);\n+        }\n+      bv_ix = 0;\n+      h_ix = 0;\n+      cur_bitvector = 0;\n+      while (h_cnt--)\n+        {\n+          /* Find the index corresponding to the next entry we will read in.\n+             First find the next non-zero bitvector and re-initialize\n+             the histogram index accordingly, then right shift and increment\n+             the index until we find a set bit.  */\n+          while (!cur_bitvector)\n+            {\n+              h_ix = bv_ix * 32;\n+              cur_bitvector = histo_bitvector[bv_ix++];\n+              gcc_assert(bv_ix <= GCOV_HISTOGRAM_BITVECTOR_SIZE);\n+            }\n+          while (!(cur_bitvector & 0x1))\n+            {\n+              h_ix++;\n+              cur_bitvector >>= 1;\n+            }\n+          gcc_assert(h_ix < GCOV_HISTOGRAM_SIZE);\n+\n+          csum->histogram[h_ix].num_counters = gcov_read_unsigned ();\n+          csum->histogram[h_ix].min_value = gcov_read_counter ();\n+          csum->histogram[h_ix].cum_value = gcov_read_counter ();\n+          /* Shift off the index we are done with and increment to the\n+             corresponding next histogram entry.  */\n+          cur_bitvector >>= 1;\n+          h_ix++;\n+        }\n     }\n }\n \n@@ -550,3 +620,184 @@ gcov_time (void)\n     return status.st_mtime;\n }\n #endif /* IN_GCOV */\n+\n+#if IN_LIBGCOV || !IN_GCOV\n+/* Determine the index into histogram for VALUE. */\n+\n+static unsigned\n+gcov_histo_index(gcov_type value)\n+{\n+  gcov_type_unsigned v = (gcov_type_unsigned)value;\n+  unsigned r = 0;\n+  unsigned prev2bits = 0;\n+\n+  /* Find index into log2 scale histogram, where each of the log2\n+     sized buckets is divided into 4 linear sub-buckets for better\n+     focus in the higher buckets.  */\n+\n+  /* Find the place of the most-significant bit set.  */\n+  if (v > 0)\n+    r = 63 - __builtin_clzll (v);\n+\n+  /* If at most the 2 least significant bits are set (value is\n+     0 - 3) then that value is our index into the lowest set of\n+     four buckets.  */\n+  if (r < 2)\n+    return (unsigned)value;\n+\n+  gcc_assert (r < 64);\n+\n+  /* Find the two next most significant bits to determine which\n+     of the four linear sub-buckets to select.  */\n+  prev2bits = (v >> (r - 2)) & 0x3;\n+  /* Finally, compose the final bucket index from the log2 index and\n+     the next 2 bits. The minimum r value at this point is 2 since we\n+     returned above if r was 2 or more, so the minimum bucket at this\n+     point is 4.  */\n+  return (r - 1) * 4 + prev2bits;\n+}\n+\n+/* Merge SRC_HISTO into TGT_HISTO. The counters are assumed to be in\n+   the same relative order in both histograms, and are matched up\n+   and merged in reverse order. Each counter is assigned an equal portion of\n+   its entry's original cumulative counter value when computing the\n+   new merged cum_value.  */\n+\n+static void gcov_histogram_merge(gcov_bucket_type *tgt_histo,\n+                                 gcov_bucket_type *src_histo)\n+{\n+  int src_i, tgt_i, tmp_i = 0;\n+  unsigned src_num, tgt_num, merge_num;\n+  gcov_type src_cum, tgt_cum, merge_src_cum, merge_tgt_cum, merge_cum;\n+  gcov_type merge_min;\n+  gcov_bucket_type tmp_histo[GCOV_HISTOGRAM_SIZE];\n+  int src_done = 0;\n+\n+  memset(tmp_histo, 0, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+\n+  /* Assume that the counters are in the same relative order in both\n+     histograms. Walk the histograms from largest to smallest entry,\n+     matching up and combining counters in order.  */\n+  src_num = 0;\n+  src_cum = 0;\n+  src_i = GCOV_HISTOGRAM_SIZE - 1;\n+  for (tgt_i = GCOV_HISTOGRAM_SIZE - 1; tgt_i >= 0 && !src_done; tgt_i--)\n+    {\n+      tgt_num = tgt_histo[tgt_i].num_counters;\n+      tgt_cum = tgt_histo[tgt_i].cum_value;\n+      /* Keep going until all of the target histogram's counters at this\n+         position have been matched and merged with counters from the\n+         source histogram.  */\n+      while (tgt_num > 0 && !src_done)\n+        {\n+          /* If this is either the first time through this loop or we just\n+             exhausted the previous non-zero source histogram entry, look\n+             for the next non-zero source histogram entry.  */\n+          if (!src_num)\n+            {\n+              /* Locate the next non-zero entry.  */\n+              while (src_i >= 0 && !src_histo[src_i].num_counters)\n+                src_i--;\n+              /* If source histogram has fewer counters, then just copy over the\n+                 remaining target counters and quit.  */\n+              if (src_i < 0)\n+                {\n+                  tmp_histo[tgt_i].num_counters += tgt_num;\n+                  tmp_histo[tgt_i].cum_value += tgt_cum;\n+                  if (!tmp_histo[tgt_i].min_value ||\n+                      tgt_histo[tgt_i].min_value < tmp_histo[tgt_i].min_value)\n+                    tmp_histo[tgt_i].min_value = tgt_histo[tgt_i].min_value;\n+                  while (--tgt_i >= 0)\n+                    {\n+                      tmp_histo[tgt_i].num_counters\n+                          += tgt_histo[tgt_i].num_counters;\n+                      tmp_histo[tgt_i].cum_value += tgt_histo[tgt_i].cum_value;\n+                      if (!tmp_histo[tgt_i].min_value ||\n+                          tgt_histo[tgt_i].min_value\n+                          < tmp_histo[tgt_i].min_value)\n+                        tmp_histo[tgt_i].min_value = tgt_histo[tgt_i].min_value;\n+                    }\n+\n+                  src_done = 1;\n+                  break;\n+                }\n+\n+              src_num = src_histo[src_i].num_counters;\n+              src_cum = src_histo[src_i].cum_value;\n+            }\n+\n+          /* The number of counters to merge on this pass is the minimum\n+             of the remaining counters from the current target and source\n+             histogram entries.  */\n+          merge_num = tgt_num;\n+          if (src_num < merge_num)\n+            merge_num = src_num;\n+\n+          /* The merged min_value is the sum of the min_values from target\n+             and source.  */\n+          merge_min = tgt_histo[tgt_i].min_value + src_histo[src_i].min_value;\n+\n+          /* Compute the portion of source and target entries' cum_value\n+             that will be apportioned to the counters being merged.\n+             The total remaining cum_value from each entry is divided\n+             equally among the counters from that histogram entry if we\n+             are not merging all of them.  */\n+          merge_src_cum = src_cum;\n+          if (merge_num < src_num)\n+            merge_src_cum = merge_num * src_cum / src_num;\n+          merge_tgt_cum = tgt_cum;\n+          if (merge_num < tgt_num)\n+            merge_tgt_cum = merge_num * tgt_cum / tgt_num;\n+          /* The merged cum_value is the sum of the source and target\n+             components.  */\n+          merge_cum = merge_src_cum + merge_tgt_cum;\n+\n+          /* Update the remaining number of counters and cum_value left\n+             to be merged from this source and target entry.  */\n+          src_cum -= merge_src_cum;\n+          tgt_cum -= merge_tgt_cum;\n+          src_num -= merge_num;\n+          tgt_num -= merge_num;\n+\n+          /* The merged counters get placed in the new merged histogram\n+             at the entry for the merged min_value.  */\n+          tmp_i = gcov_histo_index(merge_min);\n+          gcc_assert (tmp_i < GCOV_HISTOGRAM_SIZE);\n+          tmp_histo[tmp_i].num_counters += merge_num;\n+          tmp_histo[tmp_i].cum_value += merge_cum;\n+          if (!tmp_histo[tmp_i].min_value ||\n+              merge_min < tmp_histo[tmp_i].min_value)\n+            tmp_histo[tmp_i].min_value = merge_min;\n+\n+          /* Ensure the search for the next non-zero src_histo entry starts\n+             at the next smallest histogram bucket.  */\n+          if (!src_num)\n+            src_i--;\n+        }\n+    }\n+\n+  gcc_assert (tgt_i < 0);\n+\n+  /* In the case where there were more counters in the source histogram,\n+     accumulate the remaining unmerged cumulative counter values. Add\n+     those to the smallest non-zero target histogram entry. Otherwise,\n+     the total cumulative counter values in the histogram will be smaller\n+     than the sum_all stored in the summary, which will complicate\n+     computing the working set information from the histogram later on.  */\n+  if (src_num)\n+    src_i--;\n+  while (src_i >= 0)\n+    {\n+      src_cum += src_histo[src_i].cum_value;\n+      src_i--;\n+    }\n+  /* At this point, tmp_i should be the smallest non-zero entry in the\n+     tmp_histo.  */\n+  gcc_assert(tmp_i >= 0 && tmp_i < GCOV_HISTOGRAM_SIZE\n+             && tmp_histo[tmp_i].num_counters > 0);\n+  tmp_histo[tmp_i].cum_value += src_cum;\n+\n+  /* Finally, copy the merged histogram into tgt_histo.  */\n+  memcpy(tgt_histo, tmp_histo, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+}\n+#endif /* IN_LIBGCOV || !IN_GCOV */"}, {"sha": "e1532d79bcd957051db2933ed5fbf1f73f763d67", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -139,7 +139,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \tcounts: header int64:count*\n \tsummary: int32:checksum {count-summary}GCOV_COUNTERS_SUMMABLE\n \tcount-summary:\tint32:num int32:runs int64:sum\n-\t\t\tint64:max int64:sum_max\n+\t\t\tint64:max int64:sum_max histogram\n+        histogram: {int32:bitvector}8 histogram-buckets*\n+        histogram-buckets: int32:num int64:min int64:sum\n \n    The ANNOUNCE_FUNCTION record is the same as that in the note file,\n    but without the source location.  The COUNTS gives the\n@@ -171,25 +173,31 @@ typedef unsigned gcov_unsigned_t __attribute__ ((mode (SI)));\n typedef unsigned gcov_position_t __attribute__ ((mode (SI)));\n #if LONG_LONG_TYPE_SIZE > 32\n typedef signed gcov_type __attribute__ ((mode (DI)));\n+typedef unsigned gcov_type_unsigned __attribute__ ((mode (DI)));\n #else\n typedef signed gcov_type __attribute__ ((mode (SI)));\n+typedef unsigned gcov_type_unsigned __attribute__ ((mode (SI)));\n #endif\n #else\n #if BITS_PER_UNIT == 16\n typedef unsigned gcov_unsigned_t __attribute__ ((mode (HI)));\n typedef unsigned gcov_position_t __attribute__ ((mode (HI)));\n #if LONG_LONG_TYPE_SIZE > 32\n typedef signed gcov_type __attribute__ ((mode (SI)));\n+typedef unsigned gcov_type_unsigned __attribute__ ((mode (SI)));\n #else\n typedef signed gcov_type __attribute__ ((mode (HI)));\n+typedef unsigned gcov_type_unsigned __attribute__ ((mode (HI)));\n #endif\n #else\n typedef unsigned gcov_unsigned_t __attribute__ ((mode (QI)));\n typedef unsigned gcov_position_t __attribute__ ((mode (QI)));\n #if LONG_LONG_TYPE_SIZE > 32\n typedef signed gcov_type __attribute__ ((mode (HI)));\n+typedef unsigned gcov_type_unsigned __attribute__ ((mode (HI)));\n #else\n typedef signed gcov_type __attribute__ ((mode (QI)));\n+typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));\n #endif\n #endif\n #endif\n@@ -210,6 +218,7 @@ typedef unsigned gcov_position_t;\n #if IN_GCOV\n #define GCOV_LINKAGE static\n typedef HOST_WIDEST_INT gcov_type;\n+typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n #if IN_GCOV > 0\n #include <sys/types.h>\n #endif\n@@ -309,8 +318,9 @@ typedef HOST_WIDEST_INT gcov_type;\n #define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n #define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000) /* Obsolete */\n #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n-#define GCOV_TAG_SUMMARY_LENGTH  \\\n-\t(1 + GCOV_COUNTERS_SUMMABLE * (2 + 3 * 2))\n+#define GCOV_TAG_SUMMARY_LENGTH(NUM)  \\\n+        (1 + GCOV_COUNTERS_SUMMABLE * (10 + 3 * 2) + (NUM) * 5)\n+\n \n /* Counters that are collected.  */\n #define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n@@ -389,6 +399,29 @@ typedef HOST_WIDEST_INT gcov_type;\n \n /* Structured records.  */\n \n+/* Structure used for each bucket of the log2 histogram of counter values.  */\n+typedef struct\n+{\n+  /* Number of counters whose profile count falls within the bucket.  */\n+  gcov_unsigned_t num_counters;\n+  /* Smallest profile count included in this bucket.  */\n+  gcov_type min_value;\n+  /* Cumulative value of the profile counts in this bucket.  */\n+  gcov_type cum_value;\n+} gcov_bucket_type;\n+\n+/* For a log2 scale histogram with each range split into 4\n+   linear sub-ranges, there will be at most 64 (max gcov_type bit size) - 1 log2\n+   ranges since the lowest 2 log2 values share the lowest 4 linear\n+   sub-range (values 0 - 3).  This is 252 total entries (63*4).  */\n+\n+#define GCOV_HISTOGRAM_SIZE 252\n+\n+/* How many unsigned ints are required to hold a bit vector of non-zero\n+   histogram entries when the histogram is written to the gcov file.\n+   This is essentially a ceiling divide by 32 bits.  */\n+#define GCOV_HISTOGRAM_BITVECTOR_SIZE (GCOV_HISTOGRAM_SIZE + 31) / 32\n+\n /* Cumulative counter data.  */\n struct gcov_ctr_summary\n {\n@@ -397,6 +430,8 @@ struct gcov_ctr_summary\n   gcov_type sum_all;\t\t/* sum of all counters accumulated.  */\n   gcov_type run_max;\t\t/* maximum value on a single run.  */\n   gcov_type sum_max;    \t/* sum of individual run max values.  */\n+  gcov_bucket_type histogram[GCOV_HISTOGRAM_SIZE]; /* histogram of\n+                                                      counter values.  */\n };\n \n /* Object & program summary record.  */"}, {"sha": "a5029a1037ba728deda9ef8c1f4d70b3934e940f", "filename": "gcc/profile.c", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -84,6 +84,15 @@ struct bb_info {\n \n const struct gcov_ctr_summary *profile_info;\n \n+/* Number of data points in the working set summary array. Using 128\n+   provides information for at least every 1% increment of the total\n+   profile size. The last entry is hardwired to 99.9% of the total.  */\n+#define NUM_GCOV_WORKING_SETS 128\n+\n+/* Counter working set information computed from the current counter\n+   summary. Not initialized unless profile_info summary is non-NULL.  */\n+static gcov_working_set_t gcov_working_sets[NUM_GCOV_WORKING_SETS];\n+\n /* Collect statistics on the performance of this pass for the entire source\n    file.  */\n \n@@ -192,6 +201,152 @@ instrument_values (histogram_values values)\n }\n \f\n \n+/* Compute the working set information from the counter histogram in\n+   the profile summary. This is an array of information corresponding to a\n+   range of percentages of the total execution count (sum_all), and includes\n+   the number of counters required to cover that working set percentage and\n+   the minimum counter value in that working set.  */\n+\n+static void\n+compute_working_sets (void)\n+{\n+  gcov_type working_set_cum_values[NUM_GCOV_WORKING_SETS];\n+  gcov_type ws_cum_hotness_incr;\n+  gcov_type cum, tmp_cum;\n+  const gcov_bucket_type *histo_bucket;\n+  unsigned ws_ix, c_num, count, pctinc, pct;\n+  int h_ix;\n+  gcov_working_set_t *ws_info;\n+\n+  if (!profile_info)\n+    return;\n+\n+  /* Compute the amount of sum_all that the cumulative hotness grows\n+     by in each successive working set entry, which depends on the\n+     number of working set entries.  */\n+  ws_cum_hotness_incr = profile_info->sum_all / NUM_GCOV_WORKING_SETS;\n+\n+  /* Next fill in an array of the cumulative hotness values corresponding\n+     to each working set summary entry we are going to compute below.\n+     Skip 0% statistics, which can be extrapolated from the\n+     rest of the summary data.  */\n+  cum = ws_cum_hotness_incr;\n+  for (ws_ix = 0; ws_ix < NUM_GCOV_WORKING_SETS;\n+       ws_ix++, cum += ws_cum_hotness_incr)\n+    working_set_cum_values[ws_ix] = cum;\n+  /* The last summary entry is reserved for (roughly) 99.9% of the\n+     working set. Divide by 1024 so it becomes a shift, which gives\n+     almost exactly 99.9%.  */\n+  working_set_cum_values[NUM_GCOV_WORKING_SETS-1]\n+      = profile_info->sum_all - profile_info->sum_all/1024;\n+\n+  /* Next, walk through the histogram in decending order of hotness\n+     and compute the statistics for the working set summary array.\n+     As histogram entries are accumulated, we check to see which\n+     working set entries have had their expected cum_value reached\n+     and fill them in, walking the working set entries in increasing\n+     size of cum_value.  */\n+  ws_ix = 0; /* The current entry into the working set array.  */\n+  cum = 0; /* The current accumulated counter sum.  */\n+  count = 0; /* The current accumulated count of block counters.  */\n+  for (h_ix = GCOV_HISTOGRAM_SIZE - 1;\n+       h_ix >= 0 && ws_ix < NUM_GCOV_WORKING_SETS; h_ix--)\n+    {\n+      histo_bucket = &profile_info->histogram[h_ix];\n+\n+      /* If we haven't reached the required cumulative counter value for\n+         the current working set percentage, simply accumulate this histogram\n+         entry into the running sums and continue to the next histogram\n+         entry.  */\n+      if (cum + histo_bucket->cum_value < working_set_cum_values[ws_ix])\n+        {\n+          cum += histo_bucket->cum_value;\n+          count += histo_bucket->num_counters;\n+          continue;\n+        }\n+\n+      /* If adding the current histogram entry's cumulative counter value\n+         causes us to exceed the current working set size, then estimate\n+         how many of this histogram entry's counter values are required to\n+         reach the working set size, and fill in working set entries\n+         as we reach their expected cumulative value.  */\n+      for (c_num = 0, tmp_cum = cum;\n+           c_num < histo_bucket->num_counters && ws_ix < NUM_GCOV_WORKING_SETS;\n+           c_num++)\n+        {\n+          count++;\n+          /* If we haven't reached the last histogram entry counter, add\n+             in the minimum value again. This will underestimate the\n+             cumulative sum so far, because many of the counter values in this\n+             entry may have been larger than the minimum. We could add in the\n+             average value every time, but that would require an expensive\n+             divide operation.  */\n+          if (c_num + 1 < histo_bucket->num_counters)\n+            tmp_cum += histo_bucket->min_value;\n+          /* If we have reached the last histogram entry counter, then add\n+             in the entire cumulative value.  */\n+          else\n+            tmp_cum = cum + histo_bucket->cum_value;\n+\n+          /* Next walk through successive working set entries and fill in\n+            the statistics for any whose size we have reached by accumulating\n+            this histogram counter.  */\n+          while (tmp_cum >= working_set_cum_values[ws_ix]\n+                 && ws_ix < NUM_GCOV_WORKING_SETS)\n+            {\n+              gcov_working_sets[ws_ix].num_counters = count;\n+              gcov_working_sets[ws_ix].min_counter\n+                  = histo_bucket->min_value;\n+              ws_ix++;\n+            }\n+        }\n+      /* Finally, update the running cumulative value since we were\n+         using a temporary above.  */\n+      cum += histo_bucket->cum_value;\n+    }\n+  gcc_assert (ws_ix == NUM_GCOV_WORKING_SETS);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Counter working sets:\\n\");\n+      /* Multiply the percentage by 100 to avoid float.  */\n+      pctinc = 100 * 100 / NUM_GCOV_WORKING_SETS;\n+      for (ws_ix = 0, pct = pctinc; ws_ix < NUM_GCOV_WORKING_SETS;\n+           ws_ix++, pct += pctinc)\n+        {\n+          if (ws_ix == NUM_GCOV_WORKING_SETS - 1)\n+            pct = 9990;\n+          ws_info = &gcov_working_sets[ws_ix];\n+          /* Print out the percentage using int arithmatic to avoid float.  */\n+          fprintf (dump_file, \"\\t\\t%u.%02u%%: num counts=%u, min counter=\"\n+                   HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n+                   pct / 100, pct - (pct / 100 * 100),\n+                   ws_info->num_counters,\n+                   (HOST_WIDEST_INT)ws_info->min_counter);\n+        }\n+    }\n+}\n+\n+/* Given a the desired percentage of the full profile (sum_all from the\n+   summary), multiplied by 10 to avoid float in PCT_TIMES_10, returns\n+   the corresponding working set information. If an exact match for\n+   the percentage isn't found, the closest value is used.  */\n+\n+gcov_working_set_t *\n+find_working_set (unsigned pct_times_10)\n+{\n+  unsigned i;\n+  if (!profile_info)\n+    return NULL;\n+  gcc_assert (pct_times_10 <= 1000);\n+  if (pct_times_10 >= 999)\n+    return &gcov_working_sets[NUM_GCOV_WORKING_SETS - 1];\n+  i = pct_times_10 * NUM_GCOV_WORKING_SETS / 1000;\n+  if (!i)\n+    return &gcov_working_sets[0];\n+  return &gcov_working_sets[i - 1];\n+}\n+\n /* Computes hybrid profile for all matching entries in da_file.  \n    \n    CFG_CHECKSUM is the precomputed checksum for the CFG.  */\n@@ -219,6 +374,8 @@ get_exec_counts (unsigned cfg_checksum, unsigned lineno_checksum)\n   if (!counts)\n     return NULL;\n \n+  compute_working_sets();\n+\n   if (dump_file && profile_info)\n     fprintf(dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n \t    profile_info->runs, (unsigned) profile_info->sum_max);"}, {"sha": "fce8587affe3c30e38f382be5444aa8ed38e2708", "filename": "libgcc/libgcov.c", "status": "modified", "additions": 114, "deletions": 8, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f71de84041df7821e0544e96ec3cea9416c4290/libgcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f71de84041df7821e0544e96ec3cea9416c4290/libgcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.c?ref=9f71de84041df7821e0544e96ec3cea9416c4290", "patch": "@@ -97,6 +97,12 @@ struct gcov_fn_buffer\n   /* note gcov_fn_info ends in a trailing array.  */\n };\n \n+struct gcov_summary_buffer\n+{\n+  struct gcov_summary_buffer *next;\n+  struct gcov_summary summary;\n+};\n+\n /* Chain of per-object gcov structures.  */\n static struct gcov_info *gcov_list;\n \n@@ -276,6 +282,76 @@ gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,\n   return 1;\n }\n \n+/* Insert counter VALUE into HISTOGRAM.  */\n+\n+static void\n+gcov_histogram_insert(gcov_bucket_type *histogram, gcov_type value)\n+{\n+  unsigned i;\n+\n+  i = gcov_histo_index(value);\n+  histogram[i].num_counters++;\n+  histogram[i].cum_value += value;\n+  if (value < histogram[i].min_value)\n+    histogram[i].min_value = value;\n+}\n+\n+/* Computes a histogram of the arc counters to place in the summary SUM.  */\n+\n+static void\n+gcov_compute_histogram (struct gcov_summary *sum)\n+{\n+  struct gcov_info *gi_ptr;\n+  const struct gcov_fn_info *gfi_ptr;\n+  const struct gcov_ctr_info *ci_ptr;\n+  struct gcov_ctr_summary *cs_ptr;\n+  unsigned t_ix, f_ix, ctr_info_ix, ix;\n+  int h_ix;\n+\n+  /* This currently only applies to arc counters.  */\n+  t_ix = GCOV_COUNTER_ARCS;\n+\n+  /* First check if there are any counts recorded for this counter.  */\n+  cs_ptr = &(sum->ctrs[t_ix]);\n+  if (!cs_ptr->num)\n+    return;\n+\n+  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+    {\n+      cs_ptr->histogram[h_ix].num_counters = 0;\n+      cs_ptr->histogram[h_ix].min_value = cs_ptr->run_max;\n+      cs_ptr->histogram[h_ix].cum_value = 0;\n+    }\n+\n+  /* Walk through all the per-object structures and record each of\n+     the count values in histogram.  */\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n+    {\n+      if (!gi_ptr->merge[t_ix])\n+        continue;\n+\n+      /* Find the appropriate index into the gcov_ctr_info array\n+         for the counter we are currently working on based on the\n+         existence of the merge function pointer for this object.  */\n+      for (ix = 0, ctr_info_ix = 0; ix < t_ix; ix++)\n+        {\n+          if (gi_ptr->merge[ix])\n+            ctr_info_ix++;\n+        }\n+      for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n+        {\n+          gfi_ptr = gi_ptr->functions[f_ix];\n+\n+          if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+            continue;\n+\n+          ci_ptr = &gfi_ptr->ctrs[ctr_info_ix];\n+          for (ix = 0; ix < ci_ptr->num; ix++)\n+            gcov_histogram_insert (cs_ptr->histogram, ci_ptr->values[ix]);\n+        }\n+    }\n+}\n+\n /* Dump the coverage counts. We merge with existing counts when\n    possible, to avoid growing the .da files ad infinitum. We use this\n    program's checksum to make sure we only accumulate whole program\n@@ -347,6 +423,7 @@ gcov_exit (void)\n \t    }\n \t}\n     }\n+  gcov_compute_histogram (&this_prg);\n \n   {\n     /* Check if the level of dirs to strip off specified. */\n@@ -400,6 +477,8 @@ gcov_exit (void)\n       const char *fname, *s;\n       struct gcov_fn_buffer *fn_buffer = 0;\n       struct gcov_fn_buffer **fn_tail = &fn_buffer;\n+      struct gcov_summary_buffer *next_sum_buffer, *sum_buffer = 0;\n+      struct gcov_summary_buffer **sum_tail = &sum_buffer;\n \n       fname = gi_ptr->filename;\n \n@@ -482,17 +561,29 @@ gcov_exit (void)\n \n \t      f_ix--;\n \t      length = gcov_read_unsigned ();\n-\t      if (length != GCOV_TAG_SUMMARY_LENGTH)\n-\t\tgoto read_mismatch;\n \t      gcov_read_summary (&tmp);\n \t      if ((error = gcov_is_error ()))\n \t\tgoto read_error;\n-\t      if (summary_pos || tmp.checksum != crc32)\n-\t\tgoto next_summary;\n+\t      if (summary_pos)\n+                {\n+                  /* Save all summaries after the one that will be\n+                     merged into below. These will need to be rewritten\n+                     as histogram merging may change the number of non-zero\n+                     histogram entries that will be emitted, and thus the\n+                     size of the merged summary.  */\n+                  (*sum_tail) = (struct gcov_summary_buffer *)\n+                      malloc (sizeof(struct gcov_summary_buffer));\n+                  (*sum_tail)->summary = tmp;\n+                  (*sum_tail)->next = 0;\n+                  sum_tail = &((*sum_tail)->next);\n+                  goto next_summary;\n+                }\n+\t      if (tmp.checksum != crc32)\n+                goto next_summary;\n \t      \n \t      for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n \t\tif (tmp.ctrs[t_ix].num != this_prg.ctrs[t_ix].num)\n-\t\t  goto next_summary;\n+                  goto next_summary;\n \t      prg = tmp;\n \t      summary_pos = eof_pos;\n \n@@ -598,11 +689,16 @@ gcov_exit (void)\n \t  if (gi_ptr->merge[t_ix])\n \t    {\n \t      if (!cs_prg->runs++)\n-\t\tcs_prg->num = cs_tprg->num;\n+\t        cs_prg->num = cs_tprg->num;\n \t      cs_prg->sum_all += cs_tprg->sum_all;\n \t      if (cs_prg->run_max < cs_tprg->run_max)\n \t\tcs_prg->run_max = cs_tprg->run_max;\n \t      cs_prg->sum_max += cs_tprg->run_max;\n+              if (cs_prg->runs == 1)\n+                memcpy (cs_prg->histogram, cs_tprg->histogram,\n+                        sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+              else\n+                gcov_histogram_merge (cs_prg->histogram, cs_tprg->histogram);\n \t    }\n \t  else if (cs_prg->runs)\n \t    goto read_mismatch;\n@@ -635,8 +731,18 @@ gcov_exit (void)\n       /* Generate whole program statistics.  */\n       gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &prg);\n \n-      if (summary_pos < eof_pos)\n-\tgcov_seek (eof_pos);\n+      /* Rewrite all the summaries that were after the summary we merged\n+         into. This is necessary as the merged summary may have a different\n+         size due to the number of non-zero histogram entries changing after\n+         merging.  */\n+      \n+      while (sum_buffer)\n+        {\n+          gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &sum_buffer->summary);\n+          next_sum_buffer = sum_buffer->next;\n+          free (sum_buffer);\n+          sum_buffer = next_sum_buffer;\n+        }\n \n       /* Write execution counts for each function.  */\n       for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)"}]}