{"sha": "f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3ZTIyNzRkMGU2M2JmOWI0ZTQ5OTcyMWU4ZWNlOTlmNGJjZDZkMg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-05-29T17:25:04Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-05-29T17:25:04Z"}, "message": "decl.c (ENABLE_SCOPE_CHECKING): Rename from DEBUG_BINDING_LEVELS.\n\n        * decl.c (ENABLE_SCOPE_CHECKING): Rename from DEBUG_BINDING_LEVELS.\n        (binding_depth): Unconditionally define.\n        (is_class_level): Likewise.\n        (indent): Likewise.  Take an indenting parameter.\n        (push_binding_level): Remove conditional definittion.\n        (pop_binding_level): Likewise.\n        (suspend_binding_level): Likewise.\n        (resume_binding_level): Likewise.\n        (pushlevel): Likewise.\n        (pushlevel_class): Likewise.\n        (poplevel_class): Likewise.\n        (pop_everything): Likewise.\n\nFrom-SVN: r67226", "tree": {"sha": "500f2d4ef0a681c82b21570f053a436e87e0ebda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500f2d4ef0a681c82b21570f053a436e87e0ebda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "833e1a77244310aad1be0a548c871705de725edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833e1a77244310aad1be0a548c871705de725edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833e1a77244310aad1be0a548c871705de725edc"}], "stats": {"total": 161, "additions": 84, "deletions": 77}, "files": [{"sha": "3071e2b567bf397cdfd6ffc15e04d007d0ee8ccf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2", "patch": "@@ -1,3 +1,18 @@\n+2003-05-29  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* decl.c (ENABLE_SCOPE_CHECKING): Rename from DEBUG_BINDING_LEVELS.\n+\t(binding_depth): Unconditionally define.\n+\t(is_class_level): Likewise.\n+\t(indent): Likewise.  Take an indenting parameter.\n+\t(push_binding_level): Remove conditional definittion. \n+\t(pop_binding_level): Likewise.\n+\t(suspend_binding_level): Likewise.\n+\t(resume_binding_level): Likewise.\n+\t(pushlevel): Likewise.\n+\t(pushlevel_class): Likewise.\n+\t(poplevel_class): Likewise.\n+\t(pop_everything): Likewise.\n+\n 2003-05-27  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* name-lookup.h (global_scope_p): New macro."}, {"sha": "ec302aef1b2d8a15dc9e247eddad1b83db7b1bfa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 69, "deletions": 77, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f37e2274d0e63bf9b4e499721e8ece99f4bcd6d2", "patch": "@@ -148,10 +148,6 @@ static tree next_initializable_field (tree);\n static tree reshape_init (tree, tree *);\n static tree build_typename_type (tree, tree, tree);\n \n-#if defined (DEBUG_BINDING_LEVELS)\n-static void indent (void);\n-#endif\n-\n /* Erroneous argument lists can use this *IFF* they do not modify it.  */\n tree error_mark_list;\n \n@@ -448,19 +444,23 @@ static int keep_next_level_flag;\n \n static GTY(()) tree incomplete_vars;\n \n-#if defined(DEBUG_BINDING_LEVELS)\n+#ifndef ENABLE_SCOPE_CHECKING\n+#  define ENABLE_SCOPE_CHECKING 0\n+#else\n+#  define ENABLE_SCOPE_CHECKING 1\n+#endif\n+\n static int binding_depth = 0;\n static int is_class_level = 0;\n \n static void\n-indent (void)\n+indent (int depth)\n {\n-  register unsigned i;\n+  int i;\n \n-  for (i = 0; i < binding_depth*2; i++)\n+  for (i = 0; i < depth * 2; i++)\n     putc (' ', stderr);\n }\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n \n static tree pushdecl_with_scope\t(tree, struct cp_binding_level *);\n \n@@ -478,14 +478,16 @@ push_binding_level (struct cp_binding_level *newlevel,\n   newlevel->more_cleanups_ok = 1;\n \n   newlevel->keep = keep;\n-#if defined(DEBUG_BINDING_LEVELS)\n-  newlevel->binding_depth = binding_depth;\n-  indent ();\n-  fprintf (stderr, \"push %s level 0x%08x line %d\\n\",\n-\t   (is_class_level) ? \"class\" : \"block\", newlevel, input_line);\n-  is_class_level = 0;\n-  binding_depth++;\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      newlevel->binding_depth = binding_depth;\n+      indent (binding_depth);\n+      verbatim (\"push %s level %p line %d\\n\",\n+                (is_class_level) ? \"class\" : \"block\",\n+                (void *) newlevel, input_line);\n+      is_class_level = 0;\n+      binding_depth++;\n+    }\n }\n \n /* Find the innermost enclosing class scope, and reset\n@@ -511,19 +513,20 @@ pop_binding_level (void)\n     /* Cannot pop a level, if there are none left to pop.  */\n     my_friendly_assert (!global_scope_p (current_binding_level), 20030527);\n   /* Pop the current level, and free the structure for reuse.  */\n-#if defined(DEBUG_BINDING_LEVELS)\n-  binding_depth--;\n-  indent ();\n-  fprintf (stderr, \"pop  %s level 0x%08x line %d\\n\",\n-\t  (is_class_level) ? \"class\" : \"block\",\n-\t  current_binding_level, input_line);\n-  if (is_class_level != (current_binding_level == class_binding_level))\n-    {\n-      indent ();\n-      fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n-    }\n-  is_class_level = 0;\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      indent (--binding_depth);\n+      verbatim (\"pop  %s level %p line %d\\n\",\n+                (is_class_level) ? \"class\" : \"block\",\n+                (void*) current_binding_level, input_line);\n+      if (is_class_level != (current_binding_level == class_binding_level))\n+        {\n+          indent (binding_depth);\n+          verbatim (\"XXX is_class_level != (current_binding_level \"\n+                    \"== class_binding_level)\\n\");\n+        }\n+      is_class_level = 0;\n+    }\n   {\n     register struct cp_binding_level *level = current_binding_level;\n     current_binding_level = current_binding_level->level_chain;\n@@ -532,10 +535,9 @@ pop_binding_level (void)\n       level->type_decls = NULL;\n     else\n       binding_table_free (level->type_decls);\n-#if 0 /* defined(DEBUG_BINDING_LEVELS) */\n-    if (level->binding_depth != binding_depth)\n-      abort ();\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+    my_friendly_assert (!ENABLE_SCOPE_CHECKING\n+                        || level->binding_depth == binding_depth,\n+                        20030529);\n     free_binding_level = level;\n     find_class_binding_level ();\n   }\n@@ -551,19 +553,20 @@ suspend_binding_level (void)\n     /* Cannot suspend a level, if there are none left to suspend.  */\n     my_friendly_assert (!global_scope_p (current_binding_level), 20030527);\n   /* Suspend the current level.  */\n-#if defined(DEBUG_BINDING_LEVELS)\n-  binding_depth--;\n-  indent ();\n-  fprintf (stderr, \"suspend  %s level 0x%08x line %d\\n\",\n-\t  (is_class_level) ? \"class\" : \"block\",\n-\t  current_binding_level, input_line);\n-  if (is_class_level != (current_binding_level == class_binding_level))\n-    {\n-      indent ();\n-      fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n-    }\n-  is_class_level = 0;\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      indent (--binding_depth);\n+      verbatim (\"suspend  %s level %p line %d\\n\",\n+                (is_class_level) ? \"class\" : \"block\",\n+                (void *) current_binding_level, input_line);\n+      if (is_class_level != (current_binding_level == class_binding_level))\n+        {\n+          indent (binding_depth);\n+          verbatim (\"XXX is_class_level != (current_binding_level \"\n+                    \"== class_binding_level)\\n\");\n+        }\n+      is_class_level = 0;\n+    }\n   current_binding_level = current_binding_level->level_chain;\n   find_class_binding_level ();\n }\n@@ -577,14 +580,15 @@ resume_binding_level (struct cp_binding_level* b)\n   /* Also, resuming a non-directly nested namespace is a no-no.  */\n   my_friendly_assert(b->level_chain == current_binding_level, 386);\n   current_binding_level = b;\n-#if defined(DEBUG_BINDING_LEVELS)\n-  b->binding_depth = binding_depth;\n-  indent ();\n-  fprintf (stderr, \"resume %s level 0x%08x line %d\\n\",\n-\t   (is_class_level) ? \"class\" : \"block\", b, input_line);\n-  is_class_level = 0;\n-  binding_depth++;\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      b->binding_depth = binding_depth;\n+      indent (binding_depth);\n+      verbatim (\"resume %s level %p line %d\\n\",\n+                (is_class_level) ? \"class\" : \"block\", b, input_line);\n+      is_class_level = 0;\n+      binding_depth++;\n+    }\n }\n \f\n /* Create a new `struct cp_binding_level'.  */\n@@ -789,11 +793,7 @@ pushlevel (int tag_transparent)\n     return;\n \n   /* Reuse or create a struct for this binding level.  */\n-#if defined(DEBUG_BINDING_LEVELS)\n-  if (0)\n-#else /* !defined(DEBUG_BINDING_LEVELS) */\n-  if (free_binding_level)\n-#endif /* !defined(DEBUG_BINDING_LEVELS) */\n+  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n     {\n       newlevel = free_binding_level;\n       free_binding_level = free_binding_level->level_chain;\n@@ -1553,21 +1553,16 @@ pushlevel_class (void)\n   register struct cp_binding_level *newlevel;\n \n   /* Reuse or create a struct for this binding level.  */\n-#if defined(DEBUG_BINDING_LEVELS)\n-  if (0)\n-#else /* !defined(DEBUG_BINDING_LEVELS) */\n-  if (free_binding_level)\n-#endif /* !defined(DEBUG_BINDING_LEVELS) */\n+  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n     {\n       newlevel = free_binding_level;\n       free_binding_level = free_binding_level->level_chain;\n     }\n   else\n     newlevel = make_binding_level ();\n \n-#if defined(DEBUG_BINDING_LEVELS)\n-  is_class_level = 1;\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+  if (ENABLE_SCOPE_CHECKING)\n+    is_class_level = 1;\n \n   push_binding_level (newlevel, 0, 0);\n \n@@ -1644,9 +1639,8 @@ poplevel_class (void)\n \n   /* Now, pop out of the binding level which we created up in the\n      `pushlevel_class' routine.  */\n-#if defined(DEBUG_BINDING_LEVELS)\n-  is_class_level = 1;\n-#endif /* defined(DEBUG_BINDING_LEVELS) */\n+  if (ENABLE_SCOPE_CHECKING)\n+    is_class_level = 1;\n \n   pop_binding_level ();\n   timevar_pop (TV_NAME_LOOKUP);\n@@ -2361,19 +2355,17 @@ identifier_type_value (tree id)\n void\n pop_everything (void)\n {\n-#ifdef DEBUG_BINDING_LEVELS\n-  fprintf (stderr, \"XXX entering pop_everything ()\\n\");\n-#endif\n+  if (ENABLE_SCOPE_CHECKING)\n+    verbatim (\"XXX entering pop_everything ()\\n\");\n   while (!toplevel_bindings_p ())\n     {\n       if (current_binding_level->parm_flag == 2)\n \tpop_nested_class ();\n       else\n \tpoplevel (0, 0, 0);\n     }\n-#ifdef DEBUG_BINDING_LEVELS\n-  fprintf (stderr, \"XXX leaving pop_everything ()\\n\");\n-#endif\n+  if (ENABLE_SCOPE_CHECKING)\n+    verbatim (\"XXX leaving pop_everything ()\\n\");\n }\n \n /* The type TYPE is being declared.  If it is a class template, or a"}]}