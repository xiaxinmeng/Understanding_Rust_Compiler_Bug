{"sha": "7d594224c2375ae5b067b727a46c42b6ddc86de2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q1OTQyMjRjMjM3NWFlNWIwNjdiNzI3YTQ2YzQyYjZkZGM4NmRlMg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2017-06-16T05:28:06Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2017-06-16T05:28:06Z"}, "message": "stl_bvector.h (__fill_bvector(_Bit_type*, unsigned int, unsigned int, bool)): Change signature.\n\n2017-06-16  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/stl_bvector.h\n\t(__fill_bvector(_Bit_type*, unsigned int, unsigned int, bool)):\n\tChange signature.\n\t(std::fill(_Bit_iterator, _Bit_iterator, bool)): Adapt.\n\t(_Bvector_impl_data): New.\n\t(_Bvector_impl): Inherits from latter.\n\t(_Bvector_impl(_Bit_alloc_type&&)): Delete.\n\t(_Bvector_impl(_Bvector_impl&&)): New, default.\n\t(_Bvector_base()): Default.\n\t(_Bvector_base(_Bvector_base&&)): Default.\n\t(_Bvector_base::_M_move_data(_Bvector_base&&)): New.\n\t(vector(vector&&, const allocator_type&)): Use latter.\n\t(vector<bool>::operator=(vector&&)): Likewise.\n\t(vector<bool>::vector()): Default.\n\t(vector<bool>::vector(vector&&)): Default.\n\t(vector<bool>::assign(_InputIterator, _InputIterator)): Use\n\t_M_assign_aux.\n\t(vector<bool>::assign(initializer_list<bool>)): Likewise.\n\t(vector<bool>::_M_initialize_value(bool)): New.\n\t(vector<bool>(size_type, const bool&, const allocator_type&)): Use\n\tlatter.\n\t(vector<bool>::_M_initialize_dispatch(_Integer, _Integer, __true_type)):\n\tLikewise.\n\t(vector<bool>::_M_fill_assign(size_t, bool)): Likewise.\n\nFrom-SVN: r249235", "tree": {"sha": "af07ad64ae83538f1b670d7c34f9d562689886cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af07ad64ae83538f1b670d7c34f9d562689886cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d594224c2375ae5b067b727a46c42b6ddc86de2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d594224c2375ae5b067b727a46c42b6ddc86de2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d594224c2375ae5b067b727a46c42b6ddc86de2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d594224c2375ae5b067b727a46c42b6ddc86de2/comments", "author": null, "committer": null, "parents": [{"sha": "c3684b7b86da9b6b01f6fb274227fc6401df053e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3684b7b86da9b6b01f6fb274227fc6401df053e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3684b7b86da9b6b01f6fb274227fc6401df053e"}], "stats": {"total": 1358, "additions": 741, "deletions": 617}, "files": [{"sha": "26b3075143d224929f8b0ed4669fd16e96eba88e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d594224c2375ae5b067b727a46c42b6ddc86de2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d594224c2375ae5b067b727a46c42b6ddc86de2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7d594224c2375ae5b067b727a46c42b6ddc86de2", "patch": "@@ -1,3 +1,30 @@\n+2017-06-16  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_bvector.h\n+\t(__fill_bvector(_Bit_type*, unsigned int, unsigned int, bool)):\n+\tChange signature.\n+\t(std::fill(_Bit_iterator, _Bit_iterator, bool)): Adapt.\n+\t(_Bvector_impl_data): New.\n+\t(_Bvector_impl): Inherits from latter.\n+\t(_Bvector_impl(_Bit_alloc_type&&)): Delete.\n+\t(_Bvector_impl(_Bvector_impl&&)): New, default.\n+\t(_Bvector_base()): Default.\n+\t(_Bvector_base(_Bvector_base&&)): Default.\n+\t(_Bvector_base::_M_move_data(_Bvector_base&&)): New.\n+\t(vector(vector&&, const allocator_type&)): Use latter.\n+\t(vector<bool>::operator=(vector&&)): Likewise.\n+\t(vector<bool>::vector()): Default.\n+\t(vector<bool>::vector(vector&&)): Default.\n+\t(vector<bool>::assign(_InputIterator, _InputIterator)): Use\n+\t_M_assign_aux.\n+\t(vector<bool>::assign(initializer_list<bool>)): Likewise.\n+\t(vector<bool>::_M_initialize_value(bool)): New.\n+\t(vector<bool>(size_type, const bool&, const allocator_type&)): Use\n+\tlatter.\n+\t(vector<bool>::_M_initialize_dispatch(_Integer, _Integer, __true_type)):\n+\tLikewise.\n+\t(vector<bool>::_M_fill_assign(size_t, bool)): Likewise.\n+\n 2017-06-15  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* src/c++98/tree.cc  [!_GLIBCXX_INLINE_VERSION]"}, {"sha": "c9433d4f80f25159c1635ea14816a989f6865a0a", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 647, "deletions": 617, "changes": 1264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d594224c2375ae5b067b727a46c42b6ddc86de2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d594224c2375ae5b067b727a46c42b6ddc86de2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=7d594224c2375ae5b067b727a46c42b6ddc86de2", "patch": "@@ -184,7 +184,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator<(const _Bit_iterator_base& __i) const\n     {\n       return _M_p < __i._M_p\n-\t     || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n+\t    || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n     }\n \n     bool\n@@ -388,23 +388,36 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   { return __x + __n; }\n \n   inline void\n-  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)\n+  __fill_bvector(_Bit_type * __v,\n+\t\t unsigned int __first, unsigned int __last, bool __x)\n   {\n-    for (; __first != __last; ++__first)\n-      *__first = __x;\n+    const _Bit_type __fmask = ~0ul << __first;\n+    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);\n+    const _Bit_type __mask = __fmask & __lmask;\n+\n+    if (__x)\n+      *__v |= __mask;\n+    else\n+      *__v &= ~__mask;\n   }\n \n   inline void\n   fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)\n   {\n     if (__first._M_p != __last._M_p)\n       {\n-\tstd::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);\n-\t__fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);\n-\t__fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);\n+\t_Bit_type *__first_p = __first._M_p;\n+\tif (__first._M_offset != 0)\n+\t  __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);\n+\n+\t__builtin_memset(__first_p, __x ? ~0 : 0,\n+\t\t\t (__last._M_p - __first_p) * sizeof(_Bit_type));\n+\n+\tif (__last._M_offset != 0)\n+\t  __fill_bvector(__last._M_p, 0, __last._M_offset, __x);\n       }\n     else\n-      __fill_bvector(__first, __last, __x);\n+      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);\n   }\n \n   template<typename _Alloc>\n@@ -416,33 +429,62 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t_Bit_alloc_traits;\n       typedef typename _Bit_alloc_traits::pointer _Bit_pointer;\n \n-      struct _Bvector_impl\n-      : public _Bit_alloc_type\n+      struct _Bvector_impl_data\n       {\n \t_Bit_iterator \t_M_start;\n \t_Bit_iterator \t_M_finish;\n \t_Bit_pointer \t_M_end_of_storage;\n \n-\t_Bvector_impl()\n-\t: _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n-\t{ }\n- \n-\t_Bvector_impl(const _Bit_alloc_type& __a)\n-\t: _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()\n+\t_Bvector_impl_data() _GLIBCXX_NOEXCEPT\n+\t: _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n \n #if __cplusplus >= 201103L\n-\t_Bvector_impl(_Bit_alloc_type&& __a)\n-\t: _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),\n-\t  _M_end_of_storage()\n-\t{ }\n+\t_Bvector_impl_data(_Bvector_impl_data&& __x) noexcept\n+\t: _M_start(__x._M_start), _M_finish(__x._M_finish)\n+\t, _M_end_of_storage(__x._M_end_of_storage)\n+\t{ __x._M_reset(); }\n+\n+\tvoid\n+\t_M_move_data(_Bvector_impl_data&& __x) noexcept\n+\t{\n+\t  this->_M_start = __x._M_start;\n+\t  this->_M_finish = __x._M_finish;\n+\t  this->_M_end_of_storage = __x._M_end_of_storage;\n+\t  __x._M_reset();\n+\t}\n+#endif\n+\n+\tvoid\n+\t_M_reset() _GLIBCXX_NOEXCEPT\n+\t{\n+\t  _M_start = _M_finish = _Bit_iterator();\n+\t  _M_end_of_storage = _Bit_pointer();\n+\t}\n+      };\n+\n+      struct _Bvector_impl\n+\t: public _Bit_alloc_type, public _Bvector_impl_data\n+\t{\n+\tpublic:\n+\t  _Bvector_impl()\n+\t    _GLIBCXX_NOEXCEPT_IF( noexcept(_Bit_alloc_type()) )\n+\t  : _Bit_alloc_type()\n+\t  { }\n+\n+\t  _Bvector_impl(const _Bit_alloc_type& __a) _GLIBCXX_NOEXCEPT\n+\t  : _Bit_alloc_type(__a)\n+\t  { }\n+\n+#if __cplusplus >= 201103L\n+\t_Bvector_impl(_Bvector_impl&&) = default;\n #endif\n \n \t_Bit_type*\n \t_M_end_addr() const _GLIBCXX_NOEXCEPT\n \t{\n-\t  if (_M_end_of_storage)\n-\t    return std::__addressof(_M_end_of_storage[-1]) + 1;\n+\t  if (this->_M_end_of_storage)\n+\t    return std::__addressof(this->_M_end_of_storage[-1]) + 1;\n \t  return 0;\n \t}\n       };\n@@ -452,33 +494,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       _Bit_alloc_type&\n       _M_get_Bit_allocator() _GLIBCXX_NOEXCEPT\n-      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }\n+      { return this->_M_impl; }\n \n       const _Bit_alloc_type&\n       _M_get_Bit_allocator() const _GLIBCXX_NOEXCEPT\n-      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }\n+      { return this->_M_impl; }\n \n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_get_Bit_allocator()); }\n \n-      _Bvector_base()\n-      : _M_impl() { }\n+#if __cplusplus >= 201103L\n+      _Bvector_base() = default;\n+#else\n+      _Bvector_base() { }\n+#endif\n       \n       _Bvector_base(const allocator_type& __a)\n       : _M_impl(__a) { }\n \n #if __cplusplus >= 201103L\n-      _Bvector_base(_Bvector_base&& __x) noexcept\n-      : _M_impl(std::move(__x._M_get_Bit_allocator()))\n-      {\n-\tthis->_M_impl._M_start = __x._M_impl._M_start;\n-\tthis->_M_impl._M_finish = __x._M_impl._M_finish;\n-\tthis->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n-\t__x._M_impl._M_start = _Bit_iterator();\n-\t__x._M_impl._M_finish = _Bit_iterator();\n-\t__x._M_impl._M_end_of_storage = nullptr;\n-      }\n+      _Bvector_base(_Bvector_base&&) = default;\n #endif\n \n       ~_Bvector_base()\n@@ -500,11 +536,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    _Bit_alloc_traits::deallocate(_M_impl,\n \t\t\t\t\t  _M_impl._M_end_of_storage - __n,\n \t\t\t\t\t  __n);\n-\t    _M_impl._M_start = _M_impl._M_finish = _Bit_iterator();\n-\t    _M_impl._M_end_of_storage = _Bit_pointer();\n+\t    _M_impl._M_reset();\n \t  }\n       }\n \n+#if __cplusplus >= 201103L\n+      void\n+      _M_move_data(_Bvector_base&& __x) noexcept\n+      { _M_impl._M_move_data(std::move(__x._M_impl)); }\n+#endif\n+\n       static size_t\n       _S_nword(size_t __n)\n       { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }\n@@ -539,738 +580,727 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  memory and size allocation.  Subscripting ( @c [] ) access is\n    *  also provided as with C-style arrays.\n   */\n-template<typename _Alloc>\n-  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>\n-  {\n-    typedef _Bvector_base<_Alloc>\t\t\t _Base;\n-    typedef typename _Base::_Bit_pointer\t\t _Bit_pointer;\n-    typedef typename _Base::_Bit_alloc_traits\t\t _Bit_alloc_traits;\n+  template<typename _Alloc>\n+    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>\n+    {\n+      typedef _Bvector_base<_Alloc>\t\t\t_Base;\n+      typedef typename _Base::_Bit_pointer\t\t_Bit_pointer;\n+      typedef typename _Base::_Bit_alloc_traits\t\t_Bit_alloc_traits;\n \n #if __cplusplus >= 201103L\n-    template<typename> friend struct hash;\n+      template<typename> friend struct hash;\n #endif\n \n-  public:\n-    typedef bool                                         value_type;\n-    typedef size_t                                       size_type;\n-    typedef ptrdiff_t                                    difference_type;\n-    typedef _Bit_reference                               reference;\n-    typedef bool                                         const_reference;\n-    typedef _Bit_reference*                              pointer;\n-    typedef const bool*                                  const_pointer;\n-    typedef _Bit_iterator                                iterator;\n-    typedef _Bit_const_iterator                          const_iterator;\n-    typedef std::reverse_iterator<const_iterator>        const_reverse_iterator;\n-    typedef std::reverse_iterator<iterator>              reverse_iterator;\n-    typedef _Alloc                        \t\t allocator_type;\n-\n-    allocator_type get_allocator() const\n-    { return _Base::get_allocator(); }\n-\n-  protected:\n-    using _Base::_M_allocate;\n-    using _Base::_M_deallocate;\n-    using _Base::_S_nword;\n-    using _Base::_M_get_Bit_allocator;\n-\n-  public:\n-    vector()\n-#if __cplusplus >= 201103L\n-      noexcept(is_nothrow_default_constructible<allocator_type>::value)\n-#endif\n-    : _Base() { }\n+    public:\n+      typedef bool\t\t\t\t\tvalue_type;\n+      typedef size_t\t\t\t\t\tsize_type;\n+      typedef ptrdiff_t\t\t\t\t\tdifference_type;\n+      typedef _Bit_reference\t\t\t\treference;\n+      typedef bool\t\t\t\t\tconst_reference;\n+      typedef _Bit_reference*\t\t\t\tpointer;\n+      typedef const bool*\t\t\t\tconst_pointer;\n+      typedef _Bit_iterator\t\t\t\titerator;\n+      typedef _Bit_const_iterator\t\t\tconst_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef _Alloc\t\t\t\t\tallocator_type;\n \n-    explicit\n-    vector(const allocator_type& __a)\n-    : _Base(__a) { }\n+      allocator_type\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n+\n+    protected:\n+      using _Base::_M_allocate;\n+      using _Base::_M_deallocate;\n+      using _Base::_S_nword;\n+      using _Base::_M_get_Bit_allocator;\n \n+    public:\n #if __cplusplus >= 201103L\n-    explicit\n-    vector(size_type __n, const allocator_type& __a = allocator_type())\n-    : vector(__n, false, __a)\n-    { }\n-\n-    vector(size_type __n, const bool& __value, \n-\t   const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    {\n-      _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),\n-\t\t__value ? ~0 : 0);\n-    }\n+      vector() = default;\n #else\n-    explicit\n-    vector(size_type __n, const bool& __value = bool(), \n-\t   const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    {\n-      _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),\n-\t\t__value ? ~0 : 0);\n-    }\n+      vector() { }\n #endif\n \n-    vector(const vector& __x)\n-    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))\n-    {\n-      _M_initialize(__x.size());\n-      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n-    }\n+      explicit\n+      vector(const allocator_type& __a)\n+      : _Base(__a) { }\n \n #if __cplusplus >= 201103L\n-    vector(vector&& __x) noexcept\n-    : _Base(std::move(__x)) { }\n-\n-    vector(vector&& __x, const allocator_type& __a)\n-    noexcept(_Bit_alloc_traits::_S_always_equal())\n-    : _Base(__a)\n-    {\n-      if (__x.get_allocator() == __a)\n-\t{\n-\t  this->_M_impl._M_start = __x._M_impl._M_start;\n-\t  this->_M_impl._M_finish = __x._M_impl._M_finish;\n-\t  this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n-\t  __x._M_impl._M_start = _Bit_iterator();\n-\t  __x._M_impl._M_finish = _Bit_iterator();\n-\t  __x._M_impl._M_end_of_storage = nullptr;\n-\t}\n-      else\n-\t{\n-\t  _M_initialize(__x.size());\n-\t  _M_copy_aligned(__x.begin(), __x.end(), begin());\n-\t  __x.clear();\n-\t}\n-    }\n-\n-    vector(const vector& __x, const allocator_type& __a)\n-    : _Base(__a)\n-    {\n-      _M_initialize(__x.size());\n-      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n-    }\n+      explicit\n+      vector(size_type __n, const allocator_type& __a = allocator_type())\n+      : vector(__n, false, __a)\n+      { }\n \n-    vector(initializer_list<bool> __l,\n-\t   const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    {\n-      _M_initialize_range(__l.begin(), __l.end(),\n-\t\t\t  random_access_iterator_tag());\n-    }\n+      vector(size_type __n, const bool& __value, \n+\t     const allocator_type& __a = allocator_type())\n+#else\n+      explicit\n+      vector(size_type __n, const bool& __value = bool(), \n+\t     const allocator_type& __a = allocator_type())\n #endif\n+      : _Base(__a)\n+      {\n+\t_M_initialize(__n);\n+\t_M_initialize_value(__value);\n+      }\n+\n+      vector(const vector& __x)\n+      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))\n+      {\n+\t_M_initialize(__x.size());\n+\t_M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n+      }\n \n #if __cplusplus >= 201103L\n-    template<typename _InputIterator,\n-\t     typename = std::_RequireInputIter<_InputIterator>>\n-      vector(_InputIterator __first, _InputIterator __last,\n-\t     const allocator_type& __a = allocator_type())\n+      vector(vector&&) = default;\n+\n+      vector(vector&& __x, const allocator_type& __a)\n+      noexcept(_Bit_alloc_traits::_S_always_equal())\n       : _Base(__a)\n-      { _M_initialize_dispatch(__first, __last, __false_type()); }\n-#else\n-    template<typename _InputIterator>\n-      vector(_InputIterator __first, _InputIterator __last,\n+      {\n+\tif (__x.get_allocator() == __a)\n+\t  this->_M_move_data(std::move(__x));\n+\telse\n+\t  {\n+\t    _M_initialize(__x.size());\n+\t    _M_copy_aligned(__x.begin(), __x.end(), begin());\n+\t    __x.clear();\n+\t  }\n+      }\n+\n+      vector(const vector& __x, const allocator_type& __a)\n+      : _Base(__a)\n+      {\n+\t_M_initialize(__x.size());\n+\t_M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n+      }\n+\n+      vector(initializer_list<bool> __l,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__a)\n       {\n-\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-\t_M_initialize_dispatch(__first, __last, _Integral());\n+\t_M_initialize_range(__l.begin(), __l.end(),\n+\t\t\t    random_access_iterator_tag());\n       }\n #endif\n \n-    ~vector() _GLIBCXX_NOEXCEPT { }\n-\n-    vector&\n-    operator=(const vector& __x)\n-    {\n-      if (&__x == this)\n-\treturn *this;\n #if __cplusplus >= 201103L\n-      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())\n+      template<typename _InputIterator,\n+\t       typename = std::_RequireInputIter<_InputIterator>>\n+\tvector(_InputIterator __first, _InputIterator __last,\n+\t       const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n+\t{ _M_initialize_dispatch(__first, __last, __false_type()); }\n+#else\n+      template<typename _InputIterator>\n+\tvector(_InputIterator __first, _InputIterator __last,\n+\t       const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n \t{\n-\t  if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())\n-\t    {\n-\t      this->_M_deallocate();\n+\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+\t  _M_initialize_dispatch(__first, __last, _Integral());\n+\t}\n+#endif\n+\n+      ~vector() _GLIBCXX_NOEXCEPT { }\n+\n+      vector&\n+      operator=(const vector& __x)\n+      {\n+\tif (&__x == this)\n+\t  return *this;\n+#if __cplusplus >= 201103L\n+\tif (_Bit_alloc_traits::_S_propagate_on_copy_assign())\n+\t  {\n+\t    if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())\n+\t      {\n+\t\tthis->_M_deallocate();\n+\t\tstd::__alloc_on_copy(_M_get_Bit_allocator(),\n+\t\t\t\t     __x._M_get_Bit_allocator());\n+\t\t_M_initialize(__x.size());\n+\t      }\n+\t    else\n \t      std::__alloc_on_copy(_M_get_Bit_allocator(),\n \t\t\t\t   __x._M_get_Bit_allocator());\n-\t      _M_initialize(__x.size());\n-\t    }\n-\t  else\n-\t    std::__alloc_on_copy(_M_get_Bit_allocator(),\n-\t\t\t\t __x._M_get_Bit_allocator());\n-\t}\n+\t  }\n #endif\n-      if (__x.size() > capacity())\n-\t{\n-\t  this->_M_deallocate();\n-\t  _M_initialize(__x.size());\n-\t}\n-      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),\n-\t\t\t\t\t\tbegin());\n-      return *this;\n-    }\n+\tif (__x.size() > capacity())\n+\t  {\n+\t    this->_M_deallocate();\n+\t    _M_initialize(__x.size());\n+\t  }\n+\tthis->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),\n+\t\t\t\t\t\t  begin());\n+\treturn *this;\n+      }\n \n #if __cplusplus >= 201103L\n-    vector&\n-    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())\n-    {\n-      if (_Bit_alloc_traits::_S_propagate_on_move_assign()\n-\t  || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())\n-\t{\n-\t  this->_M_deallocate();\n-\t  this->_M_impl._M_start = __x._M_impl._M_start;\n-\t  this->_M_impl._M_finish = __x._M_impl._M_finish;\n-\t  this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n-\t  __x._M_impl._M_start = _Bit_iterator();\n-\t  __x._M_impl._M_finish = _Bit_iterator();\n-\t  __x._M_impl._M_end_of_storage = nullptr;\n-\t  std::__alloc_on_move(_M_get_Bit_allocator(),\n-\t\t\t       __x._M_get_Bit_allocator());\n-\t}\n-      else\n-\t{\n-\t  if (__x.size() > capacity())\n-\t    {\n-\t      this->_M_deallocate();\n-\t      _M_initialize(__x.size());\n-\t    }\n-\t  this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),\n-\t\t\t\t\t\t    begin());\n-\t  __x.clear();\n-\t}\n-      return *this;\n-    }\n+      vector&\n+      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())\n+      {\n+\tif (_Bit_alloc_traits::_S_propagate_on_move_assign()\n+\t    || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())\n+\t  {\n+\t    this->_M_deallocate();\n+\t    this->_M_move_data(std::move(__x));\n+\t    std::__alloc_on_move(_M_get_Bit_allocator(),\n+\t\t\t\t __x._M_get_Bit_allocator());\n+\t  }\n+\telse\n+\t  {\n+\t    if (__x.size() > capacity())\n+\t      {\n+\t\tthis->_M_deallocate();\n+\t\t_M_initialize(__x.size());\n+\t      }\n+\t    this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),\n+\t\t\t\t\t\t      begin());\n+\t    __x.clear();\n+\t  }\n+\treturn *this;\n+      }\n \n-    vector&\n-    operator=(initializer_list<bool> __l)\n-    {\n-      this->assign (__l.begin(), __l.end());\n-      return *this;\n-    }\n+      vector&\n+      operator=(initializer_list<bool> __l)\n+      {\n+\tthis->assign (__l.begin(), __l.end());\n+\treturn *this;\n+      }\n #endif\n \n-    // assign(), a generalized assignment member function.  Two\n-    // versions: one that takes a count, and one that takes a range.\n-    // The range version is a member template, so we dispatch on whether\n-    // or not the type is an integer.\n-    void\n-    assign(size_type __n, const bool& __x)\n-    { _M_fill_assign(__n, __x); }\n+      // assign(), a generalized assignment member function.  Two\n+      // versions: one that takes a count, and one that takes a range.\n+      // The range version is a member template, so we dispatch on whether\n+      // or not the type is an integer.\n+      void\n+      assign(size_type __n, const bool& __x)\n+      { _M_fill_assign(__n, __x); }\n \n #if __cplusplus >= 201103L\n-    template<typename _InputIterator,\n-\t     typename = std::_RequireInputIter<_InputIterator>>\n-      void\n-      assign(_InputIterator __first, _InputIterator __last)\n-      { _M_assign_dispatch(__first, __last, __false_type()); }\n+      template<typename _InputIterator,\n+\t       typename = std::_RequireInputIter<_InputIterator>>\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n #else\n-    template<typename _InputIterator>\n-      void\n-      assign(_InputIterator __first, _InputIterator __last)\n-      {\n-\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-\t_M_assign_dispatch(__first, __last, _Integral());\n-      }\n+      template<typename _InputIterator>\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n+\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+\t  _M_assign_dispatch(__first, __last, _Integral());\n+\t}\n #endif\n \n #if __cplusplus >= 201103L\n-    void\n-    assign(initializer_list<bool> __l)\n-    { this->assign(__l.begin(), __l.end()); }\n+      void\n+      assign(initializer_list<bool> __l)\n+      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }\n #endif\n \n-    iterator\n-    begin() _GLIBCXX_NOEXCEPT\n-    { return this->_M_impl._M_start; }\n+      iterator\n+      begin() _GLIBCXX_NOEXCEPT\n+      { return this->_M_impl._M_start; }\n \n-    const_iterator\n-    begin() const _GLIBCXX_NOEXCEPT\n-    { return this->_M_impl._M_start; }\n+      const_iterator\n+      begin() const _GLIBCXX_NOEXCEPT\n+      { return this->_M_impl._M_start; }\n \n-    iterator\n-    end() _GLIBCXX_NOEXCEPT\n-    { return this->_M_impl._M_finish; }\n+      iterator\n+      end() _GLIBCXX_NOEXCEPT\n+      { return this->_M_impl._M_finish; }\n \n-    const_iterator\n-    end() const _GLIBCXX_NOEXCEPT\n-    { return this->_M_impl._M_finish; }\n+      const_iterator\n+      end() const _GLIBCXX_NOEXCEPT\n+      { return this->_M_impl._M_finish; }\n \n-    reverse_iterator\n-    rbegin() _GLIBCXX_NOEXCEPT\n-    { return reverse_iterator(end()); }\n+      reverse_iterator\n+      rbegin() _GLIBCXX_NOEXCEPT\n+      { return reverse_iterator(end()); }\n \n-    const_reverse_iterator\n-    rbegin() const _GLIBCXX_NOEXCEPT\n-    { return const_reverse_iterator(end()); }\n+      const_reverse_iterator\n+      rbegin() const _GLIBCXX_NOEXCEPT\n+      { return const_reverse_iterator(end()); }\n \n-    reverse_iterator\n-    rend() _GLIBCXX_NOEXCEPT\n-    { return reverse_iterator(begin()); }\n+      reverse_iterator\n+      rend() _GLIBCXX_NOEXCEPT\n+      { return reverse_iterator(begin()); }\n \n-    const_reverse_iterator\n-    rend() const _GLIBCXX_NOEXCEPT\n-    { return const_reverse_iterator(begin()); }\n+      const_reverse_iterator\n+      rend() const _GLIBCXX_NOEXCEPT\n+      { return const_reverse_iterator(begin()); }\n \n #if __cplusplus >= 201103L\n-    const_iterator\n-    cbegin() const noexcept\n-    { return this->_M_impl._M_start; }\n+      const_iterator\n+      cbegin() const noexcept\n+      { return this->_M_impl._M_start; }\n \n-    const_iterator\n-    cend() const noexcept\n-    { return this->_M_impl._M_finish; }\n+      const_iterator\n+      cend() const noexcept\n+      { return this->_M_impl._M_finish; }\n \n-    const_reverse_iterator\n-    crbegin() const noexcept\n-    { return const_reverse_iterator(end()); }\n+      const_reverse_iterator\n+      crbegin() const noexcept\n+      { return const_reverse_iterator(end()); }\n \n-    const_reverse_iterator\n-    crend() const noexcept\n-    { return const_reverse_iterator(begin()); }\n+      const_reverse_iterator\n+      crend() const noexcept\n+      { return const_reverse_iterator(begin()); }\n #endif\n \n-    size_type\n-    size() const _GLIBCXX_NOEXCEPT\n-    { return size_type(end() - begin()); }\n+      size_type\n+      size() const _GLIBCXX_NOEXCEPT\n+      { return size_type(end() - begin()); }\n \n-    size_type\n-    max_size() const _GLIBCXX_NOEXCEPT\n-    {\n-      const size_type __isize =\n-\t__gnu_cxx::__numeric_traits<difference_type>::__max\n-\t- int(_S_word_bit) + 1;\n-      const size_type __asize\n-\t= _Bit_alloc_traits::max_size(_M_get_Bit_allocator());\n-      return (__asize <= __isize / int(_S_word_bit)\n-\t      ? __asize * int(_S_word_bit) : __isize);\n-    }\n+      size_type\n+      max_size() const _GLIBCXX_NOEXCEPT\n+      {\n+\tconst size_type __isize =\n+\t  __gnu_cxx::__numeric_traits<difference_type>::__max\n+\t  - int(_S_word_bit) + 1;\n+\tconst size_type __asize\n+\t  = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());\n+\treturn (__asize <= __isize / int(_S_word_bit)\n+\t\t? __asize * int(_S_word_bit) : __isize);\n+      }\n \n-    size_type\n-    capacity() const _GLIBCXX_NOEXCEPT\n-    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)\n-\t\t       - begin()); }\n+      size_type\n+      capacity() const _GLIBCXX_NOEXCEPT\n+      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)\n+\t\t\t - begin()); }\n \n-    bool\n-    empty() const _GLIBCXX_NOEXCEPT\n-    { return begin() == end(); }\n+      bool\n+      empty() const _GLIBCXX_NOEXCEPT\n+      { return begin() == end(); }\n \n-    reference\n-    operator[](size_type __n)\n-    {\n-      return *iterator(this->_M_impl._M_start._M_p\n-\t\t       + __n / int(_S_word_bit), __n % int(_S_word_bit));\n-    }\n+      reference\n+      operator[](size_type __n)\n+      {\n+\treturn *iterator(this->_M_impl._M_start._M_p\n+\t\t\t + __n / int(_S_word_bit), __n % int(_S_word_bit));\n+      }\n \n-    const_reference\n-    operator[](size_type __n) const\n-    {\n-      return *const_iterator(this->_M_impl._M_start._M_p\n+      const_reference\n+      operator[](size_type __n) const\n+      {\n+\treturn *const_iterator(this->_M_impl._M_start._M_p\n \t\t\t     + __n / int(_S_word_bit), __n % int(_S_word_bit));\n-    }\n+      }\n \n-  protected:\n-    void\n-    _M_range_check(size_type __n) const\n-    {\n-      if (__n >= this->size())\n-\t__throw_out_of_range_fmt(__N(\"vector<bool>::_M_range_check: __n \"\n-\t\t\t\t     \"(which is %zu) >= this->size() \"\n-\t\t\t\t     \"(which is %zu)\"),\n-\t\t\t\t __n, this->size());\n-    }\n+    protected:\n+      void\n+      _M_range_check(size_type __n) const\n+      {\n+\tif (__n >= this->size())\n+\t  __throw_out_of_range_fmt(__N(\"vector<bool>::_M_range_check: __n \"\n+\t\t\t\t       \"(which is %zu) >= this->size() \"\n+\t\t\t\t       \"(which is %zu)\"),\n+\t\t\t\t   __n, this->size());\n+      }\n \n-  public:\n-    reference\n-    at(size_type __n)\n-    { _M_range_check(__n); return (*this)[__n]; }\n+    public:\n+      reference\n+      at(size_type __n)\n+      { _M_range_check(__n); return (*this)[__n]; }\n \n-    const_reference\n-    at(size_type __n) const\n-    { _M_range_check(__n); return (*this)[__n]; }\n+      const_reference\n+      at(size_type __n) const\n+      { _M_range_check(__n); return (*this)[__n]; }\n \n-    void\n-    reserve(size_type __n)\n-    {\n-      if (__n > max_size())\n-\t__throw_length_error(__N(\"vector::reserve\"));\n-      if (capacity() < __n)\n-\t_M_reallocate(__n);\n-    }\n+      void\n+      reserve(size_type __n)\n+      {\n+\tif (__n > max_size())\n+\t  __throw_length_error(__N(\"vector::reserve\"));\n+\tif (capacity() < __n)\n+\t  _M_reallocate(__n);\n+      }\n \n-    reference\n-    front()\n-    { return *begin(); }\n+      reference\n+      front()\n+      { return *begin(); }\n \n-    const_reference\n-    front() const\n-    { return *begin(); }\n+      const_reference\n+      front() const\n+      { return *begin(); }\n \n-    reference\n-    back()\n-    { return *(end() - 1); }\n+      reference\n+      back()\n+      { return *(end() - 1); }\n+\n+      const_reference\n+      back() const\n+      { return *(end() - 1); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 464. Suggestion for new member functions in standard containers.\n+      // N.B. DR 464 says nothing about vector<bool> but we need something\n+      // here due to the way we are implementing DR 464 in the debug-mode\n+      // vector class.\n+      void\n+      data() _GLIBCXX_NOEXCEPT { }\n \n-    const_reference\n-    back() const\n-    { return *(end() - 1); }\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // DR 464. Suggestion for new member functions in standard containers.\n-    // N.B. DR 464 says nothing about vector<bool> but we need something\n-    // here due to the way we are implementing DR 464 in the debug-mode\n-    // vector class.\n-    void\n-    data() _GLIBCXX_NOEXCEPT { }\n+      void\n+      push_back(bool __x)\n+      {\n+\tif (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n+\t  *this->_M_impl._M_finish++ = __x;\n+\telse\n+\t  _M_insert_aux(end(), __x);\n+      }\n \n-    void\n-    push_back(bool __x)\n-    {\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n-        *this->_M_impl._M_finish++ = __x;\n-      else\n-        _M_insert_aux(end(), __x);\n-    }\n+      void\n+      swap(vector& __x) _GLIBCXX_NOEXCEPT\n+      {\n+\tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n+\tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n+\tstd::swap(this->_M_impl._M_end_of_storage, \n+\t\t  __x._M_impl._M_end_of_storage);\n+\t_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),\n+\t\t\t\t      __x._M_get_Bit_allocator());\n+      }\n \n-    void\n-    swap(vector& __x) _GLIBCXX_NOEXCEPT\n-    {\n-      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n-      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n-      std::swap(this->_M_impl._M_end_of_storage, \n-\t\t__x._M_impl._M_end_of_storage);\n-      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),\n-\t\t\t\t    __x._M_get_Bit_allocator());\n-    }\n+      // [23.2.5]/1, third-to-last entry in synopsis listing\n+      static void\n+      swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT\n+      {\n+\tbool __tmp = __x;\n+\t__x = __y;\n+\t__y = __tmp;\n+      }\n \n-    // [23.2.5]/1, third-to-last entry in synopsis listing\n-    static void\n-    swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT\n-    {\n-      bool __tmp = __x;\n-      __x = __y;\n-      __y = __tmp;\n-    }\n+      iterator\n+#if __cplusplus >= 201103L\n+      insert(const_iterator __position, const bool& __x = bool())\n+#else\n+      insert(iterator __position, const bool& __x = bool())\n+#endif\n+      {\n+\tconst difference_type __n = __position - begin();\n+\tif (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()\n+\t    && __position == end())\n+\t  *this->_M_impl._M_finish++ = __x;\n+\telse\n+\t  _M_insert_aux(__position._M_const_cast(), __x);\n+\treturn begin() + __n;\n+      }\n \n-    iterator\n #if __cplusplus >= 201103L\n-    insert(const_iterator __position, const bool& __x = bool())\n+      template<typename _InputIterator,\n+\t       typename = std::_RequireInputIter<_InputIterator>>\n+\titerator\n+\tinsert(const_iterator __position,\n+\t       _InputIterator __first, _InputIterator __last)\n+\t{\n+\t  difference_type __offset = __position - cbegin();\n+\t  _M_insert_dispatch(__position._M_const_cast(),\n+\t\t\t     __first, __last, __false_type());\n+\t  return begin() + __offset;\n+\t}\n #else\n-    insert(iterator __position, const bool& __x = bool())\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(iterator __position,\n+\t       _InputIterator __first, _InputIterator __last)\n+\t{\n+\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+\t  _M_insert_dispatch(__position, __first, __last, _Integral());\n+\t}\n #endif\n-    {\n-      const difference_type __n = __position - begin();\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()\n-\t  && __position == end())\n-        *this->_M_impl._M_finish++ = __x;\n-      else\n-        _M_insert_aux(__position._M_const_cast(), __x);\n-      return begin() + __n;\n-    }\n \n #if __cplusplus >= 201103L\n-    template<typename _InputIterator,\n-\t     typename = std::_RequireInputIter<_InputIterator>>\n       iterator\n-      insert(const_iterator __position,\n-\t     _InputIterator __first, _InputIterator __last)\n+      insert(const_iterator __position, size_type __n, const bool& __x)\n       {\n \tdifference_type __offset = __position - cbegin();\n-\t_M_insert_dispatch(__position._M_const_cast(),\n-\t\t\t   __first, __last, __false_type());\n+\t_M_fill_insert(__position._M_const_cast(), __n, __x);\n \treturn begin() + __offset;\n       }\n #else\n-    template<typename _InputIterator>\n       void\n-      insert(iterator __position,\n-\t     _InputIterator __first, _InputIterator __last)\n-      {\n-\ttypedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-\t_M_insert_dispatch(__position, __first, __last, _Integral());\n-      }\n-#endif\n-\n-#if __cplusplus >= 201103L\n-    iterator\n-    insert(const_iterator __position, size_type __n, const bool& __x)\n-    {\n-      difference_type __offset = __position - cbegin();\n-      _M_fill_insert(__position._M_const_cast(), __n, __x);\n-      return begin() + __offset;\n-    }\n-#else\n-    void\n-    insert(iterator __position, size_type __n, const bool& __x)\n-    { _M_fill_insert(__position, __n, __x); }\n+      insert(iterator __position, size_type __n, const bool& __x)\n+      { _M_fill_insert(__position, __n, __x); }\n #endif\n \n #if __cplusplus >= 201103L\n-    iterator\n-    insert(const_iterator __p, initializer_list<bool> __l)\n-    { return this->insert(__p, __l.begin(), __l.end()); }\n+      iterator\n+      insert(const_iterator __p, initializer_list<bool> __l)\n+      { return this->insert(__p, __l.begin(), __l.end()); }\n #endif\n \n-    void\n-    pop_back()\n-    { --this->_M_impl._M_finish; }\n+      void\n+      pop_back()\n+      { --this->_M_impl._M_finish; }\n \n-    iterator\n+      iterator\n #if __cplusplus >= 201103L\n-    erase(const_iterator __position)\n+      erase(const_iterator __position)\n #else\n-    erase(iterator __position)\n+      erase(iterator __position)\n #endif\n-    { return _M_erase(__position._M_const_cast()); }\n+      { return _M_erase(__position._M_const_cast()); }\n \n-    iterator\n+      iterator\n #if __cplusplus >= 201103L\n-    erase(const_iterator __first, const_iterator __last)\n+      erase(const_iterator __first, const_iterator __last)\n #else\n-    erase(iterator __first, iterator __last)\n+      erase(iterator __first, iterator __last)\n #endif\n-    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }\n+      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }\n \n-    void\n-    resize(size_type __new_size, bool __x = bool())\n-    {\n-      if (__new_size < size())\n-        _M_erase_at_end(begin() + difference_type(__new_size));\n-      else\n-        insert(end(), __new_size - size(), __x);\n-    }\n+      void\n+      resize(size_type __new_size, bool __x = bool())\n+      {\n+\tif (__new_size < size())\n+\t  _M_erase_at_end(begin() + difference_type(__new_size));\n+\telse\n+\t  insert(end(), __new_size - size(), __x);\n+      }\n \n #if __cplusplus >= 201103L\n-    void\n-    shrink_to_fit()\n-    { _M_shrink_to_fit(); }\n+      void\n+      shrink_to_fit()\n+      { _M_shrink_to_fit(); }\n #endif\n \n-    void\n-    flip() _GLIBCXX_NOEXCEPT\n-    {\n-      _Bit_type * const __end = this->_M_impl._M_end_addr();\n-      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)\n-        *__p = ~*__p;\n-    }\n+      void\n+      flip() _GLIBCXX_NOEXCEPT\n+      {\n+\t_Bit_type * const __end = this->_M_impl._M_end_addr();\n+\tfor (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)\n+\t  *__p = ~*__p;\n+      }\n \n-    void\n-    clear() _GLIBCXX_NOEXCEPT\n-    { _M_erase_at_end(begin()); }\n+      void\n+      clear() _GLIBCXX_NOEXCEPT\n+      { _M_erase_at_end(begin()); }\n \n #if __cplusplus >= 201103L\n-    template<typename... _Args>\n+      template<typename... _Args>\n #if __cplusplus > 201402L\n-      reference\n+\treference\n #else\n-      void\n+\tvoid\n #endif\n-      emplace_back(_Args&&... __args)\n-      {\n-\tpush_back(bool(__args...));\n+\templace_back(_Args&&... __args)\n+\t{\n+\t  push_back(bool(__args...));\n #if __cplusplus > 201402L\n-\treturn back();\n-#endif\n-      }\n-\n-    template<typename... _Args>\n-      iterator\n-      emplace(const_iterator __pos, _Args&&... __args)\n-      { return insert(__pos, bool(__args...)); }\n+\t  return back();\n #endif\n-\n-  protected:\n-    // Precondition: __first._M_offset == 0 && __result._M_offset == 0.\n-    iterator\n-    _M_copy_aligned(const_iterator __first, const_iterator __last,\n-\t\t    iterator __result)\n-    {\n-      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);\n-      return std::copy(const_iterator(__last._M_p, 0), __last,\n-\t\t       iterator(__q, 0));\n-    }\n-\n-    void\n-    _M_initialize(size_type __n)\n-    {\n-      if (__n)\n-\t{\n-\t  _Bit_pointer __q = this->_M_allocate(__n);\n-\t  this->_M_impl._M_end_of_storage = __q + _S_nword(__n);\n-\t  this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);\n-\t}\n-      else\n-\t{\n-\t  this->_M_impl._M_end_of_storage = _Bit_pointer();\n-\t  this->_M_impl._M_start = iterator(0, 0);\n \t}\n-      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n-    }\n \n-    void\n-    _M_reallocate(size_type __n);\n-\n-#if __cplusplus >= 201103L\n-    bool\n-    _M_shrink_to_fit();\n+      template<typename... _Args>\n+\titerator\n+\templace(const_iterator __pos, _Args&&... __args)\n+\t{ return insert(__pos, bool(__args...)); }\n #endif\n \n-    // Check whether it's an integral type.  If so, it's not an iterator.\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 438. Ambiguity in the \"do the right thing\" clause\n-    template<typename _Integer>\n-      void\n-      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+    protected:\n+      // Precondition: __first._M_offset == 0 && __result._M_offset == 0.\n+      iterator\n+      _M_copy_aligned(const_iterator __first, const_iterator __last,\n+\t\t      iterator __result)\n       {\n-\t_M_initialize(static_cast<size_type>(__n));\n-\tstd::fill(this->_M_impl._M_start._M_p, \n-\t\t  this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n+\t_Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);\n+\treturn std::copy(const_iterator(__last._M_p, 0), __last,\n+\t\t\t iterator(__q, 0));\n       }\n \n-    template<typename _InputIterator>\n-      void \n-      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-\t\t\t     __false_type)\n-      { _M_initialize_range(__first, __last, \n-\t\t\t    std::__iterator_category(__first)); }\n-\n-    template<typename _InputIterator>\n       void\n-      _M_initialize_range(_InputIterator __first, _InputIterator __last,\n-\t\t\t  std::input_iterator_tag)\n+      _M_initialize(size_type __n)\n       {\n-\tfor (; __first != __last; ++__first)\n-\t  push_back(*__first);\n+\tif (__n)\n+\t  {\n+\t    _Bit_pointer __q = this->_M_allocate(__n);\n+\t    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);\n+\t    this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);\n+\t  }\n+\telse\n+\t  {\n+\t    this->_M_impl._M_end_of_storage = _Bit_pointer();\n+\t    this->_M_impl._M_start = iterator(0, 0);\n+\t  }\n+\tthis->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n+\n       }\n \n-    template<typename _ForwardIterator>\n       void\n-      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t\t  std::forward_iterator_tag)\n+      _M_initialize_value(bool __x)\n       {\n-\tconst size_type __n = std::distance(__first, __last);\n-\t_M_initialize(__n);\n-\tstd::copy(__first, __last, this->_M_impl._M_start);\n+\t__builtin_memset(this->_M_impl._M_start._M_p, __x ? ~0 : 0,\n+\t\t(this->_M_impl._M_end_addr() - this->_M_impl._M_start._M_p)\n+\t\t* sizeof(_Bit_type));\n       }\n \n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 438. Ambiguity in the \"do the right thing\" clause\n-    template<typename _Integer>\n       void\n-      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-      { _M_fill_assign(__n, __val); }\n+      _M_reallocate(size_type __n);\n \n-    template<class _InputIterator>\n-      void\n-      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-\t\t\t __false_type)\n-      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n+#if __cplusplus >= 201103L\n+      bool\n+      _M_shrink_to_fit();\n+#endif\n \n-    void\n-    _M_fill_assign(size_t __n, bool __x)\n-    {\n-      if (__n > size())\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 438. Ambiguity in the \"do the right thing\" clause\n+      template<typename _Integer>\n+\tvoid\n+\t_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n \t{\n-\t  std::fill(this->_M_impl._M_start._M_p, \n-\t\t    this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n-\t  insert(end(), __n - size(), __x);\n+\t  _M_initialize(static_cast<size_type>(__n));\n+\t  _M_initialize_value(__x);\n \t}\n-      else\n+\n+      template<typename _InputIterator>\n+\tvoid \n+\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t       __false_type)\n+\t{ _M_initialize_range(__first, __last, \n+\t\t\t      std::__iterator_category(__first)); }\n+\n+      template<typename _InputIterator>\n+\tvoid\n+\t_M_initialize_range(_InputIterator __first, _InputIterator __last,\n+\t\t\t    std::input_iterator_tag)\n \t{\n-\t  _M_erase_at_end(begin() + __n);\n-\t  std::fill(this->_M_impl._M_start._M_p, \n-\t\t    this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n+\t  for (; __first != __last; ++__first)\n+\t    push_back(*__first);\n \t}\n-    }\n \n-    template<typename _InputIterator>\n-      void\n-      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-\t\t    std::input_iterator_tag)\n-      {\n-\titerator __cur = begin();\n-\tfor (; __first != __last && __cur != end(); ++__cur, ++__first)\n-\t  *__cur = *__first;\n-\tif (__first == __last)\n-\t  _M_erase_at_end(__cur);\n-\telse\n-\t  insert(end(), __first, __last);\n-      }\n-    \n-    template<typename _ForwardIterator>\n+      template<typename _ForwardIterator>\n+\tvoid\n+\t_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\t    std::forward_iterator_tag)\n+\t{\n+\t  const size_type __n = std::distance(__first, __last);\n+\t  _M_initialize(__n);\n+\t  std::copy(__first, __last, this->_M_impl._M_start);\n+\t}\n+\n+#if __cplusplus < 201103L\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 438. Ambiguity in the \"do the right thing\" clause\n+      template<typename _Integer>\n+\tvoid\n+\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+\t{ _M_fill_assign(__n, __val); }\n+\n+      template<class _InputIterator>\n+\tvoid\n+\t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\t\t\t   __false_type)\n+\t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n+#endif\n+\n       void\n-      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t    std::forward_iterator_tag)\n+      _M_fill_assign(size_t __n, bool __x)\n       {\n-\tconst size_type __len = std::distance(__first, __last);\n-\tif (__len < size())\n-\t  _M_erase_at_end(std::copy(__first, __last, begin()));\n+\tif (__n > size())\n+\t  {\n+\t    _M_initialize_value(__x);\n+\t    insert(end(), __n - size(), __x);\n+\t  }\n \telse\n \t  {\n-\t    _ForwardIterator __mid = __first;\n-\t    std::advance(__mid, size());\n-\t    std::copy(__first, __mid, begin());\n-\t    insert(end(), __mid, __last);\n+\t    _M_erase_at_end(begin() + __n);\n+\t    _M_initialize_value(__x);\n \t  }\n       }\n \n-    // Check whether it's an integral type.  If so, it's not an iterator.\n+      template<typename _InputIterator>\n+\tvoid\n+\t_M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t      std::input_iterator_tag)\n+\t{\n+\t  iterator __cur = begin();\n+\t  for (; __first != __last && __cur != end(); ++__cur, ++__first)\n+\t    *__cur = *__first;\n+\t  if (__first == __last)\n+\t    _M_erase_at_end(__cur);\n+\t  else\n+\t    insert(end(), __first, __last);\n+\t}\n+    \n+      template<typename _ForwardIterator>\n+\tvoid\n+\t_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t      std::forward_iterator_tag)\n+\t{\n+\t  const size_type __len = std::distance(__first, __last);\n+\t  if (__len < size())\n+\t    _M_erase_at_end(std::copy(__first, __last, begin()));\n+\t  else\n+\t    {\n+\t      _ForwardIterator __mid = __first;\n+\t      std::advance(__mid, size());\n+\t      std::copy(__first, __mid, begin());\n+\t      insert(end(), __mid, __last);\n+\t    }\n+\t}\n \n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 438. Ambiguity in the \"do the right thing\" clause\n-    template<typename _Integer>\n-      void\n-      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-\t\t\t __true_type)\n-      { _M_fill_insert(__pos, __n, __x); }\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n \n-    template<typename _InputIterator>\n-      void\n-      _M_insert_dispatch(iterator __pos,\n-\t\t\t _InputIterator __first, _InputIterator __last,\n-\t\t\t __false_type)\n-      { _M_insert_range(__pos, __first, __last,\n-\t\t\tstd::__iterator_category(__first)); }\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 438. Ambiguity in the \"do the right thing\" clause\n+      template<typename _Integer>\n+\tvoid\n+\t_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n+\t\t\t   __true_type)\n+\t{ _M_fill_insert(__pos, __n, __x); }\n \n-    void\n-    _M_fill_insert(iterator __position, size_type __n, bool __x);\n+      template<typename _InputIterator>\n+\tvoid\n+\t_M_insert_dispatch(iterator __pos,\n+\t\t\t   _InputIterator __first, _InputIterator __last,\n+\t\t\t   __false_type)\n+\t{ _M_insert_range(__pos, __first, __last,\n+\t\t\t  std::__iterator_category(__first)); }\n \n-    template<typename _InputIterator>\n       void\n-      _M_insert_range(iterator __pos, _InputIterator __first, \n-\t\t      _InputIterator __last, std::input_iterator_tag)\n-      {\n-\tfor (; __first != __last; ++__first)\n-\t  {\n-\t    __pos = insert(__pos, *__first);\n-\t    ++__pos;\n-\t  }\n-      }\n+      _M_fill_insert(iterator __position, size_type __n, bool __x);\n \n-    template<typename _ForwardIterator>\n-      void\n-      _M_insert_range(iterator __position, _ForwardIterator __first, \n-\t\t      _ForwardIterator __last, std::forward_iterator_tag);\n+      template<typename _InputIterator>\n+\tvoid\n+\t_M_insert_range(iterator __pos, _InputIterator __first, \n+\t\t\t_InputIterator __last, std::input_iterator_tag)\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    {\n+\t      __pos = insert(__pos, *__first);\n+\t      ++__pos;\n+\t    }\n+\t}\n \n-    void\n-    _M_insert_aux(iterator __position, bool __x);\n+      template<typename _ForwardIterator>\n+\tvoid\n+\t_M_insert_range(iterator __position, _ForwardIterator __first, \n+\t\t\t_ForwardIterator __last, std::forward_iterator_tag);\n \n-    size_type\n-    _M_check_len(size_type __n, const char* __s) const\n-    {\n-      if (max_size() - size() < __n)\n-\t__throw_length_error(__N(__s));\n+      void\n+      _M_insert_aux(iterator __position, bool __x);\n \n-      const size_type __len = size() + std::max(size(), __n);\n-      return (__len < size() || __len > max_size()) ? max_size() : __len;\n-    }\n+      size_type\n+      _M_check_len(size_type __n, const char* __s) const\n+      {\n+\tif (max_size() - size() < __n)\n+\t  __throw_length_error(__N(__s));\n \n-    void\n-    _M_erase_at_end(iterator __pos)\n-    { this->_M_impl._M_finish = __pos; }\n+\tconst size_type __len = size() + std::max(size(), __n);\n+\treturn (__len < size() || __len > max_size()) ? max_size() : __len;\n+      }\n \n-    iterator\n-    _M_erase(iterator __pos);\n+      void\n+      _M_erase_at_end(iterator __pos)\n+      { this->_M_impl._M_finish = __pos; }\n \n-    iterator\n-    _M_erase(iterator __first, iterator __last);\n+      iterator\n+      _M_erase(iterator __pos);\n+\n+      iterator\n+      _M_erase(iterator __first, iterator __last);\n   };\n \n _GLIBCXX_END_NAMESPACE_CONTAINER"}, {"sha": "9ee469716f168af2aed05f0a49d9c9f3e0289507", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/default_init.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d594224c2375ae5b067b727a46c42b6ddc86de2/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fdefault_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d594224c2375ae5b067b727a46c42b6ddc86de2/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fdefault_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fdefault_init.cc?ref=7d594224c2375ae5b067b727a46c42b6ddc86de2", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O0\" }\n+// { dg-xfail-run-if \"PR c++/65816\" { *-*-* } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+#include <ext/aligned_buffer.h>\n+\n+using T = bool;\n+\n+using __gnu_test::default_init_allocator;\n+\n+void test01()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type;\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+void test02()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type();\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}