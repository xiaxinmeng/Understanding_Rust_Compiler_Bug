{"sha": "a5eadacc354407939f4bbf55bd44d750e3554344", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlYWRhY2MzNTQ0MDc5MzlmNGJiZjU1YmQ0NGQ3NTBlMzU1NDM0NA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-06-21T00:59:17Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-06-21T00:59:17Z"}, "message": "c-typeck.c (build_function_call): Set fundecl = function again.\n\n2005-06-20  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* c-typeck.c (build_function_call): Set fundecl = function again.\n\t* tree-ssa-alias.c (find_used_portions): Address taking causes the\n\tentire variable to be used.\n\t* tree-ssa-structalias.c (do_structure_copy): Fix handling of\n\tunknown size variables, and structure copies from addressof\n\toperations.  Simplify how we do *a = *b type structure copies.\n\t(init_base_vars): Add ANYTHING = &ANYTHING constraint the right\n\tway.  READONLY's address is not taken by default.\n\tINTEGER dereference should point to anything.\n\t(create_variable_info_for): It's okay for the first field to not start\n\tat 0.\n\nFrom-SVN: r101227", "tree": {"sha": "441f3bfca76fbff3165789a7e384227c2ba626ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/441f3bfca76fbff3165789a7e384227c2ba626ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5eadacc354407939f4bbf55bd44d750e3554344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5eadacc354407939f4bbf55bd44d750e3554344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5eadacc354407939f4bbf55bd44d750e3554344", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5eadacc354407939f4bbf55bd44d750e3554344/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83fbfe42c25f312d47f30be37bcb957c2b7258cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83fbfe42c25f312d47f30be37bcb957c2b7258cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83fbfe42c25f312d47f30be37bcb957c2b7258cf"}], "stats": {"total": 139, "additions": 121, "deletions": 18}, "files": [{"sha": "01132011cba63a25a9d634d18b1020d31f134f07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5eadacc354407939f4bbf55bd44d750e3554344", "patch": "@@ -1,3 +1,17 @@\n+2005-06-20  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* c-typeck.c (build_function_call): Set fundecl = function again.\n+\t* tree-ssa-alias.c (find_used_portions): Address taking causes the\n+\tentire variable to be used.\n+\t* tree-ssa-structalias.c (do_structure_copy): Fix handling of\n+\tunknown size variables, and structure copies from addressof\n+\toperations.  Simplify how we do *a = *b type structure copies.\n+\t(init_base_vars): Add ANYTHING = &ANYTHING constraint the right\n+\tway.  READONLY's address is not taken by default.\n+\tINTEGER dereference should point to anything.\n+\t(create_variable_info_for): It's okay for the first field to not start\n+\tat 0.\n+\n 2005-06-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tconfig/sh/linux.h (FUNCTION_PROFILER): Constify a char*."}, {"sha": "7f462c4fff7ffeb8245531eeb5cc394922091bb4", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=a5eadacc354407939f4bbf55bd44d750e3554344", "patch": "@@ -1990,6 +1990,7 @@ build_function_call (tree function, tree params)\n \treturn tem;\n \n       name = DECL_NAME (function);\n+      fundecl = function;\n     }\n   function = default_function_array_conversion (function);\n "}, {"sha": "515e5ff13f431eca2a05f828c1cbc690e2494b84", "filename": "gcc/testsuite/gcc.c-torture/compile/pta-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpta-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpta-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpta-1.c?ref=a5eadacc354407939f4bbf55bd44d750e3554344", "patch": "@@ -0,0 +1,31 @@\n+typedef struct JSObject JSObject;\n+typedef struct JSObjectMap *(*JSNewObjectMapOp) (JSObject *obj);\n+typedef JSObject *(*JSGetMethodOp) (JSObject *obj);\n+struct JSObjectOps {\n+    JSNewObjectMapOp newObjectMap;\n+};\n+struct JSXMLObjectOps {\n+    struct JSObjectOps base;\n+    JSGetMethodOp getMethod;\n+};\n+struct JSObjectMap {\n+    struct JSObjectOps *ops;\n+};\n+struct JSObject {\n+    struct JSObjectMap *map;\n+};\n+\n+struct JSXMLObjectOps js_XMLObjectOps;\n+\n+\n+/* We need to create SFT's for the entire structure when this address is taken, \n+   not just the part in the component reference itself.  */\n+JSObject *JS_GetMethod(JSObject *obj)\n+{\n+    if (obj->map->ops == &js_XMLObjectOps.base) {\n+        struct JSXMLObjectOps *ops;\n+        ops = (struct JSXMLObjectOps *) obj->map->ops;\n+        obj = ops->getMethod(obj);\n+    }\n+    return obj;\n+}"}, {"sha": "04125cac88c1527e7bc5cfc2390fec67f8e041b8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a5eadacc354407939f4bbf55bd44d750e3554344", "patch": "@@ -3119,6 +3119,35 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t  }\n       }\n       break;\n+      /* This is here to make sure we mark the entire base variable as used\n+\t when you take its address.  Because our used portion analysis is\n+\t simple, we aren't looking at casts or pointer arithmetic to see what\n+\t happens when you take the address.  */\n+    case ADDR_EXPR:\n+      {\n+\ttree var = get_base_address (TREE_OPERAND (*tp, 0));\n+\n+\tif (var \n+\t    && DECL_P (var)\n+\t    && DECL_SIZE (var)\n+\t    && var_can_have_subvars (var)\n+\t    && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n+\t  {\n+\t    used_part_t up;\n+\t    size_t uid = var_ann (var)->uid;\t    \n+\t    \n+\t    up = get_or_create_used_part_for (uid);\n+ \n+\t    up->minused = 0;\n+\t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n+\t    up->implicit_uses = true;\n+\n+\t    used_portions[uid] = up;\n+\t    *walk_subtrees = 0;\n+\t    return NULL_TREE;\n+\t  }\n+      }\n+      break;\n     case VAR_DECL:\n     case PARM_DECL:\n       {"}, {"sha": "4aeda117cb2442a7b857176641c7fea601224a34", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5eadacc354407939f4bbf55bd44d750e3554344/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a5eadacc354407939f4bbf55bd44d750e3554344", "patch": "@@ -2210,8 +2210,7 @@ do_simple_structure_copy (const struct constraint_expr lhs,\n \t\t\t  const unsigned HOST_WIDE_INT size)\n {\n   varinfo_t p = get_varinfo (lhs.var);\n-  unsigned HOST_WIDE_INT pstart,last;\n-\n+  unsigned HOST_WIDE_INT pstart, last;\n   pstart = p->offset;\n   last = p->offset + size;\n   for (; p && p->offset < last; p = p->next)\n@@ -2321,8 +2320,6 @@ do_structure_copy (tree lhsop, tree rhsop)\n   unsigned HOST_WIDE_INT lhssize;\n   unsigned HOST_WIDE_INT rhssize;\n \n-  lhssize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (lhsop)));\n-  rhssize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (rhsop)));\n   lhs = get_constraint_for (lhsop);  \n   rhs = get_constraint_for (rhsop);\n   \n@@ -2334,8 +2331,18 @@ do_structure_copy (tree lhsop, tree rhsop)\n       rhs = tmp;\n     }\n   \n-  /* If the RHS is a special var, set all the LHS fields to that\n-     special var.  */\n+  /*  This is fairly conservative for the RHS == ADDRESSOF case, in that it's\n+      possible it's something we could handle.  However, most cases falling\n+      into this are dealing with transparent unions, which are slightly\n+      weird. */\n+  if (rhs.type == ADDRESSOF && rhs.var > integer_id)\n+    {\n+      rhs.type = ADDRESSOF;\n+      rhs.var = anything_id;\n+    }\n+\n+  /* If the RHS is a special var, or an addressof, set all the LHS fields to\n+     that special var.  */\n   if (rhs.var <= integer_id)\n     {\n       for (p = get_varinfo (lhs.var); p; p = p->next)\n@@ -2351,6 +2358,20 @@ do_structure_copy (tree lhsop, tree rhsop)\n     }\n   else\n     {\n+      /* The size only really matters insofar as we don't set more or less of\n+\t the variable.  If we hit an unknown size var, the size should be the\n+\t whole darn thing.  */\n+      if (get_varinfo (rhs.var)->is_unknown_size_var)\n+\trhssize = ~0;\n+      else\n+\trhssize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (rhsop)));\n+\n+      if (get_varinfo (lhs.var)->is_unknown_size_var)\n+\tlhssize = ~0;\n+      else\n+\tlhssize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (lhsop)));\n+\n+  \n       if (rhs.type == SCALAR && lhs.type == SCALAR)  \n \tdo_simple_structure_copy (lhs, rhs, MIN (lhssize, rhssize));\n       else if (lhs.type != DEREF && rhs.type == DEREF)\n@@ -2362,14 +2383,12 @@ do_structure_copy (tree lhsop, tree rhsop)\n \t  tree rhsdecl = get_varinfo (rhs.var)->decl;\n \t  tree pointertype = TREE_TYPE (rhsdecl);\n \t  tree pointedtotype = TREE_TYPE (pointertype);\n-\t  tree tmpvar;\n+\t  tree tmpvar;  \n+\n \t  gcc_assert (rhs.type == DEREF && lhs.type == DEREF);\n \t  tmpvar = create_tmp_var_raw (pointedtotype, \"structcopydereftmp\");\n-\t  lhs = get_constraint_for (tmpvar);\n-\t  do_rhs_deref_structure_copy (lhs, rhs, MIN (lhssize, rhssize));\n-\t  rhs = lhs;\n-\t  lhs = get_constraint_for (lhsop);\n-\t  do_lhs_deref_structure_copy (lhs, rhs, MIN (lhssize, rhssize));\n+\t  do_structure_copy (tmpvar, rhsop);\n+\t  do_structure_copy (lhsop, tmpvar);\n \t}\n     }\n }\n@@ -2723,7 +2742,7 @@ create_variable_info_for (tree decl, const char *name)\n   vi->offset = 0;\n   vi->has_union = hasunion;\n   if (!TYPE_SIZE (decltype) \n-      || TREE_CODE (TYPE_SIZE  (decltype)) != INTEGER_CST\n+      || TREE_CODE (TYPE_SIZE (decltype)) != INTEGER_CST\n       || TREE_CODE (decltype) == ARRAY_TYPE\n       || TREE_CODE (decltype) == UNION_TYPE\n       || TREE_CODE (decltype) == QUAL_UNION_TYPE)\n@@ -2786,7 +2805,6 @@ create_variable_info_for (tree decl, const char *name)\n \t}\n       \n       field = fo->field;\n-      gcc_assert (bitpos_of_field (field) == 0);\n       vi->size = TREE_INT_CST_LOW (DECL_SIZE (field));\n       for (i = 1; VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n \t{\n@@ -3049,8 +3067,10 @@ init_base_vars (void)\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   var_anything->address_taken = true;\n-  process_constraint (new_constraint (lhs, rhs));\n-\n+  /* This specifically does not use process_constraint because\n+     process_constraint ignores all anything = anything constraints, since all\n+     but this one are redundant.  */\n+  VEC_safe_push (constraint_t, gc, constraints, new_constraint (lhs, rhs));\n   \n   /* Create the READONLY variable, used to represent that a variable\n      points to readonly memory.  */\n@@ -3075,7 +3095,6 @@ init_base_vars (void)\n   rhs.type = ADDRESSOF;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n-  var_readonly->address_taken = true;\n   \n   process_constraint (new_constraint (lhs, rhs));\n   \n@@ -3091,6 +3110,16 @@ init_base_vars (void)\n   var_integer->next = NULL;\n   integer_id = 3;\n   VEC_safe_push (varinfo_t, gc, varmap, var_integer);\n+\n+  /* *INTEGER = ANYTHING, because we don't know where a dereference of a random\n+     integer will point to.  */\n+  lhs.type = SCALAR;\n+  lhs.var = integer_id;\n+  lhs.offset = 0;\n+  rhs.type = ADDRESSOF;\n+  rhs.var = anything_id;\n+  rhs.offset = 0;\n+  process_constraint (new_constraint (lhs, rhs));\n }  \n \n \n@@ -3101,7 +3130,6 @@ static void\n create_alias_vars (void)\n {\n   basic_block bb;\n-\n   \n   init_alias_vars ();\n "}]}