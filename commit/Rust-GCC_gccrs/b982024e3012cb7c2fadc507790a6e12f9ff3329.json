{"sha": "b982024e3012cb7c2fadc507790a6e12f9ff3329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4MjAyNGUzMDEyY2I3YzJmYWRjNTA3NzkwYTZlMTJmOWZmMzMyOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-11-14T02:23:13Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-11-14T02:23:13Z"}, "message": "libgcc2.c (__negdi2, [...]): Const-ify and/or initialize automatic variables at declaration.\n\n\t* libgcc2.c (__negdi2, __addvsi3, __addvdi3, __subvsi3, __subvdi3,\n\t__mulvsi3, __negvsi2, __negvdi2, __mulvdi3, __lshrdi3, __ashldi3,\n\t__ashrdi3, __ffsDI2, __muldi3, __clzDI2, __ctzDI2, __parityDI2,\n\t__udivmoddi4, __divdi3, __moddi3, __cmpdi2, __ucmpdi2,\n\t__fixunstfDI, __fixunsxfDI, __fixunsdfDI, __fixunssfDI,\n\t__floatdixf, __floatditf, __floatdidf, __floatdisf, __gcc_bcmp):\n\tConst-ify and/or initialize automatic variables at declaration.\n\nFrom-SVN: r73573", "tree": {"sha": "9ff2f626a7edaf237950afcd41f454bf740af5c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ff2f626a7edaf237950afcd41f454bf740af5c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b982024e3012cb7c2fadc507790a6e12f9ff3329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b982024e3012cb7c2fadc507790a6e12f9ff3329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b982024e3012cb7c2fadc507790a6e12f9ff3329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b982024e3012cb7c2fadc507790a6e12f9ff3329/comments", "author": null, "committer": null, "parents": [{"sha": "ef1f2e1235b68a4484df6428c81224b34054f18f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1f2e1235b68a4484df6428c81224b34054f18f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1f2e1235b68a4484df6428c81224b34054f18f"}], "stats": {"total": 230, "additions": 86, "deletions": 144}, "files": [{"sha": "0faf0e830122b72ba1a5bed3d61ec1f35839b8e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b982024e3012cb7c2fadc507790a6e12f9ff3329/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b982024e3012cb7c2fadc507790a6e12f9ff3329/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b982024e3012cb7c2fadc507790a6e12f9ff3329", "patch": "@@ -1,3 +1,13 @@\n+2003-11-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* libgcc2.c (__negdi2, __addvsi3, __addvdi3, __subvsi3, __subvdi3,\n+\t__mulvsi3, __negvsi2, __negvdi2, __mulvdi3, __lshrdi3, __ashldi3,\n+\t__ashrdi3, __ffsDI2, __muldi3, __clzDI2, __ctzDI2, __parityDI2,\n+\t__udivmoddi4, __divdi3, __moddi3, __cmpdi2, __ucmpdi2,\n+\t__fixunstfDI, __fixunsxfDI, __fixunsdfDI, __fixunssfDI,\n+\t__floatdixf, __floatditf, __floatdidf, __floatdisf, __gcc_bcmp):\n+\tConst-ify and/or initialize automatic variables at declaration.\n+\n 2003-11-13  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/lib1funcs.asm (divmodsi4): Replace all the uses"}, {"sha": "34171ad90023c432b4b4d49933b0811da4663cbc", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 76, "deletions": 144, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b982024e3012cb7c2fadc507790a6e12f9ff3329/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b982024e3012cb7c2fadc507790a6e12f9ff3329/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=b982024e3012cb7c2fadc507790a6e12f9ff3329", "patch": "@@ -63,13 +63,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n DWtype\n __negdi2 (DWtype u)\n {\n-  DWunion w;\n-  DWunion uu;\n-\n-  uu.ll = u;\n-\n-  w.s.low = -uu.s.low;\n-  w.s.high = -uu.s.high - ((UWtype) w.s.low > 0);\n+  const DWunion uu = {.ll = u};\n+  const DWunion w = { {.low = -uu.s.low,\n+\t\t       .high = -uu.s.high - ((UWtype) -uu.s.low > 0) } };\n \n   return w.ll;\n }\n@@ -79,9 +75,7 @@ __negdi2 (DWtype u)\n Wtype\n __addvsi3 (Wtype a, Wtype b)\n {\n-  Wtype w;\n-\n-  w = a + b;\n+  const Wtype w = a + b;\n \n   if (b >= 0 ? w < a : w > a)\n     abort ();\n@@ -94,9 +88,7 @@ __addvsi3 (Wtype a, Wtype b)\n DWtype\n __addvdi3 (DWtype a, DWtype b)\n {\n-  DWtype w;\n-\n-  w = a + b;\n+  const DWtype w = a + b;\n \n   if (b >= 0 ? w < a : w > a)\n     abort ();\n@@ -109,9 +101,7 @@ __addvdi3 (DWtype a, DWtype b)\n Wtype\n __subvsi3 (Wtype a, Wtype b)\n {\n-  DWtype w;\n-\n-  w = a - b;\n+  const DWtype w = a - b;\n \n   if (b >= 0 ? w > a : w < a)\n     abort ();\n@@ -124,9 +114,7 @@ __subvsi3 (Wtype a, Wtype b)\n DWtype\n __subvdi3 (DWtype a, DWtype b)\n {\n-  DWtype w;\n-\n-  w = a - b;\n+  const DWtype w = a - b;\n \n   if (b >= 0 ? w > a : w < a)\n     abort ();\n@@ -140,9 +128,7 @@ __subvdi3 (DWtype a, DWtype b)\n Wtype\n __mulvsi3 (Wtype a, Wtype b)\n {\n-  DWtype w;\n-\n-  w = (DWtype) a * (DWtype) b;\n+  const DWtype w = (DWtype) a * (DWtype) b;\n \n   if (((a >= 0) == (b >= 0))\n       ? (UDWtype) w > (UDWtype) (((DWtype) 1 << (WORD_SIZE - 1)) - 1)\n@@ -157,9 +143,7 @@ __mulvsi3 (Wtype a, Wtype b)\n Wtype\n __negvsi2 (Wtype a)\n {\n-  Wtype w;\n-\n-  w  = -a;\n+  const Wtype w = -a;\n \n   if (a >= 0 ? w > 0 : w < 0)\n     abort ();\n@@ -172,9 +156,7 @@ __negvsi2 (Wtype a)\n DWtype\n __negvdi2 (DWtype a)\n {\n-  DWtype w;\n-\n-  w  = -a;\n+  const DWtype w = -a;\n \n   if (a >= 0 ? w > 0 : w < 0)\n     abort ();\n@@ -230,10 +212,8 @@ __mulvdi3 (DWtype u, DWtype v)\n {\n   /* The unchecked multiplication needs 3 Wtype x Wtype multiplications,\n      but the checked multiplication needs only two.  */\n-  DWunion uu, vv;\n-\n-  uu.ll = u;\n-  vv.ll = v;\n+  const DWunion uu = {.ll = u};\n+  const DWunion vv = {.ll = v};\n \n   if (__builtin_expect (uu.s.high == uu.s.low >> (WORD_SIZE - 1), 1))\n     {\n@@ -247,10 +227,11 @@ __mulvdi3 (DWtype u, DWtype v)\n       else\n \t{\n \t  /* Two multiplications.  */\n-\t  DWunion w0, w1;\n+\t  DWunion w0 = {.ll = (UDWtype) (UWtype) uu.s.low\n+\t\t\t* (UDWtype) (UWtype) vv.s.low};\n+\t  DWunion w1 = {.ll = (UDWtype) (UWtype) uu.s.low\n+\t\t\t* (UDWtype) (UWtype) vv.s.high};\n \n-\t  w0.ll = (UDWtype) (UWtype) uu.s.low * (UDWtype) (UWtype) vv.s.low;\n-\t  w1.ll = (UDWtype) (UWtype) uu.s.low * (UDWtype) (UWtype) vv.s.high;\n \t  if (vv.s.high < 0)\n \t    w1.s.high -= uu.s.low;\n \t  if (uu.s.low < 0)\n@@ -269,10 +250,11 @@ __mulvdi3 (DWtype u, DWtype v)\n \t{\n \t  /* v fits into a single Wtype.  */\n \t  /* Two multiplications.  */\n-\t  DWunion w0, w1;\n+\t  DWunion w0 = {.ll = (UDWtype) (UWtype) uu.s.low\n+\t\t\t* (UDWtype) (UWtype) vv.s.low};\n+\t  DWunion w1 = {.ll = (UDWtype) (UWtype) uu.s.high\n+\t\t\t* (UDWtype) (UWtype) vv.s.low};\n \n-\t  w0.ll = (UDWtype) (UWtype) uu.s.low * (UDWtype) (UWtype) vv.s.low;\n-\t  w1.ll = (UDWtype) (UWtype) uu.s.high * (UDWtype) (UWtype) vv.s.low;\n \t  if (uu.s.high < 0)\n \t    w1.s.high -= vv.s.low;\n \t  if (vv.s.low < 0)\n@@ -293,10 +275,8 @@ __mulvdi3 (DWtype u, DWtype v)\n \t\t{\n \t\t  if (uu.s.high == 0 && vv.s.high == 0)\n \t\t    {\n-\t\t      DWtype w;\n-\n-\t\t      w = (UDWtype) (UWtype) uu.s.low\n-\t\t\t  * (UDWtype) (UWtype) vv.s.low;\n+\t\t      const DWtype w = (UDWtype) (UWtype) uu.s.low\n+\t\t\t* (UDWtype) (UWtype) vv.s.low;\n \t\t      if (__builtin_expect (w >= 0, 1))\n \t\t\treturn w;\n \t\t    }\n@@ -305,10 +285,9 @@ __mulvdi3 (DWtype u, DWtype v)\n \t\t{\n \t\t  if (uu.s.high == 0 && vv.s.high == (Wtype) -1)\n \t\t    {\n-\t\t      DWunion ww;\n+\t\t      DWunion ww = {.ll = (UDWtype) (UWtype) uu.s.low\n+\t\t\t\t    * (UDWtype) (UWtype) vv.s.low};\n \n-\t\t      ww.ll = (UDWtype) (UWtype) uu.s.low\n-\t\t\t      * (UDWtype) (UWtype) vv.s.low;\n \t\t      ww.s.high -= uu.s.low;\n \t\t      if (__builtin_expect (ww.s.high < 0, 1))\n \t\t\treturn ww.ll;\n@@ -321,10 +300,9 @@ __mulvdi3 (DWtype u, DWtype v)\n \t\t{\n \t\t  if (uu.s.high == (Wtype) -1 && vv.s.high == 0)\n \t\t    {\n-\t\t      DWunion ww;\n+\t\t      DWunion ww = {.ll = (UDWtype) (UWtype) uu.s.low\n+\t\t\t\t    * (UDWtype) (UWtype) vv.s.low};\n \n-\t\t      ww.ll = (UDWtype) (UWtype) uu.s.low\n-\t\t\t      * (UDWtype) (UWtype) vv.s.low;\n \t\t      ww.s.high -= vv.s.low;\n \t\t      if (__builtin_expect (ww.s.high < 0, 1))\n \t\t\treturn ww.ll;\n@@ -334,10 +312,9 @@ __mulvdi3 (DWtype u, DWtype v)\n \t\t{\n \t\t  if (uu.s.high == (Wtype) -1 && vv.s.high == (Wtype) - 1)\n \t\t    {\n-\t\t      DWunion ww;\n+\t\t      DWunion ww = {.ll = (UDWtype) (UWtype) uu.s.low\n+\t\t\t\t    * (UDWtype) (UWtype) vv.s.low};\n \n-\t\t      ww.ll = (UDWtype) (UWtype) uu.s.low\n-\t\t\t      * (UDWtype) (UWtype) vv.s.low;\n \t\t      ww.s.high -= uu.s.low;\n \t\t      ww.s.high -= vv.s.low;\n \t\t      if (__builtin_expect (ww.s.high >= 0, 1))\n@@ -360,24 +337,21 @@ __mulvdi3 (DWtype u, DWtype v)\n DWtype\n __lshrdi3 (DWtype u, word_type b)\n {\n-  DWunion w;\n-  word_type bm;\n-  DWunion uu;\n-\n   if (b == 0)\n     return u;\n \n-  uu.ll = u;\n+  const DWunion uu = {.ll = u};\n+  const word_type bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n+  DWunion w;\n \n-  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.high = 0;\n       w.s.low = (UWtype) uu.s.high >> -bm;\n     }\n   else\n     {\n-      UWtype carries = (UWtype) uu.s.high << bm;\n+      const UWtype carries = (UWtype) uu.s.high << bm;\n \n       w.s.high = (UWtype) uu.s.high >> b;\n       w.s.low = ((UWtype) uu.s.low >> b) | carries;\n@@ -391,24 +365,21 @@ __lshrdi3 (DWtype u, word_type b)\n DWtype\n __ashldi3 (DWtype u, word_type b)\n {\n-  DWunion w;\n-  word_type bm;\n-  DWunion uu;\n-\n   if (b == 0)\n     return u;\n \n-  uu.ll = u;\n+  const DWunion uu = {.ll = u};\n+  const word_type bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n+  DWunion w;\n \n-  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.low = 0;\n       w.s.high = (UWtype) uu.s.low << -bm;\n     }\n   else\n     {\n-      UWtype carries = (UWtype) uu.s.low >> bm;\n+      const UWtype carries = (UWtype) uu.s.low >> bm;\n \n       w.s.low = (UWtype) uu.s.low << b;\n       w.s.high = ((UWtype) uu.s.high << b) | carries;\n@@ -422,16 +393,13 @@ __ashldi3 (DWtype u, word_type b)\n DWtype\n __ashrdi3 (DWtype u, word_type b)\n {\n-  DWunion w;\n-  word_type bm;\n-  DWunion uu;\n-\n   if (b == 0)\n     return u;\n \n-  uu.ll = u;\n+  const DWunion uu = {.ll = u};\n+  const word_type bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n+  DWunion w;\n \n-  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       /* w.s.high = 1..1 or 0..0 */\n@@ -440,7 +408,7 @@ __ashrdi3 (DWtype u, word_type b)\n     }\n   else\n     {\n-      UWtype carries = (UWtype) uu.s.high << bm;\n+      const UWtype carries = (UWtype) uu.s.high << bm;\n \n       w.s.high = uu.s.high >> b;\n       w.s.low = ((UWtype) uu.s.low >> b) | carries;\n@@ -472,10 +440,9 @@ extern int __ffsDI2 (DWtype u);\n int\n __ffsDI2 (DWtype u)\n {\n-  DWunion uu;\n+  const DWunion uu = {.ll = u};\n   UWtype word, count, add;\n \n-  uu.ll = u;\n   if (uu.s.low != 0)\n     word = uu.s.low, add = 0;\n   else if (uu.s.high != 0)\n@@ -492,13 +459,10 @@ __ffsDI2 (DWtype u)\n DWtype\n __muldi3 (DWtype u, DWtype v)\n {\n-  DWunion w;\n-  DWunion uu, vv;\n+  const DWunion uu = {.ll = u};\n+  const DWunion vv = {.ll = v};\n+  DWunion w = {.ll = __umulsidi3 (uu.s.low, vv.s.low)};\n \n-  uu.ll = u,\n-  vv.ll = v;\n-\n-  w.ll = __umulsidi3 (uu.s.low, vv.s.low);\n   w.s.high += ((UWtype) uu.s.low * (UWtype) vv.s.high\n \t       + (UWtype) uu.s.high * (UWtype) vv.s.low);\n \n@@ -667,11 +631,10 @@ extern int __clzDI2 (UDWtype x);\n int\n __clzDI2 (UDWtype x)\n {\n-  DWunion uu;\n+  const DWunion uu = {.ll = x};\n   UWtype word;\n   Wtype ret, add;\n \n-  uu.ll = x;\n   if (uu.s.high)\n     word = uu.s.high, add = 0;\n   else\n@@ -702,11 +665,10 @@ extern int __ctzDI2 (UDWtype x);\n int\n __ctzDI2 (UDWtype x)\n {\n-  DWunion uu;\n+  const DWunion uu = {.ll = x};\n   UWtype word;\n   Wtype ret, add;\n \n-  uu.ll = x;\n   if (uu.s.low)\n     word = uu.s.low, add = 0;\n   else\n@@ -794,11 +756,8 @@ extern int __parityDI2 (UDWtype x);\n int\n __parityDI2 (UDWtype x)\n {\n-  DWunion uu;\n-  UWtype nx;\n-\n-  uu.ll = x;\n-  nx = uu.s.low ^ uu.s.high;\n+  const DWunion uu = {.ll = x};\n+  UWtype nx = uu.s.low ^ uu.s.high;\n \n #if W_TYPE_SIZE > 64\n # error \"fill out the table\"\n@@ -825,16 +784,13 @@ static inline __attribute__ ((__always_inline__))\n UDWtype\n __udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)\n {\n-  DWunion ww;\n-  DWunion nn, dd;\n+  const DWunion nn = {.ll = n};\n+  const DWunion dd = {.ll = d};\n   DWunion rr;\n   UWtype d0, d1, n0, n1, n2;\n   UWtype q0, q1;\n   UWtype b, bm;\n \n-  nn.ll = n;\n-  dd.ll = d;\n-\n   d0 = dd.s.low;\n   d1 = dd.s.high;\n   n0 = nn.s.low;\n@@ -1034,8 +990,7 @@ __udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)\n \t}\n     }\n \n-  ww.s.low = q0;\n-  ww.s.high = q1;\n+  const DWunion ww = {{.low = q0, .high = q1}};\n   return ww.ll;\n }\n #endif\n@@ -1045,12 +1000,10 @@ DWtype\n __divdi3 (DWtype u, DWtype v)\n {\n   word_type c = 0;\n-  DWunion uu, vv;\n+  DWunion uu = {.ll = u};\n+  DWunion vv = {.ll = v};\n   DWtype w;\n \n-  uu.ll = u;\n-  vv.ll = v;\n-\n   if (uu.s.high < 0)\n     c = ~c,\n     uu.ll = -uu.ll;\n@@ -1071,12 +1024,10 @@ DWtype\n __moddi3 (DWtype u, DWtype v)\n {\n   word_type c = 0;\n-  DWunion uu, vv;\n+  DWunion uu = {.ll = u};\n+  DWunion vv = {.ll = v};\n   DWtype w;\n \n-  uu.ll = u;\n-  vv.ll = v;\n-\n   if (uu.s.high < 0)\n     c = ~c,\n     uu.ll = -uu.ll;\n@@ -1115,9 +1066,8 @@ __udivdi3 (UDWtype n, UDWtype d)\n word_type\n __cmpdi2 (DWtype a, DWtype b)\n {\n-  DWunion au, bu;\n-\n-  au.ll = a, bu.ll = b;\n+  const DWunion au = {.ll = a};\n+  const DWunion bu = {.ll = b};\n \n   if (au.s.high < bu.s.high)\n     return 0;\n@@ -1135,9 +1085,8 @@ __cmpdi2 (DWtype a, DWtype b)\n word_type\n __ucmpdi2 (DWtype a, DWtype b)\n {\n-  DWunion au, bu;\n-\n-  au.ll = a, bu.ll = b;\n+  const DWunion au = {.ll = a};\n+  const DWunion bu = {.ll = b};\n \n   if ((UWtype) au.s.high < (UWtype) bu.s.high)\n     return 0;\n@@ -1158,17 +1107,14 @@ __ucmpdi2 (DWtype a, DWtype b)\n DWtype\n __fixunstfDI (TFtype a)\n {\n-  TFtype b;\n-  UDWtype v;\n-\n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n-  b = (a / HIGH_WORD_COEFF);\n+  const TFtype b = (a / HIGH_WORD_COEFF);\n   /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n-  v = (UWtype) b;\n+  UDWtype v = (UWtype) b;\n   v <<= WORD_SIZE;\n   /* Remove high part from the TFtype, leaving the low part as flonum.  */\n   a -= (TFtype)v;\n@@ -1200,17 +1146,14 @@ __fixtfdi (TFtype a)\n DWtype\n __fixunsxfDI (XFtype a)\n {\n-  XFtype b;\n-  UDWtype v;\n-\n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n-  b = (a / HIGH_WORD_COEFF);\n+  const XFtype b = (a / HIGH_WORD_COEFF);\n   /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n-  v = (UWtype) b;\n+  UDWtype v = (UWtype) b;\n   v <<= WORD_SIZE;\n   /* Remove high part from the XFtype, leaving the low part as flonum.  */\n   a -= (XFtype)v;\n@@ -1242,17 +1185,15 @@ __fixxfdi (XFtype a)\n DWtype\n __fixunsdfDI (DFtype a)\n {\n-  UWtype hi, lo;\n-\n   /* Get high part of result.  The division here will just moves the radix\n      point and will not cause any rounding.  Then the conversion to integral\n      type chops result as desired.  */\n-  hi = a / HIGH_WORD_COEFF;\n+  const UWtype hi = a / HIGH_WORD_COEFF;\n \n   /* Get low part of result.  Convert `hi' to floating type and scale it back,\n      then subtract this from the number being converted.  This leaves the low\n      part.  Convert that to integral type.  */\n-  lo = (a - ((DFtype) hi) * HIGH_WORD_COEFF);\n+  const UWtype lo = (a - ((DFtype) hi) * HIGH_WORD_COEFF);\n \n   /* Assemble result from the two parts.  */\n   return ((UDWtype) hi << WORD_SIZE) | lo;\n@@ -1279,18 +1220,17 @@ __fixunssfDI (SFtype original_a)\n   /* Convert the SFtype to a DFtype, because that is surely not going\n      to lose any bits.  Some day someone else can write a faster version\n      that avoids converting to DFtype, and verify it really works right.  */\n-  DFtype a = original_a;\n-  UWtype hi, lo;\n+  const DFtype a = original_a;\n \n   /* Get high part of result.  The division here will just moves the radix\n      point and will not cause any rounding.  Then the conversion to integral\n      type chops result as desired.  */\n-  hi = a / HIGH_WORD_COEFF;\n+  const UWtype hi = a / HIGH_WORD_COEFF;\n \n   /* Get low part of result.  Convert `hi' to floating type and scale it back,\n      then subtract this from the number being converted.  This leaves the low\n      part.  Convert that to integral type.  */\n-  lo = (a - ((DFtype) hi) * HIGH_WORD_COEFF);\n+  const UWtype lo = (a - ((DFtype) hi) * HIGH_WORD_COEFF);\n \n   /* Assemble result from the two parts.  */\n   return ((UDWtype) hi << WORD_SIZE) | lo;\n@@ -1315,9 +1255,7 @@ __fixsfdi (SFtype a)\n XFtype\n __floatdixf (DWtype u)\n {\n-  XFtype d;\n-\n-  d = (Wtype) (u >> WORD_SIZE);\n+  XFtype d = (Wtype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n   d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n@@ -1334,9 +1272,7 @@ __floatdixf (DWtype u)\n TFtype\n __floatditf (DWtype u)\n {\n-  TFtype d;\n-\n-  d = (Wtype) (u >> WORD_SIZE);\n+  TFtype d = (Wtype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n   d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n@@ -1353,9 +1289,7 @@ __floatditf (DWtype u)\n DFtype\n __floatdidf (DWtype u)\n {\n-  DFtype d;\n-\n-  d = (Wtype) (u >> WORD_SIZE);\n+  DFtype d = (Wtype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n   d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n@@ -1376,11 +1310,6 @@ __floatdidf (DWtype u)\n SFtype\n __floatdisf (DWtype u)\n {\n-  /* Do the calculation in DFmode\n-     so that we don't lose any of the precision of the high word\n-     while multiplying it.  */\n-  DFtype f;\n-\n   /* Protect against double-rounding error.\n      Represent any low-order bits, that might be truncated in DFmode,\n      by a bit that won't be lost.  The bit can go in anywhere below the\n@@ -1401,7 +1330,10 @@ __floatdisf (DWtype u)\n \t    }\n \t}\n     }\n-  f = (Wtype) (u >> WORD_SIZE);\n+  /* Do the calculation in DFmode\n+     so that we don't lose any of the precision of the high word\n+     while multiplying it.  */\n+  DFtype f = (Wtype) (u >> WORD_SIZE);\n   f *= HIGH_HALFWORD_COEFF;\n   f *= HIGH_HALFWORD_COEFF;\n   f += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n@@ -1510,7 +1442,7 @@ __gcc_bcmp (const unsigned char *s1, const unsigned char *s2, size_t size)\n {\n   while (size > 0)\n     {\n-      unsigned char c1 = *s1++, c2 = *s2++;\n+      const unsigned char c1 = *s1++, c2 = *s2++;\n       if (c1 != c2)\n \treturn c1 - c2;\n       size--;"}]}