{"sha": "f2034d064c29d9620c5562b2b5b517bdc6c7a672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIwMzRkMDY0YzI5ZDk2MjBjNTU2MmIyYjViNTE3YmRjNmM3YTY3Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-03-30T15:18:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-03-30T15:18:30Z"}, "message": "reload.h (reg_equiv_constant): Move into new structure reg_equivs, define accessor macro.\n\n\n\t* reload.h (reg_equiv_constant): Move into new structure reg_equivs,\n\tdefine accessor macro.\n\t(reg_equiv_invariant, reg_equiv_memory_loc): Likewise.\n\t(reg_equiv_address, reg_equiv_mem, reg_equiv_alt_mem_list): Likewise.\n\t(reg_equiv_init): Likewise.\n\t(reg_equivs_size): New variable.\n\t(reg_equiv_init_size): Remove.\n\t(allocate_initial_values): Move prototype to here from....\n\t* integrate.h (allocate_initial_values): Remove prototype.\n\t* integrate.c: Include reload.h.\n\t(allocate_initial_values): Corresponding changes.\n\t* ira.c (find_reg_equiv_invariant_cost): Corresponding changes.\n\t(fix_reg_equiv_init, no_equiv): Corresponding changes.\n\t(update_equiv_regs): Corresponding changes.\n\t(ira): Corresponding changes.\n\t* reload.c (push_reg_equiv_alt_mem): Corresponding changes.\n\t(push_secondary_reload): Corresponding changes.\n\t(push_reload, find_reloads, find_reloads_toplev): Corresponding changes.\n\t(make_memloc, find_reloads_address): Corresponding changes.\n\t(subst_reg_equivs, subst_indexed_address): Corresponding changes.\n\t(find_reloads_address_1): Corresponding changes.\n\t(find_reloads_subreg_address, subst_reloads): Corresponding changes.\n\t(refers_to_regno_for_reload_p): Corresponding changes.\n\t(reg_overlap_mentioned_for_reload_p): Corresponding changes.\n\t(refers_to_mem_for_reload_p, find_equiv_reg): Corresponding changes.\n\t* reload1.c: Include ggc.h.\n\t(grow_reg_equivs): New function.\n\t(replace_pseudos_in, reload): Corresponding changes.\n\t(calculate_needs_all_insns, alter_regs): Corresponding changes.\n\t(eliminate_regs_1, elimination_effects): Corresponding changes.\n\t(emit_input_reload_insns, emit_output_reload_insns): Likewise.\n\t(delete_output_reload): Likewise.\n\t* caller-save.c (mark_referenced_regs): Corresponding changes.\n\t* alpha/alpha.c (resolve_reload_operand): Corresponding changes.\n\t* frv/predicates.md (frv_load_operand): Corresponding changes.\n\t* microblaze/microblaze.c (double_memory_operand): Corresponding\n\tchanges.\n\t* avr/avr.h (LEGITIMIZE_RELOAD_ADDRESS): Corresponding changes.\n\t* xtensa/xtensa.c (fixup_subreg_mem): Corresponding changes.\n\t* mn10300/mn10300.c (mn10300_secondary_reload): Corresponding\n\tchanges.\n\t* m68k/m68k.c (emit_move_sequence): Corresponding changes.\n\t* arm/arm.c (arm_reload_in_hi, arm_reload_out_hi): Corresponding\n\tchanges.\n\t* pa/pa.c (emit_move_sequence): Corresponding changes.\n\t* vax/vax.c (nonindexed_address_p): Corresponding changes.\n\nFrom-SVN: r171731", "tree": {"sha": "f600906a3414c87afd503872e7330139e7eb57ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f600906a3414c87afd503872e7330139e7eb57ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2034d064c29d9620c5562b2b5b517bdc6c7a672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2034d064c29d9620c5562b2b5b517bdc6c7a672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2034d064c29d9620c5562b2b5b517bdc6c7a672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2034d064c29d9620c5562b2b5b517bdc6c7a672/comments", "author": null, "committer": null, "parents": [{"sha": "159b81b00a8683b5fe7efdbaff73391a8d9e2d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159b81b00a8683b5fe7efdbaff73391a8d9e2d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159b81b00a8683b5fe7efdbaff73391a8d9e2d96"}], "stats": {"total": 733, "additions": 399, "deletions": 334}, "files": [{"sha": "4c69f86f31fb7b2664471bb7ec0b9311c07ccd96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1,3 +1,52 @@\n+2011-03-30  Jeff Law  <law@redhat.com>\n+\n+\t* reload.h (reg_equiv_constant): Move into new structure reg_equivs,\n+\tdefine accessor macro.\n+\t(reg_equiv_invariant, reg_equiv_memory_loc): Likewise.\n+\t(reg_equiv_address, reg_equiv_mem, reg_equiv_alt_mem_list): Likewise.\n+\t(reg_equiv_init): Likewise.\n+\t(reg_equivs_size): New variable.\n+\t(reg_equiv_init_size): Remove.\n+\t(allocate_initial_values): Move prototype to here from....\n+\t* integrate.h (allocate_initial_values): Remove prototype.\n+\t* integrate.c: Include reload.h.\n+\t(allocate_initial_values): Corresponding changes.\n+\t* ira.c (find_reg_equiv_invariant_cost): Corresponding changes.\n+\t(fix_reg_equiv_init, no_equiv): Corresponding changes.\n+\t(update_equiv_regs): Corresponding changes.\n+\t(ira): Corresponding changes.\n+\t* reload.c (push_reg_equiv_alt_mem): Corresponding changes.\n+\t(push_secondary_reload): Corresponding changes.\n+\t(push_reload, find_reloads, find_reloads_toplev): Corresponding changes.\n+\t(make_memloc, find_reloads_address): Corresponding changes.\n+\t(subst_reg_equivs, subst_indexed_address): Corresponding changes.\n+\t(find_reloads_address_1): Corresponding changes.\n+\t(find_reloads_subreg_address, subst_reloads): Corresponding changes.\n+\t(refers_to_regno_for_reload_p): Corresponding changes.\n+\t(reg_overlap_mentioned_for_reload_p): Corresponding changes.\n+\t(refers_to_mem_for_reload_p, find_equiv_reg): Corresponding changes.\n+\t* reload1.c: Include ggc.h.\n+\t(grow_reg_equivs): New function.\n+\t(replace_pseudos_in, reload): Corresponding changes.\n+\t(calculate_needs_all_insns, alter_regs): Corresponding changes.\n+\t(eliminate_regs_1, elimination_effects): Corresponding changes.\n+\t(emit_input_reload_insns, emit_output_reload_insns): Likewise.\n+\t(delete_output_reload): Likewise.\n+\t* caller-save.c (mark_referenced_regs): Corresponding changes.\n+\t* alpha/alpha.c (resolve_reload_operand): Corresponding changes.\n+\t* frv/predicates.md (frv_load_operand): Corresponding changes.\n+\t* microblaze/microblaze.c (double_memory_operand): Corresponding\n+\tchanges.\n+\t* avr/avr.h (LEGITIMIZE_RELOAD_ADDRESS): Corresponding changes.\n+\t* xtensa/xtensa.c (fixup_subreg_mem): Corresponding changes.\n+\t* mn10300/mn10300.c (mn10300_secondary_reload): Corresponding\n+\tchanges.\n+\t* m68k/m68k.c (emit_move_sequence): Corresponding changes.\n+\t* arm/arm.c (arm_reload_in_hi, arm_reload_out_hi): Corresponding\n+\tchanges.\n+\t* pa/pa.c (emit_move_sequence): Corresponding changes.\n+\t* vax/vax.c (nonindexed_address_p): Corresponding changes.\n+\n 2011-03-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR target/47551"}, {"sha": "54de30b4a51fb025280e4f332d410623677cf903", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1027,10 +1027,10 @@ mark_referenced_regs (rtx *loc, refmarker_fn *mark, void *arg)\n       /* If this is a pseudo that did not get a hard register, scan its\n \t memory location, since it might involve the use of another\n \t register, which might be saved.  */\n-      else if (reg_equiv_mem[regno] != 0)\n-\tmark_referenced_regs (&XEXP (reg_equiv_mem[regno], 0), mark, arg);\n-      else if (reg_equiv_address[regno] != 0)\n-\tmark_referenced_regs (&reg_equiv_address[regno], mark, arg);\n+      else if (reg_equiv_mem (regno) != 0)\n+\tmark_referenced_regs (&XEXP (reg_equiv_mem (regno), 0), mark, arg);\n+      else if (reg_equiv_address (regno) != 0)\n+\tmark_referenced_regs (&reg_equiv_address (regno), mark, arg);\n       return;\n     }\n "}, {"sha": "8aabeb27dd0cb9aa04651e4e709d1af02a3cada7", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -548,7 +548,7 @@ resolve_reload_operand (rtx op)\n       if (REG_P (tmp)\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  op = reg_equiv_memory_loc[REGNO (tmp)];\n+\t  op = reg_equiv_memory_loc (REGNO (tmp));\n \t  if (op == 0)\n \t    return 0;\n \t}"}, {"sha": "56dc85ea4b8537bfa6ad0f09011098ca4a612e1a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -10897,14 +10897,14 @@ arm_reload_in_hi (rtx *operands)\n \t are two cases here: the first where there is a simple\n \t stack-slot replacement and a second where the stack-slot is\n \t out of range, or is used as a subreg.  */\n-      if (reg_equiv_mem[REGNO (ref)])\n+      if (reg_equiv_mem (REGNO (ref)))\n \t{\n-\t  ref = reg_equiv_mem[REGNO (ref)];\n+\t  ref = reg_equiv_mem (REGNO (ref));\n \t  base = find_replacement (&XEXP (ref, 0));\n \t}\n       else\n \t/* The slot is out of range, or was dressed up in a SUBREG.  */\n-\tbase = reg_equiv_address[REGNO (ref)];\n+\tbase = reg_equiv_address (REGNO (ref));\n     }\n   else\n     base = find_replacement (&XEXP (ref, 0));\n@@ -11014,14 +11014,14 @@ arm_reload_out_hi (rtx *operands)\n \t are two cases here: the first where there is a simple\n \t stack-slot replacement and a second where the stack-slot is\n \t out of range, or is used as a subreg.  */\n-      if (reg_equiv_mem[REGNO (ref)])\n+      if (reg_equiv_mem (REGNO (ref)))\n \t{\n-\t  ref = reg_equiv_mem[REGNO (ref)];\n+\t  ref = reg_equiv_mem (REGNO (ref));\n \t  base = find_replacement (&XEXP (ref, 0));\n \t}\n       else\n \t/* The slot is out of range, or was dressed up in a SUBREG.  */\n-\tbase = reg_equiv_address[REGNO (ref)];\n+\tbase = reg_equiv_address (REGNO (ref));\n     }\n   else\n     base = find_replacement (&XEXP (ref, 0));"}, {"sha": "ca73bad31c52c76cdb7dfa02d16ad14f80edf6dc", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -393,14 +393,14 @@ do {\t\t\t\t\t\t\t\t\t    \\\n     }\t\t\t\t\t\t\t\t\t    \\\n   if (GET_CODE (X) == PLUS\t\t\t\t\t\t    \\\n       && REG_P (XEXP (X, 0))\t\t\t\t\t\t    \\\n-      && reg_equiv_constant[REGNO (XEXP (X, 0))] == 0\t\t\t    \\\n+      && (reg_equiv_constant (REGNO (XEXP (X, 0))) == 0)\t\t    \\\n       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t    \\\n       && INTVAL (XEXP (X, 1)) >= 1)\t\t\t\t\t    \\\n     {\t\t\t\t\t\t\t\t\t    \\\n       int fit = INTVAL (XEXP (X, 1)) <= (64 - GET_MODE_SIZE (MODE));\t    \\\n       if (fit)\t\t\t\t\t\t\t\t    \\\n \t{\t\t\t\t\t\t\t\t    \\\n-          if (reg_equiv_address[REGNO (XEXP (X, 0))] != 0)\t\t    \\\n+          if (reg_equiv_address (REGNO (XEXP (X, 0))) != 0)\t\t    \\\n \t    {\t\t\t\t\t\t\t\t    \\\n \t      int regno = REGNO (XEXP (X, 0));\t\t\t\t    \\\n \t      rtx mem = make_memloc (X, regno);\t\t\t\t    \\"}, {"sha": "e8bc35ab17778c79f3284f5d421f2ed73f0c51e8", "filename": "gcc/config/frv/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Fpredicates.md?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -55,7 +55,7 @@\n \ttmp = SUBREG_REG (tmp);\n       if (GET_CODE (tmp) == REG\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n-\top = reg_equiv_memory_loc[REGNO (tmp)];\n+\top = reg_equiv_memory_loc (REGNO (tmp));\n     }\n \n   return op && memory_operand (op, mode);"}, {"sha": "40041b7de9c10e2ff0ee711942658387e257e866", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -3729,7 +3729,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   if (scratch_reg\n       && reload_in_progress && GET_CODE (operand0) == REG\n       && REGNO (operand0) >= FIRST_PSEUDO_REGISTER)\n-    operand0 = reg_equiv_mem[REGNO (operand0)];\n+    operand0 = reg_equiv_mem (REGNO (operand0));\n   else if (scratch_reg\n \t   && reload_in_progress && GET_CODE (operand0) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operand0)) == REG\n@@ -3738,15 +3738,15 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n \tthe code which tracks sets/uses for delete_output_reload.  */\n       rtx temp = gen_rtx_SUBREG (GET_MODE (operand0),\n-\t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand0))],\n+\t\t\t\t reg_equiv_mem (REGNO (SUBREG_REG (operand0))),\n \t\t\t\t SUBREG_BYTE (operand0));\n       operand0 = alter_subreg (&temp);\n     }\n \n   if (scratch_reg\n       && reload_in_progress && GET_CODE (operand1) == REG\n       && REGNO (operand1) >= FIRST_PSEUDO_REGISTER)\n-    operand1 = reg_equiv_mem[REGNO (operand1)];\n+    operand1 = reg_equiv_mem (REGNO (operand1));\n   else if (scratch_reg\n \t   && reload_in_progress && GET_CODE (operand1) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operand1)) == REG\n@@ -3755,7 +3755,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n \tthe code which tracks sets/uses for delete_output_reload.  */\n       rtx temp = gen_rtx_SUBREG (GET_MODE (operand1),\n-\t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand1))],\n+\t\t\t\t reg_equiv_mem (REGNO (SUBREG_REG (operand1))),\n \t\t\t\t SUBREG_BYTE (operand1));\n       operand1 = alter_subreg (&temp);\n     }"}, {"sha": "6ea5fa247037258313403895c5a9083005ee6221", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -326,8 +326,8 @@ double_memory_operand (rtx op, enum machine_mode mode)\n \t  && GET_CODE (op) == REG\n \t  && REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t  && reg_renumber[REGNO (op)] < 0\n-\t  && reg_equiv_mem[REGNO (op)] != 0\n-\t  && double_memory_operand (reg_equiv_mem[REGNO (op)], mode))\n+\t  && reg_equiv_mem (REGNO (op)) != 0\n+\t  && double_memory_operand (reg_equiv_mem (REGNO (op)), mode))\n \treturn 1;\n       return 0;\n     }"}, {"sha": "f00c53eaee0666173fcbf85292c4d9a04e2576a2", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1430,7 +1430,7 @@ mn10300_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \n       if (xregno >= FIRST_PSEUDO_REGISTER && xregno != INVALID_REGNUM)\n \t{\n-\t  addr = reg_equiv_mem [xregno];\n+\t  addr = reg_equiv_mem (xregno);\n \t  if (addr)\n \t    addr = XEXP (addr, 0);\n \t}"}, {"sha": "ab6485199b6a14904777e6b5723ba54ae909acb1", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1638,7 +1638,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   if (scratch_reg\n       && reload_in_progress && GET_CODE (operand0) == REG\n       && REGNO (operand0) >= FIRST_PSEUDO_REGISTER)\n-    operand0 = reg_equiv_mem[REGNO (operand0)];\n+    operand0 = reg_equiv_mem (REGNO (operand0));\n   else if (scratch_reg\n \t   && reload_in_progress && GET_CODE (operand0) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operand0)) == REG\n@@ -1647,15 +1647,15 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n \tthe code which tracks sets/uses for delete_output_reload.  */\n       rtx temp = gen_rtx_SUBREG (GET_MODE (operand0),\n-\t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand0))],\n+\t\t\t\t reg_equiv_mem (REGNO (SUBREG_REG (operand0))),\n \t\t\t\t SUBREG_BYTE (operand0));\n       operand0 = alter_subreg (&temp);\n     }\n \n   if (scratch_reg\n       && reload_in_progress && GET_CODE (operand1) == REG\n       && REGNO (operand1) >= FIRST_PSEUDO_REGISTER)\n-    operand1 = reg_equiv_mem[REGNO (operand1)];\n+    operand1 = reg_equiv_mem (REGNO (operand1));\n   else if (scratch_reg\n \t   && reload_in_progress && GET_CODE (operand1) == SUBREG\n \t   && GET_CODE (SUBREG_REG (operand1)) == REG\n@@ -1664,7 +1664,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n \tthe code which tracks sets/uses for delete_output_reload.  */\n       rtx temp = gen_rtx_SUBREG (GET_MODE (operand1),\n-\t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand1))],\n+\t\t\t\t reg_equiv_mem (REGNO (SUBREG_REG (operand1))),\n \t\t\t\t SUBREG_BYTE (operand1));\n       operand1 = alter_subreg (&temp);\n     }"}, {"sha": "c15935417db477eddd30cfe4c9a8002ea9860695", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1676,10 +1676,9 @@ nonindexed_address_p (rtx x, bool strict)\n   rtx xfoo0;\n   if (REG_P (x))\n     {\n-      extern rtx *reg_equiv_mem;\n       if (! reload_in_progress\n-\t  || reg_equiv_mem[REGNO (x)] == 0\n-\t  || indirectable_address_p (reg_equiv_mem[REGNO (x)], strict, false))\n+\t  || reg_equiv_mem (REGNO (x)) == 0\n+\t  || indirectable_address_p (reg_equiv_mem (REGNO (x)), strict, false))\n \treturn true;\n     }\n   if (indirectable_constant_address_p (x, false))"}, {"sha": "5623cc1ba405e60b48da2bdb9f040b248c7be042", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1093,7 +1093,7 @@ fixup_subreg_mem (rtx x)\n     {\n       rtx temp =\n \tgen_rtx_SUBREG (GET_MODE (x),\n-\t\t\treg_equiv_mem [REGNO (SUBREG_REG (x))],\n+\t\t\treg_equiv_mem (REGNO (SUBREG_REG (x))),\n \t\t\tSUBREG_BYTE (x));\n       x = alter_subreg (&temp);\n     }"}, {"sha": "af103e5fece87f891d2c3ebe933b3d92f241ff39", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -35,6 +35,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"output.h\"\n #include \"recog.h\"\n+/* For reg_equivs.  */\n+#include \"reload.h\"\n #include \"integrate.h\"\n #include \"except.h\"\n #include \"function.h\"\n@@ -330,7 +332,7 @@ struct rtl_opt_pass pass_initial_value_sets =\n /* If the backend knows where to allocate pseudos for hard\n    register initial values, register these allocations now.  */\n void\n-allocate_initial_values (rtx *reg_equiv_memory_loc)\n+allocate_initial_values (VEC (reg_equivs_t, gc) *reg_equivs)\n {\n   if (targetm.allocate_initial_value)\n     {\n@@ -348,7 +350,7 @@ allocate_initial_values (rtx *reg_equiv_memory_loc)\n \t  if (x && REG_N_SETS (REGNO (ivs->entries[i].pseudo)) <= 1)\n \t    {\n \t      if (MEM_P (x))\n-\t\treg_equiv_memory_loc[regno] = x;\n+\t\treg_equiv_memory_loc (regno) = x;\n \t      else\n \t\t{\n \t\t  basic_block bb;"}, {"sha": "e32a92abff33b30d65be3a247e983e72a9af20ec", "filename": "gcc/integrate.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -25,7 +25,6 @@ extern rtx has_hard_reg_initial_val (enum machine_mode, unsigned int);\n extern rtx get_hard_reg_initial_reg (rtx);\n /* Called from rest_of_compilation.  */\n extern unsigned int emit_initial_value_sets (void);\n-extern void allocate_initial_values (rtx *);\n \n /* Check whether there's any attribute in a function declaration that\n    makes the function uninlinable.  Returns false if it finds any,"}, {"sha": "0e0d0beda60d893699d23f952b404c304901fc29", "filename": "gcc/ira.c", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -1836,15 +1836,15 @@ rtx *ira_reg_equiv_const;\n static void\n find_reg_equiv_invariant_const (void)\n {\n-  int i;\n+  unsigned int i;\n   bool invariant_p;\n   rtx list, insn, note, constant, x;\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < reg_equiv_init_size; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < VEC_length (reg_equivs_t, reg_equivs); i++)\n     {\n       constant = NULL_RTX;\n       invariant_p = false;\n-      for (list = reg_equiv_init[i]; list != NULL_RTX; list = XEXP (list, 1))\n+      for (list = reg_equiv_init (i); list != NULL_RTX; list = XEXP (list, 1))\n \t{\n \t  insn = XEXP (list, 0);\n \t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n@@ -2104,17 +2104,18 @@ check_allocation (void)\n static void\n fix_reg_equiv_init (void)\n {\n-  int max_regno = max_reg_num ();\n-  int i, new_regno;\n+  unsigned int max_regno = max_reg_num ();\n+  int i, new_regno, max;\n   rtx x, prev, next, insn, set;\n \n-  if (reg_equiv_init_size < max_regno)\n+  if (VEC_length (reg_equivs_t, reg_equivs) < max_regno)\n     {\n-      reg_equiv_init = GGC_RESIZEVEC (rtx, reg_equiv_init, max_regno);\n-      while (reg_equiv_init_size < max_regno)\n-\treg_equiv_init[reg_equiv_init_size++] = NULL_RTX;\n-      for (i = FIRST_PSEUDO_REGISTER; i < reg_equiv_init_size; i++)\n-\tfor (prev = NULL_RTX, x = reg_equiv_init[i]; x != NULL_RTX; x = next)\n+      max = VEC_length (reg_equivs_t, reg_equivs);\n+      grow_reg_equivs ();\n+      for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n+\tfor (prev = NULL_RTX, x = reg_equiv_init (i);\n+\t     x != NULL_RTX;\n+\t     x = next)\n \t  {\n \t    next = XEXP (x, 1);\n \t    insn = XEXP (x, 0);\n@@ -2136,11 +2137,11 @@ fix_reg_equiv_init (void)\n \t    else\n \t      {\n \t\tif (prev == NULL_RTX)\n-\t\t  reg_equiv_init[i] = next;\n+\t\t  reg_equiv_init (i) = next;\n \t\telse\n \t\t  XEXP (prev, 1) = next;\n-\t\tXEXP (x, 1) = reg_equiv_init[new_regno];\n-\t\treg_equiv_init[new_regno] = x;\n+\t\tXEXP (x, 1) = reg_equiv_init (new_regno);\n+\t\treg_equiv_init (new_regno) = x;\n \t      }\n \t  }\n     }\n@@ -2645,7 +2646,7 @@ no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED,\n      should keep their initialization insns.  */\n   if (reg_equiv[regno].is_arg_equivalence)\n     return;\n-  reg_equiv_init[regno] = NULL_RTX;\n+  reg_equiv_init (regno) = NULL_RTX;\n   for (; list; list =  XEXP (list, 1))\n     {\n       rtx insn = XEXP (list, 0);\n@@ -2697,8 +2698,7 @@ update_equiv_regs (void)\n   recorded_label_ref = 0;\n \n   reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n-  reg_equiv_init = ggc_alloc_cleared_vec_rtx (max_regno);\n-  reg_equiv_init_size = max_regno;\n+  grow_reg_equivs ();\n \n   init_alias_analysis ();\n \n@@ -2763,8 +2763,8 @@ update_equiv_regs (void)\n \n \t      /* Record for reload that this is an equivalencing insn.  */\n \t      if (rtx_equal_p (src, XEXP (note, 0)))\n-\t\treg_equiv_init[regno]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n+\t\treg_equiv_init (regno)\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init (regno));\n \n \t      /* Continue normally in case this is a candidate for\n \t\t replacements.  */\n@@ -2864,8 +2864,8 @@ update_equiv_regs (void)\n \t      /* If we haven't done so, record for reload that this is an\n \t\t equivalencing insn.  */\n \t      if (!reg_equiv[regno].is_arg_equivalence)\n-\t\treg_equiv_init[regno]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n+\t\treg_equiv_init (regno)\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init (regno));\n \n \t      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n \t\t We might end up substituting the LABEL_REF for uses of the\n@@ -2965,7 +2965,7 @@ update_equiv_regs (void)\n \t    {\n \t      /* This insn makes the equivalence, not the one initializing\n \t\t the register.  */\n-\t      reg_equiv_init[regno]\n+\t      reg_equiv_init (regno)\n \t\t= gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n \t      df_notes_rescan (init_insn);\n \t    }\n@@ -3068,7 +3068,7 @@ update_equiv_regs (void)\n \t\t      reg_equiv[regno].init_insns\n \t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n \n-\t\t      reg_equiv_init[regno] = NULL_RTX;\n+\t\t      reg_equiv_init (regno) = NULL_RTX;\n \t\t      bitmap_set_bit (cleared_regs, regno);\n \t\t    }\n \t\t  /* Move the initialization of the register to just before\n@@ -3101,7 +3101,7 @@ update_equiv_regs (void)\n \t\t      if (insn == BB_HEAD (bb))\n \t\t\tBB_HEAD (bb) = PREV_INSN (insn);\n \n-\t\t      reg_equiv_init[regno]\n+\t\t      reg_equiv_init (regno)\n \t\t\t= gen_rtx_INSN_LIST (VOIDmode, new_insn, NULL_RTX);\n \t\t      bitmap_set_bit (cleared_regs, regno);\n \t\t    }\n@@ -3481,19 +3481,8 @@ build_insn_chain (void)\n   if (dump_file)\n     print_insn_chains (dump_file);\n }\n-\f\n-/* Allocate memory for reg_equiv_memory_loc.  */\n-static void\n-init_reg_equiv_memory_loc (void)\n-{\n-  max_regno = max_reg_num ();\n \n-  /* And the reg_equiv_memory_loc array.  */\n-  VEC_safe_grow (rtx, gc, reg_equiv_memory_loc_vec, max_regno);\n-  memset (VEC_address (rtx, reg_equiv_memory_loc_vec), 0,\n-\t  sizeof (rtx) * max_regno);\n-  reg_equiv_memory_loc = VEC_address (rtx, reg_equiv_memory_loc_vec);\n-}\n+\f\n \n /* All natural loops.  */\n struct loops ira_loops;\n@@ -3599,8 +3588,6 @@ ira (FILE *f)\n   record_loop_exits ();\n   current_loops = &ira_loops;\n \n-  init_reg_equiv_memory_loc ();\n-\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"Building IRA IR\\n\");\n   loops_p = ira_build (optimize\n@@ -3670,7 +3657,7 @@ ira (FILE *f)\n   if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n     df_analyze ();\n \n-  init_reg_equiv_memory_loc ();\n+  grow_reg_equivs ();\n \n   if (max_regno != max_regno_before_ira)\n     {\n@@ -3680,7 +3667,7 @@ ira (FILE *f)\n       regstat_compute_ri ();\n     }\n \n-  allocate_initial_values (reg_equiv_memory_loc);\n+  allocate_initial_values (reg_equivs);\n \n   overall_cost_before = ira_overall_cost;\n   if (ira_conflicts_p)"}, {"sha": "582371f212de831a697cb04d5191258c7a79a33f", "filename": "gcc/reload.c", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -300,13 +300,13 @@ push_reg_equiv_alt_mem (int regno, rtx mem)\n {\n   rtx it;\n \n-  for (it = reg_equiv_alt_mem_list [regno]; it; it = XEXP (it, 1))\n+  for (it = reg_equiv_alt_mem_list (regno); it; it = XEXP (it, 1))\n     if (rtx_equal_p (XEXP (it, 0), mem))\n       return;\n \n-  reg_equiv_alt_mem_list [regno]\n+  reg_equiv_alt_mem_list (regno)\n     = alloc_EXPR_LIST (REG_EQUIV, mem,\n-\t\t       reg_equiv_alt_mem_list [regno]);\n+\t\t       reg_equiv_alt_mem_list (regno));\n }\n \f\n /* Determine if any secondary reloads are needed for loading (if IN_P is\n@@ -362,8 +362,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n      might be sensitive to the form of the MEM.  */\n \n   if (REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER\n-      && reg_equiv_mem[REGNO (x)] != 0)\n-    x = reg_equiv_mem[REGNO (x)];\n+      && reg_equiv_mem (REGNO (x)))\n+    x = reg_equiv_mem (REGNO (x));\n \n   sri.icode = CODE_FOR_nothing;\n   sri.prev_sri = prev_sri;\n@@ -949,7 +949,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n       gcc_assert (regno < FIRST_PSEUDO_REGISTER\n \t\t  || reg_renumber[regno] >= 0\n-\t\t  || reg_equiv_constant[regno] == NULL_RTX);\n+\t\t  || reg_equiv_constant (regno) == NULL_RTX);\n     }\n \n   /* reg_equiv_constant only contains constants which are obviously\n@@ -962,7 +962,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n       gcc_assert (regno < FIRST_PSEUDO_REGISTER\n \t\t  || reg_renumber[regno] >= 0\n-\t\t  || reg_equiv_constant[regno] == NULL_RTX);\n+\t\t  || reg_equiv_constant (regno) == NULL_RTX);\n     }\n \n   /* If we have a read-write operand with an address side-effect,\n@@ -2855,10 +2855,10 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      && REG_P (reg)\n \t      && (GET_MODE_SIZE (GET_MODE (reg))\n \t\t  >= GET_MODE_SIZE (GET_MODE (op)))\n-\t      && reg_equiv_constant[REGNO (reg)] == 0)\n+\t      && reg_equiv_constant (REGNO (reg)) == 0)\n \t    set_unique_reg_note (emit_insn_before (gen_rtx_USE (VOIDmode, reg),\n \t\t\t\t\t\t   insn),\n-\t\t\t\t REG_EQUAL, reg_equiv_memory_loc[REGNO (reg)]);\n+\t\t\t\t REG_EQUAL, reg_equiv_memory_loc (REGNO (reg)));\n \n \t  substed_operand[i] = recog_data.operand[i] = op;\n \t}\n@@ -2879,7 +2879,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t     that we don't try to replace it in the insn in which it\n \t     is being set.  */\n \t  int regno = REGNO (recog_data.operand[i]);\n-\t  if (reg_equiv_constant[regno] != 0\n+\t  if (reg_equiv_constant (regno) != 0\n \t      && (set == 0 || &SET_DEST (set) != recog_data.operand_loc[i]))\n \t    {\n \t      /* Record the existing mode so that the check if constants are\n@@ -2889,10 +2889,10 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\toperand_mode[i] = GET_MODE (recog_data.operand[i]);\n \n \t      substed_operand[i] = recog_data.operand[i]\n-\t\t= reg_equiv_constant[regno];\n+\t\t= reg_equiv_constant (regno);\n \t    }\n-\t  if (reg_equiv_memory_loc[regno] != 0\n-\t      && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n+\t  if (reg_equiv_memory_loc (regno) != 0\n+\t      && (reg_equiv_address (regno) != 0 || num_not_at_initial_offset))\n \t    /* We need not give a valid is_set_dest argument since the case\n \t       of a constant equivalence was checked above.  */\n \t    substed_operand[i] = recog_data.operand[i]\n@@ -3280,7 +3280,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t       to override the handling of reg_equiv_address.  */\n \t\t    && !(REG_P (XEXP (operand, 0))\n \t\t\t && (ind_levels == 0\n-\t\t\t     || reg_equiv_address[REGNO (XEXP (operand, 0))] != 0)))\n+\t\t\t     || reg_equiv_address (REGNO (XEXP (operand, 0))) != 0)))\n \t\t  win = 1;\n \t\tbreak;\n \n@@ -3304,9 +3304,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t   loading it into a register; hence it will be\n \t\t\t   offsettable, but we cannot say that reg_equiv_mem\n \t\t\t   is offsettable without checking.  */\n-\t\t\t&& ((reg_equiv_mem[REGNO (operand)] != 0\n-\t\t\t     && offsettable_memref_p (reg_equiv_mem[REGNO (operand)]))\n-\t\t\t    || (reg_equiv_address[REGNO (operand)] != 0))))\n+\t\t\t&& ((reg_equiv_mem (REGNO (operand)) != 0\n+\t\t\t     && offsettable_memref_p (reg_equiv_mem (REGNO (operand))))\n+\t\t\t    || (reg_equiv_address (REGNO (operand)) != 0))))\n \t\t  win = 1;\n \t\tif (CONST_POOL_OK_P (operand)\n \t\t    || MEM_P (operand))\n@@ -3416,9 +3416,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t        else if (REG_P (operand)\n \t\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t\t && reg_renumber[REGNO (operand)] < 0\n-\t\t\t\t && ((reg_equiv_mem[REGNO (operand)] != 0\n-\t\t\t\t      && EXTRA_CONSTRAINT_STR (reg_equiv_mem[REGNO (operand)], c, p))\n-\t\t\t\t     || (reg_equiv_address[REGNO (operand)] != 0)))\n+\t\t\t\t && ((reg_equiv_mem (REGNO (operand)) != 0\n+\t\t\t\t      && EXTRA_CONSTRAINT_STR (reg_equiv_mem (REGNO (operand)), c, p))\n+\t\t\t\t     || (reg_equiv_address (REGNO (operand)) != 0)))\n \t\t\t  win = 1;\n \n \t\t\t/* If we didn't already win, we can reload\n@@ -4652,20 +4652,20 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n     {\n       /* This code is duplicated for speed in find_reloads.  */\n       int regno = REGNO (x);\n-      if (reg_equiv_constant[regno] != 0 && !is_set_dest)\n-\tx = reg_equiv_constant[regno];\n+      if (reg_equiv_constant (regno) != 0 && !is_set_dest)\n+\tx = reg_equiv_constant (regno);\n #if 0\n       /*  This creates (subreg (mem...)) which would cause an unnecessary\n \t  reload of the mem.  */\n-      else if (reg_equiv_mem[regno] != 0)\n-\tx = reg_equiv_mem[regno];\n+      else if (reg_equiv_mem (regno) != 0)\n+\tx = reg_equiv_mem (regno);\n #endif\n-      else if (reg_equiv_memory_loc[regno]\n-\t       && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n+      else if (reg_equiv_memory_loc (regno)\n+\t       && (reg_equiv_address (regno) != 0 || num_not_at_initial_offset))\n \t{\n \t  rtx mem = make_memloc (x, regno);\n-\t  if (reg_equiv_address[regno]\n-\t      || ! rtx_equal_p (mem, reg_equiv_mem[regno]))\n+\t  if (reg_equiv_address (regno)\n+\t      || ! rtx_equal_p (mem, reg_equiv_mem (regno)))\n \t    {\n \t      /* If this is not a toplevel operand, find_reloads doesn't see\n \t\t this substitution.  We have to emit a USE of the pseudo so\n@@ -4715,10 +4715,10 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \n       if (regno >= FIRST_PSEUDO_REGISTER\n \t  && reg_renumber[regno] < 0\n-\t  && reg_equiv_constant[regno] != 0)\n+\t  && reg_equiv_constant (regno) != 0)\n \t{\n \t  tem =\n-\t    simplify_gen_subreg (GET_MODE (x), reg_equiv_constant[regno],\n+\t    simplify_gen_subreg (GET_MODE (x), reg_equiv_constant (regno),\n \t\t\t\t GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n \t  gcc_assert (tem);\n \t  if (CONSTANT_P (tem) && !LEGITIMATE_CONSTANT_P (tem))\n@@ -4751,12 +4751,12 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \t       && (GET_MODE_SIZE (GET_MODE (x))\n \t\t   <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n #endif\n-\t       && (reg_equiv_address[regno] != 0\n-\t\t   || (reg_equiv_mem[regno] != 0\n+\t       && (reg_equiv_address (regno) != 0\n+\t\t   || (reg_equiv_mem (regno) != 0\n \t\t       && (! strict_memory_address_addr_space_p\n-\t\t\t       (GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),\n-\t\t\t\tMEM_ADDR_SPACE (reg_equiv_mem[regno]))\n-\t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])\n+\t\t\t       (GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n+\t\t\t\tMEM_ADDR_SPACE (reg_equiv_mem (regno)))\n+\t\t\t   || ! offsettable_memref_p (reg_equiv_mem (regno))\n \t\t\t   || num_not_at_initial_offset))))\n \tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n \t\t\t\t\t   insn, address_reloaded);\n@@ -4794,20 +4794,20 @@ make_memloc (rtx ad, int regno)\n   /* We must rerun eliminate_regs, in case the elimination\n      offsets have changed.  */\n   rtx tem\n-    = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], VOIDmode, NULL_RTX),\n+    = XEXP (eliminate_regs (reg_equiv_memory_loc (regno), VOIDmode, NULL_RTX),\n \t    0);\n \n   /* If TEM might contain a pseudo, we must copy it to avoid\n      modifying it when we do the substitution for the reload.  */\n   if (rtx_varies_p (tem, 0))\n     tem = copy_rtx (tem);\n \n-  tem = replace_equiv_address_nv (reg_equiv_memory_loc[regno], tem);\n+  tem = replace_equiv_address_nv (reg_equiv_memory_loc (regno), tem);\n   tem = adjust_address_nv (tem, GET_MODE (ad), 0);\n \n   /* Copy the result if it's still the same as the equivalence, to avoid\n      modifying it when we do the substitution for the reload.  */\n-  if (tem == reg_equiv_memory_loc[regno])\n+  if (tem == reg_equiv_memory_loc (regno))\n     tem = copy_rtx (tem);\n   return tem;\n }\n@@ -4876,18 +4876,18 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n     {\n       regno = REGNO (ad);\n \n-      if (reg_equiv_constant[regno] != 0)\n+      if (reg_equiv_constant (regno) != 0)\n \t{\n-\t  find_reloads_address_part (reg_equiv_constant[regno], loc,\n+\t  find_reloads_address_part (reg_equiv_constant (regno), loc,\n \t\t\t\t     base_reg_class (mode, MEM, SCRATCH),\n \t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n \t  return 1;\n \t}\n \n-      tem = reg_equiv_memory_loc[regno];\n+      tem = reg_equiv_memory_loc (regno);\n       if (tem != 0)\n \t{\n-\t  if (reg_equiv_address[regno] != 0 || num_not_at_initial_offset)\n+\t  if (reg_equiv_address (regno) != 0 || num_not_at_initial_offset)\n \t    {\n \t      tem = make_memloc (ad, regno);\n \t      if (! strict_memory_address_addr_space_p (GET_MODE (tem),\n@@ -4919,7 +4919,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t     in the final reload pass.  */\n \t\t  if (replace_reloads\n \t\t      && num_not_at_initial_offset\n-\t\t      && ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t\t      && ! rtx_equal_p (tem, reg_equiv_mem (regno)))\n \t\t    {\n \t\t      *loc = tem;\n \t\t      /* We mark the USE with QImode so that we\n@@ -4965,7 +4965,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n       if (GET_CODE (ad) == PLUS\n \t  && CONST_INT_P (XEXP (ad, 1))\n \t  && REG_P (XEXP (ad, 0))\n-\t  && reg_equiv_constant[REGNO (XEXP (ad, 0))] == 0)\n+\t  && reg_equiv_constant (REGNO (XEXP (ad, 0))) == 0)\n \treturn 0;\n \n       subst_reg_equivs_changed = 0;\n@@ -5282,15 +5282,15 @@ subst_reg_equivs (rtx ad, rtx insn)\n       {\n \tint regno = REGNO (ad);\n \n-\tif (reg_equiv_constant[regno] != 0)\n+\tif (reg_equiv_constant (regno) != 0)\n \t  {\n \t    subst_reg_equivs_changed = 1;\n-\t    return reg_equiv_constant[regno];\n+\t    return reg_equiv_constant (regno);\n \t  }\n-\tif (reg_equiv_memory_loc[regno] && num_not_at_initial_offset)\n+\tif (reg_equiv_memory_loc (regno) && num_not_at_initial_offset)\n \t  {\n \t    rtx mem = make_memloc (ad, regno);\n-\t    if (! rtx_equal_p (mem, reg_equiv_mem[regno]))\n+\t    if (! rtx_equal_p (mem, reg_equiv_mem (regno)))\n \t      {\n \t\tsubst_reg_equivs_changed = 1;\n \t\t/* We mark the USE with QImode so that we recognize it\n@@ -5393,13 +5393,13 @@ subst_indexed_address (rtx addr)\n       if (REG_P (op0)\n \t  && (regno = REGNO (op0)) >= FIRST_PSEUDO_REGISTER\n \t  && reg_renumber[regno] < 0\n-\t  && reg_equiv_constant[regno] != 0)\n-\top0 = reg_equiv_constant[regno];\n+\t  && reg_equiv_constant (regno) != 0)\n+\top0 = reg_equiv_constant (regno);\n       else if (REG_P (op1)\n \t       && (regno = REGNO (op1)) >= FIRST_PSEUDO_REGISTER\n \t       && reg_renumber[regno] < 0\n-\t       && reg_equiv_constant[regno] != 0)\n-\top1 = reg_equiv_constant[regno];\n+\t       && reg_equiv_constant (regno) != 0)\n+\top1 = reg_equiv_constant (regno);\n       else if (GET_CODE (op0) == PLUS\n \t       && (tem = subst_indexed_address (op0)) != op0)\n \top0 = tem;\n@@ -5688,18 +5688,18 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \n \t/* A register that is incremented cannot be constant!  */\n \tgcc_assert (regno < FIRST_PSEUDO_REGISTER\n-\t\t    || reg_equiv_constant[regno] == 0);\n+\t\t    || reg_equiv_constant (regno) == 0);\n \n \t/* Handle a register that is equivalent to a memory location\n \t    which cannot be addressed directly.  */\n-\tif (reg_equiv_memory_loc[regno] != 0\n-\t    && (reg_equiv_address[regno] != 0\n+\tif (reg_equiv_memory_loc (regno) != 0\n+\t    && (reg_equiv_address (regno) != 0\n \t\t|| num_not_at_initial_offset))\n \t  {\n \t    rtx tem = make_memloc (XEXP (x, 0), regno);\n \n-\t    if (reg_equiv_address[regno]\n-\t\t|| ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t    if (reg_equiv_address (regno)\n+\t\t|| ! rtx_equal_p (tem, reg_equiv_mem (regno)))\n \t      {\n \t\trtx orig = tem;\n \n@@ -5759,16 +5759,16 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \n \t  /* A register that is incremented cannot be constant!  */\n \t  gcc_assert (regno < FIRST_PSEUDO_REGISTER\n-\t\t      || reg_equiv_constant[regno] == 0);\n+\t\t      || reg_equiv_constant (regno) == 0);\n \n \t  /* Handle a register that is equivalent to a memory location\n \t     which cannot be addressed directly.  */\n-\t  if (reg_equiv_memory_loc[regno] != 0\n-\t      && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n+\t  if (reg_equiv_memory_loc (regno) != 0\n+\t      && (reg_equiv_address (regno) != 0 || num_not_at_initial_offset))\n \t    {\n \t      rtx tem = make_memloc (XEXP (x, 0), regno);\n-\t      if (reg_equiv_address[regno]\n-\t\t  || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t      if (reg_equiv_address (regno)\n+\t\t  || ! rtx_equal_p (tem, reg_equiv_mem (regno)))\n \t\t{\n \t\t  rtx orig = tem;\n \n@@ -5818,7 +5818,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t Also don't do this if we can probably update x directly.  */\n \t      rtx equiv = (MEM_P (XEXP (x, 0))\n \t\t\t   ? XEXP (x, 0)\n-\t\t\t   : reg_equiv_mem[regno]);\n+\t\t\t   : reg_equiv_mem (regno));\n \t      enum insn_code icode = optab_handler (add_optab, GET_MODE (x));\n \t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n@@ -5904,31 +5904,31 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n       {\n \tint regno = REGNO (x);\n \n-\tif (reg_equiv_constant[regno] != 0)\n+\tif (reg_equiv_constant (regno) != 0)\n \t  {\n-\t    find_reloads_address_part (reg_equiv_constant[regno], loc,\n+\t    find_reloads_address_part (reg_equiv_constant (regno), loc,\n \t\t\t\t       context_reg_class,\n \t\t\t\t       GET_MODE (x), opnum, type, ind_levels);\n \t    return 1;\n \t  }\n \n #if 0 /* This might screw code in reload1.c to delete prior output-reload\n \t that feeds this insn.  */\n-\tif (reg_equiv_mem[regno] != 0)\n+\tif (reg_equiv_mem (regno) != 0)\n \t  {\n-\t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*) 0,\n+\t    push_reload (reg_equiv_mem (regno), NULL_RTX, loc, (rtx*) 0,\n \t\t\t context_reg_class,\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n \t  }\n #endif\n \n-\tif (reg_equiv_memory_loc[regno]\n-\t    && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n+\tif (reg_equiv_memory_loc (regno)\n+\t    && (reg_equiv_address (regno) != 0 || num_not_at_initial_offset))\n \t  {\n \t    rtx tem = make_memloc (x, regno);\n-\t    if (reg_equiv_address[regno] != 0\n-\t\t|| ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t    if (reg_equiv_address (regno) != 0\n+\t\t|| ! rtx_equal_p (tem, reg_equiv_mem (regno)))\n \t      {\n \t\tx = tem;\n \t\tfind_reloads_address (GET_MODE (x), &x, XEXP (x, 0),\n@@ -6103,13 +6103,13 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n   int regno = REGNO (SUBREG_REG (x));\n   int reloaded = 0;\n \n-  if (reg_equiv_memory_loc[regno])\n+  if (reg_equiv_memory_loc (regno))\n     {\n       /* If the address is not directly addressable, or if the address is not\n \t offsettable, then it must be replaced.  */\n       if (! force_replace\n-\t  && (reg_equiv_address[regno]\n-\t      || ! offsettable_memref_p (reg_equiv_mem[regno])))\n+\t  && (reg_equiv_address (regno)\n+\t      || ! offsettable_memref_p (reg_equiv_mem (regno))))\n \tforce_replace = 1;\n \n       if (force_replace || num_not_at_initial_offset)\n@@ -6119,7 +6119,7 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t  /* If the address changes because of register elimination, then\n \t     it must be replaced.  */\n \t  if (force_replace\n-\t      || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t      || ! rtx_equal_p (tem, reg_equiv_mem (regno)))\n \t    {\n \t      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));\n \t      unsigned inner_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n@@ -6189,10 +6189,10 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t If find_reloads_address already completed replaced\n \t\t the address, there is nothing further to do.  */\n \t      if (reloaded == 0\n-\t\t  && reg_equiv_mem[regno] != 0\n+\t\t  && reg_equiv_mem (regno) != 0\n \t\t  && !strict_memory_address_addr_space_p\n-\t\t\t(GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),\n-\t\t\t MEM_ADDR_SPACE (reg_equiv_mem[regno])))\n+\t\t\t(GET_MODE (x), XEXP (reg_equiv_mem (regno), 0),\n+\t\t\t MEM_ADDR_SPACE (reg_equiv_mem (regno))))\n \t\t{\n \t\t  push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n \t\t\t       base_reg_class (GET_MODE (tem), MEM, SCRATCH),\n@@ -6255,14 +6255,14 @@ subst_reloads (rtx insn)\n \t  for (check_regno = 0; check_regno < max_regno; check_regno++)\n \t    {\n #define CHECK_MODF(ARRAY)\t\t\t\t\t\t\\\n-\t      gcc_assert (!ARRAY[check_regno]\t\t\t\t\\\n+\t      gcc_assert (!VEC_index (reg_equivs_t, reg_equivs, check_regno).ARRAY\t\t\\\n \t\t\t  || !loc_mentioned_in_p (r->where,\t\t\\\n-\t\t\t\t\t\t  ARRAY[check_regno]))\n+\t\t\t\t\t\t  VEC_index (reg_equivs_t, reg_equivs, check_regno).ARRAY))\n \n-\t      CHECK_MODF (reg_equiv_constant);\n-\t      CHECK_MODF (reg_equiv_memory_loc);\n-\t      CHECK_MODF (reg_equiv_address);\n-\t      CHECK_MODF (reg_equiv_mem);\n+\t      CHECK_MODF (equiv_constant);\n+\t      CHECK_MODF (equiv_memory_loc);\n+\t      CHECK_MODF (equiv_address);\n+\t      CHECK_MODF (equiv_mem);\n #undef CHECK_MODF\n \t    }\n #endif /* DEBUG_RELOAD */\n@@ -6490,12 +6490,12 @@ refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,\n \t X must therefore either be a constant or be in memory.  */\n       if (r >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  if (reg_equiv_memory_loc[r])\n+\t  if (reg_equiv_memory_loc (r))\n \t    return refers_to_regno_for_reload_p (regno, endregno,\n-\t\t\t\t\t\t reg_equiv_memory_loc[r],\n+\t\t\t\t\t\t reg_equiv_memory_loc (r),\n \t\t\t\t\t\t (rtx*) 0);\n \n-\t  gcc_assert (reg_equiv_constant[r] || reg_equiv_invariant[r]);\n+\t  gcc_assert (reg_equiv_constant (r) || reg_equiv_invariant (r));\n \t  return 0;\n \t}\n \n@@ -6625,9 +6625,9 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  if (reg_equiv_memory_loc[regno])\n+\t  if (reg_equiv_memory_loc (regno))\n \t    return refers_to_mem_for_reload_p (in);\n-\t  gcc_assert (reg_equiv_constant[regno]);\n+\t  gcc_assert (reg_equiv_constant (regno));\n \t  return 0;\n \t}\n \n@@ -6678,7 +6678,7 @@ refers_to_mem_for_reload_p (rtx x)\n \n   if (REG_P (x))\n     return (REGNO (x) >= FIRST_PSEUDO_REGISTER\n-\t    && reg_equiv_memory_loc[REGNO (x)]);\n+\t    && reg_equiv_memory_loc (REGNO (x)));\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n@@ -7032,7 +7032,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n \t\t       && ! push_operand (dest, GET_MODE (dest)))\n \t\treturn 0;\n \t      else if (MEM_P (dest) && regno >= FIRST_PSEUDO_REGISTER\n-\t\t       && reg_equiv_memory_loc[regno] != 0)\n+\t\t       && reg_equiv_memory_loc (regno) != 0)\n \t\treturn 0;\n \t      else if (need_stable_sp && push_operand (dest, GET_MODE (dest)))\n \t\treturn 0;\n@@ -7077,7 +7077,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n \t\t\t       && ! push_operand (dest, GET_MODE (dest)))\n \t\t\treturn 0;\n \t\t      else if (MEM_P (dest) && regno >= FIRST_PSEUDO_REGISTER\n-\t\t\t       && reg_equiv_memory_loc[regno] != 0)\n+\t\t\t       && reg_equiv_memory_loc (regno) != 0)\n \t\t\treturn 0;\n \t\t      else if (need_stable_sp\n \t\t\t       && push_operand (dest, GET_MODE (dest)))"}, {"sha": "baa75482d78a55cdc4d919c590600558cfde33a4", "filename": "gcc/reload.h", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -100,7 +100,7 @@ struct reload\n   int inc;\n   /* A reg for which reload_in is the equivalent.\n      If reload_in is a symbol_ref which came from\n-     reg_equiv_constant, then this is the pseudo\n+     reg_equiv_consant, then this is the pseudo\n      which has that symbol_ref as equivalent.  */\n   rtx in_reg;\n   rtx out_reg;\n@@ -204,20 +204,62 @@ extern struct target_reload *this_target_reload;\n #define caller_save_initialized_p \\\n   (this_target_reload->x_caller_save_initialized_p)\n \n-extern GTY (()) VEC(rtx,gc) *reg_equiv_memory_loc_vec;\n-extern rtx *reg_equiv_constant;\n-extern rtx *reg_equiv_invariant;\n-extern rtx *reg_equiv_memory_loc;\n-extern rtx *reg_equiv_address;\n-extern rtx *reg_equiv_mem;\n-extern rtx *reg_equiv_alt_mem_list;\n-\n-/* Element N is the list of insns that initialized reg N from its equivalent\n-   constant or memory slot.  */\n-extern GTY((length(\"reg_equiv_init_size\"))) rtx *reg_equiv_init;\n-\n-/* The size of the previous array, for GC purposes.  */\n-extern GTY(()) int reg_equiv_init_size;\n+/* Register equivalences.  Indexed by register number.  */\n+typedef struct reg_equivs\n+{\n+  /* The constant value to which pseudo reg N is equivalent,\n+     or zero if pseudo reg N is not equivalent to a constant.\n+     find_reloads looks at this in order to replace pseudo reg N\n+     with the constant it stands for.  */\n+  rtx constant;\n+\n+  /* An invariant value to which pseudo reg N is equivalent.\n+     eliminate_regs_in_insn uses this to replace pseudos in particular\n+     contexts.  */\n+  rtx invariant;\n+\n+  /* A memory location to which pseudo reg N is equivalent,\n+     prior to any register elimination (such as frame pointer to stack\n+     pointer).  Depending on whether or not it is a valid address, this value\n+     is transferred to either equiv_address or equiv_mem.  */\n+  rtx memory_loc;\n+\n+  /* The address of stack slot to which pseudo reg N is equivalent.\n+     This is used when the address is not valid as a memory address\n+     (because its displacement is too big for the machine.)  */\n+  rtx address;\n+\n+  /* The memory slot to which pseudo reg N is equivalent,\n+     or zero if pseudo reg N is not equivalent to a memory slot.  */\n+  rtx mem;\n+\n+  /* An EXPR_LIST of REG_EQUIVs containing MEMs with\n+     alternate representations of the location of pseudo reg N.  */\n+  rtx alt_mem_list;\n+\n+  /* The list of insns that initialized reg N from its equivalent\n+     constant or memory slot.  */\n+  rtx init;\n+} reg_equivs_t;\n+\n+#define reg_equiv_constant(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->constant\n+#define reg_equiv_invariant(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->invariant\n+#define reg_equiv_memory_loc(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->memory_loc\n+#define reg_equiv_address(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->address\n+#define reg_equiv_mem(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->mem\n+#define reg_equiv_alt_mem_list(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->alt_mem_list\n+#define reg_equiv_init(ELT) \\\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT))->init\n+\n+DEF_VEC_O(reg_equivs_t);\n+DEF_VEC_ALLOC_O(reg_equivs_t, gc);\n+extern VEC(reg_equivs_t,gc) *reg_equivs;\n \n /* All the \"earlyclobber\" operands of the current insn\n    are recorded here.  */\n@@ -420,3 +462,10 @@ extern void debug_reload (void);\n /* Compute the actual register we should reload to, in case we're\n    reloading to/from a register that is wider than a word.  */\n extern rtx reload_adjust_reg_for_mode (rtx, enum machine_mode);\n+\n+/* Ideally this function would be in ira.c or reload, but due to dependencies\n+   on integrate.h, it's part of integrate.c.  */\n+extern void allocate_initial_values (VEC (reg_equivs_t, gc) *);\n+\n+/* Allocate or grow the reg_equiv tables, initializing new entries to 0.  */\n+extern void grow_reg_equivs (void);"}, {"sha": "6dde9a2f90f6753cd29c9a48f73cd0a7f6527d63", "filename": "gcc/reload1.c", "status": "modified", "additions": 135, "deletions": 155, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2034d064c29d9620c5562b2b5b517bdc6c7a672/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f2034d064c29d9620c5562b2b5b517bdc6c7a672", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"obstack.h\"\n #include \"insn-config.h\"\n+#include \"ggc.h\"\n #include \"flags.h\"\n #include \"function.h\"\n #include \"expr.h\"\n@@ -101,48 +102,9 @@ static regset_head reg_has_output_reload;\n    in the current insn.  */\n static HARD_REG_SET reg_is_output_reload;\n \n-/* Element N is the constant value to which pseudo reg N is equivalent,\n-   or zero if pseudo reg N is not equivalent to a constant.\n-   find_reloads looks at this in order to replace pseudo reg N\n-   with the constant it stands for.  */\n-rtx *reg_equiv_constant;\n-\n-/* Element N is an invariant value to which pseudo reg N is equivalent.\n-   eliminate_regs_in_insn uses this to replace pseudos in particular\n-   contexts.  */\n-rtx *reg_equiv_invariant;\n-\n-/* Element N is a memory location to which pseudo reg N is equivalent,\n-   prior to any register elimination (such as frame pointer to stack\n-   pointer).  Depending on whether or not it is a valid address, this value\n-   is transferred to either reg_equiv_address or reg_equiv_mem.  */\n-rtx *reg_equiv_memory_loc;\n-\n-/* We allocate reg_equiv_memory_loc inside a varray so that the garbage\n-   collector can keep track of what is inside.  */\n-VEC(rtx,gc) *reg_equiv_memory_loc_vec;\n-\n-/* Element N is the address of stack slot to which pseudo reg N is equivalent.\n-   This is used when the address is not valid as a memory address\n-   (because its displacement is too big for the machine.)  */\n-rtx *reg_equiv_address;\n-\n-/* Element N is the memory slot to which pseudo reg N is equivalent,\n-   or zero if pseudo reg N is not equivalent to a memory slot.  */\n-rtx *reg_equiv_mem;\n-\n-/* Element N is an EXPR_LIST of REG_EQUIVs containing MEMs with\n-   alternate representations of the location of pseudo reg N.  */\n-rtx *reg_equiv_alt_mem_list;\n-\n /* Widest width in which each pseudo reg is referred to (via subreg).  */\n static unsigned int *reg_max_ref_width;\n \n-/* Element N is the list of insns that initialized reg N from its equivalent\n-   constant or memory slot.  */\n-rtx *reg_equiv_init;\n-int reg_equiv_init_size;\n-\n /* Vector to remember old contents of reg_renumber before spilling.  */\n static short *reg_old_renumber;\n \n@@ -362,6 +324,8 @@ static int first_label_num;\n static char *offsets_known_at;\n static HOST_WIDE_INT (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n+VEC(reg_equivs_t,gc) *reg_equivs;\n+\n /* Stack of addresses where an rtx has been changed.  We can undo the \n    changes by popping items off the stack and restoring the original\n    value at each location. \n@@ -596,14 +560,14 @@ replace_pseudos_in (rtx *loc, enum machine_mode mem_mode, rtx usage)\n \t  return;\n \t}\n \n-      if (reg_equiv_constant[regno])\n-\t*loc = reg_equiv_constant[regno];\n-      else if (reg_equiv_invariant[regno])\n-\t*loc = reg_equiv_invariant[regno];\n-      else if (reg_equiv_mem[regno])\n-\t*loc = reg_equiv_mem[regno];\n-      else if (reg_equiv_address[regno])\n-\t*loc = gen_rtx_MEM (GET_MODE (x), reg_equiv_address[regno]);\n+      if (reg_equiv_constant (regno))\n+\t*loc = reg_equiv_constant (regno);\n+      else if (reg_equiv_invariant (regno))\n+\t*loc = reg_equiv_invariant (regno);\n+      else if (reg_equiv_mem (regno))\n+\t*loc = reg_equiv_mem (regno);\n+      else if (reg_equiv_address (regno))\n+\t*loc = gen_rtx_MEM (GET_MODE (x), reg_equiv_address (regno));\n       else\n \t{\n \t  gcc_assert (!REG_P (regno_reg_rtx[regno])\n@@ -682,6 +646,26 @@ has_nonexceptional_receiver (void)\n   return false;\n }\n \n+/* Grow (or allocate) the REG_EQUIVS array from its current size (which may be\n+   zero elements) to MAX_REG_NUM elements.\n+\n+   Initialize all new fields to NULL and update REG_EQUIVS_SIZE.  */\n+void\n+grow_reg_equivs (void)\n+{\n+  int old_size = VEC_length (reg_equivs_t, reg_equivs);\n+  int max_regno = max_reg_num ();\n+  int i;\n+\n+  VEC_reserve (reg_equivs_t, gc, reg_equivs, max_regno);\n+  for (i = old_size; i < max_regno; i++)\n+    {\n+      VEC_quick_insert (reg_equivs_t, reg_equivs, i, 0);\n+      memset (VEC_index (reg_equivs_t, reg_equivs, i), 0, sizeof (reg_equivs_t));\n+    }\n+    \n+}\n+\n \f\n /* Global variables used by reload and its subroutines.  */\n \n@@ -769,6 +753,18 @@ reload (rtx first, int global)\n       if (! call_used_regs[i] && ! fixed_regs[i] && ! LOCAL_REGNO (i))\n \tdf_set_regs_ever_live (i, true);\n \n+  /* Find all the pseudo registers that didn't get hard regs\n+     but do have known equivalent constants or memory slots.\n+     These include parameters (known equivalent to parameter slots)\n+     and cse'd or loop-moved constant memory addresses.\n+\n+     Record constant equivalents in reg_equiv_constant\n+     so they will be substituted by find_reloads.\n+     Record memory equivalents in reg_mem_equiv so they can\n+     be substituted eventually by altering the REG-rtx's.  */\n+\n+  grow_reg_equivs ();\n+  reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n   reg_old_renumber = XCNEWVEC (short, max_regno);\n   memcpy (reg_old_renumber, reg_renumber, max_regno * sizeof (short));\n   pseudo_forbidden_regs = XNEWVEC (HARD_REG_SET, max_regno);\n@@ -882,15 +878,15 @@ reload (rtx first, int global)\n \t so this problem goes away.  But that's very hairy.  */\n \n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-\tif (reg_renumber[i] < 0 && reg_equiv_memory_loc[i])\n+\tif (reg_renumber[i] < 0 && reg_equiv_memory_loc (i))\n \t  {\n-\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], VOIDmode,\n+\t    rtx x = eliminate_regs (reg_equiv_memory_loc (i), VOIDmode,\n \t\t\t\t    NULL_RTX);\n \n \t    if (strict_memory_address_addr_space_p\n \t\t  (GET_MODE (regno_reg_rtx[i]), XEXP (x, 0),\n \t\t   MEM_ADDR_SPACE (x)))\n-\t      reg_equiv_mem[i] = x, reg_equiv_address[i] = 0;\n+\t      reg_equiv_mem (i) = x, reg_equiv_address (i) = 0;\n \t    else if (CONSTANT_P (XEXP (x, 0))\n \t\t     || (REG_P (XEXP (x, 0))\n \t\t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n@@ -899,7 +895,7 @@ reload (rtx first, int global)\n \t\t\t && (REGNO (XEXP (XEXP (x, 0), 0))\n \t\t\t     < FIRST_PSEUDO_REGISTER)\n \t\t\t && CONSTANT_P (XEXP (XEXP (x, 0), 1))))\n-\t      reg_equiv_address[i] = XEXP (x, 0), reg_equiv_mem[i] = 0;\n+\t      reg_equiv_mem (i) = XEXP (x, 0), reg_equiv_mem (i) = 0;\n \t    else\n \t      {\n \t\t/* Make a new stack slot.  Then indicate that something\n@@ -908,8 +904,8 @@ reload (rtx first, int global)\n \t\t   below might change some offset.  reg_equiv_{mem,address}\n \t\t   will be set up for this pseudo on the next pass around\n \t\t   the loop.  */\n-\t\treg_equiv_memory_loc[i] = 0;\n-\t\treg_equiv_init[i] = 0;\n+\t\treg_equiv_memory_loc (i) = 0;\n+\t\treg_equiv_init (i) = 0;\n \t\talter_reg (i, -1, true);\n \t      }\n \t  }\n@@ -1023,10 +1019,10 @@ reload (rtx first, int global)\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n-      if (reg_renumber[i] < 0 && reg_equiv_init[i] != 0)\n+      if (reg_renumber[i] < 0 && reg_equiv_init (i) != 0)\n \t{\n \t  rtx list;\n-\t  for (list = reg_equiv_init[i]; list; list = XEXP (list, 1))\n+\t  for (list = reg_equiv_init (i); list; list = XEXP (list, 1))\n \t    {\n \t      rtx equiv_insn = XEXP (list, 0);\n \n@@ -1094,11 +1090,11 @@ reload (rtx first, int global)\n     {\n       rtx addr = 0;\n \n-      if (reg_equiv_mem[i])\n-\taddr = XEXP (reg_equiv_mem[i], 0);\n+      if (reg_equiv_mem (i))\n+\taddr = XEXP (reg_equiv_mem (i), 0);\n \n-      if (reg_equiv_address[i])\n-\taddr = reg_equiv_address[i];\n+      if (reg_equiv_address (i))\n+\taddr = reg_equiv_address (i);\n \n       if (addr)\n \t{\n@@ -1109,17 +1105,17 @@ reload (rtx first, int global)\n \t      REG_USERVAR_P (reg) = 0;\n \t      PUT_CODE (reg, MEM);\n \t      XEXP (reg, 0) = addr;\n-\t      if (reg_equiv_memory_loc[i])\n-\t\tMEM_COPY_ATTRIBUTES (reg, reg_equiv_memory_loc[i]);\n+\t      if (reg_equiv_memory_loc (i))\n+\t\tMEM_COPY_ATTRIBUTES (reg, reg_equiv_memory_loc (i));\n \t      else\n \t\t{\n \t\t  MEM_IN_STRUCT_P (reg) = MEM_SCALAR_P (reg) = 0;\n \t\t  MEM_ATTRS (reg) = 0;\n \t\t}\n \t      MEM_NOTRAP_P (reg) = 1;\n \t    }\n-\t  else if (reg_equiv_mem[i])\n-\t    XEXP (reg_equiv_mem[i], 0) = addr;\n+\t  else if (reg_equiv_mem (i))\n+\t    XEXP (reg_equiv_mem (i), 0) = addr;\n \t}\n \n       /* We don't want complex addressing modes in debug insns\n@@ -1131,10 +1127,10 @@ reload (rtx first, int global)\n \t  rtx equiv = 0;\n \t  df_ref use, next;\n \n-\t  if (reg_equiv_constant[i])\n-\t    equiv = reg_equiv_constant[i];\n-\t  else if (reg_equiv_invariant[i])\n-\t    equiv = reg_equiv_invariant[i];\n+\t  if (reg_equiv_constant (i))\n+\t    equiv = reg_equiv_constant (i);\n+\t  else if (reg_equiv_invariant (i))\n+\t    equiv = reg_equiv_invariant (i);\n \t  else if (reg && MEM_P (reg))\n \t    equiv = targetm.delegitimize_address (reg);\n \t  else if (reg && REG_P (reg) && (int)REGNO (reg) != i)\n@@ -1287,7 +1283,7 @@ reload (rtx first, int global)\n \n   /* Indicate that we no longer have known memory locations or constants.  */\n   free_reg_equiv ();\n-  reg_equiv_init = 0;\n+\n   free (reg_max_ref_width);\n   free (reg_old_renumber);\n   free (pseudo_previous_regs);\n@@ -1509,9 +1505,9 @@ calculate_needs_all_insns (int global)\n \t  /* Skip insns that only set an equivalence.  */\n \t  if (set && REG_P (SET_DEST (set))\n \t      && reg_renumber[REGNO (SET_DEST (set))] < 0\n-\t      && (reg_equiv_constant[REGNO (SET_DEST (set))]\n-\t\t  || (reg_equiv_invariant[REGNO (SET_DEST (set))]))\n-\t\t      && reg_equiv_init[REGNO (SET_DEST (set))])\n+\t      && (reg_equiv_constant (REGNO (SET_DEST (set)))\n+\t\t  || (reg_equiv_invariant (REGNO (SET_DEST (set)))))\n+\t\t      && reg_equiv_init (REGNO (SET_DEST (set))))\n \t    continue;\n \n \t  /* If needed, eliminate any eliminable registers.  */\n@@ -1540,12 +1536,10 @@ calculate_needs_all_insns (int global)\n \t\t   || (REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))\n \t\t       && reg_renumber[REGNO (SET_SRC (set))] < 0\n \t\t       && reg_renumber[REGNO (SET_DEST (set))] < 0\n-\t\t       && reg_equiv_memory_loc[REGNO (SET_SRC (set))] != NULL\n-\t\t       && reg_equiv_memory_loc[REGNO (SET_DEST (set))] != NULL\n-\t\t       && rtx_equal_p (reg_equiv_memory_loc\n-\t\t\t\t       [REGNO (SET_SRC (set))],\n-\t\t\t\t       reg_equiv_memory_loc\n-\t\t\t\t       [REGNO (SET_DEST (set))]))))\n+\t\t       && reg_equiv_memory_loc (REGNO (SET_SRC (set))) != NULL\n+\t\t       && reg_equiv_memory_loc (REGNO (SET_DEST (set))) != NULL\n+\t\t       && rtx_equal_p (reg_equiv_memory_loc (REGNO (SET_SRC (set))),\n+\t\t\t\t       reg_equiv_memory_loc (REGNO (SET_DEST (set)))))))\n \t\t{\n \t\t  if (ira_conflicts_p)\n \t\t    /* Inform IRA about the insn deletion.  */\n@@ -1636,11 +1630,11 @@ calculate_elim_costs_all_insns (void)\n \t      /* Skip insns that only set an equivalence.  */\n \t      if (set && REG_P (SET_DEST (set))\n \t\t  && reg_renumber[REGNO (SET_DEST (set))] < 0\n-\t\t  && (reg_equiv_constant[REGNO (SET_DEST (set))]\n-\t\t      || (reg_equiv_invariant[REGNO (SET_DEST (set))])))\n+\t\t  && (reg_equiv_constant (REGNO (SET_DEST (set)))\n+\t\t      || reg_equiv_invariant (REGNO (SET_DEST (set)))))\n \t\t{\n \t\t  unsigned regno = REGNO (SET_DEST (set));\n-\t\t  rtx init = reg_equiv_init[regno];\n+\t\t  rtx init = reg_equiv_init (regno);\n \t\t  if (init)\n \t\t    {\n \t\t      rtx t = eliminate_regs_1 (SET_SRC (set), VOIDmode, insn,\n@@ -1664,9 +1658,9 @@ calculate_elim_costs_all_insns (void)\n     }\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n-      if (reg_equiv_invariant[i])\n+      if (reg_equiv_invariant (i))\n \t{\n-\t  if (reg_equiv_init[i])\n+\t  if (reg_equiv_init (i))\n \t    {\n \t      int cost = reg_equiv_init_cost[i];\n \t      if (dump_file)\n@@ -1686,7 +1680,6 @@ calculate_elim_costs_all_insns (void)\n \t}\n     }\n \n-  free_reg_equiv ();\n   free (reg_equiv_init_cost);\n }\n \f\n@@ -2173,9 +2166,10 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \n   if (reg_renumber[i] < 0\n       && REG_N_REFS (i) > 0\n-      && reg_equiv_constant[i] == 0\n-      && (reg_equiv_invariant[i] == 0 || reg_equiv_init[i] == 0)\n-      && reg_equiv_memory_loc[i] == 0)\n+      && reg_equiv_constant (i) == 0\n+      && (reg_equiv_invariant (i) == 0\n+\t  || reg_equiv_init (i) == 0)\n+      && reg_equiv_memory_loc (i) == 0)\n     {\n       rtx x = NULL_RTX;\n       enum machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n@@ -2299,7 +2293,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       set_mem_attrs_for_spill (x);\n \n       /* Save the stack slot for later.  */\n-      reg_equiv_memory_loc[i] = x;\n+      reg_equiv_memory_loc (i) = x;\n     }\n }\n \n@@ -2494,10 +2488,10 @@ note_reg_elim_costly (rtx *px, void *data)\n \n   if (REG_P (x)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n-      && reg_equiv_init[REGNO (x)]\n-      && reg_equiv_invariant[REGNO (x)])\n+      && reg_equiv_init (REGNO (x))\n+      && reg_equiv_invariant (REGNO (x)))\n     {\n-      rtx t = reg_equiv_invariant[REGNO (x)];\n+      rtx t = reg_equiv_invariant (REGNO (x));\n       rtx new_rtx = eliminate_regs_1 (t, Pmode, insn, true, true);\n       int cost = rtx_cost (new_rtx, SET, optimize_bb_for_speed_p (elim_bb));\n       int freq = REG_FREQ_FROM_BB (elim_bb);\n@@ -2582,14 +2576,15 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \n \t}\n       else if (reg_renumber && reg_renumber[regno] < 0\n-\t       && reg_equiv_invariant && reg_equiv_invariant[regno])\n+\t       && reg_equivs\n+\t       && reg_equiv_invariant (regno))\n \t{\n \t  if (may_use_invariant || (insn && DEBUG_INSN_P (insn)))\n-\t    return eliminate_regs_1 (copy_rtx (reg_equiv_invariant[regno]),\n+\t    return eliminate_regs_1 (copy_rtx (reg_equiv_invariant (regno)),\n \t\t\t             mem_mode, insn, true, for_costs);\n \t  /* There exists at least one use of REGNO that cannot be\n \t     eliminated.  Prevent the defining insn from being deleted.  */\n-\t  reg_equiv_init[regno] = NULL_RTX;\n+\t  reg_equiv_init (regno) = NULL_RTX;\n \t  if (!for_costs)\n \t    alter_reg (regno, -1, true);\n \t}\n@@ -2666,14 +2661,14 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t    if (GET_CODE (new0) == PLUS && REG_P (new1)\n \t\t&& REGNO (new1) >= FIRST_PSEUDO_REGISTER\n \t\t&& reg_renumber[REGNO (new1)] < 0\n-\t\t&& reg_equiv_constant != 0\n-\t\t&& reg_equiv_constant[REGNO (new1)] != 0)\n-\t      new1 = reg_equiv_constant[REGNO (new1)];\n+\t\t&& reg_equivs\n+\t\t&& reg_equiv_constant (REGNO (new1)) != 0)\n+\t      new1 = reg_equiv_constant (REGNO (new1));\n \t    else if (GET_CODE (new1) == PLUS && REG_P (new0)\n \t\t     && REGNO (new0) >= FIRST_PSEUDO_REGISTER\n \t\t     && reg_renumber[REGNO (new0)] < 0\n-\t\t     && reg_equiv_constant[REGNO (new0)] != 0)\n-\t      new0 = reg_equiv_constant[REGNO (new0)];\n+\t\t     && reg_equiv_constant (REGNO (new0)) != 0)\n+\t      new0 = reg_equiv_constant (REGNO (new0));\n \n \t    new_rtx = form_sum (GET_MODE (x), new0, new1);\n \n@@ -2835,14 +2830,13 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n       if (REG_P (SUBREG_REG (x))\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t  && reg_equiv_memory_loc != 0\n-\t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n+\t  && reg_equivs\n+\t  && reg_equiv_memory_loc (REGNO (SUBREG_REG (x))) != 0)\n \t{\n \t  new_rtx = SUBREG_REG (x);\n \t}\n       else\n-\tnew_rtx = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false,\n-\t\t\t\t    for_costs);\n+\tnew_rtx = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false, for_costs);\n \n       if (new_rtx != SUBREG_REG (x))\n \t{\n@@ -3002,10 +2996,11 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n \t      }\n \n \t}\n-      else if (reg_renumber[regno] < 0 && reg_equiv_constant\n-\t       && reg_equiv_constant[regno]\n-\t       && ! function_invariant_p (reg_equiv_constant[regno]))\n-\telimination_effects (reg_equiv_constant[regno], mem_mode);\n+      else if (reg_renumber[regno] < 0\n+\t       && reg_equiv_constant (0)\n+\t       && reg_equiv_constant (regno)\n+\t       && ! function_invariant_p (reg_equiv_constant (regno)))\n+\telimination_effects (reg_equiv_constant (regno), mem_mode);\n       return;\n \n     case PRE_INC:\n@@ -3073,8 +3068,8 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n       if (REG_P (SUBREG_REG (x))\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t  && reg_equiv_memory_loc != 0\n-\t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n+\t  && reg_equivs != 0\n+\t  && reg_equiv_memory_loc (REGNO (SUBREG_REG (x))) != 0)\n \treturn;\n \n       elimination_effects (SUBREG_REG (x), mem_mode);\n@@ -4100,11 +4095,7 @@ init_eliminable_invariants (rtx first, bool do_subregs)\n   int i;\n   rtx insn;\n \n-  reg_equiv_constant = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_invariant = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_mem = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_alt_mem_list = XCNEWVEC (rtx, max_regno);\n-  reg_equiv_address = XCNEWVEC (rtx, max_regno);\n+  grow_reg_equivs ();\n   if (do_subregs)\n     reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n   else\n@@ -4166,49 +4157,49 @@ init_eliminable_invariants (rtx first, bool do_subregs)\n \t\t  /* Always unshare the equivalence, so we can\n \t\t     substitute into this insn without touching the\n \t\t       equivalence.  */\n-\t\t  reg_equiv_memory_loc[i] = copy_rtx (x);\n+\t\t  reg_equiv_memory_loc (i) = copy_rtx (x);\n \t\t}\n \t      else if (function_invariant_p (x))\n \t\t{\n \t\t  if (GET_CODE (x) == PLUS)\n \t\t    {\n \t\t      /* This is PLUS of frame pointer and a constant,\n \t\t\t and might be shared.  Unshare it.  */\n-\t\t      reg_equiv_invariant[i] = copy_rtx (x);\n+\t\t      reg_equiv_invariant (i) = copy_rtx (x);\n \t\t      num_eliminable_invariants++;\n \t\t    }\n \t\t  else if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n \t\t    {\n-\t\t      reg_equiv_invariant[i] = x;\n+\t\t      reg_equiv_invariant (i) = x;\n \t\t      num_eliminable_invariants++;\n \t\t    }\n \t\t  else if (LEGITIMATE_CONSTANT_P (x))\n-\t\t    reg_equiv_constant[i] = x;\n+\t\t    reg_equiv_constant (i) = x;\n \t\t  else\n \t\t    {\n-\t\t      reg_equiv_memory_loc[i]\n+\t\t      reg_equiv_memory_loc (i)\n \t\t\t= force_const_mem (GET_MODE (SET_DEST (set)), x);\n-\t\t      if (! reg_equiv_memory_loc[i])\n-\t\t\treg_equiv_init[i] = NULL_RTX;\n+\t\t      if (! reg_equiv_memory_loc (i))\n+\t\t\treg_equiv_init (i) = NULL_RTX;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n-\t\t  reg_equiv_init[i] = NULL_RTX;\n+\t\t  reg_equiv_init (i) = NULL_RTX;\n \t\t  continue;\n \t\t}\n \t    }\n \t  else\n-\t    reg_equiv_init[i] = NULL_RTX;\n+\t    reg_equiv_init (i) = NULL_RTX;\n \t}\n     }\n \n   if (dump_file)\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-      if (reg_equiv_init[i])\n+      if (reg_equiv_init (i))\n \t{\n \t  fprintf (dump_file, \"init_insns for %u: \", i);\n-\t  print_inline_rtx (dump_file, reg_equiv_init[i], 20);\n+\t  print_inline_rtx (dump_file, reg_equiv_init (i), 20);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n }\n@@ -4221,14 +4212,6 @@ free_reg_equiv (void)\n {\n   int i;\n \n-  if (reg_equiv_constant)\n-    free (reg_equiv_constant);\n-  if (reg_equiv_invariant)\n-    free (reg_equiv_invariant);\n-  reg_equiv_constant = 0;\n-  reg_equiv_invariant = 0;\n-  VEC_free (rtx, gc, reg_equiv_memory_loc_vec);\n-  reg_equiv_memory_loc = 0;\n \n   if (offsets_known_at)\n     free (offsets_known_at);\n@@ -4238,12 +4221,11 @@ free_reg_equiv (void)\n   offsets_known_at = 0;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (reg_equiv_alt_mem_list[i])\n-      free_EXPR_LIST_list (&reg_equiv_alt_mem_list[i]);\n-  free (reg_equiv_alt_mem_list);\n+    if (reg_equiv_alt_mem_list (i))\n+      free_EXPR_LIST_list (&reg_equiv_alt_mem_list (i));\n+  VEC_free (reg_equivs_t, gc, reg_equivs);\n+  reg_equivs = NULL;\n \n-  free (reg_equiv_mem);\n-  free (reg_equiv_address);\n }\n \f\n /* Kick all pseudos out of hard register REGNO.\n@@ -7299,31 +7281,31 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \ttmp = SUBREG_REG (tmp);\n       if (REG_P (tmp)\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n-\t  && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n-\t      || reg_equiv_constant[REGNO (tmp)] != 0))\n+\t  && (reg_equiv_memory_loc (REGNO (tmp)) != 0\n+\t      || reg_equiv_constant (REGNO (tmp)) != 0))\n \t{\n-\t  if (! reg_equiv_mem[REGNO (tmp)]\n+\t  if (! reg_equiv_mem (REGNO (tmp))\n \t      || num_not_at_initial_offset\n \t      || GET_CODE (oldequiv) == SUBREG)\n \t    real_oldequiv = rl->in;\n \t  else\n-\t    real_oldequiv = reg_equiv_mem[REGNO (tmp)];\n+\t    real_oldequiv = reg_equiv_mem (REGNO (tmp));\n \t}\n \n       tmp = old;\n       if (GET_CODE (tmp) == SUBREG)\n \ttmp = SUBREG_REG (tmp);\n       if (REG_P (tmp)\n \t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n-\t  && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n-\t      || reg_equiv_constant[REGNO (tmp)] != 0))\n+\t  && (reg_equiv_memory_loc (REGNO (tmp)) != 0\n+\t      || reg_equiv_constant (REGNO (tmp)) != 0))\n \t{\n-\t  if (! reg_equiv_mem[REGNO (tmp)]\n+\t  if (! reg_equiv_mem (REGNO (tmp))\n \t      || num_not_at_initial_offset\n \t      || GET_CODE (old) == SUBREG)\n \t    real_old = rl->in;\n \t  else\n-\t    real_old = reg_equiv_mem[REGNO (tmp)];\n+\t    real_old = reg_equiv_mem (REGNO (tmp));\n \t}\n \n       second_reload_reg = rld[secondary_reload].reg_rtx;\n@@ -7493,16 +7475,14 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n       if ((REG_P (oldequiv)\n \t   && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n-\t   && (reg_equiv_memory_loc[REGNO (oldequiv)] != 0\n-\t       || reg_equiv_constant[REGNO (oldequiv)] != 0))\n+\t   && (reg_equiv_memory_loc (REGNO (oldequiv)) != 0\n+\t       || reg_equiv_constant (REGNO (oldequiv)) != 0))\n \t  || (GET_CODE (oldequiv) == SUBREG\n \t      && REG_P (SUBREG_REG (oldequiv))\n \t      && (REGNO (SUBREG_REG (oldequiv))\n \t\t  >= FIRST_PSEUDO_REGISTER)\n-\t      && ((reg_equiv_memory_loc\n-\t\t   [REGNO (SUBREG_REG (oldequiv))] != 0)\n-\t\t  || (reg_equiv_constant\n-\t\t      [REGNO (SUBREG_REG (oldequiv))] != 0)))\n+\t      && ((reg_equiv_memory_loc (REGNO (SUBREG_REG (oldequiv))) != 0)\n+\t\t  || (reg_equiv_constant (REGNO (SUBREG_REG (oldequiv))) != 0)))\n \t  || (CONSTANT_P (oldequiv)\n \t      && (targetm.preferred_reload_class (oldequiv,\n \t\t\t\t\t\t  REGNO_REG_CLASS (REGNO (reloadreg)))\n@@ -7560,8 +7540,8 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n       int tertiary_reload = rld[secondary_reload].secondary_out_reload;\n \n       if (REG_P (old) && REGNO (old) >= FIRST_PSEUDO_REGISTER\n-\t  && reg_equiv_mem[REGNO (old)] != 0)\n-\treal_old = reg_equiv_mem[REGNO (old)];\n+\t  && reg_equiv_mem (REGNO (old)) != 0)\n+\treal_old = reg_equiv_mem (REGNO (old));\n \n       if (secondary_reload_class (0, rl->rclass, mode, real_old) != NO_REGS)\n \t{\n@@ -8690,7 +8670,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n \n   while (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n-  substed = reg_equiv_memory_loc[REGNO (reg)];\n+  substed = reg_equiv_memory_loc (REGNO (reg));\n \n   /* This is unsafe if the operand occurs more often in the current\n      insn than it is inherited.  */\n@@ -8723,7 +8703,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n     n_occurrences += count_occurrences (PATTERN (insn),\n \t\t\t\t\teliminate_regs (substed, VOIDmode,\n \t\t\t\t\t\t\tNULL_RTX), 0);\n-  for (i1 = reg_equiv_alt_mem_list[REGNO (reg)]; i1; i1 = XEXP (i1, 1))\n+  for (i1 = reg_equiv_alt_mem_list (REGNO (reg)); i1; i1 = XEXP (i1, 1))\n     {\n       gcc_assert (!rtx_equal_p (XEXP (i1, 0), substed));\n       n_occurrences += count_occurrences (PATTERN (insn), XEXP (i1, 0), 0);"}]}