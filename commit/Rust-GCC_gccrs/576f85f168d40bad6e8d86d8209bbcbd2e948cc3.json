{"sha": "576f85f168d40bad6e8d86d8209bbcbd2e948cc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc2Zjg1ZjE2OGQ0MGJhZDZlOGQ4NmQ4MjA5YmJjYmQyZTk0OGNjMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-04-01T02:41:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-04-01T02:41:12Z"}, "message": "dwarf2out.c (dw_separate_line_info_ref): Remove.\n\n        * dwarf2out.c (dw_separate_line_info_ref): Remove.\n        (dw_separate_line_info_entry): Remove.\n        (enum dw_line_info_opcode): New.\n        (dw_line_info_entry): Use it.\n        (dw_line_info_table, dw_line_info_table_p): New.\n        (DWARF_LINE_OPCODE_BASE): Include dwarf3 opcodes.\n        (line_info_table, line_info_label_num): Remove.\n        (line_info_table_in_use): Remove.\n        (separate_line_info_table): Remove.\n        (separate_line_info_table_allocated): Remove.\n        (separate_line_info_table_in_use): Remove.\n        (LINE_INFO_TABLE_INCREMENT): Remove.\n        (line_info_label_num): New.\n        (cur_line_info_table): New.\n        (text_section_line_info, cold_text_section_line_info): New.\n        (separate_line_info): New.\n        (SEPARATE_LINE_CODE_LABEL): Remove.\n        (print_dwarf_line_table): Remove.\n        (debug_dwarf): Don't dump it.\n        (output_one_line_info_table): New.\n        (output_line_info): Use it.\n        (new_line_info_table): New.\n        (set_cur_line_info_table): New.\n        (dwarf2out_switch_text_section): Use it.\n        (dwarf2out_begin_function): Likewise.\n        (push_dw_line_info_entry): New.\n        (dwarf2out_source_line): Rewrite for new line info tables.\n        (dwarf2out_init): Remove dead initailizations.\n\nFrom-SVN: r171816", "tree": {"sha": "216266cfc14e3de892e11f7670a4160412dc9862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216266cfc14e3de892e11f7670a4160412dc9862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/576f85f168d40bad6e8d86d8209bbcbd2e948cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576f85f168d40bad6e8d86d8209bbcbd2e948cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576f85f168d40bad6e8d86d8209bbcbd2e948cc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576f85f168d40bad6e8d86d8209bbcbd2e948cc3/comments", "author": null, "committer": null, "parents": [{"sha": "6979fa58f82f6e29197498ac25ad101e616aa391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6979fa58f82f6e29197498ac25ad101e616aa391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6979fa58f82f6e29197498ac25ad101e616aa391"}], "stats": {"total": 768, "additions": 369, "deletions": 399}, "files": [{"sha": "292e421d15718260dad01e897c46fd80abaed296", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576f85f168d40bad6e8d86d8209bbcbd2e948cc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576f85f168d40bad6e8d86d8209bbcbd2e948cc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=576f85f168d40bad6e8d86d8209bbcbd2e948cc3", "patch": "@@ -1,3 +1,34 @@\n+2011-03-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (dw_separate_line_info_ref): Remove.\n+\t(dw_separate_line_info_entry): Remove.\n+\t(enum dw_line_info_opcode): New.\n+\t(dw_line_info_entry): Use it.\n+\t(dw_line_info_table, dw_line_info_table_p): New.\n+\t(DWARF_LINE_OPCODE_BASE): Include dwarf3 opcodes.\n+\t(line_info_table, line_info_label_num): Remove.\n+\t(line_info_table_in_use): Remove.\n+\t(separate_line_info_table): Remove.\n+\t(separate_line_info_table_allocated): Remove.\n+\t(separate_line_info_table_in_use): Remove.\n+\t(LINE_INFO_TABLE_INCREMENT): Remove.\n+\t(line_info_label_num): New.\n+\t(cur_line_info_table): New.\n+\t(text_section_line_info, cold_text_section_line_info): New.\n+\t(separate_line_info): New.\n+\t(SEPARATE_LINE_CODE_LABEL): Remove.\n+\t(print_dwarf_line_table): Remove.\n+\t(debug_dwarf): Don't dump it.\n+\t(output_one_line_info_table): New.\n+\t(output_line_info): Use it.\n+\t(new_line_info_table): New.\n+\t(set_cur_line_info_table): New.\n+\t(dwarf2out_switch_text_section): Use it.\n+\t(dwarf2out_begin_function): Likewise.\n+\t(push_dw_line_info_entry): New.\n+\t(dwarf2out_source_line): Rewrite for new line info tables.\n+\t(dwarf2out_init): Remove dead initailizations.\n+\n 2011-03-31  Joseph Myers  <joseph@codesourcery.com>\n \n \t* opts.h (cl_option): Add comments to fields.  Add bit-fields for"}, {"sha": "4b7afe49364cb9526323bd091b0789d94cb3c16c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 338, "deletions": 399, "changes": 737, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576f85f168d40bad6e8d86d8209bbcbd2e948cc3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576f85f168d40bad6e8d86d8209bbcbd2e948cc3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=576f85f168d40bad6e8d86d8209bbcbd2e948cc3", "patch": "@@ -4242,6 +4242,7 @@ dwarf2out_note_section_used (void)\n }\n \n static void var_location_switch_text_section (void);\n+static void set_cur_line_info_table (section *);\n \n void\n dwarf2out_switch_text_section (void)\n@@ -4298,6 +4299,8 @@ dwarf2out_switch_text_section (void)\n       cfi = cfi->dw_cfi_next;\n   fde->dw_fde_switch_cfi = cfi;\n   var_location_switch_text_section ();\n+\n+  set_cur_line_info_table (sect);\n }\n \f\n /* And now, the subset of the debugging information support code necessary\n@@ -5819,31 +5822,70 @@ typedef long int dw_offset;\n \n typedef struct dw_attr_struct *dw_attr_ref;\n typedef struct dw_line_info_struct *dw_line_info_ref;\n-typedef struct dw_separate_line_info_struct *dw_separate_line_info_ref;\n typedef struct pubname_struct *pubname_ref;\n typedef struct dw_ranges_struct *dw_ranges_ref;\n typedef struct dw_ranges_by_label_struct *dw_ranges_by_label_ref;\n typedef struct comdat_type_struct *comdat_type_node_ref;\n \n-/* Each entry in the line_info_table maintains the file and\n-   line number associated with the label generated for that\n-   entry.  The label gives the PC value associated with\n-   the line number entry.  */\n+/* The entries in the line_info table more-or-less mirror the opcodes\n+   that are used in the real dwarf line table.  Arrays of these entries\n+   are collected per section when DWARF2_ASM_LINE_DEBUG_INFO is not\n+   supported.  */\n+\n+enum dw_line_info_opcode {\n+  /* Emit DW_LNE_set_address; the operand is the label index.  */\n+  LI_set_address,\n+\n+  /* Emit a row to the matrix with the given line.  This may be done\n+     via any combination of DW_LNS_copy, DW_LNS_advance_line, and\n+     special opcodes.  */\n+  LI_set_line,\n+\n+  /* Emit a DW_LNS_set_file.  */\n+  LI_set_file,\n+\n+  /* Emit a DW_LNS_set_column.  */\n+  LI_set_column,\n+\n+  /* Emit a DW_LNS_negate_stmt; the operand is ignored.  */\n+  LI_negate_stmt,\n+\n+  /* Emit a DW_LNS_set_prologue_end/epilogue_begin; the operand is ignored.  */\n+  LI_set_prologue_end,\n+  LI_set_epilogue_begin,\n+\n+  /* Emit a DW_LNE_set_discriminator.  */\n+  LI_set_discriminator\n+};\n \n typedef struct GTY(()) dw_line_info_struct {\n-  unsigned long dw_file_num;\n-  unsigned long dw_line_num;\n-}\n-dw_line_info_entry;\n+  enum dw_line_info_opcode opcode;\n+  unsigned int val;\n+} dw_line_info_entry;\n \n-/* Line information for functions in separate sections; each one gets its\n-   own sequence.  */\n-typedef struct GTY(()) dw_separate_line_info_struct {\n-  unsigned long dw_file_num;\n-  unsigned long dw_line_num;\n-  unsigned long function;\n-}\n-dw_separate_line_info_entry;\n+DEF_VEC_O(dw_line_info_entry);\n+DEF_VEC_ALLOC_O(dw_line_info_entry, gc);\n+\n+typedef struct GTY(()) dw_line_info_table_struct {\n+  /* The label that marks the end of this section.  */\n+  const char *end_label;\n+\n+  /* The values for the last row of the matrix, as collected in the table.\n+     These are used to minimize the changes to the next row.  */\n+  unsigned int file_num;\n+  unsigned int line_num;\n+  unsigned int column_num;\n+  int discrim_num;\n+  bool is_stmt;\n+  bool in_use;\n+\n+  VEC(dw_line_info_entry, gc) *entries;\n+} dw_line_info_table;\n+\n+typedef dw_line_info_table *dw_line_info_table_p;\n+\n+DEF_VEC_P(dw_line_info_table_p);\n+DEF_VEC_ALLOC_P(dw_line_info_table_p, gc);\n \n /* Each DIE attribute has a field specifying the attribute kind,\n    a link to the next attribute in the chain, and an attribute value.\n@@ -6021,7 +6063,7 @@ skeleton_chain_node;\n #define DWARF_LINE_BASE  -10\n \n /* First special line opcode - leave room for the standard opcodes.  */\n-#define DWARF_LINE_OPCODE_BASE  10\n+#define DWARF_LINE_OPCODE_BASE  ((int)DW_LNS_set_isa + 1)\n \n /* Range of line offsets in a special line info. opcode.  */\n #define DWARF_LINE_RANGE  (254-DWARF_LINE_OPCODE_BASE+1)\n@@ -6166,31 +6208,20 @@ static GTY(()) unsigned abbrev_die_table_in_use;\n    abbrev_die_table.  */\n #define ABBREV_DIE_TABLE_INCREMENT 256\n \n-/* A pointer to the base of a table that contains line information\n-   for each source code line in .text in the compilation unit.  */\n-static GTY((length (\"line_info_table_allocated\")))\n-     dw_line_info_ref line_info_table;\n+/* A global counter for generating labels for line number data.  */\n+static unsigned int line_info_label_num;\n \n-/* Number of elements currently allocated for line_info_table.  */\n-static GTY(()) unsigned line_info_table_allocated;\n+/* The current table to which we should emit line number information\n+   for the current function.  This will be set up at the beginning of\n+   assembly for the function.  */\n+static dw_line_info_table *cur_line_info_table;\n \n-/* Number of elements in line_info_table currently in use.  */\n-static GTY(()) unsigned line_info_table_in_use;\n+/* The two default tables of line number info.  */\n+static GTY(()) dw_line_info_table *text_section_line_info;\n+static GTY(()) dw_line_info_table *cold_text_section_line_info;\n \n-/* A pointer to the base of a table that contains line information\n-   for each source code line outside of .text in the compilation unit.  */\n-static GTY ((length (\"separate_line_info_table_allocated\")))\n-     dw_separate_line_info_ref separate_line_info_table;\n-\n-/* Number of elements currently allocated for separate_line_info_table.  */\n-static GTY(()) unsigned separate_line_info_table_allocated;\n-\n-/* Number of elements in separate_line_info_table currently in use.  */\n-static GTY(()) unsigned separate_line_info_table_in_use;\n-\n-/* Size (in elements) of increments by which we may expand the\n-   line_info_table.  */\n-#define LINE_INFO_TABLE_INCREMENT 1024\n+/* The set of all non-default tables of line number info.  */\n+static GTY(()) VEC (dw_line_info_table_p, gc) *separate_line_info;\n \n /* A flag to tell pubnames/types export if there is an info section to\n    refer to.  */\n@@ -6343,7 +6374,6 @@ static void equate_decl_number_to_die (tree, dw_die_ref);\n static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *);\n static void print_spaces (FILE *);\n static void print_die (dw_die_ref, FILE *);\n-static void print_dwarf_line_table (FILE *);\n static dw_die_ref push_new_compile_unit (dw_die_ref, dw_die_ref);\n static dw_die_ref pop_compile_unit (dw_die_ref);\n static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);\n@@ -6421,6 +6451,7 @@ static unsigned int add_ranges (const_tree);\n static void add_ranges_by_labels (dw_die_ref, const char *, const char *,\n \t\t\t\t  bool *);\n static void output_ranges (void);\n+static dw_line_info_table *new_line_info_table (void);\n static void output_line_info (void);\n static void output_file_names (void);\n static dw_die_ref base_type_die (tree);\n@@ -6662,9 +6693,6 @@ static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef LINE_CODE_LABEL\n #define LINE_CODE_LABEL\t\t\"LM\"\n #endif\n-#ifndef SEPARATE_LINE_CODE_LABEL\n-#define SEPARATE_LINE_CODE_LABEL\t\"LSM\"\n-#endif\n \n \f\n /* Return the root of the DIE's built for the current compilation unit.  */\n@@ -8682,27 +8710,6 @@ print_die (dw_die_ref die, FILE *outfile)\n     fprintf (outfile, \"\\n\");\n }\n \n-/* Print the contents of the source code line number correspondence table.\n-   This routine is a debugging aid only.  */\n-\n-static void\n-print_dwarf_line_table (FILE *outfile)\n-{\n-  unsigned i;\n-  dw_line_info_ref line_info;\n-\n-  fprintf (outfile, \"\\n\\nDWARF source line information\\n\");\n-  for (i = 1; i < line_info_table_in_use; i++)\n-    {\n-      line_info = &line_info_table[i];\n-      fprintf (outfile, \"%5d: %4ld %6ld\\n\", i,\n-\t       line_info->dw_file_num,\n-\t       line_info->dw_line_num);\n-    }\n-\n-  fprintf (outfile, \"\\n\\n\");\n-}\n-\n /* Print the information collected for a given DIE.  */\n \n DEBUG_FUNCTION void\n@@ -8719,8 +8726,6 @@ debug_dwarf (void)\n {\n   print_indent = 0;\n   print_die (comp_unit_die (), stderr);\n-  if (! DWARF2_ASM_LINE_DEBUG_INFO)\n-    print_dwarf_line_table (stderr);\n }\n \f\n /* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU\n@@ -12289,24 +12294,126 @@ output_file_names (void)\n }\n \n \n+/* Output one line number table into the .debug_line section.  */\n+\n+static void\n+output_one_line_info_table (dw_line_info_table *table)\n+{\n+  char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  unsigned int current_line = 1;\n+  bool current_is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;\n+  dw_line_info_entry *ent;\n+  size_t i;\n+\n+  FOR_EACH_VEC_ELT (dw_line_info_entry, table->entries, i, ent)\n+    {\n+      switch (ent->opcode)\n+\t{\n+\tcase LI_set_address:\n+\t  /* ??? Unfortunately, we have little choice here currently, and\n+\t     must always use the most general form.  GCC does not know the\n+\t     address delta itself, so we can't use DW_LNS_advance_pc.  Many\n+\t     ports do have length attributes which will give an upper bound\n+\t     on the address range.  We could perhaps use length attributes\n+\t     to determine when it is safe to use DW_LNS_fixed_advance_pc.  */\n+\t  ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent->val);\n+\n+\t  /* This can handle any delta.  This takes\n+\t     4+DWARF2_ADDR_SIZE bytes.  */\n+\t  dw2_asm_output_data (1, 0, \"set address %s\", line_label);\n+\t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+\t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);\n+\t  break;\n+\n+\tcase LI_set_line:\n+\t  if (ent->val == current_line)\n+\t    {\n+\t      /* We still need to start a new row, so output a copy insn.  */\n+\t      dw2_asm_output_data (1, DW_LNS_copy,\n+\t\t\t\t   \"copy line %u\", current_line);\n+\t    }\n+\t  else\n+\t    {\n+\t      int line_offset = ent->val - current_line;\n+\t      int line_delta = line_offset - DWARF_LINE_BASE;\n+\n+\t      current_line = ent->val;\n+\t      if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n+\t\t{\n+\t\t  /* This can handle deltas from -10 to 234, using the current\n+\t\t     definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.\n+\t\t     This takes 1 byte.  */\n+\t\t  dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE + line_delta,\n+\t\t\t\t       \"line %u\", current_line);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* This can handle any delta.  This takes at least 4 bytes,\n+\t\t     depending on the value being encoded.  */\n+\t\t  dw2_asm_output_data (1, DW_LNS_advance_line,\n+\t\t\t\t       \"advance to line %u\", current_line);\n+\t\t  dw2_asm_output_data_sleb128 (line_offset, NULL);\n+\t\t  dw2_asm_output_data (1, DW_LNS_copy, NULL);\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase LI_set_file:\n+\t  dw2_asm_output_data (1, DW_LNS_set_file, \"set file %u\", ent->val);\n+\t  dw2_asm_output_data_uleb128 (ent->val, \"%u\", ent->val);\n+\t  break;\n+\n+\tcase LI_set_column:\n+\t  dw2_asm_output_data (1, DW_LNS_set_column, \"column %u\", ent->val);\n+\t  dw2_asm_output_data_uleb128 (ent->val, \"%u\", ent->val);\n+\t  break;\n+\n+\tcase LI_negate_stmt:\n+\t  current_is_stmt = !current_is_stmt;\n+\t  dw2_asm_output_data (1, DW_LNS_negate_stmt,\n+\t\t\t       \"is_stmt %d\", current_is_stmt);\n+\t  break;\n+\n+\tcase LI_set_prologue_end:\n+\t  dw2_asm_output_data (1, DW_LNS_set_prologue_end,\n+\t\t\t       \"set prologue end\");\n+\t  break;\n+\t  \n+\tcase LI_set_epilogue_begin:\n+\t  dw2_asm_output_data (1, DW_LNS_set_epilogue_begin,\n+\t\t\t       \"set epilogue begin\");\n+\t  break;\n+\n+\tcase LI_set_discriminator:\n+\t  dw2_asm_output_data (1, 0, \"discriminator %u\", ent->val);\n+\t  dw2_asm_output_data_uleb128 (1 + size_of_uleb128 (ent->val), NULL);\n+\t  dw2_asm_output_data (1, DW_LNE_set_discriminator, NULL);\n+\t  dw2_asm_output_data_uleb128 (ent->val, NULL);\n+\t  break;\n+\t}\n+    }\n+\n+  /* Emit debug info for the address of the end of the table.  */\n+  dw2_asm_output_data (1, 0, \"set address %s\", table->end_label);\n+  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+  dw2_asm_output_addr (DWARF2_ADDR_SIZE, table->end_label, NULL);\n+\n+  dw2_asm_output_data (1, 0, \"end sequence\");\n+  dw2_asm_output_data_uleb128 (1, NULL);\n+  dw2_asm_output_data (1, DW_LNE_end_sequence, NULL);\n+}\n+\n /* Output the source line number correspondence information.  This\n    information goes into the .debug_line section.  */\n \n static void\n output_line_info (void)\n {\n   char l1[20], l2[20], p1[20], p2[20];\n-  char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  char prev_line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  unsigned opc;\n-  unsigned n_op_args;\n-  unsigned long lt_index;\n-  unsigned long current_line;\n-  long line_offset;\n-  long line_delta;\n-  unsigned long current_file;\n-  unsigned long function;\n   int ver = dwarf_version;\n+  int opc;\n \n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n@@ -12324,16 +12431,15 @@ output_line_info (void)\n   dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, \"Prolog Length\");\n   ASM_OUTPUT_LABEL (asm_out_file, p1);\n \n-  /* Define the architecture-dependent minimum instruction length (in\n-   bytes).  In this implementation of DWARF, this field is used for\n-   information purposes only.  Since GCC generates assembly language,\n-   we have no a priori knowledge of how many instruction bytes are\n-   generated for each source line, and therefore can use only the\n-   DW_LNE_set_address and DW_LNS_fixed_advance_pc line information\n-   commands.  Accordingly, we fix this as `1', which is \"correct\n-   enough\" for all architectures, and don't let the target override.  */\n-  dw2_asm_output_data (1, 1,\n-\t\t       \"Minimum Instruction Length\");\n+  /* Define the architecture-dependent minimum instruction length (in bytes).\n+     In this implementation of DWARF, this field is used for information\n+     purposes only.  Since GCC generates assembly language, we have no\n+     a priori knowledge of how many instruction bytes are generated for each\n+     source line, and therefore can use only the DW_LNE_set_address and\n+     DW_LNS_fixed_advance_pc line information commands.  Accordingly, we fix\n+     this as '1', which is \"correct enough\" for all architectures,\n+     and don't let the target override.  */\n+  dw2_asm_output_data (1, 1, \"Minimum Instruction Length\");\n \n   if (ver >= 4)\n     dw2_asm_output_data (1, DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN,\n@@ -12349,13 +12455,15 @@ output_line_info (void)\n \n   for (opc = 1; opc < DWARF_LINE_OPCODE_BASE; opc++)\n     {\n+      int n_op_args;\n       switch (opc)\n \t{\n \tcase DW_LNS_advance_pc:\n \tcase DW_LNS_advance_line:\n \tcase DW_LNS_set_file:\n \tcase DW_LNS_set_column:\n \tcase DW_LNS_fixed_advance_pc:\n+\tcase DW_LNS_set_isa:\n \t  n_op_args = 1;\n \t  break;\n \tdefault:\n@@ -12371,236 +12479,19 @@ output_line_info (void)\n   output_file_names ();\n   ASM_OUTPUT_LABEL (asm_out_file, p2);\n \n-  /* We used to set the address register to the first location in the text\n-     section here, but that didn't accomplish anything since we already\n-     have a line note for the opening brace of the first function.  */\n-\n-  /* Generate the line number to PC correspondence table, encoded as\n-     a series of state machine operations.  */\n-  current_file = 1;\n-  current_line = 1;\n-\n-  if (cfun && in_cold_section_p)\n-    strcpy (prev_line_label, crtl->subsections.cold_section_label);\n-  else\n-    strcpy (prev_line_label, text_section_label);\n-  for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n-    {\n-      dw_line_info_ref line_info = &line_info_table[lt_index];\n-\n-#if 0\n-      /* Disable this optimization for now; GDB wants to see two line notes\n-\t at the beginning of a function so it can find the end of the\n-\t prologue.  */\n-\n-      /* Don't emit anything for redundant notes.  Just updating the\n-\t address doesn't accomplish anything, because we already assume\n-\t that anything after the last address is this line.  */\n-      if (line_info->dw_line_num == current_line\n-\t  && line_info->dw_file_num == current_file)\n-\tcontinue;\n-#endif\n-\n-      /* Emit debug info for the address of the current line.\n-\n-\t Unfortunately, we have little choice here currently, and must always\n-\t use the most general form.  GCC does not know the address delta\n-\t itself, so we can't use DW_LNS_advance_pc.  Many ports do have length\n-\t attributes which will give an upper bound on the address range.  We\n-\t could perhaps use length attributes to determine when it is safe to\n-\t use DW_LNS_fixed_advance_pc.  */\n+  if (text_section_line_info && text_section_line_info->in_use)\n+    output_one_line_info_table (text_section_line_info);\n+  if (cold_text_section_line_info && cold_text_section_line_info->in_use)\n+    output_one_line_info_table (cold_text_section_line_info);\n \n-      ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, lt_index);\n-      if (0)\n-\t{\n-\t  /* This can handle deltas up to 0xffff.  This takes 3 bytes.  */\n-\t  dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n-\t\t\t       \"DW_LNS_fixed_advance_pc\");\n-\t  dw2_asm_output_delta (2, line_label, prev_line_label, NULL);\n-\t}\n-      else\n-\t{\n-\t  /* This can handle any delta.  This takes\n-\t     4+DWARF2_ADDR_SIZE bytes.  */\n-\t  dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n-\t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n-\t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n-\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);\n-\t}\n-\n-      strcpy (prev_line_label, line_label);\n-\n-      /* Emit debug info for the source file of the current line, if\n-\t different from the previous line.  */\n-      if (line_info->dw_file_num != current_file)\n-\t{\n-\t  current_file = line_info->dw_file_num;\n-\t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n-\t  dw2_asm_output_data_uleb128 (current_file, \"%lu\", current_file);\n-\t}\n-\n-      /* Emit debug info for the current line number, choosing the encoding\n-\t that uses the least amount of space.  */\n-      if (line_info->dw_line_num != current_line)\n-\t{\n-\t  line_offset = line_info->dw_line_num - current_line;\n-\t  line_delta = line_offset - DWARF_LINE_BASE;\n-\t  current_line = line_info->dw_line_num;\n-\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n-\t    /* This can handle deltas from -10 to 234, using the current\n-\t       definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This\n-\t       takes 1 byte.  */\n-\t    dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE + line_delta,\n-\t\t\t\t \"line %lu\", current_line);\n-\t  else\n-\t    {\n-\t      /* This can handle any delta.  This takes at least 4 bytes,\n-\t\t depending on the value being encoded.  */\n-\t      dw2_asm_output_data (1, DW_LNS_advance_line,\n-\t\t\t\t   \"advance to line %lu\", current_line);\n-\t      dw2_asm_output_data_sleb128 (line_offset, NULL);\n-\t      dw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n-\t    }\n-\t}\n-      else\n-\t/* We still need to start a new row, so output a copy insn.  */\n-\tdw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n-    }\n-\n-  /* Emit debug info for the address of the end of the function.  */\n-  if (0)\n+  if (separate_line_info)\n     {\n-      dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n-\t\t\t   \"DW_LNS_fixed_advance_pc\");\n-      dw2_asm_output_delta (2, text_end_label, prev_line_label, NULL);\n-    }\n-  else\n-    {\n-      dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n-      dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n-      dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n-      dw2_asm_output_addr (DWARF2_ADDR_SIZE, text_end_label, NULL);\n-    }\n-\n-  dw2_asm_output_data (1, 0, \"DW_LNE_end_sequence\");\n-  dw2_asm_output_data_uleb128 (1, NULL);\n-  dw2_asm_output_data (1, DW_LNE_end_sequence, NULL);\n-\n-  function = 0;\n-  current_file = 1;\n-  current_line = 1;\n-  for (lt_index = 0; lt_index < separate_line_info_table_in_use;)\n-    {\n-      dw_separate_line_info_ref line_info\n-\t= &separate_line_info_table[lt_index];\n-\n-#if 0\n-      /* Don't emit anything for redundant notes.  */\n-      if (line_info->dw_line_num == current_line\n-\t  && line_info->dw_file_num == current_file\n-\t  && line_info->function == function)\n-\tgoto cont;\n-#endif\n-\n-      /* Emit debug info for the address of the current line.  If this is\n-\t a new function, or the first line of a function, then we need\n-\t to handle it differently.  */\n-      ASM_GENERATE_INTERNAL_LABEL (line_label, SEPARATE_LINE_CODE_LABEL,\n-\t\t\t\t   lt_index);\n-      if (function != line_info->function)\n-\t{\n-\t  function = line_info->function;\n-\n-\t  /* Set the address register to the first line in the function.  */\n-\t  dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n-\t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n-\t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n-\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);\n-\t}\n-      else\n-\t{\n-\t  /* ??? See the DW_LNS_advance_pc comment above.  */\n-\t  if (0)\n-\t    {\n-\t      dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n-\t\t\t\t   \"DW_LNS_fixed_advance_pc\");\n-\t      dw2_asm_output_delta (2, line_label, prev_line_label, NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n-\t      dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n-\t      dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);\n-\t    }\n-\t}\n-\n-      strcpy (prev_line_label, line_label);\n-\n-      /* Emit debug info for the source file of the current line, if\n-\t different from the previous line.  */\n-      if (line_info->dw_file_num != current_file)\n-\t{\n-\t  current_file = line_info->dw_file_num;\n-\t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n-\t  dw2_asm_output_data_uleb128 (current_file, \"%lu\", current_file);\n-\t}\n-\n-      /* Emit debug info for the current line number, choosing the encoding\n-\t that uses the least amount of space.  */\n-      if (line_info->dw_line_num != current_line)\n-\t{\n-\t  line_offset = line_info->dw_line_num - current_line;\n-\t  line_delta = line_offset - DWARF_LINE_BASE;\n-\t  current_line = line_info->dw_line_num;\n-\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n-\t    dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE + line_delta,\n-\t\t\t\t \"line %lu\", current_line);\n-\t  else\n-\t    {\n-\t      dw2_asm_output_data (1, DW_LNS_advance_line,\n-\t\t\t\t   \"advance to line %lu\", current_line);\n-\t      dw2_asm_output_data_sleb128 (line_offset, NULL);\n-\t      dw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n-\t    }\n-\t}\n-      else\n-\tdw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n-\n-#if 0\n-    cont:\n-#endif\n-\n-      lt_index++;\n-\n-      /* If we're done with a function, end its sequence.  */\n-      if (lt_index == separate_line_info_table_in_use\n-\t  || separate_line_info_table[lt_index].function != function)\n-\t{\n-\t  current_file = 1;\n-\t  current_line = 1;\n-\n-\t  /* Emit debug info for the address of the end of the function.  */\n-\t  ASM_GENERATE_INTERNAL_LABEL (line_label, FUNC_END_LABEL, function);\n-\t  if (0)\n-\t    {\n-\t      dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n-\t\t\t\t   \"DW_LNS_fixed_advance_pc\");\n-\t      dw2_asm_output_delta (2, line_label, prev_line_label, NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n-\t      dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n-\t      dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);\n-\t    }\n+      dw_line_info_table *table;\n+      size_t i;\n \n-\t  /* Output the marker for the end of this sequence.  */\n-\t  dw2_asm_output_data (1, 0, \"DW_LNE_end_sequence\");\n-\t  dw2_asm_output_data_uleb128 (1, NULL);\n-\t  dw2_asm_output_data (1, DW_LNE_end_sequence, NULL);\n-\t}\n+      FOR_EACH_VEC_ELT (dw_line_info_table_p, separate_line_info, i, table)\n+\tif (table->in_use)\n+\t  output_one_line_info_table (table);\n     }\n \n   /* Output the marker for the end of the line number info.  */\n@@ -22113,6 +22004,76 @@ var_location_switch_text_section (void)\n   htab_traverse (decl_loc_table, var_location_switch_text_section_1, NULL);\n }\n \n+/* Create a new line number table.  */\n+\n+static dw_line_info_table *\n+new_line_info_table (void)\n+{\n+  dw_line_info_table *table;\n+\n+  table = ggc_alloc_cleared_dw_line_info_table_struct ();\n+  table->file_num = 1;\n+  table->line_num = 1;\n+  table->is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;\n+\n+  return table;\n+}\n+\n+/* Lookup the \"current\" table into which we emit line info, so\n+   that we don't have to do it for every source line.  */\n+\n+static void\n+set_cur_line_info_table (section *sec)\n+{\n+  dw_line_info_table *table;\n+\n+  if (sec == text_section)\n+    {\n+      table = text_section_line_info;\n+      if (!table)\n+\t{\n+\t  text_section_line_info = table = new_line_info_table ();\n+\t  table->end_label = text_end_label;\n+\t}\n+    }\n+  else if (sec == cold_text_section)\n+    {\n+      table = cold_text_section_line_info;\n+      if (!table)\n+\t{\n+\t  cold_text_section_line_info = table = new_line_info_table ();\n+\t  table->end_label = cold_end_label;\n+\t}\n+    }\n+  else\n+    {\n+      const char *end_label;\n+\n+      if (flag_reorder_blocks_and_partition)\n+\t{\n+\t  if (in_cold_section_p)\n+\t    end_label = crtl->subsections.cold_section_end_label;\n+\t  else\n+\t    end_label = crtl->subsections.hot_section_end_label;\n+\t}\n+      else\n+\t{\n+\t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,\n+\t\t\t\t       current_function_funcdef_no);\n+\t  end_label = ggc_strdup (label);\n+\t}\n+\n+      table = new_line_info_table ();\n+      table->end_label = end_label;\n+\n+      VEC_safe_push (dw_line_info_table_p, gc, separate_line_info, table);\n+    }\n+\n+  cur_line_info_table = table;\n+}\n+\n+\n /* We need to reset the locations at the beginning of each\n    function. We can't do this in the end_function hook, because the\n    declarations that use the locations won't have been output when\n@@ -22121,114 +22082,100 @@ var_location_switch_text_section (void)\n static void\n dwarf2out_begin_function (tree fun)\n {\n-  if (function_section (fun) != text_section)\n+  section *sec = function_section (fun);\n+\n+  if (sec != text_section)\n     have_multiple_function_sections = true;\n+\n   if (flag_reorder_blocks_and_partition && !cold_text_section)\n     {\n       gcc_assert (current_function_decl == fun);\n       cold_text_section = unlikely_text_section ();\n       switch_to_section (cold_text_section);\n       ASM_OUTPUT_LABEL (asm_out_file, cold_text_section_label);\n-      switch_to_section (current_function_section ());\n+      switch_to_section (sec);\n     }\n \n   dwarf2out_note_section_used ();\n   call_site_count = 0;\n   tail_call_site_count = 0;\n+\n+  set_cur_line_info_table (sec);\n+}\n+\n+/* Add OPCODE+VAL as an entry at the end of the opcode array in TABLE.  */\n+\n+static void\n+push_dw_line_info_entry (dw_line_info_table *table,\n+\t\t\t enum dw_line_info_opcode opcode, unsigned int val)\n+{\n+  dw_line_info_entry e;\n+  e.opcode = opcode;\n+  e.val = val;\n+  VEC_safe_push (dw_line_info_entry, gc, table->entries, &e);\n }\n \n /* Output a label to mark the beginning of a source code line entry\n    and record information relating to this source line, in\n    'line_info_table' for later output of the .debug_line section.  */\n+/* ??? The discriminator parameter ought to be unsigned.  */\n \n static void\n dwarf2out_source_line (unsigned int line, const char *filename,\n                        int discriminator, bool is_stmt)\n {\n-  static bool last_is_stmt = true;\n-\n-  if (debug_info_level >= DINFO_LEVEL_NORMAL\n-      && line != 0)\n-    {\n-      int file_num = maybe_emit_file (lookup_filename (filename));\n+  unsigned int file_num;\n+  dw_line_info_table *table;\n \n-      switch_to_section (current_function_section ());\n+  if (debug_info_level < DINFO_LEVEL_NORMAL || line == 0)\n+    return;\n \n-      /* If requested, emit something human-readable.  */\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s %s:%d\\n\", ASM_COMMENT_START,\n-\t\t filename, line);\n+  switch_to_section (current_function_section ());\n \n-      if (DWARF2_ASM_LINE_DEBUG_INFO)\n-\t{\n-\t  /* Emit the .loc directive understood by GNU as.  */\n-\t  fprintf (asm_out_file, \"\\t.loc %d %d 0\", file_num, line);\n-\t  if (is_stmt != last_is_stmt)\n-\t    {\n-\t      fprintf (asm_out_file, \" is_stmt %d\", is_stmt ? 1 : 0);\n-\t      last_is_stmt = is_stmt;\n-\t    }\n-\t  if (SUPPORTS_DISCRIMINATOR && discriminator != 0)\n-\t    fprintf (asm_out_file, \" discriminator %d\", discriminator);\n-\t  fputc ('\\n', asm_out_file);\n+  /* If requested, emit something human-readable.  */\n+  if (flag_debug_asm)\n+    fprintf (asm_out_file, \"\\t%s %s:%d\\n\", ASM_COMMENT_START, filename, line);\n \n-\t  /* Indicate that line number info exists.  */\n-\t  line_info_table_in_use++;\n-\t}\n-      else if (function_section (current_function_decl) != text_section)\n-\t{\n-\t  dw_separate_line_info_ref line_info;\n-\t  targetm.asm_out.internal_label (asm_out_file,\n-\t\t\t\t\t  SEPARATE_LINE_CODE_LABEL,\n-\t\t\t\t\t  separate_line_info_table_in_use);\n-\n-\t  /* Expand the line info table if necessary.  */\n-\t  if (separate_line_info_table_in_use\n-\t      == separate_line_info_table_allocated)\n-\t    {\n-\t      separate_line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n-\t      separate_line_info_table\n-\t\t= GGC_RESIZEVEC (dw_separate_line_info_entry,\n-\t\t\t\t separate_line_info_table,\n-\t\t\t\t separate_line_info_table_allocated);\n-\t      memset (separate_line_info_table\n-\t\t       + separate_line_info_table_in_use,\n-\t\t      0,\n-\t\t      (LINE_INFO_TABLE_INCREMENT\n-\t\t       * sizeof (dw_separate_line_info_entry)));\n-\t    }\n+  table = cur_line_info_table;\n+  file_num = maybe_emit_file (lookup_filename (filename));\n \n-\t  /* Add the new entry at the end of the line_info_table.  */\n-\t  line_info\n-\t    = &separate_line_info_table[separate_line_info_table_in_use++];\n-\t  line_info->dw_file_num = file_num;\n-\t  line_info->dw_line_num = line;\n-\t  line_info->function = current_function_funcdef_no;\n-\t}\n-      else\n-\t{\n-\t  dw_line_info_ref line_info;\n+  if (0 && file_num == table->file_num\n+      && line == table->line_num\n+      && discriminator == table->discrim_num\n+      && is_stmt == table->is_stmt)\n+    return;\n \n-\t  targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL,\n-\t\t\t\t     line_info_table_in_use);\n+  if (DWARF2_ASM_LINE_DEBUG_INFO)\n+    {\n+      /* Emit the .loc directive understood by GNU as.  */\n+      fprintf (asm_out_file, \"\\t.loc %d %d 0\", file_num, line);\n+      if (is_stmt != table->is_stmt)\n+\tfprintf (asm_out_file, \" is_stmt %d\", is_stmt ? 1 : 0);\n+      if (SUPPORTS_DISCRIMINATOR && discriminator != 0)\n+\tfprintf (asm_out_file, \" discriminator %d\", discriminator);\n+      fputc ('\\n', asm_out_file);\n+    }\n+  else\n+    {\n+      unsigned int label_num = ++line_info_label_num;\n \n-\t  /* Expand the line info table if necessary.  */\n-\t  if (line_info_table_in_use == line_info_table_allocated)\n-\t    {\n-\t      line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n-\t      line_info_table\n-\t\t= GGC_RESIZEVEC (dw_line_info_entry, line_info_table,\n-\t\t\t\t line_info_table_allocated);\n-\t      memset (line_info_table + line_info_table_in_use, 0,\n-\t\t      LINE_INFO_TABLE_INCREMENT * sizeof (dw_line_info_entry));\n-\t    }\n+      targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL, label_num);\n \n-\t  /* Add the new entry at the end of the line_info_table.  */\n-\t  line_info = &line_info_table[line_info_table_in_use++];\n-\t  line_info->dw_file_num = file_num;\n-\t  line_info->dw_line_num = line;\n-\t}\n+      push_dw_line_info_entry (table, LI_set_address, label_num);\n+      if (file_num != table->file_num)\n+\tpush_dw_line_info_entry (table, LI_set_file, file_num);\n+      if (discriminator != table->discrim_num)\n+\tpush_dw_line_info_entry (table, LI_set_discriminator, discriminator);\n+      if (is_stmt != table->is_stmt)\n+\tpush_dw_line_info_entry (table, LI_negate_stmt, 0);\n+      push_dw_line_info_entry (table, LI_set_line, line);\n     }\n+\n+  table->file_num = file_num;\n+  table->line_num = line;\n+  table->discrim_num = discriminator;\n+  table->is_stmt = is_stmt;\n+  table->in_use = true;\n }\n \n /* Record the beginning of a new source file.  */\n@@ -22389,14 +22336,6 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   /* Zero-th entry is allocated, but unused.  */\n   abbrev_die_table_in_use = 1;\n \n-  /* Allocate the initial hunk of the line_info_table.  */\n-  line_info_table = ggc_alloc_cleared_vec_dw_line_info_entry\n-    (LINE_INFO_TABLE_INCREMENT);\n-  line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n-\n-  /* Zero-th entry is allocated, but unused.  */\n-  line_info_table_in_use = 1;\n-\n   /* Allocate the pubtypes and pubnames vectors.  */\n   pubname_table = VEC_alloc (pubname_entry, gc, 32);\n   pubtype_table = VEC_alloc (pubname_entry, gc, 32);"}]}