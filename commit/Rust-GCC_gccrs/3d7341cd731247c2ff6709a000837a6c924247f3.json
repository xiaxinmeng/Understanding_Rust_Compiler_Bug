{"sha": "3d7341cd731247c2ff6709a000837a6c924247f3", "node_id": "C_kwDOANBUbNoAKDNkNzM0MWNkNzMxMjQ3YzJmZjY3MDlhMDAwODM3YTZjOTI0MjQ3ZjM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-02-10T13:54:07Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-02-10T13:54:07Z"}, "message": "c++: memfn lookup consistency and dependent using-decls\n\nRather than not doing any filtering when filter_memfn_lookup encounters\na dependent using-decl, handle this case less imprecisely by holding on\nto the members in the new lookup set that come from a base, i.e. that\ncould plausibly have been introduced by that using-decl, and filtering\nthe rest as usual.  This is still imperfect, but it's closer to the\ncorrect answer than the previous behavior was.\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (filter_memfn_lookup): Handle dependent USING_DECL\n\tbetter.", "tree": {"sha": "8aacb1c758fb742403cf06c8975cc649bbb2833e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aacb1c758fb742403cf06c8975cc649bbb2833e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d7341cd731247c2ff6709a000837a6c924247f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7341cd731247c2ff6709a000837a6c924247f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7341cd731247c2ff6709a000837a6c924247f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7341cd731247c2ff6709a000837a6c924247f3/comments", "author": null, "committer": null, "parents": [{"sha": "3881e1823c5a59d988ddcddcc1e25c5738e228fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3881e1823c5a59d988ddcddcc1e25c5738e228fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3881e1823c5a59d988ddcddcc1e25c5738e228fb"}], "stats": {"total": 26, "additions": 17, "deletions": 9}, "files": [{"sha": "1b18e2a77878363ddae465465db95ed4db99ecd0", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7341cd731247c2ff6709a000837a6c924247f3/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7341cd731247c2ff6709a000837a6c924247f3/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=3d7341cd731247c2ff6709a000837a6c924247f3", "patch": "@@ -16327,28 +16327,34 @@ filter_memfn_lookup (tree oldfns, tree newfns, tree newtype)\n   /* Record all member functions from the old lookup set OLDFNS into\n      VISIBLE_SET.  */\n   hash_set<tree> visible_set;\n+  bool seen_dep_using = false;\n   for (tree fn : lkp_range (oldfns))\n     {\n       if (TREE_CODE (fn) == USING_DECL)\n \t{\n-\t  /* FIXME: Punt on (dependent) USING_DECL for now; mapping\n-\t     a dependent USING_DECL to the member functions it introduces\n-\t     seems tricky.  */\n+\t  /* Imprecisely handle dependent using-decl by keeping all members\n+\t     in the new lookup set that are defined in a base class, i.e.\n+\t     members that could plausibly have been introduced by this\n+\t     dependent using-decl.\n+\t     FIXME: Track which members are introduced by a dependent\n+\t     using-decl precisely, perhaps by performing another lookup\n+\t     from the substituted USING_DECL_SCOPE.  */\n \t  gcc_checking_assert (DECL_DEPENDENT_P (fn));\n-\t  return newfns;\n+\t  seen_dep_using = true;\n \t}\n       else\n \tvisible_set.add (fn);\n     }\n \n   /* Returns true iff (a less specialized version of) FN appeared in\n      the old lookup set OLDFNS.  */\n-  auto visible_p = [newtype, &visible_set] (tree fn) {\n+  auto visible_p = [newtype, seen_dep_using, &visible_set] (tree fn) {\n     if (DECL_CONTEXT (fn) != newtype)\n       /* FN is a member function from a base class, introduced via a\n-\t non-dependent using-decl; look in the old lookup set for\n-\t FN exactly.  */\n-      return visible_set.contains (fn);\n+\t using-decl; if it might have been introduced by a dependent\n+\t using-decl then just conservatively keep it, otherwise look\n+\t in the old lookup set for FN exactly.  */\n+      return seen_dep_using || visible_set.contains (fn);\n     else if (TREE_CODE (fn) == TEMPLATE_DECL)\n       /* FN is a member function template from the current class;\n \t look in the old lookup set for the TEMPLATE_DECL from which\n@@ -16382,7 +16388,9 @@ filter_memfn_lookup (tree oldfns, tree newfns, tree newtype)\n \tfiltered_fns = lookup_add (fn, filtered_fns);\n \tfiltered_size++;\n       }\n-  gcc_checking_assert (filtered_size == visible_set.elements ());\n+  gcc_checking_assert (seen_dep_using\n+\t\t       ? filtered_size >= visible_set.elements ()\n+\t\t       : filtered_size == visible_set.elements ());\n \n   return filtered_fns;\n }"}]}