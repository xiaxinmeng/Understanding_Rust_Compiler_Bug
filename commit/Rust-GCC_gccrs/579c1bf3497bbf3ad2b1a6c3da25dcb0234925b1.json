{"sha": "579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5YzFiZjM0OTdiYmYzYWQyYjFhNmMzZGEyNWRjYjAyMzQ5MjViMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-10-11T19:39:37Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-10-11T19:39:37Z"}, "message": "re PR bootstrap/45445 (ARM bootstrap failure: comparison failures after stage 3)\n\n\tPR bootstrap/45445\n\t* ira-lives.c (mark_pseudo_reg_live, mark_pseudo_reg_dead): New\n\tstatic functions.\n\t(mark_ref_live, mark_ref_dead): Use them.\n\t(make_pseudo_conflict): New arg ORIG_DREG.  All callers changed.\n\tSave the original reg, and use the new functions.\n\t(check_and_make_def_use_conflict): New arg ORIG_DREG.  All callers\n\tchanged.\n\t(check_and_make_def_conflict): Save the original reg.\n\nFrom-SVN: r165329", "tree": {"sha": "f12acf5da2dff4dd787a2e9e3f20448db0a368de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12acf5da2dff4dd787a2e9e3f20448db0a368de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1/comments", "author": null, "committer": null, "parents": [{"sha": "30aeeca4526f4958a7dfe9dee11ba367e7810234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30aeeca4526f4958a7dfe9dee11ba367e7810234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30aeeca4526f4958a7dfe9dee11ba367e7810234"}], "stats": {"total": 113, "additions": 73, "deletions": 40}, "files": [{"sha": "012a687715e3ccca0f16d82635e3f0320d529a45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1", "patch": "@@ -1,3 +1,15 @@\n+2010-10-11  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR bootstrap/45445\n+\t* ira-lives.c (mark_pseudo_reg_live, mark_pseudo_reg_dead): New\n+\tstatic functions.\n+\t(mark_ref_live, mark_ref_dead): Use them.\n+\t(make_pseudo_conflict): New arg ORIG_DREG.  All callers changed.\n+\tSave the original reg, and use the new functions.\n+\t(check_and_make_def_use_conflict): New arg ORIG_DREG.  All callers\n+\tchanged.\n+\t(check_and_make_def_conflict): Save the original reg.\n+\n 2010-10-11  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/45699"}, {"sha": "8a255c22f2118bc4fff805bbd06d3d3817cc4a4b", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=579c1bf3497bbf3ad2b1a6c3da25dcb0234925b1", "patch": "@@ -329,6 +329,21 @@ mark_hard_reg_live (rtx reg)\n     }\n }\n \n+/* Mark a pseudo, or one of its subwords, as live.  REGNO is the pseudo's\n+   register number; ORIG_REG is the access in the insn, which may be a\n+   subreg.  */\n+static void\n+mark_pseudo_reg_live (rtx orig_reg, unsigned regno)\n+{\n+  if (df_read_modify_subreg_p (orig_reg))\n+    {\n+      mark_pseudo_regno_subword_live (regno,\n+\t\t\t\t      subreg_lowpart_p (orig_reg) ? 0 : 1);\n+    }\n+  else\n+    mark_pseudo_regno_live (regno);\n+}\n+\n /* Mark the register referenced by use or def REF as live.  */\n static void\n mark_ref_live (df_ref ref)\n@@ -340,15 +355,7 @@ mark_ref_live (df_ref ref)\n     reg = SUBREG_REG (reg);\n \n   if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (df_read_modify_subreg_p (orig_reg))\n-\t{\n-\t  mark_pseudo_regno_subword_live (REGNO (reg),\n-\t\t\t\t\t  subreg_lowpart_p (orig_reg) ? 0 : 1);\n-\t}\n-      else\n-\tmark_pseudo_regno_live (REGNO (reg));\n-    }\n+    mark_pseudo_reg_live (orig_reg, REGNO (reg));\n   else\n     mark_hard_reg_live (reg);\n }\n@@ -445,6 +452,21 @@ mark_hard_reg_dead (rtx reg)\n     }\n }\n \n+/* Mark a pseudo, or one of its subwords, as dead.  REGNO is the pseudo's\n+   register number; ORIG_REG is the access in the insn, which may be a\n+   subreg.  */\n+static void\n+mark_pseudo_reg_dead (rtx orig_reg, unsigned regno)\n+{\n+  if (df_read_modify_subreg_p (orig_reg))\n+    {\n+      mark_pseudo_regno_subword_dead (regno,\n+\t\t\t\t      subreg_lowpart_p (orig_reg) ? 0 : 1);\n+    }\n+  else\n+    mark_pseudo_regno_dead (regno);\n+}\n+\n /* Mark the register referenced by definition DEF as dead, if the\n    definition is a total one.  */\n static void\n@@ -466,26 +488,22 @@ mark_ref_dead (df_ref def)\n     return;\n \n   if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (df_read_modify_subreg_p (orig_reg))\n-\t{\n-\t  mark_pseudo_regno_subword_dead (REGNO (reg),\n-\t\t\t\t\t  subreg_lowpart_p (orig_reg) ? 0 : 1);\n-\t}\n-      else\n-\tmark_pseudo_regno_dead (REGNO (reg));\n-    }\n+    mark_pseudo_reg_dead (orig_reg, REGNO (reg));\n   else\n     mark_hard_reg_dead (reg);\n }\n \n-/* Make pseudo REG conflicting with pseudo DREG, if the 1st pseudo\n-   class is intersected with class CL.  Advance the current program\n-   point before making the conflict if ADVANCE_P.  Return TRUE if we\n-   will need to advance the current program point.  */\n+/* If REG is a pseudo or a subreg of it, and the class of its allocno\n+   intersects CL, make a conflict with pseudo DREG.  ORIG_DREG is the\n+   rtx actually accessed, it may be indentical to DREG or a subreg of it.\n+   Advance the current program point before making the conflict if\n+   ADVANCE_P.  Return TRUE if we will need to advance the current\n+   program point.  */\n static bool\n-make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, bool advance_p)\n+make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, rtx orig_dreg,\n+\t\t      bool advance_p)\n {\n+  rtx orig_reg = reg;\n   ira_allocno_t a;\n \n   if (GET_CODE (reg) == SUBREG)\n@@ -501,29 +519,31 @@ make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, bool advance_p)\n   if (advance_p)\n     curr_point++;\n \n-  mark_pseudo_regno_live (REGNO (reg));\n-  mark_pseudo_regno_live (REGNO (dreg));\n-  mark_pseudo_regno_dead (REGNO (reg));\n-  mark_pseudo_regno_dead (REGNO (dreg));\n+  mark_pseudo_reg_live (orig_reg, REGNO (reg));\n+  mark_pseudo_reg_live (orig_dreg, REGNO (dreg));\n+  mark_pseudo_reg_dead (orig_reg, REGNO (reg));\n+  mark_pseudo_reg_dead (orig_dreg, REGNO (dreg));\n \n   return false;\n }\n \n /* Check and make if necessary conflicts for pseudo DREG of class\n    DEF_CL of the current insn with input operand USE of class USE_CL.\n-   Advance the current program point before making the conflict if\n-   ADVANCE_P.  Return TRUE if we will need to advance the current\n-   program point.  */\n+   ORIG_DREG is the rtx actually accessed, it may be indentical to\n+   DREG or a subreg of it.  Advance the current program point before\n+   making the conflict if ADVANCE_P.  Return TRUE if we will need to\n+   advance the current program point.  */\n static bool\n-check_and_make_def_use_conflict (rtx dreg, enum reg_class def_cl,\n-\t\t\t\t int use, enum reg_class use_cl,\n-\t\t\t\t bool advance_p)\n+check_and_make_def_use_conflict (rtx dreg, rtx orig_dreg,\n+\t\t\t\t enum reg_class def_cl, int use,\n+\t\t\t\t enum reg_class use_cl, bool advance_p)\n {\n   if (! reg_classes_intersect_p (def_cl, use_cl))\n     return advance_p;\n \n   advance_p = make_pseudo_conflict (recog_data.operand[use],\n-\t\t\t\t    use_cl, dreg, advance_p);\n+\t\t\t\t    use_cl, dreg, orig_dreg, advance_p);\n+\n   /* Reload may end up swapping commutative operands, so you\n      have to take both orderings into account.  The\n      constraints for the two operands can be completely\n@@ -534,12 +554,12 @@ check_and_make_def_use_conflict (rtx dreg, enum reg_class def_cl,\n       && recog_data.constraints[use][0] == '%')\n     advance_p\n       = make_pseudo_conflict (recog_data.operand[use + 1],\n-\t\t\t      use_cl, dreg, advance_p);\n+\t\t\t      use_cl, dreg, orig_dreg, advance_p);\n   if (use >= 1\n       && recog_data.constraints[use - 1][0] == '%')\n     advance_p\n       = make_pseudo_conflict (recog_data.operand[use - 1],\n-\t\t\t      use_cl, dreg, advance_p);\n+\t\t\t      use_cl, dreg, orig_dreg, advance_p);\n   return advance_p;\n }\n \n@@ -554,6 +574,7 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n   enum reg_class use_cl, acl;\n   bool advance_p;\n   rtx dreg = recog_data.operand[def];\n+  rtx orig_dreg = dreg;\n \n   if (def_cl == NO_REGS)\n     return;\n@@ -599,8 +620,8 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n       if (alt1 < recog_data.n_alternatives)\n \tcontinue;\n \n-      advance_p = check_and_make_def_use_conflict (dreg, def_cl, use,\n-\t\t\t\t\t\t   use_cl, advance_p);\n+      advance_p = check_and_make_def_use_conflict (dreg, orig_dreg, def_cl,\n+\t\t\t\t\t\t   use, use_cl, advance_p);\n \n       if ((use_match = recog_op_alt[use][alt].matches) >= 0)\n \t{\n@@ -611,8 +632,8 @@ check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n \t    use_cl = ALL_REGS;\n \t  else\n \t    use_cl = recog_op_alt[use_match][alt].cl;\n-\t  advance_p = check_and_make_def_use_conflict (dreg, def_cl, use,\n-\t\t\t\t\t\t       use_cl, advance_p);\n+\t  advance_p = check_and_make_def_use_conflict (dreg, orig_dreg, def_cl,\n+\t\t\t\t\t\t       use, use_cl, advance_p);\n \t}\n     }\n }"}]}