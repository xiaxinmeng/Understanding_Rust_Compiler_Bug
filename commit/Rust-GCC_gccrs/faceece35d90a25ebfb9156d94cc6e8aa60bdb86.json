{"sha": "faceece35d90a25ebfb9156d94cc6e8aa60bdb86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjZWVjZTM1ZDkwYTI1ZWJmYjkxNTZkOTRjYzZlOGFhNjBiZGI4Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-01-28T07:21:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-01-28T07:21:21Z"}, "message": "fp-bit.c (pack_d): When using paired doubles to implement a long double...\n\n\t* config/fp-bit.c (pack_d): When using paired doubles to implement\n\ta long double, round the high part separately.\n\t(unpack_d): Fix the case in which the high part is a power of two\n\tand the low part is a nonzero value of the opposite sign.\n\nFrom-SVN: r76780", "tree": {"sha": "4c12b2cd7e8aa5cda660f0dbb77db1ea2040a0c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c12b2cd7e8aa5cda660f0dbb77db1ea2040a0c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faceece35d90a25ebfb9156d94cc6e8aa60bdb86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faceece35d90a25ebfb9156d94cc6e8aa60bdb86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faceece35d90a25ebfb9156d94cc6e8aa60bdb86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faceece35d90a25ebfb9156d94cc6e8aa60bdb86/comments", "author": null, "committer": null, "parents": [{"sha": "28b241764ff7466a8eacff6ebd766676ae998e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b241764ff7466a8eacff6ebd766676ae998e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28b241764ff7466a8eacff6ebd766676ae998e9b"}], "stats": {"total": 97, "additions": 65, "deletions": 32}, "files": [{"sha": "02486c89cbc697e602c01c082dfd56065d053417", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faceece35d90a25ebfb9156d94cc6e8aa60bdb86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faceece35d90a25ebfb9156d94cc6e8aa60bdb86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=faceece35d90a25ebfb9156d94cc6e8aa60bdb86", "patch": "@@ -1,3 +1,10 @@\n+2004-01-28  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/fp-bit.c (pack_d): When using paired doubles to implement\n+\ta long double, round the high part separately.\n+\t(unpack_d): Fix the case in which the high part is a power of two\n+\tand the low part is a nonzero value of the opposite sign.\n+\n 2004-01-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/c4x/c4x.c (TARGET_ASM_EXTERNAL_LIBCALL): New."}, {"sha": "a1ba156bf45481832a7c8b35683c6536b4e95a7b", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faceece35d90a25ebfb9156d94cc6e8aa60bdb86/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faceece35d90a25ebfb9156d94cc6e8aa60bdb86/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=faceece35d90a25ebfb9156d94cc6e8aa60bdb86", "patch": "@@ -330,58 +330,76 @@ pack_d ( fp_number_type *  src)\n #else\n # if defined TFLOAT && defined HALFFRACBITS\n  {\n-   halffractype high, low;\n-\n-   high = (fraction >> (FRACBITS - HALFFRACBITS));\n-   high &= (((fractype)1) << HALFFRACBITS) - 1;\n-   high |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;\n-   high |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);\n-\n-   low = (halffractype)fraction &\n-     ((((halffractype)1) << (FRACBITS - HALFFRACBITS)) - 1);\n+   halffractype high, low, unity;\n+   int lowsign, lowexp;\n+\n+   unity = (halffractype) 1 << HALFFRACBITS;\n+\n+   /* Set HIGH to the high double's significand, masking out the implicit 1.\n+      Set LOW to the low double's full significand.  */\n+   high = (fraction >> (FRACBITS - HALFFRACBITS)) & (unity - 1);\n+   low = fraction & (unity * 2 - 1);\n+\n+   /* Get the initial sign and exponent of the low double.  */\n+   lowexp = exp - HALFFRACBITS - 1;\n+   lowsign = sign;\n+\n+   /* HIGH should be rounded like a normal double, making |LOW| <=\n+      0.5 ULP of HIGH.  Assume round-to-nearest.  */\n+   if (exp < EXPMAX)\n+     if (low > unity || (low == unity && (high & 1) == 1))\n+       {\n+\t /* Round HIGH up and adjust LOW to match.  */\n+\t high++;\n+\t if (high == unity)\n+\t   {\n+\t     /* May make it infinite, but that's OK.  */\n+\t     high = 0;\n+\t     exp++;\n+\t   }\n+\t low = unity * 2 - low;\n+\t lowsign ^= 1;\n+       }\n+\n+   high |= (halffractype) exp << HALFFRACBITS;\n+   high |= (halffractype) sign << (HALFFRACBITS + EXPBITS);\n \n    if (exp == EXPMAX || exp == 0 || low == 0)\n      low = 0;\n    else\n      {\n-       exp -= HALFFRACBITS + 1;\n-\n-       while (exp > 0\n-\t      && low < ((halffractype)1 << HALFFRACBITS))\n+       while (lowexp > 0 && low < unity)\n \t {\n \t   low <<= 1;\n-\t   exp--;\n+\t   lowexp--;\n \t }\n \n-       if (exp <= 0)\n+       if (lowexp <= 0)\n \t {\n \t   halffractype roundmsb, round;\n+\t   int shift;\n \n-\t   exp = -exp + 1;\n-\n-\t   roundmsb = (1 << (exp - 1));\n+\t   shift = 1 - lowexp;\n+\t   roundmsb = (1 << (shift - 1));\n \t   round = low & ((roundmsb << 1) - 1);\n \n-\t   low >>= exp;\n-\t   exp = 0;\n+\t   low >>= shift;\n+\t   lowexp = 0;\n \n-\t   if (round > roundmsb || (round == roundmsb && (low & 1)))\n+\t   if (round > roundmsb || (round == roundmsb && (low & 1) == 1))\n \t     {\n \t       low++;\n-\t       if (low >= ((halffractype)1 << HALFFRACBITS))\n-\t\t /* We don't shift left, since it has just become the\n-\t\t    smallest normal number, whose implicit 1 bit is\n-\t\t    now indicated by the nonzero exponent.  */\n-\t\t exp++;\n+\t       if (low == unity)\n+\t\t /* LOW rounds up to the smallest normal number.  */\n+\t\t lowexp++;\n \t     }\n \t }\n \n-       low &= ((halffractype)1 << HALFFRACBITS) - 1;\n-       low |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;\n-       low |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);\n+       low &= unity - 1;\n+       low |= (halffractype) lowexp << HALFFRACBITS;\n+       low |= (halffractype) lowsign << (HALFFRACBITS + EXPBITS);\n      }\n-\n-   dst.value_raw = (((fractype) high) << HALFSHIFT) | low;\n+   dst.value_raw = ((fractype) high << HALFSHIFT) | low;\n  }\n # else\n   dst.value_raw = fraction & ((((fractype)1) << FRACBITS) - (fractype)1);\n@@ -475,8 +493,16 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n \t xlow >>= -shift;\n        if (sign == lowsign)\n \t fraction += xlow;\n-       else\n+       else if (fraction >= xlow)\n \t fraction -= xlow;\n+       else\n+\t {\n+\t   /* The high part is a power of two but the full number is lower.\n+\t      This code will leave the implicit 1 in FRACTION, but we'd\n+\t      have added that below anyway.  */\n+\t   fraction = (((fractype) 1 << FRACBITS) - xlow) << 1;\n+\t   exp--;\n+\t }\n      }\n  }\n # else"}]}