{"sha": "e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5OGNlNzk5NzczM2MyOWRjYWI5YzNjNjJjYTEwMmM3ZjlmYTZlYg==", "commit": {"author": {"name": "Gerg\u00f6 Barany", "email": "gergo@codesourcery.com", "date": "2019-01-31T23:59:30Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2020-11-13T21:58:57Z"}, "message": "Decompose OpenACC 'kernels' constructs into parts, a sequence of compute constructs\n\nNot yet enabled by default: for now, the current mode of OpenACC 'kernels'\nconstructs handling still remains '-fopenacc-kernels=parloops', but that is to\nchange later.\n\n\tgcc/\n\t* omp-oacc-kernels-decompose.cc: New.\n\t* Makefile.in (OBJS): Add it.\n\t* passes.def: Instantiate it.\n\t* tree-pass.h (make_pass_omp_oacc_kernels_decompose): Declare.\n\t* flag-types.h (enum openacc_kernels): Add.\n\t* doc/invoke.texi (-fopenacc-kernels): Document.\n\t* gimple.h (enum gf_mask): Add\n\t'GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED',\n\t'GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE',\n\t'GF_OMP_TARGET_KIND_OACC_DATA_KERNELS'.\n\t(is_gimple_omp_oacc, is_gimple_omp_offloaded): Handle these.\n\t* gimple-pretty-print.c (dump_gimple_omp_target): Likewise.\n\t* omp-expand.c (expand_omp_target, build_omp_regions_1)\n\t(omp_make_gimple_edges): Likewise.\n\t* omp-low.c (scan_sharing_clauses, scan_omp_for)\n\t(check_omp_nesting_restrictions, lower_oacc_reductions)\n\t(lower_oacc_head_mark, lower_omp_target): Likewise.\n\t* omp-offload.c (execute_oacc_device_lower): Likewise.\n\tgcc/c-family/\n\t* c.opt (fopenacc-kernels): Add.\n\tgcc/fortran/\n\t* lang.opt (fopenacc-kernels): Add.\n\tgcc/testsuite/\n\t* c-c++-common/goacc/kernels-decompose-1.c: New.\n\t* c-c++-common/goacc/kernels-decompose-2.c: New.\n\t* c-c++-common/goacc/kernels-decompose-ice-1.c: New.\n\t* c-c++-common/goacc/kernels-decompose-ice-2.c: New.\n\t* gfortran.dg/goacc/kernels-decompose-1.f95: New.\n\t* gfortran.dg/goacc/kernels-decompose-2.f95: New.\n\t* c-c++-common/goacc/if-clause-2.c: Adjust.\n\t* gfortran.dg/goacc/kernels-tree.f95: Likewise.\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose-ice-1.c:\n\tNew.\n\t* testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-decompose-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/declare-vla.c: Adjust.\n\t* testsuite/libgomp.oacc-fortran/pr94358-1.f90: Likewise.\n\nCo-authored-by: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "332bb0438f3383bc22d777c3b0008c269dba4d8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/332bb0438f3383bc22d777c3b0008c269dba4d8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/comments", "author": null, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd7885755405bc9947ebe805a53d6100c78c8e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7885755405bc9947ebe805a53d6100c78c8e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7885755405bc9947ebe805a53d6100c78c8e82"}], "stats": {"total": 2371, "additions": 2355, "deletions": 16}, "files": [{"sha": "273654cfa2525099ed0d9adc2f9085c8408b096f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1480,6 +1480,7 @@ OBJS = \\\n \tomp-expand.o \\\n \tomp-general.o \\\n \tomp-low.o \\\n+\tomp-oacc-kernels-decompose.o \\\n \tomp-simd-clone.o \\\n \topt-problem.o \\\n \toptabs.o \\"}, {"sha": "0532cb70ffcee96ef5bba9eabc523d0f0f27f59b", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1796,6 +1796,19 @@ fopenacc-dim=\n C ObjC C++ ObjC++ LTO Joined Var(flag_openacc_dims)\n Specify default OpenACC compute dimensions.\n \n+fopenacc-kernels=\n+C ObjC C++ ObjC++ RejectNegative Joined Enum(openacc_kernels) Var(flag_openacc_kernels) Init(OPENACC_KERNELS_PARLOOPS)\n+-fopenacc-kernels=[decompose|parloops]\tSpecify mode of OpenACC 'kernels' constructs handling.\n+\n+Enum\n+Name(openacc_kernels) Type(enum openacc_kernels)\n+\n+EnumValue\n+Enum(openacc_kernels) String(decompose) Value(OPENACC_KERNELS_DECOMPOSE)\n+\n+EnumValue\n+Enum(openacc_kernels) String(parloops) Value(OPENACC_KERNELS_PARLOOPS)\n+\n fopenmp\n C ObjC C++ ObjC++ LTO Var(flag_openmp)\n Enable OpenMP (implies -frecursive in Fortran)."}, {"sha": "8a164ef978805f4ba96f3f684f4e766c717ab2f2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -201,7 +201,7 @@ in the following sections.\n -aux-info @var{filename}  -fallow-parameterless-variadic-functions @gol\n -fno-asm  -fno-builtin  -fno-builtin-@var{function}  -fgimple@gol\n -fhosted  -ffreestanding @gol\n--fopenacc  -fopenacc-dim=@var{geom} @gol\n+-fopenacc  -fopenacc-dim=@var{geom}  -fopenacc-kernels=@var{mode} @gol\n -fopenmp  -fopenmp-simd @gol\n -fms-extensions  -fplan9-extensions  -fsso-struct=@var{endianness} @gol\n -fallow-single-precision  -fcond-mismatch  -flax-vector-conversions @gol\n@@ -2589,6 +2589,18 @@ not explicitly specify.  The @var{geom} value is a triple of\n ':'-separated sizes, in order 'gang', 'worker' and, 'vector'.  A size\n can be omitted, to use a target-specific default value.\n \n+@item -fopenacc-kernels=@var{mode}\n+@opindex fopenacc-kernels\n+@cindex OpenACC accelerator programming\n+Specify mode of OpenACC `kernels' constructs handling.\n+With @option{-fopenacc-kernels=decompose}, OpenACC `kernels'\n+constructs are decomposed into parts, a sequence of compute\n+constructs, each then handled individually.\n+This is work in progress.\n+With @option{-fopenacc-kernels=parloops}, OpenACC `kernels' constructs\n+are handled by the @samp{parloops} pass, en bloc.\n+This is the current default.\n+\n @item -fopenmp\n @opindex fopenmp\n @cindex OpenMP parallel"}, {"sha": "648ed096e30c89e5eca0caeaced7ba3ff57b5666", "filename": "gcc/flag-types.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -415,6 +415,13 @@ enum evrp_mode\n   EVRP_MODE_RVRP_DEBUG = EVRP_MODE_RVRP_ONLY | EVRP_MODE_DEBUG\n };\n \n+/* Modes of OpenACC 'kernels' constructs handling.  */\n+enum openacc_kernels\n+{\n+  OPENACC_KERNELS_DECOMPOSE,\n+  OPENACC_KERNELS_PARLOOPS\n+};\n+\n #endif\n \n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "96ed208cb85a685566a0a2cccf29bd4b952365b9", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -687,6 +687,10 @@ fopenacc-dim=\n Fortran LTO Joined Var(flag_openacc_dims)\n ; Documented in C\n \n+fopenacc-kernels=\n+Fortran RejectNegative Joined Enum(openacc_kernels) Var(flag_openacc_kernels) Init(OPENACC_KERNELS_PARLOOPS)\n+; Documented in C\n+\n fopenmp\n Fortran LTO\n ; Documented in C"}, {"sha": "d97a231e7e8333c1b32a39d03851b974dc55c1f7", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1700,6 +1700,15 @@ dump_gimple_omp_target (pretty_printer *buffer, const gomp_target *gs,\n     case GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n       kind = \" oacc_host_data\";\n       break;\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+      kind = \" oacc_parallel_kernels_parallelized\";\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+      kind = \" oacc_parallel_kernels_gang_single\";\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n+      kind = \" oacc_data_kernels\";\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "8a1db3cc7db61972a9570d137cbfb9633bd0b775", "filename": "gcc/gimple.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -175,6 +175,15 @@ enum gf_mask {\n     GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA = 10,\n     GF_OMP_TARGET_KIND_OACC_DECLARE = 11,\n     GF_OMP_TARGET_KIND_OACC_HOST_DATA = 12,\n+    /* A 'GF_OMP_TARGET_KIND_OACC_PARALLEL' representing an OpenACC 'kernels'\n+       decomposed part, parallelized.  */\n+    GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED = 13,\n+    /* A 'GF_OMP_TARGET_KIND_OACC_PARALLEL' representing an OpenACC 'kernels'\n+       decomposed part, \"gang-single\".  */\n+    GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE = 14,\n+    /* A 'GF_OMP_TARGET_KIND_OACC_DATA' representing an OpenACC 'kernels'\n+       decomposed parts' 'data' construct.  */\n+    GF_OMP_TARGET_KIND_OACC_DATA_KERNELS = 15,\n     GF_OMP_TEAMS_HOST\t\t= 1 << 0,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n@@ -6511,6 +6520,9 @@ is_gimple_omp_oacc (const gimple *stmt)\n \tcase GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n \tcase GF_OMP_TARGET_KIND_OACC_DECLARE:\n \tcase GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+\tcase GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -6536,6 +6548,8 @@ is_gimple_omp_offloaded (const gimple *stmt)\n \tcase GF_OMP_TARGET_KIND_OACC_PARALLEL:\n \tcase GF_OMP_TARGET_KIND_OACC_KERNELS:\n \tcase GF_OMP_TARGET_KIND_OACC_SERIAL:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n \t  return true;\n \tdefault:\n \t  return false;"}, {"sha": "b731fd69b1e5b8025ff3f901b2e15bf9ee02ada6", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -9257,11 +9257,14 @@ expand_omp_target (struct omp_region *region)\n     case GF_OMP_TARGET_KIND_OACC_UPDATE:\n     case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n     case GF_OMP_TARGET_KIND_OACC_DECLARE:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n       data_region = false;\n       break;\n     case GF_OMP_TARGET_KIND_DATA:\n     case GF_OMP_TARGET_KIND_OACC_DATA:\n     case GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n+    case GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n       data_region = true;\n       break;\n     default:\n@@ -9307,6 +9310,16 @@ expand_omp_target (struct omp_region *region)\n \t= tree_cons (get_identifier (\"oacc serial\"),\n \t\t     NULL_TREE, DECL_ATTRIBUTES (child_fn));\n       break;\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+      DECL_ATTRIBUTES (child_fn)\n+\t= tree_cons (get_identifier (\"oacc parallel_kernels_parallelized\"),\n+\t\t     NULL_TREE, DECL_ATTRIBUTES (child_fn));\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+      DECL_ATTRIBUTES (child_fn)\n+\t= tree_cons (get_identifier (\"oacc parallel_kernels_gang_single\"),\n+\t\t     NULL_TREE, DECL_ATTRIBUTES (child_fn));\n+      break;\n     default:\n       /* Make sure we don't miss any.  */\n       gcc_checking_assert (!(is_gimple_omp_oacc (entry_stmt)\n@@ -9517,10 +9530,13 @@ expand_omp_target (struct omp_region *region)\n     case GF_OMP_TARGET_KIND_OACC_PARALLEL:\n     case GF_OMP_TARGET_KIND_OACC_KERNELS:\n     case GF_OMP_TARGET_KIND_OACC_SERIAL:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n       start_ix = BUILT_IN_GOACC_PARALLEL;\n       break;\n     case GF_OMP_TARGET_KIND_OACC_DATA:\n     case GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n+    case GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n       start_ix = BUILT_IN_GOACC_DATA_START;\n       break;\n     case GF_OMP_TARGET_KIND_OACC_UPDATE:\n@@ -9993,6 +10009,9 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t\tcase GF_OMP_TARGET_KIND_OACC_SERIAL:\n \t\tcase GF_OMP_TARGET_KIND_OACC_DATA:\n \t\tcase GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n \t\t  break;\n \t\tcase GF_OMP_TARGET_KIND_UPDATE:\n \t\tcase GF_OMP_TARGET_KIND_ENTER_DATA:\n@@ -10247,6 +10266,9 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n \tcase GF_OMP_TARGET_KIND_OACC_SERIAL:\n \tcase GF_OMP_TARGET_KIND_OACC_DATA:\n \tcase GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+\tcase GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n \t  break;\n \tcase GF_OMP_TARGET_KIND_UPDATE:\n \tcase GF_OMP_TARGET_KIND_ENTER_DATA:"}, {"sha": "a1604e0ee3c41c050aae3c34fd02d351f7c6690c", "filename": "gcc/omp-low.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -193,8 +193,8 @@ static tree scan_omp_1_op (tree *, int *, void *);\n       *handled_ops_p = false; \\\n       break;\n \n-/* Return true if CTX corresponds to an OpenACC 'parallel' or 'serial'\n-   region.  */\n+/* Return whether CTX represents an OpenACC 'parallel' or 'serial' construct.\n+   (This doesn't include OpenACC 'kernels' decomposed parts.)  */\n \n static bool\n is_oacc_parallel_or_serial (omp_context *ctx)\n@@ -207,7 +207,8 @@ is_oacc_parallel_or_serial (omp_context *ctx)\n \t\t  == GF_OMP_TARGET_KIND_OACC_SERIAL)));\n }\n \n-/* Return true if CTX corresponds to an oacc kernels region.  */\n+/* Return whether CTX represents an OpenACC 'kernels' construct.\n+   (This doesn't include OpenACC 'kernels' decomposed parts.)  */\n \n static bool\n is_oacc_kernels (omp_context *ctx)\n@@ -218,6 +219,21 @@ is_oacc_kernels (omp_context *ctx)\n \t      == GF_OMP_TARGET_KIND_OACC_KERNELS));\n }\n \n+/* Return whether CTX represents an OpenACC 'kernels' decomposed part.  */\n+\n+static bool\n+is_oacc_kernels_decomposed_part (omp_context *ctx)\n+{\n+  enum gimple_code outer_type = gimple_code (ctx->stmt);\n+  return ((outer_type == GIMPLE_OMP_TARGET)\n+\t  && ((gimple_omp_target_kind (ctx->stmt)\n+\t       == GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED)\n+\t      || (gimple_omp_target_kind (ctx->stmt)\n+\t\t  == GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE)\n+\t      || (gimple_omp_target_kind (ctx->stmt)\n+\t\t  == GF_OMP_TARGET_KIND_OACC_DATA_KERNELS)));\n+}\n+\n /* Return true if STMT corresponds to an OpenMP target region.  */\n static bool\n is_omp_target (gimple *stmt)\n@@ -1200,6 +1216,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    {\n \t      /* No 'reduction' clauses on OpenACC 'kernels'.  */\n \t      gcc_checking_assert (!is_oacc_kernels (ctx));\n+\t      /* Likewise, on OpenACC 'kernels' decomposed parts.  */\n+\t      gcc_checking_assert (!is_oacc_kernels_decomposed_part (ctx));\n \n \t      ctx->local_reduction_clauses\n \t\t= tree_cons (NULL, c, ctx->local_reduction_clauses);\n@@ -2415,7 +2433,9 @@ enclosing_target_ctx (omp_context *ctx)\n   return ctx;\n }\n \n-/* Return true if ctx is part of an oacc kernels region.  */\n+/* Return whether CTX's parent compute construct is an OpenACC 'kernels'\n+   construct.\n+   (This doesn't include OpenACC 'kernels' decomposed parts.)  */\n \n static bool\n ctx_in_oacc_kernels_region (omp_context *ctx)\n@@ -2431,7 +2451,8 @@ ctx_in_oacc_kernels_region (omp_context *ctx)\n   return false;\n }\n \n-/* Check the parallelism clauses inside a kernels regions.\n+/* Check the parallelism clauses inside a OpenACC 'kernels' region.\n+   (This doesn't include OpenACC 'kernels' decomposed parts.)\n    Until kernels handling moves to use the same loop indirection\n    scheme as parallel, we need to do this checking early.  */\n \n@@ -2533,6 +2554,10 @@ scan_omp_for (gomp_for *stmt, omp_context *outer_ctx)\n \n \t    if (c_op0)\n \t      {\n+\t\t/* By construction, this is impossible for OpenACC 'kernels'\n+\t\t   decomposed parts.  */\n+\t\tgcc_assert (!(tgt && is_oacc_kernels_decomposed_part (tgt)));\n+\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t  \"argument not permitted on %qs clause\",\n \t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n@@ -3070,6 +3095,8 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t  case GF_OMP_TARGET_KIND_OACC_PARALLEL:\n \t\t  case GF_OMP_TARGET_KIND_OACC_KERNELS:\n \t\t  case GF_OMP_TARGET_KIND_OACC_SERIAL:\n+\t\t  case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\t\t  case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n \t\t    ok = true;\n \t\t    break;\n \n@@ -3526,6 +3553,11 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t    case GF_OMP_TARGET_KIND_OACC_DECLARE: stmt_name = \"declare\"; break;\n \t    case GF_OMP_TARGET_KIND_OACC_HOST_DATA: stmt_name = \"host_data\";\n \t      break;\n+\t    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\t    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+\t    case GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n+\t      /* OpenACC 'kernels' decomposed parts.  */\n+\t      stmt_name = \"kernels\"; break;\n \t    default: gcc_unreachable ();\n \t    }\n \t  switch (gimple_omp_target_kind (ctx->stmt))\n@@ -3541,6 +3573,11 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t    case GF_OMP_TARGET_KIND_OACC_DATA: ctx_stmt_name = \"data\"; break;\n \t    case GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n \t      ctx_stmt_name = \"host_data\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+\t    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n+\t    case GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n+\t      /* OpenACC 'kernels' decomposed parts.  */\n+\t      ctx_stmt_name = \"kernels\"; break;\n \t    default: gcc_unreachable ();\n \t    }\n \n@@ -6930,6 +6967,8 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n       {\n \t/* No 'reduction' clauses on OpenACC 'kernels'.  */\n \tgcc_checking_assert (!is_oacc_kernels (ctx));\n+\t/* Likewise, on OpenACC 'kernels' decomposed parts.  */\n+\tgcc_checking_assert (!is_oacc_kernels_decomposed_part (ctx));\n \n \ttree orig = OMP_CLAUSE_DECL (c);\n \ttree var = maybe_lookup_decl (orig, ctx);\n@@ -7785,13 +7824,23 @@ lower_oacc_head_mark (location_t loc, tree ddvar, tree clauses,\n   else if (is_oacc_kernels (tgt))\n     /* Not using this loops handling inside OpenACC 'kernels' regions.  */\n     gcc_unreachable ();\n+  else if (is_oacc_kernels_decomposed_part (tgt))\n+    ;\n   else\n     gcc_unreachable ();\n \n   /* In a parallel region, loops are implicitly INDEPENDENT.  */\n   if (!tgt || is_oacc_parallel_or_serial (tgt))\n     tag |= OLF_INDEPENDENT;\n \n+  /* Loops inside OpenACC 'kernels' decomposed parts' regions are expected to\n+     have an explicit 'seq' or 'independent' clause, and no 'auto' clause.  */\n+  if (tgt && is_oacc_kernels_decomposed_part (tgt))\n+    {\n+      gcc_assert (tag & (OLF_SEQ | OLF_INDEPENDENT));\n+      gcc_assert (!(tag & OLF_AUTO));\n+    }\n+\n   if (tag & OLF_TILE)\n     /* Tiling could use all 3 levels.  */ \n     levels = 3;\n@@ -11639,11 +11688,14 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     case GF_OMP_TARGET_KIND_OACC_UPDATE:\n     case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n     case GF_OMP_TARGET_KIND_OACC_DECLARE:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE:\n       data_region = false;\n       break;\n     case GF_OMP_TARGET_KIND_DATA:\n     case GF_OMP_TARGET_KIND_OACC_DATA:\n     case GF_OMP_TARGET_KIND_OACC_HOST_DATA:\n+    case GF_OMP_TARGET_KIND_OACC_DATA_KERNELS:\n       data_region = true;\n       break;\n     default:\n@@ -11829,6 +11881,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  {\n \t    /* No 'firstprivate' clauses on OpenACC 'kernels'.  */\n \t    gcc_checking_assert (!is_oacc_kernels (ctx));\n+\t    /* Likewise, on OpenACC 'kernels' decomposed parts.  */\n+\t    gcc_checking_assert (!is_oacc_kernels_decomposed_part (ctx));\n \n \t    goto oacc_firstprivate;\n \t  }\n@@ -11861,6 +11915,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  {\n \t    /* No 'private' clauses on OpenACC 'kernels'.  */\n \t    gcc_checking_assert (!is_oacc_kernels (ctx));\n+\t    /* Likewise, on OpenACC 'kernels' decomposed parts.  */\n+\t    gcc_checking_assert (!is_oacc_kernels_decomposed_part (ctx));\n \n \t    break;\n \t  }"}, {"sha": "c585e5d092bf711defa0be715cc3347e13c18830", "filename": "gcc/omp-oacc-kernels-decompose.cc", "status": "added", "additions": 1531, "deletions": 0, "changes": 1531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-oacc-kernels-decompose.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-oacc-kernels-decompose.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-oacc-kernels-decompose.cc?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,1531 @@\n+/* Decompose OpenACC 'kernels' constructs into parts, a sequence of compute\n+   constructs\n+\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"cp/cp-tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"cgraph.h\"\n+#include \"fold-const.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"gomp-constants.h\"\n+#include \"omp-general.h\"\n+#include \"diagnostic-core.h\"\n+\n+\n+/* This preprocessing pass is run immediately before lower_omp.  It decomposes\n+   OpenACC 'kernels' constructs into parts, a sequence of compute constructs.\n+\n+   The translation is as follows:\n+     - The entire 'kernels' region is turned into a 'data' region with clauses\n+       taken from the 'kernels' region.  New 'create' clauses are added for all\n+       variables declared at the top level in the kernels region.\n+     - Any loop nests annotated with an OpenACC 'loop' directive are wrapped in\n+       a new compute construct.\n+\t - 'loop' directives without an explicit 'independent' or 'seq' clause\n+\t   get an 'auto' clause added; other clauses are preserved on the loop\n+\t   or moved to the new surrounding compute construct, as applicable.\n+     - Any sequences of other code (non-loops, non-OpenACC 'loop's) are wrapped\n+       in new \"gang-single\" compute construct: 'worker'/'vector' parallelism is\n+       preserved, but 'num_gangs (1)' is enforced.\n+     - Both points above only apply at the topmost level in the region, that\n+       is, the transformation does not introduce new compute constructs inside\n+       nested statement bodies.  In particular, this means that a\n+       gang-parallelizable loop inside an 'if' statement is made \"gang-single\".\n+     - In order to make the host wait only once for the whole region instead\n+       of once per device kernel launch, the new compute constructs are\n+       annotated 'async'.  Unless the original 'kernels' construct already was\n+       marked 'async', the entire region ends with a 'wait' directive.  If the\n+       original 'kernels' construct was marked 'async', the synthesized 'async'\n+       clauses use the original 'kernels' construct's 'async' argument\n+       (possibly implicit).\n+*/\n+\n+\n+/*TODO Things are conceptually wrong here: 'loop' clauses may be hidden behind\n+  'device_type', so we have to defer a lot of processing until we're in the\n+  offloading compilation.  \"Fortunately\", GCC doesn't support the OpenACC\n+  'device_type' clause yet, so we get away that.  */\n+\n+\n+/* Helper function for decompose_kernels_region_body.  If STMT contains a\n+   \"top-level\" OMP_FOR statement, returns a pointer to that statement;\n+   returns NULL otherwise.\n+\n+   A \"top-level\" OMP_FOR statement is one that is possibly accompanied by\n+   small snippets of setup code.  Specifically, this function accepts an\n+   OMP_FOR possibly wrapped in a singleton bind and a singleton try\n+   statement to allow for a local loop variable, but not an OMP_FOR\n+   statement nested in any other constructs.  Alternatively, it accepts a\n+   non-singleton bind containing only assignments and then an OMP_FOR\n+   statement at the very end.  The former style can be generated by the C\n+   frontend, the latter by the Fortran frontend.  */\n+\n+static gimple *\n+top_level_omp_for_in_stmt (gimple *stmt)\n+{\n+  if (gimple_code (stmt) == GIMPLE_OMP_FOR)\n+    return stmt;\n+\n+  if (gimple_code (stmt) == GIMPLE_BIND)\n+    {\n+      gimple_seq body = gimple_bind_body (as_a <gbind *> (stmt));\n+      if (gimple_seq_singleton_p (body))\n+\t{\n+\t  /* Accept an OMP_FOR statement, or a try statement containing only\n+\t     a single OMP_FOR.  */\n+\t  gimple *maybe_for_or_try = gimple_seq_first_stmt (body);\n+\t  if (gimple_code (maybe_for_or_try) == GIMPLE_OMP_FOR)\n+\t    return maybe_for_or_try;\n+\t  else if (gimple_code (maybe_for_or_try) == GIMPLE_TRY)\n+\t    {\n+\t      gimple_seq try_body = gimple_try_eval (maybe_for_or_try);\n+\t      if (!gimple_seq_singleton_p (try_body))\n+\t\treturn NULL;\n+\t      gimple *maybe_omp_for_stmt = gimple_seq_first_stmt (try_body);\n+\t      if (gimple_code (maybe_omp_for_stmt) == GIMPLE_OMP_FOR)\n+\t\treturn maybe_omp_for_stmt;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\t  /* Accept only a block of optional assignments followed by an\n+\t     OMP_FOR at the end.  No other kinds of statements allowed.  */\n+\t  for (gsi = gsi_start (body); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *body_stmt = gsi_stmt (gsi);\n+\t      if (gimple_code (body_stmt) == GIMPLE_ASSIGN)\n+\t\tcontinue;\n+\t      else if (gimple_code (body_stmt) == GIMPLE_OMP_FOR\n+\t\t       && gsi_one_before_end_p (gsi))\n+\t\treturn body_stmt;\n+\t      else\n+\t\treturn NULL;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Helper for adjust_region_code: evaluate the statement at GSI_P.  */\n+\n+static tree\n+adjust_region_code_walk_stmt_fn (gimple_stmt_iterator *gsi_p,\n+\t\t\t\t bool *handled_ops_p,\n+\t\t\t\t struct walk_stmt_info *wi)\n+{\n+  int *region_code = (int *) wi->info;\n+\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_OMP_FOR:\n+      {\n+\ttree clauses = gimple_omp_for_clauses (stmt);\n+\tif (omp_find_clause (clauses, OMP_CLAUSE_INDEPENDENT))\n+\t  {\n+\t    /* Explicit 'independent' clause.  */\n+\t    /* Keep going; recurse into loop body.  */\n+\t    break;\n+\t  }\n+\telse if (omp_find_clause (clauses, OMP_CLAUSE_SEQ))\n+\t  {\n+\t    /* Explicit 'seq' clause.  */\n+\t    /* We'll \"parallelize\" if at some level a loop construct has been\n+\t       marked up by the user as unparallelizable ('seq' clause; we'll\n+\t       respect that in the later processing).  Given that the user has\n+\t       explicitly marked it up, this loop construct cannot be\n+\t       performance-critical, and in this case it's also fine to\n+\t       \"parallelize\" instead of \"gang-single\", because any outer or\n+\t       inner loops may still exploit the available parallelism.  */\n+\t    /* Keep going; recurse into loop body.  */\n+\t    break;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Explicit or implicit 'auto' clause.  */\n+\t    /* The user would like this loop analyzed ('auto' clause) and\n+\t       typically parallelized, but we don't have available yet the\n+\t       compiler logic to analyze this, so can't parallelize it here, so\n+\t       we'd very likely be running into a performance problem if we\n+\t       were to execute this unparallelized, thus forward the whole loop\n+\t       nest to 'parloops'.  */\n+\t    *region_code = GF_OMP_TARGET_KIND_OACC_KERNELS;\n+\t    /* Terminate: final decision for this region.  */\n+\t    *handled_ops_p = true;\n+\t    return integer_zero_node;\n+\t  }\n+\tgcc_unreachable ();\n+      }\n+\n+    case GIMPLE_COND:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_SWITCH:\n+    case GIMPLE_ASM:\n+    case GIMPLE_TRANSACTION:\n+    case GIMPLE_RETURN:\n+      /* Statement that might constitute some looping/control flow pattern.  */\n+      /* The user would like this code analyzed (implicit inside a 'kernels'\n+\t region) and typically parallelized, but we don't have available yet\n+\t the compiler logic to analyze this, so can't parallelize it here, so\n+\t we'd very likely be running into a performance problem if we were to\n+\t execute this unparallelized, thus forward the whole thing to\n+\t 'parloops'.  */\n+      *region_code = GF_OMP_TARGET_KIND_OACC_KERNELS;\n+      /* Terminate: final decision for this region.  */\n+      *handled_ops_p = true;\n+      return integer_zero_node;\n+\n+    default:\n+      /* Keep going.  */\n+      break;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Adjust the REGION_CODE for the region in GS.  */\n+\n+static void\n+adjust_region_code (gimple_seq gs, int *region_code)\n+{\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = region_code;\n+  walk_gimple_seq (gs, adjust_region_code_walk_stmt_fn, NULL, &wi);\n+}\n+\n+/* Helper function for make_loops_gang_single for walking the tree.  If the\n+   statement indicated by GSI_P is an OpenACC for loop with a gang clause,\n+   issue a warning and remove the clause.  */\n+\n+static tree\n+visit_loops_in_gang_single_region (gimple_stmt_iterator *gsi_p,\n+\t\t\t\t   bool *handled_ops_p,\n+\t\t\t\t   struct walk_stmt_info *)\n+{\n+  *handled_ops_p = false;\n+\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_OMP_FOR:\n+      /*TODO Given the current 'adjust_region_code' algorithm, this is\n+\tactually...  */\n+      gcc_unreachable ();\n+\n+      {\n+\ttree clauses = gimple_omp_for_clauses (stmt);\n+\ttree prev_clause = NULL;\n+\tfor (tree clause = clauses; clause; clause = OMP_CLAUSE_CHAIN (clause))\n+\t  {\n+\t    if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_GANG)\n+\t      {\n+\t\t/* It makes no sense to have a 'gang' clause in a \"gang-single\"\n+\t\t   region, so warn and remove it.  */\n+\t\twarning_at (gimple_location (stmt), 0,\n+\t\t\t    \"conditionally executed loop in %<kernels%> region\"\n+\t\t\t    \" will be executed by a single gang;\"\n+\t\t\t    \" ignoring %<gang%> clause\");\n+\t\tif (prev_clause != NULL)\n+\t\t  OMP_CLAUSE_CHAIN (prev_clause) = OMP_CLAUSE_CHAIN (clause);\n+\t\telse\n+\t\t  clauses = OMP_CLAUSE_CHAIN (clause);\n+\n+\t\tbreak;\n+\t      }\n+\t    prev_clause = clause;\n+\t  }\n+\tgimple_omp_for_set_clauses (stmt, clauses);\n+      }\n+      /* No need to recurse into nested statements; no loop nested inside\n+\t this loop can be gang-partitioned.  */\n+      sorry (\"%<gang%> loop in %<gang-single%> region\");\n+      *handled_ops_p = true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Visit all nested OpenACC loops in the sequence indicated by GS.  This\n+   statement is expected to be inside a gang-single region.  Issue a warning\n+   for any loops inside it that have gang clauses and remove the clauses.  */\n+\n+static void\n+make_loops_gang_single (gimple_seq gs)\n+{\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  walk_gimple_seq (gs, visit_loops_in_gang_single_region, NULL, &wi);\n+}\n+\n+/* Construct a \"gang-single\" compute construct at LOC containing the STMTS.\n+   Annotate with CLAUSES, which must not contain a 'num_gangs' clause, and an\n+   additional 'num_gangs (1)' clause to force \"gang-single\" execution.  */\n+\n+static gimple *\n+make_region_seq (location_t loc, gimple_seq stmts,\n+\t\t tree num_gangs_clause,\n+\t\t tree num_workers_clause,\n+\t\t tree vector_length_clause,\n+\t\t tree clauses)\n+{\n+  /* This correctly unshares the entire clause chain rooted here.  */\n+  clauses = unshare_expr (clauses);\n+\n+  dump_user_location_t loc_stmts_first = gimple_seq_first (stmts);\n+\n+  /* Figure out the region code for this region.  */\n+  /* Optimistic default: assume \"setup code\", no looping; thus not\n+     performance-critical.  */\n+  int region_code = GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE;\n+  adjust_region_code (stmts, &region_code);\n+\n+  if (region_code == GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_GANG_SINGLE)\n+    {\n+      if (dump_enabled_p ())\n+\t/*TODO MSG_MISSED_OPTIMIZATION? */\n+\tdump_printf_loc (MSG_NOTE, loc_stmts_first,\n+\t\t\t \"beginning %<gang-single%> part\"\n+\t\t\t \" in OpenACC %<kernels%> region\\n\");\n+\n+      /* Synthesize a 'num_gangs (1)' clause.  */\n+      tree gang_single_clause = build_omp_clause (loc, OMP_CLAUSE_NUM_GANGS);\n+      OMP_CLAUSE_OPERAND (gang_single_clause, 0) = integer_one_node;\n+      OMP_CLAUSE_CHAIN (gang_single_clause) = clauses;\n+      clauses = gang_single_clause;\n+\n+      /* Remove and issue warnings about gang clauses on any OpenACC\n+\t loops nested inside this sequentially executed statement.  */\n+      make_loops_gang_single (stmts);\n+    }\n+  else if (region_code == GF_OMP_TARGET_KIND_OACC_KERNELS)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, loc_stmts_first,\n+\t\t\t \"beginning %<parloops%> part\"\n+\t\t\t \" in OpenACC %<kernels%> region\\n\");\n+\n+      /* As we're transforming a 'GF_OMP_TARGET_KIND_OACC_KERNELS' into another\n+\t 'GF_OMP_TARGET_KIND_OACC_KERNELS', this isn't doing any of the clauses\n+\t mangling that 'make_region_loop_nest' is doing.  */\n+      /* Re-assemble the clauses stripped off earlier.  */\n+      if (num_gangs_clause != NULL)\n+\t{\n+\t  tree c = unshare_expr (num_gangs_clause);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (num_workers_clause != NULL)\n+\t{\n+\t  tree c = unshare_expr (num_workers_clause);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+      if (vector_length_clause != NULL)\n+\t{\n+\t  tree c = unshare_expr (vector_length_clause);\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* Build the gang-single region.  */\n+  gimple *single_region = gimple_build_omp_target (NULL, region_code, clauses);\n+  gimple_set_location (single_region, loc);\n+  gbind *single_body = gimple_build_bind (NULL, stmts, make_node (BLOCK));\n+  gimple_omp_set_body (single_region, single_body);\n+\n+  return single_region;\n+}\n+\n+/* Helper function for make_region_loop_nest.  Adds a 'num_gangs'\n+   ('num_workers', 'vector_length') clause to the given CLAUSES, either the one\n+   from the parent compute construct (PARENT_CLAUSE) or a new one based on the\n+   loop's own LOOP_CLAUSE ('gang (num: N)' or similar for 'worker' or 'vector'\n+   clauses) with the given CLAUSE_CODE.  Does nothing if neither PARENT_CLAUSE\n+   nor LOOP_CLAUSE exist.  Returns the new clauses.  */\n+\n+static tree\n+add_parent_or_loop_num_clause (tree parent_clause, tree loop_clause,\n+\t\t\t       omp_clause_code clause_code, tree clauses)\n+{\n+  if (parent_clause != NULL)\n+    {\n+      tree num_clause = unshare_expr (parent_clause);\n+      OMP_CLAUSE_CHAIN (num_clause) = clauses;\n+      clauses = num_clause;\n+    }\n+  else if (loop_clause != NULL)\n+    {\n+      /* The kernels region does not have a 'num_gangs' clause, but the loop\n+\t itself had a 'gang (num: N)' clause.  Honor it by adding a\n+\t 'num_gangs (N)' clause on the compute construct.  */\n+      tree num = OMP_CLAUSE_OPERAND (loop_clause, 0);\n+      tree new_num_clause\n+\t= build_omp_clause (OMP_CLAUSE_LOCATION (loop_clause), clause_code);\n+      OMP_CLAUSE_OPERAND (new_num_clause, 0) = num;\n+      OMP_CLAUSE_CHAIN (new_num_clause) = clauses;\n+      clauses = new_num_clause;\n+    }\n+  return clauses;\n+}\n+\n+/* Helper for make_region_loop_nest, looking for 'worker (num: N)' or 'vector\n+   (length: N)' clauses in nested loops.  Removes the argument, transferring it\n+   to the enclosing compute construct (via WI->INFO).  If arguments within the\n+   same loop nest conflict, emits a warning.\n+\n+   This function also decides whether to add an 'auto' clause on each of these\n+   nested loops.  */\n+\n+struct adjust_nested_loop_clauses_wi_info\n+{\n+  tree *loop_gang_clause_ptr;\n+  tree *loop_worker_clause_ptr;\n+  tree *loop_vector_clause_ptr;\n+};\n+\n+static tree\n+adjust_nested_loop_clauses (gimple_stmt_iterator *gsi_p, bool *,\n+\t\t\t    struct walk_stmt_info *wi)\n+{\n+  struct adjust_nested_loop_clauses_wi_info *wi_info\n+    = (struct adjust_nested_loop_clauses_wi_info *) wi->info;\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+\n+  if (gimple_code (stmt) == GIMPLE_OMP_FOR)\n+    {\n+      bool add_auto_clause = true;\n+      tree loop_clauses = gimple_omp_for_clauses (stmt);\n+      tree loop_clause = loop_clauses;\n+      for (; loop_clause; loop_clause = OMP_CLAUSE_CHAIN (loop_clause))\n+\t{\n+\t  tree *outer_clause_ptr = NULL;\n+\t  switch (OMP_CLAUSE_CODE (loop_clause))\n+\t    {\n+\t    case OMP_CLAUSE_GANG:\n+\t      outer_clause_ptr = wi_info->loop_gang_clause_ptr;\n+\t      break;\n+\t    case OMP_CLAUSE_WORKER:\n+\t      outer_clause_ptr = wi_info->loop_worker_clause_ptr;\n+\t      break;\n+\t    case OMP_CLAUSE_VECTOR:\n+\t      outer_clause_ptr = wi_info->loop_vector_clause_ptr;\n+\t      break;\n+\t    case OMP_CLAUSE_SEQ:\n+\t    case OMP_CLAUSE_INDEPENDENT:\n+\t    case OMP_CLAUSE_AUTO:\n+\t      add_auto_clause = false;\n+\t    default:\n+\t      break;\n+\t    }\n+\t  if (outer_clause_ptr != NULL)\n+\t    {\n+\t      if (OMP_CLAUSE_OPERAND (loop_clause, 0) != NULL\n+\t\t  && *outer_clause_ptr == NULL)\n+\t\t{\n+\t\t  /* Transfer the clause to the enclosing compute construct and\n+\t\t     remove the numerical argument from the 'loop'.  */\n+\t\t  *outer_clause_ptr = unshare_expr (loop_clause);\n+\t\t  OMP_CLAUSE_OPERAND (loop_clause, 0) = NULL;\n+\t\t}\n+\t      else if (OMP_CLAUSE_OPERAND (loop_clause, 0) != NULL &&\n+\t\t       OMP_CLAUSE_OPERAND (*outer_clause_ptr, 0) != NULL)\n+\t\t{\n+\t\t  /* See if both of these are the same constant.  If they\n+\t\t     aren't, emit a warning.  */\n+\t\t  tree old_op = OMP_CLAUSE_OPERAND (*outer_clause_ptr, 0);\n+\t\t  tree new_op = OMP_CLAUSE_OPERAND (loop_clause, 0);\n+\t\t  if (!(cst_and_fits_in_hwi (old_op) &&\n+\t\t\tcst_and_fits_in_hwi (new_op) &&\n+\t\t\tint_cst_value (old_op) == int_cst_value (new_op)))\n+\t\t    {\n+\t\t      const char *clause_name\n+\t\t\t= omp_clause_code_name[OMP_CLAUSE_CODE (loop_clause)];\n+\t\t      error_at (gimple_location (stmt),\n+\t\t\t\t\"cannot honor conflicting %qs clause\",\n+\t\t\t\tclause_name);\n+\t\t      inform (OMP_CLAUSE_LOCATION (*outer_clause_ptr),\n+\t\t\t      \"location of the previous clause\"\n+\t\t\t      \" in the same loop nest\");\n+\t\t    }\n+\t\t  OMP_CLAUSE_OPERAND (loop_clause, 0) = NULL;\n+\t\t}\n+\t    }\n+\t}\n+      if (add_auto_clause)\n+\t{\n+\t  tree auto_clause\n+\t    = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_AUTO);\n+\t  OMP_CLAUSE_CHAIN (auto_clause) = loop_clauses;\n+\t  gimple_omp_for_set_clauses (stmt, auto_clause);\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Helper for make_region_loop_nest.  Transform OpenACC 'kernels'/'loop'\n+   construct clauses into OpenACC 'parallel'/'loop' construct ones.  */\n+\n+static tree\n+transform_kernels_loop_clauses (gimple *omp_for,\n+\t\t\t\ttree num_gangs_clause,\n+\t\t\t\ttree num_workers_clause,\n+\t\t\t\ttree vector_length_clause,\n+\t\t\t\ttree clauses)\n+{\n+  /* If this loop in a kernels region does not have an explicit 'seq',\n+     'independent', or 'auto' clause, we must give it an explicit 'auto'\n+     clause.\n+     We also check for 'gang (num: N)' clauses.  These must not appear in\n+     kernels regions that have their own 'num_gangs' clause.  Otherwise, they\n+     must be converted and put on the region; similarly for 'worker' and\n+     'vector' clauses.  */\n+  bool add_auto_clause = true;\n+  tree loop_gang_clause = NULL, loop_worker_clause = NULL,\n+       loop_vector_clause = NULL;\n+  tree loop_clauses = gimple_omp_for_clauses (omp_for);\n+  for (tree loop_clause = loop_clauses;\n+       loop_clause;\n+       loop_clause = OMP_CLAUSE_CHAIN (loop_clause))\n+    {\n+      bool found_num_clause = false;\n+      tree *clause_ptr, clause_to_check;\n+      switch (OMP_CLAUSE_CODE (loop_clause))\n+\t{\n+\tcase OMP_CLAUSE_GANG:\n+\t  found_num_clause = true;\n+\t  clause_ptr = &loop_gang_clause;\n+\t  clause_to_check = num_gangs_clause;\n+\t  break;\n+\tcase OMP_CLAUSE_WORKER:\n+\t  found_num_clause = true;\n+\t  clause_ptr = &loop_worker_clause;\n+\t  clause_to_check = num_workers_clause;\n+\t  break;\n+\tcase OMP_CLAUSE_VECTOR:\n+\t  found_num_clause = true;\n+\t  clause_ptr = &loop_vector_clause;\n+\t  clause_to_check = vector_length_clause;\n+\t  break;\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\tcase OMP_CLAUSE_SEQ:\n+\tcase OMP_CLAUSE_AUTO:\n+\t  add_auto_clause = false;\n+\tdefault:\n+\t  break;\n+\t}\n+      if (found_num_clause && OMP_CLAUSE_OPERAND (loop_clause, 0) != NULL)\n+\t{\n+\t  if (clause_to_check)\n+\t    {\n+\t      const char *clause_name\n+\t\t= omp_clause_code_name[OMP_CLAUSE_CODE (loop_clause)];\n+\t      const char *parent_clause_name\n+\t\t= omp_clause_code_name[OMP_CLAUSE_CODE (clause_to_check)];\n+\t      error_at (OMP_CLAUSE_LOCATION (loop_clause),\n+\t\t\t\"argument not permitted on %qs clause\"\n+\t\t\t\" in OpenACC %<kernels%> region with a %qs clause\",\n+\t\t\tclause_name, parent_clause_name);\n+\t      inform (OMP_CLAUSE_LOCATION (clause_to_check),\n+\t\t      \"location of OpenACC %<kernels%>\");\n+\t    }\n+\t  /* Copy the 'gang (N)'/'worker (N)'/'vector (N)' clause to the\n+\t     enclosing compute construct.  */\n+\t  *clause_ptr = unshare_expr (loop_clause);\n+\t  OMP_CLAUSE_CHAIN (*clause_ptr) = NULL;\n+\t  /* Leave a 'gang'/'worker'/'vector' clause on the 'loop', but without\n+\t     argument.  */\n+\t  OMP_CLAUSE_OPERAND (loop_clause, 0) = NULL;\n+\t}\n+    }\n+  if (add_auto_clause)\n+    {\n+      tree auto_clause = build_omp_clause (gimple_location (omp_for),\n+\t\t\t\t\t   OMP_CLAUSE_AUTO);\n+      OMP_CLAUSE_CHAIN (auto_clause) = loop_clauses;\n+      loop_clauses = auto_clause;\n+    }\n+  gimple_omp_for_set_clauses (omp_for, loop_clauses);\n+  /* We must also recurse into the loop; it might contain nested loops having\n+     their own 'worker (num: W)' or 'vector (length: V)' clauses.  Turn these\n+     into 'worker'/'vector' clauses on the compute construct.  */\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  struct adjust_nested_loop_clauses_wi_info wi_info;\n+  wi_info.loop_gang_clause_ptr = &loop_gang_clause;\n+  wi_info.loop_worker_clause_ptr = &loop_worker_clause;\n+  wi_info.loop_vector_clause_ptr = &loop_vector_clause;\n+  wi.info = &wi_info;\n+  gimple *body = gimple_omp_body (omp_for);\n+  walk_gimple_seq (body, adjust_nested_loop_clauses, NULL, &wi);\n+  /* Check if there were conflicting numbers of workers or vector length.  */\n+  if (loop_gang_clause != NULL &&\n+      OMP_CLAUSE_OPERAND (loop_gang_clause, 0) == NULL)\n+    loop_gang_clause = NULL;\n+  if (loop_worker_clause != NULL &&\n+      OMP_CLAUSE_OPERAND (loop_worker_clause, 0) == NULL)\n+    loop_worker_clause = NULL;\n+  if (loop_vector_clause != NULL &&\n+      OMP_CLAUSE_OPERAND (loop_vector_clause, 0) == NULL)\n+    vector_length_clause = NULL;\n+\n+  /* If the kernels region had 'num_gangs', 'num_worker', 'vector_length'\n+     clauses, add these to this new compute construct.  */\n+  clauses\n+    = add_parent_or_loop_num_clause (num_gangs_clause, loop_gang_clause,\n+\t\t\t\t     OMP_CLAUSE_NUM_GANGS, clauses);\n+  clauses\n+    = add_parent_or_loop_num_clause (num_workers_clause, loop_worker_clause,\n+\t\t\t\t     OMP_CLAUSE_NUM_WORKERS, clauses);\n+  clauses\n+    = add_parent_or_loop_num_clause (vector_length_clause, loop_vector_clause,\n+\t\t\t\t     OMP_CLAUSE_VECTOR_LENGTH, clauses);\n+\n+  return clauses;\n+}\n+\n+/* Construct a possibly gang-parallel compute construct containing the STMT,\n+   which must be identical to, or a bind containing, the loop OMP_FOR.\n+\n+   The NUM_GANGS_CLAUSE, NUM_WORKERS_CLAUSE, and VECTOR_LENGTH_CLAUSE are\n+   optional clauses from the original kernels region and must not be contained\n+   in the other CLAUSES. The newly created compute construct is annotated with\n+   the optional NUM_GANGS_CLAUSE as well as the other CLAUSES.  If there is no\n+   NUM_GANGS_CLAUSE but the loop has a 'gang (num: N)' clause, that is\n+   converted to a 'num_gangs (N)' clause on the new compute construct, and\n+   similarly for 'worker' and 'vector' clauses.\n+\n+   The outermost loop gets an 'auto' clause unless there already is an\n+   'seq'/'independent'/'auto' clause.  Nested loops inside OMP_FOR are treated\n+   similarly by the adjust_nested_loop_clauses function.  */\n+\n+static gimple *\n+make_region_loop_nest (gimple *omp_for, gimple_seq stmts,\n+\t\t       tree num_gangs_clause,\n+\t\t       tree num_workers_clause,\n+\t\t       tree vector_length_clause,\n+\t\t       tree clauses)\n+{\n+  /* This correctly unshares the entire clause chain rooted here.  */\n+  clauses = unshare_expr (clauses);\n+\n+  /* Figure out the region code for this region.  */\n+  /* Optimistic default: assume that the loop nest is parallelizable\n+     (essentially, no GIMPLE_OMP_FOR with (explicit or implicit) 'auto' clause,\n+     and no un-annotated loops).  */\n+  int region_code = GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED;\n+  adjust_region_code (stmts, &region_code);\n+\n+  if (region_code == GF_OMP_TARGET_KIND_OACC_PARALLEL_KERNELS_PARALLELIZED)\n+    {\n+      if (dump_enabled_p ())\n+\t/* This is not MSG_OPTIMIZED_LOCATIONS, as we're just doing what the\n+\t   user asked us to.  */\n+\tdump_printf_loc (MSG_NOTE, omp_for,\n+\t\t\t \"parallelized loop nest\"\n+\t\t\t \" in OpenACC %<kernels%> region\\n\");\n+\n+      clauses = transform_kernels_loop_clauses (omp_for,\n+\t\t\t\t\t\tnum_gangs_clause,\n+\t\t\t\t\t\tnum_workers_clause,\n+\t\t\t\t\t\tvector_length_clause,\n+\t\t\t\t\t\tclauses);\n+    }\n+  else if (region_code == GF_OMP_TARGET_KIND_OACC_KERNELS)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, omp_for,\n+\t\t\t \"forwarded loop nest\"\n+\t\t\t \" in OpenACC %<kernels%> region\"\n+\t\t\t \" to %<parloops%> for analysis\\n\");\n+\n+      /* We're transforming one 'GF_OMP_TARGET_KIND_OACC_KERNELS' into another\n+\t 'GF_OMP_TARGET_KIND_OACC_KERNELS', so don't have to\n+\t 'transform_kernels_loop_clauses'.  */\n+      /* Re-assemble the clauses stripped off earlier.  */\n+      clauses\n+\t= add_parent_or_loop_num_clause (num_gangs_clause, NULL,\n+\t\t\t\t\t OMP_CLAUSE_NUM_GANGS, clauses);\n+      clauses\n+\t= add_parent_or_loop_num_clause (num_workers_clause, NULL,\n+\t\t\t\t\t OMP_CLAUSE_NUM_WORKERS, clauses);\n+      clauses\n+\t= add_parent_or_loop_num_clause (vector_length_clause, NULL,\n+\t\t\t\t\t OMP_CLAUSE_VECTOR_LENGTH, clauses);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  gimple *parallel_body_bind\n+    = gimple_build_bind (NULL, stmts, make_node (BLOCK));\n+  gimple *parallel_region\n+    = gimple_build_omp_target (parallel_body_bind, region_code, clauses);\n+  gimple_set_location (parallel_region, gimple_location (omp_for));\n+\n+  return parallel_region;\n+}\n+\n+/* Eliminate any binds directly inside BIND by adding their statements to\n+   BIND (i.e., modifying it in place), excluding binds that hold only an\n+   OMP_FOR loop and associated setup/cleanup code.  Recurse into binds but\n+   not other statements.  Return a chain of the local variables of eliminated\n+   binds, i.e., the local variables found in nested binds.  If\n+   INCLUDE_TOPLEVEL_VARS is true, this also includes the variables belonging\n+   to BIND itself. */\n+\n+static tree\n+flatten_binds (gbind *bind, bool include_toplevel_vars = false)\n+{\n+  tree vars = NULL, last_var = NULL;\n+\n+  if (include_toplevel_vars)\n+    {\n+      vars = gimple_bind_vars (bind);\n+      last_var = vars;\n+    }\n+\n+  gimple_seq new_body = NULL;\n+  gimple_seq body_sequence = gimple_bind_body (bind);\n+  gimple_stmt_iterator gsi, gsi_n;\n+  for (gsi = gsi_start (body_sequence); !gsi_end_p (gsi); gsi = gsi_n)\n+    {\n+      /* Advance the iterator here because otherwise it would be invalidated\n+\t by moving statements below.  */\n+      gsi_n = gsi;\n+      gsi_next (&gsi_n);\n+\n+      gimple *stmt = gsi_stmt (gsi);\n+      /* Flatten bind statements, except the ones that contain only an\n+\t OpenACC for loop.  */\n+      if (gimple_code (stmt) == GIMPLE_BIND\n+\t  && !top_level_omp_for_in_stmt (stmt))\n+\t{\n+\t  gbind *inner_bind = as_a <gbind *> (stmt);\n+\t  /* Flatten recursively, and collect all variables.  */\n+\t  tree inner_vars = flatten_binds (inner_bind, true);\n+\t  gimple_seq inner_sequence = gimple_bind_body (inner_bind);\n+\t  gcc_assert (gimple_code (inner_sequence) != GIMPLE_BIND\n+\t\t      || top_level_omp_for_in_stmt (inner_sequence));\n+\t  gimple_seq_add_seq (&new_body, inner_sequence);\n+\t  /* Find the last variable; we will append others to it.  */\n+\t  while (last_var != NULL && TREE_CHAIN (last_var) != NULL)\n+\t    last_var = TREE_CHAIN (last_var);\n+\t  if (last_var != NULL)\n+\t    {\n+\t      TREE_CHAIN (last_var) = inner_vars;\n+\t      last_var = inner_vars;\n+\t    }\n+\t  else\n+\t    {\n+\t      vars = inner_vars;\n+\t      last_var = vars;\n+\t    }\n+\t}\n+      else\n+\tgimple_seq_add_stmt (&new_body, stmt);\n+    }\n+\n+  /* Put the possibly transformed body back into the bind.  */\n+  gimple_bind_set_body (bind, new_body);\n+  return vars;\n+}\n+\n+/* Helper function for places where we construct data regions.  Wraps the BODY\n+   inside a try-finally construct at LOC that calls __builtin_GOACC_data_end\n+   in its cleanup block.  Returns this try statement.  */\n+\n+static gimple *\n+make_data_region_try_statement (location_t loc, gimple *body)\n+{\n+  tree data_end_fn = builtin_decl_explicit (BUILT_IN_GOACC_DATA_END);\n+  gimple *call = gimple_build_call (data_end_fn, 0);\n+  gimple_seq cleanup = NULL;\n+  gimple_seq_add_stmt (&cleanup, call);\n+  gimple *try_stmt = gimple_build_try (body, cleanup, GIMPLE_TRY_FINALLY);\n+  gimple_set_location (body, loc);\n+  return try_stmt;\n+}\n+\n+/* If INNER_BIND_VARS holds variables, build an OpenACC data region with\n+   location LOC containing BODY and having 'create (var)' clauses for each\n+   variable.  If INNER_CLEANUP is present, add a try-finally statement with\n+   this cleanup code in the finally block.  Return the new data region, or\n+   the original BODY if no data region was needed.  */\n+\n+static gimple *\n+maybe_build_inner_data_region (location_t loc, gimple *body,\n+\t\t\t       tree inner_bind_vars, gimple *inner_cleanup)\n+{\n+  /* Build data 'create (var)' clauses for these local variables.\n+     Below we will add these to a data region enclosing the entire body\n+     of the decomposed kernels region.  */\n+  tree prev_mapped_var = NULL, next = NULL, artificial_vars = NULL,\n+       inner_data_clauses = NULL;\n+  for (tree v = inner_bind_vars; v; v = next)\n+    {\n+      next = TREE_CHAIN (v);\n+      if (DECL_ARTIFICIAL (v)\n+\t  || TREE_CODE (v) == CONST_DECL\n+\t  || (DECL_LANG_SPECIFIC (current_function_decl)\n+\t      && DECL_TEMPLATE_INSTANTIATION (current_function_decl)))\n+\t{\n+\t  /* If this is an artificial temporary, it need not be mapped.  We\n+\t     move its declaration into the bind inside the data region.\n+\t     Also avoid mapping variables if we are inside a template\n+\t     instantiation; the code does not contain all the copies to\n+\t     temporaries that would make this legal.  */\n+\t  TREE_CHAIN (v) = artificial_vars;\n+\t  artificial_vars = v;\n+\t  if (prev_mapped_var != NULL)\n+\t    TREE_CHAIN (prev_mapped_var) = next;\n+\t  else\n+\t    inner_bind_vars = next;\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, build the map clause.  */\n+\t  tree new_clause = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_SET_MAP_KIND (new_clause, GOMP_MAP_ALLOC);\n+\t  OMP_CLAUSE_DECL (new_clause) = v;\n+\t  OMP_CLAUSE_SIZE (new_clause) = DECL_SIZE_UNIT (v);\n+\t  OMP_CLAUSE_CHAIN (new_clause) = inner_data_clauses;\n+\t  inner_data_clauses = new_clause;\n+\n+\t  prev_mapped_var = v;\n+\t}\n+    }\n+\n+  if (artificial_vars)\n+    body = gimple_build_bind (artificial_vars, body, make_node (BLOCK));\n+\n+  /* If we determined above that there are variables that need to be created\n+     on the device, construct a data region for them and wrap the body\n+     inside that.  */\n+  if (inner_data_clauses != NULL)\n+    {\n+      gcc_assert (inner_bind_vars != NULL);\n+      gimple *inner_data_region\n+\t= gimple_build_omp_target (NULL, GF_OMP_TARGET_KIND_OACC_DATA_KERNELS,\n+\t\t\t\t   inner_data_clauses);\n+      gimple_set_location (inner_data_region, loc);\n+      /* Make sure __builtin_GOACC_data_end is called at the end.  */\n+      gimple *try_stmt = make_data_region_try_statement (loc, body);\n+      gimple_omp_set_body (inner_data_region, try_stmt);\n+      gimple *bind_body;\n+      if (inner_cleanup != NULL)\n+\t/* Clobber all the inner variables that need to be clobbered.  */\n+\tbind_body = gimple_build_try (inner_data_region, inner_cleanup,\n+\t\t\t\t      GIMPLE_TRY_FINALLY);\n+      else\n+\tbind_body = inner_data_region;\n+      body = gimple_build_bind (inner_bind_vars, bind_body, make_node (BLOCK));\n+    }\n+\n+  return body;\n+}\n+\n+/* Helper function of decompose_kernels_region_body.  The statements in\n+   REGION_BODY are expected to be decomposed parts; add an 'async' clause to\n+   each.  Also add a 'wait' directive at the end of the sequence.  */\n+\n+static void\n+add_async_clauses_and_wait (location_t loc, gimple_seq *region_body)\n+{\n+  tree default_async_queue\n+    = build_int_cst (integer_type_node, GOMP_ASYNC_NOVAL);\n+  for (gimple_stmt_iterator gsi = gsi_start (*region_body);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      tree target_clauses = gimple_omp_target_clauses (stmt);\n+      tree new_async_clause = build_omp_clause (loc, OMP_CLAUSE_ASYNC);\n+      OMP_CLAUSE_OPERAND (new_async_clause, 0) = default_async_queue;\n+      OMP_CLAUSE_CHAIN (new_async_clause) = target_clauses;\n+      target_clauses = new_async_clause;\n+      gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt),\n+\t\t\t\t     target_clauses);\n+    }\n+  /* A '#pragma acc wait' is just a call 'GOACC_wait (acc_async_sync, 0)'.  */\n+  tree wait_fn = builtin_decl_explicit (BUILT_IN_GOACC_WAIT);\n+  tree sync_arg = build_int_cst (integer_type_node, GOMP_ASYNC_SYNC);\n+  gimple *wait_call = gimple_build_call (wait_fn, 2,\n+\t\t\t\t\t sync_arg, integer_zero_node);\n+  gimple_set_location (wait_call, loc);\n+  gimple_seq_add_stmt (region_body, wait_call);\n+}\n+\n+/* Auxiliary analysis of the body of a kernels region, to determine for each\n+   OpenACC loop whether it is control-dependent (i.e., not necessarily\n+   executed every time the kernels region is entered) or not.\n+   We say that a loop is control-dependent if there is some cond, switch, or\n+   goto statement that jumps over it, forwards or backwards.  For example,\n+   if the loop is controlled by an if statement, then a jump to the true\n+   block, the false block, or from one of those blocks to the control flow\n+   join point will necessarily jump over the loop.\n+   This analysis implements an ad-hoc union-find data structure classifying\n+   statements into \"control-flow regions\" as follows: Most statements are in\n+   the same region as their predecessor, except that each OpenACC loop is in\n+   a region of its own, and each OpenACC loop's successor starts a new\n+   region.  We then unite the regions of any statements linked by jumps,\n+   placing any cond, switch, or goto statement in the same region as its\n+   target label(s).\n+   In the end, control dependence of OpenACC loops can be determined by\n+   comparing their immediate predecessor and successor statements' regions.\n+   A jump crosses the loop if and only if the predecessor and successor are\n+   in the same region.  (If there is no predecessor or successor, the loop\n+   is executed unconditionally.)\n+   The methods in this class identify statements by their index in the\n+   kernels region's body.  */\n+\n+class control_flow_regions\n+{\n+  public:\n+    /* Initialize an instance and pre-compute the control-flow region\n+       information for the statement sequence SEQ.  */\n+    control_flow_regions (gimple_seq seq);\n+\n+    /* Return true if the statement with the given index IDX in the analyzed\n+       statement sequence is an unconditionally executed OpenACC loop.  */\n+    bool is_unconditional_oacc_for_loop (size_t idx);\n+\n+  private:\n+    /* Find the region representative for the statement identified by index\n+       STMT_IDX.  */\n+    size_t find_rep (size_t stmt_idx);\n+\n+    /* Union the regions containing the statements represented by\n+       representatives A and B.  */\n+    void union_reps (size_t a, size_t b);\n+\n+    /* Helper for the constructor.  Performs the actual computation of the\n+       control-flow regions in the statement sequence SEQ.  */\n+    void compute_regions (gimple_seq seq);\n+\n+    /* The mapping from statement indices to region representatives.  */\n+    vec <size_t> representatives;\n+\n+    /* A cache mapping statement indices to a flag indicating whether the\n+       statement is a top level OpenACC for loop.  */\n+    vec <bool> omp_for_loops;\n+};\n+\n+control_flow_regions::control_flow_regions (gimple_seq seq)\n+{\n+  representatives.create (1);\n+  omp_for_loops.create (1);\n+  compute_regions (seq);\n+}\n+\n+bool\n+control_flow_regions::is_unconditional_oacc_for_loop (size_t idx)\n+{\n+  if (idx == 0 || idx == representatives.length () - 1)\n+    /* The first or last statement in the kernels region.  This means that\n+       there is no room before or after it for a jump or a label.  Thus\n+       there cannot be a jump across it, so it is unconditional.  */\n+    return true;\n+  /* Otherwise, the loop is unconditional if the statements before and after\n+     it are in different control flow regions.  Scan forward and backward,\n+     skipping over neighboring OpenACC for loops, to find these preceding\n+     statements.  */\n+  size_t prev_index = idx - 1;\n+  while (prev_index > 0 && omp_for_loops [prev_index] == true)\n+    prev_index--;\n+  /* If all preceding statements are also OpenACC loops, all of these are\n+     unconditional.  */\n+  if (prev_index == 0)\n+    return true;\n+  size_t succ_index = idx + 1;\n+  while (succ_index < omp_for_loops.length ()\n+\t && omp_for_loops [succ_index] == true)\n+    succ_index++;\n+  /* If all following statements are also OpenACC loops, all of these are\n+     unconditional.  */\n+  if (succ_index == omp_for_loops.length ())\n+    return true;\n+  return (find_rep (prev_index) != find_rep (succ_index));\n+}\n+\n+size_t\n+control_flow_regions::find_rep (size_t stmt_idx)\n+{\n+  size_t rep = stmt_idx, aux = stmt_idx;\n+  /* Find the root representative of this statement.  */\n+  while (representatives[rep] != rep)\n+    rep = representatives[rep];\n+  /* Compress the path from the original statement to the representative.  */\n+  while (representatives[aux] != rep)\n+    {\n+      size_t tmp = representatives[aux];\n+      representatives[aux] = rep;\n+      aux = tmp;\n+    }\n+  return rep;\n+}\n+\n+void\n+control_flow_regions::union_reps (size_t a, size_t b)\n+{\n+  a = find_rep (a);\n+  b = find_rep (b);\n+  representatives[b] = a;\n+}\n+\n+void\n+control_flow_regions::compute_regions (gimple_seq seq)\n+{\n+  hash_map <gimple *, size_t> control_flow_reps;\n+  hash_map <tree, size_t> label_reps;\n+  size_t current_region = 0, idx = 0;\n+\n+  /* In a first pass, assign an initial region to each statement.  Except in\n+     the case of OpenACC loops, each statement simply gets the same region\n+     representative as its predecessor.  */\n+  for (gimple_stmt_iterator gsi = gsi_start (seq);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      gimple *omp_for = top_level_omp_for_in_stmt (stmt);\n+      omp_for_loops.safe_push (omp_for != NULL);\n+      if (omp_for != NULL)\n+\t{\n+\t  /* Assign a new region to this loop and to its successor.  */\n+\t  current_region = idx;\n+\t  representatives.safe_push (current_region);\n+\t  current_region++;\n+\t}\n+      else\n+\t{\n+\t  representatives.safe_push (current_region);\n+\t  /* Remember any jumps and labels for the second pass below.  */\n+\t  if (gimple_code (stmt) == GIMPLE_COND\n+\t      || gimple_code (stmt) == GIMPLE_SWITCH\n+\t      || gimple_code (stmt) == GIMPLE_GOTO)\n+\t    control_flow_reps.put (stmt, current_region);\n+\t  else if (gimple_code (stmt) == GIMPLE_LABEL)\n+\t    label_reps.put (gimple_label_label (as_a <glabel *> (stmt)),\n+\t\t\t    current_region);\n+\t}\n+      idx++;\n+    }\n+  gcc_assert (representatives.length () == omp_for_loops.length ());\n+\n+  /* Revisit all the control flow statements and union the region of each\n+     cond, switch, or goto statement with the target labels' regions.  */\n+  for (hash_map <gimple *, size_t>::iterator it = control_flow_reps.begin ();\n+       it != control_flow_reps.end ();\n+       ++it)\n+    {\n+      gimple *stmt = (*it).first;\n+      size_t stmt_rep = (*it).second;\n+      switch (gimple_code (stmt))\n+\t{\n+\t  tree label;\n+\t  unsigned int n;\n+\n+\tcase GIMPLE_COND:\n+\t  label = gimple_cond_true_label (as_a <gcond *> (stmt));\n+\t  union_reps (stmt_rep, *label_reps.get (label));\n+\t  label = gimple_cond_false_label (as_a <gcond *> (stmt));\n+\t  union_reps (stmt_rep, *label_reps.get (label));\n+\t  break;\n+\n+\tcase GIMPLE_SWITCH:\n+\t  n = gimple_switch_num_labels (as_a <gswitch *> (stmt));\n+\t  for (unsigned int i = 0; i < n; i++)\n+\t    {\n+\t      tree switch_case\n+\t\t= gimple_switch_label (as_a <gswitch *> (stmt), i);\n+\t      label = CASE_LABEL (switch_case);\n+\t      union_reps (stmt_rep, *label_reps.get (label));\n+\t    }\n+\t  break;\n+\n+\tcase GIMPLE_GOTO:\n+\t  label = gimple_goto_dest (stmt);\n+\t  union_reps (stmt_rep, *label_reps.get (label));\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+/* Decompose the body of the KERNELS_REGION, which was originally annotated\n+   with the KERNELS_CLAUSES, into a series of compute constructs.  */\n+\n+static gimple *\n+decompose_kernels_region_body (gimple *kernels_region, tree kernels_clauses)\n+{\n+  location_t loc = gimple_location (kernels_region);\n+\n+  /* The kernels clauses will be propagated to the child clauses unmodified,\n+     except that the 'num_gangs', 'num_workers', and 'vector_length' clauses\n+     will only be added to loop regions.  The other regions are \"gang-single\"\n+     and get an explicit 'num_gangs (1)' clause.  So separate out the\n+     'num_gangs', 'num_workers', and 'vector_length' clauses here.\n+     Also check for the presence of an 'async' clause but do not remove it from\n+     the 'kernels' clauses.  */\n+  tree num_gangs_clause = NULL, num_workers_clause = NULL,\n+       vector_length_clause = NULL;\n+  tree async_clause = NULL;\n+  tree prev_clause = NULL, next_clause = NULL;\n+  tree parallel_clauses = kernels_clauses;\n+  for (tree c = parallel_clauses; c; c = next_clause)\n+    {\n+      /* Preserve this here, as we might NULL it later.  */\n+      next_clause = OMP_CLAUSE_CHAIN (c);\n+\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_GANGS\n+\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_WORKERS\n+\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_VECTOR_LENGTH)\n+\t{\n+\t  /* Cut this clause out of the chain.  */\n+\t  if (prev_clause != NULL)\n+\t    OMP_CLAUSE_CHAIN (prev_clause) = OMP_CLAUSE_CHAIN (c);\n+\t  else\n+\t    kernels_clauses = OMP_CLAUSE_CHAIN (c);\n+\t  OMP_CLAUSE_CHAIN (c) = NULL;\n+\t  switch (OMP_CLAUSE_CODE (c))\n+\t    {\n+\t    case OMP_CLAUSE_NUM_GANGS:\n+\t      num_gangs_clause = c;\n+\t      break;\n+\t    case OMP_CLAUSE_NUM_WORKERS:\n+\t      num_workers_clause = c;\n+\t      break;\n+\t    case OMP_CLAUSE_VECTOR_LENGTH:\n+\t      vector_length_clause = c;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else\n+\tprev_clause = c;\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_ASYNC)\n+\tasync_clause = c;\n+    }\n+\n+  gimple *kernels_body = gimple_omp_body (kernels_region);\n+  gbind *kernels_bind = as_a <gbind *> (kernels_body);\n+\n+  /* The body of the region may contain other nested binds declaring inner\n+     local variables.  Collapse all these binds into one to ensure that we\n+     have a single sequence of statements to iterate over; also, collect all\n+     inner variables.  */\n+  tree inner_bind_vars = flatten_binds (kernels_bind);\n+  gimple_seq body_sequence = gimple_bind_body (kernels_bind);\n+\n+  /* All these inner variables will get allocated on the device (below, by\n+     calling maybe_build_inner_data_region).  Here we create 'present'\n+     clauses for them and add these clauses to the list of clauses to be\n+     attached to each inner compute construct.  */\n+  tree present_clauses = kernels_clauses;\n+  for (tree var = inner_bind_vars; var; var = TREE_CHAIN (var))\n+    {\n+      if (!DECL_ARTIFICIAL (var) && TREE_CODE (var) != CONST_DECL)\n+\t{\n+\t  tree present_clause = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_SET_MAP_KIND (present_clause, GOMP_MAP_FORCE_PRESENT);\n+\t  OMP_CLAUSE_DECL (present_clause) = var;\n+\t  OMP_CLAUSE_SIZE (present_clause) = DECL_SIZE_UNIT (var);\n+\t  OMP_CLAUSE_CHAIN (present_clause) = present_clauses;\n+\t  present_clauses = present_clause;\n+\t}\n+    }\n+  kernels_clauses = present_clauses;\n+\n+  /* In addition to nested binds, the \"real\" body of the region may be\n+     nested inside a try-finally block.  Find its cleanup block, which\n+     contains code to clobber the local variables that must be clobbered.  */\n+  gimple *inner_cleanup = NULL;\n+  if (body_sequence != NULL && gimple_code (body_sequence) == GIMPLE_TRY)\n+    {\n+      if (gimple_seq_singleton_p (body_sequence))\n+\t{\n+\t  /* The try statement is the only thing inside the bind.  */\n+\t  inner_cleanup = gimple_try_cleanup (body_sequence);\n+\t  body_sequence = gimple_try_eval (body_sequence);\n+\t}\n+      else\n+\t{\n+\t  /* The bind's body starts with a try statement, but it is followed\n+\t     by other things.  */\n+\t  gimple_stmt_iterator gsi = gsi_start (body_sequence);\n+\t  gimple *try_stmt = gsi_stmt (gsi);\n+\t  inner_cleanup = gimple_try_cleanup (try_stmt);\n+\t  gimple *try_body = gimple_try_eval (try_stmt);\n+\n+\t  gsi_remove (&gsi, false);\n+\t  /* Now gsi indicates the sequence of statements after the try\n+\t     statement in the bind.  Append the statement in the try body and\n+\t     the trailing statements from gsi.  */\n+\t  gsi_insert_seq_before (&gsi, try_body, GSI_CONTINUE_LINKING);\n+\t  body_sequence = gsi_stmt (gsi);\n+\t}\n+    }\n+\n+  /* This sequence will collect all the top-level statements in the body of\n+     the data region we are about to construct.  */\n+  gimple_seq region_body = NULL;\n+  /* This sequence will collect consecutive statements to be put into a\n+     gang-single region.  */\n+  gimple_seq gang_single_seq = NULL;\n+  /* Flag recording whether the gang_single_seq only contains copies to\n+     local variables.  These may be loop setup code that should not be\n+     separated from the loop.  */\n+  bool only_simple_assignments = true;\n+\n+  /* Precompute the control flow region information to determine whether an\n+     OpenACC loop is executed conditionally or unconditionally.  */\n+  control_flow_regions cf_regions (body_sequence);\n+\n+  /* Iterate over the statements in the kernels region's body.  */\n+  size_t idx = 0;\n+  gimple_stmt_iterator gsi, gsi_n;\n+  for (gsi = gsi_start (body_sequence); !gsi_end_p (gsi); gsi = gsi_n, idx++)\n+    {\n+      /* Advance the iterator here because otherwise it would be invalidated\n+\t by moving statements below.  */\n+      gsi_n = gsi;\n+      gsi_next (&gsi_n);\n+\n+      gimple *stmt = gsi_stmt (gsi);\n+      gimple *omp_for = top_level_omp_for_in_stmt (stmt);\n+      bool is_unconditional_oacc_for_loop = false;\n+      if (omp_for != NULL)\n+\tis_unconditional_oacc_for_loop\n+\t  = cf_regions.is_unconditional_oacc_for_loop (idx);\n+      if (omp_for != NULL\n+\t  && is_unconditional_oacc_for_loop)\n+\t{\n+\t  /* This is an OMP for statement, put it into a separate region.\n+\t     But first, construct a gang-single region containing any\n+\t     complex sequential statements we may have seen.  */\n+\t  if (gang_single_seq != NULL && !only_simple_assignments)\n+\t    {\n+\t      gimple *single_region\n+\t\t= make_region_seq (loc, gang_single_seq,\n+\t\t\t\t   num_gangs_clause,\n+\t\t\t\t   num_workers_clause,\n+\t\t\t\t   vector_length_clause,\n+\t\t\t\t   kernels_clauses);\n+\t      gimple_seq_add_stmt (&region_body, single_region);\n+\t    }\n+\t  else if (gang_single_seq != NULL && only_simple_assignments)\n+\t    {\n+\t      /* There is a sequence of sequential statements preceding this\n+\t\t loop, but they are all simple assignments.  This is\n+\t\t probably setup code for the loop; in particular, Fortran DO\n+\t\t loops are preceded by code to copy the loop limit variable\n+\t\t to a temporary.  Group this code together with the loop\n+\t\t itself.  */\n+\t      gimple_seq_add_stmt (&gang_single_seq, stmt);\n+\t      stmt = gimple_build_bind (NULL, gang_single_seq,\n+\t\t\t\t\tmake_node (BLOCK));\n+\t    }\n+\t  gang_single_seq = NULL;\n+\t  only_simple_assignments = true;\n+\n+\t  gimple_seq parallel_seq = NULL;\n+\t  gimple_seq_add_stmt (&parallel_seq, stmt);\n+\t  gimple *parallel_region\n+\t    = make_region_loop_nest (omp_for, parallel_seq,\n+\t\t\t\t     num_gangs_clause,\n+\t\t\t\t     num_workers_clause,\n+\t\t\t\t     vector_length_clause,\n+\t\t\t\t     kernels_clauses);\n+\t  gimple_seq_add_stmt (&region_body, parallel_region);\n+\t}\n+      else\n+\t{\n+\t  if (omp_for != NULL)\n+\t    {\n+\t      gcc_checking_assert (!is_unconditional_oacc_for_loop);\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, omp_for,\n+\t\t\t\t \"unparallelized loop nest\"\n+\t\t\t\t \" in OpenACC %<kernels%> region:\"\n+\t\t\t\t \" it's executed conditionally\\n\");\n+\t    }\n+\n+\t  /* This is not an unconditional OMP for statement, so it will be\n+\t     put into a gang-single region.  */\n+\t  gimple_seq_add_stmt (&gang_single_seq, stmt);\n+\t  /* Is this a simple assignment? We call it simple if it is an\n+\t     assignment to an artificial local variable.  This captures\n+\t     Fortran loop setup code computing loop bounds and offsets.  */\n+\t  bool is_simple_assignment\n+\t    = (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t       && TREE_CODE (gimple_assign_lhs (stmt)) == VAR_DECL\n+\t       && DECL_ARTIFICIAL (gimple_assign_lhs (stmt)));\n+\t  if (!is_simple_assignment)\n+\t    only_simple_assignments = false;\n+\t}\n+    }\n+\n+  /* If we did not emit a new region, and are not going to emit one now\n+     (that is, the original region was empty), prepare to emit a dummy so as\n+     to preserve the original construct, which other processing (at least\n+     test cases) depend on.  */\n+  if (region_body == NULL && gang_single_seq == NULL)\n+    {\n+      gimple *stmt = gimple_build_nop ();\n+      gimple_set_location (stmt, loc);\n+      gimple_seq_add_stmt (&gang_single_seq, stmt);\n+    }\n+\n+  /* Gather up any remaining gang-single statements.  */\n+  if (gang_single_seq != NULL)\n+    {\n+      gimple *single_region\n+\t= make_region_seq (loc, gang_single_seq,\n+\t\t\t   num_gangs_clause,\n+\t\t\t   num_workers_clause,\n+\t\t\t   vector_length_clause,\n+\t\t\t   kernels_clauses);\n+      gimple_seq_add_stmt (&region_body, single_region);\n+    }\n+\n+  /* We want to launch these kernels asynchronously.  If the original\n+     kernels region had an async clause, this is done automatically because\n+     that async clause was copied to the individual regions we created.\n+     Otherwise, add an async clause to each newly created region, as well as\n+     a wait directive at the end.  */\n+  if (async_clause == NULL)\n+    add_async_clauses_and_wait (loc, &region_body);\n+\n+  tree kernels_locals = gimple_bind_vars (as_a <gbind *> (kernels_body));\n+  gimple *body = gimple_build_bind (kernels_locals, region_body,\n+\t\t\t\t    make_node (BLOCK));\n+\n+  /* If we found variables declared in nested scopes, build a data region to\n+     map them to the device.  */\n+  body = maybe_build_inner_data_region (loc, body, inner_bind_vars,\n+\t\t\t\t\tinner_cleanup);\n+\n+  return body;\n+}\n+\n+/* Decompose one OpenACC 'kernels' construct into an OpenACC 'data' construct\n+   containing the original OpenACC 'kernels' construct's region cut up into a\n+   sequence of compute constructs.  */\n+\n+static gimple *\n+omp_oacc_kernels_decompose_1 (gimple *kernels_stmt)\n+{\n+  gcc_checking_assert (gimple_omp_target_kind (kernels_stmt)\n+\t\t       == GF_OMP_TARGET_KIND_OACC_KERNELS);\n+  location_t loc = gimple_location (kernels_stmt);\n+\n+  /* Collect the data clauses of the OpenACC 'kernels' directive and create a\n+     new OpenACC 'data' construct with those clauses.  */\n+  tree kernels_clauses = gimple_omp_target_clauses (kernels_stmt);\n+  tree data_clauses = NULL;\n+  for (tree c = kernels_clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      /* Certain clauses are copied to the enclosing OpenACC 'data'.  Other\n+\t clauses remain on the OpenACC 'kernels'.  */\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP)\n+\t{\n+\t  tree decl = OMP_CLAUSE_DECL (c);\n+\t  HOST_WIDE_INT map_kind = OMP_CLAUSE_MAP_KIND (c);\n+\t  switch (map_kind)\n+\t    {\n+\t    default:\n+\t      if (map_kind == GOMP_MAP_ALLOC\n+\t\t  && integer_zerop (OMP_CLAUSE_SIZE (c)))\n+\t\t/* ??? This is an alloc clause for mapping a pointer whose\n+\t\t   target is already mapped.  We leave these on the inner\n+\t\t   compute constructs because moving them to the outer data\n+\t\t   region causes runtime errors.  */\n+\t\tbreak;\n+\n+\t      /* For non-artificial variables, and for non-declaration\n+\t\t expressions like A[0:n], copy the clause to the data\n+\t\t region.  */\n+\t      if ((DECL_P (decl) && !DECL_ARTIFICIAL (decl))\n+\t\t  || !DECL_P (decl))\n+\t\t{\n+\t\t  tree new_clause = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (new_clause, map_kind);\n+\t\t  /* This must be unshared here to avoid \"incorrect sharing\n+\t\t     of tree nodes\" errors from verify_gimple.  */\n+\t\t  OMP_CLAUSE_DECL (new_clause) = unshare_expr (decl);\n+\t\t  OMP_CLAUSE_SIZE (new_clause) = OMP_CLAUSE_SIZE (c);\n+\t\t  OMP_CLAUSE_CHAIN (new_clause) = data_clauses;\n+\t\t  data_clauses = new_clause;\n+\n+\t\t  /* Now that this data is mapped, turn the data clause on the\n+\t\t     inner OpenACC 'kernels' into a 'present' clause.  */\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_FORCE_PRESENT);\n+\t\t}\n+\t      break;\n+\n+\t    case GOMP_MAP_POINTER:\n+\t    case GOMP_MAP_TO_PSET:\n+\t    case GOMP_MAP_FORCE_TOFROM:\n+\t    case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t    case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t      /* ??? Copying these map kinds leads to internal compiler\n+\t\t errors in later passes.  */\n+\t      break;\n+\t    }\n+\t}\n+      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IF)\n+\t{\n+\t  /* If there is an 'if' clause, it must be duplicated to the\n+\t     enclosing data region.  Temporarily remove the if clause's\n+\t     chain to avoid copying it.  */\n+\t  tree saved_chain = OMP_CLAUSE_CHAIN (c);\n+\t  OMP_CLAUSE_CHAIN (c) = NULL;\n+\t  tree new_if_clause = unshare_expr (c);\n+\t  OMP_CLAUSE_CHAIN (c) = saved_chain;\n+\t  OMP_CLAUSE_CHAIN (new_if_clause) = data_clauses;\n+\t  data_clauses = new_if_clause;\n+\t}\n+    }\n+  /* Restore the original order of the clauses.  */\n+  data_clauses = nreverse (data_clauses);\n+\n+  gimple *data_region\n+    = gimple_build_omp_target (NULL, GF_OMP_TARGET_KIND_OACC_DATA_KERNELS,\n+\t\t\t       data_clauses);\n+  gimple_set_location (data_region, loc);\n+\n+  /* Transform the body of the kernels region into a sequence of compute\n+     constructs.  */\n+  gimple *body = decompose_kernels_region_body (kernels_stmt,\n+\t\t\t\t\t\tkernels_clauses);\n+\n+  /* Put the transformed pieces together.  The entire body of the region is\n+     wrapped in a try-finally statement that calls __builtin_GOACC_data_end\n+     for cleanup.  */\n+  gimple *try_stmt = make_data_region_try_statement (loc, body);\n+  gimple_omp_set_body (data_region, try_stmt);\n+\n+  return data_region;\n+}\n+\n+\n+/* Decompose OpenACC 'kernels' constructs in the current function.  */\n+\n+static tree\n+omp_oacc_kernels_decompose_callback_stmt (gimple_stmt_iterator *gsi_p,\n+\t\t\t\t\t  bool *handled_ops_p,\n+\t\t\t\t\t  struct walk_stmt_info *)\n+{\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+\n+  if ((gimple_code (stmt) == GIMPLE_OMP_TARGET)\n+      && gimple_omp_target_kind (stmt) == GF_OMP_TARGET_KIND_OACC_KERNELS)\n+    {\n+      gimple *stmt_new = omp_oacc_kernels_decompose_1 (stmt);\n+      gsi_replace (gsi_p, stmt_new, false);\n+      *handled_ops_p = true;\n+    }\n+  else\n+    *handled_ops_p = false;\n+\n+  return NULL;\n+}\n+\n+static unsigned int\n+omp_oacc_kernels_decompose (void)\n+{\n+  gimple_seq body = gimple_body (current_function_decl);\n+\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  walk_gimple_seq_mod (&body, omp_oacc_kernels_decompose_callback_stmt, NULL,\n+\t\t       &wi);\n+\n+  gimple_set_body (current_function_decl, body);\n+\n+  return 0;\n+}\n+\n+\n+namespace {\n+\n+const pass_data pass_data_omp_oacc_kernels_decompose =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"omp_oacc_kernels_decompose\", /* name */\n+  OPTGROUP_OMP, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_omp_oacc_kernels_decompose : public gimple_opt_pass\n+{\n+public:\n+  pass_omp_oacc_kernels_decompose (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_omp_oacc_kernels_decompose, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+  {\n+    return (flag_openacc\n+\t    && flag_openacc_kernels == OPENACC_KERNELS_DECOMPOSE);\n+  }\n+  virtual unsigned int execute (function *)\n+  {\n+    return omp_oacc_kernels_decompose ();\n+  }\n+\n+}; // class pass_omp_oacc_kernels_decompose\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_omp_oacc_kernels_decompose (gcc::context *ctxt)\n+{\n+  return new pass_omp_oacc_kernels_decompose (ctxt);\n+}"}, {"sha": "90139615c00f3f9e22b733f2d2cf1cfb75092c40", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1771,11 +1771,19 @@ execute_oacc_device_lower ()\n   bool is_oacc_serial\n     = (lookup_attribute (\"oacc serial\",\n \t\t\t DECL_ATTRIBUTES (current_function_decl)) != NULL);\n+  bool is_oacc_parallel_kernels_parallelized\n+    = (lookup_attribute (\"oacc parallel_kernels_parallelized\",\n+\t\t\t DECL_ATTRIBUTES (current_function_decl)) != NULL);\n+  bool is_oacc_parallel_kernels_gang_single\n+    = (lookup_attribute (\"oacc parallel_kernels_gang_single\",\n+\t\t\t DECL_ATTRIBUTES (current_function_decl)) != NULL);\n   int fn_level = oacc_fn_attrib_level (attrs);\n   bool is_oacc_routine = (fn_level >= 0);\n   gcc_checking_assert (is_oacc_parallel\n \t\t       + is_oacc_kernels\n \t\t       + is_oacc_serial\n+\t\t       + is_oacc_parallel_kernels_parallelized\n+\t\t       + is_oacc_parallel_kernels_gang_single\n \t\t       + is_oacc_routine\n \t\t       == 1);\n \n@@ -1795,6 +1803,12 @@ execute_oacc_device_lower ()\n \t\t  ? \"parallelized\" : \"unparallelized\"));\n       else if (is_oacc_serial)\n \tfprintf (dump_file, \"Function is OpenACC serial offload\\n\");\n+      else if (is_oacc_parallel_kernels_parallelized)\n+\tfprintf (dump_file, \"Function is %s OpenACC kernels offload\\n\",\n+\t\t \"parallel_kernels_parallelized\");\n+      else if (is_oacc_parallel_kernels_gang_single)\n+\tfprintf (dump_file, \"Function is %s OpenACC kernels offload\\n\",\n+\t\t \"parallel_kernels_gang_single\");\n       else if (is_oacc_routine)\n \tfprintf (dump_file, \"Function is OpenACC routine level %d\\n\",\n \t\t fn_level);\n@@ -1838,6 +1852,11 @@ execute_oacc_device_lower ()\n       fprintf (dump_file, \"]\\n\");\n     }\n \n+  /* Verify that for OpenACC 'kernels' decomposed \"gang-single\" parts we launch\n+     a single gang only.  */\n+  if (is_oacc_parallel_kernels_gang_single)\n+    gcc_checking_assert (dims[GOMP_DIM_GANG] == 1);\n+\n   oacc_loop_process (loops);\n   if (dump_file)\n     {"}, {"sha": "fc56e695b60cb02fda2d04db53d4afd89d2fc090", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_warn_unused_result);\n   NEXT_PASS (pass_diagnose_omp_blocks);\n   NEXT_PASS (pass_diagnose_tm_blocks);\n+  NEXT_PASS (pass_omp_oacc_kernels_decompose);\n   NEXT_PASS (pass_lower_omp);\n   NEXT_PASS (pass_lower_cf);\n   NEXT_PASS (pass_lower_tm);"}, {"sha": "7bb115316e808f401947fca428d498fa70ee47ba", "filename": "gcc/testsuite/c-c++-common/goacc/if-clause-2.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-2.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1,11 +1,21 @@\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" }\n+   { dg-additional-options \"-fdump-tree-omp_oacc_kernels_decompose\" } */\n+\n void\n f (short c)\n {\n-#pragma acc parallel if(c)\n-  ;\n-#pragma acc kernels if(c)\n-  ;\n-#pragma acc data if(c)\n-  ;\n-#pragma acc update device(c) if(c)\n+#pragma acc parallel if(c) copy(c)\n+  ++c;\n+\n+#pragma acc kernels if(c) copy(c)\n+  /* { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_kernels map\\(tofrom:c \\[len: [0-9]+\\]\\) if\\(_[0-9]+\\)$} 1 \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_data_kernels map\\(tofrom:c \\[len: [0-9]+\\]\\) if\\(_[0-9]+\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+     { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_gang_single async\\(-1\\) num_gangs\\(1\\) map\\(force_present:c \\[len: [0-9]+\\]\\) if\\(_[0-9]+\\)$} 1 \"omp_oacc_kernels_decompose\" } } */\n+  ++c;\n+\n+#pragma acc data if(c) copy(c)\n+  ++c;\n+\n+#pragma acc update if(c) device(c)\n }"}, {"sha": "92db33273ebc94d47fcd5501daad4f9ac7f8c17d", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-1.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,83 @@\n+/* Test OpenACC 'kernels' construct decomposition.  */\n+\n+/* { dg-additional-options \"-fopt-info-omp-all\" } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" }\n+   { dg-additional-options \"-fdump-tree-omp_oacc_kernels_decompose\" } */\n+\n+/* See also '../../gfortran.dg/goacc/kernels-decompose-1.f95'.  */\n+\n+#define N 1024\n+\n+unsigned int a[N];\n+\n+int\n+main (void)\n+{\n+  int i;\n+  unsigned int sum = 1;\n+\n+#pragma acc kernels copyin(a[0:N]) copy(sum)\n+  /* { dg-bogus \"optimized: assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } .-1 }\n+     TODO Is this maybe the report that belongs to the XFAILed report further down?  */\n+  {\n+    #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (i = 0; i < N; ++i)\n+      sum += a[i];\n+\n+    sum++; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    a[0]++;\n+\n+    #pragma acc loop independent /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (i = 0; i < N; ++i)\n+      sum += a[i];\n+\n+    if (sum > 10) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+      { \n+        #pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+\t/* { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+\t/*TODO { dg-optimized \"assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } l_loop_i$c_loop_i } */\n+        for (i = 0; i < N; ++i)\n+          sum += a[i];\n+      }\n+\n+    #pragma acc loop auto /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (i = 0; i < N; ++i)\n+      sum += a[i];\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_kernels map\\(tofrom:sum \\[len: [0-9]+\\]\\) map\\(to:a\\[0\\] \\[len: [0-9]+\\]\\) map\\(firstprivate:a \\[pointer assign, bias: 0\\]\\)$} 1 \"gimple\" } }\n+\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\)$} 2 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop independent private\\(i\\)$} 1 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop auto private\\(i\\)$} 1 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop} 4 \"gimple\" } } */\n+\n+/* Check that the OpenACC 'kernels' got decomposed into 'data' and an enclosed\n+   sequence of compute constructs.\n+   { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_data_kernels map\\(tofrom:sum \\[len: [0-9]+\\]\\) map\\(to:a\\[0\\] \\[len: [0-9]+\\]\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+   As noted above, we get three \"old-style\" kernel regions, one gang-single region, and one parallelized loop region.\n+   { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_kernels async\\(-1\\) map\\(force_present:sum \\[len: [0-9]+\\]\\) map\\(force_present:a\\[0\\] \\[len: [0-9]+\\]\\) map\\(firstprivate:a \\[pointer assign, bias: 0\\]\\)$} 3 \"omp_oacc_kernels_decompose\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_parallelized async\\(-1\\) map\\(force_present:sum \\[len: [0-9]+\\]\\) map\\(force_present:a\\[0\\] \\[len: [0-9]+\\]\\) map\\(firstprivate:a \\[pointer assign, bias: 0\\]\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_gang_single async\\(-1\\) num_gangs\\(1\\) map\\(force_present:sum \\[len: [0-9]+\\]\\) map\\(force_present:a\\[0\\] \\[len: [0-9]+\\]\\) map\\(firstprivate:a \\[pointer assign, bias: 0\\]\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+\n+   'data' plus five CCs.\n+   { dg-final { scan-tree-dump-times {(?n)#pragma omp target } 6 \"omp_oacc_kernels_decompose\" } }\n+\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\)$} 2 \"omp_oacc_kernels_decompose\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop independent private\\(i\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop auto private\\(i\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+   { dg-final { scan-tree-dump-times {(?n)#pragma acc loop} 4 \"omp_oacc_kernels_decompose\" } }\n+\n+   Each of the parallel regions is async, and there is a final call to\n+   __builtin_GOACC_wait.\n+   { dg-final { scan-tree-dump-times \"__builtin_GOACC_wait\" 1 \"omp_oacc_kernels_decompose\" } } */"}, {"sha": "ec6c4af92aa6504adb6e5d2c722013e0b94827a4", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-2.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-2.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,141 @@\n+/* Test OpenACC 'kernels' construct decomposition.  */\n+\n+/* { dg-additional-options \"-fopt-info-omp-all\" } */\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" }\n+/* { dg-additional-options \"-O2\" } for 'parloops'.  */\n+\n+/* See also '../../gfortran.dg/goacc/kernels-decompose-2.f95'.  */\n+\n+#pragma acc routine gang\n+extern int\n+f_g (int);\n+\n+#pragma acc routine worker\n+extern int\n+f_w (int);\n+\n+#pragma acc routine vector\n+extern int\n+f_v (int);\n+\n+#pragma acc routine seq\n+extern int\n+f_s (int);\n+\n+int\n+main ()\n+{\n+  int x, y, z;\n+#define N 10\n+  int a[N], b[N], c[N];\n+\n+#pragma acc kernels\n+  {\n+    x = 0; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+    y = x < 10;\n+    z = x++;\n+    ;\n+  }\n+\n+  { /*TODO Instead of using 'for (int i = 0; [...])', move 'int i' outside, to work around for ICE detailed in 'kernels-decompose-ice-1.c'.  */\n+    int i;\n+#pragma acc kernels /* { dg-optimized \"assigned OpenACC gang loop parallelism\" } */\n+  for (i = 0; i < N; i++) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+    a[i] = 0;\n+  }\n+\n+#pragma acc kernels loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+  /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+  for (int i = 0; i < N; i++)\n+    b[i] = a[N - i - 1];\n+\n+#pragma acc kernels\n+  {\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (int i = 0; i < N; i++)\n+      b[i] = a[N - i - 1];\n+\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (int i = 0; i < N; i++)\n+      c[i] = a[i] * b[i];\n+\n+    a[z] = 0; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (int i = 0; i < N; i++)\n+      c[i] += a[i];\n+\n+#pragma acc loop seq /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (int i = 0 + 1; i < N; i++)\n+      c[i] += c[i - 1];\n+  }\n+\n+#pragma acc kernels\n+  /*TODO What does this mean?\n+    TODO { dg-optimized \"assigned OpenACC worker vector loop parallelism\" \"\" { target *-*-* } .-2 } */\n+  {\n+#pragma acc loop independent /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (int i = 0; i < N; ++i)\n+#pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n+      /* { dg-optimized \"assigned OpenACC worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+      for (int j = 0; j < N; ++j)\n+#pragma acc loop independent /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t/* { dg-warning \"insufficient partitioning available to parallelize loop\" \"\" { target *-*-* } l_loop_k$c_loop_k } */\n+\t/* { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_k$c_loop_k } */\n+\tfor (int k = 0; k < N; ++k)\n+\t  a[(i + j + k) % N]\n+\t    = b[j]\n+\t    + f_v (c[k]); /* { dg-optimized \"assigned OpenACC vector loop parallelism\" } */\n+\n+    /*TODO Should the following turn into \"gang-single\" instead of \"parloops\"?\n+      TODO The problem is that the first STMT is 'if (y <= 4) goto <D.2547>; else goto <D.2548>;', thus \"parloops\".  */\n+    if (y < 5) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+#pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n+      /* { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+      for (int j = 0; j < N; ++j)\n+\tb[j] = f_w (c[j]);\n+  }\n+\n+#pragma acc kernels\n+  {\n+    y = f_g (a[5]); /* { dg-line l_part[incr c_part] } */\n+    /*TODO If such a construct is placed in its own part (like it is, here), can't this actually use gang paralelism, instead of \"gang-single\"?\n+      { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" \"\" { target *-*-* } l_part$c_part } */\n+    /* { dg-optimized \"assigned OpenACC gang worker vector loop parallelism\" \"\" { target *-*-* } l_part$c_part } */\n+\n+#pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n+    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+    for (int j = 0; j < N; ++j)\n+      b[j] = y + f_w (c[j]); /* { dg-optimized \"assigned OpenACC worker vector loop parallelism\" } */\n+  }\n+\n+#pragma acc kernels\n+  {\n+    y = 3; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+\n+#pragma acc loop independent /* { dg-line l_loop_j[incr c_loop_j] } */\n+    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+    /* { dg-optimized \"assigned OpenACC gang worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j } */\n+    for (int j = 0; j < N; ++j)\n+      b[j] = y + f_v (c[j]); /* { dg-optimized \"assigned OpenACC vector loop parallelism\" } */\n+\n+    z = 2; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+  }\n+\n+#pragma acc kernels /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+  ;\n+\n+  return 0;\n+}"}, {"sha": "9e27d1fb9b5a496f31c8542a9e474a0438d35733", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-1.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,108 @@\n+/* Test OpenACC 'kernels' construct decomposition.  */\n+\n+/* { dg-additional-options \"-fopt-info-omp-all\" } */\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" } */\n+/* { dg-ice \"TODO\" }\n+   { dg-prune-output \"during GIMPLE pass: omplower\" } */\n+\n+/* Reduced from 'kernels-decompose-2.c'.\n+   (Hopefully) similar instances:\n+     - 'libgomp.oacc-c-c++-common/declare-vla-kernels-decompose-ice-1.c'\n+     - 'libgomp.oacc-c-c++-common/kernels-decompose-1.c'\n+*/\n+\n+int\n+main ()\n+{\n+#define N 10\n+\n+#pragma acc kernels\n+  for (int i = 0; i < N; i++) /* { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" } */\n+    ;\n+\n+  return 0;\n+}\n+\n+/*\n+  In 'gimple' we've got:\n+\n+      main ()\n+      {\n+        int D.2087;\n+      \n+        {\n+          int a[10];\n+      \n+          try\n+            {\n+              #pragma omp target oacc_kernels map(tofrom:a [len: 40])\n+                {\n+                  {\n+                    int i;\n+      \n+                    i = 0;\n+                    goto <D.2085>;\n+      [...]\n+\n+  ..., which in 'omp_oacc_kernels_decompose' we turn into:\n+\n+      main ()\n+      {\n+        int D.2087;\n+      \n+        {\n+          int a[10];\n+      \n+          try\n+            {\n+              #pragma omp target oacc_data_kernels map(tofrom:a [len: 40])\n+                {\n+                  try\n+                    {\n+                      {\n+                        int i;\n+      \n+                        #pragma omp target oacc_data_kernels map(alloc:i [len: 4])\n+                          {\n+                            try\n+                              {\n+                                {\n+                                  #pragma omp target oacc_kernels async(-1) map(force_present:i [len: 4]) map(force_present:a [len: 40])\n+                                    {\n+                                      i = 0;\n+                                      goto <D.2085>;\n+      [...]\n+\n+  ..., which results in ICE in:\n+\n+    #1  0x0000000000d2247b in lower_omp_target (gsi_p=gsi_p@entry=0x7fffffffbc90, ctx=ctx@entry=0x2c994c0) at [...]/gcc/omp-low.c:11981\n+    11981                       gcc_assert (offloaded);\n+    (gdb) list\n+    11976                         talign = TYPE_ALIGN_UNIT (TREE_TYPE (TREE_TYPE (ovar)));\n+    11977                       gimplify_assign (x, var, &ilist);\n+    11978                     }\n+    11979                   else if (is_gimple_reg (var))\n+    11980                     {\n+    11981                       gcc_assert (offloaded);\n+    11982                       tree avar = create_tmp_var (TREE_TYPE (var));\n+    11983                       mark_addressable (avar);\n+    11984                       enum gomp_map_kind map_kind = OMP_CLAUSE_MAP_KIND (c);\n+    11985                       if (GOMP_MAP_COPY_TO_P (map_kind)\n+    (gdb) call debug_tree(var)\n+     <var_decl 0x7ffff7feebd0 i\n+        type <integer_type 0x7ffff67be5e8 int sizes-gimplified public SI\n+            size <integer_cst 0x7ffff67a5f18 constant 32>\n+            unit-size <integer_cst 0x7ffff67a5f30 constant 4>\n+            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ffff67be5e8 precision:32 min <integer_cst 0x7ffff67a5ed0 -2147483648> max <integer_cst 0x7ffff67a5ee8 2147483647>\n+            pointer_to_this <pointer_type 0x7ffff67c69d8>>\n+        used read SI [...]:15:12 size <integer_cst 0x7ffff67a5f18 32> unit-size <integer_cst 0x7ffff67a5f30 4>\n+        align:32 warn_if_not_align:0 context <function_decl 0x7ffff68eea00 main>>\n+\n+  Just defusing the 'assert' is not sufficient:\n+\n+      libgomp: present clause: !acc_is_present (0x7ffe29cba3ec, 4 (0x4))\n+\n+  TODO Can't the 'omp_oacc_kernels_decompose' transformation be much simpler, such that we avoid the intermediate 'data' if we've got just one compute construct inside it?\n+  TODO But it's not clear if that'd just resolve one simple instance of the general problem?\n+\n+*/"}, {"sha": "839e680385151598c097fbb2623bf3335960c2ac", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-decompose-ice-2.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,16 @@\n+/* Test OpenACC 'kernels' construct decomposition.  */\n+\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" } */\n+/* { dg-ice \"TODO\" }\n+   { dg-prune-output \"during GIMPLE pass: omp_oacc_kernels_decompose\" } */\n+\n+/* Reduced from 'kernels-decompose-ice-1.c'.  */\n+\n+int\n+main ()\n+{\n+#pragma acc kernels\n+  {\n+    int i;\n+  }\n+}"}, {"sha": "95a78623ebf901c95494634ebba0fcfd87135b64", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-decompose-1.f95", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-1.f95?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,81 @@\n+! Test OpenACC 'kernels' construct decomposition.\n+\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+! { dg-additional-options \"-fopenacc-kernels=decompose\" }\n+! { dg-additional-options \"-fdump-tree-omp_oacc_kernels_decompose\" }\n+\n+! See also '../../c-c++-common/goacc/kernels-decompose-1.c'.\n+\n+program main\n+  implicit none\n+  integer, parameter         :: N = 1024\n+  integer, dimension (1:N)   :: a\n+  integer                    :: i, sum\n+\n+  !$acc kernels copyin(a(1:N)) copy(sum)\n+  ! { dg-bogus \"optimized: assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } .-1 }\n+  !TODO Is this maybe the report that belongs to the XFAILed report further down?  */\n+\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+    sum = sum + a(i)\n+  end do\n+\n+  sum = sum + 1 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  a(1) = a(1) + 1\n+\n+  !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+    sum = sum + a(i)\n+  end do\n+\n+  if (sum .gt. 10) then ! { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" }\n+    !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+    ! { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+    !TODO { dg-optimized \"assigned OpenACC seq loop parallelism\" \"TODO\" { xfail *-*-* } l_loop_i$c_loop_i }\n+    do i = 1, N\n+      sum = sum + a(i)\n+    end do\n+  end if\n+\n+  !$acc loop auto ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+    sum = sum + a(i)\n+  end do\n+\n+  !$acc end kernels\n+end program main\n+\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_kernels map\\(to:a\\[_[0-9]+\\] \\[len: _[0-9]+\\]\\) map\\(alloc:a \\[pointer assign, bias: _[0-9]+\\]\\) map\\(tofrom:sum \\[len: [0-9]+\\]\\)$} 1 \"gimple\" } }\n+\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\)$} 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\) independent$} 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\) auto$} 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop} 4 \"gimple\" } }\n+\n+! Check that the OpenACC 'kernels' got decomposed into 'data' and an enclosed\n+! sequence of compute constructs.\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_data_kernels map\\(to:a\\[_[0-9]+\\] \\[len: _[0-9]+\\]\\) map\\(tofrom:sum \\[len: [0-9]+\\]\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+! As noted above, we get three \"old-style\" kernel regions, one gang-single region, and one parallelized loop region.\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_kernels async\\(-1\\) map\\(force_present:a\\[_[0-9]+\\] \\[len: _[0-9]+\\]\\) map\\(alloc:a \\[pointer assign, bias: _[0-9]+\\]\\) map\\(force_present:sum \\[len: [0-9]+\\]\\)$} 3 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_parallelized async\\(-1\\) map\\(force_present:a\\[_[0-9]+\\] \\[len: _[0-9]+\\]\\) map\\(alloc:a \\[pointer assign, bias: _[0-9]+\\]\\) map\\(force_present:sum \\[len: [0-9]+\\]\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_gang_single async\\(-1\\) num_gangs\\(1\\) map\\(force_present:a\\[_[0-9]+\\] \\[len: _[0-9]+\\]\\) map\\(alloc:a \\[pointer assign, bias: _[0-9]+\\]\\) map\\(force_present:sum \\[len: [0-9]+\\]\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+!\n+! 'data' plus five CCs.\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target } 6 \"omp_oacc_kernels_decompose\" } }\n+\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\)$} 2 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\) independent$} 1 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop private\\(i\\) auto} 1 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma acc loop} 4 \"omp_oacc_kernels_decompose\" } }\n+\n+! Each of the parallel regions is async, and there is a final call to\n+! __builtin_GOACC_wait.\n+! { dg-final { scan-tree-dump-times \"__builtin_GOACC_wait\" 1 \"omp_oacc_kernels_decompose\" } }"}, {"sha": "58d687d4a0c79aa9eb58616acbd20f16e1aeb0a3", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-decompose-2.f95", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-decompose-2.f95?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,142 @@\n+! Test OpenACC 'kernels' construct decomposition.\n+\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-fopenacc-kernels=decompose\" }\n+! { dg-additional-options \"-O2\" } for 'parloops'.\n+\n+! See also '../../c-c++-common/goacc/kernels-decompose-2.c'.\n+\n+program main\n+  implicit none\n+\n+  integer, external :: f_g\n+  !$acc routine (f_g) gang\n+  integer, external :: f_w\n+  !$acc routine (f_w) worker\n+  integer, external :: f_v\n+  !$acc routine (f_v) vector\n+  integer, external :: f_s\n+  !$acc routine (f_s) seq\n+\n+  integer :: i, j, k\n+  integer :: x, y, z\n+  logical :: y_l\n+  integer, parameter :: N = 10\n+  integer :: a(N), b(N), c(N)\n+\n+  !$acc kernels\n+  x = 0 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  y = 0\n+  y_l = x < 10\n+  z = x\n+  x = x + 1\n+  ;\n+  !$acc end kernels\n+\n+  !$acc kernels ! { dg-optimized \"assigned OpenACC gang loop parallelism\" }\n+  do i = 1, N ! { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" }\n+     a(i) = 0\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+     b(i) = a(N - i + 1)\n+  end do\n+\n+  !$acc kernels\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+     b(i) = a(N - i + 1)\n+  end do\n+\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+     c(i) = a(i) * b(i)\n+  end do\n+\n+  a(z) = 0 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+\n+  !$acc loop ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+     c(i) = c(i) + a(i)\n+  end do\n+\n+  !$acc loop seq ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1 + 1, N\n+     c(i) = c(i) + c(i - 1)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels\n+  !TODO What does this mean?\n+  !TODO { dg-optimized \"assigned OpenACC worker vector loop parallelism\" \"\" { target *-*-* } .-2 }\n+  !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  do i = 1, N\n+     !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-optimized \"assigned OpenACC worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+     do j = 1, N\n+        !$acc loop independent ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-warning \"insufficient partitioning available to parallelize loop\" \"\" { target *-*-* } l_loop_k$c_loop_k }\n+        ! { dg-optimized \"assigned OpenACC seq loop parallelism\" \"\" { target *-*-* } l_loop_k$c_loop_k }\n+        do k = 1, N\n+           a(1 + mod(i + j + k, N)) &\n+                = b(j) &\n+                + f_v (c(k)) ! { dg-optimized \"assigned OpenACC vector loop parallelism\" }\n+        end do\n+     end do\n+  end do\n+\n+  !TODO Should the following turn into \"gang-single\" instead of \"parloops\"?\n+  !TODO The problem is that the first STMT is 'if (y <= 4) goto <D.2547>; else goto <D.2548>;', thus \"parloops\".\n+  if (y < 5) then ! { dg-message \"note: beginning 'parloops' part in OpenACC 'kernels' region\" }\n+     !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-missed \"unparallelized loop nest in OpenACC 'kernels' region: it's executed conditionally\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+     do j = 1, N\n+        b(j) = f_w (c(j))\n+     end do\n+  end if\n+  !$acc end kernels\n+\n+  !$acc kernels\n+  y = f_g (a(5)) ! { dg-line l_part[incr c_part] }\n+  !TODO If such a construct is placed in its own part (like it is, here), can't this actually use gang paralelism, instead of \"gang-single\"?\n+  ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" \"\" { target *-*-* } l_part$c_part }\n+  ! { dg-optimized \"assigned OpenACC gang worker vector loop parallelism\" \"\" { target *-*-* } l_part$c_part }\n+\n+  !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+  ! { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+  do j = 1, N\n+     b(j) = y + f_w (c(j)) ! { dg-optimized \"assigned OpenACC worker vector loop parallelism\" }\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels\n+  y = 3 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+\n+  !$acc loop independent ! { dg-line l_loop_j[incr c_loop_j] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+  ! { dg-optimized \"assigned OpenACC gang worker loop parallelism\" \"\" { target *-*-* } l_loop_j$c_loop_j }\n+  do j = 1, N\n+     b(j) = y + f_v (c(j)) ! { dg-optimized \"assigned OpenACC vector loop parallelism\" }\n+  end do\n+\n+  z = 2 ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  !$acc end kernels\n+\n+  !$acc kernels ! { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" }\n+  !$acc end kernels  \n+end program main"}, {"sha": "d01eee2fa5d0cec3d387a3535ac482d70d2e98d3", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-tree.f95", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1,5 +1,7 @@\n ! { dg-do compile } \n ! { dg-additional-options \"-fdump-tree-original\" } \n+! { dg-additional-options \"-fopenacc-kernels=decompose\" }\n+! { dg-additional-options \"-fdump-tree-omp_oacc_kernels_decompose\" }\n \n program test\n   implicit none\n@@ -34,3 +36,6 @@ end program test\n ! { dg-final { scan-tree-dump-times \"map\\\\(alloc:t\\\\)\" 1 \"original\" } } \n \n ! { dg-final { scan-tree-dump-times \"map\\\\(force_deviceptr:u\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_data_kernels if\\(D\\.[0-9]+\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_gang_single num_gangs\\(1\\) if\\(D\\.[0-9]+\\) async\\(-1\\)$} 1 \"omp_oacc_kernels_decompose\" } }"}, {"sha": "cc4870e9711bdc3a5576bba806c560da8f22737c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -416,6 +416,7 @@ extern gimple_opt_pass *make_pass_lower_switch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_switch_O0 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vector (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vector_ssa (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_omp_oacc_kernels_decompose (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_omp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_diagnose_omp_blocks (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_expand_omp (gcc::context *ctxt);"}, {"sha": "c7eae12ec10957d889d20facfec5097288510502", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose-ice-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose-ice-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose-ice-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose-ice-1.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" } */\n+/* Hopefully, this is the same issue as '../../../gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c'.\n+   { dg-ice \"TODO\" }\n+   TODO { dg-prune-output \"during GIMPLE pass: omplower\" }\n+   TODO { dg-do link } */\n+\n+#undef KERNELS_DECOMPOSE_ICE_HACK\n+#include \"declare-vla.c\""}, {"sha": "dd8a1c1d294555c0ebbe0dcab6f96c69b4adf990", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla-kernels-decompose.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla-kernels-decompose.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" } */\n+\n+/* See also 'declare-vla-kernels-decompose-ice-1.c'.  */\n+\n+#define KERNELS_DECOMPOSE_ICE_HACK\n+#include \"declare-vla.c\""}, {"sha": "3bd6331879d2a04c3660afccb931226e982a4805", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeclare-vla.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -38,6 +38,12 @@ f_data (void)\n     for (i = 0; i < N; i++)\n       A[i] = -i;\n \n+    /* See 'declare-vla-kernels-decompose.c'.  */\n+#ifdef KERNELS_DECOMPOSE_ICE_HACK\n+    (volatile int *) &i;\n+    (volatile int *) &N;\n+#endif\n+\n # pragma acc kernels\n     for (i = 0; i < N; i++)\n       A[i] = i;"}, {"sha": "fa8ae6c79cd0347b514fb9581986fdec7421ce0a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-decompose-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-decompose-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-decompose-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-decompose-1.c?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -0,0 +1,38 @@\n+/* Test OpenACC 'kernels' construct decomposition.  */\n+\n+/* { dg-additional-options \"-fopt-info-omp-all\" } */\n+/* { dg-additional-options \"-fopenacc-kernels=decompose\" } */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+\n+int main()\n+{\n+  int a = 0;\n+  /*TODO Without making 'a' addressable, for GCN offloading we will not see the expected value copied out.  (But it does work for nvptx offloading, strange...)  */\n+  (volatile int *) &a;\n+#define N 123\n+  int b[N] = { 0 };\n+\n+#pragma acc kernels\n+  {\n+    int c = 234; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+\n+    /*TODO Hopefully, this is the same issue as '../../../gcc/testsuite/c-c++-common/goacc/kernels-decompose-ice-1.c'.  */\n+    (volatile int *) &c;\n+\n+#pragma acc loop independent gang /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized \"assigned OpenACC gang loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i } */\n+    for (int i = 0; i < N; ++i)\n+      b[i] = c;\n+\n+    a = c; /* { dg-message \"note: beginning 'gang-single' part in OpenACC 'kernels' region\" } */\n+  }\n+\n+  for (int i = 0; i < N; ++i)\n+    assert (b[i] == 234);\n+  assert (a == 234);\n+\n+  return 0;\n+}"}, {"sha": "82d8351f0e396cf9d7e2c6526c978a186894fdd3", "filename": "libgomp/testsuite/libgomp.oacc-fortran/pr94358-1.f90", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr94358-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e898ce7997733c29dcab9c3c62ca102c7f9fa6eb/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr94358-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr94358-1.f90?ref=e898ce7997733c29dcab9c3c62ca102c7f9fa6eb", "patch": "@@ -1,17 +1,22 @@\n ! { dg-do run }\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-fopenacc-kernels=decompose\" }\n \n subroutine kernel(lo, hi, a, b, c)\n   implicit none\n   integer :: lo, hi, i\n   real, dimension(lo:hi) :: a, b, c\n \n-  !$acc kernels copyin(lo, hi) ! { dg-optimized \"assigned OpenACC seq loop parallelism\" }\n-  !$acc loop independent\n+  !$acc kernels copyin(lo, hi)\n+  !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = lo, hi\n      b(i) = a(i)\n   end do\n-  !$acc loop independent\n+  !$acc loop independent ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-message \"note: parallelized loop nest in OpenACC 'kernels' region\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-optimized \"assigned OpenACC gang vector loop parallelism\" \"\" { target *-*-* } l_loop_i$c_loop_i }\n   do i = lo, hi\n      c(i) = b(i)\n   end do"}]}