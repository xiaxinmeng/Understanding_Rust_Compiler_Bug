{"sha": "a50f0918152b332395d7f224ca5f1619cfdf52a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUwZjA5MTgxNTJiMzMyMzk1ZDdmMjI0Y2E1ZjE2MTljZmRmNTJhMQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-07T18:54:10Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-07T18:54:10Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11952", "tree": {"sha": "261e575489c1c8befbbb08b75b53209bdcb7ff76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/261e575489c1c8befbbb08b75b53209bdcb7ff76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a50f0918152b332395d7f224ca5f1619cfdf52a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50f0918152b332395d7f224ca5f1619cfdf52a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50f0918152b332395d7f224ca5f1619cfdf52a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50f0918152b332395d7f224ca5f1619cfdf52a1/comments", "author": null, "committer": null, "parents": [{"sha": "637dec4188ed71b4d2e0bf04acb97b4ca19980af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637dec4188ed71b4d2e0bf04acb97b4ca19980af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/637dec4188ed71b4d2e0bf04acb97b4ca19980af"}], "stats": {"total": 147, "additions": 101, "deletions": 46}, "files": [{"sha": "f64da638a03ca7980a073975d823bd86bb4b1026", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a50f0918152b332395d7f224ca5f1619cfdf52a1", "patch": "@@ -1,3 +1,41 @@\n+Mon May  6 01:23:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_file): Don't try to emit functions that haven't\n+ \tbeen compiled.\n+\n+Fri May  3 09:30:13 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_vtable_vardecl): Oops.\n+\n+\t* decl.c (maybe_push_to_top_level): Do save previous_class_*.\n+  \tAlso store the bindings from previous_class_values.\n+\t(pop_from_top_level): Restore them.\n+\n+Thu May  2 21:56:49 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_vtable_vardecl): Only write out vtable if its\n+ \tsymbol has been referenced.\n+\t(finish_file): Re-join synthesis/vtable loop with inline emission\n+\tloop, disable inlining when an inline is output.\n+\n+Thu May  2 17:20:02 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (init_exception_processing): Setup saved_in_catch.\n+\t(push_eh_cleanup): Reset __eh_in_catch.\n+\t(expand_start_catch_block): Set __eh_in_catch.\n+\n+Thu May  2 16:21:17 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (push_eh_cleanup): Add tracking for whether or not we\n+\thave an active exception object.\n+\t(expand_builtin_throw): Use it to make sure a rethrow without an\n+\texception object is caught.\n+\n+Thu May  2 11:26:41 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (maybe_push_to_top_level): Clear out class-level bindings\n+ \tcache.\n+\n Wed May  1 11:26:52 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Also use sentries for vars with"}, {"sha": "c55d904fcd4f5681a9b69a5a5d61e0391fdc610f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a50f0918152b332395d7f224ca5f1619cfdf52a1", "patch": "@@ -2540,18 +2540,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t   IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function)));\n \n   {\n-    int is_constructor;\n-    \n-    if (TREE_CODE (function) == FUNCTION_DECL)\n-      {\n-\tis_constructor = DECL_CONSTRUCTOR_P (function);\n-\tfunction = default_conversion (function);\n-      }\n-    else\n-      {\n-\tis_constructor = 0;\n-\tfunction = default_conversion (function);\n-      }\n+    int is_constructor\n+      = TREE_CODE (function) == FUNCTION_DECL\n+\t&& DECL_CONSTRUCTOR_P (function);\n+\n+    function = default_conversion (function);\n \n     result = build_nt (CALL_EXPR, function, parms, NULL_TREE);\n "}, {"sha": "83ed195e9cc01e583691e10fd49feaac7c3c44c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a50f0918152b332395d7f224ca5f1619cfdf52a1", "patch": "@@ -1747,9 +1747,9 @@ struct saved_scope {\n   int minimal_parse_mode;\n   tree last_function_parms;\n   tree template_parms;\n+  tree previous_class_type, previous_class_values;\n };\n static struct saved_scope *current_saved_scope;\n-extern tree prev_class_type;\n \n tree\n store_bindings (names, old_bindings)\n@@ -1803,6 +1803,9 @@ maybe_push_to_top_level (pseudo)\n   struct binding_level *b = inner_binding_level;\n   tree old_bindings = NULL_TREE;\n \n+  if (previous_class_type)\n+    old_bindings = store_bindings (previous_class_values, old_bindings);\n+\n   /* Have to include global_binding_level, because class-level decls\n      aren't listed anywhere useful.  */\n   for (; b; b = b->level_chain)\n@@ -1840,6 +1843,8 @@ maybe_push_to_top_level (pseudo)\n   s->minimal_parse_mode = minimal_parse_mode;\n   s->last_function_parms = last_function_parms;\n   s->template_parms = current_template_parms;\n+  s->previous_class_type = previous_class_type;\n+  s->previous_class_values = previous_class_values;\n   current_class_name = current_class_type = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   class_binding_level = (struct binding_level *)0;\n@@ -1850,6 +1855,7 @@ maybe_push_to_top_level (pseudo)\n   strict_prototype = strict_prototypes_lang_cplusplus;\n   named_labels = NULL_TREE;\n   minimal_parse_mode = 0;\n+  previous_class_type = previous_class_values = NULL_TREE;\n   if (!pseudo)\n     current_template_parms = NULL_TREE;\n \n@@ -1913,6 +1919,8 @@ pop_from_top_level ()\n   minimal_parse_mode = s->minimal_parse_mode;\n   last_function_parms = s->last_function_parms;\n   current_template_parms = s->template_parms;\n+  previous_class_type = s->previous_class_type;\n+  previous_class_values = s->previous_class_values;\n \n   free (s);\n }\n@@ -5839,12 +5847,10 @@ start_decl (declarator, declspecs, initialized, raises)\n \n #if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n   /* Tell the back-end to use or not use .common as appropriate.  If we say\n-     -fconserve-space, we want this to save space, at the expense of wrong\n-     semantics.  If we say -fno-conserve-space, we want this to produce\n-     errors about redefs; to do this we force variables into the data\n-     segment.  Common storage is okay for non-public uninitialized data;\n-     the linker can't match it with storage from other files, and we may\n-     save some disk space.  */\n+     -fconserve-space, we want this to save .data space, at the expense of\n+     wrong semantics.  If we say -fno-conserve-space, we want this to\n+     produce errors about redefs; to do this we force variables into the\n+     data segment.  */\n   DECL_COMMON (tem) = flag_conserve_space || ! TREE_PUBLIC (tem);\n #endif\n "}, {"sha": "667d65b06bc3c36c5755ad6f6a062b5b3ffe3a9a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a50f0918152b332395d7f224ca5f1619cfdf52a1", "patch": "@@ -2591,7 +2591,9 @@ finish_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n   if (write_virtuals >= 0\n-      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars))\n+      && ! DECL_EXTERNAL (vars)\n+      && ((TREE_PUBLIC (vars) && ! DECL_WEAK (vars) && ! DECL_ONE_ONLY (vars))\n+\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars)))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n       /* Write it out.  */\n@@ -2630,7 +2632,7 @@ finish_vtable_vardecl (prev, vars)\n       rest_of_decl_compilation (vars, NULL_PTR, 1, 1);\n       return 1;\n     }\n-  else if (! TREE_USED (vars))\n+  else if (! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars)))\n     /* We don't know what to do with this one yet.  */\n     return 0;\n \n@@ -3233,37 +3235,29 @@ finish_file ()\n \t\treconsider = 1;\n \t      }\n \n+\t    /* Catch new template instantiations.  */\n \t    if (decl != TREE_VALUE (*p))\n-\t      ;\n-\t    else if (TREE_ASM_WRITTEN (decl)\n-\t\t     || (DECL_SAVED_INSNS (decl) == 0\n-\t\t\t && ! DECL_ARTIFICIAL (decl)))\n-\t      *p = TREE_CHAIN (*p);\n-\t    else\n-\t      p = &TREE_CHAIN (*p);\n-\t  }\n-      }\n+\t      continue;\n \n-    reconsider = 1;\t\t/* More may be referenced; check again */\n-    while (reconsider)\n-      {\n-\ttree *p = &saved_inlines;\n-\treconsider = 0;\n-\n-\twhile (*p)\n-\t  {\n-\t    tree decl = TREE_VALUE (*p);\n-\n-\t    if (TREE_ASM_WRITTEN (decl) || DECL_SAVED_INSNS (decl) == 0)\n+\t    if (TREE_ASM_WRITTEN (decl)\n+\t\t|| (DECL_SAVED_INSNS (decl) == 0 && ! DECL_ARTIFICIAL (decl)))\n \t      *p = TREE_CHAIN (*p);\n-\t    else if ((TREE_PUBLIC (decl) && ! DECL_WEAK (decl))\n+\t    else if (DECL_INITIAL (decl) == 0)\n+\t      p = &TREE_CHAIN (*p);\n+\t    else if ((TREE_PUBLIC (decl) && ! DECL_WEAK (decl)\n+\t\t      && ! DECL_ONE_ONLY (decl))\n \t\t     || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t\t     || flag_keep_inline_functions)\n \t      {\n \t\tif (DECL_NOT_REALLY_EXTERN (decl))\n \t\t  {\n \t\t    DECL_EXTERNAL (decl) = 0;\n \t\t    reconsider = 1;\n+\t\t    /* We can't inline this function after it's been\n+                       emitted, so just disable inlining.  We want a\n+                       variant of output_inline_function that doesn't\n+                       prevent subsequent integration... */\n+\t\t    flag_no_inline = 1;\n \t\t    temporary_allocation ();\n \t\t    output_inline_function (decl);\n \t\t    permanent_allocation (1);"}, {"sha": "b530a3ba058662d1ed017edb56c3690bf42f5f45", "filename": "gcc/cp/except.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a50f0918152b332395d7f224ca5f1619cfdf52a1", "patch": "@@ -326,6 +326,8 @@ static tree saved_throw_type;\n static tree saved_throw_value;\n /* Holds the cleanup for the value being thrown.  */\n static tree saved_cleanup;\n+/* Indicates if we are in a catch clause.  */\n+static tree saved_in_catch;\n \n static int throw_used;\n \n@@ -754,6 +756,13 @@ init_exception_processing ()\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_cleanup = lookup_name (get_identifier (\"__eh_cleanup\"), 0);\n+\n+  declspecs = tree_cons (NULL_TREE, get_identifier (\"bool\"), NULL_TREE);\n+  d = get_identifier (\"__eh_in_catch\");\n+  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  DECL_COMMON (d) = 1;\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n+  saved_in_catch = lookup_name (get_identifier (\"__eh_in_catch\"), 0);\n }\n \n /* call this to begin a block of unwind protection (ie: when an object is\n@@ -950,6 +959,9 @@ push_eh_cleanup ()\n \n   /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n   tree cleanup = build_function_call (saved_cleanup, NULL_TREE);\n+  cleanup = build (COMPOUND_EXPR, void_type_node, cleanup,\n+\t\t   build_modify_expr (saved_in_catch, NOP_EXPR,\n+\t\t\t\t      build_modify_expr (saved_throw_type, NOP_EXPR, integer_zero_node)));\n   cp_expand_decl_cleanup (NULL_TREE, cleanup);\n \n   resume_momentary (yes);\n@@ -1045,6 +1057,7 @@ expand_start_catch_block (declspecs, declarator)\n       /* Fall into the catch all section. */\n     }\n \n+  emit_move_insn (DECL_RTL (saved_in_catch), const1_rtx);\n   /* This is the starting of something to protect.  */\n   emit_label (protect_label_rtx);\n \n@@ -1327,6 +1340,13 @@ expand_builtin_throw ()\n   top_of_loop = gen_label_rtx ();\n   unwind_first = gen_label_rtx ();\n \n+  /* These two can be frontend specific.  If wanted, they can go in\n+     expand_throw. */\n+  /* Do we have a valid object we are throwing? */\n+  emit_cmp_insn (DECL_RTL (saved_throw_type), const0_rtx, EQ, NULL_RTX,\n+\t\t GET_MODE (DECL_RTL (saved_throw_type)), 0, 0);\n+  emit_jump_insn (gen_beq (gotta_call_terminate));\n+\n   emit_jump (unwind_first);\n \n   emit_label (top_of_loop);\n@@ -1678,6 +1698,7 @@ expand_throw (exp)\n \t{\n \t  rtx cleanup_insns;\n \t  tree object;\n+\n \t  /* Make a copy of the thrown object.  WP 15.1.5  */\n \t  exp = build_new (NULL_TREE, TREE_TYPE (exp),\n \t\t\t   build_tree_list (NULL_TREE, exp),"}, {"sha": "69161f9b5a395d31c56a311cde9d41aef713ab80", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50f0918152b332395d7f224ca5f1619cfdf52a1/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=a50f0918152b332395d7f224ca5f1619cfdf52a1", "patch": "@@ -1219,15 +1219,18 @@ All completely constructed temps and local variables are cleaned up in\n all unwinded scopes.  Completely constructed parts of partially\n constructed objects are cleaned up.  This includes partially built\n arrays.  Exception specifications are now handled.  Thrown objects are\n-now cleaned up all the time.\n+now cleaned up all the time.  We can now tell if we have an active\n+exception being thrown or not (__eh_type != 0).  We use this to call\n+terminate if someone does a throw; without there being an active\n+exception object.  uncaught_exception () works.\n \n The below points out some flaws in g++'s exception handling, as it now\n stands.\n \n Only exact type matching or reference matching of throw types works when\n--fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm,\n-rs6000, PowerPC, Alpha, mips, VAX, m68k and z8k machines.  Partial support\n-is in for all other machines, but a stack unwinder called\n+-fno-rtti is used.  Only works on a SPARC (like Suns), SPARClite, i386,\n+arm, rs6000, PowerPC, Alpha, mips, VAX, m68k and z8k machines.  Partial\n+support is in for all other machines, but a stack unwinder called\n __unwind_function has to be written, and added to libgcc2 for them.  The\n new EH code doesn't rely upon the __unwind_function for C++ code,\n instead it creates per function unwinders right inside the function,"}]}