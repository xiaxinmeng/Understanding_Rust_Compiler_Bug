{"sha": "34998d6bb655f3270bc54656aa9519360100c2d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ5OThkNmJiNjU1ZjMyNzBiYzU0NjU2YWE5NTE5MzYwMTAwYzJkOA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-12-30T15:51:15Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-30T15:51:15Z"}, "message": "ObjectInputStream.java, [...]: Reformated, no functional code changes.\n\n2003-12-30  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/ObjectInputStream.java,\n\tjava/io/ObjectOutputStream.java,\n\tjava/io/ObjectStreamClass.java:\n\tReformated, no functional code changes.\n\nFrom-SVN: r75236", "tree": {"sha": "3d9504271f8d663874288d9f51dc992e98266033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9504271f8d663874288d9f51dc992e98266033"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34998d6bb655f3270bc54656aa9519360100c2d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34998d6bb655f3270bc54656aa9519360100c2d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34998d6bb655f3270bc54656aa9519360100c2d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34998d6bb655f3270bc54656aa9519360100c2d8/comments", "author": null, "committer": null, "parents": [{"sha": "31775d3113a0c28019d16931f12c83bd3c9df845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31775d3113a0c28019d16931f12c83bd3c9df845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31775d3113a0c28019d16931f12c83bd3c9df845"}], "stats": {"total": 2277, "additions": 1151, "deletions": 1126}, "files": [{"sha": "9211c7c91f670d8f892f0ef8fdfe199a8140c669", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=34998d6bb655f3270bc54656aa9519360100c2d8", "patch": "@@ -1,3 +1,10 @@\n+2003-12-30  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/ObjectInputStream.java,\n+\tjava/io/ObjectOutputStream.java,\n+\tjava/io/ObjectStreamClass.java:\n+\tReformated, no functional code changes.\n+\n 2003-12-30  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/http/Connection.java"}, {"sha": "c2ddbe077c63a24fbde54f67e9969d793e875b45", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 390, "deletions": 382, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=34998d6bb655f3270bc54656aa9519360100c2d8", "patch": "@@ -73,7 +73,7 @@ public class ObjectInputStream extends InputStream\n    *\n    * @see #readStreamHeader()\n    */\n-  public ObjectInputStream (InputStream in)\n+  public ObjectInputStream(InputStream in)\n     throws IOException, StreamCorruptedException\n   {\n     if (Configuration.DEBUG)\n@@ -96,14 +96,14 @@ else if (dump == true && (val == null || val.equals(\"\")))\n     this.blockDataPosition = 0;\n     this.blockDataBytes = 0;\n     this.blockData = new byte[BUFFER_SIZE];\n-    this.blockDataInput = new DataInputStream (this);\n-    this.realInputStream = new DataInputStream (in);\n+    this.blockDataInput = new DataInputStream(this);\n+    this.realInputStream = new DataInputStream(in);\n     this.nextOID = baseWireHandle;\n-    this.objectLookupTable = new Hashtable ();\n-    this.validators = new Vector ();\n+    this.objectLookupTable = new Hashtable();\n+    this.validators = new Vector();\n     this.classLookupTable = new Hashtable();\n-    setBlockDataMode (true);\n-    readStreamHeader ();\n+    setBlockDataMode(true);\n+    readStreamHeader();\n   }\n \n \n@@ -122,23 +122,23 @@ else if (dump == true && (val == null || val.equals(\"\")))\n    * @exception IOException Exception from underlying\n    * <code>InputStream</code>.\n    */\n-  public final Object readObject () throws ClassNotFoundException, IOException\n+  public final Object readObject() throws ClassNotFoundException, IOException\n   {\n     if (this.useSubclassMethod)\n-      return readObjectOverride ();\n+      return readObjectOverride();\n \n     boolean was_deserializing;\n \n     Object ret_val;\n     was_deserializing = this.isDeserializing;\n \n     boolean is_consumed = false;\n-    boolean old_mode = setBlockDataMode (false);\n+    boolean old_mode = setBlockDataMode(false);\n \n     this.isDeserializing = true;\n \n-    byte marker = this.realInputStream.readByte ();\n-    dumpElement (\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n+    byte marker = this.realInputStream.readByte();\n+    dumpElement(\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n \n     try\n       {\n@@ -155,43 +155,43 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t  case TC_BLOCKDATALONG:\n \t    {\n \t      if (marker == TC_BLOCKDATALONG)\n-\t\tdumpElementln (\"BLOCKDATALONG\");\n+\t\tdumpElementln(\"BLOCKDATALONG\");\n \t      else\n-\t\tdumpElementln (\"BLOCKDATA\");\n-\t      readNextBlock (marker);\n-\t      throw new StreamCorruptedException (\"Unexpected blockData\");\n+\t\tdumpElementln(\"BLOCKDATA\");\n+\t      readNextBlock(marker);\n+\t      throw new StreamCorruptedException(\"Unexpected blockData\");\n \t    }\n \n \t  case TC_NULL:\n \t    {\n-\t      dumpElementln (\"NULL\");\n+\t      dumpElementln(\"NULL\");\n \t      ret_val = null;\n \t      break;\n \t    }\n \n \t  case TC_REFERENCE:\n \t    {\n-\t      dumpElement (\"REFERENCE \");\n-\t      Integer oid = new Integer (this.realInputStream.readInt ());\n-\t      dumpElementln (Integer.toHexString(oid.intValue()));\n+\t      dumpElement(\"REFERENCE \");\n+\t      Integer oid = new Integer(this.realInputStream.readInt());\n+\t      dumpElementln(Integer.toHexString(oid.intValue()));\n \t      ret_val = ((ObjectIdentityWrapper)\n-\t\t\t this.objectLookupTable.get (oid)).object;\n+\t\t\t this.objectLookupTable.get(oid)).object;\n \t      break;\n \t    }\n \n \t  case TC_CLASS:\n \t    {\n-\t      dumpElementln (\"CLASS\");\n-\t      ObjectStreamClass osc = (ObjectStreamClass)readObject ();\n-\t      Class clazz = osc.forClass ();\n-\t      assignNewHandle (clazz);\n+\t      dumpElementln(\"CLASS\");\n+\t      ObjectStreamClass osc = (ObjectStreamClass)readObject();\n+\t      Class clazz = osc.forClass();\n+\t      assignNewHandle(clazz);\n \t      ret_val = clazz;\n \t      break;\n \t    }\n \n \t  case TC_PROXYCLASSDESC:\n \t    {\n-\t      dumpElementln (\"PROXYCLASS\");\n+\t      dumpElementln(\"PROXYCLASS\");\n \t      int n_intf = this.realInputStream.readInt();\n \t      String[] intfs = new String[n_intf];\n \t      for (int i = 0; i < n_intf; i++)\n@@ -200,147 +200,149 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t\t  System.out.println(intfs[i]);\n \t\t}\n \t      \n-\t      boolean oldmode = setBlockDataMode (true);\n+\t      boolean oldmode = setBlockDataMode(true);\n \t      Class cl = resolveProxyClass(intfs);\n \t      setBlockDataMode(oldmode);\n \t      \n \t      ObjectStreamClass osc = lookupClass(cl);\n-\t      assignNewHandle (osc);\n+\t      assignNewHandle(osc);\n \t      \n \t      if (!is_consumed)\n \t\t{\n-\t\t  byte b = this.realInputStream.readByte ();\n+\t\t  byte b = this.realInputStream.readByte();\n \t\t  if (b != TC_ENDBLOCKDATA)\n-\t\t    throw new IOException (\"Data annotated to class was not consumed.\" + b);\n+\t\t    throw new IOException(\"Data annotated to class was not consumed.\" + b);\n \t\t}\n \t      else\n \t\tis_consumed = false;\n-\t      ObjectStreamClass superosc = (ObjectStreamClass)readObject ();\n-\t      osc.setSuperclass (superosc);\n+\t      ObjectStreamClass superosc = (ObjectStreamClass)readObject();\n+\t      osc.setSuperclass(superosc);\n \t      ret_val = osc;\n \t      break;\n \t    }\n \n \t  case TC_CLASSDESC:\n \t    {\n-\t      ObjectStreamClass osc = readClassDescriptor ();\n+\t      ObjectStreamClass osc = readClassDescriptor();\n \t      \n \t      if (!is_consumed)\n \t\t{\n-\t\t  byte b = this.realInputStream.readByte ();\n+\t\t  byte b = this.realInputStream.readByte();\n \t\t  if (b != TC_ENDBLOCKDATA)\n-\t\t    throw new IOException (\"Data annotated to class was not consumed.\" + b);\n+\t\t    throw new IOException(\"Data annotated to class was not consumed.\" + b);\n \t\t}\n \t      else\n \t\tis_consumed = false;\n \t      \n-\t      osc.setSuperclass ((ObjectStreamClass)readObject ());\n+\t      osc.setSuperclass ((ObjectStreamClass)readObject());\n \t      ret_val = osc;\n \t      break;\n \t    }\n \n \t  case TC_STRING:\n \t  case TC_LONGSTRING:\n \t    {\n-\t      dumpElement (\"STRING=\");\n-\t      String s = this.realInputStream.readUTF ();\n-\t      dumpElementln (s);\n-\t      ret_val = processResolution (s, assignNewHandle (s));\n+\t      dumpElement(\"STRING=\");\n+\t      String s = this.realInputStream.readUTF();\n+\t      dumpElementln(s);\n+\t      ret_val = processResolution(s, assignNewHandle(s));\n \t      break;\n \t    }\n \n \t  case TC_ARRAY:\n \t    {\n-\t      dumpElementln (\"ARRAY\");\n-\t      ObjectStreamClass osc = (ObjectStreamClass)readObject ();\n-\t      Class componentType = osc.forClass ().getComponentType ();\n-\t      dumpElement (\"ARRAY LENGTH=\");\n-\t      int length = this.realInputStream.readInt ();\n+\t      dumpElementln(\"ARRAY\");\n+\t      ObjectStreamClass osc = (ObjectStreamClass)readObject();\n+\t      Class componentType = osc.forClass().getComponentType();\n+\t      dumpElement(\"ARRAY LENGTH=\");\n+\t      int length = this.realInputStream.readInt();\n \t      dumpElementln (length + \"; COMPONENT TYPE=\" + componentType);\n-\t      Object array = Array.newInstance (componentType, length);\n-\t      int handle = assignNewHandle (array);\n-\t      readArrayElements (array, componentType);\n-\t      for (int i=0, len=Array.getLength(array); i < len; i++)\n-\t\tdumpElementln (\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n-\t      ret_val = processResolution (array, handle);\n+\t      Object array = Array.newInstance(componentType, length);\n+\t      int handle = assignNewHandle(array);\n+\t      readArrayElements(array, componentType);\n+\t      for (int i = 0, len = Array.getLength(array); i < len; i++)\n+\t\tdumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n+\t      ret_val = processResolution(array, handle);\n \t      break;\n \t    }\n \n \t  case TC_OBJECT:\n \t    {\n-\t      dumpElementln (\"OBJECT\");\n-\t      ObjectStreamClass osc = (ObjectStreamClass)readObject ();\n-\t      Class clazz = osc.forClass ();\n+\t      dumpElementln(\"OBJECT\");\n+\t      ObjectStreamClass osc = (ObjectStreamClass)readObject();\n+\t      Class clazz = osc.forClass();\n \t      \n-\t      if (!Serializable.class.isAssignableFrom (clazz))\n-\t\tthrow new NotSerializableException (clazz + \" is not Serializable, and thus cannot be deserialized.\");\n+\t      if (!Serializable.class.isAssignableFrom(clazz))\n+\t\tthrow new NotSerializableException\n+\t\t  (clazz + \" is not Serializable, and thus cannot be deserialized.\");\n \t      \n-\t      if (Externalizable.class.isAssignableFrom (clazz))\n+\t      if (Externalizable.class.isAssignableFrom(clazz))\n \t\t{\n \t\t  Externalizable obj = null;\n \t\t  \n \t\t  try\n \t\t    {\n-\t\t      obj = (Externalizable)clazz.newInstance ();\n+\t\t      obj = (Externalizable)clazz.newInstance();\n \t\t    }\n \t\t  catch (InstantiationException e)\n \t\t    {\n-\t\t      throw new ClassNotFoundException (\"Instance of \" + clazz\n-\t\t\t\t\t\t\t+ \" could not be created\");\n+\t\t      throw new ClassNotFoundException\n+\t\t\t(\"Instance of \" + clazz + \" could not be created\");\n \t\t    }\n \t\t  catch (IllegalAccessException e)\n \t\t    {\n-\t\t      throw new ClassNotFoundException (\"Instance of \" + clazz\n-\t\t\t\t\t\t\t+ \" could not be created because class or zero-argument constructor is not accessible\");\n+\t\t      throw new ClassNotFoundException\n+\t\t\t(\"Instance of \" + clazz + \" could not be created because class or \"\n+\t\t\t + \"zero-argument constructor is not accessible\");\n \t\t    }\n \t\t  catch (NoSuchMethodError e)\n \t\t    {\n-\t\t      throw new ClassNotFoundException (\"Instance of \" + clazz\n-\t\t\t\t\t\t\t+ \" could not be created because zero-argument constructor is not defined\");\n+\t\t      throw new ClassNotFoundException\n+\t\t\t(\"Instance of \" + clazz\n+\t\t\t + \" could not be created because zero-argument constructor is not defined\");\n \t\t    }\n \t\t  \n-\t\t  int handle = assignNewHandle (obj);\n+\t\t  int handle = assignNewHandle(obj);\n \t\t  \n-\t\t  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);\n+\t\t  boolean read_from_blocks = ((osc.getFlags() & SC_BLOCK_DATA) != 0);\n \t\t  \n \t\t  boolean oldmode = this.readDataFromBlock;\n \t\t  if (read_from_blocks)\n-\t\t    setBlockDataMode (true);\n+\t\t    setBlockDataMode(true);\n \t\t  \n-\t\t  obj.readExternal (this);\n+\t\t  obj.readExternal(this);\n \t\t  \n \t\t  if (read_from_blocks)\n-\t\t    setBlockDataMode (oldmode);\n+\t\t    setBlockDataMode(oldmode);\n \t\t  \n-\t\t  ret_val = processResolution (obj, handle);\n+\t\t  ret_val = processResolution(obj, handle);\n \t\t  break;\n \t\t} // end if (Externalizable.class.isAssignableFrom (clazz))\n \t      \n \t      // find the first non-serializable, non-abstract\n \t      // class in clazz's inheritance hierarchy\n-\t      Class first_nonserial = clazz.getSuperclass ();\n-\t      while (Serializable.class.isAssignableFrom (first_nonserial)\n-\t\t     || Modifier.isAbstract (first_nonserial.getModifiers ()))\n-\t\tfirst_nonserial = first_nonserial.getSuperclass ();\n+\t      Class first_nonserial = clazz.getSuperclass();\n+\t      while (Serializable.class.isAssignableFrom(first_nonserial)\n+\t\t     || Modifier.isAbstract(first_nonserial.getModifiers()))\n+\t\tfirst_nonserial = first_nonserial.getSuperclass();\n \t      \n \t      Object obj = null;\n-\t      obj = newObject (clazz, first_nonserial);\n+\t      obj = newObject(clazz, first_nonserial);\n \t      \n \t      if (obj == null)\n-\t\tthrow new ClassNotFoundException (\"Instance of \" + clazz +\n-\t\t\t\t\t\t  \" could not be created\");\n+\t\tthrow new ClassNotFoundException\n+\t\t  (\"Instance of \" + clazz + \" could not be created\");\n \t      \n-\t      int handle = assignNewHandle (obj);\n+\t      int handle = assignNewHandle(obj);\n \t      this.currentObject = obj;\n \t      ObjectStreamClass[] hierarchy =\n \t\tinputGetObjectStreamClasses(clazz);\n \t      \n-\t      for (int i=0; i < hierarchy.length; i++)\n+\t      for (int i = 0; i < hierarchy.length; i++)\n \t\t{\n \t\t  this.currentObjectStreamClass = hierarchy[i];\n \t\t  \n-\t\t  dumpElementln (\"Reading fields of \"\n-\t\t\t\t + this.currentObjectStreamClass.getName ());\n+\t\t  dumpElementln(\"Reading fields of \" + this.currentObjectStreamClass.getName ());\n \n \t\t  // XXX: should initialize fields in classes in the hierarchy\n \t\t  // that aren't in the stream\n@@ -350,68 +352,69 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t\t  if (this.currentObjectStreamClass.hasReadMethod())\n \t\t    {\n \t\t      fieldsAlreadyRead = false;\n-\t\t      boolean oldmode = setBlockDataMode (true);\n-\t\t      callReadMethod (obj, this.currentObjectStreamClass);\n-\t\t      setBlockDataMode (oldmode);\n-\t\t      dumpElement (\"ENDBLOCKDATA? \");\n+\t\t      boolean oldmode = setBlockDataMode(true);\n+\t\t      callReadMethod(obj, this.currentObjectStreamClass);\n+\t\t      setBlockDataMode(oldmode);\n+\t\t      dumpElement(\"ENDBLOCKDATA? \");\n \t\t      try\n \t\t\t{\n \t\t\t  // FIXME: XXX: This try block is to catch EOF which is\n \t\t\t  // thrown for some objects.  That indicates a bug in the logic.\n-\t\t\t  if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n-\t\t\t    throw new IOException (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n-\t\t\t  dumpElementln (\"yes\");\n+\t\t\t  if (this.realInputStream.readByte() != TC_ENDBLOCKDATA)\n+\t\t\t    throw new IOException\n+\t\t\t      (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n+\t\t\t  dumpElementln(\"yes\");\n \t\t\t}\n \t\t      catch (EOFException e)\n \t\t\t{\n-\t\t\t  dumpElementln (\"no, got EOFException\");\n+\t\t\t  dumpElementln(\"no, got EOFException\");\n \t\t\t}\n \t\t      catch (IOException e)\n \t\t\t{\n-\t\t\t  dumpElementln (\"no, got IOException\");\n+\t\t\t  dumpElementln(\"no, got IOException\");\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      readFields (obj, currentObjectStreamClass);\n+\t\t      readFields(obj, currentObjectStreamClass);\n \t\t    }\n \t\t}\n \n \t      this.currentObject = null;\n \t      this.currentObjectStreamClass = null;\n-\t      ret_val = processResolution (obj, handle);\n+\t      ret_val = processResolution(obj, handle);\n \t      break;\n \t    }\n \n \t  case TC_RESET:\n-\t    dumpElementln (\"RESET\");\n-\t    clearHandles ();\n-\t    ret_val = readObject ();\n+\t    dumpElementln(\"RESET\");\n+\t    clearHandles();\n+\t    ret_val = readObject();\n \t    break;\n \n \t  case TC_EXCEPTION:\n \t    {\n-\t      dumpElement (\"EXCEPTION=\");\n-\t      Exception e = (Exception)readObject ();\n-\t      dumpElementln (e.toString());\n-\t      clearHandles ();\n-\t      throw new WriteAbortedException (\"Exception thrown during writing of stream\", e);\n+\t      dumpElement(\"EXCEPTION=\");\n+\t      Exception e = (Exception)readObject();\n+\t      dumpElementln(e.toString());\n+\t      clearHandles();\n+\t      throw new WriteAbortedException(\"Exception thrown during writing of stream\", e);\n \t    }\n \n \t  default:\n-\t    throw new IOException (\"Unknown marker on stream: \" + marker);\n+\t    throw new IOException(\"Unknown marker on stream: \" + marker);\n \t  }\n       }\n     finally\n       {\n-\tsetBlockDataMode (old_mode);\n+\tsetBlockDataMode(old_mode);\n \t\n \tthis.isDeserializing = was_deserializing;\n \t\n \tif (! was_deserializing)\n \t  {\n-\t    if (validators.size () > 0)\n-\t      invokeValidators ();\n+\t    if (validators.size() > 0)\n+\t      invokeValidators();\n \t  }\n       }\n     \n@@ -434,40 +437,40 @@ public final Object readObject () throws ClassNotFoundException, IOException\n    * @throws InvalidClassException If there was a compatibility problem\n    * between the class present in the system and the serialized class.\n    */\n-  protected ObjectStreamClass readClassDescriptor ()\n+  protected ObjectStreamClass readClassDescriptor()\n     throws ClassNotFoundException, IOException\n   {\n-    dumpElement (\"CLASSDESC NAME=\");\n-    String name = this.realInputStream.readUTF ();\n-    dumpElement (name + \"; UID=\");\n+    dumpElement(\"CLASSDESC NAME=\");\n+    String name = this.realInputStream.readUTF();\n+    dumpElement(name + \"; UID=\");\n     long uid = this.realInputStream.readLong ();\n-    dumpElement (Long.toHexString(uid) + \"; FLAGS=\");\n+    dumpElement(Long.toHexString(uid) + \"; FLAGS=\");\n     byte flags = this.realInputStream.readByte ();\n-    dumpElement (Integer.toHexString(flags) + \"; FIELD COUNT=\");\n-    short field_count = this.realInputStream.readShort ();\n-    dumpElementln (Short.toString(field_count));\n+    dumpElement(Integer.toHexString(flags) + \"; FIELD COUNT=\");\n+    short field_count = this.realInputStream.readShort();\n+    dumpElementln(Short.toString(field_count));\n     ObjectStreamField[] fields = new ObjectStreamField[field_count];\n-    ObjectStreamClass osc = new ObjectStreamClass (name, uid,\n-                                                   flags, fields);\n-    assignNewHandle (osc);\n+    ObjectStreamClass osc = new ObjectStreamClass(name, uid,\n+\t\t\t\t\t\t  flags, fields);\n+    assignNewHandle(osc);\n \t      \n-    for (int i=0; i < field_count; i++)\n+    for (int i = 0; i < field_count; i++)\n       {\n-\tdumpElement (\"  TYPE CODE=\");\n-\tchar type_code = (char)this.realInputStream.readByte ();\n-\tdumpElement (type_code + \"; FIELD NAME=\");\n-\tString field_name = this.realInputStream.readUTF ();\n-\tdumpElementln (field_name);\n+\tdumpElement(\"  TYPE CODE=\");\n+\tchar type_code = (char)this.realInputStream.readByte();\n+\tdumpElement(type_code + \"; FIELD NAME=\");\n+\tString field_name = this.realInputStream.readUTF();\n+\tdumpElementln(field_name);\n \tString class_name;\n \t\t  \n \t// If the type code is an array or an object we must\n \t// decode a String here. In the other case we convert\n \t// the type code and pass it to ObjectStreamField.\n \t// Type codes are decoded by gnu.java.lang.reflect.TypeSignature.\n \tif (type_code == 'L' || type_code == '[')\n-\t  class_name = (String)readObject ();\n+\t  class_name = (String)readObject();\n \telse\n-\t  class_name = String.valueOf (type_code);\n+\t  class_name = String.valueOf(type_code);\n \t\t  \n \tfields[i] =\n \t  new ObjectStreamField(field_name, class_name, currentLoader());\n@@ -495,11 +498,11 @@ protected ObjectStreamClass readClassDescriptor ()\n \t  }\n       }\n \n-    boolean oldmode = setBlockDataMode (true);\n-    osc.setClass (clazz, lookupClass(clazz.getSuperclass()));\n+    boolean oldmode = setBlockDataMode(true);\n+    osc.setClass(clazz, lookupClass(clazz.getSuperclass()));\n     classLookupTable.put(clazz, osc);\n-    setBlockDataMode (oldmode);\n-\t      \n+    setBlockDataMode(oldmode);\n+\n     return osc;\n   }\n \n@@ -522,7 +525,7 @@ protected ObjectStreamClass readClassDescriptor ()\n    * @exception IOException Exception from underlying\n    * <code>OutputStream</code>.\n    */\n-  public void defaultReadObject ()\n+  public void defaultReadObject()\n     throws ClassNotFoundException, IOException, NotActiveException\n   {\n     if (this.currentObject == null || this.currentObjectStreamClass == null)\n@@ -535,7 +538,7 @@ public void defaultReadObject ()\n \t\t\t\t   + \"defaultReadObject or readFields)\");\n \n     boolean oldmode = setBlockDataMode(false);\n-    readFields (this.currentObject, this.currentObjectStreamClass);\n+    readFields(this.currentObject, this.currentObjectStreamClass);\n     setBlockDataMode(oldmode);\n \n     fieldsAlreadyRead = true;\n@@ -560,20 +563,20 @@ public void defaultReadObject ()\n    * validator outside of the <code>readObject</code> method of the\n    * object currently being deserialized\n    */\n-  public void registerValidation (ObjectInputValidation validator,\n-\t\t\t\t  int priority)\n+  public void registerValidation(ObjectInputValidation validator,\n+\t\t\t\t int priority)\n     throws InvalidObjectException, NotActiveException\n   {\n     if (this.currentObject == null || this.currentObjectStreamClass == null)\n-      throw new NotActiveException (\"registerValidation called by non-active \"\n-\t\t\t\t    +\"class and/or object\");\n+      throw new NotActiveException(\"registerValidation called by non-active \"\n+\t\t\t\t   + \"class and/or object\");\n \n     if (validator == null)\n-      throw new InvalidObjectException (\"attempt to add a null \"\n-\t\t\t\t\t+\"ObjectInputValidation object\");\n+      throw new InvalidObjectException(\"attempt to add a null \"\n+\t\t\t\t       + \"ObjectInputValidation object\");\n \n-    this.validators.addElement (new ValidatorAndPriority (validator,\n-\t\t\t\t\t\t\t  priority));\n+    this.validators.addElement(new ValidatorAndPriority (validator,\n+\t\t\t\t\t\t\t priority));\n   }\n \n \n@@ -593,7 +596,7 @@ public void registerValidation (ObjectInputValidation validator,\n    *\n    * @see java.io.ObjectOutputStream#annotateClass (java.lang.Class)\n    */\n-  protected Class resolveClass (ObjectStreamClass osc)\n+  protected Class resolveClass(ObjectStreamClass osc)\n     throws ClassNotFoundException, IOException\n   {\n     return Class.forName(osc.getName(), true, currentLoader());\n@@ -609,7 +612,7 @@ protected Class resolveClass (ObjectStreamClass osc)\n    */\n   private ClassLoader currentLoader()\n   {\n-    SecurityManager sm = System.getSecurityManager ();\n+    SecurityManager sm = System.getSecurityManager();\n     if (sm == null)\n       sm = new SecurityManager () {};\n     \n@@ -627,13 +630,13 @@ private ClassLoader currentLoader()\n    * @return A valid instance of ObjectStreamClass corresponding\n    * to the specified class.\n    */\n-  private ObjectStreamClass lookupClass (Class clazz)\n+  private ObjectStreamClass lookupClass(Class clazz)\n   {\n     ObjectStreamClass oclazz;\n \n-    oclazz = (ObjectStreamClass) classLookupTable.get(clazz);\n+    oclazz = (ObjectStreamClass)classLookupTable.get(clazz);\n     if (oclazz == null)\n-      return ObjectStreamClass.lookup (clazz);\n+      return ObjectStreamClass.lookup(clazz);\n     else\n       return oclazz;\n   }\n@@ -650,9 +653,9 @@ private ObjectStreamClass lookupClass (Class clazz)\n    * @return An array of valid {@link java.io.ObjectStreamClass} instances which\n    * represent the class hierarchy for clazz.\n    */\n-  private ObjectStreamClass[] inputGetObjectStreamClasses (Class clazz)\n+  private ObjectStreamClass[] inputGetObjectStreamClasses(Class clazz)\n   {\n-    ObjectStreamClass osc = lookupClass (clazz);\n+    ObjectStreamClass osc = lookupClass(clazz);\n \n     ObjectStreamClass[] ret_val;\n \n@@ -691,36 +694,40 @@ private ObjectStreamClass[] inputGetObjectStreamClasses (Class clazz)\n    *\n    * @see #enableResolveObject(boolean)\n    */\n-  protected Object resolveObject (Object obj) throws IOException\n+  protected Object resolveObject(Object obj) throws IOException\n   {\n     return obj;\n   }\n \n \n-  protected Class resolveProxyClass (String[] intfs)\n+  protected Class resolveProxyClass(String[] intfs)\n     throws IOException, ClassNotFoundException\n   {\n-    SecurityManager sm = System.getSecurityManager ();\n+    SecurityManager sm = System.getSecurityManager();\n     \n     if (sm == null)\n-      sm = new SecurityManager () {};\n+      sm = new SecurityManager() {};\n     \n-    ClassLoader cl = currentClassLoader (sm);\n+    ClassLoader cl = currentClassLoader(sm);\n     \n     Class[] clss = new Class[intfs.length];\n-    if(cl == null){\n-      for (int i = 0; i < intfs.length; i++)\n-\tclss[i] = Class.forName(intfs[i]);\n-      cl = ClassLoader.getSystemClassLoader();\n-    }\n+    if(cl == null)\n+      {\n+\tfor (int i = 0; i < intfs.length; i++)\n+\t  clss[i] = Class.forName(intfs[i]);\n+\tcl = ClassLoader.getSystemClassLoader();\n+      }\n     else\n       for (int i = 0; i < intfs.length; i++)\n \tclss[i] = cl.loadClass(intfs[i]);\n-    try {\n-      return Proxy.getProxyClass(cl, clss);\n-    } catch (IllegalArgumentException e) {\n-      throw new ClassNotFoundException(null, e);\n-    }\n+    try \n+      {\n+\treturn Proxy.getProxyClass(cl, clss);\n+      } \n+    catch (IllegalArgumentException e) \n+      {\n+\tthrow new ClassNotFoundException(null, e);\n+      }\n   }\n   \n   /**\n@@ -736,9 +743,9 @@ protected boolean enableResolveObject (boolean enable)\n   {\n     if (enable)\n       {\n-\tSecurityManager sm = System.getSecurityManager ();\n+\tSecurityManager sm = System.getSecurityManager();\n \tif (sm != null)\n-\t  sm.checkPermission (new SerializablePermission (\"enableSubstitution\"));\n+\t  sm.checkPermission(new SerializablePermission(\"enableSubstitution\"));\n       }\n \n     boolean old_val = this.resolveEnabled;\n@@ -755,31 +762,31 @@ protected boolean enableResolveObject (boolean enable)\n    * @exception StreamCorruptedException An invalid stream magic\n    * number or stream version was read from the stream.\n    */\n-  protected void readStreamHeader ()\n+  protected void readStreamHeader()\n     throws IOException, StreamCorruptedException\n   {\n-    dumpElement (\"STREAM MAGIC \");\n-    if (this.realInputStream.readShort () != STREAM_MAGIC)\n-      throw new StreamCorruptedException (\"Invalid stream magic number\");\n+    dumpElement(\"STREAM MAGIC \");\n+    if (this.realInputStream.readShort() != STREAM_MAGIC)\n+      throw new StreamCorruptedException(\"Invalid stream magic number\");\n \n-    dumpElementln (\"STREAM VERSION \");\n-    if (this.realInputStream.readShort () != STREAM_VERSION)\n-      throw new StreamCorruptedException (\"Invalid stream version number\");\n+    dumpElementln(\"STREAM VERSION \");\n+    if (this.realInputStream.readShort() != STREAM_VERSION)\n+      throw new StreamCorruptedException(\"Invalid stream version number\");\n   }\n \n-  public int read () throws IOException\n+  public int read() throws IOException\n   {\n     if (this.readDataFromBlock)\n       {\n \tif (this.blockDataPosition >= this.blockDataBytes)\n-\t  readNextBlock ();\n+\t  readNextBlock();\n \treturn (this.blockData[this.blockDataPosition++] & 0xff);\n       }\n     else\n-      return this.realInputStream.read ();\n+      return this.realInputStream.read();\n   }\n \n-  public int read (byte[] data, int offset, int length) throws IOException\n+  public int read(byte[] data, int offset, int length) throws IOException\n   {\n     if (this.readDataFromBlock)\n       {\n@@ -788,25 +795,25 @@ public int read (byte[] data, int offset, int length) throws IOException\n \t    int remain = this.blockDataBytes - this.blockDataPosition;\n \t    if (remain != 0)\n \t      {\n-\t\tSystem.arraycopy (this.blockData, this.blockDataPosition,\n-\t\t\t\t  data, offset, remain);\n+\t\tSystem.arraycopy(this.blockData, this.blockDataPosition,\n+\t\t\t\t data, offset, remain);\n \t\toffset += remain;\n \t\tlength -= remain;\n \t      }\n \t    readNextBlock ();\n \t  }\n \n-\tSystem.arraycopy (this.blockData, this.blockDataPosition,\n-\t\t\t  data, offset, length);\n+\tSystem.arraycopy(this.blockData, this.blockDataPosition,\n+\t\t\t data, offset, length);\n \tthis.blockDataPosition += length;\n \n \treturn length;\n       }\n     else\n-      return this.realInputStream.read (data, offset, length);\n+      return this.realInputStream.read(data, offset, length);\n   }\n \n-  public int available () throws IOException\n+  public int available() throws IOException\n   {\n     if (this.readDataFromBlock)\n       {\n@@ -816,15 +823,15 @@ public int available () throws IOException\n \treturn this.blockDataBytes - this.blockDataPosition;\n       }\n     else\n-      return this.realInputStream.available ();\n+      return this.realInputStream.available();\n   }\n \n-  public void close () throws IOException\n+  public void close() throws IOException\n   {\n-    this.realInputStream.close ();\n+    this.realInputStream.close();\n   }\n \n-  public boolean readBoolean () throws IOException\n+  public boolean readBoolean() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n@@ -838,160 +845,160 @@ public boolean readBoolean () throws IOException\n     return value;\n   }\n \n-  public byte readByte () throws IOException\n+  public byte readByte() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    byte value = this.dataInputStream.readByte ();\n+      oldmode = setBlockDataMode(true);\n+    byte value = this.dataInputStream.readByte();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public int readUnsignedByte () throws IOException\n+  public int readUnsignedByte() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    int value = this.dataInputStream.readUnsignedByte ();\n+      oldmode = setBlockDataMode(true);\n+    int value = this.dataInputStream.readUnsignedByte();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public short readShort () throws IOException\n+  public short readShort() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    short value = this.dataInputStream.readShort ();\n+      oldmode = setBlockDataMode(true);\n+    short value = this.dataInputStream.readShort();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public int readUnsignedShort () throws IOException\n+  public int readUnsignedShort() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    int value = this.dataInputStream.readUnsignedShort ();\n+      oldmode = setBlockDataMode(true);\n+    int value = this.dataInputStream.readUnsignedShort();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public char readChar () throws IOException\n+  public char readChar() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    char value = this.dataInputStream.readChar ();\n+      oldmode = setBlockDataMode(true);\n+    char value = this.dataInputStream.readChar();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public int readInt () throws IOException\n+  public int readInt() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    int value = this.dataInputStream.readInt ();\n+      oldmode = setBlockDataMode(true);\n+    int value = this.dataInputStream.readInt();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public long readLong () throws IOException\n+  public long readLong() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    long value = this.dataInputStream.readLong ();\n+      oldmode = setBlockDataMode(true);\n+    long value = this.dataInputStream.readLong();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public float readFloat () throws IOException\n+  public float readFloat() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    float value = this.dataInputStream.readFloat ();\n+      oldmode = setBlockDataMode(true);\n+    float value = this.dataInputStream.readFloat();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public double readDouble () throws IOException\n+  public double readDouble() throws IOException\n   {\n     boolean switchmode = true;\n     boolean oldmode = this.readDataFromBlock;\n     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)\n       switchmode = false;\n     if (switchmode)\n-      oldmode = setBlockDataMode (true);\n-    double value = this.dataInputStream.readDouble ();\n+      oldmode = setBlockDataMode(true);\n+    double value = this.dataInputStream.readDouble();\n     if (switchmode)\n-      setBlockDataMode (oldmode);\n+      setBlockDataMode(oldmode);\n     return value;\n   }\n \n-  public void readFully (byte data[]) throws IOException\n+  public void readFully(byte data[]) throws IOException\n   {\n-    this.dataInputStream.readFully (data);\n+    this.dataInputStream.readFully(data);\n   }\n \n-  public void readFully (byte data[], int offset, int size)\n+  public void readFully(byte data[], int offset, int size)\n     throws IOException\n   {\n-    this.dataInputStream.readFully (data, offset, size);\n+    this.dataInputStream.readFully(data, offset, size);\n   }\n \n-  public int skipBytes (int len) throws IOException\n+  public int skipBytes(int len) throws IOException\n   {\n-    return this.dataInputStream.skipBytes (len);\n+    return this.dataInputStream.skipBytes(len);\n   }\n \n   /**\n    * @deprecated\n    * @see java.io.DataInputStream#readLine ()\n    */\n-  public String readLine () throws IOException\n+  public String readLine() throws IOException\n   {\n-    return this.dataInputStream.readLine ();\n+    return this.dataInputStream.readLine();\n   }\n \n-  public String readUTF () throws IOException\n+  public String readUTF() throws IOException\n   {\n-    return this.dataInputStream.readUTF ();\n+    return this.dataInputStream.readUTF();\n   }\n \n   /**\n@@ -1002,36 +1009,36 @@ public String readUTF () throws IOException\n    */\n   public static abstract class GetField\n   {\n-    public abstract ObjectStreamClass getObjectStreamClass ();\n+    public abstract ObjectStreamClass getObjectStreamClass();\n \n-    public abstract boolean defaulted (String name)\n+    public abstract boolean defaulted(String name)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract boolean get (String name, boolean defvalue)\n+    public abstract boolean get(String name, boolean defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract char get (String name, char defvalue)\n+    public abstract char get(String name, char defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract byte get (String name, byte defvalue)\n+    public abstract byte get(String name, byte defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract short get (String name, short defvalue)\n+    public abstract short get(String name, short defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract int get (String name, int defvalue)\n+    public abstract int get(String name, int defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract long get (String name, long defvalue)\n+    public abstract long get(String name, long defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract float get (String name, float defvalue)\n+    public abstract float get(String name, float defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract double get (String name, double defvalue)\n+    public abstract double get(String name, double defvalue)\n       throws IOException, IllegalArgumentException;\n \n-    public abstract Object get (String name, Object defvalue)\n+    public abstract Object get(String name, Object defvalue)\n       throws IOException, IllegalArgumentException;\n   }\n \n@@ -1048,18 +1055,18 @@ public abstract Object get (String name, Object defvalue)\n    * @throws ClassNotFoundException \n    * @throws NotActiveException\n    */\n-  public GetField readFields ()\n+  public GetField readFields()\n     throws IOException, ClassNotFoundException, NotActiveException\n   {\n     if (this.currentObject == null || this.currentObjectStreamClass == null)\n-      throw new NotActiveException (\"readFields called by non-active class and/or object\");\n+      throw new NotActiveException(\"readFields called by non-active class and/or object\");\n \n     if (prereadFields != null)\n       return prereadFields;\n \n     if (fieldsAlreadyRead)\n-      throw new NotActiveException (\"readFields called but fields already read from\"\n-\t\t\t\t    + \" stream (by defaultReadObject or readFields)\");\n+      throw new NotActiveException(\"readFields called but fields already read from\"\n+\t\t\t\t   + \" stream (by defaultReadObject or readFields)\");\n \n     final ObjectStreamClass clazz = this.currentObjectStreamClass;\n     final byte[] prim_field_data = new byte[clazz.primFieldSize];\n@@ -1068,20 +1075,20 @@ public GetField readFields ()\n     // Apparently Block data is not used with GetField as per\n     // empirical evidence against JDK 1.2.  Also see Mauve test\n     // java.io.ObjectInputOutput.Test.GetPutField.\n-    boolean oldmode = setBlockDataMode (false);\n-    readFully (prim_field_data);\n+    boolean oldmode = setBlockDataMode(false);\n+    readFully(prim_field_data);\n     for (int i = 0; i < objs.length; ++ i)\n-      objs[i] = readObject ();\n-    setBlockDataMode (oldmode);\n+      objs[i] = readObject();\n+    setBlockDataMode(oldmode);\n \n     prereadFields = new GetField()\n       {\n-\tpublic ObjectStreamClass getObjectStreamClass ()\n+\tpublic ObjectStreamClass getObjectStreamClass()\n \t{\n \t  return clazz;\n \t}\n \n-\tpublic boolean defaulted (String name)\n+\tpublic boolean defaulted(String name)\n \t  throws IOException, IllegalArgumentException\n \t{\n \t  ObjectStreamField f = clazz.getField(name);\n@@ -1107,85 +1114,85 @@ public boolean defaulted (String name)\n \t    }\n \t  catch (NoSuchFieldException e)\n \t    {\n-\t      throw new IllegalArgumentException (e.getMessage());\n+\t      throw new IllegalArgumentException(e.getMessage());\n \t    }\n \t}\n \n-\tpublic boolean get (String name, boolean defvalue)\n+\tpublic boolean get(String name, boolean defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Boolean.TYPE);\n+\t  ObjectStreamField field = getField(name, Boolean.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  return prim_field_data[field.getOffset ()] == 0 ? false : true;\n+\t  return prim_field_data[field.getOffset()] == 0 ? false : true;\n \t}\n \n-\tpublic char get (String name, char defvalue)\n+\tpublic char get(String name, char defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Character.TYPE);\n+\t  ObjectStreamField field = getField(name, Character.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  int off = field.getOffset ();\n+\t  int off = field.getOffset();\n \n \t  return (char)(((prim_field_data[off++] & 0xFF) << 8)\n \t\t\t| (prim_field_data[off] & 0xFF));\n \t}\n \n-\tpublic byte get (String name, byte defvalue)\n+\tpublic byte get(String name, byte defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Byte.TYPE);\n+\t  ObjectStreamField field = getField(name, Byte.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  return prim_field_data[field.getOffset ()];\n+\t  return prim_field_data[field.getOffset()];\n \t}\n \n-\tpublic short get (String name, short defvalue)\n+\tpublic short get(String name, short defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Short.TYPE);\n+\t  ObjectStreamField field = getField(name, Short.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  int off = field.getOffset ();\n+\t  int off = field.getOffset();\n \n \t  return (short)(((prim_field_data[off++] & 0xFF) << 8)\n \t\t\t | (prim_field_data[off] & 0xFF));\n \t}\n \n-\tpublic int get (String name, int defvalue)\n+\tpublic int get(String name, int defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Integer.TYPE);\n+\t  ObjectStreamField field = getField(name, Integer.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  int off = field.getOffset ();\n+\t  int off = field.getOffset();\n \n \t  return ((prim_field_data[off++] & 0xFF) << 24)\n \t    | ((prim_field_data[off++] & 0xFF) << 16)\n \t    | ((prim_field_data[off++] & 0xFF) << 8)\n \t    | (prim_field_data[off] & 0xFF);\n \t}\n \n-\tpublic long get (String name, long defvalue)\n+\tpublic long get(String name, long defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Long.TYPE);\n+\t  ObjectStreamField field = getField(name, Long.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  int off = field.getOffset ();\n+\t  int off = field.getOffset();\n \n \t  return (long)(((prim_field_data[off++] & 0xFF) << 56)\n \t\t\t| ((prim_field_data[off++] & 0xFF) << 48)\n@@ -1197,31 +1204,31 @@ public long get (String name, long defvalue)\n \t\t\t| (prim_field_data[off] & 0xFF));\n \t}\n \n-\tpublic float get (String name, float defvalue)\n+\tpublic float get(String name, float defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Float.TYPE);\n+\t  ObjectStreamField field = getField(name, Float.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  int off = field.getOffset ();\n+\t  int off = field.getOffset();\n \n-\t  return Float.intBitsToFloat (((prim_field_data[off++] & 0xFF) << 24)\n-\t\t\t\t       | ((prim_field_data[off++] & 0xFF) << 16)\n-\t\t\t\t       | ((prim_field_data[off++] & 0xFF) << 8)\n-\t\t\t\t       | (prim_field_data[off] & 0xFF));\n+\t  return Float.intBitsToFloat(((prim_field_data[off++] & 0xFF) << 24)\n+\t\t\t\t      | ((prim_field_data[off++] & 0xFF) << 16)\n+\t\t\t\t      | ((prim_field_data[off++] & 0xFF) << 8)\n+\t\t\t\t      | (prim_field_data[off] & 0xFF));\n \t}\n \n-\tpublic double get (String name, double defvalue)\n+\tpublic double get(String name, double defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = getField (name, Double.TYPE);\n+\t  ObjectStreamField field = getField(name, Double.TYPE);\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  int off = field.getOffset ();\n+\t  int off = field.getOffset();\n \n \t  return Double.longBitsToDouble\n \t    ( (long) (((prim_field_data[off++] & 0xFF) << 56)\n@@ -1234,22 +1241,22 @@ public double get (String name, double defvalue)\n \t\t      | (prim_field_data[off] & 0xFF)));\n \t}\n \n-\tpublic Object get (String name, Object defvalue)\n+\tpublic Object get(String name, Object defvalue)\n \t  throws IOException, IllegalArgumentException\n \t{\n \t  ObjectStreamField field =\n-\t    getField (name, defvalue == null ? null : defvalue.getClass ());\n+\t    getField(name, defvalue == null ? null : defvalue.getClass ());\n \n \t  if (field == null)\n \t    return defvalue;\n \n-\t  return objs[field.getOffset ()];\n+\t  return objs[field.getOffset()];\n \t}\n \n-\tprivate ObjectStreamField getField (String name, Class type)\n+\tprivate ObjectStreamField getField(String name, Class type)\n \t  throws IllegalArgumentException\n \t{\n-\t  ObjectStreamField field = clazz.getField (name);\n+\t  ObjectStreamField field = clazz.getField(name);\n \t  boolean illegal = false;\n \n \t  try\n@@ -1300,7 +1307,7 @@ private ObjectStreamField getField (String name, Class type)\n \t       */\n \t      try\n \t\t{\n-\t\t  Field f = clazz.forClass().getDeclaredField (name);\n+\t\t  Field f = clazz.forClass().getDeclaredField(name);\n \t\t  if (Modifier.isTransient(f.getModifiers()))\n \t\t    throw new IllegalArgumentException\n \t\t      (\"no such field (non transient) \" + name);\n@@ -1333,12 +1340,12 @@ private ObjectStreamField getField (String name, Class type)\n    *\n    * @see #readObjectOverride()\n    */\n-  protected ObjectInputStream ()\n+  protected ObjectInputStream()\n     throws IOException, SecurityException\n   {\n-    SecurityManager sec_man = System.getSecurityManager ();\n+    SecurityManager sec_man = System.getSecurityManager();\n     if (sec_man != null)\n-      sec_man.checkPermission (SUBCLASS_IMPLEMENTATION_PERMISSION);\n+      sec_man.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n     this.useSubclassMethod = true;\n   }\n \n@@ -1351,10 +1358,10 @@ protected ObjectInputStream ()\n    *\n    * @see #ObjectInputStream()\n    */\n-  protected Object readObjectOverride ()\n+  protected Object readObjectOverride()\n     throws ClassNotFoundException, IOException, OptionalDataException\n   {\n-    throw new IOException (\"Subclass of ObjectInputStream must implement readObjectOverride\");\n+    throw new IOException(\"Subclass of ObjectInputStream must implement readObjectOverride\");\n   }\n \n   /**\n@@ -1363,14 +1370,14 @@ protected Object readObjectOverride ()\n    * @param obj The object for which we want a new handle.\n    * @return A valid handle for the specified object.\n    */\n-  private int assignNewHandle (Object obj)\n+  private int assignNewHandle(Object obj)\n   {\n-    this.objectLookupTable.put (new Integer (this.nextOID),\n-\t\t\t\tnew ObjectIdentityWrapper (obj));\n+    this.objectLookupTable.put(new Integer(this.nextOID),\n+\t\t\t       new ObjectIdentityWrapper(obj));\n     return this.nextOID++;\n   }\n \n-  private Object processResolution (Object obj, int handle)\n+  private Object processResolution(Object obj, int handle)\n     throws IOException\n   {\n     if (obj instanceof Serializable)\n@@ -1380,7 +1387,7 @@ private Object processResolution (Object obj, int handle)\n \t  {\n \t    Class classArgs[] = {};\n \t    m = getMethod(obj.getClass(), \"readResolve\", classArgs);\n-\t    obj = m.invoke (obj, new Object[] {});\t\n+\t    obj = m.invoke(obj, new Object[] {});\t\n \t  }\n \tcatch (NoSuchMethodException ignore)\n \t  {\n@@ -1394,42 +1401,42 @@ private Object processResolution (Object obj, int handle)\n       }\n \n     if (this.resolveEnabled)\n-      obj = resolveObject (obj);\n+      obj = resolveObject(obj);\n \n-    this.objectLookupTable.put (new Integer (handle),\n-\t\t\t\tnew ObjectIdentityWrapper (obj));\n+    this.objectLookupTable.put(new Integer(handle),\n+\t\t\t       new ObjectIdentityWrapper(obj));\n \n     return obj;\n   }\n \n-  private void clearHandles ()\n+  private void clearHandles()\n   {\n-    this.objectLookupTable.clear ();\n+    this.objectLookupTable.clear();\n     this.nextOID = baseWireHandle;\n   }\n \n-  private void readNextBlock () throws IOException\n+  private void readNextBlock() throws IOException\n   {\n-    readNextBlock (this.realInputStream.readByte ());\n+    readNextBlock(this.realInputStream.readByte());\n   }\n \n-  private void readNextBlock (byte marker) throws IOException\n+  private void readNextBlock(byte marker) throws IOException\n   {\n     if (marker == TC_BLOCKDATA)\n       {\n-\tdumpElement (\"BLOCK DATA SIZE=\");\n-\tthis.blockDataBytes = this.realInputStream.readUnsignedByte ();\n+\tdumpElement(\"BLOCK DATA SIZE=\");\n+\tthis.blockDataBytes = this.realInputStream.readUnsignedByte();\n \tdumpElementln (Integer.toString(this.blockDataBytes));\n       }\n     else if (marker == TC_BLOCKDATALONG)\n       {\n-\tdumpElement (\"BLOCK DATA LONG SIZE=\");\n-\tthis.blockDataBytes = this.realInputStream.readInt ();\n+\tdumpElement(\"BLOCK DATA LONG SIZE=\");\n+\tthis.blockDataBytes = this.realInputStream.readInt();\n \tdumpElementln (Integer.toString(this.blockDataBytes));\n       }\n     else\n       {\n-\tthrow new EOFException (\"Attempt to read primitive data, but no data block is active.\");\n+\tthrow new EOFException(\"Attempt to read primitive data, but no data block is active.\");\n       }\n \n     if (this.blockData.length < this.blockDataBytes)\n@@ -1442,70 +1449,70 @@ else if (marker == TC_BLOCKDATALONG)\n   private void readArrayElements (Object array, Class clazz)\n     throws ClassNotFoundException, IOException\n   {\n-    if (clazz.isPrimitive ())\n+    if (clazz.isPrimitive())\n       {\n \tif (clazz == Boolean.TYPE)\n \t  {\n \t    boolean[] cast_array = (boolean[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readBoolean ();\n+\t      cast_array[i] = this.realInputStream.readBoolean();\n \t    return;\n \t  }\n \tif (clazz == Byte.TYPE)\n \t  {\n \t    byte[] cast_array = (byte[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readByte ();\n+\t      cast_array[i] = this.realInputStream.readByte();\n \t    return;\n \t  }\n \tif (clazz == Character.TYPE)\n \t  {\n \t    char[] cast_array = (char[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readChar ();\n+\t      cast_array[i] = this.realInputStream.readChar();\n \t    return;\n \t  }\n \tif (clazz == Double.TYPE)\n \t  {\n \t    double[] cast_array = (double[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readDouble ();\n+\t      cast_array[i] = this.realInputStream.readDouble();\n \t    return;\n \t  }\n \tif (clazz == Float.TYPE)\n \t  {\n \t    float[] cast_array = (float[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readFloat ();\n+\t      cast_array[i] = this.realInputStream.readFloat();\n \t    return;\n \t  }\n \tif (clazz == Integer.TYPE)\n \t  {\n \t    int[] cast_array = (int[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readInt ();\n+\t      cast_array[i] = this.realInputStream.readInt();\n \t    return;\n \t  }\n \tif (clazz == Long.TYPE)\n \t  {\n \t    long[] cast_array = (long[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readLong ();\n+\t      cast_array[i] = this.realInputStream.readLong();\n \t    return;\n \t  }\n \tif (clazz == Short.TYPE)\n \t  {\n \t    short[] cast_array = (short[])array;\n \t    for (int i=0; i < cast_array.length; i++)\n-\t      cast_array[i] = this.realInputStream.readShort ();\n+\t      cast_array[i] = this.realInputStream.readShort();\n \t    return;\n \t  }\n       }\n     else\n       {\n \tObject[] cast_array = (Object[])array;\n \tfor (int i=0; i < cast_array.length; i++)\n- \t  cast_array[i] = readObject ();\n+ \t  cast_array[i] = readObject();\n       }\n   }\n \n@@ -1535,16 +1542,16 @@ private void readFields (Object obj, ObjectStreamClass stream_osc)\n \telse\n \t  {\n \t    stream_field = stream_fields[stream_idx];\n-\t    type = stream_field.getType ();\n+\t    type = stream_field.getType();\n \t  }\n \n \tif (real_idx == real_fields.length)\n \t  set_value = false;\n \telse\n \t  {\n \t    real_field = real_fields[real_idx];\n-\t    type = real_field.getType ();\n-\t    field_name = real_field.getName ();\n+\t    type = real_field.getType();\n+\t    field_name = real_field.getName();\n \t  }\n \n \tif (set_value && !default_initialize)\n@@ -1583,82 +1590,82 @@ else if (comp_val > 0)\n \t    if (type == Boolean.TYPE)\n \t      {\n \t\tboolean value =\n-\t\t  default_initialize ? false : this.realInputStream.readBoolean ();\n+\t\t  default_initialize ? false : this.realInputStream.readBoolean();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setBooleanField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setBooleanField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Byte.TYPE)\n \t      {\n \t\tbyte value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readByte ();\n+\t\t  default_initialize ? 0 : this.realInputStream.readByte();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setByteField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setByteField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Character.TYPE)\n \t      {\n \t\tchar value =\n-\t\t  default_initialize ? (char)0 : this.realInputStream.readChar ();\n+\t\t  default_initialize ? (char)0 : this.realInputStream.readChar();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setCharField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setCharField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Double.TYPE)\n \t      {\n \t\tdouble value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readDouble ();\n+\t\t  default_initialize ? 0 : this.realInputStream.readDouble();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setDoubleField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setDoubleField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Float.TYPE)\n \t      {\n \t\tfloat value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readFloat ();\n+\t\t  default_initialize ? 0 : this.realInputStream.readFloat();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setFloatField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setFloatField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Integer.TYPE)\n \t      {\n \t\tint value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readInt ();\n+\t\t  default_initialize ? 0 : this.realInputStream.readInt();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setIntField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setIntField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Long.TYPE)\n \t      {\n \t\tlong value =\n-\t\t  default_initialize ? 0 : this.realInputStream.readLong ();\n+\t\t  default_initialize ? 0 : this.realInputStream.readLong();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setLongField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setLongField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else if (type == Short.TYPE)\n \t      {\n \t\tshort value =\n-\t\t  default_initialize ? (short)0 : this.realInputStream.readShort ();\n+\t\t  default_initialize ? (short)0 : this.realInputStream.readShort();\n \t\tif (!default_initialize && set_value)\n-\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\t  dumpElementln(\"  \" + field_name + \": \" + value);\n \t\tif (set_value)\n-\t\t  setShortField (obj, stream_osc.forClass (), field_name, value);\n+\t\t  setShortField(obj, stream_osc.forClass(), field_name, value);\n \t      }\n \t    else\n \t      {\n \t\tObject value =\n-\t\t  default_initialize ? null : readObject ();\n+\t\t  default_initialize ? null : readObject();\n \t\tif (set_value)\n-\t\t  setObjectField (obj, stream_osc.forClass (), field_name,\n-\t\t\t\t  real_field.getTypeString (), value);\n+\t\t  setObjectField(obj, stream_osc.forClass(), field_name,\n+\t\t\t\t  real_field.getTypeString(), value);\n \t      }\n \t  }\n \tcatch (NoSuchFieldError e)\n@@ -1699,20 +1706,20 @@ private Object newObject (Class real_class, Class constructor_class)\n \n   // runs all registered ObjectInputValidations in prioritized order\n   // on OBJ\n-  private void invokeValidators () throws InvalidObjectException\n+  private void invokeValidators() throws InvalidObjectException\n   {\n-    Object[] validators = new Object[this.validators.size ()];\n+    Object[] validators = new Object[this.validators.size()];\n     this.validators.copyInto (validators);\n     Arrays.sort (validators);\n \n     try\n       {\n \tfor (int i=0; i < validators.length; i++)\n-\t  ((ObjectInputValidation)validators[i]).validateObject ();\n+\t  ((ObjectInputValidation)validators[i]).validateObject();\n       }\n     finally\n       {\n-\tthis.validators.removeAllElements ();\n+\tthis.validators.removeAllElements();\n       }\n   }\n \n@@ -1789,7 +1796,7 @@ private void callReadMethod (Object obj, ObjectStreamClass osc) throws IOExcepti\n \tClass classArgs[] = {ObjectInputStream.class};\n \tMethod m = getMethod (klass, \"readObject\", classArgs);\n \tObject args[] = {this};\n-\tm.invoke (obj, args);\n+\tm.invoke(obj, args);\n       }\n     catch (NoSuchMethodException nsme)\n       {\n@@ -1804,12 +1811,12 @@ private void callReadMethod (Object obj, ObjectStreamClass osc) throws IOExcepti\n \tif (exception instanceof IOException)\n \t  throw (IOException) exception;\n \n-\tthrow new IOException (\"Exception thrown from readObject() on \" +\n+\tthrow new IOException(\"Exception thrown from readObject() on \" +\n \t\t\t       klass + \": \" + exception.getClass().getName());\n       }\n     catch (Exception x)\n       {\n-\tthrow new IOException (\"Failure invoking readObject() on \" +\n+\tthrow new IOException(\"Failure invoking readObject() on \" +\n \t\t\t       klass + \": \" + x.getClass().getName());\n       }\n \n@@ -1833,13 +1840,13 @@ private native Object allocateObject (Class clazz)\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setBooleanField (Object obj, Class klass, String field_name,\n+  private void setBooleanField(Object obj, Class klass, String field_name,\n \t\t\t\tboolean val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setBoolean (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setBoolean(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -1861,13 +1868,13 @@ private void setBooleanField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setByteField (Object obj, Class klass, String field_name,\n+  private void setByteField(Object obj, Class klass, String field_name,\n \t\t\t     byte val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setByte (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setByte(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -1889,13 +1896,13 @@ private void setByteField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setCharField (Object obj, Class klass, String field_name,\n+  private void setCharField(Object obj, Class klass, String field_name,\n \t\t\t     char val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setChar (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setChar(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -1917,13 +1924,13 @@ private void setCharField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setDoubleField (Object obj, Class klass, String field_name,\n+  private void setDoubleField(Object obj, Class klass, String field_name,\n \t\t\t       double val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setDouble (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setDouble(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -1945,13 +1952,13 @@ private void setDoubleField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setFloatField (Object obj, Class klass, String field_name,\n+  private void setFloatField(Object obj, Class klass, String field_name,\n \t\t\t      float val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setFloat (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setFloat(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -1973,13 +1980,13 @@ private void setFloatField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setIntField (Object obj, Class klass, String field_name,\n+  private void setIntField(Object obj, Class klass, String field_name,\n \t\t\t    int val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setInt (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setInt(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -2001,13 +2008,13 @@ private void setIntField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setLongField (Object obj, Class klass, String field_name,\n+  private void setLongField(Object obj, Class klass, String field_name,\n \t\t\t     long val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setLong (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setLong(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -2029,13 +2036,13 @@ private void setLongField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setShortField (Object obj, Class klass, String field_name,\n+  private void setShortField(Object obj, Class klass, String field_name,\n \t\t\t      short val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tf.setShort (obj, val);\n+\tField f = getField(klass, field_name);\n+\tf.setShort(obj, val);\n       }\n     catch (IllegalArgumentException _)\n       {\n@@ -2057,25 +2064,26 @@ private void setShortField (Object obj, Class klass, String field_name,\n    * @throws InvalidClassException if the specified field has not the required type.\n    * @throws IOException if there is no field of that name in the specified class.\n    */\n-  private void setObjectField (Object obj, Class klass, String field_name,\n+  private void setObjectField(Object obj, Class klass, String field_name,\n \t\t\t       String type_code, Object val) throws IOException, InvalidClassException\n   {\n     try\n       {\n- \tField f = getField (klass, field_name);\n+ \tField f = getField(klass, field_name);\n \tObjectStreamField of = new ObjectStreamField(field_name, f.getType());\n \t\n \tif (of.getTypeString() == null ||\n \t    !of.getTypeString().equals(type_code))\n           throw new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n- \tf.set (obj, val);\n+ \tf.set(obj, val);\n       }\n     catch (InvalidClassException e)\n       {\n \tthrow e;\n       }\n     catch (Exception _)\n-      {}\n+      {\n+      }\n   }\n \n   private static final int BUFFER_SIZE = 1024;"}, {"sha": "8f991f0baa103172556a29ed8fd430d54807f646", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 342, "deletions": 338, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=34998d6bb655f3270bc54656aa9519360100c2d8", "patch": "@@ -132,18 +132,18 @@ public class ObjectOutputStream extends OutputStream\n    */\n   public ObjectOutputStream (OutputStream out) throws IOException\n   {\n-    realOutput = new DataOutputStream (out);\n+    realOutput = new DataOutputStream(out);\n     blockData = new byte[ BUFFER_SIZE ];\n     blockDataCount = 0;\n-    blockDataOutput = new DataOutputStream (this);\n-    setBlockDataMode (true);\n+    blockDataOutput = new DataOutputStream(this);\n+    setBlockDataMode(true);\n     replacementEnabled = false;\n     isSerializing = false;\n     nextOID = baseWireHandle;\n-    OIDLookupTable = new Hashtable ();\n+    OIDLookupTable = new Hashtable();\n     protocolVersion = defaultProtocolVersion;\n     useSubclassMethod = false;\n-    writeStreamHeader ();\n+    writeStreamHeader();\n   }\n \n   /**\n@@ -165,16 +165,16 @@ public ObjectOutputStream (OutputStream out) throws IOException\n    * @exception IOException Exception from underlying\n    * <code>OutputStream</code>.\n    */\n-  public final void writeObject (Object obj) throws IOException\n+  public final void writeObject(Object obj) throws IOException\n   {\n     if (useSubclassMethod)\n       {\n-\twriteObjectOverride (obj);\n+\twriteObjectOverride(obj);\n \treturn;\n       }\n \n     boolean was_serializing = isSerializing;\n-    boolean old_mode = setBlockDataMode (false);\n+    boolean old_mode = setBlockDataMode(false);\n     try\n       {\n \tisSerializing = true;\n@@ -185,57 +185,57 @@ public final void writeObject (Object obj) throws IOException\n \t  {\n \t    if (obj == null)\n \t      {\n-\t\trealOutput.writeByte (TC_NULL);\n+\t\trealOutput.writeByte(TC_NULL);\n \t\tbreak;\n \t      }\n \n-\t    Integer handle = findHandle (obj);\n+\t    Integer handle = findHandle(obj);\n \t    if (handle != null)\n \t      {\n-\t\trealOutput.writeByte (TC_REFERENCE);\n-\t\trealOutput.writeInt (handle.intValue ());\n+\t\trealOutput.writeByte(TC_REFERENCE);\n+\t\trealOutput.writeInt(handle.intValue());\n \t\tbreak;\n \t      }\n \n \t    if (obj instanceof Class)\n \t      {\n \t\tClass cl = (Class)obj;\n-\t\tObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (cl);\n-\t\tassignNewHandle (obj);\n-\t\trealOutput.writeByte (TC_CLASS);\n+\t\tObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(cl);\n+\t\tassignNewHandle(obj);\n+\t\trealOutput.writeByte(TC_CLASS);\n \t\tif (!osc.isProxyClass)\n \t\t  {\n \t\t    writeObject (osc);\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    realOutput.writeByte (TC_PROXYCLASSDESC);\n+\t\t    realOutput.writeByte(TC_PROXYCLASSDESC);\n \t\t    Class[] intfs = cl.getInterfaces();\n \t\t    realOutput.writeInt(intfs.length);\n \t\t    for (int i = 0; i < intfs.length; i++)\n \t\t      realOutput.writeUTF(intfs[i].getName());\n \t\t    \n-\t\t    boolean oldmode = setBlockDataMode (true);\n+\t\t    boolean oldmode = setBlockDataMode(true);\n \t\t    annotateProxyClass(cl);\n-\t\t    setBlockDataMode (oldmode);\n+\t\t    setBlockDataMode(oldmode);\n \t\t    realOutput.writeByte(TC_ENDBLOCKDATA);\n \t\t    \n-\t\t    writeObject (osc.getSuper());\n+\t\t    writeObject(osc.getSuper());\n \t\t  }\n \t\tbreak;\n \t      }\n \n \t    if (obj instanceof ObjectStreamClass)\n \t      {\n-\t\twriteClassDescriptor ((ObjectStreamClass) obj);\n+\t\twriteClassDescriptor((ObjectStreamClass) obj);\n \t\tbreak;\n \t      }\n \n \t    if ((replacementEnabled || obj instanceof Serializable)\n \t\t&& ! replaceDone)\n \t      {\n \t\treplacedObject = obj;\n-\n+\t\t\n \t\tif (obj instanceof Serializable)\n \t\t  {\n \t\t    Method m = null;\n@@ -247,7 +247,7 @@ public final void writeObject (Object obj) throws IOException\n \t\t\t// m can't be null by definition since an\n \t\t\t// exception would have been thrown so a check\n \t\t\t// for null is not needed.\n-\t\t\tobj = m.invoke (obj, new Object[] {});\n+\t\t\tobj = m.invoke(obj, new Object[] {});\n \t\t      }\n \t\t    catch (NoSuchMethodException ignore)\n \t\t      {\n@@ -259,55 +259,55 @@ public final void writeObject (Object obj) throws IOException\n \t\t      {\n \t\t      }\n \t\t  }\n-\n+\t\t\n \t\tif (replacementEnabled)\n-\t\t  obj = replaceObject (obj);\n-\n+\t\t  obj = replaceObject(obj);\n+\t\t\n \t\treplaceDone = true;\n \t\tcontinue;\n \t      }\n \n \t    if (obj instanceof String)\n \t      {\n-\t\trealOutput.writeByte (TC_STRING);\n-\t\tassignNewHandle (obj);\n-\t\trealOutput.writeUTF ((String)obj);\n+\t\trealOutput.writeByte(TC_STRING);\n+\t\tassignNewHandle(obj);\n+\t\trealOutput.writeUTF((String)obj);\n \t\tbreak;\n \t      }\n \n-\t    Class clazz = obj.getClass ();\n-\t    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (clazz);\n+\t    Class clazz = obj.getClass();\n+\t    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(clazz);\n \t    if (osc == null)\n-\t      throw new NotSerializableException (clazz.getName ());\n-\n+\t      throw new NotSerializableException(clazz.getName());\n+\t    \n \t    if (clazz.isArray ())\n \t      {\n-\t\trealOutput.writeByte (TC_ARRAY);\n-\t\twriteObject (osc);\n-\t\tassignNewHandle (obj);\n-\t\twriteArraySizeAndElements (obj, clazz.getComponentType ());\n+\t\trealOutput.writeByte(TC_ARRAY);\n+\t\twriteObject(osc);\n+\t\tassignNewHandle(obj);\n+\t\twriteArraySizeAndElements(obj, clazz.getComponentType());\n \t\tbreak;\n \t      }\n-\n-\t    realOutput.writeByte (TC_OBJECT);\n-\t    writeObject (osc);\n+\t    \n+\t    realOutput.writeByte(TC_OBJECT);\n+\t    writeObject(osc);\n \n \t    if (replaceDone)\n-\t      assignNewHandle (replacedObject);\n+\t      assignNewHandle(replacedObject);\n \t    else\n-\t      assignNewHandle (obj);\n+\t      assignNewHandle(obj);\n \n \t    if (obj instanceof Externalizable)\n \t      {\n \t\tif (protocolVersion == PROTOCOL_VERSION_2)\n-\t\t  setBlockDataMode (true);\n-\n-\t\t((Externalizable)obj).writeExternal (this);\n-\n+\t\t  setBlockDataMode(true);\n+\t\t\n+\t\t((Externalizable)obj).writeExternal(this);\n+\t\t\n \t\tif (protocolVersion == PROTOCOL_VERSION_2)\n \t\t  {\n-\t\t    setBlockDataMode (false);\n-\t\t    realOutput.writeByte (TC_ENDBLOCKDATA);\n+\t\t    setBlockDataMode(false);\n+\t\t    realOutput.writeByte(TC_ENDBLOCKDATA);\n \t\t  }\n \n \t\tbreak;\n@@ -317,22 +317,22 @@ public final void writeObject (Object obj) throws IOException\n \t      {\n \t\tcurrentObject = obj;\n \t\tObjectStreamClass[] hierarchy =\n-\t\t  ObjectStreamClass.getObjectStreamClasses (clazz);\n-\n-\t\tfor (int i=0; i < hierarchy.length; i++)\n+\t\t  ObjectStreamClass.getObjectStreamClasses(clazz);\n+\t\t\n+\t\tfor (int i = 0; i < hierarchy.length; i++)\n \t\t  {\n \t\t    currentObjectStreamClass = hierarchy[i];\n-\n+\t\t    \n \t\t    fieldsAlreadyWritten = false;\n-\t\t    if (currentObjectStreamClass.hasWriteMethod ())\n+\t\t    if (currentObjectStreamClass.hasWriteMethod())\n \t\t      {\n-\t\t\tsetBlockDataMode (true);\n-\t\t\tcallWriteMethod (obj, currentObjectStreamClass);\n-\t\t\tsetBlockDataMode (false);\n-\t\t\trealOutput.writeByte (TC_ENDBLOCKDATA);\n+\t\t\tsetBlockDataMode(true);\n+\t\t\tcallWriteMethod(obj, currentObjectStreamClass);\n+\t\t\tsetBlockDataMode(false);\n+\t\t\trealOutput.writeByte(TC_ENDBLOCKDATA);\n \t\t      }\n \t\t    else\n-\t\t      writeFields (obj, currentObjectStreamClass);\n+\t\t      writeFields(obj, currentObjectStreamClass);\n \t\t  }\n \n \t\tcurrentObject = null;\n@@ -341,7 +341,7 @@ public final void writeObject (Object obj) throws IOException\n \t\tbreak;\n \t      }\n \n-\t    throw new NotSerializableException (clazz.getName ());\n+\t    throw new NotSerializableException(clazz.getName ());\n \t  } // end pseudo-loop\n       }\n     catch (ObjectStreamException ose)\n@@ -351,243 +351,247 @@ public final void writeObject (Object obj) throws IOException\n       }\n     catch (IOException e)\n       {\n-\trealOutput.writeByte (TC_EXCEPTION);\n-\treset (true);\n+\trealOutput.writeByte(TC_EXCEPTION);\n+\treset(true);\n \n-\tsetBlockDataMode (false);\n+\tsetBlockDataMode(false);\n \ttry\n \t  {\n-\t    writeObject (e);\n+\t    writeObject(e);\n \t  }\n \tcatch (IOException ioe)\n \t  {\n-\t    throw new StreamCorruptedException (\"Exception \" + ioe + \" thrown while exception (\"+e+\") was being written to stream.\");\n+\t    throw new StreamCorruptedException\n+\t      (\"Exception \" + ioe + \" thrown while exception was being written to stream.\");\n \t  }\n \n \treset (true);\n+\t\n       }\n     finally\n       {\n \tisSerializing = was_serializing;\n-\tsetBlockDataMode (old_mode);\n+\tsetBlockDataMode(old_mode);\n       }\n   }\n \n-  protected void writeClassDescriptor (ObjectStreamClass osc) throws IOException\n+  protected void writeClassDescriptor(ObjectStreamClass osc) throws IOException\n   {\n-    realOutput.writeByte (TC_CLASSDESC);\n-    realOutput.writeUTF (osc.getName ());\n-    realOutput.writeLong (osc.getSerialVersionUID ());\n-    assignNewHandle (osc);\n+    realOutput.writeByte(TC_CLASSDESC);\n+    realOutput.writeUTF(osc.getName());\n+    realOutput.writeLong(osc.getSerialVersionUID());\n+    assignNewHandle(osc);\n \n-    int flags = osc.getFlags ();\n+    int flags = osc.getFlags();\n \n     if (protocolVersion == PROTOCOL_VERSION_2\n-\t&& osc.isExternalizable ())\n+\t&& osc.isExternalizable())\n       flags |= SC_BLOCK_DATA;\n \n-    realOutput.writeByte (flags);\n+    realOutput.writeByte(flags);\n \n     ObjectStreamField[] fields = osc.fields;\n-    realOutput.writeShort (fields.length);\n+    realOutput.writeShort(fields.length);\n \n     ObjectStreamField field;\n-    for (int i=0; i < fields.length; i++)\n+    for (int i = 0; i < fields.length; i++)\n       {\n \tfield = fields[i];\n-\trealOutput.writeByte (field.getTypeCode ());\n-\trealOutput.writeUTF (field.getName ());\n+\trealOutput.writeByte(field.getTypeCode ());\n+\trealOutput.writeUTF(field.getName ());\n \n-\tif (! field.isPrimitive ())\n-\t  writeObject (field.getTypeString ());\n+\tif (! field.isPrimitive())\n+\t  writeObject(field.getTypeString());\n       }\n \n-    boolean oldmode = setBlockDataMode (true);\n-    annotateClass (osc.forClass ());\n-    setBlockDataMode (oldmode);\n-    realOutput.writeByte (TC_ENDBLOCKDATA);\n+    boolean oldmode = setBlockDataMode(true);\n+    annotateClass(osc.forClass());\n+    setBlockDataMode(oldmode);\n+    realOutput.writeByte(TC_ENDBLOCKDATA);\n \n-    if (osc.isSerializable()\n-\t|| osc.isExternalizable())\n-      writeObject (osc.getSuper ());\n+    if (osc.isSerializable() || osc.isExternalizable())\n+      writeObject(osc.getSuper());\n     else\n-      writeObject (null);\n+      writeObject(null);\n   }\n   \n   /**\n-     Writes the current objects non-transient, non-static fields from\n-     the current class to the underlying output stream.\n-\n-     This method is intended to be called from within a object's\n-     <code>private void writeObject (ObjectOutputStream)</code>\n-     method.\n-\n-     @exception NotActiveException This method was called from a\n-     context other than from the current object's and current class's\n-     <code>private void writeObject (ObjectOutputStream)</code>\n-     method.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-  */\n-  public void defaultWriteObject ()\n+   * Writes the current objects non-transient, non-static fields from\n+   * the current class to the underlying output stream.\n+   *\n+   * This method is intended to be called from within a object's\n+   * <code>private void writeObject (ObjectOutputStream)</code>\n+   * method.\n+   *\n+   * @exception NotActiveException This method was called from a\n+   * context other than from the current object's and current class's\n+   * <code>private void writeObject (ObjectOutputStream)</code>\n+   * method.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   */\n+  public void defaultWriteObject()\n     throws IOException, NotActiveException\n   {\n-    markFieldsWritten ();\n-    writeFields (currentObject, currentObjectStreamClass);\n+    markFieldsWritten();\n+    writeFields(currentObject, currentObjectStreamClass);\n   }\n \n \n-  private void markFieldsWritten () throws IOException\n+  private void markFieldsWritten() throws IOException\n   {\n     if (currentObject == null || currentObjectStreamClass == null)\n-      throw new NotActiveException (\"defaultWriteObject called by non-active class and/or object\");\n+      throw new NotActiveException\n+\t(\"defaultWriteObject called by non-active class and/or object\");\n \n     if (fieldsAlreadyWritten)\n-      throw new IOException (\"Only one of writeFields and defaultWriteObject may be called, and it may only be called once\");\n+      throw new IOException\n+\t(\"Only one of putFields and defaultWriteObject may be called, and it may only be called once\");\n \n     fieldsAlreadyWritten = true;\n   }\n \n-\n   /**\n-     Resets stream to state equivalent to the state just after it was\n-     constructed.\n-\n-     Causes all objects previously written to the stream to be\n-     forgotten.  A notification of this reset is also written to the\n-     underlying stream.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code> or reset called while serialization is\n-     in progress.\n-  */\n-  public void reset () throws IOException\n+   * Resets stream to state equivalent to the state just after it was\n+   * constructed.\n+   *\n+   * Causes all objects previously written to the stream to be\n+   * forgotten.  A notification of this reset is also written to the\n+   * underlying stream.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code> or reset called while serialization is\n+   * in progress.\n+   */\n+  public void reset() throws IOException\n   {\n-    reset (false);\n+    reset(false);\n   }\n \n \n-  private void reset (boolean internal) throws IOException\n+  private void reset(boolean internal) throws IOException\n   {\n     if (!internal)\n       {\n \tif (isSerializing)\n-\t  throw new IOException (\"Reset called while serialization in progress\");\n+\t  throw new IOException(\"Reset called while serialization in progress\");\n \n-\trealOutput.writeByte (TC_RESET);\n+\trealOutput.writeByte(TC_RESET);\n       }\n-\n-    clearHandles ();\n+    \n+    clearHandles();\n   }\n \n \n   /**\n-     Informs this <code>ObjectOutputStream</code> to write data\n-     according to the specified protocol.  There are currently two\n-     different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n-     and <code>PROTOCOL_VERSION_2</code>.  This implementation writes\n-     data using <code>PROTOCOL_VERSION_2</code> by default, as is done\n-     by the JDK 1.2.\n-\n-     A non-portable method, <code>setDefaultProtocolVersion (int\n-     version)</code> is provided to change the default protocol\n-     version.\n-\n-     For an explination of the differences beween the two protocols\n-     see XXX: the Java ObjectSerialization Specification.\n-\n-     @exception IOException if <code>version</code> is not a valid\n-     protocol\n-\n-     @see #setDefaultProtocolVersion(int)\n-  */\n-  public void useProtocolVersion (int version) throws IOException\n+   * Informs this <code>ObjectOutputStream</code> to write data\n+   * according to the specified protocol.  There are currently two\n+   * different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n+   * and <code>PROTOCOL_VERSION_2</code>.  This implementation writes\n+   * data using <code>PROTOCOL_VERSION_2</code> by default, as is done\n+   * by the JDK 1.2.\n+   *\n+   * A non-portable method, <code>setDefaultProtocolVersion (int\n+   * version)</code> is provided to change the default protocol\n+   * version.\n+   *\n+   * For an explination of the differences beween the two protocols\n+   * see XXX: the Java ObjectSerialization Specification.\n+   *\n+   * @exception IOException if <code>version</code> is not a valid\n+   * protocol\n+   *\n+   * @see #setDefaultProtocolVersion(int)\n+   */\n+  public void useProtocolVersion(int version) throws IOException\n   {\n     if (version != PROTOCOL_VERSION_1 && version != PROTOCOL_VERSION_2)\n-      throw new IOException (\"Invalid protocol version requested.\");\n-\n+      throw new IOException(\"Invalid protocol version requested.\");\n+    \n     protocolVersion = version;\n   }\n \n \n   /**\n-     <em>GNU $classpath specific</em>\n-\n-     Changes the default stream protocol used by all\n-     <code>ObjectOutputStream</code>s.  There are currently two\n-     different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n-     and <code>PROTOCOL_VERSION_2</code>.  The default default is\n-     <code>PROTOCOL_VERSION_1</code>.\n-\n-     @exception IOException if <code>version</code> is not a valid\n-     protocol\n-\n-     @see #useProtocolVersion(int)\n-  */\n-  public static void setDefaultProtocolVersion (int version)\n+   * <em>GNU $classpath specific</em>\n+   *\n+   * Changes the default stream protocol used by all\n+   * <code>ObjectOutputStream</code>s.  There are currently two\n+   * different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n+   * and <code>PROTOCOL_VERSION_2</code>.  The default default is\n+   * <code>PROTOCOL_VERSION_1</code>.\n+   *\n+   * @exception IOException if <code>version</code> is not a valid\n+   * protocol\n+   *\n+   * @see #useProtocolVersion(int)\n+   */\n+  public static void setDefaultProtocolVersion(int version)\n     throws IOException\n   {\n     if (version != PROTOCOL_VERSION_1 && version != PROTOCOL_VERSION_2)\n-      throw new IOException (\"Invalid protocol version requested.\");\n+      throw new IOException(\"Invalid protocol version requested.\");\n \n     defaultProtocolVersion = version;\n   }\n \n \n   /**\n-     An empty hook that allows subclasses to write extra information\n-     about classes to the stream.  This method is called the first\n-     time each class is seen, and after all of the standard\n-     information about the class has been written.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-\n-     @see ObjectInputStream#resolveClass(java.io.ObjectStreamClass)\n-  */\n-  protected void annotateClass (Class cl) throws IOException\n-  {}\n+   * An empty hook that allows subclasses to write extra information\n+   * about classes to the stream.  This method is called the first\n+   * time each class is seen, and after all of the standard\n+   * information about the class has been written.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   *\n+   * @see ObjectInputStream#resolveClass(java.io.ObjectStreamClass)\n+   */\n+  protected void annotateClass(Class cl) throws IOException\n+  {\n+  }\n \n   protected void annotateProxyClass(Class cl) throws IOException\n-  {}\n+  {\n+  }\n \n   /**\n-     Allows subclasses to replace objects that are written to the\n-     stream with other objects to be written in their place.  This\n-     method is called the first time each object is encountered\n-     (modulo reseting of the stream).\n-\n-     This method must be enabled before it will be called in the\n-     serialization process.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-\n-     @see #enableReplaceObject(boolean)\n-  */\n-  protected Object replaceObject (Object obj) throws IOException\n+   * Allows subclasses to replace objects that are written to the\n+   * stream with other objects to be written in their place.  This\n+   * method is called the first time each object is encountered\n+   * (modulo reseting of the stream).\n+   *\n+   * This method must be enabled before it will be called in the\n+   * serialization process.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   *\n+   * @see #enableReplaceObject(boolean)\n+   */\n+  protected Object replaceObject(Object obj) throws IOException\n   {\n     return obj;\n   }\n \n \n   /**\n-     If <code>enable</code> is <code>true</code> and this object is\n-     trusted, then <code>replaceObject (Object)</code> will be called\n-     in subsequent calls to <code>writeObject (Object)</code>.\n-     Otherwise, <code>replaceObject (Object)</code> will not be called.\n-\n-     @exception SecurityException This class is not trusted.\n-  */\n-  protected boolean enableReplaceObject (boolean enable)\n+   * If <code>enable</code> is <code>true</code> and this object is\n+   * trusted, then <code>replaceObject (Object)</code> will be called\n+   * in subsequent calls to <code>writeObject (Object)</code>.\n+   * Otherwise, <code>replaceObject (Object)</code> will not be called.\n+   *\n+   * @exception SecurityException This class is not trusted.\n+   */\n+  protected boolean enableReplaceObject(boolean enable)\n     throws SecurityException\n   {\n     if (enable)\n       {\n-\tSecurityManager sm = System.getSecurityManager ();\n+\tSecurityManager sm = System.getSecurityManager();\n \tif (sm != null)\n-\t  sm.checkPermission (new SerializablePermission (\"enableSubstitution\"));\n+\t  sm.checkPermission(new SerializablePermission(\"enableSubstitution\"));\n       }\n \n     boolean old_val = replacementEnabled;\n@@ -597,20 +601,18 @@ protected boolean enableReplaceObject (boolean enable)\n \n \n   /**\n-     Writes stream magic and stream version information to the\n-     underlying stream.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-  */\n-  protected void writeStreamHeader () throws IOException\n+   * Writes stream magic and stream version information to the\n+   * underlying stream.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   */\n+  protected void writeStreamHeader() throws IOException\n   {\n-    realOutput.writeShort (STREAM_MAGIC);\n-    realOutput.writeShort (STREAM_VERSION);\n+    realOutput.writeShort(STREAM_MAGIC);\n+    realOutput.writeShort(STREAM_VERSION);\n   }\n \n-\n-\n   /**\n    * Protected constructor that allows subclasses to override\n    * serialization.  This constructor should be called by subclasses\n@@ -622,11 +624,11 @@ protected void writeStreamHeader () throws IOException\n    *\n    * @see #writeObjectOverride(Object)\n    */\n-  protected ObjectOutputStream () throws IOException, SecurityException\n+  protected ObjectOutputStream() throws IOException, SecurityException\n   {\n     SecurityManager sec_man = System.getSecurityManager ();\n     if (sec_man != null)\n-      sec_man.checkPermission (SUBCLASS_IMPLEMENTATION_PERMISSION);\n+      sec_man.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n     useSubclassMethod = true;\n   }\n \n@@ -643,10 +645,11 @@ protected ObjectOutputStream () throws IOException, SecurityException\n    * @exception NotActiveException Subclass has arranged for this\n    * method to be called, but did not implement this method.\n    */\n-  protected void writeObjectOverride (Object obj) throws NotActiveException,\n+  protected void writeObjectOverride(Object obj) throws NotActiveException,\n     IOException\n   {\n-    throw new NotActiveException (\"Subclass of ObjectOutputStream must implement writeObjectOverride\");\n+    throw new NotActiveException\n+      (\"Subclass of ObjectOutputStream must implement writeObjectOverride\");\n   }\n \n \n@@ -658,48 +661,48 @@ public void write (int data) throws IOException\n     if (writeDataAsBlocks)\n       {\n \tif (blockDataCount == BUFFER_SIZE)\n-\t  drain ();\n+\t  drain();\n \n \tblockData[ blockDataCount++ ] = (byte)data;\n       }\n     else\n-      realOutput.write (data);\n+      realOutput.write(data);\n   }\n \n \n   /**\n    * @see DataOutputStream#write(byte[])\n    */\n-  public void write (byte[] b) throws IOException\n+  public void write(byte[] b) throws IOException\n   {\n-    write (b, 0, b.length);\n+    write(b, 0, b.length);\n   }\n \n \n   /**\n    * @see DataOutputStream#write(byte[],int,int)\n    */\n-  public void write (byte[] b, int off, int len) throws IOException\n+  public void write(byte[] b, int off, int len) throws IOException\n   {\n     if (writeDataAsBlocks)\n       {\n \tif (len < 0)\n-\t  throw new IndexOutOfBoundsException ();\n+\t  throw new IndexOutOfBoundsException();\n \n \tif (blockDataCount + len < BUFFER_SIZE)\n \t  {\n-\t    System.arraycopy (b, off, blockData, blockDataCount, len);\n+\t    System.arraycopy(b, off, blockData, blockDataCount, len);\n \t    blockDataCount += len;\n \t  }\n \telse\n \t  {\n-\t    drain ();\n-\t    writeBlockDataHeader (len);\n-\t    realOutput.write (b, off, len);\n+\t    drain();\n+\t    writeBlockDataHeader(len);\n+\t    realOutput.write(b, off, len);\n \t  }\n       }\n     else\n-      realOutput.write (b, off, len);\n+      realOutput.write(b, off, len);\n   }\n \n \n@@ -708,8 +711,8 @@ public void write (byte[] b, int off, int len) throws IOException\n    */\n   public void flush () throws IOException\n   {\n-    drain ();\n-    realOutput.flush ();\n+    drain();\n+    realOutput.flush();\n   }\n \n \n@@ -720,43 +723,43 @@ public void flush () throws IOException\n    * @exception IOException Exception from underlying\n    * <code>OutputStream</code>.\n    */\n-  protected void drain () throws IOException\n+  protected void drain() throws IOException\n   {\n     if (blockDataCount == 0)\n       return;\n \n     if (writeDataAsBlocks)\n-      writeBlockDataHeader (blockDataCount);\n-    realOutput.write (blockData, 0, blockDataCount);\n+      writeBlockDataHeader(blockDataCount);\n+    realOutput.write(blockData, 0, blockDataCount);\n     blockDataCount = 0;\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#close ()\n    */\n-  public void close () throws IOException\n+  public void close() throws IOException\n   {\n-    flush ();\n-    realOutput.close ();\n+    flush();\n+    realOutput.close();\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeBoolean (boolean)\n    */\n-  public void writeBoolean (boolean data) throws IOException\n+  public void writeBoolean(boolean data) throws IOException\n   {\n-    blockDataOutput.writeBoolean (data);\n+    blockDataOutput.writeBoolean(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeByte (int)\n    */\n-  public void writeByte (int data) throws IOException\n+  public void writeByte(int data) throws IOException\n   {\n-    blockDataOutput.writeByte (data);\n+    blockDataOutput.writeByte(data);\n   }\n \n \n@@ -765,79 +768,79 @@ public void writeByte (int data) throws IOException\n    */\n   public void writeShort (int data) throws IOException\n   {\n-    blockDataOutput.writeShort (data);\n+    blockDataOutput.writeShort(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeChar (int)\n    */\n-  public void writeChar (int data) throws IOException\n+  public void writeChar(int data) throws IOException\n   {\n-    blockDataOutput.writeChar (data);\n+    blockDataOutput.writeChar(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeInt (int)\n    */\n-  public void writeInt (int data) throws IOException\n+  public void writeInt(int data) throws IOException\n   {\n-    blockDataOutput.writeInt (data);\n+    blockDataOutput.writeInt(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeLong (long)\n    */\n-  public void writeLong (long data) throws IOException\n+  public void writeLong(long data) throws IOException\n   {\n-    blockDataOutput.writeLong (data);\n+    blockDataOutput.writeLong(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeFloat (float)\n    */\n-  public void writeFloat (float data) throws IOException\n+  public void writeFloat(float data) throws IOException\n   {\n-    blockDataOutput.writeFloat (data);\n+    blockDataOutput.writeFloat(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeDouble (double)\n    */\n-  public void writeDouble (double data) throws IOException\n+  public void writeDouble(double data) throws IOException\n   {\n-    blockDataOutput.writeDouble (data);\n+    blockDataOutput.writeDouble(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeBytes (java.lang.String)\n    */\n-  public void writeBytes (String data) throws IOException\n+  public void writeBytes(String data) throws IOException\n   {\n-    blockDataOutput.writeBytes (data);\n+    blockDataOutput.writeBytes(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeChars (java.lang.String)\n    */\n-  public void writeChars (String data) throws IOException\n+  public void writeChars(String data) throws IOException\n   {\n-    dataOutput.writeChars (data);\n+    dataOutput.writeChars(data);\n   }\n \n \n   /**\n    * @see java.io.DataOutputStream#writeUTF (java.lang.String)\n    */\n-  public void writeUTF (String data) throws IOException\n+  public void writeUTF(String data) throws IOException\n   {\n-    dataOutput.writeUTF (data);\n+    dataOutput.writeUTF(data);\n   }\n \n \n@@ -865,7 +868,7 @@ public void writeUTF (String data) throws IOException\n     public abstract void write (ObjectOutput out) throws IOException;\n   }\n \n-  public PutField putFields () throws IOException\n+  public PutField putFields() throws IOException\n   {\n     if (currentPutField == null)\n       {\n@@ -1008,183 +1011,184 @@ private void checkType (ObjectStreamField field, char type)\n   }\n \n \n-  public void writeFields () throws IOException\n+  public void writeFields() throws IOException\n   {\n     if (currentPutField == null)\n-      throw new NotActiveException (\"writeFields can only be called after putFields has been called\");\n+      throw new NotActiveException(\"writeFields can only be called after putFields has been called\");\n \n     // putFields may be called more than once, but not writeFields.\n     markFieldsWritten();\n \n-    currentPutField.write (this);\n+    currentPutField.write(this);\n     currentPutField = null;\n   }\n \n \n   // write out the block-data buffer, picking the correct header\n   // depending on the size of the buffer\n-  private void writeBlockDataHeader (int size) throws IOException\n+  private void writeBlockDataHeader(int size) throws IOException\n   {\n     if (size < 256)\n       {\n-\trealOutput.writeByte (TC_BLOCKDATA);\n-\trealOutput.write (size);\n+\trealOutput.writeByte(TC_BLOCKDATA);\n+\trealOutput.write(size);\n       }\n     else\n       {\n-\trealOutput.writeByte (TC_BLOCKDATALONG);\n-\trealOutput.writeInt (size);\n+\trealOutput.writeByte(TC_BLOCKDATALONG);\n+\trealOutput.writeInt(size);\n       }\n   }\n \n \n   // lookup the handle for OBJ, return null if OBJ doesn't have a\n   // handle yet\n-  private Integer findHandle (Object obj)\n+  private Integer findHandle(Object obj)\n   {\n-    return (Integer)OIDLookupTable.get (new ObjectIdentityWrapper (obj));\n+    return (Integer)OIDLookupTable.get(new ObjectIdentityWrapper(obj));\n   }\n \n \n   // assigns the next availible handle to OBJ\n-  private int assignNewHandle (Object obj)\n+  private int assignNewHandle(Object obj)\n   {\n-    OIDLookupTable.put (new ObjectIdentityWrapper (obj),\n-\t\t\tnew Integer (nextOID));\n+    OIDLookupTable.put(new ObjectIdentityWrapper(obj),\n+\t\t       new Integer(nextOID));\n     return nextOID++;\n   }\n \n \n   // resets mapping from objects to handles\n-  private void clearHandles ()\n+  private void clearHandles()\n   {\n     nextOID = baseWireHandle;\n-    OIDLookupTable.clear ();\n+    OIDLookupTable.clear();\n   }\n \n \n   // write out array size followed by each element of the array\n-  private void writeArraySizeAndElements (Object array, Class clazz)\n+  private void writeArraySizeAndElements(Object array, Class clazz)\n     throws IOException\n   {\n-    int length = Array.getLength (array);\n+    int length = Array.getLength(array);\n \n-    if (clazz.isPrimitive ())\n+    if (clazz.isPrimitive())\n       {\n \tif (clazz == Boolean.TYPE)\n \t  {\n \t    boolean[] cast_array = (boolean[])array;\n \t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeBoolean (cast_array[i]);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeBoolean(cast_array[i]);\n \t    return;\n \t  }\n \tif (clazz == Byte.TYPE)\n \t  {\n \t    byte[] cast_array = (byte[])array;\n-\t    realOutput.writeInt (length);\n+\t    realOutput.writeInt(length);\n \t    realOutput.write(cast_array, 0, length);\n \t    return;\n \t  }\n \tif (clazz == Character.TYPE)\n \t  {\n \t    char[] cast_array = (char[])array;\n-\t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeChar (cast_array[i]);\n+\t    realOutput.writeInt(length);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeChar(cast_array[i]);\n \t    return;\n \t  }\n \tif (clazz == Double.TYPE)\n \t  {\n \t    double[] cast_array = (double[])array;\n-\t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeDouble (cast_array[i]);\n+\t    realOutput.writeInt(length);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeDouble(cast_array[i]);\n \t    return;\n \t  }\n \tif (clazz == Float.TYPE)\n \t  {\n \t    float[] cast_array = (float[])array;\n-\t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeFloat (cast_array[i]);\n+\t    realOutput.writeInt(length);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeFloat(cast_array[i]);\n \t    return;\n \t  }\n \tif (clazz == Integer.TYPE)\n \t  {\n \t    int[] cast_array = (int[])array;\n-\t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeInt (cast_array[i]);\n+\t    realOutput.writeInt(length);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeInt(cast_array[i]);\n \t    return;\n \t  }\n \tif (clazz == Long.TYPE)\n \t  {\n \t    long[] cast_array = (long[])array;\n \t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeLong (cast_array[i]);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeLong(cast_array[i]);\n \t    return;\n \t  }\n \tif (clazz == Short.TYPE)\n \t  {\n \t    short[] cast_array = (short[])array;\n \t    realOutput.writeInt (length);\n-\t    for (int i=0; i < length; i++)\n-\t      realOutput.writeShort (cast_array[i]);\n+\t    for (int i = 0; i < length; i++)\n+\t      realOutput.writeShort(cast_array[i]);\n \t    return;\n \t  }\n       }\n     else\n       {\n \tObject[] cast_array = (Object[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  writeObject (cast_array[i]);\n+\trealOutput.writeInt(length);\n+\tfor (int i = 0; i < length; i++)\n+\t  writeObject(cast_array[i]);\n       }\n   }\n \n \n   // writes out FIELDS of OBJECT for the specified ObjectStreamClass.\n   // FIELDS are already in canonical order.\n-  private void writeFields (Object obj, ObjectStreamClass osc)\n+  private void writeFields(Object obj, ObjectStreamClass osc)\n     throws IOException\n   {\n     ObjectStreamField[] fields = osc.fields;\n-    boolean oldmode = setBlockDataMode (false);\n+    boolean oldmode = setBlockDataMode(false);\n     String field_name;\n     Class type;\n-    for (int i=0; i < fields.length; i++)\n+\n+    for (int i = 0; i < fields.length; i++)\n       {\n-\tfield_name = fields[i].getName ();\n-\ttype = fields[i].getType ();\n+\tfield_name = fields[i].getName();\n+\ttype = fields[i].getType();\n \n \tif (type == Boolean.TYPE)\n-\t  realOutput.writeBoolean (getBooleanField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeBoolean(getBooleanField(obj, osc.forClass(), field_name));\n \telse if (type == Byte.TYPE)\n-\t  realOutput.writeByte (getByteField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeByte(getByteField(obj, osc.forClass(), field_name));\n \telse if (type == Character.TYPE)\n-\t  realOutput.writeChar (getCharField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeChar(getCharField(obj, osc.forClass(), field_name));\n \telse if (type == Double.TYPE)\n-\t  realOutput.writeDouble (getDoubleField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeDouble(getDoubleField(obj, osc.forClass(), field_name));\n \telse if (type == Float.TYPE)\n-\t  realOutput.writeFloat (getFloatField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeFloat(getFloatField(obj, osc.forClass(), field_name));\n \telse if (type == Integer.TYPE)\n-\t  realOutput.writeInt (getIntField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeInt(getIntField(obj, osc.forClass(), field_name));\n \telse if (type == Long.TYPE)\n-\t  realOutput.writeLong (getLongField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeLong(getLongField(obj, osc.forClass(), field_name));\n \telse if (type == Short.TYPE)\n-\t  realOutput.writeShort (getShortField (obj, osc.forClass(), field_name));\n+\t  realOutput.writeShort(getShortField(obj, osc.forClass(), field_name));\n \telse\n-\t  writeObject (getObjectField (obj, osc.forClass(), field_name,\n-\t\t\t\t       fields[i].getTypeString ()));\n+\t  writeObject(getObjectField(obj, osc.forClass(), field_name,\n+\t\t\t\t     fields[i].getTypeString ()));\n       }\n-    setBlockDataMode (oldmode);\n+    setBlockDataMode(oldmode);\n   }\n \n \n   // Toggles writing primitive data to block-data buffer.\n-  private boolean setBlockDataMode (boolean on) throws IOException\n+  private boolean setBlockDataMode(boolean on) throws IOException\n   {\n     if (on == writeDataAsBlocks)\n       return on;\n@@ -1202,16 +1206,16 @@ private boolean setBlockDataMode (boolean on) throws IOException\n   }\n \n \n-  private void callWriteMethod (Object obj, ObjectStreamClass osc)\n+  private void callWriteMethod(Object obj, ObjectStreamClass osc)\n     throws IOException\n   {\n     Class klass = osc.forClass();\n     try\n       {\n \tClass classArgs[] = {ObjectOutputStream.class};\n-\tMethod m = getMethod (klass, \"writeObject\", classArgs);\n+\tMethod m = getMethod(klass, \"writeObject\", classArgs);\n \tObject args[] = {this};\n-\tm.invoke (obj, args);\t\n+\tm.invoke(obj, args);\t\n       }\n     catch (NoSuchMethodException nsme)\n       {\n@@ -1227,34 +1231,34 @@ private void callWriteMethod (Object obj, ObjectStreamClass osc)\n \t  throw (IOException) exception;\n \n \tIOException ioe\n-\t  = new IOException (\"Exception thrown from writeObject() on \" +\n-\t\t\t     klass + \": \" + exception.getClass().getName());\n+\t  = new IOException(\"Exception thrown from writeObject() on \" +\n+\t\t\t    klass + \": \" + exception.getClass().getName());\n \tioe.initCause(exception);\n \tthrow ioe;\n       }\n     catch (Exception x)\n       {\n \tIOException ioe\n-\t  = new IOException (\"Failure invoking writeObject() on \" +\n-\t\t\t     klass + \": \" + x.getClass().getName());\n+\t  = new IOException(\"Failure invoking writeObject() on \" +\n+\t\t\t    klass + \": \" + x.getClass().getName());\n \tioe.initCause(x);\n \tthrow ioe;\n       }\n   }\n \n-  private boolean getBooleanField (Object obj, Class klass, String field_name)\n+  private boolean getBooleanField(Object obj, Class klass, String field_name)\n     throws IOException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\tboolean b = f.getBoolean (obj);\n+\tField f = getField(klass, field_name);\n+\tboolean b = f.getBoolean(obj);\n \treturn b;\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n-      }    \n+\tthrow new IOException(\"Unexpected exception \" + _);\n+      }\n   }\n \n   private byte getByteField (Object obj, Class klass, String field_name)\n@@ -1268,7 +1272,7 @@ private byte getByteField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n+\tthrow new IOException(\"Unexpected exception \" + _);\n       }    \n   }\n \n@@ -1283,7 +1287,7 @@ private char getCharField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n+\tthrow new IOException(\"Unexpected exception \" + _);\n       }    \n   }\n \n@@ -1298,7 +1302,7 @@ private double getDoubleField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n+\tthrow new IOException(\"Unexpected exception \" + _);\n       }    \n   }\n \n@@ -1313,8 +1317,8 @@ private float getFloatField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n-      }    \n+\tthrow new IOException(\"Unexpected exception \" + _);\n+      }\n   }\n \n   private int getIntField (Object obj, Class klass, String field_name)\n@@ -1328,8 +1332,8 @@ private int getIntField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n-      }    \n+\tthrow new IOException(\"Unexpected exception \" + _);\n+      }\n   }\n \n   private long getLongField (Object obj, Class klass, String field_name)\n@@ -1343,7 +1347,7 @@ private long getLongField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n+\tthrow new IOException(\"Unexpected exception \" + _);\n       }    \n   }\n \n@@ -1358,8 +1362,8 @@ private short getShortField (Object obj, Class klass, String field_name)\n       }\n     catch (Exception _)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n-      }    \n+\tthrow new IOException(\"Unexpected exception \" + _);\n+      }\n   }\n \n   private Object getObjectField (Object obj, Class klass, String field_name,\n@@ -1372,9 +1376,9 @@ private Object getObjectField (Object obj, Class klass, String field_name,\n \t// FIXME: We should check the type_code here\n \treturn o;\n       }\n-    catch (Exception _)\n+    catch (Exception e)\n       {\n-\tthrow new IOException (\"Unexpected Exception \"+_);\n+\tthrow new IOException ();\n       }    \n   }\n \n@@ -1434,7 +1438,7 @@ public Object run()\n   {\n     if (Configuration.INIT_LOAD_LIBRARY)\n       {\n-        System.loadLibrary (\"javaio\");\n+        System.loadLibrary(\"javaio\");\n       }\n   }\n }"}, {"sha": "5bd0e686625df536052ce636df6eff5edb3da5d9", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "modified", "additions": 412, "deletions": 406, "changes": 818, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34998d6bb655f3270bc54656aa9519360100c2d8/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=34998d6bb655f3270bc54656aa9519360100c2d8", "patch": "@@ -2,39 +2,39 @@\n    about serialized objects.\n    Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation, Inc.\n \n-This file is part of GNU Classpath.\n+   This file is part of GNU Classpath.\n \n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n  \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+\n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+\n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n \n \n package java.io;\n@@ -61,81 +61,81 @@\n public class ObjectStreamClass implements Serializable\n {\n   /**\n-     Returns the <code>ObjectStreamClass</code> for <code>cl</code>.\n-     If <code>cl</code> is null, or is not <code>Serializable</code>,\n-     null is returned.  <code>ObjectStreamClass</code>'s are memorized;\n-     later calls to this method with the same class will return the\n-     same <code>ObjectStreamClass</code> object and no recalculation\n-     will be done.\n-\n-     @see java.io.Serializable\n-  */\n-  public static ObjectStreamClass lookup (Class cl)\n+   * Returns the <code>ObjectStreamClass</code> for <code>cl</code>.\n+   * If <code>cl</code> is null, or is not <code>Serializable</code>,\n+   * null is returned.  <code>ObjectStreamClass</code>'s are memorized;\n+   * later calls to this method with the same class will return the\n+   * same <code>ObjectStreamClass</code> object and no recalculation\n+   * will be done.\n+   *\n+   * @see java.io.Serializable\n+   */\n+  public static ObjectStreamClass lookup(Class cl)\n   {\n     if (cl == null)\n       return null;\n-    if (! (Serializable.class).isAssignableFrom (cl))\n+    if (! (Serializable.class).isAssignableFrom(cl))\n       return null;\n \n-    return lookupForClassObject (cl);\n+    return lookupForClassObject(cl);\n   }\n \n   /**\n    * This lookup for internal use by ObjectOutputStream.  Suppose\n    * we have a java.lang.Class object C for class A, though A is not\n    * serializable, but it's okay to serialize C.\n    */\n-  static ObjectStreamClass lookupForClassObject (Class cl)\n+  static ObjectStreamClass lookupForClassObject(Class cl)\n   {\n     if (cl == null)\n       return null;\n \n-    ObjectStreamClass osc = (ObjectStreamClass)classLookupTable.get (cl);\n+    ObjectStreamClass osc = (ObjectStreamClass) classLookupTable.get(cl);\n \n     if (osc != null)\n       return osc;\n     else\n-    {\n-      osc = new ObjectStreamClass (cl);\n-      classLookupTable.put (cl, osc);\n-      return osc;\n-    }\n+      {\n+\tosc = new ObjectStreamClass(cl);\n+\tclassLookupTable.put(cl, osc);\n+\treturn osc;\n+      }\n   }\n \n \n   /**\n-     Returns the name of the class that this\n-     <code>ObjectStreamClass</code> represents.\n-  */\n-  public String getName ()\n+   * Returns the name of the class that this\n+   * <code>ObjectStreamClass</code> represents.\n+   */\n+  public String getName()\n   {\n     return name;\n   }\n \n \n   /**\n-     Returns the class that this <code>ObjectStreamClass</code>\n-     represents.  Null could be returned if this\n-     <code>ObjectStreamClass</code> was read from an\n-     <code>ObjectInputStream</code> and the class it represents cannot\n-     be found or loaded.\n-\n-     @see java.io.ObjectInputStream\n-  */\n-  public Class forClass ()\n+   * Returns the class that this <code>ObjectStreamClass</code>\n+   * represents.  Null could be returned if this\n+   * <code>ObjectStreamClass</code> was read from an\n+   * <code>ObjectInputStream</code> and the class it represents cannot\n+   * be found or loaded.\n+   *\n+   * @see java.io.ObjectInputStream\n+   */\n+  public Class forClass()\n   {\n     return clazz;\n   }\n \n \n   /**\n-     Returns the serial version stream-unique identifier for the class\n-     represented by this <code>ObjectStreamClass</code>.  This SUID is\n-     either defined by the class as <code>static final long\n-     serialVersionUID</code> or is calculated as specified in\n-     Javasoft's \"Object Serialization Specification\" XXX: add reference\n-  */\n-  public long getSerialVersionUID ()\n+   * Returns the serial version stream-unique identifier for the class\n+   * represented by this <code>ObjectStreamClass</code>.  This SUID is\n+   * either defined by the class as <code>static final long\n+   * serialVersionUID</code> or is calculated as specified in\n+   * Javasoft's \"Object Serialization Specification\" XXX: add reference\n+   */\n+  public long getSerialVersionUID()\n   {\n     return uid;\n   }\n@@ -145,10 +145,10 @@ public long getSerialVersionUID ()\n   // of the class represented by this ObjectStreamClass.  The Fields\n   // are sorted by name.\n   // XXX doc\n-  public ObjectStreamField[] getFields ()\n+  public ObjectStreamField[] getFields()\n   {\n     ObjectStreamField[] copy = new ObjectStreamField[ fields.length ];\n-    System.arraycopy (fields, 0, copy, 0, fields.length);\n+    System.arraycopy(fields, 0, copy, 0, fields.length);\n     return copy;\n   }\n \n@@ -158,8 +158,8 @@ public ObjectStreamField[] getFields ()\n   // primitiveness.\n   public ObjectStreamField getField (String name)\n   {\n-    for (int i=0; i < fields.length; i++)\n-      if (fields[i].getName ().equals (name))\n+    for (int i = 0; i < fields.length; i++)\n+      if (fields[i].getName().equals(name))\n \treturn fields[i];\n     return null;\n   }\n@@ -174,7 +174,7 @@ public ObjectStreamField getField (String name)\n    * @see #getSerialVersionUID()\n    * @see #getName()\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     return \"java.io.ObjectStreamClass< \" + name + \", \" + uid + \" >\";\n   }\n@@ -187,7 +187,7 @@ public String toString ()\n   //\n   // This method is used by the class to override default\n   // serialization behavior.\n-  boolean hasWriteMethod ()\n+  boolean hasWriteMethod()\n   {\n     return (flags & ObjectStreamConstants.SC_WRITE_METHOD) != 0;\n   }\n@@ -200,32 +200,32 @@ boolean hasWriteMethod ()\n   //\n   // This method is used by the class to override default\n   // serialization behavior.\n-  boolean hasReadMethod ()\n+  boolean hasReadMethod()\n   {\n-      try\n+    try\n       {\n-\t  Class[] readObjectParams = { ObjectInputStream.class };\n-\t  forClass ().getDeclaredMethod (\"readObject\", readObjectParams);\n-\t  return true;\n+\tClass[] readObjectParams = { ObjectInputStream.class };\n+\tforClass().getDeclaredMethod(\"readObject\", readObjectParams);\n+\treturn true;\n       }\n-      catch (NoSuchMethodException e)\n+    catch (NoSuchMethodException e)\n       {\n-\t  return false;\n+\treturn false;\n       }\n   }\n \n \n   // Returns true iff the class that this ObjectStreamClass represents\n   // implements Serializable but does *not* implement Externalizable.\n-  boolean isSerializable ()\n+  boolean isSerializable()\n   {\n     return (flags & ObjectStreamConstants.SC_SERIALIZABLE) != 0;\n   }\n \n \n   // Returns true iff the class that this ObjectStreamClass represents\n   // implements Externalizable.\n-  boolean isExternalizable ()\n+  boolean isExternalizable()\n   {\n     return (flags & ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;\n   }\n@@ -235,7 +235,7 @@ boolean isExternalizable ()\n   // class that is the superclass of the class this\n   // <code>ObjectStreamClass</code> represents.  If the superclass is\n   // not Serializable, null is returned.\n-  ObjectStreamClass getSuper ()\n+  ObjectStreamClass getSuper()\n   {\n     return superClass;\n   }\n@@ -245,45 +245,45 @@ ObjectStreamClass getSuper ()\n   // classes of CLAZZ and CLAZZ itself in order from most super to\n   // CLAZZ.  ObjectStreamClass[0] is the highest superclass of CLAZZ\n   // that is serializable.\n-  static ObjectStreamClass[] getObjectStreamClasses (Class clazz)\n+  static ObjectStreamClass[] getObjectStreamClasses(Class clazz)\n   {\n-    ObjectStreamClass osc = ObjectStreamClass.lookup (clazz);\n+    ObjectStreamClass osc = ObjectStreamClass.lookup(clazz);\n \n     if (osc == null)\n       return new ObjectStreamClass[0];\n     else\n-    {\n-      Vector oscs = new Vector ();\n-\n-      while (osc != null)\n       {\n-\toscs.addElement (osc);\n-\tosc = osc.getSuper ();\n-      }\n+\tVector oscs = new Vector();\n \n-      int count = oscs.size ();\n-      ObjectStreamClass[] sorted_oscs = new ObjectStreamClass[ count ];\n+\twhile (osc != null)\n+\t  {\n+\t    oscs.addElement (osc);\n+\t    osc = osc.getSuper();\n+\t  }\n+\n+\tint count = oscs.size();\n+\tObjectStreamClass[] sorted_oscs = new ObjectStreamClass[ count ];\n \n-      for (int i = count - 1; i >= 0; i--)\n-\tsorted_oscs[ count - i - 1 ] = (ObjectStreamClass)oscs.elementAt (i);\n+\tfor (int i = count - 1; i >= 0; i--)\n+\t  sorted_oscs[ count - i - 1 ] = (ObjectStreamClass) oscs.elementAt(i);\n \n-      return sorted_oscs;\n-    }\n+\treturn sorted_oscs;\n+      }\n   }\n \n \n   // Returns an integer that consists of bit-flags that indicate\n   // properties of the class represented by this ObjectStreamClass.\n   // The bit-flags that could be present are those defined in\n   // ObjectStreamConstants that begin with `SC_'\n-  int getFlags ()\n+  int getFlags()\n   {\n     return flags;\n   }\n \n \n-  ObjectStreamClass (String name, long uid, byte flags,\n-\t\t     ObjectStreamField[] fields)\n+  ObjectStreamClass(String name, long uid, byte flags,\n+\t\t    ObjectStreamField[] fields)\n   {\n     this.name = name;\n     this.uid = uid;\n@@ -302,11 +302,11 @@ int getFlags ()\n    * @throws InvalidClassException if an incompatibility between computed UID and\n    * already set UID is found.\n    */\n-  void setClass (Class cl, ObjectStreamClass superClass) throws InvalidClassException\n+  void setClass(Class cl, ObjectStreamClass superClass) throws InvalidClassException\n   {\n     this.clazz = cl;\n \n-    long class_uid = getClassUID (cl);\n+    long class_uid = getClassUID(cl);\n     if (uid == 0)\n       uid = class_uid;\n     else\n@@ -322,87 +322,89 @@ void setClass (Class cl, ObjectStreamClass superClass) throws InvalidClassExcept\n \t  }\n       }\n \n-    isProxyClass = clazz != null && Proxy.isProxyClass (clazz);\n+    isProxyClass = clazz != null && Proxy.isProxyClass(clazz);\n     this.superClass = superClass;\n-    calculateOffsets ();\n-\n+    calculateOffsets();\n+    \n     try\n       {\n-        ObjectStreamField[] exportedFields = getSerialPersistentFields (clazz);\n-\n-        if (exportedFields == null)\n-          return;\n-\n-        ObjectStreamField[] newFieldList = new ObjectStreamField[exportedFields.length + fields.length];\n-        int i, j, k;\n-\n-        /* We now check the import fields against the exported fields.\n-         * There should not be contradiction (e.g. int x and String x)\n-         * but extra virtual fields can be added to the class.\n-         */\n-\n-        Arrays.sort(exportedFields);\n-\n-        i = 0; j = 0; k = 0;\n-        while (i < fields.length && j < exportedFields.length)\n-          {\n-            int comp = fields[i].getName().compareTo (exportedFields[j].getName());\n-            if (comp < 0)\n-              {\n-                newFieldList[k] = fields[i];\n-                fields[i].setPersistent(false);\n-                fields[i].setToSet(false);\n-                i++;\n-              }\n-            else if (comp > 0)\n-              {\n-                /* field not found in imported fields. We add it\n-                 * in the list of supported fields.\n-                 */\n-                newFieldList[k] = exportedFields[j];\n-                newFieldList[k].setPersistent(true);\n-                newFieldList[k].setToSet(false);\n-                j++;\n-              }\n-            else\n-              {\n-                if (!fields[i].getType().equals (exportedFields[j].getType()))\n-                  throw new InvalidClassException (\"serialPersistentFields must be compatible with\" +\n-                                                   \" imported fields (about \" + fields[i].getName() + \")\");\n-                newFieldList[k] = fields[i];\n-                fields[i].setPersistent(true);\n-                i++;\n-                j++;\n-              }\n-            k++;\n-          }\n-\n-        if (i < fields.length)\n-          for (; i < fields.length; i++, k++)\n-            {\n-              fields[i].setPersistent(false);\n-              fields[i].setToSet(false);\n-              newFieldList[k] = fields[i];\n-            }\n-          else\n-            if (j < exportedFields.length)\n-              for (; j < exportedFields.length; j++, k++)\n-                {\n-                  exportedFields[j].setPersistent(true);\n-                  exportedFields[j].setToSet(false);\n-                  newFieldList[k] = exportedFields[j];\n-               }\n-\n-        fields = new ObjectStreamField[k];\n-        System.arraycopy (newFieldList, 0, fields, 0, k);\n+\tObjectStreamField[] exportedFields = getSerialPersistentFields (clazz);  \n+\n+\tif (exportedFields == null)\n+\t  return;\n+\n+\tObjectStreamField[] newFieldList = new ObjectStreamField[exportedFields.length + fields.length];\n+\tint i, j, k;\n+\n+\t/* We now check the import fields against the exported fields.\n+\t * There should not be contradiction (e.g. int x and String x)\n+\t * but extra virtual fields can be added to the class.\n+\t */\n+\n+\tArrays.sort(exportedFields);\n+\n+\ti = 0; j = 0; k = 0;\n+\twhile (i < fields.length && j < exportedFields.length)\n+\t  {\n+\t    int comp = fields[i].getName().compareTo(exportedFields[j].getName());\n+\n+\t    if (comp < 0)\n+\t      {\n+\t\tnewFieldList[k] = fields[i];\n+\t\tfields[i].setPersistent(false);\n+\t\tfields[i].setToSet(false);\n+\t\ti++;\n+\t      }\n+\t    else if (comp > 0)\n+\t      {\n+\t\t/* field not found in imported fields. We add it\n+\t\t * in the list of supported fields.\n+\t\t */\n+\t\tnewFieldList[k] = exportedFields[j];\n+\t\tnewFieldList[k].setPersistent(true);\n+\t\tnewFieldList[k].setToSet(false);\n+\t\tj++;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (!fields[i].getType().equals(exportedFields[j].getType()))\n+\t\t  throw new InvalidClassException\n+\t\t    (\"serialPersistentFields must be compatible with\" +\n+\t\t     \" imported fields (about \" + fields[i].getName() + \")\");\n+\t\tnewFieldList[k] = fields[i];\n+\t\tfields[i].setPersistent(true);\n+\t\ti++;\n+\t\tj++;\n+\t      }\n+\t    k++;\n+\t  }\n+\n+\tif (i < fields.length)\n+\t  for (;i<fields.length;i++,k++)\n+\t    {\n+\t      fields[i].setPersistent(false);\n+\t      fields[i].setToSet(false);\n+\t      newFieldList[k] = fields[i];\n+\t    }\n+\telse\n+\t  if (j < exportedFields.length)\n+\t    for (;j<exportedFields.length;j++,k++)\n+\t      {\n+\t\texportedFields[j].setPersistent(true);\n+\t\texportedFields[j].setToSet(false);\n+\t\tnewFieldList[k] = exportedFields[j];\n+\t      }\n+\t\n+\tfields = new ObjectStreamField[k];\n+\tSystem.arraycopy(newFieldList, 0, fields, 0, k);\n       }\n     catch (NoSuchFieldException ignore)\n       {\n-        return;\n+\treturn;\n       }\n     catch (IllegalAccessException ignore)\n       {\n-        return;\n+\treturn;\n       }\n   }\n \n@@ -411,296 +413,300 @@ void setSuperclass (ObjectStreamClass osc)\n     superClass = osc;\n   }\n \n-\n-  void calculateOffsets ()\n+  void calculateOffsets()\n   {\n     int i;\n     ObjectStreamField field;\n     primFieldSize = 0;\n     int fcount = fields.length;\n     for (i = 0; i < fcount; ++ i)\n-    {\n-      field = fields[i];\n-\n-      if (! field.isPrimitive ())\n-\tbreak;\n-\n-      field.setOffset (primFieldSize);\n-      switch (field.getTypeCode ())\n       {\n-\tcase 'B':\n-\tcase 'Z':\n-\t  ++ primFieldSize;\n-\t  break;\n-\tcase 'C':\n-\tcase 'S':\n-\t  primFieldSize += 2;\n-\t  break;\n-\tcase 'I':\n-\tcase 'F':\n-\t  primFieldSize += 4;\n-\t  break;\n-\tcase 'D':\n-\tcase 'J':\n-\t  primFieldSize += 8;\n+\tfield = fields[i];\n+\n+\tif (! field.isPrimitive())\n \t  break;\n+\n+\tfield.setOffset(primFieldSize);\n+\tswitch (field.getTypeCode())\n+\t  {\n+\t  case 'B':\n+\t  case 'Z':\n+\t    ++ primFieldSize;\n+\t    break;\n+\t  case 'C':\n+\t  case 'S':\n+\t    primFieldSize += 2;\n+\t    break;\n+\t  case 'I':\n+\t  case 'F':\n+\t    primFieldSize += 4;\n+\t    break;\n+\t  case 'D':\n+\t  case 'J':\n+\t    primFieldSize += 8;\n+\t    break;\n+\t  }\n       }\n-    }\n \n     for (objectFieldCount = 0; i < fcount; ++ i)\n-      fields[i].setOffset (objectFieldCount++);\n+      fields[i].setOffset(objectFieldCount++);\n   }\n \n \n-  private ObjectStreamClass (Class cl)\n+  private ObjectStreamClass(Class cl)\n   {\n     uid = 0;\n     flags = 0;\n-    isProxyClass = Proxy.isProxyClass (cl);\n+    isProxyClass = Proxy.isProxyClass(cl);\n \n     clazz = cl;\n-    name = cl.getName ();\n-    setFlags (cl);\n-    setFields (cl);\n+    name = cl.getName();\n+    setFlags(cl);\n+    setFields(cl);\n     // to those class nonserializable, its uid field is 0\n-    if ( (Serializable.class).isAssignableFrom (cl) && !isProxyClass)\n-      uid = getClassUID (cl);\n-    superClass = lookup (cl.getSuperclass ());\n+    if ( (Serializable.class).isAssignableFrom(cl) && !isProxyClass)\n+      uid = getClassUID(cl);\n+    superClass = lookup(cl.getSuperclass());\n   }\n \n \n   // Sets bits in flags according to features of CL.\n-  private void setFlags (Class cl)\n+  private void setFlags(Class cl)\n   {\n-    if ((java.io.Externalizable.class).isAssignableFrom (cl))\n+    if ((java.io.Externalizable.class).isAssignableFrom(cl))\n       flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;\n-    else if ((java.io.Serializable.class).isAssignableFrom (cl))\n+    else if ((java.io.Serializable.class).isAssignableFrom(cl))\n       // only set this bit if CL is NOT Externalizable\n       flags |= ObjectStreamConstants.SC_SERIALIZABLE;\n \n     try\n-    {\n-      Method writeMethod = cl.getDeclaredMethod (\"writeObject\",\n-\t\t\t\t\t\t writeMethodArgTypes);\n-      int modifiers = writeMethod.getModifiers ();\n-\n-      if (writeMethod.getReturnType () == Void.TYPE\n-\t  && Modifier.isPrivate (modifiers)\n-\t  && !Modifier.isStatic (modifiers))\n-\tflags |= ObjectStreamConstants.SC_WRITE_METHOD;\n-    }\n-    catch (NoSuchMethodException oh_well)\n-    {}\n+      {\n+\tMethod writeMethod = cl.getDeclaredMethod(\"writeObject\",\n+\t\t\t\t\t\t  writeMethodArgTypes);\n+\tint modifiers = writeMethod.getModifiers();\n+\n+\tif (writeMethod.getReturnType() == Void.TYPE\n+\t    && Modifier.isPrivate(modifiers)\n+\t    && !Modifier.isStatic(modifiers))\n+\t  flags |= ObjectStreamConstants.SC_WRITE_METHOD;\n+      }\n+    catch(NoSuchMethodException oh_well)\n+      {\n+      }\n   }\n \n \n   // Sets fields to be a sorted array of the serializable fields of\n   // clazz.\n-  private void setFields (Class cl)\n+  private void setFields(Class cl)\n   {\n-    if (! isSerializable () || isExternalizable ())\n-    {\n-      fields = NO_FIELDS;\n-      return;\n-    }\n+    if (!isSerializable() || isExternalizable())\n+      {\n+\tfields = NO_FIELDS;\n+\treturn;\n+      }\n \n     try\n-    {\n-      Field serialPersistentFields\n-\t= cl.getDeclaredField (\"serialPersistentFields\");\n-      serialPersistentFields.setAccessible(true);\n-      int modifiers = serialPersistentFields.getModifiers ();\n-\n-      if (Modifier.isStatic (modifiers)\n-\t  && Modifier.isFinal (modifiers)\n-\t  && Modifier.isPrivate (modifiers))\n       {\n-\tfields = getSerialPersistentFields (cl);\n-\tif (fields != null)\n+\tField serialPersistentFields =\n+\t  cl.getDeclaredField(\"serialPersistentFields\");\n+\tserialPersistentFields.setAccessible(true);\n+\tint modifiers = serialPersistentFields.getModifiers();\n+\n+\tif (Modifier.isStatic(modifiers)\n+\t    && Modifier.isFinal(modifiers)\n+\t    && Modifier.isPrivate(modifiers))\n \t  {\n-\t    Arrays.sort(fields);\n-\t    calculateOffsets();\n-\t    return;\n+\t    fields = getSerialPersistentFields(cl);\n+\t    if (fields != null)\n+\t      {\n+\t\tArrays.sort (fields);\n+\t\tcalculateOffsets();\n+\t\treturn;\n+\t      }\n \t  }\n       }\n-    }\n     catch (NoSuchFieldException ignore)\n-    {}\n+      {\n+      }\n     catch (IllegalAccessException ignore)\n       {\n       }\n \n     int num_good_fields = 0;\n-    Field[] all_fields = cl.getDeclaredFields ();\n+    Field[] all_fields = cl.getDeclaredFields();\n \n     int modifiers;\n     // set non-serializable fields to null in all_fields\n-    for (int i=0; i < all_fields.length; i++)\n-    {\n-      modifiers = all_fields[i].getModifiers ();\n-      if (Modifier.isTransient (modifiers)\n-\t  || Modifier.isStatic (modifiers))\n-\tall_fields[i] = null;\n-      else\n-\tnum_good_fields++;\n-    }\n+    for (int i = 0; i < all_fields.length; i++)\n+      {\n+\tmodifiers = all_fields[i].getModifiers();\n+\tif (Modifier.isTransient(modifiers)\n+\t    || Modifier.isStatic(modifiers))\n+\t  all_fields[i] = null;\n+\telse\n+\t  num_good_fields++;\n+      }\n \n     // make a copy of serializable (non-null) fields\n     fields = new ObjectStreamField[ num_good_fields ];\n-    for (int from=0, to=0; from < all_fields.length; from++)\n+    for (int from = 0, to = 0; from < all_fields.length; from++)\n       if (all_fields[from] != null)\n-      {\n-\tField f = all_fields[from];\n-\tfields[to] = new ObjectStreamField (f.getName (), f.getType ());\n-\tto++;\n-      }\n+\t{\n+\t  Field f = all_fields[from];\n+\t  fields[to] = new ObjectStreamField(f.getName(), f.getType());\n+\t  to++;\n+\t}\n \n-    Arrays.sort (fields);\n-    calculateOffsets ();\n+    Arrays.sort(fields);\n+    calculateOffsets();\n   }\n \n   // Returns the serial version UID defined by class, or if that\n   // isn't present, calculates value of serial version UID.\n-  private long getClassUID (Class cl)\n+  private long getClassUID(Class cl)\n   {\n     try\n-    {\n-      // Use getDeclaredField rather than getField, since serialVersionUID\n-      // may not be public AND we only want the serialVersionUID of this\n-      // class, not a superclass or interface.\n-      Field suid = cl.getDeclaredField (\"serialVersionUID\");\n-      suid.setAccessible(true);\n-      int modifiers = suid.getModifiers ();\n-\n-      if (Modifier.isStatic (modifiers)\n-\t  && Modifier.isFinal (modifiers)\n-\t  && suid.getType() == Long.TYPE)\n-\treturn suid.getLong (null);\n-    }\n+      {\n+\t// Use getDeclaredField rather than getField, since serialVersionUID\n+\t// may not be public AND we only want the serialVersionUID of this\n+\t// class, not a superclass or interface.\n+\tField suid = cl.getDeclaredField(\"serialVersionUID\");\n+\tsuid.setAccessible(true);\n+\tint modifiers = suid.getModifiers();\n+\n+\tif (Modifier.isStatic(modifiers)\n+\t    && Modifier.isFinal(modifiers)\n+\t    && suid.getType() == Long.TYPE)\n+\t  return suid.getLong(null);\n+      }\n     catch (NoSuchFieldException ignore)\n-    {}\n+      {\n+      }\n     catch (IllegalAccessException ignore)\n-    {}\n+      {\n+      }\n \n     // cl didn't define serialVersionUID, so we have to compute it\n     try\n-    {\n-      MessageDigest md;\n-      try \n-\t{\n-\t  md = MessageDigest.getInstance (\"SHA\");\n-\t}\n-      catch (NoSuchAlgorithmException e)\n-\t{\n-\t  // If a provider already provides SHA, use it; otherwise, use this.\n-\t  Gnu gnuProvider = new Gnu();\n-\t  Security.addProvider(gnuProvider);\n-\t  md = MessageDigest.getInstance (\"SHA\");\n-\t}\n+      {\n+\tMessageDigest md;\n+\ttry \n+\t  {\n+\t    md = MessageDigest.getInstance(\"SHA\");\n+\t  }\n+\tcatch (NoSuchAlgorithmException e)\n+\t  {\n+\t    // If a provider already provides SHA, use it; otherwise, use this.\n+\t    Gnu gnuProvider = new Gnu();\n+\t    Security.addProvider(gnuProvider);\n+\t    md = MessageDigest.getInstance(\"SHA\");\n+\t  }\n \n-      DigestOutputStream digest_out =\n-\tnew DigestOutputStream (nullOutputStream, md);\n-      DataOutputStream data_out = new DataOutputStream (digest_out);\n+\tDigestOutputStream digest_out =\n+\t  new DigestOutputStream(nullOutputStream, md);\n+\tDataOutputStream data_out = new DataOutputStream(digest_out);\n \n-      data_out.writeUTF (cl.getName ());\n+\tdata_out.writeUTF(cl.getName());\n \n-      int modifiers = cl.getModifiers ();\n-      // just look at interesting bits\n-      modifiers = modifiers & (Modifier.ABSTRACT | Modifier.FINAL\n-  \t\t\t\t| Modifier.INTERFACE | Modifier.PUBLIC);\n-      data_out.writeInt (modifiers);\n+\tint modifiers = cl.getModifiers();\n+\t// just look at interesting bits\n+\tmodifiers = modifiers & (Modifier.ABSTRACT | Modifier.FINAL\n+\t\t\t\t | Modifier.INTERFACE | Modifier.PUBLIC);\n+\tdata_out.writeInt(modifiers);\n \n-      // Pretend that an array has no interfaces, because when array\n-      // serialization was defined (JDK 1.1), arrays didn't have it.\n-      if (! cl.isArray ())\n-\t{\n-\t  Class[] interfaces = cl.getInterfaces ();\n-\t  Arrays.sort (interfaces, interfaceComparator);\n-\t  for (int i=0; i < interfaces.length; i++)\n-\t    data_out.writeUTF (interfaces[i].getName ());\n-\t}\n+\t// Pretend that an array has no interfaces, because when array\n+\t// serialization was defined (JDK 1.1), arrays didn't have it.\n+\tif (! cl.isArray())\n+\t  {\n+\t    Class[] interfaces = cl.getInterfaces();\n+\t    Arrays.sort(interfaces, interfaceComparator);\n+\t    for (int i = 0; i < interfaces.length; i++)\n+\t      data_out.writeUTF(interfaces[i].getName());\n+\t  }\n \n-      Field field;\n-      Field[] fields = cl.getDeclaredFields ();\n-      Arrays.sort (fields, memberComparator);\n-      for (int i=0; i < fields.length; i++)\n-      {\n-\tfield = fields[i];\n-\tmodifiers = field.getModifiers ();\n-\tif (Modifier.isPrivate (modifiers)\n-\t    && (Modifier.isStatic (modifiers)\n-\t\t || Modifier.isTransient (modifiers)))\n-\t  continue;\n-\n-\tdata_out.writeUTF (field.getName ());\n-\tdata_out.writeInt (modifiers);\n-\tdata_out.writeUTF (TypeSignature.getEncodingOfClass (field.getType ()));\n-      }\n+\tField field;\n+\tField[] fields = cl.getDeclaredFields();\n+\tArrays.sort(fields, memberComparator);\n+\tfor (int i = 0; i < fields.length; i++)\n+\t  {\n+\t    field = fields[i];\n+\t    modifiers = field.getModifiers();\n+\t    if (Modifier.isPrivate(modifiers)\n+\t\t&& (Modifier.isStatic(modifiers)\n+\t\t    || Modifier.isTransient(modifiers)))\n+\t      continue;\n+\n+\t    data_out.writeUTF(field.getName());\n+\t    data_out.writeInt(modifiers);\n+\t    data_out.writeUTF(TypeSignature.getEncodingOfClass (field.getType()));\n+\t  }\n \n-      // write class initializer method if present\n-      if (VMObjectStreamClass.hasClassInitializer (cl))\n-      {\n-\tdata_out.writeUTF (\"<clinit>\");\n-\tdata_out.writeInt (Modifier.STATIC);\n-\tdata_out.writeUTF (\"()V\");\n-      }\n+\t// write class initializer method if present\n+\tif (VMObjectStreamClass.hasClassInitializer(cl))\n+\t  {\n+\t    data_out.writeUTF(\"<clinit>\");\n+\t    data_out.writeInt(Modifier.STATIC);\n+\t    data_out.writeUTF(\"()V\");\n+\t  }\n \n-      Constructor constructor;\n-      Constructor[] constructors = cl.getDeclaredConstructors ();\n-      Arrays.sort (constructors, memberComparator);\n-      for (int i=0; i < constructors.length; i++)\n-      {\n-\tconstructor = constructors[i];\n-\tmodifiers = constructor.getModifiers ();\n-\tif (Modifier.isPrivate (modifiers))\n-\t  continue;\n-\n-\tdata_out.writeUTF (\"<init>\");\n-\tdata_out.writeInt (modifiers);\n-\n-\t// the replacement of '/' with '.' was needed to make computed\n-\t// SUID's agree with those computed by JDK\n-\tdata_out.writeUTF (\n-\t  TypeSignature.getEncodingOfConstructor (constructor).replace ('/','.'));\n-      }\n+\tConstructor constructor;\n+\tConstructor[] constructors = cl.getDeclaredConstructors();\n+\tArrays.sort (constructors, memberComparator);\n+\tfor (int i = 0; i < constructors.length; i++)\n+\t  {\n+\t    constructor = constructors[i];\n+\t    modifiers = constructor.getModifiers();\n+\t    if (Modifier.isPrivate(modifiers))\n+\t      continue;\n+\n+\t    data_out.writeUTF(\"<init>\");\n+\t    data_out.writeInt(modifiers);\n+\n+\t    // the replacement of '/' with '.' was needed to make computed\n+\t    // SUID's agree with those computed by JDK\n+\t    data_out.writeUTF \n+\t      (TypeSignature.getEncodingOfConstructor(constructor).replace('/','.'));\n+\t  }\n \n-      Method method;\n-      Method[] methods = cl.getDeclaredMethods ();\n-      Arrays.sort (methods, memberComparator);\n-      for (int i=0; i < methods.length; i++)\n-      {\n-\tmethod = methods[i];\n-\tmodifiers = method.getModifiers ();\n-\tif (Modifier.isPrivate (modifiers))\n-\t  continue;\n-\n-\tdata_out.writeUTF (method.getName ());\n-\tdata_out.writeInt (modifiers);\n-\n-\t// the replacement of '/' with '.' was needed to make computed\n-\t// SUID's agree with those computed by JDK\n-\tdata_out.writeUTF (\n-\t  TypeSignature.getEncodingOfMethod (method).replace ('/', '.'));\n-      }\n+\tMethod method;\n+\tMethod[] methods = cl.getDeclaredMethods();\n+\tArrays.sort(methods, memberComparator);\n+\tfor (int i = 0; i < methods.length; i++)\n+\t  {\n+\t    method = methods[i];\n+\t    modifiers = method.getModifiers();\n+\t    if (Modifier.isPrivate(modifiers))\n+\t      continue;\n+\n+\t    data_out.writeUTF(method.getName());\n+\t    data_out.writeInt(modifiers);\n+\n+\t    // the replacement of '/' with '.' was needed to make computed\n+\t    // SUID's agree with those computed by JDK\n+\t    data_out.writeUTF\n+\t      (TypeSignature.getEncodingOfMethod(method).replace('/', '.'));\n+\t  }\n \n-      data_out.close ();\n-      byte[] sha = md.digest ();\n-      long result = 0;\n-      int len = sha.length < 8 ? sha.length : 8;\n-      for (int i=0; i < len; i++)\n-\tresult += (long)(sha[i] & 0xFF) << (8 * i);\n+\tdata_out.close();\n+\tbyte[] sha = md.digest();\n+\tlong result = 0;\n+\tint len = sha.length < 8 ? sha.length : 8;\n+\tfor (int i = 0; i < len; i++)\n+\t  result += (long) (sha[i] & 0xFF) << (8 * i);\n \n-      return result;\n-    }\n+\treturn result;\n+      }\n     catch (NoSuchAlgorithmException e)\n-    {\n-      throw new RuntimeException (\"The SHA algorithm was not found to use in computing the Serial Version UID for class \"\n-\t\t\t\t  + cl.getName (), e);\n-    }\n+      {\n+\tthrow new RuntimeException\n+\t  (\"The SHA algorithm was not found to use in computing the Serial Version UID for class \"\n+\t   + cl.getName(), e);\n+      }\n     catch (IOException ioe)\n-    {\n-      throw new RuntimeException (ioe);\n-    }\n+      {\n+\tthrow new RuntimeException(ioe);\n+      }\n   }\n \n   /**\n@@ -712,7 +718,7 @@ private long getClassUID (Class cl)\n    * @param clazz Class to retrieve 'serialPersistentFields' from.\n    * @return The content of 'serialPersistentFields'.\n    */\n-  private ObjectStreamField[] getSerialPersistentFields (Class clazz)\n+  private ObjectStreamField[] getSerialPersistentFields(Class clazz) \n     throws NoSuchFieldException, IllegalAccessException\n   {\n     ObjectStreamField[] fieldsArray = null;\n@@ -724,28 +730,28 @@ private ObjectStreamField[] getSerialPersistentFields (Class clazz)\n     f.setAccessible(true);\n \n     int modifiers = f.getModifiers();\n-    if (!(Modifier.isStatic(modifiers)\n-\t&& Modifier.isFinal(modifiers)\n-\t&& Modifier.isPrivate(modifiers)))\n+    if (!(Modifier.isStatic(modifiers) &&\n+\t  Modifier.isFinal(modifiers) &&\n+\t  Modifier.isPrivate(modifiers)))\n       return null;\n     \n     o = (ObjectStreamField[]) f.get(null);\n     \n     if (o == null)\n       return null;\n \n-    fieldsArray = new ObjectStreamField[o.length];\n+    fieldsArray = new ObjectStreamField[ o.length ];\n     System.arraycopy(o, 0, fieldsArray, 0, o.length);\n     \n     return fieldsArray;\n   }\n \n   public static final ObjectStreamField[] NO_FIELDS = {};\n \n-  private static Hashtable classLookupTable = new Hashtable ();\n-  private static final NullOutputStream nullOutputStream = new NullOutputStream ();\n-  private static final Comparator interfaceComparator = new InterfaceComparator ();\n-  private static final Comparator memberComparator = new MemberComparator ();\n+  private static Hashtable classLookupTable = new Hashtable();\n+  private static final NullOutputStream nullOutputStream = new NullOutputStream();\n+  private static final Comparator interfaceComparator = new InterfaceComparator();\n+  private static final Comparator memberComparator = new MemberComparator();\n   private static final\n     Class[] writeMethodArgTypes = { java.io.ObjectOutputStream.class };\n \n@@ -775,9 +781,9 @@ private ObjectStreamField[] getSerialPersistentFields (Class clazz)\n // interfaces are compared only by name\n class InterfaceComparator implements Comparator\n {\n-  public int compare (Object o1, Object o2)\n+  public int compare(Object o1, Object o2)\n   {\n-    return ((Class)o1).getName ().compareTo (((Class)o2).getName ());\n+    return ((Class) o1).getName().compareTo(((Class) o2).getName());\n   }\n }\n \n@@ -786,16 +792,16 @@ public int compare (Object o1, Object o2)\n // conflicts are resolved by comparing type signatures\n class MemberComparator implements Comparator\n {\n-  public int compare (Object o1, Object o2)\n+  public int compare(Object o1, Object o2)\n   {\n-    Member m1 = (Member)o1;\n-    Member m2 = (Member)o2;\n+    Member m1 = (Member) o1;\n+    Member m2 = (Member) o2;\n \n-    int comp = m1.getName ().compareTo (m2.getName ());\n+    int comp = m1.getName().compareTo(m2.getName());\n \n     if (comp == 0)\n-      return TypeSignature.getEncodingOfMember (m1).\n-\tcompareTo (TypeSignature.getEncodingOfMember (m2));\n+      return TypeSignature.getEncodingOfMember(m1).\n+\tcompareTo(TypeSignature.getEncodingOfMember(m2));\n     else\n       return comp;\n   }"}]}