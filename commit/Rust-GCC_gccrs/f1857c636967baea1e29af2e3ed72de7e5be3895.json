{"sha": "f1857c636967baea1e29af2e3ed72de7e5be3895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE4NTdjNjM2OTY3YmFlYTFlMjlhZjJlM2VkNzJkZTdlNWJlMzg5NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-23T20:19:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-23T20:19:40Z"}, "message": "runtime: complete defer handling in CgocallBackDone\n    \n    When C code calls a Go function, it actually calls a function\n    generated by cgo. That function is written in Go, and, among other\n    things, it calls the real Go function like this:\n            CgocallBack()\n            defer CgocallBackDone()\n            RealGoFunction()\n    The deferred CgocallBackDone function enters syscall mode as we return\n    to C. Typically the C function will then eventually return to Go.\n    \n    However, in the case where the C function is running on a thread\n    created in C, it will not return to Go. For that case we will have\n    allocated an m struct, with an associated g struct, for the duration\n    of the Go code, and when the Go is complete we will return the m and g\n    to a free list.\n    \n    That all works, but we are running in a deferred function, which means\n    that we have been invoked by deferreturn, and deferreturn expects to\n    do a bit of cleanup to record that the defer has been completed. Doing\n    that cleanup while using an m and g that have already been returned to\n    the free list is clearly a bad idea. It was kind of working because\n    deferreturn was holding the g pointer in a local variable, but there\n    were races with some other thread picking up and using the newly freed g.\n    It was also kind of working because of a special check in freedefer;\n    that check is no longer necessary.\n    \n    This patch changes the special case of releasing the m and g to do the\n    defer cleanup in CgocallBackDone itself.\n    \n    This patch also checks for the special case of a panic through\n    CgocallBackDone. In that special case, we don't want to release the m\n    and g. Since we are returning to C code that was not called by Go\n    code, we know that the panic is not going to be caught and we are\n    going to exit the program. So for that special case we keep the m and\n    g structs so that the rest of the panic code can use them.\n    \n    Reviewed-on: https://go-review.googlesource.com/46530\n\nFrom-SVN: r249611", "tree": {"sha": "19a34329dba9299efacbc2aaa92dce5f1108fe94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19a34329dba9299efacbc2aaa92dce5f1108fe94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1857c636967baea1e29af2e3ed72de7e5be3895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1857c636967baea1e29af2e3ed72de7e5be3895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1857c636967baea1e29af2e3ed72de7e5be3895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1857c636967baea1e29af2e3ed72de7e5be3895/comments", "author": null, "committer": null, "parents": [{"sha": "0f0d0eaae5e0b07dd5a08be93ba0009b1146cf76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0d0eaae5e0b07dd5a08be93ba0009b1146cf76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f0d0eaae5e0b07dd5a08be93ba0009b1146cf76"}], "stats": {"total": 48, "additions": 37, "deletions": 11}, "files": [{"sha": "416a5876da8873af7a64f85cfa489637eea3135d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1857c636967baea1e29af2e3ed72de7e5be3895/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1857c636967baea1e29af2e3ed72de7e5be3895/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f1857c636967baea1e29af2e3ed72de7e5be3895", "patch": "@@ -1,4 +1,4 @@\n-fc0cfdff94ca1099421900f43837ca5a70189cd6\n+0a20181d00d43a423c55f4e772b759fba0619478\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8236eeabf4670e5f218ad1f1450d523fdbe0edae", "filename": "libgo/go/runtime/cgo_gccgo.go", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1857c636967baea1e29af2e3ed72de7e5be3895/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1857c636967baea1e29af2e3ed72de7e5be3895/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go?ref=f1857c636967baea1e29af2e3ed72de7e5be3895", "patch": "@@ -95,9 +95,34 @@ func CgocallBack() {\n // CgocallBackDone prepares to return to C/C++ code that has called\n // into Go code.\n func CgocallBackDone() {\n+\t// If we are the top level Go function called from C/C++, then\n+\t// we need to release the m. But don't release it if we are\n+\t// panicing; since this is the top level, we are going to\n+\t// crash the program, and we need the g and m to print the\n+\t// panic values.\n+\t//\n+\t// Dropping the m is going to clear g. This function is being\n+\t// called as a deferred function, so we will return to\n+\t// deferreturn which will want to clear the _defer field.\n+\t// As soon as we call dropm another thread may call needm and\n+\t// start using g, so we must not tamper with the _defer field\n+\t// after dropm. So clear _defer now.\n+\tgp := getg()\n+\tmp := gp.m\n+\tdrop := false\n+\tif mp.dropextram && mp.ncgo == 0 && gp._panic == nil {\n+\t\td := gp._defer\n+\t\tif d == nil || d.link != nil {\n+\t\t\tthrow(\"unexpected g._defer in CgocallBackDone\")\n+\t\t}\n+\t\tgp._defer = nil\n+\t\tfreedefer(d)\n+\t\tdrop = true\n+\t}\n+\n \tentersyscall(0)\n-\tmp := getg().m\n-\tif mp.dropextram && mp.ncgo == 0 {\n+\n+\tif drop {\n \t\tmp.dropextram = false\n \t\tdropm()\n \t}"}, {"sha": "43d595f667e77a9a612421e45ed83bd376265762", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1857c636967baea1e29af2e3ed72de7e5be3895/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1857c636967baea1e29af2e3ed72de7e5be3895/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=f1857c636967baea1e29af2e3ed72de7e5be3895", "patch": "@@ -143,14 +143,6 @@ func newdefer() *_defer {\n //\n //go:nosplit\n func freedefer(d *_defer) {\n-\t// When C code calls a Go function on a non-Go thread, the\n-\t// deferred call to cgocallBackDone will set g to nil.\n-\t// Don't crash trying to put d on the free list; just let it\n-\t// be garbage collected.\n-\tif getg() == nil {\n-\t\treturn\n-\t}\n-\n \tpp := getg().m.p.ptr()\n \tif len(pp.deferpool) == cap(pp.deferpool) {\n \t\t// Transfer half of local cache to the central cache.\n@@ -201,6 +193,15 @@ func deferreturn(frame *bool) {\n \t\t\tfn(d.arg)\n \t\t}\n \n+\t\t// If we are returning from a Go function called by a\n+\t\t// C function running in a C thread, g may now be nil,\n+\t\t// in which case CgocallBackDone will have cleared _defer.\n+\t\t// In that case some other goroutine may already be using gp.\n+\t\tif getg() == nil {\n+\t\t\t*frame = true\n+\t\t\treturn\n+\t\t}\n+\n \t\tgp._defer = d.link\n \n \t\tfreedefer(d)"}]}